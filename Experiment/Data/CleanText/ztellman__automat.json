{
    "ztellman": "Thanks!  While I have your attention, another question: how do I create a list with a minimum length?  (gen/such-that #(> (count %) 10) (gen/list :foo)) doesn't work, because the generator never grows the list, so it just loops forever.\n. I'm actually in the process of making actions associated with inputs rather than states, this was an oversight in my original implementation.  A new release with these changes (and labeling of actions in the view diagrams) will be forthcoming soon.\n. I've been poking at this a bit while on vacation.  With the new commit, you'll get a visualization that looks like:\n\nCan you confirm this is the desired behavior?\n. Oh, wow.  I'll write up some tests to cover this case, too.  Thanks!\n. I'm sorry that I somehow overlooked this for so long.  I'm just using the svg rendering functionality in dot, so I don't have a lot of control over it.  Out of curiosity (assuming you're still around), what version of graphviz are you using?\n. Okay, this is fixed now.  It's worth noting that I've decided to make a/any actions apply to all matching inputs, not just the ones that aren't explicitly handled.  I think this makes the most sense.\n. Hmm, interesting.  This is because I decided to have all transitions fire the actions associated with the default transition, so that you could do something like (a/or [a/any (a/$ :foo)] [1 (a/$ :bar)]) and have it fire both.  This seems \"correct\" to me, but the minimization isn't taking that into account, so we're getting this behavior.  I think I can fix it, but I may need to have default actions only fire when there's a default transition.\nIf you have opinions on which of these is more intuitive, let me know.\n. I was merging the default actions in the wrong place.  Thanks for isolating this failure, I wasn't thinking about this correctly.\n. Hmm.  Is this representative of the size of automata you're creating?\n. So to be clear, the reproducing case you provided creates an FSM with 724 distinct states.  However, this:\n``` clj\n(def not-url-keyword\n  (->> [:url/host :url/path :url/query :url/part]\n       (map a/not)\n       (apply a/and)))\n(a/or [:get a/any :url/host (a/ not-url-keyword) :url/path :url/part \\r \\e \\p \\o :url/query (a/ not-url-keyword)]\n     [:get a/any :url/host (a/ not-url-keyword) :url/path :url/part \\r \\e \\p \\o :url/part \\s \\e \\a \\r \\c \\h :url/query (a/ not-url-keyword)])\n```\ncreates an FSM with only 19 states.  I think that the library should probably handle hundreds of states a little more gracefully than it does, but I'm not understanding how your use case is creating a need for hundreds of states.  Is this just because there are tons of paths being or'ed together?\n. It's a combination of the number of states and the predicates.  The giant switch statement they create is too large.  I just need to create a second compilation model for large FSMs.\n. Yes, I will be implementing a fallback execution model that can support arbitrary numbers of states.  I can't imagine what you'd need millions of states for, though.\n. looks like it, thanks\n. clj\n(view [1 2 3 (a/* ['a 2 3]) 4])\n. The library can currently generate state transition images.  Can you give an example of a table, just so I have a more concrete understanding of what you'd like?  Broadly, it seems like a fine idea.\n. Can you give me the output of lein deps :tree?  I suspect this is because an earlier version of clj-tuple called its data structure tuple, while now it provides vector and hash-map.\n. Please add [clj-tuple \"0.2.2\"] to your dependencies, which should fix the issue.\n. Thanks, I can see how that would be confusing.\n. This appears to be some sort of cljx issue, I regenerated the documentation from pre-cljx days and pushed it.  Thanks for the report!\n. Hi, the README describes a function in the upcoming 0.2.0 release, not the 0.1.3 release.  Try .. instead of range.\n. No, that's my fault.  I'm going to update the README to give the correct value for 0.1.3\n. If you look in automat.fsm, there are methods that will operate on the object under the :fsm key and give you the transition table you're looking for.  This is true both in 0.1.3 and the latest snapshot.\n. Yeah, this is very explicit in the rhizome readme, but not here.  I'll leave this open until that's resolved.\n. I've talked to @DomKM, who did the original changes, about this.  I think he might get to it when he has time, but if you (or someone else) would like to take the lead I'd be very appreciative.\n. I'm sorry that I can't be more help here, I haven't used CLJS enough to understand what might be going wrong.\n. It was an unspoken assumptions that the reducer functions would only be defined using keywords.  I need to look over the code to see if there's any reason it can't be something else, but I'm pretty sure it's possible with minor changes.  Thanks for the report.\n. This was to allow for regex-style compiled representations, where each code point is an index into an array.  However, I agree that this is confusing, and should be an optional flag, if it continues at all.\n. Thanks, I haven't cleaned up the issues here in a while.\n. The automata advancement doesn't block, I'm not sure how a timeout would fit into the library.  Typically a timeout would be a signal, which may or may not be a valid signal depending on whether the event has already occurred.\n. Closing, as this is out of scope for this library.. Yes, that's what I would suggest.\n. Sorry, I'm not sure what you're asking here.  Can you elaborate?\n. Makes sense, I'll make the requisite changes this weekend.\n. If you'd like to open a pull request, I'm happy to accept your change.\nOn Thu, May 19, 2016 at 1:22 AM Pietro Braione notifications@github.com\nwrote:\n\nI had a look at the code, and I have implemented a fixed version of\ncomplement that seems to work:\n(defn complement-fixed\n  \"Returns the complement of the given automaton.\"\n  x)\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\nhttps://github.com/ztellman/automat/issues/41#issuecomment-220258580\n. I'm sorry, I've fallen behind on all of this.  What do you mean by \"add a state\"?  You can add it to the state->input->state data structure, and it should just work.\n. Sorry, this is just a screw-up in terms of doc uploading (it used to be on gh-pages, now it's on a standalone website), not some weird joke.  I'll fix it without having to delete the link.\n. The documentation links are fixed.  The correct answer to your question is a 301 permanent redirect, but documentation was previously hosted using Github Pages, which doesn't give me the freedom to use HTTP status codes in that way (as far as I know, anyway).  I've moved them to a web server I control, which will hopefully prevent this sort of issue in the future.\n. Done, sorry for the long delay.\n. I'm sorry that it's taken me so long to get to this.  I believe you're suggesting that the value from the signal be used as a (potential?) input to the FSM, which is not really the purpose of a signal.  You could potentially use advance and the intermediate state to determine how to proceed next, but that's not something which needs to be in the core library.. Good catch, thanks.\n. There's not really an easy way to do this right now.  Unwise things with pprint-inputs may be the easiest thing, or you can just copy/paste/adapt the rest of the code to your needs (there's not that much).\n. Thanks!\n. Thanks!. The checkpoint is mostly for internal use, but maybe this example will be a bit more illuminating:\n\n```clj\nuser> (def foo (a/compile \n          (a/or [:d :d]\n                [:d :d :g :h])))\n'user/foo\nuser>  (a/greedy-find foo nil [:d :d :g])\nautomat.compiler.core.CompiledAutomatonState{:accepted? false, :checkpoint #automat.compiler.core.CompiledAutomatonState{:accepted? true, :checkpoint nil, :state-index 2, :start-index 0, :stream-index 2, :value nil}, :state-index 3, :start-index 0, :stream-index 3, :value nil}\nuser>  (a/greedy-find foo *1 [:z])\nautomat.compiler.core.CompiledAutomatonState{:accepted? true, :checkpoint nil, :state-index 2, :start-index 0, :stream-index 2, :value nil}\n```\nAll of your examples were accepted states, so they don't need to have a reference back to the previous accepted state. In this example, we're halfway between one accepted state and maybe a greedier one.  Once we get something other than :h in the last input, it simply returns the checkpointed state.\nThe documentation could certainly be clearly here, but does that make sense?. The :eval backend is significantly faster than the :base backend.  In practice, I'd suggest that you'd want to serialize the non-compiled FSMs, and then compile them locally using :eval.  Is there a reason this wouldn't work for you?. Merged, thanks for the contribution.. Thanks!. I'm also seeing this error, but bit-or isn't used anywhere in the library, so I think it's something else that's causing it. . I'll take care of it today, sorry for the delay.\nOn Wed, Feb 15, 2017 at 9:48 AM Emlyn Corrin notifications@github.com\nwrote:\n\n@ztellman https://github.com/ztellman I was getting FSM compilation\noccasionally hanging, and this seems to fix it. Any ETA on getting this\nmerged (and a new release cut)? Thanks\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/ztellman/automat/pull/61#issuecomment-280084521, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAB6P-kEn8mNxLsJt_rvMFBQbtfD2oR9ks5rczphgaJpZM4LroZW\n.\n. This looks good, but I'm not near a computer right now. I'll cut a release\nlater today, thanks for diving in and figuring out the issue.\nOn Mon, May 8, 2017 at 11:17 AM masztal notifications@github.com wrote:\nAdded necessary epsilon transitions in 'maybe' and 'kleene' functions\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/ztellman/automat/pull/66\nCommit Summary\n\nBug #65 fix\n\nFile Changes\n\nM src/automat/fsm.cljc\n   https://github.com/ztellman/automat/pull/66/files#diff-0 (30)\n\nPatch Links:\n\nhttps://github.com/ztellman/automat/pull/66.patch\nhttps://github.com/ztellman/automat/pull/66.diff\n\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/ztellman/automat/pull/66, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAB6PyrXjrFO1727SOjdns4irQaqvv_Jks5r31wpgaJpZM4NUTrP\n.\n. You might try adding automat to your AOT compilation, or just do :aot :all, which is what I always do.. I'm sorry that I can't be much help here, the whole CLJS ecosystem is a bit of a mystery to me.  I'll call @DomKM to this thread, though, since he's to blame for the CLJS portion of this library.. Great, thank you.  Would you like me to cut a release with this fix?. Sorry for the delay, I've merged the change and cut a new release\nOn Fri, Sep 15, 2017 at 8:28 AM Juan A. Ruz notifications@github.com\nwrote:\nGreat, thanks a lot!\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub\nhttps://github.com/ztellman/automat/pull/69#issuecomment-329815938, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAB6P25RX0KMwslpOtN7_PXLxAUeT1teks5sipeKgaJpZM4PEoa1\n.\n. \n",
    "reiddraper": "\nThanks! While I have your attention, another question: how do I create a list with a minimum length? (gen/such-that #(> (count %) 10) (gen/list :foo)) doesn't work, because the generator never grows the list, so it just loops forever.\n\nThere's a couple different things in play here:\n1. gen/list expects another generator as it's argument, if you wanted a list of just :foos, you'd need to do (gen/list (gen/return :foo)). So let's assume for the rest of this that you're either doing that or just something like gen/int.\n2. There are actually two reasons not to use gen/such-that for this.\n   1. such/that isn't very efficient if the generator is unlikely to meet the predicate. It's better to just write a generator that is either more likely to meet the predicate, or is guaranteed.\n   2. simple-check has a 'size' parameter that is using during testing (as well as in gen/sample). The size is an integer that starts off small (0) and grows to a couple hundred. Generators can depend on this value. The idea is that you want to generate 'smaller' values during the beginning of tests, so that trivial bugs are found quickly and you don't waste time shrinking down values that could have just been generated from the beginning.\ntl;dr:\nI should either add two extra optional arguments to all of the collection generators [... & [min-count max-count]]. Or, in the meantime, you can do something like this yourself. You could just do what gen/list does but add N to num-elements. And just copy-paste for now. Thoughts on adding those extra arguments to simple-check proper?\n. ",
    "neapel": "Yes, that's great!\n. ",
    "DomKM": "It looks like this patch broke char matching.\n``` clojure\n(-> [0 :a]\n    a/compile\n    (a/find nil [0 :a])\n    :accepted?)\n;=> true\n(-> [0 :a \\b]\n    a/compile\n    (a/find nil [0 :a \\b])\n    :accepted?)\n;=> false\n``\n. This is fixed, at least in #16. These tests should probably be added once #16 is merged.\n. I agree. Having all transitions fire the actions that are associated with the default transition seems consistent with how actions behave in other cases. I think a user would be surprised if(a/or [a/any (a/$ :foo)] [1 (a/$ :bar)])did not fire both actions with an input of1`.\n. Yes. I ran into this when attempting to benchmark the FSM branch of Silk against routes extracted from Clojars.\nHere is the code that uncovered this issue:\n``` clojure\n(require '[domkm.silk :as s])\n(s/routes\n [:repo-artifact-file {:request-method :put\n                       :path [\"repo\" :group :artifact (s/& :file \"maven-metadata.xml\")]}]\n [:repo-artifact-version-file {:request-method :put\n                               :path [\"repo\" :group :artifact :version (s/& :filename\n                                                                            (->> [\"pom\" \"jar\" \"sha1\" \"md5\" \"asc\"]\n                                                                                 (map #(s/cat nil \".\" %))\n                                                                                 (apply s/|)))]}]\n [:repo {:request-method :get\n         :path [\"repo\"]}]\n [:repo-search {:request-method :get\n                :path [\"repo\" \"search\"]}]\n [:repo-projects {:request-method :get\n                  :path [\"repo\" \"projects\"]}]\n [:repo-security {:request-method :get\n                  :path [\"repo\" \"security\"]}])\n;=> clojure.lang.Compiler$CompilerException: java.lang.RuntimeException: Method code too large!\n```\nTo explain what this does, let's look at two simple routes:\nclojure\n(s/routes  [:repo {:request-method :get\n                   :path [\"repo\"]}]\n           [:repo-search {:request-method :get\n                          :path [\"repo\" \"search\"]}])\n:repo and :repo-search are route names and do not influence the generated FSM.\nThis creates an Automat FSM that looks roughly like this:\n``` clojure\n(def not-url-keyword\n  (->> [:url/host :url/path :url/query :url/part]\n       (map a/not)\n       (apply a/&)))\n(a/| [:get a/any :url/host (a/ not-url-keyword) :url/path :url/part \\r \\e \\p \\o :url/query (a/ not-url-keyword)]\n     [:get a/any :url/host (a/ not-url-keyword) :url/path :url/part \\r \\e \\p \\o :url/part \\s \\e \\a \\r \\c \\h :url/query (a/ not-url-keyword)])\n```\nIn terms of understanding the example above that causes the exception, nil and keywords (except in the request-method or scheme) are roughly like (a/* not-url-keyword) and (a/interpose-$ (java.util.UUID/randomUUID) (a/+ not-url-keyword)) respectively.\n. I'm not sure that the quantity of states is the culprit.\n``` clojure\n(def route-tuples\n  [[:repo-artifact-file {:request-method :put\n                         :path [\"repo\" :group :artifact (& :file \"maven-metadata.xml\")]}]\n   [:repo-artifact-version-file {:request-method :put\n                                 :path [\"repo\" :group :artifact :version (& :filename\n                                                                            (->> [\"pom\" \"jar\" \"sha1\" \"md5\" \"asc\"]\n                                                                                 (map #(cat nil \".\" %))\n                                                                                 (apply |)))]}]\n   [:repo {:request-method :get\n           :path [\"repo\"]}]\n   [:repo-search {:request-method :get\n                  :path [\"repo\" \"search\"]}]\n   [:repo-projects {:request-method :get\n                    :path [\"repo\" \"projects\"]}]\n   [:repo-security {:request-method :get\n                    :path [\"repo\" \"security\"]}]])\n(defn count-states [& rtes]\n  (->> rtes\n       (apply routes)\n       :compiled-automaton\n       :automaton\n       :automaton ; long story\n       automat.fsm/states\n       count))\n; this is how many states each route has individually\n(map count-states route-tuples)\n;=> (37 35 12 19 21 21)\n; a union of all routes except for the last one has only 81 states\n(apply count-states (butlast route-tuples))\n;=> 81\n; it errors with one additional route\n(apply count-states route-tuples)\n;=> clojure.lang.Compiler$CompilerException: java.lang.RuntimeException: Method code too large!\n```\nIs it possible that this issue is not solely about the number of states? What can I do to help diagnose it?\n. Also, I forgot to say, this issue occurs during compilation. Uncompiled automata can be created without issue.\nI modified my code to not automatically compile routes and found that the automaton above that cannot be compiled has 88 states.\n. This is fixed. Closing.\n. You added this feature in fc98ad4f98da0b011b56cf14d020fdbbd68026c7. This issue can be closed.\n. This is fixed in master.\n. (-> compiled-fsm meta :fsm) should return the state transition table that you are looking for. You can also generate that from a raw FSM using automat.core/precompile.\n. The argument to $ is not an input, it is a tag for an action. You use this tag as a key in a map of reducer functions passed to compile. An FSM like [1 (a/$ :begin) 2 3 4 (a/$ :end)], where the alphabet is not keywords, works fine.\n. @jjl In what way is it broken? Do you get an error?\n. @jjl I'd suggest reverting ClojureScript to the previous version to see if the tests are failing due to your CLJC conversion or due to ClojureScript compiler changes.\nLeaving this link so I can find it again:\nhttps://github.com/ztellman/automat/compare/master...jjl:cljc\n. Is your code on github up-to-date? That error looks like you forgot the :clj or :cljs in a reader conditional but I don't see it missing.\n. ",
    "naipmoro": "Hi! Thanks for replying. I'm using graphviz version 2.26.3, which is the most recent one provided by ubuntu 12.04's package manager.\n. ",
    "dignati": "I just stumbled upon this thread and was wondering if there are any plans to eventually support a much higher number of states, probably in the millions?\n. @ztellman You can implement spellcheckers with huge automatons. See this paper for example.\n. ",
    "DjebbZ": "These wikipedia pages have good examples : https://en.wikipedia.org/wiki/Finite-state_machine, https://en.wikipedia.org/wiki/State_transition_table\n. ",
    "aaronbush": "Here is the output:\n```\nPossibly confusing dependencies found:\n[automat \"0.1.3\"] -> [primitive-math \"0.1.3\"]\n overrides\n[aleph \"0.4.0\"] -> [byte-streams \"0.2.0\"] -> [primitive-math \"0.1.4\"]\nConsider using these exclusions:\n[aleph \"0.4.0\" :exclusions [primitive-math]]\n[automat \"0.1.3\"] -> [potemkin \"0.3.4\"]\n overrides\n[aleph \"0.4.0\"] -> [potemkin \"0.3.13\"]\nConsider using these exclusions:\n[aleph \"0.4.0\" :exclusions [potemkin]]\n[automat \"0.1.3\"] -> [riddley \"0.1.7\"]\n overrides\n[aleph \"0.4.0\"] -> [byte-streams \"0.2.0\"] -> [manifold \"0.1.0\"] -> [riddley \"0.1.9\"]\n and\n[aleph \"0.4.0\"] -> [manifold \"0.1.0\"] -> [riddley \"0.1.9\"]\nConsider using these exclusions:\n[aleph \"0.4.0\" :exclusions [riddley]]\n[aleph \"0.4.0\" :exclusions [riddley]]\n[automat \"0.1.3\"] -> [potemkin \"0.3.4\"] -> [clj-tuple \"0.1.2\"]\n overrides\n[aleph \"0.4.0\"] -> [potemkin \"0.3.13\"] -> [clj-tuple \"0.2.1\"]\n and\n[aleph \"0.4.0\"] -> [byte-streams \"0.2.0\"] -> [clj-tuple \"0.2.1\"]\nConsider using these exclusions:\n[aleph \"0.4.0\" :exclusions [clj-tuple]]\n[aleph \"0.4.0\" :exclusions [clj-tuple]]\nwarn\n [aleph \"0.4.0\"]\n   [byte-streams \"0.2.0\"]\n   [io.aleph/dirigiste \"0.1.0\"]\n   [io.netty/netty-all \"4.1.0.Beta4\"]\n   [manifold \"0.1.0\"]\n   [org.clojure/tools.logging \"0.3.1\"]\n [automat \"0.1.3\"]\n   [potemkin \"0.3.4\"]\n     [clj-tuple \"0.1.2\"]\n   [primitive-math \"0.1.3\"]\n   [proteus \"0.1.4\"]\n   [rhizome \"0.2.1\"]\n   [riddley \"0.1.7\"]\n [clojure-complete \"0.2.3\" :scope \"test\" :exclusions [[org.clojure/clojure]]]\n [org.clojure/clojure \"1.6.0\"]\n [org.clojure/tools.nrepl \"0.2.6\" :scope \"test\" :exclusions [[org.clojure/clojure]]]\n```\nI switched the order of the dependencies to have aleph before automat and that cleared most of the above warnings and resolved the issue with vector not being found.\n. ",
    "dvberkel": "If have not updated the corresponding image yet. If this is something that you are interested in I could change the image as well.\n. I just realized that the image does not need to be changed at all. The label on the transition is the action to be performed. Sorry for my misunderstanding \n. :+1: \n. ",
    "Engelberg": "FYI, I'm still only seeing the viz namespace docs at http://ideolalia.com/automat/\n. ",
    "dsapoetra": "Thank you! I'm sorry because the README still writes 0.1.3 version.\n. ",
    "timvisher": "@DomKM I had never thought to check the meta! That's awesome.\nSadly, it doesn't seem to work like I described above?\n``` clojure\nuser=> (-> (a/compile [1 (a/ [2 3]) 4]) meta clojure.pprint/pprint)\n{:fsm #,\n :state->index\n {# 3,\n  # 2,\n  # 1,\n  # 0}}\nnil\nuser=> (-> (a/compile [1 (a/ [2 3]) 4]) meta :fsm)\n\n``\n. @DomKM Worth noting also that I'm on the latest release (0.1.3) not the latest snapshot or alpha.automat.compiler.coredoesn't seem to exist in that version?\n. @ztellman Ah! Perfect. I can see, I think, thatfsmcontains functionality that would allow me to do this, and I hadn't noticed that the:fsm` key is operable on by that ns.\nThat said, I've been trying to piece together how to do this based on the code there and I'm coming up short. If you'll permit me to be a little lazy, what I have in hand is the previous input (say, 2) and the proposed-input (say, 4). This seems natural at least to me as serializing the state of the fsm to the db or something wouldn't be very meaningful to a human (although I suppose you could do both).\nHow can I take 2 and 4 and determine that it's not valid? I'm assuming that generally speaking there's no way to go from input -> state given that one input might lead to many states so there'd be no way given the previous input to get to the current state to then determine if the proposed input is valid or not. I feel like I'm fundamentally missing something about how fsms work. :)\nI did figure out this sort of thing but I don't think this gets me very far. In this instance I get the internal state for a given input, but I'm not sure then how to turn that around and get the permissible? functionality given that it doesn't appear to work to pass it back into advance:\n``` clojure\nuser=> (clojure.pprint/pprint (reduce into {} (map (partial fsm/input->state (-> charnock meta :fsm)) (fsm/states (-> charnock meta :fsm)))))\n{3 #,\n 1 #,\n 2 #,\n 4 #}\nnil\nuser=> (a/advance charnock (get (reduce into {} (map (partial fsm/input->state (-> charnock meta :fsm)) (fsm/states (-> charnock meta :fsm)))) 1) 2)\nIllegalArgumentException could not process input 2  automat.core/advance (core.clj:396)\n```\nIf you're able and willing to help despite my rambling, I'd greatly appreciate it!\n. This will mean that automat is >= clojure 1.7 if this is adopted.\n. ",
    "martinklepsch": "Hey @timvisher, just stumbled upon this while looking for a solution myself. I came up with the following:\nclojure\n(defn possible-transitions [compiled-fsm state]\n  (let [alphabet (f/alphabet (:fsm (meta compiled-fsm)))]\n    (set (filter (fn [t] (a/advance compiled-fsm state t nil)) alphabet))))\nThis obviously isn't ideal computation-wise but I haven't been able to find the right knobs inside the library to give me the same result. For my use case it's ok. \n@ztellman If there's a way to achieve this without brute-force as above an addition to the Readme would be a great :)\n. I just noticed that the above snippet does trigger actions which makes it potentially un-pure making it more or less useless. Anybody came up with a better approach in the meantime that is side-effect free?\n. My new approach looks like this:\n`` clojure\n(defn dry-run-wrap\n  \"Wrapaction-fnso that it only callsaction-fnif the FSM's state\n   does not contain a truthy value under::dry-run`.\"\n  [action-fn]\n  (fn [state input]\n    (if (::dry-run state)\n      state\n      (action-fn state input))))\n(defn possible-transitions [compiled-fsm state]\n  (let [alphabet (f/alphabet (:fsm (meta compiled-fsm)))\n        dry-run  (assoc state ::dry-run true)]\n    ;; SIGNAL using [t] here means we assume the FSMs signal function is first\n    (set (filter (fn [t] (a/advance compiled-fsm dry-run [t] false)) alphabet))))\n```\nI'm using dry-run-wrap to wrap action functions so that they are effectively no-ops if the ::dry-run key contains a truthy value.\n. ",
    "osfameron": "Agree that a way to check what the output states are would be a useful addition to the library, for various introspection abilities and tweaks.  (Presumably the viz view function uses some kind of similar hook, but I don't understand the code base well enough to see quite how.). It looks like the link is now pointing to http://aleph.io/codox/automat/ for Automat 0.2.0.  These docs are still rather sketchy (in terms of e.g. the inputs and outputs of the functions) but I think the original issue is fixed!. Looks like this is fixed in 0aaad0d67c34b9d4144181ce0b625e82584f1e83. Aha, yes, thanks for the reply!  I think that's clear, so basically my misunderstandings were:\n\nthe checkpoint is not created for accepted? states\nif created, the checkpoint would contain another state value\n\nIn any case, as it turns out those semantics aren't useful to my use-case*, I suspect I need to roll something up with direct use of (a/advance) instead, so I'll play with that :-)\n(* for example, I was musing on a key-binding parser.  If the user types \"dd\", should we process the :first action, or wait a little longer to see if they go on to type a \"g\"?). ",
    "achengs": "Update: It now says \"no such thing\"\n. Ok, please consider 8279da3 for this PR. \n(Note: the earlier de4c1a0 passed in Travis CI despite having ClassNotFoundExceptions!)\n. ",
    "eraserhd": "This is Clojure, not ClojureScript (it does seem like a JavaScript coersion, doesn't it?).\n. Just discovered that this works in 0.2.0-alpha2.\n. ",
    "hiredman": "oh, thanks, suddenly the diagrams with the tag make a lot more sense\n. ",
    "jjl": "Okay, I've done the bulk of the work and tests pass in clojure, but clojurescript is broken and I can't figure out why.\nCheck out my code on my fork jjl/automat , the 'cljc' branch.\n. ``````\ncustard-tart% lein clean-test\nCompiling 2 source files to /Users/jjl/code/automat/target/classes\nwarning: [options] bootstrap class path not set in conjunction with -source 1.5\nwarning: [options] source value 1.5 is obsolete and will be removed in a future release\nwarning: [options] target value 1.5 is obsolete and will be removed in a future release\nwarning: [options] To suppress warnings about obsolete options, use -Xlint:-options.\n4 warnings\nlein test automat.core-simple-check\nlein test automat.fsm-simple-check\n{:result true, :num-tests 100, :seed 1454203566359, :test-var check-closed-over-operations}\nRan 1 tests containing 1 assertions.\n0 failures, 0 errors.\nCompiling ClojureScript.\nCompiling \"target/test.js\" from [\"src\" \"test\"]...\nCompiling \"target/test.js\" failed.\nException in thread \"main\" java.lang.AbstractMethodError: Method cljsbuild/compiler/SourcePaths.find_sources(Ljava/lang/Object;)Ljava/lang/Object; is abstract, compiling:(/private/var/folders/k6/glc05svd5d194k8kgqfwkrph0000gn/T/form-init382463497803898384.clj:1:124)\n    at clojure.lang.Compiler.load(Compiler.java:7239)\n    at clojure.lang.Compiler.loadFile(Compiler.java:7165)\n    at clojure.main$load_script.invoke(main.clj:275)\n    at clojure.main$init_opt.invoke(main.clj:280)\n    at clojure.main$initialize.invoke(main.clj:308)\n    at clojure.main$null_opt.invoke(main.clj:343)\n    at clojure.main$main.doInvoke(main.clj:421)\n    at clojure.lang.RestFn.invoke(RestFn.java:421)\n    at clojure.lang.Var.invoke(Var.java:383)\n    at clojure.lang.AFn.applyToHelper(AFn.java:156)\n    at clojure.lang.Var.applyTo(Var.java:700)\n    at clojure.main.main(main.java:37)\nCaused by: java.lang.AbstractMethodError: Method cljsbuild/compiler/SourcePaths._find_sources(Ljava/lang/Object;)Ljava/lang/Object; is abstract\n    at cljsbuild.compiler.SourcePaths._find_sources(compiler.clj)\n    at cljs.closure$build$fn__5570.invoke(closure.clj:1862)\n    at clojure.lang.Atom.swap(Atom.java:37)\n    at clojure.core$swap_BANG.invoke(core.clj:2238)\n    at cljs.closure$build.invoke(closure.clj:1856)\n    at cljs.closure$build.invoke(closure.clj:1840)\n    at cljsbuild.compiler$compile_cljs$fn__5674.invoke(compiler.clj:81)\n    at cljsbuild.compiler$compile_cljs.invoke(compiler.clj:80)\n    at cljsbuild.compiler$run_compiler.invoke(compiler.clj:179)\n    at user$eval5806$iter__5824__5828$fn__5829$fn__5841.invoke(form-init382463497803898384.clj:1)\n    at user$eval5806$iter__5824__5828$fn__5829.invoke(form-init382463497803898384.clj:1)\n    at clojure.lang.LazySeq.sval(LazySeq.java:40)\n    at clojure.lang.LazySeq.seq(LazySeq.java:49)\n    at clojure.lang.RT.seq(RT.java:507)\n    at clojure.core$seq__4128.invoke(core.clj:137)\n    at clojure.core$dorun.invoke(core.clj:3009)\n    at clojure.core$doall.invoke(core.clj:3025)\n    at user$eval5806.invoke(form-init382463497803898384.clj:1)\n    at clojure.lang.Compiler.eval(Compiler.java:6782)\n    at clojure.lang.Compiler.eval(Compiler.java:6772)\n    at clojure.lang.Compiler.load(Compiler.java:7227)\n    ... 11 more\nSubprocess failed```\n``````\n. Reported bug upstream http://dev.clojure.org/jira/browse/CLJS-1554\n. Okay, that was related to an outdated lein-cljsbuild, doh!.\nNew odd error: \"Feature should be a keyword: (defprotocol InputStream (nextInput [_ eof])) {:type :reader-exception, :line 69, :column 38, :file \"/Users/jjl/code/automat/src/automat/stream.cljc\"\"\n. @domkm yes the code on github is up to date. i\u2019ve played with it locally, but as you say, the code looks fine. I gave up after about 15 minutes of poring over the same couple of lines :)\n. ",
    "cemerick": "clojure\npdf.ql.text> (a/advance (a/compile [\\A]) nil \\A)\n{:accepted? true, :checkpoint nil, :state-index 1, :start-index 0, :stream-index 1, :value nil}\nThe char FSM no longer accepts the int input, which is good.\nThe seq impl of to-stream has a separate issue that I might raise later, but I think this can be closed (same goes for #30).\n. pprint-inputs was enough, thanks. :-)\nFeel free to close this if you don't want it clogging up your issue tracker.\n. I have the same problem. Investigating now. @tangrammer if you have any further information since your last post, please let us know. \ud83d\ude04 . The result of my proposed fix #69 is available here, if anyone wants to test it themselves in an AOT project that also uses CLJS:\n[org.clojars.cemerick/automat \"0.2.3-SNAPSHOT\"]. Ah, sure, that'd be great. I have an artifact up for people to test, but it's really a pretty straightforward change. (Though I have some theories, why the change is needed is a complete mystery to me.). FYI, I believe the first release where this became a problem is CLJS 1.9.671. The prior approach was fine with AOT for earlier releases; the suggested change should be good for approximately any 1.9.x release.. Hold up on a release. This doesn't play nicely with CLJS advanced optimizations.. #70 resolves the problem entirely, just needs merging. Been using the result of that for a couple of weeks now with good results.. A build including this made my entire pipeline happy. Sorry again for the misfire earlier.. The project.clj here uses 1.9.473; I'm effectively using CLJS master + a couple of patches.\nWhat problem are you running into?. ",
    "juskrey": "Yes, this should happen sooner or later. cljx is deprecated.\n. ",
    "happy-lisper": "optimally, timeout supports would be in the library though\n. I realize that an automata advancement does not block, and of course timers would be managed outside of the library. However, in my case, I deal with different timeouts for different states and have a need to somehow create those timers, e.g. using overtone/at-at and manage them depending on states. Also, in case the timer does not trigger, I need to be able to cancel it. In some cases I might need to set two timers causing different signals, one longer for entire operation, another shorter for some sub-state. In another words, I need to tell what state I am in, and in that sense I would need a support from the library. I initially though to use reducer functions, but now see it will not work.\n. since automat.core.CompiledAutomatonState is a defrecord seems that (into {} x)  would work.\n. That was my attempt to create a self-transition for timeout case. However, it was a result partially ill-thinking of mine as well as confusion from README.md where (fn [state input] _) in an example reducer suggested that we know the state. But it is more like (fn [value input] _).\n. ",
    "huahaiy": "Try this: https://github.com/ztellman/automat/pull/35\nIt seems to work\n. Apparently, calling (fsm/reset-generation) between calls solve the problem. \n. There are still infinite loop issues with certain construction. For example, the following still leads to infinite loop:\nClojure\n(dotimes [i 10]\n  (println i)\n  (apply a/or [[1 2 4 (a/or 5 6 7 8)] [1 (a/or 5 6 7 8) 10]])\n  (fsm/reset-generations))\nNamely, if we or together automatons containing identical nested or of more than 3 items, an infinite loop appears.\n. This is now fixed. Thanks.. ",
    "vitalyper": "As @huahaiy suggested automat was ported to support clojure 1.7 and 1.8. \nPlease use below in your project.clj\n[org.clojars.semperos/automat \"0.2.0-alpha3\"]\n. ",
    "pietrobraione": "I had a look at the code, and I have implemented a fixed version of complement that seems to work:\n(defn complement-fixed\n  \"Returns the complement of the given automaton.\"\n  [x]\n  (let [fsm (->dfa (automat.compiler.core/parse-automata x))\n        st (state)]\n  (dfa\n    (start fsm)\n    (set/union #{st} (set/difference (states fsm) (accept fsm)))\n    (merge (zipmap* (states fsm) \n                    #(let [tr (fsm/input->state fsm %)] (if (contains? tr fsm/default) tr (merge tr {fsm/default st})))) \n           {st {default st}})\n    (zipmap* (states fsm) #(input->actions fsm %)))))\n. I will - but I need a little more time to test everything.\nCheers\nPietro\n. I have a question: What is the right way to add a state to an automaton?\n. Nevermind, I also fell behind as you can notice. My question was: What is the right way to create a new State object and add it to the states of an automaton? Let us say that I have some-automaton and I want to build another automaton that is some-automaton plus one additional acceptance state. Currently I do something like that:\n(let [new-state (fsm/->State nil (Object.) {} nil)]\n    (fsm/dfa\n        (fsm/start some-automaton)\n        (set/union #{new-state} (fsm/accept some-automaton))\n        ... ;rest omitted\n    )\n)\nIs my definition of new-state the right way of creating a new state?\n. ",
    "LispyAriaro": "Alright, sir. Thanks so much. \nThis kind of issue is something that has bothered me about the web as it is today. Several times you stumble on a link on the web that could really help you only to find out that the page no longer exists or it has outdated information. The authors may never know because they've moved on to other things and besides he/she can't go all pages on the internet where their link has been used in case it needs to be updated to a new link(so that the content the old link pointed isn't deleted). \nI don't know how to fix this problem. I think about the problem a bit but forget to pursue it partly because of daily events. Wondering what you think about this. \n. ",
    "magnetophon": "Thanks!\n. ",
    "jraines": "seems fixed now, maybe a redirect was messed up, idk. ",
    "erikthorselius": "It looks like Swing works. I could run code like \nScript\n(import 'javax.swing.JFrame)\n(def frame (JFrame. \"Hello Frame\"))\n(.setSize frame 200 200)\n(.setVisible frame true)\nThe stack trace is really short, hard to know what file it can't find. \nNo one else with this problem?. Found the problem! I needed to install graphviz! I tried the other clojure fsm project (reduce-fsm) and when I tried there example I got the error code \"The dot executable from graphviz was not found on the path, unable to draw fsm diagrams\nDownload a copy from http://www.graphviz.org/\". Maybe the same information would be good in this project?. ",
    "emlyn": "It's simpler to do the compilation once and serialize that, but if it's at a significant cost to performance I can also do it on the executors. I just have to memoize the compilation to avoid recompiling for every task the executor runs. In that case I'd just need the first of the two commits in this PR.. I've made the change to compile the FSM on the executors (with memoisation), and that seems to work fine. So I've removed the unneeded commit from this PR, and left just the one making uncompiled FSMs serializable. Would you be willing to merge this?. @ztellman I was getting FSM compilation occasionally hanging, and this seems to fix it. Any ETA on getting this merged (and a new release cut)? Thanks. ",
    "masztal": "Great. Please have a look at the state->input->actions map in these functions. I'm not sure if it should be also modified or not.. ",
    "tangrammer": "Hi Zach \nAdding :aot :all didn't fix the error yet so I was investigating a bit trying to isolate the problem so maybe could be more fixable now\nI uploaded a minimal project here  https://github.com/tangrammer/automat-issue\nIt has 3 branchs trying to be easier to test every odd isolated case \n\n\nsimple working case: origin/master branch commit\nmain namespace works fine when i execute lein clean && lein uberjar && java -jar target/issue-0.1.0-SNAPSHOT-standalone.jar\n\n\nsimple failing one: origin/fails-00 branch commit \nI only add one dep [com.cemerick/url \"0.1.1\"] and execute again  lein clean && lein uberjar && java -jar target/issue-0.1.0-SNAPSHOT-standalone.jar\n\n\ncomenting (:require [automat.core :as a]) fix the problem origin/now-works branch commit\nRemoving/comenting the automat namespace required fix the problem\n(Following this odd trick i don't know how to use the lib in other namespaces )\n\n\nThanks a lot again!\n. Searching for this problem in the context of clojurescript i found this discussion that links to this  CLJ-1591 \nSymbol not being bound in namespace when name clashes with clojure.core\n\nBTW: error happens with other deps like [bidi \"1.21.0\"] or [selmer \"0.9.4\"] or [cljs-react-material-ui \"0.2.37\"]\nIncluding error got when compiling issue.hola.clj\n```\nCompilerException java.lang.ExceptionInInitializerError, compiling:(/Users/tangrammer/git/ride-on/issue/src/issue/hola.clj:2:1)\n    clojure.lang.Compiler.load (Compiler.java:7391)\n    issue.core/eval10716 (form-init1581929879224297307.clj:1)\n    issue.core/eval10716 (form-init1581929879224297307.clj:1)\n    clojure.lang.Compiler.eval (Compiler.java:6927)\n    clojure.lang.Compiler.eval (Compiler.java:6890)\n    clojure.core/eval (core.clj:3105)\n    clojure.core/eval (core.clj:3101)\n    clojure.main/repl/read-eval-print--7408/fn--7411 (main.clj:240)\n    clojure.main/repl/read-eval-print--7408 (main.clj:240)\n    clojure.main/repl/fn--7417 (main.clj:258)\n    clojure.main/repl (main.clj:258)\n    clojure.main/repl (main.clj:174)\nCaused by:\nExceptionInInitializerError \n    java.lang.Class.forName0 (Class.java:-2)\n    java.lang.Class.forName (Class.java:344)\n    clojure.lang.RT.classForName (RT.java:2168)\n    clojure.lang.RT.classForName (RT.java:2177)\n    clojure.lang.RT.loadClassForName (RT.java:2196)\n    clojure.lang.RT.load (RT.java:443)\n    clojure.lang.RT.load (RT.java:419)\n    clojure.core/load/fn--5677 (core.clj:5893)\n    clojure.core/load (core.clj:5892)\n    clojure.core/load (core.clj:5876)\n    clojure.core/load-one (core.clj:5697)\n    clojure.core/load-one (core.clj:5692)\nCaused by:\nClassCastException clojure.lang.Var$Unbound cannot be cast to clojure.lang.MultiFn\n    automat.fsm__init.load (:841)\n    automat.fsm__init. (:-1)\n    java.lang.Class.forName0 (Class.java:-2)\n    java.lang.Class.forName (Class.java:344)\n``\n. @deprecated comment ... just realised that bidi[bidi \"1.21.0\"]uses[com.cemerick/url \"0.1.1\"]` that i previously noted that is a dep failing one\n@ztellman maybe this info could help too \nbidi 2.1.1 => works\nclojure\n :dependencies [[org.clojure/clojure \"1.8.0\"]\n                 [automat \"0.2.2\"]\n                 [bidi \"2.1.1\"]]\nbidi 1.21.0 fails\nclojure\n  :dependencies [[org.clojure/clojure \"1.8.0\"]\n                 [automat \"0.2.2\"]\n                 [bidi \"1.21.0\"]]\nhttps://github.com/juxt/bidi/blob/1.21.0/project.clj\nreally sorry for the noise but i'm really in trouble deploying prod app :()\nIf anyone could point me any reasons to start with solving this issue i'll really appreciate it\nThanks again\n. Hi again, \nlooking at deps and nested deps I realised that clojurescript was always present in problematic libs .  I' tried to avoid the problem adding org.clojure/clojurescript to exclusions and surprisingly it fixed the problem \n:exclusions [org.clojure/clojurescript]\nI also had to remove clojurescript from :dependencies vector :!\nFeel free to close the issue if you think the error doesn't relate to automat\nthanks and sorry for so much noise!\n. I've moved this problem to https://github.com/ztellman/automat/issues/68. I've checked that the problem arises when a namespace that contains references to automat classes is included in AOT directly or indirectly ...\nPlease, could anyone point me where the root of this issue lives so i could ask in the proper place?\nthanks in advance. Hi @cemerick sorry but I don't have more information around this issue. \nHope you have more tools to try to fix it!\n. Hi there :) \nany progress related with the advanced optimizations ... @cemerick  maybe you want to extend here the details of your current path?. Great, thanks a lot!. @cemerick could you add details about which version of cljs is supported?\nI'm trying [org.clojure/clojurescript \"1.9.562\"] with no success  :(\n[edited ] I forgot to update the lib versi\u00f3n! . ups sorry \nI forgot to update automat !!!\n. working fine! thanks @cemerick !!!. ",
    "SevereOverfl0w": "Corrected some of my math which made automata look slower than it should.. "
}