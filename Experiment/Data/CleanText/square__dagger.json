{
    "swankjesse": "I'm going to send another pull request that retains history.\n. pforhan: yep. This is a step towards that goal.\n. Going forward, could you flatten pull requests into a single commit? It requires 'commit --amend' and 'push -f', but it means the history of 'master' omits a bunch of intermediate changes.\n. I'm really picky about style. I suspect you're getting used to that.\n. On flattening. . . my regular workflow is to use one-commit-per-pull-request in regular changes. That means there's one entry in the git history, and no invisible intermediate state.\nOtherwise you could send a chain of commits that adds an embarrassing picture of me, and then deletes it, and I'd be none the wiser.\n. Hmm.... it has been my (non-obvious) intention to keep the example very minimal. I wasn't intending for it to exercise all of ObjectGraph's features; rather it was supposed to show you what it looks like in a real app.\nPerhaps it would be better to remove this from the example app and add it to the one-page project readme? That guide shows some hypothetical changes to the example app to demonstrate features of interest.\n. Nice doc, but of course I have lots of nitpicky comments!\n. Keep the backwards compatibility & flatten the change. Once it's in we can follow up on our side.\nSince backwards compatibility is opaque and awkward we should try to get to the point where Square's in a branch and you don't need to worry about us when you make changes.\n. Ugh, fixed. Good catch.\n. Looking...\n. Tons of nitpick comments as usual. But the change is very very good. If I knew it was going to be this awesome I would have done this 2 days ago!\nSorry for the slow response, I'm swamped with Starbucks stuff at my day job.\n. Fix the nitpicky test issue, flatten, and I'll merge!\n. Do let me know before you change the way scoping works! It's important to get that right and difficult to mix properly with the generated code.\n. Awesome. Thanks for also doing the CLA.\n. @cgruber yeah, definitely looking forward to build-based tests.\n. I get the impression that annotation processing is broken for multiple compile-invocations in the same process. Probably a bug, but it might get in the way of @tbroyer's otherwise-awesome proposal.\n(We were getting crashes in our ant builds when we started to use annotation processing. Configuring the compiler to run in another process fixed the issue.)\n. Looks good! Thanks again.\n. I replied privately.\n. @buildhive's complaining about a transient javac bug:\njava.lang.IncompatibleClassChangeError: dagger.InjectionTest and dagger.InjectionTest$1Parameterized disagree on InnerClasses attribute\n    at java.lang.Class.getDeclaringClass(Native Method)\n    at sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.(ParameterizedTypeImpl.java:34)\n    at sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.make(ParameterizedTypeImpl.java:77)\n    at sun.reflect.generics.factory.CoreReflectionFactory.makeParameterizedType(CoreReflectionFactory.java:86)\n    at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:122)\n    at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:31)\n    at sun.reflect.generics.repository.FieldRepository.getGenericType(FieldRepository.java:67)\n    at java.lang.reflect.Field.getGenericType(Field.java:223)\n. @JakeWharton\n. Known problem. Pull requests welcome!\n. I'm looking forward to integration tests for generated code. I don't think it's worth the hassle to unit test the exact formatting of individual files; for the most part it's just an implementation detail.\n. Yeah, I think it's the right tradeoff. I don't expect many users to call ObjectGraph.validate(), so I'm not too worried about CPU performance there. But I do expect large applications to have a lot of bindings, and I don't want those apps to have to pay for a feature that they aren't using.\n. Yeah, definite compile-time validation. This code is shared by compile-time and runtime.\n. Yeah, this is a strict circular dependency check.\n. I think you're right about renaming stuff in ObjectGraph. We'll figure out the right names in a follow-up.\n. I don't feel too strongly about where this code goes or whether it's on by default.\nI suspect people won't go through the effort to run this tool if doing so is a lot of work. I'd like to keep it on for our own apps for a while to see how we use it, and then in two months or so make a decision about what to do with it in the longer term. If we don't use it anyway, it shouldn't clutter up the core.\nI'm also tempted to split off all of the codegen stuff since it's only needed at build time.\n. We've already split out the core abstractions! It's called javax.inject. We just need to promote @Provides, MembersInjector and Lazy to that project when we're convinced they're ready.\n. @cgruber some of our tests have a test runner that injects the test case:\n@Override public void beforeTest(Method method) {\n  makeObjectGraph().inject(this);\n}\nThis is especially useful for integration testing.\nUnfortunately we use the same test runner for several tests, and sometimes the injected test doesn't have any @Inject annotated fields. We need to avoid crashing in that case.\n. Yeah, the inject() call is a no-op. For us it's come up in several places, mostly in framework code that blindly injects an instance of an abstract type like TestCase or Activity.\nSince the offending type still needs to be explicitly registered as an injection point, it's hard to be surprised by this.\n. Awesome. I'd love it if you could add a quick README.md in it/ that explains what these are and how they're run.\n. Neither get() nor injectMembers() should ever be invoked, so I think that this behavior is fine.\n. I've gone through the code, and it stresses me out a bit. Dagger ceases to exist if it loses its simplicity. I think you're trying to solve a problem where the runtime dagger jar includes some code that isn't needed at runtime. That is perhaps a problem worth solving eventually, but it isn't hurting anything as far as I can tell. And now the dagger deployment strategy is slightly less simple.\nThat said, now that I've seen the code I think it's pointing us in a good direction. Being able to run in a mode where the reflective path is completely absent is something that might help GWT, and this moves us slightly in that direction.\nThe previous code sliced up codegen vs. reflection by features: static injection, module adapters, at inject adapters. The new code slices those up again for codegen / non codegen, so now we have a 3 x 2 matrix. Plus lots of glue to pick which part of the matrix we're in. I think this is not simple enough.\nCan you try to change the code so that we have one class that does all features for reflection, and another that does all things codegen? I think that'll probably end up being a better structure than the feature split we have today. Then there's just two backends, and each backend is a single class. Right now you could fuck up the wiring and end up with a reflective static injector and a non-reflective module adapter. Which would be weird and bad.\nThanks for this change, you're pushing faster than I'm necessarily ready for. That's probably a good thing for our users!\n. Sounds good. I think one thing that makes this change larger than it needs to be is moving ObjectGraph.get(). I like to keep pure-refactor changes separate from behavior / API changes!\n. Multiple commits pays off!\n. This change is brilliant. Very nice work. Fix all my OCD nitpicks, squash it, and I'll merge it.\n. LGTM\n. @cgruber I don't think it's a problem. You can create the exact same problem with Guice, where @Singleton is scoped to the injector rather than to the application. With child injectors, it's scoped to the child injector! This is not a departure from JSR-330, which expects this.\n. I think @Singleton is the right name. The difficult part is putting the singletons in the graph whose lifetime to match your expectations!\n. Just a few more nitpicks. Fix 'em, squash and I'll merge.\nNice work dude.\n. Don't forget the CLA:\nhttps://github.com/square/dagger/blob/master/CONTRIBUTING.md\n. Found it & fixed it. https://github.com/square/dagger/pull/84\n. Really fixed this with https://github.com/square/dagger/pull/102.\nWe didn't catch this in our own apps 'cause we accidentally disabled dagger-compiler when that code was split from the main module. We're running it now. That explains why I didn't see it.\nThanks!\n. @cgruber\n. Yeah, I'd never intended to change behavior. But you start pulling at a seam and pretty soon there's a behavior change. I'm happy to split it up if you prefer, but I think we can skip it.\n. Yeah, this comes from a relative lack of concurrency support in dagger. Our fix will be to add a few carefully placed 'synchronized' tags in ObjectGraph.\n. Fixed by @kryali and myself. https://github.com/square/dagger/pull/82/\n. This isn't the right fix. We need to make the entire link step concurrent.\n. I was surprised that the requiredBy field needed @Nullable. It's too bad the nullness assertions are necessary. The @OneOf annotation implies that providesKey is non-null, but expressing this requires some ceremony with this framework. Similarly for the uses of LruCache.\n. @cgruber \n. Yep. We're also vulnerable, you can pass any object to ObjectGraph.inject() and we can fail at runtime. It's imperfect, but pragmatic.\n. This is an improvement over @OneOf. That annotation doesn't standalone; it only makes sense beside @Provides, but the compiler can't tell you that. If we were to support alternatives like @Provides and @ProvidesToSet then we'd have to deal with the weird cases where both annotations are applied.\nI like type=SET because it's explicit, simple and gives us a little wiggle room for the future. If we need to add a parameter for type=MAP later, that's okay!\n. Genius!\n. Let's just drop this.\n. This is important! I'm getting personal emails!\n. We anticipate forks. Suppose Google's fork of dagger used com.squareup.dagger in imports, but com.google.dagger in the Maven group ID. In either case we're vulnerable to naming collisions. But with dagger as the package name we don't degrade forks.\n. @keilw yeah, the exact same package! Scary right?\nThe upside is that forkers won't need to fork their dependencies and their dependencies' dependencies in order to change their internal imports from import com.squareup.dagger.Provides to import com.google.dagger.Provides.\nAs I understand it smart tools like Maven make it easy to express concepts like Google's dagger is incompatible with Square's dagger. It's similar to how we somehow avoid classpath hell even though Dagger 0.9 and Dagger 1.0 will share the same package name. Imagine if you needed to change imports every time your version changed!\n. The decision to go with a nonconvential package name was not made lightly! We had a very conventional package name for Guice and lived to regret it. In particular:\n- Despite Guice's expansive SPI for configuration and extension, forks still happen! The most notable is sisu-guice, which is used in Maven. The forks' Maven groupId org.sonatype.sisu.inject disagrees with its package name com.google.guice. So if forks exist, violations of the naming pattern exist.\n- It is the nature of dependency injection frameworks that you import them everywhere in your project. You need to import annotation types in every class that participates. With Guice we received complaints that developers didn't want to import a proprietary package com.google.inject in their core types.\nI've seen few practical drawbacks of this approach.\n. @pforhan \n. @edenman \n. I can't reproduce this locally. \nI think this is being caused by this JDK bug:\nhttp://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7003595\nWhat happens if you update your java to a recent version?\n. Sigh, it works for me. Thanks for your patience. If you wanna give it one last try, do this:\ngit pull\nmvn clean test\njava -version\nIt works for me on Mac OS X with Java 1.7.0_10-ea and Java 1.6.0_37. But there could be an annotation processor bug in your version of Java that I'm not seeing.\n. On Mon, Dec 17, 2012 at 1:10 AM, cl kim notifications@github.com wrote:\n\nTests in error:\nnoConstructorInjectionsForClassesWithTypeParameters(dagger.InjectionTest):\ndagger.InjectionTest and dagger.InjectionTest$1Parameterized disagree on\nInnerClasses attribute\nIt's a javac bug http://bugs.sun.com/view_bug.do?bug_id=7003595. Grab the\nlatest javac and the problem should go away!\n. I don't think I was clear enough. This only impacts @Inject bindings. For example, you can't do this:\n\n``` java\n  public class Foo {\n    @Inject Foo() {\n    }\n  }\npublic class Bar {\n    @Inject Foo fooOfString;\n  }\n``\n. Yikes. If you'd like to submit a pull request for the fix, that would be welcome.\n. Thanks Patrick. What will happen to these classes? Do we just assume they won't have any@Injectannotations? That seems suboptimal!\n. Works for me. We should also defer the FullGraphProcessor validation 'til the last pass.\n. @patrickbaumann thanks for the pull request but I don't think this change is ready yet.  There's just far too many complex moving parts here, and this change is extremely scary. Thestatic` field to move state from one pass to another in particular is not going to work in build systems that run javac multiple times in the same process.\nIf you'd like to figure that out and resubmit another pull request, please do.\n. Thanks for the explanation Patrick. Going from elements to strings and back to elements makes a lot more sense now! Looking forward to the follow up.\n. We should just report an error in either case. We don't want to rely on reflection.\n. If application code wants private or final, it should use constructor injection.\n. I don't think this should be an error, but I agree that it can lead to surprising code. We already have that problem, where two unrelated modules can return the same type: say ElectricHeaterModule vs. GasHeaterModule.\nIf we were to make it an error then we'd prevent you from writing an @Provides method that returns a SubFoo for testing. I think that's too harsh a limitation.\n. I don't think this feature is ready for a pull request. I really want to keep the Dagger API very sparse, and I would prefer for new APIs to get a lot of battle testing before we commit to them in the API. Would it be possible for you to fork the project, and see how this API works in practice? This is how we're managing changes from Google and so far it hasn't been too painful.\nOn the particular API.... I don't (personally) like this approach because I don't think it scales. Note that entry points are a completely synthetic concept in Dagger: the only reason we have them is so that we can be more aggressive about validation. If we decided to get rid of entry points completely, we could! And no behavior would change. For this reason a simpler solution would be to drop @EntryPoint and to use the presence of @Inject annotations to indicate that a class is an entry point. \nMy other gripe about this API is that it forces the rule that all classes in a compilation unit (ie. maven module) always target the same graph. This is reasonable for simple single-module Android applications, but it breaks down when you want to use features like ObjectGraph.plus() or create library modules that are shared across applications.\n. All that said, your code looks like a nice balance of readability and capability!\n. For what it's worth, I think this idea has wheels but I'm not ready to commit to it in the core API. I would like to do something similar though, perhaps building on the android manifest processor. One wacky thing we could do is add our own elements to AndroidManifest.xml where you list all of your app's fragments, and then all of your android entry points can be in one place. We already permit our own attribute to exclude an activity from the manifest!\nThe big upside is that each app has its own manifest and we avoid the weird \"which package does this go in?\" problem.\n. Patrick this is a huge improvement. I was very nervous about the last pull request, but this one has me very excited. I gave you a very aggressive, very nitpicky code review 'cause that's how I roll. Don't be discouraged, everything I wrote is more of a reflection of me being OCD than of you writing imperfect code!\nThanks!\n. Fantastic. Thanks @patrickbaumann.\n. This error is good enough 'til we do two-phase code gen.\n. Yeah, unit testing this stuff is brutal. Have you seen our integration tests? I think they're in compiler/it. Copy one of those directories; change it to suit your situation; and we're good. Thanks for going the extra mile on this Patrick.\n. Nice test case. I've got comments on the new method though\n. I took the problem & approach from this change and submitted it as https://github.com/square/dagger/pull/144\nThanks @patrickbaumann; apologies for jumping the gun on that.\n. No plans at the moment. Is anyone using sbt to build Android apps?\n. On Fri, Dec 7, 2012 at 1:14 AM, Joe notifications@github.com wrote:\n\nAre there any plans to benchmark or put numbers behind the 'fast' claim?\nI'm curious how it compares to Guice specifically.\nYeah, the speed difference will depend on the size of your app. Suppose you\nhave a small app that spends 100ms in Guice each time it starts up. The\nmaximum improvement you could see in such an app is 100ms. Some of the apps\nI've worked on spent a long time in Guice at startup: 3000ms or more (on\nsome older devices, anyway). This is where Dagger's avoidance of reflection\nand runtime annotations pays off.\n. No actions to take here.\n. Do you mind re-posting this to the dagger-discuss list?\nhttps://groups.google.com/forum/?fromgroups#!forum/dagger-discuss\nThanks!\n. Eep. I'm embarrassed that we still have this problem.\n. https://github.com/square/dagger/pull/222\n. LGTM\n\nJust the usual jesse-is-fickle comments. Address 'em and check it in!\n. LGTM\n. Just one comment, otherwise LGTM. Please address that, then squash & merge.\n. Good catch @tbroyer! You're right, protected is a superset of package-private. Christian, can you fix?\n. Also to the root project?\n. LGTM\n. LGTM. Please squash commits before checkin.\n. LGTM, just one nitpick on copy&pasted documentation\n. I still think we need to scope out what a robo-dagger's goals would be. At Square we never used Roboguice because we didn't see the need for it!\nThere may be some utility in offering a ready-to-go module that binds the Android framework classes. But I'm not sold on view injection, and I'm anxious about confusing 'easy' with 'simple': it would be bad to remove boilerplate if the result was less efficient or debuggable.\n. Closing this issue because it isn't specific. If there's a specific issue with dagger, please open another issue.\n. @christopherperry the graph size doesn't impact start-up time significantly.\nI'm sorry about the lack of direction on this issue; the problem is that this issue is under-defined. We don't believe in view injection and don't know what else this would cover.\n. @christopherperry even better, please just send a pull request. (not promising to accept it, but that way the task is tracked and we won't review anything 2x.)\n. LGTM\n. LGTM\n. Thanks, but.\nI'm sorry, I can't accept this change without a careful study of what we want the API to look like, or even whether we want to support assisted injections. I'm closing this change and would like to invite you to discuss the API and high-level implementation on our Google Group. Only once that's done does it makes sense to start implementing.\n. Any idea why Travis is complaining? Other than that, LGTM and thanks. (I'm embarrassed that a StringBuffer crept in!)\n. I like graph roots but I don't love the word root because it's technically inconsistent.\n\nA tree is called a rooted tree if one vertex has been designated the root, in which case the edges have a natural orientation, towards or away from the root. [...]\n\nIn Dagger, any node in the graph can be an entry point.\n. Injection points are already defined to be the members with @Inject annotations.\n. I don't think graphNodes covers the current behavior because every dependency in a node in the graph.\nIt may help to consider the definition & purpose of entry point. An entry point is a type that is a legal argument to ObjectGraph.get() or ObjectGraph.inject(). We require these to be explicitly registered so that the entire graph can be known statically; otherwise types defined in @Provides modules is known statically but other types need to be created at runtime. Like Guice's JIT bindings.\nEven if a node is not a graph root, we require an entry point for it if it's used in the two methods because otherwise code changes will have non-local effects. Removing a dependency may implicitly drop a node or series of nodes from the graph.\nOne other word that comes to mind is bootstrap. That's because the process of requesting injection from the object graph is a form of bootstrapping the application. For Android apps we need to do this in every module, but for most applications it should only happen in the main class.\n. +1 to Bob's suggestion. Let's do that.\n. https://github.com/square/dagger/pull/221\n. LGTM\n. Collections.addAll is slower because it needs to allocate an Iterator and/or an Arrays.asList wrapper. Sadly in Android an indexed for loop is the fastest way to walk through arrays and ArrayLists.\n. Pointing this out on the website is a good idea. We should also clean it up some; currently the graphs could use a little love.\n. @arichiardi if you want to see a merged graph, just create a module that includes all of the modules you want in your graph. The graph will include everything.\n. Double checked locking should be fine. Unfortunately locking is what makes singleton scoping difficult. We have two bad choices:\n- Use a shared lock, and reduce concurrency when creating objects\n- Use independent locks and risk deadlock\nI prefer the shared lock. The fix for this issue is to create that lock (probably just a new Object()) and to change singleton scope to use it. Double checked locking is fine; if checkstyle complains then we should silence checkstyle.\n. After thinking this over some, I think we aren't at risk of deadlock because we don't permit circular dependencies.  So per-singleton locks suffice.\n(That said, we also don't always statically check that no circular dependencies exist, so an application could still deadlock. But such an application would fail if dagger-compiler has validated it.)\n. @cgruber what's your change do? ProblemDetector already tries to do this.\n. Yeah, that's what ProblemDetector does.\n. Nope, we aren't doing that yet. We should! It would just require a call to ObjectGraph.validate().\n. We need to fix the code generator to reject this. The currently-supported solution is to put a try/catch in your @Provides-annotated method. This is lame, I agree, but it's very transparent.\n. Nothing in dagger. The best Android example is currently Eric Burke's, from his Android App Anatomy presentation. It uses both Dagger & Otto.\nhttps://github.com/eburke/presentations/tree/master/strange_loop_2012/samplecode/src/com/squareup/anatomy\n. Looks good aside from some style nitpicks. Address those and we'll get this merged.\n. LGTM aside from one small nitpick (add an early return on the cycle fail)\n. I don't think @RunWith is required if you use the default test runner. Here's what the docs say:\n\nWhen a class is annotated with @RunWith or extends a class annotated with @RunWith, JUnit will invoke the class it references to run the tests in that class instead of the runner built into JUnit.\n. Isn't that a bug in Google's build system? It says it would use the runner built into JUnit. (Is the test broken in Google's test runner?)\n\nI'm all for reducing needless differences, but I also hate adding dead code. I would hope my IDE and lint tools would warn me that the new annotation is useless!\n. Does JUnit allow you to override the default test runner?\n. Sounds good. Several pedantic nitpicks on the fix, but the solution is solid. I'd really like to re-think our overall code-gen strategy for some sort of \"Dagger 2.0\"\n. LGTM, just one nitpick on an exception\n. LGTM, aside from comment nitpicks.\n. LGTM aside from one problem in the test\n. Heads up, this might be a binary incompatible change since we're turning final methods into abstract methods.\n. @JakeWharton currently that gives you an error, which is the right behavior in my opinion.\n. Yeah, this is a known limitation. My expectation is that it's rare enough that the reflection fallback isn't going to be that much of a performance lose.\n. I don't think we need @NoSuperInject, especially if we can later implement full graph codegen. (I don't like the annotation because it doesn't have any behavior impact.)\n. No update. What's the concrete problem you're facing?\n. I talked to Bob. We don't want @Inject on abstract classes 'cause it violates JSR-330.\nAnother option: some mode in Dagger where reflection is disabled, and if a generated inject adapter doesn't exist then it is assumed the class has no annotations.\n. We can't do this at processor time because we don't know the superclass won't later gain any @Inject annotations.\n. Let's just make a mechanism to do dagger without any reflection. It's the racing version of Dagger.\n. @rwinograd yup, totally agree that application packaging time is the right time to do Dagger code gen. And also agree that annotation processors don't have that opportunity. At the moment I'm contemplating making a tool that'll do this.\n. I've asked Christian to look over this. I'm not perfectly sure we're completely ready to endose dagger for web apps. There's still a lot of infrastructure that's missing, such as decent data integration. It might be better to create a separate project for dagger+web integration.\n. I like Guice for the server. It's more dynamic so it's harder to debug, but that also permits nice integration with frameworks. I think if we wanted to recommend Dagger on the server it would have to be in the context of addressing weaknesses in Guice without sacrificing its strengths.\n. No, I don't think this complexity is worthwhile. Module overrides support only two levels, most commonly used for production and test. Precedence rules are not worth the complexity of implementation and we want to discourage users from building apps that would need them.\n. (similarly for injected constructors)\n. @cgruber @JakeWharton \n. I get transitivity with scope=provided. What do the docs say?\n. If we make the dagger core depend on dagger-compiler with scope=provided, does that make it so that everyone who uses dagger gets the compiler for free?\n. Obsoleted by @tbroyer's change.\n. This looks like a problem with your class path, and unrelated to Dagger. That said, we don't support Scala, but would be quite entertained by a fork that adds such support!\n. LGTM.\n. Hmmm . . . I'm tempted to forbid subclassing modules altogether. Composition instead of inheritance, right?\n. Just a few nitpicks, otherwise LGTM. Thanks!\n. Looks good. You might need to update the bug report now that dagger works around the problem.\n. Thanks for this contribution, but unfortunately we don't want to manage translations of our documentation. There are a few reasons for this, none of which are problems with your specific contribution:\n- Our user's guide is a living document. As we add features, we document them. But the translation won't track such changes.\n- The translation is shallow: API names and Javadocs aren't translated.\n- I can't verify that the translation is correct.\n- We don't want to translate Dagger's docs to other languages.\n- We don't want to translate our other projects.\nIf you'd like to fork dagger's repo and host this separately, that's completely fine with me and a good way for Japanese developers to learn about Dagger.\n. Sweet! Sounds good.\n. LGTM. Good catch!\n. LGTM. One small nitpick around the order of the two checks.\n. Let's go back to scope=provided for dagger-compiler?\n. LGTM\n. LGTM\n. LGTM\n. That's pretty ambitious. I'm not ready to ship this yet!\n. Nice picture, @kryali.\n@cgruber,\nWe're trying to build on our strengths as a dependency injector with built-in static analysis. Kiran noticed that our app had some @Provides methods that weren't being used, but we had no mechanism to discover this dead code. So he built one.\nWith this change it is an error for a module to include an @Provides dependency that never gets used. This is similar to our other check where we fail if an @Provides dependency is missing. We'll need to cover this thoroughly in the Javadoc on @Provides, where I anticipate something like this:\ncomplete=true means all necessary bindings are included\nlibrary=false means all included bindings are necessary\n. Yup. We implemented it at the @Provides-level and then realized it worked better at the module level.\n. Bunch of nitpick comments, nothing major. Most interesting one is to use the word 'library' internally instead of mixing 'library' and 'necessary'. Address 'em, I'll take a final look and we can check this in.\n. Yeah, I think we could probably add a section to the dagger website that explains our static analysis & graph building.\n. LGTM. \nThree nitpicks. Let's get this merged.\n. I'm using IntelliJ and this burns me personally, so I'm going to fix it. It does mean we're broken if you're using old code with a new dagger, but there's no incorrectness problem and a clean build fixes it.\n. Or switch to two dollar signs, to avoid conflicting with inner classes.\n. Gotta fix this!\n. Looked into this. The fix is to always treat classes containing @Inject annotations as raw types. Also, their superclasses should be treated as raw types. In our current code we treat the supertype as a parameterized type.\nUnfortunately implementing this fix is going to be awkward. At the moment our code gen works in a single phase. If there's an error, we blow up in the middle of writing out a file. A better implementation would do two phases: first we validate then we emit a file. That's more complicated so I'm going to punt this to the next milestone.\nWe could also share code between InjectProcessor and FullGraphProcessor. It already has an AtInjectBinding that's a good place to do validation.\n. LGTM, aside from @tbroyer's suggestion\n. Why isn't field injection sufficient? You can use @Named on field injection.\n. I'm not eager to support method injection. The reflective fall back codepath is going to be very inefficient, particularly on Android.\nAttaching listeners as a side-effect of dependency injection seems to be an antipattern. It means you're expanding the lifecycle of a short-lived thing to whatever long-lived thing it's listening to. I think it's safer to attach listeners separately, where you can match up addListener and removeListener calls.\n. We created Dagger to address performance problems with Guice on Android. For us it was worthwhile. Your mileage may vary.\n. If you grab the latest dagger source, it won't fail the build if dot writing fails.\n. I got sucked into a related change while I was looking into this: https://github.com/square/dagger/pull/219\n. The current code won't crash, but will emit a gap in the graph like Unbound:java.lang.String. I'm going to open a separate, post-1.0 bug to fix that.\n. Yeah, I think this is unrelated to dagger.\n. LGTM fantastic\n. Lets Get This Merged\n. LGTM with one problem about staticness\n. Add @Inject to the constructor of ComplexObject.\n. LGTM\n. @kryali @JakeWharton \n. Agreed, the singleton wrapper needs refactoring.\n. https://github.com/square/dagger/pull/232\n. Yeah, I think it's intended to work like this.\nBut I don't see where the compiler stores the originatingElements data on the filesystem. My guess is that it doesn't! I've asked StackOverflow to confirm: http://stackoverflow.com/questions/16452980/are-filers-originating-elements-useful\n. Eep, how embarrassing. Will fix.\n. Let me explain it back to you to confirm that the idea transmitted successfully.\n1. In Dagger @Singleton means one-instance-per-graph, which contradicts the conventional definition of one-instance-per-application.\n2. It's helpful to name the extending graphs after the additional state that they carry. The User extending graph holds one user constant. The Request extending graph holds one request constant.\n3. Replace the confusing word 'singleton' with the graph's name. It's not Preferences, it's @ForUser Preferences. It's not HttpHeaders it's @ForRequest HttpHeaders.\nIs that the proposal?\n. @cgruber what do you have?\n. +1 on your rules. Or something stricter, like dropping backwards compatibility for the entirely unscoped extensions.\n. @JakeWharton Jake this looks good?\n. Oooh, that's a major bug. \n. I'm late to the party on this. From Guice my experience has been that it's occasionally quite useful to control the iteration order of the set, especially within a single module. Let's do something quick & dumb, like perhaps this:\n@Provides(type=SET, rank=10) Authenticator provideAppAuthenticator() { ... }\n@Provides(type=SET, rank=20) Authenticator provideFallbackAuthenticator() { ... }\nIt's quick and it's dumb, but it addresses the problem. It's lame and bad because it takes a fully-decoupled system and allows you to add implicit dependencies between @Provides methods. But occasionally you need to do that. And Dagger is a pragmatic DI system that makes it easy to get your work done.\nHate it?\n. Sorting authenticators with compareTo is a hassle. You'll end up defining an internal rank field anyway and comparing on that.\nI'm uncomfortable relying on the order of modules passed to create. Modules can be included via multiple paths, and so you need to be very careful. That approach is implicit and somewhat fragile.\nLet's pick a few use cases and use that to drive the discussion.\n1. Some of the apps I'm working on support multiple countries. It would be fantastic to use Dagger to create plugins for each country. The order of countries in Dagger will ultimately be the order of the countries in the app's UI.\nclass UsaModule {\n  @Provides(type=SET, rank=0) CountryPlugin provideUsa(...) { ... }\n}\nclass CanadaModule {\n  @Provides(type=SET, rank=100) CountryPlugin provideCanada(...) { ... }\n}\nclass JapanModule {\n  @Provides(type=SET, rank=200) CountryPlugin provideJapan(...) { ... }\n}\n1. I'm an HTTP guy, so I want to use multibindings to select HTTP clients. Each HTTP client contributes a multibinding for an HTTP implementation: Apache HTTP client, OkHTTP, and HttpURLConnection. The application code picks the installed HTTP client with the highest precedence. At a risk of derailing the conversation, this would also allow us to do this:\n@Provides(type=LOWEST_RANK, rank=100) HttpClient provideHttpClient(...) { ... }\nMore use cases?\n. Jake: good point. Let's drop this.\n. I'm not a fan of surfacing plugins in the API. There's far too many volatile implementation details in there.\nCould we instead do something dumber? Perhaps offer two runtime jars, one with reflection support and another with compiler support? Only ship the code you're using.\n. Plugins are sufficiently low-level that I'm not even that opposed to using gross System properties to poke at them.\nSystem.setProperty(\"dagger.reflection\", \"false\");\n  ObjectGraph objectGraph = ...\nYes it is gross. But it reveals an appropriate amount of commitment to this API. It's an invisible option, and that's find with me.\n. I also don't think Plugin is the right name for these things long term. Plugin should be renamed Introspector cause it can introspect a class and tell you about it.\nThis is not an SPI and we should discourage new implementations from being written. Otherwise that code will break as soon as we add new behavior (like map bindings or full-app codegen).\nBack to Adrian's original request, it seems like if you want to opt out of reflection, you should be able to do so globally. If your application needs reflection in one object graph but not in the other, that's really weird. And it's also going to be very broken when we support full-application codegen. When we do, I'd like to do it in such a way that this 'disable reflection' argument is obsolete: you won't be able to enable or disable reflection because it won't exist anymore!\nIn the interim I think a system property is a sufficient work around.\n. @jonreeve unfortunately we merged this a bit too early. Please fill out Square's CLA, which is a necessary step for us to accept changes to the project. If you can't fill out the CLA we'll need to revert your change, and that sucks.\nhttps://github.com/square/dagger/blob/master/CONTRIBUTING.md\n. CLA received. Thanks Jon.\n. I like the \"worst\" one the best:\n@Provides(type=MAP_VALUE, key=\"Foo\") Handler provideFooPlugin() { ... }\nStrings are enough for everything I've had to do. More sophisticated apps can use strings and create their own adapter bindings like this:\n@Provides Map<Identifier, Handler> provideFooPlugin(Map<String, Handler> stringMap) {\n    // use stringMap to create the other map\n  }\nUpsides\n- No confusion between qualifier annotations and map key annotations\n- Statically checkable\n- Fewer types and less code\n. There's a lot of power you can achieve with multibindings. Guice's servlet module uses multibindings-like magic to accomplish a lot of flexibility with very little code. Imagine this:\nList<Object> modules = list(\n  new UsModule(),\n  new GenericCountryModule(\"canada\", \"CAD\", \"Beavers\", \"en-US\"),\n  new GenericCountryModule(\"france\", \"EUR\", \"Frogs\", \"fr-FR\"),\n);\n. LGTM\n. An LGTM from me means, \"address the comments in the obvious way, then merge it yourself.\"\nAnything else puts an unreasonably high cost on fixing spelling mistakes and other nitpicky things, in which we all delight in pointing out.\n(If I didn't trust you, you wouldn't have commit privileges!)\n. I like this approach best:\n@Provides(type=SET_VALUES) Set<Foo> provideFoos() { ... }\nIt's especially nice 'cause we also want to support returning multiple values for other scenarios.\n. Approach looks solid. \nhttps://android.googlesource.com/platform/libcore/+/refs/heads/master/support/src/test/java/tests/util/ClassLoaderBuilder.java\nhttps://android.googlesource.com/platform/libcore/+/refs/heads/master/luni/src/test/java/libcore/java/lang/reflect/ProxyTest.java\n. https://plus.google.com/u/0/106557483623231970995/posts/ijSTQUdQ7XB\n. @mikosik +1\n. ... though those names sound like they're suppressing warnings. A library module is a valid module; it just doesn't use its own binding.\n. Will this require @Generated on the build path?\n. We still support android 2.2 though.\n. The policy in Dagger 1.0 is to forbid checked exceptions. That's what we should do here, but with nicer error reporting rather than a compile failure in generated code.\nWe may want to permit these later, but possibly using a different mechanism. Guice has ThrowingProviders; we may want our own hooks that make checked exceptions work with dependency injection.\n. Forking is encouraged. (I know this answer isn't particularly satisfying.)\nGuice has a simple enough API for simple use cases, but is broadly extensible for folks that know what they're doing. I think this was a mistake; it means that the more ambitious programmers on any team could write code that other programmers couldn't understand. We gave you lots of rope.\nWith Dagger I think you do this by manually creating a separate @Provides method for every parameterized type you use. The downside is it's annoying boilerplate. The upside is you can grep your codebase.\nClosing the issue, but not the discussion!\n. LGTM. Merge at your leisure.\n. Agreed that injects is annoying. I'm planning to do something different for Dagger 2.0, when we can do full-application analysis.\n. I'm not convinced that we ever want to store the context class loader. The context class loader is a thread local and intended to allow low-level libraries to get the class loader of their high-level callers.\nInstead we want to find the class loader that's tied to the class we're loading. For anything that comes from a module, we want the class loader of the module class.\n. Sorry, I don't think I made myself very clear. I think you want to use the system class loader whenever you want to use the class loader of a class, and that class loader turns out to be null. For example if you ask String.class what its class loader it uses, and it returns null, then you should use the system class loader.\nYou definitely don't want to use the system class loader in any other situation. The system class loader is the root of the class loader tree, and so it can't see application classes. It won't be useful here.\nI think the only correct class loading behavior is to use the class loader of the modules. You can attempt to be precise and use the class loader of the module that referenced a type, but sometimes a type won't ever be referenced directly by a class loader. For example, when you load Foo and that needs a Bar injected, that might be the first time we ever see Bar.\nPerhaps what we want to do is track something like requestedBy, but do it for class loaders. Whenever a binding is requested we grab whichever class loader requested it. For injects= that's the module's class loader. For dependencies that's the class loader of the depending type. \n. LGTM after a few small nitpicks.\nI think we want to change requiredBy into two fields, requiredByBinding and requiredByName, where we will only set one or the other. If a binding comes as a dependency we can use the requiring binding. If it comes from a module, we'll use the method name or module name.\n. (If we do that, then we can use requiredByBinding to get the class loader)\n. LGTM. Please squash commits before merging.\n. LGTM\n. You're misunderstanding the semantics of plus(). It's allowed to add new bindings, but not override existing bindings. Even with overrides=true it isn't allowed to override bindings from the original graph.\nBut your example does show a bug in our plus implementation. We should be exploding in way #2 because the two bindings conflict. But we aren't exploding. Whoops! I'm going to repurpose this report to cover that.\n. LGTM\n. LGTM after comments.\nThis is very nice work. \n. LGTM\n. LGTM\n. +1\n. +1.\n. Seems reasonable enough. Perhaps change Binding to have 2 methods, get and getNullable ? The get overload would reject null; the other permit it. Then we call getNullable wherever we're injecting something with a @Nullable annotation.\n. Let's avoid the word \"Optional Injection\" since that means something completely different in Guice.\nThe behavior change is to throw an unchecked exception instead of injecting null, each time that would occur. Suppress the exception by marking the injection point with @Nullable.\n. Any @Nullable. Dagger shouldn't add its own.\n. Yeah, I'm not completely comfortable with the maintenance burden of checking in generated files.\n. Yeah, I'd prefer to leave it off. The long term cost is high and the long term benefit is low.\n. Wow, what a nice treat. Just a bunch of nitpicks and I think we can get this checked in!\n. Overall this change is exercising a bug in our code where multibindings aren't closed to extended graphs. But I don't think it's new regression, so we should be able to commit this and fix that separately. Let's do that.\n. Leave the test as-is and we'll fix it in a follow up. I don't like using one enum for both kinds; the ambiguity is lame.\n. Nice! Thanks Adrian!\n. Yup, that's perfect.\n. LGTM\nDIG\n. @sgoldfed...\nFirst, thanks for jumping in and fixing something that's broken.\nNext, I wanted to explain that this was a known limitation that we intentionally didn't fix. The problem with the fix is that you're generating code for classes outside of the current compile scope. This doesn't end well.\nSuppose you have A.java, B.java and C.java, such that C extends B and B extends A. Also A has injected fields, B has none, and C has injected fields. When I compile C.java, the generated code is going to detect this, and helpfully tell C$$InjectAdapter that it can skip injecting B and go right to A. So far so good.\nUntil we add an @Inject member on B. That won't necessarily cause C to be recompiled because C doesn't have to be in the same project/module as C. And that means that C now has a stale assumption.\nWe plan on solving this problem, but our fix is going to be more invasive than just improving our annotation processors. Instead we're building whole app code gen where we admit to ourselves that incremental builds are hard and give up on annotation processors which are inherently incremental. Instead we'll enter the fun and exciting world of bytecode parsing. Hooray.\nI would have loved to explain this to you before you started writing code, but you wrote the code first. Sorry about that.\n. Yeah, put it in the Google fork. Put some miles on it and see if the incremental builds are a problem in practice. Are you guys using Maven or something proprietary?\n. @tbroyer using an annotation processor to do full-app code gen is a good idea.\n. You talk a lot about this problem being unlikely to occur in a production build. But non-production builds are important too. During development I would find it quite frustrating if occasional changes required clean builds.\nAs for proposing a fix, I've already proposed it and implemented it. It's the current behavior.\n. This problem isn't theoretical. I was able to reproduce it in a very simple IntelliJ project.\nFirst download this branch and mvn install it. Next download this zip file and open it in IntelliJ. Build & run, you'll see the following:\ninjected\nnot injected\ninjected\nNext, change B.java to include an @Inject annotation on its only field by uncommenting the commented line (and commenting the other line). Re-run main, and you'll see your @Inject annotation didn't work.\ninjected\nnot injected\ninjected\nPerhaps more alarmingly, if you do a clean build, you can see the reverse problem. A non-injected field is injected.\nThe reason this particular change is problematic is that @Inject annotations are an implementation detail of a class. I should be able to add them and remove them without rebuilding downstream classes.\n. LGTM\n. LGTM\n. LGTM.\nPlease squash.\n. Whoa, custom scoping? That doesn't exist yet.\n. Sweet. Just a handful of nitpicks. The validation of custom scopes is interesting because we don't support them. That said, it's a JSR-330 type and it doesn't hurt.\nLGTM after comments addressed.\n. LGTM\n. I dig. @JakeWharton merge if you agree?\n. Let's use write*() for anything that calls into JavaWriter: classes/methods/fields/etc.\nLet's not use any prefix for name creation. If I want a stripped type name, the method can be strippedTypeName(). These are pure functions; the names don't need decoration.\nFor lookups, I'm happy with get*() or no prefix. For example, if I want the fields of String.class, I can just say fields(String.class) and that's sufficiently obvious. \n. LGTM (with some nitpicks. Please address & I'll merge)\n. LGTM\nPlease squash your commits and I'll merge!\n. LGTM\n. Nope. You'll need to do your own JNDI adapter. Should be pretty straightforward; just make a module where each @Provides methods looks into JDNI.\n. @cgruber ready to see this go in?\n@RayFromSquare do you mind adding @Ignore to the new tests until we can implement the other half?\n. LGTM\nWith a few drive-by comments!\n. LGTM\nLove this library.\n. Interesting! Care to submit a benchmark? Caliper is handy.\n. Thanks!\n. Yuck. I wonder if it's the compiler version. Are you running the same version of javac as on heroku? \n. I'm with @gk5885: there's no obvious behavior when combining set bindings with overrides. I also think it's a mistake to do unions when you plus graphs. Instead we should fail with a duplicate binding if the extending modules define additional set elements.\n(Otherwise some dependencies in the graph point to one definition of the set, and others point to a different definition of the same set.)\n. Hmmm. Greg's got a point. I think I just have to change my mental model. If I depend on a Set, I'm not depending on a specific concrete thing; rather it's a selector for all the things that match the desired type in the current graph.\nAlright, let's try it and see what falls out.\n. Because LruCache doesn't hold the lock while the value is being computed, the lock is held for a very small number of operations; typically a single map lookup.\nHow did this change impact parallelization on the server side? I wonder if it replaces lock contention (visible) with CPU load (invisible).\nIs this one of these cases where optimizing something for the JVM causes it to perform worse on Android. In particular the ReadWriteLock does an object allocation for every contended read. (Potentially causing GC stutter.)\n. If we were going to do 2 implementations, we'd want to auto-switch based on environment detection. But that's gross. Instead we should just build a solution that's both low-contention and low-allocation.\nCopy-on-write would do this, but a naive implementation is expensive when the dataset is large. A persistent datastructure would be a better fit: copy-on-write behavior with sharing.\n\u2013\nBut further inspection of our codebase shows that optimizing LruCache is fixing the wrong problem. We aren't doing plus() efficiently yet. Right now the first plus() call computes how to go from a set of modules to the corresponding graph. The 2nd plus call does the exact same work, saving a few operations at the edges thanks to our caches.\nA better solution would be to more aggressively cache the mapping from a set of module classes to their graph structure. Then we could stamp out new graphs very quickly vs. all the extra work we do today.\nSince this good solution is disruptive, and the ReadWriteLock/synchronized difference is negligible, I'm happy to approve this as-is for now. But we should circle back if we want to make lots of calls to plus() work efficiently.\n\u2013\nLGTM\nPlease fix LinkedHashMap / HashMap and unnecessary synchronized.\n. LGTM\n. LGTM\n. That's clever. I like where you're going with this.\nShould complete=false on a complete module be an error? CC: @cgruber @gk5885\n. Not strictly necessary for a change like this, but please fill out our CLA.\nhttps://github.com/square/dagger/blob/master/CONTRIBUTING.md\n. I don't feel too strongly. The constructor feels a little boilerplatey; and it provides a small amount of additional safety.\n. In Cash we use DI even in our tests. We never execute the constructors directly. Which means field injection works great for us.\nWe don't end up with constructors so declaring a constructor just so that I can annotate it adds boilerplate.\n. LGTM\n. Right now Dagger wants Java 1.6 or better, and JavaPoet wants Java 1.8 or better. I'm tempted to meet in the middle, requiring Java 1.7 or better for Dagger's compiler, and making JavaPoet build-on Java 1.7 completely.\nAlso blocked on a JavaPoet release!\n. Updated to JavaPoet 1.0.\n. ThrowingProviders were a mistake. The author was young and misguided.\n. @fuhaiq yeah, that'll work. The problem is that when you call Provider.get() later, that can throw an unchecked exception.\n. Tracking on stackoverflow.\n. We can't support this in a reasonable way. It breaks many assumptions and I don't think your cute sample is worth the hidden complexities it carries.\nOne simple assumption: if any dependency of the lazy is a stateful singleton, do we get two instances upon deserialization?\n. I don't think this change does what it says it does. It claims to move a class, but it does a bunch of other work. If you'd like to move that class, please do so in a separate, PR that does only that!\n. That wasn't as easy as I was hoping it to be! I assume you didn't see something dumb we were doing that could have made this easier?\n. Yes.\n. Basic.B\n. LGTM! Glad to get rid of that extra queue!\n. LGTM\n. Works for me.\n. Take a look at ParameterizedTypeName.\n. Please use stackoverflow.com for usage questions.\n. I would have missed that. Thanks!\n. Please add Square here also. Have you submitted Square's CLA ?\n. This first sentence isn't semantic. You could probably just say \"A value that is lazily returned.\"\nDo we want to say \"lazily created\" ? I know we want to imply that (for the normal case) but using this interface doesn't guarantee the value will be created.\n. This documentation is written as if it is addressing the implementer. By convention, Javadocs should be written to address the user. So instead of saying \"A Lazy should do X\" you should say \"A Lazy will do X\"\n. Mention that multiple calls always return the same instance?\nI hate the word 'wrapper' in docs.. It's an implementation word not a semantic or descriptive word.\n. You can simplify this quite a bit now that there's only one prefix to consult.\n. wrapper is still nails on a chalkboard for me.\n. I know it's my own word, but COMPUTED is a lousy choice here. What would work better? NOT_PROVIDED ?  hmm.\n. make this final please\n. You should probably override some of the other methods from Binding.\nI think we do something slightly nasty in ProblemDetector when we see a BuiltInBinding. We might need to do something similar for LazyBinding. You can test this by doing detectProblems and verifying that lazy works as it should. (studying the code now, it might also be correct to remove the special case for BuiltInBinding).\n. As a style rule, you always need a comment to justify why a suppressed warning is okay. This is what BuiltInBinding does:\n   @SuppressWarnings(\"unchecked\") // At runtime we know 'T' is a Provider or MembersInjector.\n. yeah, like this!\n. nit: this empty line is ugly\n. Nice\n. Order of involvement is good. You can optionally add \"Copyright Google\" to the files you create. I'd like \"Copyright Square\" on all of the files so my company gets some credit for this! Unlike Google we aren't (yet) an open source powerhouse.\n. I think Lazy should be an interface for foolish consistency with Provider and MembersInjector.\n. You could just not say wrapper. \"Returns a key for a Lazy.\"\n. Please do\n. Nice\n. just say \"the empty string, an annotation prefix or the members/ prefix\" ?\n. For the love of my sanity please never use the word \"magic\" in this project. Magic is our enemy, we shall never use it.\n. rename this to \"start of type\"\n. I'd be tempted to write a method like this:\n/**\n * Returns the delegate key or null if it doesn't use {@code delegatePrefix}.\n * @param delegatePrefix either PROVIDER_PREFIX, MEMBERS_INJECTOR_PREFIX or LAZY_PREFIX.\n */\nstatic String getDelegateKey(String key, String delegatePrefix) {\n}\nThen you can implement getDelegateKey and getLazyKey using that method.\n. nit: currently this project wraps doc lines at 80 columns. If you want to use more than 80, you need to change it for the whole project.\n. yes!\n. Any chance you can configure your tools imports so that they match mine? I use no empty lines and sort by imported classname.\n. Nice.\n. I think the value arguments discussion is distracting. Please remove it!\nIt might not be because the object depends on volatile configuration either. Some objects are simply stateful single-use. For example, I need a new  HTTP client object for each request.\n. Please use backticks around variable names: Provider<T> and Lazy<T>. Since 'Factory is not a type, you should use a lowercase 'f'. I also don't feel as strongly about avoiding providers; there are lots of useful places where they're used in new code. Http clients, executors, heck even simple builders need to be injected sometimes.\n. \"de-duplicated\" makes me a wee bit scared . . . . we should permit two children to include the same module, but forbid a single-level includes to contain duplicates?\nI don't know if there's any action for you to take here. (I also dislike the word \"deduplicated\", but that's my own problem)\n. A class?\n. It's dead code walking, but I don't think the null case happens. The ==0 optimization is a bad idea because then this sometimes returns you a mutable copy and sometimes it returns you the mutable original.\n. Eep, I really don't want the example to grow beyond \"Hello world\". We should create other examples for that.\n. Please revert this once you have the fully-featured example in place. The example isn't a test case.\n. Just deleting unused stuff. I couldn't help myself.\n. nit: lowercase 's' for 'set' the word, or {@link Set}/{@code Set} for 'Set' the class.\n. might as well say immutable?\n. Document that this must accompany @ Provides? Or perhaps this should be an attribute of @ Provides? \nSome options I haven't considered to carefully:\n  @ Provides(collection=true)\n  @ Provides(mapKey=\"foo\")\n  @ Provides(unique=false)\n. dead line\n. I don't think this case is as useful anymore. In the code above the motivation is to save a StringBuilder if we have no qualifier. In this code we're going to construct a string anyway so you don't need a special case.\n. getQualifier? It's weird for a validate method to return a value. Less weird for a get method to do validation.\n. yuck?\n. Please don't add tons of state to toString. We should come up with a simple sane way for bindings to toString themselves . . . probably just the key.\n. around an existing binding.\n. This suddenly seems quite complicated. .  . . I'd hate for all of our \"extension\" features to be implemented in one method. Perhaps call out to another method that constructs the appropriate binding?\n. Add a to-do to do something smart for child graphs? Perhaps in child graphs the sets can be combined?\n. You already defined this on line 136\n. What's a unitary binding?\n. Rule 1: don't check in commented out code\n. this method does not add much value, and the name 'unitary' is scary. Just call it 'createBinding' or methodToBinding ?\n. this method is useless. Inline that shit.\n. Could you mention @ Element ? I dislike \"dispatches provision\" since that sounds enterprisey.\n. Could you declare this as \n  SetBinding extends Binding>\n?\nThen you can make contributors typesafe.\n. ALWAYS LinkedHashSet ALWAYS\nHashSet goes in the same pile as Vector and Hashtable as collections that shall never be used.\n. Nice comment. At Square we're very nitpicky: all comments are sentences with a Capital Letter and a period. So this would be \"Let runtime exceptions through.\" . . . it's a picky thing.\n. Why 'volatile' ? Just say 'result' ? Also LinkedHashSet.\n. I don't think you need @ Override to get this behavior . . . \n. What is going on here? You can just say \"return \"SetBinding\" + contributors and save some carpal tunnel. \n. no unitary . . . just 'binding' ?\n. Unnecessary comment?\n. I think lint will fail the build with this\n. This kind of assert fails in the ugliest way. You get \"EXPECTED 1 BUT WAS 2\" . . . I think you want a single helper method:\npublic <T> Set<T> set(T... ts) {\n  return new LinkedHashSet(Arrays.asList(ts));\n}\nThen you can write strong asserts:\nassertEquals(set(\"string1\", \"string2\"), ep.strings);\n. use an int counter for the values? Then you get predictable sets: 1,2  1,3  1,4\n. ... otherwise this fails with a usless message\nexpected [Object@0x3243, Object@0x32343] but was  [Object@0x3243, Object@0x323423] \n. neat test\n. neat\n. nit: dead line\n. kind of weird to do a sample like this here\n. amen\n. extract is better than validate. I like get. Note that 'get' doesn't imply getters/setters. I'm thinking like TimeZone.getTimeZone. All 'get' means is 'returns a value without side effects'.\n. Why are singleton bindings being passed into this? That is very bad.\n. toString() is supposed to help the user debug, not the implementor. So ArrayList's toString is [a, b ] instead of \"size=2, elements=[a, b, null, null, null]\". The toString should be designed carefully, and make sense in a debugger.\nIf we wanted this (I don't think we do), we'd want to use Dagger's regular language: @ Singleton Foo, not Singleton[Foo]. But I don't think the singleton attribute is important enough to be in binding's toString.\n. Works for me.\n. Aaahhh.\n. Yeah, and it's also weird because the children would inject different sets than their parents.\n. Just call it a binding. Binding is the default.\n. You're adding 3 lines to save 3 characters. Seems like a waste to me.\n. Just 'binding'. All bindings are solo. If we add chocolate bindings I don't want to have to rename the other callsites to unityVanillaBinding\n. Ahh, that's not you losing the formatting, it's github. Github doesn't know how to escape less than signs! Garbage.\nInstead of Set{T} extends Binding{T}\ndo\nSet{T} extends Binding{Set{T}}\nthat way you can make contributors typesafe.\n. Yeah I think so. I'm shocked.\n. Huh? I don't see that at all. Shouldn't it be\nif (binding instanceof SingletonBinding) throw new AssertionError();\nIf we're double-scoping, we have a big problem.\n. You need to add behavior to the code generator to detect these and blow up. Later you can support @ Element on generated code.\n. suppress warnings? I still think this should extend Binding{Set{T}}\n. I thought you said you were changing this to use\n    assertEquals(set(\"string1\", \"string2\"), ep.strings);\n. nice. You can put this all on one line per Square's improved style guide if you like.\nif (binding instanceof SingletonBinding) throw new AssertionError();\nYou don't (generally) need messages for assertion errors, except as documentation. They never happen! And the line number in the stacktrace is enough.\n. Just do this inline with the declaration?\n. nice. Import Element?\n. I still wish you'd do full assertions comparing one set against another! You can use integer counters if you want distinct values. It's so much easier to follow vs. anonymous objects.\n. and here\n. What you're saying is VERY SCARY! I think you can get exactly what you want, though you might need two counters instead of one.\n  int nextSingleton = 100;\n  int nextInstance = 200;\n  assertEquals(set(100, 200), ...);\n  assertEquals(set(100, 201), ...);\n. nuke this crap!\n. nit: {@code AndroidManifest.xml}\n. I'd prefer to use the same exact $InjectAdapter class that we're already generating. Just add a new 'injectStatics()' method on that? I want to limit the number of generated classes!\n. On second thought, that won't really work because they each need their own sets of fields and bindings.\n. This is a bug. We need to generate the set of static injections based on the incoming @Inject-annotated class, not on the module.\nThe issue comes up when you compile different sets of .java files in different modules. Suppose I have ModuleFoo that refers to static injection of class StaticBar. And suppose these get compiled into different .jar files. The class 'StaticBar$StaticInjection' needs to be generated when StaticBar.java is compiled. Generating it with ModuleFoo won't work because the generated class will go into the wrong .jar.\nAnother way to think about it: if two modules both request static injections of the same class, we should still only generate one artifact.\n. This is related to what I was discussing above.\n. Now that you have some experience with it, please tell me honestly: how do you feel about this API ?\n. Yeah, I think you're right. This approach is simpler. Simpler wins!\n. Nit: copyright header?\n. whoa, is that an old-school xdoclet annotation? Haven't seen one of those since 2005\n. @stephenh yeah the GClass.addEquals() method shows that your approach has legs! I dig.\n. use toUpperCase(char, Locale.US)\nhttp://elliotth.blogspot.ca/2012/01/beware-convenience-methods.html\n. You're right! What a silly API.\n. Yeah, this test covers what happens when you inject a MembersInjector. Unrelated to ObjectGraph.inject().\n. When you bring this change back to life, could you combine these classes all into one file? Putting everything together might make understanding the tests easier.\nYou could also name the containing class like MissingAtInjectConstructor which would make CTRL+N work\n. I don't think this is valid to checkstyle\n. bean shell! neat.\n. no varargs in beanshell?\n. should this method have assert in the name? As-is it looks like it should return a boolean.\n. Whoa, NIO? On purpose? Crazy world.\n. no tab characters, don't be ridiculous\n. nice.\n. Shouldn't we just make Binding.UNRESOLVED implement getDependencies?\n. I don't think this should be necessary\n. Yeah, I think that's a bit more elegant. As-is we're baking in more assumptions than we should.\n. Yeah, I see where you're coming from. I guess I mean that we should be able to remove this now that the bug has been fixed?\n. This is fantastic\n. I don't like the phrase \"If you use code gen\" . . . users MUST use code gen. That's how dagger works! It isn't just for generated artifacts, it's also for doing static validation.\nI think my biggest complaint about this change is that it's going to take always-on validation and make it optional.\nNit: it's annotation processors, not annotation-preprocessors\n. Please drop the word 'simply' here. That's offensive.\nIs maven capitalized?\nUse backticks for pom.xml!\n. Square's rule is that code comments are capitalized sentences. You missed your period on the \"keeps...\" sentence.\n. rename this to dagger-buildtime or dagger-compiletime or something? \"Codegen\" was a naming mistake that I made in the original package. Now that users have to know this we need to use a more correct name!\n. Processing?\n. And most importantly, static checks!\nI'm also thinking about changing the codegen step to use something other than annotation processors. The problem with annotation processors is that they suck at doing whole-world analysis.\n. I don't like the name wire. The problem with wire is that it implies that it's manipulating application objects. It isn't. It's just building a graph that describes application objects.\n. The README didn't fix the calls to ObjectGraph.get()\n. Technically the dollarsign is a part of the suffix!\n. Dagger isn't the graph. In this code it's a factory for graphs. While I agree that ObjectGraph.get() was lousy, I don't think we need a Dagger class that has only one method. I'd prefer ObjectGraph.forModules() or something.\n. You just spent the entire 2012 newline budget !\n. Make this an inner interface in ModuleAdapter and name it 'Resolver'. It's not a ModuleResolver, it's a ModuleAdapter.Resolver.\n. This is completely insane. Why in the world would we have multiple linkers?\n. Huh?\n. Is this always going to be size 1? Or is this the set of GENERATED, REFLECTIVE ? In that case I think this class' name is weird? Shouldn't this class just be called ModuleResolver? Perhaps I need to read more of the code.\n. Off topic: I'm going to try to remove all of the @author tags from our codebase. This is a job much better served by 'git'. \n. Why is this a runtime class? Isn't everything a runtime class?\n. Pretty sure I didn't write this.\n. Too many files. I think this should be an inner interface of StaticInjection . . . like Factory or something\n. As above, the suffix includes a $\n. Is there a way you can make this class implement all of the other codegen-time interfaces? I don't think we need to divide it up by feature: Codegen linker can do codegen-static injections and codegen module resolution. Just make all of those features abstract methods on Linker and implement them here and in the ReflectiveLinker.\n. If you want to make it so that the codegen implementation can delegate to the reflective implementation, just put them in a single file and let them delegate by just making a single method call.\n. This method definitely wants to be defined in the same class as its twin, ModuleResolver.get()\n. Getting analysis early is most important to me. If we can guarantee that, it gives us liberties at runtime to make optimizations and fast startups that aren't possible otherwise.\n. The problem is that linker is very stateful. If you add additional linkers, it's unclear where that state goes. If you want to move behavior out of linker, that's okay.\n. Ahhh . . .  tricky. I thought we were going to do the Guice-migration work in Guice itself?\n. Fewer files forces simplicity! And the files should be small too!\n. Update the commit message too?\n. English sucks. We should just learn German.\nrun-time --> runtime (as in Java Runtime Environment)\ncode-generation --> code generation\ndagger-codegen --> dagger-compiler\ncompile-time --> compile time (Wikipedia uses a dash when it's an adjective like \"includes compile-time validation\")\nhttp://en.wikipedia.org/wiki/Compile_time\n. Is maven capitalized?\ncode-generation --> dagger-compiler\n. dagger-codegen --> dagger-compiler\n. adaptors --> adapters\n. ?\n. My only gripe with \"Plugin\" is that I think of plugins as being optional. But Plugin is good enough for now.\n. Remove this\n. @Override goes on the same line as the rest of the declaration. Not everyone has 30\" Google displays!\n. Nice\n. Drop 'Dagger' from ClassloadingDaggerPlugin?\n. Nice\n. Go all the way to final?\n. flip lines 49 and 50 ? keep field list, parameter list, and assignments in the same order for foolish consistency!\n. Nit: Line wrapping here looks off.\n. This is good stuff.\n. rather than saying \"a given class\", just refer to the parameter by name.\n\"Returns the static injection for {@code injectedClass}.\"\n. a --> the\n. RuntimeDaggerPlugin --> RuntimePlugin\n. I hate to ask this, but can you use an array here rather than a List? Everytime you for loop over a List that allocates an object, and our garbage collector isn't that awesome on Android.\n. Nice comment.\n(nit: capitalize 'Let')\n. Do we need to catch all exceptions here?\n. Hmmmm . . . . should this be more fatal? What were we doing previously?\n. NO they must not be hand rolled. Don't imply that we support that. We don't.\n. I'm not sure if Classloading really captures what this is. Could you call this GeneratedCodePlugin ?\n. (generated or other) --> generated\n(and above\n. nit: newline\n. nit: on same line\n. I don't consider dagger.internal to be a user-accessible plugin API.\n. Ah, I should be more specific. You should either put a <p> before \"Implementations\" or put that word on the previous line.\n. Probably unnecessary. Static injections!\n. insufficient? Don't you want linkAll ?\n. you want a for loop!\n. I think this wants to be flipped with 236\n. Preconditions is an antipattern forced by a lousy style guide!\nYou can probably just do this:\n  if (linker == null) throw new NullPointerException(\"linker\");\n. for loop\n. 2010?\n. I think these are two different things! Suppose A depends on B.\nCreating the dependency lazily means that A doesn't depend on B until as late as possible.\nMaking a dependency lazily created means that A depends on B immediately, but B isn't created until as late as possible.\nDoes this distinction make any sense?\n. Dig.\n. Whoops, this should be\nCreate your own qualifier annotations, or just use @Named.\n. ... but now this isn't a good sentence? \n. artifact ID looks off?\n. Sucks that extends is a keyword here. I'm not sure about the name root. Keep this for now, but I'd like to think about a better name later.\n. Use {@link } to link to this inline in the message rather than @see. @see is an abomination.\n. I think the 'Contributions...' sentence is confusing. Omit it?\n. I think we should avoid root because it isn't necessarily the root. You can extend an extension! It really sucks we can't use extends. Hmmm. . . . . \n. base ? buildsOn ?  supplements ? augments ?\n. yes!\n. missing space\n. It's my own problem, but I think and/or is just ugly. Could this be a list?\n. dependency graph --> object graph\n. Drop the sentence about forces resolution ... . . . that's an implementation detail that we don't want to promise.\n. I'd be tempted to rephrase this to be about graphs and math rather than dependencies. If you'd like to avoid having me nitpick every character here, just leave it and I might circle back after to describe it that way.\n. drop this? 'complete' is a bit misleading because they're not internally complete...\n. dig\n. Jesse's OCD rule: {@code } and {@link } always go with CamelCaseNames like Linker. For lower case names like linker you don't need either. Here it's weird 'cause you say linker in one sentence and Linker in the next.\n. If we stop using the word root to mean something that isn't necessarily a root, then we can refer to the top-most linker in the chain as a root.\n. missing a space\n. Jesse OCD rule: never more than one blank line in a row. (And blank lines between close braces are almost always useless.)\n. The directory name is extension-graph. Shouldn't that match the artifactId ?\n. Use augments? I don't think root is correct.\n. nit: Interface --> interface\n. this line is unnecessary?\n. this line is unnecessary?\n. cut and paste error\n. Nice test.\n. Yeah, but it's still a bug. This a cut and paste error!\n. nit: be consistent about generics and casting? (always use Class<?>)\n. I think there's a better way to structure this code that allows us to use codegen rather than reflection in a few cases. Instead of this code in the if clause, use this instead:\nseedAdapters[s++] = plugin.getModuleAdapter((Class<?>) module, null);\nThe arguments to getModuleAdapter are the class we want, and optionally an instance of that class. Or at least that's what they used to be before the big plugin refactor. That way we can call getModuleAdapter when we have a module instance (as passed to ObjectGraph.create) and also when we don't (as in an includes clause of @Module).\nThis way we end up using ModuleAdapter#newModule to create instances which may end up calling codegen.\n. It was incorrectly asking me to name my stateful static final Logger instance LOGGER. I prefer to reserve CONSTANT_CASE for constants, and try as they might, loggers aren't constants.\n. terms, addends or summands. I think those are all worse.\n. Fixed, though I don't think it's better. I did a quick search and it's weird: implementation details LOVE 'we', but most documentation avoids it. But you can find uses in careful libraries with Guava and java.util.concurrent if you have the right regex.\n. Done.\n. Yup. Root is the ObjectGraph that has no base.\n. Done.\n* <p>The current graph is not modified by this operation: its objects and the\n * dependency links between them are unchanged. But this graph's objects may\n * be shared by both graphs. For example, the singletons of this graph may be\n * injected and used by the returned graph.\n. Mostly to make it look like a conventional for loop over a linked list.\nAlso (but very minor), this if break was unnecessary on the first step of the loop.\n. I use AssertionError to indicate problems that I believe are impossible. If I could write a (reasonable) test case for it, then it wouldn't be an AssertionError, but something weaker like an IllegalStateException.\n. (I added this 'cause we're relying on non-local behavior, and if this broke the problem would be very non-obvious!)\n. Yeah, I could go either way on that. As-is we call newModule in one place only which I like.\n. Oh, I forgot about that too! That wasn't even the motivation; I added this so we could let the original exception fly if it was the last step of the loop.\n. Yup. And in the best case we never log anything.\n. I don't think so. If setAccessible(true) fails, we get a SecurityException. If it doesn't fail, then the IllegalAccessException is impossible.\nAs an aside, I don't like security managers. They don't provide security and they add friction to regular trusted programs. Applets are dead, and we should shovel as much dirt on top of their coffin as quickly as we can.\n. I think it's a you-ain't-gonna-need-it situation. Logging when codegen isn't working is good information; it tells you that you aren't as fast as you should be. But this should also be FINE, 'cause it's doesn't harm behavior. If we ever want to rip out the reflection path altogether, we might have a different story. For now we need the reflection path for superclasses that get compiled independently from dagger.\nWhen we fail, one exception should be enough!\n. Leaving for later!\n. The only thing we're doing is exploding in Linker.linkRequested() when no lock is held. That's what caught this problem.\n. neat\n. Awesome\n. We do, and it fails, but with a NullPointerException instead of an IllegalStateException.\n. Nope. It means that validate() doesn't explode because this method isn't overridden!\n. Perhaps this should be a comment // instead of a log? I doubt users care\n. similarly, this should be a comment\n. What happens if env.processingOver() occurs on the first call?\n. Can't the results of getElementsAnnotatedWith() change between the first cycle and the last cycle? Shouldn't we only ask this at the very end? Otherwise generated modules could be missed?\n. huh? why the twoString in here? This seems more complicated than it needs to be. Can't you just treat e as element and skip this entire loop completely?\n. why final ? If it isn't necessary, it shouldn't be used. (Overzealous use of keywords is one of the things driving developers away from Java and towards less wordy languages!)\n. Are these strings so that they survive across passes?\n. Is this step necessary? Or do we get the same results as from getInjectedClasses ?\n. log --> comment\n. Will we ever rediscover this class when we call getInjectedClasses?\n. Why is this static? Static is not good, not good at all. What happens with ant, when the compiler is executed multiple times in the same process?\n. nit: remains invalid --> is invalidated\n. nit: always use LinkedHashSet, never use HashSet. Nothing is worse than having a bug that won't reproduce because it only fails if the iteration order is just so.\n. why is this necessary?\n. nit: always use LinkedHashSet, never use HashSet. Nothing is worse than having a bug that won't reproduce because it only fails if the iteration order is just so.\n. nit: always use LinkedHashSet, never use HashSet. Nothing is worse than having a bug that won't reproduce because it only fails if the iteration order is just so.\n. HS --> LHS\n. nit: toString() is unnecessary with %s\n. It's a bit weird to keep two different sets around that both do the same thing: injectedClasses and delayedInjectedClasses. Could you change this so that you only use delayedInjectedClasses? You'd be able to remove this loop....\n. ... and this loop would iterate over delayedInjectedClasses. Instead of going from type to string in the first step, it would do the opposite: ask the processing env for the type from the string.\nAnd as an extra bonus, removal is way more straightforward. Your loop would look like this:\nfor (Iterator<String> i = delayedInjectedClasses.iterator(); i.hasNext(); ) {\n  String injectedClassName = i.next();\n  InjectedClass injectedClass = getInjectedClass(...);\n  ....\n  if (!missingDependentClasses) {\n    writeInjectionsForClass(injectedClass);\n    i.remove();\n  }\n}\nThis way you're removing from the set you're iterating, as your'e iterating it. Seems structurally simpler than two sets.\n. nit: size() > 0 --> !...isEmpty()\nPrefer isEmpty() wherever you can; in some collections it's way faster (for example, ConcurrentHashMap)\n. remove this unnecessary doc.\n. Rather than saying \"Check that\" and then later using @returns, you can make the behavior more explicit and shorter by documenting this as Returns true if ...\nMy rule is that if a method has no side effects, it's documentation starts with Returns ...\n. nit: nuke this empty line\n. HM --> LHM\n. Is there a way you can do the same trick? One loop instead of two, and one collection instead of two?\n. nit: toString() isn't necessary with %s\n. nice\n. don't bother with the constant, it's easier to read as just \"<\"\n. Just use CodeGen#rawTypeToString ?\n. Maybe that won't work, that assumes you're passing in a DeclaredType. This method should definitely take a TypeElement or a TypeMirror and do the work on that . . .  hide all of the string manipulation in one place.\nYou can probably do this without string manipulation by asking for the raw type of the parameterized type. See the visitor in typeToString for an example.\n. stringified? you can just say \"Returns a type name\". No need to make up words!\n. Just curious . . . any idea if this works for lookups in the processing env?\n. should this throw? seems like we'd get an empty string in this case and that isn't what we want\n. are you sure the component type's 'toString()' is going to be reasonable? What about exotic types like ArrayList<String>[]\n. should this throw?\n. How is this method different from dagger.internal.codegen.CodeGen#rawTypeToString ?\n. arbitrary text?\n. Perhaps instead of a List, this should take a single String that may include newline characters? I think that's a more natural way to express a multiline string.\n. huh?\n. is the field_ prefix really necessary? It might be better to just use the simple name straight up (and special case keywords like 'default' if they exist)\n. this is broken for classes like \"java.util.regex.Pattern\"\n. Not completely in love with the extra 'emit' prefixes. . . . it's less DSLey\n. ... though I do like the fact that it's the same pattern for keywords like 'import' as for non-keywords\n. .... ahhh. I see what you're doing here. Don't like the /* singleton */ comment, eh?\n. Is it much code to omit the prefixes unless they're necessary? That would yield the most readable output.\n. Please don't get carried away building a Java-code-generation infrastructure. Dagger's job is dependency injection. We don't want to dedicate a bunch of classes to code generation; that's yak shaving territory. What you have here is a good balance: it's readable code but we don't have a ton of complexity on the code generator end.\n. I have an internal branch of JavaWriter that uses strings with newlines. It works pretty well.\n. I don't think these method docs adds much value. It's rarely useful to document @Override methods; the documentation belongs on the base declaration. Especially since this documentation is repeated everywhere, which I find kind of gross.\n. dig\n. Done?\n. Space after // ? So it prints\n// Generated by Dagger.\nrather than\n//Generated by Dagger.\n. Done?\n. Sounds good.\n. Okay, sounds good. The primary problem with duplication is duplicated maintenance, but that doesn't apply here.\n. Done?\n. neat\n. nit: this doc is barely useful\n. why not check if the names actually intersect?\n. \"Do not edit\" ?\n. this is somewhat sloppy! Is it always necessary? Why is the variable called hasFields when it might not?\n. The static import here is surprising, but I'm okay with it\n. rename IS_A_SINGLETON to SINGLETON and NOT_SINGLETON? The 'A' is not very enumish\n. Off topic: we could totally cheat and make requestBinding return whatever type you want it to. Like this:\n T requestBinding(String name, Object requiredBy) { ... }\nIt's a disservice to type safety, but it avoids a lot of ugly casts. Not sure.\n. Otherwise add @SuppressWarnings(\"unsafe\") to the class?\n. Perhaps the static utility class should return the Javadocs rather than writing it to writer for you? Seems more composey\n. Perhaps another case for your shared Javadoc utility?\n. nit: the toString is unnecessary.\n. I don't get this. And why is dagger.internal mentioned here? I'd prefer for JavaWriter to be dagger-independent if at all possible. I don't think this part of your change is worthwhile: it's too clumsy!\n. No. This is too hacky, even for my tastes. What's the motivation? Couldn't you just always import List and Set?\n. What does asList do here?\n. Can comment be multiline?\n. Delete this doc. Please.\n. Yeah, I think these would all be better if they returned strings rather than taking a JavaWriter. And more testable, if that matters!\nCould you rename the class from ProcessorJavadocUtils to ProcessorJavadocs ? Utils doesn't carry its weight.\n. Test for a // comment?\n. This test would be more cleverer if it required you to import Set.class first.\n. Inline this?\n. Sounds good.\n. toString unnecessary?\n. The boolean is called hasFields but the code that calls this uses \"hasFields || supertype != null\". Why not just name the boolean \"importMembersInjector\"\n. Sorry, I guess I was thinking of your Javadoc utils class being more like a \"Documentation\" class. In this case, the string \"Code generated by dagger-compiler\" is duplicated. And since it's duplicated, we could easily accidentally forget to add something like, \"Do not edit\" each time this string occurs.\n. Alrightey. It's a fine line I'm asking you to balance, and I can't have my cake and eat it too.\n. Noo, emitRawText is the beginning of the end. As-is is fine.\n. I still don't understand how this works. How does it compress a name like say \"java.util.Vector\" if that isn't in my imports? Shouldn't this just use the imports rather than this chain of if/else calls?\n. This is broken if value contains \". We should require the caller to use JavaWriter.stringLiteral() to escape value and wrap it in double quotes, and then this code here should use annotationValue().\n. Delete this doc or correct it!\n. Fixed.\n. Nit: if you're going through the trouble of writing this comment, might as well toss it into the exception?\n. Similarly.\n. Similarly\n. wow\n. nit: bump the year?\n. is it worth the hassle of supporting a throws clause if the thrown type is unchecked? Like throws IllegalArgumentException ? I don't think it's worth the hassle (and developers shouldn't be doing that anyway)\n. Use %s and varargs rather than string concatenation?\n. Ah, you're right. It used to be varargs and we changed it. My bad!\n. Sure. You could add a 2nd @Provides method and confirm that it doesn't trigger any errors.\n. skip writing the dot file if the graph has a cycle? Otherwise it'll fail anyway\n. aren't these booleans independent?\n. Clearly the current way @Module is handled is bogus. But I think we should fix this with a big change and not an incremental one. Perhaps we should start by searching for @Module, rather than starting by searching for @Provides ?\n- Look up all types annotated @Module. Generate full module adapters for these, including looking for @Provides methods contained within the type.\n- As an error checking step, also look up all methods annotated @Provides. If the method's declaring type isn't annotated @Module, report an error.\n. nit: capitalize and period, and space after // Singleton.\n. Link? Or issue? Not sure how useful the comment is going forward.\n. Ahh, that's unfortunate. I naively assumed it was per-processor not per-annotation.\nShould we just fold FullGraphProcessor into this? That way there's no invisible assumptions between the two annotation processors.\n. nit: we're trying to encourage a universal convention where this method is called 'provideA' ...\n. why assertNotNull? Plus never returns null. I think you just want a comment like // this shouldn't throw ? Or even better, exercise B as an entry point?\n. what what? When did we add addsTo ?\n. Just reading it, getting refreshed. I don't think this is asserting what it should be asserting.\nThere are no rules around modules requiring no-args constructors. Users can always pass an instance of a module, in both the extending-a-graph case and the includes case. I think this doc change is more confusing than useful.\nJust say, \"pass an instance of modelClass or give it a public no-args constructor\" ?\n. nice\n. Re-read this. Sorry I'm so confused. I think it's all good except you should drop the 'If this was ...' sentence, which really threw me off.\n. We can change the convention, but we should do it deliberately. I like having a convention because it means there's one fewer thing to think about when writing an @Provides method. (It's also greppable)\n. Don't forget to annotate the test with @RunWith() for cgruber!\n. I think you need a .isTrue() here\n. Just a Question: does Eclipse warn on the unused parameter here? Seems weird to warn on an unused parameter for an overridable method.\n. The code above is correct, but this should remain as 'throw new AssertionError()'. We won't ever see an IllegalAccessException unless we're run in an applet sandbox, which we explicitly don't support.\n. @RunWith\n. Not necessary\n. Not necessary\n. Never use HashMap. Always use LinkedHashMap.\n. nit: wrap +4\n. I don't think these interfaces add much for the example. (They'd be useful in real code, but this is an example).\n. Same. Not necessary for an example.\n. Not necessary. This is definitely not serializable.\n. Do we need this and FooServlet? Home come these servlets don't inject anything?\n. Yeah, one should be sufficient. You want your example to be as small as possible\n. Nope, this message is used for both overrides and non-overrides. Your fix needs to consult the 'overrides' boolean above.\n. Use 'this' as a lock? Allocation isn't cheap on Android!\n. Just use this ?\n. PERCALE ?\n. FIRST_VALUE seems redundant . . . \n. Huh? No, if the application developer synchronizes on the Lazy, then they get the locking behavior they want. You're arguing from a JVM-developer's perspective but this isn't a JVM-only project. That's Guice!\n. Doesn't matter. Mutex leaks aren't a real problem in practice. Slow object allocation is a real problem on Android.\n. Whatever floats yer boat!\n. Thanks\n. Neat. When I wrote a test like this I used the names Rock, Scissors, Paper to hint the circularity.\n. LinkedList? \n. Use the same message syntax as ProblemDetector?\nDependency cycle:\n    0. dagger.ProblemDetectorTest$Rock bound by dagger.ProblemDetectorTest$Rock\n    1. dagger.ProblemDetectorTest$Scissors bound by dagger.ProblemDetectorTest$Scissors\n    2. dagger.ProblemDetectorTest$Paper bound by dagger.ProblemDetectorTest$Paper\n    0. dagger.ProblemDetectorTest$Rock\n. Just use IllegalStateException? Fewer types is more daggerey\n. where's the corresponding pop?\n. Use the traditional iterator for loop syntax?\nfor (Iterator<String> i = path.descendingIterator(); i.hasNext(); ) {\n    String pathElement = i.next();\n    ...\n  }\nThe benefit of this approach is that the local variable pathIterator is confined to the scope of the loop. So that if you have two for loops over the same list, you don't need to redefine a variable (gross) or use synonym names (pathIterator2)\n. You probably want a test to prove this case doesn't false positive:\nModule D includes module F\nModule E includes module F\nmodule F includes nothing\n. nice ctach\n. Awww, this is unfortunate. We need a workaround in our example?\n. Sounds good to me.\n. I wouldn't waste too much effort or special cases on self-inclusion. Normal people won't do that!\n. Gotcha. In that case, make ModuleValidationException a top-level type and use it exclusively within the compiler?\n. (That's okay for a follow-up. I'm just opposed to mixing exception types, since this looks quite nasty:\n} catch (ModuleValidationException e) {\n        error(\"Graph validation failed: \" + e.getMessage(), e.source);\n        continue;\n       } catch (IllegalStateException e) {\n. swoon\n. (that means, this is awesome)\n. I'm assuming you're just eliding the other four links in the chain?\n. For foolish consistency (and to eliminate duplicated code) we should use ModuleValidationException everywhere\n. Sorry, Deque is Java 6 only. Not on Froyo!\n. ... although this only impacts javac. Keep it.\n. ... and that means you can kill LinkedList for the far faster and far superior ArrayDeque\n. I'm merging it! The += isn't so harmful when it only happens if the compiler is about to error out.\n. Huh? Doesn't this disagree with your comment?\n\nNote: runtime exception-throwing for @Inject-annotated methods isn't supported or tested. This would require looping through all declared methods just to throw an exception or do nothing. Didn't seem worth it.\n. ... or is it just a compile-time check?\n. swap the two checks? Otherwise it won't make sense if a private method is @Inject-annotated.\n. yup.\n. add a fail() on the following line?\n. similarly\n. Yup. But flipping the logic is good.\n. Push your changes?\n. Mind doing the busywork to get the full stacktrace string for e ? Otherwise NullPointerExceptions will be brutal to diagnose.\n\nPastable snippet in answer 2 here:\nhttp://stackoverflow.com/questions/1149703/stacktrace-to-string-in-java\n. LinkedList is slower than ArrayDeque in all cases. Never use it.\n. Sounds good.\n. Do we want this behavior for ObjectGraph.get calls?\n. Still in the test case?\n. Disagree!\n. You don't need the main method at all here. You should get rid of it, and run() and implements Runnable(). Heck, you could make TestModule the only class in this test!\n. hmmm . . . this message isn't very useful. Could you somehow tell me the method that is unused? Like TestModule.string() ?\n. Similarly, please remove all of the unused stuff here.\n. Nit: please avoid reformatting\n. nit: ignoreCompletenessError -> ignoreCompletenessErrors\n. Remove this necessary stuff?\n. avoid reformatting code please\n. avoid reformatting code please\n. (If you want to reformat the code, you can. Just do it in a separate PR)\n. (Only for providerMethodBindings anyway, I don't think we have the necessary=true tag on the annotation anymore)\n. can you nuke one of these? They seem redundant\n. Too many overloads. Can you inline all callers of this one? (So you get either minimal options or maximal options, but never 3)\n. And now I'm understanding. Could you replace the word 'necessary' with 'library' ?\n. Ahhh, I understand again. Could you use the word 'library' instead of the word 'necessary' ?\n. I assume we can safely cast these to ProviderMethodBinding ?\n. (which will allow you to get the offending method out)\n. fix formatting\n. Nice\n. my favorite\n. rename e to expected\n. I don't understand this test\n. Not that it matters, but == is sufficient for Class objects.\n. Never mind!\n. Sweet\n. directly is a bit of a lie. Indirectly used bindings are okay, as long as it's indirectly via the module's entry points. English is hard.\nShould we describe any of this as graphs? \n. Should we mention that this is intended to help to detect dead code?\n. nit: copyright\n. nit: 2013\n. simple name collisions make me nervous. ForActivity ? \n. We may want to just make this a part of dagger (for some later release)\n. Similarly\n. this is sweet\n. nit: copyright statements on all of these files?\n. Also check that the field is static.\n. This was the bug. We were looking up the constructor even if we didn't find any @Inject-annotated fields.\n. What's your changes?\n. nit: why +4?\n. Going forward, please please avoid mixing refactoring changes (touch lots of files, no behavior change) with behavior changes. Makes code review much easier.\n. For what it's worth, I think this is a dumb check.\n. cl --> classLoader\nWe aren't barbarians\n. loader --> classLoader\nDagger has loaders, they are different things.\n. For what it's worth, in the VM it makes some sense. There's a cyclic dependency between creating say Class.class and creating its class loader\n. delete this line\n. Silly question: what happens to code that was generated with the old set of arguments? Can you add an overload for those guys?\n. nit classloader --> classLoader\n. No. If the cl is null, you do not want the context class loader. Instead you probably want ClassLoader.getSystemClassLoader(). \n. Sounds good.\n. should this just be getClass().getClassLoader() ?\n. similarly\n. similarly\n. one cl didn't get fixed\n. cl\n. oh, I think we have a bug. Should supertypeBinding show up in getDependencies? I think that's a bug\n. I'll open a tracking bug for this: https://github.com/square/dagger/issues/274\n. Sure. It's just inconsistent with the rest of the code that prefers getClass(). (The cost of the method call is negligible, since this will be inlined very early.)\n. I wonder if we should be more aggressive about these. There's a lot of opportunities for misplaced annotations . . . @Named without @Inject, etc, and we aren't catching them.\n. sp. generated\n. nit: it's my personal style preference, but I much prefer instance != null ? instance : result.newModule() rather than the flipped case you have here.\n. log or throw. Don't do both.\n. log or throw. Don't do both.\n. and again.\n. Nice.\n. sp. adapter\n. curious\n. supernit: 2013!\n. again\n. and one more: space before {. (I don't think our checkstyle catches these)\n. space around the = operator\n. The EnumSet.of() check is cute, but it's criminally inefficient. Simpler is to either make that enum set a constant (so we don't need an allocation every time we check this condition) or just do an or check:\nif ((provides.type() == SET || provides.type == SET_VALUES) ...\nThat's my preference.\n. Wanna add a test that checks that we still let you @Provides a Set without multibindings? When I read this the first time I was confused 'cause I thought you were making that illegal!\n. I would have expected this to fail because the Set has a conflicting definition. From the root it's an empty set, but in the extended graph it contains a string. These two shouldn't disagree!\n. No, the problem is that the root graph should be immutable. By extending it you're mutating it. That's no good.\n. I don't think this is a new problem in your code, it's just a problem where we never really thought through this combination of features. The right behavior is to restrict set contributions to a single graph. You can't add to a graph from an extension! If you really want that, you can fake it with qualifier annotations.\n. This is puzzling. Did it start out as our LruCache?\n. +1 to Jake's comment.\n. Could this be WeakHashMap<ClassLoader, LruCache<String, Class<?>> Might be simpler since LruCache can be a computing cache.\n. Is map.get safe during concurrent writes?\n. It probably isn't on Android; we definitely didn't design for that.\n. Add a comment, // Negative cache\n. Again, I don't think this is safe during concurrent writes\n. final, and with a private no-args constructor\n. Why 500? Just to not grow unbounded? I worry about a program with 501 classes churning\n. nit: class loader is two words\n. A curious change\n. 2013\n. yuck\n. This test is weird. It makes the production code more complicated (by exposing more API) and it doesn't actually catch the real race conditions in the code. What kind of regression will this catch?\n. Crazy. Never seen assumeTrue before.\n. This should use the declared return type, not the instance type. Otherwise you can't use multibindings to create a Set<Set<String>>. \n. <p> ?\n. Huh? I have a feeling the weak reference might be useless here. The map's value strongly holds a reference to the key. That will prevent it from being collected, right?\n. (There's an easy fix. Use strong references, and make ClassLoaderCache a member of ObjectGraph rather than a static singleton.)\n. Read/Write locks are almost always a bad idea for performance. Just use synchronized?\n. Obsolete comment\n. Sorry, I must have misspoken previously when I endorsed read/write locks. I don't think they're appropriate here.\nRead/Write locks are expensive to acquire and release. They're appropriate when the guarded resources are blocking or slow, like a socket or file. In such cases the time spent accessing the resource dwarfs the time spent acquiring a lock.\nSynchronized is more faster to acquire and release. It's appropriate when the guarded resource is very fast, like an in-memory data structure.\n. I don't think the current design permits classes to be unloaded. There's a chain of strong references from the static singleton to the class in the cache, which should prevent the weak key from being effective.\nJust switch it from a WeakHashMap to a LinkedHashMap and give up on unloading? Or move the cache to ObjectGraph and let that be the unit of unloading?\nNote that extension graphs can share a cache with their parent graph, decreasing the cost of throwaway child graphs.\n. I don't think there will be contention. The amount of work performed while holding the lock is trivial, particularly once the loading is all done.\n. Each loader gets its own cache? So if I use both reflection and failover loaders I get two? That's okay.\n. label on its own line?\n. nit: please don't change line wrapping on the license header.\n. nit ;;\n. nit: this Javadoc is invalid. You can't start a line with an @ character, it'll be interpreted like @Param. Fix by encasing in {@code }.\n. HashMap --> LinkedHashMap.\nAlways.\n. invert this condition and save a level of indentation?\n. nit: excessive whitespace\n. You could also move this to our TypeUtils class. Though this isn't strictly a type util. In which case you're welcome to rename that class to Util.\n. why the create prefix? It's a pure function; it doesn't matter if it's create or get so I recommend just leaving the prefix off\n. (create also sounds like it has side effects)\n. strange to return an array here...\n. ahh, I assume it's for varargs. Guess that's okay.\n. why getCanonicalName ? I think getName should work just as fine here?\n. nit: this wrapping is weird\n. Delete the snarky comment. Possibly also combine lines 382 and 381 and save a line of code?\n. The calls should be identical. Prefer getName().\n. For classes like int[] the canonical name is strictly better for source generation. I'm wrong. Let's use getCanonicalName() exclusively.\n. (if the class isn't an array, the two names are identical.)\n. Sorry, I didn't comment on that sooner. I'll post my thoughts there.\n. Yeah, sorry to misblame you for the snarky comment. Delete it anyway, it's embarrassing.\n. (I think findImports is a fine name here)\n. ... though here I think find lacks context. I would have preferred implementedInterfaces. With find I ask \"interfaces for what?\"\n. Not for this change, but I think this might work better as a method on JavaWriter. It knows what's imported and you could ask it to give you a name for a class.\n. It's fine.\n. It's fine.\n. Just inline all of these? As-is this code is less readable, less maintainable and suggests we should un-deprecate the old APIs.\n. Would this work better as withErrors(Error...) ? As-is it doesn't fail if there are additional unexpected errors.\n. If you replace this:\nJoiner.on(\"\\n\").join(\n       \"import dagger.Module;\",\n       \"import javax.inject.Singleton;\",\n       \"class Test {\",\n       \"  @Module(library = true, injects = { AbstractClass.class, Interface.class })\",\n       \"  class TestModule { }\",\n       \"  @Singleton abstract class AbstractClass { }\",\n       \"  @Singleton interface Interface { }\",\nWith this:\n\"\"\n       + \"import dagger.Module;\\n\"\n       + \"import javax.inject.Singleton;\\n\"\n       + \"class Test {\\n\"\n       + \"  @Module(library = true, injects = { AbstractClass.class, Interface.class })\\n\"\n       + \"  class TestModule { }\\n\"\n       + \"  @Singleton abstract class AbstractClass { }\\n\"\n       + \"  @Singleton interface Interface { }\\n\"\nYou don't need Guava. As-is you're depending on Guava but not importing it in Maven!\n. +1\n. Nice\n. Nice\n. Yes!\n. nit: put the success cases up top?\n. Seems like a javac bug\n. +1 for never using a non-Linked hash map.\n. Looks like it's derived from LruCache.\n. The read lock is sufficient. The synchronized is a copy/paste error from LruCache.\n. There are no allocation differences between LinkedHashMap and HashMap. The problem with ordering requirements is that they don't necessarily exist on day one. But when they do appear, it's much nicer to have a LinkedHashMap over a HashMap.\nAnd even if you don't have ordering requirements, occasionally you'll be looking at this code in a debugger, or calling toString() and it's handy to have predictability.\n. This is pretty loose. I suspect there's a better way.\n. did you reformat this file? This isn't consistent with our style rules.\n. What's this for?!\n. Please follow our (strict!) style guide here:\nhttps://github.com/square/java-code-styles\n. Please don't add new public APIs!\n. Please don't add new public APIs!\n. Please don't add new public APIs!\n. no \\n ?\n. \\n ?\n. \\n ?\n. ",
    "xaviershay": "I'll go over your README for you before releasing this, let me know when it's ready for me to have a look.\n. ",
    "pforhan": "LGTM.\n. Was this your 'initial' commit you were talking about, before the improvements we discussed?\n. Generally, I like include better than children.  It captures the intent correctly.  @swankjesse?\nIf it goes through, we could probably just dump the @Deprecated stuff.  Compiler errors will force an update.\nI'd recommend squarshing commits down for clarity.\n. Interesting idea.  I ran into almost this situation (a list/set of the same object type), though I ended up needing per-element behavior.\nIs there a good use case here?  I suppose if your set of objects is large enough, it could be handy, but for small collections, wouldn't it be more straightforward to just @Provide Set<Thingy> where you do it all in one method?\n. Can you add a unit test that verifies this change?\n. Are you instantiating one of these directly, or are you subclassing?  And this almost looks like you are using Dagger to construct an activity, which flies in the face of Android...\n. Generally, something must have an @Inject in it somewhere to function.  However, it does not need that for super classes.  \nWhat you have looks pretty good.  @swankjesse, any thoughts?\nAnd just a sanity check, you're not @Injecting an activity anywhere, are you?\n. @cgruber FYI, in the 3rd comment, he shows an @Inject Store myStore; member in his activity class.\n. @cgruber, did you ever look at this again?  The way I understand it, this wasn't about annotations on super classes, it was a confusing message Dagger was giving out about a library superclass -- @Inject was in the subclass, but Dagger was complaining that the super class didn't have any @Injected members.\nWe do this with no issue (even the extending of SherlockFragmentActivity), but I don't know if there is some magic combination that @luisdelarosa is hitting upon.\n. LGTM.  Let's do it.\n. In the case where I encountered this, it was easy enough to work around.  All I ask for is that if it compiles, it will run.  This was compiling but failing at runtime.\n. A test case that reproduces the problem (and demonstrates the fix) would be cool.\n. In simple terms: Make a branch off this one.  It will be a copy with your other commits.  Come back to this branch, then git rebase -i master and remove the commits you don't want.  You will have to force-push this branch to update it, but after a few seconds github will reflect just the commits you wanted.\nNote: make sure you have push.default set to tracking (or matching is a synonym, I think).  Add this to your ~/.gitconfig:\n[push]\n    default = tracking\n. (of course, there are a hundred other ways to do it, this is git we're talking about)\n. Pretty-please, next time do a summary line, two carriage returns, then details.  That's a monster commit summary!\n. We need to push this to a branch, right?\n. Now, you can still have this blow up your app, if you throw a RuntimeException from the catch block...\n. @cgruber Try adding ?w=1 to the end of the url in these cases.  It'd be nice if GH provided a handy checkbox for this, but at least it's something.\nhttps://github.com/square/dagger/pull/173/files?w=1\n. LGTM.\nHaven't heard \"far JAR\" as a term before.\n. LGTM\n. @JakeWharton @swankjesse what do you guys think? \n. Based on the integration tests and building our own app, no, you don't have to add it.  A quick search reveals no references to guava in code at all.  I'll update the pull.\n. Thanks, @tbroyer I like this much better.\n. Ah, well, too bad, then.  We should definitely use only what we need from guava, not (what I presume is) the mega-jar.\n. Just to clarify, here was the problem module:\njava\n  @dagger.Module(injects = {\n      LandingView.class\n  })\n  public static class Module {\n  }\nThe error message needs to give some sort of hint about how to fix the problem.  Does it ever make sense to put an interface up there?\n. Dagger has no way of knowing what classes implement interfaces.  Even guice requires you provide the class object.\n. You probably want to file this on dagger 2 at https://github.com/google/dagger. Did you mean to define this method in two places?\n. ",
    "cgruber": "I should also confirm that the codegen approach \"just works\" with Lazy.  I'll dig around a bit. \n. Heh.  That's ok.  I need to get used to project norms. \nAlso... with respect to flattening... do you want me to flatten after the pull request review has started? I'm worried about backing out comments by accident because the actual edit won't be there.  Or should I just flatten the baseline for the pull request, and then subsequent pushes to address changes are individual?\n. As to none the wiser, you can see all the commits that are on this branch above under the \"commits\" tab.  However, per our discussion, howsabout the final review step is I flatten it all with a rebase with squash into a single commit, you give that a once-over and if you like, you merge?\n. Maybe.  I wouldn't mind a \"complex example\" that amounted to an in-code tutorial.  Or instead of \"example\" have \"examples/basic-injection\" \"examples/lazy-objects\" etc.  Either way, we can save this for that.  But I'll update the README for this regardless.   \nOn Friday, August 31, 2012 at 2:12 PM, swankjesse wrote:\n\nHmm.... it has been my (non-obvious) intention to keep the example very minimal. I wasn't intending for it to exercise all of ObjectGraph's features; rather it was supposed to show you what it looks like in a real app.\nPerhaps it would be better to remove this from the example app and add it to the one-page project readme? That guide shows some hypothetical changes to the example app to demonstrate features of interest.\n\u2014\nReply to this email directly or view it on GitHub (https://github.com/square/objectgraph/pull/19#issuecomment-8200485).\n. Oh - just saw the mail for jesse's comment... didn't get notified that the code went in. \n. Ping\n. Crap - formatter screwed on this machine.  I'm closing this and I'll re-format tomorrow and re-push so everything isn't borked.\n. This is basically a proposal, though one in code.  Child modules are a misleading term, since they're not really children, except in the sense of a tree uses the parent/child metaphor.  But as metaphors, the \"includes\" notion of composition from header files is clearer as to intent. \n. Ping\n. Cool - I'm happy to dump the deprecated stuff - it was to at least keep a clean build for you guys, though you could update when you update your deps.  \n\nAs to squash, my agreement with Jesse is that during review, I just push more change, but hte final step is a rebase with squash so the final commit is a single commit.  As in, don't merge until I've done the squash and said \"ready\" more or less.\n. So... @pforhan, @swankjesse - what say you... kill the backward compatibility and just get it done?  I just didn't want to make that burden on your in-production implementations, but if you feel fine about doing a bulk change on a deps change, I can definitely simplify this change.\n. Got it.  Done - flattened.  As to backward compatibility... I think that even once we're not worrying about square, we still will not want to make breaking changes to users unless there's a killer pay-off, so I'm hoping we can get all these right early, hash it out, and make it so that anything like this is quite seldom. \n. Ok... I'm getting annoyed with Github interpreting my @ symbols even in commit messages.  Grr.\n. Thanks Jake!  I'll do that in future. \n. Ok... fixed singleton behaviour.  I don't love the way we use a   ... wrapper ... for this, but it works.  I have a better solution in mind, but I'll work up some code on it later.\n. This gets used in guice quite a bit, where different values are contributed\nto the set (or map) from multiple modules.  It can be used in plugin\narchitectures riding on top of a managed object space like this. It can be\nused for creating command-line flag bindings, or a number of other uses.\n How it'll work with purely declarative modules is unclear yet.  It may be\nthat it's less useful in object graph than in guice vs. binding a set.\nMy current thought is that a use case I have for a broadcasting logger is\nuseful insofar as I can have a null logger as a default but modules could\ncontribute log sinks.  That would be hard to do with binding a set because\nthe set shouldn't be mutable by modules.  Or that would be bad form if not\nextremely regular. And the graph/moduleadapter can impose that regularity.\nOn Sep 16, 2012, at 20:10, Patrick Forhan notifications@github.com wrote:\nInteresting idea. I ran into almost this situation (a list/set of the same\nobject type), though I ended up needing per-element behavior.\nIs there a good use case here? I suppose if your set of objects is large\nenough, it could be handy, but for small collections, wouldn't it be more\nstraightforward to just @Provide Set where you do it all in one\nmethod?\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/square/objectgraph/pull/24#issuecomment-8603513.\n. Ugh. I didn't deliberately close this.  Argh.  I was working with command-line git and merged in master into my change and github interpreted it as a closed pull request.  Lame.  I'll make a new pull request.\n. Ugh.  So github misinterpreted my branch-jostling to re-base after merging all the renames in, and it closed the previous pull request.  Here's the whole thing squashed and re-based properly.\n. Anyone?  Bueller? ;)\n. Definitely will let you know about scoping - I'll definitely not merge such a CL without showing you, and moreso, without having the code-gen integration tests in place and testing these cases.\n. Flattened and ready for merge. \n. dagger-discuss@googlegroups.com is up. \nAs to eclipse - if you use Eclipse, you can get integration with maven via M2E.  I use Dagger in eclipse.  M2E allows me to have eclipse auto-configure for most if not all of my maven plugins.  \nHaving said that, I'll be getting a proper maven plugin (that M2E will seamlessly invoke) to separate out code-generation so it's a bit easier to work with in eclipse, provides separate source locations for code-gen on a different lifecycle. \n. Also, dagger-announce@googlegroups.com is up.\n. Not at all.  M2E configures eclipse and eclipse plugins to work with the maven lifecycle.  If you have the appropriate maven plugins in your pom.xml files, then m2e will auto-configure any equivalent eclipse plugins that are there (if m2e adapters are present).\nBut regardless, you can always take projects which are configured by m2e (which would just be java projects) and add project natures. I don't think the square folks use eclipse, so they might not be able to help as much, but if Jesse whips up a mini android maven project, I can make sure it works in eclipse, and throw down some basic instructions.\nAlso, there is now a G+ page. \n. Sorry - I have things on \"approve initial posts\" but I have been ill, \nand haven't been moderating consistently. Jesse's also a moderator now, \nand I'll be better about keeping on it next week.\nglenviewjeff wrote:\n\nI think I made a post on there that wasn't approved--is someone \nmoderating the group?\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/square/dagger/issues/32#issuecomment-9080426\n. Thanks for doing this. I was going to do this after getting the build\nbased tests in, but this is awesome.\n. I don think a set binder does provide both in Guice.  You add a\nbinding to the set binder, but if you did have simple bindings you'd\nend up with duplicates unless they were each qualified.\n\nThanks for taking care if this.  Once I get the build-based tests in\nplace this sort of thing will show up on any change of logic.  Sorry I\nmissed it.\n. Test it manually to make sure it plays out but I say roll forward and\nwe can as the failing test cases later this week.\n. So, I agree with this being a good thing - finding something better than @Element, but I'm wondering if we can maybe have quick discussions about pretty fundamental API naming changes.  Jesse and I talked through @Element for quite some time and this rename seemed to come out of the blue.  Also, if this is @OneOf - any recommendations on what the map-binding case should be?  Or the multiple set entries option Jesse and I discussed.  @SeveralOf perhaps?\n. I'm going to be building an eclipse plugin that pulls the code-gen into \na separate phase, as well as things like full graph processor which M2E \nwill be able to properly configure within eclipse. Not there yet.\nc.\nPierre-Yves Ricau wrote:\n\nI took the CoffeeModule example and added a random :\njava\n@Inject\nString someString;\nThe FullGraphProcessor reported an error when started from Maven. \nHowever, it didn't report any error when started from Eclipse. It \nactually runs but no error so far.\nI'll try to put some breakpoints in it when I have time.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/square/dagger/issues/45\n. There's not just annotation pre-processing involved, but also other \nthings like a graph validation pass, etc. Maybe these can still all work \n- I still need to build some plugins for various build systems so these \n  can be fully baked into the build process. Still under investigation.\n\nChristian.\nStephen Haberman wrote:\n\n\nI'm going to be building an eclipse plugin that pulls the code-gen\n\nJust curious, but is there something specific you'll be getting by\nbuilding an Eclipse plugin?\nI've had fine luck with running processors directly in vanilla Eclipse,\nand seems like the APT API is nicer/easier to use than a full Eclipse\nplugin.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/square/dagger/issues/45#issuecomment-9210947\n. This has been working for me for quite a while.  I'm not sure what's still missing.  :/  Not even from your comment in #126, @tbroyer.  I get errors in graph validation from chagnes using m2e and m2e-apt.\n. Hmm.  At what point are we going to ask for tests around some of this stuff? \n. Not individual files - but methods like bindingClassName\n. So, this doesn't include our discussed \"circularity allowed if and only if all circularity happens with field injection\" concept.  Right now this fails even if all of your circularity is from field injection.  Or have you backed out of wanting to support cycles?\n. I like this, though I'm inclined to rename ObjectGraph.get() to ObjectGraph.graph(), and make getInstance() .get().  At this layer (from without) an objectgraph behaves like a big map of keys to entrypoint instances.\n. I actually think we should consider separating out core abstractions - things like Lazy and annotations, so that people's client code and other frameworks that want to be compatible can have the minimum set of dependencies, then the stuff needed for the run-time, then the stuff needed for build-time.  I think that's the only worthwhile separation, but I do think it's worth it.  It certainly should reduce payloads in some cases, and increase interoperability.\n\nWe're considering an \"abstractions\" artifact on Guava so things like Dagger could use ImmutableFoo and other lightweight types that might occur in people's public APIs without being forced to use all of Guava. \n. Heh.  Fair enough.  What's the promotion process for that, and can we finalize the name for @Provides first?    (are we still thinking about @Contributes? \nRegardless, as a pre-amble to getting it in JSR-330, which I (possibly perceive as a reasonably annoying process), can we at least have a separate maven target? :) \nAnyway... getting off-topic.  We can circle-back on the dev list. \n. Ok - this is beautiful.  I like how the Linker API is shaping up.  Other than making the .dot generation optional, I'm excited about this.\n. I'm going to merge this in for now - .dot creation is still fairly low on the scale of projects we're dealing with.  We have to split off the tools anyway, and we can do some fine-tuning of what's optional or not.\n. So what's the process from here?  Effectively this pull request merge doesn't exist in this repo, correct?  And you guys are just going to pull in to your fork as you see fit?\n. I naturally approve this message. :)  Thanks for taking this attitude.\n. Can you give an example?  I'm not sure what you mean by \"generic framework code can inject\".\n. So inject() in this case is basically doing a no-op?  I can see the utility, but it feels unsafe - like someone will pass in something with no @Inject and end up not realizing until run-time that nothing happened.\nThis feels like an alternate graph implementation with different behaviour suitable for testing, to be honest.  I'm not sure this behaviour is the right one in all cases. \n. Or an injector with some configuration points with strict defaults.\n. Ah - fair point.  Ok... as long as we keep some explicit signal there and don't end up with some situation where someone can trip over it. Still less strict than I'd like, but you're right - the class is at least deliberately added.\n. Grr.  I'll fix the Travis config later today and figure out why this isn't working in Travis. \n. I'm going to close this, and do some testing on the travis-ci stuff before re-submitting this pull-request. \n. As an FYI:\ndefault is \"mvn install --quiet -DskipTests=true\"  This skips invoker execution, and also cleans the current project so that compilation is done in the \"mvn verify\" step (so compilation errors show up properly).  Also, --fail-never because a failure here is a setup failure and --quiet will suppress useful info.  So letting mvn verify go forward in a bad state will at least show symptoms of what's wrong.\nmvn verify is just adding an extra set of phases past \"test\" to catch the integration tests.\n. So this pull request doesn't include an exhaustive set of tests - it includes two examples of \"failing compilation\" tests that cannot be included in the main build, because such would cause the main build to fail.  Test projects in the /src/it folder can easily be created and are simply valid maven projects... they key \"gotcha\" being to ensure that you are using the correct dagger version in the integration test (whatever the current build is).  \nIn these tests I used a filtered property to set that version, so that it will automatically be different as new versions are incremented, but that does mean that the pom.xml is invalid prior to filtering, since @dagger.version@ isn't a valid version number, so IDEs will not be able to properly consume these little test projects.  They are, however, trivial, so should need little such ide support.\n. I was thinking it should go in CONTRIBUTIONS.md (or whatever it's called) and generally fleshing that out in another PR, though I can mod it a bit in this one.\n. So something is going wrong on this - for some reason the dot-writer is dying on travis-ci, but not on my mac.  I'm working it out - but please don't merge this PR until I get it back under control. I'll squash everything and report back here.\n. Ok - ptal.\n. Oh crap - forgot to update CONTRIBUTIONS.md. \n. Done.\n. Anything else needed on this PR before merging? \n. Note - this PR blocks the integration tests PR, since the ITs use bad wiring to test failing builds, and without this change, that breaks in the dot-writer, not in javac as expected in a failing build. \n. Crap - missing a commit. \n. So one question... should UNRESOLVED constant also override get and injectMembers?  get() feels like no, since it needs to return a valid answer, and there isn't one, since it's an unresolved binding.  But injectMembers... no op behaviour, or should we just let it all blow up when it happens? \n. Thanks.  It's not 100% where we could make it totally pluggable - but it's all been isolated now, and figuring the right way to do that (without stressing @swankjesse too much ;) can go from here.\nIn theory the code-gen and reflection run-time support could me moved entirely out, though I think we probably want to have code-gen supported in all cases at all times.  But if we do make it configurable, someone could swap an alternate code-gen and runtime without difficulty... maybe they do fancy things with code-gen and obfuscation that's worth handling differently.\nOne related question... should the minimal dependencies for client code be separated out?  I know @swankjesse was talking about moving some things into JSR-330, which I like, but there might be a number of things that are really about this approach (and maybe Guice's) that are still handy to have in a separate dependency vs. the runtime. \nDoesn't have to be this PR... just food for thought.\n. On 17 Oct 2012, at 21:32, Thomas Broyer wrote:\n\nI thought we were talking about possibly getting rid of the reflection \nbackend (fallback) in the long term. With this in mind, that change \nmakes little sense (particularly the separate codegen module).\nNot to mention that it'd completely break the test runners i'm working \non, to run the unit-tests with both reflection and codegen backends \n(unfortunately not quite ready yet, but in good shape). With those \ntests, for instance, I found that InjectionTest.GetInstanceOfArray \nfails with codegen: the ModuleAdapter being generated doesn't compile \n(method return type for the method binding's get() is Integer[] \ninstead of int[]).\n\nSo, it may be that one may use Dagger without reflection, but there are \nuse-cases that I will have to support inside google that will need \nreflection - that won't be able to use fully complete and statically \nanalyzed modules\u2026 or at least won't while they're in the longer \nprocess of re-writing. I don't want others to pay a penalty for that, \nbut I will need it.  My intention is to pull the reflection out into a \nseparate back-end that isn't loaded unless you configure Dagger to load \nit.\nHowever, as to the code-gen part, the project itself should be separate, \nelse people are bringing the code-gen tools in as part of their binary.\nYour tests depend on generating code - a tooling function, separate from \nthe run-time.  So I would argue that these aren't unit tests at all, and \nbelong where my maven invoker integration tests are anyway - in the \ncode-gen project.  Your tests should work just fine there.  Or in a \nseparate project that depends on both.\n. On 17 Oct 2012, at 21:32, Thomas Broyer wrote:\n\nI found that InjectionTest.GetInstanceOfArray fails with codegen: \nthe ModuleAdapter being generated doesn't compile (method return type \nfor the method binding's get() is Integer[] instead of int[]).\n\nHmm.  How is this related to where the codegen is?  It should generate \nthe same code, in whatever project.  That's very strange.  I didn't \nactually alter the code generation logic itself - just where it's \nlocated.\n. Ah!   It's why I wanted invoker tests.  To have the same tests\nactually expressed in a build.  But I get it.  Your framework exposed\nthe fault.  Nice!\n. > How about a secondary artifact for the same Maven project?\n\nI know it sounds like a Bad Practice\u2122 but it's not much different from what ejb does, and how Guice packages its no_aop variant (and BTW probably also how Protobuf should package its lite variant instead of using a profile)\n\nI don't like how Guice re-packages its no_aop variant, personally.  It feels like playing games with the build system, and it smells wrong.  I wouldn't look at other projects as high points of module design. :)\n\nWe'd have com.squareup:dagger:jar for the runtime and com.squareup:dagger:jar:apt (apt or codegen) for the annotation processors (to be used as a dependency in the maven-compiler-plugin, and assumes com.squareup:dagger:jar is also on the classpath)\n\nI'm not sure what the win is here.  It's not a secondary or supplementary artifact (things that are other views of the main artifact) - it's a separate set of tooling.\nWhat you're testing isn't units of code, you're testing broader functionality - and you're testing it with many mechanism.  That's the definition of an integration test if I've ever heard it.  I'd rather those tests not go in the core artifact's src/test/java.  They're not unit tests.  They can comfortably go in another project that exercises the full framework. Since you raised what other projects are doing, Guava did that in order to allow it to separately release its testlibs. \n. So - as to your overall comment, my answer is yes.  I can move this a bit more towards a smaller matrix.  I think the linking/injection stuff can be merged a bit more so there's code-gen vs. not-code-gen.  Linker is doing more work than it should, I think.  \nMy plan was to merge the back-ends, it's just that this change was already so big, I wanted to move in steps.  This was not the end-state.\nI'll merge the back-ends some now, and pull createatinjectbinding from linker and put it somewhere healther (and so there can be one linker).  Let me see what I can do to get this in shape, apart from the smaller comments in this PR.\n. Yeah - I can revert the ObjectGraph.get() for now and do it separately.  In retrospect, I shouldn't have included it. \n. So, FYI - it's cleaner.  And yes yes, \"Plugin\" is a crappy crappy name.\n. Also, please note - the reflection-based plugin is not all in one class - the three things it is responsible for creating/marshalling/whatever are really big, so making inner-class versions of them was a bit over the top, I think.  OTOH, the classloading version... damn that got eerily simple.  One worker method, and three delegating methods. \n. I'm OOO today but should have it fixed up in the next day or so. Then\nonto child injectors.  :)\n. Heh.  Dagger.poke().  Classic.  We shall Dagger.thrust() into the heard of crappy run-time wiring validation...\n. Ok... squashed and rebased from master and ready to go if you don't find any other issues.\n. Weird.  You pushed an un-squashed commit. lol.\n. On 5 Mar 2013, at 13:38, Jake Wharton wrote:\n\nI wrote this last night in a one-off experimentation with code \ngeneration for another project: \nhttp://github.com/JakeWharton/butterknife/\n\nHeh.  Butter-knife.  Awesome.\n. Definitely need to fix tests and flesh out more tests, especially covering failure cases.\n. Ok... I'm stressing about this.  @Singleton\nSingleton.class is part of JSR-330, and it uses @Scope, so it's really aligned for a guice-like view of orthogonally declared scopes.  But we're going to be using extension graphs for scope.\nSo there's no technical problem here... we use @Singleton to mean @Cached per-injector.  But it's misleading.  We can overcome it with documentation, but if someone does\n```\n@Module class FooModule {\n   ... real singletons\n}\n@Module(includes=FooModule.class, entryPoints=Bar.class) class BarModule {\n   @Provides Bar a(BarImpl impl) { return impl; }\n}\n@Singleton\nclass BarImpl implements Bar {\n}\npublic static void main(String[] args) {\n  ObjectGraph root = ObjectGraph.create(new FooModule());\nSet bars = new LinkedHashSet(); // hi jesse\n  for (some loop criterion) {\n    ObjectGraph extension = root.extend(new BarModule());\n    Bar bar = extension.get(Bar.class);\n    Bar bar2 = extension.get(Bar.class);\n    if (bar != bar2) throw new AssertionError(\"Bars should be the same instance\");\n    setOfBars.add(bar);\n  }\n  if (bars.size() > 1) throw new AssertionError(\"Hey, I thought Bar was a singleton!?!  WAT?  WTF?\");\n}\n```\nthen he will get a new Bar instance in each iteration of that loop.  But BarImpl was annotated with @Singleton.  So even though @Singleton technically means one-per-injector, or \"Scopleton\" (in a sense), it's bad naming here.  Singleton-ness is attained by being singleton AND being in the root graph.  The GRAPH is the singleton scope in effect, whereas the extension graph is the per-loop-iteration graph.\nSo... now what?  I don't know.  We can go ahead, making people be really clear that their singleton objects are actually more like @ScopedToGraph or @CachedPerGraph or @OnePerGraph... or we can actually make such an annotation and encourage its use. But this will render code incompatible with other JSR-330 which use scopes transparently.\nIt also means that we're ignoring any @Scope annotations that aren't @Singleton, so we're a partial implementor of JSR-330.  \nLet me be clear.  I don't want @Scope annotations a-la Guice.  I think this model is far more rigorous and less easy to screw up with large degrees of magic.  But the above issues still need deciding.  Most importantly, the possible misleading naming. \n. So it's not a \"problem\" per-se... it's just that people who are used to annotated scopes are going to possibly have big WAT? moments, and I'm wondering if we can avoid it.\n. Put another way... this is a Guice legacy and I wonder if we can't do better.  I like @PerGraph or something that makes it clear that it's connected to the life of the graph itself. \n. PTAL Jesse (or anyone)\n. Thanks, Jesse.  It's all squashed up and pushed.  Give it a look.\n. If you got the no at inject provider could be found that probably means you\ndidn't have anything @Inject marked so the code gen has no way to know to\ncreate an adapter for it, and the reflection based handler has nothing\nmarked to look up.\nYou need to add an @Inject constructor or field(s).\nRegards,\nChristian\nSent from my iPhone.\nOn Oct 25, 2012, at 18:32, Patrick Forhan notifications@github.com wrote:\nGenerally, something must have an @Inject https://github.com/Inject in\nit somewhere to function. However, it does not need that for super classes.\nWhat you have ooks pretty good. @swankjesse https://github.com/swankjesse,\nany thoughts?\nAnd just a sanity check, you're not @Injecting an activity anywhere, are\nyou?\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/square/dagger/issues/74#issuecomment-9796832.\n. Sorry.  Missed it. Reading on my phone.\nUpon further thought, I don't think we process annotations on superclasses\ncurrently.  I recall a getDeclaredConstructors() call (vaguely from\nmemory).  We need to decide how we want to handle @Inject on parent types\nif there are no local members that are annotated.\nRegards,\nChristian\nSent from my iPhone.\nOn Oct 25, 2012, at 18:51, Patrick Forhan notifications@github.com wrote:\n@cgruber https://github.com/cgruber FYI, in the 3rd comment, he shows an\n@Inject https://github.com/Inject Store myStore; member in his activity\nclass.\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/square/dagger/issues/74#issuecomment-9797359.\n. On 29 Oct 2012, at 11:16, Patrick Forhan wrote:\n\n@cgruber, did you ever look at this again?  The way I understand it, \nthis wasn't about annotations on super classes, it was a confusing \nmessage Dagger was giving out about a library superclass -- @Inject \nwas in the subclass, but Dagger was complaining that the super class \ndidn't have any @Injected members.\nWe do this with no issue (even the extending of \nSherlockFragmentActivity), but I don't know if there is some magic \ncombination that @luisdelarosa is hitting upon.\n\nHadn't gotten to it.  I'll dig into it today and/or tomorrow.\nc.\n. On 11 Nov 2012, at 18:31, Jesse Wilson wrote:\n\nWe didn't catch this in our own apps 'cause we accidentally disabled \ndagger-compiler when that code was split from the main module. We're \nrunning it now. That explains why I didn't see it.\n\nGood test on #102, btw, Jesse.\n. I hate to do this, but can you pleases split the runtime plugin changes that alter catch/throw vs. null behaviour into a separate PR.  The documentation and naming cleanup is really orthogonal and fiddly.\n. On second thought, don't split them - I've already started the review.  Just in future, let's keep behaviour shifts clear of bulk cleanup so it's easier to track.\n. Nah - skip it.  One comment about how we handle error in the runtime plugin, and if we settle that, I'm happy to merge. \n. Hmm.  This sort of exception should only really happen if the linkedlist has had their underlying structure changed via some concurrent modification.  Are you maybe asking to inject different entrypoints from different threads?  I'm a little loath to just turn this into a ConcurrentLinkedQueue, but that might be the right solution here.  I wonder if I can whip up a test to force this error. \n(I don't know Android worth beans, so apologies if the concurrency question is moronic.)\n. woops...\n. On second thought, this test would be seriously flaky if I used the stock LinkedList in the test, since it's a race-condition that occurs on concurrent modification of the linked list itself, in the middle of a poll() operation. \n. Ugh.  That feels... like a big hammer.  Maybe that's correct, but I wonder if we can't make the process less blocking. \n. Yeah - I was thinking about that as a next step.  That and geting Singleton and Lazy properly thread safe. \n. Ok, I'm going to close this and re-think.\n. That's pretty awesome, Mohsen.  Thanks.\nAt this point, I definitely wish we had a truly standardized @Nullable annotation.  We could use the one in findbugs (with an optional maven dep, so no one would be \"getting the transitive dep for free), but it's frustrating that there isn't a more centrally located standard one.  \n@swankjesse - how do you feel about actually using @Nullable (build-time dep only)?\n. On 6 Nov 2012, at 15:49, Mohsen Vakilian wrote:\n\nIt looks to me that we can get rid of the above occurrences of the \nnull value by introducing new classes. For instance, SetBinding \nsets provideKey and requiredBy to null. This may imply that \nBinding is not the right place for fields provideKey and \nrequiredBy. Instead, these fields should belong to the subclasses \nthat can set the fields to non-null values. I think this change would \nimprove the design and make it easy to check the null-safety of the \nprogram at compile-time.\nWhat do you think about such a change? Can you think of other changes \nto remove the null values?\n\nWe talked about this earlier, and we've made some design decisions that \nwere intended to reduce object instances in order to keep Android zippy. \n  Having the same binding do duty for provideKey vs. requiredBy was one \nsuch decision, though it's entirely possible that we can simply use the \nsame key for both, but have the binding in question say whether it's \nsupporting member injection or provision as a boolean (or bitfield \ndigit).  I was thinking about that earlier, but haven't worked up a \ndesign. It touches a few areas, and we had a few other things ahead on \nmy plate.  I agree, though, these do make me cringe a bit.\nc.\n. SGTM\n. Looks good.\n. Looks good.  My only stress over this is that we have partially valid situations that can only be seen at run-time... but at least they're at the entry into the injection system, so they're fast.  This should be an edge-case.\n. Nice.  An initial scan looked good to me.  But you pointed to jesse, so I'll let him merge and do his thing. \n. I dont' think this prepares anything - we're pushing towards a 1.0 release, and so the development line is 1.0-SNAPSHOT.  I'm not sure 0.9 is meaningful.  But this PR doesn't really hurt anything.  But I don't think it does anything.  Especially since 0.9-SNAPSHOT releases will actaully be seen as before 1.0-SNAPSHOT releases, so all the snapshots in the repo are kind of out of order now.\n. (not that people should use version ranges)\n. Oh - sorry - I misread this as having been merged... it was closed.  Woops.\n. I don't think we've fleshed out the use-cases well enough for this change to have been merged, to be honest.\nHow shall we deal with the many-of case?  \n@Provide(type=SET) Collection<Foo> foos() { ... return some foos... }\nis all well and good, if we special case collection types or iterable types, but to be frank, it emans you can never multibind a set of collection values, or a set of iterable values.  And if we're special casing on iterable, then what of custom types that you need a set of, that themselves are iterable. \nAlso, I think that @Provides(type=MAP) (if we do it) will not be sufficient to support the different cases, because we'll need a static map key, so we'll still need another annotation, so this doesn't buy us anything.  That, or we'll start polluting @Provides. \nIt's not that I can't agree to this style change (and I do like the enum switching, to be clear).  But I don't know that we really know the API for this yet, and it feels a bit premature.\n. (I know... horse is out of the barn... but I'm concerned that we let the horse out of the barn before we figured this out at least a bit more.)\n. Ok - I do like the explicitness, and I do see the validity of an \"either/or\" meaning for the annotation, though I like how the code reads in the other case.  And I think we get the validity checking from the processing.  The compiler itself can't know, but as long as the build tells you (or IDE, etc.), it's the same thing.  \nAdding an Enum for MAP wasn't what I meant.  It's that if we have @Provides(type=Map) we have to add key=\"foobar\" but that key property is not used for all enums.  That or we have to add another annotation for the map key... an annotation that can only be used in context.  Or we have to have people throw around map entries, and I'm already having a problem with special casing or privileging of generalized jdk types.  That seems nearly as magical.\nAs to wiggle room, having @Provides, and having deeper behavior governed by more annotations leaves even more wiggle room as far as I can see.  Or maybe I'm not sure what wiggle room you're talking about.  \nDoing it this way, and privileging @Provides(type=SET) Iterable<Foo> f() \u2026 means I can't do a set of iterables.  Zod help us if java.util.Optional ends up implementing Iterable as the functional wonks want, for example.  And if we go to privileging java.util.Collection or java.util.Set we're still saying that you can't have a set of any of these, because our signal can't distinguish between when we're providing the thing as a value or a set of value - we infer it from the output type.\nThis is why I liked @OneOf and @ManyOf, which our processor would choke on as invalid at build time if both used.  I suppose we could do @Provides(type=SET_VALUE) and @Provides(type=SET_VALUES) or some other enum value that shows multiple values composing a set come out here, so, style aside, we CAN handle this use-case, but I wanted to nail these use-cases down before we re-worked the syntax.  One way or another, we need a signal, and special casing the output type feels like an inferior signal on its own.\nHaving said that, ok, the die is cast\u2026 this format is in.  But do you have a preferred enum value for type= that would fit the \"multiple values contributing to a set\"?\n. Abstain for lack of really strong connection to it one way or the other. \n  No objections though, if it's not providing enough value.\n. You make it sound like a moral or legal issue.  Lol.\nMaven groupid naming isn't a formal spec that can be \"violated\".  It is a\ncommon practice.   We were not permitted to have \"dagger\" as the groupid\nand still put things into sonatype's maven repository, but java package is\na namespace choice that has other considerations.  But that we may not\nmirror our desired package name in our maven group id doesn't mean we must\nmirror our group id in our package.\nIt is possible to have a package conflict.  But dagger is an unusual name,\nand it would surprise me that someone used dagger.Foo and had an overlap.\n Also, short package names are convenient and make for more readable client\ncode where fully qualified names are used.\nRegards,\nChristian\nSent from my iPhone.\nOn Nov 8, 2012, at 8:54, Werner Keil notifications@github.com wrote:\nWhile the POM contains a common groupId \"com.squareup\" and artifactId\n\"dagger\", the package name is simply \"dagger\".\nThis is highly uncommon and adds risk of package name or dependency clashes\nyou'd avoid, if the package was properly named.\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/square/dagger/issues/97.\n. On 8 Nov 2012, at 11:05, Werner Keil wrote:\n\nYeah, beside trying to seem what it isn't (a \"standard\" like \"java.\" \nor #javax.\" packages) it has the side-effect, that it hides which \ncompany is behind it, at least on a Java level. Whether intentional or \nnot, I don't know, Bob though he doesn't seem involved in Dagger is \n(former) Spec Lead of 330 after he left Google, but unlike Guice JSRs \nare always supposed to be vendor-neutral. If some of you may keep \nmaintaining these projects even after eventually leaving Square, let's \nsee, at least Twitter in some cases seems a bit like a \"Rotating Door\" \nfor developers;-)\n\nI am employed by Google and contributing to Dagger as part of my day \njob, which is \"making dependency injection better at Google\".  I also \ncontribute to Guice.  Square initiated Dagger, from a fork of Miniguice \n(written by Jesse).\nPut another way - Square is putting dollars behind this in the form of \ntime, and deserves credit\u2026 but non-Square folks are involved, and that \nwas always the intention.  There's no \"hiding the company behind it\" - \nmany companies are behind it.  And as to trying to seem what it isn't (a \nstandard) is a matter of perspective.  Whether it becomes a standard \ndepends on market forces - who uses it.\nThis is beyond the scope of this conversation - de-jure vs. de-facto \nstandards, but the package dagger means that I can make a google fork of \nDagger if I want, and, to the extent that we all collaborate to keep \nclient-side incompatibilities small or nonexistent, we can benefit from \na single java namespace for what are, in fact, replacement products.\n. You were signaling reviewers... did you want them particularly to review, or were you just distributing?\n. On 11 Nov 2012, at 13:03, Yoav Zibin wrote:\n\nThanks for replying so quickly :)\nI've updated to the latest java version but mvn test still fails for \nme:\nPlease refer to \nC:\\Users\\yzibin\\workspace\\dagger-master\\core\\target\\surefire-rep\norts for the individual test results.\n\nCan you please check the contents of the surefire reports and post them? \n  It's showing a test failure, but you need to see inside the failing \ntest report to see why.\n. > Dagger currently fails to create @Inject bindings for classes with \n\ntype parameters.\n\nWait\u2026 we do support binding something to Foo<Bar> and injecting \nFoo<Bar> now, no? Just not Foo<T>.  Yes?\n\nWe could fix this. We should weight the upsides and the downsides; one \nbig downside is that it'll require a ton of code, possibly even \nsomething that parses a type like Converter<Payment>.\nSee also Guice Punches Erasure In The \nFace.\n\nIf we do it, we need to do it, if possible, with minimal currying around \nof extra type information.  That is, we need to validate at compile-time \nthat\n@Inject Foo<Bar> foobar;\nis satisfied by\n@Provides Foo<T> provideFoo() { \u2026 }\nBut I don't think we can get around the fundamental issue represented by \nthe guarded list.  One CAN just cast the thing to the generalized form, \nand bypass type safety of the lists.  In other words, we can make a gun \nwith a safety, teach good gun safety, but we can't prevent someone from \nflipping off that safety as they line the sight up at their boot.\nI guess the question is\u2026 do we do the work to get TypeLiteral or some \nsuch into a built-in injection and what would the impact of this be on \nperformance?\nAnd, what real problems, not merely robot legs (and we have a larger \nissue there, as @swankjesse and I discussed), but real use-cases our \nusers are encountering in production systems will this address, and can \nthe problem be solved in a different way that is reasonable?  What piece \nof software can't they write that they really should write?\n. On 12 Nov 2012, at 13:12, Jesse Wilson wrote:\n\nI don't think I was clear enough. This only impacts @Inject \nbindings. For example, you can't do this:\n``` java\npublic class Foo {\n@Inject Foo() {\n}\n}\npublic class Bar {\n@Inject Foo fooOfString;\n}\n```\n\nOk - check.  This makes sense, but it seems like it would be only \nrelevant to JIT bindings, given that one could bind Foo in an \n@Provides.  This is sort of close to using Dagger as a factory \nimplicitly, and I wonder if it's a power or a code-smell.  I'd need to \nsee more samples, I think.\nI think it wouldn't be horrid to make work\u2026 just would want to make \nsure we don't end up with it being too easy to do the wrong thing or \nhave surprising behavior.  As was mentioned - if it compiles, it should \nwork.  Can we guarantee that?\n. This issue seems fixed by two pull requests.  Closing - someone re-open it if it's not really fixed. \n. Fixed by https://github.com/square/dagger/pull/134\n. I think you got them all, Thomas.\n. I'm a bit of the same mind as @swankjesse here.  I'm less worried about the fragility of entry-points as a concept - I think we want to keep these for validation reasons for the long-haul and I don't think entry-points == @Inject precisely because they're a subset of injectable resources.\nI think jesse's point about forcing all classes into the same object graph.  I think that would limit this to the android case - it would be harder in a web situation.\n. This has lapsed for about a month - @swankjesse did you want to finish up this review?  I'm loath to jump into it since you've already done much of the prior review. \n. This seems to have been fixed in #144 by @swankjesse.  If this wasn't intended to evolve into supporting injecting generics into other classes, then I think this is now a duplicate fix. \n. Yes - this is from an older version of Dagger, and the text wasn't updated.  thanks.  Plus is for \"Extension graphs.\"\n. Scooped by @JakeWharton.  :)\n. On 4 Dec 2012, at 18:32, DaveGit wrote:\n\nBut is the dagger compiler with the annotation processors (i.e. \ndagger-compiler-0.9.jar) not necessary?\nIs dagger-0.9.jar all that is needed?\n\ndagger-compiler isn't a maven-plugin, it's an annotation processor.  It \ncan be used with anything that will invoke javac with it on its class \npath.  That should be true of gradle, ivy, maven, ant, etc.  Generating \nmodules is quite separate than generating the code for ModuleAdapter or \nInjectAdapter classes.\n. We should be generating suppression annotations for some of these \nthings.  This is generated code, and should not bug the user with \ngenerics and casting for code they didn't write.\nI'll take that on, as I've got a branch that I need to push that has \nsome improvements to the code-gen output.\nChristian.\nOn 7 Dec 2012, at 13:58, DaveGit wrote:\n\nFor the last days I have been struggling with these kind of warnings \nbelow. I probably did something wrong as I couldn't find any similar \nquestion on the internet.\nI refactored several times but they don't go away.\nWhere can I find what 'capture#128 of ?' means or why is there an \nunchecked cast and what should I do?\nThe line numbers refer to the attach method in the generated files but \nI cannot see anything peculiar.\nI have at this moment 5 of them but I show here a constructor, field \nand provider\nThe GraphVizualizer draws something\ndigraph G1 {\nconcentrate = true;\nDbAdapter -> Context;\n}\nso something I do right.\nSome hints are appreciated.\nDbAdapterModule$ModuleAdapter.java:33: warning: [unchecked] unchecked \ncast\n[warn] found   : dagger.internal.Binding\n[warn] required: dagger.internal.Binding\n[warn]       p0 = (dagger.internal.Binding) \nlinker.requestBinding(\"android.content.Context\", \n.db.DbAdapterModule.class);\n[warn]\n      ^\nOptionLoaderDelegate$InjectAdapter.java:14: warning: [unchecked] \nunchecked cast\n[warn] found   : dagger.internal.Binding\n[warn] required: dagger.internal.Binding\n[warn]     c0 = (dagger.internal.Binding) \nlinker.reques\ntBinding(\"android.content.Context\", \n.loaders.OptionLoaderDelegate.class);\n[warn]\n    ^\nOptionLoaderDelegate$InjectAdapter.java:15: warning: [unchecked] \nunchecked cast\n[warn] found   : dagger.internal.Binding\n[warn] required: dagger.internal.Binding\n[warn]     f0 = (dagger.internal.Binding) \nlinker.requestBinding(\"db.DbAdapter\", \nloaders.OptionLoaderDelegate.class);\n[warn]\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/square/dagger/issues/124\n. What is your environment?  This is in an IDE I take it?\n\nC\nOn Saturday, 8 December 2012, DaveGit wrote:\n\nI also have these kind of warnings for classes in the generated files\n[warn] Could not determine source for class\nx.y.z.ContextModule$ModuleAdapter$ProvideContextBinding\n[warn] Could not determine source for class\nx.y.z.ContextModule$ModuleAdapter\n[warn] Could not determine source for class\nx.y.z.loaders.ListLoaderDelegate$InjectAdapter\n[warn] Could not determine source for class\nx.y.z.ContextModule$InjectAdapter\n[warn] Could not determine source for class\nx.y.z.db.DbAdapterModule$ModuleAdapter$ProvideDbAdapterBinding\n[warn] Could not determine source for class\nx.y.z.db.DbAdapterORMLiteFacade$InjectAdapter\n[warn] Could not determine source for class\nx.y.z.loaders.OptionLoaderDelegate$InjectAdapter\n[warn] Could not determine source for class\nx.y.z.db.DbAdapterModule$ModuleAdapter\nDoes that mean the annotation processor cannot find the source files in\ndirectory x.y.x ?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/124#issuecomment-11159004.\n. On 8 Dec 2012, at 11:58, DaveGit wrote:\nNo this is the sbt shell. But it also happens directly from the \ncommandline when I do sbt compile.\nFor the javac settings -s is pointing to \n/target/scala-2.10/src_managed/main/java\nand -processorpath is pointing to \nc:/dagger/boot/dagger-compiler-0.9.jar;c:/dagger/boot/dagger-0.9.jar;c:/dagger/boot/javax.inject-1.jar\nI also tried -s pointing tp \n/target/generated-sources/annotations so exactly as the \ncoffee example.\nThe source files and the dot file are generated in the specified but \nstill these warnings.\nThe classes are in both cases written to /target/scala-2.10/classes \nand I can not change it with the -d option of javac. It is not \nreacting on that. Maybe a bug in sbt.\nIs dagger maybe expecting the processed classes to be in \n/target/classes?\n\nOhhh.  SBT.  Ok.  This may be a strange interaction between the \ngenerated code and the scala compiler/run-time environment.  AT this \npoint, I don't believe that Scala is something any current authors use \nin production systems, so it's not going to be a high-priority to fix.\nSome of these warnings are compiler warnings that we can't do much about \nwithout examining how scala shell is interacting with things.\nDagger isn't expecting things to be anywhere, per-se.  It's an \nannotation processor, so it's really up to the compiler to determine \nwhere things are.  The Dagger compiler accesses code through an \nenvironment provided to the processor.\n. On 8 Dec 2012, at 14:57, DaveGit wrote:\n\nSo in principle it should directly work with scala source files if the \ncompiler/sbt allows it.\nBecause so far it looks like it ignoring scala source files. That is \nwhy I put the dagger annotations in java files and tie that to scala \nfiles. It is probably an annotation processor for the java compiler \nonly. It wouldn't work for any other jvm language compiler.\nOkay Christian, thanks so far anyway.\n\nAhh\u2026 I don't know if the sbt/scalac processes annotations using \njavax.tools the same way.  Eventually we are considering a \nbinary-scanning generator, which may work better with scala, so long as \nannotations are present.  But that's not targeted for 1.0.\n. I think you meant dagger-0.9.jar, Thomas.\nYes - dagger-compiler-${version}.jar requires dagger-${version}.jar and \nif you're not using Maven or some other dependency management system, \nthen you have to add all the relevant jars manually wherever you need to \nuse the compiler/code-generator.\n. So you won't get errors in wiring if you simply have some inject\nannotations.  You need to have at least one complete module that is the\nstarting definition of your graph or dagger can't perform it's full graph\nanalysis.  Do you have a module defined?\nRegards,\nChristian\nSent from my iPhone.\nOn Jan 14, 2013, at 3:06, Steven-Mark-Ford notifications@github.com wrote:\nI can get code generation working but no compiler errors.\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/square/dagger/issues/126#issuecomment-12209445.\n. Also, if you haven't set up annotation processing in eclipse you have to\nbuild from maven then add the generated classes source dir as a source\nfolder in eclipse.\nRegards,\nChristian\nSent from my iPhone.\nOn Jan 14, 2013, at 8:44, Christian Gruber cgruber@google.com wrote:\nSo you won't get errors in wiring if you simply have some inject\nannotations.  You need to have at least one complete module that is the\nstarting definition of your graph or dagger can't perform it's full graph\nanalysis.  Do you have a module defined?\nRegards,\nChristian\nSent from my iPhone.\nOn Jan 14, 2013, at 3:06, Steven-Mark-Ford notifications@github.com wrote:\nI can get code generation working but no compiler errors.\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/square/dagger/issues/126#issuecomment-12209445.\n. They should, but I am not using eclipse's annotation processing config.  I\njust build with maven inside eclipse using m2e and add the\ntarget/generated-sources/annotations folder.  I'd maven generation fails I\nget the error there and then the compilation errors are showing as broken\nin eclipse too.\nRegards,\nChristian\nSent from my iPhone.\nOn Jan 14, 2013, at 8:59, Steven-Mark-Ford notifications@github.com wrote:\n@cgruber https://github.com/cgruber I followed staxgr example on setting\nup annotation processing in eclipse and I have defined a module but I still\ndon't see any compile errors. Where would they appear within eclipse? In\nthe \"Problems\" window?\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/square/dagger/issues/126#issuecomment-12219258.\n. In order to structure my response, are you using M2E?\n. Ok, so my examples would have all been maven and m2e based.  I've not done\nenough with the standard eclipse config.\nI will say that I added the key jars to the factory path and I got code and\n.dot generation but did NOT get errors from the full graph processor.\n Strange because I do get such errors from maven and javac, and I know it's\ngenerating code because I clear out the folder and \"clean\" the project and\nI get adapters and .dot files.\nVery weird.  I'll investigate further but I know this is an uncommon\nconfiguration for dagger devs who either use IntelliJ or eclipse with m2e.\nRegards,\nChristian\nSent from my iPhone.\nOn Jan 16, 2013, at 6:13, Steven-Mark-Ford notifications@github.com wrote:\nNope, just vanilla Eclipse+ADT (All-in-one package). Thanks in advance.\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/square/dagger/issues/126#issuecomment-12313982.\n. On 21 Jan 2013, at 9:51, Thomas Broyer wrote:\n\nThis is because errors are reported without being attached to an \n\u201celement\u201d, so they only appear in the \u201cError Log\u201d view (which \nis hidden by default); see issue #110\n\nMakes sense.  I was going to look into #110 soon, so maybe I can fix all \nof this at once.  Thanks for the pointer.\n. We're not quite there with eclipse error integration\u2026 that is, you \nneed to add the dagger, dagger-compiler, and javax.inject jars manually \nto your annotation processing class path for your project, in the \npreferences, in the java compiler section.\nI'm digging into whether it'll be possible to have maven auto-configure \neclipse to use these, but for now, you need to add those.  I'll work up \nsome instructions with screen shots hopefully this week.\nChristian.\nOn 11 Feb 2013, at 22:23, Andrea Richiardi wrote:\n\nHi, I am trying to configure Dagger in my Android project...I am \nrunning into some issue. I just want to be sure that my m2e \nconfiguration is ok. I checked the dagger projects from SCM but \nimported in my pom.xml version 0.9.1.\nI created a debug configuration to launch mvn. Do I need to tick \nResolve Workspace Artifacts?\nIt looks that it compiles using maven but the error checking in \nEclipse doesn't work (there is an error on a black static field with \n@Inject annotation). Do I need additional steps?\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/square/dagger/issues/126#issuecomment-13416487\n. Hmm.  When I put dagger-compiler as a dep of the compiler plugin then\nI don't get generated code in the target/generated-sources/annotations\nfolder, so I've been doing it as an optional dependency of the library\nbeing processed.  Hrm.\n. Add the generated sources jar as a source folder manually.\n. That's awesome.  I'll do some testing and write up some docs specific to \ndagger.\n. The Javawriter was extracted into another project and you need that\njar in your factory class path also.\n. If I'm not mistaken, #110 fixes this, so errors should show up in the \nproblem frame.  But I haven't tested that. I'll try to confirm that \ntoday.\n. On 14 Feb 2013, at 9:02, Thomas Broyer wrote:\n(note: to make m2e-apt work in dagger-example, I had to Maven \u2192 \nDisable Workspace Resolution on the project)\n\nOk\u2026 THAT seriously sucks.  Thats one of my favorite m2e features.\n. Totally makes sense, Thomas.  I'm just annoyed - it means I'll have to \nuse separate workspaces in some cases, but yeah - it's mostly annoying \nfor me/us, not our users. :D\n. Yeah... I can't even find Annotation Processing in my m2e 1.2 configuration settings.  I'm on Juno SR1 - and I get no UI at those preferences locations.  Grr.\n. And of course 1.3 is announced today.  I'ma start from scratch with m2e 1.3, install m2e-apt and see how it goes. \n. I''m now having consistent success with this using m2e, m2e-apt, and \"disable workspace resolution\" (if I have dagger open as a project in eclipse).  This seems worth closing at this point. \n. Can't help on the gradle front.  Never used it, have zero idea how it \ncould even integrate with an IDE, since it's more script-like than \nsomething declarative like maven.  I'm sure one could, but exposing \nthings like dependency graph / class path would seem to need specific \nsupport for IDEs and I just don't know Gradle well enough.\n. That would suck, as it wouldn't be able to auto-configure eclipse's annotation processing support to \"just work\" in eclipse incremental builds. :(\n. You would be surprised how much \"ancillary work\" I had to do or \ninstigate and track related to Dagger to get it all going in google.\nBuild systems seem ancillary but they are HOW our framework's facilities \nare manifested.\n. Terry says they've had more luck recently. I'll check with him in next\nweek.\nOn Wed, Oct 1, 2014, 20:27 Gregory Kick notifications@github.com wrote:\n\nI don't have any personal experience with it, but I've heard that getting\nthe eclipse team to accept patches (even for pretty grievous bugs) is quite\ndifficult. For that reason, you're probably not going to see a lot of\npeople volunteering to fix that issue\u2026\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/126#issuecomment-57577502.\n. I just met a few eclipse contributors at JavaONE. I'll hit them up to see\nif they can suggest profitable direction - who to talk to, etc., if Walter\nis not involved.\n\nOn Thu, Oct 2, 2014, 08:41 Stephen Haberman notifications@github.com\nwrote:\n\nFWIW back in 2009/2010 I submitted several bugs (NPEs/etc.) in Eclipse's\nAPT support and they were pretty responsive. (As responsive as waiting for\nthe next Eclipse release can be anyway.)\nWalter Harley, who wrote the initial Eclipse APT support while working at\nBEA, was especially helpful, although since BEA defunded their Eclipse\nwork, he was just watching the bug tracker as a hobby.\nI have no idea if Walter is interested in Eclipse/APT anymore, but I'd\nlove to see someone fund him (or someone like him) to fix this bug. I would\npersonally chip in to that effort, as that Eclipse APT bug is basically the\nsole reason I'm loathe to write annotation processors anymore, and almost\nalways pick a different means of code generation.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/126#issuecomment-57649560.\n. Sorry - I have a fix planned, but am in the middle of dealing with some \ngoogle internals getting Dagger rolled out in our build system and to \nnew internal customers, so I'm stretched a little thin.  I came upon an \nidea as part of some assisted-inject thinking I was doing as to how to \nhandle interfaces in general, but there are also some simple things we \ncan do and I cal roll that up post-haste.\n. Agreed.\n. Dagger currently doesn't support this use-case.  You are doing what si \ncalled a circular reference, or a cyclic dependency.   This will result \nin a stack overflow, because to create Controller you need \nSessionController but to create SessionController you need Controller.\nTo construct A without B is invalid, and to construct B without A is \ninvalid.\n\nWe are toying with supporting A -> B -> A at some point through \nfield-only injection, but except for certain key use-cases, I find that \noften a cyclic dependency is actually a hint about a design error.\nConsider this article - it shows how you might solve a cyclic dependency \nissue without using the framework - by re-designing slightly to \neliminate it.\nhttp://misko.hevery.com/2008/08/01/circular-dependency-in-constructors-and-dependency-injection/\nThere are a few edge cases where it IS really necessary (and if you are \nusing DI for \"domain object models\" then it might be valid, though I \nwould argue don't inject domain object models, use factories).  If we \nsupport them, it will likely be through field injection, and only if the \nobjects participating in the injection are all mutually including each \nother with fields.\nBut, please consider some re-design to eliminate the cycle.  Most cycles \naren't necessary, in my experience, and it's worth the time to refactor \nyour code to eliminate them.\nChristian.\nP.S.  Not all D-I advocates agree with my position, so take it with a \ngrain of salt.\nOn 22 Dec 2012, at 14:25, Nicolas Milliard wrote:\n\nFirst, thanks for this library!\nI am learning Dagger and Dependency Injection design pattern in \ngeneral.\nI was wondering how would you solve cross dependency injections with \nDagger? Maybe this question show a misunderstanding of the dependency \ninjection design pattern or an architecture design issue in my code.\nThe code below represent what I am trying to do but  obviously \ncrashing in StackOverflow\n``` java\npublic class SessionController {\nprivate final SyncController mSyncController;\n@Inject\npublic SessionController(final Context context, SyncController \nsyncController {\n    mSyncController = syncController;\n}\n}\npublic class SyncController {\nprivate final SessionController mSessionController;\n@Inject\npublic SyncController(final Context context, SessionController \nsessionController {\n    mSessionController = sessionController;\n}\n}\npublic class ProdModule {\nprivate final Context appContext;\npublic ProdModule(final Context appContext) {\n    this.appContext = appContext;\n}\n@Provides\n@Singleton\nBus provideBus() {\n    return new Bus();\n}\n@Provides\n@Singleton\nController provideSyncController(Bus bus, SessionController \nsessionController) {\n    return new SyncController(bus, sessionController);\n}\n@Provides\n@Singleton\nSessionController provideSessionController(Controller controller, \nSyncController syncController) {\n    return new SessionController(appContext, syncController);\n}\n}\n```\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/square/dagger/issues/128\n. Please add a description to this pull request, and please squash the commits. This change includes a scoped singleton implementation - that seems out of scope with the other fixed missing bindings stuff.\n. Actually - this is really two different pulls - one to fix, the other to add a new concept of scoped singleton.  Could you please re-frame this as two pull requests so discussion of one need not impede the other?\n. Hmm.  Now this branch is missing the fix to InjectProcessor, I think.\n\nAlso, can you please add a test to verify the existence of the bug, along side this code which fixes it?\n. The tests in compiler/src/it MUST use generated code.  If they're not generating code they're missing the point and I need to fix them.  I'm checking on it. \n. When I do a \"mvn clean install\" I get generated classes in, for example, \"compiler/target/it/extension-graph/target/classes/test/\"\nthey should be in compiler/target/it/extension-graph/target/generated-classes/annotations but they aren't for reasons I can't quite work out.  You should be able to use the verification script to read in a generated class and assert about its contents. \n. Oh crap, @zbsz... I was so in the middle of another PR that I hastened to fix this not remembering you had one on the go.  I didn't mean to scoop you.  :(\n. Note... I have another pull request pending that completely re-does the JavaWriter with a more structured approach, but it's not ready.  It should make all this code much cleaner, I hope.  But for now, this makes the generated code of generally readable style, notwithstanding line-length issues in some places. \n. The simplest way to see the difference would be to actually patch it in and try it and look at the resulting output code - it's way easier than inferring it from the code generator.  Thats separate from coding/style critique of the generating code. \n. Nice.  Didn't know about gist.  This change covers many different use-cases and our existing \"example\" project is not full-featured.  I have edits to it to flesh it out more, so I'll do some \"gists\" to show the changes. \nBut not tonight. :) \n. FYI.  I threw together https://gist.github.com/4463467/revisions.  I wish github had side-by-side diffs - that would make it much easier to see, but at least you can look at the diff or the raw code generated and see.\nNote... I see a few missing bits I'll need to fix for consistency, aside from the error above abotu stripping java.util in some cases where I shouldn't. \n. PTAL.  All the bits are in place, @swankjesse \n. Actually - hang on a sec, jesse - integration tests failing - not sure why it's not showing on github.\n. Ok - fixed - I had forgotten to update two names in the tests to correspond to the altered naming convention for provides bindings. (FooProvidesAdapter vs. FooBinding, to match inject adapter naming)\n. Ok - I think it's as done as I want to make it, @swankjesse.\n. Squashed - FTR, I'm adding the suppress warnings stuff in a separate branch. \n. Rofl.   Sorry.\n. Fixes https://github.com/square/dagger/issues/109\n. Notes on this - A private or protected (inaccessible) no-arg constructor is as good as a missing no-arg constructor, so treat them the same.  This avoids some valid entrypoints which could legitimately be injected via MembersInjector falsely creating impossible Provider contract that breaks compilation.\nThe down side is that this removes catching one error case - when someone doesn't need it as an entry point and yet they mistakenly had a private/protected constructor.  But I think that's effectively the same case as them having an uninjectable parameterized constructor. \n. @tbroyer - the reason package is excluded because I regressed to a prior \nmisunderstanding from early in my java days that I keep having to \nre-train myself out of. :(  Whoops, and thanks.  @swankjesse I will \ncertainly fix it.  I still have to work through two other things you \nmentioned earlier, so this I will also fix.\n. Discovered while exercizing my new changes to code-gen in the other PR.\n. Crap.  I didn't mean to scoop that other one - I was fixing as I went forgetting the other was in process. PR #131 was the correct fix - I had originally been waiting for some tests.  Shoulda just merged it and added the tests. \n. Added to the root as well - leaving in the example for cut-and-paste friendliness.\n. PTAL\n. On 14 Jan 2013, at 15:51, Jesse Wilson wrote:\n\nLGTM. Please squash commits before checkin.\n\nDone.\n. ptal\n. I'm not sure how much harder it is to access the graph without the \ncomponent.  If you have an Application class, and you expose access \neither to the application graph instance, or make an inject method, it's \na really clean way to do it, even if it does a bit of Law of Demeter \nbreaking.\n. I'm working on J2EE servlet filters for Dagger, and in the end, that's \nlikely going to be the way people will end up getting access to the \ngraph - a utility not unlike DaggerApplication.inject(\u2026).  It might \nwell be a nice utility to make client code cleaner in Android code. I \nthink there might be some android utilities worth a dagger-android \nproject.  I'm thinking there might well be dagger-web and dagger-gwt \nproject too, with suitable conveniences for these platforms.\n. @christopherperry - there's a system to build a module from an android manifest\n. (Sorry - mistakenly closed this)\n. I don't think it's obviously not part of this project - just not \nobviously part of dagger's core.  I was thinking of an integrations/ \nfolder for specific integrations with android, gwt, web, and other \nthings.  Though there's nothing stopping another.\nAs to project names - if it's a funny riff on dagger and android, it'll \nbe good.  Stabbot? :)\n. Oh - on that point, Jake, I was going to move example/ into examples/ \nand have /example/simple /example/full-featured and there would be good \nroom for /example/android.  It can be good for showing recommended \npractices, etc. That might be a good home for at least an early version, \nunless it really turns out to deserve its own code in its own reusable \nproject.\n. Which task - creating the android sample?  Cool - I'll move the projects \naround to make space, and just add your project to the example/ folder \nonce that's been done.\n. Argh.  I have a generated factory system nearly ready for a pull request \n(like, today or tomorrow).\n. On 2 Feb 2013, at 2:01, Jesse Wilson wrote:\n\nAny idea why Travis is complaining? Other than that, LGTM and thanks. \n(I'm embarrassed that a StringBuffer crept in!)\n\nCrap - that's probably me.  It's an old habit I still can't seem to \nbreak, forgetting to use StringBuilder.  Argh.  Sorry.\n. It's a good thing we're not creating our own code writing \ninfrastructure, @swankjesse\u2026 oh wait.  :D\n. LGTM\n. Patrick Baumann wrote:\n\nI've found that people pick the concept up quickest when I explain \nthat an entry point is any class that makes explicit use of the \nObjectGraph to be created or injected into (so that it's dependency \ntree can be validated). Simplified, it's any type that is passed into \nan .inject or .create call.\n\nDid you mean .inject(Object) or .get(Class<?>)?\n. It's default is actually \"wherever your ModuleAdapter is generated\" \nwhich seems to differ depending on your maven configuration.\nWhen I do\n<dependencies>\n   <dependency>\n     <groupId>com.squareup</groupId>\n     <artifactId>dagger-compiler</artifactId>\n     <version>some-version</version>\n     <optional>true</optional>\n   </dependency>\n</dependencies>\nthen it puts my generated code into target/generated-sources/annotation \nand the .dot file is beside the module adapter.\nOn 11 Feb 2013, at 16:39, James Wald wrote:\n\nJesse's talk at QCon talk touched on a really great feature that \nvisualizes the DAG.  Maybe it's just me, but I didn't know I was \nlooking for a dot file nor did I know where the mythical file was \nsaved.  After looking through the code I was able to track it down.\nIt would be helpful to showcase this neat feature on the website.\nBy default, the dot file is saved as:\ntarget/classes/com/yourapp/YourappModule.dot\nYou can view this file with GraphViz here \nhttp://www.graphviz.org/Download..php.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/square/dagger/issues/158\n. Do we necessarily have a deadlock if we signal whether a binding is requested for member or constructor injection, separate the flows for members injection and constructor injection, so construction can happen before members injection (of anything un-injected in the current transitive closure of the requested object), and explicitly disallow any cyclic reference among constructors?\n\nI think we can do better than a global lock if we are willing to keep some constraints in place. \n. I have a circular dependency analysis change I intend to put in shortly \ninto the full graph processor. Some point in Feb, this should be in if I \ncan get this internal crap done fast.  (Hoping to finish this stuff this \nweek, or mid-next at the latest)\n. Hmm.  I just walked the dependency graph passing in a stack of the \ncurrent path from the root, blowing up if the current node appeared in \nthe stack.  Really simple.\n. Whoops.  Then why aren't we failing at compile-time now\u2026 are we just \nnot applying it in full graph processor?\n. <facepalm/>\n. The cycle-detection issue is fixed in #163. The singleton concurrency protection still needs to happen. \n. Indeed.  This is the universal danger of provides methods.  They do\nthings at run time that are hard to analyse at compile time. We can\nonly show your wiring to be structurally valid.  We cannot prove you\nwill have no errors at run time.\n. Should we reject this, or wrap this in a try/catch block and run-time exception in the generated code.  It is boiler plate, so it's reasonable to generate, and the try/catch code will be clear within the generated code, just as readable.\nHeck, we could even generate run-time exceptions for checked exceptions that wrap them.\nThen again, doing so would pretty much pervert the whole approach of checked-exceptions.  Whether you're for or against that is sort of a matter of religion. \n. Yeah - I think I agree.  Just wanted to put it out for consideration.\n. I added a continue, not a return, since other modules may be valid.\n. As a separate issue, maven console output is swallowing the multi-line output to this.  I tested it with System.out, and the error() statement is receiving the full multiline cycle path, but only the first line is being output to the maven console.  Note sure how to fix it, but it's not an error in our code, I dont' believe, so I'll stand by this PR.  But we should ifx it.  Weirdly, it doesnt' swalow the input when I run maven from m2e in eclipse.  Just from the CLI.\n. ping?\n. It isn't with the maven test runner, which runs the default junit4 test runner.  That is not true of all build systems, and Google's internal build system does not assume the default test runner.  This signal is more precise, and doesn't hurt the current code base.  I'm having it here mostly to keep the forks from diverging where they don't need to.\n. It's not a bug in their build system, it's a configuration of their build system.  The test simply is never executed.  The default in their test runner is junit3 and the way to signal you are using 4 is @RunWith(JUnit4.class) (or other runners if you're using rules, or whatever.  Our code relies on a default.  This just specifies it.  Your IDE shouldn't warn you that the new annotation is useless... it's only useless because you happen to be running the code in maven.  That's a particularity of your build system, not the code.  \nIn a pinch, if you don't want this in, I won't press.  It's not dead code - it's an explicit signal.  It says exactly what runner in whose context this test was expected to run when it was written.  It's no more \"dead\" than @Module class Foo { } using @Module is \"dead\" because if I pass it in to ObjectGraph.create() we can infer that the developer intended it to be a module.  It's just more precisely stated.\nI'll see if I can apply a fix internally to Google's build system, but what I'm saying is that you're relying on it to be the default.  It's the default because of the assumptions we're making about builds.  It's a small price to pay to be explicitly true in all environments.\nAaaaaaaaaand my argument has taken more time than it was worth. :) \n. @RunWith(? extends Runner)  (pseudocode)\nStock runners in JUnit are:\n- @RunWith(JUnit4.class) - default of junit as harnessed by surefire.\n- @RunWith(AllTests.class) - 3.x style AllTests suites runner\n- @RunWith(Parameterized.class) - for parameterized tests\n- @RunWith(Theories.class) - for a better approach to parameterized tests\n- @RunWith(Suite.class) - for building hand-rolled suites. \nOther runners from other tools that integrate with JUnit, often to do with BDD or Spec style testing or supplementary frameworks:\n- JBehave: @RunWith(JUnitReportingRunner.class) - to get normal junit reporting from BDD style tests\n- Jasmine: @RunWith(JasmineTestRunner.class) - execute javascript \"spec\" tests in your java code (why, I dunno.  But they do it)\n- Mockito: @RunWith(MockitoJUnitRunner.class) - better validation against forgetting to verify, etc.\n- PowerMock: @RunWith(PowerMockRunner.class) - like mockito runner but for powermock.\n... etc.\nOf interest to us, is @RunWith(SpringJUnit4ClassRunner.class) which auto-configures a bunch of setup for spring-using tests.  Generally unit tests with Dagger should just not use the ObjectGraph in the test - just inject dependencies (or mocks of them) by hand.  But for larger integration tests, it's quite handy to have a runner that knows how to parse annotations, and maybe do the right thing. \nNevertheless, you can override the default - which is just @RunWith(Junit4.class) if left un-marked.  Or did you mean something else by override here?\n. I know there's a pull request that partially duplicates this - but I wanted this one in place that the other can base on, since I also have a more full-featured example forthcoming.  This provides a basic structure for any examples we want. \n. Any opposition to this?  This is a structural change to the projects themselves, and I'd like to sync it so I can re-organize my eclipse workspace and not live in two worlds.  :)\n. Couldn't that be handled merely by including dagger.Module in the \nsupported annotations for that processor?\n. Yes.  My other approach was similar to yours, and we definitely need to \nreturn false.  I'm trying to keep from growing the number of independent \nprocessors for reasons that are really to-do with google's internal \nbuild system.  But regardless, yes - I'll update to support Module (it \nis really a processor of modules) and return false to not conclude \nprocessing of modules.\n. PTAL\n. Grr.  I'll fix the checkstyle errors.  Must run verify before pushing... :(\n. ping?\n. I dont think it's bogus exactly - you're just inverting the if, so to speak.  I nearly did it that way - I'd rather fix this now, so its correct, then re-work it in an internal reorganization branch.  This is a fix. If you want it to be temporary, I'm ok with that, but this change improves the current and doesn't leave us worse off. \n. Agreed.  2.0 will be even moar awesum.  Fixing out the issues you mention, and next push should be it, presuming travis.ci agrees. \n. PTAL\n. PTAL\n. So I'd like to get this in fairly quickly and ideally do a release soon thereafter.  This is a bug in the running system that's an impediment to graph.plus().\n. ptal\n. So I'm happy with this, modulo some naming and style nits in which I am lightly channelling @swankjesse.  I'll wait for the fixes to merge, and be warned, Jesse might pipe in as he is the keeper of style and I might have missed things.  \nThat said, once all the issues are addressed, please send a PTAL (please take a look) or something similar, so we know to proceed with further review or merge.\n. You shouldn't need to re-submit the pull request.  Just once everyone is all \"Looks good to me\" here one of us will merge it. \n. Oh... never mind... I get it. You dont' have to re-submit... if you git-push this branch, this Pull Request will see it.\n. Woops.  Sorry. Misclick. \n. Woops.  Once I'm settled in after my move, I'ma make a check for that. \n. This is one of those diff-tools suck moments.  The actual diff of this is much less serious, except that the inner static implementation class (which is unchanged except for comments and @Overrride annotations, is indented two spaces.  This, however, foils diff and github's diffing, apparently.  \nLe sigh.\n. I'm not opposed - we're early enough to break things\u2026 the principle at \nstake here is the principle of least surprise.  My main concern is that \noverrides seems to be something that does replace, not contribute \nadditions, in the way we've used it.  Swap-in new stuff for testing.\nBut multi binders are inherently a contributive/additive API.  What \nwould be the least surprising interpretation for users?\nTruthfully, this early, I'm ok for either - and if we want stronger, \nnon-testing use-cases for overrides then we need to consider that too.\nThough if we go there, then we need to summit a bit and flesh out our \n\"strong module contract\" idea that we whiteboarded and try to make it \nstrong enough because I think module overrides are a sort of weak flavor \nof that.\n. Where did we land with this? \n. The one thought I did have that's worth making is that I generally think \nit's not the best idea to turn objects used in the graph into @ Modules\nas well.  That is entirely feasible because of the annotative-nature of \ndagger's configuration, but I think it conflates objects - makes objects \nhave multiple purposes that can really lead to confusion.  So.. not \nforbidden, but certainly not my personal recommendation. (If I\"m reading \nyour description right).\nOn 2 Mar 2013, at 8:27, Adrian Cole wrote:\n\nThis is probably more a usage question than an issue.\n. On 6 Mar 2013, at 4:34, Jesse Wilson wrote:\nYeah, this is a known limitation. My expectation is that it's rare \nenough that the reflection fallback isn't going to be that much of a \nperformance lose.\n\nI have teams that will not use the reflection back-end, so I will need \nto deal with these\u2026 but they will be in a position to annotate the \nparents.  We should be able to generate a no-op binding for the parent, \nthough.\nHow does dagger complain when you @Inject mark the parent constructor?\nWhy won't it compile?  That seems weird to me, as described.\n. Ah.  Wait... pure abstract?  Sorry.  My bad.  But we can generate a parent adapter if it needs field injection.  That's worth fixing.\n. Still in transition.  The reflection hit is because we use reflection as \na back-up for when you can't generate code for a given part of the \ngraph.  The canonical use-case is frameworks over whose source you have \nno control.  We can do better, and we're looking at a \njust-before-packaging approach for 2.0 that will be more comprehensive \nand possibly can optimize some steps.  But we can do some incremental \nimprovement here.\n. On 6 Mar 2013, at 13:46, rwinograd wrote:\n\nIs that incremental improvement that we can create $InjectAdapters for \nabstract classes with an @Inject constructor?  Can we just remove the \nline that causes an error when an abstract class has an @Inject \nconstructor?\n\nI don't know, at time of this writing, if that's the solution.  It may \nbe, or it may be that we simply generate the concrete types' \nInjectAdapters to be wise enough to find parent fields and inject them. \nThat is problematic for package-friendly visibility, but I just want to \npoint out that there are a few ways to fix this, and I want to think \nthrough the implications.\n. I prefer the option where we don't generate an adapter for parent classes unless the parent has injectable fields (which we then must do to work around visibility issues).  But if the parent has no such injectable fields, our concrete class' adapter shouldn't try to delegate to a non-existent parent.  I think we can be a little smarter about discovery.\n. Though as a hedge, #1 above seems workable.  If you label your abstract class with @Inject on its constructor (and it has no injectable fields), we generate a no-op adapter.  That would be the shortest path, though not the best path, I think. \n. Hmm.  Hadn't thought of the JSR violation. :/\nI'm already implementing that in effect in google/dagger, via the plugin choices, but in my naive approach it would blow up. I think we really need to generate concrete-class adapters which don't delegate to the parent if there is no need to (that is, there is nothing injectable about the parent(s).  \nAny reason we can't know that at processor time?\n. @swankjesse - I see your point.  I can see the value in requiring that people update their generated adapters when they update their dependencies, but we have no guarantees there... unless we do the full-graph generation as a separate step.  Hmm. \nI agree with @rwinograd, that I don't see the JSR violation here. That said, I could see having a marker annotation that we treat like a special-cased @Inject we could put on abstract classes.  Yes, it's not behaviour changing, but it is a signal, that it participates in injection, and is a signal to generate adapters. It seems like the least destructive hedge other than allowing @Inject onto abstract classes. \n. Absolutely, to the issue of whole-graph codegen, we would need a lot more infrastructure for class structure analysis, and we would lose out on some information not stored in the .class files (param names, etc.).  Jesse and I have talked about this before as the eventual direction of Dagger. \nAs to having a non-reflection mode, I'm not opposed - quite happy for it, in fact.  I have been wondering about programming styles for it.  Was toying with something to expose the plugins (we need it potentially in google), like:\njava\nObjectGraph.using(plugins).create(modules);\nWith some constants for common plugin sets.  (DEFAULT=Loader,Reflective : LOADER=Loader,AbstractHedge)\nBut this was intended for those who also may need to do funkier things in plugins inside Google.  It might not be the right way to expose this for the average case (Though maybe under the hood, it's done that way)\nIt might be time to revisit the injector builder idea:\njava\nObjectGraph.withoutReflection().create(modules);\n... or some such.  All graph context configuration like this would happen at the root, so .plus() extended graphs all share one plugin context.  Whether we implement it by means of plugin sets or otherwise is then behind the line.\nWhat I'm not sure how to do is to have this thing handle no-adapter parents without using reflection to detect that this is, indeed, a no-adapter, non-injectable parent that should just be ignored, except to silently succeed in that case.  But silently succeeding would be the same code flow as a parent that needed an adapter but one was never generated.  No way to catch the error. :/ \n. @rwinograd - yes, that's my concern.  My build system failed (or I misconfigured) and so my code gen didn't happen, or didn't update, or some edge case.  I won't know that it failed if we don't expect a parent's binding and simply let it go.  Indeed, I'm not sure what the logic of that would look like - \"if parent exists and is injectable, look it up, else don't.\"  Especially if the parent wasn't part of that round of processing. \nI mean there must be  away, but it's not coming to me without some further investigation.  But in the short term, how would we signal \"hey, don't worry about it?  No binding adapter?  No big deal!\" \n. But clear from the logs means no failure - just silent pass-through.  Is that good enough?  I don't think so. :(.  hmm...\nIf it weren't for an un-injectable parent being turned, in a separate library, into an injectable parent, (per jesse's concern) I'd say just test for the parent's injectability and re-gen the bindings.  Even more hmm...\n. It's a sort of nonsense signal, that we need for code-gen, but \nreflection-only JSR-330 implementations don't, and it is nonsense in \ntheir context, since you can't construct an abstract class.  The signal \ndoesn't help with determining dependencies, since the framework doesn't \ninvoke the abstract constructor, the child does, and is the only one \nthat can.  At best, allowing it would result in code that is ambiguous \nwhen applied to other frameworks, and could lead to mistaken impressions \nof what's happening under the hood.\nAnd there is no actual need for a parent to be injectable if it has no \ninjectable members.  Just logically, it's a false signal.  So we should \nhandle such parents more gracefully without requiring that they add \nextra signals for dagger.  Especially since it is not unlikely that such \nparents will be dagger-agnostic frameworks (such as Android activities, \netc.)\n. So, @sgoldfed introduced pull request #294 to address this, but this was seen as problematic for reasons described in that change.  However, that change will be going in the google fork of dagger (http://github.com/google/dagger) per the discussion on that P/R.  Once we get that in, and sync everything up, we'll release an equivalent version of dagger (I'm guessing 1.1) under the maven artifact com.google.dagger:dagger:jar:1.1.0 and this should address this issue, with the caveat that incremental compilation is broken in IntelliJ in such a way that, if you start modifying the parent types, the code-generation may not re-generate.  \nIn the mean-time, I'm closing this as, prior to doing whole-graph code generation, we won't be fixing it in square/dagger. \n. Many of the copyright dates are wrong.\n. Yeah - I noticed this.  Feel free to assign it to me.  I have to fix it \nfor some of our folks anyway.  We also have some issues where if we have \nnon-constructable modules which should have had an adapter blow up in \nthe runtime plugin when people fail to configure pro guard properly.  I \nthink we need to look at some obvious failure paths and construct better \nerrors.\n. I get crappy behavior when I do scope=provided.  Specifically, I get \njava files in the /classes directory.  I'm not sure why provided makes \nmore sense than optional - they both imply no transitivity.\n. scope=provided should give no transitivity, as I understand it.  I'm not \nsure how you're getting transitivity.  It is specifically intended for \nthings like javax.servlet where the end environment will provide the \nbytes, and where including it would result in duplicate class \ndefinitions.\n. Ahhh.  I see.  Tricky.  At Google we don't use maven internally, and our \nown build system doesn't pick annotation processors out of the general \ndependency class path, so we have to spec it on each project.  I'm \nconsidering advocating having it always on, but we have JSR-330 code \nused only by guice modules so having everything generate adapters will \nresult in unused adapters.  I can see the temptation to have it \neverywhere, though.  I'm wrestling with it.  However, to ensure it's on, \nwhat we're doing is our fork will have a way of initializing without the \nreflection back-end (since we have access to all sources).  If someone \nattempts to create an app where stuff wasn't generated, debug builds \nwill call validate will fail, hard, early, and tell us.\n. I still don't see any actual reason for using scope=provided over optional=true from a theoretical level.  And in my own testing, I moved the example to optional=true precisely because maven was not putting things automatically in the correct /target/generated-sources/annotation place.  Is there any better answer than \"meh, why not?\" to doing this?  Can we get comment from sonatype or apache folks on this before committing this PR?\n. Aside - @tbroyer, m2e-apt works just fine for me with <dependencies>...<optional>true</optional>...</dependencies> (vs. m-compiler-p) for what it's worth.\n. In neither provided=true, or optional=true, does the dependency on \ncompiler become transitive for further nodes in the dependency graph.\nThey are, in practice, nearly identical in their effect on the \ndependency graph of \"upstream\" artifacts.\n. @tbroyer - if m2e-apt only considers m-compiler-p and m-processor-p dependencies only, then the project dependencies are getting into their classpaths, because m2e-apt is properly creating eclipse annotation processing configs for me and are putting all the classes in the right places when I have the compiler in the dependencies for the project itself. Notably, I am using the simple example project as the test for this. \nIt may be that it should work under m_compiler-p, but if it is supposed to NOT work under the project dependencies itself, then I can confirm that it does so function.\n. @tbroyer - I presume that your proposal to use m-compiler-p dependencies would include adding the forceJavacCompilerUse flag?  Or force the use of an older m-compiler-p version that does work?  I don't want a non-working example in the code, even if it might one-day work, just because people will cargo-cult and copy the thing as-is, and if they need to force a future version (to avoid the default non-working plugin) they may not know they need to do so. \nOtherwise, I'm on-board with this recommendation.\n. SGTM.  Either is fine.  The former is more pedagogical, the latter a bit cleaner.  I'm probably more inclined to the latter. \n. PIng\n. I'm inclined as well, though there are some legacy migration cases we're \nencountering where it's saving a lot of work, but that's a weird case.\nOff by default would certainly be my preference, and explicitly not \nallowing for any module-ness out of the parents (like @Provides, @Module \ndeclarations, etc.)  People keep wanting to use Modules as very fancy \nparts of their infrastructure and core code, rather than as \nspecifications of their system's structure, period.\n. So, double-checked locking is being explicitly borked by checkstyle saying that the idiom is broken.  That was true up until in 1.5 the JMM was fixed with volatile, and this approach avoids the obtaining of a lock.  The recommended alternatives including the lazy helper are structurally what Lazy and SingletonBinding are doing here, except that I ALSO use DCL within them to avoid a casual fetching of a memoized object from ever needing to obtain a lock.  \nIn choosing this approach (my first was just to synchronize on get(), which worked, but requires a lock in all cases) I consulted with members of the guava and jvm teams at google, and the consensus is that DCL isn't THAT much of a benefit over synchronized, but for the difference between a 5ns branch prediction vs. a 200ns mutex.  Certainly no real performance hit, but considering those numbers are java-based, not android based, and it is observably better at the cost of one extra pointer and instance of Object(), the balance seemed to be in favour of the one way.  \nI can remove DCL if people feel it's appropriate, but it will still be a complex solution because I can't synchronize the get() method, since external callers inject Lazy and Provider and can therefore obtain access to the synchronized instance.  So I at least need a mutex on \"something\" (private final Object lock = new Object(), say) to make the lock be INSIDE the get() method.\nNote: http://stackoverflow.com/questions/3578604/how-to-solve-the-double-checked-locking-is-broken-declaration-in-java\n. Also: http://stackoverflow.com/questions/4588076/is-dalviks-memory-model-the-same-as-javas\n. Ah.  Ok.  Actually, the check has been removed entirely from checkstyle 5.6 because the 1.5 JMM fixes the use of volatile.  m-checkstyle-p actually fails on our current checkstyle.xml because it doesn't have the check.  I'll remove it and bump us to the latest checkstyle plugin for this PR. \n. PIng?  Anyone want to do a review?  This is an important one, I think. \n. Awesome, thanks. This goes farther than my try/catch block change earlier, and I think it's the right move. \n. V2.0 should be mostly in usable shape by end of Q2, though a good chunk \nof it should be usable earlier than that.  Should be some directly \nvisible activity in the next few weeks.\n. Eh.  We've been tossing around some compatibility aids to make it less \nthan 100% incompatible. :)   And the migration surface should be small, \nif you're building an app with reasonable best-practices.\n. So the context and dependency injection (CDI) stuff (@Produces) is a bit orthogonal to @Inject.  It is more aligned to @Provides but it's oriented around externalized configuration (what Dagger uses @Modules for.  \nIn essence this is trying to make @Module code compatible with CDI, and hterefore more portable - but modules aren't intended to be portable - the configuration system is quite particular to Dagger, much as Guice's Foo implements Module system is particular to it.  Different DI systems have different capabilities and I think it's misguided to try to force-fit their configuration systems into a standard.\nThat said, we'll be providing (in the google fork, at least) a Dagger module -> Guice module converter, since Dagger's module system is a strict subset of Guice's and can be represented by a constrained Guice module.  But it's a converter, rather than trying to come up with a common spec language for both. \n. LGTM.\n. Awesome branch name, btw. \n. Ok - so this is the orphan analysis we talked about earlier.  That's \ncool - do we want to do this at the whole-module level, or do we want to \nannotate particular explicit bindings as being for library use.  And why \nnot use entryPoints for this?  These present but orphaned bindings are \nreally entry points into this module's part of the graph.\nThese are sort of meandering thoughts, but I think we need a deeper look \nat the whole approach to what's in/out, visible/hidden, \nnecessary/optional in the graph, and how we specify it.  I'm not sure \njust listing a module as a library (and therefore orphan-allowed) is the \nright level.  Not sure it isn't either - just trying to wrap my head \naround it.\nJust to clarify what I read as going on here - if I have a module - its \ncompleteness is the marker of whether it is expected to have (explicitly \nor JIT bound) all necessary bindings available, so it requires no other \nmodules to satisfy the graph's needs.  Yes?\nAnd, then, semi-unrelated, if I have a module that will be used as a \nlibrary - as a set of pre-fab bindings consumed by some other, complete \nmodule, then library=true marks it so that any orphaned (present but \nunreached from an entry-point) bindings are not considered an error?\nAnd the default is that orphaned bindings are an error?\nI guess I can go along with that at this level.  But I still wonder if \nwe shouldn't have an @Library marker on the @Provides method itself. \n  Even as I write that, though, I think it's more likely that one would \nmake \"library modules\" whole-sale more than one would have selected \nlibrary-level bindings.  So maybe it's ok.\nSorry this is rambling - I'm trying to wrap my mind around this in the \ncontext of other conversations that Jesse and I have had.\n. Jesse's nits notwithstanding, I'm much more enthused now about this change.  Had to get my head around it, and that worries me for communicating it - I think we need to beef up the docs to be clearer, but it makes a lot more sense now. \nMaybe we need a table illustrating the different usage implications of complete and library.\n. Also, I want to steal that meme. \n. So, I think at this point we're a bit committed, insofar as we have \npublished a loader which produces code that, if we switched naming \nconventions, would not load newly generated code. In theory we could \nproduce a loader which checks both styles, but that way lies madness. \nThis seems like assumptions IntelliJ is making that are not to spec, \nsince $ is a valid character for naming of classes in the JLS.\n. From a very flakey Internet connection, I +1 that.  Though if we are going\nto change the generation API (naming conventions) I would like to call for\na quick check on whether we have the right names or any other API pieces in\nthe generated classes.  We won't have many kicks at this can.\nRegards,\nChristian\nSent from my iPhone.\nOn May 2, 2013, at 15:18, Jesse Wilson notifications@github.com wrote:\nOr switch to two dollar signs, to avoid conflicting with inner classes.\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/square/dagger/issues/206#issuecomment-17368462\n.\n. This is already fixed in head. If you're seeing \"c0 = blah\" then that \nmeans you're running a version that doesn't have the new generator fixes \nin place.  Next release should result in no warnings.\n. Good call.  +1 indeed.\n. Closing, as this is both referenced in, and should be handled by #225 \n. In principle, I agree with this, and with the assumptions you're making \nabout providing specific subtypes and \"breaking the warrantee\" in that \ncase.  I also think this should be enabled in the reflection back-end.\nThis is the right change, from an API perspective.  I'll have to let \nsomeone else critique the code, or get to it later, sorry.\n. The one case, Jesse, which field injection doesn't support well is that \nof listeners - registration of a listener or a multi-bound set of \nlisteners - is impossible without lifecycle post-create startup which \ndagger also doesn't support.  There is no way, short of an init() method \nsomewhere, to kick off such registration.\nI do not know this for certain, but I very much suspect we will need \nmethod injection (though possibly with some very hard constraints) in \ngoogle/dagger, but I wonder if we cannot achieve it in square/dagger.  I \nthink putting a doc together with the use-cases, and the key issues, and \n(practicable) constraints that, if applied, would make it possible to do \nit more simply would be good.\nI've just been waiting until one of our users really needs it - but I \nthink the listener case will be the one that is first needed.\n. I hear you.  And I can't argue this point well contra, because I'm not \nthe one who's faced it up-front.  @gk5885 (Greg Kick) had more to say on \nthis.\nThat said, I take your point about longer lifetime objects not depending \non shorter ones - including via callbacks (which listeners effectively \nare).  Certainly that creates a larger problem if shorter lived objects \ngo out of scope and the listeners are pointing to objects that should \nhave died.  It actually would be a memory leak even if the listening \nobject was able to function out of scope by some happenstance of the \nparticular graph.\nHmm\u2026 this seems like one of the strongest arguments for a message bus, \narchitecturally\u2026\n. I'm Internet-free for the next three days so I can't agree or disagree\nto things.  Sorry the timing sucks but blame Kevin Bourillion.  Anyway\non this issue I agree with some trepidation because naming is hard.\n:)\n. I wonder - I think we could do a partial graph .dot file for incomplete \ngraphs, leaving placeholders that say \"this graph needs these things \nthat are not bound\".\nWhether it's worth it for each and every little module is a question, \nbut it could be.  Have to think about that.\n. Semi-separate, but it relates, since this connects to singleton wrapper \nhandling.  Can we consider removing the singleton wrapper, and instead \nbuild the singleton logic into the generated and reflective bindings \nproperly?  Or have a singleton form of the reflective that is returned \ninstead, and the generated one will just generate the locking stuff \nappropriately if needed, and not if not?  It feels like an extra object \nfor no really good reason, and a delegated binding which complicates the \nlogic that handles such things, including the grapher and problem \ndetector.  Fixing things to handle singleton binding wrapper might be \nthe wrong answer.\n. Ick.\n. That's weird.  I thought we already were doing that - I do remember a \nconversation about it, but maybe it just never made it in.  Let's make \nthat happen!\n. This is awesome.  Thanks Adrian.\n. For the record, I'm proposing this to the square/dagger project.  we have complex-enough apps at google that I believe this would be valueable and we may take it on board in our fork if it's not seen as enough of a win in the main project.  I'd be cool with that, but I think it really is useful in the main project, so I posted it here. \n. Also, adding @gk5885 to this since it was in discussion with him that this evolved (and now I remember his username)\n. [reposting this because mail -> github SUCKS for formatting]\nI think 2 might be mis-stated slightly, but is an ok proxy for the idea. I would name things after their lifetime/phase/whatever, but in practice I think it's the same thing.\nI hadn't characterized it in terms of named graphs, but that's the essence, and then scoping annotations that are appropriate to the named graph.\nIn practice, client code would look a lot like Guice's use, but the underlying mechanism would simply use those signals for validation of user intent.\nBut\u2026 (3) is off.  It's not HttpHeaders -> @ForRequest HttpHeaders.  It's @Singleton HttpHeaders -> @ForRequest HttpHeaders.  If you don't mark something with a scoping annotation, it will remain default scope.\nAnd since it doesn't change the semantics, but merely provides validation/self-documentation, it should be optional.  An un-named graph would behave exactly as it does today.\n. Hey @gk5885.  So that makes sense, though optionally allowing someone to rename their top-level scope could be good.  I've seen people prefer @PerVM (with a static injector), @PerApplication, @PerRequest, etc. YMMV.  But by default, enforcing @Singleton at the top may prove helpful.  That seems to match most people's colloquial use of the term, and Guice usage in practice.\n. @RayFromSquare - the problem is that @Singleton and @Scope are JSR-330 types, and we can't just go changing them.  \nIn practice, it's not going to be much more complex. From the dagger end-user's perspective, they can just ignore this, or they can use it.  If they use it, it is merely a matter of passing in scoping annotations where you want to get the validation. \n. My \"counterargument\" comes in three levels, or \"scopes\" if you will.  ;)\nMy counterargument is about naming because the whole feature is about naming.  The current problem IS that the name Singleton is misleading, and risks people misusing scopes through misconfiguration. \nBut, my counterargument is also about complexity, insofar as I disagree with your subjective assessment as to the comparative complexity of the solution, from an API perspective.  I agree it is more complex than the current implementation, but I believe you get more value for that complexity than you seem to think.  I don't think that @PerModule(MyModule.class) or @Scope(FooModule.class) is any less complex, it just shuffles the problem in a different way.\nWe can (and if I didn't say it, let me correct) treat the default as @Singleton being synonymous with your top level graph, but that's doable in my proposal as well.  In fact, I would have suggested it as the default behaviour in my own proposal, except that I wanted to retain current behaviour if you didn't opt-in for backward compatibility.\nLastly, my counterargument is that the solution you propose cannot work the way you suggest, without assuming things, in advance, about the module set.  Namely, @Singleton can't stand in for @PerModule(MyModule.class) without relying on the implicit knowledge that MyModule is the module used for the top level graph that will materialize that class.  Even if we're ok with THAT, you would have to mark classes as @PerModule(SomeModule.class) in advance of knowing which module(s) will reach this class.  It ties the class to the module, when that class could be a reusable library class reachable by many valid modules.  \nScope hints on classes should be logical scopes, which are not tied to modules from the point of view of the so-decorated class.  The module itself is what links a particular logical scope to a particular hierarchy of graphs.\n. I'm OOO today but I'm actually on this and have something I hope to push this weekend.  I can take a look tomorrow when I'm back.\n. And I agree, the narrowest graph is problematic. We've run into that which is part of why I'm working on a change. \n. Similar to what your p/r API suggests.  I have a partly working initial cut which I'm working trough the validation stuff for. \n. Agreed on the subject of Singleton.  I think that one gets reserved for root.\nJust to clarify a titch more, the way I went is, you can mark a module as X.class (where X is decorated with @Scope etc.) but you cannot have modules composed at the same graph layer with multiple scopes (it'll crap out at compile time).  Similarly, an item that is scoped that is explicitly arrived at from a differently scoped set of modules, breaks at compile time.\nI'm struggling with JIT, only becasue I want to let it JIT at the right scope generation, but I don't want a stupid performance drain finding that generation, nor a horrid mess of signals internally to optimize on finding it. \nMy current behaviour is that _entirely_ unscoped generations (that is, no modules in that graph have any scope constraint) will back-ward compatibly let you use @Singleton out of the normal root-only case as a legacy support behaviour. \nBut unscoped modules that are included into a module with a scope, or vice versa, will make that graph generation scoped and obviously will cause a compile time error if those scopes are inconsistent, including adding @Singleton scoping where a generation was alternatively scoped.\nWe should break this permissiveness in 2.0.  Hard.  But for now, we forced this on users, and we shouldn't break them with an upgrade, since it'll take some time for people to un-stich and unwind @Singleton from their graphs in its current semantic of \"memoize this.\"\n. Can you please re-validate that this problem occurs in 1.1?  I don't think we've formally fixed it, but we've made some changes under the hood, and I wonder if we're handling things better in a way that happened to fix this. \n. Um... this has sat for a while - and bits have shifted on the website.  Did you want to merge and bring it up to date, Stephen? \n@swankjesse - what do you want to do with this?\n. This isn't really a bug, it's a request for sample code - we don't really have one, and I suspect that rather than doing some sample code, someone should write a test injector generating system as a separate project or a sub-project.  That would be a great contribution. \n. Maybe I'm missing what you're asking for, but iteration order is not guaranteed on a set binding.  I'm QUITE sure that we don't want to try to guarantee that.  It would require a lot of dependency on order of module inclusion, and the fact that modules re included in a particular order is a side-effect of varargs, not an API promise we ever will rely on.  We could have taken Iterable in create().\nBut most importantly, Set has no order guarantee.  We use LInkedHashSet internally for iteration speed reasons (and others, including jesse's prejudice... whutup jesse).  But we aren't exposing an ordered set, or exposing any promise to guarantee such order.  If we did, we'd probably make a LIstBinding not merely a SetBinding.\nWhat we do have on the table is some sort of notion of MapBinding, where one could sort the map keys and get a predictable order.  But we haven't implemented map bindings yet. \n. Feel free to re-open this as I've closed the PR. It's not a done deal that this is the right kind of change, let alone your PR being the correct way to do it.  The latter may be true, but I want to nail down the former first. \n. If it werent' for performance issues, I'd be tempted to put in a change that randomizes iteration order, just to prevent people relying on this.\n. Even in Guice, you can't do this with a reliable set ordering.  All someone has to do is change their module layout and you have messed up order, which is the wrong API.\nI would suggest we get MapBinding in so you can use it to create predictable orders. I expect we may do a Multimap binder on the google fork which would end up working more like unix inet.d levels (all these are at precedence level 3, and all those at precedence level 4)  But even map binding would suffice for controllable situations.\n. I see the desire, but you're tying result order to module installation order, and that, I think, is the thrust of what I'm worried about.  If you had consistent order on pulling from maps, based on keys and you control the key content, why can't you just pull out myPlugins.get(\"a\"), myPlugins.get(\"b\"), etc.?  Why does contribution order need to matter?\n. I think you lost me on \"put a mutable collection\" bit... \nYou would contribute key/value pairs in the form of \"somekey\" and YourPluginImplForThatKey.\nThen, you would inject\njava\n@Inject Map<KeyType,PluginType> myPlugins\nThen you just fetch them from the map as you see fit, using the keys for order if you wish. I wouldn't put mutable types in the graph and manipulate them.  Taht way lies very bad sorts of runtime errors.\n. I am in favor of having some exposure of the plugins, but I want to keep \nthe create() method clean.  I would much prefer a fluent chain for any \npre-configuration of the graph, separate from the create() method.  I \nwant the create() and plus() methods to only take the spec of the graph \n(modules). If anything, the create() method feels like the end of a \nBuilder chain anyway.  THat's the way I'd go.  I'm working up something \non this internally to google, that will probably make it to the fork, \nbut I can propose it here.\n. Yeah - that PR is a bit stale, and I wanted it as a talking point for discussion.\n. Ahhhh.  Please not two different jars.  That's going to be freaking \nannoying to maintain. Imagine multiple forks AND multiple build \nconfigurations - now we have more binaries.  Ick!\nI would rather hard-code options with an ugly API than go down that \nroad.\n. I presume you meant removePlugin().\nBut otherwise, why is this better than simply taking an instance of \nPlugin?  I get Jesse's overall discomfort, and I think I disagree, \nthough it should be a \"you voided the dagger team's warrantee\" if you \nuse it. But I don't see how registering plugins then using registered \nplugins is substantively different from simply passing in plugin \ninstances.\n. Hmm.  I actually don't like the short names, as the failure modes seem \nweird to me.  i'd rather say\ndagger.plugins=dagger.internal.reflection.ReflectionPlugin,my.custom.Plugin,\nor some such.  But the truth is, I would much rather not muck about with \nproperties.  I guess I'm sort of bought-in to the builder approach as \neasy to understand, more explicit, harder to fuck up, more prone to \ncompile-failures when something isn't present or valid, etc.\nI don't mind things being more invisible, but I don't want to keep \nstatic global state on plugins.  I can easily see someone having \nmultiple ObjectGraphs in the same VM, especially if someone is managing \ndiscrete and unconnected graphs.  I'm not trying to make this cater to \nthe 1% power user - the default would still be the current \nOG.create(modules);.  But mucking about with configuration files is a \nway to serious hell, I think.  It doesn't seem particularly daggery to \nme. :)\n. This is now a pretty obsolete request, though not 100% obsolete.  Module reflection is now completely disabled in all cases, the Plugin infrastructure is now better named Loader.  But I think the remaining issues are now a matter of getting to whole-graph generation. \n. Specifically, this is now somewhat taken over by #225 which should include analysis of the whole graph.  Marking this obsolete, and closing it. \n. Hmm.  We have something in-house that might be useful (I think Ben Yu wrote it and it might be open-sourced) which could test the annotation processing environment.  It's a bit different than what you are digging for here, but it might reduce some invoker testing, which is at least part of your goal. \n. So, the thing I saw had to do with faking out the compiler/processor environment stuff, and providing test-oriented Element objects, etc.  But also, Greg Kick has done some nice stuff with the Truth testing library that might make for convenient assertions about generated code vs. expected code that is not brittle text.  Once he's got it shaped up we can try it out with the infrastructure bits and see if we can turn some of the integration tests into unit tests.  Some need to stay that way because they really are testing that the build fails, but I suspect many can be re-worked... which will also mean much faster builds. \nIt should mean that tests of the form that @adriancole is proposing above should be possible. \n. Small update - Greg's stuff is amazing.  Should land soon, and we can covert all these invoker tests. \n. LGTM\n. Totally my bad for merging early.  I didn't realize the CLA hadn't been \nsigned yet.\n. Kick-ass idea, Jake.  Let me know how you do it, so I can implement \nsomething similar on the google projects, if possible.\n. Neat!  I need to talk to our open source folks and figure out where we keep\nCLA signature records, but this sort of thing sounds cool.\nRegards,\nChristian\nSent from my iPhone.\nOn May 24, 2013, at 5:32, Thomas Broyer notifications@github.com wrote:\n@JakeWharton https://github.com/JakeWharton\n@cgruberhttps://github.com/cgruberHow about\nhttp://www.clahub.com/ ? (or something similar, i.e. built on GitHub's Web\nHooks https://help.github.com/articles/post-receive-hooks and Status\nAPIhttp://developer.github.com/v3/repos/statuses/\n)\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/square/dagger/pull/255#issuecomment-18402036\n.\n. No.  While I think this change is a net-neutral one, it encodes an implementation behaviour that is accidental in the tests, and I am strongly opposed to encoding order guarantees that are not promised in the API. I don't even thinking having consistency between loader and reflection is necessarily good, as it is likely to cause people to depend on this behaviour... behavour that is highly tied to module order, which is wrong wrong wrong. I think this needs more fleshing out on issue #252 before taking this proposal onboard. \n. Updated the issue text slightly. \n. I'm trying to think of whether there are possible use-cases that are common enough that couldn't support a string key.  I am generally in favour of reducing the complexity, and forcing static string keys would definitely do so.  But it would also reduce any and all dynamism, in a way that's even more restrictive than Set binder.  \nMy problem with this is that then we are managing the content of the graph, not the structure... though arguably we decided to do that with making contributions to sets as well.  But with set binder we've already effectively decided that we're ok with a run-time exception for duplicates.  I wonder if we shouldn't be ok with that here.  The value of this is reduced, I think, if people can't dynamically create keys and values, just like the value of the setbinder is reduced if people can't generate set contents at runtime. \nI don't know... I'm suddenly quite wishy-washy on this whole topic. :(  I think I'm just worried about creating a feature that will have limited utility if we make it too dumb.  But I'm also not sitting looking at specific use-cases.  Maybe we should just keep this open, and ask for more use-cases before deciding.  So two questions.\n1. Are there any use-cases that simply couldn't use string keys, or string-mapped-to-something the way Jesse suggests above?\n2. Are static string keys sufficient?  (That is, are there use-cases which would require dynamically generated keys, that  we are willing to support?)\nAnd let's not pre-judge them and say, \"too complicated.\"  Let's see if any (or sufficient numbers) exist, and whether or not they could be re-cast to work with this approach.\n. @swankjesse - Etiquette check: you LGTM'ed it - have we moved to a self-merge-with-an-LGTM approach, or were you just opining and someone other than me should still merge it? I don't want the \"douchebag-self-merger\" bit flipped on me. :)\n. I inferred no lack of trust - just wanted to check etiquette.  Thanks.\nShall do.\n. I'm going to close this, as it is closed by #291.\n. This is something I might need to fix anyway, as I'm needing to have the \nactual module used to declare an entry point, or provides binding from \nwhich a class is needed, in order to fix a class loading issue.\n. Actually, I take that back - I think we're going a different way.  We don't hold the right metadata currently to trace the graph back through all the included modules - we can trace from the module that declared the entrypoint. I will think about how to keep that information without making it bloated. It might be that we let ProvidesBinding keep an extra bit of info, and if we hit a provides binding between a dep and its entrypoint, we use its module, since it's tied to the specific module.\n. Generated is part of JDK6, no?\n. Or, I could read ALL the messages before I reply. :/\n. Supporting android 2.2 doesn't affect build-time.\nOn 2 Jun 2013, at 13:00, Jesse Wilson wrote:\n\nWe still support android 2.2 though.\n. Well, let me open the question - should we handle these, and wrap, or should we reject them outright?  I feel pretty scary about constructors that fail, and I'd say no to them, or wrap them in a @Provides method that handles the failure gracefully, perhaps returning a null-object pattern or some such. \n\nIn general, Providers that fail are degenerate from Dagger's point of view, and that includes naturally constructors we wrap in a provider automatically. \n. Seems quite likely.\n. I'm submitting this separately, as it's a pure cleanup, and I'm toying with a few different modifications to loading, not just the one I issued as a pull request earlier, but they all have this refactor in common. \n. It's not just \"allowing flagging of errors\" - it's the basis for roots of the full graph analysis.  I think there might be value in finding some testable approach.\nWhat I would say is, firstly, consider mocking out the injector for all but end-to-end integration tests, and second, in an actual unit test you shoudn't ever be creating an injector.  You should be testing your components in isolation.\nBut for full-scale integration tests, I can see the value of being able to assert state on arbitrary objects to more finely tune error detection. \n. Greg and I are exploring some alternatives as well around entry points, \nincluding some nice pre-linking that should remove all loading except \nthe first load of the entry point's adapter.  I think we need to throw \ntogether some shared docs on ideas for how to approach it, and hash out \nwhat 2.0 might look like.\n. now() + N minutes.  :)  No idea as we don't even know what we want in it.\n. In these cases, however, you can provide a test module (often with \noverrides=true) that narrowly defines the types you need to pull out to \nexamine in the test, or even better, a TestEntryPoint class that simply \ninjects into itself bits of graph state for the test.\n. I have tests in mind.  I may have to submit this into our fork more hastily than constructing the test.  We have a project that needs it.  If this group is ok with me submitting a test separately, I can merge here, and port in.  Otherwise, I'll have to do this in two places and merge later. \n. my other approach was to go for module's classloader, but I realized that the amount of extra state we would have to keep to tie everything to its module directly (due to includes= and other factors) is an even bigger change. I ended up carrying the module everywhere and it was gross.\nBy tying to an entry point and using the owning loader, I'm following the logical chain of the real classloaders as they must exist for the hiararchical classloading to work at all.  Gak helped me see this by distinguishing in my terminology the requesting vs. the owning loader.  \nI don't think we want the context classloader either - I was searching for a sane default.  I think if we can't get this strategy, it would be equally hard to get the module's classloader. So going for the system classloader and simply failing to load is sane.\n. Will the getSystemClassloader() load classes properly in the compile-time bindings?  I don't know enough abotu the loader structure underpinning annotation processors. \n. Never mind - I can find out myself by trying it. :D\n. Yeah... I'm not sure we don't want getClass().getClassLoader() where we can't find the requester's classloader.  Taht would at least let it work in, say, a webapp where the webapp loaded Dagger itself inside its own classloader, but not from the system classloader. That's what Class.forName() does - the equivalent to Class.forName(\"foo\", this.getClass().getClassLoader());\n. Oh FFS.  LOL.  I get you now.  I completely misread it.  Ok - I'll fix.  That makes vastly more sense.\n. PTAL\n. Squashed and merge-conflict-warred with git after the whole classloader pull request.  Yoiks.  That made a mess for squashed rebasing.  :)\n. Warning in advance - can't squash this one or it'll screw up my re-integration into the google codebase.  MOE is brilliant, but sometimes dumb.\n. (Rather, I can't squash the first three commits.  Anything after I can squash into the third.)\n. This was cribbed and modified from teh interwebz, so while it seems to work just fine, I don't know if the precise android options are what we want. \n. So, \n- android update sdk --filter platform-tools,android-16 --no-ui --force\n?\n. Yeah. I'm usually not waiting on Travis for long, as I push and do other things.  The frequency of it being ready after I am is rare.   But it would be nice if it were instant.\nI'm going to try to reduce the dependency on invoker tests - keep them only for forced-failing builds, by testing the generator in other ways that are much much faster than forking a maven build.  That'll help, but later. \n. So is this cool to merge? \n. Thanks, jesse.\n. Java6-style annotation proessors can live side by side, as long as they \ndo not consume the annotation and return true from their process() \nmethod.  As long as they consume other annotations (i.e., not \njavax.inject.* or dagger.*) then they should happily live side by side \nwith Dagger.\nThat said, I'm looking at lombok source right now and I believe it does \nthe dumb thing and accepts \"*\" as the annotations it processes, and then \nreturns true in some cases.  This will be interpreted (if I'm not \nmistaken) as having accepted everything and processed everything.  It \nshould not do this, and I believe this can cause it to short-circuit \nannotation processing by other processors if they should be run after.\nHowever, that is a cursory 5 minute examination.  I see a lot of other \nthings around AST manipulation and byte code manipulation, so I\"m not \nsure what all it's doing under the hood.  I suspect it's more \ncomplicated, but the above statement - running an annotation processor \nthat accepts all types and then returning true is bad form.\n. It doesn't matter if the triggering annotation is a Lombok one or not.  If\nyou accept \"\" and you return true you block everyone else.  I believe\nLombok accepts \"\" and conditionally returns true.  As I read the processor\nAPI and as one of my colleagues observed through experimentation, returning\ntrue, ever, when accepting \"*\" shuts down all future processing as it\nasserts that all annotations are claimed.\nPerhaps I read the Lombok code wrong.  I did scan through quickly.\n Nevertheless I believe I observed the above in the code base.\nRegards,\nChristian\nSent from my iPhone.\nOn Jun 15, 2013, at 18:31, Reinier Zwitserloot notifications@github.com\nwrote:\nLombok does not, and never has, returned 'true' for accept() unless the\nannotation that triggered the call was actually a lombok annotation.\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/square/dagger/issues/277#issuecomment-19506320\n.\n. Cool!  I'm glad it returned false in all cases - yeah, I didn't run it \nor try it, it was a potential concern raised from a brief inspection of \nthe code.  I'm glad for the clarification though - it should mean the \ntwo can work together.\nIt does kind of suck that things like Lombok are necessary - they just \nfeel like they should be java features.  Urgh.\nThanks for digging into it.  Anyone who sees dagger failing with Lombok \nor other annotation-processing systems, please let us know.\n. Feel free to keep commenting to solve the particular issues, but it seems like this issue is closed from Dagger's perspective. \n. Dagger currently references Javawriter-2.1.0.  I'm going to close this out. \n. The second commit is a style fix for square, so I'll not want to squash it, so I can cleanly merge it back into the google fork. \n. Also, sorry about the rename fail.  I can't get it to recognize that rename-modify unless I reconstruct everything.\n. FYI: The mixing of the two validations into a single loop was just making things cleaner while dealing with an NPE in the original code when run across all annotation types.  When you support \"*\" the processor and round environments don't supply typeelements for all of the things it does otherwise, so, if no one is actually declaring:\n@Provides Lazy<Foo> foo() { ... } // The invalid case.\nor \n@Provides Bar bar(Lazy<Q> q) { ... } // The valid case.\n... then dagger.Lazy won't be present as a type element. \n. Or Jesse could merge it before all the comments are addressed. ;)\n. This breaks all the tests, also - I\"m figuring out how to deal with that. \n. So this is ready, but it sounds like android+gradle is not. However, we need this inside google and there's some shuffling around going on.  Can we resolve all of that on this pull request, and then, before I check this in, will re-enable the reflective fallback for now, so that it's a one-class-deletion, and a one-try/catch block fix in the google fork, which will be easy to merge up when square/dagger wants it.\n. So, just to echo for clarity, fine-as-is (as a strategy), \nnotwithstanding any code review comments/nits/issues?  I should not \nbother splitting the change into two phases?\n. And if so, can someone PTAL? :) \n. Ping?\n. Anyone... anyone... bueller... bueller...?\n. Can you help by critiquing the code?  :) Or are you +1 as is?  I just want eyes on my code so I don't miss anything obvious. \nThis sort of brings up a point - Who actually has the right to \"LGTM\" a change so I can know its been sufficiently vetted?\n. Thanks, @adriancole for the review.  I'm hearing crickets from other actors who +1'ed the concept in the other thread.  @swankjesse - any issues with merging? \n. Once this is in, actually, it helps us avoid one of the key weaknesses of Dagger, which is that if we rely on the compile-time error, we don't assert validity at runtime (unless you call the expensive validate() method).  But someone could throw arbitrary modules in including incorrect ones that had not had the full graph analysis done on it - this at least will ensure that that process must have happened, else we would not have a moduleadapter. \n. LGTM\n. Oh - wait.  we're making classes listed in injects= a provider?  I don't think we do that - we create a deferredbinding for it, but I thought we need a membersinject or provides binding for it to matter.  \nCan we replicate this with a test case, I'm not sure I'm following what's wrong here.\n. I see these instructions - can you please list the steps YOU are taking, \nwith the specific jars (named with version numbers), where you're \nputting them, and what you're doing in eclipse?  Those instructions \nshould work, but it's hard to know whether you missed a step, unless you \ntrace through your own actions and write them down.\nAlso, where are you getting the error - attached to what, in what window \nat what stage in your activity?\n. And yet, @Amorgos, it is the norm, because managed dependencies, aside from maven implementation headaches, are important when you have the kind of versioning that the Java world has.  \nFeel free to not use maven, but I recommend that you use ANY build system that can use the maven repository structure to obtain jars, since that's where dagger is canonically published.  This can be done with ant, gradle, ivy, or other build systems created by those who dislike maven, but want a common infrastructure for managing dependencies. \n. Since Module code generation is now required, I think generating this into the module handler is the wiser course.  Shall we test for anyone's @Nullable?  I think so, since it's at compile time that we generate the bits, we can afford a slightly more expensive peek to find an annotation containing @Nullable\n. Hmm.  wait wait wait.  You're pretty solidly changing the design and \nenabling optional injection by use of @Nullable.  I know that's the \neffect of now, but do we really ever want this?  I'm not so sure we do.\nProvision of nulls is sort of janky, extends the Binding syntax, breaks \nthe Provider contract (or extends it), and I think we need one bit of \nextra pause before going down that road.\n. Ok.  this is fair.  This is less optional injection, and more explicitly \nbinding a null, with constraints.  Upon further consideration I'm more \nok with it.\nI think we should support anyone's nullable.\n. So for Dagger 2 we are steering away from this, and just forbidding null.  Any serious objections?\n. Also, Optional injection in Guice has shifted to be, in effect, either injecting Optional or creating default bindings which can be overridden - I know Jesse and I talked about a default binding concept in Dagger 1, and it's something we started to hone in on in our MapBindings conversation.  But I think the argument for supporting null-returning providers is weaker and weaker.\n. My only problem is that we can't forbid it at compile-time without nullability analysis beyond the scope of annotation processing.  I'd love it if we could.  But we can make it so it's an immediate no as early as possible. \n. Hmm.  Static injection isn't really \"recommended\" - it is there largely for limited, legacy support purposes.   I say that only to explain why little love has been given this bug as of yet.  That said, I think this is an error worth fixing, since it seems to be a structural problem with our analyzer.\nMarked as a bug, and assigned to me. \n. It's tricky.  The circularity is why we didn't test that way.   We could make a fake Adapter parent, and do it that way - but I'd rather do that only if we make more of these. \n. So these aren't generated, they are hand constructed, but based on what we would generate.  They are intended to be valid loadables.   I definitely don't want them to be the long-term ongoing pattern - and I have a whole cleanup of testing of generated stuff anyway on the go, with other things of higher priority.  But please don't think we're checking in generated code - that's a misperception.  These were hand-curated like any Fake object you might create for testing. \n. I'm happy to leave all this off, but the error wasn't detectable except where we were using the failover loader, with parts not being generated.  At least the Module would need to be present, since not having a generated module is now an error. \n. Deal.  how's that now?  Just reused the test module adapter, overridden in-place.  It's all reflective in HOW it interprets the module, but it actually gets loaded by the loader because of the name.  Because it's a ModuleAdapter impl, it \"just works.\" \n. By the way, I did confirm that if I remove the ! from FailoverLoader, the test I added fails appropriately. \n. So, can someone please properly review this?  The current HEAD is broken without this fix. \n. I'd like to see SET_VALUE (singular) as a synonym for SET, and deprecate SET, as when Jesse and I talked about this idea before, we agreed that SET by itself, in the context of having SET_VALUES was ambiguous in a way that SET_VALUE wasn't. \n. I need to dig deeper and won't have a chance until tomorrow.  When I whipped up a small prototype of this for myself, I encountered a few subtleties, and I'd like to dig around a bit.  Especially as regards to the case of handling providers, e.g.:\n@Inject Set<Provider<String>> stringProviders\nThat's a direction which this may make much more difficult, but I'm not in a position to dig deeper until tomorrow.\n. I definitely would like to see SET_VALUES, but as a synonym for SET, with SET being a deprecated annotation property (can we do that?).  So we don't break people (and don't have to maek this 2.0).  Let's then remove that older facility when we throw down 2.0. \nI'll dig in and look at the Set> implications in your impl.  Finally got done with that stupid change to classloading caching, so I'm way behind.\n. Side note - We (notably Greg @gk5885) did a bunch of profiling internally and found that, in a high-performance server situation, they were using sort of micro-scopes with child-injectors, but it meant they were doing a classloader.loadClass() very very frequently in a class-loader chain greater than a few deep.  This meant that for N classloaders in the chain, N-1 stacktraces were being generated to supply all those ClassNotFound exceptions if the class was from the near-most classloader.  When the load failed, that work was done over and over and over (hence this P/R's choice to cache failures).  But even when it succeeded, it turns out that loadClass() is still slower than an in-memory cache of the class. \nGreg posted fairly substantial performance gains with a quick and dirty caching using (I believe) a WHM on classloader, with a CHM on classes.  I opted for a double-checked LHM so we could use an LRU strategy for cached classes.  If the classloader is expired from memory, then the WHM will drop it.  But I didn't want an interminable array of classes so I put an item limit on the inner cache. \nThis should make classloading in dagger about as fast as we can, short of eliminating the reflective classload entirely (something we hope to do in nearly all cases soonish). \n. So, since LruCache seems to work nicely for the inner cache, I think rather than try to pull in a concurrent weak hash map structure scraped from Guava, I'm going to try to do a read/write lock around the weakhashmap.  That seems like it'll avoid one-global-lock-on-all-reads, and keep the get() safe.  Unless anyone has a better suggestion. \n. PTAL\n. PTAL?\n. PTAL.  Reworked the caching as an instance variable of Loader, which is now an abstract class.  The whole thing is much cleaner and tighter.  The constraint on classloading is that if you want replacement classloaders, you junk the graph.  New (root) graph == new loading cache, so if you do fancy classloader unloading, you simply merge that scope with your application/top scope, and recreate the root when you reconfigure. \n. Heh!  So, I'm not sure how it'll interact with IntelliJ, because I don't know how fine-grained IntelliJ's classpath infrastructure is, and how that maps to maven's main/test separation.  Eclipse has one-classpath-per-project, which is why this change won't work there, because it can't run the annotation processor from the same javac run that compiled them. \n. @swankjesse - it's a known limitation we intentionally didn't fix, but \"we\" need this fixed.  I realize that the desire is to get to whole-app generation, but in looking at this, we realized we need a fix in the shorter-term than the longer term.\nI think your logic is suspect with respect to the swapping in of new supertypes with @Inject.  You're talking about taht event \"not causing C to be recompiled\" because B may not be in the same project.  But that is true with any change to B, and you're proposing that we support he use-case where someone alters a supertype, and doesn't re-compile the children of the supertype.\nFirst of all, if you're in a maven context, that is, while not impossible, extremely unlikely.  To bump the upstream dependency version and release, you need to re-build the dependent project.  C will get recompiled.  In most other cases, it is similar.  In the rare case where it isn't, you're entirely at risk of B having a binary incompatibly breaking change anyway which C is assuming the old structure, so the problem is there in Java, not in ours.  You're asking us to forgo a fully code-genned solution to support an edge case that is already problematic in any java code.\nI think it's entirely reasonable for us to expect anyone using this in a dependency-aware build system (or, you know, any build system) to re-compile children of altered parents.   Period.  With that assumption in place we can get on with thing.  I'm not going to re-open this, because I want to come to some understanding before I do (don't want to precipitate a pull-request open/close war. ;)   But I do strongly feel that this functionality outweighs the risks, given the nature of the risk and the nature of Java development. \n. Oh, and as a side note, @swankjesse, Steven wrote this after discussion with Greg Kick and I in which we decided that the risk you are describing was outweighed by the value of the feature, and that this edge case mis-use of build systems wasn't one we felt we wanted to support.  That may, ultimately, mean this goes in the google fork, which is fine, but I think it's worth having this discussion here. \n. We use Blaze internally, and build from source (no binary dependencies in the way open-source projects do), but we pretty much use maven for open-source projects.  So we won't feel the pain internally, by any means.  My suspicion is that there is no build system out there (including maven) for which you can bump a dependency version and then push without rebuilding, unless you're deliberately circumventing build processes.\nAnd for those few who are manually cobbling together jars, I cheerfully welcome them into the second decade of the 21 century. \n. No, I'm putting my faith in people's consistent use of reasonable release processes... like you build clean before you push to maven's central repository.  I'm not talking about maven's compiler plugin getting it right.  The frequency of someone getting hit by what you're describing is the frequency by which one actually releases software into production without a clean build.\nAnd I repeat, I'm not convinced any of us want to support that use-case.  It's madness to rely on not building clean, while swapping in up-stream dependencies.  \nI'm not suggesting these things shouldn't be fixed (by design or fixed in implementation).  And I recommend, since you saw the error in maven-compiler-plugin, propose a fix.  :D  But seriously... who does this?  Really.\n. LOL.  Ok.  I get you. Though, so as not to get diverted by a cute response: For \"Fixes\" I meant fixing the build infrastructure to not suck, since Thomas actually mentioned where, in maven, the failure to notice and account for upstream change lay.  \nIn practice, for me, even in development, I nearly never omit clean in maven either.  Given that compilation is <10% of the time taken in my builds, the rest being unit tests (far more if I'm running integration tests), there's rarely a payoff for time-saved from incremental builds for me in the build system.   In the IDE, perhaps.  And that's important.  I can relate to the frustration in theory, but only in the IDE, and even then, I guess I'm used to all sorts of ways IDEs get out of sync and need a clean build. Is it frustrating? Yes.  I'm also not wanting to design my framework around IDE bugs. \nI guess I am, essentially, apologizing for the need for an occasional clean build, but this isn't really a problem in our framework, this is a problem in the state of IDEs and incremental compilation.    That said, I see your point - you implemented around this bugginess as a solution to a problem you encountered.  I tend to prefer a sound production scenario over a sound development scenario if I'm forced to choose, which we seem to be here.  We've clocked some real and not-insignificant speed reductions in production because of failover to reflection in our apps, so the current solution is optimized in the wrong direction from our users' perspectives. \nWe'll put it in the fork, and see how it plays out.  I just wanted to be clear and flesh out the fact that the above isn't inherently the wrong design, and the current design isn't inherently the right one... Dagger currently contains a design element inside our framework to account for a buggy build environment that doesn't permit (safe) incremental builds in an irregular case of supertypes being altered without invoking the children.  I think we disagree over where the focus on correctness should lie (development vs. production), but I am comfortable with that disagreement.  This is why we fork. :)\n. Hold off on this for a bit (like, still today, but I have a few minor fixes from our internal repo that I think should sneak in.  I'll roll a req for them shortly).\n. Ok - I'm ok with this going forward, with the note on features above. Is anyone going to be awesome and map these to a milestone and assign p/r's and issues to that milestone? :D\n. This one I'd rather not squash, as they are three entirely independent commits that fix different things.  I just put them in one pull request for brevity of review. \n. That's sort of a different issue, @adriancole - I'm not sure we want to build defensive checks against other frameworks into dagger, as that's going to be hard to manage.  However, I can see making a side project for such checks.  But these checks will do things like show warnings if you're using javax.inject.{scope/qualifier} based annotations, while not actually using @dagger.Provides or @javax.inject.Inject (as appropriate).  We can't make them errors, since it's entirely legitimate to have a guice `@Provides method with a javax.inject scope/binding annotation... but if you have dagger in your classpath, we can throw a warning, since it's likely not what you meant. \n. With eclipse, I use m2e's \"m2e-apt\" plugin which lets me auto-configure annotation processing from within eclipse.  I have no idea how intellij works with maven and annotation processing, but the fact that it wouldn't generate sources unless you removed optional seems like a HUGE bug.  Maven generates sources without removing it, and it's maven's configuration, so this leaves me concerned that IntelliJ isn't interpreting maven metadata correctly. \n. By the way, there are two reasons for hte re-factor.  One, it cleans up the processor code more nicely, so inject adapter and static injection writing are reusing more code, and the shape of the generate() methods is easy to scan over, with the writing of pieces in write() methods.  But also, if we do this refactor in both places, then it also provides a much cleaner separation of his feature in code, so the two forks will be more alike, but for the feature delta. \n. plus() doesn't override - plus extends the graph.  You can't have the \nsame binding in a parent and a child graph, period, even if you're \noverriding.   This isn't like Object-Orientation's notion of overriding, \nwhere the child overrides the parent.\n. No quick thoughts on a fix, but I think this is a problem.  I need to mull this over. :/\n. I believe this is fixed by a combination of #347, #342, and #332.\n. Rather wait until we had some solutions - sorry for my delay - had a lot of other things pop up, and just got Greg Kick's compile/processor test thing working in my environment, whcih was in my way.  Testing this with invoker integration tests is going to be horrible and slow. \n. Also, I'd rather not see this go in, only because I don't want people getting the scope Singleton as a default.  I plan on the semantic being Singleton as a backward compatibility thing, but using a null-object Scope that no one should be using explicitly to indicate \"didn't specify\" so I can distinguish between people explicitly setting Singleton.class from not setting any constraint. \n. Add a NoConstraintDontUseThisScope.class and I'll be happy. :)  \nJoking aside, I'm not sure if I want to use phrasing similar to default or NO_SCOPE for this purpose, as that's kind of overloaded with the terminology of not being memoized.  I think NO_SCOPE_CONSTRAINT is probably what I really want. \n. The other issue here is that some of these should NOT be enforced in the run-time, because the run-time costs are going to be large, to get all the edge cases right, and we now enforce module adapter generation, so we can do this all at compile-time, and if you are using a module adapter, we can be sure it was only generated in a compilation job that was valid - ergo, passed all the checks for scope consistency.  I'll have a P/R in the next couple of days with something, we can compare and contrast.\n. Sorry for the massive delays on this - I had to deal with some other things internally.  I am nearly there with a pull-request-worthy thingy.  I have the core structures in place, and am just fleshing out the validations and test-case coverage. \n. In this case, you can still pass a module in as an instance, even if it is included by another one - we prefer instances over classes, since stateful modules have to be instantiated and give their state in advance of ObjectGraph creation.  So in your tests, create the graph wtih your test module, but pass in the instance:\njava\n  ObjectGraph.create(TestModule.class, new CartModule(someState));\nDagger will just use the instance instead of attempting to instantiate the module. \n. My intention is to convert the rest of the invoker tests ASAP, but I wanted this in, with a POC of the first few tests, to give everyone a sense of how they work.\nTesting this way is in-memory (in-memory file system backing the compiler), can be pulled from string sources or compilable java files in resources/ folders, and, while still an integration test, is crazy fast, and reads cleanly.  For smaller tests, you can have the test sources and the assertions all in one easy to read package.\nNot highlighted in this P/R is the ability to do not only the failure tests, but also success tests where you can assert about code that was generated.  Once this is in I can show one of those. \n. I'm including two more tests in this P/R, for illustration.  Sadly, the .generatesSources(source1, source2) is a bit brittle.  It works, but error reporting is thin (for the moment, I have some bugs filed).  But the examples should show the compilesWithoutError() and generatesSources() cases nicely. \nAs to the compiler version, we need to fix it so it works in 6 and 7.  There is no reason other than stupid internal API drift in the compiler that it can't work in both, and I may resort to a reflective lookup of the JavacTool.getStandardfileManager() method to let it happen regardless of versions.\n. @adriancole - PTAL?  Anyone else have more thoughts before submission? I would like one quick look over since I added things.\n. Oh, and please note - the .generatedSources() does an AST-based comparison, not a string comparison, so you can use abbreviated, compressed, whitespace-altered \"expected\" code like I did here, and it still treats them as equal. \n. There is also a generatesFiles() version that does string comparison, so you can test more exactly. \n. Right?!   Told you it would be. Lol. \n. It is not a limitation of dagger, it is a misunderstanding of what plus() is for.  it is not for testing... it extends the graph in the mathematical sense of adding more things that can be injected/fetched.  It does not permit module overriding, as the graph must be stable and the extended graph is part of the extension graph definitionally.  \nThe intended use of plus() is to permit one to group some bindings into a separate, shorter-lifetime graph that can be thrown away, such as for a given web request, etc.\nThat said, the second one CAN work, if you use the proper syntax for having one module add to another via plus(), like so:\n@Module(addsTo = MyAppModule.class)\npublic class MyTestModule {\n    \u2026\n}\nBut, don't do that for testing, do that for scoping.  Instead, do this:\n```\n@Module(extends = MyAppModule.class, overrides = true )\npublic class MyTestModule {\n    \u2026\n}\nObjectGraph objectGraph = ObjectGraph.create(new MyAppModule(context), new MyTestModule());\n```\nThe Module Overrides section at http://square.github.io/dagger/ explains this a bit more clearly. \n. No no. Extends I merely used as a verb to describe what plus() at runtime, and addsTo at compile time mean and do.  We could not use the work extends as it is a java keyword.\n. Sorry - my example code included the main application because I was presuming your app module was an android one and needed a Context and so was stateful.  If your scenario is much like the demo CoffeeApp, then you would not need to include the extra instance, though there is no harm in doing so.  \nDagger will create instances of any modules passed in (explicitly or implicitly) as needed, if you did not pass that module in as an instance.\n. I think this should be taken to the dagger-discuss list, or posted as a stackoverflow question.  This really isn't the forum for this kind of question, unless you are proposing a change to dagger. \n. This entirely depends on your configuration.  You must have some way to configure annotation processing.  If it is in an Eclipse IDE, then you need to set up dagger-compiler to be in your \"Factory path\" for annotation processing in that project's properties.  If you are using maven for command-line, then you need only ensure that dagger-compiler is an optional or provided dependency in the dependency list for your project.  Otherwise, I'm not sure how to advise you, but you MUST generate module adapters at compile time or Dagger will not run.  That is by design. \n. I closed this issue, but if you want to post more about your build environment, we might be able to help.  But this is not a dagger issue, it's a configuration issue on your side.\nAlternately, I encourage you to post this on stack overflow, including information about your build system so folks can help you in a searchable forum where others might benefit. \n. Hmm.  I'm not a gradle guy at all.  @JakeWharton - do you have any insight?  \nMy first thought is this - \"processed sources\" are only the additional adapters, they aren't \"replacement sources\".  We generate new code, we don't modeify existing code.  So all the normal .class files are legit - you just ALSO need to compile the apt_generated sources along with, and that seems like a gradle configuration issue that I don't know how to solve off-hand, sadly.\n. So there seems to be a few ways this can manifest, one of which I reproduced and fixed, the other is coming from these sorts of imports.  Do you have a set of very small reproduction files for this error, @jponge?  I'd like to get this fixed finally, and I think seeing a concrete example of this would be ideal.\n. So, two fixes went into 1.2 that should fix this.  Has anyone checked this issue against the current head?  I'm going to tentatively close this, but if someone repro's this with the current head, please feel free to re-open with more details of how it is failing under the current version (which should report errors more easily).\n. Hmm.  This should be fixed, but perhaps isn't pulled in from the google \nrepo.  This is likely an upstream compilation error that we are \naccidentally masking, as upstream compilations will often cause javac to \nemit bad AST.\nCan you please verify that you have included the import statement for \ndagger.Provides and dagger.Module in all of your @Module-annotated \nclasses.  We see this problem most often when you have forgotten an \nimport somewhere.\n. Per conversations with @gk5885, I think the right answer here is to have an element scanner at the start of the processor which checks the root elements and if there are error elements, it skips to give other processors a chance to resolve the errors (by creating the classes in question).  \nAs a secondary defense, I think we should also guard all of our process() methods with a try/catch on RuntimeException so that we report errors, not crash the javac job.  I'll whip something up for both of these cases. \n. I've replicated this error in a test, in a couple of different ways, and am working up a fix. \n. Ok - I have a fix, at least for the cases I could work up.  I am just cleaning it up since I did a lot of gross things while experimenting.\nAt this point, the processors can handle:\n@Module(injects=NotYetGenerated.class)\nclass FooModule { }\nand\n@Module(library = true)\nclass FooModule {\n  @Provides Foo provideFoo(NotYetGeneratedFooImpl impl) {\n    return impl;\n  }\n}\nAnd.\n@Module(library = true)\nclass FooModule {\n  @Provides NotYetGenerated provideIt() {\n    return new NotYetGenerated()\n  }\n}\nIt even can handle some generics, specifically\n@Module(library = true)\nclass FooModule {\n  @Provides Foo provideFoo(FooImpl<String> impl) {\n    return impl;\n  }\n}\nbut not\n@Module(library = true)\nclass FooModule {\n  @Provides FooImpl<String> provideIt() {\n    return new FooImpl<String>()\n  }\n}\nIn the former cases, the Error nodes returned contain enough type information in text to pull out in order to generate the correct things.  In the last case (returning a Generic type) the Error nodes from the compiler contain, and I kid you not, a toString() of \"\".  That string literal specifically.  There's just no type information, not even type name information, in the error nodes if you are returning.  So I have a \"failure test\" to illustrate this.  Obviously this affects only cases where someone is, say, generating a type with generics that they are using in an @Provides method.  If someone needs this, they'll have to generate it in a separate javac process, i.e. a different maven project consumed by the @Module library in question.  This shouldn't affect JIT binding, since Dagger doesn't support JIT binding of generic types.\n. Crap.  Crap crap crap.  Except that the solution I have only works for non-packaged code (code in the default package).  The package information for the symbol is missing.  It's just the simple name in the error node.  I'll lick this - just have to figure out a strategy for inferring the package. \n. Yeah.  So this works:\nimport somePackage.Foo;\n@Module(library = true)\nclass FooModule {\n  @Provides Foo provideIt(somePackage.FooImpl impl) {\n    return impl;\n  }\n}\nbut this does not:\nimport somePackage.Foo;\nimport somePackage.FooImpl;\n@Module(library = true)\nclass FooModule {\n  @Provides Foo provideIt(FooImpl impl) {\n    return impl;\n  }\n}\nbasically the Error node contains the raw text of the type as described at the site itself, and does no attempt to lookup the import statements and pass the package information.  This will restrict the usefulness of \"upstream\" code generators within the same javac process, but at least generators can work.  But they have to generate really annoying code by using fully qualified class names.\n. See that pull request above?  That one, once it's committed, should be in head and fix this issue, at least several manifestations of it.  So... any day now. \n. (As in, just waiting for a completed code review and approval to merge.)\n. So the issue is apparently still there in \"gh/google/auto\" in their dagger integration, so I haven't caught the whole problem.  I'm going to keep digging. What I repro'ed in the tests was similar, and deceptively so, but apparently not exactly the same thing.\n. I'll try it out. \n. Can you replicate the error androidannotations with 1.1.1-SNAPSHOT built in your own environment from head?  This version as of this fix seems to work for autofactory.  Hopefully it fixed your issue also.\n. This has been validated in two places, so I'm closing this issue.\n. Can you post the test-case on this thread?  I'm not sure I'm following the concrete specifics of when it goes awry. \n. Crap - I'm brain-dead.  The code is above.  I'll try to repro it locally using that.\n. This seems fine to me, but I haven't validated the gradle config logic.  Can someone who uses gradle validate that?\n. Hey @gk5885, this should at least make the ClassCastExceptions not break the compiler, and as long as the generated code dagger's adapters depends on is referenced using fully qualified class names, this will work. \nUltimately, whole-graph generation is the final solution to this issue, since all the types will be present in that situation.  But for now, this should move the ball forward.\n. Anyone have further issues with this?  id like to integrate it as I have a really really big refactoring of the processors that I would very much like to issue a pull request for, but which needs to incorporate this. \n. Ping?\n. Done.\n. Thanks.  My main stress at this moment is how to rationalize overrides=true with this.\n. That is a fair representation of my concern, @adriancole.  But, I guess I'm not just worried about implementation artifact, but what overrides= even means in this context, from an API perspective.  Essentially that all overrides set bindings should replace all non-overrides set bindings?  I'm just struggling with the actual contract here. \n. Yeah - and looking at the makeGraph() method and how it does overrides, that is conveniently the simplest to implement.  I think I'll go that way.  Thanks for the insight Jake.  It clarifies something I was more slowly coming to by inspection of the internals.\n. While the parent-graph/child-graph startup example @gk5885 gives can be hacked around by having two (or N) sets (one for each scope), and having a separate object (or provides) combine them, the amount of work-around boilerplate for that approach is horrendous and more confusing than the (to me) obvious and unsurprising behaviour of unions of sets.  I'd rather do the unions, than the errors simply because the real use-cases people want this for would be so tortured as to be worse than the error modes of mis-specified graphs.  \nI take the theoretical point @swankjesse is making, but I think we have a utilitarian case for unions being less confusing, and more maintainable for the developer.\n. Ok.  Sounds good.  I have a pull request in play with this change.  So we should be good to go once that's in. \n. Hmm.  Other way around - Lazy requires Foo.  Or rather, technically, it requires Provider.  But from a sort of structural dependency, Lazy is a wrapper of foo, and providers are all implicit, so I\"m not sure how to best represent that in the digraph.  \nIt might be reasonable that if Lazy and Foo both occur in the graph, we can add Provider and have them both point at that.  But I'm not sure.  Is it not clear what the graph intention is?  \nThe simplest way I can see is to simply have Lazy point at Foo, because by the point where you get() on Lazy it will either HAVE created or WILL create Foo before get() returns.  That suggests to me that Lazy -> Foo.  \nAnother option woudl be that Lazy isn't a node, but we special case it, and it becomes a specialized edge in the digraph - where we link Baz -----> Foo and Bar ---lazy--> Foo (or something along those lines)\n. Oh no.\n@Provide Foo provideFoo(Lazy<Foo> lazy) { }\nThat should break, hard.  That is a circular dependency, specifically, and should fail at compile time.  If it doesn't, we need to file a bug.  I think there is no plausible way to think of it as Foo -> Lazy given what lazy is... it's simply a lazy creator. You're depending on Foo... but only actually demanding it when you use it.\nAnyway, I'll play with digraphs manually and see if I can come up with something visually useful. \n. So how about something like this: \ndigraph G1 {\n  concentrate = false;\n  n2 [label=\"A\"];\n  n3 [label=\"B\"];\n  n4 [label=\"C\"];\n  n5 [label=\"D\"];\n  n6 [label=\"E\"];\n  n7 [label=\"F\"];\n  n8 [label=\"G\"];\n  n2 -> n3 [fontsize=\"10\", style=\"dashed\", fontcolor=\"goldenrod\", color=\"goldenrod\" label=\"<lazy>\"];\n  n4 -> n3 [fontsize=\"10\", style=\"dashed\", fontcolor=\"goldenrod\", color=\"goldenrod\" label=\"<lazy>\"];\n  n5 -> n2 [fontsize=\"10\", style=\"dotted\", fontcolor=\"blueviolet\", color=\"blueviolet\" label=\"<provider>\"];\n  n4 -> n5;\n  n4 -> n2 [fontsize=\"10\", style=\"dotted\", fontcolor=\"blueviolet\", color=\"blueviolet\" label=\"<provider>\"];\n  n6 -> n3 [fontsize=\"10\", style=\"dashed\", fontcolor=\"goldenrod\", color=\"goldenrod\" label=\"<lazy>\"];\n  n8 -> n7;\n  n8 -> n2 [fontsize=\"10\", style=\"dotted\", fontcolor=\"blueviolet\", color=\"blueviolet\" label=\"<provider>\"];\n  n7 -> n3 [fontsize=\"10\", style=\"dashed\", fontcolor=\"goldenrod\", color=\"goldenrod\" label=\"<lazy>\"];\n  n4 -> n6;\n}\nNote - concentrate = false results in slightly better lines in larger graphs.  Otherwise, they end up merging where they shouldn't, like a normal dependency laying over a lazy/provided dependency, so it's obscured.\nI separated provider and lazy by both colour and line style, as well as adding a little label.\n. To get a clear view of how this is supposed to work in practice, the new test file in this P/R should demonstrate the behaviour.\n. One of our teams with very high server load tested this out and found that this lock was under contention more than nearly any other (but two) locks in the whole system - it may well be true that GC stutter on an allocation-sensitive VM might be the trade-off.  I'd like to see good profiling of this on Android, but I don't have the expertise.  \nSo one option is that we have two memoizers.  An LruCache-based one that does the old verison, and a read/write lock version, either of which are legit.  They key question is which you get, and by what API?  We could default to the LruCache-based one, and use the alternative based on a system property, or some similar under-the-hood mechanism.  Alternatively, we can do a sort of ObjectGraph builder which lets you optionally specify an alternate memoizer.  \nThere are lots of ways to do this - one is really dumb simple, but blunt: \nObjectGraph.optimizedForServer().create(blah).\nAnother is a sort of SPI that I know @swankjesse is going to be uncomfortable with - more like\nObjectGraph.withMemoizer(MyMemoizer.class).withLoader(FailoverLoader.class).create(modules);\nI tend to prefer this because it results in less surprise for the developer - the code is all there, and really obvious.  It reads cleanly, and we already have some hidden contract around Loaders that this can be a bit cleaner. That said, Loader is a less important use-case than the memoizer choice, since that is a specific environmental difference in which context you would definitely prime your app.\n. I have a fix I'm working on to cache the mapping a bit better - still not the 2.0 solution, but better.  Greg is noodling with a 2.0 prototype concept which we're going to workshop soon, but we're all in NYC next week, and we'll see if it's a direction we want to promote. It should eliminate all duplicate work in plus(). \nI'll fix the comments in a fresh commit (still in this pull) to keep the merges easier, forthwith.\n. Ugh.  Yeah - that's going to be problematic for us.  It would force an org-wide upgrade inside Google for anyone using Maven and, while it's not a high percentage of projects (we have our own build system), it's going to suck way too much of my time. :(  Let me think this through tomorrow, and see if there isn't a profile-related way to solve this.\nWorst case, we can simply ignore it since internally we are using the google fork, so maybe it isn't that big a deal after all - but still, the fewer deviations between the forks that are unnecessary, the better. \n. I don't think we do.\n. This looks good.  I still wish we could interrogate about these generated types, without having to spec out the whole thing - I can see a lot of hell when things change, just chasing down all the little brittle string definitions.  But it's way better than invoker, that's for sure. :) \nLGTM - thanks for doing some back-filling.  It's needed.  Any time you want to convert an invoker test, go for it - the more we can remove those the faster all our builds get. :) \n. LGTM\n. Adrian, I can't remember - do you have merge rights?  If not, let me know and I\"ll merge it.\n. Looking at the project, it seems not.  Merging. \n. Ok - this is now fixed. Please someone take a look.\n. I think it was a habitual oversight because of doing so on InjectAdapters in reflection mode, to overcome people making things package-friendly and thus having dagger's code not be able to access it.  We generate these constructors to be pubic, so it's all in our wheelhouse.\nFYI - this is failing on a checkstyle issue, which really is bogus - I have another P/R for that.\n. Heh.  I was about to re-base, but your merge works too. :)\n. FYI, to jesse's comment in another CL, we think this is a javac bug, but in performance critical code, it turns out to save about 1/3 as compared to string builder. That's not many, but for key generation which we do all the time, it seems worthwhile. \n. Yeah - it ended up being a well tested change in our build system, in practice, so we didn't write one.  I'm exhausted or I'd whip one up - but I think there's much higher priority work I need to do, sadly.  I have a bunch of change I want to make to the graphviz generator, and once I do that I'll try to fill out the tests.  Especially since we now have ASSERT.about(javaSources()).that(thisCode).compilesCleanly().and().generatesFiles(thatDOTfile) to write tests with. :)\n. Yeah - that was @gk5885's commit in the google fork.  If you don't mind, and if you think of better names for the test, can you do a pull with the tests renamed?\n. By the way - this is impossible to test without a really screwed up compile situation. In our case, it was caused by an optimization we are doing in our build system that didn't take into account annotation processing needs.  We'll fix it internally in our build, but the error showed the overeagerness.  Staging a test for this with a working build infrastructure is crazy hard. \n. Oh - better name!\n. Oh - and the check-by-name is obviously to avoid dependencies on internal classes of a given compiler environment. \n. For the record, I'm running some pretty server load across this internally to validate.  We have a customer who converted a lot of their stuff over, and have a very very large root graph, and this is hitting them hard.\n. Actually, the \"make it possible for a linker to be transitively linked\" was how it worked a few commits ago.  I undid that, and reverted it for this change, since that linking turns out to have a lower downside risk at scale, since breadth of bindings lists will more likely grow far far faster than plus() depth.  \nNot sure what you mean by \"Reverse documentation\"  /is_confused\n. So existing profiling is \"Better but not THAT much better\" because the existing code used didn't have a huge parent graph.  I have a version that does that I'm testing, but I\"m waiting for the results.  It's definitely an improvement, though a modest one for small parent graphs, obviously.\n. Ahhh.  got it.\n. Ok - so don't merge this. I've changed the CL on the google side, where we're testing it, and I'm going to re-apply this from that side.  The solution is more or less the same, just a little tighter in implementation.  But I have to merge in two directions, so let's not block the release - this performance improvement is not significant for the android case, and it's not a breaking change, so 1.2.1 nearly immediately is fine. \n. Hey.  I love my code, but I love having happier users more. :D\n. Huh.  I thought we handle that case specifically.   :/. But yeah, that's fixable. \n. There's already logic there to disambiguate the incoming parameter if they use reserved words (and I think \"module\" is the only one).  Not sure why this isn't firing.  I'll try to repro it. \n. Do you have a fork/branch I can sync to?\n. God, @gk5885's system makes this so easy. :)\n. If you like.  I wasn't imagining this as \"in for 1.2\" but if you haven't cut 1.2 yet, then sure.   Just waiting for travis. \n. BTW, this was discovered in a proguarded app internally where they had pro-guarded away a module by mistake, and the resulting error was an exception that said, something like:\nnull could not be bound for key Provider> required by Bar. \nIt was really dumb as an error message. \n. Hey @JakeWharton - if you haven't cut 1.2 yet... ;)\n. It's nearly the same. A few minor changes, but some of it is re-playing commits and fixing them.\n. Thanks!  That was fast. \n. Dammit... just as I had a breaking API change I wanted to make (to get a performance win on the server). :/\nAh well - it can live in our fork for now, and we can do a 1.3 when people feel it's appropriate to require people to generate code again. \n. Uh... travis' output is confusing.\n. LGTM pending travis being sorted out. :(\n. So will the commit that supports maven 3.1 in the android plugins break on <3.1?  That would be a problem. \n. Yeah, well, we can work around it - but I don't think we're about to upgrade all our projects to maven 3.1 just yet - maybe once we have some things in place I'm working on right now.  But just now, it's not all harmonized so trying to move things to 3.1 would be a bit fraught.  That said, leave it for now.  We can deal.  This will at least make Travis happy and he's our only CI for this project just now.  I'll sort the rest out.\n. @JakeWharton - is 1.2 cut?  If not, we should set this to milestone-1.2\n. SGTM\n. This broke a use-case we don't have an adequate test for, reported in #364.  This is release-blocking now.  We need to either roll it back and re-submit, or branch for release just before this point. \n. Or hold the release, while I fix it.\n. On it.\n. Use this list as inspiration: https://github.com/square/dagger/issues?milestone=3&state=closed\n. I would just cut-and-paste, and strip out extraneous stuff, then just collapse related things into english.  Or something.\n. NOTE - do not release.  We have a bug at head.  If you need to release, release from just before my performance fix.\n. Ok - bug should be fixed via a roll-back.  Feel free to proceed.\n. You need the actual dagger dependency to be available at runtime. \n. Sorry - I\"m not a gradle guy - I literally know nothing about how gradle specifies, or how its dependency scopes work.  A brief examination of relevant web-pages tells me that dep configurations don't work like maven scopes, though you can simulate them.  But I have no idea how without further investigation.  I would check on the gradle lists, or post a stack-overflow question. \nAs to my earlier comment - I'm only making a statement about an environmental constraint, not about how you configure that in gradle.  And I'm observing that the bytes aren't there in your run-time classpath, or you would not get a NoClassDefFound.  :)\n. Hmm.  There was a change I put in where we don't always generate the members/ injector injects list, if you have a provides method that provides it, or if the type doesn't have an @Injects field.  But, I wonder if perhaps there's a bug around classes in an inheritance hierarchy.  I'll replicate and see if I was overzealous and fix it. \n. No - I've replicated it.  It's clear enough - in order to fix something in dagger on the server, performance wise, I ended up breaking a feature... well, an allowance.  We let things be members-injected slightly more generously and so we end up generating members-injection keys for things that may not need them, because members-injecting something that has no @Inject fields is a no-op. \nBecause:\n1) we add members/foo.BAR keys for types in injects=, in order to permit this behaviour, \n  2) we link everything when we do .plus() to avoid having things JIT bound in child injectors\n  3) we fall-back to reflection if we haven't generated inject adapters\n  4) we don't generate adapters for types that don't have @Inject constructors or fields\nTherefore, we end up doing a hell of a lot of reflective lookup on server apps that have a lot of provided types that are listed in injects=.  \nMy change #359 was intended to soften this by not generating these extra members keys, but these keys were used specifically to identify what types were permitted to be members injected, includign types without any @Inject constructor or field, that softening broke the validation mechinism and you're running into that.\nRight now I'm trying to decide, do I \na) figure out a different way to manage keys (that is, opportunistically create a members-key on the fly, and figure out how to pin it to the right graph, since we know the injects= of each graph)\n  b) roll-forward, and loosen restrictions on members-injection to preserve the behaviour, finding another way to pin the validation\n  c) generate adapters for things in injects= even if they don't have @Inject anything on them - a sort of no-op adapter that avoids this reflection. \n. Can you build from head and verify that this is working now? \n. FYI: @gk5885. \n. Re-pushing with a fix to some tests that broke when I merged them in the move.\n. So - this reverts the other change, but does not fix the problem the other was intended to.  I will fix that separately.\n. I'm excited.\n. Just as a process FYI, the first few commits have gone in internally (by @gk5885) in Google's internal repo, just starting to lay out the APIs.  Very quickly I'm going to branch off the 1.x stuff (per our discussions with Jesse and Bob), so we can start moving forward on 2.x as the main trunk of development, making the 1.x branch effectively a maintenance branch (though still aggressively maintained until we decide otherwise as a project.)  So expect to see stuff before the end of the quarter.\n. You'll make an interface, like:\njava\n@Component(...)\ninterface MyApplicationGraph {\n  public Thing1 getParticularThing();\n  public void injectFoo(Foo foo);\n  //...\n}\nAnd that is your graph.  Dagger 2.0 generates the implementation, which you just use.  We are considering a sort of compatibility thingy, where we turn ObjectGraph into an interface with the get(Class<?> clazz) method.  In the generated implementations, the get() method (and inject() method) would simply have a conditional that routes those methods to the appropriate strongly typed getter/injector method on your interface, or throw an exception.\nGenerally, the new pattern would not be to bother with that, but it would allow for some existing infrastructure to be re-used while more robust infrastructure is built up. \nUltimately, the @Component interface YourGraph { ... } is more powerful, in that it permits you to offer complex types (with concrete type variables, like List<String>) which we couldn't offer through the generalized get() method.  So this above-mentioned mapping would largely be intended for backward compatibility with existing infrastructure.\n. Actually, arbitrary last-minute instantiation via dagger was never viable - if you don't express the class Foo via  @Module(injects=Foo.class) then you can't ask graph.get(Foo.class) for an instance anyway.  In this case, you just make a method public Foo getFoo().  But for arbitrary classes, that was never how Dagger was designed.\n. Hmm.  Looking at the Jersey example, it seems like it is actually building a lot of reflective API on top of Dagger... but I think the ObjectGraph-compatibility approach might suit there.  That said, this is particularly intense reflective analysis on what is supposed to be a compile-time framework... I'm thinking some of it could be potentially replaced with generics - instead of all the reflective lookup just have DaggerInjectedComponentProvider and have your component be T, instead of ObjectGraph.  But that's off the top of my head.  I'm going to build (or collaborate on) some similar infrastructure around servlet engines and for android internally in the next six to eight weeks, and I think we'll learn a lot about how to best harness Dagger 2.0 in other infrastructure. \n. Um... this is a cycle, unless I'm mistaken.  Consider that includes= and addsTo= both mean \"considers as part of their total graph space\" the thing pointed at, but as tbroyer points out, one is declaring the parent/child relationship. \nSo... you're saying that a includes b and b includes a.  That's a cycle.  Think of includes= and addsTo= both as being \"depends on\" at the module level = so if Parent includes (directly) Child and Child includes (across a scope boundary) Parent.  \nThe question I have is - why do you need this cycle in your modules? Specifically, why does Parent need to depend on Child?  That's specifically disallowed in Dagger anyway - nothing in the parent graph can \"see\" anything in the child graph?\n. BTW, in general I use \"includes=\" for decomposition of my modules, and \"addsTo=\" infrequently to note the parent/child relationships.\nSpecifically, I tend to make one key module that I consider the main module for that graph , and it includes all of its dependencies.  Then, for a child scope (say, a graph per request, or a graph per  activities) I make a main module which includes things at its level, and addsTo= the parent-graph's main module.  \n(I might also addsTo= in test-only overriding modules, but that's a separate use-case).\n. Dev note: \nFrom an implementation perspective, addsTo= and includes= both permit analysis to be performed across the module boundary (takes into account bindings from the referred-to module) but addsTo won't instantiate module instances the way includes= does, since it assumes the module and its inclusions to exist in the parent.\nInformally, let me say that I think addsTo= was an artifact of the fact that we use @Singleton for all \"memoized\" objects in the graph.   I have a change nearly ready that adds custom scope annotations, and I'm hoping to eliminate addsTo entirely (inferring which graph inclusions cross the scope boundary)\n. The point of complete=false is to allow a module to be created that will be, in the end, included by something else which provides those needed things.  It's like a soft \"requires\".  Any module that \"requires\" other things, but doesn't include them is, by definition, not a complete module, and so we don't want full graph validation performed on that module directly. \nSo if you have A that requires some things provided elsewhere, and you expect that module to be included by something that does provide those things, mark that one complete=false, and include it from the other module.\nThis is useful if, say, you are expecting to re-use a module in several apps, and those apps may provide a different binding for that required dependency.   \n```\n@Module(complete=false)\nclass MyReusableModule { \n  // Expect bar to be provided but we don't know where.\n  @Provides Foo provideFoo(Bar bar) { ... }\n}\n@Module(includes=MyReusableModule.class) \nclass MyAppModule {\n  // Provide Bar to satisfy MyResuableModule.\n  @Provides Bar provideBar() { return MyAppBar(); }\n}\n```\nAnalysis will be done on MyAppModule, and you'll get safety you need, and MyReusableModule is not stuck with a hard dependency on any particular module satisfying it. \n. No problem!\nSide note, since @tbroyer brought up library=true. \n@Module(library=true) is only needed if you expect orphan bindings.  In the example I gave above, library=true is not needed, because you include MyReusableModule which consumes the Bar binding.  If I were creating a set of stock bindings to be used in any app, say, a bunch of common things one might extract from an Activity's Context in an android app, then one might make a stock reusable module that had @Provides bindings and was marked library=true, since that module exposes bindings which it has no certainty will be used by modules which include it.\n. No - if something is already complete=false, no analysis will be done on it, including orphan analysis.  I frankly think we did this wrong - that is, our signals are imprecise and have some overlapping meaning.  But the simple rule of thumb is:\ncomplete=false: Exempt from any graph analysis\nlibrary=true: Exempt from orphan analysis.\n. Oh... sorry.  Clarification.  You don't have any entry points listed.  You actually have to have an injects=Something.class somewhere or everything will be considered an orphan.  In my example, I should have written. \n```\n@Module(complete=false)\nclass MyReusableModule { \n  // Expect bar to be provided but we don't know where.\n  @Provides Foo provideFoo(Bar bar) { ... }\n}\nclass MyEntryPoint {\n  @Inject Foo someFoo;\n}\n@Module(includes=MyReusableModule.class, injects=MyEntryPoint.class) \nclass MyAppModule {\n  // Provide Bar to satisfy MyResuableModule.\n  @Provides Bar provideBar() { return MyAppBar(); }\n}\n```\nWithout an entry point, no graph completeness analysis can be done (no root from which to start analysis) and so all declared bindings will be \"orphans\"\n. For the record, I have a nearly working custom scope constraint system \nthat forces the clarity of the addsTo and includes, so this sort of \nerror would show up at compile-time.  Was hoping to post it today, but \nmight be later in the week.\n. Injects= defines the roots of the graph dagger is managing.  You have to\nidentify activities and fragments you plan to inject so dagger can know to\ndo the graph analysis at compile time.\nOn Mon, Dec 1, 2014, 23:46 darshan1 notifications@github.com wrote:\n\n@cgruber https://github.com/cgruber can you explain the use of injects\n= {} why we write activity or fragment class name into this ?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/372#issuecomment-65193750.\n. And sorry about the failure to provide large pull requests in a timely manner, @adriancole.  Was working on scopes, but had to side-line to fix some of these performance issues for a highly performance-sensitive internal client.  :) \n. I'll squash the extra commits, but the first two need to be two independent ones or my life sucks later. :)\n. Actually, I squashed the google commits together, as long as the later ones are based off of the end-state of both, I'm ok.\n. Hmm. I can investigate tonight or tomorrow. I can roll this back if necessary. \n. LGTM\n. I'm almost there.  I've been working on this for a while, and getting \npulled aside to take care of other things.  Custom scope annotations \nWILL be a part of dagger, and soon.\n. Dagger needs to know that this type is intended for the parent graph.\nSince Dagger (where version < 1.3) uses Singleton to mean \"memoize in \nwhatever graph its configured\" unless Dagger has a positive signal that \nMySingleton is part of the root/application graph, its binding will be \ndeferred until the last minute.  In this case, it's going to be after \nyou are way past the parent graph and into the child graph.\n\nSo - simplest way out... list it in the application module's injects=. \nThat forces dagger to treat it as existing in the parent graph.  Then \nyou don't have to create a binding for it.\nAs an aside, I'm tempted to add exports= for this case, to avoid having \nto list singletons you will never access directly via ObjectGraph along \nwith members-injected thingies.\nUltimately (and I know I've been promising custom scope annotations for \na while, I'm actively working on it now), Singleton will mean \"in the \nroot graph only\" and you'll use @PerActivity or some similar custom \nscope to mean lower order graphs, so failing to declare it in the parent \nsomewhere will be flagged as an inconsistency.\nMore ultimately, Dagger 2.0 (which we're also working on) will express \nthis also, and you shouldn't have this sort of \"implicit binding\" \nslippage.\nHope that clarifies.\n. I may not have been clear - you can use @Singleton on your class - you just also need to list that type in @Module(injects = {MySingletonA.class, MySingletonB.class}) on one of the application-scope modules to insure Dagger understands that it should be materialized in the root/app graph. \n. In auto factory we are going to use guava but shade it. I anticipate doing that in dagger compiler as well so as to not require the transitive dep and not conflict with client code. \n. LGTM pending clear travis signals. \n. Thanks for this.\n. This should probably be a stackoverflow question, but here:\nIncomplete implies that an object provided depends on a not-yet-provided object.  You get that. But by declaring it in a root graph, you are saying that it depends on something visible in the root graph or a parent graph (which a root graph does not have).  If you try to provide it in an extension graph, you are attempting to create a dependency between an object in a root graph and an object in the extension (child) graph.  This is not a legitimate visibility.  Children graph objects can see ancestor graph objects, not the reverse.\nConsider an app-graph as the root graph, and a request-graph as the child graph.  Imagine you have an object that is per-application.  If it depends on something that is per-request, then it is actually not per-application, it is really per-request, from an instance perspective. Guice handles this by \"throwing a provider at it\" but that is subverting the relationship of scope, working around it.  \nA better approach is to make the object that requires a request-scoped object to also be request scoped.\nDagger is deliberately more restrictive.  Too many obscure errors are possible when you do not enforce the hierarchy of lifetimes implied in a scope.  You cannot have a singleton see a request-scoped object (or any hierarchical scope relationships).  \nMy suspicion from your stack trace is that you're trying to use servlets, and bend the servlet-as-singleton architecture to dagger-style DI.  That is not going to work the way you think, because of this scoping relationship.  I'm working up some scaffolding propsal for servlets and dagger, but it will work slightly differently, using servlet and app listeners to stage things, but you still won't be able to make servlets application-scope and depend on request data.  This scaffolding will materialize the servlet per-request, so it can depend on request objects. \nA better approach is to not use servlets directly, but use a servlet or filter to dispatch requests into an action system that is JSR-330 aware.  Your action objects are \"request scoped\" and they can depend on objects you extract from HttpServletRequest objects in modules.\n. LGTM.  Thanks for catching this. \n. Heh.  Love to hear those arguments.  Unless I hear some strong opposition to moving back to 1.5 in Dagger1.x, I'll roll the change immediately.\n. Yeah - we should.  Need the espresso team to be able to depend on a stable maven artifact.  Thanks for fast review. \n. Typically NoClassDefFound errors have to do with misconfigured proguard \nconfigurations, which is stripping away code.\n. Hah.  I think you caught a corner case we were just discussing in the \nDagger 2 initial work.  We should definitely fix this in the 1.x branch \nthough.\n. OTOH, marking it as singleton might be enough to suppress the error too, \nsince typically for things like Clock and Random, you're using them as a \nlogical \"one per system\".  That said, if it's a cheap-to-create object, \nthen it does mean there's some small locking contention issues there, \nbut since we lock locally, not globally (like Guice) the cost is pretty \nsmall.\n. Agreed, this should be an error if only to keep things clear.\n. I would suggest a slight alteration of Thomas' option-1 code to:\njava\nclass PresenterEntryPoint {\n   @Inject @Named(\"1\") Lazy<SomePresenter> presenter1;\n   @Inject @Named(\"2\") Lazy<SomePresenter> presenter2;\n}\n... but it's basically the same approach.  Dagger 1.0 is definitely \ndesigned around having robust entry-point/injectable objects, rather \nthan using ObjectGraph like a big annotated map.\n. Greg has started a DI practices site which we will publish an initial cut\nof soon.\nOn Sun, Nov 16, 2014, 09:18 Jake Wharton notifications@github.com wrote:\n\nThis is a very general issue with not a lot of clear action to take.\nDagger 2 enforces scope so it's always explicit in which graph a\ndependency lives. You can always be explicit currently by listing it in the\ninjects= list.\nWe're not going to make any recommendations on actual style. Just because\nyou don't put @Inject on constructors doesn't mean that others shouldn't.\nThis is something that should be enforced in a local style guide, if\nneeded. Again, this is something that's better in v2.\nWe also can't really recommend when to use field injection and when not\nto. You can very well use all of constructor, field, and method injection\nin a single class. You'll definitely see method injection used with\nconstructor and field to hand out 'this' references to dependencies. If you\nwant to enforce this with a local style guide you can do so.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/403#issuecomment-63211566.\n. Recommendations on messaging improvements are gratefully appreciated. :D \n  That said, when we start looking hard at the 2.0 first-cut, we can \ntake the opportunity to critique the messaging wholesale.\n. The short answer to why Dagger requires @Inject constructors is seen in \nsimple errors like this: String.\n\nclass Foo {\n   @Inject String string;\n }\nIf permitted non-@Inject-annotated constructors, then we then use Foo, \nand someone fails to bind @Provides String aString() {...} then you \nwill have String's default constructor invoked and you get an empty \nstring.\nWe saw a lot of those sorts of errors in Guice, where unintended \ninjection of types happened with insane default conditions, so Guice \nadded a \"requireAtInjectConstructors()\" configuration, and Dagger just \nmade that the universal requirement.\nI'll answer the SO question on SO.\n. Yeah - so that code seems like it should work.  Why it would be trying to implicitly-bind something that has a provides method is very odd.  I'll try to play with the example project.\n. It's not though, @JakeWharton.  It seems like he's calling the constructor explicitly in an @Provides method.  No?  Or am I missing something obvious?\n. I'm sorry - I'm not following - what do you mean \"AA\" generated classes?\nOn 4 September 2014 13:39, Eugene Beletskiy notifications@github.com\nwrote:\n\nBumped into the same issues with a difference the Dagger-generated classes\ndon't see AA generated classes despite those all are successfully\ngenerated. Not to make confs overcomplicated thinking about getting rid AA.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/410#issuecomment-54541217.\n. Yeah - your issue is quite different than the issue described in this bug.\n\nOn 5 September 2014 01:49, Eugene Beletskiy notifications@github.com\nwrote:\n\nMeaning the classes generated by Android Annotations\nhttps://github.com/excilys/androidannotations\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/410#issuecomment-54599884.\n. It is not optional in the compiler, it is required in the compiler, and well-used there. The compiler is an annotation-processor which runs inside the javac.  Unless you're going to run the javac process on android, then it should be a non-issue. \n\nIf your issue is that IDEs do not honour maven dependency scoping, than that is a problem, but one that is not ours to fix.  I highly recommend developers at least build from the command-line once before committing changes, to ensure they are not letting dependencies creep in.  \nAs to provided vs. optional, I agree, but it was changed because its behavior in terms of how maven determines what directories it creates for file-generation.  Provided dependency scope (in maven) seems to create target/generated-sources/annotations, whereas optional=true seems to (often) result in .java files ending up in the /classes folder. I don't know why - i'ts really flaky maven behavior.\nBut you can feel free to use whichever inclusion style you find worthwhile. \n. \"inclusion of Guava on the classpath\" @christopherperry - what platform are you talking about?  what is your environment?\nAs to using gradle - you are free to use gradle - the dagger project's build system is unrelated to your choice of build system.  If you find Gradle to be more suitable on your project, please use that.  That should in no way be affected by what the dagger project uses, as long as you fetch dependencies as binary artifacts (which you should be doing). \nAs to a plugin, no - it is an annotation processor so that the dagger-compiler.jar can be independent of build system.  Making it a maven plugin ends up complicating the infrastructure and tying it to maven in an unacceptable way.  You're trying to solve a problem - to not get guava usage in your project's code.  I can understand that.  But let's figure out how you can solve that. \nA simple project rule like: don't build your binaries for production in your IDE is a good one, and one which will catch any such usage.  You can even just say  \"build once from the command-line before submitting code to the repository\" and if you're really organized, you can make that into some sort of pre-submit script.\n. @JakeWharton - it doesn't happen in practice for maven projects either, when built from the command-line, because when they execute javac, they separate things out.  But it does not work in IDEs which don't segregate classpaths for things like tests, annotation processors, etc. \nI'll experiment with configuring annotation processors via the maven-compiler-plugin to see if there's a more isolated way to do this, but I don't know if the maven integration in the IDEs support this. \n. I thought we tried that and it didn't work the way we expected, @JakeWharton - I think it needs some experimentation. \n. @christopherperry - yeah.  That's an IDE not respecting maven scoping.  But at any rate, I would try to configure it as @JakeWharton suggested, by explicitly configuring it in the maven-compiler-plugin config instead of as an optional dep.\n. @swankjesse, @JakeWharton, and others - please take a look.\n. Admittedly one line of boilerplate which clarifies the implementation.\nI think you (jesse) and I had a conversation in waterloo about being ok \nwith a small amount of boilerplate to crisp things up and make the code \ncleaner and things simpler to understand, no? ;)\nThat's not to say that this, without question is the right mix of \nboilerplate for clarity - but I think it's a decent trade off.  In \nparticular, as I mentioned, I like the simple alignment of the signal \nwith the semantic - if it has an @Inject constructor, you can depend on \nit. If not, you must have an @Provider.  If not, it's not a dependency, \nthough it could be an entry point.\n. @tbroyer - fix2 is my branch, and I've adapted some of that code to other changes in review internally (plus other changes from Greg pending).  I would only trust google/dagger/tree/master or active pull requests for the current code.\nThat said, it's not impossible, as you point out, it's just more complex and since we're splitting up the role of \"can be depended on\" (gets a Factory/Provider) and \"gets stuff injected into its members\" (MembersInjector) it seemed like a good line to draw, though as demonstrated above, it's not without question.\n@roman-mazur - I think annotating the class itself would violate the spec, whose javadoc for @javax.inject.Inject says \"Identifies injectable constructors, methods, and fields.\"\n. When greg says \"In the case where we're using members injection on container-managed instances or whatnot, we won't have to add the @Inject constructor. Great. No issues there.\" above, he means things like Activity where we don't control instantiation, and provision isn't required (entry point or graph root vs. dependency, in effect).  In that case we don't need @Inject constructors. \n. Ooh.  That actually just turned off analysis.  It didn't \"solve the\nproblem\" as the error is still there. :/\nOn 10 September 2014 13:23, Maxim Naumov notifications@github.com wrote:\n\nClosed #413 https://github.com/square/dagger/issues/413.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/413#event-163866183.\n. (I mean it solved your problem, but it didn't solve the dagger issue that\nseems to be manifested.\n\nOn 10 September 2014 17:41, Christian Gruber cgruber@google.com wrote:\n\nOoh.  That actually just turned off analysis.  It didn't \"solve the\nproblem\" as the error is still there. :/\nOn 10 September 2014 13:23, Maxim Naumov notifications@github.com wrote:\n\nClosed #413 https://github.com/square/dagger/issues/413.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/413#event-163866183.\n. Well, I can't replicate it from your example, so I can't tell.  If you can\nreplicate it, can you construct a minimum possible project that has the\nissue, with the fewest number of classes?  I would like to see if this is\nan issue in dagger, or on your side.  But when I cut-and-paste your\nabove-listed module in, using Dagger 1.2.2, it works perfectly fine for me,\nhas no error, and generates a ModuleAdapter and two provision adapters.\n\n\nOn 11 September 2014 05:09, Maxim Naumov notifications@github.com wrote:\n\nSo this is an analysis issue?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/413#issuecomment-55254656.\n. That is weird - I've not seen this on OSx.  Can you please list your java -version output and your mvn -v output please?\n. Oh wow. Ok - this is just a test brittleness issue, I think.  The error is that this test rests on an implicit assumption of order of method processing that has changed in java8.  In theory a cycle like this could start on any provides method, but it happens to be first analyzed on \"C\" provider on Java6/7 and on the A method on Java8.   I'll roll a fix. It's a weird one to assert about though, just in terms of nailing down the error message, because it's conditional on where the analysis started. \n. Oh!  I might be wrong. Digging deeper.\n. Thanks.  I have replicated it.  It turns out my failure to see it was a failure in my eclipse environment.  And I think it is just a brittle test.  The error thrown is correct, but doesn't match the test's expectation, as I said above.  I'm trying to figure out how to un-brittle the test. :/\n. Fix posted in #418 \n. Side note - cycle detection is gross on Dagger 1, in that it isn't really a unified thing w.r.t. other analyses.  This is partly because the ProblemDetector (which does this) is part of the runtime, so the error returned is not some validation error, it's an IllegalStateException and the processor which uses this just tosses it.  \n\nThis could be fixed, but doesn't seem worth it given that 2.0 is close.  Cycle detection will fit nicely into the ValidationReport system, and be handled more clearly.\n. Hmm.  There should be a @SuppressWarning on that.\nOn 25 June 2014 06:55, cypressious notifications@github.com wrote:\n\nWhen using AutoFactory with qualifier annotations like this\n@AutoFactorypublic class MyClass {\n    public MyClass(int param, @Provided @QualifierA Object param2) {\n    }}\nDagger will issue the following warning:\nDagger will ignore qualifier annotations on parameters that are not @Inject constructor parameters or @Provides method parameters: param2\nThis is a kind of useless because in this case, the generated factory\nclass will use the annotation correctly. Also there is no way to hide the\nwarning (unless there is one, in which case please tell me).\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/419.\n. Eclipse might not know about it - it might not exist, but even if it did,\nif it's in the annotation processor, there's no information for eclipse to\naccess to know about it. I'll dig in.  What I will say is that if we\npreserve this warning in Dagger 2, there for sure will be a suppression\noption.\n\nOn 25 June 2014 10:41, cypressious notifications@github.com wrote:\n\nAt least Eclipse didn't offer one. What's the parameter?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/419#issuecomment-47134363.\n. LGTM\n. I'm confused.  Why would you need to reference your activity-wide objects from the first invocation of your app-wide graph.   Or rather, why are you staging tests for activities without the activity-wide graph, which it sounds like you're trying to do.\n\nI think optional in this case would be really unsafe, even if we supported it, as it would end up with your activities being agnostic to the availability of activity-scoped things, which could easily lead to someone forgetting to include something, etc.   Can you talk a bit more about your set up, and why you would need this particular organization of code and flow in these tests?  I may be missing something. \n. Yeah - we don't (at present) support @Nullable and nullable providers.\nOn 7 July 2014 11:12, Thomas Keller notifications@github.com wrote:\n\nWell, nicely put, point taken :-D\nI think Guice' interpretation of @Nullable https://github.com/Nullable\nis then what I'm looking for. See\nhttps://code.google.com/p/google-guice/wiki/UseNullable\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/423#issuecomment-48217282.\n. Why would @Inject not be valid.  Did something in 8 change about annotation declarations that I missed?\n. Yeah, but that increases the places annotations are valid.  I am not clear on why annotations would suddenly become invalid. \n. Oh my god I'm blind today.  Right.\n. Yeah 2.0 and all that, but this might help people debug, so it is probably worth rolling a 1.2.x at some point.\n. Hmm.  The build is breaking.  :(\n. Oh.  Sorry - missed that.  I had it in a branch locally but wasn't going to add it until i'd fixed the issues.  :/  Ok.  If you're satisfied - it does seem to be a failure in an unrelated invoker test. \n. Gotcha.  Cool cool. \n. I believe that is must maven hiding your error message detail.  Please use\n\"mvn -e\" (or mvn -X) to get more detail on the error messages.\n\nOn 7 August 2014 04:41, @fbiville notifications@github.com wrote:\n\nHi, I have this module:\n@Module\npublic class VidalAPI {\n```\nprivate final String uri;\nprivate VidalAPI(String uri) {\n    this.uri = uri;\n}\npublic static Resources at(String uri) {\n    ObjectGraph graph = ObjectGraph.create(new VidalAPI(uri));\n    return new ResourceFactory(graph.get(RestAdapter.class));\n}\n@Provides\nRestAdapter restAdapter(AtomConverter converter) {\n    return new RestAdapter.Builder()\n            .setConverter(converter)\n            .setEndpoint(uri)\n            .build();\n}\n@Provides\nAtomConverter converter(AtomDeserializerFactory deserializers) {\n    return new AtomConverter(deserializers);\n}\n@Provides\nAtomDeserializerFactory deserializers() {\n    return new AtomDeserializerFactory();\n}\n```\nWhenever I try building the project, I get this:\n[INFO] -------------------------------------------------------------\n[ERROR] COMPILATION ERROR :\n[INFO] -------------------------------------------------------------\n[ERROR] /home/fbiville/Projects/vidal-rest-sdk/src/main/java/com/vidal/rest/sdk/VidalAPI.java:[11,7] error: Graph validation failed: You have these unused @Provider methods:\n[INFO] 1 error\n[INFO] -------------------------------------------------------------\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\nWithout any faulty methods listed >:(.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/429.\n. The linker is aggresively linking in the parent and does block until it's done.  This is necessarily so in Dagger1 because there's no other way to figure out where an object will live (in the child graph or the parent graph) because of lazily linked graphs.  If you depend on something in your activity, but it happens to not have been loaded in the parent, but shoudl be in the parent, then we would mistakenly initialize it in the graph if we didn't force pre-linking.  (This is only relevant for @Singleton objects, and is largely an artifact of our using @Singleton to mean one-per-graph, not one-per-well-named-application-graph or some other special case). \n\nDagger 2 will have validation of custom scopes, so that if you have something in the parent graph it will  only be memoized in the parent graph.  So we can be more lean in terms of costs, only incurring the minimum costs needed for hte graph you use, rather than the sort of over-careful \"link everything\" we have to do now. \n. So this seems fine.  What's going on with Travis? \n. Grr.  This was supposed to be merged against google/master. Sorry about that. \n. As was mentioned, Dagger 2.x is on the http://github.com/google/dagger project. The square project\nis for Dagger 1.x\n. The runtime graph validation is only a hedge against adding a different set\nof modules at runtime vs. at compile time.  If you are certain you are\npassing in the same modules that you compiled with, then the validation you\nare running has already occurred.  It's a safety vs. performance question -\nbut there it is.\nOn Sat Jan 31 2015 at 7:16:52 PM Dale King notifications@github.com wrote:\n\nFor some reason in our code, we were validating the graph on each\ninjection (in debug mode). I moved it to only validate after the graph is\ncreated which means this is not a high priority thing to fix, but this will\nserve as notification in case someone else runs into this.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/459#issuecomment-72349330.\n. Acknowledged.\n\nOn Mon Feb 02 2015 at 4:30:03 PM Dale King notifications@github.com wrote:\n\nAs I said we were only doing the validation in debug mode. If there were\nissues we wanted to discover them during development. But as I said doing\nthe validation for every injection was a bad idea.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/459#issuecomment-72568738.\n. Yes! Please!\n. By the way, jesse, this is sort of what I had in mInd for declared bindings without @Provides methods.  Entry points are, in a sense, the simplest binding declarations.   You could have the module annotation just accept more minds of bindings so, if you had no work to do in your provides methods but boilerplate construction you could have the whole thing as an empty module class with a list of. I dings passed into the @Module annotation. \n\nI'll work up a pull request.\n. I can update this, but I can think of two things here.  One - we can write a template test for Lazy so that any implementor must conform to that behaviour - so it becomes contract, though not language-enforceable.  \nBut I\"m wondering if Lazy shouldn't just be a class that does it. \n. Added.  Should I be adding Google, Inc. to files I touch too?  Google legal only sort of cares because these notices have no legal impact, but they said \"follow the project norms...\" which is wonderfully flexibly unhelpful.\nalso... alphabetical, or order of involvement?\n. Lol.  Alternatives?  I can dig it.  Just don't have a better word in mind. \n. Was wondering about the special case, but I'll test it out. \n. Done\n. Though these are actually legally meaningless, but for credit's sake, sure.   \nAlso - CLA submitted. \n. done\n. Tried to remove it entirely. \n. I had a subsequent change I was going to push that cleaned a lot up of this key handling - I'll add it here if you want.\n. Done\n. NOT_PRESENT\n. done\n. Hahahahah.  Ok.  Done. I was thinking \"magic strings\" but yes - I'll rename. \n. Done\n. Doesn't work, because of \"members/\" being a special case, unless you're wanting me to have a if/elseif/elseif/else structure, which defeats the point of having a getLazyKey method at all.  I nearly moved getLazyKey() into getDelegateKey(), but I wanted to avoid all that special casing. \n. I'll do what I can.  Mine are also sorted by classname, but they seem grouped differently.  Are you just straight alphabetical with no grouping?\n. I'll edit my docs settings to wrap at 80.\n. Sure, though here you're using a Provider like a factory... does it need to be injected as a Provider?  So much depends on design, and you trend towards designs (I think) that use a Provider, where I'd rather just have my locus of control be objects that are within a request-scope (or request-lived child injector) so I don't need to have singletons which aren't really singletons... they are depending on per-request objects, so they aren't app-scoped, except as an artifact (if they are, say, servlets).\nMaybe this discussion needs some wider treatment to get to a message that is clearer and agreeable to all, but I really feel that people over-use providers, which are an internal implementation of construction/provision for the injector.  They're so close to a factory in behaviour, and guice users have semantically overloaded the two.  But I think it leads to crappy design in many, many cases.  And if we do child-graphs the way we talked about (root graphs can't see their extension graphs) then you won't be able to do that pattern anwyay - you'll have to properly create objects in your extended graphs that don't have the scope mismatch... so no need for Provider injection. \nI'll trim up this explanation, but I really want ObjectGraph's documentation to focus on solving problems positively, not by using implementation details as crutches, which Provider injection nearly always is in my experience (both inside and outside google).\n. I realize they're useful in new code... but I think it's often because people have gotten used to injecting things just-in-time in default-scope because the hammer was there, and the pattern stuck... but it's one of the underlying design approaches that has caused a lot of confusing code in and out of Google.  Non-experts in DI get screwed up by it, and one reason we want to be involved (and were going to re-write Guice anyway) was to get away from this.  Fresh start.  So while I agree there ARE valid reasons to do this, there are also a lot of reasons that are \"meh\" but commonly done, with better options overlooked (from a readability/maintainability/clarity perspective), and we should maybe articulate a longer set of examples and use-cases and hash out recommended designs. \nIn short, I've just had to do too much work with teams who didn't understand the mess they were getting themselves into, but selectively replacing Provider with either re-partitioned and otherwise-scoped objects, they could just inject T alot of the time, or Factory, or Builder directly, and get much clearer code, much less confusion with new developers, etc.  So let's talk it through in more detail, get those examples, and for the really truly important places for Provider injection, recommend it there, providing alternate design strategies for the other cases. \n. Yes.  The other isn't Object[] it's Class[], and I wanted to keep this package-friendly, so as not to expose this util to the public contract.   Bugs me, but my intention was to rip this all out once you folks had changed all your callers.\n. Please feel free to propose an alternative.  I guess the big thing is that if you include the same module twice, you should get the same module, I think.   Actually this is a larger topic, in that how does analysis work if you end up providing multiple instances of a module with different state at module creation time, vs. build analysis time? Yadda.\nBut for these purposes, the intention here is merely to ensure that we don't end up specifying modules in both children= and includes=...  If we're going to ditch children right away (or even, as @pforhan suggests, in this change) than all this language can go away since there will be only \"includes=\"\n. Heh.  Oops.\n. I'll remove it.  I was pre-optimizing so existing code wouldn't be any slower, and converted code would be equally un-slow.  SInce I plan to remove all this nearly right away, you're right, probably not worth it. \n. So, I agree, but I want to make sure this is tested.  Can you let this one go, and I promise that I will create a \"fully-featured example\" separate from this hello-world one, so that everything is tested out.  I just didn't want to create a new project now until I had the integration-test project infrastructure in place.  I can revert this if you really feel strongly about it - I just didn't want to check it in with the code-gen untested.\n. I removed this from ArrayUtils as well, since that class should disappear once children is removed.\n. Yeah... Dunno what that was.\n. On Monday, September 17, 2012 at 2:47 PM, swankjesse wrote:\n\nIn core/src/main/java/dagger/internal/RuntimeLinker.java\n\nIt's an addiction.  I understand.\n. I'm really not happy with having @Provides have more attributes.  Aside from the fact that it doesn't read in any way like english, it also starts to really overload Provides with quite dissimilar attributes.  @Element is structurally different from @MapEntry or @KeyedElement or whatever we decide mapbinder will look like.  \nAs to \"accompanies @Provider\" - I'll fix it, though it's implied.  I agree, it should be explicitly stated.\n. But it's not.  It's an unmodifiable set.  We're not using Guava and ImmutableSet. :p\n. (I'll say immutable - it's the effective meaning since we control the set privately)\n. But it's not a getter.  getFoo() is a known pattern of instance accessor methods.  Hrm.  Must find better name.\n. Yuck but it's temporary - I have a complete re-work of singleton wrapping planned.  And I checked, I believe this shouldn't have much performance hassle.\n. Fair enough.\n. Done\n. Done\n. Um... this was kind of needed for me to debug a case which was going to be entirely opaque if I didn't see it as wrapped.  Any suggestions about how to do better?  toString() is really supposed to be a debugging-focused method. \nAre we calling toString() in a normal production context in a way that I'm not noticing such that this would be a performance drain?\n. nope.  \"Keys.get()\" != \"Keys.getElementKey()\"\n. Oooh!  I like where you're going with this. But this change is agnostic about extension/child graphs.  Not sure I want to pre-sage that functionality.  It's part of the spec for child graphs.\n. Binds a unique thing, rather than binding elements that combine into a multi-binding.  Better name?\n. extractQualifier?\n. Woops.  I can't believe that's rule 1, but my mistake.  It was a proxy for how I was structuring my thought.  Removed.\n. It's not useless for the generics.  Let the compiler inline this shit.\n. I don't like unitary much, except compared against Set binding.  createSingleBinding?  createSoloBinding?  createValueBinding?\n. Lost your formatting.  Can you re-do with code escapes in your comment?\n. That's an assertion I'm not so sure about.  It's 25% more memory per node, and there's no iteration order guarantees required here.  I can do it, but neither I, nor a bunch of the team, feel that the case is quite as strong as you're arguing here.\nHaving said that, I\"m not opposed, and I\"ll make the change... I just am not so sure about the intensity.  Maybe you can rant this at me over a drink later, and I'll just put in LinkedHashSet for now pending clarity.\n. I thought Google was nitpicky. :)  I would really like to get some sort of style thingy written down so I don't have to have you mention things ad-hoc - for your convenience as well as mine.  Also done.\n. Done\n. I'll tell you what, I'll come up with a better strategy for the next added use-case.  Right now it's <20 lines and a pretty simple if/else in a loop.  But with more else-if's, we can push it to something table-driven or whatever best makes sense.\n. mentioned, also \"delegates\"\n. Crap.  This was WIP.\n. Started as something else.  Done.\n. Done\n. Checkstyle didn't break. Is that the lint you mean?\n. Removed.\n. Fair.  Done.\n. Fair.  Done.\n. I'll move it out into an integration test once I put that system in, but there was a question about use-cases and tests are the first sample code.   It's over-testing, but I\"ll move it into an example later.\n. Yeah - but this isn't getting without parameters, which getFoo does imply by common practice.  This is a transformation, or as we said, an extraction.\n. Because scope() is used as a pass-through int he original code for bindings when they're linkRequested, which a singleton binding will be.\n. Ok, I think we have different instincts here, and when I WAS debugging an earlier problem, not knowing that key A was a different binding than key B, even though they looked the same when toString was called in the assertion failure was completely unhelpful.  I have a strong concern about ambiguity in underlying types appearing to be the same things.  I can change it to @Singleton key as you say, but I would remove the tag under protest, since the underlying binding and the singleton binding are two different objects.\n. That's legit, I think, if we let contributions cross children's lines.  Remember... children aren't children... extension graphs are teh more complete combinations of a common graph and another graph.   The only reason it seems weird is because you're thinking in OO inheritance terms because of the langage.  Graph A has a, b, c in set keyed with S.  But Graph A + B having a, b, c, and d keyed with S is entirely plausible and makes total sense... divorced from the parent/child metaphor. \n. I relent. :)\n. To save three characters? Compiler won't let me instantiate a SetBinding<?>(blah);  What three characters are you talking about?\n. Heh.  Ok.\n. I take it back - I refactored the whole shabang to be clearer and have each case handled properly in another function. \n. Never mind - this method is now obsolete.\n. It had better not.  I hope many provides methods can be listed this way, so they're one-liners and really easy to consume.\n. Got it.\n. Sorry - missed a bunch of callers.\nBTW, this is why I wanted to use Truth.\nASSERT.that(ep.strings).has().exactly(\"string1\", \"string2\");\nNot advocating... just sayin'.  :)\n. extends Binding<Set<T>> and doesn't need suppression.  Just a cast now. \n. Ok - I've traced the flow through, I think you're right.  But the way we're doing this with scope(blah)  wigs me out because I NEED to widen it to support multibindings (or clone it).  But the assertion is good.\nThough if we're \"double scoping\" that's not bad, per-se - depending on the meaning of this method.  In practice, it's \"if this is a scoped binding, but hasn't been scoped, wrap it in a scoped binding.\"  In that sense, passing through this method is a non-issue.\nhaving said that... my plan is to eliminate this whole flow and have Binding handle scope properly without creating this extra object. But that's a different CL.  In this case, I'll change this to an assertion. \n. Done.\n. Sure - style/habit.  You're right, it's easier.  Done.\n. Conflicts with import javax.lang.model.element.Element;\n. Yeah - sorry.  You're right, it's clearer, though I'm just working against hitorical style, so it'll take a few to get comfortable.  Sorry.  \nBut in this case, I'm not sure I can guarantee which numbers will be in which sets, as I'm not sure there's any deterministic ordering of calls to the providers.  So it could be 1,2 or 1, 3 in either set.  Since method order is not guaranteed in JDK7, this test would break.\n. ibid.\n. So how will you assure that the first set is 100,200 and not 100,201 if the order returned in ModuleAdapter for Class.getMethods() will differ between runs.  Using these magic values will actually not work, unless i\"m really missing something.  Can you write this in a way that's deterministic?  I'm not seeing it.\n. Ok - I have an idea.  I'll just do it this way, and we can re-design the tests for Java 7 if it's a problem.  I might be mis-conceiving the order of things.  Give me a few minutes and I\"ll update the tests.\n. These final names are semi-redundant.  You're adding square-foo, but when this is pushed to the maven repository, the square- is removed - it's only going to show up as square-dagger-1.0.jar in your target/ directory.  \nTo wit: run mvn deploy -DaltDeploymentRepository=alt::default::file:///tmp/alt-repo\nand run find /tmp/alt-repo\nYou will have no files prefixed with square-\nI would just remove these in a subsequent change.\n. Ah.  Ok.  SGTM.  Nevermind then. :) \n. much better.\n. Wait... this is MembersInjectorTest... did you not want these tests as they are?  Or did you want two sets - one for getInstance, and the other for inject?\n. Yeah - not sure of the correct mechanism, but doing this on all code-gen feels overkill.\n. Shall do.  Mostly playing with travis config at this point - will \nprobably split that out.\n. Checkstyle didn't complain.\n. Not as such.  Apparently some work towards it but didn't make it in in a way that \"just works\"\n. Hmm.  Good call.\n. That was my thought too. \n. Um... I think that's actually standard for maven sub-builds and the like for console output.  It's at least not atypical.  I'll change it to spaces as it's not that big a deal which way.\n. Actually, it probably passes because it's entirely a comment.\n. Want me to change it?  There are a few different ways to get a file into a string. \n. Oddly, I think checkstyle can get these without, if the outer pom checks src/it in its scans.\n. Accidental.  Fixing.\n. Necessary in most situations, no - but in the case of trying to debug this (especially when the error was occurring in a continuous integration platform's inner build, and couldn't be replicated on my mac), this actually made it possible to see what the error was, and the binding the error was occuring in.  The stack-trace was insufficient, as it didn't tell me anything about which binding.\n. I considered it - and it's maybe more elegant, but I didn't want to re-define the meaning of UNRESOLVED to return no dependencies, when it isn't really that the key has no dependencies, it's that they key hasn't been resolved, and I wasn't sure if it was enough of an error condition that a null-object or default-object pattern wasn't misleading in the code.\nThat said, I'm not opposed - we can do that in another PR and remove the if().\n. Wait... I thought you had this line in here to distinguish for the non-maven case?\n. Good call.  Better option.\n. Ok... nothing about this change means we can't always have code-gen, though some projects that are migrating can't use codegen - this means they have to do a big-bang push.  With this structure, we can privilage code-gen for all three kinds of handling, but have other fall-backs.  In the case of injection, that's reflection.  In the case of module handling, that would be things like a guice module handler. \nYes, this is how dagger works - but allowing people to go off-warranty in order to have a path to GET to those benefits that doesn't involve a re-write is important. \nValidation should be default-on.  But allowing someone whose code can't be validated explicitly opt out to be able to get SOME of the benefits of Dagger while they restructure to get all - that's not a small thing.\n. The word 'offensive' is pretty strong.  Someone who finds 'simply' offensive is pretty darned sensitive.  It is, however, an opinion, and I'll remove it from the text. \n. Sorry - I backed out that change and meant to add it to a different commit.  I'll re-fix.\n. Actually, it IS wiring up a graph of bindings.  I'm open to suggestions though - it was off the top of my head.  \nDagger.build()\nDagger.init()\nDagger.create()\nDagger.graph()\nDagger.graphOf()\n?\n. Access to the whole AST sucks at doing whole-world analysis?  I admit I haven't been deeply into the javax.tools infrastructure, but if you don't use them, aren't you stuck with not being able to have your errors show up as Javac errors?\nOr do you just mean for the analysis?\n. dagger-compiler?\n. Removed\n. Comment removed anyway.\n. The comment itself is a cut-and-paste error, sorry.\nDagger may not have only one method. I can see this as the place where any configurability would come in.  \nDagger.wire()\nor\nDagger.with(new GuiceModuleHandler()).wire(module);\netc.\nIgnore the specifics of naming or configuration - the point is, it's a nice clean place to make sure any variance from default behaviour is up-front and explicit, and doesn't get in the way of anyone else who does use the defaults. \nRegardless, even if wire() was the only method, I'd still rather have a clear entry point, and this is nice and separated.\n. lol.  Fixed.\n. You do have multiple linkers... in the sense of things that support createAtInjectBinding.  MAybe that's a smaller interface. \nYour RuntimeLinker did the code-gen part in a conditional, but it's literally just one strategy for providing an AtInjectBinding, and you have another one, which is code-gen.  Two cases for this.\nMaybe we don't want this.  I'm weaker on this one than the others.  But the original logic is \"Try one way then fail to the next.\"  That's all this does - but allows for more kinds.\n. typo.\n. Admittedly, it may just mean that \"create at inject binding\" shouldn't be in linker.  I was tempted to go there, but this change was already huge, and I didn't want to fundamentally re-design linker here.\n. With ModuleResolver, I think it's Generated, Reflective, LegacyGuice.\n. Agreed.  No big stake in that. \n. I was following the pattern of runtimelinker.  Naming is hard. \n. LOL.  Actually, you sort of did - I just removed some lines and added an \"abstract\". :)  But fixed.  Removed actually. \n. I think that's a definite personal style thing - I'm not sure why it's too many files, but I'll do it. \n. Done.\n. I was thinking of that as a later change - pulling these things all together into a more clear.\nAlso, you really really really like to have few files. \n. Yeah - I think it shouldn't be in linker.\n. :)\n. > The problem is that linker is very stateful. If you add additional linkers, it's unclear where that state goes. If you want to move behavior out of linker, that's okay.\nYeah - I see it... As I said, I wasn't sure about this one, and was more inclined to move out the functionality.  I'm still wrapping my head around a few of the flows.  I definitely see what you mean here. \n. Sweet!  Deal.\n. We haven't picked the strategy.  Two ways to do that. First is to extend Dagger to support those Guice use-cases we are willing to support (without compromising Dagger).   The other strategy is to move Guice in Dagger's direction, so that at some point, Guice is a superset.  \nTo be honest, I'd vastly rather extend Dagger, since its source is cleaner and smaller, though not in this repo (i.e., either a fork, or extensions if we find the right seams without creating more indirection than you can stomach.)\n. Du hast Recht.\nalso... abgemacht.\n. done.\n. Crap.  This failed to fail because the \"symbol not found\" is followed by the expected \"No injectable members\" error.  It's caused by \"symbol not found\" without reverting this code, which isn't really the intention of the test, but it fits the test verification criteria.   \nHrm... I am not 100% sure how to not overspecify this.  I wonder if we have a straight-up compilation error if we need some of these errors.  This is a validation error, where a dependency is missing... but the code didn't even compile... should we run validation in this case?  \nIf we want that, then I wonder how to specify that the error we got was the only one we were testing for without articulating a lot of \"not contains\" critieria and having to specify all the typical compilation errors like symbol not found and syntax errors.  That seems brittle. \n. I guess growing up with NeXTSTEP and pluggable applications, I'm used to most application functionality being delivered through plugins.  But I still hate the name. :) \n. Heh.  Ah heh heh.. um... yeah.  \nOops.\n. Sure.\n. Hah hah.\n. And yet, when examined carefully, you should find that it isn't. ;)\n. Thanks.\n. Done.\n. Actually, at this level, the interface makes no guarantee as given in the existing text.  An aggregator at run-time decides that.  Implementors of this interface would implement either the codegen or the reflective (or other) strategy.   So I just removed the extra text.\n. Done\n. Don't hate to ask.  It's how I initially did all the delegating classes, but moved to Lists for a bunch of reasons that are no longer valid in the re-worked code.  Done. \n. I would.  Just now, no, because we control what two plugins are given and in which order.  But if we do open it up to allow someone to provide an alternative plugin, we simply have to assume badly written plugins, and fail accordingly.\nSo... maybe overkill just now, but a wee little bit of experience with crappily written eclipse plugins'll teach you - always make sure your plugin apis are guarded where used. \n. This is tricky.   I think the error log should be more fatal... I'm trying to decide about whether to throw here.  \nThe original code just blindly created a reflective static injection, which would itself fail if something went wrong.  I think \"no handler\" is a really really bad state and we should consider throwing in all three of these cases.  I think that's what I'm going to do, actually. \n. I firmly disagree... maybe you think they shouldn't be hand-rolled (I agree), and that we, as an effort, shouldn't \"support\" it (which we won't), but the class loading will entirely work if someone hand-rolled their own that was to-spec.\nAfter all, hand-rolled is just generated code that was generated by a human.\nBut I'll rephrase to avoid accidentally \"approving\" of hand-rolled.\n. (Really I'm not arguing with you here... depending on your definition of \"support.\")\n. I'm struggling with this naming myself.  I just named what it does.  And in reality, it's not a plugin that needs to use generated code.  It just needs compliant and appropriately named code.  So... I named it for what it does.\n. Entirely re-worded.\n. Need to think through some examples of this.  This is TOTALLY here for discussion. \n. Ugh.  Yeah - code that was shaped from an abandoned direction.  \n. Bah.  The verbage is ambiguous even then... because the \"dependency\" can refer to the relationship or the target of the relationship.  Hrm.\n. Maybe: \n\"Sometimes you need an object to be instantiated lazily.  You can achieve this by depending on a Lazy rather than on T directly.\" etc.\nThis avoids the lazy-dependency-creation terminology a bit. \n. fixed\n. Not sure about static injections, but we agreed to punt on this notion until later when we can talk about how to validate.  For now, the workaround is that a module must include the parent.\n. Probably true - fixed.\n. Done\n. Hard to kick the habit of that particular style rule. \n. Off how?\n. I angsted over that for about two hours, and then gave up and moved on.  I highly encourage something other than \"parent\" that means something-back-up-the-chain.\n. Ok.  Hopefully I've improved the text. \n. I'm of ambiguous mind on this.  The \"upstream\" graph (so to speak) is the root from the perspective of this generation, so I think it's valid, though I think it's also annoying. \nI was thinking about augments, but that's more of a method name, not \"the thing that is done-to\".  I think we need a noun form here.  Just not great choices.\n. I'm ambiguous on this... NullPointerException, or IllegalArgumentException.  The former is more of a \"null dereference\" whereas the latter is what's happening.  But if I left it be, there would actually be a real null dereference further down the chain, which I'm just bringing forward here.\n. Done.\n. Done (dependency graph -> object graph).\nAs to the rest, I'm going to leave it to you on this, though as much as I like the idea, be careful about making it too opaque and mathy, as we talked already about avoiding making the whole thing too close in nomenclature to a graph theory library (even though it kinda is)\n. Done\n. But I was under the impression that we only accepted (and would ultimately be validating) that the modules passed in here form complete modules or complete sets.\n. Ugh.  I agree.  Please contribute a better name. :D  \nSeriously, I'm in.  I'm just having total naming creative block. \nAnd i'll try to keep that OCD rule. \n. Done.\n. Argh. Sorry.  I'll get used to this.  I swear. lol\n. Weird.  Fixed in the real code, but it's not showing up in this partial diff.\n. Typical but not actually a requirement.  And not universal, else\ndagger would have to be dagger-core.\n. done\n. Oops.\n. Oops\n. Fixed\n. Thanks - added one extra assertion for good measure.\n. Oh!  Woops.  Srory - don't merge.  I'll fix.\n. Done.  These are fake poms anyway - just used in tests, and never deployed, but it's better to correctly self-document.\n. Doh!  I think you may be right.  I was trying to avoid passing the buck here, but passing null is an expected behaviour and the code I fixed in the other PR already handles all the cases of instantiation (by adapter loading or reflection, as appropriate).  Thanks for catching this.\n. Why?\n. Heh.  You really really like that one don't you. :D \n. Still doesn't feel like a win. :(  What's the left-hand of a plus operator in math?\n. Not a blocker... just addsTo isn't sitting any better with me than augments.\n. \"We\"?  Can you rephrase to avoid personal pronouns, plural or singular?\n. Something like, \"To demonstrate ... consider a module that provides...\"\n. the same {@code Lazy} instance will return.\n. Ok... base feels a bit better.  And root is what we'll call the base that has no base?\n. I think it should be clearer that this graph's creation and destruction will not affect the base graph (at least not the wiring and instances... the internal state of those instances may be, if they're mutable)\n. Um... why?  Clearer?  It seems exactly the same only longer. \n. Do you have a test for this case?  Good catch, but I'd love to see how it would happen (and therefore, be prevented from happening by virtue of the test)\n. Sorry - forgot about the extra object creation there. \n. So we're logging all failures, but throwing on the last one?   I think I like it. \n. I still wonder if this line isn't horrible, and we need getModuleAdapter() to return a properly configured module. \n. Nice.\n. Doh!\n. Hmm.  How is this better than throwing a clearer runtime exception. THis isn't a violated assertion or an impossible state.  This is what you get for running Dagger in something with a crappy security manager. \n. Nice.\n. Good call.  Agreed. \n. Hahahahah.  Summands.  Awesome.\nOk... addsTo it is. \n. Check.\n. Got it. \n. Well... only sort of... best case of one configuration (codegen falls back to reflection) may well have a logged exception from the code-gen provider.  I wonder if we shouldn't actually gather and log/throw all of the errors if we throw at all, so you can see.  'cause if there's a missing $InjectAdapter, it'll log Level.FINE but that's really the problem.\nThat said, I don't know if I want to allocate storage to store exceptions where it's not needed.  grumble\n. Yeah - but it seems to expose the adapter a little.  it feels more like  a result.init() call, which internally would sort this out.  Or just have getModuleAdapter do it before returning, so you always get an initialized adapter.\n. (I almost did this change last PR but it was getting too big - leave it for later if you want.)\n. I completely agree with your assessment... and I mis-remembered when you get an IllegalAccessException vs. SecurityException.  Carry on.\n. sold. \n. Yeah, I was wondering about this.  I presume we don't have any tests that force the concurrency case that could have detected this?\n. These can be inlined now, I think. \n. Ohhh.  I handled this in ModuleAdapter, but not in the at-inject stuff.  Check.\n. It would be good to have a test case that invoked this.\n. SGTM\n. Awesome!\n. Heh.  Woops. \n. Ohh... Does this keep them from being orphaned and therefore needing to be entry-points?\n. On 5 Jan 2013, at 14:48, Jesse Wilson wrote:\n\n.... ahhh. I see what you're doing here. Don't like the /* singleton \n*/ comment, eh?\n\nThat was a Kevin request.  I don't mind.  (Sorry - not a full response \nto all comments - I'm not in a position to really respond to the review \nthis sec.)\n. Yeah - I played with this a few different times - nothing really felt natural, to be honest.  I really wish Java had templates done nicely.  Le sigh.  if you prefer it, I can adapt it.  It just ended up being as awkward, as I had to split on \\n to make them emitted multi-line.  I'm 50/50 so I'll go with your preference here. \n. I think field is, because a single class can have both constructor params and fields, and they can be named the same.\nclass Foo {\n  @Inject String foo;\n  public Foo(Integer foo) { }\n}\nWhy you'd want to do that is beyond me, but it's valid java and not, technically, a conflict. I'm ok with f_foo and p_foo, but this was precise, what it meant, etc. \nThe constructor version is parameter_blah = ... and I think it distinguishes things nicely for later maintenance.\n. Crap.  I'll do a secondary check to catch classes but not packages.  It'll miss a class named java.util.foo if such would ever exist, but java.* usually follows their conventions, and worst case of missing is a FQCN. \n. Yeah... I know it's less DSL-ey.  But I was trying for consistency so everything that emitted something looked more or less the same, since you're not annotating the writer, you're emitting an annotation, just like a package.  Either go full-on DSL, or don't. :) \nThat said, I have a totally different approach in another branch I'm noodling with (alternative to JavaWriter) that might be cleaner, but it's a separate issue to this fix, which is about the outcome.\n. cut/paste.  Sorry. \n. I'll re-work it. \n. Fair enough.  I'll make it so. \n. It's in a separate branch, and it's \"noodling\" as I said.  The point was to make the emitter code way more readable, but you're right, it can end up in yak shaving.  That's why I didn't do it in the same branch. \n. So... your preference is noted, but consider the following.\n1. People's first access to this code (in a stack trace) is going to be this generated adapter\n2. Inheritance loses some context which you have to follow, which means you can't \"just see\" what's going on.\n3. This definitely is balanced in favour of the newbie who doesn't know the infrastructure - you are not your customer. \nThe documentation is repeated so it's as local to a reader's context as possible - as such it has to be duplicated.  You may not appreciate it's aesthetics, but you can skip over it - someone who is reading the code would have to go elsewhere to understand it then return.  I'm trying to avoid that.\nThat said, the javadocs are the weakest part of this change, and in some cases, I am happy to replace with.\n// internal infrastructure\n// Provider<T> implementation\n// MembersInjector<T> implementation\nBut I still think a full Javadoc is valid.  Most people reading dagger code (if Guice is any example) won't be people who know the DI framework, it'll be people who inherited it and need docs as close as they can to the proximal cause of error so they can understand things well enough to determine the root cause.\n. Done.  It's a crappy fix, but it is simple, works, and is readable.\n. Not yet - I'll ping. \n. Heh.  Dammit. \n. done\n. Yeah - I don't remember why I added that, but i wasn't sure why the existing doc was there.  I'm just going to remove it.\n. Because I was trying to not over-engineer.  This was bunches simpler than doing an intersection test for each field.  I can do it if you prefer. I just thought it was one step of overkill.\n. Done\n. It was to match the \"write\" prefix of all the others, rather than have a holder class breaking the readable flow. \n. SINGLETON is already used as a constant by your bitmap. IS_SINGLETON I can do. \n. Oooh.  Not a bad idea.  Then again, they could just be constants.  I like that better.\n. hasFoo is a long-standing pattern for boolean names.  What is sloppy about it.  It's a boolean.  isSingleton isn't a slam-dunk... which is why it's a boolean that could be false.  I'm not sure I follow here. \n. Yeah - maybe I'll add SuppressWarnings, though requestBinding is only used internally, so hopefully neither solution will ever impose on end-users. \n. WAit... looking at the actual generated code, it's not producing a warning in either eclipse or maven. And when I add it, it's showing the annotation (unchecked, not unsafe) as unnecessary.  What warnings are you seeing?\n. Except it isn't javadoc, and making javadoc generic enough to produce /* */ or /** */ would make the api worse, and be more complex than just this, I think. \n. Cut/paste error.  Done. \n. If we don't compress dagger.internal, then we end up with dagger.internal.Binding in casts and fields, and it ends up being really long harder to read at a glance lines. \n. This whole section isn't about imports - the imports need fully qualified class names.  This is about stripping packages from already imported classes, since the simple class name will suffice. \nAnother approach would be to pass in the list of all imported types and use it to strip, but this (and compressType) was a good-enough heuristic.  If the next element in the FQCN is not a capital it's package so don't strip.  It's just automating the naming convention.  It's that or a lot of special casing and any time I added an Import, I would also have to add the special case. \nI could build it such that if we emit the import, we keep the class and strip those, but I'm going to have to do splitting on periods, and I was trying to avoid building that more complex code generator system you cautioned me about. :)\n. Absolutely nothing - this evolved from something else.  Oops.  Thanks.\n. Hadn't had cause to make it so, and I didn't want to start digging into the three different kinds of comments.  I nearly didn't do this and just made an \"emitRawText\" method.\n. Doh - that was clearly reflex.\n. done\n. Agreed, and HOLY CRAP IS IT NICER TO LOOK AT.\n. done\n. The code would be more cleverer if it required me to import Set.class.  Right now the compression is a blind heuristic for major packages.  I was thinking of making its behaviour connected to the actual imports you use, but I was trying to steer away from a generalized code generator and this was headed in that direction. \n. Ah.  Yeah.  Ok.   I added the supertype thing after I name it.  I'll take\nanother look when I get near my computer.\nRegards,\nChristian\nSent from my iPhone.\nOn Jan 13, 2013, at 17:32, Jesse Wilson notifications@github.com wrote:\nIn compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java:\n\n}\n-    if (supertype != null) {\n-      writer.statement(\"injectMembersBindings.add(%s)\", \"supertype\");\n-    return interfaces.toArray(new String[0]);\n-  }\n  +\n-  private void writeImports(JavaWriter writer, boolean hasFields, boolean isProvider)\n-      throws IOException {\n-    writer.emitImport(Binding.class);\n-    writer.emitImport(Linker.class);\n-    if (hasFields) {\n-      writer.emitImport(MembersInjector.class);\n\nThe boolean is called hasFields but the code that calls this uses\n\"hasFields || supertype != null\". Why not just name the boolean\n\"importMembersInjector\"\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/square/dagger/pull/133/files#r2630052.\n. Check.  I can move more in, especially now that its more of a set of\nconstants.\nRegards,\nChristian\nSent from my iPhone.\nOn Jan 13, 2013, at 17:34, Jesse Wilson notifications@github.com wrote:\nIn compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java:\n\n@@ -327,38 +386,51 @@ private void writeStaticInjection(TypeElement type, List fields) throws\n         .createSourceFile(adapterName, type);\n     JavaWriter writer = new JavaWriter(sourceFile.openWriter());\n-    writer.addPackage(CodeGen.getPackage(type).getQualifiedName().toString());\n-    writer.addImport(StaticInjection.class);\n-    writer.addImport(Binding.class);\n-    writer.addImport(Linker.class);\n-    writer.emitEndOfLineComment(\"Code generated by dagger-compiler.\");\n\nSorry, I guess I was thinking of your Javadoc utils class being more like a\n\"Documentation\" class. In this case, the string \"Code generated by\ndagger-compiler\" is duplicated. And since it's duplicated, we could easily\naccidentally forget to add something like, \"Do not edit\" each time this\nstring occurs.\n\u2014\nReply to this email directly or view it on\nGitHubhttps://github.com/square/dagger/pull/133/files#r2630054.\n. I gotta scrape out all the e-mail-isms when I reply on e-mail. :) \n. Ok - so we fixed the warnings display, so I'll add the suppression here. \n. Doh.\n. On 14 Jan 2013, at 21:14, Jesse Wilson wrote:\n\nI still don't understand how this works. How does it compress a name \nlike say \"java.util.Vector\" if that isn't in my imports? Shouldn't \nthis just use the imports rather than this chain of if/else calls?\n\nOk.  I was clearly smoking crack.  I misunderstood how the import stuff \nworked in a pretty embarrassing way - it worked exactly the way I had \nconsidered and rejected making it work\u2026 I just misread it totally.\nAnyway - I'm fixing it and adding proper tests including taking your \nadvice on what the test should do.  When I squash it'll work.  \n. Done\n. OMG - I fixed it and accidentally reverted it.  Argh. \n. You don't need invoker.properties for a success run - that's the default.  This file can be omitted, I believe. \n. I'm confused - why is this file even in this pull request?\n. NVM.  I'm assuming this is \"clean as you go\"\n. Yeah - that was the existing way it was in BuiltInBinding.  I cut-and-pasted that one.  But I'm switching this to an AssertionError anyway.\n. done\n. done\n. Is this really a qualifier in the strict sense?  @Qualifier is to qualify a binding, equivalent to @Named, and this is quite a different use case.\n. Dont really like the \"Assisted\" word her.  It is mostly a labelling issue - btu rather than thinking of this as \"injection assisted with parameters\" I think of it as \"automate factories that do a bit of injection\" \nAs such, I'd much rather go with @Parameter or @Param or something that shows this is not injected, it's going to be a factory parameter. \n. I presume that you are using this value to provide a workaround for the missing run-time parameter names?  Its one of the reasons I avoided  a reflection back-end for factory generation - because it requires too much of the client code. \n. Um... isn't that the default if not specified?  We structure the whole project in a pretty default maveney way, so I'm not sure why we ever specified this. \n. http://maven.apache.org/ref/3.0.4/maven-model/apidocs/org/apache/maven/model/Parent.html#getRelativePath()\n. Woops - thanks @tbroyer.  Your comment hadn't updated when I posted. \n. Done\n. Grr... copypasta.  Done.\n. Done.\n. Agreed.  Removed it.\n. No.  If you say true, you're saying you've taken care of this annotation.\n. I disagree with that convention, mostly because it ends up making duplication but I think I'm just frustrated with the fact that provides methods themselves duplicate the semantic content of the signature in the name.  \nBut I'm not so opposed to it that I'll fight it.  I just dislike it quite a bit.  But I'll fix this to conform so at least there's a not-incorrect pattern.  I was using non-provides language to make it clear that the method name is irrelevant.  \nHmmm.   maybe I should say\n@Provides A irrelevantMethodNameA() { return a; }\n;)\n. Fair.  I'll fix. \n. Maybe, but I'm inclined to leave them.  FullGraphProcessor really processes modules for a different reason - not to generate, but to analyse.  I feel like it's a different processor.   I'm actually not sure why we mark any of these as returning true, since that means no one else can write a processor that processes those annotations unless they manage to get it earlier on the processor list (presumably earlier in the classpath)\nBut let's revisit this when we re-examine the whole processor infrastructure in 2.0\n. Actually - removed the test, since it's completely implied in the other. \n. Done.\n. Fixed IllegalAccessException verbiage too. \n. (Not serious - I made it provideA)\n. Awesome. \n. 2013\n. Heh.  Coolio.\n. This really feels like you're testing singleton/non-singleton nature, not all aspects of binding.  Maybe SingletonBindingTest?\n. So this is annoying to have to complain about, but the style guide for square (Which dagger follows) puts all static imports in lexical order after all non-static imports, in lexical order.   I've changed all my eclipse settings for dagger projects to do this - it's definitely not the eclipse default. \n. @swankjesse - you need to document this crap. :)\n.   After all that conversation and I missed it. lol.  I need to put in some kind of checkstyle validation or something for that.\n. So on these tests, since the poms are already translating their artifact version from properties, I wonder if we can't do the same and configure invoker to set the groupId.  This way the poms between forks will have no changes - merely the provided groupId property.\n. Might we never run in a security manager that would reject our method.setAccessible(true)?  I can easily see it especially when I get the J2EE filters in place.  I can restore it, but I think this error can occur even outside of the applet sandbox.\n. It does warn here.  I think because even though it's overridable, it isn't used in THIS method and there's no guarantee that someone WILL override it. \n. This feels like an error-prone check or something.\n. Hmm.  Or would that be a SecurityException... Never mind.  I'll revert.  It wouldn't be an IllegalAccessException at all.  Sorry.  My bad. \n. On 27 Feb 2013, at 13:00, Andy Dennie wrote:\n\nReplying via email since I can't seem to find this comment on \ngithub...\nIf you're referring to the fact that there's a missing .isTrue() at \nthe\nend of that line, I fixed that yesterday.\nOr are you questioning the purpose of the test?\n\nNo, I'm saying that this mistake was an easy one to make and is a \ndown-side of fluent APIs like Fest or Truth, and it might be good to use \nsomething like error-prone to detect and make compile errors a \npurely-no-op statements like\nassertThat(aBoolean); // FEST\nASSERT.that(aBoolean); // Truth\nsince they obviously need isTrue() to \"turn the crank\" on the fluent \napi.  So they're in all cases errors where the result of the method \nisn't captured into a variable.\nJust a tooling comment, since we do use a fluent API testing framework.\nI'll take it up with the error-prone team and Alex Ruiz (of FEST) and \nsee if we can't get some of these obvious cases to be impossible to \ncompile.\ncheers,\nChristian.\nChristian Gruber :: Google, Inc. :: Java Core Libraries :: Dependency \nInjection\nemail: cgruber@google.com :::: mobile: +1 (646) 807-9839\n. If you're going to var += \"foo\", please use a string builder. \n. curse you google/square style differences!!!!!!\n(I'll fix it later tonight)\n. Nope.  \"This\" is exposed to other callers because \"this\" is the Lazy<T> that will be injected, so if anything else locks on that Lazy<T> we can't assure no deadlock scenario.  This has to be something internal. And we can't lock on the cacheValue for obvious reasons. \n. See above.  If someone injects Provider<T> then they have access to the object to which the mutex refers. \n. Thread count.  Get it?\n. It was to make the later value more readable in the assertion. \n. Wait.. this passes checkstyle.  what should this be?\nfor (int i = 0; i < whatever; i++) {\n   ...\n}\n?\n. Also, if your object isn't expensive enough to create that new Object() vastly beats it, then you shouldn't be using Lazy, I would think.  Just create your object.\n. LOL.  Ok.  Sold.\n. ... Sold, that is, provided we document it somewhere - some note about concurrent access, noting that one could end up with a deadlock if one isn't careful about locking on the injected Provider<SomeSingleton> or Lazy<SomeSingleton>\n. LinkedList isa Deque.  I need a stack. \n. modulo \"included by\", sure. \n. I need to pass up the more local module. IllegalStateException can't carry forward the underlying module, which is NOT the same as the module at the top.  It's really awkward that we do error(..., localmodule) THEN also have to throw to get back up the call stack.  Just passing a more articulate message is better... especially in the compiler where we ARE in a JVM.\n. Actually, no.  In the self-inclusion case I want a particular message.  But for the more than self-inclusion case, I can harmonize. \n. Yep.\n. I left this in only to make sure that there wasn't some IllegalStateException I hadn't found that could bubble up, like from the ProblemDetector, etc.  I'm ok eliminating this, but I didn't want the scope of this PR to get much bigger than solving the issue at hand.\n. Why, given that I'm only pushing/popping, is ArrayDeque faster and far superior?  Both do \"contains\" with an O(N) lookup, and we're talking about 3-digit quantities tops (if you have an application with 1000 modules, UR DOIN IT RONG).\nThat said, i'm not opposed - just curious as to the strength of your dislike of LinkedList here. :)\n. I'm ok doing it, I just didn't want to broadly sweep all the exception types in this PR.\n. Ok.  You merged, so I'll fix it in another PR along with other cleanup. \n. Can I get some more information on what library() is for?  I didn't see \na discussion about it, and it's a very clear addition to our public API.\n. I don't think this should be an error at all.  An interface or enum could very well be an entry-point so long as it's bound somewhere in the modules.\n. Oh... er... yeah.  What Jesse said. :/  (Should read a whole review before adding my 2c)\n. So this should fail not because includes=someinterface, but because includes=non-module.  \nI don't think this PR really addresses the question of whether interfaces can be modules.  For instance.\n@Module(entryPoint=Something.class)\ninterface MyModule {\n  @Provides Something providesSomething(SomethingImpl impl);\n}\nShould that be valid if someone actually creates an anonymous subclass that makes provideSomething callable?  Should it be valid because we can easily infer with reflection or code-gen that this is so?   Or should interfaces-as-modules represent some sort of \"contract\" for a module and any module that conforms to that contract should be swappable for this one at run-time, with checks agianst it, etc.  Jesse and I talked about something along these lines, though it needs a LOT more fleshing out.\nThe point is that I think this should fail only because it's not a valid module, not because it is an interface. \nThe fact that interfaces aren't valid modules is the current situation, but the approach sort of sweepingly declares that they cannot be, and I can see a few different reasonable uses for interfaces in the module configuration system. \n. So... did anyone test this with a singleton binding?  I just had a whole whack of code fail in google because of a class cast exception because a SingletonBinding not-isa AbstractProviderMethodBinding. \n. Never mind - I see the fix in a later commit.  This is going to play hell with my syncing. :( \n. I don't need to make a change - your change that removed AbstractProviderMethodBinding and handles this differently is sufficient.  The only issue was that I was mid-sync with all sorts of fixes and approvals underway (assigning people's libs to library = true, etc.) when I discovered that this was a bad place to sync.  Nothing to do on this project's end.  It's all internal. \n. Woops.\n. Habit? I'll fix. \n. I'm not opposed, except that this isn't an annotation we can't handle, this is the annotation being reported back on an impossible type.  I still think reporting the extra weird is more helpful than harmful. \n. Its' two commits, I can re-submit this as separate pull erquests.\n. should I remove it?\n. Of course we are.  We make line length restrictions contra running everything through an automatic formatter, so you get gaming behaviour to keep things within the line length limits.  :p \nThat said... I'll fix it.\n. ack\n. Ack. \n. Done\n. I thought our policy was we can break between versions.  I have another breaking change in how Singletons are handled... was thinking of having a simple API that would allow dagger to throw away, or fail to the next loader if an unhandleable loader is possible.  That said, I guess we can create a deprecated overload.  But I think even a simple generated version is appropriate. I'd put it in the @Generated annotation, but then we'd incur a lookup penalty I want to avoid.\nAnyway, we should kick that to another issue, and I\"ll add the overloads.\n. Woops.\n. Ok.  I'll go that way.\n. Actually, later, we can remove stupid checks - beyond the scope of this PR\n. Thought about it and figured this was one less method call since we're generating the class.  Meh.  potato potato? \n. ditto\n. ditto\n. self nit: @deprecated\n. self nit: @deprecated\n. Yeah - I did it the way you suggested. Also cost me some line length, \nbut oh well. :D\n. So we're going to be adding more checks like this at Google, as well as doing some of these in-place checks, or validation checks, for Guice.  We will probably put the guice checks into https://code.google.com/p/error-prone/ but we're figuring that out.  I have an intern working on some of these.  We're trying to make sure we don't do any  checks that would result in code used by both Dagger and Guice apps to fail in one or the other, but for those that are unambiguously erroneous in any JSR-330 app, we hope to roll out more checks.\n. Done\n. Done.\nHeh... well, this will make FailoverLoader much smaller. :D\n. Done\n. Done again.\n. Actually, named it create() for consistency. \n. Done.\n. No - we need to keep processing after the error, so we catch all the erroneous provides methods. \n. I'd be open to it, but the change is merged.  I'd not oppose a PR that did this. \n. Acknowledged\n. I'll add the comment.  newModule() should never fail on a ClassCastException, so I should move that out.  I added some javadoc in initModuleAdapter to indicate that it is attempting to load type+suffix.\n. Done\n. Made some javadocs that make it clearer.   This class no longer does anything but load things, so it always passes the CNFE, and the javadocs say so.\n. Ack.  FInd some solid use-cases and make the argument on dagger-discuss.  I'm not opposed, though with this change, I'm less clear how needed it is.  But if it's really needed, do it. \n. Yeah - that's my dumb.  Curiously this was passing because IllegalArgumentException.class isn't sufficient information to ensure it was the missing module annotation on the included module at fault.  It was failing on the TestingLoader not having an annotation (which it shouldn't since it's not a module), but that was a different failure than this test was intended to generate. \nI fixed the test.\n. Agree with Jesse's constraint - shouldn't be able to mutate the graph from a child - that's massive unsafety right there.  Consider the leaks!  :)  Definitely, a second module in the same graph should succeed. \n. So... I feel like a fool.  I could use the LRU cache. Doh!  I think I didn't because I started with ConcurrentHashMap and some expiry handling wrappers, but bailed.  I'll try it wtih our LRU cache. \n. Yeah - I always copy a class and scrape out the content - to get the boiler plate... and then I chose poorly. :/  I'll fix this. \n. So, safe in what way?  Can it race?  Yes.  But in this case, it should be racing on putting the same thing in. What are the failure cases of safety you're worried about right here?\n. Done\n. Done\n. I put that in as a straw man for comment.  I also worry about churning, but don't know of a good way to configure this.  I don' t want this to grow unbounded, though we could.  I'm open to alternatives (either to the value, or to the strategy for expiry). \n. Made it a proper noun with link. \n. Ah - that was a rebased change and reversion.  I'll omit. \n. Ugh.  I have to stop cutting-and-pasting boilerplate and forgetting to update it. :(\n. Why?  I tested it at 2, at 3, and at lots, and just left it at lots. \n. Crap - Ok, I hadn't clued in to the cache resizing issue on concurrent-write on get(). these tests do test the basic double-check.  I didn't write them to catch a regression, I wrote them to prove that I had written the double-check correctly. \nTalking to louis, and a few others, I think I need to use different collections here, and the prime candidates are buried in MapMaker and CacheBuilder in Guava.  I may need to rip them out, so I can get weak keys and concurrent write safety for get(). \n. Fun times.\n. Per my other convo, I now see what you mean - I hadn't remembered the \"infinite linked list\" issue with map resizing.  I'm thinking of ripping out guts from Guava's mapmaker or cachebuilder which I was trying to avoid, but may be necessary.  Any altnernative suggestions?  I know of no other \"WeakConcurrentHashMap\" and \"ConcurrentLinkedHashMap\" impls.\n. It won't be strongly held IF the weak reference is the only path from a thread to the loader, unless I misunderstand the GC.  I'm a little uncomfortable with a per-graph cache - That'll bloat like crazy in a design that has a lot of scoped graph instances - way too much creation/destruction of these caches.  \nIf the class leaks outside of this cache - that is, the object is in an app-level graph, then there's a strong refernence to the classloader obtainable not via the weak reference.  But this is intended to handle cases where you have whole segments of graphs lined up with the classloaders, so when you change whatever's in the loader (throw away the classloader) you're throwing away (or eventually will release) all the types attached to that classloader, and the relevant instances of the graph.\n. Um... synchronizing on the map (or equivalent) is worse, as it locks everyone out for every read, where this does not.  I'm not sure how what you said makes sense at all.  And if I don't lock on the whole aroudn the read, I get the unsave \"get()\" operation you, yourself, critiqued in an earlier version.\nI may be misreading your review, but you seem to nearly be reversing your position entirely.  That seems odd, so I suspect I am misunderstanding - but when I posited a read/write lock above, you said, and I quote, \"Yup, that's perfect.\" \nQue?\n. Put another way, in nearly every case, this lock structure will be a read situation FAR more often than it will be a write structure, since every single lookup will read, but only an un-encountered ClassLoader will write.  That vastly puts this into ReadWriteLock territory from a performance perspective.\n. You suggest simply locking around the whole operation?  I guess if we're not going to have a lock-free get, there's not a lot of reason to double-check. :/ \nI'm really trying to minimize the amount of time we're in contention.  If I could make this lock-free I would, but get() is unsafe.  This method is really really busy when we have deep scoping - lots of threads are going to come through this method on every adapter load. \n. There is no strong chain of references from the static singleton to the class in the cache.  Where is that chain?  \nThere are such a strong references if the classes (or any instances to it) are held outside of the cache - but one can design one's use of plus() to ensure that all references to such are freed when you're going to unload the classloader (ditch the scopes that know about them, and re-create them from modules from the new classloader).  \nIn terms of this cache, there are weakreference map entries which hold the reference to the class caches, and if all other references outside of this cache are released, then the only way to get at the objects is through the weak reference.\n. Each loader gets its own cache, but you can't actually have two loaders - you get failover OR... actually the only other loader we have is a test only loader or the fake loader for full graph analysis.  There's no longer a chain of loaders - you pick one.  Failover does reflection as a backup, but if you wanted a fully reflective loader, you would replace Failover loader with ReflectingLoader, or GWTFriendlyLoader (making that one up) or whatever.\n. Yeah - the error we found was on a ByteArray, so my inital repro was about that... then I extended.  PrimitiveArrayModule. \n. Maybe - but I'm actually going to punt on this - now that I have the test running with code gen, I'm whipping up something that will let us run a set of feature tests on the run-time with the test loader, and with code-gen in the compiler with the production failover loader. \n. Sorry... to be clearer... when I'm done, I'll move this test with all the others, and all of them will run in both contexts. \n. nit: Also Google.\n. nit: also google. \n. * Cache class loading at the root injector to reduce costs of loading adapters.\n. Yeah - I'm a little unenthused about this... but I actually think we need to completely re-build this guy around a module loop, not a provides method loop.  :/\n. I think once Steven's additional checks are in (he adds a validator \nprocessor, I believe) that would likely be a good home for that \nparticular check, while module generation could be more\u2026 loopy. :)\n. Oh weird.  Totally unintentional.  I meant only to fix the (C) to a (c).  I'll fix that up.\n. I also have no idea why git would think this was a rename/modify.  \n. Yeah, while I contributed to API design and some discussion, this is all Greg Kick magic.\n. Reordered them all, so the success ones are at the top, but tried to keep them grouped by relevant thing we're testing.  That may not hold if we grup by success/warn/error, simply because testing that Scope are misused one way may have warn/error cases, but a different way may also have warn/error cases.  \nAnyway, I'll just try to keep them logically grouped as things go, but I agree, success cases at the top is handy.\n. Does gradle use scopes in a similar way to maven?  I'm not sure why \"provided\" isn't the correct scope.  Whatever the correct one is, you want dagger-compiler to not be in the transitive closure of the end binary.\n. Reordered these a bit. \n. Better error message.  Thanks.  That one was from the earlier form of this code. \n. So, speaking of \"Not tested\"... instead of adding this line to the read-me, can we get a \"gradle\" example project under the \"Examples\" folder, so someone can run this (we can even hook our build to call out to gradle and build that one, perhaps).  This way we're not throwing up configurations based on hearsay, but based on something working that is in the project. \n. Yep.  Otherwise I'd need to call it twice to get the bindings, or open an extra hole in DaggerObjectGraph in order to get the bindings which this returns nicely.  So I just moved it. (comment for other observers.)\n. Done\n. Good catch. Done.\n. Ok - I\"m going to come down here and ask why?  We've talked this through before, but in a case where you literally have zero need for order guarantees, why is LHM so crucial?  Especially when allocations are so important on Android?\nBTW, someone is doing a little experiment inside Google with this code (which is currently in our fork) to see how it behaves with CHM.  Since access (vs. mutation) is incredibly the norm under load, we're trying to see how much faster the parallelism of CHM is over even this read/write lock.  But this works, and we know it works, so we'll wait for numbers before that decision. \n. Good question.  I'm not 100% sure - I think using the read-lock is superior, but I'd rather leave this and optimize in a future pull, since this is Greg Kick's code I\"m pulling in. \n. Doesn't.  I'm going to do any changes in a separate commit (still on this pull) so as to not have merge screwiness with the google fork.\n. Yep.  I'll re-base and fix.  The other PR came after this one in our code anyway, so I can probably just re-play the original commit.  I just didn't want to pre-sage which would go in first, so I fixed up the other commit.\n. Heh.  In a string.  Ubernit. :) (done)\n. Done.\n. You're right.  That slipped in on our side.  Not a nit - unnecessarily extra allocations.\n. By the way, I think this code still has a bug.  I didn't change the core logic of this conditional - I just pull out some info we incidentally process.\nThe additional issue, which is purely in analysis...  at runtime this just works because of dynamic linking... I believe this will simply not do full graph evaluation against any class (concrete or abstract, but not interface) listed in injects= if it is not a Members-injected class. That is, if you injects=Foo.class where it's an injectable class (i.e. class Foo { @Inject Foo() {}} ) then that case may simply not end up with a requestBinding in analysis.\nI'll work up a test case for it separately.\n. Obviously this needs 0.4 final. \n. Yeah - and here - needs to be fixed to match Greg's stateless module adapter thingy.\n. Yep.  That's why I cloned the collection, though the bindings are the same (so scoped bindings aren't re-resolved)\n. Nit: Note, you can do A as an inner class, though you can also do a second source file for A, and do\n```\nimport ...JavaSourcesSubject.javaSources;\nimport ...Arrays.asList;\nASSERT.about(javaSources()).that(asList(a, module))...\n```\nTotally your option - just letting you know what those options are.\n. Yeah - I toyed with new exceptions, with pulling it out of this method, and in the end, IAE is extracted and reported as an error in the right ways at the call site. \n. You know it.  I have some clean-up commits that are now out of date, and I'll have to re-do them, but I've been focusing on performance issues that have surfaced from aggressive use of Dagger on servers. \n. BindingsGroup[FooBinding..., BarBinding...]\nTurns out it's not so bad.  Also, it's there for debugging alone.\n. Doh.  Eclipse refactor overreach. :/\n. Doh.  Eclipse refactor overreach. :/\n. Done (next push)\n. We played with this - turned out 1.5 growth factor works fairly well and we couldn't figure out a clean API for hinting to dagger what your expected scale is.  The shift from LHS to ArrayList changed the performance characteristics so substantially that minor capacity tuning was noise. \n. If it were an array, I'd say sure.  Given that it's already a list, not sure it's enough of a savings. \n. ditto. \n. Heh.  I think that was automated. :)\n. It's an arraylist.  It'll die painfully if it's ever a linked list, but it is an internal structure we control, so... done. \n. Wait... I left the linked list in here?  Sigh...\n. ",
    "JakeWharton": "If you wrap them in backticks in both comments and commits they'll be interpreted as inline code.\n@Produce\n. Closing. If seen again submit failing test case in a pull request or provide full sample code for reproducing.\n. I added an example to Tape yesterday which includes Dagger (http://github.com/square/tape). While it doesn't use the Android-specific manifest features, I do have an internal implementation that does. We currently use the maven-exec-plugin to trigger the manifest parsing during the generate-sources phase.\nI was hoping to amend the manifest module to allow it to operate as both a standalone jar or as a maven plugin itself. Doing so would allow it to require no configuration whereas using it with the maven-exec-plugin requires you to specify a few things.\nI'll try to get something in this week.\n. It represents one strategy. The application is effectively a singleton on Android and is instantiated before anything else which requires injection which is why we use it to construct the object graph. Also, optionally, you could lazily create the object graph using a singleton managed by the traditional standalone pattern.\nWe are still working on providing a means for using Dagger on Android whose API is less abrasive to consume (even if behind the scenes it does the same thing).\n. I'm calling this blocked until Travis CI fixes their support for Android. I don't want to inhibit development of this problem by breaking the awesomeness of branch builds via Travis.\n. Also, Android Bootstrap just updated to support Dagger.\n. #223 \n. It used to be a standalone .jar that you had to invoke using the Ant method or with the maven-exec-plugin. It only recently just changed to be a Maven plugin as well.\n. You still have to import the generated module and include it in the graph. I have a sample coming soon for this component to show it in action. We use this internally so I can assure you that it's working.\n. Closing this as a dupe of #33. Though we no longer use the maven-exec-plugin (thankfully) the usage still needs to be demonstrated in a simple example. We'll get to this before v1.0.\n. Do we care that a utility class is going into core? Not sure where we make the distinction with this library yet.\n. FYI: I force pushed to master to revert HEAD to before this revert. We moved to an internal fork to prevent slowing open source development.\n. That is correct. Since this project is still a bit volatile (and rightfully so), we will pull in changes from master to our internal fork once we verify that they don't break anything on our apps. Just because we are depending on a SNAPSHOT version of the project shouldn't mean we limit its development in any way, especially when it's being developed open source and by external and third-party contributors.\n. The refactor itself LGTM.\n. Yes. Fabulous.\n. No. View injection is not actually dependency injection it's just a convenience wrapper around calling findViewById and doing an implicit cast. A feature like this requires activities to extend from a common base class provided by the library which is a really bad thing to have to enforce. This is also further crippled by the fact that the constants in the R.java class are no longer final for library projects and thus cannot be used in annotations.\nYou could very easily write something to do this yourself since it doesn't actually require any libraries. Just create an annotation and in your common activity base class iterate over them and call findViewById. Another way which creates a cleaner looking onCreate method is just to have an implicit-casting version of findViewById like this:\njava\n/**\n * Finds a view that was identified by the id attribute from the XML that was processed in\n * {@link #onCreate(Bundle)} and performs an unchecked cast to the destination type.\n *\n * @param id View ID.\n * @param <T> Destination cast class type.\n * @return The view if found or {@code null} otherwise.\n */\n@SuppressWarnings(\"unchecked\")\npublic <T extends View> T findById(int id) {\n  return (T) findViewById(id);\n}\nand then your onCreate becomes:\njava\nsetContentView(R.layout.whatever);\nTextView tv = findById(R.id.title);\nSomeCustomView scv = findById(R.id.custom_view)\n. @staxgr If you switch the annotation's properly to value it will be implicitly assigned and then you can do @InjectView(R.id.whatever).\n. Dagger is for dependency injection satisfied by code-gen and compile-time graph verification. View \"injection\" has nothing to do with dependencies and is merely made to emulate actual injection. I think myself and most would recommend the findById approach.\nThe @InjectView part above was just to demystify what it does. Someone could very easily create a tiny, standalone library that does code-gen for all @InjectView annotations and then satisfies them by calling Views.inject(this) on an activity or fragment.\n. > The @InjectView part above was just to demystify what it does. Someone could very easily create a tiny, standalone library that does code-gen for all @InjectView annotations and then satisfies them by calling Views.inject(this) on an activity or fragment.\nI wrote this last night in a one-off experimentation with code generation for another project: http://github.com/JakeWharton/butterknife/\n. I'd like to close this since it isn't a very actionable issue. The only outstanding question is whether or not we want to adopt find bugs' @Nullable as a 'provided'. If not there's no action to be taken. If so, we can create a focused issue along the lines of \"Introduce FindBugs Annotations\".\n. Yeah that'll work.\n. I tried exploring the case of Collection<Foo> earlier after making this change and wasn't too happy with the potential results. That said, what I understood was that Jesse wanted to get @OneOf out of the public API for v0.9 so that there's a little more wiggle room in the API (not that we're committed to anything, really).\n. I also have the interesting case of @Provides(type=SET) String and @Provides(type=SET) Collection<String> set up in a test case on the jw/provides-type branch. Eager to see how the API ends up there.\n. And now the G+ community.\n. I'll do this today.\n. Ok, tomorrow.\n. We won't be doing this.. The groupId and artifactId follow convention which are much more important (as do all our single package name projects).. #205 \n. Pretty clever stuff. Eager to see what the two big brains think of it.\n. This is also annoying for set bindings where I want to collect a bunch of, say, Async<?> things and not really care what their generic param is.\n. Good find. Thanks!\n. I've used it as well. Far from ideal but it mostly works.\nThat said, this plugin is not required for development on Android. It merely generates a module for your manifest entries which otherwise could be done manually. We also aren't sure in what form it will exist (if at all) by the time Dagger hits 1.0.\nAndroid is moving to Gradle in the next year anyways so if we do keep this around we would probably move towards solely supporting that in the long run.\n. Closing. For further discussions please see the Google+ community or the mailing list.\n. IntelliJ just delegates to CLI Gradle. Eclipse does do the same?\n. True. But Gradle does incremental builds itself and the IDE keeps the\ndaemon warm so it's just as quick. Change one file and it only compiles one.\nOn Aug 8, 2013 7:06 PM, \"Christian Edward Gruber\" notifications@github.com\nwrote:\n\nThat would suck, as it wouldn't be able to auto-configure eclipse's\nannotation processing support to \"just work\" in eclipse incremental builds.\n:(\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/126#issuecomment-22371488\n.\n. The solution, as mentioned above, is to refactor the code to eliminate the cyclic dependency.\n. You might want to create HoneycombModule and EclairModule and then conditionally add each module to the object graph when you create it.\n\n``` java\nfinal Object searchModule;\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {\n  searchModule = new HoneycombModule();\n} else {\n  searchModule = new EclairModule();\n}\n...\nog = ObjectGraph.create(\n  new ThisModule(),\n  new ThatModule(),\n  searchModule\n);\n```\n. You could create a gist with the original and then edit it with the new output. Then we could look at the diff.\n. This is gross! We're failing your build because we cannot generate a GraphViz file. Looking into it now...\n. Can't repro. Can you verify this still happens? If so, please provide a tiny sample to reproduce (modifying the coffee example is where I usually go).\n. compiler: https://docs.google.com/file/d/0B490UMAh3G13N1J4OTlyQzdzSE0/edit?usp=sharing\ncore: https://docs.google.com/file/d/0B490UMAh3G13aHF3UE9zTkJMWFk/edit?usp=sharing\n. That is strange... unless you were using 0.9.0 when doing initial development?\nClosing this issue then. Report back if you see any strangeness.\n. Curious as to what features would it have or people think it needs?\nWe've had people bring up things like View injection but it actually has nothing to do with dependency injection, it's just a convenience wrapper around findViewById that can be implemented in a few lines. The same goes for things like Context injection. You could do it in Dagger either by injecting the Application context in your graph or perhaps by using individual extension graphs per-activity which use their own context (though likely slower).\nIn any case, we have no plans to do this because we haven't seen any need.\n. Also, RoboGuice relies on the fact that you have a common base activity which is something we never want to enforce. We have talked about expanding the included Android module to have a runtime component which makes things like accessing a single, global graph easier, however.\n. Yeah it's definitely not hard. I just find it unfortunate when I have to show code like this during presentations:\njava\nvoid inject(Object target) {\n  ((SquareApplication) getActivity().getApplication()).objectGraph.inject(target);\n}\nJust thinking off the top of my head, I'd love to provide something like an optional DaggerApplication base class so we could lower the bar of entry to:\njava\nDaggerApplication.inject(this);\n// or\nDaggerApplication.inject(this, whatever);\n...where this could be a Fragment or Activity. It certainly would make my slides a lot cleaner and make the library seem less scary to newcomers to dependency injection.\nPerhaps this code just belongs in a proper sample for Android though.\n. No. It's purely designed to parse an AndroidManifest.xml and generate a module for your activities and services to be injected.\nSomething like a static system service module would likely come from somewhere else. Perhaps a platform specific runtime component alluded to above.\n. We've been lacking a good Android sample too. Since adding helper implementations for target platforms is probably a bit off it could even just live in the sample as a module.\n. If it wasn't clear, I meant to convey that I am absolutely against View \"injection\" above.\nI personally want to lower the bar for applications to utilize injection. That is my primary goal for an Android-specific module.\nHaving a module that provides Android classes would be useful but in practice it's basically going to be a bunch of copy/pasting around:\n``` java\n  private final Context context;\n@Provide @Singleton SomeService provideSomeService() {\n    return (SomeService) context.getSystemService(Context.SOME_SERVICE); \n  }\n// ...\n```\nThat's why I thought placing it in an example would be a good place to start.\n. One of the integration tests isn't happy.\n[ERROR] The following builds failed:\n[ERROR] *  include-non-module/pom.xml\n. graphNodes?\n. No. There's a script that deploys the website. I've already run it.\n. Yeah, it probably could use for a better cleaning. I just did a simple find/replace. Will try to take a look this afternoon.\n. Whoops. Apparently this isn't fully done just yet.\n. There's two Android examples on master.\n. :thumbsup: \n. Love it.\n. Per @cgruber, switched all integration tests to use @dagger.groupId@ and @dagger.version@ when referencing the project artifacts. All the tests themselves were moved to the com.example.dagger.tests group ID with a HEAD-SNAPSHOT version.\n. I'm actually opposed to this (despite being the person the current impl bit pretty hard). I think our failure is that we are using overrides = true carelessly when we should be using a child graph in this case. It wouldn't have solved the problem, but it would have made it much more clear.\nDo we even know if set bindings and child graphs behave properly?\njava\nclass Module1 {\n  @Provides(type = SET) String a() { return \"a\"; }\n  @Provides(type = SET) String b() { return \"b\"; }\n}\nclass Module2 {\n  @Provides(type = SET) String c() { return \"c\"; }\n}\nWhat does a graph with module 1 plussed to module 2 get me?\n. Unless we find a really compelling reason to change, my vote is to do nothing. It behaves as expected when you think about it. It just surprised me when I ran into it.\n. Just a heads-up @adriancole, as you may have seen with #196 fixing #188 we now explicitly are disallowing inheritance in modules.\n. Removing wont fix it since you are already subscribed to this issue. You can change your subscription preference by using the drop down at the bottom of the page. As you alluded, you were auto-subscribed when he didn't fence your name with backticks. It's hard to remember to do this 100% of the time.\n. Closing this. It isn't really an issue but more of a discussion around best practices. The mailing list is a great place for this and probably will reach more users.\n. Another style note: we typically put annotations on the same line as the method/field declaration.\n. Closing for now. Perhaps this discussion should be moved to the mailing list. Examples are a touchy thing. As @cgruber says, far too many people will straight-up copy-paste them into their own code and expect them to work.\n. We include it in the <dependencies> section of our base pom (as opposed to <dependencyManagement>) so it gets included in all child modules.\n. By that same argument then 'provided' isn't what we want either because the dependency isn't being satisfied by the runtime. Optional makes a lot more sense to me because it is optional for downstream artifacts to include. There simply doesn't exist a scope for what we want so we have to choose whichever is less wrong.\nMaybe @jvanzyl could chime in?\n. You can disable the checkstyle check. I view that one as more of a \"brake check\" to make sure you know what you're doing.\n. I'm sold. Jesse should be back in the mix on Monday. We really need to push a new Dagger preview version ASAP so this and your other pull should get in.\n. And deployed.\n. Note: runtime exception-throwing for @Inject-annotated methods isn't supported or tested. This would require looping through all declared methods just to throw an exception or do nothing. Didn't seem worth it.\n. ```\n[INFO] --- maven-invoker-plugin:1.7:run (integration-test) @ dagger-compiler ---\n[INFO] Building: aaaprivate-field-inject/pom.xml\n[INFO] ..FAILED (33.6 s)\n[INFO]   The build exited with code 0. See /Users/jw/dev/square/dagger/compiler/target/it/aaaprivate-field-inject/build.log for details.\n[INFO] Building: cyclic-deps/pom.xml\n[INFO] ..FAILED (4.0 s)\n[INFO]   The build exited with code 0. See /Users/jw/dev/square/dagger/compiler/target/it/cyclic-deps/build.log for details.\n[INFO] Building: default-package-injected-type/pom.xml\n[INFO] ..SUCCESS (4.7 s)\n[INFO] Building: extension-graph/pom.xml\n[INFO] ..SUCCESS (3.8 s)\n[INFO] Building: include-non-module/pom.xml\n[INFO] ..FAILED (3.8 s)\n[INFO]   The build exited with code 0. See /Users/jw/dev/square/dagger/compiler/target/it/include-non-module/build.log for details.\n[INFO] Building: inject-parameterized-type/pom.xml\n[INFO] ..SUCCESS (4.2 s)\n[INFO] Building: inner-classes-complaint-injection/pom.xml\n[INFO] ..FAILED (3.9 s)\n[INFO]   The build exited with code 0. See /Users/jw/dev/square/dagger/compiler/target/it/inner-classes-complaint-injection/build.log for details.\n[INFO] Building: missing-at-inject-constructor/pom.xml\n[INFO] run script verify.bsh\n[INFO] ..FAILED (3.2 s)\n[INFO]   The post-build script did not succeed. Build output did not contain expected error text:\n    \"No injectable members on test.TestApp.Dependency.\"\n    \"required by test.TestApp for test.TestApp.TestModule\"\nBuild Output:\n    [ERROR] COMPILATION ERROR :\n    [ERROR] /Users/jw/dev/square/dagger/compiler/target/it/missing-at-inject-constructor/src/main/java/test/TestApp.java:[37,31] cannot find symbol\n    [ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.0:compile (default-compile) on project missing-at-inject-constructor: Compilation failure\n    [ERROR] /Users/jw/dev/square/dagger/compiler/target/it/missing-at-inject-constructor/src/main/java/test/TestApp.java:[37,31] cannot find symbol\n    [ERROR] symbol  : method AssertionError()\n    [ERROR] location: class test.TestApp.Dependency\n    [ERROR] -> [Help 1]\n    [ERROR]\n    [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n    [ERROR] Re-run Maven using the -X switch to enable full debug logging.\n    [ERROR]\n    [ERROR] For more information about the errors and possible solutions, please read the following articles:\n    [ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException\n\n[INFO] Building: multiple-provides-methods/pom.xml\n[INFO] run script verify.bsh\n[INFO] ..FAILED (3.9 s)\n[INFO]   The post-build script did not succeed. No binding generated for module\n[INFO] Building: provides-method-with-throws-clause/pom.xml\n[INFO] ..FAILED (3.9 s)\n[INFO]   The build exited with code 0. See /Users/jw/dev/square/dagger/compiler/target/it/provides-method-with-throws-clause/build.log for details.\n[INFO] Building: same-provides-method-name/pom.xml\n[INFO] ..SUCCESS (3.7 s)\n[INFO] Building: simple-missing-dependency-failure/pom.xml\n[INFO] ..FAILED (4.1 s)\n[INFO]   The build exited with code 0. See /Users/jw/dev/square/dagger/compiler/target/it/simple-missing-dependency-failure/build.log for details.\n[INFO] Building: uninjectable-supertype/pom.xml\n[INFO] ..SUCCESS (4.0 s)\n[INFO] -------------------------------------------------\n[INFO] Build Summary:\n[INFO]   Passed: 5, Failed: 8, Errors: 0, Skipped: 0\n[INFO] -------------------------------------------------\n[ERROR] The following builds failed:\n[ERROR] *  aaaprivate-field-inject/pom.xml\n[ERROR] *  cyclic-deps/pom.xml\n[ERROR] *  include-non-module/pom.xml\n[ERROR] *  inner-classes-complaint-injection/pom.xml\n[ERROR] *  missing-at-inject-constructor/pom.xml\n[ERROR] *  multiple-provides-methods/pom.xml\n[ERROR] *  provides-method-with-throws-clause/pom.xml\n[ERROR] *  simple-missing-dependency-failure/pom.xml\n[INFO] -------------------------------------------------\n```\n(Ignore the 'aaaprivate-field-inject' test, of course)\n. Very easily confirmed by the lack of anything in examples/simple/target/generated-sources/annotations/. Quickly adding the compiler as a provided dependency produces the generated code.\n. Seems lame to fail builds because we cannot anticipate every permutation of implementation...\n. Refs #139.\n. If someone wants to pull in the latest master and run the deploy_website.sh script that'd be swell. Not about to attempt that over a cell network...\n. The build.log is boring... it just compiles normally.\n```\n$ cat /Users/jw/dev/square/dagger/compiler/target/it/module-type-validation/build.log | \\grep -v Download\n[INFO] Scanning for projects...\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building module-type-validation HEAD-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-resources-plugin:2.5:resources (default-resources) @ module-type-validation ---\n[debug] execute contextualize\n[WARNING] Using platform encoding (MacRoman actually) to copy filtered resources, i.e. build is platform dependent!\n[INFO] skip non existing resourceDirectory /Users/jw/dev/square/dagger/compiler/target/it/module-type-validation/src/main/resources\n[INFO]\n[INFO] --- maven-compiler-plugin:3.0:compile (default-compile) @ module-type-validation ---\n[INFO] Changes detected - recompiling the module!\n[WARNING] File encoding has not been set, using platform encoding MacRoman, i.e. build is platform dependent!\n[INFO] Compiling 1 source file to /Users/jw/dev/square/dagger/compiler/target/it/module-type-validation/target/classes\n[INFO]\n[INFO] --- maven-resources-plugin:2.5:testResources (default-testResources) @ module-type-validation ---\n[debug] execute contextualize\n[WARNING] Using platform encoding (MacRoman actually) to copy filtered resources, i.e. build is platform dependent!\n[INFO] skip non existing resourceDirectory /Users/jw/dev/square/dagger/compiler/target/it/module-type-validation/src/test/resources\n[INFO]\n[INFO] --- maven-compiler-plugin:3.0:testCompile (default-testCompile) @ module-type-validation ---\n[INFO] No sources to compile\n[INFO]\n[INFO] --- maven-surefire-plugin:2.10:test (default-test) @ module-type-validation ---\n[INFO] No tests to run.\n[INFO] Surefire report directory: /Users/jw/dev/square/dagger/compiler/target/it/module-type-validation/target/surefire-reports\n\nT E S T S\nResults :\nTests run: 0, Failures: 0, Errors: 0, Skipped: 0\n[INFO]\n[INFO] --- maven-jar-plugin:2.3.2:jar (default-jar) @ module-type-validation ---\n[INFO] Building jar: /Users/jw/dev/square/dagger/compiler/target/it/module-type-validation/target/module-type-validation-HEAD-SNAPSHOT.jar\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 6.431s\n[INFO] Finished at: Thu Mar 28 16:00:20 PDT 2013\n[INFO] Final Memory: 11M/81M\n[INFO] ------------------------------------------------------------------------\n``\n. Ah, good catch. Pull incoming...\n. Adding this to the 1.0 milestone. I'd love to see this land in the next two or three weeks!\n. That's not the direction we want to go for ProGuard safety, but it would work in the interim.\n. Using\"members/\" + Foo.class.getCanonicalName();so it would just be obfuscated to\"members/\" + A.class.getCanonicalName()`.\n. Distant. Nobody is currently working on this.\nAdditionally, this type of thing is not required with the current version 2 design.\n. > will version not have problems with proguard?\nNo. There will be zero reflection.\n\nAlso, if that is the case, will a PR for version 1.1.x be welcome?\n\nYes. We can make a v1.3 with something like this if it proves to be valuable without causing runtime penalty.\n. It is 100% backwards incompatible. You can learn more at #366.\n. See Dagger 2.\n. Amazing.\n. What about prefixing generated class with a dollar sign? This would also help mitigate the problem where you search for a type in an IDE the results are littered with inject adapters due to alphabetic sorting.\n(e.g. $Foo$InjectAdapter)\n. And I also think this is an IDE bug: http://youtrack.jetbrains.com/issue/IDEA-106532\n. https://github.com/square/dagger/pull/224\nI'll do a brief once-over of the generated API for any obvious candidates. You two can do a deeper inspection when you get a chance.\n. This is compile-time verification of #210 only. This also only handles the \"dumb\" case of having the provider or lazy type explicitly as your return type. If you have a type which extends from either of these two then you're 100% on your own and I think that's a fine assumption to make.\nThis does not include reflective verification in core. If this gets a thumbs up then I can look into adding that as well.\n. Updated. Also added reflection backend check and test.\n. Updated both compiler tests and reflection check/test for raw types.\n. This was fixed on master but never deployed. I'll do that now.\n. Done.\n. I also just pushed the latest master SNAPSHOT to central's snapshot repo.\n. So the output graph doesn't correctly reflect the SET binding?\n. All I could find was one tiny lack of using a helper method. Otherwise, :shipit:!\n. I'm going to merge in anticipation of agreement from @cgruber since no further discussions were made on the referenced issue.\n. Thanks for the heads up. I should have caught these.\nhttps://github.com/square/dagger/pull/229\n. If you need to instantiate a third-party object you should do so through a @Provides method.\ne.g.,\njava\n@Module(injects = { HomeActivity.class })\npublic class BusModule {\n  @Provides /*@Singleton??*/ Bus provideBus() {\n    return new Bus(42);\n  }\n}\n. LGTM. Waiting on Travis CI.\n. Thanks! \n. Awesome. We'll bump the dep once it syncs to central and release a dot version of Dagger (hopefully with a few other improvements as well) soon. I should hope this doesn't affect too many people for now.\n. If you had a 13\" MacBook there would be two millimeters!\n. Ah, I fixed this in the activity graph example but not the simple one. I'll fix later today when I get back to a computer.\nKeep in mind (as stated in the README.md for each Android example) the projects aren't really meant to be run on a device, but rather serve as an overview of how you structure Dagger within an Android app.\n. \"later today\" has a tendency to vary in the scope of the Maven android plugin :) Hopefully they do push out an update.\n. Couldn't you just make Authenticator implement Comparable and then have a rank internally? Then you just Collections.sort and go.\nI can't see a situation where I'm comfortable providing any kind of order guarantee out of Dagger when you're using a Set. Plus your implementation doesn't seem to solve what @adriancole wants in that the ordering of modules passed to create() dictates the order.\n. I still don't think any of this should be Dagger's responsibility. I don't want to harp on my opinion over and over if you're all dead-set on implementing this so I'll just give it one more go:\nI love how dumb Dagger is. All of the logic is based solely around the graph of objects (i.e., how overrides, library/complete, singletons, etc. are treated). I'd argue that set bindings fall into this category of dumbness.\nThis is too much smarts for me because I don't see where it ends. There will inevitably be a case where the semantics of an integer-based ranking system isn't enough and someone will want more. We are now moving beyond the responsibility of \"movement of objects from where they are to where they need to be\" into \"movement of objects from where they are, where they need to be, and how they will be consumed\".\n\nThe order of countries in Dagger will ultimately be the order of the countries in the app's UI.\n\nThings like this just seem like scope creep and a disaster waiting to happen. My dependency injector is now directly controlling the behavior of code that consumes my dependencies rather than just being a delivery mechanism of said dependencies.\n. There's a discussion about this on #177 already. Probably good to track as its own issue.\n. My initial thoughts:\n``` java\nObjectGraphCreator using(String... plugins) { /.../ }\nObjectGraph.create(..); // compile + runtime\nObjectGraph.using(\"runtime\").create(..);\nObjectGraph.using(\"compile\").create(..);\nObjectGraph.using(\"compile\", \"runtime\")).create(..);\n```\nA somewhat related API could also theoretically allow reg/unreg of plugins too:\njava\nObjectGraph.removePlugin(\"runtime\");\nObjectGraph.addPlugin(\"magic\", new MagicPlugin());\n. It was just a quick stab at a separation between the plugin registry and consumption of plugins in graph creation.\nI view it like this: 99% of people probably are not going to want or need this functionality. Of those 1% that do need it, 99% probably just want to disable the reflection-based plugin to guarantee performance in production (read: Android users).\nAs such I think that the API should cater to the 0.99% rather than the 0.01% in allowing you to choose the plugins you want easily without knowledge of where they come from. To the person that needs to create and install new plugins, they may face an uglier API but still a powerful one.\nPerhaps allow interleaving types at the expense of static type safety?\njava\nObjectGraph.using(\"compile\").create(..);\nObjectGraph.using(\"compile\", new MagicPlugin()).create(..);\n. I think @pyricau also had some ideas around this.\n. This happened and is being used in v1 and v2, among others.\n. I'm working on adding a CLA check to our Travis builds. No ETA, but then it will always be obvious to us and the contributor. Nothing like a failed build if you haven't signed the agreement.\n. @tbroyer Inspired by the former but not built on the latter. Was going to do it as part of the Travis CI build script to hit a remote service for all authors and committers on the commits. I'm not sure how GitHub will handle two services attempting to set the status of a pull request which is why I was going along this route.\n. I'm going to try to today. Friday got away from me.\n\nJake Wharton\nhttp://about.me/jakewharton\nOn Mon, Aug 5, 2013 at 8:05 AM, Adrian Cole notifications@github.comwrote:\n\nany chance we can get dagger 1.1 released? I'm starting to get support\nemail which could be avoided if I can switch to SET_VALUES..\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/261#issuecomment-22112175\n.\n. This is done on v2.\n. Part of this issue is the fact that the generated \"inject adapter\" contains a constructor reference to types even if that type is never instantiated through Dagger. That issue is covered by #286, and once fixed will allow constructors that throw to be used as entry points for members-only injection.\n. I'm fine with Loader as well. It's the name of something that's already in android but I don't think that's a big deal. If you're smart enough to use Dagger and smart enough to need to know about these Loaders then you're probably smart enough to make the distinction.\n. injects= is dead in v2 and there's recommendations above for workarounds for v1.\n. There are tags too! https://github.com/square/dagger/compare/dagger-parent-1.0.0...dagger-parent-1.0.1\n\nThere was no pre-1.0 change log because it wasn't a final release. Moving forward we'll update the change log though.\n. They're close enough. We should only need platform-tools and android-16.\n. Correct. I'm a bit sad that this will make the builds significantly longer but I also hate not having those samples being built.\n. Ugh, yeah. I'll update master to point to 2.0.0 so that the next release includes it. The problem is that we don't easily have a way to figure out exactly what version the latest release depends on since it's all done via javascript (and I don't think it's worth the effort). The next release will use 2.0.0 and presumably JavaWriter will change very little... and hopefully not too many people are using Ant!\n. I have an issue with this. Posting to the mailing list though.\n. It's fine. The Gradle updates are fast and frequent and there's even a hack\nto work around it for now. We shouldn't block it.\nOn Jun 17, 2013 11:13 AM, \"Christian Edward Gruber\" \nnotifications@github.com wrote:\n\nSo this is ready, but it sounds like android+gradle is not. However, we\nneed this inside google and there's some shuffling around going on. Can we\nresolve all of that on this pull request, and then, before I check this in,\nwill re-enable the reflective fallback for now, so that it's a\none-class-deletion, and a one-try/catch block fix in the google fork, which\nwill be easy to merge up when square/dagger wants it.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/pull/281#issuecomment-19563480\n.\n. Any @Nullable annotation? Or a Dagger-provided @Nullable?\nOn Aug 9, 2013 8:08 AM, \"Jesse Wilson\" notifications@github.com wrote:\nLet's avoid the word \"Optional Injection\" since that means something\ncompletely different in Guice.\nThe behavior change is to throw an unchecked exception instead of\ninjecting null, each time that would occur. Suppress the exception by\nmarking the injection point with @Nullable.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/288#issuecomment-22400518\n.\n. I am very strongly in favor of eagerly forbidding null.\n. Static injection was removed in #507 (and #509) for the next release.\n. > Note: this won't work in eclipse\n\nI don't think you'll bother anybody on this side :)\n. LGTM. Just a slight naming thing. I'm interested in testing the annotation processor change in IntelliJ which has historically been flaky in configuring but stable once configured.\n. Too exhausted to do a real review. Tomorrow.\n. @cgruber That would be a not-too-hard script to write! Grab all commits between two tags, look for merge commits, look at what pull requests they reference.\n. Waiting for https://github.com/square/dagger/pull/299\n. Mostly LGTM! Always love protecting users from themselves.\n. Needs a reabse.\n. Once CI passes I think we can merge, smoke test, and release the next minor version.\n. In agreement, I am.\n. Thanks.\n. Tests look good. We'll need one for includes as well. \n. These are covered in v2 tests.\n. Really excited about this! Looking forward to seeing valid compilation uses as well.\n. Both are exactly the same functionally at runtime. Semantically and at compile-time there are subtle differences.\nUsing includes = ... allows Dagger's static analysis to know about much more of your object graph in order to verify and validate dependencies. If methods in TestModule require objects provided by DripCoffeeModule and includes is not used, TestModule will have to be marked complete=false.\n. This is usually a syntax error in the source that gets passed along. Using\nauto/common's superficial validator will eliminate these.\nOn Mon, Nov 2, 2015, 2:46 PM Andrew Grosner notifications@github.com\nwrote:\n\nI have done some research and strongly think its the combination of a java\nproject with annotation processing with an android project with annotation\nprocessing. I have filed an issue here:\nhttps://code.google.com/p/android/issues/detail?id=192476&can=4&colspec=ID%20Type%20Status%20Owner%20Summary%20Stars\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/320#issuecomment-153020821.\n. Woah. This should fail at runtime! Two things cannot provide the same type. Does it fail at compile time if you put addsTo=MainModule.class on ChildModule?\n\nThe .plus'd graph is a superset of the parent graph which does not allow overrides (which you aren't even actaully specifying).\n. I'll try to write a test case tonight. And maybe even seek out the root cause. Will report back.\n. Easy to reproduce. Wasn't able to find an obvious place that it should be failing, though. Checks for duplicate bindings is only covered by the full-graph analysis. I'll have to defer to @cgruber for more insight into what should be done here. Dagger's internals have changed a bit since I last dug in.\n. @cgruber any chance you'd be able to look into this soon? If not, I can try to squeeze it in one of these nights or weekends.\n. These are no longer accurate. Send a new pull with up-to-date information if you want to pursue.\n. Can't LGTM because I'm reviewing on a phone and only got through half. Time for The Walking Dead, I'll try to circle back later tonight.\n. Needs rebase.\n. Took me a while, but LGTM!\n. I like the union approach as well. It seems in parity with how the overall graph merging works.\n. overrides=true has always been graph-local. You can't override something from a parent graph. The way that I would think about it is, you can override a set binding in the same graph level (not sure the term here), the result of which is what is union'd to the parent graph's set, if present.\n. Dupe #322.\n. When building from an IDE you need to enable annotation processing. Instructions for IntelliJ can be found here for a similar library.\n. LGTM\n. Heh. Don't ever change, Maven.\nThanks, @mosabua \n. LGTM, though!\n. Two things. LGTM.\n. Yeah I don't care about the Android sample enough to force this. Most\npeople won't have upgraded to 3.1 or newer since it breaks so many plugins.\nI'd rather just disable or move the Android stuff into it's own repo.\nI have a proper Dagger Android sample going open source this week as well.\nAnd it's not tied to the horror of Maven!\nOn Nov 11, 2013 5:55 AM, \"Christian Edward Gruber\" notifications@github.com\nwrote:\n\nUgh. Yeah - that's going to be problematic for us. It would force an\norg-wide upgrade inside Google for anyone using Maven and, while it's not a\nhigh percentage of projects (we have our own build system), it's going to\nsuck way too much of my time. :( Let me think this through tomorrow, and\nsee if there isn't a profile-related way to solve this.\nWorst case, we can simply ignore it since internally we are using the\ngoogle fork, so maybe it isn't that big a deal after all - but still, the\nfewer deviations between the forks that are unnecessary, the better.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/pull/337#issuecomment-28174051\n.\n. Paste the whole stack trace. Or at least the part that runs through Dagger.\nOn Nov 10, 2013 6:41 AM, \"markjvickers\" notifications@github.com wrote:\nIn dagger 1.1.0\nUsing module multibind with an object that accepts a generic type,\nconfigured with a wildcard, causes NullPointerException.\npublic SomeClass {}\npublic class X {\n@inject https://github.com/inject\nSet> set;\n}\n@Module https://github.com/Module {\ninjects = { X.class }\n}\npublic MyModule {\n@Provides https://github.com/Provides(type = Type.SET)\npublic SomeClass<?> myProvider() {\nreturn new SomeClass();\n}\nI think this is the relevant portion of the stack trace:\n11-10 01:27:35.014: E/AndroidRuntime(17039):\njava.lang.NullPointerException at\nandroid.app.ActivityThread.handleBindApplication(ActivityThread.java:4599)\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/339\n.\n. Dupe #118.\n. Usually an hour before it's in repo1, four before their Solr instance picks\nit up on search.maven.org. Thanks!\nOn Nov 13, 2013 9:56 PM, \"Gregory Kick\" notifications@github.com wrote:\nReleased to oss.sonatype.org. It'll propagate\u2026 sometime.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/pull/340#issuecomment-28432974\n.\n. Kicking Travis, but I just realized this needs a rebase to actually pass.\n. LGTM. I have stable internet now. Should this be the cutoff for 1.2?\n. I haven't! Internet keeps slowing to handfuls of bits per second. Reviewing now though it looks mostly the same as your previous pull.\n. Tonight! Pinky promise.\n\n\nJake Wharton\nhttp://about.me/jakewharton\nOn Wed, Nov 20, 2013 at 6:41 PM, Christian Edward Gruber \nnotifications@github.com wrote:\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/355\n.\n. This week.\nOn Nov 27, 2013 1:21 PM, \"Alexey\" notifications@github.com wrote:\nHello, are there any news about 1.2 release? It would be very nice to have\na fix for #322 https://github.com/square/dagger/issues/322\nThank you in advance\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/355#issuecomment-29421106\n.\n. Shipped!\n. Yeah, sorry for the delay on my end. Chaos ensued and this release should\nhave happened two+ weeks ago.\nOn Dec 13, 2013 4:31 PM, \"Christian Edward Gruber\" notifications@github.com\nwrote:\nDammit... just as I had a breaking API change I wanted to make (to get a\nperformance win on the server). :/\nAh well - it can live in our fork for now, and we can do a 1.3 when people\nfeel it's appropriate to require people to generate code again.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/355#issuecomment-30554752\n.\n. They might have upgraded their Maven version which causes problems with the current version of the android plugin. Investigating.\n. Merged locally and pushed.\n. Yes, sadly. Maven is such a terrible mess. Is that a problem for your side? We can purge the Android examples into another repo or something as a temporary workaround. They're more trouble than they're worth at the moment.\n. LGTM. Just waiting on Travis CI.\n. No, but I'm back in the US with speedy, stable internet and rearing to release. Lets get this, the JavaWriter bump, and fixing the Travis CI build in and I'll make the release.\n. Merged locally and pushed.\n. There's no urgency to release on our side. As long as it's fixed in a reasonable timeframe I'm fine waiting.\n. This is especially useful now that we have three dependencies in the compiler.\n. Ping @cgruber @swankjesse \n. fat JAR\n. Show your dependencies closure from your build file.\nOn Nov 27, 2013 1:58 PM, \"Wade Reweti\" notifications@github.com wrote:\nHi\nI'm getting the following\njava.lang.NoClassDefFoundError: dagger.ObjectGraph when my app launches\nI'm just trying to get dagger implemented into my app. Ive disabled\nproguard as I thought this was at fault. I'm using gradle as the build\nsystem, but can't seem to get around this issue, any help would be great.\nThanks\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/362\n.\n. You can see some Gradle solutions in #325. Placing both artifacts in the compile scope should absolutely work. Are you sure something else like ProGuard isn't affecting the classes? Also, are you doing a clean build from the command line or just in the IDE. The IDE isn't going to pick up the dependencies unless you refresh its model (in the Gradle pane) and even sometimes then it may not include them. You'll want to go to \"Build\" > \"Rebuild Project\" to do a clean build after click the aforementioned \"Refresh\" button.\n. Cool. I was waiting on Travis but since it failed, LGTM. Merge when ready.\n. It's a lot to take in but exciting indeed! I'll have to pass through the\ndoc more carefully soon.\n\n\nJake Wharton\nhttp://about.me/jakewharton\nOn Tue, Dec 10, 2013 at 1:54 PM, Christian Edward Gruber \nnotifications@github.com wrote:\n\nI'm excited.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/366#issuecomment-30271953\n.\n. You'll have to use a @Component interface for creating types.\n\njava\n@Component(module = FooModule.class)\ninterface FooComponent {\n  Foo getFoo();\n}\nDagger will generate an implementation of this interface to which you can pass a module.\njava\nFooComponent fooComponent = new DaggerComponent_FooComponent(new FooModule());\nFoo foo = fooComponent.getFoo();\nWhile it seems like a lot to write for just one type, in practice you won't use it for a single type so the overhead of the code in relation to what you use it for won't be as drastic.\n. This happened.\n. Try with 1.2.0.\n. Ping @pforhan. Does this persist with 1.2.0?\n. Worth noting that I see this as well with 1.2.0 but you can revert to 1.0.1 and drop the compiler and everything works fine using the reflective runtime.\n. I'm getting an error from this. Seems like a non-deterministic test.\ncyclicDepsWithProvidesMethods(dagger.tests.integration.validation.CyclicDependencyTest)  Time elapsed: 0.092 sec  <<< FAILURE!\njava.lang.AssertionError: Expected an error containing \"0. CyclicDeps$A bound by Provides\", but only found [\"Unknown error java.lang.IllegalStateException thrown by javac in graph validation: Dependency cycle:\n      0. CyclicDeps$C bound by ProvidesBinding[key=CyclicDeps$C method=CyclicDeps.CyclicModule.c()\n      1. CyclicDeps$B bound by ProvidesBinding[key=CyclicDeps$B method=CyclicDeps.CyclicModule.b()\n      2. CyclicDeps$A bound by ProvidesBinding[key=CyclicDeps$A method=CyclicDeps.CyclicModule.a()\n      3. CyclicDeps$D bound by ProvidesBinding[key=CyclicDeps$D method=CyclicDeps.CyclicModule.d()\n      0. CyclicDeps$C\"]\n    at org.truth0.Truth$1.fail(Truth.java:57)\n    at com.google.testing.compile.JavaSourcesSubject$UnsuccessfulCompilationBuilder.withErrorContaining(JavaSourcesSubject.java:140)\n    at dagger.tests.integration.validation.CyclicDependencyTest.cyclicDepsWithProvidesMethods(CyclicDependencyTest.java:79)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n    at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:252)\n    at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:141)\n    at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:112)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:483)\n    at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:189)\n    at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:165)\n    at org.apache.maven.surefire.booter.ProviderFactory.invokeProvider(ProviderFactory.java:85)\n    at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:115)\n    at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:75)\n. I'm not too worried about urgency and might even investigate tonight.\nTravis CI passed which means it works at least somewhere. And while it's\nrarely a problem, I am technically on an unreleased version of the JVM that\nmight have bugs (Java 8 EA).\nOn Jan 10, 2014 7:27 PM, \"Christian Edward Gruber\" notifications@github.com\nwrote:\n\nHmm. I can investigate tonight or tomorrow. I can roll this back if\nnecessary.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/pull/373#issuecomment-32085283\n.\n. Works on 1.7.0_21-b12 and fails on 1.8.0-ea-b116.\n. I'm not super-excited about having two build systems for the same content. Additionally because Travis CI isn't testing both.\n. Yeah I'm not sure. Maybe we just cut over to only Gradle for the Android stuff. Let me think on it a bit.\n. Don't want two build systems, as previously mentioned.\n. This is the intended behavior. Singletons are local to the graph in which they are instantiated. As you correctly deduced, when you throw away a .plus()'d graph and then later create a new one the single instance for the new graph needs to be created.\n\nWe can improve the documentation on this at we had talked about solving it using explicit \"scope\" annotations.\n. Scope annotations are in Dagger 2.\n. The exception comes from ObjectGraph#makeGraph here:\njava\ntry {\n  BindingsGroup addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;\n  moduleAdapter.getBindings(addTo, loadedModule.getValue());\n} catch (IllegalArgumentException e) {\n  throw new IllegalArgumentException(moduleAdapter.moduleClass.getSimpleName()\n      + \" is an overriding module and cannot contribute set bindings.\");\n}\nI'm finding it hard to find a way to effectively message what the problem is from inside of the methods getBindings delegates to.\n. We decided that future versions of the compiler will be using Guava extensively. The fact that nothing using it right now is simply due to ongoing changes.\n. That's exactly what we do. You can also write a Factory for LayoutInflater and pass the ObjectGraph as an argument.\n. Both work equally fine. It's a matter of preference, I guess. Downside of the latter is that layout preview breaks.\n. Makes sense for 1.x. We can make a dot release for this.\nHappy to argue that 2.x should be Java 6-only in great length and detail :)\n. Thanks!\n. Do you want me to prepare a dot release for this?\n. I will do it this weekend or Monday at the latest. Is there anything else you wanted to sneak in?\n. 1.2.1 released.\n. Hmmm.. I wouldn't think Dalvik would throw here unless you actually try and access the Method object for the field where the type isn't present. Since that class was added in API 16, I assume you are seeing this on API 14 or 15?\n. > It would be awesome if Dagger would continue when trying to inject a class without an @Inject annotation.\nIf the type is listed in a module's injects this should work. It does for me, as far as I can tell.\n. Whoops. Bad habit of reply+close :)\n. Collections types might be an issue here. Generic types with a generic type parameter present are allowed?\n. That works for me. Maybe the compiler emits a warning for other unqualified java.*.\n. This didn't happen, probably won't ever happen. It's bold, but there's too many edge cases to avoid surprises.\n. No real action to take here. We try to minimize generated code as much as possible.\n. It doesn't matter. It certainly can be public if classes were moved around. For the purposes of that demo it didn't need to be since both the base activity and application live in the same package.\n. The Java files are not included in the dex. And like @tbroyer said, we don't and can't control where these files go.\n. This is a very general issue with not a lot of clear action to take.\nDagger 2 enforces scope so it's always explicit in which graph a dependency lives. You can always be explicit currently by listing it in the injects= list.\nWe're not going to make any recommendations on actual style. Just because you don't put @Inject on constructors doesn't mean that others shouldn't. This is something that should be enforced in a local style guide, if needed. Again, this is something that's better in v2.\nWe also can't really recommend when to use field injection and when not to. You can very well use all of constructor, field, and method injection in a single class. You'll definitely see method injection used with constructor and field to hand out 'this' references to dependencies. If you want to enforce this with a local style guide you can do so.\n. You're missing the custom application class declaration in the AndroidManifest.xml file: https://github.com/square/dagger/blob/master/examples/android-simple/AndroidManifest.xml#L12\n. Hi Jamie, welcome to the wonderful world of Dagger! Can you do us a favor and move this question to StackOverflow with the 'dagger' tag? That way it can be answered by the community and live on in a more searchable form (to hopefully help others).\nThanks!\n. Dagger can inject any object, it's just a matter of getting a reference to your ObjectGraph instance to perform injection.\nIf you are storing the graph on the application instance you can do something like this: https://github.com/square/dagger/blob/1d46e2fbd7f51bef77fcc0413ed37e3a88acf146/examples/android-simple/src/main/java/com/example/dagger/simple/DemoBaseActivity.java#L26\nIn the future, please ask general questions on StackOverflow using the 'dagger' tag. This way there's much more visibility and searchability on the question.\n. You can inject an interface but nothing was providing its type. The error message looks correct.\n. (Granted, most of Dagger's errors could use more human terms)\n. We see this internally on scary classes that you'd never want Dagger to\ninstantiate (e.g., android.app.Application). While we know it will never be\ncalled in practice, it's a bit unsettling to see an invocation of its\nconstructor in the generated code.\nOn May 12, 2014 5:49 PM, \"Christian Edward Gruber\" notifications@github.com\nwrote:\n\nYeah - so that code seems like it should work. Why it would be trying to\nimplicitly-bind something that has a provides method is very odd. I'll try\nto play with the example project.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/410#issuecomment-42906130\n.\n. To Dagger it's the same thing. In our impl we pass the Application instance\nto the constructor of the module, store it in an instance field, and return\nit in the provides. It's not bad because it's never invoked, it's just not\nsomething I'd like to see in the generated code.\nOn May 12, 2014 5:57 PM, \"Christian Edward Gruber\" notifications@github.com\nwrote:\nIt's not though, @JakeWharton https://github.com/JakeWharton. It seems\nlike he's calling the constructor explicitly in an @Provides method. No?\nOr am I missing something obvious?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/410#issuecomment-42906564\n.\n. You shouldn't use the compile scope for the compiler. Use either the built-in provided scope for the 'dagger-compiler' or the android-apt plugin and the apt scope.\n\nSee here for an example.\n. Also worth noting this doesn't happen with Gradle or Ant because it splits\nthe processorpath and classpath to javac so severely. And for Java-based\nMaven projects it makes no difference since you're using Guava anyway.\nOn Jun 23, 2014 6:36 PM, \"Christian Edward Gruber\" notifications@github.com\nwrote:\n\nIt is not optional in the compiler, it is required in the compiler, and\nwell-used there. The compiler is an annotation-processor which runs inside\nthe javac. Unless you're going to run the javac process on android, then it\nshould be a non-issue.\nIf your issue is that IDEs do not honour maven dependency scoping, than\nthat is a problem, but one that is not ours to fix. I highly recommend\ndevelopers at least build from the command-line once before committing\nchanges, to ensure they are not letting dependencies creep in.\nAs to provided vs. optional, I agree, but it was changed because its\nbehavior in terms of how maven determines what directories it creates for\nfile-generation. Provided dependency scope (in maven) seems to create\ntarget/generated-sources/annotations, whereas optional=true seems to\n(often) result in .java files ending up in the /classes folder. I don't\nknow why - i'ts really flaky maven behavior.\nBut you can feel free to use whichever inclusion style you find\nworthwhile.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/411#issuecomment-46923014.\n. You can also put the dependency on the compiler plugin directly.\n. Yeah. This guy: http://jira.codehaus.org/browse/MCOMPILER-202\n. From what a quick grep has shown, we don't explicitly use the implicit type provider as far as I can tell. I know that we've always educated that a @Provides or @Inject-annotated constructor was required for downstream injection. If we do have any lingering uses, they are accidental.\n\nI'm fine with this behavior change. It makes the behavior match what I have been telling people the behavior already was. And I would hope the use of this behavior is slim (to none) anyways.\n. Is this really an anti-pattern? Can you provide insight into usages of\nfield injection and downstream constructor injection (using the no-arg\nconstructor) in your code?\nOn May 29, 2014 9:01 PM, \"Jesse Wilson\" notifications@github.com wrote:\n\nI don't feel too strongly. The constructor feels a little boilerplatey;\nand it provides a small amount of additional safety.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/412#issuecomment-44613085.\n. What you are describing is set binding.\n\njava\n@Provides(type=SET) Fruit provideApple() {\n  return new Apple();\n}\n@Provides(type=SET) Fruit provideApricot() {\n  return new Apricot();\n}\n@Provides(type=SET) Fruit provideCherry() {\n  return new Cherry();\n}\njava\n@Inject Set<Fruit> fruits;\n. I reported this a while ago here: https://github.com/square/dagger/pull/373#issuecomment-32085205\nStill fails for me.\n. I agree. All efforts should be toward 2.0.\n. And thanks!\n. This looks like a JavaWriter bug and it might already be fixed it's just that Dagger hasn't updated in a long time.\n. Yep. Add an explicit dependency on JavaWriter 2.5.0 in the same place you declare your dagger-compiler dependency and this should be fixed.\n. I pushed version 1.2.2 to Maven central with this bumped dependency. Expect to see it in a few hours.\n. This was fixed and released.\n. > I know that ButterKnife has an @Optional annotation for such \"dependencies\", now is there something similar for Dagger as well?\nButter Knife does lookups not injection. With different layout configurations there's a very real possibility some views are present only in certain situations and completely absent in others. It refers to these view lookups as \"injection\" purely as a joke for RoboGuice converts.\n. Dupe #420. See its comments for a workaround. I'll make a dot release with a bumped JavaWriter.\n. Pushed a 1.2.2 to Maven central. Expect to see it in a few hours.\n. I saw this locally and just added Java 8 to .travis.yml to verify (and for future changes).\n. The two annotation-related features that were added were annotations on types and support for repeating annotations.\n. The test is failing because of the absence of a failing compile. The test wants the build to fail but it erroneously succeeds.\n. If you aren't using constructor injection can't you just do this yourself?\n. > There is a good reason why almost all the important Android classes are designed such that you can't construct them directly\nThe \"good reason\" is that they eschew any ounce of proper API design for eliminating every shred of overhead. Even that is a mostly a function of legacy nowadays.\n. ~~Android already simulates the provided scope for you. You're better off using the apt plugin though: https://bitbucket.org/hvisser/android-apt~~ Yeah what @f2prateek said.\n. I think this is handled better in v2 with SuperficialValidator.\n. Yeah there's a few tiny fixes to the 1.x stuff I'd like to make. Made a\npass over the issues last weekend.\nOn Aug 1, 2014 9:29 AM, \"Christian Edward Gruber\" notifications@github.com\nwrote:\n\nYeah 2.0 and all that, but this might help people debug, so it is probably\nworth rolling a 1.2.x at some point.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/pull/428#issuecomment-50905288.\n. I added JDK 8 recently. See https://github.com/square/dagger/issues/425.\n. Yep. And the build passed on Oracle JDK 7 and OpenJDK 7\n. The error should be on resourceFactory as in Dagger's eyes it's unused.\n\nYou can change your @Module declaration to fix:\njava\n@Module(injects = ResourceFactory.class)\n. Yeah keep it open. We'll try and figure it out. Can you paste the output from mvn -v?\n. The compiler is limited by the bounds of the apt's round environment and in that environment we have no way of getting this information accurately.\n. No, failing test. We should probably switch to the Android worker instead of having to install this stuff every time.\n. Don't know, but it doesn't matter. The 'android' worker has Java installed.\n. :open_mouth:\n. Define \"doesn't work\".\nOn Sep 19, 2014 2:53 AM, \"Kamol Mavlonov\" notifications@github.com wrote:\n\nI noticed a new version (1.2.2) of dagger released, however, following\ncode doesn't work:\ncompile 'com.squareup.dagger:dagger:1.2.2'\nprovided 'com.squareup.dagger:dagger-compiler:1.2.2'\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/440.\n. Do you have mavenCentral() declared in a repositories section?\n\nOn Fri, Sep 19, 2014 at 11:22 AM, Kamol Mavlonov notifications@github.com\nwrote:\n\n@JakeWharton https://github.com/JakeWharton I am in AS and Gradle\ncannot find that 1.2.2 version.\nHere the error AS Messages:\nError:Failed to find: com.squareup.dagger:dagger-compiler:1.2.2\nHowever, with version 1.2.1 it works\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/440#issuecomment-56191739.\n. The integration tests do not work on JDK 8.\n. Yes this is solved in v2. Still would be nice to fix it in v1, though.\n. Because you can introduce object instances into the graph which are not owned by you by ways of constructing the modules yourself and passing them in. For example, on Android we pass in things like the Application instance and Activity instances.\n. The Application and Activity instances are created by the framework in which your application is running, not by you.\n\n``` java\npublic void AppModule {\n  private final Application app;\npublic AppModule(Application app) {\n    this.app = app;\n  }\n@Provides @Singleton Application provideApplication() {\n    return app;\n  }\n}\n```\n. The Application class is not in the graph. That's my point.\nOn Oct 9, 2014 6:34 PM, \"Cyker Way\" notifications@github.com wrote:\n\nIn this case we have AppModule and we can call plus(AppModule.class). It\ndoesn't matter even if plus doesn't accept non-class types.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/445#issuecomment-58602281.\n. I just gave you an example of why that wouldn't work.\nOn Oct 9, 2014 6:41 PM, \"Cyker Way\" notifications@github.com wrote:\nI don't care much about whether it's Application or something else. I'm\nsimply wondering what we will lose if we change the prototype from public\nObjectGraph plus(Object... modules) to public ObjectGraph plus(Class...\nmodules). A use case on this could be helpful.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/445#issuecomment-58602668.\n. Class references to modules are still available to use in the API via\nincludes= on the @Module annotation so that functionality will always exist.\nOn Oct 9, 2014 7:19 PM, \"Cyker Way\" notifications@github.com wrote:\nSo this actually means passing in module objects is a more direct\napproach? The code I wrote in the first post shows no matter we pass in\nmodule instance or module class we have to get the other. Since getClass()\nwill always work, but adapter.newModule() only works with no-arg\nconstructors, probably I should flip my argument as passing in module\ninstance will always work correctly while passing in module class will\nsometimes lose generality?\nThen I think the doc should mention that plus is expecting module\ninstances, since dagger will construct an instance even if we pass in\nmodule class. Mixing types and the ways of passing parameters can be\nconfusing in this case.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/445#issuecomment-58604789.\n. You can't, as far as I remember. If you were designing that module to be\ncomposable you would take Application as a method argument and let someone\nelse figure how to get it in the graph. At some level, though, someone is\ngoing to have to take it as a constructor argument.\nOn Oct 9, 2014 7:31 PM, \"Cyker Way\" notifications@github.com wrote:\nSo the modules being put in includes must have no-arg constructors? For\nexample, the AppModule you gave above cannot be put in includes. If this\nis true, then how do we include this module in another module?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/445#issuecomment-58605445.\n. You're better off submitting this to https://github.com/google/dagger as development on version 1.x is unlikely to resume. Also we need to fix the problem of JDK 8 failing, not just remove it from our builds.\n. You can pass the ObjectGraph itself around as it is the thing through which you perform injection.\n. You haven't configured the 'dagger-compiler' annotation processor to run in your IDE or build system. This type of problem is much better suited to StackOverflow. Please include the 'dagger' tag when you ask.\n. Dagger requires that the annotation processor in the 'dagger-compiler'\nmodule was run during your build. I would strongly suggest using the\npublished jars for both the 'dagger' and 'dagger-compiler' artifacts.\nOn Nov 11, 2014 2:59 AM, \"Xuzhiwei\" notifications@github.com wrote:\nI copy the source code to my java project.I use eclipse.I not found the\nannotation processor.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/449#issuecomment-62490215.\n. The names must be known statically (in the annotation processor running in the compiler) so there's no way of making it dynamic in this fashion. The only way to eliminate the code duplication would be to generate these provider methods with your own tool or annotation processor.\n. No. Dagger cannot infer your intention here. You must be explicit.\n\nIf this were not the case the amount of bindings that would have to be generated would be a combinatorial explosion since it would have to be done for every super class and every interface on each of those classes.\n. Plus does not mutate the graph. It returns a new object which is a combination of the original and the new module(s).\n. The last one wins. This is a bug documented at #275.\nHere's a quick (and unfortunate) demo:\n``` diff\ndiff --git a/examples/simple/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java\nindex b6be33a..b305d77 100644\n--- a/examples/simple/src/main/java/coffee/CoffeeApp.java\n+++ b/examples/simple/src/main/java/coffee/CoffeeApp.java\n@@ -13,6 +13,10 @@ public class CoffeeApp implements Runnable {\npublic static void main(String[] args) {\n     ObjectGraph objectGraph = ObjectGraph.create(new DripCoffeeModule());\n+    objectGraph = objectGraph.plus(new OtherModule(\"One\"));\n+    objectGraph = objectGraph.plus(new OtherModule(\"Two\"));\n+    objectGraph = objectGraph.plus(new OtherModule(\"Three\"));\n+    System.out.println(objectGraph.get(String.class));\n     CoffeeApp coffeeApp = objectGraph.get(CoffeeApp.class);\n     coffeeApp.run();\n   }\ndiff --git a/examples/simple/src/main/java/coffee/OtherModule.java b/examples/simple/src/main/java/coffee/OtherModule.java\nnew file mode 100644\nindex 0000000..c80ba9e\n--- /dev/null\n+++ b/examples/simple/src/main/java/coffee/OtherModule.java\n@@ -0,0 +1,18 @@\n+package coffee;\n+\n+import dagger.Module;\n+import dagger.Provides;\n+import javax.inject.Singleton;\n+\n+@Module(injects = String.class, library = true)\n+public final class OtherModule {\n+  private final String string;\n+\n+  public OtherModule(String string) {\n+    this.string = string;\n+  }\n+\n+  @Provides @Singleton String provideString() {\n+    return string;\n+  }\n+}\n```\nThree\n~ ~ ~ heating ~ ~ ~\n=> => pumping => =>\n [_]P coffee! [_]P\n. This is not the repository for Dagger 2. You want\nhttps://github.com/google/dagger\nOn Mon, Oct 12, 2015 at 11:28 PM Mike Nakhimovich notifications@github.com\nwrote:\n\nCame here from SO question, I'm using Dagger 2 with AutoFactory and seeing\nsame behavior, only works with fully qualified names.\n@Provides\nABManager provideABManagerImpl(com.nytimes.android.ab.ABManagerImplFactory factory ) {\n    return factory.create(3, IMMEDIATELY);\n}\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/456#issuecomment-147584754.\n. This is a dupe of #396. I'll say that this is highly unlikely to happen with Dagger 1.\n. :+1: \n. blinks\n. This is not an issue for GitHub. Please try the mailing list or StackOverflow for general questions.\n. This should be posted to StackOverflow or the mailing list. GitHub issues are not the right place for discussions on how to apply the library.\n. Awesome!\n\nAnd I'll figure out Travis later tonight...\n. Sent a PR to fix the CI build: #481. Then we'll see about getting this merged.\n. Can you squash and rebase this on the latest master so we can see CI go green?\n. Thanks!\n. When you call inject(this), even in the base class, the type of this is the subclass. Therefore MyFragment needs registered in an injects= list.\n. So it is! I completely forgot Jesse made that change.\n. Branch name. Nailed it.\nCan't figure it out on mobile, but felt compelled to make that comment.\n. This is https://github.com/square/dagger/issues/275 rearing its ugly head. DAM includes DUM when being plussed on a graph in which DUM was already added. We'll get this fixed soon(ish) for a v1.3 with some other obvious bugs.\n. Here's your fix/workaround:\n``` java\n  @Module(\n      addsTo = AuthenticatedModule.class, //\n      includes = DebugAuthenticatedModuleMultipleAddsToHack.class, //\n      overrides = true //\n  ) //\n  static class DebugAuthenticatedModule {\n  }\n@Module(addsTo = DebugUnauthenticatedModule.class)\n  static class DebugAuthenticatedModuleMultipleAddsToHack {\n  }\n```\n. Set bindings and map bindings are already implemented.\n. Oh wait this is Dagger 1. Set bindings exist, no map bindings.\n. It already does, yes.\n. There's no need to bake AOP into a DI library. Libraries like AspectJ are already very good at AOP and can be used in conjunction with Dagger 1 & 2.\nhttps://groups.google.com/d/msg/dagger-discuss/pSSejx7s5h8/HKzwuJh-ZJYJ\n. There's no guarantee the the T in Lazy<T> is Serializable. Plus, if you serialize and then deserialize an instance of Lazy<T> which never fetched the backing T, how is it supposed to fetch that value without being bound to the backing graph?\n. We need a lot more information as you've given almost none. Dagger doesn't\ncare what your application ID or package name is\u2014it knows nothing about\nAndroid. You need to provide a full stack trace, show your graph creation\nand module code, and/or create a sample that demonstrates the problem.\nOn Mon, Aug 17, 2015, 7:07 PM Soroush notifications@github.com wrote:\n\nI just created a new flavor in my gradle file with a new applicationId,\nbut my app crashes when I'm trying to inject a class. It throws this\nexception:\njava.lang.NoClassDefFoundError\nIt seems that it's still looking at the default applicationId and package\nname.\nPlease let me know if you need more information about this issue.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/493.\n. Ok. Without more info there's no action for us to take then.\n. You are missing the JavaWriter dependency that the compiler requires.\n\nOn Mon, Sep 7, 2015, 9:48 AM GeorgeGathura notifications@github.com wrote:\n\ni'm trying to use dagger. i downloaded both jars,included java poet &\njavax.inject but i'm still getting this error whenever gradle\nbuilds(Android studio)\nError:Bad service configuration file, or exception thrown while\nconstructing Processor object: javax.annotation.processing.Processor:\nProvider dagger.internal.codegen.ModuleAdapterProcessor could not be\ninstantiated: java.lang.NoClassDefFoundError:\ncom/squareup/javawriter/JavaWriter\nmy dependencies{\ncompile 'javax.inject:javax.inject:1'\ncompile 'com.squareup:javapoet:1.2.0'\nprovided files('libs/dagger-compiler-1.2.2.jar')\ncompile files('libs/dagger-1.2.2.jar')\n}\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/494.\n. #458 switched Dagger to JavaPoet.\n. Dagger 2 is here: https://github.com/google/dagger.\n. LGTM\n. Hmm master built successfully on Travis CI 24 days ago when the last PR was merged. Let me try locally.\n. @jhump it fails for me locally when using JDK 7 but not JDK 8 (which has other problems... #425)\n. Full exception is:\n\njava.lang.ClassCastException: com.sun.tools.javac.comp.Resolve$SymbolNotFoundError cannot be cast to com.sun.tools.javac.code.Symbol$ClassSymbol\n    at com.sun.tools.javac.comp.Attr$IdentAttributer.visitMemberSelect(Attr.java:313)\n    at com.sun.tools.javac.comp.Attr$IdentAttributer.visitMemberSelect(Attr.java:302)\n    at com.sun.tools.javac.tree.JCTree$JCFieldAccess.accept(JCTree.java:1683)\n    at com.sun.tools.javac.comp.Attr.attribIdent(Attr.java:298)\n    at com.sun.tools.javac.main.JavaCompiler.resolveIdent(JavaCompiler.java:672)\n    at com.sun.tools.javac.model.JavacElements.nameToSymbol(JavacElements.java:162)\n    at com.sun.tools.javac.model.JavacElements.getTypeElement(JavacElements.java:144)\n    at com.sun.tools.javac.model.JavacElements.getTypeElement(JavacElements.java:61)\n    at dagger.internal.codegen.GraphAnalysisLoader.resolveType(GraphAnalysisLoader.java:90)\n    at dagger.internal.codegen.GraphAnalysisLoader.resolveType(GraphAnalysisLoader.java:91)\n    at dagger.internal.codegen.GraphAnalysisLoader.resolveType(GraphAnalysisLoader.java:72)\n    at dagger.internal.codegen.GraphAnalysisLoader.getAtInjectBinding(GraphAnalysisLoader.java:44)\n    at dagger.internal.Linker.createBinding(Linker.java:230)\n    at dagger.internal.Linker.linkRequested(Linker.java:142)\n    at dagger.internal.Linker.linkAll(Linker.java:109)\n    at dagger.internal.codegen.GraphAnalysisProcessor.processCompleteModule(GraphAnalysisProcessor.java:277)\n    at dagger.internal.codegen.GraphAnalysisProcessor.process(GraphAnalysisProcessor.java:124)\n. Might be a dupe of #444, except not reported as a bug in this case.\n. Generated code looks clean :+1:\n. Going to try a different approach\n. - .that(asList( --> that( varargs\n. Added missing newlines.\n. Annotation processing cannot modify existing classes. This cannot be done\nfor that reason alone, among others.\nOn Mon, Feb 15, 2016, 3:37 PM Vaclav Kosar notifications@github.com wrote:\n\nFor example in class A { @Inject private B b; } field b cannot be\ninjected because it is private field.\nCan you please consider to automatically generate constructor into class A\nupon compilation to avoid having to make b more accessible or writing\nconstructor manually?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/518.\n. Byte code rewriting is a very different thing than annotation processing,\nthough. And Dagger has no way of interacting with code at the bytecode\nlevel.\n\nOn Mon, Feb 15, 2016 at 5:13 PM Vaclav Kosar notifications@github.com\nwrote:\n\nWell AspectJ does code generation at compile time, so it can be done, no?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/518#issuecomment-184417028.\n. Dagger knows nothing about Android and thus nothing about the Android activity lifecycle. Injected types are not automatically freed.\n\nHowever, you interpreted that issue incorrectly. It is the presenter which is keeping a reference to the activity and preventing the activity from being garbage collected, not the other way around.\n. There is no leak. If the activity has outgoing references to dependencies and there are no incoming references to the activity it will be garbage collected.\n. No. Once garbage collected an object doesn't hold any references.\nOn Fri, Feb 19, 2016 at 2:07 PM Jemshit Iskenderov notifications@github.com\nwrote:\n\nOne last question, after Activity is destroyed and so its Presenter is\ngarbage collected, does Presenter still can hold references even it is\ngarbage collected?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/519#issuecomment-186363609.\n. Since this is a usage question and not a feature request or bug it's best suited for StackOverflow, and I see you've already asked it there: http://stackoverflow.com/q/35646368/132047 so I'll defer to it.\n. This is amazing!\n\nWe actually have an IntelliJ plugin which is supposed to provide this functionality as well: https://github.com/square/dagger-intellij-plugin. Sadly it's fallen a bit out of favor with regard to upkeep, but we have plans to revive it and restore it to its former glory.\n. The build is failing halfway through when it tries to upload. I'll look\nlater.\nOn Mon, Mar 21, 2016 at 8:39 AM Angus notifications@github.com wrote:\n\nIt looks like the dagger:1.3.0-SNAPSHOT is available on Sonatype, however\nthe dagger-compiler:1.3.0-SNAPSHOT is not available, as far as I can see.\nhttps://oss.sonatype.org/content/repositories/snapshots/com/squareup/dagger/dagger/\nhttps://oss.sonatype.org/content/repositories/snapshots/com/squareup/dagger/dagger-compiler/\napt 'com.squareup.dagger:dagger-compiler:1.3.0-SNAPSHOT'\ncompile 'com.squareup.dagger:dagger:1.3.0-SNAPSHOT'\nHave I missed something?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/523\n. Not sure why they're failing on second invocation, but we've already run them once and it's a waste to do so twice.\n. We don't have a wiki. Do you mean the website?\n. @zhanjixun No problem. \u6211\u7684\u4e2d\u56fd\u66f4\u7cdf\u7cd5\u7684\u662f (Google Translated)\n\n@Freedom000 ah, thanks. I'm sure there's a Chinese introduction on a website or blog somewhere, but I do not know of any.\n. I'll defer to the search then. We're certainly not going to be able to produce any better. Thanksm\n. Dagger 1's compiler does not shade Guava. You probably want https://github.com/google/dagger.\n. @swankjesse any thoughts?\nlgtm\n. I'll do a dot release tonight or tomorrow\n. This is saying that manually-written factory or lazy are alternatives to investigate to ultimately allow you to inject a T.\n. The issue is from data binding, not Dagger. The warnings are because you are not running the compiler in the library where the listed types are present.\n. Yes. You use annotationProcessor to declare the dagger-compiler artifact. More info @ http://tools.android.com/tech-docs/jackandjill\n. Dagger 2 has components and this repo is for Dagger 1. But to answer your question, yes you can (and probably should) use one component. Otherwise there's a lot of boilerplate involved in setting each one up and using it as an injector.\n. Move the condition inside the method and alter the return value based on it. Alternatively, you can apply different modules based on the API level. Both of these are vastly more powerful since you can actually use runtime state in your conditionals (something that is required for your non-working example).\n. I'm afraid this isn't a good forum for such a search. This project is on long-term support, not active development.\n. Dagger 2 is at https://github.com/google/dagger\nOn Sat, Jul 30, 2016, 1:12 AM ayuhe notifications@github.com wrote:\n\nDagger2, put in the lib module, in the lib DaggerXXXComponent can be\ngenerated.\nBut the specific project reference the lib \uff0cDaggerXXXComponent cannot be\ngenerated in the project, how to solve?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/square/dagger/issues/542, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAEEEWbhxBYxvo3OrSNF9xw4N0FXCe7dks5qavlIgaJpZM4JYv4z\n.\n. Dagger 1 does not have components. This is for Dagger 2 which should be filed at http://github.com/google/dagger instead.\n. You want google/dagger not square/dagger.. This class does not exist in Dagger 1. Perhaps you're looking for google/dagger and Dagger 2.. You need to specify your application subclass in the manifest on the <application> tag.. Just noticed that I think you want https://github.com/google/dagger/ and not this repo. Dagger 1 doesn't have HasActivityInjector.. You want Google/Dagger not square/dagger. This project is not accepting contributions anymore. Your build system usage should not affect your usage of the library, however.. Relative names also do not have to be prefixed with a dot which is often overlooked. This might be relevant to your interests.\n. Needs another indent\n. Inconsistent with others in file.\n. Inconsistent with others in file.\n. This and above Lazy inconsistent with others in file.\n. Same.\n. Same.\n. Two in here.\n. Last one (sorry)\n. I do this so that you can grab the .jar from the target/ folder and then upload it to the GitHub downloads page. This way the .jars that non-Maven users download from GitHub are prefixed with 'square' to provide more insight into their origins.\n. Ha. Was writing HTML this morning. Oops.\n. Updated. Added a README as well.\n. Funky indents. Not a blocker, we should reformat the entire file to two-spaces to match once this gets merged in.\n. These have their own pom which does not invoke checkstyle.\n. And I meant to add: I'm not sure it's terribly important to invoke them for these either.\n. Newline at the end but inside the brackets without a matching one at the start? Accidental addition?\n. Whoops! I did say such things. Fixed.\n. final. Also, add a newline after please.\n. Spaces around :\n. final.\n. Spaces around :.\n. Capitalize first word, period at end. (we're nit pickers!)\n. Capitalize first word, period at end.\n. Capitalize first word. Also, does this need to wrap? We either impose 100 or 120 char columns (I can't remember).\n. Period at end. Also see above comment about wrapping.\n. Thanks for updating. I will try to add some to the checkstyle rules although not all of them can be expressed as regular expressions.\n. Don't need else after a return.\n. Does this need to be in finally?\n. Use //-style comment. Change exception variable to be named ignored.\n. Use //-style comment. Change exception variable to be named ignored.\n. 2013? It's the future!\n. Bad indent.\n. I would definitely not do this using an unqualified type. We require an @Application qualifier when injecting Context internally to further re-iterate that you are not getting an activity context.\n. Same here.\n. Should probably use the plugin for this.\n. I don't see much value here since these can both be obtained from Context which you have when constructing this instance.\n. This starts to touch on what would make a good example, providing your own LocationManager instead of the system.\n. While you're right, there's no value-add for injection here. The likelihood that you're going to swap these components is zero (or impossibly close to it). Ideally an example would show advantages of using DI like swapping a concrete component for a different and/or fake impl.\n. You don't use this directly but rather always call .getKind() on it. Call it once and cache that result instead?\n. This should still be needed.\n. Well how about that. I've always just copied it along for the ride...\n. nit: capital 'c'\n. 2013s\n. Super nitpickery: Capitalize sentence and end with a period.\n. Good idea.\n. Annotations on same line as method declaration.\n. File should use two-space indentation.\n. extra spaces before both ;\n. and here\n. Sadly checkstyle isn't as strict as I would like. We could probably do a custom regex for it.\n. Shouldn't this be &lt;!-- workaround...?\n. https://github.com/square/dagger/pull/192\n. Hmmm this didn't seem to trigger...\n. Just compile-time. At runtime we only look for fields and constructors. Didn't seem useful to waste time looking for methods only to:\n1. find one with @Inject, throw exception\n2. find none, do nothing\n. Was unsure about this. Enforced by @Target on the annotation, right?\n. Should I flip the logic?\n\n``` java\nif (!module.getKind().equals(ElementKind.CLASS)) {\n  throw new AssertionError();\n}\nTypeElement moduleType = ...\n``\n. Ah, I guess it could be on an interface or enum. I'll mark as an error as well.\n. Woah. Good catch. Updated. Waiting for Travis.\n. Yep. Good call. Updated.\n. Heh, I'm trying! Stupid bluetooth tether over cell network...\n. Not at all, sir. Attempting to push it up now.\n.continuehere, I think.\n. +javadoc\n. Complete says that all of the bindings in a module can be accounted for internally or viaincludes(and maybe viaaddsTo`, I forget). This implementation verifies downstream usage of the bindings that a module exposes.\nBreaks complete:\njava\n@Module class NotCompleteModule {\n  @Provides Foo provideFoo(Bar bar) {\n    return Foo.of(bar);\n  }\n}\nBreaks this pull's check:\njava\n@Module(library=false) class UnusedModule {\n  @Provides Foo provideFoo() {\n    return new Foo();\n  }\n  @Provides Bar provideBar() {\n    return new Bar();\n  }\n}\nclass App {\n  @Inject Bar bar;\n}\nOG.create(new UnusedModule()).get(App.class);\nBasically, if you @Provide something and don't use it anywhere.\n. No, but I wasn't trying to solve that problem. Would you specify interfaces as entry points for that behavior then?\nI'll admit I whipped this up quickly on a whim purely for the validation aspect and may have under-thought it quite a bit. It doesn't actually solve the linked issue. I'll remove it from the pull.\n. Whoops. Too much reliance on auto-complete. Good catch.\n. \"Modules which have bindings that are necessary in entry points other than those directly referenced must use...\"\nSaying 'unnecessary' makes them sound bad but they may be perfectly valid.\n. \"unused\" also sounds negative. You don't like my suggestion?\n. The awesomeness of this failing is only exceeded by...\n. ...the awesomeness of this failing!\n. error(message, providerMethod)\n. Yeah. A provided Android module seems like a good thing to talk about. RoboGuice provides a bunch of Android things by default and besides View \"injection\" this is one of the first things people ask about.\n. done.\n. This should be static methinks.\n. final\n. Remove.\n. I think @tbroyer updated all of these to explicitly have <version>3.1</version>.\n. Indentation problems here.\n. Actually the for above should be unindented.\n. super nit: add an extra line here :)\n. Is the explicit typing on the left-hand side of the = intentional? Why not Map<ClassLoader, Map<String, Class<?>>?\n. ArrayModule? PrimitiveArrayModule?\n. and if you're already in this class, super nit: empty lines!\n. nit: 2013\n. nit: 2013\n. nit: 2013\n. nit: 2013\n. Why the removal?\n. Nope! Probably a behavior change in JavaWriter. Good catch.\n. That won't work, right? It'll re-do the entire provides method interation. The label would have to be at the bottom of the outer loop.\n. Woah. Also:\n\n. Thought about it but we're on the JVM so :fire:...\n. Move to top under <groupId>\n. Move to top under <groupId>\n. Move to top under <groupId>\n. Another re-formatted license header.\n. Re-formatted.\n. Move to top under <groupId>\n. Move to top under <groupId>\n. Another reformatted license\n. supernit: trailing period\n. Add imports for all this nonsense\n. Wow. Voodoo!\n. mundane nit: I think we've been doing non-javadoc style multi-line comments in every file thus far.\n. For the java plugin, provided is the correct scope. For Android, there is no correct scope because none exists. I'm not sure if advocating the compile scope is what we want to do for the compiler artifact.\n. nit: Empty line before this line to separate static vs. instance fields.\n. Whoops. I meant runtime for the Java plugin.\n. apk is the inverse, I believe. runtime means I need to link against this library but I do not want it in the final binary because it's provided by the runtime (e.g., servlets). apk is something you do not link against but do want in the final binary.\n. Er, right. I'm going to stop talking and go to bed. Ugh.\n. I just use Dagger 1.0.1 and let it do reflection :grinning: \n. Yeah we'll need two. One for java and one for Android since they're different Gradle plugins with different compilation semantics.\n. I think we want containsOnly or containsExactly here and below\n. Missing empty line before.\n. Can you give a quick explanation on the removal here as it's been a few months since I've been in Dagger deep? I can definitely remember that this line is where the majority of our configuration-based problems would manifest. Presumably makeGraph also triggers this or an equivalent?\n. Ah, I found it above. Not sure how I missed it.\n. Clipped?\n. Is this really from Android?\n. supernit: space after comma\n. supernit: does this need to wrap? Lines above are longer.\n. This is going to conflict with your other PR.\n. JLS order is public final boolean and for consistency with other methods\n. LinkedHashMap? Does it matter here? I'm not sure it does (on mobile).\n. It's re-wrapped in linkRequested\n. If we're going to do this (and I'm fine that we are) there's probably a lot of clean-up we can make other places in the compiler to leverage.\n. This can be shortened to:\njava\nshouldBeComplete &= errors.isEmpty();\n. At the very least you should be using isEmpty() in the conditional here.\n. FYI, none of the linked options work for Android when building in the IDE. There's now an 'apt' plugin for Android builds.\n. Revert.\n. Revert.\n. Revert.\n. 13 -> 19\n. Might as well add:\ngroovy\nbuildscript {\n  repositories {\n    mavenCentral()\n  }\n}\nwhile we're here\n. Can be deleted. Gradle 1.8 provides this task by default and updating the version can be done manually by twiddling the URL in gradle-wrapper.properties.\n. Can you move this dependency version to the root pom.xml to match the others?\n. I need to undelete a test and switch it to verify compilation failure. Back in an hour or two though, in case you review before then.\n. Added!\n. ",
    "glenviewjeff": "Thanks Christian, could you add the Google groups information to the README?  \nI was aware of m2e, but don't you have to do all of your builds in Maven and as a result lose most of the Eclipse/ADT features like error highlighting, Android lint, etc?\n. OK, thanks for all the great help and development of the tool.  I'll definitely give it a shot in a month or two once I get my redesign finished.  Where's the G+ page?\n. I think I made a post on there that wasn't approved--is someone moderating the group?\n. ",
    "dave-r12": "Hi, not sure if this fits with the issue described, but is the tape project demonstrating the idiom for doing injection within Android? I notice you extend the Application class to build the ObjectGraph, and then the onCreate you do the injection for the activity\n. ",
    "adriancole": "thank you!\n. still fiddling with this in gradle even in eclipse...\nOn Wed, Aug 7, 2013 at 12:12 PM, Christian Edward Gruber \nnotifications@github.com wrote:\n\nI''m now having consistent success with this using m2e, m2e-apt, and\n\"disable workspace resolution\" (if I have dagger open as a project in\neclipse). This seems worth closing at this point.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/126#issuecomment-22262930\n.\n. Depends.  If you have a custom wrapper than configuring the eclipse\ngradle can be a pain, if possible.  The eclipse plugin/task for Gradle\ndoesn't support writing the apt metadata in .classpath, .factories,\n.setttings etc.  For my use case, I can't use reflection at all anymore due\nto failover loader, and this makes this issue really painful in clunky\nintegration scenarios.\n\nI've no doubt I or we can improve things to make adt work fine in\neclipse,idea from maven, Gradle, just that it is suprise ancillary\nwork.  at least in the case of Gradle, this probably eludes to a dagger\nplugin, as I'm not really looking forward to teaching a bunch of people the\nmagic settings.\nAn alternative would be to make it possible to use a combination of compile\nand reflection in unit tests.  This is basically the feature that is now\ngone.\nOn Thursday, August 8, 2013, Jake Wharton wrote:\n\nIntelliJ just delegates to CLI Gradle. Eclipse does do the same?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/126#issuecomment-22370880\n.\n. I've no doubt that even what I could imagine would only be a small part of\nthe effort you've put through towards getting builds right.\n\nSo let's just catalog what he have, as we aren't really tracking build\nsystem debt that needs to be sorted as much as the java code.\nBefore FailoverLoader, we had getting:\n- adding a scope to Gradle which could use annotation processing during\n  test runs but not include it as a compile deps.  These are still somewhat\n  snowflake special instructions.\n- similar for the android plugin for Gradle which has slightly different\n  classpath stuff.\n- ProGuard support\nNow that failover loader makes it impossible to mix and match adhoc modules\nvia reflection, we have a bit more stuff in IDE land.\n- probably need to update docs to say reflection is deprecated as it barely\n  has a use case that can work now.\n- for build system plugins that generate eclipse metadata(eclipse:eclipse\n  or Gradle eclipse), instructions or extensions that setup the proper 3 jar\n  dependency for adp processing and how to keep that in sync when next\n  upgrade happens.\n- for IDE plugins, any similar instructions or config to do above,\n  including a known list of IDEs that may have worked with reflection but\n  don't work properly with ADP.\nChoosing battles, I'd still love to be able to have folks productive before\nthe latter mountain is moved, especially as it is usually an override\nmodule used in a test that now fails and enters an IDE config loop.  In\nhindsight I think we should have done a flag as there are cases where mixed\nreflection and compile is ok, provided we aren't deprecating reflection.\nOn Friday, August 9, 2013, Christian Edward Gruber wrote:\n\nYou would be surprised how much \"ancillary work\" I had to do or\ninstigate and track related to Dagger to get it all going in google.\nBuild systems seem ancillary but they are HOW our framework's facilities\nare manifested.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/126#issuecomment-22393851\n.\n. Anyway since I'm the one whining, I'll take on the how-to etc stuff. ;)\n\nOn Friday, August 9, 2013, Adrian Cole wrote:\n\nI've no doubt that even what I could imagine would only be a small part of\nthe effort you've put through towards getting builds right.\nSo let's just catalog what he have, as we aren't really tracking build\nsystem debt that needs to be sorted as much as the java code.\nBefore FailoverLoader, we had getting:\n- adding a scope to Gradle which could use annotation processing during\n  test runs but not include it as a compile deps.  These are still somewhat\n  snowflake special instructions.\n- similar for the android plugin for Gradle which has slightly different\n  classpath stuff.\n- ProGuard support\nNow that failover loader makes it impossible to mix and match adhoc\nmodules via reflection, we have a bit more stuff in IDE land.\n- probably need to update docs to say reflection is deprecated as it\n  barely has a use case that can work now.\n- for build system plugins that generate eclipse metadata(eclipse:eclipse\n  or Gradle eclipse), instructions or extensions that setup the proper 3 jar\n  dependency for adp processing and how to keep that in sync when next\n  upgrade happens.\n- for IDE plugins, any similar instructions or config to do above,\n  including a known list of IDEs that may have worked with reflection but\n  don't work properly with ADP.\nChoosing battles, I'd still love to be able to have folks productive\nbefore the latter mountain is moved, especially as it is usually an\noverride module used in a test that now fails and enters an IDE config\nloop.  In hindsight I think we should have done a flag as there are cases\nwhere mixed reflection and compile is ok, provided we aren't deprecating\nreflection.\nOn Friday, August 9, 2013, Christian Edward Gruber wrote:\n\nYou would be surprised how much \"ancillary work\" I had to do or\ninstigate and track related to Dagger to get it all going in google.\nBuild systems seem ancillary but they are HOW our framework's facilities\nare manifested.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/126#issuecomment-22393851\n.\n. FYI:  I'm not happy with this solution, but it works in both idea and\neclipse and can be used as a scrapyard until we can coerce a proper gradle\nplugin.\n\n\nhttps://github.com/Netflix/denominator/blob/master/dagger.gradle\nOn Fri, Aug 9, 2013 at 11:01 AM, Adrian Cole adrian.f.cole@gmail.comwrote:\n\nAnyway since I'm the one whining, I'll take on the how-to etc stuff. ;)\nOn Friday, August 9, 2013, Adrian Cole wrote:\n\nI've no doubt that even what I could imagine would only be a small part\nof the effort you've put through towards getting builds right.\nSo let's just catalog what he have, as we aren't really tracking build\nsystem debt that needs to be sorted as much as the java code.\nBefore FailoverLoader, we had getting:\n- adding a scope to Gradle which could use annotation processing during\n  test runs but not include it as a compile deps.  These are still somewhat\n  snowflake special instructions.\n- similar for the android plugin for Gradle which has slightly different\n  classpath stuff.\n- ProGuard support\nNow that failover loader makes it impossible to mix and match adhoc\nmodules via reflection, we have a bit more stuff in IDE land.\n- probably need to update docs to say reflection is deprecated as it\n  barely has a use case that can work now.\n- for build system plugins that generate eclipse metadata(eclipse:eclipse\n  or Gradle eclipse), instructions or extensions that setup the proper 3 jar\n  dependency for adp processing and how to keep that in sync when next\n  upgrade happens.\n- for IDE plugins, any similar instructions or config to do above,\n  including a known list of IDEs that may have worked with reflection but\n  don't work properly with ADP.\nChoosing battles, I'd still love to be able to have folks productive\nbefore the latter mountain is moved, especially as it is usually an\noverride module used in a test that now fails and enters an IDE config\nloop.  In hindsight I think we should have done a flag as there are cases\nwhere mixed reflection and compile is ok, provided we aren't deprecating\nreflection.\nOn Friday, August 9, 2013, Christian Edward Gruber wrote:\n\nYou would be surprised how much \"ancillary work\" I had to do or\ninstigate and track related to Dagger to get it all going in google.\nBuild systems seem ancillary but they are HOW our framework's facilities\nare manifested.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/126#issuecomment-22393851\n.\n. jeez this one's a tough call.  I need to play with SET_VALUES in 1.1 more as this was the only place I needed overrides=true on set bindings before.\n. Thanks for the heads up!\n. Fwiw I think we probably need using(plugins) as a separate issue.  I\nrecently found an error in some leaves in my build which didn't use the\ncompiler at all.  I'd love to at least in a unit test take out the ability\nto use the reflective plugin.\n\n\n\nOn Wednesday, May 22, 2013, Christian Edward Gruber wrote:\n\nAbsolutely, to the issue of whole-graph codegen, we would need a lot more\ninfrastructure for class structure analysis, and we would lose out on some\ninformation not stored in the .class files (param names, etc.). Jesse and I\nhave talked about this before as the eventual direction of Dagger.\nAs to having a non-reflection mode, I'm not opposed - quite happy for it,\nin fact. I have been wondering about programming styles for it. Was toying\nwith something to expose the plugins (we need it potentially in google),\nlike:\nObjectGraph.using(plugins).create(modules);\nWith some constants for common plugin sets. (DEFAULT=Loader,Reflective :\nLOADER=Loader,AbstractHedge)\nBut this was intended for those who also may need to do funkier things in\nplugins inside Google. It might not be the right way to expose this for the\naverage case (Though maybe under the hood, it's done that way)\nIt might be time to revisit the injector builder idea:\nObjectGraph.withoutReflection().create(modules);\n... or some such. All graph context configuration like this would happen\nat the root, so .plus() extended graphs all share one plugin context.\nWhether we implement it by means of plugin sets or otherwise is then behind\nthe line.\nWhat I'm not sure how to do is to have this thing handle no-adapter\nparents without using reflection to detect that this is, indeed, a\nno-adapter, non-injectable parent that should just be ignored, except to\nsilently succeed in that case. But silently succeeding would be the same\ncode flow as a parent that needed an adapter but one was never generated.\nNo way to catch the error. :/\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/177#issuecomment-18292771\n.\n. +1\n. thx!  I can test the PR/branch whenever.\n. I'm sure you noticed, but it is this generated line awry:\n\nprovider = (Binding<Provider>) linker.requestBinding(\"denominator.Provider\", DNSApiManager.class);\n. root cause seems to be in JavaWriter: https://github.com/square/javawriter/issues/8\n. sent fix: https://github.com/square/javawriter/pull/9\n. confirming with the javawriter fix, denominator passes all tests using dagger 1.0.0.\n. ps dagger 1.0.0 will be released into netflix production tomorrow.  Thanks, all, and enjoy the flicks :)\n. I'll update this commit as soon as 3.5.4 is out (estimated later today)\n. haha :)\n. It seems that in the reflective plugin, contribution to a set binding might be breadth-first wrt includes.  You can paste the below into SetBindingTest to see what I mean.\n```\n  static class FirstStringFromSetBinding {\n    String string;\n@Inject\nFirstStringFromSetBinding(Set<String> strings) {\n  this.string = strings.iterator().next();\n}\n\n}\n@Module(injects = FirstStringFromSetBinding.class)\n  static class String1Module {\n    @Provides(type = SET)\n    String provideFirstString() {\n      return \"string1\";\n    }\n  }\n@Module(injects = FirstStringFromSetBinding.class)\n  static class String2Module {\n    @Provides(type = SET)\n    String provideSecondString() {\n      return \"string2\";\n    }\n  }\n@Test\n  public void testOrderOfReflectiveSetBindings() {\n    FirstStringFromSetBinding ep = ObjectGraph\n        .create(new String1Module(), new String2Module())\n        .get(FirstStringFromSetBinding.class);\n    assertEquals(\"string1\", ep.string);\n  }\n@Test\n  public void testOrderOfReflectiveSetBindingsWithIncludedSetBinding() {\n@Module(injects = FirstStringFromSetBinding.class, includes = String1Module.class)\nclass IncludeString1Module {\n}\n\nFirstStringFromSetBinding ep = ObjectGraph\n    .create(new IncludeString1Module(), new String2Module())\n    .get(FirstStringFromSetBinding.class);\nassertEquals(\"string2\", ep.string);\n\n}\n```\n. Yeah I'm mainly trying to get iteration order consistent.  I'm aware about Set by itself not guaranteeing that, but LInkedHashSet should, and it would be helpful to not have accidental ordering differences, if they can be avoided.  I'm aware this request could reasonably be punted, but I'm also ok owning this up to fixing it.\n. I'm closing this per issue #256 the contribution order is consistent, although I'd have preferred depth-first.\n. So, I think the main concern is that I'd like to use contributed bindings like a plugin-system such as described in Jesse's talk.  The case in point is credentials suppliers.  I'd prefer to be able to have users contribute to a binding and have some means of ensuring their preferences are at the top.  You're right this is probably more a list binding, than a set.  However, breadth-first contribution wrt includes doesn't really help me either.  Is there a better way, or is basically set binding not the right tool for the job?\n. Yeah, I'm over the Set idea.  I was being too clever and I get it.\nEven if order was guaranteed insertion on Map or Multimap, I'm still hosed if the contribution algo is breadth first wrt Module.includes.  Basically, I'd love to ensure that whatever collection binding we choose, if someone adds a module later in ObjectGraph.create, those contributions are always later in the resulting binding.\nex.  ObjectGraph.create(moduleA, moduleThatIncludesB, moduleC)  I'd love to ensure the collection ends up A, B, C instead of A, C, B.\nMake sense?\n. yeah I see what you mean.  basically put a mutable collection under a key and be done with it.  That would work.\n. ok, so let me make this more concrete.\nSay you are making a library with Dagger, and it needs to authenticate.  You have Provider<Credentials> injected into things that use them, for example to connect to google storage.  The api wants to be convenient to cloud users, so it has \"built-in\" support for GCE service accounts (ex. a Provider<Credentials> that curls http://metadata/computeMetadata/v1beta1/instance/service-accounts/default/token or fails if that url isn't present because you are on a laptop or whatever).  I want users to be able to override this, for example, specifying statically configured credentials in a file.  I'd prefer to not lose visibility of what they've overridden in case their providers suck for some reason.\nI'm thinking thing = ObjectGraph.create(new MyLibraryModule(), TheirAuthModule()).get(ThingThatNeedsAuth.class);\nThe priority I'm referring to is that I'd like to ensure that any contributed bindings they supply in TheirAuthModule() appropriately bump those in MyLibraryModule().  In other words, I'd like to have something that acts like the fallback chain in guava Optional.or().\nI can dumb down the feature to only one source of credentials by using ObjectGraph.plus and ditching the contributed bindings idea ( I think).\nThanks for your time, man.\n. Fwiw I got by via removing set binding for module.overrides. If there was a\nway to achieve the default plugin idea differently, it would be to instead\nannotate the Provides method with type=SOFT or something (remember\nImplementedBy)\nMeanwhile, I'm also fine dropping this as multiple ordered contributors is\nthat important to justify killing the simplicity of Dagger.\nHats off for the discussion: much appreciated.\nOn Thursday, May 23, 2013, Jesse Wilson wrote:\n\nJake: good point. Let's drop this.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/252#issuecomment-18389127\n.\n. I'm indifferent about how to achieve plugin exposure, so proposals welcome!\n. seems the more relevant google fork discussion is this one: https://github.com/google/dagger/pull/3\n. I'm ok with a system property.  Also, if needed, I can always check the\nclasspath for $$ classes which could indicate compile worked ala\nhttps://github.com/adriancole/dagger/commit/1b8514061eecc0b60b9e85b1be9af8caca87346b#diff-2\n\nOn Fri, May 24, 2013 at 9:24 PM, Jesse Wilson notifications@github.comwrote:\n\nPlugins are sufficiently low-level that I'm not even that opposed to using\ngross System properties to poke at them.\nSystem.setProperty(\"dagger.reflection\", \"false\");\n  ObjectGraph objectGraph = ...\nYes it is gross. But it reveals an appropriate amount of commitment to\nthis API. It's an invisible option, and that's find with me.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/253#issuecomment-18439550\n.\n. looking forward to it\n. Lgtm\n. p.s. I'm totally cool with this being closed out.  That said, there's some code here that was harder than expected to nail down, and maybe I can repurpose it.  For example, there are probably parts of our contract which should be validated as being the same between reflective and annotation-processed modes.  If you can think of one, I'll rewrite the integration test I have here to prove that instead.\n. per issue #252, my main desire is for prioritized contributed bindings.  I also like and would use Map bindings, and will think about it to see if this would work to solve prioritized, too.\n. I'm in favor of the first option, particularly for a configuration api, it is more important to me that the value can be complex than its key.\n\n@Provide(type=MAP_VALUE) @Key(\"foo\") Plugin provideFooPlugin() { ... }\n. All my current use cases are fine with \"worst\" fwiw.  I also like the less\ntypes thing, and am ok with the extra key attribute on the Provides\nannotation only to permit map bindings, as javadoc can easily tell people\n\"only when type is MAP\"\nOn Thursday, May 23, 2013, Jesse Wilson wrote:\n\nI like the \"worst\" one the best:\n@Provides(type=MAP_VALUE, key=\"Foo\") Handler provideFooPlugin() { ... }\nStrings are enough for everything I've had to do. More sophisticated apps\ncan use strings and create their own adapter bindings like this:\n@Provides Map provideFooPlugin(Map stringMap) {\n    // use stringMap to create the other map\n  }\nUpsides\n- No confusion between qualifier annotations and map key annotations\n- Statically checkable\n- Fewer types and less code\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/257#issuecomment-18387972\n.\n. I've been playing around quite a bit, and one thing that seems quite easy (in principle) to do with map bindings, but not in set bindings, is to override by key.  Here's the current workaround I am using.  I'm totally cool with the first 3 providers, as I can simply override in a module if I choose to use a different impl per key.  As the boilerplates to achieve this are so error-prone, I'm considering code gen, if we make a strict decision to never support map binding.  I understand the \"just fork and do whatever\" mantra, just that I still don't want to maintain my own DI library just because it makes map binding really really hard to achieve.  It would be a better pain to codegen the boilerplate, I guess, as the responsibility is less.\n\n```\n        @Provides\n        @Named(\"CloudIdentity\")\n        Decoder cloudIdentityDecoder() {\n            return elementsAreGroups(\n                    \"^.token[\\\":{\\s]+id\\\":\\\"([^\\\"]+)\\\"(.cloudDNS\\\"[^\\]]+publicURL\\\":\\s*\\\"([^\\\"]+)\\\")?\", 3, 1);\n        }\n    @Provides\n    @Named(\"CloudDNS#nameToIds()\")\n    Decoder nameToIdsDecoder() {\n        return multimapEntriesAreGroups(\"\\\"name\\\"[:\\\\s]+\\\"([^\\\"]+)\\\"[,:\\\\s]+\\\"id\\\"[:\\\\s]+([0-9]+)\", 1, 2);\n    }\n\n    @Provides\n    @Named(\"CloudDNS#idNameType(String)\")\n    Decoder idNameTypeDecoder() {\n        return cellsAreGroups(\n                \"\\\"name\\\"[:\\\\s]+\\\"([^\\\"]+)\\\"[,:\\\\s]+\\\"id\\\"[:\\\\s]++\\\"([^\\\"]+)\\\"[,:\\\\s]+\\\"type\\\"[:\\\\s]++\\\"([^\\\"]+)\\\"\",\n                2, 1, 3);\n    }\n\n    // workaround until map binding is added to dagger\n    @Provides(type = SET)\n    Config<Decoder> cloudIdentityDecoder(@Named(\"CloudIdentity\") Decoder cloudIdentityDecoder) {\n        return Config.create(\"CloudIdentity\", cloudIdentityDecoder);\n    }\n\n    @Provides(type = SET)\n    Config<Decoder> nameToIdsDecoder(@Named(\"CloudDNS#nameToIds()\") Decoder nameToIdsDecoder) {\n        return Config.create(\"CloudDNS#nameToIds()\", nameToIdsDecoder);\n    }\n\n    @Provides(type = SET)\n    Config<Decoder> addIdNameTypeDecoder(@Named(\"CloudDNS#idNameType(String)\") Decoder idNameTypeDecoder) {\n        return Config.create(\"CloudDNS#idNameType(String)\", idNameTypeDecoder);\n    }\n\n``\n. I like the@Provides(type=SET_VALUES), too.  Currently, I work around by having a base module just provideSetnormally with an empty set; if my contributor saysoverrides=trueit does what it should.  A scenario where we can avoid hackish use ofoverrides=true` would be an improvement to me. \n. submitted a PR for this, as particularly adding this takes out some ugly workarounds wrt default to empty set.\nhttps://github.com/square/dagger/pull/291\n. any chance we can get dagger 1.1 released?  I'm starting to get support email which could be avoided if I can switch to SET_VALUES..\n. +1\n. Agreed Loader is a more meaningful name. Go for it!\nOn Tuesday, June 4, 2013, Jesse Wilson wrote:\n\nLGTM. Merge at your leisure.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/pull/268#issuecomment-18911375\n.\n. looks reasonable, and the description sounds reasonable, too.  It would be nice to have a test that shows the classloader isolation operating.  I slightly cringe, know that probably isn't straightforward.\n. I'm cool with tests happening later.\n. glad to see this!\n. Late to the party, but nice work! Thanks for making these public access, too.\n. Lgtm\n. what's the problem with gradle (curiousity)?  I just recently made an android dagger gradle project fine(ish).\n. oh right.  https://groups.google.com/forum/#!topic/dagger-discuss/jiK7B2TMLK0  I'll answer this..\n. Fwiw I still am in favor of this change :)\n+1\n\nOn Thursday, June 27, 2013, Christian Edward Gruber wrote:\n\nAnyone... anyone... bueller... bueller...?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/pull/281#issuecomment-20144391\n.\n. done the review. there's nothing blocking in my comments as they only address clarity of intent vs structural issues.\n. Agreed less piso mojado.  Good work!\n\nOn Saturday, June 29, 2013, Christian Edward Gruber wrote:\n\nOnce this is in, actually, it helps us avoid one of the key weaknesses of\nDagger, which is that if we rely on the compile-time error, we don't assert\nvalidity at runtime (unless you call the expensive validate() method). But\nsomeone could throw arbitrary modules in including incorrect ones that had\nnot had the full graph analysis done on it - this at least will ensure that\nthat process must have happened, else we would not have a moduleadapter.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/pull/281#issuecomment-20242551\n.\n. agreed. I don't think the injects attribute should be magically also a provider.\n. actually, I have doubts, too..\n\nSince #232 is implemented, aren't entry points required to have an @Inject annotation (or be supplied via @Provides)?  If that's the case, isn't this issue unsolvable without undoing #232?\n. +1\nOn Fri, Jun 21, 2013 at 4:33 PM, Jesse Wilson notifications@github.comwrote:\n\n+1.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/288#issuecomment-19846241\n.\n. I wonder if we could make a dagger-compiler main method to create the test classes, and invoke that prior to surefire?  I know it looks like a circular dep (and it is), so maybe not a good idea.\n. LGTM\n. updated commit to address nits.\n\n@cgruber I added tests to show SET_VALUES bindings of Set<A> do not impact Set<Provider<A>>.  Whether or not that behavior is desired is a different question :)  IMHO, multibindings shouldn't clash, particularly since they can be seeded from a combination of unique and set collaborators.\n. ps lemme know if we want to change SET_VALUES to SET_VALUE\n. before I tidy this up, do we want to have this process on type=SET, such as @cgruber suggests?  Only impact I can see is perhaps someone who literally wants a Set<Set<Foo>> might complain as there could be ambiguity.\n. should I leave the test as-is (exposing the bug) or rewrite it to not make\na child graph?\n. ok. should be ready to go now.  only change besides adding tests was the following in SetBinding\njava\n      if (contributor.provideKey.equals(provideKey)) {\n        result.addAll((Set<T>) contribution);\nThe above ensures the nested sets don't trip up logic.  Before, it used instanceof Set which @swankjesse pointed out would.\n. nudge.. any chance of mergy releasey?\n. Woot, thanks for the time reviewing, folks\nOn Wednesday, July 24, 2013, Jesse Wilson wrote:\n\nNice! Thanks Adrian!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/pull/291#issuecomment-21479599\n.\n. LGTM\n. LGTM\n. exciting!\n. hate to be a nag, but anything blocking 1.1 at this point?\n. LGTM shipit\n. really happy about this.. I wonder if there's support for adding in a test that mixes incorrect annotations.  Ex. I burnt time using guice @Provides when I meant Dagger and visa versa.\n. Would it be valid to allow multiple provides annotations in a class which\nhas a dagger.module annotation?\n\nNo problem punting to a friendly warning side project either way.\nOn Friday, July 26, 2013, Christian Edward Gruber wrote:\n\nThat's sort of a different issue - I'm not sure we want to build defensive\nchecks against other frameworks into dagger, as that's going to be hard to\nmanage. However, I can see making a side project for such checks. But these\nchecks will do things like show warnings if you're using\njavax.inject.{scope/qualifier} based annotations, while not actually using\n@dagger.Provides or @javax.inject.Inject (as appropriate). We can't make\nthem errors, since it's entirely legitimate to have a guice `@Provideshttps://github.com/Providesmethod with a javax.inject scope/binding annotation... but if you have\ndagger in your classpath, we can throw a warning, since it's likely not\nwhat you meant.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/pull/299#issuecomment-21654993\n.\n. Nice description update also useful ref to error prone.  Will look at impl tomorrow if not merged before.\n. If not implicitly already the case, I'd like to see provides checks also double-check for @Module annotation on the type.  All else looks fine after noted nits.\n. LGTM\n\nThanks for the good work!\n. warning suppressions look like a good idea.  Only recommendation is to include a test that uses the array form.  ex. @SuppressWarnings({\"scoping\", \"bar\"})\n. Lgtm thanks for the extra test!\n. @sgoldfed is the merge commit intentional?\n. awesome\n. time to pull that trigger?\n. I agree with the principles here.  sounds good.\nOn Mon, Aug 5, 2013 at 8:45 PM, Steven Goldfeder\nnotifications@github.comwrote:\n\n@adriancole https://github.com/adriancole In regards to the check you\nwanted for @c.g.i.Provides in dagger modules, I discussed this with\n@gk5885 https://github.com/gk5885 and @cgruberhttps://github.com/cgruberand a good way to achieve this without using defensive checks is:\nCheck that @dagger.Provides is only used in classes annotated with\n@dagger.Module and that @c.g.i.Provides is only used in classes that\nextend c.g.i.AbstractModule. The first one is already in Dagger (as you\nrequested :-) )\nDoing it this way is nice and clean as\n- If a class fits the criteria of both, then both annotations can be\n  used\n- If we want to protect against some other DI framework's annotations,\n  we just add a check to validate that they are being used correctly, but\n  don't have to go ahead and rewrite our dagger checks to now forbid more\n  annotations.\nI'm going to go ahead and add these checks to error-pronehttps://code.google.com/p/error-prone/\n.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/pull/299#issuecomment-22151374\n.\n. LGTM\n. Are you getting this error from surefire (maven) or in the console from a\ntestng run in your IDE?\n\nOn Tuesday, August 6, 2013, Andrew Regan wrote:\n\nI'm testing the upgrade from 1.0.1 to 1.1.0 (Maven, Java 7), and added the\nnew dagger-compiler dependency as described, but all my TestNG tests -\nwhich call ObjectGraph.create( new MyModule() ) as a final static - now\nfail:\n[snip]\nCaused by: java.lang.IllegalStateException: Module adapter for class\nblah.MyModule could not be loaded. Please ensure that code generation was\nrun for this module.\nat dagger.internal.FailoverLoader.getModuleAdapter(FailoverLoader.java:41)\nat dagger.internal.Modules.getAllModuleAdapters(Modules.java:43)\nat dagger.ObjectGraph$DaggerObjectGraph.makeGraph(ObjectGraph.java:167)\nat dagger.ObjectGraph$DaggerObjectGraph.access$000(ObjectGraph.java:134)\nat dagger.ObjectGraph.create(ObjectGraph.java:126)\nat blah.MyTest.(MyTest.java:53)\n... 26 more\nI can paste the Module, if you like.\nAre there any more steps I need to take?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/302\n.\n. you'll probably notice this with idea as well.  I've not fiddled with\nsettings to force its incremental stuff to use the compiler jar, yet.\n\nOn Wed, Aug 7, 2013 at 4:57 AM, Andrew Regan notifications@github.comwrote:\n\nAh, that's strange. Running within Eclipse and doing 'mvn test' (from\nwithin E) both produce the error. As soon as I switch to 'mvn clean\ninstall' (from command line), it works, and having done that, both the\nEclipse and 'mvn test' runs subsequently work.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/302#issuecomment-22238132\n.\n. Really cool.\n\nI'd love to be able to see a success-case, even if just pasted in the description in markdown.  Could one not be included in this PR?\n. Note that this change makes the build require JDK 7.  Ex. running w/JDK 6 results in stuff like the following.\ncyclicDepsWithInjectables(dagger.internal.codegen.CyclicDependencyTest)  Time elapsed: 0.086 sec  <<< ERROR!\njava.lang.NoSuchMethodError: com.sun.tools.javac.api.JavacTool.getStandardFileManager(Ljavax/tools/DiagnosticListener;Ljava/util/Locale;Ljava/nio/charset/Charset;)Lcom/sun/tools/javac/file/JavacFileManager;\n    at com.google.testing.compile.Compilation.compile(Compilation.java:60)\nwe might want to update the pom to reflect minimum JDK (compilerVersion)\n. LGTM: builds fine (noting above), much less arduous option to cover negative tests.\nyay\n. LGTM\nvery cool.  thanks for adding the positive test.\n. 50% fewer lines and faster running tests?\n. saved 10-15 seconds!\n. LGTM except might be nice to note specific github issues for projected feature TODOs\n. If we want to investigate this further we probably should:\n- [ ] backfill test of ModuleAdapterProcessor.generateModuleAdapter().  This will easily help show any codegen differences if we take any action here.  We can do this similarly to InjectAdapterGenerationTest.\n- [ ] add a caliper test module, which first benchmark could be written to show the time to ObjectGraph.create with 1000 bindings? (what's the best count here?)\n- [ ] figure out a bench for Dalvik, presuming there's not a direct correlation there..\nThis should be done after @cgruber recent pull requests are merged, but they can be done independently by folks.  Once these are in, we have a solid place to test ideas including the class.forname thing that might be promising.  I'd be hesitant to do too much before, though.  my 2p anyway.\nLooking at this realistically, I can't promise I can run through all of this, but I will start on backfilling the generation test tomorrow.\n. Fwiw, I can see value in union set bindings on .plus\n. Sounds tricky.  I guess overrides=true could be implemented to reset the\nset \"bound so far\", but concede that module ordering differences could mean\nnon deterministic results... is that the concern?\n. @mosabua awesome. here's the trivial pr: #337\n. we decided not to take action on #337 as the fix breaks <3.1 maven!\n. LGTM\n. looks good and the code is simple.\nwould be ideal backport a test case on this.. there's probably something to similar in guava, maybe testConcurrentLoading\n. lol on the build failure!\n[ERROR] Failed to execute goal com.jayway.maven.plugins.android.generation2:android-maven-plugin:3.8.0:generate-sources (default-generate-sources) on project android-simple: The plugin com.jayway.maven.plugins.android.generation2:android-maven-plugin:3.8.0 requires Maven version 3.1.1 -> [Help 1]\nI'll see about a conditional version.. ick\n. ick.. beyond my maven-fu at the moment.  seems easy enough to enforce a maven version project-wide.  Not sure how to use a maven version as a part of profile activation to choose the plugin version.\n@cgruber @JakeWharton @swankjesse any probs bumping minimum version of maven to 3.1.1 instead of investigating how to support old versions?  impact would be at least updating the travis build.\n. Good point.  I'd prefer to not maintain 2 mavens if we can get by with\nsomething else for samples. Sounds like a plan!\n. closing won't fix\n. before we look into this further, can you please correct your versions to match across dagger and dagger-compiler?\n. weird.. I didn't realize we supported injecting wildcard types!\n. ok rebased. and will bump again once compile-testing 0.4 is out.\n@cgruber yeah I will probably knock out more of these, particularly as getting rid of the maven int tests == faster builds\n. @gk5885 naggy nag.. :)\n. thx @gk5885.\nready to merge, I think\n. I'm so glad you fixed this!  Thanks, @cgruber!\nLGTM\n. Not sure why we set accessibility formerly or if that was just an oversight.\nLGTM\n. LGTM\n. Ideally, this would have a test case.  LGTM\n. Oh.  Cool.  I didnt think about being able to test generation of dot\nfiles.  Sweet!\n. I understand the change, but it took a few minutes to grok the second new test.  Seems it is ensuring orphan analysis does happen when one of the modules is contributing to a set binding, but not marked library.  There could be a clearer way to name the test, or perhaps matching the exception message could help make this quicker to grok. \nLGTM\n. Sure. I starred for followup.\n. Nit: s/ERROR_NAMES_TO_PASS_THROUGH/TO_PROPAGATE/\nAlso, this would be nice to have a test case.\nOtherwise, LGTM\n. Yeah that makes sense.\nWrt testing: I didn't scroll up enough to see what you mean.  Seems this\nwould be a lot of work and result in what's likely to be a flakey test.\nSleeping dogs lie is fine by me.\n. AFAICT, the changes here:\n- shuffle some things around, with some reverse documentation.\n- make it possible for a Linker to be transitively linked.\n- put in a flag and defensive checks to avoid doing that more than once.\nThe code looks slightly more complex than before, but I don't see a cleaner way of achieving the optimization, so assuming your tests prove the hypothesis...\nLGTM\n. @cgruber by reverse documentation, I meant that in the new code you extracted a couple methods and put javadoc on them :).  scratch the \"make it possible for a linker to be transitively linked\" comment.. I read that incorrectly\n. @cgruber awesome.  I really appreciate your objective review of changes like this!\n. Thanks.  This looks fixable.\n. @cgruber should we just avoid using the word module for now?  Ex. make the field named _module?\n. basically wondering if we should prefix with $ or _ or something else..\n. Well, I'll backfill a test first, since we've affected the above codegen!\n. Yeah, the generated module adapter fails to compile\u2026\n``` java\nJavaFileObject a = JavaFileObjects.forSourceString(\"A\", Joiner.on(\"\\n\").join(\n    \"import javax.inject.Inject;\",\n    \"class A { @Inject A(){ }}\"));\nJavaFileObject b = JavaFileObjects.forSourceString(\"B\", Joiner.on(\"\\n\").join(\n    \"import javax.inject.Inject;\",\n    \"class B { @Inject B(){ }}\"));\nJavaFileObject module = JavaFileObjects.forSourceString(\"BModule\", Joiner.on(\"\\n\").join(\n    \"import dagger.Module;\",\n    \"import dagger.Provides;\",\n    \"import javax.inject.Inject;\",\n    \"@Module(injects = B.class)\",\n    \"class BModule { @Provides B b(A module) { return new B(); }}\"));\n```\nwith..\njava.lang.AssertionError: Compilation produced the following errors:\nmem:///SOURCE_OUTPUT/BModule$$ModuleAdapter.java:73: cannot find symbol\nsymbol  : method add(BModule)\nlocation: interface java.util.Set<dagger.internal.Binding<?>>\nmem:///SOURCE_OUTPUT/BModule$$ModuleAdapter.java:82: cannot find symbol\nsymbol  : method get()\nlocation: class BModule\n. oh.. I just pasted this into InjectAdapterGenerationTest in a new test, and it fails :)\n``` java\n  @Test public void providesHasParameterNamedModule() {\n    JavaFileObject a = JavaFileObjects.forSourceString(\"A\", Joiner.on(\"\\n\").join(\n        \"import javax.inject.Inject;\",\n        \"class A { @Inject A(){ }}\"));\n    JavaFileObject b = JavaFileObjects.forSourceString(\"B\", Joiner.on(\"\\n\").join(\n        \"import javax.inject.Inject;\",\n        \"class B { @Inject B(){ }}\"));\nJavaFileObject module = JavaFileObjects.forSourceString(\"BModule\", Joiner.on(\"\\n\").join(\n    \"import dagger.Module;\",\n    \"import dagger.Provides;\",\n    \"import javax.inject.Inject;\",\n    \"@Module(injects = B.class)\",\n    \"class BModule { @Provides B b(A module) { return new B(); }}\"));\n\nASSERT.about(javaSources()).that(asList(a, b, module)).processedWith(daggerProcessors())\n    .compilesWithoutError();\n\n}\n```\n. You should be.\n. LGTM\n. wow.  glad you were able to catch this!\nLGTM\n. lgtm\n. Interesting design WIP.  Thanks for putting it together!\n. sounds great.\n. I was just thinking\u2026 I've not seen a massive PR from @cgruber in a while :P\n. LGTM\n. thx!  I forget\u2026 so we squash or does this screw up the google fork process?\n. gotit.\n. It has been several months since my last injection confession.  I have\nbound an unqualified ExecutorService and used Named annotations.\nYou are forgiven.  Create and add a HailMary annotation to the\nExecutorService to separate it from evil.\n. It will feel a little boiler-platey or mysterious to folks who don't\nunderstand, or are reading javax.inject.Inject javadoc which says it is\noptional. That said, if not too expensive to do, perhaps a special error\nmessage when there are members with Inject but no Inject ctor could do the\ntrick.\nAt any rate, I'm in favor of the change.\n-a\n. A build floor of JDK 7 sounds sensible to me.\n. as previously discussed, I'd prefer this to be a formal part (read public) part of the api.  That said, I know this opinion isn't universally held, so fine with being package protected.\n. suffix being added here assumes that either initModuleAdapter or newModule only fail for CFE for a type with an adapter suffix.  I'd say either move the exception coercion to where the type is being loaded or add a comment as to why this assumption is always true.\n. little OCD, but a one line comment above the try saying why CNFE is ok to ignore\n. moving this comment up to javadoc might remove my concern for downstream comments\n. yeah this is the syntax I'd love to access outside the dagger package :P\n. Actually I think this change removes most needs.  I'll keep whatever firepower I may have in support of map bindings which is the single largest issue I have with dagger.\n. I agree.  Went a little wild with enumset there.\n. Sure thing\n. I thought that they should be collaborating into the same output set (ex. SET_VALUES ~ addAll while SET ~ add).  Why would empty set be invalid?  Without allowing empty set contribution, my original intent is thwarted...\n. I suppose it would make more sense as Provides(type = ADD) and  Provides(type = ADD_ALL) in hindsight.\n. oh i see.  should I attempt a copyOf on graph.plus, then?\n. ok, so basically convert this test from one that succeeds to one that fails :)\n. well, I guess there's one that should succeed... a second module in the same graph should succeed.\n. OK, then I'll wait to you decide what to do with this branch.  no worries if the answer is close\n. adding a second integration test: multiple-modules-setvalues for this\n. ok adding a test for this\n. oh there's already providesSet() test\n. worthwhile backfilling a non-primitive array test?\n. even better!\nOn Wed, Jul 24, 2013 at 8:48 AM, Christian Edward Gruber \nnotifications@github.com wrote:\n\nIn\ncompiler/src/test/java/dagger/internal/codegen/PrimitiveInjectionTest.java:\n\n\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n  +package dagger.internal.codegen;\n  +\n  +import dagger.Module;\n  +import dagger.ObjectGraph;\n  +import dagger.Provides;\n  +import javax.inject.Inject;\n  +import org.junit.Test;\n  +\n  +import static org.fest.assertions.Assertions.assertThat;\n  +\n  +\n  +public final class PrimitiveInjectionTest {\n\n\nSorry... to be clearer... when I'm done, I'll move this test with all the\nothers, and all of them will run in both contexts.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/pull/293/files#r5375279\n.\n. supernit leading space?\n. more a question... we usually set min/max to 1.6, right?\n. supernit eol before eof\n. worthwhile checking to see if declaring type has a @Module annotation?\n. worthwhile putting a github issue link for compile-testing in the TODO?\n. is synchronized needed here considering the below readLock?\n. thanks.  this code is clearer than before.  nit: I don't see why the conversion to List was needed.\n. nit: format\n. goes without saying I guess that cloning keeps us from mutating the parent in a child graph.\n. would it make more sense to have the comment as a part of the IAE message?\n. LinkedHashMap follows conventions more closely.\n. nice\n. will this look gross?\n. would it be over engineering to consider a default capacity (besides 10)?\n. save an iterator by using index loop?\n. save an iterator by using index loop?\n. thanks!\n. sgtm\n. assuming it is an array list, we've made the following blanket change to okhttp to remove an extra allocation in android.\n\njava\nfor (int i = 0, size = list.size(); i < size; i++) {\n  ...\n. gotcha\n. ",
    "tbroyer": "@pforhan do you want a smoke test? Or do we wait for @cgruber tests? Or can we go with it and Christian will add to the set of tests he's preparing?\n@cgruber Indeed that wouldn't work: the return type and qualifier serve as the key for the Set, so there has to be duplicates, unless you only want singleton sets ;-)\n. I duplicated the provideHeater method in DripCoffeeModule from the example and mvn clean package fails with:\n[INFO] --- maven-compiler-plugin:2.5:compile (default-compile) @ dagger-example ---\n[INFO] Compiling 8 source files to /home/tbr/Projets/dagger/example/target/classes\n[INFO] -------------------------------------------------------------\n[ERROR] COMPILATION ERROR : \n[INFO] -------------------------------------------------------------\n[ERROR] error: Duplicate bindings for coffee.Heater: DripCoffeeModule.provideHeater(), DripCoffeeModule.provideHeaterElement()\n[INFO] 1 error\n. @cgruber is this your integrationtests branch?\nFor RequestFactory in GWT, @bobvawter came out with an approach that doesn't need forking a build and analyzing the results: calling javax.tools.JavaCompiler from the unit-test. See http://code.google.com/p/google-web-toolkit/source/browse/trunk/user/test/com/google/web/bindery/requestfactory/apt/RfValidatorTest.java\n(src/test/java would have to be added as a testResource, but I think that approach could work within a Maven build)\n. I rebased/squashed/ammended my commits; I suppose you're OK with that.\nSide note: re. tests failing on BuildHive, this is due to using an old version of the JDK. Had the same issue on my computer with Oracle JDK 6u27, vanished when switching to OpenJDK 7 (gives me even more test failures with OpenJDK 6 \u2013Ubuntu has 6u24\u2013).\nSee http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7003595 and http://dev-snapshot.blogspot.fr/2012/08/use-java-7-on-buildhive.html\n. m2e-apt works fine for me, though it requires either:\n- explicitly putting Dagger as a dependency of the maven-compiler-plugin\n- explicitly listing the processors rather than relying on discovery\n- using the org.bsc.maven:maven-processor-plugin (and rely on true discovery in the classpath)\nI've used the latter in the example in Sheath, but I'm going to switch to the maven-compiler-plugin as the maven-processor-plugin has no mean of specifying the source compatibility (I'm using OpenJDK 7, so it's implicitly using -source 1.7 which causes warnings with the processors, that declare being compatible with SourceVersion.RELEASE_6 only)\n. Should this issue be closed? We have #110 already (which is fixed BTW, but hasn't been closed yet) which covers error reporting as annotations in the editors, and I think #117 fixed the iterating/incremental build (IIRC, during my manual tests for #110, FullGraphProcessor reporting was OK)\n. I have to take back my above claim. Looks like an Eclipse plugin would help here; see my comment on issue #126 for more info on what's currently missing.\n. I thought we were talking about possibly getting rid of the reflection backend (fallback) in the long term. With this in mind, that change makes little sense (particularly the separate codegen module).\nNot to mention that it'd completely break the test runners i'm working on, to run the unit-tests with both reflection and codegen backends (unfortunately not quite ready yet, but in good shape). With those tests, for instance, I found that InjectionTest.GetInstanceOfArray fails with codegen: the ModuleAdapter being generated doesn't compile (method return type for the method binding's get() is Integer[] instead of int[]).\n. See https://github.com/tbroyer/dagger/blob/codegen-unittest/core/src/test/java/dagger/InjectionTest.java\nThe code as-is doesn't work (tests don't actually exercise the code, as the reflection backend doesn't use the contextClassLoader, which I haven't committed), but you get the idea.\nEach unit-test is run twice: once as-is (there's a ClassLoader that makes sure codegen classes are never used) and once with annotations processed (the classes to be processed that are needed by the test are listed in an annotation on the test method; and there's a classloader that fails the test in case a generated class is not found, to prevent a fallback to the reflection backend).\nThe TODOs about testing with \"javac\" are the cases where compilation is expected to fail, in this case we'd call a tool to process the classes and collect diagnostics that we can assert on.\nThe next step is to add the same thing with ECJ/JDT: each test would then run 3 times: reflection, javac, jdt.\n. On Thu, Oct 18, 2012 at 4:03 AM, Christian Edward Gruber wrote:\n\nOn 17 Oct 2012, at 21:32, Thomas Broyer wrote:\n\nI found that InjectionTest.GetInstanceOfArray fails with codegen:\nthe ModuleAdapter being generated doesn't compile (method return type\nfor the method binding's get() is Integer[] instead of int[]).\n\nHmm. How is this related to where the codegen is? It should generate\nthe same code, in whatever project. That's very strange. I didn't\nactually alter the code generation logic itself - just where it's\nlocated.\n\nNothing to do with where the codegen is, it's just that the unit-tests\ncurrently only exercise the reflection backend. Exercising the codegen\nbackend has 2 parts: making sure the generated code compiles, and making\nsure it runs. My take on it is to run the exact same unit-tests but with\nannotations processed. In the case of InjectionTest.GetInstanceOfArray,\nit happens that the generated code doesn't compile.\n. > However, as to the code-gen part, the project itself should be separate,\n\nelse people are bringing the code-gen tools in as part of their binary.\n\nHow about a secondary artifact for the same Maven project?\nI know it sounds like a Bad Practice\u2122 but it's not much different from what <packaging>ejb</packaging> does, and how Guice packages its no_aop variant (and BTW probably also how Protobuf should package its lite variant instead of using a profile)\nWe'd have com.squareup:dagger:jar for the runtime and com.squareup:dagger:jar:apt (apt or codegen) for the annotation processors (to be used as a dependency in the maven-compiler-plugin, and assumes com.squareup:dagger:jar is also on the classpath)\n. FYI: https://groups.google.com/d/msg/google-guice/qfOKyx02VkI/LAcHJZ-ZZbcJ\n. I've been looking at this and one issue I have is: where should we put the markers? For some errors it's obvious, but for others I'm not so sure.\n- Unexpected @Provides on [some method]:\n  on the method obviously\n- Classes declaring @Provides methods must not be private or abstract:\n  on the class obviously\n- @Provides methods must not be private, abstract or static:\n  on the method obviously\n- [some class] has @Provides methods but no @Module annotation:\n  on the class obviously\n- Unexpected value for include or Unexpected value [some value] in includes of [some type]:\n  ideally on the value itself, but on the module class could be enough (given how annotations are processed at code-gen, it's not that easy to find back the exact location of a value in an annotation; I suggest we add it later, maybe)\n- Duplicate binding for [some key]:\n  ideally one error on each @Provides method but it then pollutes the log (also, we currently report such an error as soon as we find a duplicate, if there's another we'll report the error separately, so we could easily end up with several duplicate binding markers on the same method; also I don't know how well it'd work with incremental builds if we report an error in a file that hasn't been changed/recompiled), so we can go with reporting the error only on the method that's been detected as a duplicate.\n- all the missing binding errors generated by linkAll():\n  should they be reported on the fields/constructor arguments that cannot be fulfilled? on the currently validated module? both? those two alternatives have drawbacks UX-wise.\nAny other error I'd missed?\nCc: @cgruber\n. Other errors I previously missed:\n- Code gen failed and Graph processing failed on IOException:\n  we can put them on the class\n- Could not find injection type required by [some types] and Could not find types required by provides methods for [some types]:\n  assuming the remaining types can be found again at the time we emit these errors (at processingOver()), we can attach the errors to the types. This means duplicating the error for each type though, which is bad UX if you read a build log. Given that it's about missing types, i.e. code that wouldn't compile anyway, then maybe we can skip those errors (i.e. let them as they are now, only visible in the Error Log view in Eclipse) and rely on the IDE to add its own markers for the missing types.\n- Too many injectable constructors on [some type]:\n  could be on the type, on each injectable constructor or on each injectable constructor but the first. We currently emit one error per extra injectable constructor; in this case, the error should probably ideally be on the annotation itself then.\n- Abstract class [some class] must not have an @Inject-annotated constructor.:\n  similar to the above.\n- Cannot inject [some member]\n  on the member, ideally on the annotation itself.\n. Ah, I deleted my comment as soon as I posted it but the notifications were apparently already sent ;-)\nI backed it up 'cause obviously you already have dagger-0.9.jar (yes, I mean 0.9) in your project's build path, so you shouldn't have to add it again in the factory path I guess. Just a guess though; I thought I'd better try it before making such claims.\n. This is because errors are reported without being attached to an \u201celement\u201d, so they only appear in the \u201cError Log\u201d view (which is hidden by default); see issue #110 \n. @cgruber I've successfully used m2e-apt in the past; haven't tried it with Dagger yet though. It also requires you to put dagger-compiler as a dependency of the compiler or processor plugin.\n@arichiardi you won't have error annotations in your code with 0.9.1 (see issue #110). The error you're seeing is probably due to some network/server error when retrieving the artifact, try forcing resolution (mvn -U or check the appropriate box in Eclipse when you Maven \u2192 Update project configuration\u2026)\n. @cgruber I'd swear I saw it work but now that I try it again on a small project, it actually doesn't even run the annotation processors! (tried with an Oracle JDK6 and OpenJDK7, with and without -Dmaven.compiler.fork; the dagger-compiler-0.9.1.jar never appears in the Command line options (when running mvn with -X`)). Auto-config of Eclipse with m2e-apt works fine though.\nActually, m2e-apt seems to work OK even with dagger-compiler as a project dependency ( optional or provided), as it simply enables annotation processing in Eclipse and puts the whole build path as the factory path (and configures the output to target/generated-sources/annotations). Annotation processor discovery from JDT/ADT does the rest to pick and run the annotation processors from Dagger.\n. @arichiardi with a recent 1.0-SNAPSHOT and m2e-apt (or manually configured annotation processing in Eclipse), you should have markers in the editor. It's not clear whether you're using m2e-apt or not (it would confirm, or not, my experience with m2e-apt).\n. @Steven-Mark-Ford Just tested in dagger-example and \u201cNo injectable members on \u2026\u201d are reported on the module class, but only if you somehow make Eclipse recompile the module (rebuild project, or edit/save the module). Similarly, errors don't go even after you fixed them, until Eclipse recompiles the module. But this is because the validation doesn't take place at all, so no error will be reported to the Error Log view either.\n(note: to make m2e-apt work in dagger-example, I had to Maven \u2192 Disable Workspace Resolution on the project)\n. @Steven-Mark-Ford with a recent self-built 1.0-SNAPSHOT?\n. On Thu, Feb 14, 2013 at 5:39 PM, Christian Edward Gruber wrote:\n\nOn 14 Feb 2013, at 9:02, Thomas Broyer wrote:\n\n(note: to make m2e-apt work in dagger-example, I had to Maven \u2192\nDisable Workspace Resolution on the project)\n\nOk\u2026 THAT seriously sucks. Thats one of my favorite m2e features.\n\nI suppose it's a limitation of Eclipse: you can only add JARs to the\nFactory Path, so there's no way m2e-apt would add dependent projects (at\nleast without mvn package-ing them, which you don't want it to do\nautomatically; so in the end, a manual mvn install is clearer, and you\nwon't break Eclipse with a mvn clean). I haven't tried re-enabling\nworkspace resolution after m2e-apt has configured the factory path, maybe\nit'd work, and thus only annotation processing would suffer from the\nsituation.\nWorkspace resolution works OK for most projects though, it's only an issue\nwhen you have dagger-compiler as a project in the same namespace. So\nbasically, it's mostly an issue for us people hacking on Dagger, not for\ndevelopers using Dagger in their projects.\n. @adennie Let everyone (maven-compiler-plugin and Eclipse) discover the annotation processors, i.e. don't specify them explicitly; the dependency should be enough (for m2e-apt at least)\n. I just hit this bug too while refactoring some code from Guice to Dagger.\nCompilation (with dagger-compiler) fails with:\nNo binding for members/com.example.xxx.Xxx required by com.example.xxx.Application.Module for com.example.xxx.Application.Module\nAs a workaround, I'll create a class that depends on Providers of my so-called entry points and add it as the single entryPoint.\n. Note that I've been using 0.9.1. Would be great to have an 0.9.2 some time soon BTW, be it for #110.\n. I'm a bit late but I'm wondering why protected constructors have been excluded here. How are they different from default-scoped constructor in this context?\nFor reference (because I had to double-check; you made me doubt):\n- http://en.wikibooks.org/wiki/Java_Programming/Keywords/protected4\n- http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html\n. Seems like it fixes issue #130, and thus somehow duplicates PR #131 \n. Oh, it didn't auto-close the issue :-(\nI suppose I should have written Fixes #110 rather than Fixes issue #110\n. @swankjesse You apparently merged #150 too quickly: it was missing the invoker.properties file telling the IT failure is expected.\n. I amended the last commit to change toString().equals() to contentEquals().\nTell me if you want me to rebase on top of #152 (or master once that PR is merged)\n. And sorry for the borked #150 \n. LGTM\n(note, we could replace a bunch of .getCanonicalName() too, and possibly use an import static to make everything more readable)\n. Only updated the copyright year.\n. I also noticed modules with no @Provides methods had no MethodAdapter generated, and had a change in the works. My approach however was rather to split ProvidesProcessor into a ModuleProcessor (@SupportedAnnotationTypes(\"dagger.Module\")) and ProvidesProcessor. ModuleProcessor would do almost all of what ProvidesProcessor currently does (generating the ModuleAdapters) and ProvidesProcessor would only validate the @Provides methods (are they static? abstract? private? within a non-static or private class? outside a @Module class?).\nWith your current approach, I'm afraid you won't generate a ModuleAdapter if the current round only contains @Modules with no @Provides method, because the processor wouldn't be triggered at all.\n. Possibly (probably). You have to change the process() method to return false though, or that would prevent the FullGraphProcessor from being triggered (unless it's moved above the ProvidesProcessor in the META-INF, and itself changed to return false)\n. Abstract class XXX must not have an @Inject-annotated constructor.\nSource: https://github.com/square/dagger/blob/6024e62af666dd798d4122c98773ba889ca2b7ba/compiler/src/main/java/dagger/internal/codegen/InjectProcessor.java#L169\n. Do we really want to somehow generate those no-op $InjectAdapters? If so, when should it be done? (which annotation processor? given that we're talking about a class that is not annotated)\nA quick workaround is to write the class by hand, which is real easy:\n``` java\nimport dagger.internal.Binding;\nimport dagger.internal.Keys;\npublic final class FrameworkClass$InjectAdapter extends Binding {\n  public FrameworkClass$InjectAdapter() {\n    super(null, Keys.getMemberKey(FrameworkClass.class), NOT_SINGLETON, FrameworkClass.class);\n  }\n}\n```\nThat's it!\nIt ties you to Dagger internals, but it's IMO an acceptable trade-off. We might want to provide a simple NullInjectAdapter to make it simpler and less dependent from Dagger internals:\n``` java\npackage dagger;\nimport dagger.internal.Binding;\nimport dagger.internal.Keys;\npublic abstract class NullInjectAdapter extends Binding {\n  protected NullInjectAdapter(Class type) {\n    super(null, Keys.getMemberKey(type), NOT_SINGLETON, type);\n  }\n}\n```\nThat way, one could easily make a dagger adapter artifact for a framework, that provides all those NullInjectAdapters.\nThat said, I quite like the @NoSuperInject or noBindingsNeeded proposals (with better names though). The former would remove the supertype binding from the generated $InjectAdapter, while the latter would generate an $InjectAdapter like the one above.\n. Er, using optional means that any project that wants to use dagger-compiler will have to add an explicit dependency (same a scope=provided), but the version declared in the optional dependency is taken into account when resolving the actual version to use.\nI'm fine with using scope=provided though; seems better than optional=true to me.\n. @jvanzyl it only contains annotation processors so it's really only needed at compile time. Ideally, it shouldn't affect dependency mediation in downstream modules.\nWith previous versions you could add it to the m-compiler-p dependencies (and that's what m2e-apt uses) but it no longer works with 3.0.\n. @jvanzyl I just re-tested (using dagger's samples/simple) with m-compiler-plugin 2.4, 2.5, 2.5.1 and 3.0 and confirm this is regression in 3.0. It works with forceJavacCompilerUse=true though, so its probably more an issue within plexus-compiler 2.x. Do you want me to file a bug? If so, to plexus-compiler or m-compiler-p?\n@cgruber using optional=true or provided=true should (theoretically) make any difference in output, as both dependencies are just put in the classpath when compiling. I did see source files emitted to target/classes in some earlier tests, but I can't remember the exact environment (e.g. JDK version, or whether I launched the build from M2E or the CLI, or version of the m-compiler-p) and conditions (where the dependency was deplared). And in my latest tests with m2e-apt (a few weeks ago), it didn't work with dagger-compiler as a project dependency (note: it worked if the pom had it in the m-compiler-p dependencies when imported into Eclipse or the projects were later updated from the pom, and then moved as a project dependency, because m2e-apt would have detected that it had some job to do and created a file in the .settings/, and that file was never deleted; using a new Maven module or deleting the .settings/ exhibited the issue: m2e-apt looks at m-compiler-p or m-processor-p dependencies only)\nBTW, dismiss my earlier comment about optional vs. provided making any difference in dependency mediation (version conflict resolution): it doesn't matter (from the wiki pages at codehaus).\n@JakeWharton @swankjesse if dagger-compiler is in your parent pom's dependencies then it indeed appears as a dependency in all your modules (that have the parent pom as a <parent>, or transitively as an ancestor), it's not a transitive dependency though.\n. @jvanzyl Done: http://jira.codehaus.org/browse/MCOMPILER-202\nThe sample is at https://github.com/square/dagger/tree/master/examples/simple (see detailed steps in issue report)\n. @cgruber Gaaahhh! Just tried again and confirm it just works (and now I read back my comments on issue #126 and see that it was already the case a month ago, sorry for the noise)\nSo, let's sum up:\n- the only issue with putting dagger-compiler as a dependency of the project (either optional or provided) rather than the maven-compiler-plugin is that it then takes part of dependency mediation in downstream projects, but that shouldn't be a problem in practice.\n- there's no practical difference between optional and provided (at least there shouldn't be; just tried again, with m-compiler-p 2.5 and OpenJDK 7u15, and confirm it doesn't make a difference; I remember I saw the same behavior that generated files ended in target/classes instead of target/generated-sources/annotations but cannot reproduce it \u2013tried m-compiler-p versions 2.3, 2.4, 2.5, 2.5.1 and 3.0, with OpenJDK 7u15, OpenJDK 6u27 and Oracle JDK 6u27; using Maven 3.0.4, and the latest master but changed optional to provided in the simple example), and they're both inappropriate at the theoretical level.\n- putting dagger-compiler as a dependency of the maven-compiler-plugin is the best choice, but doesn't work with the m-compiler-p 3.0 unless you forceJavacCompilerUse.\nTherefore, I'd rather oppose merging this PR and instead:\n- change the simple example (and integration tests) to use a m-compiler-p dependency.\n- add a note about the m-compiler-p:3.0 bug.\n. @cgruber How about a comment (both in the examples and website, possibly even in the integration tests):\n<!--\n   Uncomment below line if you use maven-compiler-plugin 3.0+\n   and `xxx$InjectAdapter` and `xxx$ModuleAdapter` are not generated.\n   See http://jira.codehaus.org/browse/MCOMPILER-202\n-->\n<!--\n  <forceJavacCompilerUse>true</forceJavacCompilerUse>\n-->\nAn alternative would be to use version 3.0 and have this:\n<!-- workaround for http://jira.codehaus.org/browse/MCOMPILER-202 -->\n<forceJavacCompilerUse>true</forceJavacCompilerUse>\nIf people aren't using 3.0 it'll do no harm (but I don't want to put this in the poms if we don't use 3.0, that'd be bogus)\n. It's already been reported as #177 \n. The javadoc says TypeKind.ERROR means that the type \u201ccould not be resolved.\u201d It probably means Gson is not in the classpath, or you're missing the import in a file (i.e. a compile error).\n. Modules are complete by default, that's why ServicesModule doesn't compile.\nYou have to put complete = false on ServicesModule (and you can safely remove the complete = true from GLarmModule)\n. We'll want to do a few changes to the code then:\n- Remove the TODO in ProvidesProcessor\n- Remove support for subclassing in ReflectiveModuleAdapter\n. Could it be that OSX's JDK does not have com.sun.tools.javac and, with forceJavacCompilerUse set to true, the m-c-p then forks a javac process? (could possibly be confirmed by running mvn -X package)\nJust ran mvn clean package -Dmaven.compiler.fork on Linux and confirm examples/simple/target/generated-sources/annotations/ is empty (i.e. annotation processing didn't run: no $ModuleAdapter class in target/classes either).\nLooks like #190 is actually only working as a side-effect of the in-process com.sun.tools.javac, so:\n- m2e-apt shouldn't suggest using plugin dependencies (they work for the maven-processor-plugin because that one explicitly takes them into account; see my comment in jbosstools/m2e-apt#14)\n- we should revert 2014bce8e79f7bdba4fcaa4f581e6189543ded00 and f784b96520d0a408ac76b5b187e7bb9dc5c32ff1 (and then choose whether to keep scope=provided or optional=true as a rule; i.e. what to do with #182)\n. Checked that it worked \"reliably\" by running with -Dmaven.compiler.fork and modifying the compiler/pom.xml to run the IT tests with the same property:\n<properties>\n   <maven.compiler.fork>true</maven.compiler.fork>\n</properties>\n. Website redeployed.\n. Works for me :(\nApache Maven 3.0.4 (r1232337; 2012-01-17 09:44:56+0100)\nMaven home: /home/tbr/bin/apache-maven-3.0.4\nJava version: 1.7.0_15, vendor: Oracle Corporation\nJava home: /usr/lib/jvm/java-7-openjdk-amd64/jre\nDefault locale: fr_FR, platform encoding: UTF-8\nOS name: \"linux\", version: \"3.5.0-25-generic\", arch: \"amd64\", family: \"unix\"\n(also tried with Oracle JDK 6u27)\nCould you post the (relevant) content from the build.log?\n. Ah yes, indeed. Looks like we had a race condition between pull-requests #196 and #198; that test probably doesn't run the annotation processor on your machine (#194)\n. LGTM, but I think raw types should probably be tested in the reflection backend (it's rather obvious they'll be ruled out in the codegen backend)\n@Provides Provider providesRawProvider() { return null; }\n. LGTM\nI'll let someone else do the merge though.\n. Re. why method injection isn't supported in Dagger: method injection is hard and has a lot of corner cases (contrary to fields and constructors, methods can be overridden, and the rules to determine whether a method is an override are not trivial)\nIf you look at the TCK for JSR 330, approximately half the tests are about method injection:\nhttps://code.google.com/p/atinject/source/browse/trunk/tck/org/atinject/tck/\n. I'm no Android expert but your sample project's stacktrace doesn't talk about Dagger a single time.\nLooks more like loading the application class from your AndroidManifest.xml and your ProGuard config obfuscating that class (you have rules about views and activities but none for applications)\n. When you plus(), the base graph links all the bindings (to later know which ones come from the base or the subgraph, and detect conflicts). The problem is that HomeActivity cannot actually be injected from the base graph as there's no binding for ComplexObject (so Dagger tries a JIT binding, and fails as the class is not injectable).\nSo you shouldn't have that injects = {HomeActivity.class} on the base graph: you know you have to plus() the graph with a module that provides ComplexObject and the base graph cannot inject HomeActivity, so why are you saying otherwise?\n. It has less to do with plus() that it has with complete = false. If you call validate() on your base graph, it'll explode in the exact same way: the issue is about not providing the binding for ComplexObject in the base graph while pretending (declaring) it can inject HomeActivity. Overall yes, you clearly need a good understanding of your graph, and that's why the annotation processor will generate a dot file at compile-time, but that only works for complete = true modules; as soon as you use complete = false on a module and do not includes it from a complete = true module, then you're on your own.\n. BTW: still happens in 1.2.0 too.\n. Oops! sorry, failed to test properly (changed version property in parent POM of my Maven project but the failing module wasn't actually using that property :-/ ).\nSo, to sum up: this failed in 1.1.0 but passes in 1.2.0.\n. You must have Dagger 0.9.1 in your classpath (note that because of the change in groupId, Maven's conflict mediation doesn't work, and you can then have both 0.9.1 and 1.0.0 in your classpath).\nIn 0.9.1, injects was called entryPoints, and library didn't exist.\n. @JakeWharton @cgruber How about http://www.clahub.com/ ? (or something similar, i.e. built on GitHub's Web Hooks and Status API)\n. This is a bug of the maven-compiler-plugin. Try updating to 3.0 or 3.1. See #218 \n. You actually need JavaWriter 1.x; 2.x is incompatible. See #278\n. It's not much about working \"in Eclipse\", but rather \"without managed dependencies\". If you use Maven for instance, m2e-apt can automatically configure Eclipse. And if you use (e.g.) Ant (without Ivy), then using JavaWriter 2.x will break your compilation too.\n. > Follow-up question that's possibly off-topic here: does Dagger 2 have this feature?\nAFAICT, Dagger 2 forbids nulls by default (this can be turned to a warning globally, or turned off on a case-by-case basis using @Nullable, but then the injection point must be annotated with @Nullable too).\nSee https://github.com/google/dagger/blob/dagger-2.9/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java#L249-L260 (see also other uses of nullableValidationKind()) and https://google.github.io/dagger/dagger-1-migration.html#nullability\nSee also https://groups.google.com/d/topic/dagger-discuss/F4hb8Qb51Es/discussion (the flag is still there in 2.9 though, more than a year later, but never documented \u2013 there was a pull request, but it got closed without merging). @swankjesse How about capitalizing on the annotation processor but instead run it as a post-processor? (javac -proc:only -cp target/classes example.MyModule example.MyInjectable example.MyInjected, or the equivalent in code with javax.tools.JavaCompiler, with the list of classes to process being fed by classpath scanning \u2013 e.g. with Scannotation or Reflections)\n. @cgruber You're putting too much faith in Maven: https://cwiki.apache.org/confluence/display/MAVEN/Incremental+Builds\nmaven-compiler-plugin 3.x handles the situation better than 2.5 but we're still not there yet (and I do believe Maven is broken by design in this respect, and is therefore unfixable).\nAFAICT, Ant's javac task and many others (I believe Gradle too) are similarly broken.\nOne issue, to begin with, is that they try to infer staleness at the file level (Foo.java is newer than Foo.class so it needs to be recompiled; this is fine, but the reverse is not always true, because Foo.java can depend on Bar.java that has changed \u2013the exact problem we're discussing here\u2013; SCons uses heuristics to infer those dependencies from the source file content, but it still have false negatives).\nThey consequently use the previously compiled classes in the compile classpath (and this includes classes that have sinced been removed from sources, and because of annotation processors, class post-processors and the way inner classes are compiled, there's not a one-to-one mapping between output files and source files so it's hard if not impossible to selectively delete class files). This also stems from the fact that Maven plugins all output to target/classes, overwriting existing files if needed, rather than each having its own output folder and then merging outputs together.\nLooking at the current state of affairs (trunk of maven-compiler-plugin and maven-shared-incremental), it seems like it doesn't take into account the module's dependencies (I find it really strange, I thought it'd be one of the first thing they'd fix); which is exactly what we're talking about here.\nAFAICT, the only Java-oriented build system that gets it right is Buck (and Blaze indeed I guess); notably because it handles staleness at the JAR level.\nThe issue for many projects is that Buck doesn't manage external dependencies other than at the file-level. Gerrit solved it with gen_rules that download jars from Central before using them as java_binaries; transitive dependencies and version conflict resolution still have to be manually handled.\nSee also http://blog.ltgt.net/in-quest-of-the-ultimate-build-tool\n. LGTM\nShould anyone else review before merge?\n. FYI, I published a Gradle plugin that automatically sets up IntelliJ IDEA and/or Eclipse (in addition to adding new configurations and automatically configuring JavaCompile tasks): https://github.com/tbroyer/gradle-apt-plugin\nFor IntelliJ IDEA, when using IntelliJ's built-in Gradle integration (rather than ./gradlew idea), there are a couple of manual steps to enable annotation processing in the IDE, but that's optional (for example if you regularly run ./gradlew assemble or ./gradlew compileJava)\n. Announced on Twitter, maybe a bit late to announce on G+, etc. WDYT?\n. The ActivityTitleController is not instantiated by Dagger, but by the ActivityModule; so it's not being injected by Dagger.\nYou'd have to either change ActivityModule so the provideTitleController receives a Foo and somehow passes it to the ActivityTitleController; or use a MembersInjector<ActivityTitleController> somewhere to inject the members of the  ActivityTitleController after it's been created (maybe it can be passed to provideTitleController, I have no idea if that'd work, or even if that's supposed to work)\n. Possibly a bug but, to begin with, you're also making a mistake: addsTo is saying you'll plus() the module in a child graph (so, wrt validation, the module can be complete when taking into account the dependencies provided by the - complete - parent graph), but you're actually including it in the same graph as the \"parent\" module (and if it depends on objects provided by it, then it's not complete)\n. Without introducing a third module providing the things that both ModuleA and ModuleB depend on (so that third module could be a library=true, and ModuleA and ModuleB could be independent from one another, or possibly one including the other, and library=false, or at least complete=true), no, and library=true,complete=false is the way to go (I'd then remove the inclusion and introduce a third module that includes both ModuleA and ModuleB and can be library=false,complete=true).\n. You seem to be confusing includes and addsTo (that said, maybe the sample needs a few changes).\nAs such, ApplicationModule is not able to inject MainActivity because it doesn't provides NavigationController, yet you create an ObjectGraph with just that module, so it shouldn't declare injects=MainActivity.class.\nAnd you put complete=false to make the compile-time validation pass (complete=false means the module cannot fulfill all dependencies and thus should be used in conjunction with another module when creating the ObjectGraph so that the ObjectGraph is complete); you shouldn't use complete=false in this case; as a rule of thumb, you should use complete=false if you create an ObjectGraph with that module only.\nYou plus() the ActivityModule to the ApplicationModule-graph, so ActivityModule shouldn't includes=ApplicationModule.class but rather say that it addsTo=ApplicationModule.class (I suppose you added the includes to make the compile-time validation pass, but includes is more than just about validation, contrary to addsTo).\nAnd ActivityModule is the one that can inject MainActivity so that's where injects=MainActivity.class should be.\nFixing your issue should thus be as easy as moving the injects=MainActivity.class to the ActivityModule and replace the includes with an addsTo; and you can also remove the complete=false from ApplicationModule.\nSee also #370 about addsTo and includes.\n. We identified this in #372 already\n. Hmm, if Guava is provided, it means that I have to explicitly add Guava as a dependency (as provided or optional if I don't use it myself) when I add dagger-compiler; right?\n(I really wish Maven \u2013the maven-compiler-plugin\u2013 had a way to declare/resolve dependencies for the -processorpath of javac; http://jira.codehaus.org/browse/MCOMPILER-134)\n. Looks like #177 \n. I think the problem is that you declare your interface in @Module(injects=) but you never bind an implementation without @Named. Trim your injects= and it should work.\n. Other examples where you'd probably use unqualified java.* classes: java.time.Clock, java.nio.file.FileSystem; basically when you'd expect the default implementation at runtime, but mock/stub/fake it in tests.\nI like the java.lang.* rule, but maybe we could add collections: either special-casing java.util.Map and anything that is or extends java.util.Iterator, java.util.Iterable or java.util.Enumeration; or every class/interface in java.* (or maybe just java.util.*) that is generic. \u2026when all type parameters qualify as well as errors.\n. You basically have two options (which are not dagger-specific):\n- if the type with someMethod is managed by Dagger, then inject providers of those 2 flavors and choose the one to get() from depending on the value of type\n``` java\n@Inject @Named(\"1\") Provider presenter1Provider;\n@Inject @Named(\"2\") Provider presenter2Provider;\npublic void someMethod() {\n   SomePresenter presenter = / use presenter1Provider or presenter2Provider /.get();\n}\n``\n- otherwise, create theObjectGraphwith different modules depending on the value oftype; those modules will provideSomePresenterwithout qualifier so you can useobjectGraph.get(SomePresenter.class). Dagger itself doesn't decide where the generated files go, it's left to the Java compiler. Your toolchain might not be passing the appropriate arguments to the Java compiler though.\n. @christopherperry Theprovidedscope is almost equivalent totrue`, the thing being that the dependency is not transitive.\nBut the root of the issue is that Maven has no real support for annotation processors, so you have to include your annotation processor dependencies as project dependencies, but just make sure they're not transitive (or for a WAR or similar, that they won't be packaged in the generated artifact). As a consequence, dependency resolution takes into account the transitive dependencies of your annotation processors (and their versions). This can be a problem, but you'll have to blame Maven for it. There are workarounds (see MCOMPILER-202, or the maven-processor-plugin), but because they'll merge the plugin dependencies with the project dependencies, you could still have conflicts (but at least you'd exclude the annotation processor dependencies from your project dependencies so you're sure no one will erroneously use them \u2013 and no, @cgruber, the IDE is right here).\nAs @JakeWharton said, this is less of an issue in other build tools where you can cleanly separate out annotation processor dependencies from project dependencies, but I'm not aware of a single Maven plugin that would use the -processorpath (see (MCOMPILER-134)[http://jira.codehaus.org/browse/MCOMPILER-134)). But even then, you could still have dependency conflicts between annotation processors; so yes, ideally, annotation processors should be dependency-free or should jarjar/shade their dependencies to avoid conflicts.\n. @cgruber I quickly looked at the generator code (in cgruber/dagger:fix2, which doesn't build BTW), and it would seem quite easy to handle the default constructor case (refactor InjectProcessingStep a bit to call ProvisionBinding.Factory.forNoArgsConstructor when there's no @Inject-annotated constructor, it would a priori not complicate the code substantially); so I must ask: what's the rationale for the deviation from spec?\nIf you really want it, then maybe, at the cost of a small additional complexity, there could be a option to turn it on; e.g. call javac with -Adagger.requireInjectConstructor to suppress the generation of the ProvisionBinding for default constructors.\nIn case that behavior is adopted, would the following work as a workaround:\njava\n@Provides CoffeeMaker provideCoffeeMaker(MembersInjector<CoffeeMaker> membersInjector) {\n  CoffeeMaker coffeeMaker = new CoffeeMaker();\n  membersInjector.injectMembers(coffeeMaker);\n  return coffeeMaker;\n}\n. OK @gk5885, I think you convinced me ;-) (the bit about parent classes)\n. You might have to uncheck Enable processing in editor in the project settings' Java\u2192Compiler\u2192Annotation Processing and/or disable incremental builds.\nAFAICT, this is a bug in Eclipse JDT-APT, not in Dagger proper.\n. The doc is no different from ObjectGraph.create(Object...), and the behavior is similar too.\nI do agree though that the doc could be better by explicitly mentioning you can pass a mix of classes and instances. But note that Dagger 2 is nearly there and that kind of API has been removed there.\n. Almost: because there can't be more than one module instance for a given module class, you can actually reference a class in includes (for graph validation at compile-time) but actually provide an instance of that class at runtime.\n``` java\n@Module(includes=ModuleB.class)\nclass ModuleA { / \u2026 / }\n@Module(includes=ModuleC.class)\nclass ModuleB { / \u2026 / }\n@Module\nclass ModuleC {\n  ModuleC(SomeObject whatever) { / \u2026 / }\n}\nObjectGraph graph = ObjectGraph.create(ModuleA.class, new ModuleC(someObject));\n```\n(note: I used ObjectGraph.create() here, it works exactly the same for ObjectGraph#plus())\nAnother approach would be to have all modules have complete=false and require that you provide another module to Object.create() or ObjectGraph#plus() that provides the missing dependency; or if ModuleC is only providing SomeObject, remove it from the includes.\n``` java\n@Module(includes=ModuleB.class, complete=false)\nclass ModuleA { / \u2026 / }\n@Module(complete=false)\nclass ModuleB { / \u2026 requires SomeObject \u2026 / }\n@Module(library=true)\nclass ModuleC {\n  ModuleC(SomeObject whatever) { / \u2026 provides SomeObject \u2026 / }\n}\nObjectGraph graph = ObjectGraph.create(ModuleA.class, new ModuleC(someObject));\n```\n\nYou could even have modules that have a no-arg constructor and have other constuctors, and decide at runtime whether you provide an instance (using whichever constructor you want) or not (letting Dagger instantiate it with its no-arg constructor). I wouldn't really recommend it, but that would work.\n``` java\n@Module\nclass SomeModule {\n  SomeModule() {\n    this(\"some default value\");\n  }\nSomeModule(String someValue) { / \u2026 / }\n}\n``\n.includesis used both for graph validation at compile-time, and at runtime: notice how I didn't provideModuleB`.\nThe best coding practice IMO is to try to move all provided values to the top-most module, and use complete=false for modules deeper in the hierarchy:\n``` java\n@Module(includes=ModuleB.class, complete=false)\nclass ModuleA { / \u2026 / }\n@Module(complete=false)\nclass ModuleB { / \u2026 requires SomeObject \u2026 / }\n@Module(includes=ModuleA.class)\nclass ModuleC {\n  ModuleC(SomeObject whatever) { / \u2026 provides SomeObject \u2026 / }\n}\nObjectGraph graph = ObjectGraph.create(new ModuleC(someObject));\n```\nNote that compared to the previous sample, ModuleC now includes ModuleA. That way ModuleC is complete and the whole graph can be validated at compile time.\n. Yes.\nIt'll throw an UnsupportedOperationException with message \"No no-args constructor on ModuleC\": https://github.com/square/dagger/blob/65573a5680e6e170b62aed573ec1672139e48fcf/core/src/main/java/dagger/internal/ModuleAdapter.java#L58\n. You have to be explicit:\n```\n    @Singleton\n    public RFXComService provideRFXComService() {\n        return new RFXComService();\n    }\n@Provides(type = Provides.Type.SET)\npublic BusAware rfxComServiceAsBusAware(RFXComService b) {\n    return o;\n}\n\n@Provides(type = Provides.Type.SET)\npublic Handler rfxComServiceAsHandler(RFXComService b) {\n    return o;\n}\n\n``\n. 1.2.3-SNAPSHOT is the current version atmaster, so either do anmvn installat the root of your Git clone, or usemvn -pl examples/simple -am package(usingpackage` here as an example goal). That said running Maven at the root of the Git clone will build the example as part of the reactor/multi-module build.\nThat said, by total chance, you're right there was a problem uploading the dagger-compiler during the last build: https://travis-ci.org/square/dagger/builds/87551853#L1484 (but it's a snapshot so mvnrepository wouldn't show it anyway)\n. @JakeWharton This is about auto-common, not Guava; but that doesn't change your answer: Dagger 1 doesn't use auto-common.\n. @swankjesse I think you mixed up projects \ud83d\ude0b\n. You're on the wrong issue tracker; see https://github.com/google/dagger for Dagger 2.. Wrong issue tracker then; see https://github.com/google/dagger. You mean processing @Inject static fields in InjectProcessor to generate such an injectStatics method (there would actually need to be 2 methods \u2013attach and inject\u2013 and a bunch of fields to store the bindings between these two phases), and simply call it/them from the ModuleAdapter generated by the ProducesProcessor?\nThe issue is that, if we don't want to refactor the whole static injection stuff, we'd have to have instances of StaticInjection lying around that StaticInjection.get(Class) could return, so it's transparent from the ObjectGraph and Linker points of view.\nI guess we could make all generated $InjectAdapter classes implement a StaticInjection interface and have the Linker look it up by requesting a binding for the class to be injected and then casting it (falling back to reflection if the returned binding is not assignable to StaticInjection) but I'm afraid it would complicate the code a bit too much (in readability, mostly). I can try that if you like though.\n\nI want to limit the number of generated classes!\n\nHopefully there shouldn't be that much classes requiring static injection ;-)\nIt's probably a trade-off between using reflection (a bit slower at runtime) or codegen (slightly bigger artifacts). I have absolutely no idea what could be better in practice (particularly on Android).\n. You mean the JavaWriter? Awesome!\n. Character.toUpperCase is locale-agnostic (contrary to String.toUpperCase), and FWIW it's what Introspector.decapitalize uses (actually isUpperCase and toLowerCase)\n. Could there be an option (SupportedOptions) to turn it on/off?\n. Alternately, you can declare it as a dependency of the maven-compiler-plugin. It has the advantage of playing well with m2e-apt to auto-configure annotation processing in Eclipse.\nSee https://community.jboss.org/en/tools/blog/2012/05/20/annotation-processing-support-in-m2e-or-m2e-apt-100-is-out\n. Dagger.draw()?\n(OK, I sheath this pun for good now ;-) )\n. > > The directory name is extension-graph. Shouldn't that match the artifactId ?\n\nTypical but not actually a requirement.  And not universal, else dagger would have to be dagger-core.\n\nJust a FYI: http://www.sonatype.com/people/2011/01/maven-tip-project-directories-and-artifact-ids/\n. Oh, just noticed contentEquals(), would be even better: http://docs.oracle.com/javase/7/docs/api/javax/lang/model/element/Name.html#contentEquals(java.lang.CharSequence)\n. It's not. The ProvidesProcessor rules out any throws clause, whether the exceptions are checked or unchecked. Do you want me to change this test to use an unchecked exception?\n. error() is not a varargs, and all other error reporting in the same method (e.g. @Provides methods must not be private, abstract or static) use concatenation.\nI know Christian started reworking error reporting, and I have something in the works too which uses varargs; so we should probably change everything at once then.\n. Er, throws IllegalArgumentException will cause a @Provides methods must not have throws clause error.\nWhat matters most here IMO is that checked exceptions cause generated code to fail compilation later (unhandled exception for the get() or injectMembers() of the generated Binding), whereas it's not a problem for a throws with an unchecked exception.\nWe could test both cases, but is it worth it? (the assumption here is that there's no real value in ruling out unchecked exceptions, but it's not worth the hassle to allow them; so we reject them, on the other assumption that Modules are special-enough beasts that developers have near-total control on them and can easily remove such offending-though-harmless throws clauses).\n. No problem; I had to double-check too on my side ;-)\n. One thing I'm not comfortable about: testing both cases would mean differentiating the errors in the verify.bsh script, so we'd be reyling on the toString() implementation for the ExecutableElement, which is not specified.\nWith that single test as we have here:\n- we're testing the case that's harmful\n- we can simply test for the presence of the error message in the log, assuming there's no other @Provides method that could trigger the error (which I believe is a valid assumption; if it were not, we'd have bigger problems than a false-positive test!)\n. Yes, it's the default: http://maven.apache.org/ref/3.0.4/maven-model/apidocs/org/apache/maven/model/Parent.html#getRelativePath(), and for ages: http://maven.apache.org/ref/2.2.1/maven-model/apidocs/org/apache/maven/model/Parent.html#getRelativePath()\n. Oops! fixed\n. Well, see discussion in #182: either we use m-compiler-p and we need the workaround, or we stick to a previous version and we should then explain why it doesn't work with 3.0 if we don't want people to file bug reports.\n. Should the class be renamed as ModuleTest as this is no longer only testing for @Module(includes=\u2026)?\n. Le 12 avr. 2013 07:00, \"Christian Edward Gruber\" notifications@github.com\na \u00e9crit :\n\nIn core/src/main/java/dagger/Module.java:\n\n@@ -60,4 +60,5 @@\n    */\n   boolean complete() default true;\n-  boolean library() default false;\n\nCan I get some more information on what library() is for? I didn't see a\ndiscussion about it, and it's a very clear addition to our public API.\n\nWell, with this change, Dagger now fails the build if you have a\n@Provides that's not used in the graph, so library is a mean to disable\nthat extra validation.\nI wonder what the difference with complete is though (well, complete is\nmore about missing provides methods, but is there a need for that new\nlibrary?)\n. This should probably use typeUtils.isSameType(). See javadoc: http://docs.oracle.com/javase/7/docs/api/javax/lang/model/type/TypeMirror.html#equals(java.lang.Object)\n. Why is this using isAssignable vs. isSameType?\n. How about raw types? Will they fail later?\n. nit (but as the test fails\u2026): should it be LazyProvidesModule? or should the other be ProvideProvideModule (without the s)?\n. Ha, I was actually commenting on the previous patch ;-)\n. IIRC, the compiler validates (or at least reports errors for) the annotations' @Target after the annotation processors are called; so how about just ignoring annotations that we don't know how to handle and let the compiler report the error later on?\n. Shouldn't this be a break?\n. Maybe we could use Provider.class.getCanonicalName() and Lazy.class.getCanonicalName()?\n(maybe a bit less readable but I like strong-typing)\n. Sure but we're in the\nfor (String invalidTypeName : Arrays.asList(\"javax.inject.Provider\",\n\"dagger.Lazy\"))\nloop; not the one that loops over the methods.\n. Missing a break (no need to look at Lazy if the method's return type is Provider)\nI wonder if a labeled continue wouldn't be more (or as much) readable:\nloopOverProvidesMethods:\nfor (Element providerMethod : providesMethods(env)) {\n  \u2026\n  for (String invalidTypeName : \u2026) {\n    if (\u2026) {\n      error(\u2026);\n      continue loopOverProvidesMethod;\n    }\n  }\n  \u2026\n}\n. Haven't tried it, but label should be just before the loop according to: http://docs.oracle.com/javase/tutorial/java/nutsandbolts/branch.html\n\nA labeled continue statement skips the current iteration of an outer loop marked with the given label.\n. +1 to module loop, and add a ProvidesValidatorProcessor for the error of provides methods outside modules.\n. @cgruber Gradle has configurations that work almost the same as Maven scopes. There's nothing equivalent to provided by default, but it's easy to make (add a new configuration, and configure JavaCompile tasks to use both compile and provided in the classpath \u2013too bad there's no processor path\u2013), or you could just use the plugin from SpringSource, that does exactly that, in a packaged and automated way: https://github.com/spring-projects/gradle-plugins/tree/master/propdeps-plugin\n. Not sure the error message is meaningful here; won't it always be Type <any> missing.?\n. DISCLAIMER: none of this has been tested with an Android build.\n\nAs I said, you could use SpringSource's propdeps-plugin to bring provided and optional configurations (and use either one for dagger-compiler), or you could (untested) use something like that:\ngroovy\nconfigurations {\n  apt\n}\ndependencies {\n  apt \"com.squareup.dagger:dagger-compiler:$daggerVersion\"\n}\ntasks.withType(JavaCompile).each { task ->\n  task.classpath.add(configurations.apt)\n}\nor (this is what the propdeps-plugin does, more or less)\ngroovy\nconfigurations {\n  apt\n}\ndependencies {\n  apt \"com.squareup.dagger:dagger-compiler:$daggerVersion\"\n}\n// XXX: I don't know if there's a way to address all source sets\nsourceSets.main.java.compileClasspath += configurations.apt\nor\ngroovy\nconfigurations {\n  apt\n}\ndependencies {\n  apt \"com.squareup.dagger:dagger-compiler:$daggerVersion\"\n}\ntasks.withType(JavaCompile).each { task ->\n  task.options.compilerArgs += [ '-processorpath', configurations.apt.asPath ]\n}\n(see also http://stackoverflow.com/a/18687395/116472 and http://stackoverflow.com/a/17999249/116472 \u2013they add a -s flag to javac for better integration with Android Studio, IIUC\u2013, and the gradle-androidannotations-plugin)\n. Shouldn't there be build/ too?\n. How about using latest.release instead of hard-coded versions?\n. Those 2 lines are identical\n. The problem is that provided doesn't exist with the java plugin alone. The real scope you'd want is apt (or some similar name) that would configure javac's processorpath, and that requires either a plugin (e.g. android-apt) or a few lines of Groovy.\n. ",
    "stephenh": "@tbroyer I've used the JavaCompiler approach for testing non-trivial processors ([1] and [2]) and didn't figure out how to also run them with the Eclipse implementation of APT.\nI'm not sure what dagger's approach to Eclipse is going to be (e.g. defer to m2e integration or configure Eclipse to directly run the processor, e.g. on file save?), but if Eclipse is running the processor directly, there are annoying differences/bugs between the javac and ecj implementations, such that relying on unit tests of javac via the ToolsProvider probably wouldn't be sufficient to ensure it also works in Eclipse. Which sucks.\nAlso, for debugging processors, AFAIK the approaches are also different: for javac you can use ToolsProvider in unit tests and it will hit the debug points. But for eclipse, you need to use the Eclipse Plugin development stuff to \"Debug as Eclipse\", and start a separate Eclipse instance/workspace, then as you type/hit-save in the separate Eclipse instance, your processor debug points in the original Eclipse instance get hit.\nBoth work really well once you have them setup, but it is annoying that they are different, not just to run, but also for the code they put under test (e.g. ToolsProvider works for unit tests, but Eclipse requires a separate \"example\" project/workspace).\nSo, in my experience anyway, where I want processors that run well in Eclipse, I wasn't able to rely on ToolsProvider-based unit tests, and instead just have a large \"example\" project for each processor where I add integration-level tests.\nPerhaps dagger is different though; I haven't had a chance to really look at/play with the project to get a feel for what a good Eclipse setup would be, so I'm just relating my prior experience. YMMV.\n[1] https://github.com/stephenh/bindgen/blob/master/processor/src/test/java/org/bindgen/processor/AbstractBindgenTestCase.java\n[2] https://github.com/stephenh/bindgen/blob/master/processor/src/test/java/org/bindgen/processor/AccessTest.java\n. > I'm going to be building an eclipse plugin that pulls the code-gen \nJust curious, but is there something specific you'll be getting by\nbuilding an Eclipse plugin?\nI've had fine luck with running processors directly in vanilla Eclipse,\nand seems like the APT API is nicer/easier to use than a full Eclipse\nplugin.\n. > There's not just annotation pre-processing involved, but also other \n\nthings like a graph validation pass, etc.\n\nSeems like one of the processors I wrote cached data across\ninvocations; so even when Eclipse/javac called it incrementally with\n\"units 1 and 2 changed\", it would have cached the info for the other\nunits it had previously generated, so could re-apply program-wide type\nlogic on each incremental pass.\nUnfortunately I forget the details...so, sorry, I'm not being very\nhelpful, just musing that it seems possible.\n. As popular as annotation processors are these days (see dagger, auto value, etc.) perhaps some kind soul (or team of kind souls at Google/Square) could fix what I believe is the core underlying issue:\nhttps://bugs.eclipse.org/bugs/show_bug.cgi?id=280542\nAFAIK this would mean that however dagger/autovalue/& friends got on the Eclipse classpath (whether manually, or via a Maven classpath container, or via a Gradle classpath container, etc.) that Eclipse would automatically run them. Just like javac.\n. FWIW back in 2009/2010 I submitted several bugs (NPEs/etc.) in Eclipse's APT support and they were pretty responsive. (As responsive as waiting for the next Eclipse release can be anyway.)\nWalter Harley, who wrote the initial Eclipse APT support while working at BEA, was especially helpful, although since BEA defunded their Eclipse work, he was just watching the bug tracker as a hobby.\nI have no idea if Walter is interested in Eclipse/APT anymore, but I'd love to see someone fund him (or someone like him) to fix this bug. I would personally chip in to that effort, as that Eclipse APT bug is basically the sole reason I'm loathe to write annotation processors anymore, and almost always pick a different means of code generation. \n. Another lurker comment, but I think JavaWriter makes a lot of sense; using a DSL for emitting Java source code is much more sane than a template-based approach.\nFWIW, I've done the same sort of thing, and have a reusable \"sourcegen\" DSL, hidden within this joist-util project. You can see some of the unit tests here:\nhttps://github.com/stephenh/joist/tree/master/util/src/test/java/joist/sourcegen\nhttps://github.com/stephenh/joist/blob/master/util/src/test/java/joist/sourcegen/GClassTest.java\nIt's very similar to JavaWriter, although instead of each method call immediately calling \"out.write\", it buffers the fields/methods/etc. as data structures, and then outputs them in a final \"toCode\" pass. This means you can do things out of order, like later add new imports, annotations, etc.\nWhich, depending on how complex your processor is, can sometimes be useful to have your processor code organized logically rather than solely on the physical order of the resulting Java code.\nAnyway, YMMV, and definitely under you don't want to pull in a dependency, even with jarjar'ing, unless you really need it.\nHopefully I'll eventually do more than just lurk, as I've done a bit with APT over the years, and think it can be pretty neat applied to problems like this, I just haven't had the time yet. Great stuff!\n. ",
    "dnkoutso": "@JakeWharton LGTM, I can merge if you want, unless @swankjesse has objections.\n. ",
    "buildhive": "Square \u00bb dagger #6 FAILURE\nLooks like there's a problem with this pull request\n(what's this?)\n. Square \u00bb dagger #7 UNSTABLE\nLooks like there's a problem with this pull request\n(what's this?)\n. Square \u00bb dagger #4 UNSTABLE\nLooks like there's a problem with this pull request\n(what's this?)\n. ",
    "crazybob": "Looks great. Is the bit arithmetic necessary? It trades off memory for CPU perf. Seems like CPU perf would be more desirable.\n. We'll validate at compile time, right? Users shouldn't have to opt into this kind of validation.\n. Exciting!\nI'd also consider Dagger.poke(). Just kidding. ;-)\n. I might call it \"injects=...\" The doc is \"explicitly declares types this\nmodule is capable of injecting.\"\nBob\nOn Mar 26, 2013 9:06 PM, \"Jesse Wilson\" notifications@github.com wrote:\n\nI don't think graphNodes covers the current behavior because every\ndependency in a node in the graph.\nIt may help to consider the definition & purpose of entry point. An entry\npoint is a type that is a legal argument to ObjectGraph.get() or\nObjectGraph.inject(). We require these to be explicitly registered so\nthat the entire graph can be known statically; otherwise types defined in\n@Provides modules is known statically but other types need to be created\nat runtime. Like Guice's JIT bindings.\nEven if a node is not a graph root, we require an entry point for it if\nit's used in the two methods because otherwise code changes will have\nnon-local effects. Removing a dependency may implicitly drop a node or\nseries of nodes from the graph.\nOne other word that comes to mind is bootstrap. That's because the\nprocess of requesting injection from the object graph is a form of\nbootstrapping the application. For Android apps we need to do this in every\nmodule, but for most applications it should only happen in the main class.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/154#issuecomment-15503308\n.\n. \n",
    "kryali": "https://github.com/square/dagger/pull/81 happy now @JakeWharton \n. @swankjesse \n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary:\n[INFO]\n[INFO] Dagger (Parent) ................................... SUCCESS [1.581s]\n[INFO] Dagger ............................................ SUCCESS [6.293s]\n[INFO] Dagger Compiler ................................... SUCCESS [1:06.895s]\n[INFO] Dagger Example (Parent) ........................... SUCCESS [0.014s]\n[INFO] Dagger Example - Simple ........................... SUCCESS [1.246s]\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 1:16.262s\n[INFO] Finished at: Wed Apr 24 18:01:35 PDT 2013\n[INFO] Final Memory: 19M/81M\n[INFO] ------------------------------------------------------------------------\n. nice!\n. super cool :+1: \n. should probably revert this\n. what offending method?\n. hm good point, how about unecessary -> unused\n. good catch, got some eagle eyes\n. ",
    "mecid": "Thanks man! \n. ",
    "staxgr": "I wrote the something exactly the same as the first suggestion from Jake a few months ago. It's just a couple of lines, feel free to copy it https://github.com/staxgr/ViewInject/blob/master/src/se/tap2/viewinject\n. @macsux Did you find a solution to your problem, I'm having sort sort the same?\n. For anyone interested...\nThis is how you get dagger to run without maven with a (simple) eclipse setup\n1. Create a directory compile-libs next to your libs directory.\n2. Put dagger-compiler-.jar in this directory. \n3. Put dagger-.jar and javax.inject.jar (get it from here: http://code.google.com/p/atinject/downloads/list ) in your libs directory.\n4. Put dagger-.jar and javax.inject.jar on your buildpath.\n5. Goto Project->Properties->Java Compiler-> and check \"Enable project specific settings\". AND Goto Project->->Properties->Java Compiler->Factory path and check \"Enable project specific settings\"\n6. Under Factory path Click add JARs and add dagger-compiler-.jar, dagger-.jar and javax.inject.jar\nUpdate!\nMake sure you have \".apt_generated\" as a source folder on your build path.\nClean and rebuild project and you should be good to go!\n. Hmm, I'm not sure if I could see compile errors (guess you mean if you have\nunresolved dependencies and such) either. I was happy once I got it to\nwork... (don't have my environment here so I can test unfortunately)\nOn Mon, Jan 14, 2013 at 9:59 PM, Steven-Mark-Ford\nnotifications@github.comwrote:\n\n@cgruber https://github.com/cgruber I followed staxgr example on\nsetting up annotation processing in eclipse and I have defined a module but\nI still don't see any compile errors. Where would they appear within\neclipse? In the \"Problems\" window?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/126#issuecomment-12219258.\n. \n",
    "christopherperry": "@JakeWharton Wouldn't doing something like this violate one of the main reasons for using Dagger (avoiding the use of reflection in favor of compile time annotation processing)? I know casting the findViewById calls sucks, but your workaround is palatable in comparison.\n. @JakeWharton I understand that, I'm just pointing out that what staxgr wrote is not the approach one would want to take when using Dagger because it doesn't do code-gen, it uses reflection.\n. @JakeWharton Domo arigato Sensei.\n. The wrapper is a bit nice, I like not having to cast all my Views, it really cleans up my Activity/Fragment classes (but like you said, this has nothing to do with injection). \nThe list of Provided Injections is what I'm ultimately after.   Really we'd be providing a default Module.\n\nEdit -\nYou say there's already an Android module provided?\n. Does it construct all the providers that give the same provided injections as Roboguice?\n. Ok, since it obviously doesn't belong in this project I'll start another project. Any naming suggestions? robo-dagger? dagger-android?\n. @cgruber I see what you did there. I might just use that one.\n. If you two don't mind, I'd like to tackle the task. I'll get to it in a few days.\n. I'm not planning on implementing view injection, just a nice Android sample with a module that binds the service classes. \n. Just forked and tried to build, and Maven won't resolve the maven-release-plugin. I tried mvn -U clean install, and nothing.\n\nEdit: In case anyone else runs into this problem, the problem seems to have been the version of Maven I was using. I was using v3.0.3, and there's a note in the documentation for the plugin that says you have to use v3.0.4. I upgraded, and tried again and it resolved the plugin.\n. I'm only including android dependencies available on Central, so we don't have to involve the maven-android-sdk-deployer.\n. @JakeWharton I started working on this in my fork. Can you think of what you'd like in the example? I just created an Application class to store a static reference to the object graph and provided a static method on it as Jake suggested above. I'm injected a few things in an Activity, and also a Fragment trying to show a few different usages of modules (i.e. complete vs incomplete). I'm not sure how in depth you want this because it's supposed to be just an example. \nAlso, does a larger object graph increase startup time?\n. @swankjesse No issue, but I did do some work on a demo. Wondering why nobody responded to my questions in this thread.\n. Well, I didn't write any wrapper classes to provide any 'View injection' behavior but I did write some example code on how to use Dagger with Android on my fork. Perhaps take a look and provide some feedback as to whether or not the example I provide is sufficient for a pull request?\n. So no Android example then?\n. I would think since you guys are advertising (it's very prominent on the website, and the Readme) this as a dependency injection library for Android and Java (in that order) that there would be an Android example with the library. \n. You only run into this problem where you aren't doing proper dependency injection (passing dependencies via constructor). If you are testing your class in isolation, and passing all dependencies in your constructor then you have zero need for dagger to be involved at all in your test class.\nSometimes though, it's unavoidable because you don't have control over the creation of the class (i.e. you can't provide your own constructor to do proper DI). Activity, Fragment, Service, View, etc are all problematic in this way, so these are really the only classes where you are forced into using field injection and Dagger in your test class.\n. @cgruber That's exactly what I'm doing, and I've got something that hooks into the Activity/Fragment creation process to allow me to define mocked behaviors at the right time (I'm using Robolectric.buildActivity().create().etc().etc() to start my Activities in test, which presents timing issues for defining mocked behaviors for things that run in onCreate() etc). I could share if you guys would like, I'm open to comments/suggestions.\n. This is happening to me. Not sure what I'm doing wrong. Not using ProGuard. I think the reporting is still crappy as I had to step through Dagger with the debugger until I found where the exception was being thrown.\n. @JakeWharton Which way has been used to greater success? I'd like to make sure I'm not bloating my unit tests to set up stuff, and since I'm using field injection (on Views) it forces Dagger into the mix which I'm really not digging. Not sure I have much choice otherwise as passing dependencies in a method would force me to inject them outside the View and pass them in which sort of sucks as well.\n. That's a good one.\n. Guava is still on the classpath, even when using provided scope. This is a problem for development, as we don't want devs accidentally using anything from Guava since it bloats our application.\nI think the suggested usage is partially wrong (and partially correct):\nxml\n<dependency>\n  <groupId>com.squareup.dagger</groupId>\n  <artifactId>dagger-compiler</artifactId>\n  <version>1.2.1</version>\n  <optional>true</optional>\n</dependency>\nis the suggested usage. But this has no effect on the project that includes this dependency. Per the maven documentation: \n\nProject-A -> Project-B\n\nThe diagram above says that Project-A depends on Project-B. When A declares B as an optional dependency in its POM, this relationship remains unchanged. Its just like a normal build where Project-B will be added in its classpath.\n\nProject-X -> Project-A\n\nBut when another project(Project-X) declares Project-A as a dependency in its POM, the optional dependency takes effect. You'll notice that Project-B is not included in the classpath of Project-X; you will need to declare it directly in your POM in order for B to be included in X's classpath.\n\n\nThe problem is, in the pom for the dagger-compiler guava is not listed as optional so it is included in the project that uses it. It should be listed as optional in it's pom.\n. @cgruber If it's a maven thing, one more reason to switch to Gradle. So the recommended approach for Maven is to use the default compile scope, and not provided? It doesn't seem to make a difference as to the inclusion of Guava on the classpath. Wouldn't this be better as a plugin instead of a dependency?\n. @cgruber Project IDE is IntelliJ, build with Maven. What I mean is, Guava classes are readily visible when coding. Nothing stopping devs from using Guava during development and being unpleasantly surprised later.\n. What would the plugin do differently?\n. That breaks the Law of Demeter. It's best if objects only have a handle to exactly what they need.\n. Ok, well I could provide some injections that refer to an interface, but inject a concrete implementation. That would be a solid example of that. The java example uses a coffee maker as it's subject, what would you like to see here? Also, it's not about swapping components, passing in the kitchen sink into an object makes for nasty unit tests.\n. ",
    "brettcannon": "Fixed the \"or\" problem and signed the CLA.\nOn Tue, Oct 23, 2012 at 6:01 PM, Jesse Wilson notifications@github.comwrote:\n\nDon't forget the CLA:\nhttps://github.com/square/dagger/blob/master/CONTRIBUTING.md\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/pull/73#issuecomment-9719976.\n. On Tue, Oct 23, 2012 at 3:20 PM, Christian Edward Gruber \nnotifications@github.com wrote:\nIn README.md:\n\n@@ -163,7 +163,7 @@ class CoffeeMaker {\n### Lazy injections\n-Sometimes you need to make a dependency lazily created.  For any binding T, you can create a Lazy<T> which defers instantiation until the first call to Lazy<T>'s get() method. If T is a singleton, then Lazy<T> will be the same instance for all injections within the ObjectGraph.  Otherwise, each injection site will get its own Lazy<T> instance.  Regardless, subsequent calls to any given instance of Lazy<T> will return the same underlying instance of T.\n+Sometimes you need to create a dependency lazily.  For any binding T, you can create a Lazy<T> which defers instantiation until the first call to Lazy<T>'s get() method. If T is a singleton, then Lazy<T> will be the same instance for all injections within the ObjectGraph.  Otherwise, each injection site will get its own Lazy<T> instance.  Regardless, subsequent calls to any given instance of Lazy<T> will return the same underlying instance of T.\n\nMaybe:\n\"Sometimes you need an object to be instantiated lazily. You can achieve\nthis by depending on a Lazy rather than on T directly.\" etc.\nThis avoids the lazy-dependency-creation terminology a bit.\n\nI went with \"Sometimes you need an object to be instantiated lazily\".\n. ",
    "luisdelarosa": "Subclassing.\nSorry - I cut off the error message, so perhaps that will give a better clue.  Here's the full message:\nCaused by: java.lang.IllegalStateException: Errors creating object graph:\nNo injectable members on com.actionbarsherlock.app.SherlockFragmentActivity. Do you want to add an injectable constructor? required by members/com.luisdelarosa.MyApplication.MyActivity\nMyActivity looks like:\n``` java\npublic class MyActivity extends SherlockFragmentActivity {\n    @Inject MyStore store;\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    ((MyApplication) getApplication()).inject(this);\n     // more work here\n}\n\n}\n```\nAlso, MyActivity is declared as an entryPoint.\n. I just pulled and merged the latest upstream master and got a different exception:\nCaused by: java.lang.IllegalStateException: Errors creating object graph:\n  No available @Inject handlers could be found for key members/com.actionbarsherlock.app.SherlockFragmentActivity in class com.actionbarsherlock.app.SherlockFragmentActivity required by members/com.luisdelarosa.MyActivity\n    at dagger.internal.ThrowingErrorHandler.handleErrors(ThrowingErrorHandler.java:34)\n    at dagger.internal.Linker.linkRequested(Linker.java:123)\n    at dagger.ObjectGraph.getEntryPointBinding(ObjectGraph.java:214)\n    at dagger.ObjectGraph.inject(ObjectGraph.java:196)\n    at com.luisdelarosa.MyApplication.inject(MyApplication.java:38)\n    at com.luisdelarosa.MyActivity.onCreate(MyActivity.java:26)\n    at android.app.Activity.performCreate(Activity.java:5008)\n    at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1079)\n    at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2023)\nThen I added an explicit constructor in SherlockFragmentActivity.\n@Inject\npublic SherlockFragmentActivity() {\n}\nThis explicit constructor fixes these errors.  I'd like to understand better why this would be required, though.  I assume this isn't normal ABS/Dagger integration.\nThanks.\n. ",
    "wombleabroad": "Not sure whether or not to create a new issue here, but this fix works fine when using the reflection strategy. Using 0.9 artifcacts, if I switch to the code generation strategy (by adding the dagger-compiler plugin dependency) I get the following error at runtime:\n\njava.lang.IllegalStateException: Errors creating object graph:\n  No injectable members on com.actionbarsherlock.app.SherlockFragmentActivity. Do you want to add an injectable constructor? required by class com.foo.MyActivity\n    at dagger.internal.ThrowingErrorHandler.handleErrors(ThrowingErrorHandler.java:34)\n    at dagger.internal.Linker.linkRequested(Linker.java:136)\n    at dagger.ObjectGraph.getEntryPointBinding(ObjectGraph.java:264)\n    at dagger.ObjectGraph.inject(ObjectGraph.java:238)\n    at com.foo.MyActivity.onCreate(MyActivity.java:n)\n\nI noticed that in MyActivity$InjectAdapter, the supertype instance field is set like this in the attach method:\nsupertype = (dagger.internal.Binding<com.actionbarsherlock.app.SherlockFragmentActivity>) linker.requestBinding(\"members/com.actionbarsherlock.app.SherlockFragmentActivity\", com.foo.MyActivity.class);\nThe two argument Linker.requestBinding method calls the three argument Linker.requestBinding method with mustBeInjectable = true. Could this be the source of the error?\n. ",
    "reprogrammer": "@cgruber, @swankjesse \nDo you find any of the nullness warnings marked in my change suspicious or they are always safe?\n. Field dagger.internal.Binding.requiredBy is @Nullable because it's set to null at the following locations:\n- https://github.com/reprogrammer/dagger/blob/master/core/src/main/java/dagger/internal/Binding.java#L26\n- https://github.com/reprogrammer/dagger/blob/master/core/src/main/java/dagger/internal/SetBinding.java#L43\nSimilarly, field dagger.internal.Binding.provideKey is @Nullable because it's set to null at the following locations:\n- https://github.com/reprogrammer/dagger/blob/master/core/src/main/java/dagger/internal/Binding.java#L26\n- https://github.com/reprogrammer/dagger/blob/master/core/src/main/java/dagger/internal/Linker.java#L312\nIt looks to me that we can get rid of the above occurrences of the null value by introducing new classes. For instance, SetBinding sets provideKey and requiredBy to null. This may imply that Binding is not the right place for fields provideKey and requiredBy. Instead, these fields should belong to the subclasses that can set the fields to non-null values. I think this change would improve the design and make it easy to check the null-safety of the program at compile-time.\nWhat do you think about such a change? Can you think of other changes to remove the null values?\n. If you are considering the adoption of FindBugs analysis or annotations for nullness analysis, beware of its following two shortcomings:\n- FindBugs may not find all nullness bugs.\n- The semantics of FindBugs annotations can be misleading.\n. ",
    "keilw": "Fascinating, so would com.google.dagger use exactly the same package?!\nIf it does, that's the perfect case of Classpath Hell such a naming causes.\n. Sure people did all kinds of strange things in Maven, remember those SpringSource OSGi-enabled Maven artifacts, which were repackaged into something like \"com.springsource.org.apache.commons.logging\";-D\nJava Jigsaw still hasn't shown enough credible evidence how it wishes to solve this, but at least via OSGi, even if the package or bundle names were exactly the same you can tell your code whether to use Dagger 0.9 or 1.0;-)\nSo while OSGi has means of telling Dagger 0.9 and 1.0 apart even if both were in the same classpath, Maven itself isn't smart enough to do so.\n. +1\n. Yeah, beside trying to seem what it isn't (a \"standard\" like \"java.\" or #javax.\" packages) it has the side-effect, that it hides which company is behind it, at least on a Java level. Whether intentional or not, I don't know, Bob though he doesn't seem involved in Dagger is (former) Spec Lead of 330 after he left Google, but unlike Guice JSRs are always supposed to be vendor-neutral. If some of you may keep maintaining these projects even after eventually leaving Square, let's see, at least Twitter in some cases seems a bit like a \"Rotating Door\" for developers;-)\n. Thanks for the input, I know, some of it may even be worth more a blog or something.\nI can't name them, but companies involved in or evaluating Agorava are looking at some of these implementations, Dagger, Guice itself or various forks and derived projects, and when one of them is found appropriate, they are also considering to put further resources behind it.\n. Wow after 4 1/2 years ;-) Thanks for feedback nevertheless. A few highly regarded projects like FitNesse also don't give a damn about the package name or artifactId.. If it's just an internal, project-specific package and library, I certainly agree. If it contains public API or SPI  to be used by other projects or products that's a different story.. ",
    "tonit": "The argument \"we anticipate forks\"  for a simplistic namespace like\n\"dagger\" instead of \"com.squareup.dagger\" is really interesting.\nUsually i throw people out of the window not following (seemingly good)\nconventions.\nYou increase the likelihood of collisions but increase certainty of forks.\nQuestion is why?\nAs a \"platform building guy\" i like to spread the open for extension but\nclose to modification paradigm. But if you say you embrace forks your\nreally mean open for modification, but close to extension ?  This is a\nfundamental question not suitable for this thread but i find the fact that\nyou do and the way you embrace it worth thinking about! (note to myself).\nSpeaking of OSGi, using Attribute Matching, OSGii subsystems or  Capability\nmechanisms you have a wealth of options to lock down competing providers of\nDagger in the same VM.\nJust my 2cts.\nToni\nToni Menzel | Founder | Rebaze GmbH\ntoni.menzel@rebaze.com | www.rebaze.com\nAccess To Alien Technology: Great software needs a great foundation. We\nhelp unlocking the next level in technology.\nRebaze Pass for Maven http://goo.gl/1YLlt, Rebaze Pass for\nOSGihttp://goo.gl/WP8XT\n, Rebaze Pass for Neo4j http://www.rebaze.com/services/, Rebaze Pass for\nJenkins http://www.rebaze.com/services/\nOn Thu, Nov 8, 2012 at 4:02 PM, Werner Keil notifications@github.comwrote:\n\nSure people did all kinds of strange things in Maven, remember those\nSpringSource OSGi-enabled Maven artifacts, which were repackaged into\nsomething like \"com.springsource.org.apache.commons.logging\";-D\nJava Jigsaw still hasn't shown enough credible evidence how it wishes to\nsolve this, but at least via OSGi, even if the package or bundle names were\nexactly the same you can tell your code whether to use Dagger 0.9 or 1.0;-)\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/97#issuecomment-10190827.\n. Fully agree. I just said its a nice angle that hasn't spread yet. I know\nyou'd mention the Sisu example. Good one.\nAbout \"not importing proprietary packages\": I've seen both directions: \ncom.company* looks proprietary, org.apache or _org.ops4j (shameless\nplug) are seemingly *trust-building_ namespaces.\n\nToni Menzel | Founder | Rebaze GmbH\ntoni.menzel@rebaze.com | www.rebaze.com\nAccess To Alien Technology: Great software needs a great foundation. We\nhelp unlocking the next level in technology.\nRebaze Pass for Maven http://goo.gl/1YLlt, Rebaze Pass for\nOSGihttp://goo.gl/WP8XT\n, Rebaze Pass for Neo4j http://www.rebaze.com/services/, Rebaze Pass for\nJenkins http://www.rebaze.com/services/\nOn Thu, Nov 8, 2012 at 4:42 PM, Jesse Wilson notifications@github.comwrote:\n\nThe decision to go with a nonconvential package name was not made lightly!\nWe had a very conventional package name for Guice and lived to regret it.\nIn particular:\n-\nDespite Guice's expansive SPI for configuration and extension, forks\n   still happen! The most notable is sisu-guicehttps://github.com/sonatype/sisu-guice,\n   which is used in Maven. The forks' Maven groupId\n   org.sonatype.sisu.inject disagrees with its package name\n   com.google.guice. So if forks exist, violations of the naming pattern\n   exist.\n   -\nIt is the nature of dependency injection frameworks that you import\n   them everywhere in your project. You need to import annotation types\n   in every class that participates. With Guice we received complaints that\n   developers didn't want to import a proprietary package\n   com.google.inject in their core types.\nI've seen few practical drawbacks of this approach.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/97#issuecomment-10192378.\n. \n",
    "levonk": "I know this issue has been put to rest for a while.   But, It seems to me that it would have been preferable to just purchase us.dagger instead of violating the convention.   Interesting discussion happening here as well https://www.reddit.com/r/java/comments/5sh96o/packaging_java_is_it_time_to_stop_beginning_with/. ",
    "yoav-zibin": "Thanks for replying so quickly :)\nI've updated to the latest java version but mvn test still fails for me:\nC:\\Users\\yzibin\\workspace\\dagger-master>java -version\njava version \"1.7.0_09\"\nJava(TM) SE Runtime Environment (build 1.7.0_09-b05)\nJava HotSpot(TM) 64-Bit Server VM (build 23.5-b02, mixed mode)\nC:\\Users\\yzibin\\workspace\\dagger-master>mvn -e test\n[INFO] Error stacktraces are turned on.\n[INFO] Scanning for projects...\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Build Order:\n[INFO]\n[INFO] Dagger (Parent)\n[INFO] Dagger\n[INFO] Dagger Compiler\n[INFO] Dagger AndroidManifest.xml Module Generator\n[INFO] Dagger Example\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building Dagger (Parent) 1.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-enforcer-plugin:1.0:enforce (enforce-maven) @ dagger-parent ---\n[INFO]\n[INFO] ------------------------------------------------------------------------\n[INFO] Building Dagger 1.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO]\n[INFO] --- maven-enforcer-plugin:1.0:enforce (enforce-maven) @ dagger ---\n[INFO]\n[INFO] --- maven-resources-plugin:2.5:resources (default-resources) @ dagger ---\n[debug] execute contextualize\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\n[INFO] skip non existing resourceDirectory C:\\Users\\yzibin\\workspace\\dagger-mast\ner\\core\\src\\main\\resources\n[INFO]\n[INFO] --- maven-compiler-plugin:2.5:compile (default-compile) @ dagger ---\n[INFO] Nothing to compile - all classes are up to date\n[INFO]\n[INFO] --- maven-resources-plugin:2.5:testResources (default-testResources) @ da\ngger ---\n[debug] execute contextualize\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\n[INFO] skip non existing resourceDirectory C:\\Users\\yzibin\\workspace\\dagger-mast\ner\\core\\src\\test\\resources\n[INFO]\n[INFO] --- maven-compiler-plugin:2.5:testCompile (default-testCompile) @ dagger\n[INFO] Nothing to compile - all classes are up to date\n[INFO]\n[INFO] --- maven-surefire-plugin:2.10:test (default-test) @ dagger ---\n[INFO] Surefire report directory: C:\\Users\\yzibin\\workspace\\dagger-master\\core\\t\narget\\surefire-reports\n\nT E S T S\nRunning dagger.ExtensionTest\nTests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.095 sec\nRunning dagger.InjectionOfLazyTest\nTests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.012 sec\nRunning dagger.InjectionTest\nTests run: 31, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.125 sec <<< F\nAILURE!\nRunning dagger.InjectStaticsTest\nTests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.002 sec\nRunning dagger.internal.KeysTest\nTests run: 18, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.014 sec\nRunning dagger.LazyInjectionTest\nTests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.018 sec\nRunning dagger.MembersInjectorTest\nTests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.024 sec\nRunning dagger.ModuleIncludesTest\nTests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.019 sec\nRunning dagger.ProblemDetectorTest\nTests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.006 sec\nRunning dagger.SetBindingTest\nTests run: 6, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.022 sec\nResults :\nTests in error:\n  noConstructorInjectionsForClassesWithTypeParameters(dagger.InjectionTest): dag\nger.InjectionTest and dagger.InjectionTest$1Parameterized disagree on InnerClass\nes attribute\nTests run: 89, Failures: 0, Errors: 1, Skipped: 0\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary:\n[INFO]\n[INFO] Dagger (Parent) ................................... SUCCESS [0.683s]\n[INFO] Dagger ............................................ FAILURE [1.756s]\n[INFO] Dagger Compiler ................................... SKIPPED\n[INFO] Dagger AndroidManifest.xml Module Generator ....... SKIPPED\n[INFO] Dagger Example .................................... SKIPPED\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 2.649s\n[INFO] Finished at: Sun Nov 11 13:02:54 EST 2012\n[INFO] Final Memory: 6M/105M\n[INFO] ------------------------------------------------------------------------\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.\n10:test (default-test) on project dagger: There are test failures.\n[ERROR]\n[ERROR] Please refer to C:\\Users\\yzibin\\workspace\\dagger-master\\core\\target\\sure\nfire-reports for the individual test results.\n[ERROR] -> [Help 1]\norg.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal o\nrg.apache.maven.plugins:maven-surefire-plugin:2.10:test (default-test) on projec\nt dagger: There are test failures.\nPlease refer to C:\\Users\\yzibin\\workspace\\dagger-master\\core\\target\\surefire-rep\norts for the individual test results.\n        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor\n.java:213)\n        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor\n.java:153)\n        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor\n.java:145)\n        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProje\nct(LifecycleModuleBuilder.java:84)\n        at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProje\nct(LifecycleModuleBuilder.java:59)\n        at org.apache.maven.lifecycle.internal.LifecycleStarter.singleThreadedBu\nild(LifecycleStarter.java:183)\n        at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(Lifecycl\neStarter.java:161)\n        at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:320)\n        at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:156)\n        at org.apache.maven.cli.MavenCli.execute(MavenCli.java:537)\n        at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:196)\n        at org.apache.maven.cli.MavenCli.main(MavenCli.java:141)\n        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.\njava:39)\n        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAcces\nsorImpl.java:25)\n        at java.lang.reflect.Method.invoke(Method.java:597)\n        at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Laun\ncher.java:290)\n        at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.jav\na:230)\n        at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(La\nuncher.java:409)\n        at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:\n352)\nCaused by: org.apache.maven.plugin.MojoFailureException: There are test failures\n.\nPlease refer to C:\\Users\\yzibin\\workspace\\dagger-master\\core\\target\\surefire-rep\norts for the individual test results.\n        at org.apache.maven.plugin.surefire.SurefireHelper.reportExecution(Suref\nireHelper.java:87)\n        at org.apache.maven.plugin.surefire.SurefirePlugin.writeSummary(Surefire\nPlugin.java:641)\n        at org.apache.maven.plugin.surefire.SurefirePlugin.handleSummary(Surefir\nePlugin.java:615)\n        at org.apache.maven.plugin.surefire.AbstractSurefireMojo.executeAfterPre\nconditionsChecked(AbstractSurefireMojo.java:137)\n        at org.apache.maven.plugin.surefire.AbstractSurefireMojo.execute(Abstrac\ntSurefireMojo.java:98)\n        at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(Default\nBuildPluginManager.java:101)\n        at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor\n.java:209)\n        ... 19 more\n[ERROR]\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\n[ERROR]\n[ERROR] For more information about the errors and possible solutions, please rea\nd the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureExc\neption\n[ERROR]\n[ERROR] After correcting the problems, you can resume the build with the command\n[ERROR]   mvn  -rf :dagger\nC:\\Users\\yzibin\\workspace\\dagger-master>\n. I tried:\nmvn test\non my ubuntu machine (I thought maybe it is has something to do with running on windows),\nand here I get a different failure.\nI'll try the project again when it reaches beta :)\nThanks!\n\nT E S T S\nRunning dagger.ProblemDetectorTest\nTests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.119 sec\nRunning dagger.InjectStaticsTest\nTests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.033 sec\nRunning dagger.InjectionOfLazyTest\nTests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.025 sec\nRunning dagger.MembersInjectorTest\nTests run: 8, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.052 sec\nRunning dagger.ExtensionTest\nTests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.02 sec\nRunning dagger.LazyInjectionTest\nTests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.021 sec\nRunning dagger.internal.KeysTest\nTests run: 18, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.018 sec\nRunning dagger.SetBindingTest\nTests run: 7, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.064 sec\nRunning dagger.InjectionTest\nTests run: 31, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.222 sec <<< FAILURE!\nRunning dagger.ModuleIncludesTest\nTests run: 8, Failures: 0, Errors: 3, Skipped: 0, Time elapsed: 0.058 sec <<< FAILURE!\nResults :\nTests in error: \n  noConstructorInjectionsForClassesWithTypeParameters(dagger.InjectionTest): dagger.InjectionTest and dagger.InjectionTest$1Parameterized disagree on InnerClasses attribute\n  childModuleWithBinding(dagger.ModuleIncludesTest): No entry point for members/dagger.ModuleIncludesTest$1TestEntryPoint. You must explicitly add an entry point to one of your modules.\n  childModuleWithChildModule(dagger.ModuleIncludesTest): No entry point for members/dagger.ModuleIncludesTest$2TestEntryPoint. You must explicitly add an entry point to one of your modules.\n  childModuleWithManualConstruction(dagger.ModuleIncludesTest): No entry point for members/dagger.ModuleIncludesTest$3TestEntryPoint. You must explicitly add an entry point to one of your modules.\nTests run: 90, Failures: 0, Errors: 4, Skipped: 0\n[INFO] ------------------------------------------------------------------------\n[INFO] Reactor Summary:\n[INFO] \n[INFO] Dagger (Parent) ................................... SUCCESS [0.440s]\n[INFO] Dagger ............................................ FAILURE [4.108s]\n[INFO] Dagger Compiler ................................... SKIPPED\n[INFO] Dagger AndroidManifest.xml Module Generator ....... SKIPPED\n[INFO] Dagger Example .................................... SKIPPED\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 4.737s\n[INFO] Finished at: Mon Nov 12 16:35:21 EST 2012\n[INFO] Final Memory: 10M/179M\n[INFO] ------------------------------------------------------------------------\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:2.10:test (default-test) on project dagger: There are test failures.\n[ERROR] \n[ERROR] Please refer to /home/yzibin/Documents/dagger-static-dependency-injection-like-GUICE/core/target/surefire-reports for the individual test results.\n[ERROR] -> [Help 1]\n[ERROR] \n[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.\n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\n[ERROR] \n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException\n[ERROR] \n[ERROR] After correcting the problems, you can resume the build with the command\n[ERROR]   mvn  -rf :dagger\nyzibin@yzibin:/home/yzibin/Documents/dagger-static-dependency-injection-like-GUICE$ \n. ",
    "gesellix": "I also had the same error using JDK 6:\nJava(TM) SE Runtime Environment (build 1.6.0_26-b03)\nJava HotSpot(TM) 64-Bit Server VM (build 20.1-b02, mixed mode)\nSwitching to JDK 7 helped:\nJava(TM) SE Runtime Environment (build 1.7.0_07-b10)\nJava HotSpot(TM) 64-Bit Server VM (build 23.3-b01, mixed mode)\n. ",
    "clkim": "I was so excited about trying out Dagger after listening to Eric's talk; great work guys and much thanks for sharing...\nI'm on a WindowsXP using jdk1.7.0, and had just cloned repository this morning from git://github.com/square/dagger.git\nI'm getting the same error after running from the dagger directory: mvn clean test  OR  mvn clean install\nTests in error:\n  noConstructorInjectionsForClassesWithTypeParameters(dagger.InjectionTest): dagger.InjectionTest and dagger.InjectionTest$1Parameterized disagree on InnerClasses attribute\nHere're the contents of C:\\downloadpath\\dagger\\core\\target\\surefire-reports\\TEST-dagger.InjectionTest.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<testsuite failures=\"0\" time=\"0.14\" errors=\"1\" skipped=\"0\" tests=\"31\" name=\"dagger.InjectionTest\">\n  <properties>\n    <property name=\"java.runtime.name\" value=\"Java(TM) SE Runtime Environment\"/>\n    <property name=\"sun.boot.library.path\" value=\"C:\\Program Files\\Java\\jdk1.7.0\\jre\\bin\"/>\n    <property name=\"java.vm.version\" value=\"21.0-b17\"/>\n    <property name=\"java.vm.vendor\" value=\"Oracle Corporation\"/>\n    <property name=\"java.vendor.url\" value=\"http://java.oracle.com/\"/>\n    <property name=\"path.separator\" value=\";\"/>\n    <property name=\"guice.disable.misplaced.annotation.check\" value=\"true\"/>\n    <property name=\"java.vm.name\" value=\"Java HotSpot(TM) Client VM\"/>\n    <property name=\"file.encoding.pkg\" value=\"sun.io\"/>\n    <property name=\"user.script\" value=\"\"/>\n    <property name=\"user.country\" value=\"US\"/>\n    <property name=\"sun.java.launcher\" value=\"SUN_STANDARD\"/>\n    <property name=\"sun.os.patch.level\" value=\"Service Pack 3\"/>\n    <property name=\"java.vm.specification.name\" value=\"Java Virtual Machine Specification\"/>\n    <property name=\"user.dir\" value=\"C:\\Documents and Settings\\<username>\\My Documents\\Downloads\\dagger\"/>\n    <property name=\"java.runtime.version\" value=\"1.7.0-b147\"/>\n    <property name=\"java.awt.graphicsenv\" value=\"sun.awt.Win32GraphicsEnvironment\"/>\n    <property name=\"java.endorsed.dirs\" value=\"C:\\Program Files\\Java\\jdk1.7.0\\jre\\lib\\endorsed\"/>\n    <property name=\"os.arch\" value=\"x86\"/>\n    <property name=\"java.io.tmpdir\" value=\"C:\\DOCUME~1\\<USERNAME>~1\\LOCALS~1\\Temp\\\"/>\n    <property name=\"line.separator\" value=\"\n\"/>\n    <property name=\"java.vm.specification.vendor\" value=\"Oracle Corporation\"/>\n    <property name=\"user.variant\" value=\"\"/>\n    <property name=\"os.name\" value=\"Windows XP\"/>\n    <property name=\"classworlds.conf\" value=\"C:\\Program Files\\Apache Software Foundation\\apache-maven-3.0.4\\bin\\m2.conf\"/>\n    <property name=\"sun.jnu.encoding\" value=\"Cp1252\"/>\n    <property name=\"java.library.path\" value=\"C:\\Program Files\\Java\\jdk1.7.0\\bin;C:\\WINDOWS\\Sun\\Java\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\Program Files\\ATI Technologies\\ATI.ACE\\;C:\\Program Files\\Common Files\\Intuit\\QBPOSSDKRuntime;C:\\Program Files\\Android\\android_sdk\\platform-tools;C:\\Program Files\\Android\\android_sdk\\tools;C:\\Program Files\\Java\\jdk1.7.0\\bin;C:\\Program Files\\TortoiseHg\\;C:\\Program Files\\TortoiseSVN\\bin;C:\\Program Files\\SourceGear\\Common\\DiffMerge\\;C:\\Python27;C:\\Program Files\\Apache Software Foundation\\apache-maven-3.0.4\\bin;.\"/>\n    <property name=\"java.specification.name\" value=\"Java Platform API Specification\"/>\n    <property name=\"java.class.version\" value=\"51.0\"/>\n    <property name=\"sun.management.compiler\" value=\"HotSpot Client Compiler\"/>\n    <property name=\"os.version\" value=\"5.1\"/>\n    <property name=\"user.home\" value=\"C:\\Documents and Settings\\<username>\"/>\n    <property name=\"user.timezone\" value=\"America/New_York\"/>\n    <property name=\"java.awt.printerjob\" value=\"sun.awt.windows.WPrinterJob\"/>\n    <property name=\"java.specification.version\" value=\"1.7\"/>\n    <property name=\"file.encoding\" value=\"Cp1252\"/>\n    <property name=\"user.name\" value=\"<UserName>\"/>\n    <property name=\"java.class.path\" value=\"C:\\Program Files\\Apache Software Foundation\\apache-maven-3.0.4\\boot\\plexus-classworlds-2.4.jar\"/>\n    <property name=\"java.vm.specification.version\" value=\"1.7\"/>\n    <property name=\"sun.arch.data.model\" value=\"32\"/>\n    <property name=\"java.home\" value=\"C:\\Program Files\\Java\\jdk1.7.0\\jre\"/>\n    <property name=\"sun.java.command\" value=\"org.codehaus.plexus.classworlds.launcher.Launcher clean install\"/>\n    <property name=\"java.specification.vendor\" value=\"Oracle Corporation\"/>\n    <property name=\"user.language\" value=\"en\"/>\n    <property name=\"awt.toolkit\" value=\"sun.awt.windows.WToolkit\"/>\n    <property name=\"java.vm.info\" value=\"mixed mode, sharing\"/>\n    <property name=\"java.version\" value=\"1.7.0\"/>\n    <property name=\"java.ext.dirs\" value=\"C:\\Program Files\\Java\\jdk1.7.0\\jre\\lib\\ext;C:\\WINDOWS\\Sun\\Java\\lib\\ext\"/>\n    <property name=\"sun.boot.class.path\" value=\"C:\\Program Files\\Java\\jdk1.7.0\\jre\\lib\\resources.jar;C:\\Program Files\\Java\\jdk1.7.0\\jre\\lib\\rt.jar;C:\\Program Files\\Java\\jdk1.7.0\\jre\\lib\\sunrsasign.jar;C:\\Program Files\\Java\\jdk1.7.0\\jre\\lib\\jsse.jar;C:\\Program Files\\Java\\jdk1.7.0\\jre\\lib\\jce.jar;C:\\Program Files\\Java\\jdk1.7.0\\jre\\lib\\charsets.jar;C:\\Program Files\\Java\\jdk1.7.0\\jre\\classes\"/>\n    <property name=\"java.vendor\" value=\"Oracle Corporation\"/>\n    <property name=\"maven.home\" value=\"C:\\Program Files\\Apache Software Foundation\\apache-maven-3.0.4\"/>\n    <property name=\"file.separator\" value=\"\\\"/>\n    <property name=\"java.vendor.url.bug\" value=\"http://bugreport.sun.com/bugreport/\"/>\n    <property name=\"sun.cpu.endian\" value=\"little\"/>\n    <property name=\"sun.io.unicode.encoding\" value=\"UnicodeLittle\"/>\n    <property name=\"sun.desktop\" value=\"windows\"/>\n    <property name=\"sun.cpu.isalist\" value=\"pentium_pro+mmx pentium_pro pentium+mmx pentium i486 i386 i86\"/>\n  </properties>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"basicInjection\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"providerMethodsConflict\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"singletonsInjectedOnlyIntoProviders\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"noJitBindingsForInterfaces\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"noProvideBindingsForAbstractClasses\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"extendsParameterizedType\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"injectParameterizedType\"/>\n  <testcase time=\"0.015\" classname=\"dagger.InjectionTest\" name=\"injectWildcardType\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"noConstructorInjectionsForClassesWithTypeParameters\">\n    <error message=\"dagger.InjectionTest and dagger.InjectionTest$1Parameterized disagree on InnerClasses attribute\" type=\"java.lang.IncompatibleClassChangeError\">java.lang.IncompatibleClassChangeError: dagger.InjectionTest and dagger.InjectionTest$1Parameterized disagree on InnerClasses attribute\n    at java.lang.Class.getDeclaringClass(Native Method)\n    at sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.&lt;init&gt;(ParameterizedTypeImpl.java:52)\n    at sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl.make(ParameterizedTypeImpl.java:95)\n    at sun.reflect.generics.factory.CoreReflectionFactory.makeParameterizedType(CoreReflectionFactory.java:105)\n    at sun.reflect.generics.visitor.Reifier.visitClassTypeSignature(Reifier.java:140)\n    at sun.reflect.generics.tree.ClassTypeSignature.accept(ClassTypeSignature.java:49)\n    at sun.reflect.generics.repository.FieldRepository.getGenericType(FieldRepository.java:85)\n    at java.lang.reflect.Field.getGenericType(Field.java:236)\n    at dagger.internal.plugins.reflect.ReflectiveAtInjectBinding.create(ReflectiveAtInjectBinding.java:161)\n    at dagger.internal.plugins.reflect.ReflectivePlugin.getAtInjectBinding(ReflectivePlugin.java:46)\n    at dagger.internal.RuntimeAggregatingPlugin.getAtInjectBinding(RuntimeAggregatingPlugin.java:113)\n    at dagger.internal.Linker.createJitBinding(Linker.java:180)\n    at dagger.internal.Linker.linkRequested(Linker.java:109)\n    at dagger.internal.Linker.linkAll(Linker.java:88)\n    at dagger.ObjectGraph.linkEverything(ObjectGraph.java:189)\n    at dagger.ObjectGraph.validate(ObjectGraph.java:178)\n    at dagger.InjectionTest.noConstructorInjectionsForClassesWithTypeParameters(InjectionTest.java:518)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:601)\n    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:45)\n    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15)\n    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:42)\n    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20)\n    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:68)\n    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:47)\n    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231)\n    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60)\n    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229)\n    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50)\n    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222)\n    at org.junit.runners.ParentRunner.run(ParentRunner.java:300)\n    at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:53)\n    at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:123)\n    at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:104)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:601)\n    at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:164)\n    at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:110)\n    at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:175)\n    at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcessWhenForked(SurefireStarter.java:107)\n    at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:68)\n</error>\n  </testcase>\n  <testcase time=\"0.016\" classname=\"dagger.InjectionTest\" name=\"moduleWithNoProvidesMethods\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"getInstanceRequiresEntryPoint\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"getInstanceOfPrimitive\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"getInstanceOfArray\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"getInstanceAndInjectMembersUseDifferentKeys\"/>\n  <testcase time=\"0.016\" classname=\"dagger.InjectionTest\" name=\"entryPointNeedsNoInjectAnnotation\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"cannotGetOnMembersOnlyInjectionPoint\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"nonEntryPointNeedsInjectAnnotation\"/>\n  <testcase time=\"0.015\" classname=\"dagger.InjectionTest\" name=\"twoAtInjectConstructorsIsRejected\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"runtimeProvidesMethodsExceptionsAreNotWrapped\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"runtimeConstructorExceptionsAreNotWrapped\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"providerInjection\"/>\n  <testcase time=\"0.016\" classname=\"dagger.InjectionTest\" name=\"singletons\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"bindingAnnotations\"/>\n  <testcase time=\"0.016\" classname=\"dagger.InjectionTest\" name=\"singletonBindingAnnotationAndProvider\"/>\n  <testcase time=\"0.015\" classname=\"dagger.InjectionTest\" name=\"singletonInGraph\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"noJitBindingsForAnnotations\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"injectableSupertypes\"/>\n  <testcase time=\"0.016\" classname=\"dagger.InjectionTest\" name=\"uninjectableSupertypes\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"singletonsAreNotEager\"/>\n  <testcase time=\"0\" classname=\"dagger.InjectionTest\" name=\"moduleOverrides\"/>\n  <testcase time=\"0.015\" classname=\"dagger.InjectionTest\" name=\"getInstance\"/>\n</testsuite>\n. Ok, got BUILD SUCCESS :)\nBut only with jdk1.6.0_38 and not jdk1.7.0 (for me anyway, on Windows XP).\nHere's my setup, in case it's helpful to others:\n- set System variables in Environment Variables: JAVA_HOME, value C:\\Program Files\\Java\\jdk1.6.0_38\n  (in Control Panel > Java icon > Java tab > View... button, I see 1.7 Platform is enabled, probably when I installed jdk 1.7)\n- $ mvn -version\nApache Maven 3.0.4 (r1232337; 2012-01-17 03:44:56-0500)\nMaven home: c:\\Program Files\\Apache Software Foundation\\apache-maven-3.0.4\nJava version: 1.6.0_38, vendor: Sun Microsystems Inc.\nJava home: c:\\Program Files\\Java\\jdk1.6.0_38\\jre\nDefault locale: en_US, platform encoding: Cp1252\nOS name: \"windows xp\", version: \"5.1\", arch: \"x86\", family: \"windows\"\n- $ java -version\njava version \"1.7.0_10\"\nJava(TM) SE Runtime Environment (build 1.7.0_10-b18)\nJava HotSpot(TM) Client VM (build 23.6-b04, mixed mode, sharing)\n- $ mvn clean package (in 'dagger' sub-directory where dagger is cloned from github)\n- copy from ~/.m2/repository folder the javax jar file needed\njavax.inject-1.jar\n- paste into the .\\example\\target folder\n- run\n$ java -cp ./example/target/*:./core/target/* coffee.CoffeeApp\n. ",
    "patrickbaumann": "Can do. I can get around the issue in the InjectProcessor by checking for missing types before calling writeInjectAdapter:\nfor(Element element:injectedClass.fields){\n  TypeMirror m = element.asType();\n  if(m.getKind() == TypeKind.ERROR){\n    /* code to prevent execution of writeInjectAdapter */\n  }\n}\nfor(Element element:injectedClass.constructor.getParameters()){\n  /* same logic */\n}\n/* check of statics as well */\nI'll try to cover the other processors with similar checks and get a pull request out in a few days.\n. I'll be writing it such that the classes we skip on one code gen pass are attempted on subsequent passes (presumably after code gen has taken place in the other processors and the missing types have become available). If on the final pass, there are still injectable classes or modules that haven't been handled, we can finish with a more readable error. (e.g.: \"The class 'example.GenerateClass' required by 'example.ConcreteClass' does not exist!\" or \"The module _ included by _ does not exist!\")\n. No problem. I'll take care of the static concern, clean up the code a bit to reduce verbosity, and add some comments to explain some of the type handling strangeness.\n. Got rid of other finals. It's a habit that's hard to break. Heh.\n. No worries on the nitpicking. Nothing wrong with trying to keep your project consistent and concise. Hopefully I addressed your concerns in this latest commit. Let me know if I missed anything or you find anything else. Thanks!\n. I was able to get the visitor approach to work. With this approach, however, a unit test doesn't seem appropriate. Would you guys consider creating a test project that exercises some of these compiler project use cases? For my testing purposes, I've been adding / modifying classes in the example project to reproduce the issue and fail the build until fixed, but that's clearly not where it should remain.\n. Heh, I completely missed the subdirs of compiler/it. That's what I get for relying so much on the eclipse src browser. I'll get something thrown together here shortly. Thanks!\n. I hope I addressed your concerns. Let me know if anything else stands out. Thanks again. \n. No worries. I'm just glad it got resolved. Thanks!\n. It's nothing official or scientific, but I threw together a couple of demo Android apps that are identical in function but built with RoboGuice in one implementation and Dagger in the other. Source and results are at http://github.com/patrickbaumann/daggervsroboguice\nIt's a simple example but in the worst case, Dagger sliced off about 350ms of start up time compared to Guice on a Galaxy Nexus.\n. I've had to explain it quite a few times as well and I don't think the name is the sticking point so much as the concept. The name seems completely appropriate, I'd just recommend adding a few more examples to the docs and coming up with a more concise explanation (easier said than done, of course).\nI've found that people pick the concept up quickest when I explain that an entry point is any class that makes explicit use of the ObjectGraph to be created or injected into (so that it's dependency tree can be validated). Simplified, it's any type that is passed into an .inject or .create call.\n. Heh, yes. My bad. Shows how rarely I use it in my code base.\n. Nothing wrong with nit-picking. Consistency never hurt anyone. Have you considered adding rules like this to your checkstyles rules?\n. As I understand it, processingOver can only be true on the first pass if no code generating annotations are found for any processor. If that were the case, this processor would never be called.\n. getElementsAnnotatedWith() only returns the elements being handled in a particular round of processing. If we delay this until the very end (processingOver()), getElementsAnnotatedWith() will return an empty collection. Instead we're building the set from the first round so that it's complete by the final.\n. That's what I tried at first but it turns out an element instance changes from round to round. If I just used the original element stored in a previous round, I'd encounter the missing TypeKind issue. The only way around that was to use the name to look up the element using the processing environment. This may be simplified by storing all module types as strings as done in the other processors.\n. Regarding storing them as strings, see the comment above. In short, yes.\nI will remove the static. It may have been a bit too extreme with regards to persisting across passes on my part. That said, even with multiple javac calls in the same process, it shouldn't be a problem as the contents of the set are checked in the final pass. The build will fail if the set still contains elements that have not been handled in the last pass of one of the javac calls.\n. getInjectedClasses calls getClassesAnnotatedWith which only returns classes being handled on the current pass (only classes generated on the last pass). If we didn't do this, classes that existed in the previous pass but referenced nonexistent classes at the time would not be re-included in this pass.\n. See above comments on getClassesAnnotatedWith()\n. I've modified this to take a TypeMirror. I'll look into the visitor more this evening.\n. Yep. The processing environment requires the raw type name without any generic modifiers:\nGenericType instead of GenericType<T> or GenericType<>\n. Yep, we should. I'll have this throw something readable.\n. rawTypeToString appends <...> onto the end of the type name if it is generic. We need just the type name in order to look up the type via the processing environment.\n. Unfortunately I'm not sure that type name can be looked up via the processing env. This new method is only used to reference classes being injected into or module names, never the types being injected so we shouldn't ever need to reference an exotic type like that.\n. ",
    "gunnarmorling": "Or maybe invoke a setter method (if there is one)?\n. Ah, ok, I see what you mean.\nBut maybe the module with the provider method should be required to have set overrides=true in such cases?\n. ",
    "pyricau": "Thank you for the feedback :+1: .\nAlso, on the API usage side, unlike the manifest plugin, adding @EntryPoint requires the same effort as adding an entry to an entryPoint annotation parameter, so why bother ? Maybe there's a point about readability (\"Oww, that fragment is an entry point, I forgot about that\"), but I'm not even sure.\n@swankjesse said\n\nuse the presence of @Inject annotations to indicate that a class is an entry point.\n\n@cgruber said\n\nI don't think entry-points == @Inject precisely \n\nI think you both have a point. Not all @Inject annotations are entry points, but, correct me if I'm wrong, I think all entry points have an @Inject annotation (or another dagger annotation). Am I correct?\nOn Android, entry points will be classes created by the system. These classes can be identified quite easily, based on their class hierarchy: Activity, Fragment, Service, ...\nSo what about an annotation processor that looks for Dagger annotations (from current round + a cache), checks their type hierarchy for Android classes, and generates a new EntryPointsModule? \nThis processor would need to run prior to Dagger in the current implementation, because Dagger collects the annotations (process() returns true. Any good reason for that?).\nSince this is Android specific, it should probably be a separate module or project. However, adding one processor to your project is already hard, but if we start having collections of separate processors it won't be user friendly. A solution would be to create a new processor that somehow includes daggers standard processors.\nAm I missing something here? It's sunday evening, and I just tasted a good new wine... Things will be more clear tomorrow.\nIf you think it's worth it, I'll try to implement this new processor, probably next week or so. I'm giving two talks this week and haven't started yet.. if you feel like implementing this feature, please go ahead ;) .\n. I'm closing the pull request, these commits won't be merged. I certainly put some effort in trying to make the code readable, but now it's value is more about what I learned then about the actual content.\n. I just realized one of my assumptions is wrong: we can have entry points with no @Inject annotations, having @Inject only in their parent classes.\n. I like this :+1: . Edit: except maybe that InjectProcessor.process() has a lot of final noise for variables :) \n. I just checked, and you are right. We do that in InjectProcessor and ProvidesProcessor.\nSorry, I should have checked. Shame... I noticed that IDEA wasn't getting rid of some classes and I assumed Dagger wasn't doing the right thing. Maybe it's an Intellij thing (EAP ... ?) or it's also very likely my processor conf was broken.\nClosing the issue.\n. Thanks, I didn't know that.\n. Thank you guys for these comments! I just bumped into the turkish i problem ( https://groups.google.com/d/topic/androidannotations/PeSJ2yPN0GE/discussion ), and if I hadn't read the article mentioned by @swankjesse I would have had no clue about what the hell was going on...\n. I actually implemented this with a finally, but then I realized it wasn't the case in the rest of Dagger code so I kept it this way for consistency.\n. Yep. That's mostly me not knowing what can jump out of there. I guess we don't like checked exceptions for some reason :) .\n. Because it's so much easier to understand this way :) ?\n. ",
    "DaveGit": "Yes me.\n. But is the dagger compiler with the annotation processors (i.e. dagger-compiler-0.9.jar) not necessary?\nIs dagger-0.9.jar all that is needed?\n. I also have these kind of warnings for classes in the generated files\n[warn] Could not determine source for class x.y.z.ContextModule$ModuleAdapter$ProvideContextBinding\n[warn] Could not determine source for class x.y.z.ContextModule$ModuleAdapter\n[warn] Could not determine source for class x.y.z.loaders.ListLoaderDelegate$InjectAdapter\n[warn] Could not determine source for class x.y.z.ContextModule$InjectAdapter\n[warn] Could not determine source for class x.y.z.db.DbAdapterModule$ModuleAdapter$ProvideDbAdapterBinding\n[warn] Could not determine source for class x.y.z.db.DbAdapterORMLiteFacade$InjectAdapter\n[warn] Could not determine source for class x.y.z.loaders.OptionLoaderDelegate$InjectAdapter\n[warn] Could not determine source for class x.y.z.db.DbAdapterModule$ModuleAdapter\nDoes that mean the annotation processor cannot find the source files in directory x.y.x ?\n. No this is the sbt shell. But it also happens directly from the commandline when I do sbt compile.\nFor the javac settings -s is pointing to projectdir/target/scala-2.10/src_managed/main/java\nand -processorpath is pointing to c:/dagger/boot/dagger-compiler-0.9.jar;c:/dagger/boot/dagger-0.9.jar;c:/dagger/boot/javax.inject-1.jar\nI also tried -s pointing tp projectdir/target/generated-sources/annotations so exactly as the coffee example.\nThe source files and the dot file are generated in the specified directory but still these warnings.\nThe classes are in both cases written to projectdir/target/scala-2.10/classes and I can not change it with the -d option of javac. It is not reacting on that. Maybe a bug in sbt.\nIs dagger maybe expecting the processed classes to be in projectdir/target/classes?\n. So in principle it should directly work with scala source files if the compiler/sbt allows it.\nBecause so far it looks like it ignoring scala source files. That is why I put the dagger annotations in java files and tie that to scala files. It is probably an annotation processor for the java compiler only. It wouldn't work for any other jvm language compiler.\nOkay Christian, thanks so far anyway.\n. ",
    "scompt": "Here's a tweet from @swankjesse where he mentions a couple numbers between Guice and Dagger.\n. Thanks for the pointer to the addsTo parameter. That does make my second example work.\nI don't see the extends parameter in Module. Is that new or not in the main repo?\n. ",
    "macsux": "No, decided to use Guice instead. Felt like a more mature project, and had\nfeatures which I liked that dagger didn't. I don't care that much about\nstartup time anyways for what I'm doing.\nOn Thu, Jan 3, 2013 at 3:04 AM, Anton Gravestam notifications@github.comwrote:\n\n@macsux https://github.com/macsux Did you find a solution to your\nproblem, I'm having sort sort the same?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/126#issuecomment-11837049.\n. \n",
    "Steven-Mark-Ford": "I can get code generation working but no compiler errors. Despite the fact that I have a provider with a parameter which has not been provided.\n. @cgruber I followed staxgr example on setting up annotation processing in eclipse and I have defined a module but I still don't see any compile errors. Where would they appear within eclipse? In the \"Problems\" window?\n. @cgruber Would you be able to give me an example of a Dagger compile-time error and how to induce it so I can see if I can replicate this within my eclipse project?\n. Nope, just vanilla Eclipse+ADT (All-in-one package). Thanks in advance.\n. @cgruber @tbroyer Thanks! I look forward to using full integration but for now I will use the \"Error Log\" view for compilation errors.\n. @arichiardi just so you are aware updating the factory path to include the JARs listed above will induce the compiler of annotations but the errors you are seeing in the Problems window are not the full list of dagger compile errors. They will not yet include errors like \"No injectable members on ...\" as far as I am aware. Such errors can still only be located in the \"Error Log\" window. @cgruber please correct me if I am wrong here.\n. @tbroyer I get \u201cNo injectable members on \u2026\u201d in the Error Log.\nOn Thu, Feb 14, 2013 at 4:02 PM, Thomas Broyer notifications@github.comwrote:\n\n@Steven-Mark-Ford https://github.com/Steven-Mark-Ford Just tested in\ndagger-example and \u201cNo injectable members on \u2026\u201d are reported on the\nmodule class, but only if you somehow make Eclipse recompile the module\n(rebuild project, or edit/save the module). Similarly, errors don't go even\nafter you fixed them, until Eclipse recompiles the module. But this is\nbecause the validation doesn't take place at all, so no error will be\nreported to the Error Log view either.\n(note: to make m2e-apt work in dagger-example, I had to Maven \u2192 Disable\nWorkspace Resolution on the project)\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/126#issuecomment-13550413.\n. @tbroyer Thanks. That would be the issue then.\n\nOn Thu, Feb 14, 2013 at 4:11 PM, Thomas Broyer notifications@github.comwrote:\n\n@Steven-Mark-Ford https://github.com/Steven-Mark-Ford with a recent\nself-built 1.0-SNAPSHOT?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/126#issuecomment-13550788.\n. \n",
    "arichiardi": "Hi, I am trying to configure Dagger in my Android project...I am running into some issue. I just want to be sure that my m2e configuration is ok. I checked the dagger projects from SCM but imported in my pom.xml version 0.9.1.\nI created a debug configuration to launch mvn. Do I need to tick Resolve Workspace Artifacts?\nIt looks that it compiles using maven but the error checking in Eclipse doesn't work (there is an error on a black private final field with @Inject annotation). Do I need additional steps?\nEDIT: I have a \"The POM for com.squareup:dagger-compiler:jar: is missing, no dependency information available\" in the ErrorLog...I might have set up wrong my pom.xml.\n. @tbroyer I can survive without error on annotation in eclise, I can generate the code with mvn -install, that means that the correct jars are there (I can see them in my local .m2 folder). The problem is that it looks like the code is not \"visible\" to Eclipse, as I have the \"blank field might not be initialized\" error on private final field with @Inject annotation...\n. I confirm that it perfectly works with just dependency under pom.xml. I have compiled (no-test) dagger after having synced with the repo and installed the version 1.0-SNAPSHOP in my local repository. There is no error log for annotations but the mvn output is fine.\nI discovered that my \"blank field not initialized\" was caused by the fact that the injected field was final. Thanks!\n. @tbroyer No, I don't have m2e-apt at the moment. I am trying to configure it manually actually, linking the dagger-compiler.jar in the maven local repo to the project specific properties, enabling annotations. Note that it is still not compiling with regular maven.\n. Ok, now something's better. I get this:\nInternal compiler error: java.lang.NoClassDefFoundError: com/squareup/java/JavaWriter at dagger.internal.codegen.InjectProcessor.writeIncjectAdapter(InjectProcessor.java:190)\nBut at least it seems that it is trying to compile annotations with the custom dagger-compiler-.jar.\nNot that I have just pulled from the repository.\n. Sorry for all these updates....but I am now able to see annotation errors under Problems in Eclipse!\nSo, in order to achieve this, under Factory path click \"Add Jar...\" and add dagger-compiler-.jar, dagger-.jar, javax.inject.jar AND javawriter.jar.\nI don't know/think that it works without this \"Project specific property\" setting. Again, I am not using m2e-apt.\n. This is a very cool feature, is there a .dot file per module? Or one merged graph starting from the root (even more awesome)?\n\nEDIT: I tried for fun to merge the dot files with the following command:\ngvpack -n GLarmModule.dot ServicesModule.dot XmlServiceModule.dot\nBut no luck. Still, it's good to have them especially in large projects.\n. Yeah you are right, currently I have:\nGLarmModule includes ServiceModule includes XmlServiceModule\nBut dotty (graphviz dispaly tool) doesn't really show all the dependencies. Probably some branch is not there because it is not used in the code (I am in \"developing\" mode and some feature is commented out).\n. I mean, it is ok to have Runtime failures like these. My app needs a XmlPullParser to work. I was just suggesting that Dagger doesn't have to interfere with the developer here. But you already know that :)\n. IMHO, to avoid perversion (\"why is this freaking framework throwing something different here?\") and avoid a catch (Exception everything) block, which is always bad, you should reject it.\n. I follow you guys because this is really interesting. I agree with the override behavior of just replacing stuff (where this means replacing just dependencies or branches depending on the implementation). The adding behavior, for testing or not, is already in the Module composition. New module, new branch. Raising an exception if there are conflicts like above. IHMO (as always) and not knowing much about the current implementation :) Thanks!\n. Hey guys, my 2 cents. I was reading this and it looks like optional is not what you want here, because:\nOptional dependencies - If project Y depends on project Z, the owner of project Y can mark project Z as an optional dependency, using the \"optional\" element. When project X depends on project Y, X will depend only on Y and not on Y's optional dependency Z. The owner of project X may then explicitly add a dependency on Z, at her option. (It may be helpful to think of optional dependencies as \"excluded by default.\")\nThere is a table on the maven page which clarifies the scopes. You are basically using the dependency dagger-compiler to build the project right? So it looks like you need something that is the opposite to scope=runtime...the closest is scope=provided. Still, there is dependencyManagement vs. dependency that is not very clear to me...\n. No wait, from what I understand optional is meaningful just for parents.\nIf my Android app is Y and dagger-compiler is Z, and you tell me to put scope=optional that just means that if I had a X project depending on Y, I would need to manually add dagger-compiler to it (Z = dagger-compiler is self-excluded).\nThis one can be a good choice for it as well, but doesn't solve the problem that you don't want to have dagger-compiler included in the jar/apk you create when you generate Y...in which case scope=provided would work.\nThis is my understanding but I will need some confirmation from some Maven guru :)\n. Imho, following the table in that link, no. But I haven't tried. In the table, it is basically the case where your Android app declares (by default) dagger-core as scope=compile (left column) and dagger-core declares dagger-compiler as scope=provided (top row). The intersection is empty...\n. ",
    "adennie": "@tbroyer I'm trying to get this working (Eclipse, m2e, m2e-apt).  Can you show how you configured maven-compiler-plugin in your POM?  I haven't used m2e-apt before... I installed it, and then went to to Window->Preferences->Maven->Annotation Processing and choose \"Automatically configure...\".  Now I'm trying to figure what to put here:\n<plugin>\n  <artifactId>maven-compiler-plugin</artifactId>\n  <dependencies>\n    <dependency>\n      <groupId>com.squareup</groupId>\n      <artifactId>dagger-compiler</artifactId>\n      <version>${dagger.version}</version>\n    </dependency>\n  </dependencies>\n  <configuration>\n    <annotationProcessors>\n      <annotationProcessor>WHAT GOES HERE?</annotationProcessor>\n    </annotationProcessors>\n  </configuration>\n</plugin>\n. @tbroyer Hmm, OK, thanks.  Still not working for me, so must be something else.  Besides installing m2e-apt and choosing \"Automatically configure...\" is there anything else to the m2e-apt configuration that I might be missing?\n. OK, I've (locally) made the changes you suggested, @cgruber .  I'll wait for @swankjesse to review before resubmitting the pull request, in case he has additional comments.\n. right, that's what I meant, sorry, should have used clearer wording.\n. OK, updated based on feedback from @cgruber and @swankjesse .\n. My 2 cents: I think override should replace, not expand multibindings, both to accomodate the test replacement use case, and for consistency with single bindings.\n. @swankjesse @jclouds just to clarify my earlier comment, I acknowledge the use case for additive bindings, but \"override\" doesn't seem to me like the right vehicle for it.\n. FWIW, I do the injection in onAttach, because in practice I found it useful to have it happen there (so that I can use injected objects in my fragments' onCreateView, for example).  The trick I use is, in my activity's onCreate, I initialize its graph before calling super.onCreate(), so that it would be available to my fragment in its onAttach().  See my fb-android-dagger library for an  example of this approach.\n. Hi, take a look at https://github.com/fizz-buzz/fb-android-dagger for an approach that injects a Service.  Injecting an IntentService would be very similar.\n. whoops\n. Yeah, I've been painstakingly building and tweaking my eclipse settings for square stuff also, after doing some otto stuff recently.  I was thinking of contributing them back eventually, when I feel like they're about right, but as you can see, they're not  yet.\n. sure\n. Replying via email since I can't seem to find this comment on github...\nIf you're referring to the fact that there's a missing .isTrue() at the \nend of that line, I fixed that yesterday.\nOr are you questioning the purpose of the test?\n-Andy\nChristian Edward Gruber wrote:\n\nIn core/src/test/java/dagger/internal/BindingTest.java:\n\n+\n+import static org.fest.assertions.Assertions.assertThat;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public final class BindingTest {\n- private Binding wrappedBinding;\n- private Binding singletonBinding;\n  +\n- @Before public void setUp() {\n- wrappedBinding = new StringBinding();\n- singletonBinding = Linker.scope(wrappedBinding);\n- }\n  +\n- @Test public void testSingletonBindingIsSingleton() {\n- assertThat(singletonBinding.isSingleton());\n\nThis feels like an error-prone check or something.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/pull/170/files#r3174236.\n. \n",
    "gk5885": "I don't have any personal experience with it, but I've heard that getting the eclipse team to accept patches (even for pretty grievous bugs) is quite difficult.  For that reason, you're probably not going to see a lot of people volunteering to fix that issue\u2026\n. It actually might be good to enforce that @Singleton can only be applied to the top-level injector since that seems like a point of confusion.  The basic idea is that all scopes are implemented as 1-per-injector and the user has the capability to say that an injector is associated with a given scope.  So, the top-level Injector is associated with the @Singleton scope.  I can create a child injector associated with the request scope (and there should be infrastructure that does this correctly for, say, servlets).  It's still implemented as 1-per-injector, but the injector is the child in this case.\n. I'm with @RayFromSquare on this one.  Allowing @Singleton to mean anything besides one-per-root-graph has already been a source of confusion for new adopters.  Plus, it's especially unintuitive for anybody migrating from Guice.  I think I'd prefer a release with the existing behavior and warnings logged about how this is soon going to have different behavior (git does similar things and I like the approach).  Then we can change it without too much worry.\n(As an aside, I wonder who singleton is and whether he/she gets sick of random Java projects mentioning him/her all the time\u2026 :)\n. FWIW, we have better testing strategies, but I don't think the invoker tests ever got converted.\n. I should actually be able to get to this today.\nOn Jun 2, 2013 11:36 AM, \"Adrian Cole\" notifications@github.com wrote:\n\n+1\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/265#issuecomment-18809083\n.\n. It's part of the JDK\u2026\n. This slipped through my inbox, but I'm having a bit of difficultly following the line of reasoning here.\n\nFirst, we have single-artifact incremental builds to deal with.  @swankjesse argues that this approach breaks incremental builds because applying an annotation processor to a subclass can result in stale behavior.  OK, but OTOH, @tbroyer provided some evidence that altering the superclass in more horrible, obvious ways is broken anyway.  So, either we have a build system that does the right thing or one that does the wrong thing, but have we actually found any situation where it works correctly for some types of superclass changes, but not for annotations?  Granted, the example would generate Errors at runtime, we overload resolution for example could generate behavior-only changes as well.\nSecond, we have inter-artifact snapshot/development builds.  The link from @tbroyer shows that this is again super-broken no matter what we do.\nFinally, we have inter-artifact release builds.  We all seem to agree that if you're updating a versioned dependency or cutting a release, there's almost certainly going to be a clean build, right?  Seems fine there.\nI guess I would be curious to know if there's actually a concrete example of this breaking, but only for annotation processors.  It seems to me that if you change a superclass without recompiling a subclass \"you're gonna have a bad time\" regardless of whether or not an annotation processor is involved.\n. OK, so \"it doesn't work in IntelliJ\" is a valid issue.  AFAICT, it's actually the only issue - Maven's compilation issues have nothing to do with annotation processing and your example project works fine in Eclipse.  The only documentation that I can find about when IntelliJ chooses to recompile is buried in an FAQ which says \"IntelliJ IDEA keeps track of dependencies between source files\".  It seems like it's probably trying to be more clever than it ought to.\nSince IntelliJ probably isn't going to change any time soon it does seem reasonable to forgo this feature for the time being.\nThat said, the notion that injected members are implementation details is absurd.  Just because you wedged DI between the caller and type doesn't mean that you get any fewer errors when you request an instance without providing bindings for the supertype's dependencies.  The field may have default visibility, but callers have to know all of the dependencies to get anything meaningful out of the ObjectGraph.  Otherwise, each one of the errors is going to (correctly) reference an \"implementation detail\" of the supertype that isn't anywhere in the calling code.\nIn fact, this is where IntelliJ's compilation scheme is already breaking down for Dagger.  Take Dagger 1.0.1 and toss an @Inject Object foo; on B.  No complaints from IntelliJ.  You get an IllegalStateException at runtime instead.  Eclipse handles this situation like you'd hope: immediate compilation error.\n. @sgoldfed, we're checking for implements Module, not extends AbstractModule, right?\n. It seems that there's also an issue or two lurking where javac returns a \"valid\" AST in cases where type information is missing (e.g. missing import for @Provides). I wonder if a quick scan to just check that all of the type mirrors can be resolved to elements might be a simple check that would cover all of the bases.\n. The more I think about this, the more I wonder whether overrides = true makes any sense at all for set bindings. I could see a provider of an actual set (not SET_VALUES) overriding a set binding, but I don't know that there's actually anything that can be done that's not going to surprise people.  Is the best answer to just make set bindings an error in when you're in a module with overrides?\n. I think unions are OK.  Plussed graphs are logical supersets of bindings, so having set bindings reflect that behavior seems reasonable.  If the naive interpretation of a set binding for a single graph is \"give me the union of all contributions\", the same logic seems like it should apply.\nPlus, I think that this might be useful behavior that would be hard to emulate if we made the error a binding.  For instance, say I have some services.  Some might list in the application-level graph, but some might exist at the task-level.  I might want to wait until they're all healthy, but I probably don't want to have to manage a different set of bindings for each \"scope\".  This is a contrived example, but it seems pretty plausible to me.\n. Sure.  I'll put it on the TODO list for Tuesday.\n. On it today.  Travel threw my timeline a bit.\n. Released to oss.sonatype.org.  It'll propagate\u2026 sometime.\n. I'm so proud of my baby.\n. OK, here's the (still somewhat messy) code: https://github.com/gk5885/dagger/tree/pipe-dream\nI recommend taking a look at how this all comes together in the sample.  I'm working thorough the features that enable the more interesting bits of graph composition.  I'll update this issue and the sample code when I get that stuff running.\n. The auto factory case is notably different because we don't separate the\napi from the processor.  true seems sufficient for\nDagger.\nOn Wed Jan 22 2014 at 1:26:17 PM, Christian Edward Gruber \nnotifications@github.com wrote:\n\nIn auto factory we are going to use guava but shade it. I anticipate doing\nthat in dagger compiler as well so as to not require the transitive dep and\nnot conflict with client code.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/pull/381#issuecomment-33070011\n.\n. I'd just make the test that if all of the classes needed to formulate the type are in java.* then it's no good.  For example List<MySpecialType> is OK, but List<String> isn't.\n\nThat said, this is almost certainly going to cause some issues with some existing code.  Classes like Random being bound as just \"give me an instance\" and classes like Locale being bound with an assumption that no qualifier is that of \"the platform\" or \"the application\" are certainly common.  I wonder if starting with java.lang.* as a more conservative trial might be a good idea.\n. There's certainly no harm in having a module in there twice, but doing so is almost certainly a mistake.  I'd be in favor of flagging this as an error.\n. @roman-mazur, to follow up, the @Inject annotation cannot be applied to types. The target is declared as: @Target(value={METHOD,CONSTRUCTOR,FIELD})\n@tbroyer, it's not a matter of whether or not you can support it.  I have something locally that adds support, but the question is really whether or not we should support it.  Since I convinced @cgruber of this originally, let's see if I can lay out the reasoning again.\nLet's say that you want to figure out whether or not something can be provided.  Here's what you have to check right now:\n1. Is it explicitly configured (@Provides method)?\n2. Is there an @Inject constructor?\n3. Does it have a default constructor?  If so:\n   1. Is there an @Inject field somewhere on the class?\n   2. Do any of its supertypes have @Inject fields?\nSo, given the rules that we have, this can't be depended upon:\nclass Foo {}\nBut, this may or may not depending on whether or not Bar (or any of its supertypes) has an @Inject field:\nclass Foo extends Bar {}\nIn the worst case, in order to figure out whether or not you can depend on a class you have to look at its constructors, its fields and all of the fields in each of its supertypes.  Gross.\nWith the proposed change, the flowchart now looks like this:\n1. Is it explicitly configured (@Provides method)?\n2. Is there an @Inject constructor?\nThe other consideration ends up being how much boilerplate this adds in the common case.  I suspect that it doesn't actually end up being that bad in practice.  I'm hoping callers are either using members injection for instances created by some other means or just mixing in injected fields in instance that they expect to be provided by the graph.  It would seem strange to have a single type be both graph-managed and not in the same application.  (We don't want to preclude that, but I don't want to design for it either\u2026)\nIn the case where we're using members injection on container-managed instances or whatnot, we won't have to add the @Inject constructor.  Great.  No issues there.\nIn the case where we're putting @Inject on fields for types that are intended to be provided, you would have to add the @Inject constructor.  I think this actually has a couple of benefits:\n1. It makes the intended usage explicit.  No more guessing at whether or not the type is expected to be in the graph.\n2. Requiring the constructor is a gentle nudge in the direction of constructor injection and final fields.  I.e. if you have to make a constructor anyway, might as well use it.  Guice has had this advice in the wiki for quite some time.\nFor those that really like the brevity of field injection, we're really only requiring one extra line.  Given all of the other considerations, that seems like a reasonable concession.\n. @roman-mazur, I don't think that your interpretation of javax.inject.Inject matches its specification.  Constructor, field and method injection are to happen in sequence.\nIn this example,\nclass Foo {\n  @Inject Bar bar;\n  @Inject Foo() { }\n}\nthe constructor is to be injected (with no dependencies), followed by the bar field.  That is the only compliant implementation.\n. @relgames, no one disputes that an injector may use public, default constructors.  But, as is the case in Guice when you invoke Binder.requireAtInjectOnConstructors(), it is valid for an injector to choose not to.  Much the same way that @Inject \"may apply to static as well as instance members,\" that behavior isn't necessarily supported -- that particular bit is actually a called out specifically as a parameter in the tck.  Basically, we're interpreting that bit of the specification to mean that the behavior is enabled, but not mandated.\nThat said, much of the work that we've done with Dagger 2 has eliminated many of the surprises and pitfalls that we were used to seeing with reflectively built graphs, so I would be open to reexamining the tradeoffs between safety and brevity in this case.  I suspect that there will always be some number of restrictions on what we allow to be injected because the full universe of injectable types per the specification includes String, Properties, Thread, etc., for which the default constructor is never the correct thing.  But, a discussion about whether or not this particular tradeoff in the general is still warranted would be worth raising an issue there.\n. There have been major changes in Dagger 2 to address these types of issues.  Presumably, if someone were to migrate the Dagger 1 processors to extend BasicAnnotationProcessor this would get resolved.\n. In that case, we need @cgruber to do a sync with the google repo.\n. I actually have a ton of them staged in a repo.  I'll take a pass at this.\n. ",
    "niqo01": "Thank you for this fast, detailed and useful explanation. \n. Very straight forward. That's perfect, thanks a lot.\n. It was a dependency error and It was obvious sorry about that.\nThanks for the fast answer\n. ",
    "xueqingxiao": "I got same issue, so. dagger can not deal with cross dependency injection, right?  if not, have any solution?\n. can anybody help to fix this issue? when I clean my project, it's fixed.\n. ",
    "zbsz": "Yes, I just wanted to request this small fix, never meant to push the scoped singleton thing, but I'm just learning how things work on github, and don't actually know how to fix it now :)\n. Thanks for help, done it, unfortunately created another pull request in the process (tried to follow some other instructions).\n. InjectProcessor doesn't need to be changed.\nYou can observe the problem by inspecting generated classes in target directory, for example test in compiler/src/it/same-provides-method-name defines two @Provides methods, but generated ModuleAdapter has only one binding (after my fix there are 2 bindings). \nBut I don't know how to change this test to assert the problem, it seems that tests in compiler/src/it don't use generated code, only reflection.\nThis is a simple bug, in this code 'result' is a HashMap and we use different key (different types even) when getting objects from hashmap and when adding to it.\nList methods = result.get(type);    // here we use type as a key\nif (methods == null) {\n        result.put(type.toString(), new List...);  // here we use string\n} \nthis results in overwriting, methods list inside this hashmap is always replaced.\n. No problem, glad it was fixed. Besides, I didn't include a test.\n. This is a duplicate\n. ",
    "lexer": "I haven't maven on my laptop at the moment. If you will share me recent dagger.jar and dagger-compiler.jar i will try it right now.\n. thanks. will be back soon with results.\n. It works! Strange thing that it also works with 0.9.1.\n. Im totally confused 0.9.0 also works. Probably Im trying to do it differently now or it was somehow related to certain version of IntelliJ. Anyway, thanks for considering this.\n. ",
    "ylevin": "Ok, I'm ready to discuss the API for assisted injections.\n. ",
    "mescortes": "Thanks!\n. LGTM\n. LGTM\n. ",
    "jameswald": "I thought about this today too, same concerns.  What about injectPoints?  This would align with callers of the inject() method.\n. Hmm I see... perhaps injectors would be more concise.  I'm somewhat surprised that these objects can't be gathered at compile time.  Perhaps it's for flexibility, to avoid a static annotation such as @Injector on the class, however, I could see myself using @Injector on all my classes that need to inject.\n. That's interesting, I'm pretty sure I was able to create a circular dependency which did pass the dagger-compiler.  It generated a dot file with this graph:\n.\nThat obviously resulted in a stack overflow at runtime.  If this isn't supposed to happen I can reproduce it tonight and try to fix it.  The gist of it is that I injected the service into the application via an @Inject constructor, and in turn, the service injected the application via a @Module provider.\n. ",
    "ming13": "Thanks! I\u2019ll remember the trick.\n. ",
    "sdhull": "@christopherperry +1\nI agree.\n@swankjesse @JakeWharton IMO, if this isn't it, then there should (at the very least) be one that you do like prominently linked-to from the readme and github page. Examples are useful.\n. Oh.  :flushed: \nWell shut my mouth  :grin: \n. ",
    "jclouds": "I'm currently using additive feature of multibindings to allow users to add\nto a set of authentication providers.\n-A\nOn Fri, Mar 8, 2013 at 5:35 PM, Andy Dennie notifications@github.comwrote:\n\nMy 2 cents: I think override should replace, not expand multibindings,\nboth to accomodate the test replacement use case, and for consistency with\nsingle bindings.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/174#issuecomment-14655504\n.\n. ahh.. maybe we can rename to DNSProvider :)\n\nAnyway, that's a good idea, trying ObjectGraph.plus() will try it.\nOn Sat, Mar 2, 2013 at 9:00 AM, Jesse Wilson notifications@github.comwrote:\n\nThis is difficult to grok 'cause your Provider is different than\nJSR-330's Providerhttps://code.google.com/p/atinject/source/browse/trunk/src/javax/inject/Provider.java\n.\nOne thing you could experiment with is ObjectGraph.plus(). Perhaps you\ncould build your application in two phases: build a small inner object\ngraph with everything you need during bootstrap, then build upon that to\ncreate a more complete object graph.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/176#issuecomment-14331216\n.\n. +1 personally I'll have short term work when subclassing is removed, but I\ncan see the benefits.\n\nOn Sunday, March 24, 2013, Christian Edward Gruber wrote:\n\nI'm inclined as well, though there are some legacy migration cases we're\nencountering where it's saving a lot of work, but that's a weird case.\nOff by default would certainly be my preference, and explicitly not\nallowing for any module-ness out of the parents (like @Provides, @Module\ndeclarations, etc.) People keep wanting to use Modules as very fancy\nparts of their infrastructure and core code, rather than as\nspecifications of their system's structure, period.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/188#issuecomment-15352857\n.\n. +1\n. \n",
    "modules": "@JakeWharton thanks\n. ",
    "rwinograd": "@cgruber so to be clear you guys can work (at some point) to fix this?  \nOut of curiosity, what is the reason that having an @Inject annotated constructor on an abstract class is an error?  Obviously we can't create a new instance of that class via new (or via its constructor), but I don't see why we can't still create a Binding class that doesn't implement the Provider interface.\nWith all that being said, I still do think it is weird that you have to compile the base class with the annotation processor on the classpath or you get a runtime performance hit .  It serves as an additional barrier for using any inheritance based framework.\n. Is that incremental improvement that we can create $InjectAdapters for abstract classes with an @Inject constructor?  Can we just remove the line that causes an error when an abstract class has an @Inject constructor?\n. Just looked at the annotation processor library a bit more - previously didn't know about the Element#getEnclosingElements() and Types#asElement(TypeMirror) methods. I thought you guys were given a very limited subset of information from the annotation process, rather than having more freedom via these methods.\nThanks for the quick responses I don't mean to spam you guys, I'm just interested in the problem/solution.\n. Any update for this issue?\n. Based off of our conversation at GoogleIO, I'd like to reopen this.\nThe concrete issue we are facing is that if we are trying to transition a multi-package application to use dagger over guice.  We have many abstract framework classes that don't have any fields that need to be injected, while the child classes have @Inject constructors.  With this situation, an InjectAdapter is never created for the abstract class but one is created for the child object that will try delegating out to the parent InjectAdapter; the net effect is that when we go to create an instance of the child class we needlessly use reflection and get a performance hit.\nThe way I see it, we have a few options:\n1) As mentioned by @tbroyer above, we could create our own internal InjectAdapter for the class (I believe that we now have to name that object $InjectAdapter, rather than just InjectAdapter based off of #224 - please correct me if I'm wrong)\n2) We could also add a do nothing field to the base class that needs to be injected\nWe would like a simple way to generate an InjectAdapter for this class so that when we go to inject into the child class, we don't fail while looking up the binding for the parent class.  Ideally we'd like to be able to just construct an InjectAdapter that doesn't rely on delegating out to another InjectAdapter for the parent class, but if that is not possible for now it would be nice if we could:\n1) Allow us to annotate abstract class's constructor with @Inject.  Is there an actual issue with being able to annotate the abstract class's constructor with @Inject? I can't think of a reason for the compiler to throw an exception when you encounter an abstract class with a @Inject annotated constructor...\n2) Allow us to annotate a class with something that indicates that we want you to generate an InjectAdapter for it (even though it doesn't need one by your normal definitions).\nPersonally, I'd prefer 1.\n. @cgruber - totally agreed that it would be better to not pollute our application with no-op adapters (doubly true because of dex method limits), i'm just trying to find a hedge.\n@swankjesse - a mode without runtime reflection would be greatly appreciated. Off the top of my head I can't think of anything for our use cases where that fallback wouldn't work.\nFor my own knowledge, what part of JSR-330 is violated? Only thing I could see was: \"@Inject can apply to at most one constructor per class.\", but we are allowed to have a non abstract class have an @Inject constructor and a child class that also has an @Inject constructor.\n. In practice with Android you do have a packaging step though that everything has to go through before deployment anyways - you could move the creation of the InjectAdapters, etc... to be part of the creation of the final APK.\nTo me this actually makes more sense anyways, since I'm not really convinced that InjectAdapters should be created within (or included with) library jar files anyways.  Seems to me that it should be up to the final consumer of those libraries to use dagger, rather than the creator of the libraries.\nI think that means you'd have to stop using the annotation processor...\n. I'm a fan of having the code generation done as part of the packaging step for a few reasons:\n1) It wouldn't use the annotation processor which doesn't seem to be incredibly well supported\n2) It would allow for more extensive optimizations of the InjectAdapters since the entire world is known at that point\n3) It would enable an easier transition for those of us with projects that have libraries that are JSR-330 compliant, since less packages need to be transitioned over\n. @cgruber: I may be misinterpreting this, but your concern is that there is no way to differentiate between the cases where missing a parent adapter is the desired behaviour versus the case where missing the parent adapter is an error?\n. I would assume that the RuntimeAggregatingPlugin would be configured with a FailSafePlugin that returns a no-op instance of Binding and logs the fact that no Binding was found for that key.  At which point it should be clear from the logs that some classes did not have Binding objects created.\n. Can we go into more detail about why the abstract class cannot have the @Inject annotation on the constructor? \n. ",
    "digitalsanctum": "Sure, whatever makes sense. Part of the reason I submitted this PR was to spark some discussion around using Dagger for web apps while gaining more understanding of Dagger itself. \nDid you have any particular data integration in mind? I'd be willing to help with this effort since I was planning on extending this example more anyway. \n. They're just a couple of simple servlets to illustrate multiple servlet mappings. Should I stick with just one HelloWorldServlet?\n. ",
    "jvanzyl": "Is the dagger-compiler only required at build time? It is not required in the runtime or by downstream consumers?\n. I would recommend not using the maven-compiler-plugin version 3.0 and go back to what you were doing. I would consider that a regression and we'll fix it. Is there anything you specifically need in 3.0? If not, just revert and I'll get that fixed.\n. @tbroyer File an issue with the m-c-p and if you can point me at the example project I can make a test case.\n. ",
    "crocket": "It seems play is a web framework based on scala which doesn't play nicely with java dependency injection frameworks.\nI decided that a DI framework is not worth time-consuming troubleshootings that result in nasty hacks, so I removed dagger from my repo.\nIs it possible to make it compatible with Scala?\n. ",
    "wsargent": "FYI https://github.com/wsargent/play-java-dagger2\n. ",
    "hajimes": "Thanks a lot for carefully commenting to my pull request! I understand your clear arguments and will keep the translation hosted in my repo separately. Also, to address some issues you listed, I added a notice \"This Japanese document is an unofficial translation of the Dagger's user-guide from the snapshot YYYY-MM-DD. Please refer to the original user-guide for the latest and precise information.\" It will be a pleasure for me if this tiny contribution helps your library to spread in my country.\n. ",
    "mgrzechocinski": "Hey,\nI'd like to know if there are any plans to rebase & integrate this pull request? I'd love to use Dagger in my project but one of the critical requirements is obfuscation. \nM.\n. Thanks for those links, they are very helpful. I have a requirement that the app has to be obfuscated as much as possible. Keeping e.g. names of classes which contains injects (coffee.* in sample app) seems to be unacceptable. I definitely need to play with it. \n. ",
    "orip": "@mgrzechocinski see this SO answer and the comments on this G+ thread.\nPeople have gotten Dagger 1.1.0 working reliably with obfuscation, with some extra ProGuard rules.\n. ",
    "cermakcz": "Dagger's codegen changed quite a bit since I've forked it and I'm afraid I now don't have the time to rebase my changes. I also lack a will to do it, since it's clearly not a way Dagger's creators meant for it to go. Otherwise they'd have probably already done it.\n. ",
    "nimeacuerdo": "This is still an open enhancement issue for milestone 2.0, but it looks like we should we forget about any other approach in dagger regarding ProGuard integration rather than tweaking the latter (as my SO question mentioned above suggests).\n. @voidmachine have a look at this: http://stackoverflow.com/a/18177491/654026\n. @cgruber in your example for testing you state that the graph should be created like this:\nObjectGraph objectGraph = ObjectGraph.create(new MyAppModule(context), new MyTestModule());\nwhereas in the Dagger documentation at http://square.github.io/dagger/, the provided example uses a different approach:\n```\n...\n  @Before public void setUp() {\n    ObjectGraph.create(new TestModule()).inject(this);\n  }\n@Module(\n      includes = DripCoffeeModule.class,\n...\n      overrides = true\n  )\n  static class TestModule {\n...\n```\nI mean, specifically, the use of:\nObjectGraph.create(new TestModule()).inject(this);\ninstead of\nObjectGraph.create(new DripCoffeeModule(), new TestModule()).inject(this);\nWhich is the right one?\n. Nice, thanks for clarifying that guys :+1: \n. Hi @chrisjenx,\nI was wondering what's your setup because I see a difference behavior (dagger 1.2.1).\nGiven a class like:\n@Singleton\npublic class MySingletonClass {\n...\n    @Inject\n    public MySingletonClass() {}\n...\n}\nthat is only referenced by a couple of activities, say Activity1 and Activity2 that need that singleton injected. They inherit from a base class where the injection is triggered by plus'ing the application graph for every activity created:\n```\npublic class Activity1 extends BaseActivity {\n...\n@Inject\nMySingletonClass clazz;\n...\n}\npublic class Activity2 extends BaseActivity {\n...\n@Inject\nMySingletonClass clazz;\n...\n}\npublic class BaseActivity extends Activity {\n...\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        // Add the activity subgraph and inject self\n        activityGraph = getApplication().getObjectGraph().plus(getModules());\n        activityGraph.inject(this);\n    super.onCreate(savedInstanceState);\n}\n\n...\n}\n```\nand I see both activities injected with the same instance of the singleton.\n. Ok, to be in the safe side I will go back to adding my application-wide singletons to the application module with the corresponding provider method: nore cluttered than using the @Singleton annotation at the class level but safer.\n. Thanks @cgruber, that clarifies things more (and allows us to avoid having to use providers).\n. ",
    "SuperJugy": "I have been trying to make a generic proguard file that makes it possible to use dagger-compiler.\nSo far here is what I got:\n```\nKeep the annotated things annotated\n-keepattributes Annotation\nKeep the dagger annotation classes themselves\n-keep @interface dagger.,javax.inject.\nKeep the Modules intact\n-keep @dagger.Module class *\n-Keep the fields annotated with @Inject of any class that is not deleted.\n-keepclassmembers class * {\n  @javax.inject.* ;\n}\n-Keep the names of classes that have fields annotated with @Inject and the fields themselves.\n-keepclasseswithmembernames class * {\n  @javax.inject.* ;\n}\nKeep the generated classes by dagger-compile\n-keep class $$ModuleAdapter\n-keep class $$InjectAdapter\n-keep class **$$StaticInjection\n```\nI'm sure I'm missing more things, but the one that is currently blocking me is this use case:\nIf I have a base class:\njava\npublic class Parent {\n  @Inject Something something;\n  ...\n}\nAnd an inherited class:\njava\npublic class Child extends Parent {\n  ...\n}\nI will have to declare both in the Module like this:\njava\n@Module(injects = {Parent.class, Child.class})\npublic class Module {\n  @Provide\n  Something provideSomething() {\n    return new Something();\n  }\n}\nNow, the parent class is covered by the fact that it has an @Inject annotated field. but the Child will get obfuscated making the IllegalArgumentException: No inject registered for members/a.a. ... to be thrown.\nThis could be solved kind of easy if the dagger-compiler generated a Proguard config file which simply adds all classes declared in the injects = ... attribute of @Module.\nSo far my proguard file covers all modules (and its provide methods) and all classes with Injected methods. Don't know what other use cases are needed to be covered.\nWhat you think of generating this config file?\n. Oh, what's the direction you aim at?\n. Is this already implemented in a snapshot or is it a work in progress, our\nis it a distant future?\n. What do you mean is not requiered in version 2? will version not have\nproblems with proguard?\nAlso, if that is the case, will a PR for version 1.1.x be welcome?\nOn Fri, Feb 14, 2014 at 4:33 PM, Jake Wharton notifications@github.comwrote:\n\nDistant. Nobody is currently working on this.\nAdditionally, this type of thing is not required with the current version\n2 design.\n\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/202#issuecomment-35131715\n.\n\n\nSaludos Cordiales\nIng. J\u00fcrgen Adri\u00e1n Cruz Castrej\u00f3n\n. Well, If I where to submit a PR it would be the generation of a Proguard\nconfig file based on the dagger annotations just to prevent obfuscation in\nthose specific classes and members. I see no penalty there. But it is nice\nto know Version 2 won't have those troubles. Any ETA on V2?\nOn Fri, Feb 14, 2014 at 4:45 PM, Jake Wharton notifications@github.comwrote:\n\nwill version not have problems with proguard?\nNo. There will be zero reflection.\nAlso, if that is the case, will a PR for version 1.1.x be welcome?\nYes. We can make a v1.3 with something like this if it proves to be\nvaluable without causing runtime penalty.\n\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/202#issuecomment-35132580\n.\n\n\nSaludos Cordiales\nIng. J\u00fcrgen Adri\u00e1n Cruz Castrej\u00f3n\n. Another question. Will version 2 require to change annotations in the code?\nOr will it be backwards compatible and just need to change the dependency?\nOn Feb 14, 2014 4:57 PM, \"Christian Edward Gruber\" notifications@github.com\nwrote:\n\nV2.0 should be mostly in usable shape by end of Q2, though a good chunk\nof it should be usable earlier than that. Should be some directly\nvisible activity in the next few weeks.\n\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/202#issuecomment-35133353\n.\n. From what I see in the document, classes injected would stay very similar.\nSame for modules with providers. The biggest change I notice is the switch\nfrom object graph to these new components. But as you say it should not be\na big problem.\n. Ok, trying to figure out what rules would be missing in my generic proguard config, I've found the following:\n- Proguard needs not to remove the annotations from code.\n- Proguard should not remove, nor rename the @Module annotated classes.\n- Proguard should not remove, nor rename the fields of classes annotated with @Inject\n- Proguard should not rename the classes that are being injected (either the types of the fields annotated with @Inject or the types of the methods annotated with @Provide\n- Proguard should not remove nor rename the generated Adapters.\n- Proguard should not rename the entry points (the classes declared in the @Module(injects = {...}) section)\n- Proguard should not rename the first super class of any entrypoint. (apparently, every InjectAdapter generated makes a key referencing the super class by name even if the super class has no injected fields. But I don't understand why only the first super type is strongly referenced but the rest of the hierarchy isn't a problem if it is obfuscated.)\n\nI do not use the @Inject annotation in constructors so I'm probably missing a use case there.\nOf all this points, the ones that would need to be incorporated in the generation of a proguard config file would be the entrypoints, the first father of the entrypoints and the types that the providers return.\nI'm not sure if sending a PR for this or waiting for version 2 is a better idea.\n. Are you using the objectGraph.inject(this) in conjunction with\njava\n@Module(injects=AnotherClassThatInheritsFromAnInjectedClass.class)\npublic class Module {\n  @Provide\n  Something provideSomething() {\n    ...\n  }\n}\nBecause with the above approach, proGuard obfuscates the class Something (and then the module can't find the provided class) and the class AnotherClassThatInheritsFromAnInjectedClass because it doesn't have any @Injectable parameters, rather implements one that does (Making the objectGraph not finding the entry point).\nNotice that I'm using the dagger-compiler to avoid reflection as much as I can. But I really want to try out dagger 2.0 with no reflection and more intuitive API.\nMy current approach was to remove all the classes from @Module(injects=...) and instead, in the constructor of such classes, use mSomething = objectGraph.get(Something.class); to inject my fields. But even with this approach, the class Something is still getting obfuscated. I can obviously add manually the class but I was looking for a more generic config or automated generation that doesn't require to manually add this dependencies.\n. Yeah I really hope for it.\n. ",
    "chrisjenx": "@SuperJugy your generic config works pretty well for me. \n. @SuperJugy yeah I'm still testing it. \nI pretty much exclusively use:\njava\n@Inject\npublic Something(){\n}\nfor my none injects={} classes.\nInterestingly I think because I very rarely do:\n@Provides\nSomething providesSomething(){\n  return new SomethingImpl();\n}\nOr I have explicitly defined @Inject SomethingImpl something elsewhere, your rules work.\n. @SuperJugy I don't do: @Module(injects=AnotherClassThatInheritsFromAnInjectedClass.class) which is why I guess your config works for me.\nI just made the following change to make sure @Inject constructor classes are not changed.\n``` bash\n-Keep the names of classes that have fields annotated with @Inject and the fields themselves.\n-keepclasseswithmembernames class * {\n  @javax.inject. ;\n  @javax.inject. (...);\n}\n```\nNoticed though that barely anything is obfuscated. Not ideal but better than nothing. Guess the full swing to 2.0 will improve this greatly when very little reflection is done.\n. I've got a pro guard config that seems to work well. I'll post it in a sec.\nOn 19 Aug 2014 07:07, \"Matthias K\u00e4ppler\" notifications@github.com wrote:\n\nAh, it's because of this:\n// $$InjectAdapter\nprivate Binding supertype;\nso what we'd need in additional to what's been mentioned here is a rule\nthat says: whenever a class is used as part of injection, keep the super\nclass, too.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/202#issuecomment-52610810.\n. Ahh OK great.\n\nScope annotations would be great. Would clean up my providers massively,\nalthough I guess added complexity.\nEither way thanks for confirming that :)\nOn 10 Feb 2014 04:43, \"Jake Wharton\" notifications@github.com wrote:\n\nThis is the intended behavior. Singletons are local to the graph in which\nthey are instantiated. As you correctly deduced, when you throw away a\n.plus()'d graph and then later create a new one the single instance for\nthe new graph needs to be created.\nWe can improve the documentation on this at we had talked about solving it\nusing explicit \"scope\" annotations.\n\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/issues/379#issuecomment-34600609\n.\n. @cgruber Cool good to hear.\n. @nimeacuerdo I only get separate instances if Singleton if:\n1. its not injected before a plus'd graphy (application object level). \n2. not @provided in the Application module. (Before the plus'd graph)\n\nSaying that I have not rechecked as of 1.2.1 this was on 1.2, so it may of inadvertently been fixed. @cgruber might be better to answer that one.\n. Quick dive through the .plus method. I'm assuming that the first extension does full linking of the the graph and if its not done then syncs until its done.\nSo I guess is the Linker really that slow? If so surely I would see a really poor perf from Application to Activity? I probably add 10's of injectable classes at activity level. \nI must be doing something complex which the Linker is struggling with?\n. @cgruber OK So I am correct in understanding that extending the graph will go ahead an initialize all the previous @Singletons in the parent graph(s)? Which would explain the high overhead as it's init stuff that I haven't yet called on in one hit?\nSo I guess I need to be more definitive with my Modules and try to reduce the library=true instances? Or init the Flow Modules into the activity graph...(which I don't really want to do)?\nWhat's the timeframe for Dagger2?\n. ",
    "mttkay": "What's the state of this? I've been through many variations of PG config, none of which worked.\nStill trying to get to the bottom of it, but what I believe happens is that ProGuard renames a base type from which injectable classes inherit, but the inject adapters are still referring to that base type by its unobfuscated name. I'm not sure why Dagger is even looking at that class, as it has neither Inject annotations nor injectable fields or constructors (it's a plain old base class), but that's what's happening.\n. Ah, it's because of this:\n// $$InjectAdapter\nprivate Binding<com.soundcloud.android.main.DefaultLifeCycleComponent> supertype;\nso what we'd need in addition to what's been mentioned here is a rule that says: whenever a class is used as part of injection, keep the super class, too.\n. @chrisjenx I had some success with this config:\n```\n-keepnames com.soundcloud.android.\n...\n-keepclassmembers,allowobfuscation class * {\n    @javax.inject. ;\n    @dagger. ;\n    ();\n}\n-keep class javax.inject. { *; }\n-keep class $$ModuleAdapter\n-keep class $$InjectAdapter\n-keep class $$StaticInjection\n-keep class dagger.* { ; }\n```\nmeaning, I couldn't make it work without turning off obfuscation entirely for any classes referenced by Dagger. Good enough I guess.\n. Oh and, I had to add exceptions for any classes that PG decided to completely remove (or merge with others) and which were referenced by Dagger. We only had the one I mentioned above though, so I had to fully -keep it, which is perfectly fine, however.\n. ",
    "alexandru-calinoiu": "@chrisjenx Can you please post the config that you got working?\n. ",
    "IlyaEremin": "+1 @balauru \ncc @chrisjenx \n. ",
    "chenry": "Thanks for your quick response.  I am really impressed and enthusiastic about the Dagger project, and I was hoping that I may be able to use it \"across the board\" for all of my Dependency Injection needs.  However, I completely understand the desire to maintain the focus of the library to solving a specific problem.\nKeep up the great work!!!!\n. ",
    "ravn": "After a lot of experimentation in our particular setting, I found out how to use this syntax to inject configuration strings in \"pure\" JSR330 with Guice, Weld and Spring (so our libraries can be used directly with all these), and we now have a code base using this approach.\nIf dagger can be added to the list, that would be great.  If not, like pico container, then at least we have that clarified.\n/Thorbj\u00f8rn\nDen 24/04/2013 kl. 15.26 skrev Jesse Wilson notifications@github.com:\n\nWhy isn't field injection sufficient? You can use @Named on field injection.\n\u2014\nReply to this email directly or view it on GitHub.\n. Just to clarify:  I have found Guice startup to be rather slow (most likely due to all the housekeeping).  Would dagger be faster?  (in other words, is it worth switching to field injection to get this?)\n. For the archives:  I did some prototyping to learn how to use dagger, and I really like the static compilation approach.  It is much better to have a normal compilation error which needs to be fixed instead of crossing your fingers every time you launch your program and hope the magic still works.  Also it is much faster than guice on our target non-x86 platform and the centralized module approach makes it easy to have a single spot for documentation on your configuration even with our use of @Named(\"foo\") Strings for configuration values.  The only downside is having to rewrite to constructor injection but I understand the argument for method injection being hard to do right, and the size and speed of Dagger makes it worthwhile for us too.\n. \n",
    "bentatham": "Thanks - it works (around the issue) for me now with dagger-compiler-1.0-20130328.234449-2 (once I worked changed all the groupIds too, from the 0.9.1 release).\n. +1.   I am in the midst of needing this feature, and luckily its already here as an enhancement.\nTo me, having compile-time key-analysis is certainly nice to have, but not a necessity.  The first run could/would throw an error on first injection if the created map has duplicate keys.  Perhaps that could be a Module configuration option to throw an error or not, or based on existing \"overrides=true\" to not throw the error.\n. ",
    "deckerj": "Thanks for your answers. I guess, I have to use a proper proguard.cfg. Is there a working template anywhere?\n. ",
    "mingfai": "For @voidmachine case, the proguard.cfg may include: \n-keep public class * extends android.app.Activity\n-keep public class * extends android.app.Application\n-keep public class * extends android.app.Service\n-keep public class * extends android.app.backup.BackupAgentHelper\n-keep public class * extends android.appwidget.AppWidgetProvider\n-keep public class * extends android.content.BroadcastReceiver\n-keep public class * extends android.content.ContentProvider\n-keep public class * extends android.preference.Preference\n-keep public class * extends android.view.View\n(from somewhere on web)\nI wish Dagger can properly support ProGuard and provide reasonable hints (or documentation) about how to use Dagger with ProGuard.\n. ",
    "wlrover": "Could I get a little explanation on why the call to inject when placed in onActivityCeated() works and why not when it is in onAttach() ?\n. ",
    "chrisanderson79": "From what I recall it was an issue resulting from the fragment life cycle. onAttach can get called before the activity has completed its onCreate call. I think the null pointer was probably occurring as the activityGraph wasn't initialized when it tried to do the injection.\nonActivityCreated should always be called after the onCreate for the activity has executed. Doing the injection here will mean the activityGraph should always be initialized.\nThe following explains some of the fragment life cycle which might help, though good luck making sense of it all, after years of using Fragments I still get the occasional WTF moment.\nhttp://developer.android.com/guide/components/fragments.html#Lifecycle \n. In my case ComplexObject is from a 3rd party API so that's not really an option for me unless I start sub classing, hence why I'm trying to use the provider module registered through the Activity. Is this the only option I have?\n. The problem I'm having is using that module - I'm adding the module in HomeActivity as follows but it seems to be falling over when trying to inject the activity:\nhttps://github.com/chrisanderson79/dagger/blob/master/examples/android-activity-graphs-complex-module/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java\nI can get this to work by using a wrapper to inject the ComplexObject as follows:\n```\n@Inject\nBus bus;\npublic static class InjectionWrapper {\n    @Inject\n    ComplexObject complexObect;\n}\nInjectionWrapper injectionWrapper;\n@Override\nprotected void onPostCreate(Bundle savedInstanceState) {\n    super.onPostCreate(savedInstanceState);\ninjectionWrapper = new InjectionWrapper();\n\nthis.getObjectGraph().inject(injectionWrapper);\n\nAssertUtility.assertNotNull(bus);\nAssertUtility.assertNotNull(injectionWrapper.complexObect);\n\n}\n```\nThe module declaration then looks like this:\n@Module(injects = { InjectionWrapper.class }, complete = false)\npublic class ComplexModule {\nThis all feels a little wrong though.\n. Alternatively as I mentioned in the first post if I remove HomeActivity from the  BusModule so it looks like this\n@Module(complete = false)\npublic class BusModule {\nAnd keep the HomeActivity in ComplexModule it all works.\n@Module(injects = { HomeActivity.class }, complete = false)\npublic class ComplexModule {\nMy problem is that ComplexModule was added after the BusModule so it seems quite easy to get in this situation. There seems to be some dependency on where the injects declaration sits, i.e. using the following module declarations seems to cause the problem.\n@Module(injects = { HomeActivity.class }, complete = false)\npublic class BusModule {\n@Module(injects = { HomeActivity.class }, complete = false)\npublic class ComplexModule {\n. I don\u2019t really think I\u2019m saying otherwise, I guess I\u2019m still trying to get to grips with how the module setup works.\nThe biggest problem I have at the moment is that by using to plus operation to extend the object graph we can quite easily break existing modules if we don't modify the entry points.\nIn this case adding the ComplexModule requires me to go through and modify the BusModule to remove HomeActivity.class from the injects. \nIf I remove ComplexModule I need to go back to BusModule and add HomeActivity.class back into the injects.\nI guess you need a good understanding of your object graph but this just feels quite easy to break.\n. ",
    "hamen": "Thank you @adennie\n. ",
    "RowlandOti": "@adennie, your solution helped alot. Its obvious super.onCreate() does trigger something in Fragments.. ",
    "ghost": "Is this more complicated than necessary? Seems to me we could cover all of the same ground by giving @Singleton an optional scope parameter, something like: @Singleton(scope = ActivityModule.class). If I try to instantiate one against a graph that doesn't derive from that module, explode.\nOr maybe it's a new annotation called @Scope, and @Singleton is just a shorthand for @Scope(TheRootModule.class)\n(I'm assuming here that the @Scope or @Singleton annotation appears on a class definition. I'm always happiest when I can write a new class and not have to do parallel, invisible work in magical module class to make it actually work.)\n. @cgruber My objection is about over-complexity, but your counter-argument is about naming. Something like, say, @PerModule(ActivityModule.class) still sounds simpler to me than the proposal above, and having Dagger interpret @Singleton as shorthand for @PerModule(MyRootActivity.class) shouldn't conflict with the JSR.\n. I'm thinking that GitHub's Comment and Close buttons should be just a little bit closer together. There's an entire millimeter of space there.\n. @cgruber I'm wanting scopes badly enough to start working on them. What do you think about the tests @swankjesse  and I whipped up this morning? I think they're in line with your thinking.\nhttps://github.com/square/dagger/pull/309\nAll modules have a scope annotation. By default it is @Singleton. A provider method whose scope doesn't match the module is an error. Thus, if I am an @Request module it is an error for me to define an @Singleton provider method.\nA class can provide a scope anntoation. If no module has that annotation, injecting such a class is a static error.\n. Unaddressed here is how to deal with unscoped (@Singleton) modules on a .plus() line. IIRC @swankjesse's thought was that we should be permissive in such cases, e.g. to allow an app to stitch third party modules into a narrower scope. So an @Singleton provider method in a module that is .plus'd into a child graph would behave as it does today.\nI'm unclear, though, on the implications this has for classes that are annotated with @Singleton. I really dislike the current behavior, where they land in the narrowest graph. I want to be able to structure an app s.t. @Singleton always means the root graph, unambiguously. If that can be broken by a single module forgetting to declare a scope, life's not much improved.\n. OK\n. ",
    "tiziano88": "FYI This seems to still be happening.\n. ",
    "dev4mobile": "Stephen's modify more clearly\n. ",
    "jonreeve": "Sorry, did look at that page (evidently a bit too briefly) but missed that bit at the bottom. Done, no worries.\n. ",
    "mikosik": "As cgruber mentioned: 'default bindings' and overrides= are both incarnations of the same concept - defining the precedence of duplicated bindings.\nHaving said that it is natural to me to name both of them using the same wording.\nInstead of\n@Provides(useByDefault=true, type=UNIQUE) Set ...\njust write\n@Provides(overridable=true, type=UNIQUE) Set ... \nIt might seem a small change but this way it won't increase conceptual weight of the framework. There's already override concept at the modules level so it is easy to understand what it means when applied to Provides binding (lower level).\nI would even risk saying that implementing default binding this way is a must - you just decided it when you invented overrides= in modules ;) You just need to enable it at the lower level.\nLast thing that I'm not 100% sure but that is obvious to my symmetry seeking brain is the fact that when we would have \noverrides= in modues and overridable= in Providers\nwe should also have\noverrides= in Providers and overridable= in modules\nNote a third option (which I don't like but mentioning for completeness of discussion).\nJust add overridable= to modules. It would be still possible to define default binding by placing it as only Provides method in overridable module. This seems awkward to me but avoids bringing override concept to Provides level - they would be only available in modules.\n. Wouldn't it be better to replace:\ncomplete / library options\nwith\nfailOnMissingBindings / failOnUnusedBindings\nIt would more clearly explain meaning of this options without any additional documentation. Similar names would also signal that both options are responsible for configuring how validation of graph works.\nI know it's too late but maybe in dagger 2.0?\n. My first feeling was to reply and suggest:\nallowMissingBindings / allowUnusedBindings\nbut these still don't feel like perfect names.\nWhile I cannot come up with anything good enough, let me just share a few suggestions. I found dagger project yesterday so I'm newbie enough to see which api/naming is easy to understand and which is not.\nThe only (I think) function of current complete/library options is to specify what type of validations are run during compilation. If they fail, compiler warns with \"Graph validation failed:\". This makes word \"validate\" as natural prefix for those options. Secondly both javadocs for those fields use phrase \"additional static checking\".\nThis would suggest:\ncheckNoBindingIsMissing / checkNoBindingIsUnused\nor\nvalidateNoBindingIsMissing / validateNoBindingIsUnused\nLong and hard to type and have ugly \"No\" negation inside.\nI hope some native English speaker finds shorter versions.\n. ",
    "BrantApps": "Hey guys, I'm building my app through the android-maven-plugin but when I include the dagger-compiler (all at v1.0.1) my build fails at the compile stage with;\n<blah> ....com/oceanlife/task/DatabaseHelper$$InjectAdapter.java:[56,29] unreported exception\nandroid.content.pm.PackageManager.NameNotFoundException; must be caught or declared to be thrown\nIs this a manifestation of the same issue?\n. ",
    "diwakergupta": "While this is a perfectly valid ideological standpoint, there are plenty of\npractical use-cases for using injectors in a unit test. Mocks are\nincredibly useful, but are not suited everywhere. As one example, we use\n@Named bindings to generate random port numbers for tests. What you choose\nto call \"unit\" vs. \"integration\" test is often subjective -- in my case,\nmany unit tests depend on some other components for testing, hence the need\nfor injection.\n. @swankjesse, @cgruber awesome, look forward to it! I guess it's premature but I'll still ask -- any timeline for a 2.0 release? :-)\n. On Mon, Jun 24, 2013 at 3:06 AM, Jerome notifications@github.com wrote:\n\nFrom my point of view, unit tests should test components isolated from\neach other by using mocks, or tracking down a test failure can really\nbecome painful.\n\nThis is a fine point of view but in practice, I've seen most code bases\nthat use injection also relying on injection for testing. Existence of\nprojects such as GuiceBerry (https://code.google.com/p/guiceberry/) and\nJukito (https://github.com/ArcBees/Jukito) further support my anecdotal\nobservations.\nAnyways, just wanted to raise this so we can have a discussion. If the\nDagger community doesn't find this useful, feel free to close as won't fix.\n. ",
    "jloisel": "From my point of view, unit tests should test components isolated from each other by using mocks, or tracking down a test failure can really become painful.\nWe do test objects being injected by providing instances manually, this avoids that unit tests to fail when injection is not working.\nWe have tests on modules checking that wiring is working fine. These are the only tests we have that use injection. This allows use to quickly figure out if our code is failing because of wiring or broken code inside an object.\nObjects should be simple enough to be mocked easily. We try to have mostly single method interfaces with obvious contracts.\nMaybe, there should be something dedicated to integration unit tests in Dagger allowing to relax some settings, although this is pretty dangerous as it may be misused in production code.\n. There are also libraries like PowerMock (http://code.google.com/p/powermock/) but that does not mean it's a good practice to use them. I understand your point of view, working with legacy code often requires to make compromise. I'm open to having something in Dagger satisfying both worlds.\n. ",
    "maherbeg": "Err, just saw a change log was added yesterday for 1.0 to 1.0.1, my bad! Tagged commits would still be useful though!\n. ",
    "joprsal": "OK, that makes sense.\nThanks\n. ",
    "rzwitserloot": "Lombok does not, and never has, returned 'true' for accept() unless the annotation that triggered the call was actually a lombok annotation.\n. Ah, I see. I've fixed that for the next release. Thanks for the tip!\n. Actually, the current version of lombok always returned false anyway, the fix I just committed merely makes that a bit more readable in the code. I'm not sure if the original reporter of this issue actually gave lombok + dagger a try and found that it didn't work, but if you didn't: Go ahead and try. It'll probably work out.\nIf my analysis is wrong, the edge release I just uploaded DEFINITELY returns false, so if that + dagger isn't working for you, something else is amiss:\nhttp://projectlombok.org/download-edge.html\n. ",
    "colriot": "I use Lombok (0.11.6, 0.11.8) with Dagger (0.9.1, 1.0.0) successfully in our project. Works like a charm.\n. @novabyte yep. We use Maven for building the project. No special configuration needed as far as I can remember.\n. ",
    "novabyte": "@colriot ok thanks, I must have had a configuration problem somewhere else in the codebase. Did you use Maven or Gradle to handle the build process?\n. @colriot ok, thanks. I'll give it a go with Gradle and report back any problems.\n@cgruber Thanks for closing the issue, I was waiting to hear from Sergey before closing it myself. I'm glad it's not a problem with Dagger. :)\n. ",
    "sinojelly": "This problem was fixed.\nSee also:\nhttps://github.com/excilys/androidannotations/issues/631\n. ",
    "EurigJones": "Ok. Firstly I'm using Eclipse 3.7.2 with ADT (on Windows 8). My project also uses Android Annotations and is already in my compile-libs folder and is added under the factory path.\nHere are my steps. And I'm carrying them out as I write them just for confirmation:\n- javax.inject.jar and dagger-1.0.1.jar copied into libs folder.\n- javawriter-2.0.1.jar and dagger-compiler-1.0.1.jar copied into compile-libs folder.\n- Project properties -> project specific settings already selected.\n- Project properties -> Java compiler -> Annotation Processing -> Factory Path. I added all 4 jars to this (note that android annotations jar is also present if that makes any difference)\n- Once added, I click apply. I get this..\n\n- I clean my project I get this (as well as every other preceding clean operation)\n\nI have allso tried changing the order of the jars under the factory path in various ways (but not all combinations), but it didn't make a difference.\nI then browsed into my eclipse logs and found the following stacktrace:\njava.lang.NoClassDefFoundError: Could not initialize class dagger.internal.codegen.ProvidesProcessor\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57)\n    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n    at java.lang.reflect.Constructor.newInstance(Constructor.java:525)\n    at java.lang.Class.newInstance0(Class.java:374)\n    at java.lang.Class.newInstance(Class.java:327)\n    at org.eclipse.jdt.apt.core.internal.ClassServiceFactory.newInstance(ClassServiceFactory.java:26)\n    at org.eclipse.jdt.internal.apt.pluggable.core.dispatch.IdeAnnotationProcessorManager.discoverNextProcessor(IdeAnnotationProcessorManager.java:92)\n    at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundDispatcher.round(RoundDispatcher.java:116)\n    at org.eclipse.jdt.internal.compiler.apt.dispatch.BaseAnnotationProcessorManager.processAnnotations(BaseAnnotationProcessorManager.java:159)\n    at org.eclipse.jdt.internal.apt.pluggable.core.dispatch.IdeAnnotationProcessorManager.processAnnotations(IdeAnnotationProcessorManager.java:134)\n    at org.eclipse.jdt.internal.compiler.Compiler.processAnnotations(Compiler.java:813)\n    at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:432)\n    at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:364)\n    at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:178)\n    at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:301)\n    at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:60)\n    at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:254)\n    at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:178)\n    at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:728)\n    at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n    at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:199)\n    at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:239)\n    at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:292)\n    at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\n    at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:295)\n    at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:351)\n    at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:374)\n    at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)\n    at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)\n    at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)\nI hope that describes my issue. \nThanks!\n. Excellent, downgrading to javawriter-1.0.5.jar worked. Thanks a lot.\nI'd strongly suggest updating the Dagger documentation to guide new users to getting it to work in Eclipse.\n. @tbroyer Yes I understand that. But a large part of Android developers are not using maven. \nGenerally compared with the pain and stress I've had with maven in the past (especially with Android) I would rather spend 15 minutes per month making sure an Android project has the latest dependencies manually. \nI think maven is probably the worst thing a Java developer ever contributed to a community. \n. ",
    "zofrex": "Is this feature still desirable to add, or is Dagger 1 feature frozen now that 2 is out?\nFollow-up question that's possibly off-topic here: does Dagger 2 have this feature?. ",
    "sgoldfed": "In regards to Dagger's naming scheme for adapters: It confuses Eclipse. In particular, Eclipse gets confused when you have two classes in the same package named as in: Foo and Foo$SomethingElse. That is, when you have a class that is named identically to another class with the first different character being a dollar sign.\nWhen I say that Eclipse gets confused, in the class itself it gives no errors(i.e. It doesn't show any errors when you declare Foo$SomethingElse). But, when you write out that class name somewhere else, it shows an error. So, if in another class, we have a field of type Foo$SomethingElse, Eclipse will give an error that it cannot resolve the type.\nAll of Dagger's adapters will create this error in Eclipse. It's just that until now,  nowhere in the generated code do we ever write out an adapter name. Instead we use the interface as in\nBinding<Foo> foo;\nfoo = (Binding<Foo>) linker.requestBinding(...);\nI encountered this issue, since in my code, I declare and initialize ParentAdapters (and at least for the initialization, I need to use the actual adapter name). So, in the code I generated, when I declare Ancestor$$ParentAdapter$$Child, Eclipse gives an error.\nThe good news is, that you only see this error when you look inside the class; it does not appear on the package explorer. The better news is that the code works fine even in Eclipse.\nIt appears that the cause of the error is Eclipse getting confused by the $ in the name with inner classes. To see this easily, run the codegen and try importing the generated adapters using Eclipse's autocomplete. You can see that it changes the '$' to '.' in its suggestions, and it thinks that the name of the class is just the suffix(e.g.  in the autocomplete list it will show \"InjectAdapter\" and \"ModuleAdapter\" even though no such classes exist).\nAnyway, as I said this is not a functionality issue since despite the red line inside the class, everything works fine. The real issue is: Will users be looking at the generated code and get confused by the red line. Or will they see the errors and blame Dagger for unrelated issues in their code.\nIf we want to change it, then we can either:\n(1) change the naming scheme. Using a separator other than $ (or $$) seems to do the trick. But this will break for classes that have already been generated with the current naming scheme.\n(2) break the naming scheme for ParentAdapters only since after all, the only time that we declare an adapter by name is with ParentAdapters. \n. @adriancole Not directly related to the checks you are discussing, but take a look at error-prone where there are additional helpful DI checks. (See also above where I've edited the pull request comment and added some more detail about the extra checks that error-prone will give you)\n. PTAL. I've fixed all of the nits. I've also added a check that @Provides methods are only declared in modules. In regards to custom scoping: my understanding was that the plan is to add support for it which is why I added the checks.\n. PTAL (moved elementToString() to Util and also refactored ModuleAdapterProcessor and InjectAdapterProcessor to use it)\n. I've added the ability to suppress the warnings that I introduced (and also suppressed them in GraphVisualizerTest where we intentionally have qualified fields without @Inject). So please take another look. Thanks!\n. PTAL-Added tests for the arrays form of @SuppressWarnings and squashed. \n. Nope-removed it. Thanks!\n. @adriancole In regards to the check you wanted for @c.g.i.Provides in dagger modules, I discussed this with @gk5885 and @cgruber and a good way to achieve this without using defensive checks is:\nCheck that @dagger.Provides is only used in classes annotated with @dagger.Module and that @c.g.i.Provides is only used in classes that extend c.g.i.AbstractModule. (The first one is already in Dagger as you requested :-) )\nDoing it this way is nice and clean as\n- If a class fits the criteria of both, then both annotations can be used\n- If we want to protect against some other DI framework's annotations, we just add a check to validate that they are being used correctly, but don't have to rewrite our existing checks to now forbid more annotations.\nI'm going to go ahead and add these checks to error-prone.\n. Hadn't thought it through, but yes.\n. PTAL. \n. PTAL\n. I squashed to two commits separating the fixes from the pure refactoring. Can squash to one if you prefer\n. PTAL\n. This is awesome!\n. writer.emitPackage() itself emits an empty line. Was having two empty lines intentional?\n. Fixed.\n. Fixed.\n. Fixed.\n. Changed.\n. Changed and did the same in validateScoping().\n. removed.\n. I looked at a few of the existing tests, and they were all 1.5\n. removed(and removed from the next line as well)\n. Fixed.\n. Yes. I've added a new method, validateProvides(),  to do that. I couldn't just add it here though, since this method was only going to be called on scoped or qualified @Provides methods whereas we would want to check all @Provides methods.\n. Done.\n. Done.\n. Done.\n. Fixed all of these.\n. Fixed.\n. Done.\n. Done.\n. Fixed.\n. Added.\n. Moved, and also refactored to use this method in InjectAdapterProcessor and ModuleAdapterProcessor\n. The commented question on this line is intended for code review.\n. So getCanonicalName() seems to have been used intentionally. See https://github.com/square/dagger/commit/5ac493eee74bf08fc72fa19408dcfd4de3d5ed67. \n. Will do. (This actually all predates me. I just moved it.)\n. Again in light of https://github.com/square/dagger/commit/5ac493eee74bf08fc72fa19408dcfd4de3d5ed67 should I leave getCannonicalName() for both of them?\n. This was how I understood the proposal in #303. Do you want me to revert all of them? I also changed:\n- fieldName()->createFieldName()\n- parameterName()->createParameterName()\n. Although combining 381 and 382 as is will be a line length violation. I can change it to:\nwriter.emitStatement( \"%s = \"\n      + \"(%s) linker.requestBinding(%s, %s.class, getClass().getClassLoader(), false, true)\",\n      \"supertype\",\nbut I think the original way might be clearer.\n. what about this one?\n. and this one?\n. reverting this one too.\n. reverting.\n. changed to implementedInterfaces\n. reverted to strippedTypeName\n. Also what do you mean by it knows what's imported? Does JavaWriter keep state? Or can we just move this method there as is--i.e. we would provide the same parameters but just move it to JavaWriter?\n. nevermind--I took a look at JavaWriter source code\n. ",
    "poblish": "Ah, that's strange. Running within Eclipse and doing 'mvn test' (from within E) both produce the error. As soon as I switch to 'mvn clean install' (from command line), it works, and having done that, both the Eclipse and 'mvn test' runs subsequently work.\n. OK if I close this question? I've learned that if I get this problem I just need to do a clean build, and that this isn't dagger's fault. (I'm actually using dagger with Play 2.1 - successfully for the most part - but am having to do cleans quite often.)\n. ",
    "ouchadam": "Intellij would not generate our sources till we removed:\n<optional>true</optional>\n(multi module project).\n. ",
    "gowrojisunil": "having the same problem with eclipse . i have loaded dagger and its annotations.unable to work through it\n. ",
    "rifatdover": "I'm also facing the same problem\n. ",
    "sharyuke": "I got this problem too.... how can i fix?\n. ",
    "chakrit": "Also found another issue, even if I reduce the number of overrides to only 1-step. When I call ObjectGraph.inject inside the library project, I only get the library project's version of DataObject but when I call inject outside the library project I get the correct version for the same class.\n. Hmm the second issue happens only if I build the ObjectGraph using .plus. If I change the .plus line and only call ObjectGraph.create with all modules concatenated, this does not happen :/\n. Closing this as I've found a workaround.\n. That is a bit complicated to do since if we requires an init method to be called, that means all the class's dependents needs to call it before the object becomes usable \u2014 breaking the DI/IoC principle.\nWe could use the factory pattern, but that is combersome/complicated and is the reason why we're using dagger in the first place. And constructor injection has its own set of inconveniences as the OP said. @Provider mode also doesn't scale well once you have a number of classes in your projects that needs some kind of initialization.\n. The main reason for this (at least for me) is that constructor injection is cumbersome (as if Java wasn't cumbersome enough already). Using constructor injections would of course be more \"unbroken\" but that means we have to save all the dependency references (final vars or what have you) and repeat a ton of pointless this.a = a code. That is why I prefer property injections over ctor injection. It is basically much more straightforward and practical. But that means I then lose the ability to do after-injection initialization should there be any need to. Thus this issue.\nIMO Constructors in languages like Java should be kept as simple as possible. There is a good reason why almost all the important Android classes are designed such that you can't construct them directly yet there is almost always a well-defined way add initialization code should you need to (callba.. ahem onCreate() and friends)\n. @JakeWharton oh, that page is certinaly much more useful. Thank you!!\n. ",
    "Deminem": "+1\n. ",
    "jasta": "I modified Dagger's android-simple example to demonstrate this problem.  See: https://github.com/jasta/dagger/commits/master for source, and in particular see dvm-debug.log which shows the instrumented result of Dalvik with LOG_CLASS_LOADING 1 enabled to visualize the provider classes being loaded during ObjectGraph.create.\n. Perhaps, although I did not select Dagger as my implementation after all so I must admit that my motivation for optimizing it has gone way down since I did this investigation months ago :)\n. ",
    "mhernand40": "This seems to be caused by JDK 1.7.\nThe issue no longer repros on our Jenkins machine when I target JVM 1.6.0_37 (Sun Microsystems Inc. 20.12-b01).\nI have also verified that this repros in Ubuntu with JVM 1.7.0_40 (Oracle Corporation 24.0-b56) but gets resolved with JVM 1.6.0_45 (Sun Microsystems Inc. 20.45-b01).\n. ",
    "gadam0": "I have seen the same problem. The issue is in ModuleAdapterProcessor.\nhttps://github.com/square/dagger/blob/master/compiler/src/main/java/dagger/internal/codegen/ModuleAdapterProcessor.java#L216\nTypeMirror.equals(TypeMirror) does not indicate whether two types are the same.\nTypes.isSameType(TypeMirror, TypeMirror) is the correct comparison.\nHere is the Java 7 documentation:\nhttp://docs.oracle.com/javase/7/docs/api/javax/lang/model/type/TypeMirror.html#equals%28java.lang.Object%29\nThis class should use 'types.isSameType' instead of 'equals'.\n. ",
    "pabloogc": "Right now I'm facing the same issue running Android Studio 2.0.11, gradle 0.5.5 and dagger 1.1.0.\nFollowing this solution: http://stackoverflow.com/questions/16683944/androidannotations-nothing-generated-empty-activity\nI managed to generate the processed sources under build/sources/apt_generated. Now I need to figure out how to make gradle actually use this sources instead of the unprocessed ones (it builds fine, crashes at runtime) but I have no idea of what part of the build configuration I have to tweak for that. Some light here would be nice :)\n. Exactly, with processed sources I mean the code generated by dagger, not the whole source. I wasn't clear there.\nI am 95% sure the problem is with gradle somehow not compiling or including the \"apt_generated\" classes in  the apk. I guess the solution comes with modifying \njava\nandroid.sourceSets[variant].java.srcDirs += ...\nbut no luck for now. If I get it working I'll post my build.gradle since I think this will be a recurring problem for newcomers.\nThank you for your help.\n. Well, finally I got it working. I really don't know if this is the best solution because of possible conflicts with flavors and things like that but for now it will do the trick.\n``` groovy\nbuildscript {\n   ...\n}\napply plugin: 'android'\nconfigurations {\n    preprocess\n}\ndependencies {\n    ...\n    preprocess 'com.squareup.dagger:dagger-compiler:1.1.0'\n    compile 'com.squareup.dagger:dagger:1.1.0'\n}\nandroid {\n    compileSdkVersion 18\n    buildToolsVersion \"18.0.0\"\ndefaultConfig {\n    minSdkVersion 14\n    targetSdkVersion 18\n}\n\n}\nandroid.applicationVariants.all { variant ->\n    //Where to place the generated code\n    variant.ext.set(\"dagger_gen_${variant.dirName}\", file(\"${project.buildDir}/source/dagger_gen/${variant.dirName}\"))\n//Do the actual preprocessor things\nvariant.javaCompile.doFirst {\n    File out = variant.ext.get(\"dagger_gen_${variant.dirName}\")\n    out.mkdirs()\n    variant.javaCompile.options.compilerArgs += [\n            '-processorpath', configurations.preprocess.getAsPath(),\n            '-s', out\n    ]\n}\n\n}\n```\n. ",
    "Kolyall": "@pabloogc Can you help me to make dagger:1.2.2 working on Android Studio? Your this last answer didn't help me...already tried.  https://github.com/square/dagger/issues/520\n. Please explain, because in your description there is no any tutorials \"how to integrate it with Android Studio\"\nOnly \"You will need to include the Dagger JAR in your application's runtime. In order to activate code generation you will need to include the compiler JAR in your build at compile time.\"\nBut how to make it? \n. ",
    "hameno": "I'm getting the same error in my android project which builds with maven - the dagger example builds fine on this machine...not sure whats different...\n$ java -version\njava version \"1.7.0_40\"\nJava(TM) SE Runtime Environment (build 1.7.0_40-b43)\nJava HotSpot(TM) 64-Bit Server VM (build 24.0-b56, mixed mode)\n. ",
    "jponge": "@swankjesse @hameno @giorgio-zamparelli \nI encountered this issue today during a lab session on middleware design and implementation where my students are using Dagger to build a components container.\nBasically it happens when you have bogus Java imports in source code, say import javax.*. The issue went away as they fixed errors, but the cast error is quite misleading. I spent some time suspecting the OpenJDK 7 build in Fedora, but it is really about Java source code :wink: \n. ",
    "zorakLA": "@cgruber \nI'm seeing this same issue with version 1.2.0 of dagger.  In a gradle build script.  I am able to build fine in eclipse.\nAdditional information\njava -version\njava version \"1.7.0_45\"\nJava(TM) SE Runtime Environment (build 1.7.0_45-b18)\nJava HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)\nI checked my source and don't have any imports like the following:\nimport some.class.*;\nAny suggestions?  Any info on the scenarios where this does manifest so that I can avoid?  Thanks\n. ",
    "acortelyou": "EDIT:\nThis exception can obscure the real errors during compilation.\nDisabling the dagger-compiler should reveal the actual problems eg bogus imports on injectable classes.\n. ",
    "gusennan": "@acortelyou thank for you pointing this out, I removed the compiler from the build.gradle and the underlying problems became evident.  Dagger w/ 1.2.0\n. ",
    "yogurtearl": "I am getting this with dagger 1.2.1 and javac 1.7.0_55 on Mac OS 10.9.3.\nIf I remove the dagger-compiler dependency, it compiles fine.\nUPDATE: I had some issues with a module in another sub-project, that wasn't get re-built because of the way I was invoking gradle. After I recompiled all the sub-projects it worked.\nAn annotation processor threw an uncaught exception.\nConsult the following stack trace for details.\njava.lang.ClassCastException: com.sun.tools.javac.code.Symbol$VarSymbol cannot be cast to javax.lang.model.element.ExecutableElement\n    at dagger.internal.codegen.ModuleAdapterProcessor.providerMethodsByClass(ModuleAdapterProcessor.java:172)\n    at dagger.internal.codegen.ModuleAdapterProcessor.process(ModuleAdapterProcessor.java:98)\n    at com.sun.tools.javac.processing.JavacProcessingEnvironment.callProcessor(JavacProcessingEnvironment.java:793)\n    at com.sun.tools.javac.processing.JavacProcessingEnvironment.discoverAndRunProcs(JavacProcessingEnvironment.java:722)\n    at com.sun.tools.javac.processing.JavacProcessingEnvironment.access$1700(JavacProcessingEnvironment.java:97)\n    at com.sun.tools.javac.processing.JavacProcessingEnvironment$Round.run(JavacProcessingEnvironment.java:1029)\n    at com.sun.tools.javac.processing.JavacProcessingEnvironment.doProcessing(JavacProcessingEnvironment.java:1163)\n    at com.sun.tools.javac.main.JavaCompiler.processAnnotations(JavaCompiler.java:1108)\n    at com.sun.tools.javac.main.JavaCompiler.compile(JavaCompiler.java:824)\n    at com.sun.tools.javac.main.Main.compile(Main.java:439)\n    at com.sun.tools.javac.main.Main.compile(Main.java:353)\n    at com.google.errorprone.ErrorProneCompiler.compile(ErrorProneCompiler.java:154)\n    at com.sun.tools.javac.main.Main.compile(Main.java:342)\n    at com.sun.tools.javac.main.Main.compile(Main.java:333)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at net.ltgt.gradle.errorprone.ErrorProneCompiler.execute(ErrorProneCompiler.java:85)\n    at net.ltgt.gradle.errorprone.ErrorProneCompiler.execute(ErrorProneCompiler.java:25)\n    at org.gradle.api.internal.tasks.compile.CleaningJavaCompilerSupport.execute(CleaningJavaCompilerSupport.java:33)\n    at org.gradle.api.internal.tasks.compile.CleaningJavaCompilerSupport.execute(CleaningJavaCompilerSupport.java:24)\n    at org.gradle.api.tasks.compile.Compile.performCompilation(Compile.java:165)\n    at org.gradle.api.tasks.compile.Compile.compile(Compile.java:153)\n    at org.gradle.api.tasks.compile.Compile.compile(Compile.java:87)\n    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)\n    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n    at java.lang.reflect.Method.invoke(Method.java:606)\n    at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:63)\n    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$IncrementalTaskAction.doExecute(AnnotationProcessingTaskFactory.java:236)\n    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:212)\n    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$IncrementalTaskAction.execute(AnnotationProcessingTaskFactory.java:223)\n    at org.gradle.api.internal.project.taskfactory.AnnotationProcessingTaskFactory$StandardTaskAction.execute(AnnotationProcessingTaskFactory.java:201)\n    at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:533)\n    at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:516)\n    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:80)\n    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:61)\n    at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:46)\n    at org.gradle.api.internal.tasks.execution.PostExecutionAnalysisTaskExecuter.execute(PostExecutionAnalysisTaskExecuter.java:35)\n    at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:64)\n    at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:58)\n    at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:42)\n    at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:52)\n    at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:53)\n    at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)\n    at org.gradle.api.internal.AbstractTask.executeWithoutThrowingTaskFailure(AbstractTask.java:289)\n    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.executeTask(AbstractTaskPlanExecutor.java:79)\n    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.processTask(AbstractTaskPlanExecutor.java:63)\n    at org.gradle.execution.taskgraph.AbstractTaskPlanExecutor$TaskExecutorWorker.run(AbstractTaskPlanExecutor.java:51)\n    at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor.process(DefaultTaskPlanExecutor.java:23)\n    at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter.execute(DefaultTaskGraphExecuter.java:86)\n    at org.gradle.execution.SelectedTaskExecutionAction.execute(SelectedTaskExecutionAction.java:29)\n    at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:61)\n    at org.gradle.execution.DefaultBuildExecuter.access$200(DefaultBuildExecuter.java:23)\n    at org.gradle.execution.DefaultBuildExecuter$2.proceed(DefaultBuildExecuter.java:67)\n    at org.gradle.execution.DryRunBuildExecutionAction.execute(DryRunBuildExecutionAction.java:32)\n    at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:61)\n    at org.gradle.execution.DefaultBuildExecuter.execute(DefaultBuildExecuter.java:54)\n    at org.gradle.initialization.DefaultGradleLauncher.doBuildStages(DefaultGradleLauncher.java:166)\n    at org.gradle.initialization.DefaultGradleLauncher.doBuild(DefaultGradleLauncher.java:113)\n    at org.gradle.initialization.DefaultGradleLauncher.run(DefaultGradleLauncher.java:81)\n    at org.gradle.launcher.exec.InProcessBuildActionExecuter$DefaultBuildController.run(InProcessBuildActionExecuter.java:64)\n    at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:33)\n    at org.gradle.launcher.cli.ExecuteBuildAction.run(ExecuteBuildAction.java:24)\n    at org.gradle.launcher.exec.InProcessBuildActionExecuter.execute(InProcessBuildActionExecuter.java:35)\n    at org.gradle.launcher.daemon.server.exec.ExecuteBuild.doBuild(ExecuteBuild.java:45)\n    at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:34)\n    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)\n    at org.gradle.launcher.daemon.server.exec.WatchForDisconnection.execute(WatchForDisconnection.java:42)\n    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)\n    at org.gradle.launcher.daemon.server.exec.ResetDeprecationLogger.execute(ResetDeprecationLogger.java:24)\n    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)\n    at org.gradle.launcher.daemon.server.exec.StartStopIfBuildAndStop.execute(StartStopIfBuildAndStop.java:33)\n    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)\n    at org.gradle.launcher.daemon.server.exec.ReturnResult.execute(ReturnResult.java:34)\n    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)\n    at org.gradle.launcher.daemon.server.exec.ForwardClientInput$2.call(ForwardClientInput.java:71)\n    at org.gradle.launcher.daemon.server.exec.ForwardClientInput$2.call(ForwardClientInput.java:69)\n    at org.gradle.util.Swapper.swap(Swapper.java:38)\n    at org.gradle.launcher.daemon.server.exec.ForwardClientInput.execute(ForwardClientInput.java:69)\n    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)\n    at org.gradle.launcher.daemon.server.exec.LogToClient.doBuild(LogToClient.java:60)\n    at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:34)\n    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)\n    at org.gradle.launcher.daemon.server.exec.EstablishBuildEnvironment.doBuild(EstablishBuildEnvironment.java:60)\n    at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:34)\n    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)\n    at org.gradle.launcher.daemon.server.exec.StartBuildOrRespondWithBusy$1.run(StartBuildOrRespondWithBusy.java:45)\n    at org.gradle.launcher.daemon.server.DaemonStateCoordinator.runCommand(DaemonStateCoordinator.java:186)\n    at org.gradle.launcher.daemon.server.exec.StartBuildOrRespondWithBusy.doBuild(StartBuildOrRespondWithBusy.java:49)\n    at org.gradle.launcher.daemon.server.exec.BuildCommandOnly.execute(BuildCommandOnly.java:34)\n    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)\n    at org.gradle.launcher.daemon.server.exec.HandleStop.execute(HandleStop.java:36)\n    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)\n    at org.gradle.launcher.daemon.server.exec.DaemonHygieneAction.execute(DaemonHygieneAction.java:39)\n    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)\n    at org.gradle.launcher.daemon.server.exec.CatchAndForwardDaemonFailure.execute(CatchAndForwardDaemonFailure.java:32)\n    at org.gradle.launcher.daemon.server.exec.DaemonCommandExecution.proceed(DaemonCommandExecution.java:125)\n    at org.gradle.launcher.daemon.server.exec.DefaultDaemonCommandExecuter.executeCommand(DefaultDaemonCommandExecuter.java:51)\n    at org.gradle.launcher.daemon.server.DefaultIncomingConnectionHandler$ConnectionWorker.handleCommand(DefaultIncomingConnectionHandler.java:155)\n    at org.gradle.launcher.daemon.server.DefaultIncomingConnectionHandler$ConnectionWorker.receiveAndHandleCommand(DefaultIncomingConnectionHandler.java:128)\n    at org.gradle.launcher.daemon.server.DefaultIncomingConnectionHandler$ConnectionWorker.run(DefaultIncomingConnectionHandler.java:116)\n    at org.gradle.internal.concurrent.DefaultExecutorFactory$StoppableExecutorImpl$1.run(DefaultExecutorFactory.java:64)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n    at java.lang.Thread.run(Thread.java:745)\n. I still get this all the time in Dagger 1.2.2, when I have a dependency that needs to be rebuilt. Rebuilding the dependency makes the error go away.\n. This issues seem to happen reproducibly if you are missing an import of a custom Qualifier annotation after an @Inject\nE.g. \njava\n    @Inject @Foo String foo;\nwhere you didn't import the Foo annotation.\nThis error seems to be pre-empting the compiler error for \"Symbol Foo not found\".\nSo the code would NOT compile anyway, but you are not seeing a helpful compiler error.\n. We just ran into this again. \nWe erroneously had this:\nimport com.sun.istack.internal.Nullable;\nWorked fine on JDK 8, but got ClassCastException: com.sun.tools.javac.code.Symbol$VarSymbol cannot be cast to javax.lang.model.element.ExecutableElement using JDK 7\nCan not find com.sun.istack.internal.Nullable would have been a much more helpful error.\n. Doh. thanks.\n. Awesome, thanks.\nOn Monday, July 21, 2014, Jake Wharton notifications@github.com wrote:\n\nPushed a 1.2.2 to Maven central. Expect to see it in a few hours.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/424#issuecomment-49682395.\n. It seems this was caused by excluding guava from a Java only sub module of my Android project.\nI don't want guava in my APK ( because of the method count ).\n\nThe Java plugin doesn't have \"provided\" dependancies, so I had put this:\ngroovy\n  compile ('com.squareup.dagger:dagger-compiler:1.2.2') {\n    exclude group: 'com.google.guava'\n  }\nThat caused the exception above, so I worked around this by adding an excludes to the submodule dependency in the build file for my Android application module.\ngroovy\n compile (project(':myDaggerJavaSubModule')){\n    exclude group: 'com.google.guava'\n  }\nSeems like there should be a better way... \nAlso, the above exception doesn't not make it obvious that the root problem is a missing guava dependency.\n. Thanks for the tips! \nI will leave this open, as I think the error message could/should be improved. Feel free to close if you think otherwise.\n. ",
    "gervaisb": "+1 for the @jponge solution.\nRemoavong all * imports made the trick. (In my case it was android.graphics.*) \n. ",
    "srayhunter": "I ran into the same issue with missing imports on annotations. I refactored some annotations and missed some imports. Once I added the imports for the annotations, everything compiled fine.\n. ",
    "agrosner": "do any of you guys having issues here also use an Android library with annotation processing? It appears to be happening in DBFlow as well: https://github.com/Raizlabs/DBFlow/issues/429\n. I have done some research and strongly think its the combination of a java project with annotation processing with an android project with annotation processing. I have filed an issue here: https://code.google.com/p/android/issues/detail?id=192476&can=4&colspec=ID%20Type%20Status%20Owner%20Summary%20Stars\n. ",
    "siejkowski": "I got the same error on \"1.7.0_21\". Oracle JVM, Linux, 64-bits.\n. One workaround that I used was simply using Java 1.6, but obviously it won't be a solution for every project.\n. ",
    "kayone": "I get the same error when trying to use Dagger with Android Annotations.\nIs there a work around available that I could use for now?\n. I hate to be that guy, but any idea when a release with this fix will be available?\n. ",
    "screendriver": "I've got the same issue. I want to use Dagger and AndroidAnnotations at the same time.\n. :+1: It works! :tada:\nDagger + Androidannotations finally works together.\n. Let me know if you need a sample project\n. :+1: it works. Thank you\n. ",
    "amangel": "If I add the addsTo=MainModule.class then it gives a compile time warning for the duplicate binding.\n. ",
    "f2prateek": "whoops\n. Ref #325 \n. How would you suggest we demo a gradle example? You could just have a separate example in the examples folder; like android-gradle maybe. I could update the Travis CI configuration to check the gradle build as well if you like.\n. Think the best way would be to add a custom scope for the java project that simulates the provided scope. Not sure of the best solution, but this could be a start http://www.sinking.in/blog/provided-scope-in-gradle/\n. Can you post the full stack trace?\n. plus is documented here - https://github.com/square/dagger/blob/master/core/src/main/java/dagger/ObjectGraph.java#L99.\nI will admit that accepting an array of Object's is a bit counterintuitive. I've occasionally passed in List<Object>  to have the code compile, but of course fail at runtime.\n. If it's runtime for the Java plugin, wouldn't the Android equivalent be apk?\n. Ah right. runtime and apk are the same however right? From the bug tracker : 'Runtime dependency - not required at compile time but should get packaged in the apk.' which would be the same as the apk scope for the Android plugin.\n. That sounds better! You can close this PR (or leave it open until the samples are in).\nIs there any disadvantage of using the compile scope for the compiler dependency with the Android plugin. It will get packaged in the apk, but is that such a bad thing (still likely to be better than the reflection fallback)?\n. That's already in the .gitignore a couple of lines up.\nOn Jan 20, 2014 2:29 AM, \"Thomas Broyer\" notifications@github.com wrote:\n\nIn .gitignore:\n\n@@ -21,3 +21,5 @@ classes\n obj\n.DS_Store\n+\n+.gradle\n\nShouldn't there be build/ too?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/square/dagger/pull/378/files#r8999604\n.\n. \n",
    "jbeder": "I see what you mean - I think you could make an argument for either direction for the arrow; I was thinking of the lazy.get() call as fake method that looks like\nFoo provideTheRealFoo(Lazy<Foo> lazy) { ... }\n(I sorta view all providers, e.g. from T to U, as maps from Lazy<T> to Lazy<U>, which leads me to this viewpoint.)\nBut you're right, it could be viewed the other way, and they both naturally depend on a Provider.\nGiven that there are multiple ways of thinking about this, I like the idea of having a specialized \"lazy\" edge.\n. Heh, no, I didn't mean as a @Provides method, just a way to think about dependencies.\nYou can think about Lazy<T> as a monad, with provider methods looking like T -> Lazy<U>; you can ask gak about all the horrible ways I've been trying to use Dagger :)\nThanks for taking a look!\n. I like it!\n. ",
    "marcoRS": "I am also seeing this error in Android Studio as well as when running \"mvn clean install\". I tried upgrading to 1.1.0 and this error started appearing. I also am seeing errors in the generated files about modules that are in my test project. Do the packages in the test project have to be the same as in the main project? \n. It might be possible that your project set up is not including the generated code as a source. You can check to see if it's included under  Project Settings --> Module --> Sources. \n. ",
    "kurokoda": "Sorry, to clarify, code annotation IS enabled. I've tried it both as a compiled and provided dependency. I'm getting this stack trace:\n11-04 23:33:18.037: ERROR/AndroidRuntime(916): FATAL EXCEPTION: main\n        java.lang.RuntimeException: Unable to create application com.indigocode.dagger.DemoApplication: java.lang.IllegalStateException: Module adapter for class com.indigocode.dagger.AndroidModule could not be loaded. Please ensure that code generation was run for this module.\n        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4447)\n        at android.app.ActivityThread.access$1300(ActivityThread.java:141)\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1316)\n        at android.os.Handler.dispatchMessage(Handler.java:99)\n        at android.os.Looper.loop(Looper.java:137)\n        at android.app.ActivityThread.main(ActivityThread.java:5103)\n        at java.lang.reflect.Method.invokeNative(Native Method)\n        at java.lang.reflect.Method.invoke(Method.java:525)\n        at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:737)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:553)\n        at dalvik.system.NativeStart.main(Native Method)\n        Caused by: java.lang.IllegalStateException: Module adapter for class com.indigocode.dagger.AndroidModule could not be loaded. Please ensure that code generation was run for this module.\n        at dagger.internal.FailoverLoader.getModuleAdapter(FailoverLoader.java:41)\n        at dagger.internal.Modules.getAllModuleAdapters(Modules.java:43)\n        at dagger.ObjectGraph$DaggerObjectGraph.makeGraph(ObjectGraph.java:167)\n        at dagger.ObjectGraph$DaggerObjectGraph.access$000(ObjectGraph.java:134)\n        at dagger.ObjectGraph.create(ObjectGraph.java:126)\n        at com.indigocode.dagger.DemoApplication.onCreate(DemoApplication.java:32)\n        at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1007)\n        at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4444)\n        ... 10 more\nAnd here are my screenshots of the relevant settings.\n\n\n. The code itself is not being generated, as far as I can tell. It's set to be deployed to the the project's generated code folder 'gen', but no dagger-generated files are appearing in that folder. You can see that that folder is linked in this screenshot:\n\n. ",
    "xiezefan": "dagger will generate code to the folder app/gen\nso add \njava.srcDirs = 'gen'\nto you app/build.gradle like this\nsourceSets.main {\n        java.srcDirs = ['src/main/java', 'gen']\n    }\n. ",
    "mosabua": "I am going to cut a 3.8.0 release of the Android Maven Plugin that will be compatible with Maven 3.1.1, but drop support for older releases.. \n. But it will then also work with Tesla\n. Its out... should sync to central soon. 3.8.0 ... release notes and stuff later tonight. hth @JakeWharton @adriancole \n. Its all released now... want to help us with aar consumption in return ;-) ?\n. Yes... thats intentional... supporting both is a PITA and too much effort. Just force everyone to get with the times  ;-)\nBtw. @JakeWharton had no problems when I mentioned that at AnDevCon in Boston a few months ago.\n. ",
    "bartolkaruza": "Ok I changed com.squareup.dagger:dagger:1.0.1 back to com.squareup.dagger:dagger:1.1.0 and com.squareup:dagger-compiler:0.9.1 to com.squareup.dagger:dagger-compiler:1.1.0 and now the compiler is giving me all kinds of compiler errors that I'm still working on (in my code).\nThe changed groupid of dagger-compiler was what threw me off. There is two dagger-compiler packages on maven central and this tool was sending me to the wrong version; http://gradleplease.appspot.com/\nThanks\n. ",
    "markjvickers": "Here's the stack trace.\nI first hit this issue with multibinds, but the bigger issue I guess is that wildcard types generally aren't supported.\n11-11 12:47:56.199: E/AndroidRuntime(7459): FATAL EXCEPTION: main\n11-11 12:47:56.199: E/AndroidRuntime(7459): java.lang.RuntimeException: Unable to create application com.meh.hammurabi.Hammurabi: java.lang.NullPointerException\n11-11 12:47:56.199: E/AndroidRuntime(7459):     at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4599)\n11-11 12:47:56.199: E/AndroidRuntime(7459):     at android.app.ActivityThread.access$1400(ActivityThread.java:152)\n11-11 12:47:56.199: E/AndroidRuntime(7459):     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1342)\n11-11 12:47:56.199: E/AndroidRuntime(7459):     at android.os.Handler.dispatchMessage(Handler.java:99)\n11-11 12:47:56.199: E/AndroidRuntime(7459):     at android.os.Looper.loop(Looper.java:137)\n11-11 12:47:56.199: E/AndroidRuntime(7459):     at android.app.ActivityThread.main(ActivityThread.java:5328)\n11-11 12:47:56.199: E/AndroidRuntime(7459):     at java.lang.reflect.Method.invokeNative(Native Method)\n11-11 12:47:56.199: E/AndroidRuntime(7459):     at java.lang.reflect.Method.invoke(Method.java:511)\n11-11 12:47:56.199: E/AndroidRuntime(7459):     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1102)\n11-11 12:47:56.199: E/AndroidRuntime(7459):     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:869)\n11-11 12:47:56.199: E/AndroidRuntime(7459):     at dalvik.system.NativeStart.main(Native Method)\n11-11 12:47:56.199: E/AndroidRuntime(7459): Caused by: java.lang.NullPointerException\n11-11 12:47:56.199: E/AndroidRuntime(7459):     at com.meh.hammurabi.Hammurabi.initModules(Hammurabi.java:46)\n11-11 12:47:56.199: E/AndroidRuntime(7459):     at com.meh.hammurabi.Hammurabi.onCreate(Hammurabi.java:35)\n11-11 12:47:56.199: E/AndroidRuntime(7459):     at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1017)\n11-11 12:47:56.199: E/AndroidRuntime(7459):     at android.app.ActivityThread.handleBindApplication(ActivityThread.java:4596)\n11-11 12:47:56.199: E/AndroidRuntime(7459):     ... 10 more\n. ",
    "AlexeyBuzdin": "Hello, are there any news about 1.2 release? It would be very nice to have a fix for #322\nThank you in advance\n. ",
    "JayNewstrom": "Any update on a planned release date?\n. ",
    "orira": "attached below\ndependencies {\n    compile 'com.jakewharton:butterknife:4.0.1'\n    compile 'com.squareup.dagger:dagger-compiler:1.0.1'\n    compile 'com.squareup.dagger:dagger:1.0.1'\n    compile files('/Users/wadereweti/Projects/dependencies/activeandroid-3.1-beta.jar')\n }\nThanks\n. thanks cgruber, but I would've thought, given it's available at compile time, it would be available at runtime.\nhaving to write both\ncompile 'com.squareup.dagger:dagger-compiler:1.0.1'\ncompile 'com.squareup.dagger:dagger:1.0.1'\nruntime 'com.squareup.dagger:dagger-compiler:1.0.1'\nruntime 'com.squareup.dagger:dagger:1.0.1'\ndoesn't seem right to me\n. yep right you are, thanks man.\n. ",
    "felipecsl": "I started getting this with Android Studio 0.9.0 and build tools 21.1.0. I had compile for dagger and dagger-compiler before, which was working well.\nAfter the update, setting dagger-compiler to apt fixed the problem.\n. ",
    "ahri": "Turns out it was my buildr config at fault, so many apologies for thinking it was an issue with Dagger!\n. ",
    "johnlcox": "With the ObjectGraph being deprecated will there be something equivalent to ObjectGraph#get(type)?\n. So what if you just have a Class<?> that you need to get an instance of?\nFor instance for dagger/jersey integration: https://github.com/johnlcox/dagger-servlet/blob/master/dagger-jersey/src/main/java/com/leacox/dagger/jersey/DaggerComponentProviderFactory.java#L180\n. That definitely makes sense. The dagger-jersey project was a quick attempt at getting dagger integration with Jersey and it works, but does require marking a lot of classes as injects on the module.\n. ",
    "thatsIch": "Works fine for me in 1.2.1\n. You are not forced to create a module for every type but a @Provides method for every type.\n. ",
    "benjamin-bader": "Relevant eclipse session data:\neclipse.buildId=v22.0.5-757759\njava.version=1.7.0_25\njava.vendor=Oracle Corporation\nBootLoader constants: OS=macosx, ARCH=x86_64, WS=cocoa, NL=en_US\nFramework arguments:  -product com.android.ide.eclipse.adt.package.product -keyring /Users/ben/.eclipse_keyring -showlocation\nCommand-line arguments:  -os macosx -ws cocoa -arch x86_64 -product com.android.ide.eclipse.adt.package.product -keyring /Users/ben/.eclipse_keyring -showlocation\n. ",
    "BraisGabin": "This warnning appeared after a git pull with conflicts. A clean fix the problem.\nDagger version 1.2.1\nGraph visualization failed. Please report this as a bug.\njavax.annotation.processing.FilerException: Source file already created: /Project/.apt_generated/com/company/product/dagger/ApiModule.dot\nat org.eclipse.jdt.internal.apt.pluggable.core.filer.IdeFilerImpl.createResource(IdeFilerImpl.java:96)\nat dagger.internal.codegen.GraphAnalysisProcessor.writeDotFile(GraphAnalysisProcessor.java:372)\nat dagger.internal.codegen.GraphAnalysisProcessor.process(GraphAnalysisProcessor.java:137)\nat org.eclipse.jdt.internal.compiler.apt.dispatch.RoundDispatcher.handleProcessor(RoundDispatcher.java:139)\nat org.eclipse.jdt.internal.compiler.apt.dispatch.RoundDispatcher.round(RoundDispatcher.java:110)\nat org.eclipse.jdt.internal.compiler.apt.dispatch.BaseAnnotationProcessorManager.processAnnotations(BaseAnnotationProcessorManager.java:159)\nat org.eclipse.jdt.internal.apt.pluggable.core.dispatch.IdeAnnotationProcessorManager.processAnnotations(IdeAnnotationProcessorManager.java:134)\nat org.eclipse.jdt.internal.compiler.Compiler.processAnnotations(Compiler.java:846)\nat org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:434)\nat org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:451)\nat org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:365)\nat org.eclipse.jdt.internal.core.builder.IncrementalImageBuilder.compile(IncrementalImageBuilder.java:329)\nat org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:302)\nat org.eclipse.jdt.internal.core.builder.IncrementalImageBuilder.build(IncrementalImageBuilder.java:134)\nat org.eclipse.jdt.internal.core.builder.JavaBuilder.buildDeltas(JavaBuilder.java:265)\nat org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:193)\nat org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:726)\nat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\nat org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:199)\nat org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:239)\nat org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:292)\nat org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)\nat org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:295)\nat org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:351)\nat org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:374)\nat org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)\nat org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)\nat org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)\n. ",
    "mattprecious": "I guess this is less of a parent/child relationship and more about separating my modules into related components. I have ModuleA which provides my application context and some singleton classes that handle notifications and alarms. I have ModuleB which handles all of the preferences for my app. ModuleA includes ModuleB, and ModuleB relies on some things that ModuleA provides, so the validation fails unless I mark them both as libraries and not completed. Is there a better method of separating these?\n. SGTM. Thanks for the help!\n. On that note, does MyReusableModule need to be marked as library = true since it's not consuming Foo? My ModuleB provides a binding that it doesn't use within ModuleB, so validation is failing unless I mark it as a library.\n. Hmm, the compiler says otherwise.\nGraph validation failed: You have these unused @Provider methods:\n    1. com.mattprecious....\n    Set library=true in your module to disable this check.\nThis is in my module that has complete = false.\n. Ah, gotcha. I think in my case I do need library = true, since I kind of have a dependency cycle going.\n```\n@Module(complete=false, library = true)\nclass MyReusableModule { \n  // Expect bar to be provided but we don't know where.\n  @Provides Foo provideFoo(Bar bar) { ... }\n}\n@Module(includes=MyReusableModule.class) \nclass MyAppModule {\n  // Provide Bar to satisfy MyResuableModule.\n  @Provides Bar provideBar() { return MyAppBar(); }\n@Provides Baz provideBaz(Foo foo) { return new Baz(foo); }\n}\n```\n. ",
    "JoeMaher": "Still a massive help after all these years, thanks @mattprecious and @cgruber \n. ",
    "mjurkus": "Thanks for clearing that up!\n. But this is not the case.Proguard is not used. Application is minSdkVersion=14.\n. @JakeWharton Yes, API 14 and 15 only.\n. ",
    "dgandhi17": "@cgruber  can you explain the use of injects = {} why we write activity or fragment class name into this ?\n. @JakeWharton @DjBushido  I have a doubt about this code \n@Module (\n    injects = {\n        MainActivity.class,\n        DaggerAAExample.class\n    }\n)\nwhy we need to add injects {} in module or when or where we should use this annotation.\nWhat i understood is the methods which this module provides can be injectable into only this two classes defined into injects {} ?\ncorrect me if i am wrong .... \n. ",
    "juanmendez": "You will also get the error if your appModule and activityModule both are injecting the same activity member. So maybe you start off with appModule and create activityModule, make sure this is not the case.\n. ",
    "andaag": "Also affects 1.2.1, no reply from kaspersky yet.\n. Kaspersky has confirmed a false positive and has fixed the issue. \n. That's a workaround specific to roboeletric. Has anyone actually gotten this working with for example espresso and the default android toolchain?\n. ",
    "vinc3m1": "So after some more tinkering I've noticed that the above was happening because of the no args constructor that TabAdapter has which dagger was using to create an instance with. I haven't been able to reproduce the above again, instead I get crashes.\nMy setup is as follows:\n- ApplicationModule is the base Application ObjectGraph\n- VenueModule is the activity scope module, correctly defined with addsTo\n- VenueActivity has TabFragment as a child.\nVenueModule annotation:\njava\n@Module(\n    injects = {\n        TabFragment.class,\n        VenueActivity.class\n    },\n    addsTo = AppModule.class,\n)\npublic class VenueModule {\n  @Provides @Singleton TabAdapter provideTabAdapter() {\n    // if was is a no-args constructor, dagger still finds it and creates an instance\n    return new TabAdapter(\"asdfads\");\n  }\n}\nMy VenueActivity is as follows:\n``` java\nprivate ObjectGraph objectGraph;\n@Inject SessionManager sessionManager; // this comes from ApplicationModule\n@Inject TabAdapter mAdapter; // this comes from VenueModule\n@Override protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    objectGraph = DashApp.get(this).getObjectGraph().plus(new VenueModule(this));\n    objectGraph.inject(this);\n    // ...\n}\n```\nTabFragment also uses the VenueActivity extended ObjectGraph to inject itself in onActivityCreated\nThis is the weird part:\n- All injection works fine on the Fragment\n- All injection passes compile time validation\n- If I try to inject anything from VenueModule into VenueActivity, it crashes and doesn't see the @Provides functions:\nme.dashwith.ui.venue.tab.TabAdapter has no injectable members. Do you want to add an injectable constructor? required by class me.dashwith.ui.venue.VenueActivity\n- If I remove the injections from VenueModule in VenueActivity, things work fine\nSo why wouldn't the Activity be able to inject itself if the Fragment injection works fine? Is the objectgraph not ready if I inject with it right away? This doesn't seem to make sense...\n. Wow. Turns out I had a subclass of VenueActivity, DemoVenueActivity, which I forgot to list under injects. I'm not sure if messaging can be improved in this case? or why that subclass causes problems?\n. ",
    "rosshambrick": "I'm seeing the same issue here on a class that was added in api 17.  Was a resolution or workaround ever found for this?\n. ",
    "matbos": "Indeed that fixes it.\nThank you and sorry for an unnecessaty ticket.\n. ",
    "rtack": "already done before opening pull request.\n. ",
    "cable729": "@JakeWharton Interesting, that's not how it's working for me. I'll see if I can get it down to a minimal reproducable state.\n. ",
    "kkocel": "If You are using other libraries (especially Google Play Services or Guava) it's quite possible that You hit the limit of a dex file. It was discussed eg. here: https://www.facebook.com/notes/facebook-engineering/under-the-hood-dalvik-patch-for-facebook-for-android/10151345597798920\nExamine Your libraries, and count methods in a dex file http://stackoverflow.com/questions/14023397/is-there-a-way-to-get-count-of-number-methods-used-in-a-jar-file\nThen use proguard or jarjar links to cut out some unused methods.\n. ",
    "kamoljan": "@JakeWharton Thank you I just realised it. But you already responded!!!\nThank you for your super fast responses!!! :+1: \n. @JakeWharton I am in AS and Gradle cannot find that 1.2.2 version.\nHere the error AS Messages:\nError:Failed to find: com.squareup.dagger:dagger-compiler:1.2.2\nHowever, with version 1.2.1 it works\n. I do have\n```\napply plugin: 'com.android.application'\ndef versionMajor = 2\ndef versionMinor = 0\ndef versionPatch = 6\ndef versionBuild = 0 // bump for dogfood builds, public betas, etc.\nandroid {\n    compileSdkVersion 19\n    buildToolsVersion '19.1.0'\n    defaultConfig {\n        applicationId 'org.kamol.shopobrol'\n        minSdkVersion 16\n        targetSdkVersion 19\n    versionCode versionMajor * 10000 + versionMinor * 1000 + versionPatch * 100 + versionBuild\n    versionName \"${versionMajor}.${versionMinor}.${versionPatch}\"\n}\nbuildTypes {\n    release {\n        runProguard false\n        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'\n   }\n}\ncompileOptions {\n    sourceCompatibility JavaVersion.VERSION_1_7\n    targetCompatibility JavaVersion.VERSION_1_7\n}\nproductFlavors {\n}\n\n}\nrepositories {\n    mavenCentral()\n    maven { url 'https://repo.commonsware.com.s3.amazonaws.com' }\n}\ndependencies {\n    compile fileTree(dir: 'libs', include: ['*.jar'])\n    compile project(':libraries:facebook')\n    compile 'com.android.support:support-v4:20.0.0'\n    compile 'com.squareup.okhttp:okhttp-urlconnection:2.0.0'\n    compile 'com.squareup.okhttp:okhttp:2.0.0'\n    compile 'com.squareup.picasso:picasso:2.3.3'\n    compile 'com.squareup.retrofit:retrofit:1.6.1'\n    debugCompile 'com.squareup.retrofit:retrofit-mock:1.6.1'\n    compile 'com.squareup.dagger:dagger:1.2.2'\n    provided 'com.squareup.dagger:dagger-compiler:1.2.2'\n    compile 'com.jakewharton:butterknife:5.1.1'\n    compile 'com.jakewharton.timber:timber:2.4.1'\n    compile 'com.netflix.rxjava:rxjava-core:0.19.6'\n    compile 'com.netflix.rxjava:rxjava-android:0.19.6'\n    compile 'com.etsy.android.grid:library:1.0.5'\n    androidTestCompile 'com.jayway.android.robotium:robotium-solo:5.2.1'\n    compile 'com.mixpanel.android:mixpanel-android:4.2.2@aar'\n    compile 'com.commonsware.cwac:camera:0.6.9'\n    compile 'de.greenrobot:eventbus:2.2.1'\n}\n```\n. @Zubnix thank you for your response\n. ",
    "jskierbi": "As stated in javadocs, this method throws: \n\nIllegalArgumentException if type is not one of this object graph's injectable types. \n\nAs I understand, your SomePresenter is not an injectible type, instead being provided in two named flavours in a module. Correct me if I'm wrong - but it seems that dagger won't let You do that.\n. ",
    "aryaxt": "Thanks for the quick response. Yes, SomePresenter is being provided by my module.\nI guess I have to find another way around this.\n. Thanks for the great answers. I took the provider approach.\n. ",
    "RomanZhilich": "Looks like this example is outdated.\nTake a look at this one, and its usage of Dagger https://github.com/JakeWharton/u2020\n. ",
    "jrstarke": "Thanks @JakeWharton, It's now up at http://stackoverflow.com/questions/23177280/how-to-design-an-android-application-using-dagger-with-testing-in-mind\n. ",
    "MikolajKakol": "Check: https://speakerdeck.com/jakewharton/android-apps-with-dagger\n. The problem is that Dagger requires that classes that has @Provided annotation must have some kind of Injection on it's own. If class doesn't require any additional injection you need to add @Inject to default constructor. Source: https://github.com/square/dagger/blob/master/core/src/main/java/dagger/internal/Linker.java#L267\nSince you are using AndroidAnnotations it looks that you cannot inject generated classes directly, you might create some proxy class that could be injected and responsible for creating AndroidAnnotations objects.\nBTW why Dagger even requires those empty annotations for constructor?\n. ",
    "bspeice": "I totally understand why Dagger needs the @Inject annotation. The thing is, I do have @Provides bound, and included in the module. The following code is from the project I referenced earlier.\nModule:\nDaggerAAExampleModules.java\n@Module (\n    injects = {\n        MainActivity.class,\n        DaggerAAExample.class\n    }\n)\npublic class DaggerAAExampleModules {\n    @Provides\n    AAPrefs_ providePrefs() {\n        return new AAPrefs_(DaggerAAExample.getApplication());\n    }\n}\nMainActivity.java\n```\npublic class MainActivity extends ActionBarActivity {\n    @Inject\n    AAPrefs_ prefs;\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    DaggerAAExample.getApplication().inject(this);\n    setContentView(R.layout.activity_main);\n}\n// ... more code to do stuff here ...\n\n```\nDaggerAAExample.java\n```\npublic class DaggerAAExample extends Application {\nprivate ObjectGraph graph;\n\nprivate static DaggerAAExample instance;\n\npublic DaggerAAExample() {\n    instance = this;\n}\n\npublic static DaggerAAExample getApplication() {\n    return instance;\n}\n\n@Override\npublic void onCreate() {\n    graph = ObjectGraph.create(new DaggerAAExampleModules());\n    graph.inject(this);\n}\n\npublic void inject(Object o) {\n    graph.inject(o);\n}\n\n}\n```\nI've included the relevant code. Now, the trick is, Android Annotations at compile-time generates the AAPrefs_.java file. Dagger appears to find it, and the ObjectGraph appears to build successfully at compile. However, at runtime, I get the error as shown above. This is all doing a debug build, so I can't imagine that Proguard is messing anything up. I'm making sure to use an @Provides so that Dagger knows how to create the object (though as mentioned on SO, I'm not quite using the Context correctly), but at runtime, Dagger can't seem to find the constructor.\nAll I need to do for the example to work is just copy the file Android Annotations created to the src/ folder, rename it, rename the injections, and everything works. No code changes beyond the class name. That's why I'm confused.\nI apologize if we seem to be talking past each other, please let me know if there's anything else I can do to clarify the issue.\n. Correct me if I'm wrong then, but this is a legitimate issue, I'm not just using Dagger the wrong way?\nI'm going to try and see if using a factory in addition to the '@Provides' does anything.\n. ",
    "christophesmet": "I'm having the same issue.\nAny news ?\n. ",
    "Yougin": "Bumped into the same issues with a difference the Dagger-generated classes don't see AA generated classes despite those all are successfully generated. Not to make confs overcomplicated thinking about getting rid AA.\n. Meaning the classes generated by Android Annotations https://github.com/excilys/androidannotations \n. ",
    "christophecommon": "It also seems to be the case that it gives this error when you provide the same object in multiple modules.\nThis is obvious an error of mine, but maybe it helps someone.\n. ",
    "pselden": "Thanks @JakeWharton. Appreciated.\n. ",
    "roman-mazur": "Can annotation of default constructor be replaced with class annotation? Like\njava\n@Inject class Foo {\n  @Inject Bar bar;\n}\nNow implicit constructor is not needed and Foo is clearly marked as what we can depend on, isn't it?\n. As for me @Inject on a constructor does not really represents what is happening...\nWhen I look at the code\njava\nclass Foo {\n  final Bar bar;\n  @Inject Foo(Bar bar) { this.bar = bar; }\n}\nI interpret it like \"Use constructor to satisfy Foo's dependencies\".\nBut in your case of\njava\nclass Foo {\n  @Inject Bar bar;\n  @Inject Foo() { }\n}\n@Inject on constructor really means \"Foo can be provided with default implementation\", an absolutely different thing!..\nAs far as I understand the minimal is to have @Inject on fields/constructor to indicate what dependencies must be satisfied, and @Provide methods to specify how to get those dependencies. Obviously it would be nice to avoid boilerplate like\njava\n@Provide Foo foo() { \n  Foo foo = new Foo();\n  inject(foo);\n  return foo;\n}\nAnd when you use\njava\nclass Foo {\n  @Inject Bar bar;\n  @Inject Foo() { }\n}\nto avoid the bigger boilerplate above, @Inject has more to do with @Provide then with initial @Inject... Because now it answers the question \"how\". And meanings of @Inject on the constructor and on the field are completely different.\nWhat about\njava\n@Provided class Foo {\n  @Inject Bar bar;\n}\nYes I'm again about annotating classes, and this time introducing a new annotation :).\nBut I hope my reasoning makes sense...\n. Thanks, I see my mistake.\n. flaky test?\n. And can it be specified like\nlanguage:\n  - java\n  - android\n?\n. They should change language to something different...\n. ",
    "relgames": "Hi @gk5885, you mention @Inject specification http://docs.oracle.com/javaee/6/api/javax/inject/Inject.html\nAnd it clearly says:\n@Inject is optional for public, no-argument constructors when no other constructors are present. This enables injectors to invoke default constructors.\nI think you are mixing 2 different actions together:\n1) Make class providable (a candidate for instantiation), and\n2) Actually instantiate a class, injecting it's dependencies: constructor (if exists), then fields, then methods.\n@Inject annotation defines dependencies for a constructor, field or method. It makes little sense to use it for non-argument constructor (because there are no dependencies to be injected), and that's why the specification says it is optional.\n. @gk5885 I think I see your point. \nI was little bit confused by using @Inject for allowing other classes to inject a class. I came from a Spring world where multiple annotations exist: @Bean for explicitly instantiated classes (IMO it's the same as @Provides), @Autowired (@Inject) and @Service for declaring a bean valid for instantiation and DI. \nSo in Dagger, @Inject is used where in Spring I'd use separate @Autowired and @Service.\n. ",
    "ultimate-deej": "The problem solved by adding complete = false to the @Module annotation\n. So this is an analysis issue?\n. I reverted my project back, and voila it works! Have no idea what could cause the error the first time.\nJust not to look shallow: by the time this happened I was changing the code back and forth, and the error persisted\n. ",
    "ychern": "Thank you!\n. ",
    "Athou": "One solution would be to annotate generated class with @SuppressWarnings(\"all\").\n. ",
    "saturation": "Many thanks for reply!\nHere you go:\n$ java -version\njava version \"1.8.0\"\nJava(TM) SE Runtime Environment (build 1.8.0-b132)\nJava HotSpot(TM) 64-Bit Server VM (build 25.0-b70, mixed mode)\n[~/repository/dagger]\n$ mvn -version\nApache Maven 3.0.3 (r1075438; 2011-02-28 19:31:09+0200)\nMaven home: /usr/share/maven\nJava version: 1.8.0, vendor: Oracle Corporation\nJava home: /Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home/jre\nDefault locale: en_US, platform encoding: UTF-8\nOS name: \"mac os x\", version: \"10.8.5\", arch: \"x86_64\", family: \"mac\"\n. Works like charm.\nThank you.\n. ",
    "cypressious": "At least Eclipse didn't offer one. What's the parameter?\n. Nice, thank you.\n. ",
    "lin1987www": "Yes, you are right :) It is success.\nThanks you help! \nCommomLib build.gradle \ndependencies {\n    ...\n    provided 'javax.inject:javax.inject:1'\n    provided 'com.squareup:javawriter:2.5.0'\n    provided 'com.squareup.dagger:dagger-compiler:1.2.1'\n    compile 'com.squareup.dagger:dagger:1.2.1'\n    ...\n}\nMyApp build.gradle\ndependencies {\n    ...\n    provided 'javax.inject:javax.inject:1'\n    provided 'com.squareup:javawriter:2.5.0'\n    provided 'com.squareup.dagger:dagger-compiler:1.2.1'\n    ...\n}\n. thnak you!\n. ",
    "shareme": "there is a workaround... its the jul 12 comment on the same bug report..workaround link:\nhttp://chrisjenx.com/gradle-robolectric-jacoco-dagger/\n. ",
    "realdadfish": "@shareme I'm aware of this workaround, but I'd rather not use that but see a proper fix on either side :)\n. @cgruber The issue is basically that I have some components / singletons that need to be created and also partially mocked before the activity is created / fully set up, otherwise I suffer from test flakiness. So while I'd really like to just create one, the activity-scoped object graph, and inject stuff from this into my test, the creation of this graph requires a call to getActivity() from Android's instrumentation infrastructure, and unfortunately this does more than just returning some context: it creates and initializes the whole activity synchronously in the background.\nRight now I help myself by calling get() on the activity's object graph at the appropriate places and only use annotation-based injection for the base application graph.\n. Well, nicely put, point taken :-D\nI think Guice' interpretation of @Nullable is then what I'm looking for. See https://code.google.com/p/google-guice/wiki/UseNullable\n. ",
    "Zubnix": "jsr250 has a postconstruct annotation. From my own experience, if you need an after constructor 'callback' when doing DI, your design is broken, but I realize those things are unfortunately rather the norm than the exception.\nWhen doing DI, you usually first build the graph before doing business. Introducing a postconstruct callback breaks this flow as it encourages to do business while the graph is being build.\n. afaik the gradle provided does not mean it will be present on the build path, just that it should not be added to the final artifact. You have to manually add it to your build path.\nhttp://stackoverflow.com/questions/18738888/how-to-use-provided-scope-for-jar-file-in-gradle-build\nIirc gradle does not have a simple way of saying 'compile time only' and as such has horrible annotation processing support, especially in combination with javadoc generation.\n. ",
    "fbiville": "Hmmm, it does not seem to provide more information:\n```\n\u279c  vidal-rest-sdk git:(issue_1_dagger) mvn -e clean install\n[INFO] Error stacktraces are turned on.\n[INFO] Scanning for projects...\n[INFO] \n[INFO] Using the builder org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder with a thread count of 4\n[INFO]                                                                       \n[INFO] ------------------------------------------------------------------------\n[INFO] Building vidal-rest-sdk 1.0-SNAPSHOT\n[INFO] ------------------------------------------------------------------------\n[INFO] \n[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ vidal-rest-sdk ---\n[INFO] Deleting /home/flo/Projects/_VIDAL/vidal-rest-sdk/target\n[INFO] \n[INFO] --- maven-enforcer-plugin:1.3.1:enforce (enforce-versions) @ vidal-rest-sdk ---\n[INFO] \n[INFO] --- jacoco-maven-plugin:0.7.1.201405082137:prepare-agent (prepare-agent) @ vidal-rest-sdk ---\n[INFO] argLine set to -javaagent:/home/flo/.m2/repository/org/jacoco/org.jacoco.agent/0.7.1.201405082137/org.jacoco.agent-0.7.1.201405082137-runtime.jar=destfile=/home/flo/Projects/_VIDAL/vidal-rest-sdk/target/jacoco.exec\n[INFO] \n[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ vidal-rest-sdk ---\n[INFO] Using 'UTF-8' encoding to copy filtered resources.\n[INFO] skip non existing resourceDirectory /home/flo/Projects/_VIDAL/vidal-rest-sdk/src/main/resources\n[INFO] \n[INFO] --- maven-compiler-plugin:2.5.1:compile (default-compile) @ vidal-rest-sdk ---\n[INFO] Compiling 10 source files to /home/flo/Projects/_VIDAL/vidal-rest-sdk/target/classes\n[INFO] -------------------------------------------------------------\n[ERROR] COMPILATION ERROR : \n[INFO] -------------------------------------------------------------\n[ERROR] /home/flo/Projects/_VIDAL/vidal-rest-sdk/src/main/java/com/vidal/rest/sdk/VidalAPI.java:[12,7] error: Graph validation failed: You have these unused @Provider methods:\n[INFO] 1 error\n[INFO] -------------------------------------------------------------\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 1.399 s (Wall Clock)\n[INFO] Finished at: 2014-08-07T21:26:02+01:00\n[INFO] Final Memory: 15M/87M\n[INFO] ------------------------------------------------------------------------\n[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:2.5.1:compile (default-compile) on project vidal-rest-sdk: Compilation failure\n[ERROR] /home/flo/Projects/_VIDAL/vidal-rest-sdk/src/main/java/com/vidal/rest/sdk/VidalAPI.java:[12,7] error: Graph validation failed: You have these unused @Provider methods:\n[ERROR] -> [Help 1]\norg.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:2.5.1:compile (default-compile) on project vidal-rest-sdk: Compilation failure\n/home/flo/Projects/_VIDAL/vidal-rest-sdk/src/main/java/com/vidal/rest/sdk/VidalAPI.java:[12,7] error: Graph validation failed: You have these unused @Provider methods:\nat org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:212)\nat org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153)\nat org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145)\nat org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:108)\nat org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call(MultiThreadedBuilder.java:188)\nat org.apache.maven.lifecycle.internal.builder.multithreaded.MultiThreadedBuilder$1.call(MultiThreadedBuilder.java:184)\nat java.util.concurrent.FutureTask.run(FutureTask.java:266)\nat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\nat java.util.concurrent.FutureTask.run(FutureTask.java:266)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\nat java.lang.Thread.run(Thread.java:744)\n\nCaused by: org.apache.maven.plugin.CompilationFailureException: Compilation failure\n/home/flo/Projects/_VIDAL/vidal-rest-sdk/src/main/java/com/vidal/rest/sdk/VidalAPI.java:[12,7] error: Graph validation failed: You have these unused @Provider methods:\nat org.apache.maven.plugin.AbstractCompilerMojo.execute(AbstractCompilerMojo.java:729)\nat org.apache.maven.plugin.CompilerMojo.execute(CompilerMojo.java:128)\nat org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:133)\nat org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208)\n... 11 more\n\n[ERROR] \n[ERROR] Re-run Maven using the -X switch to enable full debug logging.\n[ERROR] \n[ERROR] For more information about the errors and possible solutions, please read the following articles:\n[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException\n```\n. Hurray! That's it!\nI should have RTFM on Module.class.\nHow come the faulty method was not displayed, though? Should I keep the issue open for that?\n. Sure thing\n\u279c  vidal-rest-sdk git:(issue_1_dagger) mvn -v\nApache Maven 3.2.1 (ea8b2b07643dbb1b84b6d16e1f08391b666bc1e9; 2014-02-14T18:37:52+01:00)\nMaven home: /home/flo/Tools/maven\nJava version: 1.8.0, vendor: Oracle Corporation\nJava home: /home/flo/Tools/jdk1.8.0/jre\nDefault locale: en_US, platform encoding: UTF-8\nOS name: \"linux\", version: \"3.11.0-26-generic\", arch: \"amd64\", family: \"unix\"\n. ",
    "heenenee": "I also had this problem with maven-compiler-plugin:2.5.1, but I changed to maven-compiler-plugin:3.3 and then the unused @Provider methods were successfully displayed upon compilation failure.  So it's probably some old bug in the maven-compiler-plugin failing to show multi-line error messages.\n. Additionally, the unused @Provider methods are once again suppressed if <fork>true</fork> is set on the maven-compiler-plugin configuration, even on version 3.3.  So there is still probably a bug regarding multi-line error messages in the maven-compiler-plugin.\n. ",
    "dgyuri": "@cgruber: Make sure to run \"apt-get update\" before install anything with aptitude.\nbefore_install:\n - sudo apt-get update -qq\n - sudo apt-get install -qq libstdc++6:i386 lib32z1\n...\n. ",
    "vronin": "As I understand Dagger is all about graphs.\nTaking into account that Dagger has a compiler, it can build a graph of what interfaces each class with @Inject annotation implements. And create a binding for an interface to use the class, if this is only class which implemented this interface.\n. ok. got it. make sense.\nI am closing this issue then.\n. ",
    "loeschg": "Any insight as to why this is failing for a README.md change?\n. ",
    "cykerway": "Well, that one doesn't specify what the parameter should be (its type specifically). I prefer module class objects (i.e. Module.class) since those should be what ultimately used, but I cannot confirm I'm correct on this.\n. I'm wondering why it can let in an instance since what it really wants is its class. We don't really need to new an object to get its class. If we only let in classes then I guess we can use java.lang.Class as the parameter type instead of java.lang.Object so that users know exactly what they should pass in?\n. When we have an instance Application application, shouldn't we be able to pass in application.getClass() even if only classes are allowed?\nI guess this use case may be the reason why we allow instances. But in fact I've seen many people creating instances just to get its class when they already have the class name. Maybe they have seen instances passed in in other implementations and they think the method only works with instances. The Object parameter type is not quite helpful in figuring this out.\n. In this case we have AppModule and we can call plus(AppModule.class). It doesn't matter even if plus doesn't accept non-class types.\n. I don't care much about whether it's Application or something else. I'm simply wondering what we will lose if we change the prototype from public ObjectGraph plus(Object... modules) to public ObjectGraph plus(Class... modules). A use case on this could be helpful.\n. So this actually means passing in module objects is a more direct approach? The code I wrote in the first post shows no matter we pass in module instance or module class we have to get the other. Since getClass() will always work, but adapter.newModule() only works with no-arg constructors, probably I should flip my argument as passing in module instance will always work correctly while passing in module class will sometimes lose generality?\nThen I think the doc should mention that plus is expecting module instances, since dagger will construct an instance even if we pass in module class. Mixing types and the ways of passing parameters can be confusing in this case. \n. So the modules being put in includes must have no-arg constructors? For example, the AppModule you gave above cannot be put in includes. If this is true, then how do we include this module in another module?\n. Thanks, this is very useful clarification. Just to summarize:\n1.  If we're going to call plus manually, then passing in module instances always works, while passing in module classes works when the modules have a valid no-arg constructor.\n2.  If we're going to include one module in another, then the one being included must have a valid no-arg constructor.\nMay I get a confirmation on this summarization? If I'm now correct on it I can close this issue. \nThank you.\n. All right now have something more. In the first example you gave here, ModuleC doesn't have a no-arg constructor. Is it still OK to put it in ModuleB's includes? is the includes declaration only for graph validation at compile-time? \nIf true then I guess the best coding practice is to always use module instances for ObjectGraph.create and ObjectGraph.plus since you can still includes anyway.\n. Now I think things work easily with no-arg constructors. Basically you can freely use module instances and module classes and even mix them (though not good). So I'm interested in the cases where some modules don't have no-arg constructor.\nIn the first example you gave:\n```\n@Module(includes=ModuleB.class)\nclass ModuleA { / \u2026 / }\n@Module(includes=ModuleC.class)\nclass ModuleB { / \u2026 / }\n@Module\nclass ModuleC {\n  ModuleC(SomeObject whatever) { / \u2026 / }\n}\nObjectGraph graph = ObjectGraph.create(ModuleA.class, new ModuleC(someObject));\n```\nIf I change the last line to:\nObjectGraph graph = ObjectGraph.create(ModuleA.class);\nDoes it look like Dagger will try to construct a ModuleC instance with a no-arg constructor and then fail?\n. Cool. Thanks.\n. ",
    "Xuzhiwei": "I copy the source code to my java project.I use eclipse.I not found the annotation processor.\n. ",
    "rogerp91": "Hi.!\nE/AndroidRuntime: FATAL EXCEPTION: main\njava.lang.NoClassDefFoundError: dagger.internal.FailoverLoader\nat dagger.ObjectGraph.create(ObjectGraph.java:129)\n. ",
    "rdehuyss": "I see, thanks for the input! Though I think I'll sometimes forget it and it can introduce subtle bugs. No chance this will be tackled with Dagger 2.0?\n. Ok, thanks for the input!\n. ",
    "mickmltsai": "Yes. I am sorry.\nI modify my question for more specific:\nobjectGraph = ObjectGraph.create(new module);\nobjectGraph = objectGraph.plus(moduleA);\nsome operations...\nobjectGraph = objectGraph.plus(moduleA);\nsome operations...\nobjectGraph = objectGraph.plus(moduleA);\nsome operations...\n...\nHow about the last objectGraph status? Will it contain many moduleAs(or Dagger will find out moduleA already in the objectGraph, and make plus(moduleA) invalid after first time) ?\n. I see. Many thanks for reply!\n. ",
    "CoatedMoose": "Someone else with the same issue.\nhttp://stackoverflow.com/questions/25100115/google-auto-factory-dagger-integration-dependencies-on-injected-code\n. I do not know which BasicAnnotationProcessor you are referring to. A search for filenames hasn't yielded any results (checked square/dagger and google/dagger).\n. ",
    "digitalbuddha": "Came here from SO question, I'm using Dagger 2 with AutoFactory and seeing same behavior, only works with fully qualified names.\n@Singleton\n    @Provides\n    ABManager provideABManagerImpl(com.example.android.ab.ABManagerImplFactory factory ) {\n        return factory.create(3, IMMEDIATELY);\n    }\n. @gk5885 mentions that Dagger 2 has resolved the issue, I thought it might be worth noting that extending BasicAnnotationProcessor does not fix this.\n. ",
    "jag4364u": "@digitalbuddha as you mentioned factory classes works with fully qualified names ! for me still it is not working. do you any other suggestion on this to make it work? i am using dagger<2.5> . please help.\n. ",
    "lyubomyr-shaydariv": "Oops, sorry for the dupe.\n. ",
    "dalewking": "For some reason in our code, we were validating the graph on each injection (in debug mode). I moved it to only validate after the graph is created which means this is not a high priority thing to fix, but this will serve as notification in case someone else runs into this.\n. As I said we were only doing the validation in debug mode. If there were issues we wanted to discover them during development. But as I said doing the validation for every injection was a bad idea.\n. ",
    "mortyccp": "I come up with an approach, am I correct?\nThe only thing bother me is if HostedFragment is not specified in the @Module inject, I cannot get it from the graph.\n``` java\npublic class HostActivity extends Activity {\n    private static final String FRAGMENT_TAG = \"fragment tag\";\nprivate ObjectGraph objectGraph;\nprivate HostedFragment fragment;\n@Inject LocationManager locationManager;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_host);\n\n    // Injecting fields that are required\n    objectGraph = ObjectGraph.create(new HostActivityModule(this));\n    objectGraph.inject(this);\n\n    // Injecting fragment\n    fragment = (HostedFragment) getFragmentManager().findFragmentByTag(FRAGMENT_TAG);\n    if (fragment == null) {\n        fragment = objectGraph.get(HostedFragment.class);\n        getFragmentManager().beginTransaction().add(R.id.fragment_container, fragment, FRAGMENT_TAG).commit();\n    }\n}\n\npublic static class HostedFragment extends Fragment {\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n        return inflater.inflate(R.layout.fragment_hosted, container, false);\n    }\n}\n\n@Module(\n        injects = {\n                HostActivity.class,\n                HostedFragment.class\n        },\n        library = true\n)\npublic static class HostActivityModule {\n\n    private Context mContext;\n\n    public HostActivityModule(Context mContext) {\n        this.mContext = mContext;\n    }\n\n    @Provides @Singleton HostedFragment provideHostedFragment() {\n        return new HostedFragment();\n    }\n\n    @Provides @Singleton LocationManager provideLocationManager() {\n        return (LocationManager) mContext.getSystemService(LOCATION_SERVICE);\n    }\n}\n\n}\n```\n. ",
    "kaibookblue": "So I was being incredibly stupid. :)\nThanks for the quick response.\n. ",
    "fadils": "@tbroyer is it good now? Or still missing something.\nMy apologise. Initially, I was thinking Dagger in Android Studio kind of mindset. But in fact, Dagger is more general than I initially thought. =)\nI look forward to your feedbacks.\n. ",
    "fuhaiq": "@JakeWharton So map bindings will exist in Dagger2 ?\n. @swankjesse ok, so just add 'throws' declaration in the provided method ? \njava\n@Provides Heater provideHeater() throws HeaterException{\n  return new ElectricHeater();\n}\n. That's quite enough for what I want to know, please close this issue if anyone could.\n. @JakeWharton thanks for quick response, that makes sense, I will take a look.\n. ",
    "ArthurSav": "It was an issue with multidex enabled. Fixed by adding the below line in my Application class\njava\n@Override\nprotected void attachBaseContext(Context base) {\n    super.attachBaseContext(base);\n    MultiDex.install(this);\n}\n. ",
    "cizmazia": "I use the following pattern with Guava Suppliers (for variables used in lambdas which are serialized and executed by Apache Spark in different processes):\njava\nfinal Supplier<MyObj> supplier = (Serializable & Supplier<MyObj>) () -> new MyObj();\nfinal Supplier<MyObj> lazy = Suppliers.memoize(supplier);\nIt seems that Lazy can be implemented in the same way as MemoizingSupplier. In my use case, this would eliminate the boilerplate code above.\nIntended use:\n``` java\nclass SparkComputation {\n    @Inject Lazy lazy;\npublic void run() {\n    // The lambda is executed in different processes\n    stream.map(x -> lazy.get().convert(x));\n}\n\n}\n```\nMyObj is not required to be Serializable. Binding<T> delegate in LazyBinding would need to be Serializable. Would it possible to achieve that if all the upstream graph dependencies were injected as Lazy?\n. For this kind of use cases, that is exactly the expected guarantee: one singleton instance per process.\n. It is not about my cute sample. As far as I can tell this a simplest approach for dependency injection into lambdas which are being distributed into multiple Apache Spark workers. Any pointers appreciated. \n. ",
    "gabrielsoroush": "Thanks Jake for your quick response. Unfortunately I can't share any code here.\nBut after reading this: https://code.google.com/p/android/issues/detail?id=75456 I figured it might be the gradle issue not Dagger.\n. ",
    "GeorgeGathura": "i added it and worked. \nThanks.\nI do have a question though. Considering java poet is a successor to java writer, is there a time the java writer dependency won't be required?\n. ",
    "gengjiawen": "@tbroyer It works when i use the command mvn install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=truefrom travis-ci.Thanks.\n. ",
    "jhump": "@swankjesse, my first approach I ended up tossing because it seemed riskier: it was to change the format of the key strings so that type names get encoded with slashes in the package (instead of dots) and nested classes are separated with dots (instead of dollars). For example com/squareup/Outer.Inner.Foo$Bar.Baz. That way we can unambiguously convert the string into either binary names (replace dots with dollars then replace slashes with dots) or canonical names (replace slashes with dots).\nBut this was a bigger and more complicated change which had a couple of big downsides:\n1. More work to decode keys. It looks like Keys has had some level of optimization to make it faster (for example, using String#concat instead of + operator). The new encoding would be slower.\n2. The runtime must still support code that was generated with an older version of the compiler. So the encoding must further be unambiguous about whether it was in a new vs. legacy format, and then put multiple paths in all of the decoding logic.\nThe latter point seemed riskiest because it doesn't seem easy to test. I suppose I could have added support for a system property to force it to generate keys in the legacy format. Then a unit test could run the compiler both ways and verify that the runtime works regardless of the key format that appears in generated code.\n(Easier to do, but less thorough, would be to just have unit tests for all of the methods in Keys. But, since it's just a string vs. a Key type [with encapsulation/hiding], I'd be worried that there are places outside of Keys that directly operate on the string.)\nSo, all said and done, this seemed a lot easier. It does more work in pathological cases (like a class name with a silly number of dollar signs), but in practice should be the same as without the fix since it does at least first check the version of the name with all dollars replaced with dots.\nAlso, this is not unlike the work that javac must do to resolve a class use into a binary name (it does the inverse work; naively it must do more since there are many more dots that may potentially need to be converted to dollars, but it can employ techniques to prune the search space that I don't think can apply here).\n. BTW, any tips on getting travis-ci to go green -- is it flaky? That test passes fine locally, and the error message in travis-ci is cryptic enough that I don't know where to start debugging.\n. The issue in CI was a bug in javac. I put together a trivial repro case and filed a bug with Oracle. Under some conditions, it can throw instead of return null when asking Elements#getTypeElement for an unknown type.\nI hacked in a work-around here.\n. ",
    "vackosar": "Well AspectJ does code generation at compile time, so it can be done, no?\n. ",
    "jemshit": "So we make each injectedVariable=null  on onDestroy() or any other quick\nsolution to prevent memory leak? I thought @ActivityScope etc.. on Components  destroy all injected variables after that scope (Activity) is destoyed?\nOn Fri, Feb 19, 2016, 16:59 Jake Wharton notifications@github.com wrote:\n\nDagger knows nothing about Android and thus nothing about the Android\nactivity lifecycle. Injected types are not automatically freed.\nHowever, you interpreted that issue incorrectly. It is the presenter which\nis keeping a reference to the activity and preventing the activity from\nbeing garbage collected, not the other way around.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/square/dagger/issues/519#issuecomment-186246542.\n. Ok, so the problem was Presenter keeping ref to Activity. Thanks :+1: \n. One last question, after Activity is destroyed and so its Presenter is garbage collected, does Presenter still can hold references even it is garbage collected?\n. I guess the thing i missed is Activity is destroyed does not mean it is garbage collected.\n. \n",
    "zhanjixun": "\u55ef\uff0c\u4f60\u597d\uff0c\u6709\u4e2d\u6587\u7248\u7684\u4e3b\u9875\u5417\uff0c\u6211\u7684\u82f1\u6587\u9605\u8bfb\u80fd\u529b\u6709\u70b9\u5dee\u3002\n. ",
    "Freedom000": "@JakeWharton  Well\uff0che means some description in Chinese just like wiki or papers and so on.\n. ",
    "soarcn": "There are many of them, for example http://blog.changecong.com/2014/12/daggerjianjiezhongwen/\ntry to search \"dagger \u4e2d\u6587 android\" in google or baidu.\n. ",
    "GaborPeto": "As the logs suggest:\nDo you want to add an injectable constructor?\nThis is what I usually do if I inject the class that doesn't have an injectable member. you can just add\n@Inject public void DeleteBastion() {}\nand you will not get an error. In the future if you want to inject a member in that class, just do that and remove the default constructor with the @Inject annotation.\n. ",
    "brozikcz": "Thanks for answer, but I don't understand. What do you mean about ParameterizedTypeName?\n@swankjesse I updated first comment.\n. Problem solved, my bug in mix dagger 1.2.2 from own lib and newest version 1.2.5 from main project.. ",
    "jpgpuyo": "Ok, thank you!\n. ",
    "drinkjava2": "Hi Jake,\nThank you take time to replay this issue.\nBest Regards\nYong Zhu\n2016-07-24 17:17 GMT-06:00 Jake Wharton notifications@github.com:\n\nI'm afraid this isn't a good forum for such a search. This project is on\nlong-term support, not active development.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/square/dagger/issues/541#issuecomment-234809483, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AQzyrHSEN6ROg4dWmRjw5kbAFAO0j9J_ks5qY_KlgaJpZM4JTeLU\n.\n. \n",
    "Spoortihallur": "instead of taking a pull. I requested for pull request. My Bad\n. ",
    "ronshapiro": "Whoops... this is not google/dagger...\n. https://github.com/square/dagger/commit/e85f260d7146ad4a485b298b6f24cf5c44bea269. ",
    "marciodel": "Sorry! Wrong version. . ",
    "AttwellBrian": "Ha. This is embarrassing.\nMoved to https://github.com/google/dagger/issues/621. ",
    "ifucolo": "I m using Multidex.install on my application\nThanks. ",
    "kingning1": "\u4e0d\u597d\u610f\u601d\uff0c\u758f\u5ffd\u5927\u610f\u4e86\uff01\n\u8c22\u8c22\u60a8\u5728\u767e\u5fd9\u4e4b\u4e2d\u7684\u5e2e\u52a9\u3002. ",
    "NightlyNexus": "Wrong Dagger. github.com/google/dagger is component Dagger.. ",
    "benkay": "Derp. Filed this in the wrong dagger project \ud83d\ude33. ",
    "holmes": "save the List creation and use an Array?\nnew String[]{Provider.class.getCanonicalName(), Lazy.class.getCanonicalName()}\n. ",
    "edenman": "you're fired.\n. ",
    "ben-humangeo": "I was playing around with the format because I kept getting an error for line length > 100.  New commit for reformat is available.\n. ",
    "bdparrish": "This should be added to the CONTRIBUTING.md so new contributors are aware.\n. "
}