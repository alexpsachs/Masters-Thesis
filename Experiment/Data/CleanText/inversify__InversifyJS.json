{
    "remojansen": "Implemented by e3cdb4e607f04d87062f75bbc97859b278341841\n. Implemented by 3e8ee7418cd0429988bab46f0b308c895af25356\n. Done!\n. Moved to examples repository https://github.com/inversify/inversify-code-samples/issues/4\n. Moved to examples repository https://github.com/inversify/inversify-code-samples/issues/3\n. Moved to examples repository https://github.com/inversify/inversify-code-samples/issues/2\n. Hi, we run our unit tests in browsers using karma and a bundle file which is created using browserify but we compile (from ts to js) in one task and then create a bundle (from js to js) in another task. A few releases ago we were compiling and bundling using one unique task:\n``` js\nvar gulp        = require(\"gulp\"),\n    browserify  = require(\"browserify\"),\n    tsify       = require(\"tsify\"),\n    source      = require(\"vinyl-source-stream\"),\n    buffer      = require(\"vinyl-buffer\"),\n    sourcemaps  = require(\"gulp-sourcemaps\");\ngulp.task(\"build-bundle-test\", function() {\nvar mainTsFilePath = \"test/inversify.test.ts\";\n  var outputFolder   = \"temp/\";\n  var outputFileName = \"bundle.test.js\";\nvar bundler = browserify({\n    debug: true,\n    standalone : \"inversify\"\n  });\n// TS compiler options are read from tsconfig.json file\n  return bundler.add(mainTsFilePath)\n                .plugin(tsify, { typescript: require(\"typescript\") })\n                .bundle()\n                .pipe(source(outputFileName))\n                .pipe(buffer())\n                .pipe(sourcemaps.init({ loadMaps: true }))\n                .pipe(sourcemaps.write(\".\"))\n                .pipe(gulp.dest(outputFolder));\n});\n```\nThe preceding task will read the TS compiler options from the tsconfig.json file:\njs\n{\n    \"compilerOptions\": {\n        \"target\": \"es5\",\n        \"lib\": [\"es6\", \"dom\"],\n        \"types\": [\"reflect-metadata\"],\n        \"module\": \"commonjs\",\n        \"moduleResolution\": \"node\",\n        \"experimentalDecorators\": true,\n        \"emitDecoratorMetadata\": true\n    }\n}\nYou should be able to copy the above and change the  file paths.\nIf you are going to run your app in a browser, we recommend to import reflect-metadata as a global:\nhtml\n<script src=\"./node_modules/reflect-metadata/Reflect.js\"></script>\nAs opposed to as part of the bundle:\nts\n// in your main ts file\nimport \"reflect-metadata\";\nYou can learn more at:\n- Environment support and polyfills\n- Working with module bundlers\n. I decided that this feature will not be implemented I will implement a much more powerful feature \"contextual binding\" https://github.com/inversify/InversifyJS/issues/15\n. @sanex3339 thanks for sharing that!\n. You can now use: \n```\n@inject(\"IFoo\",\"IBar\")\nclass FooBar implements IFooBar {\npublic foo : IFoo;\n  public bar : IBar;\npublic log() {\n    console.log(\"foobar\");\n  }\nconstructor(foo : IFoo, bar : IBar) {\n    this.foo = foo;\n    this.bar = bar;\n  }\n}\n```\nFor more details check out #33 \n. Closing this issue to create a more detailed one\n. Hi @mrgamer sorry for the late reply I had a crazy summer... you can use InversifyJS with vanilla javascript. Please take a look  to the example at http://inversify.io/ search for: \"The Basics (with JavaScript)\" in the page and you will be able to find a basic example.\nPlease ask me any questions here if you need additional help.\n. Hi @pixelshaded this issue should be fixed now by commits f3e7859b9301f9ef7f73c5abdf79c6b451c08eaf and pull request https://github.com/borisyankov/DefinitelyTyped/pull/5698 \nIt would be much appreciated if you can conform that everything works as you expected. \nThanks!\n. I'm going to close this issue to ensure that we only have one unique issue to refer to this problem. You can follow the updates at #46\n. HI @pixelshaded sorry for the late reply, I had a crazy busy summer. I've been thinking about a few changes that I want to do to InversifyJS and I like your suggestion, I will do everything I can to support both modules and Async injections. I never though about modules by async was on my plans already: https://github.com/inversify/InversifyJS/issues/16\nIs going to take me a while because I have to do some analysis about a few complex things but I will keep you updated. Thanks for your feedback :)\n. Implementation of Inject \"ToPromise\" and \"ToValue\" (can be used to inject a module) is in progress...\n. Closing this issue because we are going to track it here\n. I'm have never used inversify with harmony mode before, I was able to reproduce the issue and I'm trying to find a way to fix it. Will give you more details soon.\n. @orzarchi I have done a release (v.1.0.2) which resolves your issue:\nError: Could not resolve service class\nHowever there is another issue that needs to be fixed in order to support ES6 native classes:\nTypeError: Class constructors cannot be invoked without 'new'\nI will fix it as soon as someone answers this SO question: \nhttp://stackoverflow.com/questions/33193310/constr-applythis-args-in-es6-classes\nThanks for using inversify!\n. Hi @orzarchi I'm happy to let you know that if you download the version v1.0.3 from npm you should be able to use ES6 classes with --harmony mode in node 4.0:\n```\n\"use strict\";\nvar inversify = require(\"inversify\");\nclass A {\n  constructor(){\n    this.something = \"A is doing something!\";\n  }\n  doSomething(){\n    console.log(this.something);\n  }\n}\nclass B {\n  constructor(a) {\n    this._a = a;\n  }\n  useA() {\n    this._a.doSomething();\n  }\n}\nvar kernel = new inversify.Kernel();\nkernel.bind(new inversify.TypeBinding('a', A));\nkernel.bind(new inversify.TypeBinding('b', B));\nvar b = kernel.resolve('b');\nb.useA();\n```\nI was able to run the file above using:\nnode index.js --harmony\nPlease let me know if you experience more issues.\n. Hi @orzarchi thanks for your comments. I really worry when I have to add a run-time dependency to inversify because as you may have noticed it has no dependencies at the moment.\nI'm not too worry about using node-introspect in node but I'm worry about increasing the size of inversify in the browser. How heavy is node-introspect?\nAlso I'm working on version 2.0 and it will use decorators and there will be some significant changes. I will keep you updated so you can take a look to how things work on the upcoming 2.0 version.\n. I've been keeping an eye for a while on the conversations about introspection and reflection and the community seems to not been able to agree for the moment on a standard. For the moment we are going to generate the metadata manually using decorators:\n@inject(\"someDependency\", \"anotherDependency\")\nInstead of using reflection (or manual parsing) to get that metadata. We will use reflection or introspection once we find a official proposal. \nThanks for helping us to improve InversifyJS :smile: \n. :+1: Thanks for that!\n. Hi @avs14093 at the moment InversifyJS throws a stack overflow error if there are circular dependencies but I will look into the possibility of offering something better than that in the future.\n. We are not going to remove cyclic dependencies. It seams to be what other big projects are doing:\n- Angular issue 1\n- Angular issue 2\nAs you said we are going to try to throw a meaningful error.\n. This is now merged into master 81817a30e61fd7ac5511721d15285e27aba7f173\n. There was an issue in some Node.js versions but it has been fixed by dab6e544914d9142629ed51f199a10e04bc923a8\n. Hi guys! using decorators and reflect-metadata is in my plans :+1:  Thanks for your feedback and I promise I will do something about it as soon as I can :smile: \n. Hi @amcdnl I'm closing this issue because as @Jameskmonger said above #34 has added support for the @Inject decorator:\nYou should be able to do the following:\nTypeScript:\n```\nimport { Inject } from \"inversify\";\n@Inject(\"FooInterface\", \"BarInterface\")\nclass FooBar implements FooBarInterface {\n  public foo : FooInterface;\n  public bar : BarInterface;\n  public log(){\n    console.log(\"foobar\");\n  }\n  constructor(foo : FooInterface, bar : BarInterface) {\n    this.foo = foo;\n    this.bar = bar;\n  }\n}\n```\nJavaScript:\nvar FooBar = (function () {\n  function FooBar(FooInterface, BarInterface) {\n    this.foo = FooInterface;\n    this.bar = BarInterface;\n  }\n  FooBar.prototype.log = function () {\n    console.log(\"foobar\");\n  };\n  return Inject(\"FooInterface\", \"BarInterface\")(FooBar);\n})();\nAlso, we have plans to use the reflec-metada API in 2.0 but we have not used for the moment because we don't really need it and we would need to use fallback and that would increase the size of InversifyJS.\nThanks for your feedback :+1: \n. Yes we are going to use the ES7 Reflect API and some decorators. The decorators that I have in mine can be preview at https://github.com/inversify/InversifyJS/tree/2.0/source/decorators\nOne of them (@tagged) allows the users to add metadata that can be used in constrained bindings. Under the hood this decorators will use the Reflect to read and write the metadata. This is really similar to @Reflect.metadata(metadataKey, metadataValue) from the project that you shared (ReflectDecorators).\n. @pnocera thanks for reporting the issue :+1: \n. @jamesrichford thanks a lot for your contribution :)\n. @jamesrichford sure, if you want to keep an eye on issues and send pull request your are more than welcome. I'm planing a lot of things for version 2.0 but I'm going to be busy with work for a few months :( Any kind of help is great :)\n. We should be able to import InversifyJS as a:\nGlobal\n/// <reference path='typings/inversify/inversify.d.ts' />\nvar Kernel = inversify.Kernel;\nvar TypeBinding = inversify.TypeBinding;\nvar TypeBindingScopeEnum = inversify.TypeBindingScopeEnum;\nvar Inject = inversify.Inject;\nES6 module\nimport * as inversify from \"inversify\";\nvar Kernel = inversify.Kernel;\nvar TypeBinding = inversify.TypeBinding;\nvar TypeBindingScopeEnum = inversify.TypeBindingScopeEnum;\nvar Inject = inversify.Inject;\nimport { Kernel, TypeBinding, TypeBindingScopeEnum, Inject } from \"inversify\";\nExternal module\nimport inversify = require(\"inversify\");\nvar Kernel = inversify.Kernel;\nvar TypeBinding = inversify.TypeBinding;\nvar TypeBindingScopeEnum = inversify.TypeBindingScopeEnum;\nvar Inject = inversify.Inject;\nWe will only merge the pull request once we get all these options to work. \nBased on the documentation here:\n\nYour typings file should...\n- be a .d.ts file\n- be an external module\n- not have triple-slash references\n-  not pollute global scope\nThe rationale is that typings should not bring new compatible sources to the set of compiled files; otherwise source files (i.e. .ts files) will be considered by the compiler as part of the user code and will be compiled, and outputs in the package can be overwritten with the resulting .js outputs.\nAdditionally, loading typings should not pollute global scope by bringing potentially conflicting entries from different version of the same library. Modules have their own scope, and do not pollute the global namespace, if your typings file is not a module, it will be polluting the user global scope, and will cause conflicts with other packages that depend on your package. Similarly ///  can bring global declarations into the global scope and should be avoided.\n\nIt looks like we are going to need two files based on this issue. \nTake a look to the React type definitions there are two files one to be used as a global and one to be used for modules. \nSo we need two files:\n- type_definitions/inversify.d.ts\n- type_definitions/inversify-global.d.ts\nAnd two files for testing those:\n- type_definitions/inversify-test.ts\n- type_definitions/inversify-global-test.ts\nThe typings field in the packaghe.json should point to the inversify.d.ts file not the  type_definitions/inversify-global.d.ts.\n. @basarat thanks a lot for taking a look :)\n. Hi guys thanks for working on this and sorry it took so long to merge the changes...\nFor future references:\nUse inversify-global.d.ts if you are going to use Inversify as a global:\n```\n/// \nvar kernel = new inversify.Kernel();\n// ...\n```\nUse `inversify.d.ts if you are going to use InversifyJS as a module:\n```\n/// \nimport { TypeBindingScopeEnum, TypeBinding, Kernel, Inject } from \"inversify\";\nvar kernel = new Kernel();\n// ...\n```\n. @jamesrichford thanks a lot again for helping me with this project :+1:  I agree with everything you said. I think that if we can do just as you said and support still decorators in 1.x (as long as we still support the old way without decorators) that would be great. \nI you could send that pull request it would be great. \nAlso I would like to share with you some ideas about InversifyJS 2.0 I want to explain you why is taking so long :disappointed: and what I have in mind. I have created a mailing list at https://groups.google.com/forum/#!topic/inversifyjs/06opbRx6_I8 please join and I will share with you my plans :smile: \n. Hi @jamesrichford thanks a lot for the pull request I will review and merge it tonight :)\n. Hi @jamesrichford just merged your pull request thanks a lot for that :+1: \nAbout #32 @tenowg I'm investigating about it and I will merge the pull request (or ask for some additional changes) ASAP please be patient.\n. Hi guys, I was trying to add node and browser (global) examples and I saw this issue as well. I'm at work but I will look at it when I get home. I would like to add some unit tests or integration test to ensure that we don't have this issues again. Yesterday I merged code to master that is not fully working and we need to avoid that as much as possible.\nIt is being painful to get this working but we need to do it :) as @tenowg said is more convenient and it the recommended way to distribute type definition files since TypeScript 1.5.\n. I'm going to close this issue to ensure that we only have one unique issue to refer to this problem. You can follow the updates at #46\n. I'm going to close this issue to ensure that we only have one unique issue to refer to this problem. You can follow the updates at #46\n. @Jameskmonger @jamesrichford It sounds good to me too, feel free to send a pull request.\n. @Jameskmonger sorry for the recent problems with type definitions I have some times this weekend so I will try my best to get it fixed by monday...\n. I'm going to close this issue to ensure that we only have one unique issue to refer to this problem. You can follow the updates at #46\n. Hi @Jameskmonger thanks for the pull requests I think the build is failing because coveralls needs a token which was available in the file .coveralls.yml I think the token is not needed anymore but we might need to add service_name: travis-ci like for example at https://github.com/piwik/device-detector/blob/master/.coveralls.yml can you try that please?\n. :+1: Awesome work!\n. Nice one :) I had this issue on my list I'm really happy to see that is fixed :+1: \n. Closing as it is done by https://github.com/inversify/InversifyJS/pull/39\n. @Jameskmonger about bower I think we need to consider something before you spend time working on this. \nI have seen that the community seems to be encouraging the usage of npm instead of bower you can find many articles about it like this or this.\nSo my main question is: what do you guys think, should we fix bower or just stop using it?\n. I also think that stop using it sounds better. What do you think @jamesrichford ?\n. Cool so we are going to drop support for bower. I'm going to change the title of the issue.\n. Thanks a lot for your work I really appreciate it :smile: \n. Merged :+1: \n. @Jameskmonger do you mind if I assign this issue to you?\n. Thanks :rainbow: :+1: \n. Hello guys I just did a release (1.2.1) on npm. Please let me know if it solves the issues :question: \n. @jamesrichford thanks for taking a look. I just released 1.2.2please take a look :)\n. I have documented how I tested it here\n. @inversify/collaborators thanks for taking a look guys :) \nAbout the compilation issues: \nA) --moduleResolution node\nIf you were previously using a reference to ./typings/inversify/inversify.d.ts and an external module import. You should be able to just remove the reference to the .d.ts file and use the --moduleResolution node flag instead:\nimport { Inject } from \"inversify\";\nThe TypeScript compiler will then search in the package.json file for a field named typings and use a reference to ./node_modules/inversify/type_definitions/inversify-npm.d.ts.\nB) --moduleResolution classic\nFor older versions of TypeScript or when using the --moduleResolution classic flag you can reference the file provided with the npm module:\n```\n/// \nimport { Inject } from \"inversify\"; \n```\nC) global\nJust add a reference to the inversify-global.d.ts file provided with the npm module:\n```\n/// \nvar Inject = inversify.Inject;\n``\n. Hi @jmp909 we have a repo for examples at https://github.com/inversify/inversify-code-samples if you create a fork and add your example under a folder named \"vscode\" I will be happy to merge your pull request ; )\n. @inversify/collaborators I think we can close this issue?\n. Thanks guys!\n. Thanks a lot again :smile: \n. I don't think is the token. It seems to be problem withtslint`\nUNMET PEER DEPENDENCY tslint@^3 || >=3.1.0-dev || >=3.2.0-dev || >=3.2.1-dev\n\nThe gulpfile.js then fails when importing the module:\ntslint = require(\"gulp-tslint\")\n\n. I want to research more, it should work because the variable was there:\n\nI wonder if this is related:\n\nEncrypted environment variables are not available to pull requests from forks due to the security risk of exposing such information to unknown code. - Source\n. @Jameskmonger I think I have found how to fix this issue. I will so a pull request shortly :smile: Thanks for your work once more :+1: \n. @Jameskmonger I think https://github.com/inversify/InversifyJS/pull/50 should fix it :smile: \n\nJust for reference I followed the guide about Encrypting Variables Using a Public Key\n. Hi @RichardJECooke at the moment we are having a problem with the .d.ts files but we are working on it. I'm going to close this issue to ensure that we only have one unique issue to refer to this problem. You can follow the updates at https://github.com/inversify/InversifyJS/issues/46\n. I don't think there is going to be a lot of incompatibilities. The main problem I can think about is the usage of injections without the @Inject decorator but if we use the warning for it should be ok.\nI'm planing to do some changes to some names to make the code a bit shorter. For example:\nkernel.bind(new TypeBinding<FooInterface>(\"FooInterface\", Foo, TypeBindingScopeEnum.Transient));\nI would like to use:\nkernel.bind(new Binding<FooInterface>(\"FooInterface\", Foo, BindingScope.Transient));\nThis won't be a big problem because users can create aliases:\nvar TypeBinding = Binding;\nvar TypeBindingScopeEnum = BindingScope;\n. :+1:  I was working on something similar. What I did wasn't brilliant... we can take advantage of this new feature to do something better.\n. Release 1.3.0 drops support for injections without `@Inject decorator\n. @tenowg thanks a lot for that!\n. I just updated the Architecture overview page in the Wiki. It explains  folder structure and resolution process changes for the upcoming version 1.3.\n. Moved to the wiki at https://github.com/inversify/InversifyJS/wiki/Roadmap I'm closing this but since the wiki have no comments you can use this issue to ask any questions...\n. Hi @theofidry thanks for this suggestion. I like it but I don't think we should add this to InversifyJS directly. I see this working better as a plugin for module bundlers (webpack, browserify, etc).\nI'm not fully sure about this being 100% possible because we are planing to have support for some complex binding resolution constraints. Things like: \"When IFoo is requested, inject an instance of Foo only if the parent request class name named FooBar\". If we have this kind of injections it might be possible to pre-resolve everything and dump it into a file. \nAlso we could end with lots of pre-resolved instances and that could become a memory issue.\nSo I would say that we are going to explore it but is not one of our top priorities right now. We are going to focus on finishing everything in the roadmap before exploring this. Please don't be disappointed if it takes some time for us to experiment with it :wink: \n. PS @Jameskmonger thanks for keeping an eye on the issues :smile: \n. I'm closing this issue because I don't think this will be possible anymore due to contextual bindings. Contextual binding allows us to declare constraints that are resolved at run-time like the following:\nkernel.bind<IWeapon>(\"IWeapon\").to(Katana).when(request => { \n    return request.parentRequests.target.name.equal(\"katana\"); \n})\nThis makes quite complex (maybe even impossible) to pre-calculate and dumb all the injections that take place in an application.\n. I understand, basically the tool that resolved the dependencies would not be able to use contextual bindings but developers could get around it using named and tagged bindings. I have added this to the a new page in the wiki so it is documented.\n. Hi @Fire-Dragon-DoL I just created a new release. Thanks for reporting this issue :wink:\n. Hi @Jameskmonger an angular 2.0 example would be great! \nI'm not 100% sure about the current version fully working with angular 2.0 but I don't see why not. I would suggest to grab the TodoMVC example and modify it:\n- Split these two classes (Todo & TodoStore) in two files and declare their interfaces as well.\n- Inject TodoStore using @Inject.\n- Bootstrap is the composition root \nI'm not familiar with Angular 2.0 but I found the following in the documentation:\n\nWhen the app developer invokes bootstrap() with the root component MyApp as its argument, Angular performs the following tasks:\n- It uses the component's selector property to locate the DOM element which needs to be upgraded into the angular component.\n- It creates a new child injector (from the platform injector). Optionally, you can also override the injector configuration for an app by invoking bootstrap with the componentInjectableBindings argument.\n- It creates a new Zone and connects it to the angular application's change detection domain instance.\n- It creates an emulated or shadow DOM on the selected component's host element and loads the template into it.\n- It instantiates the specified component.\n- Finally, Angular performs change detection to apply the initial data providers for the application.\n\nI took a quick look it doesn't look easy to modify or replace. I don't know what would be better:\n- Create our own angular bootstrap function\n- Override the angular bootstrap function.\nIf we create our own bootstrap function we could release it as a package named inverisfy-angular or something similar and explain that it contains the inversify-angular bindings (something like the react-redux bindings...)\n. Another good resource: http://blog.thoughtram.io/angular/2015/05/18/dependency-injection-in-angular-2.html\n. Hi @Jameskmonger I asked for help at https://github.com/angular/angular/issues/6885 let's see what they answer...\n. Closing this because it doesn't seem possible for now :( we should focus on 2.0 and all the other JS frameworks and Node.js for now. Once we get that done we should have time to focus on Angular 2.0 integration.\n. Hi @ptitjes \nYou can create a library that uses inversify internally. If you library exposed as a variable, you should be able to inject that variable into an angular component using the angular injector. \nIt is important that you separate the angular and the inversify injectors in something like:\nts\n@injectable() // angular injectable not an inversify injectable\nclass Service {\n    public container: Container;\n    public constructor() {\n        this.container = new Container();\n    }\n    doSomething() {\n        const something = this.container.get(\"something\");\n        return something.doSomething();\n    }\n}\nAngular will resolve Service and then inversify will resolve everything else on demand.\nThis is the only way I can think to integrate both because angular is very tightly coupled to its own IoC container. More info @ https://github.com/inversify/InversifyJS/issues/625#issuecomment-352122739\n. @ptitjes that could work. Let me know how do you get on and if it works we can create a page in the wiki documenting angular limitations and recipes.. The answer by John White is right:\nYou can use:\n```\nclass Server implements IServer\n{\n    db : IDatabase;\n    expressApp : express.Express;\nconstructor(@Inject(\"IDatabase\") db : IDatabase)\n{\n    this.db = db;\n    ...\n}\n\n}\n```\nBut it will stop working in the next release:\n```\n@Inject(\"IDatabase\")\nclass Server implements IServer\n{\n    db : IDatabase;\n    expressApp : express.Express;\nconstructor(db : IDatabase)\n{\n    this.db = db;\n    ...\n}\n\n}\n```\nSorry about the misleading docs...\n. Hi @RichardJECooke I just released version 1.3.0 and it allows to apply the Inject decorator to a class:\n```\ninterface IKatana {\n    power : number;\n    hit() : boolean;\n}\ninterface IShuriken {\n    power : number;\n    throw() : boolean;\n}\n@Inject(\"IKatana\", \"IShuriken\")\nclass Warrior {\nprivate _katana : IKatana;\nprivate _shuriken : IShuriken;\n\nconstructor(katana : IKatana, shuriken : IShuriken) {\n    this._katana = katana;\n    this._shuriken = shuriken;\n}\n\n}\n```\nThe following is not supported anymore:\n```\nclass Warrior {\nprivate _katana : IKatana;\nprivate _shuriken : IShuriken;\n\nconstructor(\n    @Inject(\"IKatana\") katana : IKatana, \n    @Inject(\"IShuriken\") shuriken : IShuriken\n) {\n    this._katana = katana;\n    this._shuriken = shuriken;\n}\n\n}\n```\nSorry about the issues caused.\n. Hi @RichardJECooke thanks for this suggestion :)\nYour question has been edited and the changes need to be approved by 3 stack overflow moderators before it can be edited again:\n\nI have privileges to to create new tags, so I will create a new tag named \u00ecnversifyjs as soon as your answer can be edited again.\nI have also added a small section about support to the official website.\n. I just created the tag inversifyjs on stack overflow http://stackoverflow.com/tags/inversifyjs so I'm closing this issue :smile:\n. :+1:  If is possible also ensure that dist and type_definitions folders are available before publishing. \n. Thanks for the PR :smile: \nI just noticed a small problem. If you take a look to the default gulp task you will see that it runs the build and test tasks. The default task is executed by Travis CI so the build task will be executed two times.\nCan you please rename the test task as build-and-test:\ngulp.task(\"build-and-test\", function(cb) {\n  runSequence(\"build\", \"istanbul:hook\", \"mocha\", \"cover\", cb);\n});\nAnd replace the build and test sub-tasks from the default task with the new build-and-test task:\ngulp.task(\"default\", function (cb) {\n  runSequence(\n    \"lint\",\n    \"build-and-test\",\n    \"dist\",\n    cb);\n});\n. Looks good to me too :+1:  Thanks a lot for the PR and CR guys!\n. @harper84 @RichardJECooke Hi guys sorry about the problems with the last few releases we have been working on a few things to avoid this kind of problems. For example the last PR #66 ensures that unit tests and build work before publishing to npm. \nWe will continue to work to ensure that you can trust the library for production usage please let us know any kind of concerns.\n. Hi guys based on this and this the current semver version 2.0.0-alpha.0 should be correct. I still working on the first release of 2.0 I'm sorry it is takings so long but I have very limited free time at the moment :( I think I have 70% done more or less I will keep you updated.\n. With the features available today you could do:\nif (app.get('env') === 'dev') {\n    kernel.bind(new TypeInstance<ISomething>('ISomething', Something));\n} \nelse if (app.get('env') === 'stg') {\n     kernel.bind(new TypeInstance<ISomething>('ISomething', NotReallySomething));\n}\nYour types Something and NotReallySomething must implement the same ISomething interface.That ensures that it is safe to replace one class with another as the Liskov substitution principle (from the SOLID principles) states:\n\n\u201cobjects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.\u201d\n\nIt is not possible to do:\nkernel.bind(new TypeInstance<Something>('SomethingOrNotReallySomething'));\nBecause that is compiled into the following:\nkernel.bind(new TypeInstance('SomethingOrNotReallySomething'));\nSo as you can see we would not have the type (Something) information at runtime.\n. Is\nclass Something implements ISomething { //...\nthe mock and\nvar Something = mongoose.model<ISomethingModel>('Something2', somethingSchema);\nthe real implementation?\n. ### The problem\nSo we have a plain object. The interface of the object is:\ninterface ISomething {\n  /// \n}\nAnd its class is:\nexport class Something implements ISomething {\n  public static findOne(something: any, next:Function) {\n        //there is similar method on mongoose.Document so I do custom implementation of it here\n        //do findOne\n    }\n}\nThe method findOne is part of the mongoose Model. So it looks to me like you want ISomething to behave as a Model.\nThe problem is that then you are using ISomething to create a model:\nexport var Something = mongoose.model<ISomething>('Something2', somethingSchema);\nYou are passing the ISomething to mongoose.model but mongoose is expecting a Document not a model. Both the mock and the real implementation need to implement the same interface.\nThe solution\nDeclare ISomething as a Document:\ninterface ISomething extends mongoose.Document {\n  /// \n}\nDeclare ISomethingModel as a Model:\ninterface ISomethingModel extends mongoose.model<ISomething>{}\nCreate a Model using the ISomething Document.\n```\nvar _model = mongoose.model('Something2', somethingSchema); \nclass SomethingModel implements ISomethingModel {\n   public static findOne(something: any, next:Function) {\n        // USE_model HERE\n    }\n}\n```\nCreate a mock of the model ISomethingModel:\nclass SomethingModelMock implements ISomethingModel {\n public static findOne(something: any, next:Function) {\n        // mock _model response here\n    }\n}\nCreate your InversifyJS config for the app ans test:\nif (app.get('env') === 'dev') {\n    kernel.bind(new TypeInstance<ISomethingModel>('ISomethingModel', SomethingModel));\n} \nelse if (app.get('env') === 'stg') {\n     kernel.bind(new TypeInstance<ISomethingModel>('ISomethingModel', SomethingModelMock ));\n}\n\nNote: I haven't test this solution but based on the moongose type definitions and an example that I found online I believe it should work.\n\nTip!\nI would recommend to have two inversify.config.ts files. You can have inversify.config.ts in your source directory:\nkernel.bind(new TypeInstance<ISomething>('ISomething', Something));\nAnd inversify.test.config.ts in your test directory:\nkernel.bind(new TypeInstance<ISomething>('ISomething', NotReallySomething));\nHope it helps, and please ask again if you have more problems :four_leaf_clover: \n. I think I know what is the problem now. We have the ISomething document:\ninterface ISomething extends mongoose.Document {\n  /// \n}\nThe SomethingModel:\nvar somethingModel = mongoose.model<ISomething>('Something2', somethingSchema);\nAnd the something model mock:\nclass SomethingModelMock implements ISomethingModel {\n public static findOne(something: any, next:Function) {\n        // mock _model response here\n    }\n}\nThis is a problem because:\n- SomethingModelMock is a class\n- somethingModel is an instance\nInversifyJS needs classes and is not able to work with instances yet. This is going to be supported in InversifyJS 2.x:\nif (app.get('env') === 'dev') {\n    kernel.bind<ISomethingModel>('ISomethingModel').toValue(somethingModel);\n} \nelse if (app.get('env') === 'stg') {\n     kernel.bind<ISomethingModel>('ISomethingModel').to(SomethingModelMock);\n}\nI found a class wrapper for mongoose maybe that can help you to declare somethingModel as a class. Then you will be able to resolve it.\n. Hi, the feature that you needed: toValue has been merged into master by https://github.com/inversify/InversifyJS/pull/97. Over the next few weeks we are going to try to make 2.0 stable please keep an eye in the roadmap for updates.\n. A middleware could be a good place. The composition root is around the routing for sure. When a request arrives to the express server the route maps to an action in a controller. So I thinlk when a new requests arrives a new instance of the required controller should be resolved. \n```\nclass UserController implements IController {}\nclass InvoiceControllerimplements IController {}\nkernel.bind>(\"IController\").to(UserController)\nkernel.bind>(\"IController\").to(InvoiceController)\n```\nGET /users/1\nlet controller = kernel<IController<any>>.get(\"IUserController\") // you need to get \"UserController\"\ncontroller.get(urlArgs)\nPOST /invoice { id: 1, user: \"\", date: \"\" records: [ /* ... */ ] }\nlet controller = kernel<IController<any>>.get(\"IInvoiceController\")\ncontroller.post(playload)\nSo we know the controller from the path and we know the action from the request method. That's how I would do it but it is just an opinion. All the dependencies of the controller are injected via its constructor. \nThis means that we only use Kernel.get in one place around the routing logic but it actually gets invoked with each new request.\n. Hi @codyjs thanks a lot for this :) I like it a lot! I will be happy to take this in a PR also your framework stuff could become an npm package if you are interested ? I could create a new project something like inversify-express-utils ?\n. Great :smile_cat:  I just created a repo for the framework part https://github.com/inversify/inversify-express-utils\nToday I can't do any work but I will try to set up the Travis CI build for you as ASAP (probably ready by monday).\n. I see that there are some things really similar to inversify-express-utils like the @controller decorator and some additional things. For example I don't think inversify-express-utils has a @test decorator. You should work with @codyjs to join both ideas. The best would be that the express example used the inversify and inversify-express-utils npm packages.\n. Help is welcome :smile: at the moment @codyjs is the main author of the express-utils I'm focus on the inversify core but soon enough I will have more free time and I will help on express-utils as well.\n. I'm closing this we have now a basic express example :smile: If you want to suggest changes or additions you can do it at https://github.com/inversify/InversifyJS/issues/265\n. I'm closing this because it is too complicated to integrate it with AngularJS as it ti tightly coupled to its own injector :(\n. We are going to use https://github.com/inversify/InversifyJS/issues/265 to track this...\n. I just wanted to check online because in some popular IoC containers no exceptions are thrown. I asked Mark Seemann for advice just to be sure and yes we should throw friendly error.\nSo we need to replace line 62 with:\nreturn null;\nWith:\nthrow new Error(`Cannot resolve ${runtimeIdentifier}: no bindings available.`);\nIs that error friendly enough? Can you think of a better one?\n. I know what you mean the problem is we cannot detect that something is wrong when adding annotations:\n@Inject(\"FooInterface\", \"BarInterface\")\nBecause @Inject is decoupled from the kernel and the bindings. So we can't show any errors there. However, we can provide a friendly error when we invoke resolve:\nkernel.resolve<FooBarInterface>(\"FooBarInterface \")\nWe can throw:\nCannot resolve 'BarInterface': it is likely that you forgot to register this type.\n. @inversify/collaborators this is a small change. I think we can do it in both 1.x and 2.x, what do you think?\n. This is already done in v2.0.0-alpha.0.\n. Hi @inversify/collaborators!\nI just did a commit today after a lot of changes in the directory architecture, I have also been working on a few new decorators and other things. The project looks like this so far:\n.\n\u251c\u2500\u2500 CONTRIBUTING.md\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 activation\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 decorator_utils.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 inject.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 metadata.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 named.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 paramnames.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 tagged.ts\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 bindings\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 binding.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 binding_count.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 binding_scope.ts\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 constants\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 error_msgs.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 metadata_keys.ts\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 interfaces\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 inversify.ts\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 kernel\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 kernel.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 key_value_pair.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 lookup.ts\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 planning\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 context.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 plan.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 planner.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 queryable_string.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 request.ts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 target.ts\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 resolution\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 resolver.ts\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 utils\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 utils.ts\n\u251c\u2500\u2500 test\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 // ...\n\u251c\u2500\u2500 tsconfig.json\n\u251c\u2500\u2500 tslint.json\n\u251c\u2500\u2500 type_definitions\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 inversify-global-test.ts\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 inversify-global.d.ts\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 inversify-npm.d.ts\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 inversify-test.ts\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 inversify.d.ts\n\u251c\u2500\u2500 typings\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 typings.json\n\u2514\u2500\u2500 wallaby.js\nI have managed to get to a point in which all the old stuff still works except the kernel because I'm in the middle of the implementation of the new process. The build logs look as follows:\n```\n[01:42:24] Using gulpfile ~/Desktop/InversifyJS/gulpfile.js\n[01:42:24] Starting 'default'...\n[01:42:24] Starting 'lint'...\n[01:42:28] Finished 'lint' after 3.43 s\n[01:42:28] Starting 'build'...\n[01:42:28] Starting 'build-source'...\n[01:42:29] Finished 'build-source' after 1.68 s\n[01:42:29] Starting 'build-test'...\n[01:42:31] Finished 'build-test' after 1.59 s\n[01:42:31] Starting 'build-type-definitions'...\n[01:42:32] Finished 'build-type-definitions' after 1.39 s\n[01:42:32] Finished 'build' after 4.67 s\n[01:42:32] Starting 'test'...\n[01:42:32] Starting 'istanbul:hook'...\n[01:42:32] Finished 'istanbul:hook' after 182 ms\n[01:42:32] Starting 'mocha'...\n@Inject\n\u2713 Should not generate metadata when not applied\n\n\u2713 Should generate metadata if declared injections\n\n\u2713 Should throw when applayed mutiple times\n\n\u2713 Should be usable in VanillaJS applications\n\nMetadata\n\u2713 Should set its own properties correctly\n\n@Named\n\u2713 Should not generate metadata for unnamed parameters\n\n\u2713 Should generate metadata for named parameters\n\n\u2713 Should throw when applayed mutiple times\n\n\u2713 Should throw when not applayed to a constructor\n\n\u2713 Should be usable in VanillaJS applications\n\n@ParamNames\n\u2713 Should not generate metadata when not applied\n\n\u2713 Should generate metadata if declared parameter names\n\n\u2713 Should throw when applayed mutiple times\n\n\u2713 Should be usable in VanillaJS applications\n\n@Tagged\n\u2713 Should not generate metadata for untagged parameters\n\n\u2713 Should generate metadata for tagged parameters\n\n\u2713 Should generate metadata for parameters tagged mutiple times\n\n\u2713 Should throw when applied mutiple times\n\n\u2713 Should throw when not applied to a constructor\n\n\u2713 Should be usable in VanillaJS applications\n\nBinding\n\u2713 Should set its own properties correctly\n\n\u2713 Should be able to use implementationType as a constructor\n\n\u2713 Should throw when attempting to use an invalid scope\n\nKernel\n1) Should be able to get a service without dependencies\n\n2) Should be able to get a service with acomplex dependency tree\n\n3) Should NOT be able to get unbound dependencies\n\n4) Should store singleton type bindings in cache\n\n5) Should unbind a binding when requested\n\n\u2713 Should unbind all bindings when requested\n\n6) Should throw when cannot unbind\n\nLookup\n\u2713 Should throw when invoking get, remove or hasKey with a null key\n\n\u2713 Should throw when attempting to add a null key\n\n\u2713 Should throw when attempting to add a null value\n\n\u2713 Should be able to link multiple values to a key\n\n\u2713 Should throws when key not found\n\nContext\n    - Todo\nPlan\n    - Todo\nPlanner\n    - Should generate a basic resolution plan\n    - Should generate a complex resolution plan\nQueryableString\n\u2713 Should be able to set its own properties\n\n\u2713 Should be able to return its value\n\n\u2713 Should be able to identify if it's value starts with certain text\n\n\u2713 Should be able to identify if it's value ends with certain text\n\n\u2713 Should be able to identify if it's value is equals to certain text\n\nTarget\n\u2713 Should be able to create instances of untagged tagets\n\n\u2713 Should be able to create instances of named tagets\n\n\u2713 Should be able to create instances of tagged tagets\n\n\u2713 Should be able to identify named metadata\n\n\u2713 Should be able to identify multi-injections\n\n\u2713 Should be able to match named metadata\n\n\u2713 Should be able to identify tagged metadata\n\n\u2713 Should be able to match tagged metadata\n\nResolver\n    - Todo\nUtils\n\u2713 Should flatten multidimensional arrays\n\n43 passing (42ms)\n  5 pending\n  6 failing\n1) Kernel Should be able to get a service without dependencies:\n     TypeError: Cannot set property 'plan' of null\n      at Kernel._planAndResolve (src/kernel/kernel.js:9:4561)\n      at Kernel.get (src/kernel/kernel.js:9:2355)\n      at Context. (test/kernel/kernel.test.js:12:29)\n2) Kernel Should be able to get a service with acomplex dependency tree:\n     TypeError: Cannot set property 'plan' of null\n      at Kernel._planAndResolve (src/kernel/kernel.js:9:4561)\n      at Kernel.get (src/kernel/kernel.js:9:2355)\n      at Context. (test/kernel/kernel.test.js:28:35)\n3) Kernel Should NOT be able to get unbound dependencies:\n     TypeError: Cannot set property 'plan' of null\n      at Kernel._planAndResolve (src/kernel/kernel.js:9:4561)\n      at Kernel.get (src/kernel/kernel.js:9:2355)\n      at Context. (test/kernel/kernel.test.js:41:26)\n4) Kernel Should store singleton type bindings in cache:\n     TypeError: Cannot set property 'plan' of null\n      at Kernel._planAndResolve (src/kernel/kernel.js:9:4561)\n      at Kernel.get (src/kernel/kernel.js:9:2355)\n      at Context. (test/kernel/kernel.test.js:51:31)\n5) Kernel Should unbind a binding when requested:\n     TypeError: Cannot set property 'plan' of null\n      at Kernel._planAndResolve (src/kernel/kernel.js:9:4561)\n      at Kernel.get (src/kernel/kernel.js:9:2355)\n      at Context. (test/kernel/kernel.test.js:66:26)\n6) Kernel Should throw when cannot unbind:\n     AssertionError: expected [Function] to throw error including 'Could not get service FooInterface' but got 'Could not unbind service FooInterface'\n      at Context. (test/kernel/kernel.test.js:98:35)\n```\nSo the remaining work for me are:\n- Implement the Planner class\n- Implement the Plan class\n- Implement the Resolver class\n- Change Kernel to use Planner and Resolver\nI think what I'm going to do is add some tests without 100% test coverage. Then I will merge to a branch and you guys want you can help me to achieve 100% test coverage again.\nYou can browse the code as it is right now.  Will keep you updated :rainbow: \n. Once I'm done with my tasks. I will merge to the 2.0.0-alpha.0 branch. You can track the progress of 2.0.0-alpha.0 here.\n. Hi @ktutnik welcome to the family :family: :rainbow: :fireworks: I did a hangout with the rest of the team a couple of weeks ago to plan the release of 2.0. \nAt the moment the team is block by me :sob: until I merge 2.0.0-alpha.0 once I have done that I will create milestones and issues to match the roadmap and we can all work together to make it happen. \n. @ktutnik I'm in GTM+0 (Dublin, Ireland) I have send you an invite :)\n. Hi @inversify/collaborators, I just want to share a quick update... I've been doing some work over the weekend and I managed to implement the Planner#81. \n\nSo I just need to complete #81 and #82 and we are good to release 2.0.0-alpha.0.\n. I just merged 2.0.0-alpha.0 https://github.com/inversify/InversifyJS/pull/89 :rocket: please take a look, test it if you can. I'm going to be doing some testing and updating documentation.\n. Hello again @inversify/collaborators I just released 2.0.0-alpha.1 :tada: it would be great if you could try it out and let me know your thoughts. Thanks!\n. Hello @inversify/collaborators! 2.0.0-alpha.3 landed :rocket:  master just a few minutes ago :tada: I have closed the milestone and created a new milestone: 2.0.0-beta.1. \nThere is a couple of small issue in the new milestone, the issues #107 and #105 are good candidates for PRs.\n. Thanks :smile: I will add a tag \"help wanted\" to show show that I'm not working on something. If you want to work on it just comment to say that you want to do it and I will remove the tag and assign it to you. If I'm working on something I will assign it to me. Does that work? \n. Hi @inversify/collaborators guys before we move from alpha to beta we really need feedback from the community. To create the final version of the APIs.\nI have already started to ask online via twitter and I will also ask for feedback at my local type script meetup. Do you any other ideas about how can we get some feedback about the APIs?\n. I will do that I will create a \"discussion\" if I feel like I want to talk about something. Please do the same if you have questions.\n. I'm planning to finish Enhanced fuent binding syntax and do a release 2.0.0-alpha.7. After that we can try it and if it is fine we can promote it to 2.0.0-alpha.1. \nI have done some significant changes. \n@injectable\nI have renamed @inject to @injectable. I have done this because right now we do:\n@inject(\"IKatana\", \"IShuriken\")\nThe thing is that in the future this won't be necessary because the TypeScript compiler will be able to add:\n[\"IKatana\", \"IShuriken\"]\nThe problem is that we will no longer will need to declare the strings but we will still be required to use the decorator:\n@inject()\nThe angular 2.0 team is aware of this:\n\n\nInjector will throw NoAnnotationError when trying to instantiate a class that does not have @Injectable marker, as shown in the example below.\n\nSo to be prepared for the future we will start using @injectable instead of @inject.\nKernel modules\nLet's consider the following kernel modules:\n```\nlet warriors: IKernelModule = (k: IKernel) => {\n    k.bind(\"INinja\").to(Ninja);\n};\nlet weapons: IKernelModule = (k: IKernel) => {\n    k.bind(\"IKatana\").to(Katana).inTransientScope();\n    k.bind(\"IShuriken\").to(Shuriken).inSingletonScope();\n};\n```\nInstead of:\nlet kernel = new Kernel({ modules: [ someModule ] });\nNow we have:\nkernel = new Kernel();\nkernel.load(warriors, weapons);\nMiddleware\nImagine that we have two middleware functions:\n```\nfunction logger(next: (context: IContext) => any) {\n    return (context: IContext) => {\n        let result = next(context);\n        console.log(\"CONTEXT: \", context);\n        console.log(\"RESULT: \", result);\n        return result;\n    };\n};\nfunction devTools(next: (context: IContext) => any) {\n    return (context: IContext) => {\n        let result = next(context);\n        let _window: any = window;\n        let inversify_devtools = _window.inversify_devtools;\n        if (inversify_devtools !== undefined) { \n          inversify_devtools.log(context, result); \n        }\n        return result;\n    };\n};\n```\nThis wasn't fully implemented but the idea was the following.\nlet kernel = new Kernel({ middleware: [ logger, devTools ] });\nNow we have:\nkernel = new Kernel();\nkernel.applyMiddleware(logger, devTools);\n. Hi guys I've been doing some research and I have another breaking change :disappointed: #136 \nYou can learn get a better context about it at The current state of dependency inversion in JavaScript.\n. I'm closing this issue but feel free to follow updates in the gitter chat. It is likely that we will get a 2.0.0-beta.1 release during the weekend or next week :tada: \n. Hi @ktutnik thanks a lot for your feedback! would you like to join the team? An person with experience with IoC containers like you would be a great addition. \np.s. Have you check our roadmap?\n. Done by https://github.com/inversify/InversifyJS/pull/97\n. I need to think about this but I think this would be possible thanks to the parent Kernel feature in the roadmap: \nvar kernel: kernel = null;\nif(config.mode == \"easy\"){\n   kernel = new Kernel(easyKernel);\n}\nelse {\n   kernel = new Kernel(hardKernel);\n}\nThe Kernel chain will behave in a similar way to the JavaScript prototype chain. If a binding cannot be resolved the kernel will search in the kernel chain. This idea was inspired by child injectors in Angular DI.\n. This is now done by 052dcafce8f268ed3bfce0a1ce0172f73f3ead00 \nAt the end I decided to leave our the parent kernel feature, we can still add it in the future but I see small real-world use cases so I decided to leave it out until some people ask for it (A.K.A. KISS).\nThe way it works is the following:\n```\nlet someModule: IKernelModule = (kernel: IKernel) => {\n    kernel.bind(\"INinja\").to(Ninja);\n    kernel.bind(\"IKatana\").to(Katana);\n    kernel.bind(\"IShuriken\").to(Shuriken).inSingletonScope();\n};\nlet options: IKernelOptions = {\n    modules: [\n        someModule\n    ]\n};\nlet kernel = new Kernel(options);\nlet ninja = kernel.get(\"INinja\");\nconsole.log(ninja2);\n```\n. This is done already https://github.com/remojansen/InversifyJS/commit/92b722b5ae8601d60a23d5e7908191b91a92d30e\n. Done https://github.com/remojansen/InversifyJS/commit/75f2eeaaeec48313be0a8726df2d2441eb132760\n. Done https://github.com/remojansen/InversifyJS/commit/a4d51e8f623a775363f23d057c26be869f843123\n. Done https://github.com/remojansen/InversifyJS/commit/a4d51e8f623a775363f23d057c26be869f843123\n. This is done now by 9a13447ed3b40bdb1ce2a65a4a927f15a9a73516. The template has been auto-generated.\n. This is done now by 967abbe8fd64d2e307d56a28904562d18def4761. The template has been auto-generated.\n. :+1: We need to do some thinking about it but sound like a good idea to me.\n. Hi @ktutnik I'm doing some analysis on this week... can you please send me some documentation from an IoC where this is available? I would like to see theirs APIs and some real world use cases. Thanks :smile: \n. Hi I've been reading about interception in Unity  and Windsor Castle and I think what you are asking for in your example is not really interception as InversifyJS is not creating a proxy of the dependency being injected. \nIf you could please let me know what do you have in mind about this feature I will be happy to see if I can implement it but I have another feature in mind (middleware) that could be what you are looking for and is more powerful.\n. Hi @ktutnik thanks for your help :) I think I understand it now. I have a few things in mind. One of my main concerns is introducing dependencies.\nAt the moment, we don't have dependencies (only polyfills for Promise and Reflect) so looks like is a good idea to do the same and use the Proxy. If the environment don't support Proxy we will use a polyfill.\nI can imagine something like the following working:\ninterface IBindingProxySyntax<T> {\n   proxy(fn: (injectable: T) => IProxy<T>);\n}\nkernel.bin<IKatana>(\"IKatana\").to(Katana).proxy((katana) => {\n   let handler = {\n     // interception logic goes here... http://mzl.la/1UayLPy\n   };\n   return new Proxy(katana, handler);\n});\nWhat are your thoughts?\np.s. a good resource.\n. Please take a look to the following:\nkernel.bin<INinja>(\"INinja\").to(Ninja).proxy((ninja) => {\n   let handler = {\n        apply: function(target, thisArgument, argumentsList) {\n           if(target.name === \"swing\") {\n             console.time();\n             let result = target.apply(thisArgument, args);\n             console.log(\"swing execution time\");\n             console.timeEnd();\n             return result;\n           }\n           else {\n             return target.apply(thisArgument, args);\n           }\n        }\n   };\n   return new Proxy(ninja, handler);\n});\nWe can achieve the same but we will be using standards.\n. Interception is now implemented in 2.0.0-alpha.3 but cannot be tested due to an issue with gulp-mocha and the --harmony-proxies flag. I'm going to create an issue for that issue, link it to to this and close this one.\n. :+1: We need to do some thinking about it but sound like a good idea to me.\n. This is done by #102\n. Done by 8ad5e73bb414c252a0df7af7010e470ca8d388d2\n. Done 08909b39846fe5627876cc0928aa41d2102e1ad8\n. Done by #102\n. Done by #102\n. Done by #102\n. Sorry @ktutnik I closed this PR by mistake and I can't re-open it because the repo has been removed do you mind re-sending it? thanks\n. Done by https://github.com/inversify/InversifyJS/pull/97\n. Done by https://github.com/inversify/InversifyJS/pull/97\n. Done by #102\n. This decorator was implemented in 2.0.0-alpha.0.\n. Done by #102\n. Thanks for reporting. I will fix it as soon as I can, for the moment you should be able to manually point to:\n/// <reference path=\"/node_modules/inversify/type_definitions/inversify.d.ts\" />\n. Hi @slice-beans I just released 2.0.0-alpha.3 can you please try again. Please note that I have removed the typings field in the package.json because it was causing many problems. You need to reference the following file as described in the new docs:\n/// <reference path=\"node_modules/inversify/type_definitions/inversify.d.ts\" />\nHope it helps :four_leaf_clover: \n. Thanks for taking a look. I just added the type definitions to DefinitelyTyped. Once the PR has been merged into master you will be able to do:\n$ npm install inversify@2.0.0-alpha.3\n$ typings install inversify --ambient\nI'm closing this issue but please write back if you have more problems.\n. The bluebird issue should be fixed now thanks to https://github.com/inversify/InversifyJS/pull/114\n. Hi @Jameskmonger thanks for taking a look. I will do a commit tonight to try to fix this issue but I have another issue. I need to use the ES6 Proxy class here. I have created a SO question because I've not been able to fix it.\nI'm also going to update the type definitions to fix #101 \n. 2.0.0-alpha.3 landed :rocket:  master :tada: \n. Done by #102\n. Done by #102\n. Fixed by https://github.com/inversify/InversifyJS/pull/130\n. If we target ES6 typescript imports es6.d.ts. This file declares the typings  for the Proxy class. We don't want to target ES6, so when targeting ES5 the imported file is lib.d.ts and the typings for the Proxy object are not declared. That's why you are getting the TypeScript error. \nI added type definitions for Proxy (just to test) and I was getting another error at runtime because Proxy is not defined at runtime. My node.js runtime is v4.2.1 so this is probably the problem.\nWe need to use a polyfill to ensure that the TravisCI build will work in old node versions. We also need to find how to do it to document it in the environmemt support and polyfills wiki page. \nThere are two popular polyfills:\n- harmony-reflect (I tried this but t conflicts with the reflect-metadata polyfill).\n- harmony-proxy\nWe need to try with the second one and probably create the harmony-proxy.d.ts file and send it to the DefinitelyTyped project. \nI hope this makes sense... \nPlease let me know if it is not clear enough.\n. Please take a look to https://github.com/inversify/InversifyJS/pull/117 it seems to be fixed but I'm waiting for this PR to remove a hard code path to one a fork. I have created an issue for this: https://github.com/inversify/InversifyJS/issues/118\n. Thanks a lot for that :+1: \n. Thanks a lot for that :+1: \n. Closing this as it was fixed by #112\n. Thanks for that!\n. Thanks a lot :+1: \n. Hi @marnits please take a look to this JavaScript example . You need to import reflect-metadata:\nrequire(\"reflect-metadata\");\nIn TypeScript you can do:\nimport \"reflect-metadata\";\nPlease let me know if it works.\n. Hi @marnits I understand that the library should import its dependencies. The problem is that these dependencies are optional because they are polyfills. Importing polyfills is an anti-pattern because it penalizes modern JavaScript environments. So I believe this is a documentation problem more than a problem with the library.\nYour issue with: \nimport \"reflect-metadata\";\nCould be that you are missing a reference?\n/// <reference path=\"node_modules/reflect-metadata/reflect-metadata.d.ts\" />\nI have created a page in the wiki to document the environment support and usage of polyfills. Please let us know if this documentation helped you to solve the problem.\n. Hi @RichardJECooke in the home page we have a note about the environment that links to the Environment support and polyfills page. \nIs that not enough? Can you please let us know what parts of the docs are confusing? We will try to improve the docs, also if you want you can suggest changes to the docs sending a PR. Thanks!\n. I have created an issue to improve the installation  docs.\n. This is not ready but looking good :smile: \n\n. I have implemented the integration tests on this on a fork. I have already spotted some issues:\n\nI will try to keep the description above updated. So you know how far I'm from completing this.\n. All integration tests are working now :rainbow: :four_leaf_clover:\n\nPR https://github.com/inversify/InversifyJS/pull/128 \n. Done by #135\n. Hi @acopalipsis can you please use the issue template it helps us to support users like you. \nWe need to know what version of node.js you are using and most important which version of InversifyJS you are using. \nIn version 1.x the decorator was called Inject in version 2.x it is called inject.  Also in version 1.x the methods getAll and get from kernel are not defined. \nSo it looks to me like you are using 1.x with the documents of 2.x. Please try to install the alpha release: \n$ npm install inversify@2.0.0-alpha.3\nWe have a page that details How to upgrade from 1.x to 2.x.\n. I have updated the docs to display:\n$ npm install inversify@2.0.0-alpha.3 --save\ninstead of:\n$ npm install inversify --save\nThis should help others don't encounter the same problem. Please let us know if this solved your problem.\n. No problem. We don't use tsd because  it is deprecated. Right now we are in inversify@2.0.0-alpha.3 but once we go into a production ready release (inversify@2.0.0) we will send the type definitions to typings so it will be possible to do:\n$ typings install inversify --save\nBut this is not possible right now.\n. Based on Ninject:\n\nThe activation actions are run the first time an instance is resolved even if not created by Ninject (e.g. Constants)\n\nI think we need to rename proxy and change it for onActivation and this method would allow you to do something of your choice with the instance about to be injected and added to the cache. One of the use cases is injecting a Proxy. So injecting a proxy becomes more a use case than a feature:\n```\nkernel.bind(\"INinja\").to(Ninja);\nkernel.bind(\"IKatana\").to(Katana).onActivation((katana) => {\n    let handler = {\n        apply: (target, thisArgument, argumentsList) => {\n            console.log(Starting: ${new Date().getTime()});\n            let result = target.apply(thisArgument, argumentsList);\n            console.log(Finished: ${new Date().getTime()});\n            return result;\n        }\n    };\n    katana.use = new Proxy(katana.use, handler);\n    return katana;\n});\n``\n. I've been reading about this an the majority of IoC container don't include interception as part of the IoC container itself. They support it via plugins and extensions. So I decided to changeproxyfroonActivation`. This can be used for interception and for other purposes.\nThis example implements interception without the help of plugins or external libraries thanks to ES6 proxies:\n```\nkernel.bind(\"INinja\").to(Ninja);\nkernel.bind(\"IKatana\").to(Katana).onActivation((context, katana) => {\n    let handler = {\n        apply: (target, thisArgument, argumentsList) => {\n            console.log(Starting: ${new Date().getTime()});\n            let result = target.apply(thisArgument, argumentsList);\n            console.log(Finished: ${new Date().getTime()});\n            return result;\n        }\n    };\n    katana.use = new Proxy(katana.use, handler);\n    return katana;\n});\n```\nIf you want you could easily plug in an external library for interception. Here is an example with @ktutnik's Benalu:\n```\nkernel.bind(\"INinja\").to(Ninja);\nkernel.bind(\"IKatana\").to(Katana);\nkernel.bind(\"IBenalu\").toValue(Benalu);\nkernel.bind(\"IKatana\").to(Katana).onActivation((context, katana) => {\nlet Benalu = context.kernel.get<IBenalu>(\"IBenalu\");\n\nvar proxy = Benalu.fromInstance(katana)\n    .addInterception(function(i) {\n\n        //filter the invocation\n        if(i.methodName == \"use\"){\n\n            //call the real method\n            i.proceed();\n\n            //override the return value\n            i.returnValue = \"Custom return!\";\n        }\n    })\n    .build();\n\n});\n```\nThis is done in #135\n. HI @rashtao thanks for reporting. We will fix this as soon as we can. All we need to do is change this line and fix compilation errors that will raise. So it should be a quick fix.\n. Hi @jamesrichford that would be great :smile: I will assign it to you.\n. yes that's right documentation should not be committed. Take your time fixing the implicit anys thanks for helping with ti :smile: \n. @jamesrichford thanks for working on this.\nAbout the tslint issue\nI use the VS Code tslint plugin and I get that error:\n\nHowever when I use gulp-tslint the error is gone. So it must be the version of tslint? I have created an issue but it is likely to escalate to the tslint project... One thing I have notice is that the global tslint influences on this my global tslint package is tslint@3.3.0 so maybe try to update gulp-tslint and the global tslint package.\nAbout any issues\nThe functions _param and `__decorate are based on the TypeScript pollifyll for decorators. I think target shoud have the same type (probably any), in your example it uses 3 types:\n\nGo to this link and look at the javascript output.\nThe function _param cannot change from this:\nfunction (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nWe can use hard-coded null for the key as you have said. My fault here because I haven't explain this yet but in the future we will probably explore implementing method and properties injections and we will then need the key. So we can choose to set it as null  for now or leave it as it is right now?\nThe function __decorate has been simplified from:\nfunction (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nto\nfunction _decorate(decorators, target) {\n    Reflect.decorate(decorators, target);\n}\nBecause in inversify we are sure that Reflect is available and we are sure that method and property decorators are not allowed (for now). \nI'm going to try to take a look to help you but I have little time this week so I can't promise :(\n. Hi @jamesrichford  I took a look to this and I ended up finishing it. As you said it ended up being much more work that expected. Thanks for helping me with it. https://github.com/inversify/InversifyJS/pull/129\n@rashtao thanks for reporting the issue. We are trying to go into beta an any kind of issues reported are more than welcome. This is now fixed and will be released soon please keep an eye on the releases.\n. Thanks for reporting! I have take a look and I know what's going on but I have spotted a performance optimization. Will let you know as soon as I fix it (probably tonight).\n. Hi @acopalipsis this has been resolved but it has not been released yet. I will try to remember to notify you once we do a release but please keep an eye for releases.\n. This is in progress at remojansen/InversifyJS.\n. Thanks! :+1: I didn't know that you can do that with the markdown :smile: \n. Thanks a lot for reporting this issue. I have one question. I like the Redux style:\n- dist (bundled + sourcemaps and compressed bundled + sourcemaps)\n- lib (es5 not compressed)\n- es (es6 not compressed)\nWhat about sourcemaps for lib and es6? Should they be included? I took a look top redux and it doesn't include sourcemaps (even for the compressed file in dist).\nThanks!\n. I think is good idea two add them as a gulp task. I was actually thinking about adding an extra compilation targeting es6 a couple of days ago. \nI wasn't thinking about including the output to the npm releases, I was thinking about catching potential duplicated definitions errors caused by the es6.d.ts file that is included by the compiler when we target es6.\nWe are including sourcemaps already in the dist folder using .map files. So we just need:\n- [ ] Two more tasks to generate the lib and es folders. I haven't test it but should be similar to the following:\n```\nvar tsLibProject = tsc.createProject(\"tsconfig.json\", { target : \"ES5\" });\ngulp.task(\"build-lib\", function() {\n    return gulp.src([\n        \"src/*/.ts\"\n    ])\n    .pipe(tsc(tsLibProject ))\n    .on(\"error\", function (err) {\n        process.exit(1);\n    })\n    .js.pipe(gulp.dest(\"lib/\"));\n});\nvar tsEsProject = tsc.createProject(\"tsconfig.json\", { target : \"ES6\" });\ngulp.task(\"build-es\", function() {\n    return gulp.src([\n        \"src/*/.ts\"\n    ])\n    .pipe(tsc(tsEsProject))\n    .on(\"error\", function (err) {\n        process.exit(1);\n    })\n    .js.pipe(gulp.dest(\"es/\"));\n});\n``\n- [ ] Add this two new tasks to [thebuildtask](https://github.com/inversify/InversifyJS/blob/master/gulpfile.js#L181-L189) so it runs on CI.\n- [ ] Add thelibandesfolders to the.gitignore` file.\nPRs are more than welcome, I think I haven't left anything behind but please add a comment if you are unsure about anything.\n. OK this makes sense now. They don't have sourcemaps because they never compress and they don't have dist folder either. Let's leave the dist folder there for now. Is handy if someone wants to test it without a build script.\nAs you say we will need to update the package.json as you have said:\n\"main\": \"lib/inversify.js\",\n\"jsnext:main\": \"es/inversify.js\",\nI wasn't aware of the jsnext field is nice to learn about it :smile: \n. As I have explained at the chat:\n\nWe have removed it because most people is using a build tool like webpack and browserify\nthe dist folder was good for being consumed directly in browsers but it was causing some problems that was preventing us from being able to auto-generate the dts files and simplify the installation process.\n. I'm sorry but I cannot merge this. There is a problem with the typings field in the package.json file. We tried to used a few weeks ago but we had to roll it back.\n\nYou can read here about the requirements:\n\nYour typings file should...\n- be a .d.ts file\n- be an external module\n- not have triple-slash references\n\nWe meet the first two requirements but we have a dependency on bluebird.d.ts and harmony-proxy.d.ts which means that we don't meet the third requirement and therefore we cannot use the typings field in the package.json file.\nRight now we are in alpha so we are just explaining how to to add a manual reference but in the future we are going to add the type definitions to the typings registry. If you know how to do this better your help is more than welcome :smile: \nIf you want to update the PR to send just the README.md changes I will be happy to merge it.\n. We created them manually because some people was having problems. The problem was that we couldn't find a way to create one single type definition file that would work all the possible ways of consuming it:\n- Add // <reference>\n- No // <reference> but typings in package JSON\n- es6 imports import { } from \"inversify\"\n- typescript external module import inversify = require('inversify');\n- global window.inversify\n. @hourliert give it a few minutes and run the build again the coveralls servers fails some times :(\n. Nice one :+1: thanks for your help!\n. @hourliert  If you are wondering when will this be release... we have a roadmap. I want to merge issues #142 & #136 and then I will release 2.0.0-alpha.7. After that we should be really close to a beta release.\n. Thanks!\n. We need it for contextual bindings and multi injection. But you can solve your problem using the unbind method:\nkernel.unbind(\"HttpConfig\")\nkernel.bind(\"HttpConfig\").to(customHttpConfig)\n. Thanks!\n. Thanks! Sorry we are changing a lot the API during the alpha releases and it's hard to keep everything updated. Once we go I to beta we will focus on the documentation.\n. Hi @KarolBuchta I'm just going to wait until the next alpha release to see if fixes this. It should be at some time this week. Will get back as soon as I do a new release.\n. @KarolBuchta I have assign it to you. Thanks a lot for helping me with this :smile: \n. @KarolBuchta thanks a lot for spending some time checking this out :+1: \n. Thanks for reporting this :+1:  I will add something to the docs for the beta release.\n. @KarolBuchta I have assign it to you. Thanks a lot for helping me with this :smile: \n. Hi @KarolBuchta the wiki is now part of the source code you can find the new page here. Thanks!\n. I think we are missing an important detail in the docs. Can you please try to add the following to your tsconfig.json file:\n\"emitDecoratorMetadata\": true\nPlease let me know if it works.\n. Great! We don't want to add it as a dependency because it will eventually become part of the run time. So it is a temporal fallback. Same applies for the Promise and Proxy APIs. We have documented it at https://github.com/inversify/InversifyJS/wiki/Environment-support-and-polyfills\n. Thanks! feel free to ask for support again if you have any problems. We are trying to go into beta soon. I'm hopping sometime this month.\n. I'm glad to know that you like the library :smile_cat: \nI haven't run the following code sample so it may contain some errors but the following should work:\n``` ts\n@injectable()\nclass PersonStore {\n    constructor(@multiInject(\"IPerson\") people: IPerson[]) {\n      // ...\n    }\n  }\nexport const kernel = new Kernel();\nexport interface IPerson {}\n```\n``` ts\n@injectable()\nclass Ninja implements IPerson {}\n@injectable()\nclass Samurai implements IPerson {}\nkernel.bind(\"IPerson \").to(Ninja);\nkernel.bind(\"IPerson\").to(Samurai);\nkernel.bind(\"IPersonStore\").to(PersonStore);\nconst personStore = kernel.get(\"IPersonStore\"); \n// If you need a factory\nkernel.bind(\"IFactory\").toAutoFactory(\"IPersonStore\");\nconst personStoreFactory = kernel.get(\"IFactory\");\n```\n. Thanks, do you want to close the issue or keep it open until you can confirm?\n. Thanks!\n. Looks like you forgot to add a reference to the type definition file:\n/// <reference path=\"node_modules/inversify/type_definitions/inversify/inversify.d.ts\" />\nOnce we go into beta we will distribute this file via typings but for the moment you need to manually add the reference. Please  let me know if it works.\n. You should be able to add it to your path in your gulp configuration.\n. var path = [\n    \"**/*.ts\",\n   \"node_modules/inversify/type_definitions/inversify/inversify.d.ts\",\n    \"!node_modules/**\", // maybe you need to remove this??\n    \"!typings/browser/**\",\n    \"!typings/browser.d.ts\", '!bin/**'\n];\n. I think I know whats going on... VS Code uses the tsconfig.json file not the gulpfile.js, so instead of declaring the files to be included in your gulpfile.js you can declare then in your tscondig.json file. You can see an example here.\n. It could be that there is a conflict between:\n\"exclude\": [\n    \"node_modules\",\nAnd\n\"files\": [\n      \"node_modules/inversify/type_definitions/inversify/inversify.d.ts\"\n  ]\n. I don't know :disappointed: I would suggest as a temporal solution that you add the reference:\n/// <reference path=\"../node_modules/inversify/type_definitions/inversify/inversify.d.ts\" />\nTo your main.d.ts file. Once we go into beta you will be able to install the inversify.d.ts file using typings so all you will need to do is to remove the reference.\n. The problem is the versions. Which version of InversifyJS are you using?\n. Yes that's the problem. I just opened a PR https://github.com/DefinitelyTyped/DefinitelyTyped/pull/8851 to solve your problem. I recommend you to use the latest 2.0.0-alpha.8 and to keep an eye on releases. We will probably have a couple of releases this month before going into beta.\n. Yes it looks like a bug. I think if you use the @multiInject decorator the injected value should always be an array (even if there is only one binding). Thanks for spotting this issue.\n. Great I really need help to spot this kind of stuff because there are millions of use cases. Thanks a lot for helping me to tests and please feel free to try to do a PR with a bud fix If you think that you know what is going on.\n. Hi, thanks for the examples. I can see why the following won't work:\nts\n@injectable()\nclass SamuraiMaster extends Samurai {\n    public isMaster: boolean;\n}\nBy looking at the JS output:\nts\nvar SamuraiMaster = (function (_super) {\n    __extends(SamuraiMaster, _super);\n    function SamuraiMaster() { // No declared constructor arguments\n        _super.apply(this, arguments); // HERE!\n        this.isMaster = true;\n    }\n    return SamuraiMaster;\n}(Samurai));\nHowever, the following works:\nts\n@injectable()\nclass SamuraiMaster extends Samurai {\n    public isMaster: boolean;\n    public constructor(@inject(SYMBOLS.IKatana) weapon: IWeapon) {\n        super(weapon);\n        this.isMaster = true;\n    }\n}\nThe JS output looks as follows:\nvar SamuraiMaster = (function (_super) {\n    __extends(SamuraiMaster, _super);\n    function SamuraiMaster(weapon) {\n        _super.call(this, weapon);\n        this.isMaster = true;\n    }\n    SamuraiMaster = __decorate([\n        injectable(),\n        __param(0, inject(SYMBOLS.IKatana))\n    ], SamuraiMaster);\n    return SamuraiMaster;\nSo it looks to me like a limitation more than a bug. The main problem for me is that it fails because weapon is undefined but there are no friendly errors like: \nError: Derived classes must explicitly declare its constructor.\nI know a hack that we can use to be able to provide a friendly error. We can check the SamuraiMaster.prototype.__proto__.constructor to access the Samurai constructor from the SamuraiMaster constructor.\nThe problem is that it is a really bad idea to use __proto__. However, I saw a new API I wasn't aware of Object.getPrototypeOf(). \nI'm going to sleep now because is 1:39 am here :( but let me think about it and I will share some ideas tomorrow :sleeping: :wink: \n. Take a look to this early implementation. I need to to more testing but this will probably solve this problem :smile: \n. The example that you used to showcase the error:\n\nThis one doesn't because _katana and _shuriken are undefined.\n\nShould now throw:\nUncaught Error: Derived class must explicitly declare its constructor: CyberNinja.\nThanks a lot for helping me to spot this issue.\n. Thanks a lot for that :+1: \n. Hi @hourliert thanks for your help. I have assigned this issue it to you.\nRemoving the change from #155 and doing the following sounds good to me:\nif (\n    request.target && request.target.isArray() &&\n    (!request.parentRequest.target || !request.parentRequest.target.isArray())\n) {\n// ..\nI need to think about the @multiInject of a @multiInject is a complex case :smile:\n. Sounds great :smile: I will code review your PR. If you think that there is going to be something that could lead to limitations on the future or that feels like a hack maybe ask here before actually implementing it but otherwise work ahead :rocket: \n. Thanks a lot! Great job :+1: I only have one minor comment. The method:\nmatchesArray(name: string|Symbol|any): boolean;\nThe argument name is really the runtime identifier of the type. At the moment there is an inconsistency in the code sometimes I use runtimeIdentifier and sometimes I use service to refer to the same thing. Here we are using name. What do you think is better runtimeIdentifier or service? We should use the same name across all the modules in the lib.\n. I like serviceIdentifier :+1: I have created an issue for this refactoring https://github.com/inversify/InversifyJS/issues/161\n. @CoderAjay Thanks!\n. Happy to hear that!  that people enjoy building awesome stuff with InversifyJS it what matters the most to us \ud83d\ude04\n. @KarolBuchta thanks a lot for your help :+1: and congratulations for your first PR :wink: \n. Thanks :+1:\n. Thanks @markistaylor a lot for your contribution :+1: \n. Hi @hourliert thanks for reporting this. I have assigned the issue to you. Send a PR whenever you have a chance, no need to be in a hurry :wink: \n. Thanks a lot for the PR. Your help is more than welcome we really need people like you to help us to spot issue before we do a production-ready release.\n. Thanks a lot :) I like the way you solved the issue :+1: \n. In this example:\nts\nkernel.bind<ISword>(\"ISword\").to(EnchantedSword).withDynamicParameters((context, params) => {\n    // Imagine to have some logic here that picks the kind of sword to enchant\n    let swordType = isWarrior(player) ? \"real\" : \"toy\"\n    params[\"ISword\"] = context.kernel.getNamed<ISword>(\"ISword\", swordType);\n});\nMy understanding is that player and isWarrior are somehow available as globals. The fact they are not passed to the function as arguments is something that looks like a code smell to me.\nWe want to achieve this without using globals. The problem is that there are two different cases here:\nA) Dynamic values change based on conditions around types\nIf you are trying to do something like:\nts\nfunction isWarrior(player) {\n     return player instanceof Warrior; // looking for types\n}\nThen you cal use contextual constrains to remove the globals. \nts\nkernel.bind<ISword>(\"ISword\").to(MetallicSword).whenInjectedInto(Warriot);\nkernel.bind<ISword>(\"ISword\").to(ToySword).whenInjectedInto(Civil);\n// or\nkernel.bind<ISword>(\"ISword\").to(MetallicSword).whenAnyAncestorIs(Warrior);\nkernel.bind<ISword>(\"ISword\").to(ToySword).whenAnyAncestorIs(Civil);\nIt would also be possible to use metadata:\nts\nkernel.bind<ISword>(\"ISword\").to(MetallicSword).whenAnyAncestorTagged(\"warrior\", true);\nkernel.bind<ISword>(\"ISword\").to(ToySword).whenAnyAncestorTagged(\"warrior\", false);\nTake a look to this example of contextual constraints I wrote it some time ago but is related:\nThere are many out of the box constraints available that you could potentially use:\nts\ninterface IBindingWhenSyntax<T> {\n    when(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T>;\n    whenTargetNamed(name: string): IBindingOnSyntax<T>;\n    whenTargetTagged(tag: string, value: any): IBindingOnSyntax<T>;\n    whenInjectedInto(parent: (Function|string)): IBindingOnSyntax<T>;\n    whenParentNamed(name: string): IBindingOnSyntax<T>;\n    whenParentTagged(tag: string, value: any): IBindingOnSyntax<T>;\n    whenAnyAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T>;\n    whenNoAncestorIs(ancestor: (Function|string)): IBindingOnSyntax<T>;\n    whenAnyAncestorNamed(name: string): IBindingOnSyntax<T>;\n    whenAnyAncestorTagged(tag: string, value: any): IBindingOnSyntax<T>;\n    whenNoAncestorNamed(name: string): IBindingOnSyntax<T>;\n    whenNoAncestorTagged(tag: string, value: any): IBindingOnSyntax<T>;\n    whenAnyAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T>;\n    whenNoAncestorMatches(constraint: (request: IRequest) => boolean): IBindingOnSyntax<T>;\n}\nB) Dynamic values change based on conditions around data\nIf you are looking for something like:\nts\nfunction isWarrior(player) {\n     return player.isWarrior; // looking for runtime data\n}\nIn this case we need a factory to remove the globals because you need to pass the data as arguments.\nts\nkernel.bind<IFactory<ISword>>(\"IFactory<ISword>\").toFactory<ISword>((context) => {\n    return (player) => {\n        if (player.isWarrior) {\n            return context.kernel.getNamed<ISword>(\"ISword\", \"real\");\n        }  else {\n            return context.kernel.getNamed<ISword>(\"ISword\", \"toy\");\n        }\n    };\n});\nAbout the date issue\nWe can't do what castle does because our architecture is different. However, I think there is a use case that is not available right now.\n``` ts\ninterface IUseDate {\n    doSomething();\n}\n@injectable()\nclass UseDate implements IUseDate {\n    constructor(@inject(\"Date\") private currentDate: Date) {\n    }\ndoSomething() {\n    console.log(`Today is ${this.currentDate}`);\n}\n\n}\nlet kernel = new Kernel();\nkernel.bind(\"IUseDate\").to(UseDate);\nkernel.bind(\"Date\").toDynamicValue((context) => { new Date(); });\nlet subject = kernel.get(\"IUseDate\");\nsubject.doSomething(); // will print a new date in each instance\n```\nSummary\n\nFeel free to share with us your real use case scenario and we will try our best to help you to solve it using contextual constraints or factories. It is even possible to mix factories and contextual constraints.\nWe are not going to implement withDynamicParameters for now because it doesn't fit well with the InversifyJS architecture and there are potential ways to work around it.\nWe will implement toDynamicValue to solve the date use case.\n. Hi, thanks for your comment. If the users invoke:\n\nlet engine = carFactory.createEngine(1);\nThey factory creates a new engine with displacement === 1 but how does the factory knows if the engine should be PetrolEngine or DieselEngine?\n. Hi @lazyoft please take a look to the following. I have assumed that you need some sort of \"engine name\":\n``` ts\n// this bindings should not be exposed to the users\nlet kernel = new Kernel();\nkernel.bind(\"ISparkPlugs\").to(SparkPlugs);\nkernel.bind(\"IInjectorPump\").to(InjectorPump);\nkernel.bind>(\"IFactory\").toFactory((context) => {\n    return (named: string) => {\n        return context.kernel.getNamed(\"IEngine\", named);\n    };\n});\n// expose this function to the users of the library (do not expose the kernel directly)\nfunction registerEngine(engine, named, displacement) {\n// bind the engine to a category using a named binding\nkernel.bind<IEngine>(\"IEngine\").to(engine).whenTargetNamed(named);\n\n// biding the displacement to the engine that we just registered\nkernel.bind<number>(\"displacement\").to(displacement).whenInjectedInto(engine);\n\n}\n// users can register new engines\nregisterEngine(DieselEngine, \"diesel\", 1);\nregisterEngine(PetrolEngine, \"petrol\", 2);\nlet createEngine = kernel.get>(\"IFactory\");\nlet dieselEngine = createEngine(\"diesel\"); // displacement 1\nlet petrolEngine = createEngine(\"petrol\"); // displacement 2\n```\nThe only problem with this is if you have two engines with the same name... but you could bind engines to cars or something more advanced:\n``` ts\nfunction registerEngine(engine: IEngine, car: ICar, displacement: number) {\n// bind the engine to a category using a named binding\nkernel.bind<IEngine>(\"IEngine\").to(engine).whenInjectedInto(car);\n\n// biding the displacement to the engine that we just registered\nkernel.bind<number>(\"displacement\").to(displacement).whenInjectedInto(engine);\n\n}\nregisterEngine(DieselEngine, SomeCarType, 1);\nregisterEngine(PetrolEngine, AnotherCarType, 2);\n```\n. Thanks a lot for helping me to understand your needs. I've been doing a lot of thinking about the different ways we could try to resolve this use case and I think I have found a nice solution:\n``` ts\n// Current IFactory behaviour\nexport interface IFactory extends Function {\n    (...args: any[]): T;\n}\n// Proposed IFactory behaviour \nexport interface IFactory extends Function {\n    (...args: any[]): (IFactory|T);\n} \n```\nWe will need to change a bit the classes:\n``` ts\n@injectable()\nclass DieselEngine implements IEngine {\n    private _injectorPump: IInjectorPump;\n    public displacement: number;\n    constructor(\n        @inject(\"IInjectorPump\") injectorPump: IInjectorPump\n    ) { \n        this._injectorPump = injectorPump;\n        this.displacement = null; // don't inject displacement\n    } \n    /.../\n}\n@injectable()\nclass PetrolEngine implements IEngine {\n    private _sparkPlugs: ISparkPlugs\n    public displacement: number;\n    constructor(\n        @inject(\"ISparkPlugs\") sparkPlugs: ISparkPlugs\n    ) {\n        this._sparkPlugs = sparkPlugs;\n        this.displacement = null; // don't inject displacement\n    }     \n    /.../\n}\n```\nThe factory will work with AMBIGUOUS_MATCH:\n``` ts\nkernel.bind(\"ISparkPlugs\").to(SparkPlugs);\nkernel.bind(\"IInjectorPump\").to(InjectorPump);\nkernel.bind(\"IEngine\").to(PetrolEngine).whenTargetNamed(\"petrol\");\nkernel.bind(\"IEngine\").to(DieselEngine).whenTargetNamed(\"diesel\");\nkernel.bind>(\"IFactory\").toFactory((context) => {\n    return (named: string) => (displacement: number) => {\n        let engine = context.kernel.getNamed(\"IEngine\", named);\n        engine.displacement = displacement;\n        return engine;\n    };\n});\n@injectable()\nclass DieselCarFactory implements ICarFactory {\n    private _engineFactory: IFactory;\n    constructor(\n        @inject(\"IFactory\") factory: IFactory // (...args: any[]) => (...args: any[]) => T;\n    ) { \n        this.factory = factory(\"diesel\");                       // (...args: any[]) => T;\n    }\n    createEngine(displacement: number): IEngine {\n        return this.factory(displacement);                      // T\n    }\n}\n```\nThe factory will also work with NO AMBIGUOUS_MATCH:\n``` ts\nkernel.bind(\"IEngine\").to(DieselEngine);\nkernel.bind>(\"IFactory\").toFactory((context) => {\n    return (displacement: number) => {\n        let engine = context.kernel.get(\"IEngine\");\n        engine.displacement = displacement;\n        return engine;\n    };\n});\n@injectable()\nclass DieselCarFactory implements ICarFactory {\n    private _engineFactory: IFactory;\n    constructor(\n        @inject(\"IFactory\") factory: IFactory // (...args: any[]) => T;\n    ) { \n        this.factory = factory;                                 // (...args: any[]) => T;\n    }\n    createEngine(displacement: number): IEngine {\n        return this.factory(displacement);                      // T\n    }\n}\n```\nMy full notes are available here.\n. Cool! I'm going to close this issue and create two separated issues one for the toDynamicValue and another for the new IFactory<T> signature.\n. I know using castings is no the best but If you really wanted to keep displacement private you would be able to do the following:\n``` ts\n@injectable()\nclass DieselEngine implements IEngine {\n    private _injectorPump: IInjectorPump;\n    private _displacement: number;\n    constructor(\n        @inject(\"IInjectorPump\") injectorPump: IInjectorPump\n    ) { \n        this._injectorPump = injectorPump;\n        this._displacement = null; // don't inject displacement\n    } \n    /.../\n}\nkernel.bind>(\"IFactory\").toFactory((context) => {\n    return (named: string) => (displacement: number) => {\n        let engine = context.kernel.getNamed(\"IEngine\", named);\n        (engine)._displacement = displacement; // note casting here\n        return engine;\n    };\n});\n``\n. As it is right now it is not possible. When you request T InversifyJS will create an instance of T but it won't useFactory` for that. However, I will soon start working on a feature that will solve this problem and has been already being requested by other users. I will a new comment when I have an update. Sorry for any issues caused by the lack of this feature.\n. I'm closing this issue but you can follow the progress at  #177\n. #177 has been split into two issues. You can track the progress of the dynamic value injection in #181 \n. @lazyoft I have this almost ready in a fork. The problem is that the users are forced to write the full signature of the Factory:\nts\n@inject(\"IFactory<IEngine>\") factory: (category: string) => (displacement: number) => IEngine\nAn alternative was to use generics:\nts\n@inject(\"IFactory<string, number, IEngine>\") factory: IFactory<string, number, IEngine>\nBut it would be limited to a number of generic arguments and it would be really verbose.\nI have created another issue to request a feature that would the following:\nts\n@inject(\"IFactory<IEngine>\") factory: IFactory<IEngine>\nI'm going to wait to see what the TypeScript guys write back.\n. This has been implemented I will release version 2.0.0-beta.2 really soon \ud83d\ude04 \n. We don't support injection into functions. We only support injection via class constructors  at the moment but we have documented a work around here.\n. The native Symbol should start with uppercase. The type definitions use uppercase as well. Can you share more details about the error please?\n. Symbol can be used to declare global and local symbols:\n``` ts\nSymbol.for(\"foo\"); // create a new global symbol\nSymbol.for(\"foo\"); // retrieve the already created symbol\n// Same global symbol, but not locally\nSymbol.for(\"bar\") === Symbol.for(\"bar\"); // true\nSymbol(\"bar\") === Symbol(\"bar\"); // false\n// The key is also used as the description\nvar sym = Symbol.for(\"mario\");\nsym.toString(); // \"Symbol(mario)\"\n```\nMore info here.\nInversifyJS is designed to use local symbols:\n``` ts\nlet TYPES = {\n    Katana: Symbol(\"IKatana\"),\n    Ninja: Symbol(\"INinja\"),\n    Shuriken: Symbol(\"IShuriken\")\n};\n@injectable()\nclass Ninja implements INinja {\nprivate _katana: Katana;\nprivate _shuriken: Shuriken;\n\npublic constructor(\n    @inject(TYPES.Katana) katana: Katana,\n    @inject(TYPES.Shuriken) shuriken: Shuriken\n) {\n    this._katana = katana;\n    this._shuriken = shuriken;\n}\n\npublic fight() { return this._katana.hit(); };\npublic sneak() { return this._shuriken.throw(); };\n\n}\n```\nA full example is available here.\n. When you select a compilation target, TypeScript imports a file named lib.d.ts. This file delcares all the native JavaScript objects. The Symbol object is not recognized by typescript unless you target ES6. But if you add the InversifyJS type definitions:\nts\n/// <reference path=\"node_modules/inversify/type_definitions/inversify/inversify.d.ts\" />\nYou will be able to target ES5 and the Symbol should be declared.\n. The TypeScript docs explain the requirements for typed npm modules:\n\nYour definition files should\n- be.d.ts files\n- be written as external modules\n- not contain triple-slash references\n\nThe problem is that our type definitions contain triple-slash references so we cant use the typings field:\nMicrosoft is working on a new way to publish type definitions via npm for TypeScript 2.0 so I will wait for that to be announced and do it the way they recommend.\n. I have created inversify-dts that is the way we are going to provide type definitions for now so I'm closing this issue.\n. I've been thinking about this for a while. I'm not sure about how will exactly work but I will share the my progress on it here...\n. I will do some analysis but implementing property injection is something possible.\n. I would like to share some thoughts about this.... All kinds of feedback will be much appreciated.\nThe current behaviour\nConnect could actually be used to inject some props using the latest release:\n``` ts\nfunction mapStateToPropsReposPage(state: any) {\n    return { \n        repos: state.get(\"repos\"),\n        myService: kernel.get(MyService)\n    };\n}\nfunction mapDispatchToPropsReposPage(dispatch: Redux.Dispatch) {\n    return { actions : bindActionCreators(settingsActions, dispatch) };\n}\n@connect(mapStateToPropsReposPage, mapDispatchToPropsReposPage)\nclass Settings extends Component {\n  // ...\n}\n```\nOption A: Optional dependencies\nts\nexport class Settings extends Component<SettingsProps, {}> {\n  constructor (props: SettingProps, context: any, @inject(MyService) private myService: MyService) {\n    super(props, context);\n  }\n  // ...\n}\nThis introduces optional dependencies. We won't be implementing this because it can lead to bad practices and in the context of React is useless.\nOption B: Property injection\n``` ts\nexport class Settings extends Component {\n  @inject(MyService)\n  private myService: MyService;\nrender() {}\n}\n```\nIn the current version when we use @inject (as a parameter decorator) we are generating metadata but nothing is resolved. Later, when we invoke kernel.get<T>(\"T\") is when the actual entities are resolved and injected.\nIn the case of property injection (and in particular React) when we use  @inject (as a property decorator) we are not generating metadata we are actually resolving  and setting the dependency. This means that  @inject (as a property decorator) needs access to the kernel:\n``` ts\nlet kernel = new Kernel();\nkernel.bind(\"ISomeService\").to(SomeService);\nlet inject = makeInjectPropertyDecorator(kernel);\nclass SomeWebComponent {\n    @inject(\"ISomeService\")\n    private _service: ISomeService;\n    public doSomething() {\n        let count =  this._service.count;\n        this._service.increment();\n        return count;\n    }\n}\n```\nWhen we access the property (getter) is when kernel.get<T>(\"T\") is invoked. We can optimise this so the dependency is resolved only when we access the property for the first time. \nThis seems to be the way to go. My main concern is how to support some of the contextual binding constraints like whenNoAncestorIs or whenAnyAncestorNamed. I need to do some more thinking on this...\n. @otbe I would like to ask a few questions if you don't mind...\nHow @provideSingleton works?\nYou are suggesting that @provideSingletonScope will generate the following binding:\nts\nkernel.bind<ISomeService>(\"ISomeService\").to(SomeService).inSingletonScope();\nI assume that you mean the following:\nts\nkernel.bind<any>(SomeService).to(SomeService).inSingletonScope();\nAs we don't have any other identifier or type information at that point? It would be like the following:\n``` ts\nlet kernel = new Kernel();\nlet provideSingleton = makeProvideSingletonDecorator(kernel);\nlet provideTransient = makeProvideTransientDecorator(kernel);\n// AKA kernel.bind(MyService1).to(MyService1).inSingletonScope()\n@provideSingleton\nclass MyService1 {}\n// AKA kernel.bind(MyService2).to(MyService2).inTransientScope()\n@provideTransient\nclass MyService2 {}\n```\nWhat about a fluent decorators?\nYour idea made me think about the following:\n``` ts\nlet kernel = new Kernel();\nlet provide = makeProvideDecorator(kernel);\n// AKA kernel.bind(MyService1).to(MyService1).inSingletonScope()\n@provide().inSingletonScope().done()\nclass MyService1 {}\n// AKA kernel.bind(MyService2).to(MyService2).inTransientScope()\n@provide().inTransientScope().done()\nclass MyService2 {}\n// AKA kernel.bind(Katana).to(Katana).whenTargetTagged(\"canThrow\", false)\n@provide().whenTargetTagged(\"canThrow\", false).done()\nclass Katana {}\n// AKA kernel.bind(Shuriken).to(Shuriken).whenTargetTagged(\"canThrow\", true)\n@provide().whenTargetTagged(\"canThrow\", true).done()\nclass Shuriken {}\n```\nCreating aliases would be straight forward:\n``` ts\nlet provideSingleton = provide().inSingletonScope().done();\nlet provideTransient = provide().inTransientScope().done();\nlet provideThrowable = provide().whenTargetTagged(\"canThrow\", true).done();\n@provideSingleton\nclass Katana {}\n@provideTransient\nclass Katana {}\n@provideThrowable\nclass Shuriken {}\n```\nWhat do you guys think?\nUsing @set instead of @inject?\nI also have a question for everyone. To avoid confusion between @inject as a parameter decorator and @inject as a property decorator I think we should use a better naming.\nHow about naming the property decorator @set?\n``` ts\nlet kernel = new Kernel();\nkernel.bind(\"ISomeService\").to(SomeService);\nlet set = makeSetDecorator(kernel);\nclass SomeWebComponent {\n    @set(\"ISomeService\")\n    private _service: ISomeService;\n    public doSomething() {\n        let count =  this._service.count;\n        this._service.increment();\n        return count;\n    }\n}\n``\n. I'm adding thediscussion` label to this because this ticket will be splitted into a few tickets once we have a better idea of what needs to be done. For the moment it is likely that we will have two tickets:\n- Property injection support\n- Declaration of bindings via decorators\n. Hi @otbe and @donaldpipowitch thanks for your comments.\nWe will use @inject instead of @set. \nAbout the string constants. The @inject decorator will work with classes, strings and symbols, just like the current bind method.\nts\ninterface IKernel {\n    bind<T>(serviceIdentifier: (string|Symbol|INewable<T>)): IBindingToSyntax<T>;\n    // ...\n}\n``` ts\nlet kernel = new Kernel();\nkernel.bind(SomeService).to(SomeService);\nlet inject= makeInjectPropertyDecorator(kernel);\nclass SomeService {}\nclass SomeWebComponent {\n    @inject(SomeService)\n    private _service: SomeService;\n    public doSomething() {\n        let count =  this._service.count;\n        this._service.increment();\n        return count;\n    }\n}\n// or\nlet ISomeService = \"ISomeService\";\nclass SomeWebComponent {\n    @inject(ISomeService)\n    private _service: ISomeService;\n    public doSomething() {\n        let count =  this._service.count;\n        this._service.increment();\n        return count;\n    }\n}\n// or \nlet ISomeService = Symbol(\"ISomeService\");\nclass SomeWebComponent {\n    @inject(ISomeService)\n    private _service: ISomeService;\n    public doSomething() {\n        let count =  this._service.count;\n        this._service.increment();\n        return count;\n    }\n}\n```\n. I have created an issue for property injection support  please review too see If I forgot to think about something...\nLet's focus on @provide in this issue. I will create a ticket for it once I feel more confident about the final requirements.\n. @otbe thanks for spotting it :)\n. I'm going to close this issue you can track the progress and share feedback at:\n- @provide support\n- Property injection support\nThanks a lot @otbe @donaldpipowitch and @kenjiru for sharing your feedback! :+1: \n. No worries, thanks for using the library :+1: \n. Property injection is now available in inversify@2.0.0-beta.3 \u2b50 \ud83c\udf89 documentation is available here.\n. I'm going to release this as an optional npm package. I'm going to be working on  another repo: https://github.com/inversify/inversify-binding-decorators\n. I just released inversify-binding-decorators@1.0.0-beta.1 so I'm closing this issue.\n. Thanks a lot \ud83d\udc4d \n. I'be been doing some analysis on this and it is better to wait for now until TypeScript 2.0 becomes stable.\n. Hi @goenning thanks for the comments. I tried this sometime ago and it is a big change. Some help is more than welcome. I will take a look to your branch over the next few days and share my thoughts. \nI'm working at the moment on a big refactor you can explore it here and see the changes here. I would recommend you to wait until I get it merged it into master or it will be a nightmare to resolve the conflicts. I'm planning to get it done over the next 2-3 weeks.\nAlso one of the things that we need to explore is that the changes should improve the code (prevent issues) but it should not cause trouble for our users, please keep in mind that :smile: \n. Hi @goenning I just merged the big refactor that I was talking about \ud83d\ude09 \n. Thanks a lot for the PR :+1: \n. From SO:\n\npropertyIsEnumerable will return true only for enumerable \"own\" properties.\n. Well @injectable should only be applied to classes and @inject only applied to properties or the arguments of a method. So they can't be applied to a method. In the case of properties it will be not enumerable.\n. Just adding here some ideas mentioned on Gitter...\n\n``` ts\nimport { TestableKernel } from \"inversify-testing-utils\";\nimport { kernel } from \"../src/kernel\";\n// TestableKernel is a superset of Kernel (includes snapshot/restoreSnapshot)\nlet testableKernel = new TestableKernel(kernel);\n// snapshot of original kernel\ntestableKernel.snapshot();\ntestableKernel.unbind(MyService);\ntestableKernel.bind(MyService).to(MyServiceMock);\n// do something...\n// return to snapshot\ntestableKernel.restoreSnapshot();\n```\n\nkeep in mind that restore must modify the original kernel\n\n``` ts\nimport { kernel } from './shared/kernel'; // this kernel includes all bindings from my app -> \nkernel.snapshot() // create a snapshot of the current bindings -> lets say \"MyService bound to MyService\"\nkernel.unbind(MyService);\nkernel.bind(MyService).to(MyServiceMock); // \"MyService bound to MyServiceMock\"\n// do something\nkernel.restoreSnapshot(); // \"MyService bound to MyService\"\n``\n. Snapshot is available thanks to #207 by @otbe I'm going to leave this open for now. I want to do some thinking about things like auto-mocking...\n. I think this can be closed for now? I will probably remove the project as well until we have a better idea.... I will think about this once 2.0.0 becomes gold.\n. Hi @lazyoft thanks for this proposal I will work on this as soon. I will release 2.0.0 and then I will work on 2.1.0 which will include this feature.\n. I'm closing this but this will be implemented. The implementation ticket is https://github.com/inversify/InversifyJS/issues/307.\n. Done by https://github.com/inversify/InversifyJS/pull/202\n. Done by https://github.com/inversify/InversifyJS/pull/202\n. Great work :) thanks a lot for this PR \n. Done by 38875cae73fdb2f56b0831d002d76d4cba831a8a\n. Nightly build is now enabled in Travis CI\n. YourApiRequestDecorator` entity is a class not an interface and then you are using:\nts\nBasicAuthDecorator implements ApiRequestDecorator\nInstead of:\nts\nBasicAuthDecorator extends ApiRequestDecorator\nWhy do you need a class?\n. Here are two examples that should help you:\nOption A: Using a base class\n``` ts\nclass ApiRequestDecorator {\n    public decorateRequest(request : any): void {\n};\n\n}\n@injectable()\nclass BasicAuthDecorator extends ApiRequestDecorator {\nprivate _username: string;\nprivate _password: string;\n\npublic constructor(\n    @inject(\"string\") @named(\"username\") username : string, \n    @inject(\"string\") @named(\"password\") password : string\n) {\n    super();\n    this._username = username;\n    this._password = password;\n}\n\npublic decorateRequest(request : any) : void {\n    super.decorateRequest(request);\n};\n\n}\n@injectable()\nclass SomeController {\nprivate _apiRequestDecorator: ApiRequestDecorator;\n\npublic constructor(\n    @inject(\"ApiRequestDecorator\") apiRequestDecorator: ApiRequestDecorator\n) {\n    this._apiRequestDecorator = apiRequestDecorator;\n}\n\npublic doSomething(request : any) {\n    this._apiRequestDecorator.decorateRequest(request);\n}\n\n}\nlet kernel = new Kernel();\nkernel.bind(\"ApiRequestDecorator\").to(BasicAuthDecorator);\nkernel.bind(\"SomeController\").to(SomeController);\n// this is the important part\nkernel.bind(\"string\").toConstantValue(\"your_username\").whenTargetNamed(\"username\");\nkernel.bind(\"string\").toConstantValue(\"your_password\").whenTargetNamed(\"password\");\nvar controller = kernel.get(\"SomeController\");\ncontroller.doSomething(null);\n```\nOption B: Using an interface\n``` ts\ninterface ApiRequestDecorator {\n    decorateRequest(request : any): void;\n}\n@injectable()\nclass BasicAuthDecorator implements ApiRequestDecorator {\nprivate _username: string;\nprivate _password: string;\n\npublic constructorpublic constructor(\n    @inject(\"string\") @named(\"username\") username : string, \n    @inject(\"string\") @named(\"password\") password : string\n) {\n    this._username = username;\n    this._password = password;\n}\n\npublic decorateRequest(request : any) : void {\n    // DO SOMETHING\n};\n\n}\n@injectable()\nclass SomeController {\nprivate _apiRequestDecorator: ApiRequestDecorator;\n\npublic constructor(\n    @inject(\"ApiRequestDecorator\") apiRequestDecorator: ApiRequestDecorator\n) {\n    this._apiRequestDecorator = apiRequestDecorator;\n}\n\npublic doSomething(request : any) {\n    this._apiRequestDecorator.decorateRequest(request);\n}\n\n}\nlet kernel = new Kernel();\nkernel.bind(\"ApiRequestDecorator\").to(BasicAuthDecorator);\nkernel.bind(\"SomeController\").to(SomeController);\n// this is the important part\nkernel.bind(\"string\").toConstantValue(\"your_username\").whenTargetNamed(\"username\");\nkernel.bind(\"string\").toConstantValue(\"your_password\").whenTargetNamed(\"password\");\nvar controller = kernel.get(\"SomeController\");\ncontroller.doSomething(null);\n```\nPlease feel free to ask any questions we are here to help :wink: \n. @Davste93 I have updated my last comment I forgot the most important part :cry:  To inject a value you need to use toConstantValue.\n. I would recommend you to take a look to all the features in the docs. I'm sorry I know the docs are really long :cry: but it is because there a lot of features :santa: \n. Hi @alfonsorios96 please refer to the page about inheritance in our wiki. Base classes require annotations as well.. Just landed master \ud83c\udf89 great work \ud83d\udc4d \n. Hi, can you please try the following:\n``` ts\n@injectable() // Needs to be injectable\nclass ApiDogDataRepository extends DataRepository {\n  constructor(\n    @inject('IParser') parser : IParser\n  ) {\n    super();\n    this.parser = parser;\n  }\n}\n@injectable() // Needs to be injectable\nclass ApiHumanDataRepository extends DataRepository {\n  constructor(\n    @inject('IParser') parser : IParser\n  ) {\n    super();\n    this.parser = parser;\n  }\n}\nlet kernel = new Kernel();\nkernel.bind>(\"DataRepository\")\n      .to(ApiHumanDataRepository);\nkernel.bind>(\"DataRepository\")\n      .to(ApiDogDataRepository);\nkernel.bind>(\"IParser\")\n      .to(ApiParser);\nkernel.bind>(\"IParser\")\n      .to(ApiParser);\n```\nI haven't run this code so I need your confirmation to know if it works :wink: \n. The following should also work:\n``` ts\n// ...\n@injectable() // Needs to be injectable\nclass ApiDogDataRepository extends DataRepository {\n  constructor(\n    @inject('IParser') parser : IParser\n  ) {\n    super();\n    this.parser = parser;\n  }\n}\n@injectable() // Needs to be injectable\nclass ApiHumanDataRepository extends DataRepository {\n  constructor(\n    @inject('IParser') parser : IParser\n  ) {\n    super();\n    this.parser = parser;\n  }\n}\nlet kernel = new Kernel();\nkernel.bind>(\"DataRepository\")\n      .to(ApiHumanDataRepository);\nkernel.bind>(\"DataRepository\")\n      .to(ApiDogDataRepository);\nkernel.bind>(\"IParser\").to(ApiParser);\n```\nIf your ApiHumanDataRepository and ApiDogDataRepository are doing the same they could also become a generic type ApiDataRepository:\n``` ts\n// ...\n@injectable() \nclass ApiDataRepository extends DataRepository {\n  constructor(\n    @inject('IParser') parser : IParser\n  ) {\n    super();\n    this.parser = parser;\n  }\n}\nlet kernel = new Kernel();\nkernel.bind>(\"IDataRepository\").to(ApiDataRepository);\nkernel.bind>(\"IParser\").to(ApiParser);\nlet apiHumanDataRepository = kernel.get>(\"IDataRepository\");\nlet apiDogDataRepository = kernel.get>(\"IDataRepository\");\n```\n. Hi @Davste93 please confirm if this issue can be closed when you have a chance \ud83d\ude09 \n. What you are looking for is a feature called contextual bindings:\n``` ts\ninterface IWeapon {}\nabstract class BaseSoldier {\n    weapon : IWeapon;\n    constructor(\n      weapon : IWeapon\n    ) {\n      this.weapon = weapon;\n    }\n}\n@injectable()\nclass Soldier extends BaseSoldier {\n    constructor(\n      @inject('IWeapon') weapon : IWeapon\n    ) {\n      super(weapon);\n    }\n}\n@injectable()\nclass Archer extends BaseSoldier {\n    constructor(\n      @inject('IWeapon') weapon : IWeapon\n    ) {\n      super(weapon);\n    }\n}\n@injectable()\nclass Knight extends BaseSoldier {\n    constructor(\n      @inject('IWeapon') weapon : IWeapon\n    ) {\n      super(weapon);\n    }\n}\n@injectable()\nclass Sword implements IWeapon{}\n@injectable()\nclass Bow implements IWeapon{}\n@injectable()\nclass DefaultWeapon implements IWeapon{}\nlet kernel = new Kernel();\nkernel.bind(\"IWeapon\").to(DefaultWeapon).whenInjectedInto(Soldier);\nkernel.bind(\"IWeapon\").to(Sword).whenInjectedInto(Knight);\nkernel.bind(\"IWeapon\").to(Bow).whenInjectedInto(Archer);\nkernel.bind(\"BaseSoldier\").to(Soldier).whenTargetNamed(\"default\");\nkernel.bind(\"BaseSoldier\").to(Knight).whenTargetNamed(\"knight\");\nkernel.bind(\"BaseSoldier\").to(Archer).whenTargetNamed(\"archer\");\nlet soldier = kernel.getNamed(\"BaseSoldier\", \"default\");\nlet knight = kernel.getNamed(\"BaseSoldier\", \"knight\");\nlet archer = kernel.getNamed(\"BaseSoldier\", \"archer\");\nconsole.log(knight.weapon);\nconsole.log(archer.weapon);\n```\nI had to change your code because it is not possible to create an instance of an abstract class. This means that you will never be able to do something like:\nts\nkernel.bind<X>(\"X\").to(SomeAbstractClass).\nAlso there is a limitation that forces you to indicate the injections in the derived class not in the abstract class so the following won't work:\n``` ts\nabstract class BaseSoldier {\n    weapon : IWeapon;\n    constructor(\n      @inject('IWeapon') weapon : IWeapon\n    ) {\n      this.weapon = weapon;\n    }\n}\n@injectable()\nclass Soldier extends BaseSoldier {}\n```\nBut the following will work:\n``` ts\nabstract class BaseSoldier {\n    weapon : IWeapon;\n    constructor(\n      weapon : IWeapon\n    ) {\n      this.weapon = weapon;\n    }\n}\n@injectable()\nclass Soldier extends BaseSoldier {\n    constructor(\n      @inject('IWeapon') weapon : IWeapon\n    ) {\n      super(weapon);\n    }\n}\n```\nSo you should be able to do what you want using contextual constraints but I have discovered a bug. If you decorate with injectable the abstract class:\n@injectable()\nabstract class BaseSoldier {\n    weapon : IWeapon;\n    constructor(\n      @inject('IWeapon') weapon : IWeapon\n    ) {\n      this.weapon = weapon;\n    }\n}\nA friendly error is displayed:\nError: Derived class must explicitly declare its constructor: Soldier.\nBut if you forget @injectable() undefined is infected and there are no errors displayed. I'm going to create a new issue to investigate this.\n. I have created the issue https://github.com/inversify/InversifyJS/issues/212\n. Great :tada: I was about to send another example a bit more simple:\n``` ts\nlet kernel = new Kernel();\nkernel.bind(\"IWeapon\").to(DefaultWeapon).whenInjectedInto(Soldier);\nkernel.bind(\"IWeapon\").to(Sword).whenInjectedInto(Knight);\nkernel.bind(\"IWeapon\").to(Bow).whenInjectedInto(Archer);\nkernel.bind(\"Soldier\").to(Soldier);\nkernel.bind(\"Knight\").to(Knight);\nkernel.bind(\"Archer\").to(Archer);\nlet soldier = kernel.get(\"Soldier\");\nlet knight = kernel.get(\"Knight\");\nlet archer = kernel.get(\"Archer\");\nconsole.log(soldier.weapon);\nconsole.log(knight.weapon);\nconsole.log(archer.weapon);\n```\nThe thing about contextual bindings is that is a really flexible feature so it is easy to find alternative and better ways :smile: \nCan I close this issue then?\n. This is fixed by 93ef0c745ec3fde262f79810f1b8aa8282bab286\n. Hi @gjsduarte I'm sorry bad I have bad news. The following is extracted from the angular 2.0 docs by Google:\n\nWe recommend adding @Injectable() to every service class, even those that don't have dependencies and, therefore, do not technically require it. Here's why:\n- Future proofing: No need to remember @Injectable() when we add a dependency later.\n- Consistency: All services follow the same rules, and we don't have to wonder why a decorator is missing.\n\nWe could make then optional but by adding @injectable to all our classes we can provide better error handling. Also in the future @inject might be not needed if the metadata generated by the TypeScript compiler for @injectable becomes more rich (at the moment it cannot be used for interfaces).\nIf this happens and we have all our classes decorated with @injectable, it will be save to remove all @inject annotations so it will be easier to migrate to a new version.\nSo I'm sorry but @injectable will remain mandatory.\n. Hi @hourliert can I ask you for some help? \nI think I remember you fixed one issue about abstract classes and you added this test case. I'm working on this issue and I have done some changes on a fork 8bc5a362080ccdabbe9727738f733f0525a14c5a. \nI fixed this issue but your test case is now failing \ud83d\ude22  \nThe following code throws \nError: Derived class must explicitly declare its constructor: SamuraiMaster.\nThis is a false possitive:\n``` ts\nclass Samurai implements ISamurai {\npublic rank: string;\n\npublic constructor(rank: string) { // dependency is base class detected\n    this.rank = rank;\n}\n\n}\n@injectable()\nclass SamuraiMaster extends Samurai implements ISamurai {\n    // explicitly declared constructor\n    constructor() { // no dependencies in derived class detected\n        super(\"Master\"); // this is not detected!! root cause of the false possitive\n    }\n}\n```\nIn the output JS there is nothing that I could parse using Regex:\njs\nvar Samurai = (function () {\n    function Samurai(rank) {\n        this.rank = rank;\n    }\n    return Samurai;\n}());\nvar SamuraiMaster = (function (_super) {\n    __extends(SamuraiMaster, _super);\n    function SamuraiMaster() {\n        _super.call(this, \"Master\"); // this is not detected\n    }\n    SamuraiMaster = __decorate([\n        injectable()\n    ], SamuraiMaster);\n    return SamuraiMaster;\n}(Samurai));\nThis might be just a limitation. Something that is not possible to be supported. Any ideas?\nThanks a lot \ud83d\ude09 \n. I could find _super.call(this, \"X\", \"Y\", \"Z\"); in the derivedClass.toString() and parse it to find [\"X\", \"Y\", \"Z\"]. Then, if the length of that array doesn't match the baseClass.length, I would be able to throw but it feels very hacky \ud83d\ude1e  and for engines with support for ES6 the regex would be different.\n. The following code behaves in multiple ways based on the engines:\n``` js\nclass Samurai {\n    constructor(name, rank) {\n        this.name = name;\n        this.rank = rank;\n    }\n}\nclass MasterSamurai extends Samurai {\n    constructor(name) {\n        super(name, \"master\");\n    }\n}\nconsole.log(MasterSamurai.toString());\n```\nES5\nfunction MasterSamurai(name) {\n    _super.call(this, name, \"master\");\n}\nES6 - Node v0.12.14\nfunction MasterSamurai(name) {\n    _classCallCheck(this, MasterSamurai);\n    return _possibleConstructorReturn(\n         this, \n         Object.getPrototypeOf(MasterSamurai).call(this, name, \"master\")\n    );\n}\nES6 - Node v4.4.4 & 5.11.1\nclass MasterSamurai extends (yield) {\n     constructor(name) {\n         super(name, \"master\");\n     }\n}\nES6 - Node v6.1.0\nclass MasterSamurai extends Samurai {\n    constructor(name) {\n        super(name, \"master\");\n    }\n}\n:cry: \nI have asked for help on SO.\n. The injection of undefined without errors issue is fixed. However, there is a limitation about derived classes. I have added it to the README.md file:\nInheritance\n``` ts\ninterface IWarrior {\n    weapon: IWeapon;\n}\n@injectable()\nclass Samurai implements IWarrior {\npublic weapon: IWeapon;\n\npublic constructor(weapon: IWeapon) {\n    this.weapon = weapon;\n}\n\n}\n```\nDerived classes constructor must be manually implemented and annotated.\nTherefore, the following code snippet:\nts\n@injectable()\nclass SamuraiMaster extends Samurai implements IWarrior {\n    public isMaster: boolean;\n}\nThrows an exception:\nError: Derived class must explicitly declare its constructor: SamuraiMaster\nHowever, he following works:\nts\n@injectable()\nclass SamuraiMaster extends Samurai implements IWarrior {\n    public isMaster: boolean;\n    public constructor(@inject(SYMBOLS.IWeapon) weapon: IWeapon) {\n        super(weapon);\n        this.isMaster = true;\n    }\n}\nThe above also works with abstract classes but it has one limitation. \nIt doesn't work when a base class has constructor injections and its derived class don't have any constructor injections:\n``` ts\n@injectable()\nclass Samurai implements ISamurai {\npublic rank: string;\n\npublic constructor(rank: string) {\n    this.rank = rank;\n}\n\n}\n@injectable()\nclass SamuraiMaster extends Samurai implements ISamurai {\n    constructor() {\n        super(\"Master\");\n    }\n}\n```\nThe precedding code snippet throws an error. Unfortunately, as a result of the technical limitation, this error is misleading:\nError: Derived class must explicitly declare its constructor: SamuraiMaster.\nYou can overcome this limitation by injecting into the derived class:\n``` ts\nkernel.bind(SYMBOLS.RANK).toConstantValue(\"Master\");\n@injectable()\nclass Samurai implements ISamurai {\npublic rank: string;\n\npublic constructor(rank: string) {\n    this.rank = rank;\n}\n\n}\n@injectable()\nclass SamuraiMaster extends Samurai implements ISamurai {\n    constructor(@inject(SYMBOLS.RANK) rank: string) {\n        super(rank);\n    }\n}\n```\n. Hi @codyjs I did a release yesterday https://www.npmjs.com/package/inversify-express-utils I haven't test it yet though... let me know if you find issues and need a new release :wink: \n. p.s. do you think we can close this issue as we have an issue for the example. If there are bugs or new features we can create new issues...\n. Block by #220\n. A small sneak peek https://www.youtube.com/watch?v=BmeTffguFio\n. It is far from being completed. The main technical challenge is that ideally, we want the Devtools UI to run in a process (in a chrome extension or in a Nodejs child process). Then we need to connect your app to the Devtools process so it can access the container instance and its bindings. \nThe problem is that memory cannot be shared. I started to think about serialization but it won't work because, for example, binding constraints are functions and they are not serializable.\nI'm sure that we can find a solution but I just don't have enough time to think about this at the moment :cry: because I'm writing a book about TypeScript. The project is not dead I plan to get back to it when I have time but if you want to help that would be awesome.\nThe actual UI is almost done (it is a Redux app) but the dependencies are very outdated.\n. This one is quite tricky to implement. The main problem is that you cannot share memory between de extension (Chrome) and the app. The extension needs to read the inversify container bindings but the only way is to serialize them. The problem is that the bindings contain functions and functions are not serializable. I have some ideas but not enough time to complete it right now :( Please feel free to work on it as a side project if you wish.. Hi, thanks a lot for your feedback.\n1. About number one, if you could help us to understand better the requirements and explain us how the API should look that could be a good starting point. I have plans to investigate support for other kinds of scope like webworker scope because in IoC containers like Ninject we have thread scope... so I totally understand why you are asking for this feature.\n2. This should be covered by inversify-binding-decorators.\n``` ts\nimport { injectable, Kernel } from \"inversify\";\nimport makeFluentProvideDecoratorfrom \"inversify-binding-decorators\";\nvar kernel = new Kernel();\nlet provide = makeFluentProvideDecorator(kernel);\nlet TYPE = {\n    IWeapon : \"IWeapon\"\n};\ninterface IWeapon {}\nlet provideSingleton = function(identifier) {\n    return provide(identifier)\n              .inSingletonScope()\n              .done();\n};\n@provideSingleton(TYPE.IWeapon)\nclass Shuriken implements IWeapon {\n    public hit() {\n        return \"hit!\";\n    }\n}\nlet shuriken = kernel.get(TYPE.IWeapon);\n``\n. About being able to use@singleton` without doing:\nlet provideSingleton = function(identifier) {\n    return provide(identifier)\n              .inSingletonScope()\n              .done();\n};\nIt is not possible right now and it would require a significant change in the architecture of the library so it is less likely that it will happen. It is not a big deal because you can copy paste the above code snippet and use it as @provideSingleton(serviceIdentifier).\nI can imagine request and session scope becoming available at some point. I will try to think about possibles ways to implement this...\n. Thanks a lot for those links It will help me a lot during analysis \ud83d\udc4d \n. @ktersius at the moment this is not possible because we don't support child kernels or custom scopes kike session or request scope yet. But both features are in our road map. Child kernel us 100% duable and you can be sure we will implement it custom scopes is a complex feature and need more analysis before I can't promise anything just yet. I will use this issue to keep you updated.\n. I'm closing this issue because we added support for inRequestScope. No plans for inSessionScope for now but I will think about it. About decorators for scopes it is currently possible via inversify-binding-decorators.. Hi, we renamed toValue a couple of releases ago. It is now called toConstantValue\nWe need to update our website but the docs on GitHub should be up to date.\nCan you please try with the following?\nts\ncontainer.bind('base-api-address').toConstantValue('http://localhost:5000/api/');\n. I will try to fix the docs ASAP. Can you please let me know which inversify.d.ts file are you using? Is it the inversify-dts one? In beta.6 we have done some changes to the installation process.\n. I have updated the GitHub docs. Can you please confirm that the type definitions included in https://www.npmjs.com/package/inversify-dts work for you?\n. You are importing bluebird.d.ts but inversify already imports bluebird for you. Try to remove bluebird from you typings.json and typings/index.d.ts Also, if you are importing harmony-proxy you will have the same problem with it.\n. Your comments have helped me to spot an issue I have documented it here. I will fix it as soon as I can. Thanks a lot for asking for help this is the only way we can improve the library.\n. We have published a new version of inversify-dts. Is everything working for you now?\n. Thanks, I don't think we will be able to do that because inversidy-dts constains definitions for all our projects and inversify is only one of the projects. This means that there will be many more releases of inversidy-dts than inversify. I'm sorry for all this .d.ts mess but we are just waiting for TypeScript 2.0 to be relased as it will include a new a better way to distribute .d.ts files.\nAbout the duplicated identifiers issue I believe we have to do more work so I have created another issue #231 and I'm going to close this one.\n. Done by https://github.com/inversify/dts/commit/e43f159eea5d9c7bf805ee644da8f0bb7c87c121\n. Thanks a lot \ud83d\udc4d \n. Hi james! can this be removed https://github.com/inversify/InversifyJS/blob/master/.travis.yml#L12 ?\n. This should be fixed now thanks to an AWESOME npm module. Thanks for reporting the issue!\n. @Jameskmonger thanks for that!\n. Thanks for reporting :+1: this has been fixed by df898a7778bc7a2d714f9ee065bb025e781f02c8\n. Thanks :+1: \n. The problem for me is that vscode shows all the JS files in the project explorer and it creates a lot of noise. If the file is not creating any issues in other IDEs I would like to keep it as it helps me. The TypeScript guys do it as well.\n. Are you targeting ES6? When targeting ES5 I need to manually install bluebird or Promise type is not found...\n. I have released inversify-dts@1.0.3 this issue should be fixed now. Sometimes it is required to manually install typings but no duplicated typings errors should take place...\n. No worries... I will document that. If using node.d.ts no need for bluebird but if you are working on a browser app you do need it.\n. Thanks for reporting I'm working on this now...\n. Hi I have roll back that commit and beta.8 has been released can you please try it?\n. Another note the .d.ts files in the inversify-dts project have been updated. Before if a third party library was required (e.g. bluebird) it was included. If the users had already included this library they would get a duplicated type identifier error. To solve this problem we don't include them anymore but we do require the users to install them manually.\n. Hi @FGRibreau was this problem solved for you? Can I close the issue?\n. This is now live http://inversify.io/\n. Merged #236\n. I'm closing this as it will be improved once async/await is supported when targeting es5...\n. I will try to document it better in the future (my priority right now is the 2.0 release candidate) but for the moment you can refer to some of my blog posts:\n- The current state of dependency inversion in JavaScript\n- About object-oriented design and the \u201cclass\u201d & \u201cextends\u201d keywords in TypeScript / ES6\nIoC containers is somehow controversial and not everyone feels like it is something that they need. If you feel like you need an IoC container then I would like InversifyJS to be the best but if you don't want too use it that is cool too. My personal point of view is that if you code using an OOP style InversifyJS will help. If you are using a FP style then you probably don't need it.\n. Thanks! I have plans to create page about \"motivation\" in the wiki. I will add the links there :)\n. Hi @codyjs sorry for the late reply I was on holidays...\nWhat you have done is fine but there are other ways to do this using metadata.\n``` ts\nkernel.bind(\"IController\").to(FooController).whenTargetNamed(\"foo\");\nkernel.bind(\"IController\").to(BarController).whenTargetNamed(\"bar\");\n@injectable()\nclass SomeClass {\n    constructor(@multiInject(\"IController\") ) {\n       this._controllers = controllers;\n    }\n}\nclass AnpotherClass {\n    constructor(\n        @inject(\"IController\") @named(\"foo\") fooController,\n        @inject(\"IController\") @named(\"bar\") barController\n     ) {\n       this._fooCntroller= fooController;\n       this._barCntroller= fooController\n    }\n}\n```\nUsing metadata is probably better because you the interface identifier IController not the class identifier FooController and depending upon an abstraction is better then deepening upon a concretion,\nPlease close this issue if you don't need more help :)\n. Hi @codyjs I have granted you pushing permissions for this repo. This should help you to contribute and merge PR from others.\nI will use the express Dev utils soon in one of my projects and I will collaborate them. At the moment all my time its being consumed by the chrome devtools but I'm nearly done :smile_cat: I will ask you for help in the future because maybe is possible to enable the DevTools for Node.js using a child process...\n. Hi @codyjs can this issue be closed now that we have released the latest version?\n. Thanks!\n. I also come from a Java and C# background and I believe that using I prefix is a good thing. Just like using _ prefix for the private members of a class. I'm aware of the TypeScript recommendation to avoid the I prefix. \nI like InversifyJS to be driven by the community not by myself so I have created a survey that you will be able to find here. \nI will leave this issue open for some time and see what our users think...\nPlease participate in the survey.\n. I've been doing some reading online and everyone in the TypeScript team seems very sure about the idea of not using I prefix. I understand that because most of the people with a Java/C# background (like me) like more the I prefix but I have removed it from the code. \nI was thinking about this over the weekend and really is not a big dial because you can still develop your application using the I prefix and the libraries normally don't use this convention (e.g. node.d.ts). The only interfaces that are affected by this are the internal inversify interfaces like IKernel, IContext, IRequest etc. now they are named IKernel, IContext, IRequest. \nThis will be merged as soon as I get the new inversify.d.ts ready and released as beta.9 once #247 is fixed.\n. I can add something that would be fast to tell if a symbol/identifier has been registered. But not if it can be resolved. What I mean is that maybe resolving causes an exception (e.g. ambiguous binding) the only way to tell this or tell what it will resolve to is to actually resolve it. The problem is that resolving it would be much slower than checking if it is registered so it makes no sense to check if can be resolved when checking and resolving are the same thing. So I suggest we only check if it it registered but avoid resolving it. Would that be OK?\n. This is now implemented but not released yet. \n. I've been thinking about this over the weekend and the best solution that I have found is to restrict the number of constructor arguments in a derived class to be > than the number of constructor arguments of its base class.\nWe have the following cases (being length  the number of constructor arguments):\n- A) Base.length > Derived.length (potential non-detectable error)\n- B) Base.length === Derived.length (no potential errors)\n- C) Base.length < Derived.length (no potential errors)\nThis issue is related with case A:\n``` ts\n@injectable()\nclass Warrior {\n    public rank: string;\n    public constructor(rank: string) { // length = 1\n        this.rank = rank;\n    }\n}\n@injectable()\nclass SamuraiMaster extends Warrior  {\n    public constructor() { // length = 0\n       super(\"master\");\n    }\n}\n```\nThe code snippet above throw a misleading error:\n\nError: Derived class must explicitly declare its constructor: SamuraiMaster\n\nWe try to provide developers with useful feedback like:\n\nMissing required @injectable annotation in: SamuraiMaster\n\nThis works fine in most cases but it causes some problem when using inheritance. In order to overcome this issues we need to restrict the usage of inheritance.\n\nThe number of constructor arguments in a derived class MUST be >= than the number of constructor arguments of its base class.\n\nThe users have a few ways to overcome this limitation  available. These will be documented in the wiki:\nWORKAROUND A) Property setter\nYou can use the public, protected or private access modifier and a property setter:\n``` ts\n@injectable()\nclass Warrior {\n    protected rank: string;\n    public constructor() { // length = 0\n        this.rank = null;\n    }\n}\n@injectable()\nclass SamuraiMaster extends Warrior {\n    public constructor() { // length = 0\n       super();\n       this.rank = \"master\";\n    }\n}\n```\nWORKAROUND B) Property injection\n``` ts\n@injectable()\nclass Warrior {\n    protected rank: string;\n    public constructor() { // length = 0\n        this.rank = null;\n    }\n}\nlet TYPES = { Rank: \"Rank\" };\n@injectable()\nclass SamuraiMaster extends Warrior  {\n@injectNamed(TYPES.Rank, \"master\")\n@named(\"master\")\nprotected rank: string;\n\npublic constructor() { // length = 0\n   super();\n}\n\n}\nkernel.bind(TYPES.Rank)\n      .toConstantValue(\"master\")\n      .whenTargetNamed(\"master\");\n```\nWORKAROUND C) Inject into the derived class\n``` ts\n@injectable()\nclass Warrior {\n    protected rank: string;\n    public constructor(rank: string) { // length = 1\n        this.rank = rank;\n    }\n}\nlet TYPES = { Rank: \"Rank\" };\n@injectable()\nclass SamuraiMaster extends Warrior  {\n    public constructor(\n        @inject(TYPES.Rank) @named(\"master\") rank: string\n    ) { // length = 1\n       super(rank);\n    }\n}\nkernel.bind(TYPES.Rank)\n      .toConstantValue(\"master\")\n      .whenTargetNamed(\"master\");\n```\nThe following should also work:\n``` ts\n@injectable()\nclass Warrior {\n    protected rank: string;\n    public constructor(rank: string) { // length = 1\n        this.rank = rank;\n    }\n}\ninterface Weapon {\n    name: string;\n}\n@injectable()\nclass Katana implements Weapon {\n    public name: string;\n    public constructor() {\n        this.name = \"Katana\";\n    }\n}\nlet TYPES = { \n    Rank: \"Rank\",\n    Weapon: \"Weapon\"\n};\n@injectable()\nclass SamuraiMaster extends Warrior  {\n    public weapon: Weapon;\n    public constructor(\n        @inject(TYPES.Rank) @named(\"master\") rank: string,\n        @inject(TYPES.Weapon) weapon: Weapon\n    ) { // length = 2\n       super(rank);\n       this.weapon = weapon;\n    }\n}\nkernel.bind(TYPES.Weapon).to(Katana);\nkernel.bind(TYPES.Rank)\n      .toConstantValue(\"master\")\n      .whenTargetNamed(\"master\");\n```\nSo i'm going to implement the restriction and document this on the wiki. I'm hoping to get this issue resolved this week.\n. I'be been doing some analysis on this and it is better to wait for now until TypeScript 2.0 becomes stable.\n. Thanks for letting me know I have updated the description :)\n. I'm closing this issue because I changed my original plans... You can learn more about the proposed alternative at https://github.com/inversify/InversifyJS/issues/404\n. gulp-header release is broken https://github.com/tracker1/gulp-header/issues/37\n. I'm sorry but we can't use typings like angular does for a few reasons you can find more at https://github.com/inversify/InversifyJS/issues/186\n. Thanks a lot for the PR but I won't be able to merge. Sorry if the current installation process is not as easy as one would expect but we are working on the new .d.ts distribution system. This means that typings will not be required in the future. This is why we started using inversify-dts. I hope this doesn't put you off contributing in the future.\n. @Offirmo thanks! We are right now block by https://github.com/DefinitelyTyped/DefinitelyTyped/pull/10998 and the TypeScript 2.0 release but it should be here soon :smile: \n. InversifyJS is now ready for a new release RC.14 :tada: after that I have to migrate all side projects to TypeScript 2.0. At that point, RC.14 will be promoted to 2.0 stable.\n. \n\ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 \nThanks a lot guys for all the work during all this months!\n. Thanks for reporting will try to fix this ASAP.\n. Hi @carbosound1 I just rleased beta.10 please let me know if it works for you.\n. Thanks to you for using it :)\n. When you say a module are you talking about an ES6 module or an npm module? Does RouteBuilder extend a class? Can I find the full source code on github? Thanks\n. I'm not fully sure but my guess is the following... \nI'm assuming that you have 2 npm modules.\nThe @injectable() annotation uses Reflect.defineMetadata under the hood. The Reflect object is mean to be a global. \nIf you are using multiple npm modules maybe what is happening is that you have 2 instances of Reflect (one per module):\n- In one module you create some metadata using Reflect.defineMetadata via @injectable()\n- In the second module, you try to read the metadata using Reflect.getMetadata via kernel.get(). \nThe problem is that if there are two Reflect objects the second will fail. I have never encounter this problem so it would be great if you could debug and find it.\nInvoking the following:\nts\nReflect.getMetadata(\"inversify:paramtypes\", RouteBuilder);\nShould return an empty array in both npm modules. The solution to this problem would be to ensure that Reflect is accessed as a singleton global.\n. When it returns undefined is because a new instance of Reflect has been imported and it doesn't contain the metadata from the first instance.\nIf you are going to distribute the npm modules as librarires then they shouldn't import reflect-metadata, \nYou need to remove the following from your code:\nts\nimport \"reflect-metadata\";\nThis line should be be used only once by the consumers.\nThe consumers are the ones that need to import it. For example, InversifyJS uses Reflect but you as a consumer need to import it.\nWe do import reflect when we run the unit test because the unit test can be considered as a consumer.\n. No problem. Can this issue be closed then?\n. @tenowg can you please confirm if this issue be closed? Thanks!\n. No problem :) Feel free to create issues instead of using the chat if you have any questions. Issues can help other users and at the moment we don't get a crazy number of issues. If it scales to too many issues per day we will change the rules but for the moment is fine to create issues \ud83d\ude09 \n. Hi, thanks for reporting. I started working on this yesterday but is not ready. I'm working on this fork.\n. This example has not been updated for some time :( My main goal right now is to finish the 2.0.0 release. I will then focus on all the side projects and the examples. You can try to help with this but I would recommend you to wait until https://github.com/inversify/InversifyJS/issues/256 is completed to avoid re-doing work.\n. Great :+1:  My plan is to release inversify-express-utils@1.0.0-beta.1 and inversify-dts@1.0.7 before Monday.\n. I just finished it https://github.com/inversify/inversify-express-utils/pull/4 I also need to update https://github.com/inversify/inversify-dts and release both. I just created https://github.com/inversify/inversify-express-example maybe you can start by moving the code to that repo?\n. This issue can now be closed right? If you want more examples we can create new issues for each example?\n. I just created the repos:\n- https://github.com/inversify/inversify-express-example\n- https://github.com/inversify/inversify-binding-decorators-example\n- https://github.com/inversify/inversify-marionette-example\n- https://github.com/inversify/inversify-hapi-example\nIf someone can help to migrate the examples to individual repositories that would be great.\n. I will crate some issues of stuff that needs to be done. Here is the first one:\n- Refactor examples: split the inversify-code-samples into multiple projects\n. I have migrated each example to its new repo now we need to get done the following:\n- [x] Update dependencies inversify-express-example\n- [x] Add CI checks inversify-express-example\n- [x] Enable greenkeeper for inversify-express-example\n- [ ] Update dependencies inversify-binding-decorators-example\n- [ ] Add CI checks inversify-binding-decorators-example\n- [ ] Enable greenkeeper for inversify-binding-decorators-example\n- [ ] Update dependencies inversify-marionette-example\n- [ ] Add CI checks inversify-marionette-example\n- [ ] Enable greenkeeper for inversify-marionette-example\n- [ ] Update dependencies inversify-hapi-example\n- [ ] Add CI checks inversify-hapi-example\n- [ ] Enable greenkeeper for inversify-hapi-example\nI will work on this once I release the devtools. If someone want to help PRs are more than welcome!\nThanks :four_leaf_clover:\n. :+1:  that also on my list. I will enable the builds on travis appveyor and greenkeeper :smile: \n. I'm closing this remaining actions can be tracked by #306\n. Hi thanks for reporting. I will investigate and try to fix this ASAP. \n. Hi, I'm trying to reproduce this issue in our unit test. I'm using the following test:\n``` ts\n    it(\"Trying to reproduce issue #266\", () => {\n    const kernel = new Kernel();\n    let pInject = makePropertyInjectDecorator(kernel);\n\n    let symbols = {\n        IC: Symbol(\"IC\")\n    };\n\n    class A {\n        public b: B;\n\n        constructor() {\n            this.b = new B(\"test\");\n        }\n    };\n\n    class B {\n\n        public name: string;\n\n        @pInject(symbols.IC)\n        public c: IC;\n\n        constructor(name: string) {\n            this.name = name;\n        }\n\n    };\n\n    interface IC {\n        test: string;\n        getName(name: string): string;\n    }\n\n    @injectable()\n    class C implements IC {\n        public test: string;\n\n        constructor() {\n            this.test = \"this is a test property\";\n        }\n\n        public getName(name: string): string {\n            return \"this is the getName function \" + name;\n        }\n    }\n\n    kernel.bind<IC>(symbols.IC).to(C);\n    let a = new A();\n    expect(a.b).not.eql(undefined);\n    expect(a.b.name).eql(\"test\");\n    expect(a.b.c.getName(a.b.name)).eql(\"this is the getName function \" + a.b.name);\n\n});\n\n```\nThe test is working so I'm almost sure that your problem is the same as #262. You are importing reflect-metadata multiple times.\n- import 1\n- import 2\nAs I explained in #262:\n\nYou need to remove the following from your code:\n\nts\nimport \"reflect-metadata\";\n\nThis line should be be used only once by the consumers.\nThe consumers are the ones that need to import it. For example, InversifyJS uses Reflect but you as a consumer need to import it.\nWe do import reflect when we run the unit test because the unit test can be considered as a consumer.\n\nSo you need to change your code to import \"reflect-metadata\" only once in your whole application.\n. No problem :smile: happy to help.\n. Hi thanks a lot for reporting this issue. I've been able to fix it and it is now merged into master. It will be included in the next release.\n. Hi guys, thanks for all the work! I merged https://github.com/inversify/inversify-dts/pull/5 and released inversify-dts@1.0.8 please let me know if this issue can be closed. \n. This is now completed.\n. Done by https://github.com/inversify/InversifyJS/pull/273\n. .d.ts update can be found at https://github.com/inversify/inversify-dts/pull/6\n. I have released inversify-express-utils@1.0.0-rc.1 \ud83c\udf89 \n. You could try something like the following in the framework:\n``` ts\nfunction getHttpServer(kernel: inversify.interfaces.Kernel) {\nlet pInject = makePropertyInjectDecorator(kernel);\n\n@injectable()\nclass HttpServer {\n\n    @pInject(\"HttpConfig\")\n    public httpConfig: HttpConfig;\n\n}\n\nreturn HttpServer;\n}\n```\nAnd then users would be able to do:\n``` ts\nimport {getHttpServer} from \"framework\";\nimport {Kernel} from \"inversify\";\nlet kernel = new Kernel();\nlet HttpServer = getHttpServer(Kernel);\nkernel.bind(\"HttpConfig\").toValue({\"port\": 8080});\nkernel.bind(\"HttpServer\").to(HttpServer);\n```\nWe adde property injection support because it was needed in some cases (e.g working with React) but if you could you should avoid it. I learned almost everything I know about DI and IoC in the book Dependency Injection in .NET and I remember that the author recommended to use constructor injection always as first option.\nI've been also able to find some reasons at SO:\n\nIf the class cannot do its job without the dependency, then add it to the constructor. The class needs the new dependency, so you want your change to break things. Also, creating a class that is not fully initialized (\"two-step construction\") is an anti-pattern (IMHO). If the class can work without the dependency, a setter is fine.\n\nPlease let me know if you have more questions or if this issue can be closed.\n. No problem. I have added some notes here so I'm closing this issue now.\n. Done by https://github.com/inversify/InversifyJS/pull/277\n. It fails in nodejs_version=0.1.2 because:\n\nInstall-Product node $env:nodejs_version\nnode  x86 package not found\n. :+1: thanks a lot for the PR!\n. Thanks for letting me know I will fix it ASAP :)\n. I think is a good ideal. Will work on this after the 2.0 release :)\n. @tenowg 2.0.0 has been released expect this coming soon!\n. I though this was going to be a small thing but it is turning out to be quite complex :sob: I'm nearly done but it introduces some breaking changes so it will be released as 3.0.0. It took forever to release 2.0.0 and only one week to release 3.0.0 :smile: \n. Good news :tada: https://github.com/inversify/InversifyJS/pull/392\n. Default target will be available in 3.0.0 docs available at https://github.com/inversify/InversifyJS/blob/master/wiki/default_targets.md\n. I see a different problem here and here.\n. :+1: \n. Thanks for reporting :) This will be fixed for the 2.0.0 release.\n. This was done https://github.com/inversify/InversifyJS/pull/282\n. This is the error that I was expecting to happen based on the docs:\nThe reflect-metadata polyfill should be imported only once in your entire application because the Reflect object is mean to be a global singleton.\n\nThis issue was reported here the problem is the usage of multiple import 'reflect-metadata' but yesterday I tried to remove them and it didn't work.\nI think we need to remove all the import 'reflect-metadata' and leave only the ones in the bootstrap files. The problem them will happen when you run your unit tests. All the tests (in one application) need to run in the same process.\n. I have plans to try to solve the reflect-metadata issue but is not that easy because we need a a browser and a node.js version. \nThere is more details at https://github.com/inversify/InversifyJS/blob/master/wiki/module_bundlers.md\n. I'm happy to use npm script only but if the build is complex I find gulp easier to deal with.\n. Fix merged \ud83c\udf89 \n. I will not merge this I've been trying and even angular 2.0 avoid including reflect-metadata. You can see that it is imported only once as a global I know it is a pain to deal with. I will work on improving the docs as much as I can bit not change the way it is imported.\n. Closing this as well it can be followed at https://github.com/CitadelJS/core/issues/\n. I don't think we can provide authorize as a framework element but you can implement your own, here is an example https://github.com/stelltec/public-tech-demos/blob/master/nodejs-madrid-meetup/demo3/src/ui/rest_api/controllers/secure_controller.ts#L8. \ud83d\udc4d Thanks!\n. I think ORM is out of the scope. We should be compatible with ORMs but nothing beyond that.\n- Routing \ud83d\udc4d \n- Authorisation \ud83d\udc4d \n- Authentication \ud83d\udc4d \n- Dependency Injection \ud83d\udc4d \n- Custom Middleware \ud83d\udc4d \nWe can provide the users with default implementations of these features for example we can provide with a default implementation of Authorisation using passport but the users should be able to register their own implementations.\n- Pluggability \ud83d\udc4d  \nBased on ASP.net core this is the Built-in middleware that they offer:\n\n- Validation \ud83d\udc4d sounds like another nice idea.\n. I would like to also suggest response caching support:\n[ResponseCache(Location = ResponseCacheLocation.None, NoStore = true)]\npublic IActionResult Error()\n{\n  return View();\n}\nAnd make as easy as possible working with multiple environments (dev, prod, uat...)\n. :+1: to:\n\nI would say that we should still provide direct access to request and response objects, because sometimes syntactic sugar isn't enough to cover all cases.\n\nand \n\nI would argue though that we have own request & response objects, that via adapters, get connected to the host http framework like express/koa/hapi etc.\n\nI think we need an npm module for the framework and an npm module for each of the adapters so we can do something like:\n$ npm install framework framework-express\n$ npm install framework framework-koa\nAnd people will be able to extend it...\n\nshould create an extra repo for it and we should define some issues.\n\nI'm open to suggestions we can work on the inversify-express-utils repo or create a new repo... if we create a new repo we need a name!\nAnother suggestion that I would like to do is to use asp.net core as a reference. It can help us a lot for example I used ninject and angular 2 while developing inversify and having a reference was really useful.\n. Yes Inversify is related with \"inversion of control\". We could relate it somehow with the SOLID principles. \nSometimes I use a word translated to another language. For example SOLID in Japanese is kotai that sounds cool to me: kotai.js. \nOr maybe because we allow people to replace one framework express with other like koa that is the Liskov substitution principle so maybe Liskov it would be a tribute to Barbara Liskov.\nOne more suggestion Martin.js as a tribute to Robert Cecil Martin for his relation with the \"Dependency inversion principle\".\n\nnpm install @framework/core @framework/express @framework/authorization @framework/validation\n\nThe best solution is to create a new GitHub organization in that case.\n. The name of a star could be cool! feel free to suggest some :)\n. Closing this we can follow the conversation at https://github.com/CitadelJS/core/issues \ud83d\ude04 \n. @amir-arad if you want a fully featured framework nest is the solution if you want more freedom of choice then you can use inversify-express-utils. I will be soon experimenting and trying to finish https://github.com/ZafiroJS which will be an alternative to nest but it is going to take several months due to my lack of free time . Solved by migrating to https://codeclimate.com\n. Hi thanks for the PR I'm on holidays and I don't have my laptop with me so I won't be able to review it until I get back next week.\n. Thanks a lot for the PR. I removed the method because it was the default but I guess it is OK to keep it available.\n. You can invoke the decorator using the decorate function:\nimport { decorate, injectable } from \"inversify\";\ndecorate(injectable(), ClassName)\nCheck out https://github.com/inversify/InversifyJS/blob/master/wiki/basic_js_example.md for more info.\n. > Maybe the decorate function could also be mentioned in another part of the documentation.\nI will do something to improve this.\nAbout your problem I think option 1 is better. I would recommend to use option one and inject the config as a constant value:\nts\nkernel.bind<any>(\"config\").toConstantValue({ objectMode: true });\nI will also try to think more about it and see If I add a better solution to the docs.\n. Hi @lukas-zech-software the next release will include a new workaround for your issue https://github.com/inversify/InversifyJS/pull/333\n. We moved the interfaces under the interfaces namespace because we decided to remove the I prefix from all interfaces:\nts\nimport { Kernel } from \"inversify\"; // is Kernel the class or the interface?\nBy doing the following we can solve the naming collision:\nts\nimport { interfaces, Kernel } from \"inversify\"; // is Kernel the class or the interface?\nlet kernel: interfaces.Kernel = new Kernel();\n. Hi @Jameskmonger can this be closed? Do you have any ideas about how to improve this without introducing I prefix?\n. I also like the I prefix but it is not recommended in TypeScript. I researched multiple issues and all the developers seems to agree:\n- https://github.com/Azure/autorest/issues/498\n- https://github.com/Microsoft/TypeScript-Handbook/issues/121\nAnd it has recently been added as a TsLint rule. I understand that:\nts\nimport { Kernel, IKernel } from 'inversify';\nlet kernel: IKernel = new Kernel();\nIs nice but is breaking the recommended style guides. \nThe current solution:\nts\nimport { Kernel, interfaces } from 'inversify';\nlet kernel: interfaces.Kernel = new Kernel();\nRequires just one extra word and it allow us to follow the style guide.\n. Thanks!\n. The issues in IE are caused because Function.name is not an standard in JS versions < ES6.\nThe good news is that function name is only used to provide developer-friendly errors and it will be fine to use the following:\n```\nfunction getFunctionName(f) {\n    return f.name ?  f.name : f.toString().match(/^function\\s*([^\\s(]+)/)[1];\n}\nlet constructorName = getFunctionName(func);\n```\nBeyond this issue we need to prevent issues in browsers and to do so we need to run the tests on a web browser.\n. The function.name issue was fixed #302  by but it has not been released yet.\n. Hi @endel,\nBased on your feedback I have impelmented browser testing:\nSTART:\n31 07 2016 09:39:38.721:INFO [karma]: Karma v1.1.2 server started at http://localhost:9876/\n31 07 2016 09:39:38.736:INFO [launcher]: Launching browsers Firefox, Chrome, IE with unlimited concurrency\n31 07 2016 09:39:38.736:INFO [launcher]: Starting browser Firefox\n31 07 2016 09:39:38.814:INFO [launcher]: Starting browser Chrome\n31 07 2016 09:39:38.861:INFO [launcher]: Starting browser IE\n31 07 2016 09:39:41.468:INFO [IE 11.0.0 (Windows 8.1 0.0.0)]: Connected on socket /#WnT7WRE6ip9Zi6wjAAAA with id 55234899\n31 07 2016 09:39:42.966:INFO [Chrome 51.0.2704 (Windows 8.1 0.0.0)]: Connected on socket /#mU6ZwPr-SmIQDas4AAAB with id 13681852\n31 07 2016 09:39:43.726:INFO [Firefox 47.0.0 (Windows 8.1 0.0.0)]: Connected on socket /#E4TyJvgr6NEtzvmvAAAC with id 63667869\n// ...\nFinished in 0.21 secs / 0.185 secs\nSUMMARY:\n\u221a 133 tests completed\n\u00d7 2 tests failed\nFAILED TESTS:\n  InversifyJS\n    \u00d7 Should support the injection of providers\n      IE 11.0.0 (Windows 8.1 0.0.0)\n    ReferenceError: 'Promise' is undefined\n       at Anonymous function (temp/bundle.test.js:10711:17)\n       at Anonymous function (temp/bundle.test.js:10718:9)\n    \u00d7 Should be able to identify missing @injectable in a base class\n      IE 11.0.0 (Windows 8.1 0.0.0)\n    expected [Function: throws] to throw error including 'Missing required @injectable annotation in: Samurai' but got 'Missing required @injectable annotation in: undefined.'\n    Error\nIt is almost ready, all the integration tests are running on the latest version of IE, Chrome and Firefox on AppVeyor. \nThere two test failing on IE 11 once I get those two sorted I will merge and close the issue.\nThere might be problems in IE < 11 but I asume that everything can be fixed using polyfills.\n. Done by #316\n. Done by #302\n. Hi @endel,\nWe try to provide developers with useful errors like Missing @injectable annotation in class X or Missing @inject annotation in argument Y in class X however we noticed a case in which the library was failing without errors.  \nDue to technical limitation we had to reach a compromise. We had to choose only one of the following options:\n- Not required  the declaration of constructors in derived classes and be unable to prevent silent errors that would lead developers to very confusing scenarios.\n- Require the declaration of constructors in derived classes and matching number of arguments to prevent silent errors.\nI decided that silent errors is much worst than enforcing the declaration of constructors. I'm sorry if it is not great at the moment.  I have recieved this feedback before and it is something I'm personally not happy about. The problem is caused mainly by non-standard behavior in versions of node so I believe that we will be able to improve this in the future but is something that we can't do at the moment.\n. Hi @otbe sorry for the following really long comment! I've been thinking about ways to use property injection in an npm module that is not aware of the InversifyJS kernel. Here are my thoughts:\nThe proposed solution doesn't feel right\nAbout you proposed solution:\nts\nmasterKernel.load(subKernel);\nThis solution doesn't feel right for me. The parent (masterKernel) would be able to load all the bindings from the child (subkernel). \nHowever, we would have a few problems:\n- We wouldn't be able to unload them.\n- The @inject property decorator would not be able to access the masterKernel.\nSo I've been thinking about other solutions and the bad news is that all my options are quite big breaking changes.  This means that I will not be able to add this to the 2.0 release.\nUsing global variables as a temporal fix?\nAt the moment your problem is that you have the following:\n- Module A) Declares a singleton kernel instance and the @inject property decorator and it is the composition root\n- Module B) Standalone but requires @inject property decorator\nAs you know this creates a circular dependency:\nA --> B\nB --> A\nThe solution with the current implementation would be to create an additional module so you will have:\n- Module A) Declares a singleton kernel instance and the @inject property decorator as global variables\n- Module B) Standalone but consumes the global variables declared by A\n- Module C) It is the composition root and consumes B and consumes the global variables declared by A\nB --> A\nC --> B\nC --> A\nChild kernels (2.1) will allow you to remove the globals in the future\nAfter the 2.0 release. I will work on the support for child kernels. The child kernel system is going to behave as a  hierarchical dependency injection system. This means that the bindings of the parent kernel are only accessed when no bindings are found in the child kernel.\nOnce this feature is added you could declare a kernel in each module. Then, in your core module you could create the master parent and import each of the child kernels:\nts\nsubKernel.setParent(masterKernel);\nWhich is not far from:\nts\nmasterKernel.load(subKernel);\nThe main difference is that there is hierarchical structure but it should be able to fix your problem.\nShould we re-write the property inject feature in the future?\nThe current implementation:\n- The property inject decorator calls the kernel under the hood.\n- The property getter is replaced by the decorator when the class is DECLARED. \n- The property is then lazy initialized when it is accessed for the first time.\nThe new implementation:\n- The property inject decorator will NOT call the kernel and will generate metadata instead.\n- The property getter is replaced by the decorator when the class is RESOLVED.\n- The property is then lazy initialized when it is accessed for the first time.\nI see a few potential problems: \n- More complex resolution (especially when working with inheritance).\n- Additional step when resolving a dependency (check for property metadata) may affect performance.\n- Only classes that are resolved will get injected properties\n```\n@injectable()\nclass Ninja {\n  @inject()\n  public weapon: Weapon;\n}\nlet ninja1 = kernel.get(\"Ninja\");\nninja1.weapon.name === \"Shuriken\"; // true (weapon was injected)\nlet ninja2 = new Ninja();\nninja2.weapon.name === \"Shuriken\"; \n// false (weapon was NOI injected because ninja2 was not resolved)\n```\nThis re-write is a breaking change and we are probably talking about InversifyJS 3.0.\n. Hi @endel I'm still working on 2.0 but help would be much appreciated.\nThe child kernel feature requirements are very clear and has been documented at #307 PRs for this feature are welcome!\nFor the new implementation I would like to wait until we get more feedback about the potential problems:\n\nI see a few potential problems:\n- More complex resolution (especially when working with inheritance).\n- Additional step when resolving a dependency (check for property metadata) may affect performance.\n- Only classes that are resolved will get injected properties.\n\nSo please let me think a bit more about the new implementation. I will create an issue and let you know when it's ready :)\nThanks a lot for helping out!\n. I'm closing this as we now have: \n307 to follow the implementation progress  of child kernel support\n310 to talk about property injection\n. Thanks a lot for fixing this issue \ud83d\udc4d \n. Hi @lukas-zech-software sounds like a good idea to me :smile: I will be happy to merge a PR!\n. Hi @lukas-zech-software I would like to include this in the 2.0 release. Are you planing to send a PR please let me know and I will implement it if you don't have time. Thanks!\n. Hi @lholznagel Thanks a lot for helping me out :clap: I will enable greenkeeper and travis for you this evening :smile: \n. @lholznagel the marionette is very very old and may require to be rewrite... (it uses requirejs for exmaple) maybe start by with the hapi example and we can think if we really want to keep the marionette example alive...\nThe idea is that I wanted at least one example of a front-end application but maybe makes more sense to create a React + Mobx example and remove the marionette example.\n. I'm closing this issue. We can use https://github.com/inversify/InversifyJS/issues/435 instead. Hi @endel I have invited you to the organization I will assign this issue to you once you join it :smile: \n. Done by #318\n. Hi thanks for reporting, the words warrior and ninja are used in many places can you please let me know the section in which you found the issue? Thank!\n. Sorry I just saw it. You send the PR to your fork Robotregent/InversifyJS you need to send the PR to the inversify repo inversify/InversifyJS.\n. I have created and merged the PR #309 thanks a lot for fixing the typo!\n. > Only classes that are resolved will get injected properties\nThis is a major problem in React! React is a huge sector of potential users. The new implementation feels right but I don't feel like killing compatibility with react is a good idea. \nThe kernel child support will be an alternative solution (see \"Child kernels (2.1) will allow you to remove the globals in the future\" here) and will allow us to keep supporting react.\n. I think I have a solution. The current implementation of property injection should be moved to a new npm module \"inversify-inject-decorators\":\ninversify-inject-decorators\n``` ts\nimport makePropertyInjectDecorator from \"./makePropertyInjectDecorator\";\nimport makePropertyInjectNamedDecoratorfrom \"./makePropertyInjectNamedDecorator\";\nimport makePropertyInjectTaggedDecoratorfrom \"./makePropertyInjectTaggedDecorator\";\nimport makePropertyMultiInjectDecoratorfrom \"./makePropertyMultiInjectDecorator\";\nfunction getDecorators() {\nlet lazyInject = makePropertyInjectDecorator(Kernel);\nlet lazyInjectNamed = makePropertyInjectNamedDecorator(Kernel);\nlet lazyInjectTagged = makePropertyInjectTaggedDecorator(Kernel);\nlet lazyMultiInject = makePropertyMultiInjectDecorator(Kernel);\n\nreturn {\n    lazyInject ,\n   lazyInjectNamed,\n   lazyInjectNamed,\n   lazyMultiInject\n};\n\n}\nexport default getDecorators;\n```\n``` ts\nimport { getDecorators } from \"inversify-inject-decorators\";\nimport { Kernel } from \"inversify\";\nlet kernel = new Kernel();\nlet {\n   lazyInject ,\n   lazyInjectNamed,\n   lazyInjectNamed,\n   lazyMultiInject\n} = getDecorators(kernel );\n```\nThis implementation is useful for React and maybe other projects but I believe it should not be part of the core module.\nThen we can rewrite the current implementation of property injection. With the new implementation, only classes that are resolved will get injected properties. This means that it won't work with react but that will not be a problem because inversify-inject-decorators will be compatible with React.\n. The module inversify-inject-decorators has been released and the old implementation of the property injection has been removed by #337.\n. After #337 this is no longer a breaking change added minor label.\n. Hi @endel thanks for trying to help me. I don't think it will be easy to share work because it affects a lot of parts of the library and is not fully clear to me yet what needs to be done in detail. I know we are going to need a lot of unit tests but we are note ready for that either \ud83d\ude22 I will let you once I get to a more mature implementation. Thanks a lot for trying to help :)\n. Implemented by #350\n. Hi @endel, Thanks! at the end it was easier than expected. Properties are injected just after an instance iscreated and are NOT lazy evaluated.  Remember that if you want lazy evaluated you can use inversify-inject-decorators.\n. I think is a great idea :+1:  but for the API it would be easier to implement if we did something like:\nts\nkernel.bind(Something).toSelf();\nThe toSelf method should returnBindingInWhenOnSyntax so users can use the rest of the binding API:\nts\nkernel.bind(Something).toSelf().inSingletonScope();\nkernel.bind(Something).toSelf().whenTargetNamed(\"name\");\nkernel.bind(Something).toSelf().onActivation(() => { /* ... */ });\nAlso some users will be familiar with this because it is based on Ninject.\n. Closing this as it has been merged to master #312 :smiley: \n. Thanks a lot for the PR! great work :+1: \n. This PR requires changes in docs and dts files. I have implemented both the dts update at inversify/inversify-dts/pull/12 and docs update  at this commit.\n. This is now implemented https://github.com/inversify/inversify-inject-decorators\n. Done by #316\n. Removed node 0.12 because won't be supported in a couple of months and changed it for the main version used on AWS 4.4.6\n. Done\n. Hi @endel thanks a lot for the PR I won't have time to review it today. Maybe tonight but I'm not sure... I will test it and review it ASAP \u263a\n. Merged \ud83c\udf89 thanks a lot for the PR!\n. Great work \ud83d\udc4d thanks a lot for your contribution!\n. HI @endel thanks! I'm working on It I want to get auto-deployments to npm on build success + tag but I'm having some problems. You should see the new release at some point over the next couple of hours \ud83d\ude04 \n. 2.0.0-rc.5 should be released now :)\n. At the moment express-utils is very basic but maybe if it evolves we will have problems to also support restify. Also the fact that the npm module is called express utils makes me think that supporting also restify may be confusing. A lot of restify users could ignore this just because the name. I'm coping @codyjs because he is the author of the express-utils let's see what he thinks but maybe a new repo inversify-restify-utils would be better? \n. :+1:  new repo and new npm module\n. @rundef I can create a repo under the @inversify organization if you want? I will be able to help you with the DevOps stuff (Travis, npm releases, ...) and we will be able to monitor all the projects in one place.\n. Great, the repo is available at https://github.com/inversify/inversify-restify-utils I'm closing this issue but you can comment if you have any questions also you can find us on the gitter chat :)\n. Hi @rundef thanks a lot for your PR. I have configured the travis CI build and done the first npm release https://www.npmjs.com/package/inversify-restify-utils please let me know you experience any problems with it \ud83d\ude04\n. Hi @endel will try my best to not introduce the breaking change. I'm trying to find out why it is using the wrong target. Maybe the latest tsify release is broken...\n. Perfect \ud83c\udf89  Will upgrade to 1.0.3 them :)\n. Hi @otbe and @endel, since you asked me about this issue in the past I would appreciate your input on this. You can follow the progress here.\nThanks!\n. I have implemented this at https://github.com/inversify/InversifyJS/pull/333\n. Hi,\nThanks for your feedback. Our problem is that our type definitions have some third party dependencies this means that they contain triple-slash references and for that reason we can't use typings for npm.\nFrom the TS docs:\n\nYour definition files should\nbe.d.ts files\nbe written as external modules\nnot contain triple-slash references\n\nAbout why not using the auto-generated dts files... when we started the project there was no support for the auto-generation of the dts of UMD modules I think it will be possible in TS 2.0.\nWe have plans to fix these two issues with TypeScript 2.1 becomes available all our Promise based APIs will be migrated using async/await and we will then be able to remove third party dts from bluebird. If you think that you can helps us to improve this we would be happy to accept a PR.\n. Yes, bluebird is the only one.I think lib.es6.d.ts is applied when targeting ES6 but we target ES5.\n. Hi, I have submit a PR to DefinitelyTyped after it gets merged all the type definitions will be available via @types. This requires TypeScript 2.0 so the next step for us will be to tests all the modules using TypeScript 2.0. We will try to remove typings as well for third party dependencies and use @types instead. If everything goes well I will update the docs to document the new installation process. Once this is done I will finally release InversifyJS 2.0 :smile: \n. Hi guys I'm working on this and I have some problems.\nI'm trying to remove typings and use @types instead for our dev dependencies. I also removed bluebird and replaced with core-js (this is what the guys from Angular 2.0 are doing).\nI'm having the following problem:\n```\n$ gulp\n[01:06:44] Using gulpfile ~/CODE/forks/InversifyJS/gulpfile.js\n[01:06:44] Starting 'default'...\n[01:06:44] Starting 'build'...\n[01:06:44] Starting 'lint'...\n[01:06:55] Finished 'lint' after 11 s\n[01:06:55] Starting 'build-bundle-src'...\nevents.js:154\n      throw er; // Unhandled 'error' event\n      ^\nTypeScript error: \n/CODE/forks/InversifyJS/node_modules/@types/chai/index.d.ts(412,11)\nError TS2451: Cannot redeclare block-scoped variable 'Object'.\n```\nYou can see my changes here. I'm working on a fork.\nAny help would be much appreciated. \nThanks!\n. I'm just copying this link here so I can use it as a reference later... https://basarat.gitbooks.io/typescript/content/docs/types/lib.d.ts.html\n. Ok guys so I have good news. The npm module includes now the typings and they are auto-generated. The bad news is that I have to migrate all the other modules and they are not ready yet. There is a new issue to follow the progress on that so I'm closing this issue.\nAlso is interesting to mention that it was possible thanks to an option I wasn't aware. It allows you to target ES5 but use some ES6 features without external libraries. Check \"lib Option\" in https://basarat.gitbooks.io/typescript/content/docs/types/lib.d.ts.html to find out more.\n. @rundef 1.6.0 has now been released\n. Can you please let us know your version of node.js? We have unit tests for this feature and they are passing so maybe is a rare condition.... The link of the dependency graph is broken.\n. These are the versions of node that we test at the moment https://github.com/inversify/InversifyJS/blob/master/.travis.yml#L3-L9\n. Hi @djflex68 did using a different version of node solve your problem? If not, can you think about anything else that could help us to reproduce the issue? thanks!\n. Hi @djflex68 any updates on this issue? I will close the issue in a few days if no more help is required.\n. Thanks for letting me know. I will close this issue now.\n. Type definitions are now available https://github.com/inversify/inversify-dts/blob/master/inversify-inject-decorators/inversify-inject-decorators.d.ts\n. I tried to the code above in our unit tests and it works fine. The @inject decorator is not required when you use classes. The annotation is not required because the typescript compiler generates the metadata for us. However, for that to happen it is required to do two things:\n- import reflect-metadata\n- Set emitDecoratorMetadata to true in tsconfig.json.\nI will add a note about this in the docs. Please let me know if this issue can be closed.\n. Hi @johnfields were you able to solve the issue? Can this issue be closed? Thanks!\n. No problem :smile: \n. Hi @anthonyjlmorel I'm not 100% sure about being able to do that mostly because some browsers throws the stack overflow exception (caused by circular dependencies) in different points during the execution. But this is a nice suggestion so I will try to implement it.\n. Hi @anthonyjlmorel this has now been implemented by #353 I will try to release it tonight I'm closing this issue\n. Hi thanks for reporting I'm testing now I will let you know soon If I find out what it the problem. To highlight code you need to use: \n\n. Hi, I think I know what is the problem. The decorator @multiInject() is a parameter decorator not a property decorator. It can be used to decorate the arguments of a constructor but not the properties of a class.\nWe had support for @inject() and @multiInject() but we recently removed it to a separated repository.\nIf you apply @multiInject() to a property:\nts\n @multiInject(\"wheels\") private wheels: IWheel[];\nYou will get a compilation error but this is the expected behaviour.\nThis week we have started to work on a new implementation of property injection. So for the moment you can only use: \n- Constructor injection with inversify\n- Property injection (lazy evaluated) with inversify + inversify-inject-decorators\nBut in a few weeks you will be able to use:\n- Constructor injection with inversify\n- Property injection with inversify\n- Property injection (lazy evaluated) with inversify + inversify-inject-decorators\nYou can learn more details at the wiki.\n. Thanks! \nWe have two options:\nA) Using inversify property injection (Work in progress)\nts\nclass Vehicle implements IVehicle{\n    @multiInject(\"wheels\") public wheels: IWheel[];\n    constructor(@inject(\"engine\") public engine: IEngine){}\n}\nts\nlet car= kernel.get<Vehicle>(\"Vehicle\");\n// At this point both the engine and the wheels have already been injected\nB) Using inversify-inject-decorators lazy property injection\nclass Vehicle implements IVehicle{\n    @lazyMultiInject(\"wheels\") public wheels: IWheel[];\n    constructor(@lazyInject(\"engine\") public engine: IEngine){}\n}\nts\nlet car= kernel.get<Vehicle>(\"Vehicle\");\n// At this point only engine has already been injected\n// When we try to access the property is when it is injected\nconsole.log(car.wheels); // Wheels is injected when this line is executed\nKeep in mind that when working with OOP in JavaScript you can have two kinds of circular dependencies:\n- Circular dependencies in your JavaScript modules \n- Circular dependencies in your JavaScript classes\nIf you have circular dependencies in your JavaScript modules weird things will happen  (See an example). We can try to help with this kind of cases but there is not much we can do because it is purely based on your project organization. Some module loaders include features to fix circular dependencies in JS modules this is not the job of InversifyJS.\nIf you have a circular dependency in your JavaScript classes, InversifyJS will detect it and throw an exception so you can fix it.\nFeel free to ask any other questions :smile: \n. Hi @Jacks50 I don't see @multiInject in the code in your SO question? If you are binding 2 items to one identifier:\nts\ncontainer.bind<IX>(\"IX\").to(XA);\ncontainer.bind<IX>(\"IX\").to(XB);\nThe get method as container.get<IX>(\"IX\") will throw an error. If you want to resolve all you will need to use container.getAll<IX>(\"IX\") instead.\n. @Jacks50 you could bind it as a constant value:\nts\ncontainer.bind<IX>(\"IX\").toConstantValue(someVal);\n. Thanks!\n. There was a bug which prevented the following error to be displayed. The error is:\nts\nError: Ambiguous match found for serviceIdentifier: Intl\nRegistered bindings:\n Object - tagged: { key:lang, value: fr }\n Object - tagged: { key:lang, value: fr }\nI have created a PR that will be merged soon and I will do a release ASAP.\nWe don't have a feature at the moment to get multiple results with a tag. We need something like getAllTagged and getAllNamed I'm going to take note and this is something that could be implemented in the future. For the moment you can do the following:\n``` ts\nkernel.bind(\"Intl\").toConstantValue({ lang: \"fr\", hello: \"bonjour\" });\nkernel.bind(\"Intl\").toConstantValue({ lang: \"fr\", goodbye: \"au revoir\" });\nkernel.bind(\"Intl\").toConstantValue({ lang: \"es\", hello: \"hola\" });\nkernel.bind(\"Intl\").toConstantValue({ lang: \"es\", goodbye: \"adios\" });\nfunction getLang(lang) {\n    return kernel.getAll(\"Intl\").filter((i) => { return i.lang === lang})\n}\nlet fr = getLang(\"fr\");\nlet es = getLang(\"es\");\n```\n. @Offirmo thanks for the feature request I will work on that ASAP \ud83d\ude04 \n. Thanks for this as well :)\n. Hi @Offirmo, this has been implemented by https://github.com/inversify/InversifyJS/issues/348 and is now available in 2.0.0-rc.11\n. Docs available here\n. Typings should be available in inversify-dts@2.1.0\n. I just updated the examples repository for node and everything seems to be working fine (https://github.com/inversify/inversify-express-example/pull/44) We can try to help if you give us more details.\n. I think we can achieve this in an easier way:\n``` ts\nkernel.bind(RSRCIDS.module).toDynamicValue((context: interfaces.Context) => {\n    return module_factory({\n        schema: context.kernel.get(RSRCIDS.schema)\n    });\n});\n// usage:\nconst module = context.kernel.get(RSRCIDS.module);\n```\nNotice how we used:\nts\n.toDynamicValue((context: interfaces.Context) => { /**/ });\nInstead of:\nts\n.toDynamicValue(() => { /**/ });\nThis is not possible at the moment but it is easy to implement \ud83d\ude04  I will try to implement it as soon as I can but might take me over a week because I have too much work at the moment with other stuff...\nAlso check the recipe for Injecting dependencies into a function.\n. This has been implemented by #352 and will be released soon\n. Thanks! I will try to do another release tonight I'm closing this issue now :smile: \n. Thanks!\n. I need to think more about the possible implementation of this. I will confirm soon If I can implement something to sove this.\nFor the moment you can use a closure to create a \"singleton dynamic value\":\n``` ts\nbind(RSRCIDS.model).toDynamicValue((function() {\nvar cache = null;\n\nreturn (context: interfaces.Context) => {\n\n    if (cache !== null) {\n         return cache;\n    } else {\n        return factory({\n            schema: context.kernel.get<IJsonSchemaExtended>(RSRCIDS.schema)\n        });\n    }\n\n};\n\n})());\n```\nNote that I haven't actually tested this but my guess is that it will work...\n. What we are missing is support for inSingletonScope in toDynamicValue bindings:\nts\nkernel.bind<AdventureArchetypeModel>(RSRCIDS.model)\n      .toDynamicValue((context: interfaces.Context) => {\n          return factory({ schema: context.kernel.get<IJsonSchemaExtended>(RSRCIDS.schema) });\n      }).inSingletonScope();\nI will add support for this ASAP.\n. I have improved the page about scope in the wiki:\nAbout inSingletonScope\nThere are many available kinds of bindings:\nts\ninterface BindingToSyntax<T> {\n    to(constructor: { new (...args: any[]): T; }): BindingInWhenOnSyntax<T>;\n    toSelf(): BindingInWhenOnSyntax<T>;\n    toConstantValue(value: T): BindingWhenOnSyntax<T>;\n    toDynamicValue(func: (context: Context) => T): BindingWhenOnSyntax<T>;\n    toConstructor<T2>(constructor: Newable<T2>): BindingWhenOnSyntax<T>;\n    toFactory<T2>(factory: FactoryCreator<T2>): BindingWhenOnSyntax<T>;\n    toFunction(func: T): BindingWhenOnSyntax<T>;\n    toAutoFactory<T2>(serviceIdentifier: ServiceIdentifier<T2>): BindingWhenOnSyntax<T>;\n    toProvider<T2>(provider: ProviderCreator<T2>): BindingWhenOnSyntax<T>;\n}\nIn terms of how scope behaves we can group these types of bindings in two main groups:\n- Bindings that will inject an object\n- Bindings that will inject a function\nBindings that will inject a object\nIn this group are included the following types of binding:\nts\ninterface BindingToSyntax<T> {\n    to(constructor: { new (...args: any[]): T; }): BindingInWhenOnSyntax<T>;\n    toSelf(): BindingInWhenOnSyntax<T>;\n    toConstantValue(value: T): BindingWhenOnSyntax<T>;\n    toDynamicValue(func: (context: Context) => T): BindingInWhenOnSyntax<T>;\n}\nWe can select the scope of this types of binding with the exception of the toConstantValue which will always be a singleton.\nWhen we invoke kernel.get for the first time and we are using to, toSelf or toDynamicValue the InversifyJS kernel will try to generate an object instance or value using a constructor or the dynamic value factory. If the scope has been set to inSingletonScope the value is cached. The second time we invoke kernel.get, and if inSingletonScope has been selected, InversifyJS will try to get the value from the cache.\nNote that a class can have some dependencies and a dynamic value can access other types via the current context. These dependencies may or many not be a singleton independently of the selected scope of their parent object in their respective composition tree,\nBindings that will inject an function\nIn this group are included the following types of binding:\nts\ninterface BindingToSyntax<T> {\n    toConstructor<T2>(constructor: Newable<T2>): BindingWhenOnSyntax<T>;\n    toFactory<T2>(factory: FactoryCreator<T2>): BindingWhenOnSyntax<T>;\n    toFunction(func: T): BindingWhenOnSyntax<T>;\n    toAutoFactory<T2>(serviceIdentifier: ServiceIdentifier<T2>): BindingWhenOnSyntax<T>;\n    toProvider<T2>(provider: ProviderCreator<T2>): BindingWhenOnSyntax<T>;\n}\nWe cannot select the scope of this types of binding because the value to be injected (a factory function) is always a singleton. However, the factory internal implementation may or may not return a singleton.\nFor example, the following binding will inject a factory which will always be a singleton.\nts\nkernel.bind<interfaces.Factory<Katana>>(\"Factory<Katana>\")\n      .toAutoFactory<Katana>(\"Katana\");\nHowever, the value returned by the factory may or not be a singleton:\nts\nkernel.bind<Katana>(\"Katana\").to(Katana).inTransientScope();\n// or\nkernel.bind<Katana>(\"Katana\").to(Katana).inSingletonScope();\n. Implemented by https://github.com/inversify/InversifyJS/pull/360 I will release this ASAP \ud83d\ude04 \n. Thanks!\n. Hi, Thanks for using InversifyJS and reporting this issue. I'm going to fix this issue as part of #330 I will close this issue now but you can follow the progress at #330.\nI'm working on a PR #360 so the fix should be available very soon.\n. This PR is blocked by https://github.com/TypeStrong/tsify/issues/196\n. Thanks :) I think we are more close than ever to the 2.0 stable release \ud83c\udf89 \n. Done by 38b9a8a888ef4430bc60cda900abe118d225c35d\n. Thanks \ud83d\udc4d \n. Npm module has been deprecated and repo removed\n. Done by inversify/inversify.github.io/commit/66901e26dd0d98aa05ceb6d4fa58fa199f41246b\n. Hi guys I just released inversify-logger-middleware@2.0.1 it should fix your issue\n. I have also released inversify-restify-utils@2.0.1 I think that's all so I'm closing this issue.\n. @lholznagel thanks for letting me know! I'm at work now. I have done the changes but I won't be able to release it until this evening :cry: \n. I just released inversify-express-utils@2.0.1\n. Thanks for reporting this issue. I will fix it this evening \n. I need to check but I think it uses kernel.getServiceIdentifierAsString.\nA class is a function at run-time so it should show the class name not the whole class? If is not working like that could you please share some code to reproduce the issue? \nThanks!\n. Hi @andreasrueedlinger thanks for helping out I'm working on this now. Will share PR and release when I get them ready...\n. Your use case about classes will now generate:\nSUCCESS: 0.78 ms.\n    \u2514\u2500\u2500 Request : 0\n        \u2514\u2500\u2500 serviceIdentifier : MyController\n        \u2514\u2500\u2500 bindings\n            \u2514\u2500\u2500 Binding<MyController> : 0\n                \u2514\u2500\u2500 type : Instance\n                \u2514\u2500\u2500 implementationType : MyController\n                \u2514\u2500\u2500 scope : Singleton\n        \u2514\u2500\u2500 childRequests\n            \u2514\u2500\u2500 Request : 0\n                \u2514\u2500\u2500 serviceIdentifier : MyService\n                \u2514\u2500\u2500 bindings\n                    \u2514\u2500\u2500 Binding<MyService> : 0\n                        \u2514\u2500\u2500 type : Instance\n                        \u2514\u2500\u2500 implementationType : MyService\n                        \u2514\u2500\u2500 scope : Singleton\n                \u2514\u2500\u2500 target\n                    \u2514\u2500\u2500 serviceIdentifier : MyService\n                    \u2514\u2500\u2500 name : myService\n                    \u2514\u2500\u2500 metadata\n                        \u2514\u2500\u2500 Metadata : 0\n                            \u2514\u2500\u2500 key : inject\n                            \u2514\u2500\u2500 value : MyService\nYour case about symbols will generate:\nSUCCESS: 1.71 ms.\n    \u2514\u2500\u2500 Request : 0\n        \u2514\u2500\u2500 serviceIdentifier : Symbol(MyController)\n        \u2514\u2500\u2500 bindings\n            \u2514\u2500\u2500 Binding<Symbol(MyController)> : 0\n                \u2514\u2500\u2500 type : Instance\n                \u2514\u2500\u2500 implementationType : MyController\n                \u2514\u2500\u2500 scope : Singleton\n        \u2514\u2500\u2500 childRequests\n            \u2514\u2500\u2500 Request : 0\n                \u2514\u2500\u2500 serviceIdentifier : Symbol(MyService)\n                \u2514\u2500\u2500 bindings\n                    \u2514\u2500\u2500 Binding<Symbol(MyService)> : 0\n                        \u2514\u2500\u2500 type : Instance\n                        \u2514\u2500\u2500 implementationType : MyService\n                        \u2514\u2500\u2500 scope : Singleton\n                \u2514\u2500\u2500 target\n                    \u2514\u2500\u2500 serviceIdentifier : Symbol(MyService)\n                    \u2514\u2500\u2500 name : myService\n                    \u2514\u2500\u2500 metadata\n                        \u2514\u2500\u2500 Metadata : 0\n                            \u2514\u2500\u2500 key : inject\n                            \u2514\u2500\u2500 value : Symbol(MyService)\nThis has already been implemented by inversify/inversify-logger-middleware/pull/28 and will be released with inversify-logger-middleware@2.0.2\n. This should be now fixed:\n\n. Hi @lholznagel this is working in the express examples right? If so it must be something in your config.\n. No problem thanks for reporting it \ud83d\udc4d \n. Thanks! \ud83d\ude04  I will document here the fix...\nTo fix this problem you need to use inversify-express-utils@2.0.2 then you can import both interfaces and Controller decorator:\n``` ts\nimport { injectable, interfaces as inversifyInterfaces, Kernel } from 'inversify';\nimport { interfaces as expressUtilsInterfaces, Controller, InversifyExpressServer, TYPE } from 'inversify-express-utils';\nconst kernel: inversifyInterfaces.Kernel = new Kernel();\nkernel.bind(TYPE.Controller).to(MyController).whenTargetNamed('MyController');\n@injectable()\n@Controller('/api')\nclass MyController implements expressUtilsInterfaces.Controller {\n  constructor() {\n    console.log('do something');\n  }\n}\n```\n. Hi @luisfarzati can you please confirm that this issue has been solved for you? Thanks\n. Great, I will close this issue now. \nJust to clarify Controller (decorator) and Controller (interface) are not the same thing:\n``` ts\nimport { interfaces, Controller } from 'inversify-express-utils';\n@Controller('/api') // Decorator\nclass MyController implements interfaces.Controller { // Interface\n    // ...\n}\n```\nThat's why it is not possible to have one unique import.\n. From the docs:\n\nThe compressor might drop unused variables / unreachable code and this might change the number of identifiers or their position.\n\nThis is a problem because  some variables may not be used at design time and be used only at run-time.  I'm not sure about which variable its being dropped. I will have to do some testing to figure it out. If you could provide minimal source code that reproduces the issue It will facilitate future investigation.. Sorry but optional dependencies are not supported:\nts\nconstructor(\n        @inject('RethinkDb.ConnectionOptions') host: RethinkDb.ConnectionOptions,\n        @inject('string') dbName: string = 'ViewModels', // optional NOT SUPPORTED!\n        @inject('string') tableName: string = 'Users' // optional NOT SUPPORTED!\n) {\n// ...\nYou need to use the @unmanaged decorator:\n``` ts\nimport { inject, unmanaged, injectable } from \"inversify\";\n@injectable()\nexport default class TemplateViewModelRepository\n{\n    public host: RethinkDb.ConnectionOptions;\n    public dbName: string;\n    public tableName: string;\nconstructor(\n    @inject(\"RethinkDb.ConnectionOptions\") host: RethinkDb.ConnectionOptions,\n    @unmanaged() dbName: string,\n    @unmanaged() tableName: string\n) {\n    this.host = host;\n    this.dbName= dbName;\n    this.tableName= tableName;\n}\n\n}\n@injectable()\nexport default class UserModelRepository \n    extends TemplateViewModelRepository implements IReadUserModels, IWriteUserModels {\n    constructor(\n        @inject('RethinkDb.ConnectionOptions') host: RethinkDb.ConnectionOptions\n    ) {\n        super(host, \"ViewModels\", \"Users\");\n    }\n}\n```\nYou can find the documentation about it here.\nPlease let me know if this solves your issue and I will close it.\n. @frossi85 you need to use the decorate helper.\nFor property decorators you need something like:\nts\nlazyInject(TYPES.SomeDependency)(MyComponent.prototype, \"_someProperty\");\nWhich is the same as:\nts\nclass Something {\n   @lazyInject(TYPES.SomeDependency) private _someProperty: any;\n   // ...\n}\n. Thanks for the PR :+1: \n. Hi @timdp,\nThanks for the feedback. I think I have seem something online in the past about typescript decorators and babel decorators having incompatibility issues. \nI'm not an user of babel so I have not encountered this problem but I would like to support both babel and typescript.\nI need to do some research before I can start to work on this. If you would like to help that would be awesome. Please let me know if you know a link or repo in Github that solves this issue already.\n. I just found \"Enabling decorators in your transpiler\" maybe it can help you to solve your issue.\n. Thanks! If you find the solution we will document it in the wiki :smile: \n. Using ES7 Decorators with Babel 6 is probably what you are looking for.\n. Well, the problem is that in JS we don't have class properties. This means that at run-time property injection doesn't really make sense. For this reason, only constructor injection is supported when using the decorate function:\n``` js\nvar inversify = require(\"inversify\");\nrequire(\"reflect-metadata\");\nvar TYPES = {\n  Ninja: 'Ninja',\n  Katana: 'Katana',\n  Shuriken: 'Shuriken'\n}\nclass Katana {\n  hit () {\n    return 'cut!'\n  }\n}\ninversify.decorate(inversify.injectable(), Katana);\nclass Shuriken {\n  throw () {\n    return 'hit!'\n  }\n}\ninversify.decorate(inversify.injectable(), Shuriken);\nclass Ninja {\nconstructor(katana, shuriken) {\n      this._katana = katana;\n      this._shuriken = shuriken;\n  }\nfight () { return this._katana.hit() }\n  sneak () { return this._shuriken.throw() }\n}\ninversify.decorate(inversify.injectable(), Ninja);\ninversify.decorate(inversify.inject(TYPES.Katana), Ninja, 0);\ninversify.decorate(inversify.inject(TYPES.Shuriken), Ninja, 1);\n// Declare bindings\nvar kernel = new inversify.Kernel()\nkernel.bind(TYPES.Ninja).to(Ninja);\nkernel.bind(TYPES.Katana).to(Katana);\nkernel.bind(TYPES.Shuriken).to(Shuriken);\n// Resolve dependencies\nvar ninja = kernel.get(TYPES.Ninja);\nconsole.log(ninja.fight(), ninja.sneak());\n```\n. That is kind of out of the way the other decorators work and could lead to confusion of our users. I don't think we should go that way.\nI understand that the JS API is too verbose but you could create some helpers:\nDeclare a annotate helper function\nThis helper reduces the annotation code.\njs\nfunction annotate(constructor, dependencies) {\n    inversify.decorate(inversify.injectable(), constructor);\n    (dependencies || []).forEach(function(dependency, index) {\n        inversify.decorate(inversify.inject(dependency), constructor, index);\n    });\n}\n``` js\nvar inversify = require(\"inversify\");\nrequire(\"reflect-metadata\");\nvar TYPES = {\n  Ninja: 'Ninja',\n  Katana: 'Katana',\n  Shuriken: 'Shuriken'\n}\nclass Katana {\n  hit () {\n    return 'cut!'\n  }\n}\nannotate(Katana);\nclass Shuriken {\n  throw () {\n    return 'hit!'\n  }\n}\nannotate(Shuriken);\nclass Ninja {\nconstructor(katana, shuriken) {\n      this._katana = katana;\n      this._shuriken = shuriken;\n  }\nfight () { return this._katana.hit() }\n  sneak () { return this._shuriken.throw() }\n}\nannotate(Ninja, [TYPES.Katana, TYPES.Shuriken]);\n// Declare bindings\nvar kernel = new inversify.Kernel()\nkernel.bind(TYPES.Ninja).to(Ninja);\nkernel.bind(TYPES.Katana).to(Katana);\nkernel.bind(TYPES.Shuriken).to(Shuriken);\n// Resolve dependencies\nvar ninja = kernel.get(TYPES.Ninja);\nconsole.log(ninja.fight(), ninja.sneak());\n```\nDeclare register helper function\nThis helper reduces annotation and binding registration code.\njs\nfunction register(kernel, identifier, constructor, dependencies) {\n    inversify.decorate(inversify.injectable(), constructor);\n    (dependencies || []).forEach(function(dependency, index) {\n        inversify.decorate(inversify.inject(dependency), constructor, index);\n    });\n    return kernel.bind(identifier).to(constructor);\n}\n``` js\nvar inversify = require(\"inversify\");\nrequire(\"reflect-metadata\");\nvar TYPES = {\n  Ninja: 'Ninja',\n  Katana: 'Katana',\n  Shuriken: 'Shuriken'\n}\nclass Katana {\n  hit () {\n    return 'cut!'\n  }\n}\nclass Shuriken {\n  throw () {\n    return 'hit!'\n  }\n}\nclass Ninja {\nconstructor(katana, shuriken) {\n      this._katana = katana;\n      this._shuriken = shuriken;\n  }\nfight () { return this._katana.hit() }\n  sneak () { return this._shuriken.throw() }\n}\n// Declare bindings\nvar kernel = new inversify.Kernel()\nregister(kernel, TYPES.Katana, Katana);\nregister(kernel, TYPES.Shuriken, Shuriken);\nregister(kernel, TYPES.Ninja, Ninja, [TYPES.Katana, TYPES.Shuriken]);\n// Resolve dependencies\nvar ninja = kernel.get(TYPES.Ninja);\nconsole.log(ninja.fight(), ninja.sneak());\n``\n. I will add something to the wiki. Addinginversify-vanillajs-helperssounds like a good idea :smile: \n. Perfect! do you want me to create a repo forinversify-vanillajs-helpers` under the inversify organization?\n. What I mean is that I can create the repo as an officially supported repo and you can help us. Or you can create the repo under your user if you prefer that.\n. No problem, we will create it them :smile: \n. I'm closing this issue you can follow https://github.com/inversify/InversifyJS/issues/375 to track the implementation of the JS helpers\n. It will be a very small library that you will be able to install using npm.\n. @timdp I have done an initial release of the helpers you can find out more at https://github.com/inversify/inversify-vanillajs-helpers please not that this new library is not production ready yet (I have to write a lot of unit tests...).\n. No problem, sure feel free to send a PR or share the code here.\n. This works fine with babel right?\n. Hi @timdp I've been doing some work on this please check the latest release https://github.com/inversify/inversify-vanillajs-helpers#registration-helper I would like to hear your thoughts. Thanks!\n. I think i'm only a few unit tests away from closing this issue.\n. I'm closing this issue. I have released inversify-vanillajs-helpers 1.0.0 with 100% test coverage. More info at https://www.npmjs.com/package/inversify-vanillajs-helpers\n. Thanks!\n. Can you please let us know more about your configuration or the packages that you are having issues with? The \"@types/express\" is the new official way to use type definitions. All projects will move in that direction. Also as we have documented in the installation guide our library requires typescript 2.0.\n. No problem \ud83d\ude04 \n. This has been done :)\n. Thanks a lot for this PR as well \ud83d\udc4d is great to see a new contributor \ud83d\ude04 \n. Thanks for the PR \ud83d\ude04\n. Hi @nodify-at,\nThanks a lot for using inversify and sharing your feedback with us \ud83d\udc4d \nI see why you need it but I don't know if I like the idea of adding this as a feature because it will require all repositories to have a property named request. I don't like this because it forces the repositories to implement an interface and I think it is better to give freedom to our users and avoid forcing the implementation of an interface or extension of a base class.\nAlso, based on the SOLID principles and the separation of concerns principle, your repositories should not be aware of your controllers, or any kind of service related concerns like headers or requests. That is the job of your controllers. Your repositories should only be concern with data access stuff.\nYou should read the token in the controller and then pass it to the repository. The repository needs a token but it doesn't need to know that it comes from a request header.\nAlso this is not easy to implement at the moment because multiple request can be taking place at a given moment.  So when we use @inject(TYPES.IncomingRequest) which of the requests that the server is processing should be injected? Remember that the Inversify kernel lives at the application scope not session or request scope.\nI have plans to add custom scope support to inversify and request/session scope to the express utils but even them this would not be possible.\nI would like to know what thinks @codyjs ?\n. Hi @nodify-at can this issue be closed?\n. Hi @julianosam las week I implemented and released support for inRequestScope. \nWe refer to each call to the container.get as a container request. The inRequestScope uses the same instance for all the sub-dependencies in one unique container request. It should help in this case. \nIn the inversify-express-utils architecture, the container.get method is invoked by the router:\n\nEach HTTP request will be handled by one route.\nEach route leads to 1 unique call to container.get\n\nThese means that we can assume that we can map 1 HTTP call to 1 Container Request.\nSo, in theory, we can try something similar to the following:\n```ts\nconst TYPE = {\n    CurrentRequest : Symbol(\"CurrentRequest\")\n    UserContext: Symbol(\"UserContext\")\n};\nfunction setup(cntnr) {\nconst server = new InversifyExpressServer(cntnr);\n\n//  Create a middleware to bind the current request to a type\nconst currentRequestBindingMiddleware = (req, res, next)  => {\n   cntnr.isBound(TYPE.CurrentRequest) {\n       cntnr.rebind<Request>(TYPE.CurrentRequest)\n            .toConstantValue(req)\n            .inRequestScope();\n   } else {\n       cntnr.bind<Request>(TYPE.CurrentRequest)\n            .toConstantValue(req)\n            .inRequestScope();\n   }\n   next();\n};\n\nserver.setConfig((app) => {\n    app.use(bodyParser.urlencoded({**  extended: true  }));\n    app.use(bodyParser.json());\n    app.use(helmet());\n    app.use(compress());\n    // It shoud bind the request before routing takes place for all requests\n    app.use(currentRequestBindingMiddleware(cntnr));\n});\n\nreturn server;\n\n}\nconst container = new Container();\n// We can then declare a dynamic binding that creates\n// a binding for UserContext using the current request\ncontainer.bind(TYPE.UserContext).toDynamicValue((context) => {\n    const currentRequest = context.get(TYPE.CurrentRequest);\n    return new UserContext(currentRequest);\n}).inRequestScope();\nconst server = setup(container);\n// ...\n@injectable()\n@controller(\"/\")\nexport class  MyService {\n@inject(TYPE.UserContext) private _userContext : UserContext;\n\n@httpGet('/')\npublic get(): string {\n    const user = this._userContext.get();\n    return `Hello ${user.name}!`;\n}\n\n}\n```\nWhat should happen then is the following:\n\nAn HTTP request thits the server.\nA binding is declared for TYPE.CurrentRequest and the current request.\nRouting takes places and container.get is invoked.\nThe container tries to resolve TYPE.UserContext because it is needed by a Contoller.\nThe TYPE.CurrentRequest resolved value is added to the inRequestScope.\nThe TYPE.UserContext resolved value is added to the inRequestScope.\nThe TYPE.UserContext resolved value controller is injected in to a Contoller.\n\n:warning: This problem is not as simple as it may look because the Container is an application singleton. This means that we have one container that is shared across multiple requests. So we need to test this properly with many parallel requests to ensure that there are no rare conditions.\n. @efredin @julianosam @codyjs  please take a look to https://github.com/inversify/inversify-express-utils/pull/72\n\nHttpContext docs\nAuthProvider docs. This answer is probably too late but...\n\nYou need to use lazy property injection with inversify-inject-decorators because we can't inject into React components via constructor injection. You can learn more at:\n- https://github.com/inversify/InversifyJS/blob/master/wiki/property_injection.md\n- http://blog.wolksoftware.com/dependency-injection-in-react-powered-inversifyjs\n. Thanks for adding this :+1:  I'm just waiting for a second code review to merge your PR.\n. Thanks a lot for your contribution. I just released inversify-restify-utils@2.1.2 so I'm closing this issue \ud83d\udc4d \n. Hi, thanks for reporting. Can you please share your tsconfig.json and package.json from both projects?\n. I see a few things. You are using typings and InversifyJS uses @types because it requires typescript 2.0. It looks like you are missing some compilation options required by InversifyJS you can learn more at https://github.com/inversify/InversifyJS#installation\nAlso, in one project you are using webpack configured by yourself and in the other you are using the react-native cli.\nThe error:\n\nCannot find module 'inversify' \n\nCould be caused because typescript is < 2.0 you need to find a way to ensure that ts-loader and the react-netive CLI are using TS > =2.0.\n. They have changed the distributuion of dts files in ts > 2.0 https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/. I'm researching will let you know if I find the problem but it is probably the way the react-native cli works.\n. Hi @faisalil the project that is using ts-loader + webpack works because it  supports TypeScript. However the react native cli seems to support Flow not typescript (https://github.com/facebook/react-native/issues/5691#issuecomment-178411082). \nI think you are going to have to create your own build process an not use the React native CLI just like in the project that is working fine. I found some TS < 2.0 examples online:\n- https://raygun.com/blog/2016/07/react-native-typescript/\n- https://github.com/mrpatiwi/ReactNativeTS\nYou can use them as guide but you will need to upgrade them to TS >= 2.0.\n. Closing this as I don't think it is a inversify issue. It seems to be a react-native + ts 2.0 issue. Sorry we can't help here :cry: \n. Hi, thanks a lot for reporting this issue. I'm about to release inversify@2.0.1 which contains a fix for this issue. \nHowever, getFunctionName is only called when there is an issue (e.g. a missing annotation). At the moment you are not able to see the error message because it throws but after upgrading to 2.0.1 you will get some error. The error description should help you but feel free to ask any questions if you need additional help.\n. I just released inversify@2.0.1 please let me know if it solves your issue \ud83d\ude04 \n. Hi @stjepangolemac we have a small guide about this issue in our wiki https://github.com/inversify/InversifyJS/blob/master/wiki/inheritance.md#what-can-i-do-when-my-base-class-is-provided-by-a-third-party-module hope it solves your issue\n. I'm going with @codyjs advice for now. We might revisit this if we get other use cases :smile: \n. Hi! Thanks for sharing this request :smile:  Unfortunately this feature doesn't match adhere to our vision.  We want to encourage developers to avoid singletons. Using everything as a singleton is normally a bad practice and we want to encourage good practices.\nHowever, you can do something like:\n``` ts\nimport { interfaces } from \"inversify\";\nfunction bindInSingletonScope(\n    kernel: interfaces.Kernel,\n    serviceIdentifier: interfaces.ServiceIdentifier,\n    service: constructor: interfaces.Newable\n) {\n    return kernel.bind(serviceIdentifier, service); // return so you can create constraints\n}\nbindInSingletonScope('foo', Foo);\nbindInSingletonScope('bar', Bar);\nbindInSingletonScope('baz', Baz).whenTargetNamed(\"something\"); // you can create constraints\n```\n. I started the development of InversifyJS after reading this post and my main motivation was the following about DI in Angular 1.0:\n\nInversifyJS solves all these problems. \nAbout the first point \"internal cache\" I think that the main problem is that the \"internal cache\" is like a \"global state\" and global state can break your unit tests. For example, one tests does something using X and the next test will also use X because is a singleton. \nYou can see some other thoughts at SO.\n. Here are some Angular 2  examples I guess is not harm to give the power of choice to our users.\nI will do something to allow overriding of some defaults when creating a kernel instance:\nts\nlet kernel = new Kernel({\n    defaultScope: \"singleton\",\n    hierarchicalNavigation: \"descending\"\n});\n- defaultScope is what you are asking for.\n- hierarchicalNavigation allows to configure hierarchical dependency injection to be ascending or descending by default it will be descending.\nAngular 2 is ascending by default but I have been talking with other devs about it in other issues and descending allow us to split apps into multiple npm modules.\n. This will be implemented soon. Keep an eye on the following issue to find out when it becomes available https://github.com/inversify/InversifyJS/issues/393\n. Thanks for reporting this issue. We will fix it ASAP feel free to send a PR if you want to contribute a fix (Please remember to add a test case to reproduce the issue before fixing).\n. Done by https://github.com/inversify/inversify-logger-middleware/pull/32 & released by with inversify-logger-middleware@2.0.3 \ud83c\udf89 \n. @skyrpex thanks a lot this suggestion. Many times I made the mistake of forgetting that Map and WeakMaps are available. I though about using an AVL tree to improve complexity from O(n) to O(log n). But looks like Map uses a hash table internally and achieves O(1) complexity. I will use a Map :smile: \n. Expect this to be merged soon \ud83c\udf89 \nBefore\n\nAfter\n\n. Merged https://github.com/inversify/InversifyJS/pull/398 :tada:\n. Hi,\nSorry for the late reply I was away for the weekend.\nThis is not possible because the value treated as a singleton would be the provider () => Promise<T> not the value T.\nHowever, there is a work around using closures:\nts\nkernel.bind<interfaces.Provider<DbConn>>(\"Provider<DbConn>\").toProvider<DbConn>((context) => {\n    let singleton = null; \n    return () => {\n        if (singleton === null) {\n            return new Promise<DbConn>((resolve, reject) => {\n                let dbConn = new MongoClient(new Server('localhost', 27017));\n                dbConn.open(function(err, conn) {\n                    if (err) { reject(err); }\n                    singleton = conn;\n                    resolve(dbConn);\n                });\n            });\n        } else {\n            return Promise.resolve(singleton);\n        }\n    };\n});\n. AppVeyor build is broken by issue caused bt node 7.0 https://github.com/appveyor/ci/issues/1131#issuecomment-258130881\n. Awesome thanks a lot for this PR \ud83d\udc4d \n. Thanks a lot for this PR :+1: \n. Thanks for all the PRs \ud83d\udc4d \n. @kennyjacob that's awesome welcome to the OSS club \ud83d\udc4d If you want I can suggest a few things that I have to do and I think they are not too complex...\nYesterday I released 3.0.0-beta.1 but I haven't update any of the side-projects would you like to help with that? \nYou can ignore the devtools because they are not ready. The logger-middleware will be the most complicated one because there are some breaking changes but the rest should be fine.\n. Hi @kennyjacob sorry for the late reply I was away last week... Check out the issues with the Accepting PRs tag here. \nThe first 3 are not too complicated. Please feel free to add comments to the issues if you need hel with them and I will try my best to assist you.\n. Hi @lholznagel I'm closing this because this issue is now outdated... I will create a new one in a few minutes.. Hi @meticoeus at the moment we have the following:\n``` ts\nimport getDecorators from \"inversify-inject-decorators\";\nimport { Kernel, injectable, tagged, named } from \"inversify\";\nlet kernel = new Kernel();\nlet { lazyInject } = getDecorators(kernel);\nlet TYPES = { Weapon: \"Weapon\" };\ninterface Weapon {\n    name: string;\n    durability: number;\n    use(): void;\n}\n@injectable()\nclass Sword implements Weapon {\n    public name: string;\n    public durability: number;\n    public constructor() {\n        this.durability = 100;\n        this.name = \"Sword\";\n    }\n    public use() {\n        this.durability = this.durability - 10;\n    }\n}\nclass Warrior {\n    @lazyInject(TYPES.Weapon)\n    public weapon: Weapon;\n}\nkernel.bind(TYPES.Weapon).to(Sword);\nlet warrior = new Warrior();\nconsole.log(warrior.weapon instanceof Sword); // true\n```\nInternally it uses a \"get proxy\" via Object.defineProperty you can see the details here. I don't think we can await inside the proxy :cry: \nSo I think you are right, the only way would be to inject a promise:\n``` ts\nimport getDecorators from \"inversify-inject-decorators\";\nimport { Kernel, injectable, tagged, named } from \"inversify\";\nlet kernel = new Kernel();\nlet { lazyInject } = getDecorators(kernel);\nlet TYPES = { Weapon: \"Weapon\" };\ninterface Weapon {\n    name: string;\n    durability: number;\n    use(): void;\n}\n@injectable()\nclass Sword implements Weapon {\n    public name: string;\n    public durability: number;\n    public constructor() {\n        this.durability = 100;\n        this.name = \"Sword\";\n    }\n    public use() {\n        this.durability = this.durability - 10;\n    }\n}\nclass Warrior {\n    @lazyInject(TYPES.Weapon)\n    public weapon: Promise;\n    public fight() {\n        this.weapon.then((sword) => {\n            sword.use();\n        });\n    }\n}\nkernel.bind(TYPES.Weapon).to(Sword);\nlet warrior = new Warrior();\n```\nThe other option is to inject a function that returns a function. So the warrior can use async and await:\n``` ts\nclass Warrior {\n    @lazyInject(TYPES.Weapon)\n    public weapon: () => Promise;\n    public async fight() {\n        let sword = await this.weapon();\n        sword.use();\n    }\n}\nlet warrior = new Warrior();\nwarrior.fight();\n```\nWhat do you guys think?\ncc: @otbe @donaldpipowitch you guys are using it with React so it is important to get your feedback.\n. Hi @rashtao at the moment you can choose between promise or value. All the kinds of injections inject a value or a Factory of the value. If you want a promise we inject a Provider. The provider is a Async Factory.\nThis means that we can use @inject(\"TYPE\") to inject a type: value, a factory or a provider.\nWhat is not possible and I would like to make possible is injecting a value that requires an async initialization. In other word be able to await Provider and inject its value. This is not possible at the moment but I don't think we need @awaitInject because you will be able to use:\n- @inject(\"Provider<T>\") allows access to the value via a promise\n- @inject(\"T\") allows direct access to the value without promise\nThe problem is that to be able to support AsyncValue injections we need the library to be async by default. So you will be able to choose if you want to inject a promise or a value but you will always have to await to get that promise or that value:\n``` ts\ncontainer.bind(\"Warrior\").to(Ninja);\n// we have to await but it is synchronous\nlet ninja = await container.get(\"Warrior\"); \n// ninja is a value\n```\n``` ts\ncontainer.bind(\"DbClient\").toAsyncValue((context) => {\n    return () => {\n        return new Promise((resolve, reject) => {\n            // ...\n        });\n    };\n});\n// we have to await because is asynchronous\nlet dbClient = await container.get(\"DbClient\");\n// dbClient is a value\n```\n``` ts\ncontainer.bind>(\"Provider\").toProvider((context) => {\n    return () => {\n        return new Promise((resolve) => {\n            let katana = context.container.get(\"Katana\");\n            resolve(katana);\n        });\n    };\n});\n// we have to await but it is synchronous\nlet katanaProvider= await container.get>(\"Provider\");\n// katanaProvider is a Promise\n```\nNote that we await only at the composition root not in every level of the composition tree. We also await in the levels in which a async value is injected.\n. Not 100% the same:\n- @inject(\"Provider<T>\") injects a function that returns a promise () => Promise<T>\n- @inject(\"Promise<T>\") injects a promise Promise<T>\n. Hi @buehler thanks a lot for your feedback. Having container.get and container.getAsync is something that I have actually think about. I see two problems:\n- Provider<T> is an alias for (...args: any[]) => Promise<T> and it can take some arguments provided by the user not the container. So provider should always be injected as a factory that returns a promise never as the value returned by the promise.\n- AsyncValue injection does not allow user provided args  () => Promise<T> this means that we could inject it as a value when container.getAsync is used or as a promise when container.get is used. But this makes the code hard to understand because your class may be annotated as @inject(\"DbClient\") and the reality is that DbClient will sometimes be a promise and sometimes be a value based on the container method invoked.\n. Maybe it is not worth it to introduce async value injection? \nAt the moment we can do:\n``` ts\nclass UserRepository { \nprivate _db: DbClient;\nprivate _dbProvider: Provider<DbClient>;\n\n// STEP 1\npublic constructor(\n    @inject(\"Provider<DbClient>\") provider: Provider<DbClient> // Provider injection \n) { \n    this._dbProvider = provider;\n}\n\n// STEP 2\nprivate async init() {\n    if (this._db) return this._db;\n    this._db = await this._dbProvider();\n    return Promise.resolve(this._db);\n}\n\npublic async getUser(): Promise<Users[]>{\n    let db = await this.init();\n    return db.collections.user.get({});\n}\n\npublic async deletetUser(id: number): Promise<boolean>{\n    let db = await this.init();\n    return db.collections.user.delete({ id: id });\n}\n\n}\n```\nIt requires a two-step initialization but the code is not bad.\nI wanted to allow one step initialization:\n``` ts\nclass UserRepository { \nprivate _db: DbClient;\n\n// STEP 1\npublic constructor(\n    @inject(\"DbClient\") db: DbClient // Async value injection\n) { \n    this._db = db;\n}\n\npublic async getUser(): Promise<Users[]>{\n    return this._db.collections.user.get({});\n}\n\npublic async deletetUser(id: number): Promise<boolean>{\n    return this._db.collections.user.delete({ id: id });\n}\n\n}\n```\nBut it requires the whole framework to become async. Maybe the price to pay is too high for just one small improvement?\n. I'm going to investigate the @buehler suggestion.toAsyncValue is not going to happen because it is probably too early to force people to use async / await. Thanks a lot for your feedback :)\n. I have created #418 I'm closing this issue :smile: . Hi @alexmt please use inversify@2.0.1 for the moment. We are in the process of upgrading inversify-restify-utils to work with 3.0.0-beta.1 but is not ready yet.\n. Done by #420 and available on 3.0.0-beta.2. \ud83d\udc4d Awesome thanks a lot for creating this tool and sending the PR \ud83d\ude04 \n. Can you please try class based inheritance:\n``` ts\ninterface CustomContainer extends interfaces.Container {\n    createChild: Container;\n}\nclass CustomContainer  extends Container {\n    createChild = () => {\n        const child = new Container();\n        child.parent = this;\n        return child;\n    }\n}\n```\nI have't try this but I assume that it will work. Please let me know if it solves your problem :wink: \n. Interesting :thinking:  do you know about any issue/link in which I can learn more about the default exports issues? I want to learn more before I introduce a change. \nI will introduce Container.prototype.createChild as a feature. I have create #408 to track it. Feel free to send a PR.\n. @shlomiassaf @lholznagel thanks a lot for the links!\nI have created another issue to remove the default exports #410 I'm closing this issue because now we can use #408 & #410 to track the required actions.\n@shlomiassaf thanks a lot for trying the beta and sharing feedback it is a really valuable contribution :+1: \n. Done by #420 and available on 3.0.0-beta.2. The type information is only emitted when a decorator is applied :cry: Have you take a look to inversify-binding-decorators?\n. The type information is only emitted when a decorator is applied :cry: \nHave you tried inversify-binding-decorators?\n\n. Sure! I will try my best to publish this evening but I just arrived from a week awake and I have to write back to many emails before :sob: \n. About your question about multiple containers...\nLets say that you have two npm modules:\n- Warriors Module: declares a Conainer (A) and uses it to create a @provide annotation. The annotation is used in a class Ninja\n- Weapons Module: declares a Conainer (B) and uses it to create a @provide annotation. The annotation is used in a class Katana\nBoth modules are then consumed from a third module C. But how can we get the Katana to be injected into the Ninja if the bindings and metadata are in two different containers. There are two available solutions:\n- Container.merge\n- Hierarchical DI (Based on Angular 2)\n. Yes you are right is not a breaking change because ourpublic interface is not using default at the moment anyway.\n. @lholznagel they are exported because maybe someone will work on devtools that will benefit from those interfaces. For example the devtools use some of the internal inversify interfaces.\n. The namespace was added to avoid naming conflicts. \nBefore we had IContainer and Container: \nts\nimport { IContainer, Container } from \"inversify\";\nIt was recommended by most guidelines to avoid the I prefix:\nts\nimport { Container } from \"inversify\"; // Interface or Class?? Error!\nWe use the interface namespace to avoid conflicts between the interface and the implementations:\nts\nimport { interfaces, Container } from \"inversify\";\n. If you guys have a better idea please let me know because I remember not being too happy about it when I changed it :cry:  We could use ContainerInterface instead of Container but I kind of like more the namespace?\n. Hi @shlomiassaf let's remove the default exports and I will think about going back to the I prefixes. I need to think this one well because we already went from using I to not using it and I don't want to frustrate our users with breaking changes.\n. I'm closing the issue because this has now been merged into master by #416. I will leave the interfaces as they are right now. I don't feel 100% sure about changing them so I will wait until we have more users and we can collect more feedback about it.. Thanks for this suggestion. I see your point but I really think that optional dependencies lead to bad code that's why is not available at the moment. Have you encountered a use case in which you need @optional ?\nIf there is a real use case in which it is needed I will be happy to implement it but I would like to avoid it otherwise.\nAs a side note: When I started to think about @optional I also though about @default(\"ID\", value) which will resolve and inject \"ID\" but if no bindings are declared will inject value.\n. Sorry for the late reply I wanted to finish other features first. I've been thinking about this and here is my idea of how the API should look like.\n~~@default()~~\nI don't think InversifyJS should manage default values because the TypeScript compiler can do this job for us and one of our design goals is to add as litle runtime overhead as possible. This means that we only need the @optional annotation and the TypeScript syntax for default values = \"value\":\nts\nclass MyClass {\n  constructor(@inject(\"ID\") @optonal() myInjection: string = \"value\") {\n  }\n}\n@optional()\nWe need this decorator and it will be implemented. I recommend using @optional() with non- nullable types enabled. \ntype Optional<T> = T | undefined;\nThe type of the arguments decorated @optional() should be the union of undefined and a give type:\nts\nclass MyClass {\n  constructor(@inject(\"ID\") @optonal() myInjection: Optional<string>) {\n  }\n}\n. Hi @shlomiassaf optional dependencies have now been merged into master by https://github.com/inversify/InversifyJS/pull/432 and will be available in the 3.0.0-beta.4 release later this week \ud83d\ude09  . Hi @alexmt I just release 3.0.0-beta.2 which I believe you need for this. Your suggestion looks good to me. However, I mainly look after the InversifyJS core. I would like @codyjs and @lholznagel to share their thoughts just to be sure because they are more experienced than me with node \ud83d\ude04 . The PR has been merged \ud83c\udf89 \nI have created another issue to do the same in the express utils https://github.com/inversify/InversifyJS/issues/422.\nI'm going to try to update the dependencies and do a release ASAP.. @codyjs thanks a lot for helping out :heart: \n. Hi @dkellenb can you confirm that this solves your problem? Thanks!\n. Can one of you guys @codyjs @goenning @dkellenb please document the answer on SO to ensure that it will help other users in the future? Thanks a lot for your help!\n. @FriOne I'm not experienced with Sockets but if it is an object you should be able to inject it using:\n```ts\ncontainer.bind(\"SocketType\").toConstantValue(socketInstance);\n// and in your controllers\n@inject(\"SocketType\")\n```. Hi we use mocha, chai and sinon with istanbul to run our unit test and test coverage and it works fine. I have never work with jest maybe is a jest issue?\n. Do you think there is anything we can do about it? What is using Ava / Jest for test coverage? istanbul?\n. Hi @ppsimatikas did the solution work for you? Can this issue be closed? Thanks\n. Hi @ppsimatikas have you been able to solve this issue?\nPlease note that I will close this issue in a few days If there is nothing else we can do to help.\nps: Thanks a lot @lholznagel for your help here \ud83d\udc4d  . Done by #416. I started working on this and I realized that the proposed solution has a problem: It assumes that we want the provider to return a singleton. For this reason, I decided not to go ahead with this change. However, I noticed that the Provider was much less flexible than the Factory. I have upgraded the Provider signature to allow advanced use cases like: \n\nSingleton and Transient scope support\nCustom arguments support\nSupport for the partial application of custom arguments\n\nI have created a PR #431 that documents all these features. The PR also documents a \"recipe\" that helps to reduce boilerplate:\nts\nfunction valueOrDefault<T>(provider: () => Promise<T>, defaultValue: T) {\n    return new Promise<T>((resolve, reject) => {\n        provider().then((value) => {\n            resolve(value);\n        }).catch(() => {\n            resolve(defaultValue);\n        });\n    });\n}\n```ts\n@injectable()\nclass Ninja {\n    public level: number;\n    public rank: string;\n    public constructor() {\n        this.level = 0;\n        this.rank = \"Ninja\";\n    }\n    public train(): Promise {\n        return new Promise((resolve) => {\n            setTimeout(() => {\n                this.level += 10;\n                resolve(this.level);\n            }, 100);\n        });\n    }\n}\n@injectable()\nclass NinjaMaster {\n    public rank: string;\n    public constructor() {\n        this.rank = \"NinjaMaster\";\n    }\n}\ntype NinjaMasterProvider = () => Promise;\nlet container = new Container();\ncontainer.bind(\"Ninja\").to(Ninja).inSingletonScope();\ncontainer.bind(\"NinjaMasterProvider\").toProvider((context) => {\n    return () => {\n        return new Promise((resolve, reject) => {\n            let ninja = context.container.get(\"Ninja\");\n            ninja.train().then((level) => {\n                if (level >= 20) {\n                    resolve(new NinjaMaster());\n                } else {\n                    reject(\"Not enough training\");\n                }\n            });\n        });\n    };\n});\nlet ninjaMasterProvider = container.get(\"NinjaMasterProvider\");\nvalueOrDefault(ninjaMasterProvider, { rank: \"DefaultNinjaMaster\" }).then((ninjaMaster) => {\n    // Using default here because the provider was rejected (the ninja has a level below 20)\n    expect(ninjaMaster.rank).to.eql(\"DefaultNinjaMaster\");\n});\nvalueOrDefault(ninjaMasterProvider, { rank: \"DefaultNinjaMaster\" }).then((ninjaMaster) => {\n    // A NinjaMaster was provided because the the ninja has a level above 20\n    expect(ninjaMaster.rank).to.eql(\"NinjaMaster\");\n    done();\n});\n```\n. Hi, Alex thanks a lot for reporting this issue. Require JS needs AMD modules but not a bundled version of the library. We don't have plans to include a bundled version (dist/inversify) because we had problems with that in the past. However, I can add a AMD version for you. \nYou will then have to create the bundle using the RequireJS Optimizer. I will include aamd folder in the next release. This folder will contain all the InversifyJS source files in AMD format but not bundled.\n. Done by #420 and available on 3.0.0-beta.2. Thanks for the feedback. This is going to be included in the next release (3.0.0).\n. This has been implemented, check out #424 for more details. . Thanks for letting me know @codyjs If you guys can confirm that this is not possible I will close this issue :). Thanks for the details \ud83d\udc4d . Hi @sanex3339 thanks for reporting this issue I will investigate and let you know my thoughts ASAP.. I think I might have an idea of what is going on... Your individual entities are singletons but your factory is not a singleton.\nThere is something that is not very clear in the docs: The factory is a singleton by default and there is no way to change that. However, the value returned by the factory may or may not be a factory.\nThe factory is just a function which is injected as a function always but when you invoke the factory the value returned may or may not be a singleton. The behavior is controlled by the way to implement your factory and it is not controlled by InversifyJS.\nIn your case is a bit more complicated because your factory uses named bindings but you can try the following (Please note that I have written the following code in notepad so it may contain errors).\n```ts\nthis.container\n    .bind(ServiceIdentifiers['Factory'])\n    .toFactory((context: interfaces.Context) => {\n    let cache = new Map<string, INodeTransformer[]>(); // singleton!\n\n    return (nodeTransformersMap: Map<string, string[]>) => {\n\n        (nodeType: string) => {\n\n            if (cache.has(nodeType)) {\n\n                // Try to access singleton from cache\n                return cache.get(nodeType);\n\n            } else {\n\n                // Try to resolve\n\n                const nodeTransformers: string[] = nodeTransformersMap.get(nodeType) || [];\n                const instancesArray: INodeTransformer[] = [];\n\n                nodeTransformers.forEach((transformer: string) => {\n                    instancesArray.push(\n                        context.container.getNamed<INodeTransformer>(\n                            'INodeTransformer', transformer\n                        )\n                    );\n                });\n\n                // Add to cache\n                cache.set(nodeType, instancesArray); // add to cache\n                return instancesArray;\n\n            }\n\n        };\n    }\n});\n\n```\nPlease let me know if it improves the performance. Also please note that the performance should be good but is never going to be as fast as your original code because your original code didn't have to resolve a dependency tree at all. Everything was in memory as a singleton since the moment it was declared.\n. Happy to help. I will close this issue.. Sounds reasonable to me. Would you like to send a PR?. Cool I will be working in other issues first but If I finish them I will also work on this. I will comment here if I'm working on it.... If you send a PR I will review it and take a look to the build and test coverage \ud83d\udc4d . This has been now merged into master https://github.com/inversify/InversifyJS/pull/427. Released \ud83c\udf89 \n\n. This is not available in typescript@rc so I will close it.. @sanex3339 thanks for the PR take your time to fix it. If you are busy don't worry leave it open. And I will send a PR to your PR.. I have sent you a PR that I hope will fix the build \ud83d\ude04 . Thanks for merging my PR. The AppVeyor build failed due to a timeout. It is re-building now \u23f3 . Merged \ud83c\udf89 . You need some kind of additional metadata and use a contextual constraint based on that metadata. We support some features for this kind of use case like Tagged Binding and Named Binding. \nIn your case you are also going to need a Factory Injection. Let's take a look to an example!\nYou only need one OAuthClient implementation:\n```ts\nimport {injectable, inject} from \"inversify\"\nimport {ValidationHandler} from 'majisti/authentication/ValidationHandler'\nimport {OAuthProvider} from 'majisti/authentication/OAuthProvider'\nimport {WindowFacade} from 'utils/WindowFacade'\n@injectable()\nexport default class OAuthClient {\nprivate provider: OAuthProvider\nprivate windowFacade: WindowFacade\nprivate validationHandler: ValidationHandler\n\npublic constructor(\n    @inject(Types.OAuthProvider) provider: OAuthProvider,\n    @inject(Types.WindowFacade) windowFacade: WindowFacade,\n    @inject(Types.JwtValidationHandler) validationHandler: ValidationHandler\n) {\n    this.provider = provider\n    this.windowFacade = windowFacade\n    this.validationHandler = validationHandler\n}\n\n}\n```\nI don't know what kind of app you are creating but I will use a REST API with inversify-express-utils as an example. You will need to inject a Factory<OAuthClient> into a Controller:\n```ts\n@injectable()\n@Controller('/auth')\nclass LoginController() {\nprivate _oAuthClientFactory: Factory<OAuthClient>;\n\npublic constructor(@inject(\"Factory<OAuthClient>\") oAuthClientFactory: Factory<OAuthClient>) {\n    this._oAuthClientFactory = oAuthClientFactory;\n}\n\n@Post('/login')\npublic login(request: Request) {\n    let name = request.header.provider; // read provider from a header\n    let oAuthClient = this.oAuthClientFactory(name); // get client using provider as metadata\n}\n\n}\n```\nNotice how the factory uses a header as an argument. This header is used as metadata. \n\nController -> Client (Parent) -> Provider\n\nThe metadata is used in some contectual constraints. Notice the whenParentNamed constraints and how it is used in the Factory<OAuthClient>:\n```ts\nlet container = new Container();\ncontainer.bind(\"OAuthClient\").to(OAuthClient);\ncontainer.bind(\"OAuthProvider\").to(LinkedInAuthProvider).whenParentNamed(\"LinkedIn\");\ncontainer.bind(\"OAuthProvider\").to(FacebookAuthProvider).whenParentNamed(\"Facebook\");\ncontainer.bind(\"OAuthProvider\").to(GoogleAuthProvider).whenParentNamed(\"Google\");\ncontainer.bind>(\"Factory\").toFactory((context: interfaces.Context) => {\n    return (named: string) => {\n        return context.container.getNamed(\"OAuthClient\", named);\n    };\n});\n```\nI hope this helps.\nPlease let e know if I can close this issue.\n. Hi @gCardinal I saw you posted a comment but I can't see it now? \n\n. No problem \ud83d\ude04 and happy to help here. Please post more questions if you need additional help \ud83d\udc4d and thanks for the nice comments about the lib!. Hi @abettadapur I will get this done this week but I can't promise you a date at the moment \ud83d\ude09 . I have added support for AMD modules and released it:\n$ npm install --save inversify@3.0.0-rc.1 inversify-inject-decorators@3.0.0-beta.1\n\n. Thanks \ud83d\ude04 Docs available at here.. CC: @lholznagel @codyjs \nHi! thanks for this suggestion. I understand this use case. Just like I usually do I recommend to create an API that feels like the ASP.NET core API. \nWe should use the docs about Formatting Response Data as a reference. \nSo we have 3 requirements:\nFormatting response data at route level\nIt is very easy to think that an annotation like @json() is the best solution but I don't agree with this for a few reasons. This means that we will need a new annotation for each format:  @textplain(), @xml()... As you can imagine this is not really easy to extend by the community. \nAlso, I don't think we should aim for decorators as a solution for everything. We don't want our framework to become like Java spring:\n\nThe way ASP.NET core handles this is:\npublic JsonResult Get()\n{\n    return Json(_authorRepository.List());\n}\nIs almost identical to the node.js way:\nresponse.json(result);\nMaybe we need to declare our own JsonResult class? \nFormatting response data at controller level\nSame as at route level.\nFormating response data at application level\nWe need a to include something in the server public interface that allows us to register global response formatters. Initially, we can add three basic formatters:\n\nXml\nPlain Text\nJson\n\nThis is basically a kind of response middleware like gziping responses...\nWe can then implement a few nice features. For example, routes that allow an extension:\n\nWe can also add support for content negotiation so we respond in a given format based on the request headers.\n. Do you guys want o volunteer to implement this? I would like to do some work on the DevTools projects after the 3.0 release.. Hi @ChrLipp thanks for researching this. I guess the best thing to do for now is to close this issue. The XML case may come back in the future but most people use JSON these days... \nI like to implement features only when there is a real need for them, a real use case. In this case adding XML support would be a lot of extra complexity that has not been required by no one so far. That's why I'm closing this issue.. Thanks @lholznagel If you could upgrade to the following that would be great:\n\ninversify-express-utils\ninversify-express-example\n\nI will upgrade the following projects:\n\ninversify.github.io\ninversify-logger-middleware\ninversify-basic-example\n\nThen we can both try to fix:\n\ninversify-hapi-example\n. Sorry I forgot about it \ud83d\ude22 I will try to do a release later tonight I have to go offline now for 2 or 3 hours...\n. No worries! We can do it tomorrow :). Hi @riggerthegeek are you using inversify 2.0 or 3.0 ? express-utils is not ready for 3.0 we are working on that this week.. Yes, all the side projects are not ready for 3.0 we are going to upgrade one by one during this week. Try using 2.0 please let me know if that fix your issue.. Sorry about the problems caused. You can expect a release compatible with 3.0 later this week :smile: . I think I get it.\n\n\nThis line needs to be wrapped in a try/catch. Is it worth me submitting a PR with a fix?\n\nThat sounds good to me. \n@lholznagel do you think try/catch is correct here?. I think in the case of a catch we need to return a HTTP Error 500 Internal server error. I'm happy with your suggestion, do you want to send a PR?. This has now been released \ud83c\udf89 \n\n@lholznagel do we need to do this in the express utils as well?\n. Cool \ud83d\ude0e I will await for the PR before closing this. Sorry, I have no idea :cry: maybe @lholznagel or @codyjs can help ?. We need to rollback the handlerFactory function? \nhttps://github.com/inversify/inversify-restify-utils/pull/22/files#diff-916156c481141bfcd08c6ae40ce10e00L80\nAbout the issue I won't be able to try until tonight :(. I'm just trying to guess but this seems wrong to me:\nts\nexport default fooService => { // fooService  is a function\n    return new BasicStrategy((email, pass, cb) => {\n        fooService.login(emailAddress, password) // fooService is an object?\n           .then(user => {\n                if (user) {\n                    cb(null, user);\n                } else {\n                    cb(null, false);\n                }\n          }).catch(err => {\n              console.log('auth');\n              console.log(err);\n              cb(err);\n          });\n    });\n}. No problem! we are here to help :wink: \nI have created a new issue to rollback the changes https://github.com/inversify/InversifyJS/issues/439. I think there is no need to change that. Promise libraries are just a temporal thing and at some point we will not need them. I believe it is correct to write the lib in a way that allow us to don't have to worry about which version of Promise is used.\nThe check x instance of Promise should work because Promise should be a global. For example, if you import it from bluebird:\n```\nimport { Promise } from \"bluebird\";\n// ...\nlet a = Promise.resolve(1);\na instanceof Promise; // true\n```\nOr form Q:\n```\nimport * as Q from \"q\";\nlet Promise = Q.Promise;\n// ....\nlet a = Promise.resolve(1);\na instanceof Promise; // true\n```\nAuthors of other libraries should do the same thing to avoid problems.\nBecause promises are declared as a global global we don't need to worry about concrete versions.\n. Closing this issue because I've not been able to find the doc in the screen capture in the code base. Done by PR https://github.com/inversify/inversify-restify-utils/pull/23. Hi, I just wrote an unit test to try to reproduce this issue and it seems to work fine for me. I used the following example:\n```ts\nit(\"Should be able to throw an exception inside of a factory\", () => {\ntype RandomProvider = (named?: string) => Promise<string>;\n\nlet container = new Container();\n\ncontainer.bind<RandomProvider>(\"RandomProvider\").toFactory<string>((context: interfaces.Context) => {\n    return (name?: string) => {\n        if (name) {\n            return \"It works!\";\n        }\n        throw new Error(\"Argument name cannot be null!\");\n    };\n});\n\nlet provider = container.get<RandomProvider>(\"RandomProvider\");\n\nlet throws = () => { provider(); };\n\nexpect(throws).to.throw(\"Argument name cannot be null!\");\nexpect(provider(\"something\")).to.eql(\"It works!\");\n\n});\n```\nI would try to debug the following:\n```ts\nexport default (context: Context) => {\n    return (name: string): OAuthClient => {\n   console.log(\"BREAKPOINT HERE!!! =>\", name);\n\n    if (name) {\n        return context.kernel.getNamed<OAuthClient>(Types.OAuthClient, name)\n    }\n\n    throw new TypeError('name cannot be undefined')\n}\n\n}\n```. I just tried to following just to be use:\n```ts\nit(\"Should be able to throw an exception inside of a factory\", () => {\ntype RandomProvider = (named?: string) => Promise<string>;\n\n@injectable()\nclass ProviderConsumer {\n    @inject(\"RandomProvider\") public randomProvider: RandomProvider;\n}\n\nlet container = new Container();\ncontainer.bind<ProviderConsumer>(ProviderConsumer).toSelf();\n\ncontainer.bind<RandomProvider>(\"RandomProvider\").toFactory<string>((context: interfaces.Context) => {\n    return (name?: string) => {\n        if (name) {\n            return \"It works!\";\n        }\n        throw new Error(\"Argument name cannot be null!\");\n    };\n});\n\nlet consumer = container.get<ProviderConsumer>(ProviderConsumer);\n\nexpect(consumer.randomProvider).not.to.eql(undefined);\n\nlet throws = () => { consumer.randomProvider(); };\n\nexpect(throws).to.throw(\"Argument name cannot be null!\");\nexpect(consumer.randomProvider(\"something\")).to.eql(\"It works!\");\n\n});\n```\nBut it works fine for me as well..... No problem \ud83d\udc4d . Hi! I think I know the solution. \nThe \"quick and dirty\" solution\nBindings are like dictionary entries. A dictionary entry has a key and a value. In a binding, the key can be a symbol, string or class. The value can be a lot of things: class, factory, constant or dynamic value, provider...\nYou have declared some bindings:\nts\ncontainer.bind<IMqttClient>(MqttClient).toSelf().inSingletonScope();\ncontainer.bind<IWebSocketServer>(WebSocketServer).toSelf().inSingletonScope();\nYou have used the classes as key because the bind<T>(ID) method takes an ID as its argument. You also used the classes as value, because toSelf() uses the value of the key as the value itself.\nAt this point TypeScript knows how to resolve a request for two keys:\n\nMqttClient\nWebSocketServer\n\nThe problem is that your class WebSocketServer requires an interface:\nts\nconstructor (mqttClient: IMqttClient) {\n    this._mqttClient = mqttClient\n}\nYou can solve it using the class instead of the interface:\nts\nconstructor (mqttClient: MqttClient) {\n    this._mqttClient = mqttClient\n}\nThe recommended solution\nUsing classes as keys is not recommended because you lose the benefits of the inversion of control principle. Your classes are coupled to each other. You need to use interfaces as keys to be able to decouple it:\nts\nconstructor (@inject(\"IMqttClient\") mqttClient: IMqttClient) {\n    this._mqttClient = mqttClient\n}\nAs you can see interfaces require an inject annotation. This is the error that you have been seeing:\n\nError: Missing required @inject or @multiInject annotation in: argument 0 in class WebSocketServer.\n\nBecause the key is not the class you also need to update the bindings:\nts\ncontainer.bind<IMqttClient>(\"IMqttClient\").to(MqttClient).inSingletonScope();\ncontainer.bind<IWebSocketServer>(\"IWebSocketServer\").to(WebSocketServer).inSingletonScope();\nAt that point you should be able to request intances of \"IWebSocketServer\":\nts\nconst wss = container.get<IWebSocketServer>(\"IWebSocketServer\");\nwss.send('lol');\n. Hi @sanex3339 I don't think that change is is going to be possible. If no bindings match the name no bindings will be returned. \nYou can try using container.isBoundNamed:\n```ts\nlet id = \"XXXXX\";\nlet name =\"YYYYY\";\nlet val =  container.isBoundNamed(id, name) ? container.getNamed(id, name) : container.get(id);\n```\n. Sorry for that. I think I understand the problem now. I will test it and fix it during the weekend :+1: . Fixed by https://github.com/inversify/InversifyJS/pull/443 and released as 3.0.0-rc.2 :tada:. Thanks for reporting. We don't include polyfill by default but we document if they are required. I will add a note about it just like the note at https://github.com/inversify/InversifyJS#installation. I have added instructions in the docs https://github.com/inversify/inversify-inject-decorators/commit/ddca3c3aea6028e7e9904aa8e3f079fc7c101df0. You can use @inject to annotate a constructor:\nts\n@injectable()\nclass A {\n    public c: number;\n    constructor(@inject(\"A\") a: number, @inject(\"B\") b: number) {\n         this.c = a + b;\n    }\n}. In you example you used property injection. That also works:\n```ts\n@injectable()\nclass A {\n@inject(\"A\")\npublic a: number;\n\n@inject(\"B\")\npublic b: number;\n\n\npublic c: number;\n\n// constructor(){} no need for default constructor\n\ninit(){\n    this.c = this.a + this.b;\n}\n\n}\n```\nIf you work with primitive values or classes (not interfaces) @inject annotations are not needed:\nts\n@injectable()\nclass A {\n    public c: number;\n    constructor(a: number, b: number) {\n         this.c = a + b;\n    }\n}\nThe problem is that a and b are the same type so the same value will be injected unless you declare a constraint:\n```ts\nkernel.bind(\"Number\").toConstantValue(5).when((request: interfaces.Request) => {\n    return request.target.name.equals(\"a\");\n});\nkernel.bind(\"Number\").toConstantValue(5).when((request: interfaces.Request) => {\n    return request.target.name.equals(\"b\");\n});\n```\n. ```ts\nkernel.bind(\"Number\").toConstantValue(5).when((request: interfaces.Request) => {\n// access kernel\nlet x = request.parentContext.container.get<any>(\"SOME_ID\");\n\nreturn request.target.name.equals(\"a\");\n\n});\n.ts\nimport \"reflect-metadata\";\nimport { Container, injectable, inject } from \"inversify\";\ninterface IWorldConfig {\n    worldWidth: number;\n    worldHeight: number;\n}\ninterface ISectorMonitorConfig {\n    sectorWidth: number;\n    sectorHeight: number;\n}\nclass ConfigType {\n    public static WorldConfig: symbol = Symbol.for('WorldConfig');\n    public static SectorMonitorConfig: symbol = Symbol.for('SectorMonitorConfig');\n}\n@injectable()\nclass SectorMonitor {\n    constructor(@inject(ConfigType.SectorMonitorConfig) config: ISectorMonitorConfig ){\n        console.log( config.sectorWidth, config.sectorHeight );\n    }\n}\nlet container = new Container();\ncontainer.bind(ConfigType.WorldConfig).toConstantValue({ worldWidth: 10, worldHeight: 10 });\ncontainer.bind(ConfigType.SectorMonitorConfig).toDynamicValue((context) => {\n    let worldConfig = context.container.get(ConfigType.WorldConfig);\n    return {\n       sectorWidth: worldConfig.worldWidth,\n       sectorHeight: worldConfig.worldHeight\n   }\n}).inSingletonScope();\ncontainer.bind(SectorMonitor).toSelf();\ncontainer.get(SectorMonitor); // 10 10\n```\nDynamic values, factories and providers have access to the context which allow you to resolve other dependencies.. Thanks for the prosal \ud83d\udc4d  @acopalipsis solution is a good workaround. There are two workarounds at the moment:\n\nUse one kernel for test and one kernel for app\nUse kernel modules (kernel modules can load and unload groups of bindings)\n\nAnyway this feature will be implemented in the future. It is likely to be released in the upcoming 3.1 release.\n. I'm not sure about fully understanding what do you need but I will try. I think you are asking for a new method getNamedConstructor ?\nIf that is the case, that method is not needed because you can do the following:\nFirst use toConstructor to declare some bindings:\nts\ncontainer.bind<X>(\"X\").toConstructor(X).whenTargetNamed(customNodeNameA);\ncontainer.bind<X>(\"X\").toConstructor(X).whenTargetNamed(customNodeNameB);\nThen use getNamed to get the constuctor:\n```ts\n bind(ServiceIdentifiers['Factory'])\n        .toFactory((context: interfaces.Context) => {\n            let cachedOptions: IOptions;\n        return (customNodeName: CustomNodes) => {\n            if (!cachedOptions) {\n                cachedOptions = context.container.get<IOptions>('IOptions');\n            }\n            let Constructor = container.getNamed<X>(\"X\", customNodeName);\n            return new Constructor(cachedOptions);\n        };\n    });\n\n``. You can usetoDynamicValue+inSingletonScope`:\n```ts\nimport { interfaces, Container } from \"inversify\";\ninterface Config {\n    name: string;\n}\nlet container = new Container();\nfunction provider( context: interfaces.Context ): any {\n    let { name } = context.container.get( Symbol.for( 'config' ) );\n    return { name };\n}\ncontainer.bind(Symbol.for('config')).toConstantValue({ name: \"config\" });\ncontainer.bind(Symbol.for('provider')).toDynamicValue(provider).inSingletonScope(); // !!!\nlet a = container.get(Symbol.for('provider'));\nlet b = container.get(Symbol.for('provider'));\nconsole.log(a === b); // to be true!\n```. Done by https://github.com/inversify/InversifyJS/pull/461. Need to fix failing tests:\nProperty Injection\n    1) Should be able to inject a property\n    2) Should be able to inject a property combined with constructor injection\n    3) Should be able to inject a named property\n    4) Should be able to inject a tagged property\n    5) Should be able to multi-inject a property\n    6) Should be able to inject a property in a base class. If you are planning to use ES6 we have https://github.com/inversify/inversify-vanillajs-helpers \ud83d\ude09 . There are no decorators because babel decorators and typescript decorators are not compatible \ud83d\ude2d this will be fixed in a few months when the T39 finish the decorator standard. Also we created the helpers not only for babel users but also for ES5 users.. Done by https://github.com/inversify/InversifyJS/pull/461. Done by https://github.com/inversify/InversifyJS/pull/461. The decorators @Controller('/') and @Get('/') use the domain as base path.\n| Controller  | Method  | Decorators  | Path |\n|---|---|---|---|\n| /  |  GET | @Controller(\"/\") and Get(\"/\")  |  http://cms.example.com/  |\n| /  | GET  | @Controller(\"/\") and  Get(\"/\")  | http://cms.localhost/ |\n| /users  |  GET | @Controller(\"/users\") and Get(\"/\")  |  http://cms.example.com/users  |\n| /users  | GET  | @Controller(\"/users\") and Get(\"/\")  | http://cms.localhost/users |\nAs you can see the domain name should not affect the controllers and method decorators.\nMay @CoderAjay or @lholznagel can help?\n. Thanks for the help @lholznagel \ud83d\udc4d \n@hkarimpoor what do you want to achieve? Invoke a different controller or method based on the domain? Would this https://www.npmjs.com/package/express-subdomain work for you? If that middleware works we can add a change so you will be able to use it.\n. @hkarimpoor can you confirm that https://www.npmjs.com/package/express-subdomain could be an option for you? if it would work I can try to implement a fix so you can use it.... There is no way to catch this at compilation time but I have added a validation check that will be included in the release.\nIt will throw the following:\n\nThe toSelf function can only be applied when a constructor is used as service identifier. Thanks for the PR \ud83d\udc4d . Done by https://github.com/inversify/InversifyJS/pull/461. Hi @Mika56 this has been implemented but it is not available yet. It will be included in the next release. Please refer to https://github.com/inversify/InversifyJS/pull/467 for more details.. https://github.com/travis-ci/travis-ci/issues/7084 is blocking this PR. Hi @LordXaoca thanks for using inversify and for your suggestion \ud83d\udc4d \n\nInstead of sealed bindings we allow you to add and remove bindings. You can remove a binding and then create a new one using container.unbind.\nAt the moment we only allow you to remove all bindings for a given service identifier but there is already an issue to improve this #447. Re-opening issue as the requirement is to allow to invoke unbind from container modules.. I have implemented support for unbind within container modules https://github.com/inversify/InversifyJS/pull/464 It will be released over the next few days. Hi @LordXaoca about:\n\nI don't see any ability to check is there binding exists\n\nI will be solved that problem by providing access to isBound to the modules. I will do this later today. Check out the wiki to learn more.\nI don't want to add sealed bindings for now because there is already a way to achieve the same with: bind, unbind and isBound. I think it gets messy when a library offers many ways to do something. At the same time I listen to the user's feedback and I really appreciate your feedback. If more users mention the need for this I will implement it.\n. Hi @mertdeg thanks for the PR sorry but we already fixed this issue but it has not been released until tonight. The version 3.0.0-rc.4 has been released just now should solve this problem for you.. Hi @endel can you please try with 3.0.0-rc.4? . For the moment the recommended solution is using:\n\nStable 0.1.8 + 2.0.1.\nLatest 0.1.0 + 3.0.0-rc.4.\n\nThe 3.0.0-rc.4 release will become 3.0.0 very soon.\nHi @fdnhkj  inversifyJS doesn't have reflect-metadata in its dependencies because it is a polyfill. At some point, some JS engines will not require it so it is an optional dependency.. inversify@3.0.0 has now been released and it works with reflect-metadata@0.1.9. This should be already fixed in 3.0.0-rc.4 can you please confirm?. This should be already fixed in 3.0.0-rc.4 can you please confirm? If you are using inversify@2.X.X you will need reflect-metadata@0.1.8 instead of reflect-metadata@0.1.9.. \ud83d\udc4d thanks for this suggestion. Sorry for the late reply I was on holidays... I will try to do something about this and share my plans here soon.... Done by https://github.com/inversify/InversifyJS/pull/477. Thanks for this suggestion. Sorry for the late reply I was on holidays... I need to think about this for a few day. I will let you know my thoughts ASAP \ud83d\ude04 . \ud83d\udc4d thanks for this PR.  A provider is asynchronous so there is no other way. It sounds to me like you want to execute asynchronous code as if it was synchronous but that is not a good practice. An option is to fetch that data before InversifyJS is initialized. Once you have fetched the data you can create a binding with toConstantValue. It sounds to me like this is the right solution because you mentioned:\n\nAlmost all the other modules require this config. \n\nThis is an indicator of the config being almost like a global. It makes sense to fetch it before the app starts running.. :+1: I'm happy to accept a PR for this. Here are some recommendations for your PR:\n\n\nThe Router instance should be a property of the InversifyExpressServer class\n\n\nThe class constructor should allow users to optionally pass a custom router instance:\nts\nconstructor(container: inversify.interfaces.Container, router?: express.Router) {\n    this.container = container;\n    this.router = router || express.Router();\n}\n\n\nThanks a lot for contributing :smile: . > Note: this feature will also fix https://github.com/inversify/InversifyJS/issues/456. Hello, sorry for the late reply on this.. I've been very busy but this weekend I was able to implement and release this feature:\n```ts\nlet container = new Container();\nlet router = express.Router({\n    caseSensitive: false,\n    mergeParams: false,\n    strict: false\n});\nlet server = new InversifyExpressServer(container, router);\n```\nThis feature is available at inversify-express-utils@3.1.0. \ud83d\udc4d  Thanks for the PR. Hi @JonathanYates, sorry for the late reply. The recipe that you found is the recommended way. Inversify is heavily driven by metadata and at the moment decorators can only be applied to classes. In the future, they may be applied to functions and we will revisit how injecting into functions might work.. Done by 286d20377ee1730a7a437b5c0453aa6b48832305. The correct to pass some state from redux to a react component is using the connect function from the npm module react-redux. Connected components are considered smart components. \nLibertad is an experiment that I have not been able to complete due to lack of free time \ud83d\ude22 \nIf you want to pass the store to a component without using connect you could use inversify-inject-decorators. It will allow you to inject the store as a property:\n```ts\nimport getDecorators from \"inversify-inject-decorators\";\nimport { Container } from \"inversify\";\nimport { MLSStore } from \"./store\";\nlet container = new Container();\nlet { lazyInject } = getDecorators(container);\ncontainer.bind(\"MLSStore\").to(MLSStore);\nexport { lazyInject };\n```\n```ts\nimport * as React from \"react\";\nimport { lazyInject } from \"./ioc\";\nclass Hello extends React.Component<{}, {}> {\n@lazyInject('MLSStore')\nprivate MLSStore;\n\nconstructor() {\n    super();\n    console.log('sa ', this.MLSStore);\n\n    this.MLSStore.subscribe((newState) => {\n        console.log('redux state changed ', newState);\n    })\n}\n\nrender() {\n    return <h1>Hello from component!</h1>;\n}\n\n}\n```\nI recommend reading http://blog.wolksoftware.com/dependency-injection-in-react-powered-inversifyjs to understand why react doesn't play nicely with constructor injection.\nHope this helps \ud83d\ude09 . Hi guys, let me see if I understand the issue correctly. At the moment you write:\n```ts\ncontainer.unbind(\"IHttpClient\");\ncontainer.bind(\"HttpClient\")\n    .to(HttpClient)\n    .inSingletonScope()\n    .whenInjectedInto(AuthHttpClient);\ncontainer.bind(\"IHttpClient\")\n    .to(AuthHttpClient)\n    .inSingletonScope();\n```\nBut you only want to override the IHttpClient binding:\nts\ncontainer.bind<IHttpClient>(\"IHttpClient\")\n    .to(AuthHttpClient)\n    .inSingletonScope()\nIs that correct?. I'm considering adding a new Container method named rebind:\nts\ncontainer.rebind<IHttpClient>(\"IHttpClient\")\n    .to(AuthHttpClient)\n    .inSingletonScope();\nIt could also be used from a module:\n```ts\nlet someModule = new ContainerModule((bind, unbind, rebind) => {\n    rebind(\"IHttpClient\")\n        .to(AuthHttpClient)\n        .inSingletonScope();\n});\ncontainer.load(someModule);\n```\nThe only limitation is that if multiple bindings are available for one service identifier (e.g. \"IHttpClient\") they will be all removed and replace by one single binding. So rebind will not support contextual constraints and multi injections.\nMaybe in future improvements, rebind will support named and tagged constraints. But we need to implement this first.\n. This is now available in 3.1.0. \ud83d\udc4d thanks for the PR. \ud83d\udc4d . Hi, thanks for this feature request. I believe this has been discussed in the past but I can't remember it :cry: . Let see if other members of the team can remember it...\nCan you guys please review @codyjs @lholznagel thanks :+1: . @maxmalov would you like to contribute this feature? I also think that it is a good idea \ud83d\udc4d \nI'm only wondering one thing... \nAt the moment you can pass middleware as:\nts\n@Controller(path, [middleware, ...])\n// or\n@Method(method, path, [middleware, ...])\n// or\n@SHORTCUT(path, [middleware, ...])\nMore info here.\nI was wondering if we need:\nA\nAn extra @ Middleware decorator:\nts\n@Controller(\"/\")\n@Middleware(Constants.AuthorizeMiddleware)\nclass MyController {\n// ...\nB\nOr if we should allow serviceIdentifiers to be passed to the existing decorators:\nts\n@Controller(\"/\", Constants.AuthorizeMiddleware)\nclass MyController {\n// ...\nA service identifier can be a class constructor function, a string or a Symbol and the middleware is a function. This means that detecting if the argument passes is a serviceIdentifier or a middleware is not straight forward but it is not impossible.\nI think option A will be easier to implement. Should we call the decorator @Middleware or @InjectMiddleware?\nWhat do you guys think?\n. I'm going to separate your comments in two features.\nA) Being able to stub middleware during testing\nIf your controller looks as follows:\n```ts\nlet TYPE = {\n    AuthorizeMiddleware: Symbol(\"AuthorizeMiddleware\"),\n    AllowAnonymousMiddleware: Symbol(\"AllowAnonymousMiddleware\")\n};\n@injectable()\n@Controller(\"/\")\n@Middleware(TYPE.AuthorizeMiddleware)\nclass MyController {\n@Post(\"/\")\n  public create() {\n      // ...\n  }\n@Get(\"/\")\n  @Middleware(TYPE.AllowAnonymousMiddleware)\n  public get() {\n      // ...\n  }\n}\n```\nAnd your middleware doesn't have dependencies:\n```ts\nlet AuthorizeMiddleware = (req, res) => {\n    // ...\n};\nlet AllowAnonymousMiddleware = (req, res) => {\n    // ...\n};\n```\nDeclaring the bindings should be fine:\n```ts\nlet container = new Container();\ncontainer.bind(TYPE.AuthorizeMiddleware)\n         .toConstantValue(AuthorizeMiddleware);\ncontainer.bind(TYPE.AllowAnonymousMiddleware)\n         .toConstantValue(AllowAnonymousMiddleware);\ncontainer.bind(TYPE.Controller)\n         .to(MyController)\n         .whenTargetNamed(\"MyController\");\n```\nAt the moment it is not possible to stub the middleware because we hard code a reference to the middleware:\nts\n@Controller(\"/\", AuthorizeMiddleware)\nBut the @Middleware decorator will allow use to hard code a reference to an identifier of the middleware (not the middleware itself):\nts\n@Controller(\"/\")\n@Middleware(TYPE.AuthorizeMiddleware)\nThis will allow you to stub your middleware when testing. All you would need to do is to use different bindings for TYPE.AuthorizeMiddleware and TYPE.AllowAnonymousMiddleware during testing:\n```ts\ncontainer.bind(TYPE.AuthorizeMiddleware)\n         .toConstantValue(function mock(req, res) {\n              // ...\n         });\ncontainer.bind(TYPE.AllowAnonymousMiddleware)\n         .toConstantValue(function mock(req, res) {\n              // ...\n         });\n```\nB) Being able to inject entities to middleware\nLet's imagine that you have the same controller:\n```ts\nlet TYPE = {\n    AuthorizeMiddleware: Symbol(\"AuthorizeMiddleware\"),\n    AllowAnonymousMiddleware: Symbol(\"AllowAnonymousMiddleware\")\n};\n@injectable()\n@Controller(\"/\")\n@Middleware(TYPE.AuthorizeMiddleware)\nclass MyController {\n@Post(\"/\")\n  public create() {\n      // ...\n  }\n@Get(\"/\")\n  @Middleware(TYPE.AllowAnonymousMiddleware)\n  public get() {\n      // ...\n  }\n}\n```\nBut this time the middleware requires a service to be injected:\n```ts\nlet authorizeMiddlewareFactory = (authService) =>{\n    return function authorizeMiddleware(req, res) => {\n         // Use authService here...\n    }\n};\nlet AllowAnonymousMiddleware = (req, res) => {\n    // ...\n};\n```\nThe solution you suggested would work but requires a lot of code. I would try with toDynamicValue:\n```ts\nlet container = new Container();\ncontainer.bind(TYPE.AutService).to(AutService);\ncontainer.bind(TYPE.AuthorizeMiddleware)\n         .toDynamicValue((context: interfaces.Context) => {\n             let authService = context.container.get(TYPE.AutService);\n             return authorizeMiddlewareFactory(authService);\n         });\ncontainer.bind(TYPE.AllowAnonymousMiddleware)\n         .toConstantValue(AllowAnonymousMiddleware);\ncontainer.bind(TYPE.Controller)\n         .to(MyController)\n         .whenTargetNamed(\"MyController\");\n```\nIf your middleware has more than one dependency:\n```ts\ncontainer.bind(TYPE.AuthorizeMiddleware)\n         .toDynamicValue((context: interfaces.Context) => {\n             let authService = context.container.get(TYPE.AutService);\n             let logginService = context.container.get(TYPE.LogginService);\n             return authorizeMiddlewareFactory(authService, logginService);\n         });\n```\nIt will start becoming ugly. In general, if you see container.get multiple times in your code you should consider it a code smell.\nYou could create a small helper to solve this problem:\nts\nfunction bindMiddleware(container, middlewareId, middlewareFactory, dependencies) {\n    container.bind<AuthorizeMiddleware>(TYPE.AuthorizeMiddleware)\n                   .toDynamicValue((context: interfaces.Context) => {\n                       let injections = dependencies.map((dependency) => {\n                           context.container.get(dependency);\n                       });\n                       return middlewareFactory(...injections);\n                  });\n}\nYou could then use this helper as follows:\n```ts\nlet authorizeMiddlewareFactory = (authService, logginService) =>{\n    return function authorizeMiddleware(req, res) => {\n         // Use authService & logginService here...\n    }\n};\nbindMiddleware(\n    container,\n    TYPE.AuthorizeMiddleware,\n    authorizeMiddlewareFactory,\n    [TYPE.AutService, TYPE.LogginService]\n);\n```\nI think this is something we could document in the recipes but not something that should be part of the framework. The main problem here is that we are dealing with functions not with classes and we can't use decorators on functions. I saw online that there are conversations about adding decorator support for functions but we need to wait until there is more clarity on that...\nIf you want this helper (or something similar) to become a npm module you can always release it yourself.\nSummary\n\nA) We need to implement @Middleware\nB) Once A has been implemented you will be able to use the helper described above.\n\nThe @Middleware decorator needs to be implemented using additional metadata here. This is not really a beginner feature so if you want to implement it I can try to do some analysis and comment here how I would implement it. I fyou think that it is too complex we will implement it and you can always help us to test if it solves your issue. Testing is also a very valuable contribution :+1: . Hi @maxmalov thanks a lot for your work :+1: it looks very good. I like more option one. I only spotted one important required change. The Middleware interface needs to use the ServiceIdentifier<T> interface from inversify then you can removed the MiddlewareIdentifier interface:\n```ts\nimport { interfaces } express from \"inversify\";\nexport type Middleware = (interfaces.ServiceIdentifier | express.RequestHandler);\n```. Hi @mitjarogl at the moment I don't have time because I'm writing a book after working hours. If you want to send a PR I will be happy to merge it. In Express it was implemented by https://github.com/inversify/inversify-express-utils/pull/35 you can use it as reference.. Hi, I think the key point is:\n\nwithout relying on annotations\n\nWhen you don't use annotations you need to generate additional metadata. For example, constructor injections that use classes as types need to be manually annotated. \nMy guess is that you forgot one of those annotations.\nHowever, we want inversify to provide developers with a nice user experience and one of the ways we do it is by providing nice error descriptions. I don't consider:\n\nError: Cannot read property 'name' of undefined\n\nA user-friendly error and I want to fix it. Can you please help us by providing a small piece of code that can reproduce the issue?\nIt will help us a lot to accelerate the patching process.\nThanks!\n. I have tried to reproduce your problem without success because the following file is missing:\n\nimport protobufMeta from \"./Protobuf\";\n\n. @sebastian-zarzycki-es sorry for the late reply. This is going well, I expect to release it during the weekend. Once I release it I will need your help to confirm that it solves your problem.. After doing some investigation it turns out that no changes were required to the lib. I was doing it wrong:\n\nts\nInversify.decorate(lazyInject(TYPES.SomeDependency), MyComponent, \"_someProperty\");\n\nShould have been:\nts\nlazyInject(TYPES.SomeDependency)(MyComponent.prototype, \"_someProperty\");\nHere is a full example:\n```js\nvar Inversify = require(\"inversify\");\nvar getDecorators = require(\"inversify-inject-decorators\").default;\nvar helpers = require(\"inversify-vanillajs-helpers\").helpers;\nrequire(\"reflect-metadata\");\nvar TYPES = {\n    SomeComponent: \"SomeComponent\",\n    SomeDependency: \"SomeDependency\"\n};\nclass MyComponent {\n    constructor() {\n        this._someProperty; // declare it this way or it won't work :(\n    }\n    render() {\n        return this._someProperty.doSomething();\n    }\n}\nvar myContainer = new Inversify.Container();\nvar lazyInject = getDecorators(myContainer).lazyInject;\nhelpers.annotate(MyComponent, []); // required because inversify invokes \"new\"\nlazyInject(TYPES.SomeDependency)(MyComponent.prototype, \"_someProperty\");\nmyContainer.bind(TYPES.SomeDependency).toConstantValue({\n    doSomething: function () {\n        return \"something\";\n    }\n});\nmyContainer.bind(TYPES.SomeComponent).to(MyComponent);\nvar component = myContainer.get(TYPES.SomeComponent); // inversify invokes \"new\"\nconsole.log(component.render());\n```\nIn the case of React the component instance is not created by Inversify and the test case is a bit different:\n```js\nvar Inversify = require(\"inversify\");\nvar getDecorators = require(\"inversify-inject-decorators\").default;\nvar helpers = require(\"inversify-vanillajs-helpers\").helpers;\nrequire(\"reflect-metadata\");\nvar TYPES = {\n    SomeComponent: \"SomeComponent\",\n    SomeDependency: \"SomeDependency\"\n};\nclass MyComponent {\n    constructor(props) {\n        this.props = props;\n        this._someProperty; // declare it this way or it won't work :(\n    }\n    render() {\n        return this._someProperty.doSomething();\n    }\n}\nvar myContainer = new Inversify.Container();\nvar lazyInject = getDecorators(myContainer).lazyInject;\n// helpers.annotate(MyComponent, []); Not required because we invoke \"new\"\nlazyInject(TYPES.SomeDependency)(MyComponent.prototype, \"_someProperty\");\nmyContainer.bind(TYPES.SomeDependency).toConstantValue({\n    doSomething: function () {\n        return \"something\";\n    }\n});\nmyContainer.bind(TYPES.SomeComponent).to(MyComponent);\nvar component = new MyComponent({ prop1: \"prop1\" }); // we invoke \"new\"\nconsole.log(component.render());\nconsole.log(component.props.prop1);\n```\nI have added both test cases to the inversify-vanillajs-helpers unit tests.\nI would recommend creating a small helper:\n```ts\nfunction lazyInjectHelper(type: any, clss: any, prop: string) {\n    lazyInject(type)(clss.prototype, prop);\n}\nlazyInjectHelper(TYPES.SomeDependency, MyComponent, \"_someProperty\");\n```. You probably want to add something to your source code to let other developers that the class has a property. You would probably use:\nts\nthis._someProperty = null;\nBut that causes the lazy injection to fail so I recommend using the following instead:\nts\nthis._someProperty;\nAbout your original question:\n\nThere's no example using ES6 decorators or injecting property by name, not by index.\n\nIt can be achieved using the following:\nts\nlazyInject(TYPES.SomeDependency)(MyComponent.prototype, \"_someProperty\");\nYou could create babel decorator that invokes that under the hood. Or if you are not using decorators ar all just use a function:\n```ts\nfunction lazyInjectHelper(type: any, clss: any, prop: string) {\n    lazyInject(type)(clss.prototype, prop);\n}\nlazyInjectHelper(TYPES.SomeDependency, MyComponent, \"someProperty\");\n`` . Underscore` is used as a naming convention to indicate that a property is mean to be private. \nDecorators are just functions:\nts\nfunction lazyInject(id) {\n    return function (proto, prop) {\n        // do something ...\n    }\n}\nYou can invoke them using @lazyInject(TYPE.SomeDependency) and the TypeScript compiler will generate some code that calls it as:\nts\nlazyInject(TYPES.SomeDependency)(MyComponent.prototype, \"_someProperty\");\nThis means that if you are not using TypeScript you can just call it as a function. Just like the code generated by the TypeScript compiler.\nThere was a change in the decorator proposal and the TypeScript decorators are not compatible with the babel ones. At some point they will be the same but TypeScript needs to do an update. I don't know the details because I don't use babel but I'm sure there is info online... So if you want to use a decorator using the @ syntax you will need to write a babel compatible decorator (function).\nDoes that make sense?\n. Are you using babel? I can try to investigate this evening. Won't promise I will figure out but I can try to help.. We define  a custom getter and setter. @observable probably do the same and that is why they are incompatible :(\nI know there are project using mobx with React and inversify but they use TypeScript and they don't mix lazyInject with @observable. For example dwatch uses lazyInject as you can see here.. As you can see in the Dwatch source code they use it as a decorator and I know that some people have used inversify with babel. I'm sorry I'm not experienced with Babel maybe @lholznagel can help? If not I suggest you ask some of the members of the Babel community.. @lholznagel thanks for taking a look :+1: \n. Hi @jamesrichford feel free to comment if you see anything ugly \ud83d\ude09 . Sorry but this doesn't align with our project goals. I want to deliver a great developer experience and I believe that TypeScript delivers a superior developer experience. The TypeScript compiler can generate metadata that other way would have to be declared manually. Also, TypeScript helps thanks to its amazing IDE support. Just like the just main language in Angular is TypeScript we also target TypeScript as our main language and we actively encourage to adopt it. \nIt is also important to mention that we are happy to help and support those who don't choose TypeScript as well.. Hi, thanks for reporting your issue. There is a solution for this problem already documented on the wiki. Please refer to the section \"What can I do when my base class is provided by a third party module?\".. Hi @agalazis thanks for reporting this issue. Can you please provide some minimal source code to reproduce the issue?. Hi @agalazis I've been working on a fix for a few days already. It is a tricky bug \ud83d\ude04 I have been able to fix ti but it breaks some of the tests cases related to the usage of abstract classes. If I have to reach a compromise I prefer to support the spread operator than supporting advance errors in abstract classes. I guess most people will prefer this as well. Should have an update soon.. I just created a PR and it includes some documentation. Things have improved a bit but sadly the spread operator is not a recommended option. Please refer to the new section in the docs to learn more.. I'm not 100% sure but I think it was required because it was needed for promises or weak map I can't remember but there was something that was needed :( if you remove it, do you get errors? Feel free to try to remove it from our docs and config https://github.com/inversify/InversifyJS/blob/master/tsconfig.json#L4 and send a PR the CI servers will let us know if it is really needed :). So I finally got some free time to check this out and \"dom\" is not required \ud83d\udc4d . You should be able to use toConstantValue:\n```ts\nimport { Container } \"inversify\";\nimport * as $ from \"jquery\";\nconst container = new Container();\ncontainer.bind(\"JQuery\").toConstantValue($);\nexport { container };\n```\n```ts\nimport { container } from \"inversify\";\nconst $ = container.get(\"JQuery\");\n```\nPlease let me know if this issue can be closed.\n. Hi, thanks for sharing your feedback with us :+1:  \nI'm programming languages like Java or C# we are able to use reflection to explore the types in an assembly or DLL. We can then automatically generate the bindings. Unfortunately, in JavaScript we don't have a reflection mechanism as powerful and therefore all we can do is to create some utilities and helpers like the inversify-binding-decorators. \nThe highest level of auto-registration that we can provide is the auto-provice utility.\nI'm closing this issue. Feel free to add a comment if you have any additional questions.\nps @Dirrk thanks for helping here . @Dirrk would you like to send a PR with this update? Could be a nice and easy PR \ud83d\ude04 . Thanks a lot \ud83d\udc4d . @Dirrk thanks a lot for the PR \ud83d\udc4d . I think this is  possible and I also think it is a good idea :+1: I will investigate more this evening but right now I'm thinking the following:\nIn InversifyJS we use the decorators to generate metadata then we use reflection_utils.ts to read that metadata.\nThe reflection utils code is not very plugable and it is hard coded to use Reflect.getMetadata at the moment. \nWe could refactor the reflection utils code into something that consumes a new interface named MetadataReader. \nInversifyJS will use a class by default: \nts\nReflectMetadataReader implements MetadataReader {\n   // ...\n}\nWe can allow users to provide their own implementations of MetadataReader:\nts\nconstainer.applyCustomMetadataReader(myStaticMethodMetadataReader);\nInversify will continue to validate that there is no missing metadata as it does right now. The only thing that we are changing is the source of the metadata.. Hi guys, this is nearly implemented now. You can follow the process at https://github.com/inversify/InversifyJS/pull/507 I'm hoping to release this this weekend :smile: . I just released inversify@3.2.0 which has support for this feature. I have added some unit tests:\nhttps://github.com/inversify/InversifyJS/blob/master/test/features/metadata_reader.test.ts\nAnd some info in the docs:\nhttps://github.com/inversify/InversifyJS/blob/master/wiki/middleware.md#custom-metadata-reader. @rulai-hu was this feature useful for you? Did you manage to resolve your use case?. Thanks for your feedback :+1: I will review this during the weekend :). I have started to work on this I only have one question so far. If you look at the unity example, they resolve ManagementController and that has a dependency on ITenantStore. There are no bindings for ManagementController but there is a binding for ITenantStore this makes sense because it would be very complicated (if not impossible) to resolve all the sub-dependencies without bindings.\nI can implement container.resolve but I'm afraid it will only be able to resolve the root dependency. I don't know if this works in your plugin scenario? For plugin scenarios one option could be using multiple container modules or multiple child containers.. This has now been implemented by PR #512 and is available in the inversify@3.3.0 release (should be available over the next hour or so...). Thanks a lot for sharing your feedback with us \ud83d\udc4d . :+1: We support transient and singleton but we support contextual constraints which most DI libs for JS don't.. Sorry I was unable to release yesterday. I will try this evening again. I'm finishing a new feature int he core lib.... I have released inversify-express-utils@3.3.0 & inversify@3.2.0 \ud83c\udf89  I'm closing this issue.. Hi @lholznagel thanks a lot for your help here :) @khorvat  can this issue be closed?. Thanks a lot for this PR :+1: . We need to add a feature for this. We have already an issue https://github.com/inversify/InversifyJS/issues/489. Please keep en eye on that issue to find the implementation progress.. I'm afraid that because React only works with @lazyInject and you are using babel this issue is a blocker. There is no way to get around it for now. I will try to implement that feature for you. I was going to pick a couple of tasks from the backlog this week so I will pick #489 first. I'm sorry but that is the best I can do to help you at the moment.. As far as I know this is a limitation of JavaScript. I want to implement something custom scopes that will allow users to have more control over when a class is created but we will still not be able to know when it is garbage collected.. No worries :wink: . Thanks for the long post, it was required to explain your concerns :+1: I think your main concern is:\n\nThere is an OPTIONAL argument of IServerOptions type, a single INTERFACE. So I go to the Inversify documentation and found that I can use @decorated(), ok I try but this annotation only accept class types, no an Interface like in this case... \n\nThe problem is that you have annotated your HapiServer class:\nts\n@injectable()\nexport class HapiServer extends Hapi.Server {\n// ...\nBut you are not the owner of the source code of the Hapi.Server class and you cannot decorate it as follows:\nts\n@injectable()\nclass Server extends Events.EventEmitter {\n  constructor(@unmanaged() options?: IServerOptions);\n  ...\n}\nBut you should be able to use the decorate helper in this case:\n```ts\nimport { decorate, injectable, unmanaged } from \"inversify\";\nimport * as Hapi from \"hapi\";\ndecorate(injectable(), Hapi.Server);\ndecorate(unmanaged(), Hapi.Server, 1);\n```\nI haven't tried this but it should work. Please let me know how do you get on.\nps: more info about decorate().\n. Sorry about this issue. I will investigate ASAP will try to build something with Hapi to see if I can reproduce the issue.. Ok, so I've been researching this and I found an alternative way. It looks like there is something inside Hapi.Server which makes it complicated to create instances of it using inversify. After trying a few different ways I found one that I feel is not too bad using a factory. I will copy all the source code files here:\ninterfaces.ts\n```ts\nimport { Server } from 'hapi';\nexport interface IServerConfiguration {\n  port: number;\n}\nexport interface IConfigurationManager {\n  getServerConfig(): IServerConfiguration;\n}\nexport interface IServerFactory {\n  create(): Server;\n}\n```\ntypes.ts\nts\nexport const TYPES = {\n    IServerFactory: \"IServerFactory\",\n    IConfigurationManager: \"IConfigurationManager\"\n};\nconfig.ts\n```ts\nimport { IServerConfiguration } from \"./interfaces\";\nimport { injectable } from \"inversify\";\n@injectable()\nexport class Configuration {\n    getServerConfig(): IServerConfiguration {\n        return {\n            port: 8080\n        };\n    }\n}\n```\nserver_factory.ts\n```ts\nimport { interfaces, injectable, inject } from \"inversify\";\nimport { Server } from 'hapi';\nimport { TYPES } from \"./types\";\nimport { IServerConfiguration, IConfigurationManager, IServerFactory } from \"./interfaces\";\n@injectable()\nexport class ServerFactory implements IServerFactory {\nprivate _serverConfig: IServerConfiguration;\npublic constructor(\n    @inject(TYPES.IConfigurationManager) config: IConfigurationManager\n  ) {\n    this._serverConfig = config.getServerConfig();\n  }\npublic create() {\n      const instance = new Server();\n      instance.connection({\n        port: this._serverConfig.port,\n        routes: {\n          cors: false\n        }\n      });\n      return instance;\n  }\n}\n```\ninversify.config.ts\n```ts\nimport { Server } from 'hapi';\nimport { Container } from 'inversify';\nimport { Configuration } from \"./config\";\nimport { IConfigurationManager, IServerFactory } from \"./interfaces\";\nimport { TYPES } from \"./types\";\nimport { ServerFactory } from \"./server_factory\";\nexport class Kernel extends Container {\n  constructor() {\n    super();\n    this.declareDependencies();\n  }\ndeclareDependencies() {\n    this.bind(TYPES.IConfigurationManager).to(Configuration);\n    this.bind(TYPES.IServerFactory).to(ServerFactory);\n  }\n}\n```\nindex.ts\n```ts\nimport \"reflect-metadata\";\nimport { interfaces } from \"inversify\";\nimport { Server } from \"hapi\";\nimport { Kernel } from './inversify.config';\nimport { TYPES } from \"./types\";\nimport { IServerFactory } from \"./interfaces\";\nconst iocKernel = new Kernel();\nconst serverFactory = iocKernel.get(TYPES.IServerFactory);\nconst server = serverFactory.create();\nserver.start((err) => {\n    if (err) {\n      console.error(err);\n    }\n    console.log('Server running at:', server.info.uri);\n});\n```\nI hope you find this solution better than the original one.\n. You are right the only way is to use a factory (with toFactory()) and when your factory becomes too complex you need to create your own factory class:\n```ts\nimport \"reflect-metadata\";\nimport { interfaces, injectable, inject, Container } from \"inversify\";\n@injectable()\nclass Logger {\n    log(message) {\n        console.log(message);\n    }\n}\n@injectable()\nclass User {\n    @inject(Logger) private logger: Logger;\n    public name: string;\n}\n@injectable()\nclass UseFactory {\n    @inject(Logger) private logger: Logger;\n    @inject(\"UserConstructor\") private User: { new(): User };\n    public create(name: string) {\n        this.logger.log(\"Creating user instance...\");\n        const user = new this.User();\n        user.name = name;\n        return user;\n    }\n}\nvar container = new Container();\ncontainer.bind(Logger).toSelf();\ncontainer.bind<{ new(): User }>(\"UserConstructor\").toConstructor(User);\ncontainer.bind(UseFactory).toSelf();\nvar useFactory = container.get(UseFactory);\nlet user = useFactory.create(\"John\");\nconsole.log(user.name); // \"John\"\n```\nI hope this solves your issue. I'm closing this issue but please feel free to use the comments if you need additional help.. You can do it manually or you could use lazyInject:\n```ts\nimport \"reflect-metadata\";\nimport { interfaces, injectable, inject, Container } from \"inversify\";\nimport getDecorators from \"inversify-inject-decorators\";\nvar container = new Container();\nlet { lazyInject } = getDecorators(container);\n@injectable()\nclass Logger {\n    log(message) {\n        console.log(message);\n    }\n}\n@injectable()\nclass User {\n    @lazyInject(Logger) private logger: Logger; // here!\n    public name: string;\n}\n@injectable()\nclass UseFactory {\n    @inject(Logger) private logger: Logger;\n    @inject(\"UserConstructor\") private User: { new(): User };\n    public create(name: string) {\n        this.logger.log(\"Creating user instance...\");\n        const user = new this.User();\n        user.name = name;\n        user.logger.log(\"User created!\");\n        return user;\n    }\n}\ncontainer.bind(Logger).toSelf();\ncontainer.bind<{ new(): User }>(\"UserConstructor\").toConstructor(User);\ncontainer.bind(UseFactory).toSelf();\nvar useFactory = container.get(UseFactory);\nlet user = useFactory.create(\"John\");\nconsole.log(user.name); // \"John\"\n```\nI know manually is more work but I would recommend it over lazyInject because I believe is easier to follow the source code.. Hi, @AltekkeE thanks a lot for this suggestion. I would be happy to accept a PR for this features. A few months ago we wanted to start a project that provided something like that but due to lack of time, we never implemented it. I will await your PR \ud83d\udc4d . I have merged the PR so I'm closing this issue :smile:. We never started but we had a lot of conversations about it https://github.com/CitadelJS. Hi,\nThe error: \n\nThe number of constructor arguments in a derived class be greater than or equal to that of its base class\n\nIs something that we added to ensure that a developer won't forget to pass some arguments to the super constructor. We did this to prevent people from wasting time trying to figure out why some injection was missing. By default, it forces both the derived and super constructors to match but that is just the default behavior. \nWe implemented a decorator named @unmanaged() to allow your use case. In your derived constructor, you are injecting something into the base class via its super constructor. It is important to understand that is injection is done by your code and not by the IoC container. For this reason, we consider this an \"unmanaged\" injection since the injection is not managed by inversify:\n```ts\nimport { unmanaged, injectable } from \"inversify\";\nexport class RepositoryBase implements IRepositoryBase {\n  protected readonly _repository: Repository;\n  constructor(@unmanaged() type: { new (): T; }) { // This injection is not managed by inversify!\n    this._repository = getConnectionManager().get().getRepository(type);\n  }\n}\n@injectable()\nexport class ModeratorRepository extends RepositoryBase implements IModeratorRepository {\n  constructor() {\n      super(Moderator); // injected by the developer not by the IoC container library\n  }\n}\n```\nI'm closing this issue but please use the comments if you need additional info.\nps: I have edited your question check the markdown to see how to format the code. @lholznagel I know but this is an odd one because 3.0 and 4.0 is a breaking change. But the build is successful and the coverage reports are not available :(. @AltekkeE That sounds like a good way to prevent this issue in the future. Thanks for sharing it :+1: . Rolled back to 3.0.1 will wait until gulp-mocha fixes the problems.. You need to decorate both the base and the derived class: BoringConsoleDemoApp extends BaseApp.\nThis means using injectable in BoringConsoleDemoApp and BaseApp. I'm not sure abut your makeInjectable function being invoked for BoringConsoleDemoApp and BaseApp? \nThe error:\n\nError: Missing required @injectable annotation in: BoringConsoleDemoApp.\n\nLooks bad too me, Inversify should be able to tell you that the base class is missing the annotation.\nWill check out to see if there is something wrong with the error generation.. I though that was the way the error worked. I must check it out. Will leave this issue open until I find out.. Closing this issue because I have created an issue that makes more clear how to reproduce the issue.. I have:\nts\n@Delete(authServerPaths.server.roleFeature.endpoints.delete)\n    public async delete(\n        @RequestParam(\"role_id\") roleId: string,\n        @RequestParam(\"feature_id\") featureId: string,\n        @Request() req: express.Request,\n        @Response() res: express.Response\n    ) {\nand authServerPaths.server.roleFeature.endpoints.delete is /role_feature/:role_id/:feature_id.\nI'm debugging and looks like there is something wrong with here. The else is not invoking Reflect.defineMetadata ? I'm trying a few things.... Fixed! these two lines need to be moved out of the if/else :tada: . I think you need a controller with multiple methods and multiple annotations in the arguments, to reproduce the issue one method is not enough.  Did you try that? I released that change and it is working fine at work for me :). I added a test case.  The test case needed to hit this else.\nThe original code was:\nts\nif (!Reflect.hasOwnMetadata(METADATA_KEY.controllerParameter, target.constructor)) {\n    parameterMetadataList.unshift(parameterMetadata);\n    metadataList[methodName] = parameterMetadataList; // !\n    Reflect.defineMetadata(METADATA_KEY.controllerParameter, metadataList, target.constructor); // !\n} else {\n    metadataList = Reflect.getOwnMetadata(METADATA_KEY.controllerParameter, target.constructor);\n    if (metadataList.hasOwnProperty(methodName)) {\n        parameterMetadataList = metadataList[methodName];\n    }\n    parameterMetadataList.unshift(parameterMetadata);\n}\nThe if will generate some metadata thanks to the Reflect.defineMetadata call but the else case is not generating any metadata because it is missing the Reflect.defineMetadata call.\nThe fixed code is:\nts\nif (!Reflect.hasOwnMetadata(METADATA_KEY.controllerParameter, target.constructor)) {\n    parameterMetadataList.unshift(parameterMetadata);\n} else {\n    metadataList = Reflect.getOwnMetadata(METADATA_KEY.controllerParameter, target.constructor);\n    if (metadataList.hasOwnProperty(methodName)) {\n        parameterMetadataList = metadataList[methodName];\n    }\n    parameterMetadataList.unshift(parameterMetadata);\n}\nmetadataList[methodName] = parameterMetadataList; // !\nReflect.defineMetadata(METADATA_KEY.controllerParameter, metadataList, target.constructor); // !. No, problem thanks for your awesome PR :+1: . Hi, I have one question. It is TypedRepo a class or an interface? Inversify requires @inject annotations always if you use interfaces. Annotations are not required if you use classes instead of interfaces. This is due to the way the TypeScript compiler generates metadata.. I will debug a test case to see if we can make it optional but it is likely to not be possible. We had issue with silent errors when using inheritance and we added some rules to ensure that there will never be silent errors. The problems is that those rules make the way inheritance work more restrictive and this seems to be one of those limitations.. So I managed to get some free time to test this during the weekend and I found the problem:\n```ts\n@injectable()\nexport class BLBase implements IBLBase {\n  protected _repository: IRepoBase;\nconstructor(repository: IRepoBase) { // REMOVED @unmanaged()  !!!\n    this._repository = repository;\n  }\n}\n``\nThen you can useextends BLBase` without problems:\nts\n@injectable()\nclass TypedBL extends BLBase<Type> implements ITypedBL {\n  constructor(@inject(TypedRepo) repository: TypedRepo) {\n    super(repository);\n  }\n}\nI have added a test case with some comments here. It should help you to understand better when to use @unmanaged.\n. @ggranum sorry for the very late reply, I think I missed the comment notification somehow... I just saw this because @garkin added a new comment.\nThe annotations are required because we have many use cases and kinds of mistakes:\n\nBase class don't have any dependencies\nDerived class don't have any dependencies\nBoth Base and Derived classes have dependencies\nSometimes users forget the injectable annotation in the Base class.\nSometimes users forget the injectable annotation in the Derived class.\nSometimes users forget an inject annotation in the Base class.\nSometimes users forget an inject annotation in the Derived class.\n\nI tried to create errors to let the users know what was exactly the problem but it was not possible for me to identify the exact problem if only the Derived class was annotated. So we decided that forcing some restrictions in order to achieve better error reporting was a good idea.\n. I'm not 100% sure about your problem but I think what you are trying is:\nts\n@injectable()\nexport class ConfigurationService<T> \n    extends Disposable implements IConfigurationService, IDisposable {\n    constructor(\n        @inject('environmentService') EnvironmentService: IEnvironmentService\n    ) {\n        // Create EnvironmentService by hand?\n        let environmentService = new EnvironmentService(/*...*/, \"\", { /*...*/ });\n        super();\n    }\n   ....\n}\nIf that is the case, then all you need is toConstructor:\nts\ncontainer.bind<IEnvironmentService>(\"IEnvironmentService\")\n         .toConstructor(SettingsTestEnvironmentService);\nPlease refer to the \"Injecting a class constructor\" wiki page for more details.\nDoes this solve your problem? Can the issue be closed?. Nearly there:\nts\nconst config = new SettignsTestEnvironmentService(args, path, customAppSettingsHome);\ncontainer.bind<IEnvironmentService>(\"IEnvironmentService\").toConstantValue(config);. In that case you need  a setter:\nts\n@injectable()\nexport class ConfigurationService<T> \n    extends Disposable implements IConfigurationService, IDisposable {\n       private _platform: Platform, \n    constructor(\n        @inject('environmentService') environmentService: IEnvironmentService\n    ) {\n        super();\n    }\n        public setPlatform(platform: Platform) {\n             this._platform: Platform;\n        }\n   ....\n}\nOr a factory:\n```ts\nclass ConfigurationService \n    extends Disposable implements IConfigurationService, IDisposable {\n    constructor(\n                private _platform: Platform, \n        environmentService: IEnvironmentService\n    ) {\n        super();\n    }\n   ....\n}\ncontainer.bind<(platform: Platform) => ConfigurationService>(\"ConfigurationService\").toFactory((context: interfaces.Context) => {\n    return (platform: Platform) => {\n        let environmentService = context.container.get(\"Katana\");\n        return new ConfigurationService(platform, environmentService);\n    };\n});\nlet configurationServiceFactory = container.get<(platform: Platform) => ConfigurationService>(\"ConfigurationService\");\nlet configurationService = configurationServiceFactory(/ ... platform ... /);\n```. Hi @veeramarni can this issue be closed?. The import:\nts\nimport { tagProperty } from \"inversify/dts/annotation/decorator_utils\nDoesn't work because you are tying to import a dts file.\nYou can try with:\nts\nimport { tagProperty } from \"inversify/lib/annotation/decorator_utils\nBut please keep in mind that the tagProperty is supposed to be private.\nWhat is you use case? I don't think it is a good idea to make these methods public but if you have a strong use case I will be happy to change my mind.\n. Can decorate do the job?\nts\ndecorate(injectable(), Ninja);\ndecorate(inject(TYPES.Katana), Ninja, 0);\ndecorate(inject(TYPES.Shuriken), Ninja, 1);. So you need something like this but the base class will be abstract?. I will try to test this and if it is not possible using decorate I will expose the functions you need.. So I added a test case based on my comment. You can find the test case here. It seems to be working fine so there should be no need to export decorator_utils. \n. Hi @hdurix please take a look to Overriding bindings on unit test also instead of unbind you can use rebind.\nPlease let me know if you need additional help and close the issue if you don't have more questions.. Hi @veeramarni you forgot to invoke:\nts\nchildContainer.parent = parentContainer;\nYou need to try something like:\n```ts\n@injectable()\nclass HeirarchyTarget {\n    constructor(@inject('Container') parentContainer: Container) { // inject parent\n        let childContainer = new Container();\n        childContainer.parent = parentContainer; // set parent\n        let service2 = childContainer.get('IService2');\n        console.log(service2);\n        assert.equal(service2.d, true);\n    }\n}\nit(\"Should be able to inject to child dependency\", () => {\n    let container = new Container();\n    container.bind(\"Container\").toConstantValue(container); // be able to inject parent!\n    container.bind(\"IService1\").to(Service1);\n    container.bind(\"IService2\").to(Service2);\n    container.bind(\"HeirarchyTarget\").to(HeirarchyTarget);\n    let cl = container.get(\"HeirarchyTarget\");\n    console.log(cl);\n});\n```\nPlease let me know if this issue can be closed?. Sure! feel free to send a PR \ud83d\ude04 . Hi @atrauzzi, thanks for thinking about ways to improve inversify and sharing them. I really appreciate it.\nI've been reading the links from laravel and I saw:\n\nThere is no need to bind classes into the container if they do not depend on any interfaces. The container does not need to be instructed on how to build these objects, since it can automatically resolve these objects using reflection.\n\nThis is almost the same in Inversify. When we use classes (not interfaces), the only required annotation is @injectable(), the main problem is that we don't have fully-featured reflection so we can't explore a DLL and automatically generate bindings.\nWhen you use @injectable() it will generate some metadata if the class is declared. The problem is, the class is declared only if it is imported at least one time. \nWe would need something like:\nts\nimport \"./entities/someInjectable1\";\nimport \"./entities/someInjectable1\";\nimport \"./entities/someInjectable1\";\nimport \"./entities/someInjectable1\";\nimport \"./entities/someInjectable1\";\nThis is how the @provide() decorator works.\nIt would be much nicer if all the classes where loaded automatically but this is not possible due to the lack of fully featured reflection in JS. In Node.js we can write a function that reads a directory in the file system and loads every module but in browsers things are much more complicated.\nAlso, my understanding is that in the future the --emitDecoratorMetadata flag from TS will be able to generate metadata for interfaces. At the moment all interfaces are serialized as Object. The Object type is too ambiguous this is why we need @inject annotations.\nI originally though about using naming or path conventions (that is how version 1.0 of inversify worked) but I don't think that is a good idea because I believe that the main features of InversifyJS is being a universal library that work in browsers and node, it is agnostic of frameworks and architectures. I also tried to allow InversifyJS so people can build frameworks in top of it and create great developer experiences. We could improve the Inversify experience but that would mean being less flexible.\nI'm open to examine examples if you want to try ideas but I see this more as a side-project library specific for a concrete architecture and framework.. Hi @atrauzzi I think things are likely to head this way.\nMy vision about this right now is that I want to wait until there is a clear vision of where TypeScript is heading. If they are going to implement reflection for interfaces, then there are no need for custom transforms. If they are not going to do it, then using transform could be an option but I see the transforms as something that would live outside of the core repo.\nYou can see how people is already testing some of this stuff.. Thanks for understanding my point of view. Let's hope the future is more clear soon :+1: . Hi @gagle sorry for the late reply I was on holidays... checkout the metadata middleware feature I have a feeling that maybe could be useful for your use case.. Thanks for reporting this. Would you like to send a PR? . This has been implemented by #539 will be released in 4.0.0. Hi @oneassasin you can use the @inject decorator in a constructor, in a constructor with a property shortcut or in a property.  The @lazyInject is decorator is meant to be applied after a class has been created, for that reasons it doesn't make sense to be applied to a constructor. \nTypeScript allows us to define properties using the constructor shortcut but @lazyInject can only work when applied to a property, not to a constructor for that reasons I don't think we need to do anything about this issue. It is better to be explicit about @lazyInject only working on properties.. @Dirrk thanks for helping here :+1:  @hexa00 can you please confirm that this solves your issue and close the issue if so? Thanks!. Check out the release 4.1.0 \ud83c\udf89 Here is a test case that you can use as documentation.. @Adamfsk thanks for reporting this issue. I will try to fix it ASAP (Probably during the weekend). If this is blocking you. I would recommend using lazyInject as a temporal work around.. @Adamfsk that sounds like it could be possible. We detect circular dependencies because the resolver enters into an infinite loop and there is a stack overflow. We catch that exception and try to find out the cause by exploring a list of the most recent resolved entities. However, the stack overflow takes place in different moments in different JS engines. Will try to see if I can reproduce it but if you can provide a test case that will be much appreciated.. The following works for me:\n```ts\n@injectable()\nclass C {\n    public name = \"C\";\n}\n@injectable()\nclass B {\n    public name = \"B\";\n    @inject(\"C\") public c: C;\n}\n@injectable()\nclass A {\n    public name = \"A\";\n    @inject(\"B\") public b: B;\n    @inject(\"C\") public c: C;\n}\nconst container =  new Container();\ncontainer.bind(\"A\").to(A);\ncontainer.bind(\"B\").to(B);\ncontainer.bind(\"C\").to(C);\nlet a = container.get(\"A\");\nexpect(a.name).eql(\"A\");\nexpect(a.b.name).eql(\"B\");\nexpect(a.c.name).eql(\"C\");\nexpect(a.b.c.name).eql(\"C\");\n```\nThe dependency graph here looks like:\n\u2514\u2500\u2500A\n   \u251c\u2500\u2500 B\n   |   \u2514\u2500\u2500 C\n   \u2514\u2500\u2500 C\nWhat does your dependency graph look like?\n. @Adamfsk any luck with this?. Hi @showplans, can you share some information about your environment? Node version, ts version etc? A test case would be much appreciated \ud83d\udc4d . \ud83d\udc4d Thanks for the insights, It is clear that we have a bug that no one has been able to reproduce so far. The list of classes works in some cases because circular dependencies have been detected correctly in our unit tests. I will try to investigate once more but again without a tests case is very hard to do anything about it \ud83d\ude22 . This is now fixed \ud83c\udf89 https://github.com/inversify/InversifyJS/pull/716 it will be available in the next release.. I'm not fully sure about about what are you trying there. Are you trying to inject the same a type @inject(\"A\") but inject two different values?\nIf so, you can try the following:\n```ts\nclass A {}\nclass B {}\n@injectable()\nclass C {\n    @inject(\"Data\")\n    public collection: Array;\n}\n@injectable()\nclass D {\n    @inject(\"Data\")\n    public collection: Array;\n}\nconst a: A[] = [];\nconst b: B[] = [];\ncontainer.bind(\"Data\")\n    .toConstantValue(a)\n    .whenInjectedInto(C); // this is the important part\ncontainer.bind(\"Data\")\n    .toConstantValue(b)\n    .whenInjectedInto(D); // this is the important part\ncontainer.bind( C )\n    .to(C)\n    .inSingletonScope();\ncontainer.bind( D )\n    .to(D)\n    .inSingletonScope();\n```\nHere you can see a live demo (in JavaScript).\nYou can use one of the following features:\n\nNamed bindings\nTagged bindings\nContextual bindings\n. Docs available at https://github.com/inversify/InversifyJS/blob/master/wiki/injecting_npm_modules.md. Hi @tsschaffert this is the expecting behavior. The inject @inject decorator was created just to support interfaces. This is due to the way the TS compiler emits decorator metadata and at this point in time there is nothing we can do about it :cry: . Can you please share details about your environment (version of node, ts, inversify, browser, etc.) also can you share a code example that reproduces the issue?\n\nCall stack issues are mostly related with circular dependencies but Inversify should catch those and explain where is the circular dependency located.. @akosyakov can you please confirm that you are using onActivation handler?. @marshalYuan I just tried with the following unit test and it worked fine:\n```ts\nit(\"Should not throw maximum call stack size exceeded\", () => {\ninterface Ninja {\n    fight(): string;\n}\n\ninterface Katana {\n    hit(): string;\n}\n\n@injectable()\nclass Katana implements Katana {\n    public hit() {\n        return \"cut!\";\n    }\n}\n\n@injectable()\nclass Ninja implements Ninja {\n\n    private _katana: Katana;\n\n    public constructor(\n        @inject(\"Katana\") katana: Katana\n    ) {\n        this._katana = katana;\n    }\n\n    public fight() {return this._katana.hit(); }\n\n}\n\nlet container = new Container();\ncontainer.bind<Ninja>(\"Ninja\").to(Ninja);\ncontainer.bind<Katana>(\"Katana\").to(Katana).onActivation((context, katana) => {\n    let handler = {\n        apply: function(target: any, thisArgument: any, argumentsList: any) {\n            console.log(`Starting: ${new Date().getTime()}`);\n            let result = target.apply(thisArgument, argumentsList);\n            console.log(`Finished: ${new Date().getTime()}`);\n            return result;\n        }\n    };\n    katana.hit = new Proxy(katana.hit, handler);\n    return katana;\n});\n\nlet ninja = container.get<Ninja>(\"Ninja\");\nexpect(ninja.fight()).eql(\"cut!\");\n\n});\n```\nThe problem must be something else not the onActivation handler.. Hi @akosyakov thanks for the hints, I will try a few things to see if I can get to reproduce it. Please share an tests case if you do find it.. As you said, the following two bindings return the same instance of FooImpl:\nts\ncontainer.bind(FooImpl).toSelf().inSingletonScope();\ncontainer.bind(Foo).toDynamicValue(ctx => \n  ctx.container.get(FooImpl)\n).inSingletonScope();\nSo you have two identifiers FooImpl & Foo that resolve same singleton instance of FooImpl. Can you please explain me why you need two identifiers?\nThe only other way I can think about is:\nts\ncontainer.bind(FooImpl).toSelf().inSingletonScope();\ncontainer.bind(\"PUBLIC_ID_A\").toConstantValue(container.get(FooImpl));\n. I think toDynamicValue works nicely in that case. \nI think the issue could be related with circular dependencies. Call stack errors are thrown wen there is a circular dependency. we catch it in a very specific place. \nIn your case maybe the exception takes place when the dynamic value is resolved. That means that we might need an additional catch. Again, thanks for the info, I think I have now some info to try some test cases :+1: \n. @akosyakov do you have more insights about this? Is it still happening to you?. Hi @gagle, sorry for the late reply. I had some very busy days over the past few weeks...\nAbout @postConstruct, that is the way property injection works at the moment. If the instance has not been created by InversifyJS then you can use @lazyInject.\nAbout @preDestroy,  we could invoke it when container.unload() is called but we will only be able to invoke the `@preDestroy method of singleton instances. InversifyJS does not store references to transient references because memory would never be released.\nThis is a very complex problem in JavaScript because we cannot detect when an object is about to be garbage collected. I still thinking about this, you can read some of my ideas here. If I manage to implement a nice solution for custom scopes you will be able to declare:\n\nonActivation equivalent to @postConstruct. Invoked after instances are created.\nonDeactivation  equivalent to @preDestroy. Invoked then a custom scope ends. We will not be able to do it with the default scope because as I said we cannot detect when an object is about to be garbage collected or out of scope.\n\nAbout, making the API async, I tried once and I ended up with a not very nice dev experience. It forced you to use async / await and not always was ideal. The solution would be to provide two APIs (e.g. container.get(\"TYPE\") and await container.getAsync(\"TYPE\")) but this will make the library way more complex. I'm not fully convinced this will happen for now.\nIn summary, for the moment the API will remain sync and instead of implementing @preDestroy and @postConstruct I will continue thinking about custom scopes because I think it solves this problem and other problems as well. \nI'm closing this issue. The custom scope feature can be tracked at #218.\n. @gagle thanks for giving me more details. Kee in mind that the onActivation handler is not really designed for class initialization. Initialization makes more sense in the class definition. The real goal of the onActivation handler is to allow Interception:\n\nInterception is an advanced programming technique that allows you to intercept calls to an object so that you can add additional logic before or after the call. \n\nIf the goal is initialization your class should probably have an initialize method instead of using the onActivation handler. You can then decide if you want the initialize method to be asynchronous or synchronous.. @crabicode the class constructor cannot be async a decorator could be async if you use some metadata \"ready:false\" the problem is that then you would have to manually check every n units of time if it is ready because you cannot await a decorator. So this is not possible and it is likely to continue not being possible.\nYou are going to need to implement your own initialization. Something like:\n```ts\n@injectable()\nclass FileReader {\nprivate _isReady: boolean;\nprivate _filePath: string;\nprivate _data: any;\nprivate _logger: Logger;\n\npublic constructor(logger: Logger) {\n    this._logger = logger;\n    this._isReady = false;\n}\n\npublic async initialize(filePath: string) {\n    return new Promise((res, rej) => {\n        fs.open(this._filePath, \"r\", (err, fd) => {\n            if (err) {\n                this._isReady = true;\n                this._logger.info(`File found: ${filePath}`);\n                rej(err);\n            } else {\n                this._data = fd;\n                this._isReady = false;\n                this._logger.error(`File error: ${filePath}`);\n                res(this);\n            }\n        });\n    });\n}\n\npublic async read() {\n    if (this._isReady) {\n        // do something this this._data;\n    } else {\n        throw new Error();\n        this._logger.error(`File error: ${filePath} is not initialized`);\n    }\n}\n\npublic async write() {\n    if (this._isReady) {\n        // do something this this._data;\n    } else {\n        throw new Error();\n        this._logger.error(`File error: ${filePath} is not initialized`);\n    }\n}\n\npublic dispose() {\n    // close file\n}\n\n}\nconst fileReader = container.get(\"FileReader\");\nconst fileReaderReady = await fileReader.initialize();\nconst text = await fileReaderReady.read();\n```\nI would try to avoid this kind of class with internal state like \"isReady\", instead it is better to use a async  factory function. That way the class does not need to keep state. The factory will know what needs to be done and in which order.. @sachabarber you were using inversify 1.x? and now you are using inversify 2.x?. Hi @sachabarber sorry but I'm at work at the moment. I will try to help you as soon as I have some free time at home. I will try tonight but I can't promise I will have time.. I'm a Microsoft MVP right now but only for 1 year so far :smile: \nI cloned your repo and tried to run webpack but I got a lot of erros:\n```\n$ webpack\nWebpack is watching the files\u2026\n[at-loader] Using typescript@2.3.2 from typescript and \"tsconfig.json\" from /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/tsconfig.json.\n[at-loader] Checking started in a separate process...\n[at-loader] Ok, 0.142 sec.\nHash: 3f9d9fcf98de5073db24\nVersion: webpack 2.5.1\nTime: 6533ms\n                                       Asset       Size  Chunks                    Chunk Names\n       vendor.bundle.3f9d9fcf98de5073db24.js    2.34 MB       0  [emitted]  [big]  vendor\n        index.bundle.3f9d9fcf98de5073db24.js    4.04 kB       1  [emitted]         index\n     indexCss.bundle.3f9d9fcf98de5073db24.js  194 bytes       2  [emitted]         indexCss\n    indexCss.bundle.3f9d9fcf98de5073db24.css  187 bytes       2  [emitted]         indexCss\n   vendor.bundle.3f9d9fcf98de5073db24.js.map    2.51 MB       0  [emitted]         vendor\n    index.bundle.3f9d9fcf98de5073db24.js.map    3.65 kB       1  [emitted]         index\n indexCss.bundle.3f9d9fcf98de5073db24.js.map  328 bytes       2  [emitted]         indexCss\nindexCss.bundle.3f9d9fcf98de5073db24.css.map  117 bytes       2  [emitted]         indexCss\n                                  index.html  524 bytes          [emitted]       \n   [0] ./~/react/react.js 56 bytes {0} [built]\n  [11] ./~/fbjs/lib/warning.js 2.1 kB {0} [built]\n  [14] ./~/object-assign/index.js 2.11 kB {0} [built]\n  [15] ./~/react-dom/lib/ReactDOMComponentTree.js 6.27 kB {0} [built]\n  [19] ./~/react-dom/index.js 59 bytes {0} [built]\n  [50] ./~/react/lib/React.js 3.32 kB {0} [built]\n [202] ./src/index.tsx 976 bytes {1} [built]\n [203] ./~/bootstrap/dist/css/bootstrap.css 3.73 kB {0} [built] [failed] [1 error]\n [204] ./scss/index.scss 41 bytes {2} [built]\n [283] ./~/jquery/dist/jquery.js 268 kB {0} [built]\n [284] ./~/lodash/lodash.js 540 kB {0} [built]\n [346] ./~/react-bootstrap/es/index.js 4.85 kB {0} [built]\n [364] ./~/react-dom/lib/ReactDOM.js 5.14 kB {0} [built]\n [396] ./~/react-dom/lib/ReactVersion.js 350 bytes {0} [built]\n [413] ./~/react-dom/lib/findDOMNode.js 2.46 kB {0} [built]\n    + 430 hidden modules\nERROR in ./~/bootstrap/dist/css/bootstrap.css\nModule build failed: ModuleNotFoundError: Module not found: Error: Can't resolve 'file-loader' in '/home/rjansen/CODE/MadCapIdea/FrontEndWebSite'\n    at factoryCallback (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/webpack/lib/Compilation.js:264:39)\n    at factory (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/webpack/lib/NormalModuleFactory.js:247:20)\n    at resolver (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/webpack/lib/NormalModuleFactory.js:65:21)\n    at asyncLib.parallel (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/webpack/lib/NormalModuleFactory.js:202:22)\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:3838:9\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:421:16\n    at iteratorCallback (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:996:13)\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:906:16\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:3835:13\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:1074:9\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:421:16\n    at iteratorCallback (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:996:13)\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:906:16\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:1071:13\n    at resolver.resolve (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/webpack/lib/NormalModuleFactory.js:273:20)\n    at onResolved (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/Resolver.js:70:11)\n    at loggingCallbackWrapper (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/createInnerCallback.js:31:19)\n    at afterInnerCallback (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/Resolver.js:138:10)\n    at loggingCallbackWrapper (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/createInnerCallback.js:31:19)\n    at Resolver.applyPluginsAsyncSeriesBailResult1 (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/tapable/lib/Tapable.js:181:46)\n    at innerCallback (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/Resolver.js:125:19)\n    at loggingCallbackWrapper (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/createInnerCallback.js:31:19)\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/tapable/lib/Tapable.js:283:15\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/UnsafeCachePlugin.js:38:4\n    at loggingCallbackWrapper (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/createInnerCallback.js:31:19)\n    at afterInnerCallback (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/Resolver.js:138:10)\n    at loggingCallbackWrapper (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/createInnerCallback.js:31:19)\n    at Resolver.applyPluginsAsyncSeriesBailResult1 (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/tapable/lib/Tapable.js:181:46)\n    at innerCallback (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/Resolver.js:125:19)\n    at loggingCallbackWrapper (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/createInnerCallback.js:31:19)\n @ ./src/components/Hello.tsx 18:0-43\n @ ./src/index.tsx\nERROR in ./~/bootstrap/dist/css/bootstrap.css\nModule build failed: ModuleNotFoundError: Module not found: Error: Can't resolve 'file-loader' in '/home/rjansen/CODE/MadCapIdea/FrontEndWebSite'\n    at factoryCallback (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/webpack/lib/Compilation.js:264:39)\n    at factory (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/webpack/lib/NormalModuleFactory.js:247:20)\n    at resolver (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/webpack/lib/NormalModuleFactory.js:65:21)\n    at asyncLib.parallel (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/webpack/lib/NormalModuleFactory.js:202:22)\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:3838:9\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:421:16\n    at iteratorCallback (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:996:13)\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:906:16\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:3835:13\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:1074:9\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:421:16\n    at iteratorCallback (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:996:13)\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:906:16\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/async/dist/async.js:1071:13\n    at resolver.resolve (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/webpack/lib/NormalModuleFactory.js:273:20)\n    at onResolved (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/Resolver.js:70:11)\n    at loggingCallbackWrapper (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/createInnerCallback.js:31:19)\n    at afterInnerCallback (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/Resolver.js:138:10)\n    at loggingCallbackWrapper (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/createInnerCallback.js:31:19)\n    at Resolver.applyPluginsAsyncSeriesBailResult1 (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/tapable/lib/Tapable.js:181:46)\n    at innerCallback (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/Resolver.js:125:19)\n    at loggingCallbackWrapper (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/createInnerCallback.js:31:19)\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/tapable/lib/Tapable.js:283:15\n    at /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/UnsafeCachePlugin.js:38:4\n    at loggingCallbackWrapper (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/createInnerCallback.js:31:19)\n    at afterInnerCallback (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/Resolver.js:138:10)\n    at loggingCallbackWrapper (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/createInnerCallback.js:31:19)\n    at Resolver.applyPluginsAsyncSeriesBailResult1 (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/tapable/lib/Tapable.js:181:46)\n    at innerCallback (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/Resolver.js:125:19)\n    at loggingCallbackWrapper (/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/enhanced-resolve/lib/createInnerCallback.js:31:19)\nERROR in /home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/extract-text-webpack-plugin/loader.js??ref--1-0!/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/css-loader/index.js?importLoaders=1!/home/rjansen/CODE/MadCapIdea/FrontEndWebSite/node_modules/bootstrap/dist/css/bootstrap.css doesn't export content\nChild extract-text-webpack-plugin:\n       [0] ./~/css-loader/lib/css-base.js 2.26 kB {0} [built]\n       [1] ./~/css-loader!./~/sass-loader/lib/loader.js!./scss/index.scss 290 bytes {0} [built]\nChild html-webpack-plugin for \"index.html\":\n       [0] ./~/lodash/lodash.js 540 kB {0} [built]\n       [1] ./~/html-webpack-plugin/lib/loader.js!./template.html 565 bytes {0} [built]\n       [2] (webpack)/buildin/global.js 509 bytes {0} [built]\n       [3] (webpack)/buildin/module.js 517 bytes {0} [built]\nChild extract-text-webpack-plugin:\n       [0] ./~/css-loader/lib/css-base.js 2.26 kB {0} [built]\n       [1] ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css 154 kB {0} [built]\nERROR in ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css\nModule not found: Error: Can't resolve 'file-loader' in '/home/rjansen/CODE/MadCapIdea/FrontEndWebSite'\n @ ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css 6:4445-4497 6:4520-4572\n\nERROR in ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css\nModule not found: Error: Can't resolve 'url-loader' in '/home/rjansen/CODE/MadCapIdea/FrontEndWebSite'\n @ ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css 6:4622-4676\n\nERROR in ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css\nModule not found: Error: Can't resolve 'url-loader' in '/home/rjansen/CODE/MadCapIdea/FrontEndWebSite'\n @ ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css 6:4707-4760\n\nERROR in ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css\nModule not found: Error: Can't resolve 'url-loader' in '/home/rjansen/CODE/MadCapIdea/FrontEndWebSite'\n @ ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css 6:4790-4842\n\nERROR in ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css\nModule not found: Error: Can't resolve 'url-loader' in '/home/rjansen/CODE/MadCapIdea/FrontEndWebSite'\n @ ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css 6:4876-4928\n\nChild extract-text-webpack-plugin:\n       [0] ./~/css-loader/lib/css-base.js 2.26 kB {0} [built]\n       [1] ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css 154 kB {0} [built]\nERROR in ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css\nModule not found: Error: Can't resolve 'file-loader' in '/home/rjansen/CODE/MadCapIdea/FrontEndWebSite'\n @ ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css 6:4445-4497 6:4520-4572\n\nERROR in ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css\nModule not found: Error: Can't resolve 'url-loader' in '/home/rjansen/CODE/MadCapIdea/FrontEndWebSite'\n @ ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css 6:4622-4676\n\nERROR in ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css\nModule not found: Error: Can't resolve 'url-loader' in '/home/rjansen/CODE/MadCapIdea/FrontEndWebSite'\n @ ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css 6:4707-4760\n\nERROR in ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css\nModule not found: Error: Can't resolve 'url-loader' in '/home/rjansen/CODE/MadCapIdea/FrontEndWebSite'\n @ ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css 6:4790-4842\n\nERROR in ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css\nModule not found: Error: Can't resolve 'url-loader' in '/home/rjansen/CODE/MadCapIdea/FrontEndWebSite'\n @ ./~/css-loader?importLoaders=1!./~/bootstrap/dist/css/bootstrap.css 6:4876-4928\n\n```\n. Ok so I have managed to get it to work and I have created a PR for your project. I also changed your code to inject your class Foo. Just to be sure that everything works.\nThe PR can be found at https://github.com/sachabarber/MadCapIdea/pull/1\n@sachabarber thanks for your being patient\n@lholznagel thanks for giving me a hand \ud83d\udc4d . No problem @sachabarber happy to help :+1: . @sachabarber haha yes sometimes my most productive times are my \"insomnia times\" :rofl: . @AltekkeE I will have something for you this weekend. I'm working on an example for a presentation at a meetup and it will be useful for you as well.. Hi @AltekkeE this is not fully finished but you can start taking a look https://github.com/stelltec/public-tech-demos/tree/master/nodejs-madrid-meetup/demo3/src\nOver the next few days there will be a fully working example in that repository.. I just released inversify-express-utils@3.5.2 :tada: . @lholznagel @lynx-r I saw you guys are talking about this in the chat. I will try to take a look this weekend but feel free to help you have time available.. @lynx-r I was thinking that but I though you didn't use it to simplify the question :+1: . Hi @atrauzzi, this is now fixed in inversify@4.1.1 thanks for reporting the issue :+1: . Hi @akosyakov, this is one of the most complex features that I've been planing for months but it is not ready yet. I have an issue #218 to track it. What you  need is inRequestScope(): \n:warning: This feature is not available yet :warning:\nts\ncontainer.bind<A>(\"A\").to(A);\ncontainer.bind<B1>(\"B1\").to(B1).inRequestScope();\ncontainer.bind<B2>(\"B2\").to(B2).inRequestScope();\ncontainer.bind<C>(\"C\").to(C).inRequestScope();\nI have plans to add support for this feature but it is a complicated one. I also have plans for inCustomScope.\nFor the moment, there are multiple ways to hack your way around this use case. They are not very elegant :cry: the less ugly one I can think about is the following:\n```ts\n@injectable()\nclass AFactory {\n@inject(\"A\") private A: A;\n   @inject(\"B1\") private B1: B1;\n   @inject(\"B2\") private B2: B2;\n   @inject(\"C\") private C: C;\npublic getA() {\n       const c = new this.C();\n       const b1 = new this.B1(c);\n       const b2 = new this.B2(c);\n       const a = new this.A(b1, b2, c);\n       return a;\n   }\n}\ncontainer.bind(\"A\").toConstructor(A);\ncontainer.bind(\"B1\").toConstructor(B1);\ncontainer.bind(\"B2\").toConstructor(B2);\ncontainer.bind(\"C\").toConstructor(C);\ncontainer.bind(\"AFactory\").to(AFactory);\nconst aFactory = container.get(\"AFactory\");\nconst a = aFactory.getA();\n```\nPlease let me know if it is OK to close this issue.. That would be my second suggestion I don't think it is better or worst than the factory just a question of personal preference.. Hi @orendin how are you importing \"reflect-metadata\" ? from the command line or form the app? \nThe problem seems to be caused because the metadata is stored in the Reflect object which is created as a global by reflect-metadata.\nMy guess is that the mocha watch mode is not cleaning the globals with each run. Can you please check if mocha has some setting force cleaning the globals?. No peoblem @orendin, I'm quite sure that that is the problem. If you manage to reset the Reflect global it should work :wink: . No problem, maybe the mocha guys can help.. Better than a try / catch you can create a helper powered by container.isBound:\n```ts\nfunction getOrDefault(\n    container: Container, typeIdentifier: Symbol, defaultValue: T\n) {\n    if (container.isBound(typeIdentifier) === true) {\n        return container.get(typeIdentifier)\n    }\n    return defaultValue;\n}\ninterface Foo {\n    bar: string;\n}\nconst foo = getOrDefault(container, typeIdentifier, { bar: \"default\" });\n```\nWe can add this to the core library but we need more methods getNamedOrDefault getTaggedDefault:\nts\nconst w1 = container.getOrDefault<Ninja>(\"Ninja\", { weapon: \"Shuriken\" });\nconst w2 = container.getNamedOrDefault<Warrior>(\"Warrior\", \"Sneaky\". { weapon: \"Shuriken\" });\nconst w3 = container.getTaggedOrDefault<Warrior>(\"Warrior\", { sneaky: true }, { weapon: \"Shuriken\" });. @atrauzzi I would prefer people to be explicit about it. I think it is better to make defaultValue not optional:\nts\nconst w1 = container.getOrDefault<Ninja|null>(\"Ninja\", null);\nIf by default is null people will have to check for null all the time :sob: \n@akosyakov if we do overloads:\nts\nget<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, defaultValue: T): T;\nHow will you allow for null as default?\nts\nconst ninja = container.get<Ninja>(\"Ninja\"); // thorws\nconst nullableNinja = container.get<Ninja|null>(\"Ninja\", null); // null\nI don't want to force everyone to check for nulls.\nAlso I was just thinking that we already have @optional() cpuld @default(someValue) be a good thing too?\nI'm removing, \"Accepting PRs\" we need talk this properly first :smile: \n. I think I like the following:\nA\nts\nconst ninja = container.get<Ninja>(\"Ninja\"); // thorws\nconst nullableNinja = container.get<Ninja|null>(\"Ninja\", null); // null\nconst defaultNinja = container.get<Ninja>(\"Ninja\", { weapon: \"default\" }); // Obj\nMore than:\nB\nts\nconst ninja = container.get<Ninja>(\"Ninja\"); // thorws\nconst nullableNinja = container.getOrDefault<Ninja|null>(\"Ninja\", null); // null\nconst defaultNinja = container.getOrDefault<Ninja>(\"Ninja\", { weapon: \"default\" }); // Obj\nWhat do you guys think?. So we need to add an optional argument defaultValue to all existing get* methods:\n```ts\nget(\n    serviceIdentifier: ServiceIdentifier,\n    defaultValue: T\n): T;\ngetNamed(\n    serviceIdentifier: ServiceIdentifier,\n    named: string|number|symbol,\n    defaultValue: T\n): T;\ngetTagged(\n    serviceIdentifier: ServiceIdentifier,\n    key: string|number|symbol,\n    value: any,\n    defaultValue: T\n): T;\ngetAll(\n    serviceIdentifier: ServiceIdentifier, defaultValue: T\n): T[];\n```\nThe above functions will not use try/catch internally (the will is isBound, isNamed, isBoundTagged) - the whole point of it is that it is implemented without exceptions so that it is fast. \nWe also need to create the helpers (just a wrapper around the other functions):\n```ts\ntryGet(\n    serviceIdentifier: interfaces.ServiceIdentifier\n): T | null;\ntryGetNamed(\n    serviceIdentifier: ServiceIdentifier,\n    named: string | number | symbol\n): T | null;\ntryGetTagged(\n    serviceIdentifier: ServiceIdentifier,\n    key: string | number | symbol,\n    value: any\n): T | null;\ntryGetAll(\n    serviceIdentifier: ServiceIdentifier\n): T[];\n```\nI think I like more get and tryGet than get and getOptional because reminds me to Parse and TryParse do you guys agree?\n. Thank for the feedback guys, I really appreciate it \ud83d\udc4d \nSo, as you pointed out defaultValue should include ?:\n```ts\nget(\n    serviceIdentifier: ServiceIdentifier,\n    defaultValue?: T\n): T;\ngetNamed(\n    serviceIdentifier: ServiceIdentifier,\n    named: string|number|symbol,\n    defaultValue?: T\n): T;\ngetTagged(\n    serviceIdentifier: ServiceIdentifier,\n    key: string|number|symbol,\n    value: any,\n    defaultValue?: T\n): T;\ngetAll(\n    serviceIdentifier: ServiceIdentifier, \n    defaultValue?: T[]\n): T[];\n```\nAnd should return undefined and y think it is ok to stick with tryGet* as you said we don't need to follow C# and getOrThrow would require us to rename the existing method and the new ones will be named like the currently existing ones. I would like to avoid such breaking change.\n```ts\ntryGet(\n    serviceIdentifier: interfaces.ServiceIdentifier\n): T | undefined;\ntryGetNamed(\n    serviceIdentifier: ServiceIdentifier,\n    named: string | number | symbol\n): T | undefined;\ntryGetTagged(\n    serviceIdentifier: ServiceIdentifier,\n    key: string | number | symbol,\n    value: any\n): T | undefined;\ntryGetAll(\n    serviceIdentifier: ServiceIdentifier\n): T[];\n```\nWhat do you guys think that should happen for child requests? Let's say that Ninja needs Weapon. The binding for Ninja has been declared but the binding for Weapon is missing:\n\nWhen invoking get<Ninja>(Ninja) I expect a \"no bindings found for Ninja\" exception.\nWhen invoking get<Ninja>(Ninja) I expect a \"no bindings found for Weapon\" exception or undefined? I personally fear returning undefined for child requests becoming something very confusing.\n\n. Thanks for all the feedback I'm closing this issue. I have created #566 so it is easy to know what are the final requirements.. @AltekkeE can we throw or something is someone tries to use it with args @RequestBody(\"xxx\")? Should that not be a compilation error.. @massivedynamicsrls are you using TypeScript? how did you pass arguments to RequestBody without getting a compilation error?. @theodesp this is a needed feature. If someone sends a PR it will be welcome.. I have the following vision in mind:\n\nNow in the Planner, we have the following decisions:\nIf there are no bindings available here\nor we have multiple bindings available here = >\nShall we just proceed as normal and throw the Error?\n\nIf a default value is provided the no exception should be thrown. The functions will not use try/catch internally (the should use isBound, isNamed, isTagged) - the whole point of it is that it is implemented without exceptions so that they are fast. The plan should create a constant value binding containing the default as part of the plan. So we can proceed to the resolution phase.\n\nIf there are no bindings available and the target request is optional here => Shall we return the default value instead?\n\nIn the resolve phase, there will be a  binding of a constant type always so the idea is that you will not have to do any changes to the resolution phase.\n. Hi @Aboisier can you please share your feedback in #576 ? I will close this issue so we can track it in the other one. . The @injectable decorator will always be required. In the future we might be able to remove the need for @inject decorators.\n```ts\n@injectable()\nclass FileStream implements IStream { ... }\n[...]\ncontainer.bind(\"IStream\").to(FileStream);\n```\nYou can use the rebind function:\n```ts\n@injectable()\nclass EncryptedStream implements IStream {\n    constructor(@inject(\"IStream\") baseStream: IStream) { }\n}\n[...]\ncontainer.bind(\"Stream\").to(FileStream).whenInjectedInto(EncryptedStream);\ncontainer.rebind(\"IStream\").to(EncryptedStream);\n```. Thanks for giving me more details. I don't think I fully understand the issue. Bases on your comments:\n\nIn this case, each module will have to register its own IStream implementation.\n\nSo each module will invoke:\nmodule 1\nts\ncontainer.bind<IStream>(\"IStream\").to(FileStream);\nmodule 2\nts\ncontainer.bind<IStream>(\"IStream\").to(EncryptedStream);\nmodule 3\nts\ncontainer.bind<IStream>(\"IStream\").to(CompressedStream);\n\nmy final application will just request an IStream. \n\nSo the app does:\nts\nconst stream = container.get<IStream>(\"IStream\")\n\nNow, depending on which modules I have registered I am expecting to either have:\n\nA) a FileStream\nB) an EncryptedStream(FileStream)\nC) a CompressedStream(FileStream)\nD) an EncryptedStream(CompressedStream(FileStream))\n\n\nI'm assuming that when you use the word \"module\" you are talking about container modules.\nThis last comment is what I don't understand 100%.  I'm trying to link each module to one of the items in the list above.\nA) Module 1 is loaded\nts\ncontainer.bind<IStream>(\"IStream\").to(FileStream);\ncontainer.bind<IBaseStream>(\"IBaseStream\").to(FileStream);\nWhen the application asks for IStream a FileStream instance is injected.\nB) Module 2 is loaded\nts\ncontainer.rebind<IStream>(\"IStream\").to(EncryptedStream);\nThe EncryptedStream class has a dependency on IBaseStream.\nWhen the application asks for IStream an EncryptedStream instance is injected.\nC) Module 3 is loaded (when module 2 is not loaded)\nts\ncontainer.rebind<IStream>(\"IStream\").to(CompressedStream);\nThe CompressedStream class has a dependency on IBaseStream.\nWhen the application asks for IStream a CompressedStream instance is injected.\nD) Module 3 is loaded (after module 2)\nts\ncontainer.rebind<IStream>(\"IStream\").to(CompressedStream);\ncontainer.rebind<IBaseStream>(\"IBaseStream\").to(EncryptedStream);\nThe CompressedStream class has a dependency on IBaseStream, IBaseStream is EncryptedStream has a dependency on IBaseStream and this is the problem. If we use two interfaces we will lose the reference to the third one.\nI don't really know how to solve this problem but cases A, B and C work fine is just D \ud83d\ude22 Is this the problem? Did I understand it? What kind of API do you have in your mind? \n. In the example:\nts\nconst constructorName = (currentRequest.bindings[0].implementationType as Function).name;\nIf the code is minified, constructorName will be the minified name. If you are not comparing the constructorName value against a hard coded string, then it is OK, you won't need  the @targetname decorator. \nIf you want to do some conditional you could always use the values instead of hard coded strings:\nts\ncontainer.bind<Logger>(\"Logger\").toDynamicValue((context, currentRequest: interfaces.Request) => {\n    const constructorName = (currentRequest.bindings[0].implementationType as Function).name;\n    const someClassName = (SomeClass as any).name; // \"SomeClass\" or minified name\n    if (constructorName === someClassName) {\n        // do something\n    }\n    const logger = new Logger(constructorName);\n    return logger;\n});. You could do that but if you have two classes like in the example you have two requests with two targets:\n\nSomeClass\nLogger\n\nIn your example the annotation is applied to the target Logger so it should be @targetName(\"Logger\") to access SomeClass you will need to use context.plan.rootRequest (because in this case the root request is SomeClass) after fixing this issue you will be able to use currentRequest.parentRequest instead but the name will be compressed sometimes. So I guess at that point we might need to add support for the @targetName decorator for classes. At the moment it only works in arguments.\n. Hi @guscastro @mtfranchetto @Aboisier boisier \nThis is now implemented by https://github.com/inversify/InversifyJS/pull/719 and available in inversify@4.8.0 \ud83c\udf89  \nYou can now access the current request via context.currentRequest. The following code snippet is an example:\n```ts\n@injectable()\nclass Logger {\n    public named: string;\n    public constructor(named: string) {\n        this.named = named;\n    }\n}\nconst container = new Container();\nconst TYPE = {\n    Logger: Symbol.for(\"Logger\")\n};\ncontainer.bind(TYPE.Logger).toDynamicValue((context) => {\n    const namedMetadata = context.currentRequest.target.getNamedTag();\n    const named = namedMetadata ? namedMetadata.value : \"default\";\n    return new Logger(named);\n});\nconst logger1 = container.getNamed(TYPE.Logger, \"Name1\");\nconst logger2 = container.getNamed(TYPE.Logger, \"Name2\");\nexpect(logger1.named).to.eq(\"Name1\");\nexpect(logger2.named).to.eq(\"Name2\");\n```. @Aboisier \n\nWill it be possible to access the class name even when the code is minified? If not, would it be possible to use something like the @targetname decorator?\n\nYou can access the class name via context.currentRequest.bindings[0].implementationType.name but the name will change if the class is minified. This can be solved if you compare agains the class though.\n```ts\nclass Ninja {\n}\n// ...\ncontainer.bind(TYPE.Warrior)to(Ninja).inActivation((context) => {\n    const currentClass = context.currentRequest.bindings[0].implementationType;\n    if (currentClass) {\n         if (currentClass.name === Ninja.name) {\n            // ...\n        }\n    }\n```\nHowever, in this case, would be better to check for the constructor:\nts\ncontainer.bind<Warrior>(TYPE.Warrior)to(Ninja).inActivation((context) => {\n    const currentClass = context.currentRequest.bindings[0].implementationType;\n    if (currentClass) {\n         if (currentClass === Ninja) {\n            // ...\n        }\n    }\nI haven't try this but I think it should work.\nFor factories (auto-factory, factory, dynamic value and provider bindings) the implementationType will be null because the constructor is not the class (is the factory).. @krzkaczor by parent request do you mean root request? It should be accessible via context.plan.rootRequest.. This issue is caused because InversifyJS adds some metadata to the constructor. You are creating a new constructor and the metadata is lost. You need to manually copy the metadata from the original constructor to the new constructor. We can use the reflect-metadata API:\n```ts\nconst {Container, injectable, inject, named} = inversify\nfunction logClass(target: any) {\n// save a reference to the original constructor\n  var original = target;\n// a utility function to generate instances of a class\n  function construct(constructor, args) {\n    var c : any = function () {\n      return new constructor(...args);\n    }\n    c.prototype = constructor.prototype;\n    return new c();\n  }\n// the new constructor behaviour\n  var newConstructor : any = function (...args) {\n    console.log(\"New: \" + original.name);\n    return construct(original, args);\n  }\n// copy prototype so intanceof operator still works\n  newConstructor.prototype = original.prototype;\n// Copy metadata\n  var metadataKeys = Reflect.getMetadataKeys(target);\n  metadataKeys.forEach((metadataKey) => {\n      var metadataValue = Reflect.getMetadata(metadataKey, target);\n      Reflect.defineMetadata(metadataKey, metadataValue, newConstructor);\n  });\n// return new constructor (will override original)\n  return newConstructor;\n}\ninterface IPerson {\n    say: () => void;\n}\n@injectable()\nclass Person implements IPerson {\n    say() {\n    console.log('hello folks');\n  }\n}\nlet personType = Symbol('Person');\nlet stuffType = Symbol('Stuff');\n@injectable()\n@logClass\nclass Stuff {\n    constructor(@inject(personType) private person: IPerson) {\n    console.log(person);\n  }\ndo() {\n    this.person.say();\n  }\n}\nlet container = new Container();\ncontainer.bind(personType).to(Person);\ncontainer.bind(stuffType).to(Stuff);\nlet stuff = container.get(stuffType);\nstuff.do(); // hello folks\n```. I haven't tested it but InversifyJS allows you to use 3 kinds of identifiers:\n\nClasses\nStrings Literals\nSymbols\n\nCan you please check if the following works:\n```ts\nenum Types {\n    Something = \"Something\"\n};\nconst container = new Container();\ncontainer.bind(Types.Something).toConstantValue(\"SOME VALUE\");\nconst value = container.get(Types.Something);\n```\nMy guess is that this should work?\n. Do you get this error when you compile with webpack, tsc, .. as well or only in IDEA?. Will check out but I don't have IDEA, I'm going to upgrade the project to TypeScript 2.4 when it is released (probably next week).. @dagatsoin did some work this week on VS with the latest version of TS and I could not see any errors. Can you check this with the IDEA team, please?. Hi @akosyakov If you can do the following:\nts\nbind(WorkspaceFrontendContribution).toSelf().inSingletonScope();\nbind(FrontendApplicationContribution).toService(WorkspaceFrontendContribution);\nbind(CommandContribution).toService(WorkspaceFrontendContribution);\nbind(MenuContribution).toService(WorkspaceFrontendContribution);\nbind(KeybindingContribution).toService(WorkspaceFrontendContribution);\nIt means that I would need to implement toService. The toService binding will use toDynamicValue under the hood.\nSuggested multiBindToService helper\nIf I do that and I also create the following function:\nts\nconst multiBindToService = (container) => (service) => (...types) => {\n    return types.map(t => container.bind(t).toService(WorkspaceFrontendContribution));\n};\nYou will also be able to do:\n```ts\ncontainer.bind(WorkspaceFrontendContribution).toSelf().inSingletonScope();\nmultiBindToService(container)(WorkspaceFrontendContribution)(\n    CommandContribution,\n    MenuContribution,\n    KeybindingContribution\n);\n```\nHow can I customize the scope with multiBindToService?\nBecause the helper returns an array of bindings you will be able to configure other options like for example inSingletonScope:\nts\nmultiBindToService(container)(WorkspaceFrontendContribution)(\n    CommandContribution,\n    MenuContribution,\n    KeybindingContribution\n).map(b => b.inSingletonScope());\nWhy do you use multiple functions in multiBindToService?\nI use multiple functions (container) => (service) => (...types) => to allow you to avoid repeating your self:\n```ts\ncontainer.bind(WorkspaceFrontendContribution).toSelf().inSingletonScope();\n// You can create partial functions if you expect to call \n// multiBindToService(container)(WorkspaceFrontendContribution)\n// multiple times\nconst mbts = multiBindToService(container);\nconst mbtWorkspaceFrontendContribution = mbts(WorkspaceFrontendContribution);\nmbtWorkspaceFrontendContribution(\n    CommandContribution,\n    MenuContribution,\n    KeybindingContribution\n);\nmbtWorkspaceFrontendContribution(\n    SomeType1,\n    SomeType2,\n    SomeType3\n);\n```\nSummary\nI can implement:\n\nThe toService feature\nThe multiBindToService function\n\nAnd you will be able to do:\nts\ncontainer.bind(WorkspaceFrontendContribution).toSelf().inSingletonScope();\ncontainer.bind(FrontendApplicationContribution).toService(WorkspaceFrontendContribution);\ncontainer.bind(CommandContribution).toService(WorkspaceFrontendContribution);\ncontainer.bind(MenuContribution).toService(WorkspaceFrontendContribution);\ncontainer.bind(KeybindingContribution).toService(WorkspaceFrontendContribution);\nOr:\n```ts\ncontainer.bind(WorkspaceFrontendContribution).toSelf().inSingletonScope();\nmultiBindToService(container)(WorkspaceFrontendContribution)(\n    CommandContribution,\n    MenuContribution,\n    KeybindingContribution\n);\n```\nWould that work?\n. This is now implemented by https://github.com/inversify/InversifyJS/pull/720 and released by 4.9.0 \ud83c\udf89 . Docs :book: :point_right: https://github.com/inversify/InversifyJS/blob/master/wiki/transitive_bindings.md. We need more details to be able to help, we need the code of the Server class and see how do you invoke myContainer.get<IServer>(TYPES.IServer).. @robertmain we wrote the decorators they don't come express. They come from https://github.com/inversify/inversify-express-utils\n@oneassasin just an update on this. I want to implement generic controllers myself so I will look at this feature at some point. It is not an easy one because the way things work internally but I will try my best to solve it. Unfortunately, it will take me some time because I try to solve simple issues first.\nThanks for suggesting this feature \ud83d\udc4d . @rmblstrp a PR would be awesome :+1: . This feature is now implemented and will be released in inversify-express-utils@5.2.2 :tada: . Hi @AltekkeE I like this feature :+1: I have some questions if you don't mind... \nHow do you think this should play with the onActivation feature? should  @PostConstruct  be invoked before or after the onActivation handler? \nI'm thinking that maybe after because we could have the onActivation for all implementations of a Type and @PostConstruct for one of the implementations. Do you agree?\n. True, thanks for bringing that to my memory. I think @postConstruct should go first then. So the order should be:\n\nconst x = new X() // new instance\nx.postConstruct() // instance initialized\nonActivationHandler(x) // \n\nI also think that we should wrap postConstruct with a try catch and if an error takes place throw a custom error. Something like:\n\n@postConstruct error in class X: The details of the original exception goes here.\n\nDo you have any other concerns?. @gagle the problem is that we know when an object is created but we cannot know when it is destroyed. @AltekkeE I'm sorry but I won't be able to do a release today but I will get it out during the weekend. \nAbout preDestroy. Let's think about the API before we implement it. \nI have plans for custom scopes and the API would be something like:\nIn inversify-express-utils, when a request hits the server:\n```ts\nconst requestScope = container.createScope(\"requestScope\") // Symbol(\"requestScope\");\nconst scope = container.beginScope(requestScope); // creates a new scope instance\nconst controllerInstance = container.getInScope(\"Controller\", scope);\n// ...\ncontainer.endScope(scope); // kills the controller instance invokes @predestory\n```\nWe would need getInScope, getInScopeNamed, getAllInScope & getInScopeTagged ...\nUser will be able to do:\nts\ncontainer.bind<Controller>(\"Controller\").to(SomeController).inCustomScope(requestScope);\ncontainer.bind<Repository>(\"Repository\").to(SomeRepository).inCustomScope(requestScope);\nInternally the container will keep dictionary like:\nts\nscopeID // Symbol(\"requestScope\")\nscopeInstanceID // Some auto-generated ID\nvaluesArray // An array that contains all the objects in the scope isntance\n. Hi guys, I'm closing this issue I have created https://github.com/inversify/InversifyJS/issues/593 to follow @preDestroy  I just released 4.2.0. Hi @AltekkeE thanks a lot for this PR. Awesome work :+1:  I don't see any problems at the implementation details level. At the architecture level, there is a problem that you have already mentioned @ https://github.com/inversify/InversifyJS/issues/587#issuecomment-311414698:\n\nMy only other concern is that i did not add any code to the annotation phase or the plan phase.\n\nThe way I would preffer it to work is the following:\n\n\nMove the reading of the metadata to metadata_reader.ts. \n\n\nThe reflection_utils.ts will consume the metadata reader.\n\n\nThe plan phase asks the reflection ustils for the dependencies of an object. Then it creates a request for each dependency. We need to put the post construct handler somewhere I'm thinking that the right place is probably or theRequest class not the Binding class.\n\n\nThe resolve phase should then invoke the handler like here. It will look something like:\n\n\n```ts\n        // use post construct handler if available\n        if (typeof request.postconstructMethodName !== null) {\n            resultrequest.postconstructMethodName;\n        }\n    // use activation handler if available\n    if (typeof binding.onActivation === \"function\") {\n        result = binding.onActivation(request.parentContext, result);\n    }\n\n```\nThis is much more code and work but it is needed by a feature that allows to create your own metadata reader. This was needed to allow people to create their own  custom anotation system.\nI'm happy to merge this PR now and refactor later? Please let me know if you want to do the refactor.\n. @AltekkeE I have merged it :tada: will try to do a release later tonight.\nAdding a wiki page about life cycle hooks sounds like a good idea :+1: \nDebugging unit test is quite a manual process now. I have to do something about it :cry: I can't remember the steps but you basically need to compile the test and then run mocha with debug brk and then plug VSCode.... Do you mind sending that as a PR? :+1: . Awesome thanks a lot for this :+1: . @jonfasking I agree with @lholznagel the error makes sense for me. Why do you want to start the app without controllers?\n. @jonfasking if you are not going to use controllers at all then, using inversify-express-utils might be an overkill. The utils are mostly a router and controller factory. Maybe you will be better off by creating an express app from scratch and adding inversify to your socket process. I have personally never used InversifyJS with sockets but I have no reasons to think that It will not work.\n@lholznagel I agree about adding a note in the docs to explain that it is mostly a helper to implement MVC architecture :+1: . Hi @jonfasking, this issue has now been resolved by https://github.com/inversify/inversify-express-utils/pull/97 and will be available in inversify-express-utils@5.2.0. Hi, thanks for this suggestion. Are you aware of @lazyInject? It uses a proxy already. I don't see how @hardInjectable would be different?. I think this is a very specific use case, it should not be part of the core module but I can show you a pattern to get around it:\n\nCreate an internal instance of Container. This instance is internal to your library and it is not exposed.\nCreate a lazyInject annotation using the Container instance defined in 1\nAllow the users of your library to pass their own Container instance to your library. You can then use container.merge or userContainer.parent = internalContainer to link the two containers.\n\n. Glad to hear ti worked :smile_cat: . @the-owl sorry about that! let's do the following then:\n\nPost -> httpPost\nPut -> httpPut\nPatch -> httpPatch\nHead -> httpHead\nDelete -> httpDelete\nMethod -> httpMethod\n\nI think the change in name is reasonable, for example in C# they use:\n```csharp\n[HttpGet]\npublic ActionResult Login() {\n    return View();\n}\n[HttpPost]\npublic ActionResult Login(string userName, string password) {\n    // do login stuff\n    return View();\n}\n```. I have a mongo / mongoose demo at https://github.com/stelltec/public-tech-demos/tree/master/nodejs-madrid-meetup/demo3 I hope it hels.. @asykes74 please let me know if this issue can be closed?. We actually need to change thre APIs:\n\nwhenInjectedInto\nwhenAnyAncestorIs\nwhenNoAncestorIs\n\nInstead of taking (Function|string) they should allow ServiceIdentifier<T>.\nts\ntype ServiceIdentifier<T> = (string | symbol | Newable<T> | Abstract<T>);\nThis means that 4 different types are allowed as arguments.\nSo the APIs will become:\n\nwhenInjectedInto(parent: ServiceIdentifier<T>) => interfaces.BindingOnSyntax<T>\nwhenAnyAncestorIs(parent: ServiceIdentifier<T>) => interfaces.BindingOnSyntax<T>\nwhenNoAncestorIs(parent: ServiceIdentifier<T>) => interfaces.BindingOnSyntax<T>\n\nAll these functions use typeConstraint. The typeConstraint function can handle the types string and Newable<T> cases. \n\n\nWe need unit tests to make sure that it also works in the Abstract<T> case (it should be covered).  \n\n\nWe also need to add support for the symbol case which means that we need a new } else if() {.\n\n\n. Yes, the plan sounds good for me :+1: For the test cases create a new file under the features folder (the inversify.test.ts is too long...).. Hi @theodesp  sorry for the late reply on this. I will get back to you ASAP (probably this weekend). Hi @theodesp sorry for the late reply, the book is taking all my time :cry: \nIn your example, you could solve the problem by using whenParentNamed instead of whenInjectedInto:\n```ts\n let TYPES = {\n    Ninja: \"Ninja\",\n    NinjaMaster: Symbol(\"NinjaMaster\"),\n    NinjaStudent: Symbol(\"NinjaStudent\"),\n    Weapon: \"Weapon\",\n};\nlet TAGS = {\n    lethal: \"lethal\",\n    nonLethal: \"non-lethal\"\n}\ncontainer.bind(TYPES.Ninja).to(NinjaMaster).whenTargetNamed(TAGS.lethal);\ncontainer.bind(TYPES.Ninja).to(NinjaStudent).whenTargetNamed(TAGS.nonLethal);\ncontainer.bind(TYPES.Weapon).to(Katana).whenParentNamed(TAGS.lethal); // here!\ncontainer.bind(TYPES.Weapon).to(Bokken).whenParentNamed(TAGS.nonLethal); // here!\nlet master = container.getNamed(TYPES.Ninja, \"lethal\");\nlet student = container.getNamed(TYPES.Ninja, \"non-lethal\");\n``\nIf thewhenInjectedIntoconstraint is checking the type identifier maybe it could be solved by using the class constructor (it can be accessed via the requests.binding.constructor property) usingwhenInjectedInto(NinjaMaster)andwhenInjectedInto(NinjaStudent)`.\nThanks for helping out :+1: \n. Thanks again for this :+1: I have merged the PR :tada: . Thanks :heart:  I'm just a human that drinks too much Redbull :wink: . I have merged your PR :tada: thanks a lot for the fix \ud83d\ude04 . @AltekkeE thanks for the PR \ud83d\udc4d sometimes we get failed builds for random reasons, this time it failed because of a timeout in PhanthomJS... I manually re-build it, it is running now but it should work :). Hi @akosyakov thanks for helping to find this one out \ud83d\udc4d  This is now implemented by #666 I was unable to display the dependency graph in the error messages but it shows something like:\n\nIt looks like there is a circular dependency in one of the 'toDynamicValue' bindings. Please investigate bindings withservice identifier 'B'. @theodesp this is needed indeed, feel free to send a PR :+1: . Thanks for the PR and sorry for the build issues. It was a time out in PhantomJS.. @Bloodjunkie sorry for the very late reply on this issue. InversifyJS has not been designed with AMD support in mind. I can imagine that it is possible to get it to work but these days AMD is very uncommon so investing in it is not worth it.\n\nAlso, inheritance is quite complicated to support, we have done everything that we could but the support for inheritance is not as smooth as we would like. Not our fault though because the problems are due to some technical limitations. We, therefore, recommend using composition over inheritance (this is a recommended OOP good practice anyway) and have also created a wiki pay with some help about common inheritance issues.\nI will close this issue as there is not much that we can do to help with either AMD or inheritance.. @tiagoschenkel thanks for reporting this issue, would you like to send a PR or you want one of us to look at this?  . Hi thanks for all the details, I think both isBoundNamed and isBoundTagged should check as well in parent/child containers. We can try to find ways to increase the binding performance (the lookup is not using a particularly fancy algorithm at the moment). However, I don't think to register a binding should be extremely fast. The important thing is to resolve bindings very fast.\nYour changes look good :+1: . PR merged and 4.3.0 released :tada:. Hi @theodesp thanks a lot for this PR :+1: great work once more :smile: . @tiagoschenkel thanks a lot for the PR :+1: nice work :smile: . Fixed by #616. @sanex3339 thanks a lot for this PR :+1:  . @sanex3339 I will release it during lunch time in a couple of hours :wink: . Thanks a lot for the PR @bloublou2014 :+1: . Done by #657. @GiorgioZett sorry for the very late reply on this. It looks like you are missing:\nts\ndecorate(injectable(), EventEmitter);\nWe have unit tests for this feature and no one else has reported issues with it so my guess is that this is a configuration issue. I will close this issue but please feel free to ask more questions using the comments, creating a new issue or contacting us in the chat.. I understand your suggestion but this kind of promotes using classes as identifiers. We actually want to promote using interfaces and also we want to keep the main library as lightweight as possible. For this reasons, I will not add this to the core library but I will share with you some alternatives.\nThe helper you implemented doesn't feel hacky to me. I have actually recommended doing similar things in the past (See \"Tip: Reducing boilerplate\" here).\nI recommend you to use inversify-binding-decorators.\nYou can use @provide or you can use autoProvide:\nYou can have an index file that exposes all your entities:\nts\nexport { default as Warrior } from \"./warrior\";\nexport { default as Katana } from \"./katana\";\nThen create bindings for all of them automatically:\n```ts\nimport * as entites from \"../entities\";\nlet container = new Container();\nautoProvide(container, entites);\n```\nPlease feel free to ask any questions. Thanks a lot for suggesting a feature and for using inversify.\n. @agomezgu sorry for the bad news but Angular has been designed to work with its own IoC containers and it is quite difficult to replace it by other IoC containers like InversifyJS. \nThe Http source code can be found here. As we can see the constructor looks as follows:\nts\n@Injectable()\nexport class Http {\n  constructor(protected _backend: ConnectionBackend, protected _defaultOptions: RequestOptions) {}\n// ...\nThe @injectable() annotation in that source code comes from angular not from inversify. We need to add a second annotation @injectable() from inversify. The problems is that we can't use a decorator because we are not the authors of this class. There is a solution for this problem mentioned by @AltekkeE in the previous comment:\n```ta\nimport { decorate, injectable } from \"inversify\";\nimport { Http } from \"@angular/http\";\ndecorate(injectable(), Http);\n```\nThen we can declare a binding:\ncontainer.bind<Http>(Http).toSelf();\nAnd finally we can try to resolve:\nts\nconst http = container.get<Http>(Http);\nThe problem is that the Http class needs two dependencies: ConnectionBackend and RequestOptions.\nYou can search for the source code of these two classes two see if they are public or private. If there are private there is nothing we can do (without ugly hacks). If they are public we can annotate them and declare bindings:\n```ts\nimport { RequestOptions, ConnectionBackend } from \"@angular/htttp\";\ndecorate(injectable(), RequestOptions);\ndecorate(injectable(), ConnectionBackend);\ncontainer.bind(ConnectionBackend).toConstantValue(ConnectionBackend);\ncontainer.bind(RequestOptions).toSelf();\n```\nNote that ConnectionBackend uses toConstantValue because it is an abstract class (I know this because saw this in the source code).\nThen we would have to repeat the operation for the dependencies of RequestOptions and ConnectionBackend and keep going. The worst part is that it is very likely that at some point you would find something private and you will not be able to continue.\nIn summary: I'm afraid that if your choice is angular, you will have to stick to the angular IoC container.\nI actually asked about this to the Angular team when InversifyJS was in its early days: https://github.com/angular/angular/issues/6885\n. Awesome! Looks good to me. Thanks for this PR! I will try to release this evening.. @mattmeye TypeScript limits the usage of decorators to classes no instances but I think I get what you are trying to achieve. Many controllers are a simple HTTP CRUD interface for some entity and it would be nice if we could use a generic controller. Instead of having to re-write the same code many times.\nI'm closing this issue because we already have an issue to support generic controllers. This is something that I personally want to fix somehow. So you can expect something to happen about it early next year. The issue is https://github.com/inversify/InversifyJS/issues/586. Hi @stephandrab \nThis is now implemented by https://github.com/inversify/InversifyJS/pull/719 and available in inversify@4.8.0 \ud83c\udf89  \nYou can now access the current request via context.currentRequest. The following code snippet is an example:\n```ts\n@injectable()\nclass Logger {\n    public named: string;\n    public constructor(named: string) {\n        this.named = named;\n    }\n}\nconst container = new Container();\nconst TYPE = {\n    Logger: Symbol.for(\"Logger\")\n};\ncontainer.bind(TYPE.Logger).toDynamicValue((context) => {\n    const namedMetadata = context.currentRequest.target.getNamedTag();\n    const named = namedMetadata ? namedMetadata.value : \"default\";\n    return new Logger(named);\n});\nconst logger1 = container.getNamed(TYPE.Logger, \"Name1\");\nconst logger2 = container.getNamed(TYPE.Logger, \"Name2\");\nexpect(logger1.named).to.eq(\"Name1\");\nexpect(logger2.named).to.eq(\"Name2\");\n``. Thanks for this PR :+1: . :+1: Thanks!. @r0bnet you can still use traditional express middleware. For example, [here](https://github.com/inversify/inversify-express-example/blob/master/MongoDB/bootstrap.ts#L33-L34) we use the helmet andbodyParsermiddleware`. You could add path specific middleware like for example:\nts\napp.use(\"/public\", express.static(\"public\"));\nYou could ofcourse, create your own just like in a traditional express app:\nts\napp.use(\"/public\", (req, res, next) => {\n  console.log('Time:', Date.now())\n  next()\n});. Done by #657. Hi, thanks for asking the question. I have answered this in SO.. Thanks for this PR \ud83d\udc4d . Thanks for the PR. Thanks a lot for the PR :+1: . Done by #661. Thanks for sharing your interest in the project. I just released inversify-restify-utils@3.3.0. I'm closing this issue.. Done by #666. Looks like you are missing:\nnpm install @types/node\nThe require and http modules are not used by InversifyJS so this is likely not to be a problem with InversifyJs.. the reflect-metadata.d.ts file is included in the npm module. Have you installed reflect metadata:?\n\nnpm install reflect-metadata. Sorry for not being able to help you. The only thing I can recommend is to maybe start with the basic example as project template? https://github.com/inversify/inversify-basic-example. This is strange, I have a few projects with \"types\": [\"reflect-metadata\"] and it has never been a problem.. Merged :tada: Thanks for the PR :+1: . You are using a very old not supported version (2.0.0-rc.14) the current version is 4.5.1 also the node version (5.4) is quite old the latest version is 9.0.\n\nThe following works but you will need to upgrade both node and inversify:\n```ts\nimport { Container, interfaces } from \"inversify\";\nconst container: interfaces.Container = new Container();\n``. I have implemented A, B and C https://github.com/inversify/inversify-express-utils/pull/72 and I have moved D to a new issue https://github.com/inversify/InversifyJS/issues/673. \n- [HttpContextdocs](https://github.com/inversify/inversify-express-utils#httpcontext)\n- [AuthProviderdocs](https://github.com/inversify/inversify-express-utils#authprovider). I'm adding this comment for future reference https://stackoverflow.com/questions/54218295/inject-httpcontext-into-inversifyjs-middleware/54233115#54233115. @PowerMogli would you like to try to send a PR, one of the reasons I didn't do it already is because it is an easy change and I was waiting for someone that maybe wants to contribute for the first time.... This is now done by https://github.com/inversify/inversify-binding-decorators/pull/64 and it is available ininversify-binding-decorators@3.1.0.. @PowerMogli Done :tada: https://github.com/inversify/inversify-binding-decorators/pull/65 and released ininversify-binding-decorators@3.2.0`. Docs:\n\nUsing @provide multiple times\nUsing @provideFluent multiple times. @PowerMogli I think I get you. Do you mind creating a separate issue, please? This feature could be complicated.\n\nWe probably want something like:\nts\n@provideSingleton(VIEWSTATE.ViewStateSynchronizer, TYPE.PatientComponentModel)\nBut that would require:\nts\ncontainer.bind(VIEWSTATE.ViewStateSynchronizer, TYPE.PatientComponentModel)\n         .to(PatientComponentModel)\nWhich I'm not sure about being possible. Let me think about this one because I think I can come up with a workaround. I will get back to you ASAP. Thanks for the PR :+1: I have shared it on twitter https://twitter.com/RemoHJansen/status/930041795018461184. This is now fixed \ud83c\udf89 https://github.com/inversify/InversifyJS/pull/716 it will be available in the next release.. You don't need to install the typings using npm (they are already included in the npm module). - If the .d.ts file included in @types/inversify-inject-decorators is not working the problem needs to be reported in https://github.com/DefinitelyTyped/DefinitelyTyped. They should flag the file as deprecated.\n\nIf the .d.ts file included in inversify-inject-decorators is not working then the problem should be reported here. However, I find this unlikely because the .d.ts file is auto-generated by the compiler.\n\nYou should avoid using @types/inversify-inject-decorators. In the docs we say:\n\nThe inversify-inject-decorators type definitions are included in the npm module and require TypeScript 2.0.\n. Just checked and the files seem to be correct:\n\ninversify-inject-decorators@3.0.3/dts/decorators.d.ts\nts\nimport { interfaces } from \"inversify\";\ndeclare function getDecorators(container: interfaces.Container): {\n    lazyInject: (serviceIdentifier: string | symbol | interfaces.Newable<any> | interfaces.Abstract<any>) => (proto: any, key: string) => void;\n    lazyInjectNamed: (serviceIdentifier: string | symbol | interfaces.Newable<any> | interfaces.Abstract<any>, named: string) => (proto: any, key: string) => void;\n    lazyInjectTagged: (serviceIdentifier: string | symbol | interfaces.Newable<any> | interfaces.Abstract<any>, key: string, value: any) => (proto: any, propertyName: string) => void;\n    lazyMultiInject: (serviceIdentifier: string | symbol | interfaces.Newable<any> | interfaces.Abstract<any>) => (proto: any, key: string) => void;\n};\nexport default getDecorators;\ninversify@4.5.1/dts/inversify.d.ts\nts\nexport { Container } from \"./container/container\";\nexport { ContainerModule } from \"./container/container_module\";\nexport { injectable } from \"./annotation/injectable\";\nexport { tagged } from \"./annotation/tagged\";\nexport { named } from \"./annotation/named\";\nexport { inject } from \"./annotation/inject\";\nexport { optional } from \"./annotation/optional\";\nexport { unmanaged } from \"./annotation/unmanaged\";\nexport { multiInject } from \"./annotation/multi_inject\";\nexport { targetName } from \"./annotation/target_name\";\nexport { postConstruct } from \"./annotation/post_construct\";\nexport { MetadataReader } from \"./planning/metadata_reader\";\nexport { guid } from \"./utils/guid\";\nexport { interfaces } from \"./interfaces/interfaces\";\nexport { decorate } from \"./annotation/decorator_utils\";\nexport { traverseAncerstors, taggedConstraint, namedConstraint, typeConstraint } from \"./syntax/constraint_helpers\";\nexport { getServiceIdentifierAsString } from \"./utils/serialization\";\nYou need to install both inversify and inversify-inject-decorators. This could be a configuration issue. For example, you might be using an old version of TypeScript.\nI would recommend using the basic example as project template https://github.com/inversify/inversify-basic-example. @ae-draft no problem, thanks for using inversify :+1: . Hi, thanks for reporting this issue. We need to investigate this one better it is not the first time that this issue is mentioned to me but it is weird because I've been using this config in many projects and I never experienced this issue. One thing that I just noticed is that everybody experiencing the issue seems to be using create-react-app so my guess is that something else is going one in the  create-react-app config.. I have spent some time trying to test this but create-react-app my-app --scripts-version=react-scripts-ts failed for me. I will close this issue because it seems like a typescript or create-react-app or config issue not an issue with inversify.. Turns out that this is not an error.\nThis error may seem a bit misleading because when using classes as service identifiers @inject annotations should not be required and if we do add an annotation like @inject(Dom) or @inject(DomUi) we will still get the same exception.  This happens because, at the point in time in which the decorator is invoked, the class has not been declared so the decorator is invoked as @inject(undefined). This trigger InversifyJS to think that the annotation was never added. The solution is to use Symbol.for(\"Dom\") as service identifier instead of the class Dom.\nI have added some test at https://github.com/inversify/inversify-inject-decorators/pull/40/. I have documented this @ https://github.com/inversify/InversifyJS/blob/master/wiki/classes_as_id.md#known-limitation-classes-as-identifiers-and-circular-dependencies. Hi, thanks for reporting this issue. I was unable to reproduce this issue. I was able to run the following code snippet without issues:\n```ts\nimport { Container } from \"inversify\";\nimport { makeProvideDecorator } from \"inversify-binding-decorators\";\nimport \"reflect-metadata\";\nconst container = new Container();\nconst provide = makeProvideDecorator(container);\nexport const Controllers = Symbol.for(\"cashfarm.tractor.controllers\");\nexport function Controller(target: any) {\n  try {\n    console.log(Providing ${target.name} controller);\n    provide(Controllers)(target);\n  } catch (e) {\n    throw new Error(Error decorating controller ${target.name}: ${e.message});\n  }\n}\n@Controller\nclass Controller1 {\n    public id = \"Controller1\";\n}\n@Controller\nclass Controller2 {\n    public id = \"Controller2\";\n}\nconst controllers = container.getAll(Controllers);\nconsole.log(controllers);\n/\n[\n    Controller1 { id: 'Controller1' },\n    Controller2 { id: 'Controller2' }\n]\n/\n```\nCan you please check my example and find out if you are doing something different? Can you also please check that you are importing \"reflect-metadata\" only one time in your entire application?  . No problem @svallory the metadata keys can be found at /src/constants/metadata_keys.ts.  You can see here the one used by @injectable. So you should be able to try:\nts\nReflect.hasOwnMetadata(\"design:paramtypes\", target)\nIf it returns false it means that it is missing the @injectable annotation or that the metadata has been deleted. The metadata is deleted for example when \"reflect-metadata\"  is imported.. @svallory yes, that is why inversify or inversify-express-utils doesn't import it automatically.. This was implemented by https://github.com/inversify/inversify-express-utils/pull/80 and released in inversify-express-utils@5.0.0-beta.1 :tada:. Hi @sveinburne thanks for reporting this issue. Would you like to send a PR?. Yes that should be OK :+1: . @sveinburne I just released 4.5.2 \ud83c\udf89 . :+1: Thanks for the PR, I will try to do a release this weekend. Hi @babbarankit, do you have a sample repo? Can you provide some details about the error and stack, please? Thanks!. Hi @babbarankit your solution sounds good I have never used typeorm but If I have time I will try to create an official typeorm + inversify-express-utils example \ud83d\udc4d . @matthewjh The problem is that every time you call Symbol(\"XXXX\") you get a new unique symbol. For example, the following won't work:\nts\ncontainer.bind<UserRepository>(Symbol(\"UserRepository\")).to(UserRepository)\nts\n@inject(Symbol(\"UserRepository\"))\nThe above doesn't work because the symbols created in the first and second call of Symbol(\"XXXXX\") are two unique symbols.\nWe normally don't face this problem because we declare the symbol once in advance but I have experienced a problem in one project in which we load and unload modules dynamically and we declare symbols dynamically. Using Symbol.for(\"XXXXX\") will always return the same symbol and not cause any problems so it is safer.\n. A small application can probably work just fine with strings as IDs. As the application grows and especially if you have very large teams chances of two classes with the same name will increase and Symbol will prevent these collisions if on top of that you are doing dynamic stuff Symbol.for will protect you. \nIf you don't want to worry about this the best thing to do is to use Symbol.for and then you are safe for the future growth of your app.. Yes, they should. At least I was able to do it without problems. Do you have any thoughts about why it could be a problem? Maybe I'm missing something?. Thanks for the PR \ud83d\udc4d . Sorry for the late reply, glad you found a solution!. @Razzeee thanks a lot for the PR that was a big mistake, thanks for spotting it :+1: . They are the same. Check out this line in the code. I added aliases because some people wanted to explicitly remark that a function is going to be injected. We can also say toConstructor for example. A constructor is a function but if what we are trying to inject is not meant to be a constructor it could be misleading. So it is basically a way to describe better what you are trying to do.. Hi @JoshuaKGoldberg can this issue be closed? Thanks!. Closing this issue please feel free to ask more questions. Also, as a reference, if you are wondering about toConstructor / toDynamicValue / toFactory check out the following question on SO \ud83d\udc49 https://stackoverflow.com/questions/46867437/in-inversify-why-to-prefer-constructor-factory-injection-over-todynamicvalue/47055959#47055959\n. @nros it is because Binding.clone() is used for the container snapshot feature. When we create a snapshot and restore we want to ensure that the original binding is not mutated. If the new binding shares the singleton value with the old binding a mutation could be possible. Maybe Binding.clone() shuld be named Binding.snapshot() instead. I would also need to check to ensure that that is the only use case (maybe there is something else that I can't remember).. No worries :+1: Thanks for using inverisfy :100: . Hi @kiranagre we have two examples:\n\nWithout inversify-express-utils :point_right: https://github.com/inversify/inversify-basic-example\nWith inversify-express-utils :point_right: https://github.com/inversify/inversify-express-example. Hi @kiranagre I'm closing this issue. Feel free to ask questions using the comments or the chat..  I took a look but I was unable to find out what is wrong. It looks like it is a restify issue though...\n\nThe error is thrown when you import restify here.\nts\nimport * as restify from 'restify';\nImporting restify will import errorTypes.js as you can see here.\njs\nrequire('./errorTypes');\nThe errorTypes.js file leads us to restify-errors:\n```js\n'use strict';\nvar errors = require('restify-errors');\nerrors.makeConstructor('RequestCloseError');\nerrors.makeConstructor('RequestAbortedError');\n```\nAnd in restify-errors we can find the place in which the exception is thrown:\n```js\nfunction makeConstructor(name, defaults) {\nassert.string(name, 'name');\nassert.optionalObject(defaults, 'defaults');\n\n// code property doesn't have 'Error' in it. remove it.\nvar defaultCode = name.replace(new RegExp('[Ee]rror$'), '');\nvar d = _.assign({}, {\n    name: name,\n    code: (defaults && defaults.code) || defaultCode,\n    restCode: _.get(defaults, 'restCode', defaultCode)\n}, defaults);\n\n// assert that this constructor doesn't already exist.\nassert.equal(typeof module.exports[name], 'undefined',\n             'Constructor already exists!');\n\n// ...\n```\nI was debugging and I saw that the function makeConstructor in `` is invoked tree times:\n```js\nerrors.makeConstructor('RequestCloseError');\nerrors.makeConstructor('RequestAbortedError');\nerrors.makeConstructor('RequestCloseError'); // Error!!!\n```\nSomething invoking makeConstructor two times with the id \"RequestCloseError\". Which lead me to think that there is a weird issue in your app.\nI have created a PR for your repo https://github.com/MathieuDoyon/restify-inversify-errors/pull/1 as you can see removing the import:\nts\nimport * as restify from 'restify';\nFixes the problem. I actually tested something else and the problem is not the import, is the pre call:\n```ts\nimport * as restify from 'restify'; // OK\nconst pre = restify.pre; // Exception\n```\nI'm sorry I don't know what is happening :(\n. Hi @MathieuDoyon  can please try to upgrade to restify@6.3.4 and let us know if this issue can be closed? I will close it in a few days if there are no updates.. This change looks good to me. Are u planning to send a PR?. @JoshuaKGoldberg I noticed that we already have them https://github.com/inversify/InversifyJS/blob/e3b2871729aeb328ef5d2366282bffa4dc2c1a62/src/constants/literal_types.ts but they are not exposed. Closing this issue by https://github.com/inversify/InversifyJS/pull/718\nYou can now do:\n```ts\nimport { BindingScopeEnum, Container  } from \"inversify\";\nconst container = new Container({\n    defaultScope: BindingScopeEnum.Singleton,\n});\n```\nThis feature is available in 4.7.0 :tada:. Thanks a lot for the PR :+1: . Hi @JoshuaKGoldberg thanks for this PR I will try to push against your branch this evening. Please leave the PR open and don't delete your branch.. Hi @JoshuaKGoldberg if you merge https://github.com/JoshuaKGoldberg/InversifyJS/pull/1 the build in this PR should go green :smile: . @lholznagel thanks for the heads up, It is not a big deal. Id the performance test that fails sometimes.. @lholznagel but you mean in this PR, not in master right? This PR will be fixed once https://github.com/JoshuaKGoldberg/InversifyJS/pull/1 is merged. @JoshuaKGoldberg Just created https://github.com/JoshuaKGoldberg/InversifyJS/pull/3 The tests that capture the exceptions for circular dependencies fails sometimes because the exception is not always thrown at the exact same point in the call stack. I have changed the tests to allow two possible valid outcomes.. Hi @JoshuaKGoldberg sorry for the issues I tried to edit the code directly on GitHub and it had some lint issues. Please merge https://github.com/JoshuaKGoldberg/InversifyJS/pull/4 it should be the last one :crossed_fingers: . My mistake again :cry: this should be the final fix https://github.com/JoshuaKGoldberg/InversifyJS/pull/5. :+1: I will review all the changes and merge it later tonight. Thanks a lot for this PR \ud83d\udcaf . @JoshuaKGoldberg merged :tada: thanks a lot for your work . Hi, I will try to fix this as soon as I can but it might take me some time because I'm currently under pressure trying to finish my upcoming book (http://www.learningtypescript.com/). The problem as @m3l7 says is that we don't share the singletons. We did this because we didn't want to deep-clone the cached instances. I would like to achieve this without external dependencies which means that we are going to need a custom deep-clone function. If someone wants to send a PR it would be very welcome.. Blocked by https://github.com/nodejs/node/issues/17684. Replaced by https://github.com/inversify/InversifyJS/pull/717. Blocked by nodejs/node#17684. Hi @cyberhck thanks for the suggestion. \nWe are already using the emitted metadata and have a similar behavior.\nIn the aurelia example:\n```ts\nimport {CustomerService} from 'backend/customer-service';\nimport {CommonDialogs} from 'resources/dialogs/common-dialogs';\nimport {EventAggregator} from 'aurelia-event-aggregator';\nimport {autoinject} from 'aurelia-framework';\n@autoinject\nexport class CustomerEditScreen {\n  constructor(private customerService: CustomerService, private dialogs: CommonDialogs, private ea: EventAggregator) {\n    this.customer = null;\n  }\nactivate(params) {\n    return this.customerService.getCustomerById(params.customerId)\n      .then(customer => this.customer = customer)\n      .then(customer => this.ea.publish('edit', customer));\n  }\n}\n```\nThe entities injected are all classes: 'CustomerService', 'CommonDialogs' and 'EventAggregator'.\nWhen you use classes you can do the following in InversifyJS:\n```ts\nimport {CustomerService} from 'backend/customer-service';\nimport {CommonDialogs} from 'resources/dialogs/common-dialogs';\nimport {EventAggregator} from 'aurelia-event-aggregator';\nimport {injectable} from 'inversify';\n@injectable()\nexport class CustomerEditScreen {\n  constructor(private customerService: CustomerService, private dialogs: CommonDialogs, private ea: EventAggregator) {\n    this.customer = null;\n  }\nactivate(params) {\n    return this.customerService.getCustomerById(params.customerId)\n      .then(customer => this.customer = customer)\n      .then(customer => this.ea.publish('edit', customer));\n  }\n}\n```\nts\ncontainer.bind<CustomerEditScreen>(CustomerEditScreen).toSelf();\ncontainer.bind<CustomerService>(CustomerService).toSelf();\ncontainer.bind<CommonDialogs>(CommonDialogs).toSelf();\ncontainer.bind<EventAggregator>(EventAggregator).toSelf();\nYou only need the @inject annotations if you use interfaces:\n```ts\nimport {ICustomerService, ICommonDialogs, IEventAggregator} from './interfaces';\nimport {injectable} from 'inversify';\n@injectable()\nexport class CustomerEditScreen {\n  private customerService: ICustomerService;\n  private dialogs: ICommonDialogs;\n  private ea: IEventAggregator;\n  constructor(\n     @inject(\"ICustomerService\") customerService: ICustomerService,\n     @inject(\"ICommonDialogs\") dialogs: ICommonDialogs,\n     @inject(\"IEventAggregator\") ea: IEventAggregator\n  ) {\n    this.customer = null;\n  }\nactivate(params) {\n    return this.customerService.getCustomerById(params.customerId)\n      .then(customer => this.customer = customer)\n      .then(customer => this.ea.publish('edit', customer));\n  }\n}\n```\nWe need the annotation @inject(\"ICustomerService\") for interfaces because the metadata is emitted as Object which means that we don't have enough information to know what needs to be injected.\nSo my understanding is that in InversifyJS @injectable() works like @autoinject in Aurelia but only works with classes, not interfaces. Both Angular and Aurelia have the same problem.\nPlease let me know if this is what you were wondering and If I can close the issue.. It doesn't work with static methods \ud83d\ude22  but you can use @lazyInject in static properties, then the static method could use the static property.. @pirmax can you please double check if DatabaseRepository has a dependency on CompanyRepository?  Also can you please ensure that you are using the latest version of InversifyJS? Thanks. Closing this issue because of inactivity. Please feel free to create a new issue if you need help again.. Hi @matthewjh this is by design as reported by @btkostner but there are a few way to solve this problem as documented in our wiki I will close this issue but please feel free to create a new one if you have more questions.. I just merged the PR :tada: . Hi @DonJayamanne,\nI think this issue should be fixed by the reflect-metadata module. The reflect-metadata module is supposed to be a polyfill. I think it should not override itself everytime it is loaded.\nThe problem is somewhere in https://github.com/rbuckton/reflect-metadata/blob/master/Reflect.ts#L1697-L1715\nMany people have already reported similar issues:\nhttps://github.com/rbuckton/reflect-metadata/issues/78\nhttps://github.com/rbuckton/reflect-metadata/issues/45\n...\nBut the module seems to not be actively maintained :cry:  The module has been created by one of the TypeScript engineers at Microsoft. Since you guys work at vscode maybe you can contact him through Microsoft?\nThe reflect-metadata has actually become a very important module (It is used by +30K public repos) in the entire TypeScript ecosystem. I would actually like it to become something supported officially by Microsoft (like DefinitelyTyped). I wonder what @DanielRosenwasser thinks about this?\n. Hi @DonJayamanne about:\n\nIs it possible for Inversify not to use reflect-metadata or for a user of Inversify to provide the functionality exposed by reflect-metadata (by providing its own API for storage and retrieval of the metadata)?\n\nThis feature is not avaiable righ now but I started to work on it last night. I will provide you with an interface to read and write metadata. The default implementation of the interface will use reflect-metadata but you should be able to create your own implementations.\nAbout:\n\nAt the end of the day reflect-metadata is not an optional module of inversify, users of inversify MUST install reflect-metadata.\n\nThis is true, but only for a period of time. In theory, in the future reflect-metadata should only be required by browsers without native support for it. It could be conditionally loaded but we will still have problems if two other extensions use it.\n. @DonJayamanne I was trying to fix this issue in InversifyJS but after a few hours, I realized that there is not much that I can do. It needs to be fixed in the reflect-metadata package but even that is not a 100% safe solution because if an extension is using an outdated reflect-metadata or another polyfill that overrides the Reflect object we will hit the same issue. \nThis is something that needs to be addressed by the polyfill authors it should not have to be addressed by the lib authors or the vscode extension authors. \nThe other option would be that vscode could use isolated globals for each extension. That way extension and library authors would not have to worry but I don't know if this is an option. I have created an issue to ask for this https://github.com/Microsoft/vscode/issues/41297\n. Thanks a lot for the fix and release @rbuckton \ud83d\udc4d . @DonJayamanne I'm closing this issue. Thanks a lot for using InversifyJS :smile: . Thanks for the PR \ud83d\udc4d . Hi @yardz thanks for reporting this issue.\nYou need to use the following instead:\nstart\": \"nodemon --watch 'Basic/**/*.ts' --ignore 'Basic/**/*.spec.ts' --exec 'ts-node' Basic/bootstrap.ts\"\nI will close this issue now. Please feel free to create a new issue if you need additional help.. Thanks a lot @AltekkeE  :+1: . Hi @anteburazer, I don't remember any previous questions about Next.js and InversifyJS. I use InversifyJS mostly on the server-side so I don't see why it should not work. I would recommend to give it a go in a small experiment and ask more specific questions if you encounter any issues. We will be happy to help.. Hi @j I don't have experience with DataLoader but I took a quick look. I would try to avoid creating a container for each request if possible.\nYou should be able to do something like what I describe in the following code snippet. Please note that I have not tested it because I don't have enough time but it should give you an idea of the general architecture:\n```ts\nimport { injectable, inject, Container, interfaces as inversifyInterfaces } from \"inversify\";\nimport { controller, httpGet, BaseHttpController, interfaces, TYPE, InversifyExpressServer } from \"inversify-express-utils\";\nimport * as express from \"express\";\nimport * as DataLoader from \"dataloader\";\n// We implement Principal and CustomAuthProvider to support auth\nclass Principal implements interfaces.Principal {\n    public details: any;\n    public constructor(details: any) {\n        this.details = details;\n    }\n    public isAuthenticated(): Promise {\n        return Promise.resolve(true);\n    }\n    public isResourceOwner(resourceId: any): Promise {\n        return Promise.resolve(resourceId === 1111);\n    }\n    public isInRole(role: string): Promise {\n        return Promise.resolve(role === \"admin\");\n    }\n}\ninterface User {\n    // ...\n}\ninterface AuthService {\n    getUser(token: string): User;\n}\n@injectable()\nclass CustomAuthProvider implements interfaces.AuthProvider {\n    public async getUser(\n        req: express.Request,\n        res: express.Response,\n        next: express.NextFunction\n    ): Promise {\n        const token = req.headers[\"x-auth-token\"];\n        // Here I'm using the token as an user detail\n        // I'm doing this because your function genUsers\n        // expects a token but it would be better if it\n        // expected the current user. We could resolve the\n        // user here and pass its details to the principal\n        // Then you could access the user details via the\n        // HttpContext\n        const user = {\n            token: token\n        };\n        return new Principal(user);\n    }\n}\n// We then implement a service that gets the loaders injected: \nconst APP_TYPES = {\n    Loaders: \"Loaders\"\n};\ninterface Loaders {\n    users: DataLoader | null;\n}\nfunction genUsers(authToken: string, ids: number[]): Promise {\n    return Promise.resolve([]);\n}\nfunction createLoaders(authToken: string) {\n    return {\n        users: new DataLoader((ids: number[]) => genUsers(authToken, ids)),\n    };\n}\n@injectable()\n@controller(\"/some_service\")\nclass SomeService  extends BaseHttpController {\n@inject(APP_TYPES.Loaders) private readonly _loaders: Loaders;\n@httpGet(\"/\")\n  public get() {\n      if (this._loaders.users) {\n        return this._loaders.users.loadMany([1, 2, 3]);\n      }\n  }\n}\n// We can then use toDynamicValue and inRequestScope to create the binding for the loaders.\n// The inversify-express-utils module uses inRequestScope will ensure that only in instance is created\n// for each HTTP Request. We use toDynamicValue so we can access the HttpContext and then get the required token.\nconst container = new Container();\ncontainer.bind(\"Loaders\").toDynamicValue((ctx) => {\n    const httpContext = ctx.container.get(TYPE.HttpContext);\n    if (httpContext.user) {\n        return createLoaders(httpContext.user.details.token);\n    }\n    return {\n        users: null\n    };\n}).inRequestScope();\nconst server = new InversifyExpressServer(\n    container, null, null, null, CustomAuthProvider\n);\n```\nYou can learn more about:\n\nHttpContext\nAuthProvider\ninversify/inversify-express-utils\n\nI will close the question if you don't mind. Please feel free to create a new issue or comment below if you need additional help.. Thanks for the PR \ud83d\udc4d . Hi @jan-molak sorry but due to some changes in the last few versions, it is not possible now. \nWe use the @controller to create some metadata. Then when the server is created we read the metadata to find all the controllers in the application and declare all the routes.\nYou can check how @controller works:\nhttps://github.com/inversify/inversify-express-utils/blob/master/src/decorators.ts#L8-L40\nThis change is part of a bigger plan: \n\n\nWe are working on a module that will be able to auto-generate the OpenApi specification but it is not ready yet. \n\n\nWe are working on a framework that will provide an API with a much higher level of abstraction https://github.com/ZafiroJS/\n\n\nIf you don't want to use a decorator you can try to use it as a function.\nts\ncontroller(path, middleware)(SomeClass);\nBut that is probably not what you need?. Hi @kristianmandrup an identifier can be 3 things:\nA class\nts\ncontainer.bind<Weapon>(Katana).to(Katana).whenTargetTagged(\"canThrow\", false);\nOr the shortcut:\nts\ncontainer.bind<Weapon>(Katana).toself().whenTargetTagged(\"canThrow\", false);\nThen you can use the following to inject:\nts\n@injectable{ \nclass SomeClass {\n    public constructor(@inject(Katana) @tagged(\"canThrow\", false) weapon: Weapon) {\n       // ...\nBut when we use classes we are missing the benefits of the dependency inversion principle.\nA string\nts\ncontainer.bind<Weapon>(\"Katana\").to(Katana).whenTargetTagged(\"canThrow\", false);\nThen you can use the following to inject:\nts\n@injectable{ \nclass SomeClass {\n    public constructor(@inject(\"Katana\") @tagged(\"canThrow\", false) weapon: Weapon) {\n       // ...\nA symbol\nts\nconst KatanaId = Symbol.for(\"Katana\");\ncontainer.bind<Weapon>(KatanaId).to(Katana).whenTargetTagged(\"canThrow\", false);\nThen you can use the following to inject:\n@injectable{ \nclass SomeClass {\n    public constructor(@inject(KatanaId) @tagged(\"canThrow\", false) weapon: Weapon) {\n       // ...\nYou can learn more about symbols at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\nI think this should be enough to answer your question, I will close the issue now but please feel free to ask more questions if you need additional help. Also please refer to our wiki, we have more info in it about identifiers.\nhttps://github.com/inversify/InversifyJS/tree/master/wiki\n. Thanks a lot for the PR \ud83d\udc4d . I have two potential solutons in mind:\nA) Use toFactory\nYou need to invoke the factory:\n```ts\nimport { inject, injectable, Container, interfaces } from \"inversify\";\nimport \"reflect-metadata\";\ntype FactoryOfWeapon = (parent: IWeaponHolder) => IWeapon;\nconst TYPE = {\n    OrphanWeapon: Symbol.for(\"OrphanWeapon\"),\n    FactoryOfWeapon: Symbol.for(\"FactoryOfWeapon\"),\n    WeaponName: Symbol.for(\"WeaponName\"),\n    WeaponHolder: Symbol.for(\"WeaponHolder\")\n};\ninterface IWeapon {\n    parent: IWeaponHolder;\n    use(): string;\n    owner(): string;\n}\ninterface IWeaponHolder {\n    name: string;\n    weapon: IWeapon;\n    fight(): string;\n}\n@injectable()\nclass Weapon implements IWeapon {\n    private readonly _name: string;\n    public parent: IWeaponHolder;\npublic constructor(\n    // We can inject stuff into Weapon\n    @inject(TYPE.WeaponName) name: string\n) {\n    this._name = name;\n}\n\npublic use() {\n    return this._name;\n}\n\npublic owner() {\n    return `Owned by ${this.parent.name}!`;\n}\n\n}\n@injectable()\nclass Character implements IWeaponHolder {\n    public weapon: IWeapon;\n    public name: string;\n    public constructor(\n        // We can inject stuff into Character\n        @inject(TYPE.FactoryOfWeapon) factoryOfWeapon: FactoryOfWeapon\n    ) {\n        this.name = \"Ninja\";\n        this.weapon = factoryOfWeapon(this); // <---- THIS IS THE PART THAT YOU ARE MISSING!\n    }\n    public fight() {\n        return Using ${this.weapon.use()}!;\n    }\n}\nconst container = new Container();\n// We inject a string just to demostrate that we can inject stuff into Weapon\ncontainer.bind(TYPE.WeaponName).toConstantValue(\"Katana\");\n// We declare a binding for Weapon so we can use it within the factory\ncontainer.bind(TYPE.OrphanWeapon).to(Weapon);\ncontainer.bind(TYPE.FactoryOfWeapon).toFactory((ctx: interfaces.Context) => {\n    return (parent: IWeaponHolder) => {\n        const orphanWeapon = ctx.container.get(TYPE.OrphanWeapon);\n        orphanWeapon.parent = parent;\n        return orphanWeapon;\n    };\n});\ncontainer.bind(TYPE.WeaponHolder).to(Character);\nconst character = container.get(TYPE.WeaponHolder);\nconsole.log(character.fight());\nconsole.log(character.weapon.owner());\n```\nB) Use onActivation and inRequestScope\nIf you really don't want to invoke the factory, you can do the following:\n\n:warning: Note: this solution is less efficient than option A\n\n```ts\nimport { inject, injectable, Container, interfaces } from \"inversify\";\nimport \"reflect-metadata\";\ntype FactoryOfWeapon = (parent: IWeaponHolder) => IWeapon;\nconst TYPE = {\n    WeaponName: Symbol.for(\"WeaponName\"),\n    WeaponHolder: Symbol.for(\"WeaponHolder\"),\n    Weapon: Symbol.for(\"Weapon\")\n};\ninterface IWeapon {\n    parent: IWeaponHolder;\n    use(): string;\n    owner(): string;\n}\ninterface IWeaponHolder {\n    name: string;\n    weapon: IWeapon;\n    fight(): string;\n}\n@injectable()\nclass Weapon implements IWeapon {\n    private readonly _name: string;\n    public parent: IWeaponHolder;\npublic constructor(\n    // We can inject stuff into Weapon\n    @inject(TYPE.WeaponName) name: string\n) {\n    this._name = name;\n}\n\npublic use() {\n    return this._name;\n}\n\npublic owner() {\n    return `Owned by ${this.parent.name}!`;\n}\n\n}\n@injectable()\nclass Character implements IWeaponHolder {\n    public weapon: IWeapon;\n    public name: string;\n    public constructor(\n        @inject(TYPE.Weapon) weapon: IWeapon\n    ) {\n        this.name = \"Ninja\";\n        this.weapon = weapon; // No need for factory :)\n    }\n    public fight() {\n        return Using ${this.weapon.use()}!;\n    }\n}\nconst container = new Container();\n// We inject a string just to demostrate that we can inject stuff into Weapon\ncontainer.bind(TYPE.WeaponName).toConstantValue(\"Katana\");\n// The inRequestScope is important here\ncontainer.bind(TYPE.Weapon).to(Weapon).inRequestScope();\n// We can use onActivation adn search for Weapon in the inRequestScope\ncontainer.bind(TYPE.WeaponHolder)\n    .to(Character)\n    .onActivation((ctx: interfaces.Context, weaponHolderInstance: IWeaponHolder) => {\n        const scope = ctx.plan.rootRequest.requestScope;\n        if (scope) {\n            // We search in the entire inRequestScope, this\n            // takes O(n) execution time so It is slower than the factory\n            const weaponInstance = Array.from(scope.values())\n                                        .find(v => v instanceof Weapon);\n            weaponInstance.parent = weaponHolderInstance;\n        }\n        return weaponHolderInstance;\n    });\nconst character = container.get(TYPE.WeaponHolder);\nconsole.log(character.fight()); // Using Katana!\nconsole.log(character.weapon.owner()); // Owned by Ninja!\n```. I'm closing this issue. Please feel free to open a new issue or comment here if you need additional help.. Thanks @kristianmandrup happy to help.  I have added it to our wiki https://github.com/inversify/InversifyJS/blob/master/wiki/recipes.md#using-request-scope-and-activation-handlers-to-avoid-factories-when-working-with-circular-dependenies. Hi @kristianmandrup I'm not sure about knowing what you need but looks to me like you need to look at contextual constraints to avoid duplication. \nFor example, instead of:\nts\ncontainer.bind<IWeapon>(TYPE.OrphanWeapon).to(Weapon);\ncontainer.bind<IShield>(TYPE.OrphanShield).to(Shield);\ncontainer.bind<IWeaponHolder>(TYPE.WeaponHolder).to(Character);\ncontainer.bind<IShieldHolder>(TYPE.ShieldHolder).to(Character);\nYou can do:\n```ts\ncontainer.bind(TYPE.Weapon).to(Weapon).whenAnyAncestorsNamed(\"weapon_holder\");\ncontainer.bind(TYPE.Weapon).to(Shield).whenAnyAncestorsNamed(\"shield_holder\");\ncontainer.bind(TYPE.Warrior).to(Character);\nconst weaponHolder = container.getNamed(TYPE.Warrior, \"weapon_holder\");\nconst shieldHolder = container.getNamed(TYPE.Warrior, \"shield_holder\");\n```\nYou can use the same Warrior class and inject a shield or a weapon based on the name metadata.\n. Hi @buehler, I tried to take a look to your code but I was unable to find lazyInject. It looks to me like there is some sort of issue with the modules.  The error seems to be at:\n\n/src/declarations/workspace-declarations.js:24:11\n\nMy guess is that workspace-declarations.js had a dependency on ioc.js because it was importing lazyInject` but at runtime the import is not a funcion.\nI would try to debug the following to see what is happening. I would expect this issue to be reported by many but so far this is the first case so my guess is that is is likely something wrong with the modules not with inversify-inject-decorators:\nconst decorators = getDecorators(container);\nconst lazyInject = decorators. lazyInject;\nPlease let me know how it goes and feel free to ask more questions I will b happy to try to help.\n. Closing this issue because it has been fixed by #774 and it has already been released.. Make sure that your controller is using extends BaseHttpController. That would allow you to access httpContext:\n```ts\nimport { injectable, inject } from \"inversify\";\nimport { controller, httpGet, BaseHttpController } from \"inversify-express-utils\";\n@controller(\"/\")\nclass UserPreferencesController extends BaseHttpController {\n@inject(\"AuthService\") private readonly _authService: AuthService;\n\n@httpGet(\"/\")\npublic async get() {\n    const token = this.httpContext.request.headers[\"x-auth-token\"];\n    return await this._authService.getUserPreferences(token);\n}\n\n}\n```\nThen you can also use authprovider:\nts\nconst server = new InversifyExpressServer(\n    container, null, null, null, CustomAuthProvider\n);\nThis will make the user available as a property of the httpContext:\n```ts\n@controller(\"/\")\nclass UserDetailsController extends BaseHttpController {\n@inject(\"AuthService\") private readonly _authService: AuthService;\n\n@httpGet(\"/\")\npublic async getUserDetails() {\n    if (this.httpContext.user.isAuthenticated()) {\n        return this._authService.getUserDetails(this.httpContext.user.details.id);\n    } else {\n        throw new Error();\n    }\n}\n\n}\n```\nYou can learn more in the docs:\n\nhttpcontext\nauthprovider\n\nI'm closing this issue. Please feel free to open a new issue or comment here if you need additional help.. Hi @eloyleonardo I will close this issue now because it has been inactive for a week. Please feel free to create a new issue or use the comments if you have more questions.. Thanks for the PR.\nThe problem\nI'm not sure about the helper isSimpleFunction. If someone uses:\nts\n@inject(SomeClass)\nIt could be a problem:\n```ts\nclass SomeClass { }\nfunction someFunction() { }\nfunction isSimpleFunction(value: any): value is () => T {\n    return typeof value === \"function\" && value.length === 0;\n}\nconsole.log(\n    isSimpleFunction(someFunction), // true\n    isSimpleFunction(SomeClass), // true !!!! <---- FALSE POSITIVE\n    isSimpleFunction(\"SomeClass\"), // false\n    isSimpleFunction(Symbol.for(\"SomeClass\")), // false\n);\n```\nThe solution\nI think we are going to need a class so the users can use:\nts\n@injec(new LazyServiceIdentier(() => SomeClass))\nThe class could be something very simple:\nts\nclass LazyServiceIdentier<T> {\n    private _cb: () => interfaces.ServiceIdentifier<T>;\n    public constructor(cb: () => interfaces.ServiceIdentifier<T>) {\n        this._cb = cb;\n    }\n    public get() {\n        return this._cb();\n    }\n}\nSo the check function can become:\nts\nfunction isLazyServiceIdentier<T>(value: any): value is () => T {\n    return value instanceof LazyIServiceIdentier;\n}\nThat should work:\n```ts\nclass SomeClass {}\nfunction SomeFunction() {}\nconsole.log(\n    isLazyServiceIdentier(SomeClass), // false\n    isLazyServiceIdentier(\"SomeClass\"), // false\n    isLazyServiceIdentier(Symbol.for(\"SomeClass\")), // false\n    isLazyServiceIdentier(someFunction), // false\n    isLazyServiceIdentier(new LazyServiceIdentier(() => SomeClass)), // true\n    isLazyServiceIdentier(new LazyServiceIdentier(() => \"SomeClass\")), // true\n    isLazyServiceIdentier(new LazyServiceIdentier(() => Symbol.for(\"SomeClass\"))) // true\n);\n```\n. Great, thanks a lot.\nAlso if you don't mind, can you please also change:\n```ts\nfunction inject(serviceIdentifierOrFunc: ServiceIdentifierOrFunc) {\n  if (serviceIdentifierOrFunc === undefined) {\n    throw new Error(UNDEFINED_INJECT_ANNOTATION); // <-- Too early to know the target\n  }\nreturn function(target: any, targetKey: string, index?: number): void {\n      // ...\n  };\n}\n```\nFor:\nts\nfunction inject(serviceIdentifierOrFunc: ServiceIdentifierOrFunc) {\n  return function(target: any, targetKey: string, index?: number): void {\n      if (serviceIdentifierOrFunc === undefined) {\n          throw new Error(UNDEFINED_INJECT_ANNOTATION(target.name)); // <--- Target ready\n      }\n      // ...\n  };\n}\nYou will be able to create a more concrete error msg. Something like:\nts\nexport const UNDEFINED_INJECT_ANNOTATION = (name: string) => {\n    return `@inject called with undefined this could mean that the class ${name} has `\n           \"a circular dependency problem. You can use a LazyServiceIdentier to  \" + \n           \"overcome this limitation.\";\n};\n. @krzkaczor looking great \ud83d\udcaf thanks a lot for the PR, awesome contribution \ud83d\udc4d  I will do a release now.. Thanks for the suggestion. I have created an entry about this in the wiki https://github.com/inversify/InversifyJS/blob/master/wiki/circular_dependencies.md . @m3l7 thanks for the PR, please don't close it. I don't have enough time to help this week but I will send a PR to your work next week. We can then merge both changes. I would like to tell you how to fix the references issue but I'm not sure right now I will have to experiment a little bit.... Thanks a lot for the PR :100: . Hi @dcherman thanks a lot for the praising inversify and this suggestion. I like this idea as you have already noticed I'm a big fan of .net Web API \ud83d\ude04 I will be happy to accept a PR, it is a nice contribution \ud83d\udc4d My only recommendation is to try to use the same names used by .Net (https://msdn.microsoft.com/library/system.net.http.httpresponsemessage.aspx).\n. I can imagine that in the long-term feature this will become very feature-rich and we might need something like IActionResult. Is it possible to use IActionResult even if it is just a minimal implementation so we can prevent breaking changes in the future?. I like the idea of implementing the only the minimal set of features as you said but in a way that allows us to add more if need with ease and without breaking changes. In my experience, it is better to avoid features until they are actually needed for a real use case.. @ankitcf this was a delivered decision with the goal of supporting request scope because it was needed to support HttpContext and AuthProvider. You can make the dependencies of your controller singleton with inSingletonScope or inRequestScope (singleton per HTTP request). Why do you need a singleton at controller level? Maybe I can help you to find an alternative way.. Yes, you are right, it is not a good idea for high throughput systems but our goal so far has been to provide developers with a nice API that they enjoy and allows them to write applications that are easier to read and maintain. Of course, we care about performance too but it is a secondary goal. Also for high throughput systems, people will probably skip express.js for something like fastify or even skip node.js altogether. \nI will close this issue now, but please feel free to ask more questions if you wish to know more.\n. Hi @dcherman thanks for asking. The problem is that you cannot use \"\" as a child of \"/\". The routes defined by @controller('/') are joined to the routes defined by methods like @httpGet('*') so it was trying \"/\". There are two solutions:\nA) Using inversify-express-utils\nI'm not sure but I think the problem is that you cannot define the \"*\" as an action you can try the following:\n```ts\n@controller(\"*\")\nclass NotFoundController {\n  @httpGet(\"/\")\n  public async index() {\n    return Promise.resolve(\"not found!\");\n  }\n}\n@controller(\"/\")\nclass HomeControllee {\n@httpGet(\"/\")\n  public index() {\n    return Promise.resolve(\"home!\");\n  }\n}\nconst container = new Container();\nconst server = new InversifyExpressServer(container);\nconst app = server.build();\napp.listen(3000, () => {\n  console.log(\"Listening on port 3000...\");\n});\n```\nb) Using express.js\n```ts\nconst server = new InversifyExpressServer(container);\n// Info: https://github.com/inversify/inversify-express-utils/blob/752a68310e3ea515c0c47a757413fe38ee1f00f4/src/server.ts#L71-L82\nserver.setErrorConfig((app) => {\n    // Catch and log all exceptions\n    app.use(exceptionLoggerMiddleware);\n});\n// Info: https://github.com/inversify/inversify-express-utils/blob/752a68310e3ea515c0c47a757413fe38ee1f00f4/src/server.ts#L58-L69\nserver.setConfig((app) => {\n    app.use(helmet());\n});\n// Loads constrollers and initializes routing\nconst app = server.build();\n// The route for /\napp.get(\"/\", (req: express.Request, res: express.Response) => {\n    res.redirect(homePath);\n});\n// The last route should be a global handler for 404 errors\napp.get(\"*\", (req: express.Request, res: express.Response) => {\n    res.redirect(notFoundPath);\n});\n```\nThis should solve your problem so I'm closing the issue. Please feel free to ask again if you need additional help.. Thanks for the PR \ud83c\udf08 \ud83d\udc4d . Thanks for the PR :). Hi @JoshuaKGoldberg I don't know if I'm getting you. Is InjectionTypes.Dependency is a class @inject(InjectionTypes.Dependency) should work with:\nts\ncontainer.bind<typeof InjectionTypes.Dependency>(InjectionTypes.Dependency).toSelf();\nBut based on your second example: \ntype MyInjections = {\n    Dependency: typeof Dependency;\n};\nI'm wondering if InjectionTypes.Dependency is a class? because typeof Dependency is not a class.\nIf using a class maybe the problem is that when @inject(InjectionTypes.Dependency) is invoked (when the class declaration is executed) maybe it is likely to be too early for InjectionTypes.Dependency to be declared. The latest release has a fix for this called LazyServiceIdentifer:\n```ts\nimport { LazyServiceIdentifer, inject } from \"inversify\";\n// ...\n@inject(new LazyServiceIdentifer(() => InjectionTypes.Dependency))\n```\nYou can also declare a helper:\n```ts\nconst lazyEvaluatedInject = (id: any) =>  inject(new LazyServiceIdentifer(() =>id));\n// ...\n@lazyEvaluatedInject(InjectionTypes.Dependency)\n```\n. @akosyakov we don't have custom ts-rules but I'm sure that it could be something that people could find useful. Are you planning to implement them?. @sanex3339 see updated API. It will be blackguards compatible.. @JoshuaKGoldberg sorry for the late reply. I'm finishing my new book and I've been out of GitHub for weeks. Thanks a lot for the PR it is a nice feature :+1: . @kbirger very good PR thanks a lot  :100: . Hi @jacobEAdamson awesome PR! thanks a lot for this contribution :100: . @ashraymehta @AltekkeE I have released 6.0.0. You can rollback to 5.2.1 or upgrade to 6.0.0. Sorry for any inconvenience caused.. @akosyakov seems like we need to implement rebindNamed and rebindTagged()?. Hi guys, I think I know what is happening but I'm not sure about being able to support it. I'm also not sure about it being a good idea even if we can support it.\nBasically only derived controllers can be decorated with @controller. You can do the following:\n```ts\n@injectable()\nclass BaseController {\n    public getPublicThings() {\n        return { things: [\"a\", \"b\"] };\n    }\n}\n@controller(\"/api/test\")\nclass PublicController  extends BaseController {\n    constructor(/ deps /) {\n        super(/ deps /);\n    }\n    @httpGet(\"/public-things\")\n    public getPublicThings() {\n        return { things: [\"a\", \"b\"] };\n    }\n}\n@controller(\"/api-int/test\")\nclass TestController extends BaseController {\n    constructor(/ deps /) {\n        super(/ deps /);\n    }\n@httpGet(\"/private-things\")\npublic getPrivateThings() {\n    return { things: [\"c\", \"d\"] };\n}\n\n}\n```\nI think we should investigate how difficult is to support both parent and dserived controllers to define routes. If the complexity is too high then we should avoid implementing it and throw an error that helps users to understand that they cannot do that.\n. Hi @TheAifam5 my understanding is that web extensions use a completely independent execution environment form the application environment. This means that the reflect-metadata module needs to be imported from both the app and the extension. Then your next problem is going to be that the extension and the app cannot share memory. So if you want them to be able to talk to each other you are going to need to create a set of serializable messages. I'm afraid we are not going to be able to provide you with much support here because we know very little about extensions. Maybe you can ask at the Mozilla channels https://discourse.mozilla.org/c/add-ons ?  I will close this issue because I don't think we can do anything else.. Hi @mgebundy the core maintainers are more focused on express than restify because we use it at work everyday. The restify package was contributed by someone outside of the core team. We try to maintain it. Merging PRs and doing releases but we don't actively try to add new features. If you are interested in actively maintainn it to keep it up to date witht he express utils that would be much appreciated. I will do a release at some point later today.. Hi @mgebundy  I have released inversify-restify-utils@3.4.0. I should be more active soon, I've been very busy for months trying to finish a book.. Hi @zerox12311, unfortunately, we don't have an example but in theory, there should be no problems with it. You will need to create a controller just like any other controller in inversify-express-utils. There are examples of that in the repo. In graphql, you will need to create one single endpoint. Instead of having multiple controllers with multiple endpoints you will have only one. That controller can have dependencies injected just like any other controller in inversify-express-utils.. Hi @AlexTugarev @dcavanagh and I are looking into this. We need to be able to run all our tests in ES5 and ES6 so we need to do some changes to our CI. Will try to solve this as soon as we can.. @shlomokraus @eropple I think this is a good idea. We need to come up with a proposal for potential changes in the API and once we all agree we will be able to implement it. PRs are welcome so if you guys would like to contribute we should be able to help and guide you.. @Moln hi sorry but as we added features the library is probably now over 4KB. I don't know what is the current size. I assume that if you enable tree-shaking in Webpack it can probably be reduced to only the bits you need.. Hi @shaunc you are right at the moment I don't have a lot of time. @dcavanagh has been helping me but we need more contributions. We are happy to assist if someone wants to tackle an issue. Are there any particular issues that are urgent for you?. I understand your concerns the project is not abandoned but profess will be slow. However, I can tell you that I work at a startup and we really heavily on Inversify so if there are major issues they will be resolved. The package ahs continue to grow because it might not be evolving fast but it is reliable.. Thanks for the feedback, we will try to keep a changelog from now on. :+1: thanks a lot for the review :100: I have done those changes at https://github.com/inversify/InversifyJS/pull/491. ",
    "ulrichb": "The link above is dead. Could you post a new one with the browserify sample?\n. In the just released 2.0.0-rc.14, the dist-dir disappeared. \nIs this as intended?\n. ",
    "sanex3339": "Right now in my project i find some workaround with help of gulp.\nAfter typescript compiling but before minification, i parse with regexp current stream content (gulp-data plugin), find any functions arguments matched to pattern like: ISettings, IParams, IInterfaceA. And then push them into array and put that array as except parameter for uglify2 plugin.\njavascript\nlet reservedVariables = [];\n``` javascript\n.pipe(ts({\n            out:  'output.js',\n            typescript: require('typescript')\n        }))\n.pipe(data(function(file) {\n            let results,\n                result,\n                res;\n        results = String(file.contents).match(/function[^(]*\\(([^)]*)\\)/g);\n\n        for (result in results) {\n            res = results[result].match(/function[^(]*\\(([^)]*)\\)/)[1].split(',');\n\n            res.forEach((value) => {\n                if (value === '') {\n                    return false;\n                }\n\n                if (/I[A-Z]\\w*/.test(value)) {\n                    reservedVariables.push(value);\n                }\n            });\n        }\n\n        reservedVariables = reservedVariables.filter(function (value, index, self) {\n            return self.indexOf(value) === index;\n        });\n\n        return  reservedVariables;\n    }))\n\n.pipe(uglify({\n            mangle: {\n                except: reservedVariables\n            }\n        }))\n``\n. Looks like typings duplication. Did you completely remove old typings folder?\nhttps://github.com/DefinitelyTyped/DefinitelyTyped/issues/10729\n. Version 3.0.0-beta.2. Yep, i done practically same thing simultaneously with your comment. Thank you for quick response and amazingInversify`!. I can try to do it in weekend.. I made some changes and update few tests but my MacBook Air just dying on that project so very hard to write additional tests, IDE is freezes.\nhttps://github.com/sanex3339/InversifyJS/commit/2ef3c17d975ed56e39e83272a6c39c150640a801\nI can make PR with this changes, but i think this changes should be covered by additional tests.. When i can expect beta version with this?. Amazing, thank you!. Hmm. Strange behaviour with Symbol('blablabla').toString(). \nhttps://ci.appveyor.com/project/remojansen/inversifyjs/build/282/job/l5lqfu0fgkj11u6c#L1667\n@@blablabla result in IE11 and PhantomJS doesn't look like a standard behaviour for Symbol.\nhttps://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toString\n. > If no bindings match the name no bindings will be returned.\nLooks like you didn't understand me, because my bad english.\nThe problem is when i have only one named binding 'YYY' with service idendtifier 'A', when i will try to get from container dependency with service identifier 'A' but with name 'XXX' (which is not exist in the container), i will get (only one available in the container) named dependency with name 'YYY', like it is default binding. For my side this is strange, an error should trow.\nWhen i have two or more binding with names 'XXX' and 'YYY' with service identifier 'A', when i will try to get from container dependency with service identifier 'A' but with name 'ZZZ' (which is not exist in the container), i will get an error, as expected.. Thank you!. Thank you. Thank you, i did it, with toConstructor i still should add resolved constructors to the cache (because resolve time still about 0.15ms, but with constructors i can use cache and overall time of factory call now about 0.005-0.01ms\n```ts\n// customNode factory\nbind(ServiceIdentifiers['Factory'])\n    .toFactory((context: interfaces.Context) => {\n        const cache: Map > = new Map();\n    let cachedOptions: IOptions;\n\n    return (customNodeName: CustomNodes) => {\n        if (!cachedOptions) {\n            cachedOptions = context.container.get<IOptions>(ServiceIdentifiers.IOptions);\n        }\n\n        if (cache.has(customNodeName)) {\n            return new (<interfaces.Newable<ICustomNode>>cache.get(customNodeName));\n        }\n\n        const constructor: interfaces.Newable<ICustomNode> = context.container\n            .getNamed<interfaces.Newable<ICustomNode>>(\n                ServiceIdentifiers.ICustomNode,\n                customNodeName\n            );\n\n        cache.set(customNodeName, constructor);\n\n        return new constructor(cachedOptions);\n    };\n});\n\n```. I like this.\nIn my project i need to pass all required dynamic values through initialize method, for example:\n```typescript\nclass Foo implements IFoo {\n    @initializable()\n    private valueA;\n@initializable()\nprivate valueB;\n\nconstructor(@inject(...) bar: IBar) {...\n}\n\npublic initialize(valueA: number, valueB: number) {\n    this.valueA = valueA;\n    this.valueB = valueB;\n\n    // will be the runtime Error if valueA or valueB will be undefined at the end of `initialize` method\n}\n\ngetSum() {\n    return this.valueA + this.valueB;\n}\n\n}\nclass App {\n    private foo: IFoo;\nconstructor(@inject(...) foo: IFoo) {\n    this.foo = foo;\n}\n\ngetMathRandomSum() {\n    this.foo.initialize(Math.random(), Math.random());\n\n    return this.foo.getSum();\n}\n\n}\n```\nDecorator:\nhttps://github.com/javascript-obfuscator/javascript-obfuscator/blob/master/src/decorators/Initializable.ts\nMethod call:\nhttps://github.com/javascript-obfuscator/javascript-obfuscator/blob/master/src/custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup.ts#L122\nMethod:\nhttps://github.com/javascript-obfuscator/javascript-obfuscator/blob/master/src/custom-nodes/string-array-nodes/StringArrayNode.ts#L53\nSo, i really want some way to make this things without custom decorators, only with Inversify.js decorators.. So, i think we should use hasMetadata instead of hasOwnMetadata here:\nhttps://github.com/inversify/InversifyJS/blob/master/src/resolution/instantiation.ts#L37. I'll try to make PR. Nice! When i can expect release with this fix?. If possible, keep old sync API please. My package is fully sync and i very don't want to make it async.. Amazing. ",
    "johndoe2361289638163": "What is the state of this issue? Are contextual injections now fully supported?. Any update on this??. ",
    "pixelshaded": "nice. ty\n. ",
    "orzarchi": "Hi, thanks for adding this feature!\nAfter poking around in your code, I think I have something that can help:\nI've found an npm module called node-introspect that seems to offer almost\nall the functionality needed to resolve argument names in functions and\nconstructors.\nI've made a pull request with some fixes (\nhttps://github.com/kilianc/node-introspect/pull/4).\nCurrently me and the author are working out the kinks.\nSince it seems like your argument resolve code is pretty similar,\nmaybe we can all join forces, and you can reuse this code for Inversify?\nOn Sun, Oct 18, 2015 at 11:37 PM, Remo H. Jansen notifications@github.com\nwrote:\n\nHi @orzarchi https://github.com/orzarchi I'm happy to let you know that\nif you download the version v1.0.3 from npm you should be able to use ES6\nclasses with --harmony mode in node 4.0:\n\"use strict\";\nvar inversify = require(\"inversify\");\nclass A {\n  constructor(){\n    this.something = \"A is doing something!\";\n  }\n  doSomething(){\n    console.log(this.something);\n  }\n}\nclass B {\n  constructor(a) {\n    this._a = a;\n  }\n  useA() {\n    this._a.doSomething();\n  }\n}\nvar kernel = new inversify.Kernel();\nkernel.bind(new inversify.TypeBinding('a', A));\nkernel.bind(new inversify.TypeBinding('b', B));\nvar b = kernel.resolve('b');\nb.useA();\nI was able to run the file above using:\nnode index.js --harmony\nPlease let me know if you experience more issues.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/inversify/InversifyJS/issues/23#issuecomment-149045123\n.\n. It's just a single function, seems perfect for you actually.\n\nOn Mon, Oct 19, 2015, 00:28 Remo H. Jansen notifications@github.com wrote:\n\nHi @orzarchi https://github.com/orzarchi thanks for your comments. I\nreally worry when I have to add a run-time dependency to inversify because\nas you may have noticed it has no dependencies at the moment.\nI'm not too worry about using node-introspect in node but I'm worry about\nincreasing the size of inversify in the browser. How heavy is\nnode-introspect?\nAlso I'm working on version 2.0 and it will use decorators and there will\nbe some significant changes. I will keep you updated so you can take a look\nto how things work on the upcoming 2.0 version.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/inversify/InversifyJS/issues/24#issuecomment-149048729\n.\n. Ended up writing my own small ioc container that uses reflection :)\nhttps://github.com/orzarchi/node-microioc\n. \n",
    "PeterDaveHello": "np\n. ",
    "jamesadarich": "Hey Remo,\nJust to clarify on this issue - will the feature be too detect cyclic dependencies in a tree and throw a meaningful error when they are found rather than trying to resolve a cyclic dependency?\n. Hey,\nI've encountered this issue as well and it will probably be a bit further reaching than just adding a space at the end. I added a regular expression to check if the words \"constructor\" or \"class\" are in there as keywords and tested against your code (and mine) and all looks hunky dory :)\nCheers!\n. No problem! Invesrsify has made my life working with Marionette much easier. Let me know if you need any help with stuff would be glad to lend a hand :)\n. Hey @tenowg! Hope all is well with you, just having a look at this pull request and I think I agree with you in that the typings aren't quite right, and definitely should be in the package.json. However I'd like to propose a minor tweak to your commit.\nI think it is right to remove the exported module but not the declared one because we need to declare it as something and it also means you can import very neatly either\nimport * as Inversify from \"inversify\";\nor specifically what you want\nimport { Kernel, TypeBindings } from \"inversify\";\ni.e. \ndeclare module 'inversify'\n   export module inversify\nshould become\ndeclare module 'inversify'\nHave tried this on Atom (which I believe VSC is based upon) on some of my solutions and this seems to be working quite neatly. What do you think? :)\nI believe this is what @pixelshaded was talking about in #18 so my thoughts are that this PR should close it (with the above change)\nAlso as a side note don't be worried about deleting instead of commenting stuff out! Things are neater that way and we can always revert mistakes :)\nNice one on the contribution!!!\n. Just tried this on VS2015 and not getting the same issue - is this perhaps to do with moduleResolution? I have mine set to \"node\" in my compilerOptions.\n. Hey @tenowg!\nHave you got a repo with an example of how the imports are happening? as I cannot recreate the issue at the moment (with my updated typings) and would like to because I think you are right that there needs to be a \"typings\" property in the package.json that references the type_definitions/inversify.d.ts file my only concern is maintaining two versions of the typings.\nLooking at my projects I'm sure you are right that the typings file is not quite correct and needs to be changed but probably just as simple as removing the encapsulating export module as above, as after that I can import Inversify as you require.\nCheers :)\n. Nice one, I requested access. I'll wing you a PR over asap :)\n. Sounds fair enough to me - just needs an npmignore file to be added :+1: I'll have an investigate tonight if I get a chance\n. This is probably linked to #35 at the moment 1.2.0 is a broken build - a temporary fix is noted in my comment on #32 (which are the typings changes found in #34) if you want to use 1.2.0 whilst this issue is being resolved?\n. :+1: looks pretty good so far. At a quick skim maybe in .gitignore put comments for the added stuff for consistency and readability? Same for .npmignore as well. But that's super minor so nice rework. Also probably worth hitting bower for the same as people using bower don't deserve to be penalised I guess :stuck_out_tongue_winking_eye: You can do this by adding an ignore property to the bower.json (see here http://themestent.github.io/front-end-workflow/bower.json.html)\n. Just investigated how many downloads inversify has on bower and this probably sways my opinion here.\n\nI think that all these package managers are lovely for competition and driving people forward but literally we're making work that is not used by anyone so drop it for now and someone can always raise a support bower/jspm etc. issue if they need it. :)\n. Hey Remo,\nLooks like 1.2.1 is breaking get issue cannot find module \"inversify\", looks like the npm distribution is missing the definition and source code.\n\nThis is what I got after a fresh install. Probably need to reinclude this stuff!\n. Tested briefly - run time issues are fixed but getting some compile errors. Need to look into the cause. Initial thinking is the lack of typings in package.json. Will investigate the issues I'm having at compile time when I get the chance\n. Sorry about late response on this. I have retested and 1.2.2 is working. I had an old cached version of the Inversify package.json which was causing me trouble.\nGreat work :+1:\n. As an added note without seeing the project it's probably the module type your setting for the typescript compiler i.e. in your tsconfig.json\n{\n    \"compilerOptions\": {\n        \"module\": \"amd\"\n    }\n}\nor for CLI\ntsc --module amd\n. Agreed\n. Great point Remo. If we intend on changing the API then we should definitely notify people. I'm wondering though if the scope is much greater than just the decorators as we intend to make a fair few changes that will affect people's set up.\nPerhaps a more general notification for people using 1.x? But then again should we be treating Inversify 1 and 2 as an upgrade or almost different libraries since the changes may be quite large.\nAlso may be worth thinking of creating a tool to ease the transition to convert existing set ups from 1.x to 2.x?\n. I guess my thought is that constructing a new Binding is a bit redundant and perhaps using the opportunity to redactor to something like\nkernel.bind<Interface>(\"Interface\").to(Class).with(Binding Scope.Transient)\nThis will cut out the need to create a new binding and pass that in and make the syntax more fluent\n. Hey @theofidry,\nI think your question is can all dependencies resolved at one time (but if I'm answering the wrong questions then please let me know)\nThis should happen when you call kernel.resolve for your application root then this will happen. i.e.\nIf I have the following\n```\nkernel.bind(new TypeBinding(\"IA\", A);\nkernel.bind(new TypeBinding(\"IB\", B);\nkernel.bind(new TypeBinding(\"IC\" C);\ninterface IA {}\nclass A implements IA {\n    constructor(@Inject(\"IB\") b) { }\n}\ninterface IB {}\nclass B implements IB {\n   constructor(@Inject(\"IC\") c) {}\n}\ninterface IC {}\nclass C implements IC {\n}\n```\nby calling kernel.resolve(\"IA\") you will be returned an A with a B which has a C all already instantiated. If this is all you need then there is no need to call Inversify again as everything has already been resolved and should not be causing you any more performance issues. :)\n. LGTM CR Passed :fireworks: \n. :+1: \n. Hey Remo,\nNice work!! Do we have a process for picking up issues? Maybe just comment on the issue to let others know you are working on it?\n. Nice! If I were any good at social media I'd spread the word myself!\nI'll have a think about this but maybe worth simply logging a \"Suggestions\" issue for people to spam their ideas?\n. Hey Remo,\nJust tried to recreate this issue and I don't seem to get any issues. I swapped the comments out in this test  (see below) and it still passes for me. I get a TypeScript error on not knowing what the Proxy class is but I suspect this is expected.\n```\nit(\"Should be able to configure the proxyMaker of a binding\", () => {\n    interface INinja {}\n    let ninjaIdentifier = \"INinja\";\n\n    let binding = new Binding<INinja>(ninjaIdentifier);\n    let bindingInWhenProxySyntax = new BindingInWhenProxySyntax<INinja>(binding);\n\n    bindingInWhenProxySyntax.proxy((ninja: INinja) => {\n        let handler = {};\n        return new Proxy<INinja>(ninja, handler);\n    });\n\n    expect(binding.proxyMaker).not.to.eql(null);\n\n});\n\n```\n\nCould you please clarify what the issue is? :)\n. I was pondering about proxies myself and unfortunately because TypeScript doesn't reflect out Interface information it makes it difficult to do any smart proxying.\nPerhaps whilst we await proper reflection from the all wonderful Microsoft! :) We can proxy out the bound class. This would mean that we can tell what members a class has and proxy all of them automatically leaving the developer to not do anything. We've proxied out more than we need to but it's more workable from a dev point of view.\n. I can pick this one up later today @remojansen  :)\n. Looks like we've got quite a few implicit anys - gonna go through the solution and rework them to keep them nicely typed all the way through and then turn on noImplicitAnys on the compiler if all happy with that?\nAlso I've noticed a \"documentation\" folder that's appeared in my build but is not in the repo and not in the gitignore. I've added to gitignore for now so I don't accidentally commit, I take it this shouldn't be committed for now?\n. Hey Remo,\nLooks like we've got some linting issues on the import export portion of inversify:\n\nThat relates to:\n\nin ./src/inversify.ts\nIs this being resolved elsewhere or do we want to resolve it in this fix?\nAlso another issue I have detected as a part of removing implicit anys:\nin ./src/activation/decorator_utils.ts\n```\nfunction _decorate(decorators: ClassDecorator[], target: Function) {\n    Reflect.decorate(decorators, target);\n}\nfunction _param(paramIndex: number, decorator: ParameterDecorator): ClassDecorator {\n    return function (target: Object, key: string | symbol) { decorator(target, key, paramIndex); };\n}\n// Allows VanillaJS developers to use decorators:\n// decorate(inject(\"IFoo\", \"IBar\"), FooBar);\n// decorate(paramNames(\"foo\", \"bar\"), FooBar);\n// decorate(named(\"foo\"), FooBar, 0);\n// decorate(tagged(\"bar\"), FooBar, 1);\nfunction decorate(\n    decorator: (ClassDecorator|ParameterDecorator),\n    target: any,\n    parameterIndex?: number): void {\nif (typeof parameterIndex === \"number\") {\n    _decorate([_param(parameterIndex, decorator)], target);\n} else {\n    _decorate([decorator], target);\n}\n\n}\n```\nI believe this is how it should be typed but I am getting an issue coming out as _param does not return a ClassDecorator because it has the key argument still in it. Should this be rewritten to:\n```\nfunction _decorate(decorators: ClassDecorator[], target: Function) {\n    Reflect.decorate(decorators, target);\n}\nfunction _param(key: string | symbol, paramIndex: number, decorator: ParameterDecorator): ClassDecorator {\n    return function (target: Object) { decorator(target, key, paramIndex); };\n}\n// Allows VanillaJS developers to use decorators:\n// decorate(inject(\"IFoo\", \"IBar\"), FooBar);\n// decorate(paramNames(\"foo\", \"bar\"), FooBar);\n// decorate(named(\"foo\"), FooBar, 0);\n// decorate(tagged(\"bar\"), FooBar, 1);\nfunction decorate(\n    decorator: (ClassDecorator|ParameterDecorator),\n    target: any,\n    key?: string | symbol,\n    parameterIndex?: number): void {\nif (typeof parameterIndex === \"number\") {\n    _decorate([_param(key, parameterIndex, decorator)], target);\n} else {\n    _decorate([<ClassDecorator>decorator], target);\n}\n\n}\n``\n. On second thought probably should null out the key property from theParameterDecorator` as VanillaJS users are just decorating the class and pointing towards a specific index so the key is inconsequential in our context.\nSo...\n```\nfunction _decorate(decorators: ClassDecorator[], target: Function) {\n    Reflect.decorate(decorators, target);\n}\nfunction _param(paramIndex: number, decorator: ParameterDecorator): ClassDecorator {\n    return function (target: Object) { decorator(target, null, paramIndex); };\n}\n// Allows VanillaJS developers to use decorators:\n// decorate(inject(\"IFoo\", \"IBar\"), FooBar);\n// decorate(paramNames(\"foo\", \"bar\"), FooBar);\n// decorate(named(\"foo\"), FooBar, 0);\n// decorate(tagged(\"bar\"), FooBar, 1);\nfunction decorate(\n    decorator: (ClassDecorator|ParameterDecorator),\n    target: any,\n    parameterIndex?: number): void {\nif (typeof parameterIndex === \"number\") {\n    _decorate([_param(parameterIndex, decorator)], target);\n} else {\n    _decorate([<ClassDecorator>decorator], target);\n}\n\n}\n```\nThoughts?\n. Hey Remo,\nJust in case you haven't seen this feature has moved to TypeScript 2.1 :)\n. @remojansen does this require a review?. Maybe change these two lines to\nconst bindingToSyntax = this.rebind.call(this, serviceIdentifier);\nAs having three word bind three times in a row is a bit of a mind bender! Haha. ",
    "Jameskmonger": "Fixed by #34 ? @remojansen \n. :+1: \n. Why do you not want to use ///  calls to the typings file?\n. Not too sure about the maintainability of this solution... There are multiple files to maintain this way\n. I'm working on this now, @remojansen. I will most likely also remove the /dist/ directory from the repo because it doesn't really need to be distributed with the repo if it's published on npm.\n. This is showing as a failed test because the test coverage is 99.78% - it was at the same percentage before and has not changed due to my changes. Just FYI @remojansen \n. I have just taken a look and the current npm distribution is 130kb. After the initial changes, I have got this down to 46kb.\n. I have now got this down to 40kb.\n. Hey @remojansen, I have had a look and the build is building correctly but is marking as failed for a reason:\n- The coverage is not yet at 100%\n- This PR has not increased the coverage towards 100%\nIf a coveralls check does not increase the coverage towards 100%, then coveralls will say that the build has failed. If you take a look at some of your previous builds, https://coveralls.io/builds/4754691 or https://coveralls.io/builds/4754690, you can see that they are also sitting at 99.78%.\nI will now add the service_name: travis-ci to the .coveralls.yml file to see if this makes the build pass.\n. This is an issue with coveralls @remojansen , please see here: https://github.com/lemurheavy/coveralls-public/issues/545\n. @remojansen  I have inspected the coverage logs and it seems that the only part not under test is this part:\nvar a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f\nThis is caused where the browserify code is not being tested. I recommend using jasmine-node rather than karma to run the tests, because then we can test the commonjs code rather than the amd code.\n. All fixed, @remojansen. By using Mocha we don't have to browserify the code before testing it - we can test the raw commonjs code which means that we're testing the Inversify code by itself rather than after being browserified. It also means that we get accurate coveralls reports rather than them being affected by the browserification process.\nAnd now I can sleep! :stuck_out_tongue_winking_eye: \n. I think stop using it, it's a lot of work to maintain multiple package managers.\n. No problem! :smile: :+1: \n. :fireworks: \n. That's fine @remojansen, assign me and I will take a look!\n. We could have a separate integration test file for each type, and try to compile them on the server.\n. The NPM distribution now looks good to me, @remojansen ! Nice work.\n. @jmp909: You're using AMD, so wrap your class like this:\nrequire(['inversify'], function (inversify) {\n    // you will have access to inversify here\n}\nhttp://requirejs.org/docs/errors.html#notloaded\n. I agree @remojansen\n. @remojansen Could you please create an OAuth token for the repository and set the TSD_GITHUB_TOKEN environment variable in Travis to that token? Otherwise Travis cannot install typings on the CI server.\nHere are some instructions: https://github.com/DefinitelyTyped/tsd#tsdrc\n. For some reason the environmental variable hasn't been added, @remojansen ... Please try to add it again\n. This also won't build until the environmental variable is added because GitHub prevents the downloading of TSD typing files @remojansen \n. The npm install is working fine, however tsd install is not functioning because it does not have the authentication token.\n38.70s$ npm install -g tsd\nnpm WARN engine joi-assert@0.0.3: wanted: {\"node\":\">= 0.10.0 <= 0.11.0\"} (current: {\"node\":\"5.4.1\",\"npm\":\"3.3.12\"})\n/home/travis/.nvm/versions/node/v5.4.1/bin/tsd -> /home/travis/.nvm/versions/node/v5.4.1/lib/node_modules/tsd/build/cli.js\n/home/travis/.nvm/versions/node/v5.4.1/lib\n\u2514\u2500\u252c tsd@0.6.5 \n  \u251c\u2500\u2500 assertion-error@1.0.0 \n  \u251c\u2500\u252c bl@0.9.5 \n  \u2502 \u2514\u2500\u252c readable-stream@1.0.33 \n  \u2502   \u251c\u2500\u2500 core-util-is@1.0.2 \n  \u2502   \u251c\u2500\u2500 isarray@0.0.1 \n  \u2502   \u2514\u2500\u2500 string_decoder@0.10.31 \n  \u251c\u2500\u2500 bluebird@1.2.4 \n  \u251c\u2500\u252c chalk@1.1.1 \n  \u2502 \u251c\u2500\u2500 ansi-styles@2.1.0 \n  \u2502 \u251c\u2500\u2500 escape-string-regexp@1.0.4 \n  \u2502 \u251c\u2500\u252c has-ansi@2.0.0 \n  \u2502 \u2502 \u2514\u2500\u2500 ansi-regex@2.0.0 \n  \u2502 \u251c\u2500\u2500 strip-ansi@3.0.0 \n  \u2502 \u2514\u2500\u2500 supports-color@2.0.0 \n  \u251c\u2500\u2500 colors@1.1.2 \n  \u251c\u2500\u2500 deep-freeze@0.0.1 \n  \u251c\u2500\u252c definition-header@0.1.0 \n  \u2502 \u251c\u2500\u252c parsimmon@0.5.1 \n  \u2502 \u2502 \u2514\u2500\u2500 pjs@5.1.1 \n  \u2502 \u2514\u2500\u2500 xregexp@2.0.0 \n  \u251c\u2500\u252c detect-indent@0.2.0 \n  \u2502 \u251c\u2500\u2500 get-stdin@0.1.0 \n  \u2502 \u2514\u2500\u2500 minimist@0.1.0 \n  \u251c\u2500\u2500 diff@1.4.0 \n  \u251c\u2500\u252c event-stream@3.1.7 \n  \u2502 \u251c\u2500\u2500 duplexer@0.1.1 \n  \u2502 \u251c\u2500\u2500 from@0.1.3 \n  \u2502 \u251c\u2500\u2500 map-stream@0.1.0 \n  \u2502 \u251c\u2500\u2500 pause-stream@0.0.11 \n  \u2502 \u251c\u2500\u2500 split@0.2.10 \n  \u2502 \u251c\u2500\u2500 stream-combiner@0.0.4 \n  \u2502 \u2514\u2500\u2500 through@2.3.8 \n  \u251c\u2500\u2500 exit@0.1.2 \n  \u251c\u2500\u252c glob@4.5.3 \n  \u2502 \u251c\u2500\u252c inflight@1.0.4 \n  \u2502 \u2502 \u2514\u2500\u2500 wrappy@1.0.1 \n  \u2502 \u251c\u2500\u2500 inherits@2.0.1 \n  \u2502 \u251c\u2500\u252c minimatch@2.0.10 \n  \u2502 \u2502 \u2514\u2500\u252c brace-expansion@1.1.2 \n  \u2502 \u2502   \u251c\u2500\u2500 balanced-match@0.3.0 \n  \u2502 \u2502   \u2514\u2500\u2500 concat-map@0.0.1 \n  \u2502 \u2514\u2500\u2500 once@1.3.3 \n  \u251c\u2500\u252c joi@4.9.0 \n  \u2502 \u251c\u2500\u2500 hoek@2.16.3 \n  \u2502 \u251c\u2500\u2500 isemail@1.2.0 \n  \u2502 \u251c\u2500\u2500 moment@2.11.1 \n  \u2502 \u2514\u2500\u2500 topo@1.1.0 \n  \u251c\u2500\u2500 joi-assert@0.0.3 \n  \u251c\u2500\u2500 jsesc@0.5.0 \n  \u251c\u2500\u252c json-pointer@0.2.2 \n  \u2502 \u2514\u2500\u2500 foreach@2.0.5 \n  \u251c\u2500\u2500 lazy.js@0.3.2 \n  \u251c\u2500\u2500 lru-cache@2.5.2 \n  \u251c\u2500\u252c minimatch@1.0.0 \n  \u2502 \u2514\u2500\u2500 sigmund@1.0.1 \n  \u251c\u2500\u2500 minimist@1.2.0 \n  \u251c\u2500\u2500 ministyle@0.1.4 \n  \u251c\u2500\u252c minitable@0.0.4 \n  \u2502 \u2514\u2500\u2500 minichain@0.0.1 \n  \u251c\u2500\u252c miniwrite@0.1.4 \n  \u2502 \u2514\u2500\u2500 mkdirp@0.3.5 \n  \u251c\u2500\u252c mkdirp@0.5.1 \n  \u2502 \u2514\u2500\u2500 minimist@0.0.8 \n  \u251c\u2500\u2500 open@0.0.5 \n  \u251c\u2500\u252c request@2.67.0 \n  \u2502 \u251c\u2500\u2500 aws-sign2@0.6.0 \n  \u2502 \u251c\u2500\u252c bl@1.0.1 \n  \u2502 \u2502 \u2514\u2500\u252c readable-stream@2.0.5 \n  \u2502 \u2502   \u251c\u2500\u2500 process-nextick-args@1.0.6 \n  \u2502 \u2502   \u2514\u2500\u2500 util-deprecate@1.0.2 \n  \u2502 \u251c\u2500\u2500 caseless@0.11.0 \n  \u2502 \u251c\u2500\u252c combined-stream@1.0.5 \n  \u2502 \u2502 \u2514\u2500\u2500 delayed-stream@1.0.0 \n  \u2502 \u251c\u2500\u2500 extend@3.0.0 \n  \u2502 \u251c\u2500\u2500 forever-agent@0.6.1 \n  \u2502 \u251c\u2500\u252c form-data@1.0.0-rc3 \n  \u2502 \u2502 \u2514\u2500\u2500 async@1.5.2 \n  \u2502 \u251c\u2500\u252c har-validator@2.0.6 \n  \u2502 \u2502 \u251c\u2500\u252c commander@2.9.0 \n  \u2502 \u2502 \u2502 \u2514\u2500\u2500 graceful-readlink@1.0.1 \n  \u2502 \u2502 \u251c\u2500\u252c is-my-json-valid@2.12.4 \n  \u2502 \u2502 \u2502 \u251c\u2500\u2500 generate-function@2.0.0 \n  \u2502 \u2502 \u2502 \u251c\u2500\u252c generate-object-property@1.2.0 \n  \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 is-property@1.0.2 \n  \u2502 \u2502 \u2502 \u251c\u2500\u2500 jsonpointer@2.0.0 \n  \u2502 \u2502 \u2502 \u2514\u2500\u2500 xtend@4.0.1 \n  \u2502 \u2502 \u2514\u2500\u252c pinkie-promise@2.0.0 \n  \u2502 \u2502   \u2514\u2500\u2500 pinkie@2.0.1 \n  \u2502 \u251c\u2500\u252c hawk@3.1.3 \n  \u2502 \u2502 \u251c\u2500\u2500 boom@2.10.1 \n  \u2502 \u2502 \u251c\u2500\u2500 cryptiles@2.0.5 \n  \u2502 \u2502 \u2514\u2500\u2500 sntp@1.0.9 \n  \u2502 \u251c\u2500\u252c http-signature@1.1.0 \n  \u2502 \u2502 \u251c\u2500\u2500 assert-plus@0.1.5 \n  \u2502 \u2502 \u251c\u2500\u252c jsprim@1.2.2 \n  \u2502 \u2502 \u2502 \u251c\u2500\u2500 extsprintf@1.0.2 \n  \u2502 \u2502 \u2502 \u251c\u2500\u2500 json-schema@0.2.2 \n  \u2502 \u2502 \u2502 \u2514\u2500\u2500 verror@1.3.6 \n  \u2502 \u2502 \u2514\u2500\u252c sshpk@1.7.3 \n  \u2502 \u2502   \u251c\u2500\u2500 asn1@0.2.3 \n  \u2502 \u2502   \u251c\u2500\u2500 assert-plus@0.2.0 \n  \u2502 \u2502   \u251c\u2500\u252c dashdash@1.12.2 \n  \u2502 \u2502   \u2502 \u2514\u2500\u2500 assert-plus@0.2.0 \n  \u2502 \u2502   \u251c\u2500\u2500 ecc-jsbn@0.1.1 \n  \u2502 \u2502   \u251c\u2500\u2500 jodid25519@1.0.2 \n  \u2502 \u2502   \u251c\u2500\u2500 jsbn@0.1.0 \n  \u2502 \u2502   \u2514\u2500\u2500 tweetnacl@0.13.3 \n  \u2502 \u251c\u2500\u2500 is-typedarray@1.0.0 \n  \u2502 \u251c\u2500\u2500 isstream@0.1.2 \n  \u2502 \u251c\u2500\u2500 json-stringify-safe@5.0.1 \n  \u2502 \u251c\u2500\u252c mime-types@2.1.9 \n  \u2502 \u2502 \u2514\u2500\u2500 mime-db@1.21.0 \n  \u2502 \u251c\u2500\u2500 node-uuid@1.4.7 \n  \u2502 \u251c\u2500\u2500 oauth-sign@0.8.0 \n  \u2502 \u251c\u2500\u2500 qs@5.2.0 \n  \u2502 \u251c\u2500\u2500 stringstream@0.0.5 \n  \u2502 \u251c\u2500\u2500 tough-cookie@2.2.1 \n  \u2502 \u2514\u2500\u2500 tunnel-agent@0.4.2 \n  \u251c\u2500\u2500 rimraf@2.2.8 \n  \u251c\u2500\u2500 semver@4.3.6 \n  \u251c\u2500\u2500 type-detect@0.1.2 \n  \u251c\u2500\u252c universal-analytics@0.3.10 \n  \u2502 \u251c\u2500\u2500 async@0.2.10 \n  \u2502 \u2514\u2500\u2500 underscore@1.8.3 \n  \u251c\u2500\u252c update-notifier@0.2.2 \n  \u2502 \u251c\u2500\u252c chalk@0.5.1 \n  \u2502 \u2502 \u251c\u2500\u2500 ansi-styles@1.1.0 \n  \u2502 \u2502 \u251c\u2500\u252c has-ansi@0.1.0 \n  \u2502 \u2502 \u2502 \u2514\u2500\u2500 ansi-regex@0.2.1 \n  \u2502 \u2502 \u251c\u2500\u2500 strip-ansi@0.3.0 \n  \u2502 \u2502 \u2514\u2500\u2500 supports-color@0.2.0 \n  \u2502 \u251c\u2500\u252c configstore@0.3.2 \n  \u2502 \u2502 \u251c\u2500\u2500 graceful-fs@3.0.8 \n  \u2502 \u2502 \u251c\u2500\u252c js-yaml@3.5.2 \n  \u2502 \u2502 \u2502 \u251c\u2500\u252c argparse@1.0.4 \n  \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500 lodash@4.0.0 \n  \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 sprintf-js@1.0.3 \n  \u2502 \u2502 \u2502 \u2514\u2500\u2500 esprima@2.7.1 \n  \u2502 \u2502 \u251c\u2500\u2500 object-assign@2.1.1 \n  \u2502 \u2502 \u251c\u2500\u252c osenv@0.1.3 \n  \u2502 \u2502 \u2502 \u251c\u2500\u2500 os-homedir@1.0.1 \n  \u2502 \u2502 \u2502 \u2514\u2500\u2500 os-tmpdir@1.0.1 \n  \u2502 \u2502 \u251c\u2500\u2500 user-home@1.1.1 \n  \u2502 \u2502 \u2514\u2500\u2500 xdg-basedir@1.0.1 \n  \u2502 \u251c\u2500\u2500 is-npm@1.0.0 \n  \u2502 \u251c\u2500\u252c latest-version@1.0.1 \n  \u2502 \u2502 \u2514\u2500\u252c package-json@1.2.0 \n  \u2502 \u2502   \u251c\u2500\u252c got@3.3.1 \n  \u2502 \u2502   \u2502 \u251c\u2500\u252c duplexify@3.4.2 \n  \u2502 \u2502   \u2502 \u2502 \u251c\u2500\u2500 end-of-stream@1.0.0 \n  \u2502 \u2502   \u2502 \u2502 \u2514\u2500\u2500 readable-stream@2.0.5 \n  \u2502 \u2502   \u2502 \u251c\u2500\u2500 infinity-agent@2.0.3 \n  \u2502 \u2502   \u2502 \u251c\u2500\u2500 is-redirect@1.0.0 \n  \u2502 \u2502   \u2502 \u251c\u2500\u2500 is-stream@1.0.1 \n  \u2502 \u2502   \u2502 \u251c\u2500\u2500 lowercase-keys@1.0.0 \n  \u2502 \u2502   \u2502 \u251c\u2500\u2500 nested-error-stacks@1.0.2 \n  \u2502 \u2502   \u2502 \u251c\u2500\u2500 object-assign@3.0.0 \n  \u2502 \u2502   \u2502 \u251c\u2500\u2500 prepend-http@1.0.3 \n  \u2502 \u2502   \u2502 \u251c\u2500\u252c read-all-stream@3.0.1 \n  \u2502 \u2502   \u2502 \u2502 \u251c\u2500\u252c pinkie-promise@1.0.0 \n  \u2502 \u2502   \u2502 \u2502 \u2502 \u2514\u2500\u2500 pinkie@1.0.0 \n  \u2502 \u2502   \u2502 \u2502 \u2514\u2500\u2500 readable-stream@2.0.5 \n  \u2502 \u2502   \u2502 \u2514\u2500\u2500 timed-out@2.0.0 \n  \u2502 \u2502   \u2514\u2500\u252c registry-url@3.0.3 \n  \u2502 \u2502     \u2514\u2500\u252c rc@1.1.6 \n  \u2502 \u2502       \u251c\u2500\u2500 deep-extend@0.4.1 \n  \u2502 \u2502       \u251c\u2500\u2500 ini@1.3.4 \n  \u2502 \u2502       \u2514\u2500\u2500 strip-json-comments@1.0.4 \n  \u2502 \u251c\u2500\u252c semver-diff@2.1.0 \n  \u2502 \u2502 \u2514\u2500\u2500 semver@5.1.0 \n  \u2502 \u2514\u2500\u2500 string-length@1.0.1 \n  \u251c\u2500\u2500 uri-templates@0.1.9 \n  \u251c\u2500\u2500 uuid@2.0.1 \n  \u2514\u2500\u252c verror@1.4.0 \n    \u2514\u2500\u2500 extsprintf@1.0.3 \n1.36s$ tsd install\n-> running install\n[ERR!] GitHub API: GitHub rate limit reached.\n    To increase the limit use GitHub authentication.\n    See: https://github.com/DefinitelyTyped/tsd#tsdrc\n. Also it is building fine on some of the instances and failing on the others.. I think potentially leave it a bit and rebuild later :stuck_out_tongue: \n. @remojansen I can confirm that the environment variables are not being set for the TSD auth key. You are the only one who has the permission to set environment variables for the Travis builds so I think you will have to do that.\n\n. Okay @remojansen , the only way to fix this for now was to push my unencrypted OAuth key into the repo. Please remove this from the travis.yml after you merge this pull request!!\n. > 1. load the page and require a service => resolution overhead\n\n\nrequire another service => no resolution overhead because resolution has already occurred one time\nreload page and require a service => resolution overhead\n\n\nWouldn't that result in the initial page load time being increased, @theofidry ?\n. Ah, okay. So what you mean is almost a compilation process where 'static' (which is a very loaded term in a programming context) dependencies are resolved on compilation so they do not have to be resolved at runtime?\n. This addresses #65 \n. It appears that npm is not happy with appending alpha to anything other than the last part of the version.. how about 2.0.0-alpha rather than 2.0.0-alpha.0?\n. No problem @tenowg and @remojansen .\nAfter looking into the semantic versioning documentation I am happy that 2.0.0-alpha.0 is valid semantic versioning. It seemed odd to have the alpha modifier on the patch version rather than the major version (as we are working on the alpha release of version 2).\nHowever after looking into the documentation, I can see that 2.0.0-alpha.0 is correct semantic versioning.\nClosing this issue - thanks guys! :thumbsup:\n. Closing as further discussion required in #68.\n. The builds all failed on build-type-definitions. Maybe the build needs to be retriggered @remojansen \n. See #108 @remojansen \n. See #110 @remojansen \n. Hi @remojansen, please see #229 \n. Sure, there are no issues with having it in IDEs, I wasn't sure of any benefits but I'm happy to close this if it significantly helps the developers using Visual Studio :smile:\n. I personally think that we should add the I prefix to all interfaces.\nThe documentation that @mocanu-razvan linked to in #242 was for writing declaration files rather than writing TypeScript.\nI don't know of any other projects where the interfaces are stored in a separate interfaces module.\nI would expect to be able to import them like this (and I think lots of others would also):\nimport { Kernel, IKernel } from 'inversify';\n. I am happy with the style, I guess it is just odd coming from a .NET perspective. Will close this as not an issue :)\n. All URL parameters are strings because they're in a URL, so I think this is by design.. ",
    "amcdnl": "Just to clarify, your not planning to support ES-next decorators?\n. :) ... eta on release?\n. ",
    "pnocera": "That's pretty cool, thanks !\n. ",
    "tenowg": "@jamesrichford you are correct, I had it backwards... using declare module 'inversify' allows for much smoother imports\n. Seems I was in error... and not sure why... I am going to investigate this more, but doing the last commit makes this fail with visual studio, with \"not a module\" error on build, but not in IDE. Let me look into this more before merging\n. At the chance of sounding a fool, I didn't test the last commit before pushing it... I was wrong in that adding back in declare module 'invserify' was required, it isn't required, and is actually what is breaking VS build process. I am not sure if this is a Bug with VS, as the import statement:\nimport {Kernel} from 'inversify';\ndoesn't show an error in the IDE, but only when building does it cry. But after further review, including examining other repos, none seem to use declare module '...' syntax. So i am starting to be inclined to believe that it isn't required, as my project also builds with no issue now (yes this time ti tested it with a full build and run) using either import method\nimport * as i from 'inversify';\nand\nimport {Kernel} from 'inversify';\nSo as of now, with my current understanding, I believe leaving the declare statement out might be acceptable.\n. Doing some research I found that these are the requirements to use the typings in a package.json\nbe a .d.ts file\nbe an external module\nnot have triple-slash references\nSo, in order for what I want to do, I will require an additional .d.ts file (probably easiest to achieve by setting definitions to true in tsconfig) or a copy of the one used in type_definitions which would be left alone if someone doesn't want to use moduleResolution... I will fix this one last time and see if it is acceptable.\n. there is a repo at https://github.com/tenowg/inversifytest that is setup so all you should need to do is pull it and run tsc from the base directory - if you don't have asp.net 5 installed you shouldn't need to load the project.\nI have included the node_modules directory, with a modified version of inversify that adds typings, and points it to a modified version of the inversify.d.ts under type_definitions.\nI hope you find the issue, maintaining 2 copies is a pain, but you shouldn't have to maintain two if this works... hopefully is might be an issue with my setup\ntwo things: importing works, if you look at test.ts there is no error, when I run tsc I get the error\n. I would love to maybe talk about this, I will be watching gitter when I get home from work, about 7 hours from now, if needed\n. Not sure if this is really even right :smile: but I have made the d.ts files work in all instances requested, and leaving the need to maintain only one d.ts file. Please review and let me know. thanks\nnote: the error is likely because there isn't a base tsconfig.json file on the project (at least this is the case in VSC)\n. @jamesrichford I don't believe you negated the need for #32 By attempting it in the first place, I have found that the typings file I updated was correct, and with new update, negates the need for the DefinatelyTyped file there now...\n. Well, simply because if there is a way to prevent it, and not clutter code more by have essentially 2 import statements, I am all for it. Also less steps to setup... either moving the files to a typings folder for a shorter reference, or typing long reference paths, when all that is needed is a single import {Kernel} from 'inversify' and the rest is handled by tsc and resolveModules. I had it working, albet it needed some tweaking and fixing to be clean, but that was reversed... oh well.\n. @remojansen I do still have the repo up (look at #32) that has a working example of it working globally, with import {} and import as... it is convoluted, but it does show that it can be done, I really don't know how to clean it up from there tho...\n. actually, the way I have it setup (not perfect by any means) only requires one file to be maintained, inversify.d.ts\n. This issue was attempted at #32 but seems that the format for using typings is different then that required by /// references and will require either a new d.ts file and thus an additional file to maintain or someone to figure it out.\n. check #57 \n. Can you give me a link that say that it is not correct, just curious as I have always seen the current (2.0.0-alpha.0) as the correct semantic versioning.\n\nA pre-release version MAY be denoted by appending a hyphen and a series of dot separated identifiers immediately following the patch version. Identifiers MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST NOT include leading zeroes. Pre-release versions have a lower precedence than the associated normal version. A pre-release version indicates that the version is unstable and might not satisfy the intended compatibility requirements as denoted by its associated normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\n\nfrom the semvar documentation\n. I have a small example I have been playing with... its still ugly, and needs alot of work, but it works... Anyone is free to check it out and give any advice/code...\nhttps://github.com/DemgelOpenSource/express-mvc\nIf I feel this is working, I will cleanup more and create some better docs... Also the name will change, just trying to come up with something\n. would be great if we could get something similar to:\nusing(IScope scope = kernel.newScope(\"request\")) {\n    // Anything marked with .inScope() at the binding would be resolved to this scope\n    // Anything no marked would resolve as normal\n}\nI understand that is from .NET syntax, but I think the idea is there.\nthis would also be a good time to think of using a IDisposable.\nThis format would be for those that are using the kernel directly, as in my case with my MVC project.\n. I might mention.. that manually removing both /// from inversify.d.ts does NOT require that I install the typings for harmony-proxy or bluebird, as my builds are working without these, nor did I change any other settings in tsconfig.json...\nOn a side note... I seriously hope that 2.0 typscript fixes many of these issues...\n. Sorry for late reply... targetting es5, Promise is part of node, just install typings for node and forget about bluebird\n. I think the I prefixed interface still does have a place, I also come from Java/C# and have used many other languages. My argument is that sometime an interface is just that, an Interface, not a generic identifier. I use abstract classes for alot of things, so I also use an A prefix at times, so it makes it easier in my mind to be able to identify an interface vs. abstract vs. concrete class.\nThere have been many conventions, but the strongest convention has also always been, be consistent, so if we are going to break convention, always break that convention.\n. The main thing would be to check if it is registered, so this is fine.\n. On 06/21/2016 06:40 PM, Remo H. Jansen wrote:\n\nI'm not fully sure but my guess is the following...\nI'm assuming that you have 2 npm modules.\nThe |@injectable()| annotation uses |Reflect.defineMetadata| under the \nhood. The Reflect object is mean to be global. If you are using \nmultiple npm modules maybe what is happening is that you have to \ninstances of Reflect (one per module):\n- In one module you read create some metadata using\n  |Reflect.defineMetadata| via |@injectable()|\n- In the second module, you try to read the metadata\n  |Reflect.getMetadata| via |kernel.get()|. The problem is that if\n  there are two Reflect objects the second will fail.\nI have never encounter this problem so it would be great if you could \ndebug and find it:\nReflect.getMetadata(\"inversify:paramtypes\", RouteBuilder);\nShould return an empty array in both npm modules.\nYou seem to be on the right track... if I call Reflect... from test.js \n(the test module setupfile) it return an emtpy [], but from getRouter() \nit returns undefined... any ideas on how to fix this?\n. On 06/21/2016 07:37 PM, Remo H. Jansen wrote:\nIf you are going to distribute the npm modules as librarires then they \nshouldn't import |reflect-metadata|,\nYou need to remove the following from your code:\nimport  \"reflect-metadata\";\nThe consumers are the ones that need to import it. For example, \nInversifyJS uses Reflect but you as a consumer need to import it.\nWe do import reflect when we run the unit test \nhttps://github.com/inversify/InversifyJS/blob/master/gulpfile.js#L174 because \nthe unit test can be considered as a consumer.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub \nhttps://github.com/inversify/InversifyJS/issues/262#issuecomment-227603860, \nor mute the thread \nhttps://github.com/notifications/unsubscribe/ABGCIv_SY0oe1K8-JrurHLapm_umg9nYks5qOHXTgaJpZM4I7JbS.\nThanks, I had thought of the same thing, but was missing an import from \nmy validator module that was causing the issue... thanks for all the \nhelp, not sure if I would have looked for it had not for you confirmation\n. Yes, this issue is closed... thanks again\n. \n",
    "basarat": "ES6 import and require import will was thanks to package.json + inversify.d.ts found in this PR. \nglobal\n```\n\n/// \n```\n\nIf you just change this to node_modules/inversify/type_definitions/inversify.d.ts Then the global scenario will work as well :rose:\n. ",
    "jmp909": "hi,\nit would be great if someone could upload a version of the foobar example that runs in VS Code. I think I'm missing a few steps with 'require.js' and also it doesn't seem to like the  @Inject \ncurrently it's turning the statment import { TypeBindingScopeEnum, TypeBinding, Kernel, Inject } from \"inversify\" into var inversify_1 = require(\"inversify\") at the top of the file and I get an error Uncaught Error: Module name \"inversify\" has not been loaded yet for context: _. Use require([])\nsorry I'm a bit lost!\nthanks\nj\n. thanks.. it was mainly that I needed to work out how to bootstrap it properly as well. I've put a working version here https://github.com/jmp909/inversify-typescript-basic , but it'd be good if you could create a similar repository specifically replicating the basic code on the website example, in terms of how to best set it up. It's all new to me, and I decided to jump in at the deep end!\nthanks\nJ\n. ",
    "theofidry": "\nI think your question is can all dependencies resolved at one time (but if I'm answering the wrong questions then please let me know)\n\nNo actually I assumed that was the case (otherwise would be quite heavy performant wise right?) :p My concern is more:\n1. load the page and require a service => resolution overhead\n2. require another service => no resolution overhead because resolution has already occurred one time\n3. reload page and require a service => resolution overhead\nSo what I meant be being resolved at runtime is: the first resolution occurs when you try to retrieve a service. My question was, wouldn't it be possible to call a command or something, so that the dependencies are being resolved, and the result is dumped into a file. As a result, in production you would use this dump and when calling a service, even if it's for the first time, you have no resolution overhead.\n. > I see this working better as a plugin for module bundlers (webpack, browserify, etc).\nIndeed that would work out quite well in this case.\n\nIf we have this kind of injections it might be possible to pre-resolve everything and dump it into a file. Also we could end with lots of pre-resolved instances and that could become a memory issue.\n\nIndeed this is an issue. But this could be solved by marking such services as lazy loaded, i.e. being resolved only when requested. This way, the user could find a balance between resolution overhead and memory usage. \nKeep it up :)\n. Ha, not sure to have been clear enough @Jameskmonger. \nRight now, dependencies are being resolved when a service is called. So if you require a service to render the page, you will have a time taken by Inversify to resolve the dependencies on your page load time (which I called \"resolution overhead\" previously). Obviously, Inversify is smart enough for not having to resolve dependencies a second time: calling the service again will get you the service instance right away (no \"resolution overhead\"). However, if you reload your page, dependencies will have to be resolved again.\nAs a result, the way it is, you have a resolution overhead on each page load. Hence my suggestion to \"dump\" the container with resolved dependencies. The caveat is that you will have a bigger memory footprint as all your services will be instantiated right away, however your page will be loaded faster as you no longer have to resolve those dependencies.\nThen as some dependencies cannot be resolved in such predictable way or because some services are not needed on each page, i.e. it is making the memory footprint needlessly bigger than needed, you could have lazy services, which are being resolved at runtime instead of being \"dumped\".\n. exactly\n. @remojansen but we have the same issues in say PHP for example. This can be solved by having pre-calculable dependencies. Then contextual ones are still solved at run-time.\nAlso note that this happens when you rely on autowiring:\nts\nkernel.bind(new inversify.Binding(\"FooInterface\", Foo, BindingScope. Singleton));\nvar foobar = kernel.resolve(\"FooBarInterface\");\nIn other words you are binding your services (ex Foo) to interfaces and classes and then just ask for an interface. But what happens when you have multiple implementations of the same interface? Your current solution is contextual binding.\nHowever, you could solve this problem differently by explicitly resolving your dependencies. Instead of having:\n```\nfoo1: bound to \"FooInteface\"\nfoo2: bound to \"FooInterface\" when asked by \"foobar\"\nbar: bound to \"BarInterface\"\nfoobar: ask for \"FooInterface\" and \"BarInterface\"\n```\nYou could give your services names  and resolves those dependencies via names:\n```\nfoo1: bound to \"@foo1\" (still implements FooInterface)\nfoo2: bound to \"@foo2\" (still implements FooInterface)\nbar: bound to \"@bar\" (still implements BarInterface)\nfoobar: ask for \"@foo2\" and \"@bar\" (still typehint FooInterface and BarInterface so could change foo2 for foo1 without changing anything)\n```\nIn another words, you are making all your dependencies predictable. Note that changes only the way you declare your bindings (rather the convention used, does not change anything under the hood per say), but nothing to your service declarations.\nAlso note that in PHP when dealing with such cases, there is also the case where we do not want the service to be loaded to the IoC Container systematically, hence just requiring the service to be loaded at run time (and will be only if needed). Which are just lazy services and requires to be specified as such, so it's just a configuration thing and nothing special.\n. ",
    "ptitjes": "Hi @remojansen. Do you think this issue could be reopen now that 2.0 is way past ?\nI would need some guidance on bridging Angular DI and Inversify.\nMy use case is the following:\nI have an Ionic/Angular/Typescript client application and an Inversify/Node/Typescript server app that interact together and with a database. I'd like to factor out some service code common to both the client and server applications. So I was thinking of extracting a library out of them and using Inversify for DI in it. But then I would need to use that base service container inside Angular DI.\nAny hints or advices ?\n  . @remojansen OK. What I had in mind was more to inject the Inversify container in Angular and using providers to make the services accessible. But I still have to test the idea. Something along the lines of\n```typescript\n@NgModule({\n  // ...\n  providers: [\n    InversifyContext,\n    SomeCalledbackServiceInAngular,\n    {\n      provides: APP_INITIALIZER,\n      deps: [InversifyContext, SomeCalledbackServiceInAngular],\n      useFactory: (ctx: InversifyContext, s: SomeCalledbackServiceInAngular) => () => {\n        ctx.container.bind(inversifyToken).toConstantValue(s)\n      },\n      multi: true,\n    },\n    inversifyProvided(MyService, MyService),\n  ]\n})\nexport class MyApp {\n}\n@Injectable()\nexport class InversifyContext {\n  public container = new Container()\n}\nexport function inversifyProvided(angularToken, inversifyToken) {\n  return {\n    provides: angularToken,\n    deps: [InversifyContext],\n    useFactory: (ctx: InversifyContext) => ctx.container.get(inversifyToken),\n  }\n}\n@Injectable()\nexport class SomeCalledbackServiceInAngular implements ICalledbackService {\n  // ...\n}\n```\nwhere ICalledbackService and MyService are defined in my library.. OK, the following worked (also tested with Angular AOT).\nA plunker that demonstrates it.\nServiceA (in Angular) calls ServiceB (in Inversify) calls ServiceC (back in Angular).\n```typescript\n// To be in library 'mylib'\nexport function initContainer(s: AServiceC) {\n  let container = new Container()\n  container.bind(ServiceB).toSelf()\n  container.bind(AServiceC).toConstantValue(s)\n  return container\n}\nexport abstract class AServiceC {\ngreet(name: string): string {\n    throw new Error('Not implemented')\n  }\n}\n@injectable()\nexport class ServiceB {\n// The @inject is mandatory when build with Angular AOT removing the class @injectable ?\n  // Don't know if it would be necessary in a real library\n  constructor(@inject(AServiceC) private service: AServiceC) {\n  }\ngreet(name: string): string {\n    return this.service.greet(name)\n  }\n}\n// To be in the Angular application\n@Injectable()\nexport class ServiceC extends AServiceC {\ngreet(name: string): string {\n    return ${name}, I'm your father!\n  }\n}\n@Injectable()\nexport class ServiceA {\nconstructor(private service: ServiceB) {\n  }\ngreet(name: string): string {\n    return this.service.greet(name)\n  }\n}\nexport const MyLibContainer = new InjectionToken('MyLibContainer')\n@NgModule({\n  // ...\n  providers: [\n    ServiceA,\n    ServiceC,\n// Provider for the Inversify container from 'mylib'\n// Unfortunately, it is not possible to make a macro function due to the lambda.\n// That would fail with Angular AOT!\n{\n  provide: MyLibContainer,\n  deps: [ServiceC],\n  useFactory: (s) => initContainer(s),\n},\n\n// Provider for ServiceB from 'mylib'\n// Unfortunately, it is not possible to make a macro function due to the lambda.\n// That would fail with Angular AOT!\n{\n  provide: ServiceB,\n  deps: [MyLibContainer],\n  useFactory: (c: Container) => c.get(ServiceB),\n},\n\n],\n})\nexport class AppModule {\n}\n```. ",
    "RichardJECooke": "And my other code in case it helps:\niDatabase.ts:\n```\n'use strict'\ninterface IDatabase\n{\n    deleteAllBooks() : any;\n    insertBook(name: string, src: string) : any;\n    selectBook() : any;\n}\nexport = IDatabase;\n```\ndatabase.ts:\n```\n'use strict'\nimport { Inject } from \"inversify\";\nimport IDatabase = require(\"./iDatabase\");\nimport pgp = require('pg-promise');\nimport config = require('../config');\n//https://github.com/vitaly-t/pg-promise/wiki/Learn-by-Example\nclass Database implements IDatabase\n{\n    _db : any;\nconstructor ()\n{\n    this._db = pgp(/*options*/)(config.divi_db_connectionstring); //connect to database\n}\n\ndeleteAllBooks() : any\n{\n    return this._db.query(\"delete from dbo.note\", null, null);\n}\n\ninsertBook(name: string, src: string) : any\n{\n    return this._db.none(\"insert into dbo.note(name, src) values($1, $2)\", [name, src]);\n}\n\nselectBook() : any\n{\n    return this._db.query(\"select name, src from dbo.note\", null);\n}\n\n}\nexport = Database;\n```\nioc.ts:\n```\n'use strict';\nimport { TypeBinding, Kernel, TypeBindingScopeEnum } from \"inversify\";\nimport IDatabase = require('../database/iDatabase');\nimport Database = require('../database/database');\nimport IServer = require('../webservice/iServer');\nimport Server = require('../webservice/server');\n//http://inversify.io\nclass Ioc\n{\n    public container : Kernel;\nconstructor()\n{\n    let c = new Kernel();\n    c.bind(new TypeBinding<IDatabase>(\"IDatabase\", Database, TypeBindingScopeEnum.Transient));\n    c.bind(new TypeBinding<IServer>(\"IServer\", Server, TypeBindingScopeEnum.Transient));\n    //c.bind(new TypeBinding<ISettings>(\"ISettings\", Settings, TypeBindingScopeEnum.Singleton));\n    this.container = c;\n}\n\n}\nexport = Ioc;\n```\n. This was super confusing. Please put these lines in your homepage documentation at the top:\nRun: npm install reflect-metadata@0.1.3\nAdd to your main .ts file: import 'reflect-metadata';\n. No, that light grey note is not enough. \nFirstly, because most users assume that a recent version of Node.js is a modern Javascript engine & so wouldn't click to read anything more.\nSecondly, because your front page 'hello world' app should show as few as possible, but all necessary, commands to get your app to run. \nIn Inversify's case this means including the instruction to install reflect-metadata - or 99% of users on Node will find the basic Inversify app fails for them.\n. Oh, and sorry, no time for a PR right now - it's just those two lines 'npm install...' though that must be included. \n. ",
    "harper84": "Richard, I think this was fixed in 1.3.1; it was spotted soon after release. Class decorators appear to be working now.\n. ",
    "kuncevic": "The problem is that I am relying on  third party module so to be more specific it is how I instantiate my third party thing:\n//That is '/model/something' module\ninterface ISomethingModel extends ISomething, mongoose.Document { }    \nexport var Something = mongoose.model<ISomethingModel>('Something', somethingSchema);  // that is what I meant by NotReallySomehting\nISomething - my interface contained just my custom properties of a model. \nexport interface ISomething {\n    field1: string;\n    field2: string;\n};\nmongoose.Document interface contained operations on a model which is third party coming from https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/mongoose/mongoose.d.ts.\n//That is Something from '/mock/something' module:\nexport class Something implements ISomething {\n    public static findOne(something: any, next:Function) {\n        //custom implementation to mock 'findOne' method from 'mongoose.Document'\n    }\n}\nThat is how I am replacing my imports manually from calling module. \nIf i need my implementation I am using:\nimport { Something } from '../mock/something';\nIn case I need full functional I am using this:\nimport { Something } from '../model/something';\n. @remojansen  yes that is correct I just updated with more details\n. @remojansen Thanks for help and the Tip is great!\nI think it is turned out that this:\ninterface ISomethingModel extends mongoose.model<ISomething>{}\nshould be this with Model capital, otherwise got an error.:\ninterface ISomethingModel extends mongoose.Model<ISomething>{}\nThen when I changed the interfaces like per example I we got an error in both cases when implements ISomethingModel \nclass SomethingModelMock implements ISomethingModel {\n public static findOne(something: any, next:Function) {\n        // mock _model response here\n    }\n}\nError saying that I need to implement aggregate... that is from mongoose.d.ts https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/mongoose/mongoose.d.ts\nexport interface Model<T extends Document> extends NodeJS.EventEmitter {   \n    aggregate(...aggregations: Object[]): Aggregate<T[]>;\n    aggregate(aggregation: Object, callback: (err: any, res: T[]) => void): Promise<T[]>;\n    aggregate(aggregation1: Object, aggregation2: Object, callback: (err: any, res: T[]) => void): Promise<T[]>;\n    aggregate(aggregation1: Object, aggregation2: Object, aggregation3: Object, callback: (err: any, res: T[]) => void): Promise<T[]>;\n}\nIn normal scenario for my case I do not really need to change/override any mongoose stuff\nclass SomethingModel implements ISomethingModel {\n   //nothing custom here\n}\nBut only in second case I need to do changes\nclass SomethingModelMock implements ISomethingModel {\n public static findOne(something: any, next:Function) {\n        // mock _model response here\n    }\n}\nSo how to resolve aggregate not implemented not sure yet.\n. @remojansen Oh I see. Is there any way to avoid this line and just reference is sort of globally?\n. ehhh vscode for some reason saying can't find module inversify without this thing /// <reference path=\"node_modules/inversify/type_definitions/inversify/inversify.d.ts\" /> in the top of .ts file.\n. That is how my typescript.json looking like:\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"module\": \"commonjs\",\n    \"sourceMap\": true,\n    \"emitDecoratorMetadata\": true,\n    \"experimentalDecorators\": true,\n    \"removeComments\": false,\n    \"noImplicitAny\": false,\n    \"watch\": true\n  },\n  \"exclude\": [\n    \"node_modules\",\n    \"typings/browser.d.ts\",\n    \"typings/browser\"\n  ],\n  \"files\": [\n      \"node_modules/inversify/type_definitions/inversify/inversify.d.ts\"\n  ]\n}\nUPDATE:\nFrom https://github.com/TypeStrong/atom-typescript/blob/master/docs/tsconfig.md\nNOTE: exclude should not be used when files or filesGlob are in use. The presence of the files property takes presedence over the exclude property.\n. That is tricky bit. Just having this section:\n\"files\": [\n      \"node_modules/inversify/type_definitions/inversify/inversify.d.ts\",\n      \"typings/main.d.ts\"\n  ]\nStill having same issue \nUPDATE:\nJust installed inversify typings to default folder typings install inversify --ambient --save\nThen rollback my exclude section \n\"exclude\": [\n    \"node_modules\",\n    \"typings/browser.d.ts\",\n    \"typings/browser\"\n  ]\nAnd now vscode is happy.\nAlso had ts build issue error TS2304: Cannot find name 'Promise'. which fixed by typings install bluebird --ambient --save\n. @remojansen  I just did install inversify using typings :) see my prev comment. \nAll good now and thanks for your help :+1: \n. Ah I see the trick. I've got typings 2.0.0-alpha.3 installed but I need 2.0.0-alpha.6 which is in  <reference path=\"../node_modules/inversify/type_definitions/inversify/inversify.d.ts\" />\n. OK great. Thanks again.\n. ",
    "ktutnik": "@remojansen can you share your analysis, where is the entry point on the express project to bootstrap  and resolve the dependency process. im thinking of creating a middleware but didn't get the spot.\n. it is not about wether it should return null or not, you can keep return null if that is the specification. \nMy point is when you have 50+ Types (classes) and if you forgot to register one of them (really easy to forgot them), finding the bug will be difficult. \nInstead Inversify should able to say \"Hey, you forgot to register this one which is required by the class you want to resolve\".\n. @remojansen Thanks for let me in as the team. hi all @inversify/collaborators.\nNo worries, i have take a look at the road map and also have check the changes you made on your fork. yes its biggie, and i think it will be awesome. Will spent time to learn the new architecture until it ready.\ncan you add me on hangout im? btw i living in a place @ +8:00GMT what yours? \n. great!\n. @remojansen Yes would love to join. if you need to reach me ktutnik@gmail.com\n. Yes interceptor is one step ahead.\nInterception increase the separation concern. Because it give ability to change method/property behaviour from other location. So that behaviour is reusable among classes.\nExample of interception, is adding caching behaviour to existing object without have to change the object itself. \nI saw the middleware feature of Inversify but I think it will be different. middleware seems a global way to change the behaviour of the Iversify system. but interception is specific to class that registered to the container. User freely intercept which class and define them in the registration. \nI made a dynamic proxy for this purposes. please take a look at https://github.com/ktutnik/benalu \n. have a look at the test here https://github.com/ktutnik/benalu/blob/master/tests/benaluproxy.test.ts\n. here is example what it will be:\nthe purpose is showing a log of execution time of a method call and print it using console.time and console.timeEnd.\nJavascript\ninterface IKatana {\n   swing();\n}\nclass Katana implement IKatana {\n   swing(){\n      console.log('Swing performed');\n   }\n}\nregistration:\nJavascript\nlet kernel = new Kernel();\nkernel.bin<IKatana>(\"IKatana\").to(Katana).addInterception((invocation, context) => {\n   if(invocation.memberName == \"swing\"){\n      console.time();\n      invocation.proceed();\n      console.log(\"Katana.swing execution time\");\n      console.timeEnd();\n   }\n});\nuses:\nJavascript\nvar katana = kernel.get<IKatana>(\"IKatana\");\nkatana.swing();\nthe result will be:\nSwing performed\nKatana.swing execution time\n9ms\n. I think Proxy is not clearly made for interception. The key point of interception is the execution step (befor execution, after execution or both).  User even can choose to not to execute the original method at all. \nProxy still can solve the problem but lost the feel of interception.\n. i just thinking the same, i think \"proxy\" is not a good name. and also i like the B implementation, so proxy is provided by the IOC itself.\nby the way my intention to add this \"proxy\" discussion is the need of AOP feature (interception) support which is a common function in today IOC. \n. ",
    "codyjs": "I came up with https://github.com/codyjs/express-typescript-ioc after hacking at an express + Inversify project for a while. It's maybe not as simple as an example should be, but it's fairly easy to understand what's going on without digging too much.\nThoughts on this as an example?\n. @remojansen Great, glad you like it!\nI like the idea of making the \"framework\" an npm package, and I'd be happy to contribute. Let me know if you need help with setting it up.\n. Ok. I will start migrating the code after work today\n. Cool, I'll try it out!\nYeah, we can close this issue and use the new repository for any bugs/features\n. This answers my question. Thanks!\n. I think this is a must-have.\nI think it would be nice if the user could have a choice of calling res.send() (or equivalent) after resolving the promise, or instead just have the promise resolve to the value to be sent.\nWe just need to have a similar check after the resolution of the promise, something like:\n``` ts\nlet handler: express.RequestHandler = (req: express.Request, res: express.Response, next: any) => {\n    let result = this.kernel.get(target.constructor.name)targetMethod;\n// try to resolve promise\nif (result && result instanceof Promise) {\n\n    result.then((value: any) => {\n        if (!res.headersSent) {\n            res.send(value);\n        }\n    });\n\n} else if (!res.headersSent) {\n    res.send(result);\n}\n\n};\n```\nBut either way, the controller method would need to return the promise.\n. > What about different types of responses? We return both HTML, json, images, mp3, zip and streams\nThe idea was to give users as much freedom as possible by giving them access to the Response object, but also allow the common case (i.e., res.send()) to be the easiest to implement by simply returning an object from your controller's method.\nI was thinking to get around this, we could add an optional parameter to the method decorators that specifies the method on res to call, something like @Get('/', 'sendFile'), but really this would be just as easy as calling res.sendFile() in the method itself.\n\nError handling? There should be a catch, but what about the statusCode and message?\n\nThis is something that hasn't been implemented yet, but definitely should. There should be a method on the InversifyExpressServer that lets you set up the error handlers, kind of like .setConfig(). That would be where you specify the error message and statusCode.\nThen either use next(err), or like you said, use a try/catch to around the controller method call and then pass the error along.\n\nI don't think that the next-function and be used.\n\nI don't understand this point. Why can't the next function be used?\n. @remojansen Thanks for the access! It will come in handy.\n@m-abs Sorry for the delay, I have been on vacation.\nAt first glance, I think the solution here would be to pass in the original next() function from the outer request handler to the controller method, but I would need to test it. When I get home tonight I'll hopefully be able to work on this.\n. I think I found the solution to your problem. It seems that the request handler was sending the response even if the controller method didn't return anything. This was negating any calls to next(). Adding an additional check to the else if condition seems to have fixed this:\n``` ts\nlet result: any = this.kernel.getNamed(\"IController\", controllerName)key;\n// try to resolve promise\nif (result && result instanceof Promise) {\nresult.then((value: any) => {\n    if (value && !res.headersSent) {\n        res.send(value);\n    }\n});\n\n} else if (result && !res.headersSent) {\n    res.send(result);\n}\n```\nAfter this fix, the following two test cases pass:\n``` ts\nit (\"should work for async methods which call next()\", (done) => {\n    @injectable()\n    @Controller(\"/\")\n    class TestController {\n        @Get(\"/\") public getTest(req: express.Request, res: express.Response, next: express.NextFunction) { \n            return new Promise(((resolve) => {\n                setTimeout(() => {next(); resolve();}, 100, \"GET\");\n            }));\n        }\n    @Get(\"/\") public getTest2(req: express.Request, res: express.Response) {\n        return \"GET\";\n    }\n}\nkernel.bind<TestController>(\"TestController\").to(TestController);\n\nserver = new InversifyExpressServer(kernel);\nrequest(server.build())\n    .get(\"/\")\n    .expect(200, \"GET\", done);\n\n});\nit (\"should work for async methods called by next()\", (done) => {\n    @injectable()\n    @Controller(\"/\")\n    class TestController {\n        @Get(\"/\") public getTest(req: express.Request, res: express.Response, next: express.NextFunction) { \n            next();\n        }\n    @Get(\"/\") public getTest2(req: express.Request, res: express.Response) {\n        return new Promise(((resolve) => {\n            setTimeout(resolve, 100, \"GET\");\n        })); \n    }\n}\nkernel.bind<TestController>(\"TestController\").to(TestController);\n\nserver = new InversifyExpressServer(kernel);\nrequest(server.build())\n    .get(\"/\")\n    .expect(200, \"GET\", done);\n\n});\n```\nLet me know if this also worked for you.\n. Great! I'm glad this helped. I'll be including this change in a 1.0.0-alpha.4 release sometime later this week.\n. Yes, this can be closed now.\n. Hey guys, thanks a lot for the contributions and help!\nI took a look at https://github.com/inversify/inversify-express-example and it looks good. The only problem is that after @remojansen makes the 1.0.0-beta.1 release, the way the controllers are bound to the kernel will need to change slightly, see https://github.com/inversify/inversify-express-utils/pull/3.\nOtherwise it is good. In the future it would be nice to add examples for using middleware (maybe passport?) and a vanilla JavaScript example.\n. I think inversify-express-utils is ready to be a release candidate. I can't think of any more features that would be needed.\n. I like the example, simple and clean.\nSome thoughts: This would mean that only one authProvider could be used throughout the entire app, but I think that more granular functionality could be achieved with custom authProviders if needed.\nBy default, how would the authProvider have access to the User object? Would this be serialized into the session after authentication? (This could be done with Passport)\n. @jhuntoo I like the idea of doing away with the express handler signatures and making things more customizable. Do we still want users to be able to access the request/response objects? (I.e. index(@req() request: express.Request)) or do we want to hide the express objects entirely?\n. I agree with @remojansen , it could be confusing since the name of the module is express. I think a new repo would be better\n. Maybe I misunderstood the question, but it sounds like @remojansen is right. I don't see why you would inject the request into anything. The request should be sent to the controller and passed along from there. Nothing \"depends\" on the request, it's just some data that's been sent to the server, and its lifetime is finite.\nIf you need to read an access token from the request, you can either send the request from the controller like this:\nTypeScript\n@Get('/')\ngetSomething(req, res) {\n    let token = this.service.getToken(req);\n    // ...\n}\nOr, preferably, you should use middleware, like this:\nTypeScript\n@Get('/', setAuthToken)\ngetSomething(req, res) {\n    // this was set in setAuthToken()\n    let token = req.token;\n    // ...\n}\nYou might find this example helpful.\n. I think it would be much easier and simpler to inject both instances into a service, an then implement the conditional logic explicitly in the controller:\nTypeScript\nif (req.headers.A) {\n    user = this.service.getUsersFromA();\n} else if (req.headers.B) {\n    user = this.service.getUsersFromB();\n}\nThis way it's clear just by reading the controller what is happening. Otherwise, you would have to dig through the IoC container configuration (app root) to find this logic, and even then it's not quite as clear.\nI suppose that if this is a common enough problem with Inversify in general, it isn't a bad feature to have. But right now I'm not convinced that it's necessary for this particular use case.\n. I think this should be currently supported, try this:\nEDIT: I misread the docs. You need to wrap the express app in an http.Server.\n``` TypeScript\n// ...\n// server.build() actually returns an Express.Application instance\nlet app = server.build();\napp.listen(3000, 'localhost', () => console.log('listening on http://localhost:3000'));\nlet server = require('http').createServer(app); \n// socket.io expects an http.Server versus a InversifyExpressServer\n// see http://socket.io/docs/#using-with-express-3/4\nlet io = socketIo(server);\n// ...\n```\n. No problem, hopefully that does actually work!\n.  I'm not very familiar with Restify, so I could be wrong, but after some reading it looks like Express doesn't support these \"route options\", only a simple string for a path.\nRestify API: http://restify.com/#routing (Scroll a bit down to see that server.get() takes an object as the first argument)\nExpress API: http://expressjs.com/en/4x/api.html#app.get.method\nOne thing that is missing from express-utils is the ability to have an array of paths, as specified in the Express API.\n@lholznagel, @alexmt thoughts?. +1 for the headers idea.. :+1: : LGTM as well.. ",
    "lholznagel": "Hey, just found this project.\nCurrently trying to learn the whole thing. Maybe when I have a clearer understanding of this, I can provide and / or extend the examples and also support the express-utils project.\nBut first I have to rewrite my project in order to get some experience.\n. Ah okay, so nearly the same solution I used.\n. Okay, will take a look at the issues later today and look if I fined something.\nCurrently working on a example for express. Possible that a PR for it comes today :)\n. What is there todo in inversify-express-utils? Updating the inversify dependencies?\n. As soon as I am ready with it I will make a PR\n. Thanks.\nIn the next few days I will create more examples. This was the most basic one I could think of.\n. I think yes. With the updated Readme it works\n. I totally agree with you. When we split the example you can do multiple example and don\u00b4t have a folder in folder in folder insanity. Then also greenkeeper could work when we just have one package.json in the root and then instead of app or so the example name.\nFor example BasicMongoDBTest. This would include a basic example which uses MongoDB and also is shows how to test it.\n. > Add CI checks inversify-express-example\nA new example is nearly finished, probably tomorrow. After that I would work on this.\nWhen all have CI we could add greenkeeper.\n. Interesting, just updated the example. The only problem was that I forgot to install inversify-dts. After installing it all worked\n. Oh, now I see the problem, forgot to take a look if the server starts. When I try to start it I get the same message.\n. In the express example everything works :)\n. When the updates comes, I would check if my example works, if not I would update it.\nCurrently working on a new example, will take some time because I don\u00b4t have much time this weekend.\nWould be nice if the new Version has some new commits, but to keep everything on the same Version I find it ok\n. Yeah checking why\n. Oh I think I now what is wrong. Need to change the config so that I have a running mongodb.\nTravis actually fails with The command \"npm typings install\" failed and exited with 1 during . think that I am missing a -g in the install script. Will take a look at it tomorrow\n. Fixed with inversify/inversify-express-example#7\n. This can be closed. Both appveyor and travis are completely successful\n. Oh, got it. Completely forgot about metadata.\n. Maybe I have an idea for the reflect-metadata problem. Because every module needs the main inversify project as dependency we can let the other modules access the main project. So how about we add a small api in the main project where all other modules register their decorators. With that only one module would create an instance of reflect-metadata.\nDon\u00b4t now if this could work, will take a small look.\n. Internally everything works, but when I try it in my project it breaks again :(.\nMaybe the solution from inversify/inversify-express-example#9 is ok for the moment. Long term there must be another solution :D\n. Would help, but I completely avoid gulp, grunt, webpack, and so on. My setup uses TypeScript from start to end without any of these things. Only npm scripts :)\n. Don\u00b4t know why, but I never got warm with Passport.\nFor accessing the user Object I generate a jwt token and put it into the header field. In the Token I serialized a expire date and the id of the user. So when I need the id I deserialized the token and searched for the id in the database. I think it is possible to insert some parts of the user Object so that we don\u00b4t need a database.\n. How much do we want to do in terms of Authentication? I think we should support a basic login with database and, to go with the time, something like two-factor authentication. With a module called notp it was very easy when I used it in an application of mine.\n. Wow that's so awesome :+1:\nI also agree with a move away from other frameworks. Will take some more work, but nothing that we can\u00b4t handle\n. @codyjs Maybe the Objects should only be available in a reduces way. Sometimes when I need to look into the Objects it is so much unnecessary information.\n. So, do we want to create a whole new framework?\nWhen we maybe should create an extra repo for it and we should define some issues, so that we can start working on it.\n. The angular / ngrx way is pretty awesome.\nI like to name my project like stars. kotai sound good to me\n. Here are some that don\u00b4t exist hundreds of times on Github\n- wega\n- canopus\n- enif\n- arktur\n- mirfak\n- elnath\n- nunki\n. The project idea is not active anymore.\nMy suggestion would be to use nest. I can take a look at upgrading as soon as I am home from work.\nCI is just enabling it in travis? \n. You're welcome, I am glad that I can help you :).\nWill take a look at the hapi example. \n. Just took a quick look. Is it really mostly just renaming?\nWhen yes I think a generic solution would be better.\n. Wait for a response from @remojansen. I just gave my two cents :D\n. good point with the npm module name. Would also say a new repo\n. I hink the [] needs to stay there:\nlet weapons = kernel.getAll<Weapon[]>(\"Weapon\");  // returns Weapon[]\n. Oh okay, thanks for trying :)\n. Ups, my mistake. Sorry for that.\nThanks for reporting.\nCan confirm that an index.d.ts is created and not an inversify.d.ts. When you change it locally, does it work then?\n. Can confirm this bug in another project also. Will create a PR to fix both projects :)\n. @remojansen in inversify-express-utils is the same problem. \n. Hey, I think it matches this issue #371 \n. Yep, but I also had the same problem there, before I did \"something\". I thought it was because of the migration but now the same problem occurs again, which is why I created this issue as a \"reminder\" and to find the problem so that we can add some information to \"How t use it\" topic.\nWill resume searching for the problem tomorrow.\n. export declare function Controller(path: string, ...middleware: express.RequestHandler[]): (target: any) => void;\nthe function under decorators.d.ts is exported.\nIn the file interfaces.d.ts the interface is exported:\nimport * as express from \"express\";\ndeclare namespace interfaces {\n  ...\n    interface Controller {\n    }\n   ...\n}\nexport default interfaces;\n. Okay found it. I added the namespace interface to the exported stuff:\nimport { InversifyExpressServer } from \"./server\";\nimport { Controller, Method, Get, Put, Post, Patch, Head, All, Delete } from \"./decorators\";\nimport { TYPE } from \"./constants\";\nimport { interfaces } from './interfaces';\nexport { InversifyExpressServer, Controller, Method, Get, Put, Post, Patch, Head, All, Delete, TYPE };\nexport { interfaces };\nin the code I now use:\nimport { interfaces } from 'inversifyexpress-utils';\nconst kernel = new Kernel();\nkernel.bind<interfaces.Controll>()...\n. @luisfarzati the implements Controller can be removed, works for me.\n. @remojansen you sir, are awesome! The latest release seems to fix it. Removing node_modules and reinstalling everything works.\n. Is this also a small libary or only a collection of code snippets?\n. Did you find a solution? or why is the issue closed.\n. The example is not yet updated. There is a PR inversify/inversify-express-example#106 which updates it.\nI must honestly say I forgot about that PR because of work / school.. Jop, just saw it. I like that idea, especially because there is one step less when connecting to a database or something similar.\n. Also: basarat gitbooks\n. I would help to remove them in the side projects :)\n. Another idea while I am looking at inversify-express-utils. The file interfaces uses a namespace. Why export all interfaces when you only need one.\nWould have the benefit that you only import those interfaces that you need and that you don\u00b4t collide with the interfaces from inversify.\nOr is there any benefit that I currently don\u00b4t see to keep it that way?\n. Sorry, I was a little bit unclear what I meant.\nThat you export them is ok but is the namespace needed?\nI personally have a file interfaces.ts somewhere in my project. In this file, I create all my interfaces and export them. When I need them I import only those that I need. But with the namespace, I would theoretically import all, also those that I don\u00b4t need.\n. Oh yeah remember that problem.\nI think that the namespace is better than ContainerInterface\n. Oh yeah, I can totally understand you, that really is ugly. From my point it looks good.. What if you take the variable created in Line 36, and put this into a container?. I am using ava and can confirm that decorators make problems. But I think it's actually reflect-metadata that is causing this problem.\n. I use for coverage nyc. For coverage with ava you need to use nyc because ava\u00b4s way of running tests.\nThe only solution I can think of, is to map the coverage files to the ts files not the js. \n. So just tested my idea. It works :tada:\nWhen using sourcemaps they should automatically map to the ts files. When this is successful you see in the Istanbul html report, that there are all .ts files and no .js files. When you now open one of those files it shows the coverage of that file. Because we don\u00b4t have any decorators that are converted from ts to js we don\u00b4t have the problem that that code is not covered.\n. So firstly I tested to use gulp-sourcemaps and gulp-typescript like I did before. The problem was, that because of some paths in the sourcemaps, nyc had some problems.\nAfter some tinkering I changed added \"inlineSourceMap\": true to my tsconfig.\n\n\nWhole tsconfig\njson\n{\n  \"compilerOptions\": {\n    \"target\": \"es6\",\n    \"inlineSourceMap\": true,\n    \"module\": \"commonjs\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"moduleResolution\": \"node\",\n    \"declaration\": false\n  },\n  \"compileOnSave\": false,\n  \"exclude\": [\n    \"node_modules\"\n  ]\n}\n\nand that's basically it. When I now compile with tsc the javascript files all contain the sourcemaps for the typescript file and nyc uses them.\nHope it helps :)\n. Hi @ppsimatikas, sorry to hear that.\nDo you have a repo or similar? Maybe I can take a look at it and help.\n. Hm, tsconfig looks good. Never looked into jest so I have no idea if the config is okay.\nWhen you now run the tests and nyc displays its output (look down for example). Are the files shown as .ts or .js?\nMaybe chaning es2015 to es6 but I don\u00b4t think that this is the problem\n---------------------|----------|----------|----------|----------|----------------|\nFile                 |  % Stmts | % Branch |  % Funcs |  % Lines |Uncovered Lines |\n---------------------|----------|----------|----------|----------|----------------|\nAll files            |     78.1 |    73.68 |    66.25 |    78.02 |                |\n src                 |       76 |    85.71 |    42.86 |       76 |                |\n  amqp.ts            |      100 |      100 |      100 |      100 |                |\n---------------------|----------|----------|----------|----------|----------------|. I also think that express not supports this kind of options.. Do you use version 2 or version 3 (current beta)?\nVersion 3 will have a big performance boost https://github.com/inversify/InversifyJS/issues/395#issuecomment-258036753. Think that the response based on the Header is one of the best way to deal with that. Because like @remojansen said when we support json as decorator we also need plain, xml.\nMaybe we should generally rethink the express utils and look what is missing and what is really needed. But also without the decorator pain like spring boot.. With a quick look, it looks good.. Would take a look at express-utils and restify-utils tomorrow :). When do you plan to create a release for express-utils?, so that I can upgrade the express-examples.. No worries, going to bed in an hour :). Currently, I don\u00b4t understand the problem. When your code throws an error, inverify express (restify) utils don\u00b4t work as expected anymore?. This would be the only idea I have. Question is what we do in the catch only make an output saying that there is an unexpected problem?\nWondering why @riggerthegeek don\u00b4t uses a try-catch but ok.. ah okay.\nWe could make use of setErrorConfig(errorConfig) from inversify-express-utils and use that when a error happens. Hm, hard to say. But @riggerthegeek says that the same problem occurs with express. So I think we should also update the express repo with this fix.. Both packages should be nearly equal. To have them in separate repos and packages was more a design choice.. Sorry, I never really worked with passport.. Hm good question. I always do it like @remojansen listed it. I route subdomains and such with nginx to the server it belongs.\nDid you tried your example from above? Just taking a quick look at the vhost module, maybe you can try to do something like this: @Get(vhost('cms.local')). Really don\u00b4t know if this works and if inversify-express will detect this.\n. Well with the url given from above this would work:\n``` ts\n@injectable()\n@Controller('/')\nexport class HomeController {\n  @Get('/')\n  public get(req: Request, res: Response) {\n    // admin page\n    return '/';\n  }\n}\n@injectable()\n@Controller('/customer')\nexport class CustomerController {\n  // normaly post here get for testing\n  @Get('/add')\n  public get(req: Request, res: Response) {\n    // add customer\n    return '/customer/add';\n  }\n}\n```\nThen I tried to make subdomains working. My only solution was this:\nts\napp.use(vhost('cms.example.localhost', (request: Request, response: Response) => {\n  response.redirect(request.originalUrl);\n}));\nThe problem with this is that you can access all routes, without subdomain or with a changed subdomain.\ncms.example.localhost -> works\nasd.example.localhost -> works. I remember that we wanted to do something like this in citadeljs.\nI think this would be a good idea. :+1: . Nope, sorry.\nNever used babel always typescript.. Inversify also works in the browser and I think that needs dom.. From a quick look, this could be possible.\nJust keep in mind that the decorators are still needed.. This is because of TypeScript.\nBecause we use decorators, these helper functions are generated by TypeScript in order to make it compatible with JavaScript.. So after some research, I found out that there is a Compiler Options flag that reduces the amount of helper functions.\nWhen you add \"importHelpers\": true to the tsconfig.json file then, a file tslib is importet to every file.\ntslib, this contains methods for all helper functions.\nBecause these just get imported all helper functions should get removed.. Just as a general idea and to prevent things like this, maybe we should lock the dependency versions? I mean we have greenkeeper enabled.. Getting the same errors like Remo when cloning and trying to run it.\nLike you said I run npm install before starting. After that I executed npm run build-dev.. Seems to be an issue with missing dependencies in the package.json\nfile-loader and url-loader are missing, installing them fixes some of the errors. You can test if it works, by removing the node_modules folder. Then just run npm install again and it should work.. Just took a quick look at the code.\nIn the abstract class you use @Get('/id') but this needs to be @Get('/:id).\nIf you don\u00b4t add this the route would be /rest/id. I think this is ok.\nOn startup express-utils checks for all controllers in inversify. When it finds them it registered them in express. The reason for the exception is that no controllers are registered and so express-utils cannot register them in express.\nThat\u00b4s why I think it's ok because it makes no sense to start a express server without registered routes.. I understand your point. Yes, by reading your comment I would say use inversify.\nTaking a quick look at the readme of inversify-express-utils there are only things for controllers or am I overseeing something where you benefit from express utils?\n@remojansen Maybe we have to add something like: These are only utils for express. They support you building controllers with the power of inversify. to the readme to make it clear that these are only utils for creating controllers.. Can you create a small example repo? Maybe then I can help you better.. Sorry for that.\nFor me using body parser as middleware in express was a base requirement, feel free to send a PR :). @patrickhousley under #57 I extended the example with body parser.\n@theodesp what do you mean by that? Express does not throw an exception or does something else.\n@both Like discussed here, express utils is only a util and supports you building express controllers. We just added some decorators on top of express. Because we don\u00b4t change the way express works, I don\u00b4t think it is our task to check if the user added a body parser.\nFeel free to extend the PR.. Done in #57. @remojansen could you restart appveyor?. We had some problems with greenkeeper when not locking the dependencies.. What imports has 3. CONCRET OBJECT?\nMy first guess is that because of @injectable() inversify tries to inject Http into the constructor. But that is not added to myContainer.\nAn example project containing only the important code could be helpful :)\nSidenote:\nPlease don\u00b4t add +1 or I have the same problem. If you are interested in the topic click Subscribe. Then you get notifications. Thanks :). Hm without testing it I would say something like:\nmyContainer.bind<Http>(TYPES.Http).to(Http)\nI always used the angular dependency injection so, I don\u00b4t know how to handle this the best way, sorry.. Hey, sorry for the late reply. I just added one comment.. Feel free to create a PR :). I think this is a good idea. :+1: Feel free to create a PR, happy to review it. Hey thanks for the issue, I must say that I never that of that issue.\nI think it could work with something like this: (not tested!)\n``` javascript\nimport * as bodyParser from 'body-parser';\nimport * as fs from 'fs';\nimport * as http from 'http';\nimport * as https from 'https';\nimport { Container } from 'inversify';\nimport { interfaces, InversifyExpressServer, TYPE } from 'inversify-express-utils';\n// replace this with your private key\nconst privateKey  = fs.readFileSync('sslcert/server.key', 'utf8');\n// replace this with you certificate\nconst certificate = fs.readFileSync('sslcert/server.crt', 'utf8');\nconst credentials = {key: privateKey, cert: certificate};\n// set up container\nlet container = new Container();\n// note that you must bind your controllers to Controller\ncontainer.bind(TYPE.Controller).to(FooController).whenTargetNamed('FooController');\ncontainer.bind('FooService').to(FooService);\n// create server\nlet server = new InversifyExpressServer(container);\nserver.setConfig((app) => {\n  // config for express\n  app.use(bodyParser.urlencoded({\n    extended: true\n  }));\n  app.use(bodyParser.json());\n});\nlet app = server.build();\n// create the http server\nconst httpServer = http.createServer(app);\n// create the https server\nconst httpsServer = https.createServer(credentials, app);\nhttpServer.listen(8080);\nhttpsServer.listen(8443);\n```\nPlease let me know if this helps :)\nHave a nice day.. @esakkikrishnan if you only want to use expressjs remove all the inversify-express-utils and replace let app = server.build(); with let app = express(). Feel free to create a PR :). Hey,\nsorry to say but this is really not an inversify issue. If you want to return 204 you need to return it by yourself.. Status code 200 is the default behavior of express.\nInversify-express-utils is like it says just a util for working with inversify. We should not change the default behavior or do something else that has nothing to do with us, in my opinion.. The example you looked at is from inversify-express-utils. That is an extra for inversify to help building express applications.\nIf you just want to use inversify, take a look at the readme of this repo, where an example is given. These are just plain inverify and no express is involved.. I restarted the travis job twice, but the error still occurs :/. @remojansen know all builds are red :D. /home/travis/build/inversify/InversifyJS/test/container/lookup.test.ts\nERROR: 66:41  no-unused-expression  unused expression, expected an assignment or function call\nERROR: 66:41  whitespace            missing whitespace\nERROR: 66:42  semicolon             Missing semicolon\nI think that these are linter errors. :). Oh okay, I meant the PR, sorry. Just as an FYI: This is a possible breaking change. ",
    "chrispickford": "Was a Knockout.js example ever created? I'm struggling to integrate Inversify using a custom component loader.. ",
    "dtbiedrzycki": "Was this work completed? I am on inversifyjs version 5.0.1 and do not see anything that seems to support this.\nEDIT: found it!: https://github.com/inversify/InversifyJS/blob/master/wiki/activation_handler.md. ",
    "mattgrayisok": "Thanks @remojansen. Just tried it out and the typings referencing is working as expected now.\nThe process I followed this time around was:\n- npm install inversify Installed ^2.0.0-alpha.3\n- Added /// <reference path=\"../node_modules/inversify/type_definitions/inversify/inversify.d.ts\" /> to the top of my inversify.config.ts\n- import { Kernel } from \"inversify\"; works as expected and compiles\nNote that includinginversify.d.ts as a file: reference in a typings config results in bluebird not being included for whatever reason and consequently Promise is undefined when target is set to es5. Might be something to look into in the future :+1:\n. ",
    "marnits": "I cannot do \nimport \"reflect-metadata\";\nin my ts files. It's not working.\nI suggest that you should think about preparing documentation how to use inversify with ES6 modules. I really don't know how to successfully configure your library. In other hand - inversify should inject dependent module be itself. I understand that this is alpha version. I'll change my imports (ES6 modules) for require (Typescript import) and I believe it will works fine, but stable version should work with both of the import mechanisms. \n. Hi @remojansen ! Thank You for providing the document. When I've tried use \nimport \"reflect-metadata\";\nI was getting\nUncaught TypeError\nso I thought that this is related with this import, but not.\nThis error appears only when I'm trying to use .toValue(). For example:\nkernel.bind('global').toValue(window);\nkernel.bind('six').toValue(6);\nWhen I'm getting this values from kernel, it prompts Uncaught TypeError. Probably it's because I'm doing something wrong - nevermind. \nThe problem with Reflect has gone - thank You for your help.\n. ",
    "acopalipsis": "Thanks for help. Even had to abandon the Declaration established through tsd.\n. let id: symbol = Symbol.for('some-id'); // Symbol is constructor which retutn type symbol\ntypeof id === \"symbol\"; // true\nString === string, Number === number, Symbol === symbol\n. https://www.typescriptlang.org/play/#src=let%20a%3A%20Symbol%3B%0Alet%20b%3A%20symbol%3B\nsee that red Symbol? in .ts.d validation of the type Symbol.. but the compiler is yelling that this is a mistake, because there is no type Symbol is symbol.\n. You are right I compile es6. It was easier for me to .ts.d edit Symbol on the symbol.\n. each primitive that is to inject, it is better to refuse. And to group related values not only for DI, it is even more terrible. It DI not from the world of js. They will be available only to those who do not understand js. easier to write factory for each dependency than to create interfaces for each VO + constant with a unique type. The first will be faster + all the features es7 (spread operator).. ```\nkernel.bind(\"Number\").toConstantValue(5).when((request: interfaces.Request) => {\n    return request.target.name.equals(\"a\");\n});\nkernel.bind(\"Number\").toConstantValue(5).when((request: interfaces.Request) => {\n    return request.target.name.equals(\"b\");\n});\n```\nvs\n```\nconst factory = props => new A( ...props );\nfactory( [ 5, 6 ] );\nconst factory = ({a, b}) => new A( a, b );\nfactory( {a: 5, b: 6} );\n```\nin js there is a great opportunity to pass parameters when you call, why not use it?. ```\nkernel.bind(\"Number\").toConstantValue(5).when((request: interfaces.Request) => {\n    // I here somehow to access the dependencies?\n    return request.target.name.equals(\"a\");\n});\n```. if I understand correctly, then I do it - \n```\n// app-configuration.ts\nexport const app: Container = new Container();\napp.bind( Symbol.for( 'SomeConfig' ) ).to( { name: \"APP_NAME\" } );\n// .spec.ts\nimport { app } from \"../src/app-configuration.ts\";\nlet spec: Container = new Container();\nspec.parent = app;\nspec.bind( Symbol.for( 'SomeConfig' ) ).to( { name: \"SPEC_NAME\" } );\nconsole.log( spec.get( Symbol.for( 'SomeConfig' ) ).name ); // SPEC_NAME\n```\n. If so, then I apologize! This is the first thing that occurred to me, but typescript auto-completion in phpstorm said that there is no such method.... @remojansen very cool! Thanks.. ",
    "coveralls": "\nCoverage remained the same at 100.0% when pulling d93864113366acd0266d0f386d687a878465cb72 on remojansen:master into 17d008539873ba7b818245d7499b310b75932597 on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling 7e1d831ffba6a3fb936d5732d16f0b5af2602f8a on remojansen:master into d6d1adb1a7f74f0a7073fd0c016838b1e24e1e3a on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling cc9191dc69c1f24ae04529ef89a055ad3b51ee8e on remojansen:master into fc9d371120974266c3bf42bed5e553fc848e1eef on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling 459800bcdd2197cf811cfdf2d40f32133a785dbe on remojansen:master into fc9d371120974266c3bf42bed5e553fc848e1eef on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling a75c6efe65a6bd4bf542f11effea11d805f7a9f9 on remojansen:master into fc9d371120974266c3bf42bed5e553fc848e1eef on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling d460bb657925ab3d98d6ea98dc1144e1b1cff1da on adidahiya:patch-1 into 88798e661487610992b5cfacc3d23bf240fd9406 on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling 166f902106bc17d7ed8d6f3165f25796618214db on hourliert:package-typings into 8d436653a497670f38b8c513e37781183de77eff on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling 470739e93cfb5e3342a1619bc8ebf85449cc7fce on hourliert:lib-es-build into 8d436653a497670f38b8c513e37781183de77eff on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling c861b91d731e179855133da4052f447b4def5269 on hourliert:lib-es-build into 8d436653a497670f38b8c513e37781183de77eff on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling c2b84d733a8609969c1f05542ca9aae778b8b858 on remojansen:master into 616258969b001c07c9e0223b0cb2920dbfbc03d0 on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling a4461c2d960194557eb9a41bc0c2bf648e2ab606 on remojansen:master into 616258969b001c07c9e0223b0cb2920dbfbc03d0 on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling 85d1a4c7700e50bcbf977ad26f7f9253916cc5b9 on mikaturunen:master into 8a835c2ab5bf463add98c73ac5ca4a828e49cef8 on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling 1de1e6835b094b5e5fd48618f492337edbb47830 on remojansen:master into 3bc34e3f9c9bf18f27c4a5e7244e14a5928cedea on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling 75842596f28212f2948a4a954372cd77a67c2377 on remojansen:master into f52cca561381ff97041eab650eefe9b65e8d9faf on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling 541abf95f28358519a0c207105eba1c00aa6a027 on remojansen:master into f9189e50c2d6846e02377b39bff5c9b591dfa36e on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling 636795ecc38585c17972c133a423be20017bd4b0 on hourliert:multiinject-array into 6b5459ab9b05af6a36a8869b8a872b6625b20bfe on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling b4d3bc0c6de3b0c1f6312c98980e95070d60e092 on remojansen:master into fcf2cc11035e407d00f5fc2b94c278bc3d5dfa64 on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling 66c57cb5fac79e749f459b16518b5b1fad356de8 on hourliert:multiinject-complex into af36bf72dad6706ff07cebdff65366f566de72dd on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling 3cde6fc7748f3e2b4c0fe78dc1376546e67c9733 on remojansen:master into b9b56ff420309dbdcdcbb215b8465804915edbe2 on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling 66b4effcb2c2a798b32f57884a31b8bdc966e98a on remojansen:master into 115d55947c83bd850645afba4a30ed3cc601dca8 on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling be63558785110057cc238c312a0f9ec73182d151 on CoderAjay:master into 88823b0e4e0d5c4c4afda688f228d26d78902400 on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling f9bd9b88efe16333eb06a7f400aaf75a94dedbe3 on KarolBuchta:master into 98777c58fcb013dde74a19b11063d2d459d3287a on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling 56e3532ddc02b7a2d36c8178ea183b205636bd80 on markistaylor:error_msg_type into 186b7cb53c9b4c0e549de962c1248bcbf6ea5e7a on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling cc7cc316ab9df4df56cda158f9dcf49602b0fc2c on markistaylor:iprovider-bug into 9a04e957092703ccb59b60937e3ffe10fe8cf79a on inversify:master.\n. \nCoverage remained the same at 100.0% when pulling cc7cc316ab9df4df56cda158f9dcf49602b0fc2c on markistaylor:iprovider-bug into 9a04e957092703ccb59b60937e3ffe10fe8cf79a on inversify:master.\n. ",
    "hourliert": "Hi,\nYou're right. I have never noticed that (maybe because I never had to debug something related to redux).\nI guess, we still could include source maps like in the dist folder as long as they are not inline.\nWe could use the typescript compiler directly (without using gulp) to output these 2 folders. Or just create new gulp tasks to be standardized.\nWhat do you think? I could do the PR if you want.\n. Seems good. The only remaining thing is how should we modify package.json?\nIn redux, they are a main key pointing to lib/index.js and a jsnext:main key pointing to es/index.js here.\nThe file dist/redux.js is not included in package.json.\nFor inversify, what about dist/inversify.js?\n. Yep, I have just noticed that when testing the PR for https://github.com/inversify/InversifyJS/issues/138.\nMoreover, I haven't noticed that the type definitions files for Inversify are not auto-generatred by Typescript. Is there a reason against that?\n. I see. Seems legit!\n. @remojansen Yeah! Can't wait to see alpha.7 out. \nAnd BTW, this library is awesome. Great job!\n. If browserify works the same way than webpack. https://github.com/inversify/InversifyJS/pull/140 should solve this.\nA quick fix could be to declare inversify as external in the browserify config file.\n. Ok, you are confirming my thoughts!\nI will let you know if I have an issue when using this.\n. We can close as this is not really an issue I guess.\n. I am going to work on this.\nJust before starting. What the final decision?\nI have written some tests to help us to understand the 2 possibles solutions:\nThis one works out of the box (look at the comment //INTERESTING PART HERE to save some time)\nEDIT: the test is available here\n``` typescript\n    it(\"Should be able to inject dependencies into a mother class\", () => {\n    interface INinja {\n        fight(): string;\n        sneak(): string;\n    }\n\n    interface ICyberNinja extends INinja {\n        hack(): string;\n    }\n\n    interface IKatana {\n        hit(): string;\n    }\n\n    interface IShuriken {\n        throw(): string;\n    }\n\n    @injectable()\n    class Katana implements IKatana {\n        public hit() {\n            return \"cut!\";\n        }\n    }\n\n    @injectable()\n    class Shuriken implements IShuriken {\n        public throw() {\n            return \"hit!\";\n        }\n    }\n\n    let TYPES = {\n        Katana: Symbol(\"IKatana\"),\n        Ninja: Symbol(\"INinja\"),\n        Shuriken: Symbol(\"IShuriken\")\n    };\n\n    class Ninja implements INinja {\n\n        private _katana: Katana;\n        private _shuriken: Shuriken;\n\n        public constructor(\n            katana: Katana,\n            shuriken: Shuriken\n        ) {\n            this._katana = katana;\n            this._shuriken = shuriken;\n        }\n\n        public fight() { return this._katana.hit(); };\n        public sneak() { return this._shuriken.throw(); };\n\n    }\n\n    //INTERESTING PART HERE\n    @injectable()\n    class CyberNinja extends Ninja implements ICyberNinja {\n        public constructor(\n            @inject(TYPES.Katana) katana: Katana,\n            @inject(TYPES.Shuriken) shuriken: Shuriken\n        ) {\n            super(katana, shuriken);\n        }\n\n        public hack() { return \"hack!\"; }\n    }\n\n    let kernel = new Kernel();\n    kernel.bind<ICyberNinja>(TYPES.Ninja).to(CyberNinja);\n    kernel.bind<IKatana>(TYPES.Katana).to(Katana);\n    kernel.bind<IShuriken>(TYPES.Shuriken).to(Shuriken);\n\n    let ninja = kernel.get<ICyberNinja>(TYPES.Ninja);\n\n    expect(ninja.fight()).eql(\"cut!\");\n    expect(ninja.sneak()).eql(\"hit!\");\n    expect(ninja.hack()).eql(\"hack!\");\n\n});\n\n```\nThis one doesn't because _katana and _shuriken are undefined.\n``` typescript\n        @injectable()\n        class Ninja implements INinja {\n        private _katana: Katana;\n        private _shuriken: Shuriken;\n\n        public constructor(\n            //INTERESTING PART HERE\n            @inject(TYPES.Katana) katana: Katana,\n            @inject(TYPES.Shuriken) shuriken: Shuriken\n        ) {\n            this._katana = katana;\n            this._shuriken = shuriken;\n        }\n\n        public fight() { return this._katana.hit(); };\n        public sneak() { return this._shuriken.throw(); };\n\n    }\n\n    @injectable()\n    class CyberNinja extends Ninja implements ICyberNinja {\n        public hack() { return \"hack!\"; }\n    }\n\n    let kernel = new Kernel();\n    kernel.bind<ICyberNinja>(TYPES.Ninja).to(CyberNinja);\n    kernel.bind<IKatana>(TYPES.Katana).to(Katana);\n    kernel.bind<IShuriken>(TYPES.Shuriken).to(Shuriken);\n\n    let ninja = kernel.get<ICyberNinja>(TYPES.Ninja);\n\n    expect(ninja.fight()).eql(\"cut!\");\n    expect(ninja.sneak()).eql(\"hit!\");\n    expect(ninja.hack()).eql(\"hack!\");\n\n``\n. Nice, I didn't know aboutObject.getPrototypeOf()`. That's neat.\n. I am working on the fix.\nIn fact, I found a more generic solution to https://github.com/inversify/InversifyJS/issues/155.\nInstead of this we should do something like this:\n``` ts\n        if (\n            request.target && request.target.isArray() &&\n            (!request.parentRequest.target || !request.parentRequest.target.isArray())\n        ) {\n        // Create an array instead of creating an instance\n        return childRequests.map((childRequest) => { return this._resolve(childRequest); });\n\n    } else { ... }\n\n```\nIt solves https://github.com/inversify/InversifyJS/issues/155 more elegantly too (so we could remove this).\nThe problem with that is if we are doing a @multiInject of a @multiInject.\nAnother way is to hack something here. I am not sure this is the really elegant...\nDo you see another solution?\nEDIT: \nI found the proper solution. I added a method on interfaces/planning/target.d.ts to check if the target has a metadata multi_inject for a specific service.\nThis allows me to test if the parent has a metadata multi_inject in the same 'family'.\nIt seems to work well. I am going to push soon. I just need to write more tests.\n. I will push something that solves @multiInject of @multiInject very soon. You tell me if that is acceptable \ud83d\ude03 \nI have also written more tests of complex situations. I hope that will better cover 'real world' use cases.\n. You are right.\nI think runtimeIdentifier is better. Or we could use something like serviceIdentifier. IMO, having 'identifier' into these variable names is more relevant.\n. ",
    "rashtao": "Thanks, that solves my problem.\nCongrats for this great work!\n. Thanks for the response. I agree that using constructor injection makes everything better, independently from the library/framework/language. For my implementation I am fine with using it.\nAbout the approach that you propose, I think it is almost like using the kernel as Service Locator registry. But it would be another design pattern, sometimes considered an anti-pattern!\nMaybe you could explicitly clarify in the documentation/examples that setter injection is achieved using the kernel as Service Locator registry.\nFeel free to close this issue and congrats for your work and help! \n. From a user point of view, I would like to have the possibility to decide case by case whether to inject a Promise or the resolution value of the promise. And that is the point also about using async/await: the  consumer can decide to deal with the promise or to await and get the value. \nIn the constructor parameters annotations, we could have 2 alternatives:\n- @ inject --> injects a promise\n- @ awaitInject --> inject the resolution value of the promise\nFurthermore the lazyness concept is a little different to me: it means whether to create the dependency before or to inject a proxy and create the real object as the consumer calls methods on it. So the lazy annotation could be applied to both cases.\n. thanks for the clarification!\nhaving a flexible @inject would be nice... Anyways from the consumer point of view: @inject(\"Provider<T>\") would be the same of @inject(\"Promise<T>\"), right?\n. ",
    "mikaturunen": "If the PR's go in this easily, I don't see it as a problem. It's quite common in actively developed products. Good work guys! Enjoyed using Inversify so far. \n. ",
    "KarolBuchta": "This issue also exists for 2.x.\n. Hi, i am the one who asked in chat. \nThank you i see the point. I will try that out when it's released.\nI've also just tried out external, as the browserify docs state:\nConfig in package.json\n\"browserify\": {\n    \"transform\" : [\"browserify-shim\" ],\n    \"external\": [\"inversify\"]\n  },\nProgrammatic usage:\n\nExternal requires may be specified in opts.require, accepting the same formats that the files argument does.\n\nI have also tried the noParse option.\nAll of this did not work. I am not sure whether i did something wrong here, i'm new to browserify/ts etc. I could imagine that this doesn't work correctly because of tsify. While establishing the build file i had several issues with it going into a similar direction (ignored options or transforms). I would have to investigate further on a detailed reason.\nBut in the meantime:\nThis article (substack/node-browserify#1151) states 3 possible solutions for the problem \"Requiring a third party standalone browserify module into another browserify build.\":\n\nI've seen confusion about how to consume a bundle in a subsequent bundling operation a number of times here and on stackoverflow1. Generally it can be cured by:\nSetting noParse for bundle A in the bundle B operation; or\nRunning the standalone bundle through derequire; or\nMinifying the bundle\n\nI found a solution for me, in the gulpfile in my init task:\n(Sry, this is still coffeescript, i encountered this issue while migrating a project to ts)\n```\nderequire = require 'gulp-derequire'\ntasks.push(\n    gulp.src(['node_modules/inversify/dist/inversify.js'])\n    .pipe(derequire())\n    .pipe(gulp.dest('src/ts/libs'))\n)\n```\nAnd in package.json i've added:\n\"browser\": {\n  \"inversify\": \"./src/ts/libs/inversify.js\",\n},\nMy original suggestion was that you use derequire too, because this will be the most unobstrusive way for other developers to use your library. Any further problems will be avoided, people can simply do require('inversify') without any further settings or workarounds. But as you want to deploy a lib version too, this is probably unnecessary.\n. Hi,\nI reinstalled the inversify node module, removed my browserify shim (which made the thing break before), and tested again with alpha.8. I have tested the new configuration with the exact same conditions in my build. \nIt works with the new lib folder, together with the setting for main: \"lib/inversify.js\" in package.json. @hourliert You were right, it works the same way in browserify as in webpack, i checked it in the docs.\nI also checked whether switching the module resolution in browserify to classic, which had no influence as well.\nI think this issue can be closed.\n. ",
    "mention-bot": "By analyzing the blame information on this pull request, we identified @adidahiya, @PeterDaveHello and @mikaturunen to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen to be a potential reviewer\n. By analyzing the blame information on this pull request, we identified @adidahiya, @hourliert and @PeterDaveHello to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen to be a potential reviewer\n. By analyzing the blame information on this pull request, we identified @hourliert, @adidahiya and @Jameskmonger to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen, @adidahiya and @PeterDaveHello to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen to be a potential reviewer\n. By analyzing the blame information on this pull request, we identified @remojansen to be a potential reviewer\n. By analyzing the blame information on this pull request, we identified @remojansen, @adidahiya and @PeterDaveHello to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @hourliert, @Jameskmonger and @jamesrichford to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @Jameskmonger, @remojansen and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @hourliert to be a potential reviewer\n. By analyzing the blame information on this pull request, we identified @hourliert to be a potential reviewer\n. By analyzing the blame information on this pull request, we identified @remojansen to be a potential reviewer\n. By analyzing the blame information on this pull request, we identified @remojansen to be a potential reviewer\n. By analyzing the blame information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @Jameskmonger, @greenkeeperio-bot and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen to be a potential reviewer\n. By analyzing the blame information on this pull request, we identified @Jameskmonger, @remojansen and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen to be a potential reviewer\n. By analyzing the blame information on this pull request, we identified @otbe, @adidahiya and @PeterDaveHello to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @otbe to be a potential reviewer\n. By analyzing the blame information on this pull request, we identified @Jameskmonger, @remojansen and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @greenkeeperio-bot, @remojansen and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen to be a potential reviewer\n. By analyzing the blame information on this pull request, we identified @Jameskmonger, @greenkeeperio-bot and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen to be a potential reviewer\n. By analyzing the blame information on this pull request, we identified @otbe, @adidahiya and @markistaylor to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @Jameskmonger, @remojansen and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen, @adidahiya and @PeterDaveHello to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @otbe and @hourliert to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @Jameskmonger, @greenkeeperio-bot and @PeterDaveHello to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @PeterDaveHello and @adidahiya to be potential reviewers\n. By analyzing the blame information on this pull request, we identified @hourliert and @Jameskmonger to be potential reviewers\n. @lukas-zech-software, thanks for your PR! By analyzing the annotation information on this pull request, we identified @remojansen to be a potential reviewer\n. @remojansen, thanks for your PR! By analyzing the annotation information on this pull request, we identified @greenkeeperio-bot, @hourliert and @Jameskmonger to be potential reviewers\n. @Skahrz, thanks for your PR! By analyzing the annotation information on this pull request, we identified @remojansen and @hourliert to be potential reviewers\n. @remojansen, thanks for your PR! By analyzing the annotation information on this pull request, we identified @endel and @lukas-zech-software to be potential reviewers\n. @endel, thanks for your PR! By analyzing the annotation information on this pull request, we identified @remojansen, @otbe and @hourliert to be potential reviewers\n. @greenkeeperio-bot, thanks for your PR! By analyzing the annotation information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. @greenkeeperio-bot, thanks for your PR! By analyzing the annotation information on this pull request, we identified @Jameskmonger, @remojansen and @hourliert to be potential reviewers\n. @greenkeeperio-bot, thanks for your PR! By analyzing the annotation information on this pull request, we identified @Jameskmonger, @remojansen and @hourliert to be potential reviewers\n. @greenkeeperio-bot, thanks for your PR! By analyzing the annotation information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. @remojansen, thanks for your PR! By analyzing the annotation information on this pull request, we identified @greenkeeperio-bot, @Jameskmonger and @Skahrz to be potential reviewers\n. @greenkeeperio-bot, thanks for your PR! By analyzing the annotation information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. @greenkeeperio-bot, thanks for your PR! By analyzing the annotation information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. @remojansen, thanks for your PR! By analyzing the annotation information on this pull request, we identified @hourliert, @endel and @greenkeeperio-bot to be potential reviewers\n. @greenkeeperio-bot, thanks for your PR! By analyzing the annotation information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. @Offirmo, thanks for your PR! By analyzing the annotation information on this pull request, we identified @remojansen to be a potential reviewer\n. @Offirmo, thanks for your PR! By analyzing the annotation information on this pull request, we identified @remojansen to be a potential reviewer\n. @remojansen, thanks for your PR! By analyzing the annotation information on this pull request, we identified @lukas-zech-software, @otbe and @endel to be potential reviewers\n. @remojansen, thanks for your PR! By analyzing the annotation information on this pull request, we identified @lukas-zech-software, @endel and @otbe to be potential reviewers\n. @remojansen, thanks for your PR! By analyzing the annotation information on this pull request, we identified @lukas-zech-software and @hourliert to be potential reviewers\n. @remojansen, thanks for your PR! By analyzing the annotation information on this pull request, we identified @endel, @hourliert and @lukas-zech-software to be potential reviewers\n. @remojansen, thanks for your PR! By analyzing the annotation information on this pull request, we identified @hourliert, @Jameskmonger and @greenkeeperio-bot to be potential reviewers\n. @Offirmo, thanks for your PR! By analyzing the annotation information on this pull request, we identified @remojansen to be a potential reviewer\n. @remojansen, thanks for your PR! By analyzing the annotation information on this pull request, we identified @hourliert, @lukas-zech-software and @otbe to be potential reviewers\n. @remojansen, thanks for your PR! By analyzing the annotation information on this pull request, we identified @endel, @otbe and @hourliert to be potential reviewers\n. @endel, thanks for your PR! By analyzing the annotation information on this pull request, we identified @remojansen and @lukas-zech-software to be potential reviewers\n. @timdp, thanks for your PR! By analyzing the annotation information on this pull request, we identified @remojansen, @markistaylor and @otbe to be potential reviewers\n. @greenkeeperio-bot, thanks for your PR! By analyzing the annotation information on this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers\n. @goenning, thanks for your PR! By analyzing the annotation information on this pull request, we identified @remojansen, @hourliert and @Jameskmonger to be potential reviewers\n. @goenning, thanks for your PR! By analyzing the annotation information on this pull request, we identified @remojansen to be a potential reviewer\n. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @greenkeeperio-bot, @Jameskmonger and @hourliert to be potential reviewers.\n. @greenkeeperio-bot, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers.\n. @greenkeeperio-bot, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @Jameskmonger and @hourliert to be potential reviewers.\n. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @Skahrz, @lukas-zech-software and @hourliert to be potential reviewers.\n. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @otbe, @lukas-zech-software and @endel to be potential reviewers.\n. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @otbe, @endel and @lukas-zech-software to be potential reviewers.\n. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @otbe, @lukas-zech-software and @endel to be potential reviewers.\n. @goenning, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @PeterDaveHello and @sergeyzenchenko to be potential reviewers.\n. @kennyjacob, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen to be a potential reviewer.\n. @kennyjacob, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen and @Jameskmonger to be potential reviewers.\n. @TiagoMestre, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen to be a potential reviewer.\n. @greenkeeper[bot], thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @greenkeeperio-bot and @Jameskmonger to be potential reviewers.\n. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @goenning, @hourliert and @endel to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @Jameskmonger to be a potential reviewer.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @endel and @hourliert to be potential reviewers.. @sanex3339, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @lukas-zech-software and @hourliert to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @hourliert, @lukas-zech-software and @endel to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @hourliert, @lukas-zech-software and @sanex3339 to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @sanex3339, @lukas-zech-software and @endel to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @greenkeeperio-bot, @Jameskmonger and @hourliert to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @sanex3339, @greenkeeperio-bot and @Jameskmonger to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @greenkeeperio-bot, @Jameskmonger and @hourliert to be potential reviewers.. @thinkingmedia, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen to be a potential reviewer.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @greenkeeperio-bot, @Jameskmonger and @hourliert to be potential reviewers.. @greenkeeper[bot], thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @greenkeeperio-bot and @Jameskmonger to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @sanex3339, @lukas-zech-software and @otbe to be potential reviewers.. @mertdeg, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen to be a potential reviewer.. @CoderAjay, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen to be a potential reviewer.. @greenkeeper[bot], thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @greenkeeperio-bot and @Jameskmonger to be potential reviewers.. @Pyo25, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @PeterDaveHello and @sergeyzenchenko to be potential reviewers.. @greenkeeper[bot], thanks for your PR! By analyzing the history of the files in this pull request, we identified @greenkeeper, @remojansen and @greenkeeperio-bot to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @greenkeeperio-bot, @Jameskmonger and @hourliert to be potential reviewers.. @netnexus, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen to be a potential reviewer.. @maxmalov, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen to be a potential reviewer.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @jamesrichford, @sanex3339 and @greenkeeperio-bot to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @sanex3339, @lukas-zech-software and @otbe to be potential reviewers.. @greenkeeper[bot], thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @greenkeeperio-bot and @Jameskmonger to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @sanex3339, @Jameskmonger and @hourliert to be potential reviewers.. @Dirrk, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @greenkeeperio-bot and @Jameskmonger to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @Skahrz, @hourliert and @KarolBuchta to be potential reviewers.. @Dirrk, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @greenkeeperio-bot and @Jameskmonger to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @jamesrichford, @lukas-zech-software and @sanex3339 to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @jamesrichford, @hourliert and @lukas-zech-software to be potential reviewers.. @greenkeeper[bot], thanks for your PR! By analyzing the history of the files in this pull request, we identified @greenkeeperio-bot, @remojansen and @Dirrk to be potential reviewers.. @greenkeeper[bot], thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @greenkeeperio-bot and @Dirrk to be potential reviewers.. @greenkeeper[bot], thanks for your PR! By analyzing the history of the files in this pull request, we identified @Dirrk, @remojansen and @greenkeeper to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @greenkeeper, @greenkeeperio-bot and @Dirrk to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @jamesrichford, @lukas-zech-software and @sanex3339 to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @jamesrichford, @greenkeeper and @greenkeeperio-bot to be potential reviewers.. @greenkeeper[bot], thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @greenkeeper and @greenkeeperio-bot to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @jamesrichford, @greenkeeper and @greenkeeperio-bot to be potential reviewers.. @greenkeeper[bot], thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @greenkeeper and @greenkeeperio-bot to be potential reviewers.. @remojansen, thanks for your PR! By analyzing the history of the files in this pull request, we identified @otbe and @greenkeeper to be potential reviewers.. @AltekkeE, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @timdp and @otbe to be potential reviewers.. @AltekkeE, thanks for your PR! By analyzing the history of the files in this pull request, we identified @Jameskmonger, @remojansen and @hourliert to be potential reviewers.. @AltekkeE, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @hourliert and @lukas-zech-software to be potential reviewers.. @theodesp, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @Pyo25 and @PeterDaveHello to be potential reviewers.. @theodesp, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @lukas-zech-software and @greenkeeper to be potential reviewers.. @tiagoschenkel, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @otbe and @endel to be potential reviewers.. @daxself, thanks for your PR! By analyzing the history of the files in this pull request, we identified @jamesrichford, @remojansen and @greenkeeper to be potential reviewers.. @cntech, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @Pyo25 and @PeterDaveHello to be potential reviewers.. @AltekkeE, thanks for your PR! By analyzing the history of the files in this pull request, we identified @greenkeeper, @remojansen and @greenkeeperio-bot to be potential reviewers.. @AltekkeE, thanks for your PR! By analyzing the history of the files in this pull request, we identified @remojansen, @greenkeeper and @greenkeeperio-bot to be potential reviewers.. ",
    "ballwood": "awesome, worked perfectly. might wanna add the npm package reflect-metadata as a dependency as well. doesn't seem to work without a require(\"reflect-metadata\");\n. Ok cool, didn't realise. Looks like a good project, will be giving it a thorough workout in the next few days to see if it's suitable for us.\n. ",
    "ajaysinghj8": "Thanks to you guys for building such a great IOC with typescript compatibility. I am using it one of my pet project and inversify rocks.\n. I have been able to find a work around for this problem, by replacing\nlib/resolution/instantiation.js: line 14\n   instance[propertyName] = injection; \nwith \n  Object.defineProperty(instance, propertyName, { value: injection });\nit works fine for me. . Ya, It is fixed in 3.0.0-rc.4, working fine for me. Thanks.  . ",
    "markis": "Hi, I like what you all are doing with this project.  Just trying to help out when I find things that need addressed.\n. ",
    "codecov-io": "Current coverage is 100.00%\n\nBranch #172 has no coverage reports uploaded yet.\nNo diff could be generated. No reports for master found.\nReview entire Coverage Diff as of 520b86c\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 100.00%\nMerging #173 into master will not affect coverage as of d0bf20d\n\ndiff\n@@            master    #173   diff @@\n======================================\n  Files           32      32       \n  Stmts          788     789     +1\n  Branches        65      65       \n  Methods        182     182       \n======================================\n+ Hit            788     789     +1\n  Partial          0       0       \n  Missed           0       0\n\nReview entire Coverage Diff as of d0bf20d\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 100.00%\nMerging #175 into master will not affect coverage as of 989612d\n\ndiff\n@@            master    #175   diff @@\n======================================\n  Files           32      32       \n  Stmts          789     789       \n  Branches        65      65       \n  Methods        182     182       \n======================================\n  Hit            789     789       \n  Partial          0       0       \n  Missed           0       0\n\nReview entire Coverage Diff as of 989612d\nPowered by Codecov. Updated on successful CI builds.\n. ## Current coverage is 100.00%\nMerging #176 into master will not affect coverage as of 68a9898\n\ndiff\n@@            master    #176   diff @@\n======================================\n  Files           32      32       \n  Stmts          789     789       \n  Branches        65      65       \n  Methods        182     182       \n======================================\n  Hit            789     789       \n  Partial          0       0       \n  Missed           0       0\n\nReview entire Coverage Diff as of 68a9898\nPowered by Codecov. Updated on successful CI builds.\n. \n",
    "lazyoft": "Hi @remojansen,\nThanks for the explanation, I didn't pay a lot of attention to binding constraints honestly, but they seem quite a powerful mechanism that should solve a lot of the issues I presented. The specific case I was trying to solve was that of an abstract factory that could use the kernel in order to solve components.\n``` typescript\ninterface ICarFactory {\n    createEngine(displacement: number): IEngine;\n    createTires(code: string): ITires;\n    createBody(color: string): IBody;\n}\n@injectable()\nclass DieselEngine implements IEngine {\n    constructor(\n        @inject(\"IInjectorPump\") private injectorPump: IInjectorPump, \n        @inject(\"displacement\") private displacement: number) {}\n    /.../\n}\n@injectable()\nclass PetrolEngine implements IEngine {\n    constructor(\n        @inject(\"ISparkPlugs\") private sparkPlugs: ISparkPlugs, \n        @inject(\"displacement\") private displacement: number) {}\n    /.../\n}\n```\nIn this case the end user might be able to create its own engine, without having to worry about the other parts of the car but the displacement. As engines are dependent on different parts which depend on their type I just wanted the end user to provide one or few parameters that might change dynamically (depending on the choice made). From what I understood this cannot be solved by the toProvider, because it will force me to resolve all the dependencies manually from within the closure. On the other hand I think that toDynamicValue might solve this specific issue more easily, because it allows me to bind that specific dependency to a closure that will capture the value given by the user without having to wrap my values in an IProvider<T> interface.\n. Hi @remojansen,\napologies but I am still trying to wrap my head around this, therefore maybe I wasn't very clear with my intent. This will work for binding a specific engine to a name that can later be used for retrieving that, and this is quite nice, but what if I want to build engines of the same type with different displacements?\n``` typescript\ninterface ICarFactory {\n    createEngine(displacement: number): IEngine;\n    createTires(code: string): ITires;\n    createBody(color: string): IBody;\n}\n// This will internally register and create diesel engines\nclass DieselCarFactory implements ICarFactory {\n    createEngine(displacement: number): IEngine { // How can I pass the displacement to the factory?\n        /.../\n    }\n}\n```\nFrom what I understood in order to do that as of now, I can unbind and rebind the displacement binding from within the createEngine method, and assigning it to the current displacement value. I don't think I can do this using contextual constraints, because the constraints for building the engine will always be the same, with the displacement being the only thing changing. From what is my understanding having a toDynamicValue in this scenario will help, because in that case I can simply close to a local variable that will contain the displacement at the time of creation.\n``` typescript\nclass DieselCarFactory implements ICarFactory {\n    private currentDisplacement: number;\nconstructor(private kernel: IKernel) {\n    kernel.bind<number>(\"displacement\").toDynamicValue(context => this.currentDisplacement);\n}\n\ncreateEngine(displacement: number): IEngine {\n    this.currentDisplacement = displacement; // good thing we don't have threads...\n    return this.kernel.getNamed<IEngine>(\"IEngine\", \"diesel\");\n}\n\n}\n```\nthanks again for your support. I can work around this by now, so no need to hurry with the toDynamicValue, even though it might be helpful on this and other cases IMHO.\n. I like this, it looks cleaner than the other solutions and doesn't force the user to make the parameters the factory is going to define injectable. The only minor drawback I can think of is the exposition of the parameter as a public property, which might not be desirable in all the use cases, but it looks like a fair tradeoff to me, given the flexibility it provides.\nThanks a lot!\n. Hi @remojansen,\nfrom what I can see they will going to implement variadic types in 2.1 hopefully (it was something I was interested into as well, along with support for nominal types). For the time being I would say that it will be most unlikely to go with partial applications with more than 2 or three parameters for these cases, so the long signature should not be a big deal.\nThaks a lot, really appreciated your efforts.\n. Hi @remojansen thanks for the reply. Looking forward to it!\n. This will not solve my issue, because this will work if I have knowledge of what was the base class. I am talking about modules in different projects, which should be unaware of the base class to be decorated, as it might change depending on which modules I have in my application.\nWith my former example consider this (injectable and inject decorators omitted for clarity):\nmodule1\ntypescript\nclass FileStream implements IStream { ... }\nmodule2\ntypescript\nclass EncryptedStream implements IStream {\n    constructor(baseStream: IStream) { ... }\n}\nmodule3\ntypescript\nclass CompressedStream implements IStream {\n   constructor(baseStream: IStream) { ... }\n}\nIn this case, each module will have to register its own IStream implementation, and my final application will just request an IStream. Now, depending on which modules I have registered I am expecting to either have: \n\na FileStream\nan EncryptedStream(FileStream)\na CompressedStream(FileStream) \nan EncryptedStream(CompressedStream(FileStream)) \n\ndepending on the modules my application is requiring.\nAssuming that every module has the responsibility of binding their own IStream a simple unbind will not work because every module will have to bind the base stream to a class he is unaware of.\nThe current workaround I can think of is to take the whole binding information, rename the identifier and bind a new IStream with the decorated class which has a dependency with the renamed identifier, which at this point can be whatever class has been registered or redefined by any module occurring before. \nThis at present will force me to use a private member of the container, which I would rather avoid as it might change in the future.\nHope this makes more sense to you.. Hi Remo,\nsorry for the delay in the answer. You are right, the case that we have which doesn't work is D, you got this right. Regarding the API I'm not really sure, as having something that specifies the decoration part would seem very odd to me.\nTechnically speaking I think that this could be resolved in the following way, given my current understanding of the internals of inversify.\n\nTake the original binding from the lookup table of the container.\nClone it with a generated identifier, and remove the original\nRegister the new component with the original identifier, and give a constraints that will explicitly inject the dependency for (2)\n\nThis way even if you add a new component at a later time it should still work, as the newly registered component will redefine the previous one.\nAs I was writing I can do this kind of thing provided I have access to the lookup table in the container, which at present is private. I can see that accessing to such table is currently encapsulated with the getBindingDictionary function in planner.ts, but this is not exported in the typings of the library, therefore I cannot experiment with it safely. Perhaps for such edge cases a first workaround would be to just have that function in the exported typings\nAs for the proposed API if it were to just solve the decorator part, I would think of something like:\ntypescript\ncontainer.bind<IStream>(\"IStream\").to(FileStream); // First registration\ncontainer.chain<IStream>(\"IStream\").with(EncryptedStream); // Subsequent registrations\ncontainer.chain<IStream>(\"IStream\").with(CompressedStream);\nThis might be suitable for decorators, but to be honest I don't like the fact that it will bind the library to a specific design pattern, perhaps having a way to extend the binding syntax by third parties or just to provide some mechanism to access the internals for providing custom extenders might be more flexible.\nFeel free to share your thoughts on this.. ",
    "otbe": "That sounds reasonable. :)\nThanks for clarification \ud83d\udc4d \n. Another thought on this. What I really want to do is:\n```\nexport class Settings extends Component {\n  @inject(MyService)\n  private myService: MyService;\nrender() {}\n}\n```\nIts more declarative and closer to other DI frameworks (like guice) :)\nI have hacked a decorator to do this, but with the disadvantage of injecting at accessing the property. :(\n. @remojansen \nWould love to see option B in inversify :)\nMy current implementation of @inject does exactly what you describe :) I could share it, but its a bit hacky :) \nThis includes your optimization about only one kernel.get<T>(\"T\"). This is necessary, because we have to provide the same reference for MyService for every hit of this.myService.  We also have to support multiple injections of the same service (for different keys). Something like:\n``` javascript\nexport class Settings extends Component {\n  @inject(MyService)\n  private myService: MyService;\n@inject(MyService)\n  private myService2: MyService;\nrender() {}\n}\n```\nmyService and myService2 should be different objects (if transient).\nBtw: in the same manner we could provide @provideTransientScope and @provideSingletonScope decorators for unifying @injectable() and kernel.bind<ISomeService>(\"ISomeService\").to(SomeService);. For example:\n``` javascript\n// for singletons\n@provideSingletonScope\nclass MyService {}\n// for transient instances\n@provideTransientScope\nclass MyService {}\n```\nOur code looks very elegant and organized with this three decorators (@inject, @provideSingletonScope/@provideTransientScope) :)\n. @remojansen \nYes you're right. @provideSingletonScope would create kernel.bind<any>(SomeService).to(SomeService).inSingletonScope(); (this was a copy&paste error :))\nFluent decorators would be fine for me. Im not sure if I would use it the following way @provide().inTransientScope().done() (its a bit long :)), but +1 for aliases.\nLike @donaldpipowitch said, @set seems a bit out of context. Basically its an injection and I prefer\nto @inject, but with aliasing its up to me \ud83d\udc4d \nJust for clarification:\nThe following should work as expected? Note the SomeService in @set. I don't want to pass string constants through my application :)\n``` javascript\nlet kernel = new Kernel();\nkernel.bind(SomeService).to(SomeService);\nlet set = makeSetDecorator(kernel);\nclass SomeWebComponent {\n    @set(SomeService)\n    private _service: ISomeService;\n    public doSomething() {\n        let count =  this._service.count;\n        this._service.increment();\n        return count;\n    }\n}\n``\n. The only thing you may have missed to mention in your examples: support for multiple@inject`s for the same service on different properties. Something like:\n``` javascript\nexport class Settings extends Component {\n  @inject(MyService)\n  private myService: MyService;\n@inject(MyService)\n  private myService2: MyService;\nrender() {}\n}\n```\nIs this necessary?\n. Use case\n``` javascript\nexport class MyServiceB {\n  @inject(MyServiceA)\n  myServiceA: MyServiceA\nname: string;\n}\nlet s = kernel.get(MyServiceB);\nconsole.log(Object.keys(s)); // [ 'name' ]\nconsole.log(s.propertyIsEnumerable('myServiceA'); // false\n``\n. Maybe we could add a hint to the docs !?\nFrom a users point of view (and non decorator expert) its a bit unexpected, because we declare this property like any other property within the class. So why it should not be enumerable? \n. After some time using@mock` Im not that happy with it :/ I want to share my mocks across several tests and if I do one time:\njavascript\n@mock(MyService)\nexport class MyServiceMock {\n  foo(): number {\n    return;\n  }\n}\nMyService is mocked for every test, because my kernel is shared too. That may be fine for services that use MyService, but if I test MyService itself I have to unbind the mock. So at the end I have to ensure that I get the correct version (mocked or not mocked) of MyService in every test. But a bigger problem is, that I have to kernel.get(MyService) in beforeEach for getting an instance of this mock, because I want to spy on it and modify the behavior of methods.\nIm switched to something like that:\njavascript\nexport function setupSingletonMock<T>(target: string | Symbol | INewable<any>, mock: { new(...args: any[]): T; }): T {\n  kernel.unbind(target);\n  kernel.bind<T>(target).to(mock).inSingletonScope();\n  return kernel.get<T>(target);\n}\nand use it like \n``` javascript\nlet myServiceMock;\nbeforeEach(() => {\n   myServiceMock = setupSingletonMock(MyService, MyServiceMock);\n});\nit('test', () =>\u00a0{\n  spyOn(myServiceMock, 'foo').andReturn(5);\n});\n```\nWhat do you think about it?\n. @endel I dont know if I get you wrong, but property injection is already in inversify :)\n@remojansen \nDont worry about long comments/posts. Sometimes I do it myself :)\n\nChild kernels (2.1)\n\nYour child kernel / hierarchical dependency injection proposal is exactly what I had in mind when asking this question on gitter :) Maybe my load function was a bit misleading, but thats exactly what I want :)\n. ",
    "kenjiru": "An integration with React would be really cool, something like the connect() wrapper from \"react-redux\". This would allow us to wrap the root component of our application and then inject all the needed classes in the child components.\n. ",
    "donaldpipowitch": "Looking forward to this! Thank you.\n. I don't know if @set is as clear as @inject. \"Set\" always sounds very \"final\" to me. I wouldn't guess I could change the passed service at runtime.\nI personally don't mind using @inject for properties and parameters, if they do basically the \"same\" things in two different contexts and if these contexts can't clash with each other.\n. This problem occurred, because Store1 was exported as undefined. This was a problem with an older version of typescript@next. The current version 2.1.0-dev.20160807 works.\n. ",
    "zkohl": "This appears to be a limitation of Node. So not a problem with Inversify :)\nhttps://github.com/Microsoft/TypeScript/issues/6740\nThanks for all your hard work!\n. ",
    "ryall": "Shame this is included separately. I completely missed it up until now because I never found this issue. Maybe a reference in the core docs would be helpful.. ",
    "goenning": "I'm starting to learn more about TypeScript and I think that InversifyJS is an awesome project to start on. I'd like to give this issue some love now that TS 2.0 is officially released.\nI've  started to play around and see what happens if we enable strictNullChecks on  InversifyJS and I found interesting how this flag shows many potential problems within the code.\nI'd like to see your thoughts about it.\nI understand that many of these issues should be handled accordly. For example the Context class should not allow a null kernel to be used as it assumes everywhere inside the code that the context will always have non-falsy kernel.\nAnother example is the target/parentContext/parentRequest properties of the Request class. All of them can be null by definition, but mostly everywhere the code does not expect it be. While we don't run in any issue during run-time, the TS 2.0 compiler is always complaining about it. Sure we can just throw out some not-nul operators (request.target!.name!), but I don't think it's the best way of dealing with nullables. I'm a big fan of the Null Object Pattern btw, maybe there is some room for it here.\nAnyway, I'll just fork it and try to play around with this and see where I can get. Just wanted to know if this is something you're already working on, or maybe you got some outcome that you could share from your previous analysis.\nBy the way, what you think about moving from null to undefined? \nhttps://github.com/Microsoft/TypeScript/wiki/Coding-guidelines#null-and-undefined\nhttps://medium.com/@basarat/null-vs-undefined-in-typescript-land-dc0c7a5f240a#.s3e4ea8z1\n. Oh, that's good to know. I prefer to wait and avoid a big merge conflict. I'll keep an eye on it :)\n. @dkellenb My guess would be on changing app.listen(3000) to httpServer.listen(3000) as you have wrapped the Express application in a HttpServer.\n. Your connection url should be ws://localhost:3000/socket.io/?EIO=3&transport=websocket\n. ",
    "SET001": "maybe I'm doing something wrong but methods/properties of classes decorated with @injectable also not enumerable\n. The problem was that to enumerate object methods in ES6 one should use Object.getOwnPropertyNames on that object prototype.\nNot Inversify related.\n. ",
    "davidstellini": "It's an interface, had to hand-write the code. Sorry!\n. kernel.bind<string>(\"string\").toConstantValue(\"your_username\").whenTargetNamed(\"username\");\nkernel.bind<string>(\"string\").toConstantValue(\"your_password\").whenTargetNamed(\"password\");\nThis is the critical part I was looking for. Thanks!\n. Would it not be possible to force inversify to inject an instance of BasicAuthDecorator which I created instead?\n. @remojansen Thanks! that clears up a lot :)\nCan I choose to bind a particular parser to each different repository?\nEx: \nbind SomeParser1 (implements Parser) -> ApiDogDataRepository\nbind SomeParser2 (implements Parser) -> ApiHumanDataRepository\nThis would be like your Warrior example, but extending it to:\n``` typescript\ninterface IWeapon {}\nabstract class Soldier {\nweapon : IWeapon;\n    constructor(\n      @inject('Weapon') weapon : IWeapon;\n    ) {\n      super();\n      this.weapon = weapon;\n    }\n}\nclass Archer extends Soldier {}\nclass Knight extends Soldier {}\n@injectable()\nclass Sword implements IWeapon{}\n@injectable()\nclass Bow implements IWeapon{}\n@injectable()\nclass DefaultWeapon implements IWeapon{}\nkernel.bind(\"IWeapon\").to(DefaultWeapon);\n//And then,\nkernel.bind /Knight.weapon / to Sword\nkernel.bind /Archer.weapon / to Bow\n```\nI want to bind it in a way that getting an instance of knight will create an instance of Sword, however knight should have no knowledge on how to create the Sword instance (thus the use of inversify and not type instantiation via constructor). I might choose to bind 'Mace' instead so that every time I create an instance of a knight it would have a mace Weapon.\nMy particular real world scenario is that I can't always use the same parser across multiple data repositories, but at the same time, most of the time it IS the same parser.\nSo I can have a JSON parser used across 95% of the app, but 5% would use a HATEOAS parser. \n. Found another way, this solves this issue for me:\nIt compiles this time! :P Thanks for the beautiful library, I enjoy using it!\n``` typescript\nimport {injectable, inject, Kernel, IKernel, IRequest} from \"inversify\";\nimport \"reflect-metadata\";\ninterface Parser{\n  parse() : string;\n}\nclass Dog {\n  name : string;\n}\nclass Human{\n  surname : string;\n}\n@injectable()\nclass HateosParser implements Parser {\n  parse() : string {\n    return \"Hello HATEOAS!\";\n  }\n}\n@injectable()\nclass ApiParser implements Parser {\n  parse() : string {\n    return \"Hello JSON!\";\n  }\n}\nabstract class DataRepository {\n  parser : Parser;\n}\n@injectable()\nclass DogDataRepository extends DataRepository {\nconstructor(\n    @inject('Parser') parser : Parser\n  ) {\n    super();\n    this.parser = parser;\n  }\n}\n@injectable()\nclass HumanDataRepository extends DataRepository {\n  constructor(\n    @inject('Parser')  parser : Parser\n  ) {\n    super();\n    this.parser = parser;\n  }\n}\nlet kernel : IKernel = new Kernel();\nkernel.bind(\"DogDataRepository\").to(DogDataRepository);\nkernel.bind(\"HumanDataRepository\").to(HumanDataRepository);\nkernel.bind>(\"Parser\").to(HateosParser).when((request: IRequest) => {\n    return request.parentRequest.serviceIdentifier === 'DogDataRepository';\n});\nkernel.bind>(\"Parser\").to(ApiParser).when((request: IRequest) => {\n    return request.parentRequest.serviceIdentifier !== 'DogDataRepository';\n});\nvar dogDataRepository = kernel.get(\"DogDataRepository\");\nvar humanDataRepository = kernel.get(\"HumanDataRepository\");\nconsole.log(dogDataRepository.parser.parse());\nconsole.log(humanDataRepository.parser.parse());\n```\n. Go ahead! Thank you!\n. Meanwhile, for anyone looking to install inversify typings, they can do:\n    npm install inversify --save\n    npm install inversify-dts  --save-dev\n    typings install npm:inversify-dts/inversify/inversify.d.ts --save --global\nThis is always better than manually adding a ///<reference path=...\nI've added a readme.md change here: https://github.com/inversify/InversifyJS/pull/253\n. ",
    "alfonsorios96": "@remojansen Hi, I'm in trouble using your tip A. Option A: Using a base class\nBecause, it's not working, I must to have a @injectable label in my father class and I don't know why :(\n```TS\nexport class Service {\n  public log(error: Error) {\n    winstonLog.error(error.stack);\n  }\n}\n@injectable()\nexport class UserService extends Service {\nconstructor(\n      @inject(TYPES.UserRepository) private userRepository: UserRepository,\n      @inject(TYPES.UserRoleService) private userRoleService: UserRoleService,\n      @inject(TYPES.WarehouseAccountUserService) private warehouseAccountUserService: WarehouseAccountUserService,\n      @inject(TYPES.TransactionWrapper) private transactionWrapper: TransactionWrapper,\n      @inject(TYPES.AuthService) private authService: AuthService\n) {\n    super();\n  }\n```\nerror: uncaughtException: Missing required @injectable annotation in: Service. Hi, I also have the same problem. \nThe index.ts (where do the bind)\nI have this line kernel.bind<interfaces.Controller>(TYPE.Controller).to(RFMonitorController).inSingletonScope().whenTargetNamed(TAGS.RFMonitorController);\nThe problem here is I have other similar binds and they are working good.. ",
    "brycesteinhoff": "I'm curious about this also. Is it possible to bind an already-instantiated instance into the container for some key? Is this what toConstantValue is for?. ",
    "alexey-pelykh": "This is still the case, unless skipBaseClassChecks is set to true. Is there a way to tag specific class to be ignored from checks?. ",
    "gjsduarte": "I suggest two possibilites here:\n- Extend the binding to syntax to optionally automatically decorate the class:\n  if (!Reflect.hasOwnMetadata(METADATA_KEY.PARAM_TYPES, constructor)) {\n          decorate(injectable(), constructor);\n   }\n- Change the planner to only check for the @injectable attribute on sub-dependencies:\n  Perhaps by adding a flag to the _getDependencies that is set by the _createChildRequest method.\n. ",
    "JoshuaKGoldberg": "@remojansen is this issue complete? Can you provide details on what else needs to be done?. npm ERR! path C:\\projects\\inversifyjs\\node_modules\\fsevents\\node_modules\nnpm ERR! code EPERM\nnpm ERR! errno -4048\nnpm ERR! syscall scandir\nnpm ERR! Error: EPERM: operation not permitted, scandir 'C:\\projects\\inversifyjs\\node_modules\\fsevents\\node_modules'\nnpm ERR!     at Error (native)\nnpm ERR!  { Error: EPERM: operation not permitted, scandir 'C:\\projects\\inversifyjs\\node_modules\\fsevents\\node_modules'\nnpm ERR!     at Error (native)\nnpm ERR!   stack: 'Error: EPERM: operation not permitted, scandir \\'C:\\\\projects\\\\inversifyjs\\\\node_modules\\\\fsevents\\\\node_modules\\'\\n    at Error (native)',\nnpm ERR!   errno: -4048,\nnpm ERR!   code: 'EPERM',\nnpm ERR!   syscall: 'scandir',\nnpm ERR!   path: 'C:\\\\projects\\\\inversifyjs\\\\node_modules\\\\fsevents\\\\node_modules' }\nnpm ERR! \nnpm ERR! Please try running this command again as root/Administrator.\nFailure is definitely not related to this change. \ud83d\ude04 . Thanks so much @sleepysort! . Yes :). You know, this actually is a breaking change. You would no longer be able to use sring literals as many likely do. I'll hold off the change.\nhttps://github.com/Microsoft/TypeScript/issues/17690\nhttps://github.com/Microsoft/TypeScript/issues/3192#issuecomment-261720275\nSteps to make the change locally are:\n Delete literal_types.ts\n Perform the OP's suggested replacement in interfaces.ts\n* Replace usages of the enum types exported from that file with the newly exported enums in interfaces.ts. https://github.com/Microsoft/TypeScript/issues/17690#issuecomment-350889463\nWill just use a const object.. Huh, got a clean run locally. Might have done something silly. Will investigate soon.. Sorry @remojansen can you re-send the PR? Half the builds are passing and I can't figure out why the others aren't \ud83d\ude26 . The issue I'm trying to solve is that there's no guarantee at development time that we correctly hook up our injections. Giving a more complete example:\n```typescript\nimport { Container, inject, injectable } from \"inversify\";\n@injectable()\nclass Dependency { }\n@injectable()\nclass Sample {\n    @inject(Dependency)\n    dependency: number; // this is clearly wrong\n}\nconst container = new Container();\ncontainer.bind(Dependency).toSelf();\ncontainer.bind(Sample).toSelf();\nconst sample = container.get(Sample);\n```. Oh hey just noticed I had fixed this and never resolved this issue. Sorry about that! \ud83d\ude04 \n@paulspiteri FYI - recommend filing a new issue if Container.Merge is still not doing what you need?. ",
    "amir-arad": "i'm checking out InversifyJS, and would have loved it if I had some dev-tools lib to plug into my application in dev setup, so that i can at least enjoy it in development.\ncurrently it seems that the devtools project has to catch up with the core lib. pitty.. hi,\nthe link above is broken. where's the discussion live today?\n10x. thanks @TheAifam5 . \nI've tried that and i found out that with providers, the consumer is injected with a function that returns a promise to an entity (()=>Promise<T>), instead of simply an entity (T). \nWhat I mean by async factory is to register something like (context)=>Promise<T> and have the consumer be injected with T.\n. ",
    "polesskiy-dev": "Any news or thoughts about implementation? . ",
    "xenoterracide": "Some context. I'm not 100% sure that I'm quite yet qualified. Currently I'm looking at replacing AngularJS as my framework because I find it has become overly prescriptive and I'd like to use Material Design, but moving to Angular 2 means that its Material Design impl won't work, and it doesn't seem polished to use Polymer (there's some toe stepping with binding instead of being able to inject into components). One thing needed to compose a great framework is a session scope. In Spring we actually implemented a TransactionScope and then got them to add it to Spring Tx.\nI haven't actually worked with TS/InversifyJS yet, and glancing at the architecture docs, so pseudo code. From what I can tell custom scopes need a conversation id. My suggestions are based largely on Springs implementation, which was designed a long time ago, so maybe a new impl could be better designed http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-scopes-custom and the impl of transaction scope\n```\ninterface Scope {\n   void onDestroy( Function callback );\n   void onCreate( Function callback);\n   String currentConversationId();\n   Object get( String name );\n   void remove( name )\n}\nkernel.registerScope( \"myScope\", new MyScope() );\nkernel.getScope(MyScope).onDestroy( function (obj) { log(\"destroying\" + obj )} )\n```\nhopefully this is helpful\n```\n```\n. ",
    "ktersius": "I'm not sure if this belongs on this issue or not.\nI find that I need to be able to resolve session information let's say ISession. This session is only valid for a specific call and contains things like user information for current request.\nIt would be great if one could create a child kernel/scope where I could bind my ISession to and then resolve my aggregate root with. Any subsequent resolves, via a factory for instance, that might get triggered from within this aggregate root, lets say via a promise that get's resolved later on will then use this child kernel and resolve the correct ISession.\nNot sure if this can be done already?\n. @antoniusostermann \nI've since solved my original problem\njavascript\nprivate getChildContainer()\n {\nlet childKernel = new inversify.Container();; //Create a child kernel so that any resolved instances of IContext resolve the correct context.\nchildKernel.parent = this.container;\nchildKernel.bind<IContext>(\"IContext\").toConstantValue(this.context); //For any class that needs access to context information.\nreturn childKernel;\n}\nYou should be able to easily pass the current request/context and then from there just make sure to use the child kernel for all resolving. This way you will get the correct context/request when resolving further down the line.. @antoniusostermann Your entry point should just use the childContainer after you create it.  There will always be some root somewhere where you work with the container it-self to get the whole process started.\n```javascript\n/ My composition root /\nserver.onRequest(request => {\n  // request is now the currently handled request, so set it as context object\n   let childContainer = getChildContainer(container, request);\n// get params of current request\n  let params = childContainer.get(\"parameterService\").getParams(); \n});\n```. ",
    "antoniusostermann": "Just found this. Because I think this fits to my gitter comment, posting it here:\n\nHello, does anyone know of a best practice to inject \"context\" or \"scope\" into a class? For example, given I have a server handling requests, many services need a specific request object to work properly. One, for example, grabs the parameters out of a given request. How should I offer the currentRequest dependency? don't really like to implement a setRequest() method on each of these classes... Is it, for example, possible to register an asynchronous \"scope\" to the container, and inject the currentRequest as the default request into my classes?  So sth. like this:\n```typescript\n/ My composition root /\nserver.onRequest(request => {\n  // request is now the currently handled request, so set it as context object\n  container.bindContext(\"currentRequest\").to(request);\n// get params of current request\n  let params = container.get(\"parameterService\").getParams(); \n});\n// Purpose of this class is to get parameters out of specific request, so it strongly depends on a given request instance\n@injectable()\nclass ParameterService {\n  constructor(@injectContext(\"currentRequest\") request: Request) {\n    this.request = request;\n  }\ngetParams():  Parameter[]; // Fetches Parameter based on given request\n```\nThat way, I do not need to implement setters in each of my classes, which have to be called to enable the class to work properly. I consider this an anti pattern and strongly believe strict dependencies belong into the constructor. \nIf I'd use a factory instead to create ParameterService objects, all other classes which depend on ParameterService could not inject this service without being a factory on their own. This would end in a factory mess, where all factories have unnecessary dependencies (they need a specific request instance only to pass it to ParameterService\nBut using currentRequest only as the default injection, I could still test my class easily.\nThe problem with this is that since container is a global object and the currentRequest is a callback parameter handled asynchronously,  setting this context won't be easy.\nDoes anyone have an idea how to achieve this with inversify, or comes up with a best practive to solve such problems? Thanks!! :). @ktersius Thanks so much for your answer. But how to \"make sure to use the child kernel for all resolving\" if you are just using @inject in your classes?. Hey @guscastro , with inversify-components (https://github.com/webcomputing/inversify-components) you are able to create your own scoped dependencies, but it's implemented the way @ktersius describes it here in https://github.com/inversify/InversifyJS/issues/218#issuecomment-274803147. It might be helpful for you, although it also changes the way you declare dependencies.. ",
    "guscastro": "Hi @remojansen ,\nDo you have inSessionScope in your sight by any chance? This is a feature our team would be particularly interested in.\nThanks,\nGus. Thanks, @antoniusostermann . I ended up using the workaround described as well. Unfortunately, we have a very large application built on top of inversify and changing declarations is likely more work than implementing the feature on inversify.. Hi,\nWe're quite keen on this feature. Is this something you're working on/accepting PRs for?\nThanks!. @AltekkeE @remojansen and other maintainers - I'm working on a PR to allow receiving the context into the binding methods mentioned. It looks simple enough.\nI have two questions, though:\n1) The change to onActivation is a breaking change in the way it's proposed. Are you comfortable proceeding with the breaking change? And would the breaking change affect how soon we are able to have this feature released?\n2) Given interfaces.Request already has context, do we still require context to be passed on to onActivation (the alternative is e.g.: onActivation((currentRequest, loggerInstance))? The same applies to toDynamicValue, except that that API wouldn't have a breaking change otherwise.\nThanks. I think @krzkaczor meant the same case as I also need, which is referencing the immediately injecting class. Use case: a Logger tagged with the name of the class it's injected into.\nI was able to get the parent name with the following, which is a bit cumbersome...\ncontext.currentRequest.parentRequest &&\n          context.currentRequest.parentRequest.bindings.length &&\n          context.currentRequest.parentRequest.bindings[0].implementationType &&\n          (context.currentRequest.parentRequest.bindings[0].implementationType as any).name. ",
    "simon-hardy": "@remojansen thanks mate, there are still a couple of toValue calls in the github docs as well\nWhat threw me is that intellisense is still showing toValue.\n. I originally was using the typings DefinitelyTyped ones, when I realised those were alpha I uninstalled them. I then looked for ones in the npm package but didn't find any. Honestly not sure where my IDE is picking them up from now (tried both atom.io and VS Code).\n. OK, that's solved my problem, but raised another...\nDuring build of my Typescript, I get the following issue:\n\nnode_modules/inversify-dts/typings/globals/bluebird/index.d.ts(667,9): error TS2300: Duplicate identifier 'concurrency'.\nnode_modules/inversify-dts/typings/globals/bluebird/index.d.ts(670,9): error TS2300: Duplicate identifier 'spread'.\nnode_modules/inversify-dts/typings/globals/bluebird/index.d.ts(673,9): error TS2300: Duplicate identifier 'suffix'.\nnode_modules/inversify-dts/typings/globals/bluebird/index.d.ts(674,9): error TS2300: Duplicate identifier 'filter'.\nnode_modules/inversify-dts/typings/globals/bluebird/index.d.ts(676,9): error TS2300: Duplicate identifier 'promisifier'.\nnode_modules/inversify-dts/typings/globals/bluebird/index.d.ts(683,9): error TS2300: Duplicate identifier 'promise'.\nnode_modules/inversify-dts/typings/globals/bluebird/index.d.ts(707,9): error TS2300: Duplicate identifier 'callback'.\nnode_modules/inversify-dts/typings/globals/bluebird/index.d.ts(743,5): error TS2300: Duplicate identifier 'export='.\ntypings/globals/bluebird/index.d.ts(667,9): error TS2300: Duplicate identifier 'concurrency'.\ntypings/globals/bluebird/index.d.ts(670,9): error TS2300: Duplicate identifier 'spread'.\ntypings/globals/bluebird/index.d.ts(673,9): error TS2300: Duplicate identifier 'suffix'.\ntypings/globals/bluebird/index.d.ts(674,9): error TS2300: Duplicate identifier 'filter'.\ntypings/globals/bluebird/index.d.ts(676,9): error TS2300: Duplicate identifier 'promisifier'.\ntypings/globals/bluebird/index.d.ts(683,9): error TS2300: Duplicate identifier 'promise'.\ntypings/globals/bluebird/index.d.ts(707,9): error TS2300: Duplicate identifier 'callback'.\ntypings/globals/bluebird/index.d.ts(743,5): error TS2300: Duplicate identifier 'export='.\n. Yep all looks good from my end. Thanks for the quick turnaround.\n\nThe only suggestion I might have is to version the inversify-dts package the same as the main inversify package as currently it is 1.0.1 and correlates to 2.0.0-beta.6.\n. Ah brilliant, thanks. \n. ",
    "FGRibreau": "@remojansen yes :)\n. ",
    "AriaFallah": "Alright thanks! I'll take a look.\n. @remojansen both blog posts were exactly what I wanted. Really well written. You should put them at the top of the README or something.\n. ",
    "m-abs": "@codyjs It's a great idea, but a few thoughts.\nWhat about different types of responses? We return both HTML, json, images, mp3, zip and streams\nError handling? There should be a catch, but what about the statusCode and message?\nOf cause with a Promise, the controller method could handle that, if only it sends the header before resolving.\n. Looking at https://github.com/inversify/inversify-express-utils/blob/master/src/route-container.ts#L44-49\nI don't think that the next-function and be used. We don't need it in our project, but I still think it should work :+1: \n. I think you're right, it's much easier just to call the res.sendFile() within our own function.\nThank you for the next(err) suggestion, I'll try that.\n\nI don't understand this point. Why can't the next function be used?\n\nSorry, I was confused. I had some wrong assumptions about how the next-function works. \n. I tried your patch and hit a minor problem, see here:\nhttps://github.com/m-abs/testing-inversify-express-utils/blob/next-fn/index.ts#L14\nRequest to http://localhost:3000/ works as expected, index(...) calls next() and index2() returns 'indexi'\nhttps://github.com/m-abs/testing-inversify-express-utils/blob/next-fn/index.ts#L25-L43\nRequest to http://localhost:3000/async respond with an empty page and the server throws:\nError: Can't set headers after they are sent.\n    at ServerResponse.OutgoingMessage.setHeader (_http_outgoing.js:346:11)\n    at ServerResponse.header (/home/mabs/project/inversify-express-utils/node_modules/express/lib/response.js:718:10)\n    at ServerResponse.json (/home/mabs/project/inversify-express-utils/node_modules/express/lib/response.js:246:10)\n    at Timeout._onTimeout (index.ts:60:25)\n    at tryOnTimeout (timers.js:224:11)\n    at Timer.listOnTimeout (timers.js:198:5)\n. Inspired by @codyjs fix, I've tried to solve the problem I had with next()-calls. \n``` typescript\n        let handler: express.RequestHandler = (req: express.Request, res: express.Response, next: any) => {\n            let nextCalled = false;\n            let postHandler = (value: any) => {\n                if (!nextCalled && !res.headersSent) {\n                    res.send(value);\n                }\n            };\n        let result = this.kernel.get(target.constructor.name)[targetMethod](req, res, (...nextArgs: any[]) => {\n          nextCalled = true;\n          next(...nextArgs);\n        });\n\n        // try to resolve promise\n        if (result && result instanceof Promise) {\n            result.then(postHandler);\n        } else {\n            postHandler(result);\n        }\n    };\n\n```\nhttps://github.com/m-abs/inversify-express-utils/blob/handle-promise-and-next/src/route-container.ts#L44-63\nThe problem:\n- The function notAsync() calls next() (https://github.com/m-abs/testing-inversify-express-utils/blob/next-fn/index.ts#L26)\n- So the function async() is called and returns a promise. (https://github.com/m-abs/testing-inversify-express-utils/blob/next-fn/index.ts#L31)\n- notAsync() then returns the result from next(), which is undefined, so the RequestHandler returns an empty page to the client.\n- So when the promise async() is resolved, the headers was already sent.\nThe solution:\n- Wrap the next-function parameter, to register if it's called.\n- If next() was called, don't send the data to the client.\n. @codyjs \nI've just tested your fix and it solved the issue I had, thanks :+1: \n. ",
    "satya-jugran": "I have raised a similar issue. If someone can look into this - #895 . ",
    "jbeckton": "Coming from C# I have a habit of using IFoo for interfaces. Regardless of what the guys at Typescript recommend; an interface in Typescript has a different purpose than a class. Typescript interfaces are for compile time anyways, they do not exist in the compiled javascript. So, having a naming convention that allows developers to visually identify an interface from a class makes a lot of sense to me. And I think as far as the compiler goes it could care less if you use an interface vs a class to define a type reference, you could subject yourself to alot of run time errors if you use an interface in place of a class because of a simple mixup. To take the argument a bit further, most anyone can argue that conventions are not needed, the software can still compile and run without them. But the benefits of conventions contribute to quality and productivity. In C# and Java the compiler does not care if you prefix your interfaces with an I, but it's a widely used convention thats been around for years and has more to do with identifying the purpose of the file/code than how it's used in compilation and run time. In Typescript an interface defines a contract, like for a json response from the server or an Api from a third party library and it has no implementation. Sounds alot like interfaces in other platforms so why not prefix it with an I? \n. ",
    "mocanu-razvan": "One idea that I came across supporting the view that I prefixes should not be used is that using an I prefix for interfaces avoids the need to properly think about the identifiers used for the interface and implementation classes.\nFor example, one should not define an ICar interface and an associated Car implements ICar implementation class. Car is the generic identifier here and it should be the one used for the interface. You would want specific, concrete identifiers for your implementation, concrete classes, e.g. SportsCar implements Car, SUVCar implements Car etc. Some other examples: interface PaymentProcessor and concrete class CreditCardPaymentProcessor instead of IPaymentProcessor and PaymentProcessor.\nAnother view is that prefixing interfaces with I seems to be very similar to hungarian notation in the old days, e.g. szMessage, iCount, pData etc. We should probably be prefixing classes with C if we prefix interfaces with I. In general, I think this solution of using prefixes or suffixes in names to identify their type became obsolete with the advance of static analysis tools that made it trivial to understand what is the type of an identifier.\n. ",
    "atrauzzi": "\ud83d\udc4d - Totally support not using I prefixes.  Even in C#, I think it's another one of those things that  people do \"just cuz\".  Like newline braces \ud83d\ude03 . @remojansen - Right, if you look at the code I linked, that's the exact project I'm working with.  Here it is again, just in case:\nhttps://github.com/atrauzzi/anecdote-engine/blob/master/src/Engine/ConfigurationReader.ts#L27-L46\nI'm not sure I can shrink it given that I might suddenly stop encountering the bug if I make it too contrived.  But I think my project is clean enough that you can check it out and run with it easily.\n. So it looks like I did in fact have some bad imports going on.  Apologies for the runaround :). Yup, that worked!\nhttps://github.com/atrauzzi/protoculture/blob/master/src/Suite/ProtocultureServiceProvider.ts#L10\nI definitely agree, some mention of \"hey, it's actually your abstract class that I don't know about\" would be useful in this case.. My interest in this is to provide injection for an abstract class setter/property.  This allows subclasses to have full control over the constructor.\nI've manually set it up so that a set happens prior to lifecycle, but I thought it would be nice to wire this using DI as well.. I think that would impose on implementers a convention in their constructors.  Which might risk breaking the fun/easy factor. This is to ensure applications have access to their \"context\".\nThe context needs to be provided at some point to the app shortly after being instantiated. The context is singleton-esque.  This might be a case where I'm already doing the right thing and the container need not be involved.  I was just thinking that if I'm able to get every dependency an app would need bound, inversify could handle everything for me.. Here is the specific property I'm thinking about: https://github.com/atrauzzi/protoculture/blob/master/src/App/Base.ts#L12. Yeah, the weapon property/setter there looks about right. And of course abstract base, without using annotations.. Yeah, definitely appreciate the differences in the JS space because it doesn't offer an autoloader pass the same way as PHP (if a class isn't found, you can plug a loader in as a last ditch to discover it before failing).\nThat all said, my imagination may be getting the better of me here... I still think these things might be possible.\nIf we think through how people will do their bindings, would it not be safe to assume that every class they'll want will have to have been imported at least once because they'll be pulling in that reference (to the constructor/static/class-type); prior to inversify's first attempt to work with it?  Not sure if that's the most effective way to express what I'm thinking, but the order of everything actually works out.\nThe TS interface thing sounds like it can't come soon enough but with an object, you could generate some kind of fingerprint from the signature of the interface-object-meta-thingy.  It's all duck-typed after all ;)\nThe name and path conventions I totally agree on.  Inversify should be zero-convention when it comes to physical project structure.  I'll take care of that with protoculture ;)\nThe convention was more about having an option of automatic self-wiring provided an implementer stuck to using reflectable types, which despite the interface issue may still be possible (the fingerprinting).  And that's all in the logical space in my mind.\nI'd have to spend some while looking at the code for inversify to understand where these opportunities are to pre-populate the metadata and what the right things to do are.  But I'm slightly curious because even the little bit of metadata being generated now may be enough.. Yeah, overall I agree.  From protoculture's side, I'll just continue \"passing along\" the code debt for managing those pointers.  Then once the winner of all this is determined, most of these concerns will turn into noops.\nJust something we all have to be aware of in TypeScript land until the dust settles \ud83d\ude04 \nFeel free to close this or leave it as a bookmark?. :)\nAwesome! Next time I make this mistake, I bet I'll be way less confused.  Hehe.. Would defaultValue be optional and itself default to null if not provided?. My vote is for A. I've used similar APIs before and enjoyed it!. If I'm remembering right at the moment, .net's tryGet APIs are a little different semantically, taking an out parameter and returning a boolean.  It likely goes without saying, but I'll just put here: Please don't do that! \ud83d\ude09 \nBut beyond that, nothing really obligates TS to do the same except that it happens to attract the attention of a lot of C# developers.\nI feel like getOptional is more misleading as it could be conflated with the concept of \"optionals\".  Seems future-prone, so I would avoid it for your reason, and at least one other.\nAlternative names? getOrThrow, getOrFail.\nIs defaultValue optional or defaulted?  Should we be returning undefined as opposed to null when a get is attempted and no default is provided?. Love the empty array. Totally agree. If we need to know when nothing is bound, the manual checks are still there and are more expressive.\nAll of this looks great.. Still hoping for this to become a thing some day! \u2764\ufe0f . Another ping on this one, running into it today.  I have so many scenarios where it's totally fine to not resolve anything.. ",
    "Offirmo": ":+1: can't wait for the 2.0.0 release. I'll write a blog post.\n. @remojansen thanks !\nThe idea would be to use a provider for lazy-loading languages on-demand. I'm definitely interested in getAllTagged and getAllNamed !\nFor now, I'm including the lang in the Service Id instead kernel.bind<Intl>(\"Intl.fr\") and using getAll\n. @remojansen opened a new issue for the feature request https://github.com/inversify/InversifyJS/issues/348\n. @remojansen you are amazing\n. @lholznagel I tested it for real. Using [] cause a typescript failure claiming a return type of Weapon[][]. Not using [] works as expected.\nIt also makes sense. The [] is redundant and adds nothing.\n. OMG. Testing it. Are typings up to date, too ?\n. index.ts (70,37): Property 'getAllTagged' does not exist on type 'Kernel'. (2339)\n. implemented by https://github.com/inversify/InversifyJS/pull/349\n. TSError: \u2a2f Unable to compile TypeScript\nindex.ts (9,36): Cannot find module 'inversify'. (2307)\nI've broken my setup and can't even find why... :cry: \n. Working. For some unknown reason, latest typescript@next went wild and I had to give it previously unneeded options: files: [ (reference paths) ]\nreference path in code are not working anymore. :unamused: \n. Note: I'm not sure of the \"module\" terminology. I made it up, but a more experienced programmer may use a more fitting name.\n. This is perfect ! You are working so fast !\n. Btw on your website, your INFRAESTRUCTURE IS 100% CLOUD http://www.wolksoftware.com/page/services\n. A solution could be to create a new type of binding as I proposed in #351. The \"dynamic value\" semantic has its own meaning.\n. Great ! So the caching would be configurable, even better.\nBut I'd like you to elaborate about this \"singleton scope\". I guess it means that for a given kernel state, the same resource identifier will return the same resource (singleton).\nDo you confirm ? Can you elaborate on the caching mechanism ? Is there a documentation entry for this feature ?\nAs usual, I'm impressed at your reactivity !\n. Tested it just now. Works perfectly :+1: \n. ",
    "CobeLapierre": "The issue is resolved. thanks for both resolving the issue and writing this amazing ioc.\n. Sorry, it is indeed the problem with importing the metadata. I hadn't noticed the #262 issue.\nThe ticket can be closed. Thanks\n. ",
    "voxmatt": "I know this is a closed issue, but @remojansen and @tenowg thank you for working through this in public \u2014 just saved me from pulling out the last of my hair!\n. ",
    "jhuntoo": "I think we could follow asp.net core on this.\nIn summary we could implement a single @ Authorize decorator that handles, Basic, RBAC, Policy and Claims Based via cookie or token.\nAlso the  @Anonymous looks handy so that u can makes controllers secure by default, and \"opt-in\" to unsecure routes.\nBeyond that, users could create their own Authorization middleware, something similar to this\n``` typescript\nexport class MyAuth implements AuthorizationMiddleware {\n  handle(context: AuthorizationContext): AuthorizationResult {\n    return (context.identity === 'GOD')\n      ? allow()\n      : deny();\n  }\n}\n// * Supporting Types\nexport interface AuthorizationContext {\n   identity: string;\n   request: any;\n}\nexport interface AuthorizationMiddleware {\n  handle(context: AuthorizationContext);\n}\nexport interface AuthorizationResult {}\nexport function deny(options?: any): AuthorizationResult {return {}; }\nexport function allow(options?: any): AuthorizationResult {return {}; }\n```\n. Possible topics for discussion.\nScope of framework;\n- Routing\n- Authorisation\n- Authentication\n- Dependency Injection\n- Custom Middleware, (method, controller & global)\n- ORM ?? \nPluggability\n- Just express or extendable to other frameworks ?\nUse existing frameworks  vs roll our own\n- Validation - https://github.com/epoberezkin/ajv perhaps\n- Sequelize is well established, there are others too\n. I'd suggest we move away from express (or any other framework) handler function signatures and use our own. This means we could do cool things like model binding.\n```\nindex(@body() body) {\n    return ok('Hello World')\n}\nindex(@queryString('filter') filter) {\n    return notFound({ object: {} })\n}\nindex(@param('userId')) {\n    return ok();\n}\n```\n. I would say that we should still provide direct access to request and response objects, because sometimes syntactic sugar isn't enough to cover all cases.\nI would argue though that we have own request & response objects, that via adapters, get connected to the host http framework like express/koa/hapi etc.\nSo all code within a controller method is written in the typescript-y style, and we can  keep a consistent approach to interacting with the request/response pipeline\nIn theory users, could write part of their app in Inversify, or natively in their chosen http host framwork.\n. Yeah I think so... also Inversify was a name born out of DI right? so given that that this will be a http application framework, I'd suggest a departure from that name.\nTrying to use type in  it... (though maybe not a good idea as we don't want to exclude ES6/7 folks right @remojansen )\ntyperoutes\ntroutes\ntypeapi\nMaybe something less descriptive and cooler sounding as every other JS framework github \ud83d\ude04\n. @remojansen  Agreed.\nI like the way angular, ngrx does it...\nnpm install @framework/core  @framework/express @framework/authorization @framework/validation\n. @antoniolopesgomes @tenowg @pleerock I\"m cc'ing you in on this discussion as authors of similar projects so that we can discuss, overlaps, objectives, and perhaps uniting together to build \"the\" kick-arse typescript web server framework.\nWe have a number of folks here that would like to bring to together existing pieces like DI (Inversify), decorator based routing, Authorization, Authentication, Validation into discreet modules that can be leveraged on any underlying http framework such as express/koa/hapi via use of a pluggable engines.\nYou are already building (or have built) some of this - would you be interested joining forces ??\n. ",
    "centigrade-thomas-becker": "What is the status of this feature? I found a similiar issue #487 that is not resolved either.. ",
    "viktor-flower": "\nI don't think we can provide authorize as a framework element but you can implement your own, here is an example https://github.com/stelltec/public-tech-demos/blob/master/nodejs-madrid-meetup/demo3/src/ui/rest_api/controllers/secure_controller.ts#L8\n\nIs it still the best solution to create a handler processing? I would like  a decorator approach like @IsAuthenticated. ",
    "sergeyzenchenko": "Merged.\n. ",
    "lukas-zech-software": "PR for bindings\n. Please note the the two checkpoints\n\n\n[ ] My change requires a change to the documentation.\n[ ] I have updated the documentation accordingly.\n\n\nhave been left blank intentionally, as these methods were already in the documentation, I just added the implementation \n. Thanks for the hint.\nI read most of the documentation but skipped the JS example as I use TypeScript.\nMaybe the decorate function could also be mentioned in another part of the documentation.\nThis solution resolves my issue.\nBut I have a follow up question which is more about how to solve the problem with third party dependency in the most elegant way.\nAssuming my class from above needs to call the super constructor of the third party class with a parameter which is hard coded. My class itself does not need any parameter, therefore I have different counts of parameters and trigger the The number of constructor arguments in a derived class must be >= than the number of constructor arguments of its base class. error.\nI cannot use any of the work arounds mention in the inheritance article, as all of these need to modify the base class. In my case its a NodeJS Stream wich must get the config object in the constructor.\nMy current solution to this problem is, to inject the config for the base class into my own class and then pass it to the base class, which means that I need to register the config in my kernel, which would basically not be necessary as it could be hard coded.\nAnother solution I could think of would be to inject a meaningless dummy parameter into the class just to increase the number of parameters.\nBoth solutions work, but seem far from perfect.\nWhat approach would you suggest?\nSolution 1:\n``` typescript\ndecorate(injectable(), PassThrough);\n@injectable()\nclass Dependency extends PassThrough {\n  constructor(@inject('objectModeConfig') private config: any) {\n    super(config);\n  }\n}\nkernel.bind('Dependency').to(Dependency);\nkernel.bind('objectModeConfig').toConstantValue({ objectMode: true });\n```\nSolution 2:\n``` typescript\ndecorate(injectable(), PassThrough);\n@injectable()\nclass Dependency extends PassThrough {\n  constructor(@inject('dummy') private dummy: any) {\n    super({ objectMode: true });\n  }\n}\nkernel.bind('Dependency').to(Dependency);\nkernel.bind('dummy').toConstantValue('dummy');\n```\n. To further improve the error message, the request could, in case of above error, lookup dependencies without the meta data to provide possible solutions:\ntypescript\nNo bindings found for serviceIdentifier: 'Weapon' and tag: {key:'faction', value:'ninjarai'} \nPossible bindings for serviceIdentifier: 'Weapon': [ {'tagged': {key:'faction', value:'ninja'}}, {'tagged': {key:'faction', value:'samurai'}} ]\nAgain, if approved, I\"ll implement this and provide a pull request\n. Sorry for all those added white spaces in the diff.\nThe Visual Studio Code auto format function seems to have done this according to the settings in .vscode ?\nUse this link to view the changes without white spaces\nI can also remove them again if they conflict with any code convention I was not aware of\n. a possible solution would be to resolve the dependencies with their primary identifier and register the resolved instance again under the 'ICacheable' identifier and then use getAll() \n```typescript\ncontainer.bind('IFooService').to(FooService).inSingletonScope();\ncontainer.bind('IFooService2').to(FooService2).inSingletonScope();\ncontainer.bind('ICacheable').toConstantValue(container.get('IFooService'));\ncontainer.bind('ICacheable').toConstantValue(container.get('IFooService2'));\ncontainer.getAll('ICacheable')\n```\nbut this seems cumbersome and I need to register all services first before I can resolve and re-register the instances, else it would fail.\nAlso this cannot be done in container modules as there is no way to resolve a dependency in there. ",
    "endel": "Yay! \ud83c\udf89  \ud83d\udc4f \n. Hey @remojansen,\nWhat about when I'm extending another class but not implementing a constructor? E.g.:\n``` typescript\n@injectable()\nclass Base {\n    constructor(@inject(Foo) foo: Foo) {\n    }\nbar () {}\n\n}\n@injectable()\nclass Child extends Base {\n    bar() {}\n}\n```\nWhen trying to retrieve a Child through injection the same error pops out. Shouldn't I be able to just omit the constructor when extending another class?\n. Hi @remojansen, thanks for your precise thoughts on this. We're building a IoC sort of framework over here and I'd be glad if I could help you out on property injection and child kernels implementation if you haven't started with it yet. Cheers! \n. Hi @remojansen, great! Thanks for the invitation \ud83d\ude04 \n. Hey @remojansen, I see that you made some progress here, that's great! May I help you with this?\n. Awesome @remojansen! Thanks for your work here. \nAre the property injections happening during instantiation or they are they lazy evaluated? \nCheers!\n. That's really great, can finally inject properties across inherited classes, without having to repeat the constructor signature <3 <3 <3 <3 \n. Thanks! \ud83c\udf89 \n. Great, thanks!\n. Hey @remojansen, that's odd. Do you have any idea why tsify is changing the target to anything below ES5? IMHO nobody on earth would have a reason to use anything below that, isn't it? Cheers!\n. It was actually a bug on on that version: https://github.com/TypeStrong/tsify/commit/90b86265a38f0cca8d950798162e6b5cfbc2825b\n. You're doing a great job man, that's awesome! :)\n. That's impressive.\n. This will come in handy \ud83d\udc4d  \ud83d\udc4d . PS: using v0.1.8 works fine!. Hey @remojansen, the version I'm using is 2.0.1, actually. I need to upgrade our framework to use 3.0.0, will do it this week possibly!. Related to https://github.com/inversify/InversifyJS/issues/466. ",
    "robertmain": "I'm chipping in here to say that I'm getting this too, except it's complaining about my controllers. The error I'm getting says No matching bindings found for serviceIdentifier: String. It gets thrown when Server.build() is called.. Can I just ask if you wrote those decorators, or if they come from express?. @r0bnet are you using this for express routing also? I'm trying to do something similar, I think - except that I'm using decorators to set-up my routes along these lines: https://spring.io/guides/gs/rest-service/#_create_a_resource_controller\n. I was asking if you wrote the decorators you're using in your code example, or if express provided them. \nI'm trying to build something similar to the way SpringMVC does things with decorators so I was going to ask you how you were doing things. However, I found a package on npm that does what I was after - don't worry about it :). @AltekkeE oh cool - thanks :). ",
    "marechal-p": "I had the same problem as @robertmain, and the cause was that I expected inversify to only use attribute injection, while in fact it also tried to do constructor injection. See the following:\n```ts\nclass Example {\n@inject(Dependency)\nprotected dep: Dependency;\n\nconstructor(\n    public defaultArg: string = 'defaultValue'\n) {\n    console.log(this.defaultArg);\n}\n\n@postConstruct()\nactualInitialization() {\n    this.dep.use();\n}\n\n}\n```\nIn this case inversify tries to provide a dependency for the constructor argument defaultArg, even though we never decorated it to inject something.\nThe fix:\nts\n    constructor(\n        @optional() public defaultArg: string = 'defaultValue'\n    ) {\nEven with @optional() I think inversify will try to provide a dependency for it, but if it fails it will not throw an error.. ",
    "Robotregent": "Hi, I added a PR to the ticket. Can you see it? I'm not sure if i have done it right :)\n. Thanks for helping me with this PR stuff :)\n. ",
    "rundef": "Yes, it's mostly just renaming (restify is based on express)\nCool, then I'll send a PR later !\nThanks\n. Yes, sound good to me\n. ",
    "mvestergaard": "It also appears that the typings in inversify-dts come from DefinitelyTyped, but since the project is written in TS, why not let TS generate the .d.ts files?\nYou might have a good reason, it just seems backwards to me.\nSee https://github.com/mobxjs/mobx for another example. Written in TS, definitions are generated and included in package.json.\n. Are there other third party typings needed except for bluebird? Because I would think it would be pretty easy to create your own typings for a simple promise interface, bluebird is most likely overkill.\n. I would actually even think you can just use the typings from lib.es6.d.ts that ships with typescript, and it can automatically output them for you in the definitions, but don't hold me up on that.\nIf not, I would just copy them from lib.es6.d.ts\n. ",
    "MeirionHughes": "I was surprised there were no typings too :D. Thankfully they are available via: @types/inversify (need to use typescript 2.0)\nNote, any @types modules that needs to be installed by your lib consumers needs to be in dependency while typings for say @types/jasmine can go in devDependencies. \n. ",
    "djflex68": "My node version is 5.11.1, maybe it's too old ?\n. Can you please publish a release soon ? \nWe are waiting of #882 because of performance issues with Math.random.. ",
    "johnfields": "fyi for anyone working on this return child.sayHello() should be this.child.sayHello()\n. @remojansen yes it can be closed.  Thanks for investigating!\n. ",
    "anthonyjlmorel": "Thanks @remojansen !\nCan I ask for a clarification on lazy injection meaning ?\nI was wondering if lazy injection can be a mean to resolve circular dependency (CD) error that inversify currently throws. \nIn my sense, I see that CD can be a problem while in the constructor we want to directly use the dependency that has not been loaded yet and thus creates a kind of deadlock.\nBut if I use my dependency later in my code (in a business method for instance), I think this CD is not an issue. \nCan I solve this by using the \"lazy injection\" you're talking about ?\nThanks for this amazing framework by the way.\n. ",
    "jacks50": "Is the support for the @multiInject decorator resolved ? I've got a weird issue and it seems to concern it after trying to debug my app. I can't @multiInject properties nor constructor parameters, I've posted on SO to see if someone has had this issue or not ...\nEDIT : It seems related to it because when deleting the decorator, my app runs without errors, else I got an error without message (as seen in the debugger). Hi @remojansen and thank you for your quick reply.\nIndeed, I forgot a class in my SO question :) I updated it, but after digging the issue I think now it is related to one of my injectable KeyFeature.\nIn fact, when I remove all the @inject in my KeyFeature classes (related to the SO question), I've got no more errors, but I made a small test to check if the @multiInject was working correctly and it was the case. \nSo yes, I am binding 2 items to one identifier, but they should be injected in the constructor with @multiInject. They are injected as long as none of the injected object has an @inject on its properties / constructor.\nDoes the little stacktrace gives you an hint about what could be the error ? I don't even have a message, is there a way to get one ? Or is this error not handled, and thus not giving a message ?\nThank you very much for your time !. I have finally found my error ! In my workflow, I'm binding some values retrieved from a JSON object which are typeof any and, as I guess, are not supported by inversify (since they are not newable).\nIs it possible to bind primitive types (or any) so I can inject these values to the required objects ? Or do I must create a class for these values ?. @remojansen Thank you ! I just noticed it and used it, works perfectly ! Thank you very much for your time :). Just noticed there was an update to do .. My bad, sorry for inconvenience.. ",
    "mpontus": "Does this eliminate the need to maintain TYPES object if every interface was replaced with an abstract class?  Are there any downsides to using this approach?. ",
    "andreasrueedlinger": "Yes, this was my workaround locally :-)\n. It would be nice to have a serviceIdentifierFormatter instead of just toString() to support all kind of serviceIdentifier types (Symbol, string and class). Otherwise it will log the whole implementation of a class in case of a class identifier\n. Here is the code to reproduce the error when using Symbol:\n``` typescript\nimport 'reflect-metadata';\nimport { Kernel, inject, injectable } from 'inversify';\nimport { makeLoggerMiddleware, textSerializer } from 'inversify-logger-middleware';\nconst TYPES = {\n  MyService: Symbol('MyService'),\n  MyController: Symbol('MyController')\n};\n@injectable()\nclass MyService {\n  foo() {\n    return 123;\n  }\n}\n@injectable()\nclass MyController {\n  constructor(\n      @inject(TYPES.MyService) private myService: MyService\n    ) { }\nbar() {\n  return this.myService.foo();\n}\n\n}\nconst kernel = new Kernel();\nkernel.bind(TYPES.MyService).to(MyService).inSingletonScope();\nkernel.bind(TYPES.MyController).to(MyController).inSingletonScope();\nlet logger = makeLoggerMiddleware();\nkernel.applyMiddleware(logger);\nlet myController = kernel.get(TYPES.MyController);\n```\nThis yields the following stack-trace:\n```\n/node_modules/inversify-logger-middleware/lib\n/serializers/text/request_serializer.js:16                                \n            textEntry = propertyLogger(textEntry, 2, \"Binding<\" + request.se\nrviceIdentifier + \">\", bindingIndex.toString());                          \n                                                                ^           \nTypeError: Cannot convert a Symbol value to a string                      \n    at /node_modules/inversify-logger-middleware/lib/serializers/text/request_serializer.js:16:65                      \n    at Array.forEach (native)                                             \n    at Object.serializeRequest [as default] (/node_modules/inversify-logger-middleware/lib/serializers/text/request_serializer.js:15:26)\n    at Object.textSerializer [as default] (/node_modules/inversify-logger-middleware/lib/serializers/text/text_serializer.js:12:45)                                                                \n    at consoleRenderer (/node_modules/inversify-logger-middleware/lib/renderers/console_renderer.js:4:37)              \n    at Kernel._middleware (/node_modules/inversify-logger-middleware/lib/index.js:53:13)                               \n    at Kernel._get (/node_modules/inversify/lib/kernel/kernel.js:162:27)                                               \n    at Kernel.get (/node_modules/inversify/lib/kernel/kernel.js:76:21)                                                 \n    at Object. (/index.js:48:27)\n    at Module._compile (module.js:541:32)                                 \n```\n. And using (almost) the same code with Classes:\n``` typescript\nimport 'reflect-metadata';\nimport { Kernel, inject, injectable } from 'inversify';\nimport { makeLoggerMiddleware, textSerializer } from 'inversify-logger-middleware';\n@injectable()\nclass MyService {\n  foo() {\n    return 123;\n  }\n}\n@injectable()\nclass MyController {\n  constructor(\n      @inject(MyService) private myService: MyService\n    ) { }\nbar() {\n  return this.myService.foo();\n}\n\n}\nconst kernel = new Kernel();\nkernel.bind(MyService).to(MyService).inSingletonScope();\nkernel.bind(MyController).to(MyController).inSingletonScope();\nlet logger = makeLoggerMiddleware(null, (entry) => console.log(textSerializer(entry)));\nkernel.applyMiddleware(logger);\nlet myController = kernel.get(MyController);\n```\ngives the following not very nice output (not using the kernel.getServiceIdentifierAsString you mentioned):\n```\nSUCCESS: 5.92 ms.\n    \u2514\u2500\u2500 Request : 0\n        \u2514\u2500\u2500 serviceIdentifier : class MyController {    constructor(myService) {        this.myService = myService;    }    bar() {        return this.myService.foo();    }}\n        \u2514\u2500\u2500 bindings\n            \u2514\u2500\u2500 Binding : 0\n                \u2514\u2500\u2500 type : Instance\n                \u2514\u2500\u2500 implementationType : MyController\n                \u2514\u2500\u2500 scope : Singleton\n        \u2514\u2500\u2500 childRequests\n            \u2514\u2500\u2500 Request : 0\n                \u2514\u2500\u2500 serviceIdentifier : class MyService {    foo() {        return 123;    }}\n                \u2514\u2500\u2500 bindings\n                    \u2514\u2500\u2500 Binding : 0\n                        \u2514\u2500\u2500 type : Instance\n                        \u2514\u2500\u2500 implementationType : MyService\n                        \u2514\u2500\u2500 scope : Singleton\n                \u2514\u2500\u2500 target\n                    \u2514\u2500\u2500 serviceIdentifier : class MyService {    foo() {        return 123;    }}\n                    \u2514\u2500\u2500 name : undefined\n                    \u2514\u2500\u2500 metadata\n                        \u2514\u2500\u2500 Metadata : 0\n                            \u2514\u2500\u2500 key : inject\n                            \u2514\u2500\u2500 value : class MyService {    foo() {        return 123;    }}\n```\n. ",
    "luisfarzati": "I'm getting a Cannot find name 'Controller'. when doing this:\n``` typescript\nimport { inject, injectable } from 'inversify'\nimport { Controller, Get } from 'inversify-express-utils'\n@Controller('/foo')\n@injectable()\nexport class FooController implements Controller  {\n}\n```\nMy tsconfig.json:\njson\n  \"compilerOptions\": {\n    \"target\": \"es2015\",\n    \"lib\": [\"es6\"],\n    \"types\": [\"reflect-metadata\"],\n    \"module\": \"commonjs\",\n    \"moduleResolution\": \"node\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"noImplicitAny\": true\n  },\nNow I might be mistaken, but I'm wondering how does the following code in decorators.d.ts \ntypescript\nimport interfaces from \"./interfaces\";\nexport declare function Controller(path: string, ...middleware: express.RequestHandler[]): (target: any) => void;\nexport declare function All(path: string, ...middleware: express.RequestHandler[]): interfaces.HandlerDecorator;\nexport declare function Get(path: string, ...middleware: express.RequestHandler[]): interfaces.HandlerDecorator;\nexport declare function Post(path: string, ...middleware: express.RequestHandler[]): interfaces.HandlerDecorator;\nexport declare function Put(path: string, ...middleware: express.RequestHandler[]): interfaces.HandlerDecorator;\nexport declare function Patch(path: string, ...middleware: express.RequestHandler[]): interfaces.HandlerDecorator;\nexport declare function Head(path: string, ...middleware: express.RequestHandler[]): interfaces.HandlerDecorator;\nexport declare function Delete(path: string, ...middleware: express.RequestHandler[]): interfaces.HandlerDecorator;\nexport declare function Method(method: string, path: string, ...middleware: express.RequestHandler[]): interfaces.HandlerDecorator;\nexport the Controller interface. It's importing the interfaces for using them when exporting the decorators, but is not exporting the interface itself. Right?\n. Thanks, I'll continue on that thread!\n. Yeap, same here. Shouldn't decorators.d.ts export the Controller interface that is importing from interfaces.d.ts?\n. But you are exporting the @Controller decorator. How about the Controller interface?\nNote that I'm not getting an error when using the @Controller decorator, but rather when I try to use the interface like in the example:\ntypescript\n@Controller('/foo')\n@injectable()\nexport class FooController implements Controller  { // I get a \"Controller is undefined\" here\n}\n(I might be missing something here, new to TS)\n. @remojansen thanks! Working now. Ideally, would be nice to be able to import Controller as is, but that's just me being too picky :D Thank you!\n. ",
    "pkeuter": "@remojansen This works perfectly when I'm not using uglifyjs with manging enabled. When I am using uglifyjs with mangling enabled, i'm getting this error: Error: No matching bindings found for serviceIdentifier: Symbol(Controller).\ncontainer.bind<invInterfaces.Controller>(TYPE.Controller).to(controllers.AuthController).whenTargetNamed(\"AuthController\");\n@Controller(\"/auth\")\n@injectable()\nexport class AuthController implements interfaces.Controller {\n    constructor( @inject(TYPES.AuthService) private service: IAuthService) { }\ninversify version 3.0.0-rc.4\ninversify-express-utils: 3.0.0-beta.1\nAny idea what that could be? Maybe this is the wrong place to post this, but I'm not sure if it's worth opening a new issue.. Hi there!\nThis PR (https://github.com/inversify/inversify-express-utils/pull/126) breaks piping data like \nstream.data.pipe(_res);\n    return;\nThis is because the headers won't be set yet when returning from the function. There is obviously a workaround by writing the headers before returning, but I liked the previous method of just returning without a value. This also gives the error handler a chance to set the headers (when opening the filestream fails for instance). Is there a way we can reimplement this?\nOn a sidenote; this was a breaking change, so I would have expected the version number to change to 6.0.0 instead of 5.2.1.. There currently (since this PR) seems no way to not let Inversify handle the response. This is obviously a problem. If people really want the possibility to not return anything and still let Inversify handle the response, we need some way to flag that we want to override functionality. This can possibly be done in the decorator? Hopefully we can find a good solution to this, but currently this is broken (since it's not released as a breaking change) and there is no workaround. As such, I would opt for reverting this PR until we find a decent way to handle this situation. @remojansen please advise.. ",
    "frossi85": "Sorry to revive an old issue, but how I can do the same in ES6??. ",
    "timdp": "Thanks! I haven't done much beyond some experiments with ES decorators but if I come across something useful, I'll definitely post it here.\n. I'd already googled my way to both those links, but thanks. :smile:\nI still think the main reason why it doesn't work is because Babel doesn't know what to do with the decorators on the parameters.\nI've updated the Gist to use instance properties instead:\n``` js\n@injectable()\nclass Ninja {\n  @inject(TYPES.Katana) _katana = null\n@inject(TYPES.Shuriken) _shuriken = null\nfight () { return this._katana.hit() }\n  sneak () { return this._shuriken.throw() }\n}\n```\nThis requires babel-plugin-transform-class-properties to be loaded first. However, the properties still just disappear because of the @inject (without it, they get moved to the constructor). \nI wonder if it's even possible to use the current implementation of inject with JS? I mean, if you use it with decorate, it expects the index of the parameter ...\n. So there's no way to avoid decorate altogether? Perhaps with an alternative decorator such as the following construct:\njs\n@injectable()\n@inject({\n  _katana: TYPES.Katana,\n  _shuriken: TYPES.Shuriken\n})\nclass Ninja {\n  fight () { return this._katana.hit() }\n  sneak () { return this._shuriken.throw() }\n}\nNot saying it's perfect but it would solve a common case and not require decorate.\n. True, I was already thinking about a lightweight adapter around the API, but it'd be nice if it were supported out of the box. Or someone could create an inversify-helpers package. If not, I'd at least consider adding the comment above to the docs. :-)\n. Not my call but I think a lot of people would find it useful!\n. Oh, I see. I appreciate the offer but I'm not really interested in maintaining another project at this point. Thanks anyway. :-)\n. Thanks. I actually ended up writing a simple decorator (called wire) that basically does the same as helpers.annotate. Could be one of the helpers maybe?\n. It's very similar to yours:\n``` js\nimport {decorate, injectable, inject} from 'inversify'\nexport default (dependencies = []) => (constructor) => {\n  decorate(injectable(), constructor)\n  dependencies.forEach((dep, index) => {\n    decorate(inject(dep), constructor, index)\n  })\n}\n```\nwhich allows you to write things like\n``` js\nimport TYPES from './ioc/types'\nimport wire from './ioc/wire'\n@wire()\nclass Foo {}\n@wire()\nclass Bar {}\n@wire([TYPES.Foo, TYPES.Bar])\nclass Baz {\n  constructor (foo, bar) {\n    this._foo = foo\n    this._bar = bar\n  }\n}\n``\n. Yep, withtransform-decorators-legacyat least.\n. Good job!registerlooks like a drop-in replacement for thewire` decorator that I wrote and I'm sure the other ones will be useful to us in the long run as well. :+1:\n. ",
    "jt-helsinki": "OK, I upgraded to the new way and it all worked. Fantastic! Thankyou! \ud83d\udc4d  \nBasically, I had a mix of typings and @type definitions. It got the point where there were so many conflicts that it just became unmanageable. That's seems to be pretty much it. \nThanks again\nJT\n. ",
    "nodify-at": "Hi @remojansen , \nthank you for your support. I think you're right. We can close the ticket, I've solved my problem by using a middleware.\n. ",
    "julianosam": "Hi @remojansen, @codyjs \nI completely agree that the request object should only be accessible up to the controller layer. However, cross-cutting concerns like identity (user context) in a web app (i.e. express) are usually extracted from the session or some other property/token stored in the request object. \nIs there a way to make the user context injectable into the application services using Inversify.js while maintaining a good separation of concerns? It seems we're lacking the concept of request or session scopes to achieve that...  Or is there another way? Thanks!\n```typescript\n@Get('/')\ngetSomething(req, res) {\n    // How can I make this injectable?\n    let userCtx:UserContext = () => new User(req.session.user);\n   // ...\n}\n...\n@injectable()\nexport class  MyService {\n// So that I can inject it whenever I need it...\nconstructor(\n    @inject('UserContext') private _userCtx : UserContext;\n){ }\n\nmyFunction() {\n\n    const user = this._userCtx();\n    // do smth with the user info...\n\n}\n\n}\n```. Thanks so much for the reply @remojansen ! Will give it a try soon!. ",
    "efredin": "@remojansen the whole race condition could be avoided by modifying inversify-express-utils to use a child container to resolve each controller method. \njavascript\nprivate handlerFactory(controllerName: any, key: string, parameterMetadata: interfaces.ParameterMetadata[]): express.RequestHandler {\n        return (req: express.Request, res: express.Response, next: express.NextFunction) => {\n            let container = this._container.createChild();\n            container.bind<express.Request>(TYPE.Request).toConstantValue(req);\n            let args = this.extractParameters(req, res, next, parameterMetadata);\n            let result: any = container.getNamed(TYPE.Controller, controllerName)[key](...args);\n            Promise.resolve(result)\n                .then((value: any) => {\n                    if (value && !res.headersSent) {\n                        res.send(value);\n                    }\n                })\n                .catch((error: any) => {\n                    next(error);   });\n        };\n    }. ",
    "wfrank2509": "Hi there @remojansen ...\nsorry for bringing it up again.\nI tried the example you illustrated above to bind an object to the http request scope.\ncntnr.bind(TYPE.CurrentRequest)\n                .toConstantValue(req)\n                .inRequestScope();\nIt looks like the .inRequestScope is not allowed on a Constant.\nIs there another way to accomplish that? I looked into the HttpContext injection stuff which would basically work but wouldn't be as \"elegant\" ...\nHope you can shed some light on that topic?\nThanks and greets,\nWolfgang\n. ",
    "faisalil": "for the \"commonjs\" project, tsconfig.json: \njs\n{\n  \"compilerOptions\": {\n    \"noImplicitAny\": false,\n    \"module\": \"commonjs\",\n    \"target\": \"es6\",\n    \"jsx\": \"react\",\n    \"allowJs\": true,\n    \"experimentalDecorators\": true,\n    \"inlineSourceMap\": true,\n    \"allowSyntheticDefaultImports\": true\n  },\n  \"include\": [\n    \"js/**/*\"\n  ]\n}\npackage.json:\njs\n{\n  \"version\": \"1.0.0\",\n  \"name\": \"somename\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"webpack\"\n  },\n  \"devDependencies\": {\n    \"babel-core\": \"^6.3.17\",\n    \"babel-loader\": \"^6.2.0\",\n    \"babel-plugin-transform-es2015-classes\": \"^6.9.0\",\n    \"babel-preset-es2015\": \"^6.3.13\",\n    \"babel-preset-react\": \"^6.3.13\",\n    \"babel-preset-stage-3\": \"^6.11.0\",\n    \"copy-webpack-plugin\": \"^3.0.1\",\n    \"image-webpack-loader\": \"^2.0.0\",\n    \"jest\": \"^15.0.2\",\n    \"jest-cli\": \"^15.0.2\",\n    \"react-addons-test-utils\": \"^15.3.1\",\n    \"react-test-renderer\": \"^15.3.1\",\n    \"sinon\": \"^1.17.6\",\n    \"source-map-loader\": \"^0.1.5\",\n    \"ts-loader\": \"^0.8.2\",\n    \"typescript\": \"^2.0.3\",\n    \"typings\": \"^1.3.2\",\n    \"webpack\": \"1.13.1\"\n  },\n  \"dependencies\": {\n    \"adal-angular\": \"^1.0.11\",\n    \"immutable\": \"^3.8.1\",\n    \"moment\": \"^2.14.1\",\n    \"radium\": \"^0.18.1\",\n    \"react\": \"^15.2.1\",\n    \"react-custom-scrollbars\": \"^4.0.0\",\n    \"react-dom\": \"^15.2.1\",\n    \"react-redux\": \"^4.4.5\",\n    \"react-router\": \"^2.6.0\",\n    \"redux\": \"^3.5.2\",\n    \"redux-actions\": \"^0.10.1\",\n    \"redux-form\": \"^5.3.2\",\n    \"redux-thunk\": \"^2.1.0\"\n  }\n}\nFor the other project (es6 module project), \ntsconfig: \njs\n{\n    \"compilerOptions\": {\n        \"allowJs\": true,\n        \"outDir\": \"built\",\n        \"module\": \"es6\",\n        \"target\": \"es6\",\n        \"jsx\": \"react\",\n        \"inlineSourceMap\": true,\n        \"noEmitOnError\": true,\n        \"experimentalDecorators\": true,\n        \"allowSyntheticDefaultImports\": true\n    },\n    \"compileOnSave\": true,\n    \"include\": [\n        \"../js/src/**/*\",\n        \"typings/**/*\"\n    ]\n}\nand package.json:\njs\n{\n  \"name\": \"someothername\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"node node_modules/react-native/local-cli/cli.js start\"\n  },\n  \"dependencies\": {\n    \"deep-equal\": \"^1.0.1\",\n    \"immutable\": \"^3.8.1\",\n    \"moment\": \"^2.13.0\",\n    \"react\": \"^15.3.2\",\n    \"react-native\": \"^0.34.1\",\n    \"react-native-button\": \"^1.7.1\",\n    \"react-native-communications\": \"^2.1.2\",\n    \"react-native-elements\": \"^0.6.1\",\n    \"react-native-extra-dimensions-android\": \"^0.17.0\",\n    \"react-native-gifted-spinner\": \"^0.1.0\",\n    \"react-native-parsed-text\": \"^0.0.16\",\n    \"react-native-router-flux\": \"^3.35.0\",\n    \"react-native-vector-icons\": \"^2.1.0\",\n    \"react-native-video\": \"^0.8.0\",\n    \"react-redux\": \"^4.4.5\",\n    \"redux\": \"^3.6.0\",\n    \"redux-actions\": \"^0.12.0\",\n    \"redux-thunk\": \"^2.1.0\"\n  }\n}\n. @remojansen any idea?\n. I am using typescript 2.0.3 for all projects so I don't think its a typescript issue. Why would the fact that I am using typings be a problem if I am using typescript@2? \nThe error is a typescript compile error and its happening on the react native project not the project using webpack. I doubled checked the compilation options and I am not missing anything. \n. @remojansen this is not a react-native issue ! The reason I am saying that is that typescript complication is where things break down (even if I don't have a single typescript file). This is a legit issue in the typescript definitions. . ",
    "stjepangolemac": "It solves that error but now I have another one (caused by my implementation). My logger class extends winston logger which doesn't have injectable decorator. How am I supposed to fix this?\nHere is the error.\nError: Missing required @injectable annotation in: Anonymous function: function (options) {\n  events.EventEmitter.call(this);\n  this.configure(options);\n}\nAnd it seems to point to this function in the winston logger https://github.com/winstonjs/winston/blob/master/lib/winston/logger.js line 25\njavascript\nvar Logger = exports.Logger = function (options) {\n  events.EventEmitter.call(this);\n  this.configure(options);\n};\n. Yes, that helped me a lot. You are very responsive and helpful, keep up the good work!\n. ",
    "jbcpollak": "Hum, in my experience true singletons (ie, a module that returns a class instance) are bad practice (it makes testing hard for one), but using an IoC instantiated singleton is ok, it avoids instantiating unnecessary duplicate objects, etc.\nFor example, I have a 'MapProvider' class that is needed by multiple components and has an in-memory construct of the map. I don't want multiple copies of the MapProvider during production runtime, so I'd like to make it a singleton.\nI'm coming from the Java/Spring IoC world however - so perhaps there is a better pattern in JavaScript.\nCan you point me to some articles on how to avoid IoC singletons? What do you do about service modules? \nInteresting work around - I hadn't thought about a helper function, thanks. But as you said - if its a bad idea even for an IoC, I'd like to learn more about why.\n. Thanks! I'll read the post and the SO link. I understand those points and agree inversify doesn't have those problem. I would say that one solution to the internal cache problem is to keep singletons but make factories easier to create (Spring does this nicely).\nAnyway, I'll review the links you sent and see if I can think of ways to restructure my code, although I'm skeptical there are solutions around it.\n. Just a follow up - I read both links you sent:\nThe SO explains why you would not want to use manually constructed singletons - I completely agree. The Angular link explains their improvements, but doesn't explain how a service can be used to share state between components - it must be possible, but I don't see how. For example, in their article they created a NameService - if each component has its own instance of NameService, how can they every share state?\n. is there any way this annotation can be added to the derived class rather than the base class? Specifically, what if the base class is in a library you don't want to modify or add inversify annotations to?\nI've got code like this for the base classes:\ndecorate(injectable(), LibClass1);\ndecorate(injectable(), LibClass2);\ndecorate(injectable(), LibClass3);\nWhich is annoying but managable, but I don't see how to decorate the constructor parameters with @unmanaged().\nFrom a compositional perspective it seems like something that is more appropriate on the derived class anyway.. ",
    "skyrpex": "Why not a WeakMap or a Map itself? \n. Nice!\n. ",
    "Shepless": "@remojansen works a treat. Thank you! I'll close the issue.\n. ",
    "kenneththorman": "It seems like this has broken the https://github.com/inversify/inversify-express-example.\nWhen downloading directly from github I am faced with this compilation error\nnode_modules/inversify-binding-decorators/dts/factory/fluent_provide_decorator_factory.d.ts(3,76): error TS2694: Namespace 'interfaces' has no exported member 'Container'.\nnode_modules/inversify-binding-decorators/dts/factory/provide_decorator_factory.d.ts(2,61): error TS2694: Namespace 'interfaces' has no exported member 'Container'.\nnode_modules/inversify-binding-decorators/dts/utils/auto_wire.d.ts(2,52): error TS2694: Namespace 'interfaces' has no exported member 'Container'.\nnode_modules/inversify-express-utils/dts/server.d.ts(18,49): error TS2694: Namespace 'interfaces' has no exported member 'Container'.\nThank you in advance\nRegards\nKenneth\n. ",
    "johnjacobkenny": "@remojansen Thank you for the prompt responses and merges! I'm just starting out in contributing to open source and this is keeping me motivated! :)\n. @remojansen I'm new to inversify and I wanted to try it out and see how it worked. I am thrilled to be able to contribute, but it will take a while as I get used to how inversify works. If time is not a constraint I can help here and there as I learn. \nIf there's something you'd like me to look at specifically (which would be easy to get started with) please let me know. Thanks!\n. ",
    "meticoeus": "For lazy injection, what about injecting a promise or async getter that resolves to the dependency once it is available? A component waiting on a database connection would probably render a loading state until the data is available regardless of injection method.\n. ",
    "buehler": "Hey @remojansen \nMy 2 cents to this matter :-)\nFirst of all: async constructor are not gonna happen in my opinion. The simple reason is: no language I know (maybe not that much) does support it. Since TypeScript is using many core concepts of C#, the way to go (as in Java or similar languages) looks like this (Possible with TypeScript 2):\ntypescript\nclass Foobar {\n    private constructor(private dbInstance: any) {}\n    public static async create(/* whatever */): Foobar {\n        let db = await getMyDbInstance();\n        return new Foobar(db);\n    }\n}\nSo much for the constructors ;-)\nSo as I understand this discussion, it's not about some critical missing part, it's about convenience? So you actually want to inject a previously awaited inject? \nProblem is, that if you want to achieve that, you need to await all the things before you create the instance.\nI could imagine the following scenarios:\ntypescript\nclass Foobar {\n    private async getDb(): Promise<Db> {\n        return await container.get; //...\n    }\n}\nor use a factory (async factory) with the code at the beginning of this post (the async create method) to inject the value.\nAnother possibility could be a container.get method, which returns the result immediately but with Promises injected (or factories / provider) and a container.getAsync method, that can  be awaited but awaits all Promises that are injected.\nDo I understand the question?\nCheers\n. I like the first code ;-) It's neat and understandable. Maybe the price is too high. If the whole framework needs to get async I don't know if the features are that great at the moment. \nBut maybe for features in the future, there will be the need to make the framework async, but I'd wait for that to happen.\nA possible extension to make the code cleaner could be an extension to the Provider:\n``` typescript\nclass Provider{\n    public readonly value: T;\npublic get someFancyNameForProvideValue(): Promise<T> {\n    return this.value !== undefined ? Promise.resolve(this.value): this.provide();\n}\n\npublic provide(): Promise<T> {\n     /* exec provider function */\n     this.value = 42; // save the result of the provider function\n}\n\n}\n// then you could make either:\nclass UserRepository { \n// STEP 1\npublic constructor(\n    @inject(\"Provider<DbClient>\") private provider: Provider<DbClient> // Provider injection \n) {}\n\npublic async getUser(): Promise<Users[]>{\n    let db = this.provider.value || await this.provider.provide();\n    return db.collections.user.get({});\n}\n\n}\n// or (would be cool too, with the fancy getter):\nclass UserRepository { \n// STEP 1\npublic constructor(\n    @inject(\"Provider<DbClient>\") private provider: Provider<DbClient> // Provider injection \n) {}\n\npublic async getUser(): Promise<Users[]>{\n    let db = await this.provider.someFancyNameForProvideValue;\n    return db.collections.user.get({});\n}\n\n}\n```\nThe idea would be to extend the provider so that it is a class that has a provide function. (Maybe)\nSo you could \"save\" the init function and just await the provider function that returns the value if initialized, or executes the function and saves the value.\n. No worries mate :-)\n. ",
    "alexmt": "Thank you for response, @remojansen ! We are currently using 2.0.1 . I was trying to implement test app using 3.0.0-beta.1 in order to create PR for https://github.com/inversify/InversifyJS/issues/412 . I would be glad to do it when 3.0.0-beta.1 is stable.\n. Thank you response guys! @lholznagel , can you take a look at PR please?. ",
    "shlomiassaf": "Thank you for the quick response, great work btw!!!\nInheriting will work, but it doesn't fit my use case (lib) it's more for local use.\nIf I go that path I will have to force user's of my lib to use my Container version, which is a bad idea.\nI'm also not a fan of monkey patching but if it's harmless I can live with it.\nPatching the prototype while extending the type the way I tried to is the official way to do it as described in the TypeScript docs here (see Module Augmentation)\nI think the reason it's not working is due to the use of default exports.\nAlso the main file is renaming (as) all the defaults which might also be a problem.\nI also tried:\ndeclare module 'inversify/dts/container/container' {\n  interface Container {\n    createChild(): Container;\n  }\n}\nWith no luck, there is no Container interface in the module since the module is the Container (default)\nI believe default is not a good pattern, RXJS doesn't use it, angular 2 does not as well and they are 2 leading TypeScript projects...\nIt doesn't save much anyway...\n. BTW, creating a child from the parent directly is a good addition, that helper function makes sense a parent creating a child...\n. Well, Axel Rauschmayer from the @2ality blog commented about it, he's someone to listen to...\nYou can also read a very good explanation here\nI don't see any good reasons to use default exports, it doesn't give anything really, saves nothing.\nYou can also see that my attempt to augment the module failed and it shouldn't, I did it \"by the books\"\n. @lholznagel thanks.\nThere are more reasons that devs didn't find yet, I think this issue is on more reason... I'm 99% sure its due to default exports.\nI would ban them personally :)\n. Bummer :/\nYes I know inversify-binding-decorators, used it before but its a 70% solution... anyway no types no good :)\nBTW, can you publish nversify-binding-decorators for 3.0.1? I saw it was commited but it's not on npm\nInteresting thing... how are you going to manage bindings where multiple containers are an option?\n. @remojansen no worries, publish when you can :)\nThanks for the help!\nI will close this now.\n. I think it shouldn't break the API as long as the exports are the same, right?\n. @lholznagel I agree that the namespace is redundant but it means the interface names should be different then the concrete classes.\nAlso note that you never really import anything other then design time types, the interfaces never go to the runtime...\n. @remojansen ContainerInterface is indeed long but IMO it's better over namespace.\nAbout prefixing interfaces with I (e.g: IDontCare), that's an opinion and it's a general suggestion fo r the generic, average project. Inversify is a library(or IoC framework) not your average generic project.\nbasarat's gitbook says:\n\nReason: Unconventional. lib.d.ts defines important interfaces without an I (e.g. Window, Document etc).\n\nThe typescript guys say\n\nBecause the concept of an interface in TypeScript is much more broad than in C#.\n\nTo me, the MS guys make no sense. I mean, an TS interface is virtual as well as a shape and in a structural type system it is more broad... but that's just THE reason to mark it so people can identify it and say hey, this is a interface/type, I can't use it in runtime.\nThe I shouldn't confuse anyone, you'r in a TS context not C#... a dev should know.\nBasart's might make more sense if it was what actually happens, MS does not prefix anything in lib.d.ts with I. Maybe it's just outdated.\nAnyway, it's always important to remember that guidelines are generic, they address the majority of projects, the average ones. Inversify is not the average project...\nNot using default exports is a good guideline, one that makes sense and get you out of trouble.\nPrefixing with I, well I don't think so... if someone is confused between C# and TS because we prefix with I... will.. mmm :) \n. @remojansen Bad as it might be it is something that in several scenarios is needed. Again, as a library author I would like to inject some values but not always, depending on state and configuration in a dynamic way.\nFor example, a meta wrapper for an express server can be configured to listen to 2 http servers: secured (https) and unsecured (http), both derive from net.Server but not from each other.\nA user might use http, https or http + https... so I want to provide him the option to set them both in the ctor...\nI can create a token (service identifier) for an array of net.Server but then he needs to find the type, no good...\nMy current solution is to bind both types and set one of the to undefined...\nAbout @default, I think it can be\nclass MyClass {\n  constructor(@inject(\"ID\") @default(\"value\") myInjection: string) {\n  }\n}\nIt's better to keep a consistent API for more verbosity.\nThe @default parameter can be optional giving you and @optional behaviour\nclass MyClass {\n  constructor(@inject(\"ID\") @default() myInjection: string) {\n  }\n}\nThough I would still add an @optional decorator for code clarity, it is easier to understand.\nMy 2 cents on this is to be opinionated but not aggressively.\nJust because people can mess up thing doesn't mean others should suffer.\nInversify is not a somewhat of a low level library. When used, it's part of the core of the application and as such should offer flexibility.\n. ",
    "pmoleri": "Hi, I'm looking for something like what was mentioned here:\nconst myClass = container.instantiate(MyClass);\nGiven that the class is decorated, it would be nice to have a way to construct an instance of without binding it to the container.\nIs there any way to do it?. Hi @Dirrk,\nThanks for your input. I get that inversify-binding-decorators gives me a shortcut to auto bind implementations, but that's actually what I'm trying to avoid.\nIn this case, I want to use the container to construct an instance of B, but I don't want to get it registered in the container.\nE.g.:\n```typescript\n@injectable()\nclass A {\n    prop = \"test\";\n}\n@injectable()\nclass B {\n    constructor(private a: A) {\n    }\n}\nconst container = new Container();\ncontainer.bind(A).to(A);\ncontainer.get(B); // Error: No matching bindings found for serviceIdentifier: B\n```\nAt this point, the container has all the information it needs to construct an instance of B.\nI agree get should fail because it the binding wasn't registered.\nBut another function such as container.create(class) could be implemented to enable users to create a class without register the binding.\nAs a workaround I could just bind/get/unbind, but I guess the create option may be a nice addition to the api.\nI can create a new issue if you it\u2019s worth it.. Hi @Dirrk,\nThanks again for taking the time to answer. It's not about wanting a factory or an instance, it's more about that I don't find necessary to bind just to execute a get.\nIn my use case, I'm loading classes at runtime (like plugins), these classes are @injectable so I'm using the container to create the instances, but I don't have any particular interest in binding them to the container.\nPerhaps there's another way to structure the application, for example loading and binding the classes at startup and using multiInject, but I don't think I should restructure the application just to play nice with inversify. However I'll keep the idea alive, I may be missing something valuable and I don't see it just yet.\nAs for if I have seen it in another language. I think it's what Unity does:\n```csharp\npublic ManagementController(ITenantStore tenantStore)\n{\n  this.tenantStore = tenantStore;\n}\nvar container = new UnityContainer();\ncontainer.RegisterType();\nvar controller = container.Resolve();\n```. Hi @Dirrk, I'll create the issue.\nThanks for everything.. Hi @remojansen, that's great news.\nIt didn't occur to me before, I was thinking only in the root class. I guess the plugin should be able to register bindings somehow, probably via an injected service or exporting a declaration.\nIn a previous C# project, we used a custom DI container that would auto-bind any unbound dependency along the way. A global config option would say if it should auto-bind as singleton (we used it as singleton). But something like that may be pushing it too far for a generic container.\nBottom line, I think the root class scenario is enough and doesn't force you to make arguable choices.. Amazing. Thanks a lot.. ",
    "Dirrk": "@pmoleri the container is how inversify works.  \nIf you want to get around doing the container.bind('MyClass').to(MyClass) then you can use inversify-binding-decorators as suggested in this thread.  \nIf you want to get around creating an instance whenever you need one, consider setting up a factory and injecting that into the function you want to generate other objects from.  \nOr you could (although I think it goes against the whole idea of DI) and export a function from your inversify.config.ts like so:\n```typescript\nconst GetMyClassFactory = (identifier: string): MyClass => {\n  return container.get('MyClass');\n}\nexport { GetMyClassFactory }\n```. @pmoleri, thanks for bringing more light into the issue as I now have a much better understanding of what you want to do.  However, I would like to know a use case for this before we pull anyone in.\nFor instance, using your example with A and B.  Why would you not just bind B?  And more importantly why do you need to unbind it to get the affect you want?  Is there some use case, that needs you to use the container but can't have it bound?  Have you seen used this feature in another langauge ?\nBasically, it sounds like your trying to create a factory but don't want to create a factory. I would check these docs on how to create a factory and I would be your use case would fit perfectly in it.  https://github.com/inversify/InversifyJS/blob/master/wiki/factory_injection.md\nHope this helps!. @pmoleri, I think this is possible to create.  The runtime limitations would be avoided because Resolve could then do the work needed to add it to the container without actually doing it (but still resolve the dependencies).  I think its worth creating a new issue referencing the new information you have provided and write some rudimentary examples that you would expect to work using the Ninja / Katana / Sword type examples to keep with the theme.. See here:\nhttps://github.com/inversify/inversify-binding-decorators/. Appears to be a failed build due to an environment issue in Travis. Only one build failed and it was a network error while downloading a module completely unrelated to bluebird. . @remojansen yeah I think I can handle it ;-). Build passed successfully: https://travis-ci.org/Dirrk/InversifyJS/builds/207737114\nPR created here: https://github.com/inversify/InversifyJS/pull/503\n. Hey @rulai-hu this is a well thought out idea and you have great examples.  I was wondering what this would give you that the inversify-vanillajs-helpers doesn't?  I know you used it in your example, but I guess I am wondering why you went further with this if the helpers provided a work around.  Did the helpers not solve all of the problems or was it just out of wanting to do it?\nAnd to clarify you are asking for 3 potential features right?\n1. Extending middleware to provide a hook that will allow this type of overriding\n2. making Inversify.decorate not throw - by adding in a param/new function that doesn't throw instead?\n3. Officially supporting a static function on a class that annotates the dependencies\nTo give my opinion on this, I wrote a solution using the helpers:\n```javascript\n//...\nconst decorateForMe = function(c, type) {\n    let decorators = [];\n    if (c && c.inversify && typeof c.inversify === 'function') {\n        decorators = c.inversify();\n    }\n    register(type, decorators)(c);\n};\ndecorateForMe(A, 'A');\n///...\n```\nThe full code can be seen here: https://gist.github.com/Dirrk/19cfa0ff53ece4d139b4248036a022c0\nI think having decorate not throw is a bad idea for everyone else, because they want to be informed that the decorate failed properly while running the code.  I also think that adding a static function on a class directly couples that class to the IoC which, to me seems wrong.  Obviously decorators couple as well but not as a method on the class itself.  I have not worked with the middle ware yet so I really have no help to offer there atm but I just wanted to give you my feedback before one of the maintainers looks at it.. @rulai-hu, yeah I played around with it a bit more last night and you would basically have to continue to copy paste a bunch more stuff to use my example in a real application due to all the ways you can use inversify in an app so I can see how that becomes a problem.. Successful pass here:\nhttps://travis-ci.org/Dirrk/InversifyJS/builds/212197913. @AltekkeE this looks pretty cool.  Another module that does something similar is https://www.npmjs.com/package/tsoa.  I haven't used the others but in case you wanted other examples I thought I would provide it. . I think this is what you are looking for https://github.com/inversify/InversifyJS/blob/master/wiki/constructor_injection.md\nmainContainer.bind<interfaces.Newable<ITest>>(\"Newable<ITest>\").toConstructor<ITest>(Test);\n// should return the constructor of Test that can be passed down to the \"makeSomethingAndRun()\"\n. ",
    "dkellenb": "Thanks for your hint. Tried it out, but it's still not possible to connect. Server does not answer. By the way, you should not declare server variable twice.\n``` javascript\n// server.build() actually returns an Express.Application instance\nlet app = server.build();\n// socket.io expects an http.Server versus a InversifyExpressServer\n// see http://socket.io/docs/#using-with-express-3/4\nlet httpServer = require('http').createServer(app);\nlet io = socketIo(httpServer);\nio.on('connection', (client) => {\n  console.log('Client connection opened');\n// Success!  Now listen to messages to be received\n  client.on('message', (event) => console.log('Received message from client!', event));\n  client.on('disconnect', (event) => console.log('Client has disconnected'));\n});\n```\nNo luck so far.\n. I've added a demo project setup, where you can reproduce the behavior:\n=> https://github.com/dkellenb/inversify-express-utils-websockets\n1. npm install\n2. npm install ts-node -g\n3. ts-node src/bootstrap.ts\nUsing https://chrome.google.com/webstore/detail/dark-websocket-terminal/dmogdjmcpfaibncngoolgljgocdabhke following steps can be done to verify the behavior\n17:26:09    command:    /connect ws://localhost:3000/\n17:26:09    system: Connecting to ws://localhost:3000/\nNo protocol negotiation.\n17:26:09    error:  WebSocket error.\n17:26:09    system: Connection closed.\nClose status: 1006 (Abnormal Closure)\n. Tried your suggestion on https://github.com/dkellenb/inversify-express-utils-websockets/. HTTP working, but no success with WebSocket. Still the same WebSocket error.\n21:32:29    command:    /connect ws://localhost:3000/\n21:32:29    system: Connecting to ws://localhost:3000/\nNo protocol negotiation.\n21:32:29    error:  WebSocket error.\n21:32:29    system: Connection closed.\nClose status: 1006 (Abnormal Closure)\n. yay, working. great! will add it to the documentation! thanks a lot.\n. @remojansen : Done, documented also on SO.\n. ",
    "FriOne": "Great! But in general socket.io is used to emit something in a controller or somewhere else. @remojansen is there a way to make socket.io injectable? It is also will be nice if we can make controller-style injection to handle io messages.. @remojansen socket.io needs server instance, so it can be injected only after port listening. Like here. I tried to make binding after, but controller saying No matching bindings found. @lholznagel you can't do it after building this. But you should build because you need server instance for socket.io.. Ok, I understood, ngExress engine should be moved after inversify server build.. ",
    "jsilveira2": "Hi @FriOne, you find any solution for your question? I'm have the same problem.. ",
    "ppsimatikas": "Jest is using instabul under the covers.\n@lholznagel I do have the same feeling, that reflect-metadata is causing the issue.\n. @lholznagel I am happy for your success :D \nCan you please share of how did you map the ts files in your coverage configuration?\n. I have tried the ts configuration with no success.\n. Unfortunately I am not able to share the repo, but I can share the needed files with you.\njest.json \n{\n  \"collectCoverageFrom\": [\n    \"client/**/*.js\",\n    \"client/**/*.jsx\",\n    \"server/**/*.ts\",\n    \"server/**/*.tsx\"\n  ],\n  \"coverageThreshold\": {\n    \"global\": {\n      \"functions\": 50,\n      \"lines\": 50,\n      \"statements\": 50\n    }\n  },\n  \"moduleFileExtensions\": [\n    \"js\",\n    \"jsx\",\n    \"ts\",\n    \"tsx\"\n  ],\n  \"transform\": {\n    \"^.+\\\\.(ts|tsx)$\": \"<rootDir>/test_setup/preprocessor.js\",\n    \"^.+\\\\.(js|jsx)$\": \"<rootDir>/node_modules/babel-jest\"\n  },\n  \"testResultsProcessor\": \"<rootDir>/node_modules/ts-jest/coverageprocessor.js\",\n  \"testRegex\": \"/test/.*\\\\.spec\\\\.(ts|tsx|js|jsx)$\",\n  \"updateSnapshot\": true,\n  \"moduleNameMapper\": {\n    \"^.*[.](jpg|JPG|gif|GIF|png|PNG|less|LESS|css|CSS|scss|SCSS)$\": \"<rootDir>/test_setup/EmptyModule\"\n  }\n}\ntsconfig.json\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"moduleResolution\": \"node\",\n    \"target\": \"es2015\",\n    \"inlineSourceMap\": true,\n    \"types\": [\n      \"node\",\n      \"reflect-metadata\"\n    ],\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"lib\": [\"es6\", \"dom\"],\n    \"allowJs\": true,\n    \"jsx\": \"react\"\n  },\n  \"exclude\": [\n    \"node_modules\"\n  ],\n  \"compileOnSave\": false,\n  \"buildOnSave\": false\n}. ",
    "greenkeeper[bot]": "Version 4.0.1 just got published.\nUpdate to this version instead \ud83d\ude80 \n\n\n\nRelease Notes\nv4.0.1\n\n[bugfix] Removed no-unused-variable rule from recommended config, as it was causing spurious deprecation warnings. #1748 \n\n\n. After pinning to 0.1.8 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 3.4.6 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 4.1.1 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 2.2.34 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. ## Version 1.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits .\n\n02b8095 1.0.1\ne0f52be Stop testing on Node 0.8. Mocha 3 can\u2019t run on it.\n\nSee the full diff.\n\n. After pinning to 4.2.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 4.3.1 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nRelease Notes\nv4.3.1\n\n[bugfix] Fix back-compat break. Allow formattersDirectory === null (#1997)\n\n\n. ## Version 4.4.1 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nRelease Notes\nv4.4.1\n\n[bugfix] errant space in recommended ruleset (couldn't find no-misused-new)\n\n\n. ## Version 4.4.2 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nRelease Notes\nv4.4.2\n\n[bugfix] whitespace rule caused false positive on EOF (#2131)\n[bugfix] WebStorm fails because json formatter parameter has extra space (#2132)\n\n\n. ## Version 2.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 5.3.2 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nRelease Notes\nv5.3.2\n\n[bugfix] Fixes not a directory error\n\n\n. ## Version 4.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n4.0.2 / 2017-06-05\nWe have another bugfix release, addressing some issues for WebPack 1 users.\nBug Fixes\n\nRevert getting version information from package.json, some bundler tools like Webpack do not come default with json loaders despite Node being able to handle this. This change moves back to hardcoding the version number in the codebase. (#985, #986)\n\n\n\nCommits\nThe new version differs by  commits.\nSee the full diff\n\n. ## Version 5.4.1 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nRelease Notes\nv5.4.1\n\ud83d\udee0 Bugfixes\n\n[bugfix] Fixed regression in --exclude CLI option when using --project (#2852)\n\n\n. ## Version 5.4.2 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n\nRelease Notes\nv5.4.2\n\ud83d\udee0 Bugfixes\n\n[bugfix] Restored support for multiple --exclude options in the CLI (#2855)\n[bugfix] Restored support for --version CLI option (#2857)\n\n\n. ## Version 2.3.1 just got published. \nYour tests are still failing with this version. Compare the changes \ud83d\udea8 \n. After pinning to 5.4.3 your tests are passing again. Downgrade this dependency \ud83d\udccc.. After pinning to 3.1.7 your tests are still failing. The reported issue might not affect your project. These imprecisions are caused by inconsistent test results.. After pinning to 2.3.7 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 2.4.0 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nCommits\nThe new version differs by 11 commits.\n\n20eb865 Update docs/changelog.md and set new release id in docs/_config.yml\ne333e75 Add release documentation for v2.4.0\nfde7911 2.4.0\n9afdcfc Update Changelog.txt and AUTHORS for new release\n57bb8b3 Merge pull request #1489 from Rowno/named-anonymous-mocks\nc9a35ef Update fake-xhr-and-server.md\n837ec0c Allow anonymous mock functions to be named\n259a330 Merge pull request #1481 from fatso83/fix-safari-breaking\ne742268 Merge pull request #1488 from VynceMontgomery/patch-1\na6a2b8c Clarify behavior of useFakeTimers\n24d15f2 Avoid running test for #1456 on Safari\n\nSee the full diff\n\n. ## Version 2.4.1 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nCommits\nThe new version differs by 16 commits.\n\n112af55 Update docs/changelog.md and set new release id in docs/_config.yml\n7f2d45d Add release documentation for v2.4.1\ndfef160 2.4.1\n92e005f Update Changelog.txt and AUTHORS for new release\nd5e4f04 stub#withArgs:  set promiseLibrary correctly (#1497)\n20eb865 Update docs/changelog.md and set new release id in docs/_config.yml\ne333e75 Add release documentation for v2.4.0\nfde7911 2.4.0\n9afdcfc Update Changelog.txt and AUTHORS for new release\n57bb8b3 Merge pull request #1489 from Rowno/named-anonymous-mocks\nc9a35ef Update fake-xhr-and-server.md\n837ec0c Allow anonymous mock functions to be named\n259a330 Merge pull request #1481 from fatso83/fix-safari-breaking\ne742268 Merge pull request #1488 from VynceMontgomery/patch-1\na6a2b8c Clarify behavior of useFakeTimers\n\nThere are 16 commits in total.\nSee the full diff\n\n. ## Version 3.1.0 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nRelease Notes\nv3.1.0\n\nAdd factory functions for sandbox and fake server (#1515)\nAdd support for passing a function to stub.throws(...). (#1511)\nLots of documentation updates\nFix regression on sandbox.stub(obj,protoMethod) (#1512)\n\n\n\nCommits\nThe new version differs by 69 commits.\n\n1e33b74 Update docs/changelog.md and set new release id in docs/_config.yml\n3e0fe34 Add release documentation for v3.1.0\n24207cd 3.1.0\n94e262d Update Changelog.txt and AUTHORS for new release\naf6348c Merge pull request #1519 from fatso83/sandbox-wrong-config-passed\nf8b4ea1 Update sandbox docs\n127aafc Add missing docs on sandbox config change\ncacd10d Fix relative links\n1f2d2e3 Merge pull request #1515 from sinonjs/create-factory-functions\n75ad693 Merge pull request #1516 from fatso83/1512-sandbox-stub-props-on-prototype\nb4a3f42 Fix regression on sandbox.stub(obj,protoMethod)\nece1ee5 Add regression test case\n6648f1b Use new sandbox and fake server factory functions in documentation\n4c2aa41 Add factory functions for sandbox and fake server\nec74e94 Add support for passing a function to stub.throws(...). (#1511)\n\nThere are 69 commits in total.\nSee the full diff\n\n. ## Version 3.2.0 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nRelease Notes\nAdd stub#resolvesThis\n\nFix #1521 by caching references to Array.prototype.filter (#1523)\nFix #1368 by adding stub#resolvesThis (#1517)\n\n\n\nCommits\nThe new version differs by 84 commits.\n\nf1d6e75 Update docs/changelog.md and set new release id in docs/_config.yml\nf6374e8 Add release documentation for v3.2.0\n1b81ec6 3.2.0\naea2654 Update Changelog.txt and AUTHORS for new release\n81c23fb Merge pull request #1523 from fatso83/1521-stub-array-filter-fails\n052a2d0 Add requirements to pull request template\n56ca580 Cache other references to Array.prototype.filter\n531f872 Cache reference to filter in stubbing calls\n3df68a7 fixes issue #1368 by adding stub#resolvesThis (#1517)\n6689cab Merge pull request #1522 from sinonjs/centered-readme-header-with-logo\nbe66ebb Fix \"npm based CDNs\" link\nb005f1d Contered header with logo in readme\n996d502 Merge pull request #1520 from fatso83/jsdelivr\nb376dcf Add hints on using CDNs in docs and README\n3ad5e05 Add props for default file in CDN delivery\n\nThere are 84 commits in total.\nSee the full diff\n\n. ## Version 3.2.1 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nCommits\nThe new version differs by 99 commits.\n\ndbef9aa Update docs/changelog.md and set new release id in docs/_config.yml\n97b0535 Add release documentation for v3.2.1\n359e78b 3.2.1\n590ae7d Update Changelog.txt and AUTHORS for new release\nd9cae73 Merge pull request #1532 from EyalAr/master\n4f40409 fix fakeServerWithClock.create function mock to return a unique value\n4310343 Merge pull request #1533 from noisecapella/gs/fix_undefined\nf87b512 resolvesThis should override previous throws\na85a355 fix tests that stub nise.fakeServer.create & fakeServerWithClock.create\n5c3fb95 preserve context of functions from nise: fakeServer, fakeServerWithClock\nb509f4e add tests for issue #1531\n28bcedc Merge pull request #1530 from noisecapella/gs/regression_onfirstcall\n7b53434 Fix regression for issue #1526 regarding onFirstCall().throws()\n350717d Remove superfluous \n2a04615 Fix docs regression introduced by #1523\n\nThere are 99 commits in total.\nSee the full diff\n\n. ## Version 3.3.0 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nCommits\nThe new version differs by 123 commits.\n\ne9f40a2 Rename Changelog.txt to History.md\n40edb3e Update docs/changelog.md and set new release id in docs/_config.yml\n27986c8 Add release documentation for v3.3.0\n85f30b5 3.3.0\n7d45683 Update Changelog.txt and AUTHORS for new release\n10906a7 Merge pull request #1560 from servel333/nested_property_matcher\na54b38c Fixes docs for error.\n04ba963 Adds sinon.match.hasNested\n5fbd9ee Merge pull request #1549 from killmenot/fix-1442\n0a34cf5 Merge pull request #1550 from kuba-orlik/patch-1\na90f3ce Merge pull request #1558 from fatso83/fix-eslint-error\n32e4516 Update code to stricter linting\n212e91d Fix eslint peerDependencies error\n5606815 Fix double backticks in inline code examples\naf30213 fix #1442\n\nThere are 123 commits in total.\nSee the full diff\n\n. ## Version 4.0.2 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nCommits\nThe new version differs by 171 commits.\n\n39e5737 Update docs/changelog.md and set new release id in docs/_config.yml\nc2bd7b1 Add release documentation for v4.0.2\nda24e94 4.0.2\ncea60e8 Update History.md and AUTHORS for new release\nd4dcfca Document the stub.reset breaking change (#1590)\naab1917 Merge pull request #1596 from mroderick/fix-preversion-to-use-history.md\n5dbe685 Update 'nise' to latest version (#1593)\n578b9ea Update History.md and AUTHORS for new release\n499b698 Fix preversion.sh to stage History.md\n1e5fd0f Remove unneeded characters\n2a69d51 fix typo in contributing\n6cc71ec Document how to trigger progress events (#1585)\ne49fcf1 Fix broken test-coverage task\n527086a Use supports-color module to test if system supports colors\n78782b4 Merge pull request #1580 from mroderick/dependency-hygeine\n\nThere are 171 commits in total.\nSee the full diff\n\n. After pinning to 3.2.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 3.2.2 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n9960d23 Version 3.2.2\n0741fd4 Merge pull request #536 from amcasey/patch-1\ne6b1b51 Accept typescript >=2.6.0-dev\nd8e7b68 Merge pull request #530 from willpracht/patch-1\nfadb714 Fixing spelling error\n\nSee the full diff\n\n. ## Version 3.2.3 just got published. \nYour tests are passing again with this version. Explicitly upgrade to this version \ud83d\ude80 \n\nRelease Notes\nv3.2.3 - Support TS 2.7-dev\nAdds support for 2.7-dev builds of TypeScript.\n\n\nCommits\nThe new version differs by 8 commits.\n\n6914e22 Version 3.2.3\n74b69f6 Merge pull request #542 from Kingwl/master\n9244073 Accept typescript >=2.7.0-dev\n9960d23 Version 3.2.2\n0741fd4 Merge pull request #536 from amcasey/patch-1\ne6b1b51 Accept typescript >=2.6.0-dev\nd8e7b68 Merge pull request #530 from willpracht/patch-1\nfadb714 Fixing spelling error\n\nSee the full diff\n\n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 16 commits.\n\nec9126c Update docs/changelog.md and set new release id in docs/_config.yml\n1222a0f Add release documentation for v4.0.1\n1bf1f2d 4.0.1\n1545c26 Update History.md and AUTHORS for new release\ne9fab2d Merge pull request #1579 from fatso83/upgrade-deps\nf2252b4 Upgrade nise and lolex versions\nd81a937 Fix doc typo: scenarious -> scenarios\naf3a645 Merge pull request #1577 from evan-007/fix_doc_typo\n7c9c881 Remove extra backtick from fake-xhr-and-server docs\ncf9bf05 Merge pull request #1575 from mroderick/tidy-up-docs\n2e8abad Remove obsoleted lib/sinon/sandbox-stub.js\n28e70d1 Use an include for migration guides\n3c68adc Move migration guides to new section\n6197ff3 Merge pull request #1565 from fatso83/patch-docs\ndfb9ee6 Add migration guide for 4.0\n\nThere are 16 commits in total.\nSee the full diff\n\n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.0.1\n4.0.1 / 2017-10-05\n\ud83d\udc1b Fixes\n\n#3051: Upgrade Growl to v1.10.3 to fix its peer dep problems (@dpogue)\n\n\n\nCommits\nThe new version differs by 6 commits.\n\neb8bf8d Release v4.0.1\n3b485ea update CHANGELOG.md for v4.0.1 [ci skip]\n96e5c1a upgrade eslint to v4.8.0\nd7cff37 Update growl to 1.10.3\n0cdd921 remove preversion script; test on publish; closes #2999\nf49c0ce Fix changelog issues/pr URLs (#3047)\n\nSee the full diff\n\n. After pinning to 5.7.0 your tests are passing again. Downgrade this dependency \ud83d\udccc.. ## Version 1.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\ncba63e2 1.1.2\n9e56f5b Revert vinyl update (needs major)\n\nSee the full diff\n\n. ## Version 2.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n502f2e5 2.0.0\n9248440 Upgrade vinyl & tests\n\nSee the full diff\n\n. ## Version 5.9.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv5.9.1\n\ud83d\udee0 Bugfixes\n\n[bugfix] Removed extraneous deprecation warning produced when using tslint:recommended or tslint:latest by disabling typeof-compare in these rulesets. (#3639)\n[bugfix] Resolve directories as absolute paths when validating custom rulesDirectory paths, which fixes usage with tslint-loader. (#3640)\n\n\n. ## Version 4.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits.\n\nf7139e7 Update docs/changelog.md and set new release id in docs/_config.yml\n0b75f10 Add release documentation for v4.3.0\n66603e7 4.3.0\n2bee64e Update History.md and AUTHORS for new release\nc45032e Update package-lock.json\nc27e714 add docs\n5459212 add calledOnceWith\nbeea2f6 simplify nested if statements\n3e7edca add calledOnceWithExactly assertion\n\nSee the full diff\n\n. ## Version 4.4.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n99ef3fa Update docs/changelog.md and set new release id in docs/_config.yml\n2075fda Add release documentation for v4.4.2\n5ac4eae 4.4.2\ne0bfd43 Update History.md and AUTHORS for new release\n5a2f19f Add descriptive error message on attempt to call argument that is not a function\n\nSee the full diff\n\n. ## Version 4.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 5.0.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv5.0.4\n5.0.4 / 2018-03-07\n\ud83d\udc1b Fixes\n\n#3265: Fixes regression in \"watch\" functionality introduced in v5.0.2 (@outsideris)\n\n\n\nCommits\nThe new version differs by 3 commits.\n\n851ad29 Release v5.0.4\n868830a update CHANGELOG.md for v5.0.4 [ci skip]\neb09421 restore removed methods which still used\n\nSee the full diff\n\n. ## Version 4.4.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n988df0c Update docs/changelog.md and set new release id in docs/_config.yml\n2c2f245 Add release documentation for v4.4.6\n0b51a76 4.4.6\nfa11833 Update History.md and AUTHORS for new release\ne5e6835 Return returned value of invokant when using yields* and callsArg* (#1724)\n\nSee the full diff\n\n. ## Version 5.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 2.4.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits.\n\nfbf2f06 Normalize end-of-line in JS files\n\nSee the full diff\n\n. ## Version 5.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits.\n\n68883b0 Update docs/changelog.md and set new release id in docs/_config.yml\n6c20e74 Add release documentation for v5.0.2\n415c78f 5.0.2\n1a31c0e Update History.md and AUTHORS for new release\n6b47a83 Fix #1770: Reset history on sandbox reset\n7d1eff1 Remove bithound (#1773)\n32484d2 Fix broken link in docs\n93d182f Add link to sinon.replace from fake\n92dc963 Add missing links for documentation\n\nSee the full diff\n\n. ## Version 5.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits.\n\n5155c01 Update docs/changelog.md and set new release id in docs/_config.yml\n75ffac0 Add release documentation for v5.0.3\n347eeb5 5.0.3\n454d77d Update History.md and AUTHORS for new release\n2a3696d Fix #1775: Default sandbox does not restore stubs, spies, mocks\n724dd6c Improve documentation for fakes\nf45dc6e Removed unused link to the google group\n80eca7a Update home page to use fakes for the examples\n57fac55 Fix syntax error in example\n\nSee the full diff\n\n. ## Version 5.0.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 12 commits.\n\n374f593 Update docs/changelog.md and set new release id in docs/_config.yml\nf298d51 Add release documentation for v5.0.5\n90a4212 5.0.5\n7055663 Update History.md and AUTHORS for new release\ne5b43de Refuse to replace already replaced values\nd4467e7 Update docs/changelog.md and set new release id in docs/_config.yml\n7e08393 Add release documentation for v5.0.4\n6fcf7b2 5.0.4\nb8d65ff Update History.md and AUTHORS for new release\n3a66331 Fix #1781: Reject non-function values a f argument to fake\n5503f73 Remove node@4, add node@10\ncfccaf3 Update migration-guides.md\n\nSee the full diff\n\n. ## Version 5.0.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\nc0eb019 Update docs/changelog.md and set new release id in docs/_config.yml\n4b33872 Add release documentation for v5.0.6\n2d6900d 5.0.6\na22c3f0 Update History.md and AUTHORS for new release\n8f34417 Remove support-sinon.js as postinstall\n\nSee the full diff\n\n. ## Version 5.0.10 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits.\n\n4313d2d Update docs/changelog.md and set new release id in docs/_config.yml\ne21c92a Add release documentation for v5.0.10\n41d0dcb 5.0.10\n928379c Update History.md and AUTHORS for new release\n5ca48d3 Merge pull request #1802 from ifrost/feature/restore-default-sandbox-fake-timers\n087bc1c Cache reverse function\nd19a4c0 Add issue number\n6799e1c Use fakeTimers in the default sandbox\n8b6f8a8 Revert spied fakeTimers to original state\n\nSee the full diff\n\n. ## Version 3.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.0.1\nChangelog: https://github.com/inikulin/publish-please/blob/master/CHANGELOG.md#301---2018-06-05\n\n\nCommits\nThe new version differs by 35 commits.\n\n59a1d92 doc(CHANGELOG): update documentation\n0089df4 test(guard): fix typo\n961680f test(guard): fix test on windows CI\nc870e65 chore(ci): try fix test on windows CI\n877fa15 chore(ci): try fix test on windows CI\nbd5f0e6 test(guard): try fix test on windows CI\nbf88811 chore(ci): configure AppVeyor\nac30db6 test(integration): reminder on code that is not cross-platform\n4ea11d9 style(chalk): take a color that is cross-platform friendly\n7961424 fix(validation): make the code cross-platform\nfa0d464 chore(npm): make the script cross-platform\n45cbe3a test(coverage): ensure coverage will not drop under 90%\n684a2db fix(publish): ensure test does not modify tracked files\n0a9aad5 test(install): add unit test on post-install\ne2c513d fix(install): fix warning message when doing 'npm install' in dev mode\n\nThere are 35 commits in total.\nSee the full diff\n\n. ## Version 3.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.0.2\nChangelog: https://github.com/inikulin/publish-please/blob/master/CHANGELOG.md#302---2018-06-12\n\n\nCommits\nThe new version differs by 5 commits.\n\n84fe250 test(vulnerability): add test to ensure coverage does not drop\n639c49a fix(pr): finalize pr\nd5782c0 chore clean formatting\n4354f4c fix inability to configure exceptions to security warnings via .nsprc file\nf76ce2c Merge pull request #61 from hdorgeval/pr/issue#60\n\nSee the full diff\n\n. ## Version 3.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.0.3\nChangelog: https://github.com/inikulin/publish-please/blob/master/CHANGELOG.md#303---2018-06-20\n\n\nCommits\nThe new version differs by 5 commits.\n\ne577774 doc(CHANGELOG): update documentation\n246436f style(publish): apply prettier\nfa35730 Merge branch 'master' into pr-npm3.10.10\n0049ce5 fix(install): fix preinstall on npm 3.10.10\n7aebc56 Merge pull request #65 from franksrevenge/master\n\nSee the full diff\n\n. ## Version 3.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.1.0\nChangelog: https://github.com/inikulin/publish-please/blob/master/CHANGELOG.md#310---2018-06-21\n\n\nCommits\nThe new version differs by 39 commits.\n\n442cf93 doc(CHANGELOG): update documentation\n361d884 Merge branch 'master' into pr/dry-mode\ne456dc3 Merge pull request #68 from hdorgeval/pr-npm3.10.10\n324e3e9 doc(CHANGELOG): update documentation\nf232337 feat(dry-run): be able to use dry-run on the publish-please repo itself\n7b32a74 doc(dry-run): update dry-run demo\n13e2519 style(dry-run): add blank line\nc3facd0 test(integration): clean code\n6939a0c fix(config): make the cli testable on the config option\n58fb78c refactor(publish): move guard function to a module\n61f661d test(publish): remove duplicated code\n296df4b test(dry-run): add unit test for --dry-run option\n1b64bac chore(config): prevent tests to loop for eternity when testing is done on the repo itself\n59d4459 test(dry-run): add integration test\n107b0ce fix(dry-run): in dry mode default answer to confirm questions is always yes\n\nThere are 39 commits in total.\nSee the full diff\n\n. ## Version 3.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.1.1\nChangelog: https://github.com/inikulin/publish-please/blob/master/CHANGELOG.md#311---2018-07-01\n\n\nCommits\nThe new version differs by 19 commits.\n\nc32dbcb doc(CHANGELOG): update documentation\n0e09b84 refactor(publish): be more expressive in variable names to have a more readable code\ne6870c3 refactor(publish): be more expressive in variable names to have a more readable code\n7a932bc refactor(publish): be more expressive in variable names to have a more readable code\nefbca3d doc(publish): update documentation\nd1a0ca5 chore(coverage): ensure coverage will not drop under 96%\n8fe6849 doc(CHANGELOG): update documentation\n3076c8c test(publish): fix failing tests\need5784 fix(publish): gracefully handle prepublish vs prepublishOnly script when installing publish-please\n1fdef7f refactor(publish): extract more code to  new module\nb106340 test(publish): fix test that was green for bad reason\n179829a refactor(publish): extract node and npm current versions into a separate module\n6092851 test(publish): try fix failed test on node6\n684932f chore(lint): remove unused eslint configuration\n672dcdd chore(ci): update node versions\n\nThere are 19 commits in total.\nSee the full diff\n\n. ## Version 3.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.2.0\nChangelog: https://github.com/inikulin/publish-please/blob/master/CHANGELOG.md#320---2018-07-15\n\n\nCommits\nThe new version differs by 37 commits.\n\n816ab12 doc(npx): update documentation\na466442 doc(npx): update documentation\nab64d8f test(npx): fix tests that are red for bad reason\n6f72afb test(npx): fix tests that are red for bad reason\nd1d3318 test(npx): fix tests that are red for bad reason\nde1aca9 test(npx): add unit tests\nf366f91 test(npx): fix test on windows CI\ncb974c5 test(npx): add integration tests for 'npx publish-please'\n5c352ea test(npx): fix test on windows CI\n8f912a2 test(npx): add test for 'npx publish-please'\n7bc9b73 test(npx): add integration test for 'npx publish-please config'\n018eece feat(npx): be able to run the command 'npx publish-please config'\na6bad61 feat(npx): be able to parse the command 'npx publish-please config'\n37b0377 test(npx): add integration test for the command 'npx publish-please --dry-run'\nf48f3d9 test(npx): add integration test for the command 'npx publish-please --dry-run'\n\nThere are 37 commits in total.\nSee the full diff\n\n. ## Version 5.0.0-alpha.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n5.0.0-alpha.3 - Fix fullReporter\nFixes the full reporter (#581)\n\n\nCommits\nThe new version differs by 4 commits.\n\nb39e93b Version 5.0.0-alpha.3\na0a0d4a Update release\ned1f19f Merge pull request #582 from chapterjason/master\n9bfa670 Fixed ansi-colors dependency\n\nSee the full diff\n\n. - The devDependency @types/sinon was updated from 5.0.2 to 5.0.4.\nUpdate to this version instead \ud83d\ude80. - The devDependency @types/sinon was updated from 5.0.2 to 5.0.5.\nUpdate to this version instead \ud83d\ude80. - The devDependency publish-please was updated from 4.0.0 to 4.1.0.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v4.1.0\nChangelog: https://github.com/inikulin/publish-please/blob/master/CHANGELOG.md#410---2018-10-13\n\n\nCommits\nThe new version differs by 8 commits.\n\n9db25b1 test(branch-validation): fix test\n4e2ab18 doc(branch-validation): update documentation\nf8b870c test(branch-validation): add test to check the validation is working on both  'release' and 'master' branches\n2603761 test(branch-validation): fix and add test to check the validation is working on both  'release' and 'master' branches\nbd84b5f Merge branch 'master' into master\nb5c40da chore(npm): bump version to v4.1.0\n95c6f55 Merge pull request #79 from hdorgeval/pr-update-inquirer\n4f96a46 feat(validation): add branch validation via regular expression\n\nSee the full diff\n\n. - The devDependency karma was updated from 3.0.0 to 3.1.1.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v3.1.1\nBug Fixes\n\nconfig: move puppeteer from dependency to dev-dependency (#3193) (f0d52ad), closes #3191\n\n\n\nCommits\nThe new version differs by 2 commits.\n\n361aa3f chore: release v3.1.1\nf0d52ad fix(config): move puppeteer from dependency to dev-dependency (#3193)\n\nSee the full diff\n\n. - The devDependency karma was updated from 3.0.0 to 3.1.2.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v3.1.2\nBug Fixes\n\nbrowser: report errors to console during singleRun=false (#3209) (30ff73b), closes #3131\nchangelog: remove release which does not exist (#3214) (4e87902)\ndep: Bump useragent to fix HeadlessChrome version (#3201) (240209f), closes #2762\ndeps: upgrade sinon-chai 2.x -> 3.x (#3207) (dc5f5de)\nfile-list: do not preprocess up-to-date files (#3196) (5334d1a), closes #2829\npackage: bump lodash version (#3203) (d38f344), closes #3177\nserver: use flatted for json.stringify (#3220) (fb05fb1), closes #3215\n\nFeatures\n\ndocs: callout the key debug strategies. (#3219) (2682bff)\n\n\n\nCommits\nThe new version differs by 11 commits.\n\n7d4d347 chore: release v3.1.2\n5077c18 chore: update contributors\nfb05fb1 fix(server): use flatted for json.stringify (#3220)\n2682bff feat(docs): callout the key debug strategies. (#3219)\n4e87902 fix(changelog): remove release which does not exist (#3214)\n30ff73b fix(browser): report errors to console during singleRun=false (#3209)\n5334d1a fix(file-list): do not preprocess up-to-date files (#3196)\ndc5f5de fix(deps): upgrade sinon-chai 2.x -> 3.x (#3207)\nd38f344 fix(package): bump lodash version (#3203)\nffb41f9 refactor(browser): log state transitions in debug (#3202)\n240209f fix(dep): Bump useragent to fix HeadlessChrome version (#3201)\n\nSee the full diff\n\n. - The devDependency karma was updated from 3.0.0 to 3.1.3.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v3.1.3\nBug Fixes\n\nadd missing dep flatted (#3223) (655d4d2)\n\n\n\nCommits\nThe new version differs by 3 commits.\n\n169f3a9 chore: release v3.1.3\n6f351a5 chore: update contributors\n655d4d2 fix: add missing dep flatted (#3223)\n\nSee the full diff\n\n. - The devDependency publish-please was updated from 4.1.0 to 5.1.0.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v5.1.0\nChangelog: https://github.com/inikulin/publish-please/blob/master/CHANGELOG.md#510---2018-10-29\n\n\nCommits\nThe new version differs by 18 commits.\n\n1411a9a doc(CHANGELOG): update release date\nc789cca chore(npm): remove 'promisify-event' dependency\nf9cfc7d chore(npm): update 'should' dependency\n52703e0 chore(npm): update 'mocha' dependency\n3a88330 chore(npm): update linter and prettier dependencies\n844bcfe chore(npm): update 'semver' dependency\nf5f9e8c chore(npm): remove 'pkgd' and 'read-pkg' dependencies in favour of an internal package reader\n4b7c7fb chore(npm): remove pinkie-promise dependency\nb081dbd chore(npm): pin version of 'cp-sugar' dependency\n8723258 chore(CI): revert node 11 on appveyor\nffda864 chore(CI): fix appveyor configuration\n98b41cf chore(CI): fix appveyor configuration\n9b1be1a chore(CI): load node 11 x64 instead of x32\n5f03cd1 chore(npm): update lodash dependency\nad00997 chore(CI): add node 11 in build matrix\n\nThere are 18 commits in total.\nSee the full diff\n\n. - The devDependency publish-please was updated from 4.1.0 to 5.1.1.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v5.1.1\nChangelog: https://github.com/inikulin/publish-please/blob/master/CHANGELOG.md#511---2018-10-30\n\n\nCommits\nThe new version differs by 5 commits.\n\nd4b3b0a doc(CHANGELOG): update release date\n31c55b9 test(sensitive-data): fix test to work on all npm versions\n5b2dc40 fix(sensitive-data): remove auto-generated package tar file\n855e693 chore(release): bump version to 5.1.1\nd96eca5 Merge pull request #81 from hdorgeval/pr-update-dependencies\n\nSee the full diff\n\n. - The devDependency publish-please was updated from 4.1.0 to 5.2.0.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v5.2.0\nChangelog: https://github.com/inikulin/publish-please/blob/master/CHANGELOG.md#520---2018-11-04\n\n\nCommits\nThe new version differs by 10 commits.\n\nd94b72b test(sensitive-data): fix test on Windows CI\nc825cd2 doc(sensitive-data): update release date\nedd3b92 doc(sensitive-data): update documentation\n05a99ba test(sensitive-data): test npx usage with custom .sensitivedata file\n4018a60 test(sensitive-data): add test for private ssh key\n8a1c1cb doc(sensitive-data): update documentation\nd1b8c5d feat(sensitive-data): be able to override .sensitivedata on per project basis\n1404d82 doc(sensitive-data): update documentation\n83f78da chore(release): bump version to v5.2.0\n4f8284a Merge pull request #83 from hdorgeval/pr-fix-sensitive-data\n\nSee the full diff\n\n. - The devDependency @types/sinon was updated from 5.0.5 to 5.0.7.\nUpdate to this version instead \ud83d\ude80. - The devDependency publish-please was updated from 5.1.1 to 5.4.0.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n779838e chore(release): bump version to v5.4.0\n403ad3e Merge pull request #85 from hdorgeval/pr-ci-reporter\n\nSee the full diff\n\n. - The devDependency publish-please was updated from 5.1.1 to 5.4.1.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v5.4.1\nChangelog: https://github.com/inikulin/publish-please/blob/master/CHANGELOG.md#541---2018-11-26\n\n\nCommits\nThe new version differs by 8 commits.\n\nbc54b3e fix(release): bump version to v5.4.1\n1cb4ff0 Merge pull request #87 from hdorgeval/pr-dry-run\n570e386 chore(release): change release date\nefab306 test(dry-run): fix tests on npm version < 6.1.0\n29689df refacto(publish): simplify dry-run workflow\nab7e7cc fix(publish): report correct message on successfully published package\nbdbcc90 doc(release): update release date and changes\nd842d06 feat(publish): do not prompt user on dry run\n\nSee the full diff\n\n. - The devDependency publish-please was updated from 5.1.1 to 5.4.2.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v5.4.2\nChangelog: https://github.com/inikulin/publish-please/blob/master/CHANGELOG.md#542---2018-11-29\n\n\nCommits\nThe new version differs by 6 commits.\n\n77f1354 chore(release): update release date\nd3eff9a test(ci-reporter): add tests for Teamcity\nbc30888 feat(ci-reporter): be able to show custom icons when running in Teamcity\n898ed66 feat(reporter): be able to have specific success/error icons for Teamcity\n6fbcfdb feat(reporter): be able to detect TeamCity CI env\n7c847fb chore(release): bump version to v5.4.2\n\nSee the full diff\n\n. - The devDependency publish-please was updated from 5.1.1 to 5.4.3.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v5.4.3\nChangelog: https://github.com/inikulin/publish-please/blob/master/CHANGELOG.md#543---2018-12-02\n\n\nCommits\nThe new version differs by 20 commits.\n\n2538124 chore(release): update release date\nce43a82 doc(README): add gif demo\n010ae2d doc(media): remove unused media files\n8dada4e doc(publish): revamp documentation\nb695bac doc(publish): revamp documentation\n0b48262 doc(publish): revamp documentation\nc9e072e doc(publish): revamp documentation\n7ddf61d doc(publish): revamp documentation\n046bcf4 doc(publish): revamp documentation\ne257332 doc(publish): revamp documentation\na54abd8 doc(publish): revamp documentation\ncf5b231 doc(publish): revamp documentation\n116f504 doc(publish): revamp documentation\nc8c1c65 doc(publish): revamp documentation\n3fe5112 doc(publish): revamp documentation\n\nThere are 20 commits in total.\nSee the full diff\n\n. - The devDependency gulp-typescript was updated from 4.0.2 to 5.0.1.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v5.0.1 - Resolve @types in node_modules above current directory\n\nFixes #563\n\n\n\nCommits\nThe new version differs by 6 commits.\n\nd0410c2 v5.0.1\nd88aacb Update baselines\nea22fb7 Merge pull request #610 from lddubeau/fix/relative-config-path\n2551704 Generate a new release.\n1f9302a Pass the full path of the configuration file.\n4c27021 Add a test for #563\n\nSee the full diff\n\n. - The devDependency @types/sinon was updated from 7.0.0 to 7.0.2.\nUpdate to this version instead \ud83d\ude80. - The devDependency @types/sinon was updated from 7.0.0 to 7.0.3.\nUpdate to this version instead \ud83d\ude80. - The devDependency @types/sinon was updated from 7.0.0 to 7.0.5.\nUpdate to this version instead \ud83d\ude80. - The devDependency @types/sinon was updated from 7.0.5 to 7.0.7.\nUpdate to this version instead \ud83d\ude80. - The devDependency @types/sinon was updated from 7.0.5 to 7.0.8.\nUpdate to this version instead \ud83d\ude80. - The devDependency @types/sinon was updated from 7.0.5 to 7.0.9.\nUpdate to this version instead \ud83d\ude80. - The devDependency @types/sinon was updated from 7.0.5 to 7.0.10.\nUpdate to this version instead \ud83d\ude80. - The devDependency sinon was updated from 7.2.3 to 7.2.5.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 8 commits.\n\n8b8bddd Update docs/changelog.md and set new release id in docs/_config.yml\n33f0b67 Add release documentation for v7.2.5\n2b4bc7d 7.2.5\nfb54e29 Update CHANGELOG.md and AUTHORS for new release\n8ac68f3 Upgrade mochify to latest\nadd43e3 Upgrade @sinonjs/samsam to latest\nd0c073c don't call extends.nonEnum in spy.resetHistory (#1984)\nf99e2ef Use stable Chrome in Circle\n\nSee the full diff\n\n. - The devDependency sinon was updated from 7.2.3 to 7.2.6.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\n0468cd4 Update docs/changelog.md and set new release id in docs/_config.yml\n7f2c8c2 Add release documentation for v7.2.6\n36b99b3 7.2.6\n1fc586e Update CHANGELOG.md and AUTHORS for new release\nc8758fd Upgrade @sinonjs/formatio\ne24daed Set fake.lastArg to last argument regardless of type\n\nSee the full diff\n\n. - The devDependency sinon was updated from 7.2.3 to 7.2.7.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits.\n\n4a8f432 Update docs/changelog.md and set new release id in docs/_config.yml\n714911e Add release documentation for v7.2.7\n33ca39b 7.2.7\ne8b997f Update CHANGELOG.md and AUTHORS for new release\n7913865 Update @sinonjs/commons @sinonjs/formatio\n19b3fc7 Retain spy function names and fix spy.named(name) (#1987)\n3275d18 Document spying on accessors (#1976)\n\nSee the full diff\n\n. - The devDependency mocha was updated from 5.2.0 to 6.0.1.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v6.0.1\n6.0.1 / 2019-02-21\nThe obligatory round of post-major-release bugfixes.\n\ud83d\udc1b Fixes\nThese issues were regressions.\n\n#3754 - Mocha again finds test.js when run without arguments (@plroebuck)\n#3756 - Mocha again supports third-party interfaces via --ui (@boneskull)\n#3755 - Fix broken --watch (@boneskull)\n#3759 - Fix unwelcome deprecation notice when Mocha run against languages (CoffeeScript) with implicit return statements; returning a non-undefined value from a describe callback is no longer considered deprecated (@boneskull)\n\n\ud83d\udcd6 Documentation\n\n#3738 - Upgrade to @mocha/docdash@2 (@tendonstrength)\n#3751 - Use preferred names for example config files (@Szauka)\n\n\n\nCommits\nThe new version differs by 9 commits.\n\n6d3d6b4 Release v6.0.1\n2146ece update CHANGELOG.md for v6.0.1\n7c9221d backout deprecation of value returned from suite; closes #3744\nb7cfceb fix --watch not finding any files to execute; closes #3748\nb836d73 Upgrade docdash version - issue #3663\n7926f47 fix --ui issues, closes #3746\n00f2ed9 dev dep upgrades from \"npm audit\" and \"npm upgrade\"\n34afb1a fix(cli/run.js): Revert default glob to match Mocha-5.2\n6d5a0db Bring the example congfiguration file in line with the documentation. (#3751)\n\nSee the full diff\n\n. - The devDependency mocha was updated from 5.2.0 to 6.0.2.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for v6.0.2\n6.0.2 / 2019-02-25\n\ud83d\udc1b Fixes\nTwo more regressions fixed:\n\n#3768: Test file paths no longer dropped from mocha.opts (@boneskull)\n#3767: --require does not break on module names that look like certain node flags (@boneskull)\n\n\n\nCommits\nThe new version differs by 6 commits.\n\n00a895f Release v6.0.2\n1edce76 update CHANGELOG for v6.0.2 [ci skip]\n347e9db fix broken positional arguments in config; ensure positional args are unique; closes #3763\n9e31e9d fix handling of bareword args matching node flags; closes #3761\n6535965 Update \"karma-browserify\" to eliminate Karma middleware warning (#3762)\n37febb6 improve issue template. (#3411)\n\nSee the full diff\n\n. ",
    "abettadapur": "Thank you! That will be very helpful. ",
    "gms1": "cool! Many thanks!. ",
    "gCardinal": "I was hoping I had been fast enough that you didn't get the notification!\nYes I did post something, I was having a problem I couldn't figure out and thought maybe my implementation of your solution was flawed, but it turns out it was simply a silly mistake that I eventually fixed.\nThat being said, I got the factory working! Your example was great and helped me understand InversifyJS a bit more. It's still a bit weird to me how some things are handled, I'm just too used to the way Symfony does dependency injection, but overall this project is growing on me! Thank you for the help and the great library.. So, I kept working on other stuff while I was waiting on your answer (I didn't expect to have one today) and then tried your test. And... it works.\nNow, I'm unsure as to what makes it so it works now, but... it does. I sure won't complain.\nSorry for the ID-10T error!. ",
    "jdinh-mackevision": "@remojansen \nWould this pattern be equivalent to using the Make Provide Decorator utility?\nFound here...https://github.com/inversify/inversify-binding-decorators. ",
    "ChrLipp": "Sounds great!\nThe only downside for the ASP.NET way is that the tests for the controller have to be output-format aware. I would prefer that the selection of the format is based on the header (+1). Is it something like this (only json case implemented)?\nprivate handlerFactory(controllerName: any, key: string): express.RequestHandler {\n    return (req: express.Request, res: express.Response, next: express.NextFunction) => {\n        let result: any = this.container.getNamed(TYPE.Controller, controllerName)[key](req, res, next);\n        // try to resolve promise\n        if (result && result instanceof Promise) {\n            result\n                .then((value: any) => {\n                    if (value && !res.headersSent) {\n                        this.sendResult(req, res, value);\n                    }\n                })\n                .catch((error: any) => {\n                    next(error);\n                });\n\n        } else if (result && !res.headersSent) {\n            this.sendResult(req, res, result);\n        }\n    };\n}\n\nprivate sendResult(req: express.Request, res: express.Response, result: any) {\n    switch (req.accepts(\"xml\", \"json\")) {\n        case \"json\":\n            res.json(result);\n            break;\n        default:\n            res.send(result);\n    }\n}\n\nWorks for me.. I did some tests and have some remarks:\n\nif no accept header is given, express already sets the Content-Type based on the type of the payload. So if I return an Object, express sets the Content-Type already to 'application/json' regardless of the Accept header. I didn't know this.\nThis means that the header stuff is only needed if I return e.g. a string and want it converted to json.\nIf I want to allow only JSON and the client doesn't send the JSON Accept header I would like to block the request. This would not work within the current solution, but can be easily solved with a custom middleware which just returns 403 when the Accept header is missing.\nThe xml case (which I didn't implement) is not trivial since I need a serializer. Ideally the user is able to register his own serialization infrastructure.\n\nSo what do you say? Is an implementation still necessary with express standard functionality?\nIf you want I can send you a PR with the current code (no XML handling) , but at the moment I am not sure if the change is needed at all - the user just has to return an Object.\n. ",
    "riggerthegeek": "Aaah, that'll explain it @remojansen. I'm using v3.0.\nIs that the case with Restify?\nIn fairness, it does largely seem to work with Inversify 3 as I've done a full end-to-end with it on Restify. Yeah, it works with Inversify v2.x.x.\nI'll leave for you to close the issue, but I'm a happy chappie with v2. Thanks. Apologies @remojansen, that hasn't fixed the issue (I was mistakenly using the version I was going to add to a PR).\nIf you look in the /src/server.ts file, line 82 is:\nlet result: any = this.container.getNamed(TYPE.Controller, controllerName)[key](req, res, next);\n\nThis line needs to be wrapped in a try/catch. Is it worth me submitting a PR with a fix?. If you create a controller as this:\n@Controller('/foo')\n@injectable()\nexport class FooController implements Controller {\n\n    constructor( @inject('FooService') private fooService: FooService ) {}\n\n    @Get('/')\n    private index(req: restify.Request): string {\n        throw new Error(\"some error\");\n    }\n\n}\nMy server is going into a spin and never resolving. If I replace that with return Promise.reject(\"some error\") it's fine, but it won't work when trying to handle uncaught exceptions due to my idiocy. @lholznagel I'm of the opinion that, as it's already checking for a promise/callback error it should also check for a try/catch. \n@remojansen I wouldn't want Inversify to decide. That's why the app.on(\"uncaughtException\") middleware exists. @lholznagel I don't think we need to do that as Restify and Express already handle that as they do a cb('err') or Promise.reject('err').\nPR will be incoming - I'm on a train at the moment so WiFi keeps cutting out. Hmmmm, it's failed the CI stage. It seems that most of the failures are pre-existing stuff - have I taken it from the wrong branch? (I took from master). I would suggest we do need it on the Express utils. I'll do a PR at some point in the next 24 hours. If anyone gets to it before me, the handlerFactory method appears to be exactly the same in both packages.. Hello chaps, I have bad news.  I think I may have wasted everyone's time on this for which I profusely apologise. I think there is still an issue, but it's not the one I first thought it was.\nWhen I came in this morning and installed the update, it was still failing to first the uncaughtException event. I've traced through what's happening and it appears that it's sending the issue up through the middleware that I'm setting using the @Get decorator.\nMy middleware (largely stubbed) is as follows (it's a PassportJS strategy).\nController\n@Get('/', [\n      (req, res, cb) => passport.authenticate('basic', { session: false })(req, res, cb),\n    ])\n    index () {\n      throw new Error('some error')\n    }\n}\nMiddleware\nexport default fooService => {\n    return new BasicStrategy((email, pass, cb) => {\n        fooService.login(emailAddress, password)\n           .then(user => {\n                if (user) {\n                    cb(null, user);\n                } else {\n                    cb(null, false);\n                }\n          }).catch(err => {\n              console.log('auth');\n              console.log(err);\n              cb(err);\n          });\n    });\n}\nThe fooService returns a promise, but the strategy is resolving a callback so I'm not returning the promise. My console is showing the 'auth' message and the error that should be thrown up the route which leads me to think that the middleware is misconfigured.\nCertainly what I have determined is that the PR I submitted for this issue was wrong as it never fires the restify uncaughtException listener.\nCan anyone suggest how to solve this problem?. This isn't a Passport issue. It's an issue with using a promise in middleware when resolving a callback. I get exactly the same when stripping out the passport stuff\n@Get('/', [\n        (req, res, cb) => {\n        fooService.login('email', 'pass')\n          .then(user => {\n            if (user) {\n              cb(null, user);\n            } else {\n              cb(null, false);\n            }\n          }).catch(err => {\n          console.log(\"auth\");\n          // console.log(err);\n          cb(err);\n        });\n        }\n    ])\n    index () {\n      throw new Error('some error')\n    }\n}\nfooService is resolved in the Constructor declaration, but still the same file as in the passport example. Right, this is me with egg on my face. It is as issue, but it's an issue with restify not with the utils.\nPlease accept my apologies for wasting everyone's time. I would use the excuse of tight-project deadlines for not checking my stuff properly.\n\nIn answer to your question @remojansen, I'm using ES6 not TypeScript. export default fooService gets compiled as export default function(fooService) - that's what's coming in from my injector. ",
    "marvinroger": "I first started with using Symbols as IDs and it worked great, but I wanted to see if I could simplify the flow of having to specify IMqttClient, Symbol('IMqttClient'), MqttClient. So I thought using the class as the ID would simplify everything. I also thought the IoC principle could be kept, e.g. by doing something like that in the context of a test for example:\njs\ncontainer.bind<IMqttClient>(MqttClient).to(MqttClientShim).inSingletonScope()\nAnd that it would be smart enough to guess the MqttClient or MqttClientShim depending of the context would \"fit\" into the IMqttClient contructor parameter. That's a lot of bad thoughts!\nAnyway, thanks for your extensive answer, and for your great project. That's definitely a game changer.. There's definitely something wrong here. I have a sample project that shows the circular dependency message. The git diff (before and after error message) is here: https://github.com/marvinroger/iot/compare/bc2d7b84b916d33366fbb9addd0b935c1a1b687c...7ee14cca69bef026f88ada38e826b824961b8be9\nI added two classes: WsBroadcaster and RequestResponder, and they don't have any circular dependency. Also, weird thing: if you remove the WsServer injection in WsBroadcaster, the issue disappears - even though WsServerand WsBroadcaster don't require each other -.. ",
    "basickarl": "Nvm, found the answer after some digging!\nhttps://github.com/inversify/InversifyJS/blob/master/wiki/basic_js_example.md. @remojansen Ooo interesting! From seeing the examples I don't see ES2016 decorators anywhere, any reason for this?\nExample instead of the following:\nclass MyClass { ... }\ninversify.decorate(inversify.injectable(), MyClass);\nYou'd write\n@injectable()\nclass MyClass { ... }. @remojansen Ah! Glad to hear it will be compatible in the future! :) I guess I'll stick with the vanilla helpers until then, thanks!. My bad it was me who has misunderstood export.\nexport default should be just export.. ",
    "hkarimpoor": "As I mention above there is a module which is called \"vhost\"  make able to do this approach but I need to do this routing by decorators or if there is no way ,using a way to inject this middleware ( ex: vhost) into each controller. ( I prefer the first one ,doing by decorators). @lholznagel thanks but @Get(vhost('cms.local')) doesnot work.\n@remojansen  my final goal is writing different controller which routes based on domain and subdomain for example : \nif user type  cms.mydomain.com   route to  admin home page \nif user type  cms.mydomain.com/customer/add   route to  admin  adding customer page \n.\n.\n.\nif user type  mydomain.com route to normal website home page .\nhow can I achieve this approach by writing something like this : \n@injectable()\n@Controller('cms/')\nexport class HomeController {\n     @Get('/customer/add')\n      public  get(req:express.Request,res:express.Response) {  \n   }\n}. Any Suggestion ? I am really need this feature if you can help . @remojansen  thanks for reply, I confirm express-subdomain could be really helpful.\nOR express-vhost or any other middleware which can search against domain part.\nMy Expectation:\ncms.example.localhost ->   redirect to CMS home pages\ncms.example.localhost/products ->   redirect to CMS productspages that Admin can edit products\nwww.example.localhost ->  redirect to normal website home page\nwww.example.localhost/products  ->  redirect to normal website products page that only displays products list\nabcd.example.localhost ->   redirect to  not found page\n. ",
    "AlexanderKiriluyk": "@remojansen A very necessary thing.\nFor example, I used vhost in my projects.\nIt would be very cool if you implement this feature. @lholznagel Thanks, this works great!. ",
    "ivan-shaban": "I checked patch and i think it is better to implement in different way. Yes, for now i will able to unbind something in module, but how do i know that i should do that? I don't see any ability to check is there binding exists( So i propose to pass in module optional \"override strategy\" function, it will solve override situations, for now i see possible scenarios:\n- throw error is binding exists (default)\n- override old binding with new binding (useful when you wanna update config)\n- skip new binding if old exists (to prevent update, but do not throw error)\nThere are probably more strategies or user event may write own strategy if he need it. What do you think about it?. Hi, sorry for late answer, in comment above i'm not talking about sealed bindings, i'm talking about bindings management. I check tests and, i think, i understand how library works, as i understand in container configuration i can make several binginds with the same serviceIdentifier (e.g. to use Multi-injection), but formally i get error only when i try to get bad-mapped-instance. IMHO it is bad behaviour, because it is hard to understand when i really make mistake, probably i manually type wrong binding, or mb i have few modules where the same serviceIdentifier was used, dunno. But if we will check bindings when we configure container it will be more explicit, what do you think about it?. ",
    "fdnhkj": "I am facing the same issue with reflect-metadata v0.1.9.\nAfter reading release notes for that version, I see no breaking changes  (cc @rbuckton).\nAs it is affecting a release version, wouldn't it be good to publish a hotfix forcing version of reflect-metadata at max v0.1.8 ?\nThanks @endel for reporting it and for the temporary solution!\nI was investigating this issue for quite some hours and was not suspecting reflect-metadata at all!\nYou saved me some other debugging session hours!\nPS: I am wondering why inversifyJS doesn't have reflect-metadata in its dependencies. Can someone please help me understanding ? Thanks :). ",
    "fyodorvi": "I'm using this:\ninversifyContainer.bind = <any>_.wrap(inversifyContainer.bind, (originalBind, ...rest: any[]) => {\n    const binding = originalBind.apply(inversifyContainer, rest);\n    binding._binding.onActivation = (context, instance) => {\n        wireInstanceConfig(instance);\n        return instance;\n    };\n    return binding;\n});\nTerribly dirty, I know, but that's the only way for now.. ",
    "Moln": "I need this feature, too.. ",
    "ajeffrey": "I also use factory classes with a create(...) method in a lot of my code. Perhaps a generic solution would be to add a toFactoryClass<T>(f: interfaces.FactoryClass<T>) method, with a new FactoryClass interface:\ntypescript\ninterface FactoryClass<T> {\n  create(...args: any[]): T;\n};\nI can put together a pull request this weekend if you want :)\n(I don't know if this fully solves OP's problem, but it seems linked). @Podlas29 perhaps we could combine our requirements into a sensible common interface - adding the toFactoryClass binding (which behaves like toFactory but with .create instead of accepting a raw function), then having a function that can make bound factories automatically provide their objects if the factory takes no arguments. Just a shorthand for bind<IInstance>('IInstance').toDynamicValue((ctx) => ctx.container.get<IFactory>('IFactory').create());. what about having the config be blank by default, loaded with values by another class, then proceeding to start up your app?\ne.g.\n```typescript\n// config.ts\n@injectable()\nexport class Config implements IConfig {\n  private _values: {};\n  constructor() {\n    this._values = {};\n  }\n  // stuff\n  load(values: {}) {\n    this._values = values;\n  }\n  // stuff\n};\n// config-loader.ts\n@injectable()\nexport class ConfigLoader implements IConfigLoader {\n  constructor(@inject('IConfig') private _config) {}\n  async load() {\n    // pull config down, asynchronously\n    this._config.load(somedata);\n  }\n};\n// ./index.ts\nconst loader = container.get(TYPES.IConfigLoader);\nloader.load().then(() => {\n  // config is now populated, we can use classes that depend on it\n});\n// ./inversify.config.ts\n// [import & cie]\ncontainer.bind(TYPES.IConfig).to(Config).inSingletonScope();\ncontainer.bind(TYPES.IConfigLoader).to(ConfigLoader);\n// [other bindings]\n```\nthat way the only thing you have to change is your startup script. You can also avoid having to dirty your application logic with DI code.. ",
    "mpodlasin": "@ajeffrey just to be clear - I want to go one step further - I do not want to just bind factories easily. I also want them to actually create instances without additional boilerplate (calling create by hand in config or in actual classes where such instance is needed).\nI would imagine adding such feature would be quite involved from api standpoint (for example how singletion/transient scope for both factory and instance should be specified).. ",
    "Elminday": "@mpodlasin @ajeffrey @remojansen  what is the status?. @dcavanagh any ideas?. ",
    "Pyo25": "Thanks for the reply @remojansen. \nBased on your suggestion, I see two possibilities: using a constant value or using a singleton. \nThe drawback I see of using a constant value is that we spread bindings over 2 different files (index.ts and inversify.config.ts).\nWhat do you think? \nWith a constant value\n```ts\n// ./index.ts\nimport \"reflect-metadata\";\nimport { IConfig } from \"./config\";\nimport { Config } from \"./config/config\";\nimport { container } from \"./inversify.config\";\nimport {\u00a0IService} from \"./service\";\nimport {\u00a0TYPES\u00a0} from \"./types\";\nlet config = new Config();\nconfig.initialize()\n  .then((cfg) => container.bind(TYPES.IConfig).toConstantValue(cfg))\n  .then(() => container.get(TYPES.IService).initialize())\n  .catch((err) => {\n    console.error(\"fatal error\", err);\n    process.exit(1);\n  });\n// ./inversify.config.ts\n// nothing about IConfig nor Config\n```\nWith a singleton\n```ts\n// ./index.ts\nimport \"reflect-metadata\";\nimport { IConfig } from \"./config\";\nimport { container } from \"./inversify.config\";\nimport {\u00a0IService} from \"./service\";\nimport {\u00a0TYPES\u00a0} from \"./types\";\nlet config = container.get(TYPES.IConfig);\nconfig.initialize()\n  .then(() => container.get(TYPES.IService).initialize())\n  .catch((err) => {\n    console.error(\"fatal error\", err);\n    process.exit(1);\n  });\n// ./inversify.config.ts\n// [import & cie]\ncontainer.bind(TYPES.IConfig).to(Config).inSingletonScope();\n// [other bindings]\n```. Hi @ajeffrey! Your solution seems nice as well. Thx for proposing it. \nOn my side I finally went for the singleton option (without a loader).. ",
    "ognus": "Thanks @remojansen :)\nI must be missing something, but how specifying single custom router would solve https://github.com/inversify/InversifyJS/issues/456? Shouldn't each controller need it's own custom router for different subdomain?\nAt the moment there is a new router created for each controller, do you suggest to nest those routers under custom this.router like so?\n```\ncontrollers.forEach((controller: interfaces.Controller) => {\n...\nif (controllerMetadata && methodMetadata) {\n    let router: express.Router = express.Router();\n...\n\nthis.router.use(controllerMetadata.path, ...controllerMetadata.middleware, router);\n\n}\n}\nthis.app.use('/', this.router);\n```. @remojansen thanks, appreciate that :) looks good \ud83d\udc4d . ",
    "JonathanYates": "I managed to get this working from the recipe in here\nhttps://github.com/inversify/InversifyJS/blob/master/wiki/recipes.md\nIs this the correct way to do it?\n. ",
    "drew-r": "+1 on an easier way to overwrite bindings.\nIf you're swapping out dependencies for testing it becomes very verbal very quickly. ",
    "mtfranchetto": "Yes, but also with the ability to override the dependencies passed to the base service.\nYou can have a look at this where you can find a Java example regarding the construction of the instances (Window is the HttpClient of the previous code):\njava\nWindow decoratedWindow = new HorizontalScrollBarDecorator (\n                new VerticalScrollBarDecorator (new SimpleWindow()));\nI was thinking about an elegant solution to do this in inversify with the ability to override bindings in kernel modules.. Rebind is definitely an improvement. Looking forward to have rebind support for tagged constraints in order to cover all of ours use cases.\nThanks for your incredible work and time.. Any update on this feature?. ",
    "maxmalov": "@remojansen I'd really like to, but I'm fairly new with inversify, so I will definitely need you help and review at the start. \nI'm common with current approach of injecting middleware, but have a few concerns about it. Since right not it is possible to inject express request handlers only you cannot control how the middleware is being created. I've done some digging already and come up to the following motivation:\n\nI need to stub middleware during testing\nI need to inject entities to middleware. For instance, we have authorization middleware which will validate user's roles and a service responsible for authorization. So I want to inject a service to middleware somehow. And since I'm fairly new with inversify the only solution I see now is to use factories:\n\n```ts\n// middleware factory definition\nexport interface AuthMiddlewareFactory {\n  (authService: AuthService): express.RequestHandler;\n}\nfunction makeAuthMiddleware(authService): express.RequestHandler {\n  return (req, res, next) => {\n    // ...\n  };\n}\nts\n// configuration\ncontainer.bind(\"AuthService\").toSelf();\ncontainer.bind(\"AuthMiddlewareFactory\").toConstantValue(makeAuthMiddleware);\ncontainer.bind>(\"Factory\").toFactory((context: interfaces.Context) => {\n    return () => {\n        let service = context.container.get(\"AuthService\");\n        let makeAuthMiddleware = context.container.get(\"AuthMiddlewareFactory\");\n        return makeAuthMiddleware(service);\n    };\n});\n```\nWell, this is a lot of code for a single middleware and a lot of manual dependency resolutions which complicates this solution. So this is the point I stuck at, but I guess there should be another way.... Wow, @remojansen, thanks for detailed explanation :+1:. I'll play around with it and see what I can do.. @remojansen I've tried different approaches you've described previously (about the way of injecting middlewares). So I put all my current findings and thoughts below:\nA) Inject middleware via @Controller and @Method decorators\nhere is the diff https://github.com/inversify/inversify-express-utils/compare/master...maxmalov:middleware-injection-compat\nand how it'll look like\n```ts\nlet plain = (req, res, next) => { ... };\nlet stringId = \"foo\";\nlet symbolId = Symbol(\"bar\"); \n@Controller(\"/\", plain, stringId, symbolId)\nclass Controller {\n  @Get(\"/\", plain, stringId, symbolId)\n  public getTest(req, res) { ... }\n}\n```\nThis is the easiest way to implement and use as a developer later in the code, I guess. Besides it does not break compatibility with current version of express utils. The main pro of this approach is that developer can specify order of middleware in an intuitive way (I'll cover that later in second approach).\nB) Inject middleware via new @Middleware decorator\nHere comes the tricky part, because order of decorators is really matters, ex\nts\n@Controller(\"/\")\n@Middleware(Middleware1)\n@Middleware(Middleware2)\nclass Controller {}\nSo @Middleware cannot easily share the same metadata object with @Controller decorator, since it will be applied first. We need to store this metadata separately, that's okay. But there is also ambiguity related to the order; in the example above, @Middleware(Middleware2) will be applied before @Middleware(Middleware1). So we have a reverse order of middleware list and should keep this in mind later. I guess this is obvious for experienced developers, but not so much for starters. Since the order of middleware in express apps does really matter, there should be obvious way for developer to specify this order. @Middleware decorator can take a list, and overwrite the list of middleware each time it was applied, but it will be the same as case A), then.\nHere is the diff with kind of in progress state (only controller level middleware injection) https://github.com/inversify/inversify-express-utils/compare/master...maxmalov:middleware-injection-decorator\nWhat do you think about these (at this moment I don't cover injecting entities to middleware :ghost:)?. ",
    "mitjarogl": "@maxmalov, @remojansen  Hey, great work. Is it possible to add this same feature into inversify-restify-utils package? Thanks.. \ud83d\udc4d \n. @remojansen This issue has been resolved. Can you please build npm package inversify-restify-utils so new updates will be available. Thanks :). ",
    "cguillemette": "Just for the record, I had this problem and it was caused by Typescript. I flushed the /ts-node folder and it worked then.. ",
    "kevelbreh": "Hi @cguillemette, how would I go about flushing the ts-node folder doing this?. ",
    "sebastian-zarzycki-es": "How is the progress coming along with this? Can I help in any way? (test, etc.). Fantastic! I will definitely check it out as soon as it's available.. I'm not sure I follow. \nthis._someProperty; // declare it this way or it won't work :(\nWhat does it mean exactly? Declare it what way? In constructor or with underscore?\nAlso, I'm not sure how related to my original issue - https://github.com/inversify/InversifyJS/issues/514 - where I was asking whether it's possible to use decorators in vanillajs, to achieve similar effect. I believe it's doable, but either I cannot find proper syntax, or something's not supported yet. Could you please refer to that?. Why does this._someProperty = null; cause lazy injection to fail? Because the value is already defined? Would assignment to undefined help? Why do you keep using the underscore in the examples - is it significant?\nAlso, I was under the impression that lazyInject already is a decorator and it has , as specified in https://github.com/inversify/inversify-inject-decorators package. So I'm even more confused here. My idea was to use the syntax as presented in #514, using @lazyInject. I guess I'm having a hard time with understanding the difference. Are TS decorators not the same thing as Babel's? If not, how would I go about making it compatible? Couldn't I annotate properties directly, using the syntax in #514?. Kind of, thanks. My main goal is to avoid specifying the (MyComponent.prototype, \"_someProperty\") part. If decorator decorates a property, then that property name and the class it belongs to, should already be passed into the decorator for use. It seems that I would have to figure out that part on my own.. I do, yes. Specifically - \"babel-plugin-transform-decorators-legacy\" plugin. . Ouch, more issues. When using lazyInject (even as function, for now), even though the actual inject works, it seems to break the default MobX @observable functionality - I think there are some getter conflicts. I'm beginning to doubt it could all coexist - mobx/react/inversify, that is :(. Yeah. I guess I can work around this by injecting one property and then assigning it to another @observable property. A bit clunky, but doable.\nStill, using lazyInject as decorator would be nice, nonetheless. Do you think there's a way to do this?. Thanks for answer. My underlying question, though, was: how do I proceed for now, without this feature being implemented?. Thank you, I sure do appreciate this!. ",
    "aligajani": "As you say. But React isn't in TypeScript ...\nOn Mon, Feb 13, 2017 at 9:31 AM Remo H. Jansen notifications@github.com\nwrote:\n\nClosed #492 https://github.com/inversify/InversifyJS/issues/492.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/inversify/InversifyJS/issues/492#event-959253556, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/ABpo2mFVoIpdjf9WqngBCz2QatcZp_X6ks5rcCLrgaJpZM4L-m3G\n.\n-- \n\nAli Gajani\nFounder at Mr. Geek\nwww.mrgeek.me\nwww.aligajani.com\n. ",
    "aksharpatel47": "Apologies. I only took into account the documentation in the readme. I was under the impression that only request object is available in the method. After looking through the source code and the tests I realized my mistake. Closing the issue.. ",
    "agalazis": "Here is fiddle that demonstrates the difference between creating the object with new and creating it with inversify:\nhttps://jsfiddle.net/bv4eb3rL/2/\n(check the console logs)\nBy the way it's not a huge issue, updating the docs with a warning and to use multi-inject to achieve this  with real arrays could also help some people,  but I understand that there could be some edge-cases where people might need this (once again a warning could do at least)\n. ",
    "Deviad": "Same problem here.\n. Hello,\nI have the same issue but with MongoClient. My goal would be to have something like this\n------ generic-client.ts ------\n```\nimport { Db, ObjectID } from 'mongodb';\nimport { injectable } from 'inversify';\nimport { MongoDBConnection } from '../services/database.service';\n@injectable()\nexport class GenericClient {\n    public db: Db;\nconstructor() {\n    MongoDBConnection.getConnection((connection) => {\n        this.db = connection;\n    });\n}\n\npublic find(collection: string, filter: Object, result: (error: Error, data: any) => void): void {\n   return this.db.collection(collection).find(filter).toArray((error, find) => {\n        return result(error, find);\n    });\n}\n\npublic findOneById(collection: string, objectId: string, result: (error: Error, data: any) => void): void {\n    return this.db.collection(collection).find({ _id: new ObjectID(objectId) }).limit(1).toArray((error, find) => {\n        return result(error, find[0]);\n    });\n}\n\npublic insert(collection: string, model: any, result: (error: Error, data: any) => void): void {\n    this.db.collection(collection).insertOne(model, (error, insert) => {\n        return result(error, insert.ops[0]);\n    });\n}\n\npublic update(collection: string, objectId: string, model: any, result: (error: Error, data: any) => void): void {\n    this.db.collection(collection).updateOne(\n        { _id: new ObjectID(objectId) },\n        { $set: model },\n        (error, update) => result(error, model)\n    );\n}\n\npublic remove(collection: string, objectId: string, result: (error: Error, data: any) => void): void {\n    this.db.collection(collection).deleteOne({ _id: new ObjectID(objectId) }, (error, remove) => {\n        return result(error, remove);\n    });\n}\n\n}\nexport default GenericClient;\n----- generic-DAO.ts -----\nimport { inject, injectable } from 'inversify';\nimport GenericClient from './generic-client';\nimport IGenericEntity from '../interfaces';\n@injectable()\nexport class GenericDAO {\n    private _genericClient: GenericClient;\n    private _model: string;\nconstructor(\n   genericClient: GenericClient,\n   model: string\n) {\n    this._genericClient = genericClient;\n    this._model = model;\n}\n\npublic getUsers(): Promise<T[]> {\n    return new Promise<T[]>((resolve, reject) => {\n        this._genericClient.find(this._model, {}, (error, data: T[]) => {\n            resolve(data);\n        });\n    });\n}\n\npublic getUser(id: string): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n        this._genericClient.findOneById(this._model, id, (error, data: T) => {\n            resolve(data);\n        });\n    });\n}\n\npublic newUser(user: T): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n        this._genericClient.insert(this._model, user, (error, data: T) => {\n            resolve(data);\n        });\n    });\n}\n\npublic updateUser(id: string, user: T): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n        this._genericClient.update(this._model, id, user, (error, data: T) => {\n            resolve(data);\n        });\n    });\n}\n\npublic deleteUser(id: string): Promise<any> {\n    return new Promise<any>((resolve, reject) => {\n        this._genericClient.remove(this._model, id, (error, data: any) => {\n            resolve(data);\n        });\n    });\n}\n\n}\nexport default GenericDAO;\n```\n----- user-DAO.ts ------\n```\nimport { inject, injectable } from 'inversify';\nimport GenericClient from './generic-client';\nimport TYPES from '../constants/types';\nimport IGenericEntity from '../interfaces';\nimport GenericDAO from './generic-DAO';\n@injectable()\nexport class UserDAO extends GenericDAO {\n    private _dbClient: GenericClient;\n    private _userModel: string;\nconstructor(\n    @inject(TYPES.GenericClient) genericClient: GenericClient,\n    model: string\n) {\n    super(genericClient, model);\n    this._dbClient = genericClient;\n    this._userModel = model;\n}\n\n}\nexport default UserDAO;\n```\nThe problem is when I have in app.ts\ncontainer.bind>(TYPES.UserDAO).to( GenericDAO);\nAny ideas? How can I apply the above idea as per @rmblstrp suggestion?. I had to install ts-helpers and enable support for them in tsconfig \"importHelpers\": true,\n. Yes, correct. Thank you.\n. ",
    "KerryRitter": "I don't believe I ever resolved this issue, sorry I can't provide suggestions. ",
    "ssljivic": "Thanks.. ",
    "rulai-hu": "@Dirrk @remojansen Thanks for responding!\n@Dirrk I considered the Inversify helper route, but ultimately no matter how many levels of abstraction I use, Inversify.decorate is secretly pulling the strings in the background of the file. I also considered 'centralizing' all the Inversify-related boilerplate, e.g. in Container Modules, but imo spreading information about a single class to multiple files is a difficult design decision to make.\nI wanted a solution where classes can exist independently of Inversify or its helpers, trading for that with a useless static method (without Inversify to interpret it).\n@remojansen That would definitely work. Being able to intercepting the point before metadata is read would make a clean and direct solution feasible.. ",
    "veeramarni": "I think I found the answer for it here and will give a try.. I'm trying to find a way to pass the constructor argument. For example, if we instantiate the class outside inversify we do the following way. But with inversify to instantiate, how to achieve this?\nconst env = new SettignsTestEnvironmentService(args, path, customAppSettingsHome);\n. @remojansen \nIf I'm not wrong, I can do the following, right?\n```\ncontainer.bind(\"IEnvironmentService\")\n         .toValue(new SettignsTestEnvironmentService(args, path, customAppSettingsHome));\n``. Thanks for clarifying. What if we have mixed one like the following. How to passPlatform` argument into the constructor.\nts\n@injectable()\nexport class ConfigurationService<T> \n    extends Disposable implements IConfigurationService, IDisposable {\n    constructor(\n                private _platform: Platform, \n        @inject('environmentService') environmentService: IEnvironmentService\n    ) {\n        super();\n    }\n   ....\n}. @remojansen \nThat worked very well, I think using a Factory is very clean. Thanks for this amazing package. . @remojansen \nI think we should reduce the boilerplate code especially if we have Hierarchical DI system and we need to expose child's Interfaces and Symbols by parent classes to instantiate the child classes.\nCan we accomplish the same thing similar to createInstance in\nhttps://github.com/veeramarni/vscode/blob/master/src/vs/platform/instantiation/common/instantiationService.ts ?\nI have checked this note, but can we inject something like serviceInstance to the child classes instead of creating a new container to reduce the boilerplate code as above. \nPlease let me know your feedback. . Oh great! I could inject Container. That's what I was looking for. This would be very helpful, do you want me to add this example to your tests?. I have the same issue with jest. Wondering if anyone finds a way.. I have noticed this is something not yet added to the feature. Only ServiceIdentifier or RequestHanlder functions are only workable based on #487 . Tried as per #487, I think i can skip this issue. . ",
    "khorvat": "Hi,\nI have added lines below to my configuration and helper methods are gone. Thanks for the hint.\n\"importHelpers\": true,\n\"noEmitHelpers\": true. Yes, thanks. ",
    "viktor1190": "Sorry for my bad english redaction, I need to practice it, hehe, Yes, that is my question, I will try it and give you my feedback.. I only added those lines to my Server implementation:\ndecorate(injectable(), Hapi.Server);\ndecorate(unmanaged(), Hapi.Server, 1);\n\nthe output is:\n/Users/****/git/nodejs/myproject/node_modules/inversify/lib/planning/planner.js:107\n            throw new Error(error.message);\n            ^\nError: Missing required @injectable annotation in: Anonymous function: function (options) {\nHoek.assert(this instanceof internals.Server, 'Server must be instantiated using new');\n\noptions = Schema.apply('server', options || {});\n\nthis._settings = Hoek.applyToDefaultsWithShallow(Defaults.server, options, ['connections.routes.bind']);\nthis._settings.connections = Hoek.applyToDefaultsWithShallow(Defaults.connection, this._settings.connections || {}, ['routes.bind']);\nthis._settings.connections.routes.cors = Hoek.applyToDefaults(Defaults.cors, this._settings.connections.routes.cors);\nthis._settings.connections.routes.security = Hoek.applyToDefaults(Defaults.security, this._settings.connections.routes.security);\n\nthis._caches = {};                                                              // Cache clients\nthis._handlers = {};                                                            // Registered handlers\nthis._methods = new Methods(this);\nhis._events = new Podium([{ name: 'log', tags: true }, 'start', 'stop']);      // Server-only events\nthis._dependencies = [];                                                        // Plugin dependencies\nthis._registrations = {};                                                       // Tracks plugins registered before connection added\nthis._heavy = new Heavy(this._settings.load);\nthis._mime = new Mimos(this._settings.mime);\nthis._replier = new Reply();\nthis._requestor = new Request();\nthis._decorations = {};\nthis._plugins = {};                                                             // Exposed plugin properties by name\nthis._app = {};\nthis._registring = false;                                                       // true while register() is waiting for plugin callbacks\nthis._state = 'stopped';                                                        // 'stopped', 'initializing', 'initialized', 'starting', 'started', 'stopping', 'invalid'\n\nthis._extensionsSeq = 0;                                                        // Used to keep absolute order of extensions based on the order added across locations\nthis._extensions = {\n    onPreStart: new Ext('onPreStart', this),\n    onPostStart: new Ext('onPostStart', this),\n    onPreStop: new Ext('onPreStop', this),\n    onPostStop: new Ext('onPostStop', this)\n};\n\nif (options.cache) {\n    this._createCache(options.cache);\n}\nif (!this._caches._default) {\n    this._createCache([{ engine: CatboxMemory }]);                              // Defaults to memory-based\n}\n\nPlugin.call(this, this, [], '', null);\n\n// Subscribe to server log events\n\nif (this._settings.debug) {\n    const debug = (request, event) => {\n\n        const data = event.data;\n        console.error('Debug:', event.tags.join(', '), (data ? '\\n    ' + (data.stack || (typeof data === 'object' ? Hoek.stringify(data) : data)) : ''));\n    };\n\n    if (this._settings.debug.log) {\n        this._events.on({ name: 'log', filter: this._settings.debug.log }, (event) => debug(null, event));\n    }\n\n    if (this._settings.debug.request) {\n        this.on({ name: 'request', filter: this._settings.debug.request }, debug);\n        this.on({ name: 'request-internal', filter: this._settings.debug.request }, debug);\n    }\n}\n\n}.\nat _createSubRequests (/Users/*/git/nodejs/myproject/node_modules/inversify/lib/planning/planner.js:107:19)\n    at Object.plan (/Users//git/nodejs/myproject/node_modules/inversify/lib/planning/planner.js:126:5)\n    at /Users/*/git/nodejs/myproject/node_modules/inversify/lib/container/container.js:228:37\n    at Kernel.Container._get (/Users//git/nodejs/myproject/node_modules/inversify/lib/container/container.js:221:44)\n    at Kernel.Container.get (/Users/*/git/nodejs/myproject/node_modules/inversify/lib/container/container.js:180:21)\n    at Object. (/Users/*/git/nodejs/myproject/build/app/index.js:21:24)\n    at Module._compile (module.js:570:32)\n    at Object.Module._extensions..js (module.js:579:10)\n    at Module.load (module.js:487:32)\n    at tryModuleLoad (module.js:446:12)\nat ChildProcess.exithandler (child_process.js:206:12)\nat emitTwo (events.js:106:13)\nat ChildProcess.emit (events.js:191:7)\nat maybeClose (internal/child_process.js:877:16)\nat Socket.<anonymous> (internal/child_process.js:334:11)\nat emitOne (events.js:96:13)\nat Socket.emit (events.js:188:7)\nat Pipe._handle.close [as _onclose] (net.js:498:12)\n\n.....\n19 verbose node v6.9.5\n20 verbose npm  v4.4.4. Thank you very much, it has served me well..\n",
    "mueees": "Thanks for the answer.\nIn your example, the logger is not injected automatically to the new user instance. \nI could do it manually, like this:\n```javascript\n@injectable()\nclass UseFactory {\n    @inject(Logger) private logger: Logger;\n    @inject(\"UserConstructor\") private User: { new(): User };\n    public create(name: string) {\n        const user = new this.User();\n    user.logger = this.logger;\n\n    return user;\n}\n\n}\n``\nbut is there any way to do it automatically based on@inject(Logger) private logger: Logger;` annotation? \nThanks\n. OK, I got it.\nThanks. ",
    "dcavanagh": "@remojansen What was the project? . The problem is with gulp-mocha ^4.0. https://github.com/sindresorhus/gulp-mocha/issues/159\nI tried reverting gulp-mocha to ^3.0 and the code coverage worked again.. @remojansen What if you check that the coverage report is not empty?\nThis fails the build\nvar report = require('./coverage/coverage-final.json');\n    if (Object.keys(report).length === 0) {\n        throw new Error(\"no test coverage\");\n    }\n    return ret;. @remojansen \nit looks like you are getting the default behavior which adds req, res, next to the end of the arguments array that is passed to the RoleFeatureController.delete method. That \nwhat is the value of \"authServerPaths.server.roleFeature.endpoints.delete\"?\nwhat is the value of request.params? \nThe request.params object must contain an \"role_id\" and \"feature_id\" property\nit is working for me using this code. \n@Delete('/:id/:feature_id')\n    public deleteJob(@RequestParam('id') roleId: string,\n        @RequestParam('feature_id') featureId: string,\n        @Request() req: express.Request,\n        @Response() res: express.Response): Promise<Message> {\n        return  this.jobService.deleteJob(roleId);\n    }. @remojansen  I'm still having trouble reproducing the problem\nOn Thu, Apr 6, 2017 at 12:00 PM, Remo H. Jansen notifications@github.com\nwrote:\n\nClosed #527 https://github.com/inversify/InversifyJS/issues/527 via\ninversify/inversify-express-utils@bd16e7a\nhttps://github.com/inversify/inversify-express-utils/commit/bd16e7a751a7f51e5969163a78d7ccd8870808b9\n.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/inversify/InversifyJS/issues/527#event-1032497651,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AKvP2Lz_btk9Vrny7v5qLIhuq2JhaGW8ks5rtQwtgaJpZM4M1iM-\n.\n. Ok.. I will try that. I just wanted to reproduce it so I could understand why it was going wrong.. @remojansen Looks great! I was able to reproduce the problem. Sorry for all the trouble.. @remojansen Sounds great!. I think that the problem is that the @QueryParam(\"paramName\") decorator can only ever be a string because it is looking up the \"paramName\" in the query field of the incoming request. The solution should probably be to throw an error if the type is anything but a string.\n\nWe could discuss adding middleware to this if it is a common use case.\n. @requestBody() does not take any arguments. It was intended to supply the body of the request as an object so that you can apply a type to it. So in your case:\nts\ninterface Customer {\n  customerId: number;\n  title: string;\n  firstName: string;\n}\nand the method\nts\n@post('/')\npublic addCustomer (@responseBody() customer: Customer): any {\n  let title = customer.title;\n}. I don't see why not. #161 thanks!. 5.2.2. @guscastro Please feel free to make a PR . I agree! @postConstruct is meant to allow for implementation specific setup. I'm not sure about the order since the onActivation feature can change the behavior of the class if understand it correctly.. Sounds good.. I will add that\nMy only other concern is that i did not add any code to the annotation phase or the plan phase. \nThe resolution phase just checks to see if the POST_CONSTRUCT metadata exists on the prototype and then executes the method that was decorated. @gagle @remojanse \nI was thinking about the preDestroy and came up with 2 possibilities.\n\n\nOnly allow @preDestory to be applied to classes that are in the singleton scope. Throw an error if not. Not sure if this would really be helpful because I haven't ever needed to destroyed a singleton.\n\n\nMaybe have the container maintain a reference to the object and have the consumer notify the container when it no longer needs it? I guess that would be coding by convention and would probably just be easier to have the consumer run the method. @remojansen no problem! thanks for all your help. @remojansen Merging it now would be great. I will take a stab at the refactor. \n\n\nI also need to address the documentation. I was thinking of adding a \"Life cycle hooks\" file to the wiki. Would that be appropriate?\nI've been having a problem debugging the unit tests in vsCode. Do you use a specific setup for this?. I figured out how to debug the mocha tests in vscode. \n`{\n    // Use IntelliSense to learn about possible Node.js debug attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n\"version\": \"0.2.0\",\n\"configurations\": [\n    {\n        \"type\": \"node\",\n        \"request\": \"launch\",\n        \"name\": \"Mocha Tests\",\n        \"program\": \"${workspaceRoot}/node_modules/mocha/bin/_mocha\",\n        \"args\": [\n            \"--require\",\n            \"reflect-metadata\",\n            \"-u\",\n            \"tdd\",\n            \"--timeout\",\n            \"999999\",\n            \"--colors\",\n            \"${workspaceRoot}/test/**/*.js\"\n        ],\n        \"internalConsoleOptions\": \"openOnSessionStart\"\n    },\n    {\n        \"type\": \"node\",\n        \"request\": \"launch\",\n        \"name\": \"Launch Program\",\n        \"program\": \"${workspaceRoot}/lib/inversify.js\",\n        \"outFiles\": [\n            \"${workspaceRoot}/out/**/*.js\"\n        ]\n    }\n]\n\n}\n`. @remojansen Great!  I was a little dejected when the other test failed. Do we want to lock all the dependencies?. Would this work?. closing issue because PR was merged. Thanks!. I don't think that this is possible in typescript \nFooController<A> is a type not a class.\n. https://github.com/inversify/inversify-restify-utils/pull/101. @Josh-ES \nThe @httpPut function is looking for an express.RequestHandler as its second input. This is used as express middleware.\nthe type signature of express.RequestHandler is \n(req: Request, res: Response, next: NextFunction): any;\nthe value that you are passing is not a function it is the return value of passport.authenticate\nthe way that I handle this is to have a separate middleware function\n```\nfunction authenticationMiddleware(req: Request, res: Response, next: NextFunction) {\n    passport.authenticate(....);\n}\n@httpPost(\"/\", authenticationMiddleware)\n...\n```\n. @r0bnet I think what you are looking for is the @requestParam decorator\n@httpGet('/:id')\npublic getStuffById(@requestParam('id') id: string) {}\n@robertmain the decorators are part of the Inversify express utils. @JoshuaKGoldberg  That would be great! . @remojansen I added 2 rules that allow the build to pass. . Pull Request\nThanks!. @kevynb Could you please provide a code sample for your 3.x usage and I will take a look. @kevynb \nWould something like this work?\nlet server = new InversifyExpressServer(container, null, {\n        rootPath: '/'\n    });\n    server.setConfig((app) => {\n          app.use('/api', (req, res, next) => {\n                console.log('api auth');\n                next();\n            });\n            app.use('/admin', (req, res, next) => {\n                console.log('admin auth');\n                next();\n            });\n         let router = express.Router();\n            app.use('/api', router);\n    });\n    let theApp: express.Application = server.build();\n    theApp.listen(appPort);\n    container.bind<express.Application>(TYPES.App).toConstantValue(theApp);. I haven't heard back so I am going to close the issue. Please reopen it if you are still having trouble.. @mactanner I was able to get it to work with a few changes.\none thing was that in the file.on('end', (),... you were putting res.json({ mediaFileId });\nres.json actually sends the response, so if there were two files I would get a \"'Can\\'t set headers after they are sent.'\" error because for the second file the response already left. I moved the res.json to a `busboy.on('finish, () => {}) and just logged the filename in the original.\n@httpPut('/')\n    public addMediaFile(@request() req, @response() res): void {\n        const mediaFileId = 'uuid';\n        const busboy = new Busboy({ headers: req.headers });\n        busboy.on('file', (fieldname, file, filename, encoding, mimetype) => {\n            file.on('data', data => {\n                console.log('File [' + filename + '] got ' + data.length + ' bytes');\n            });\n            file.on('end', () => {\n                console.log('File[' + filename + '] finished');\n            });\n            const writeStream = fs.createWriteStream(filename);\n            file.pipe(writeStream);\n        }).on('finish', () => {\n            res.json({ mediaFileId });\n        });\n        req.pipe(busboy);\n    }. @mactanner were you ever able to get this to work?. @DaZiYuan  The code that you provided does not use any Inversify feature.\nPlease provide some more information and sample code.\nWhat error are you getting?. the problem is in your tsconfig.json. Typescript is not creating the __decorate function in the file.\nset \"noEmitHelpers\": false,. Please provide some more detail. A code sample would really help.\nThanks. Thanks!. thanks!. javascript\nconst optionsVerification = new OptionsVerification({enabled: \"false\"}).validate();\ndoes not invoke anything in inversify. For the dependencies to be fulfilled you need to get the optionsVerification from the container.\nTry\njavascript\n const optionsVerification = myContainer.get< IOptionsVerification >(TYPES. IOptionsVerification);. @kbirger I don't see why this can't be done. Would you like to make a PR?. @kbirger Awesome PR !!! Thanks a lot! Looks like it was a lot of work! #124 \n@remojansen will probably release it sometime today. #161 thanks!. 5.2.2. Thanks!. Thanks!. Thanks!. you need to import \"reflect-metadata\";  once in the tests\n. Here is how i did it recently\n```javascript\n    let UserServiceMock: UserService;\n    let container: Container = null;\nbeforeEach(() => {\n    UserServiceMock = mock(UserServiceImpl);\n    container = new Container();\n    container.bind<UserController>('controller').to(UserController);\n    container.bind<UserService>('userService').toConstantValue(instance(UserServiceMock));\n});\n\nit('Should return a user', () => {\n\n    let userController: UserController = container.get('controller');\n    when(UserServiceMock.getUser('userId')).thenResolve(user);\n\n    userController.getUser('userId')\n        .then((data: User) => {\n            expect(data).to.equal(user);\n        }, (error) => {\n            assert.fail(error);\n        });\n});\n\n. @ashraymehta  You are correct. This should not have been released as a patch and the docs were not updated. My fault. I am sorry for all the trouble. @Bon4ik inversify-express-utils is just express under the hood. If you want to register a global middle-ware you can do it in the config steptypescript\nfunction myMiddleWare(request: express.Request, response: express.Response, next: express.NextFunction) {\n    console.log(HTTP ${request.method} ${request.url});\n    next();\n}\nlet server = new InversifyExpressServer(container);\nserver.setConfig((app) => {\n  app.use(myMiddleWare);\n  app.use(bodyParser.json());\n});\nlet serverInstance = server.build();\nserverInstance.listen(3000);\n```. @kbirger  I'm having some trouble reproducing the error in the test code. Can you please take a look at the test case below? How were you able to produce the 404? \n```typescript\nit(\"should support inherited methods\", (done) => {\n        let container = new Container();\n    @controller(\"/api/test\")\n    class BaseController {\n        @httpGet(\"/public-things\")\n        public getPublicThings() {\n            return { things: [\"a\", \"b\"] };\n        }\n\n    }\n\n    @controller(\"/api/test\")\n    class TestController extends BaseController {\n        constructor(/* deps */) {\n            super(/* deps */);\n        }\n\n        @httpGet(\"/private-things\")\n        public getPrivateThings() {\n            return { things: [\"c\", \"d\"] };\n        }\n    }\n\n    let server = new InversifyExpressServer(container);\n    let app = server.build();\n\n    supertest(app).get(\"/api/test/public-things\")\n        .expect(\"Content-Type\", /json/)\n        .expect(200)\n        .then(response1 => {\n            expect(response1.body.things[0]).to.equal(\"a\");\n        });\n\n    supertest(app).get(\"/api/test/private-things\")\n        .expect(\"Content-Type\", /json/)\n        .expect(200)\n        .then(response1 => {\n            expect(response1.body.things[0]).to.equal(\"c\");\n            done();\n        });\n\n});\n\n```. @kbirger  Thanks.. i missed that I will try it now. @kbirger ~~~I'm still not getting the error.~~~ I got the error!!! Here is the refactored test case that produces the error. \n```typescript\nimport * as supertest from \"supertest\";\nimport { expect } from \"chai\";\nimport { InversifyExpressServer } from \"../src/server\";\nimport { httpGet, controller } from \"../src/decorators\";\nimport { Container } from \"inversify\";\nimport { cleanUpMetadata } from \"../src\";\ndescribe(\"Unit Test: Issue 854\", () => {\nbeforeEach((done) => {\n    cleanUpMetadata();\n    done();\n});\n\nit(\"should support inherited methods\", (done) => {\n    let container = new Container();\n\n    @controller(\"/api/test\")\n    class BaseController {\n        @httpGet(\"/public-things\")\n        public getPublicThings() {\n            return { things: [\"a\", \"b\"] };\n        }\n    }\n\n    @controller(\"/api-int/test\")\n    class TestController extends BaseController {\n        constructor(/* deps */) {\n            super(/* deps */);\n        }\n\n        @httpGet(\"/private-things\")\n        public getPrivateThings() {\n            return { things: [\"c\", \"d\"] };\n        }\n    }\n\n    let server = new InversifyExpressServer(container);\n    let app = server.build();\n\n    supertest(app).get(\"/api-int/test/public-things\")\n        .expect(\"Content-Type\", /json/)\n        .expect(200)\n        .then(response1 => {\n            expect(response1.body.things[0]).to.equal(\"a\");\n        });\n\n    supertest(app).get(\"/api-int/test/private-things\")\n        .expect(\"Content-Type\", /json/)\n        .expect(400)\n        .then(response1 => {\n\n            done();\n        });\n\n});\n\n});\n```\nedit\nPut full code from the bug test file\nStrike through\nThanks for your patience!\n. @tiagoschenkel  I apologize for this error. I will work on releasing it as 5.0.0 instead. @amir-arad were you looking at a specific repository or could you not find it in any of them?  Thanks\n. @Freest10 I got it to build by adding .js to the resolve extensions array\n```javascript\nconst path = require('path');\nconst APP_DIR = path.resolve(__dirname, \"./src/\");\nmodule.exports = {\n    mode: 'development',\n    entry: \"./src/index\",\n    output: {\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js'\n    },\n    resolve: {\n        // Add .ts and .tsx as a resolvable extension.\n        extensions: [\".ts\", \".js\"],\n        modules: [\n            'node_modules'\n        ],\n    },\n    module: {\n        rules: [\n            {\n                test: /.ts$/,\n                use: 'ts-loader'\n            }\n        ]\n    }\n};\n```. Reverted to 4.0.2. @zta192 Can you please recreate this issue in the Inversify repository. We like to track all the issues there\nThanks. @zandroid Released this today. I apologize for the delay. @asdanilenk Which repository did you submit a change to?. I am very sorry for the delay. 4.14.0 has been released. #929 thanks for pointing that out!. Thanks for all the PRs!!!. @bogdan-dumitru this is definitely interesting have you looked into implementing this already? Can we discuss it further?\n. fixed by #978. @remojansen There was a conversation going on between you and @m3l7. can you please advise if this PR is ready?. Thanks for letting us know you figured it out. I am going to close this. Please reopen it if you continue to have problems. @simplegsb  Please submit it as a PR! Do you have unit tests showing that your changes fix the problem?  Thanks\n. @Stnaire can you please share your webpack config? Or a repo set up to recreate the issue?\nThanks. fixed in version 6.2.0 which was just released. sorry for the delay. closed by https://github.com/inversify/inversify-basic-example/pull/56. @lexon This is a good idea Someone else had also asked about it. would you be interested in looking into implementing it?. @remojansen I'm having trouble getting istanbul to run properly in gulp 4.0 this might have to wait for gulp-istanbul to be updated . https://github.com/inversify/inversify-express-utils/commit/062da224e264f8836a67e97d01f0b1ea7373d69c. @tspoke do you think that it should be limited to number and string? . the guid function has been changed to id \nand the property guid has been changed to id on the following interfaces & their implementations \nBinding\nContext\nRequest\nTarget\nContainer\nContainerModule\nAsyncContainerModule. I added the information in #983 . @johnheroy, from a quick look at your example I see something that might be the problem. return observable.pipe(ignoreElements()).toPromise() triggers the response to be sent with the result of that as the body. You might be able to return await observable.pipe(ignoreElements()).toPromise() or something like that. another option would be to return from inside your subscription handler. @justinfagnani do you have any suggestions? \nLet's keep an eye on this Reflect Metadata Issue. @annajolly another option in addition to @gejgalis would be to inject the service in the constructor.\n```ts\n@injectable()\nexport class CustomAuthProvider implements interfaces.AuthProvider {\nconstructor(@inject(AUTH_TYPES.AUTH_SERVICE) private readonly _authService: AuthService) {}\n}\n```. @annajolly I am going to close this. Please reopen if you have more problems. You didn't talk about this in your PR comments. Was this just a test case that you saw was missing?. ",
    "IRCraziestTaxi": "@remojansen Thanks so much for your help! That did the trick. I think I can live with putting extra decorators in my common RepositoryBase.. @remojansen TypedRepo is a class. I forgot to mention that if I make TypedBL a standalone class instead of extending BLBase, then TypedRepo is injected without the need for @inject. It is when TypedBL extends BLBase that @inject becomes necessary.. ",
    "holotrek": "OK, the @unmanaged() decorator works, but I find it a little irritating. If this was needed for an actual functional reason, that would be one thing, but from your explanation, it seems like you are simply annoying those who understand how inheritance works, just to baby those who do not. \nThere are a myriad of ways that an unskilled/ignorant/inept developer could screw up their code, and this is a very strange specific example that you're trying to catch through your infrastructure when really it should be caught by the developer when they're debugging and finding that their parameter value is missing. Besides, if they are using TypeScript and their base class parameters are not optional, it will give them a compilation error, which is where this kind of thing should be found! It is not the responsibility of your library to find it for them.\nP.S. thanks for the library! I find it very helpful to manage dependencies, especially in the request scope.. ",
    "cdibbs": "@remojansen I agree with @holotrek. This is not only out-of-scope for a DI library, but also a design bug. What happens when you have not only A extends ABase, but also, GreaterA extends A? Isn't it valid to have GreaterA pass constant parameters to A's constructor while still wanting Inversify to manage all of A's constructor parameters so A, itself, might be injected?\nHow does Inversify currently satisfy this use-case? Anyway, thanks for a great library.. I am having this issue, also. The list of classes, as @showplans mentioned, doesn't make any sense, with some having no dependencies at all. If I get some time, I'll try to dig deeper and see what's going on.. It would be better to show no list of classes in the circular dependency error than to have the list be inaccurate and send developers on a goose chase. Once I got back to it, this evening, I discovered I did have a circular dependency, but it was not on a class listed by the error message. Resolving that circular dep indeed cleared the error.\nIn case it helps the maintainers: the error was that I accidentally typed @inject(Token_ThisClassItself) rather than the actual dep.\nMy advice to anyone encountering the error: ignore the error message content, and just git diff to see what you've changed recently. :-). Hey, I think I found a way to demo the bug.\n```typescript\nimport { injectable, inject, multiInject, Container } from 'inversify';\nimport 'reflect-metadata';\nlet tokens = {\n    Kernel: Symbol(\"Kernel\"),\n    First: Symbol(\"First\"),\n    Circular: Symbol(\"Circular\"),\n    Irrelevant: Symbol(\"Irrelevant\")\n}\n@injectable()\nclass Real {\n}\n@injectable()\nclass Circular {\n    constructor(\n        @inject(tokens.Circular / my oops /) real: Real\n    ) {}\n}\n@injectable()\nclass First {\n    constructor(\n        @inject(tokens.Circular / valid /) circ: Circular\n    ) {}\n}\n@injectable()\nclass Irrelevant {\n}\n@injectable()\nclass Kernel {\nconstructor(\n    @inject(tokens.Irrelevant) private another: Irrelevant,\n    @multiInject(tokens.First) private first: First) {\n\n}\n\n}\nvar container = new Container();\ncontainer.bind(tokens.Kernel).to(Kernel);\ncontainer.bind(tokens.First).to(First);\ncontainer.bind(tokens.Circular).to(Circular);\ncontainer.bind(tokens.Irrelevant).to(Irrelevant);\ncontainer.get(tokens.Kernel);\n```\nThis outputs the following error for me:\nError: Circular dependency found: Symbol(Kernel) -> Symbol(Irrelevant) -> Symbol(First) -> Symbol(First)\nIf I change from @multiInject to @inject, the error message still includes Irrelevant, but at least shows the correct circular ref class, at the end:\nError: Circular dependency found: Symbol(Kernel) -> Symbol(Irrelevant) -> Symbol(First) -> Symbol(Circular) -> Symbol(Circular)\nHope this helps! Thanks for your work on this library.. ",
    "dustensalinas": "I'd like to reiterate this.  This should at most be a compile time warning at most, not the current design.\n. ",
    "ggranum": "@remojansen: Reading the docs, I get the impression there is an assumption (in the code) that a base-class will be used as a bind target, even if/when it never actually is. Am I wrong? \nAngular doesn't have this restriction (forced declaration of inject on the child class ctor args), indicating it's possible, so obviously they are doing something different. Presumably related to the fact that abstract base classes do not require an @Inject annotation?\nThis issue is quite confusing and unexpected, in great part because everything else (at least that I've worked with so far) Just Works, which is, of course, great :~). \nThanks much, . ",
    "garkin": "Why am i forced to annotate base class if it's just a code reuse and not injected anywhere?. Would be cool to see an option to lift off this assertion: \nts\nnew Container({ assertInheritanceInjection: false })\nIt realy bogs me to write boilerplate annotations and polute dependency space to make framework feel good about already idiomaticaly correct code.\nGreat experience with Inversify so far, thank you for your job.. If someone is still wondering what exactly is wrong with OPs code.\nThe problem is that default MetadataReader uses Reflect.getMetadata instead of Reflect.getOwnMetadata. \nReflect.getMetadata does search for own metadata of the class, and if it found none it will follow inheritance tree upwards untill it will find one.\nSo, when Inversify tries to retrieve metadata of TypedBL with no annotations in constructor it receives BLBase metadata instead with @unmanaged() on the first constructor argument.\nhttps://github.com/rbuckton/reflect-metadata/blob/master/Reflect.ts#L1263\nts\n function OrdinaryGetMetadata(MetadataKey: any, O: any, P: string | symbol | undefined): any {\n    const hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\n    if (hasOwn) return OrdinaryGetOwnMetadata(MetadataKey, O, P);\n    const parent = OrdinaryGetPrototypeOf(O);\n    if (!IsNull(parent)) return OrdinaryGetMetadata(MetadataKey, parent, P);\n    return undefined;\n}\nAs already was mentioned before, there are following ways to avoid this:\n- provide own implementation of MetadataReader (just ugly)\n- remove @unmanaged() from the base class (will limit possible minimum constructor arguments count for children, could be not applicable for more complex inheritance topologies)\n- add at least one explicit @inject(...) for the children constructor,  to make Reflect.getMetadata happy (that way we lose declared ability to infer dependencies from constructor argument types ). ",
    "hdurix": "Hello @remojansen and thanks for your help.\nThis wiki page is really helpful to do unit testing (this one aswell).\nIt's just a shame the documentation for tests is so hard to find because it helps a lot, maybe it could be good to add an entry for test documentation both in welcome readme and in wiki readme even if it's simple redirects to those pages.. ",
    "gagle": "I just built the tree dependency tree by reading the metadata of each class, keys inversify:tagged and inversify:tagged_props. Hi @remojansen , this definitely will work to get the metadata in a consistent way. Thanks!. Note that @postConstruct is also useful when dependencies are injected into properties instead of through the constructor. It will be called after they are injected, it's the second chance to init the injectable.\nFor now, it would be also fine if @postConstruct and @preDestroy are implemented even if they are synchronous because even JavaEE does not implement them and some workaround must be done (although the result is the same, async init): http://tomee.apache.org/examples-trunk/async-postconstruct/README.html\n@remojansen Do you mind if I push a PR with this sync postConstruct and preDestroy annotations?. Hi @remojamsen, thanks a lot for the detailed explanation. I get the point with the preDestroy in transient scope, it's not the responsibility of inversify and can be implemented by the lib consumer. However, the postConstruct even if it can be implemented with onActivation, it's preferable to have this function in the class declaration instead of in the composition file. But again, it can be easily implemented by the lib consumer. The main problem here is with the asynchronous nature and if you had problems in the past with this approach then there's nothing to do for now.. Yes, but we need a way to initialize after the class is instantiated. We can create an async initialize() method and then in each method call await this.initialize(). But this is very ugly. This should be done automatically by the container and as I explained before, this requires the API to be async.. Async initialization is one of the big things that I'd like to be included. It's weird to have async getter functions to retrieve already initialized data.. preDestroy could be useful too\nhttps://github.com/inversify/InversifyJS/issues/551. Sounds ok for me, this is what I exactly thought when I created the other issue about pre and post. IF the componet is a singleton, there is already a reference to the instance, so we can call the predestroy when the container is closed. Conceptually, if the container creates instances and they are singleton, it is also its responsibility to manage the full lifecycle and not only the instance creation. The predestroy scenario typically won't never happen because the  developers usually don't care about destroying things, sockets and i/o things are automatically closed by the underlying system and resources are freed up, but it's more cleaner if connections can be gracefully closed. In other words, the framework should allow to free up resources, it's not the framework's responsibility to close or not to close resources, so let's enable this feature to the developer.. ",
    "samvv": "Hi, is it perhaps possible to re-open this issue? I have a use-case scenario where I think it would be best if this was supported. Say we have some library functions that we would like to be able to use without being forced to use Inversify, thus forcing us to inject everything using constructor injection. In our application, we are using React and Inversify internally, which forces us to use @lazyInject. There's no way to combine the two, because constructor injection is currently forbidden when using @lazyInject.\nWould love to hear your feedback on this one @remojansen.. I just thought of something: this requires you to either tell InversifyJS upfront if it should make use of the Proxy method, or that it should autodetect whether to use this feature. In the second case, a dependency on React is required, which is probably a no-go. Maybe just like a lazyInjectable, there could be a hardInjectable which uses this proxy method? Something like this:\n```ts\nimport { hardInjectable, inject } from \"inversify\"\n@hardInjectable()\nexport class MyApp extends React.Component {\n@hardInject(Types.Logger)\n  logger: Logger\nrender() {\n    return Woo this is cool!\n  }\n}\n```\nNot even sure the hardInject is necessary, because the method only needs to transform the class itself to a Proxy for it to work.\nAlso noting that there is a third option, where Proxy-based injection becomes the default for all objects as long as typeof Proxy !== 'undefined'. Actually, this is the one I would go for. I'll make this a separate issue.\n. Are you serious? I'm sorry, I thought it just bound the container to the annotation using some prototype magic. Then the issue I'm actually having is something entirely different: being able to use @inject from the package inversify directly instead of some custom defined annotation. It is needed in my case because I can't get access to the container beforehand (I'm defining a pluggable architecture, and the containers aren't statically defined).\nI was also about to add that it won't work the way I described: you need a custom @injectable annotation which will wrap the component in a ProviderConsumer (this is what the @bind does in my container mini-library) .. Perfect, thanks! I'll try it later this evening or tomorrow and let you know how it went.. @remojansen All right, I got it working in this project \ud83d\ude04  Now I'm wondering if it will also work with unmanaged classes like React.Component, but that's for another project and another day.. ",
    "hexa00": "Yes it works! thanks!\nFor reference here's what the test now looks like:\n```typescript\nconst ISomething = Symbol(\"ISomething\");\nconst ITest = Symbol(\"ITest\");\ninterface ISomething {\n}\nclass Foo implements ISomething {\n}\ninterface ITest {\n    aTest: ISomething;\n    run(): void;\n}\n@injectable()\nclass Test implements ITest {\n    constructor( @inject(ISomething) public aTest: ISomething) {\n    }\nrun() {\n    console.log(\"test\");\n}\n\n}\nfunction makeSomethingAndRun(something: typeof Test) {\n    let mything = new something(new Foo());\n    mything.run();\n}\nmainContainer.bind>(\"Newable\").toConstructor(Test);\nlet TestConstructor = mainContainer.get>(\"Newable\");\nmakeSomethingAndRun(TestConstructor);\n```. ",
    "Adamfsk": "I might be wrong about this issue.. I've found out that I DO actually have a circular dependency, but the error output is completely incorrect. It's in an entirely different location including none of the classes mentioned in the error message. I'll see if I can create an example project but it might be somewhat difficult! There's definitely something not working correctly here though.. Hi Nick,\nThe issue here is that the error message points to the wrong classes when reporting the circular dependencies. In my case it was completely wrong and would have been a wild goose chase if I didn't have in depth knowledge of the system that we'd coded. It often includes irrelevant classes in the list, and sometimes doesn't even include the ones that are causing the circular dependency!\nSent from my iPhone\n\nOn 14 Nov 2017, at 12:10, Nick of Nexxar notifications@github.com wrote:\nHm I do not understand the last example. Does not class Circular uses a circular dependency on itself and thus must fail? To me it seems as if inversify IS working properly - where I am wrong?\nClass Circular needs an instance injected that is based on tokens.Circular but Circular is the one to be bound to that token: container.bind(tokens.Circular).to(Circular);. So to resolve that token an instance of Circular is needed which can not be created because initially the token was not resolved - chicken - egg problem. To me this seems a classical circular dependency, isn't it?\nAm I misunderstanding the example?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. \n",
    "showplans": "I'm having exactly this issue. It's correctly reporting that a circular dependency exists, but the list of classes given is complete nonsense (it includes classes that don't have any dependencies, for example). Unfortunately this is in a complex project that I'm not at liberty to share, but if I have any spare time I'll try and create a test case.. ",
    "nros": "Hm I do not understand the last example. Does not class Circular uses a circular dependency on itself and thus must fail? To me it seems as if inversify IS working properly -  where I am wrong?\nClass Circular needs an instance injected that is based on tokens.Circular but Circular is the one to be bound to that token: container.bind<Circular>(tokens.Circular).to(Circular);. So to resolve that token an instance of Circular is needed which can not be created because initially the token was not resolved - chicken - egg problem. To me this seems a classical circular dependency, isn't it?\nAm I misunderstanding the example?. OK, I get it, thanks. So I was just mislead by the name.\nMeanwhile I was able to use a different solution by utilizing a child container as temporary container. It solved my specific problem and seems the far better solution anyway.\nMany thanks for your time and clarification.\n. ",
    "tsschaffert": "Ah, that's a shame, but thanks for the info.. ",
    "marshalYuan": "Maybe in activation handler!\n```\ncontainer.bind(\"Ninja\").to(Ninja);\ncontainer.bind(\"Katana\").to(Katana).onActivation((context, katana) => {\n    let handler = {\n        apply: function(target, thisArgument, argumentsList) {\n            console.log(Starting: ${new Date().getTime()});\n            let result = target.apply(thisArgument, argumentsList);\n            console.log(Finished: ${new Date().getTime()});\n            return result;\n        }\n    };\n    katana.use = new Proxy(katana.use, handler);\n    return katana;\n});\n```\nThis demo will throw the Error when run many times(exceed nodejs max callstack size). ",
    "akosyakov": "We don't use onActivation, but we have a lot of dynamic bindings, factories, and some providers. I will try to come up with a reproducible example.. I think it should something to do with dynamic bindings, e.g.:\n```ts\ninterface Foo {\n}\nclass FooImpl implements Foo {\n  constructor(\n    @inject(Bar) bar: Bar\n  ) {}\n}\nclass Bar {\n  constructor(\n    @inject(Foo) foo: Foo\n  ) {}\n}\ncontainer.bind(FooImpl).toSelf();\ncontainer.bind(Foo).toDynamicValue(ctx => \n  ctx.container.get(FooImpl)\n);\ncontainer.get(Bar);\n```\nI have not tried this code, but a closure for the dynamic value triggers a new request and it can be a reason.. Generally we have kind of a pattern:\nts\ncontainer.bind(FooImpl).toSelf().inSingletonScope();\ncontainer.bind(Foo).toDynamicValue(ctx => \n  ctx.container.get(FooImpl)\n).inSingletonScope();\nSo some clients can inject FooImpl directly and other Foo but both get the same instance. Is there a better way to achieve it without toDynamicValue?. @remojansen Could you comment on https://github.com/inversify/InversifyJS/issues/549#issuecomment-304857978 please? How would you achieve it?. Two different interfaces to the same code, one expose only public API, another provide an access to internals, like interfaces.Container and just Container.. @remojansen I've added a test for it: https://github.com/inversify/InversifyJS/pull/604. @remojansen thanks for the hint. @remojansen I've managed it with a new child container for each A instance.\n. @remojansen would be nice just to have overloads for existing methods, e.g. \nts\nget<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): T;\nget<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, defaultValue: T): T;\n. btw I was surprised that:\n- multiInject fails without bindings\n- and multiInject + optional inject undefined\nI've expected an empty array in both cases.. I like A more, there also can be getOptional:\nts\n/** \n * return `undefined` if the binding is missing, \n * a short cut for `get(serviceIdentifier, undefined)`\n */\ngetOptional<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): T |\u00a0undefined;\n/** \n * return an empty array if there is no bindings,\n * a short cut for `getAll(serviceIdentifier, [])`\n */\ngetAllOptional<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>): T[];. btw try { } catch { } is just bogus, since there can be real issues with broken bindings. I would prefer undefined, since it is kind of default null in js world, and a lot of projects try don't use null at all.\ntryGet sounds good to me, getOrThrow/getOrFail sound too verbose.. container.isBound(typeIdentifier) can it throw an error or never throws?. - for getAll should not be a type of a default value be T[]?\n- I think try* methods should return undefined or an empty array only if there is no bindings for the given serviceIdentifier in other cases it should behave like get*, so it should throw. It would be also nice to support method injections:\nts\nexport class Foo {\n     setBar(@inject(Bar) bar: Bar) {}\n     activate(@inject(Bar) bar: Bar, @inject(Baz) baz: Baz) {}\n}. It would be nice if the following shortcut would be possible then:\nts\nbind(FrontendApplicationContribution).toService(WorkspaceFrontendContribution).toSelf().inSingletonScope();\n, that should be an equivalent to:\nbind(WorkspaceFrontendContribution).toSelf().inSingletonScope();\nbind(FrontendApplicationContribution).toService(WorkspaceFrontendContribution);\nIt is the very common case for us:\n- a framework is programmed against interfaces, e.g. FrontendApplicationContribution\n- a framework extension is programmed against implementations of framework interfaces, e.g. WorkspaceFrontendContribution\n- but both should work with the same instances\nBasically, a framework extension should always use toDynamicValue for each implemented interface from a framework right now, that is a lot of code and issues with tracking down cycles and missing bindings.. Hi, yes it should work.\nMy main concern is support of chained bindings, toService should get it covered, like:\nts\ncontainer.bind(MySqlDatabaseTransactionLog).toSelf().inSingletonScope(); // resolves to MySqlDatabaseTransactionLog\ncontainer.bind(DatabaseTransactionLog).toService(MySqlDatabaseTransactionLog); // resolves to MySqlDatabaseTransactionLog\ncontainer.bind(TransactionLog).toService(DatabaseTransactionLog); // resolves to MySqlDatabaseTransactionLog as well\nRegarding to a shortcut to bind multiple identifiers at once:\nI was wondering whether bind can support var-args generally, i.e.: \nts\ncontainer.bind(WorkspaceFrontendContribution).toSelf().inSingletonScope();\ncontainer.bind(CommonContribution, MenuContribution, KeybindingContribution).toService(WorkspaceFrontendContribution);\nIf not the helper function is fine with me.. Cool! Thank you!. ",
    "onselakin": "Please ignore this issue entry, inSingletonScope works fine.. ",
    "crabicode": "I am curious if it is possible to make thr @postConstruct method to be async. Cause that way I can do some IO right after the instance has been initialized . Any thoughts how to accomplish it? . ",
    "sachabarber": "No this is a NEW project, straight into inversify 2.x, my actual git repo is here if you wanted to try the issue yourself : https://github.com/sachabarber/MadCapIdea\nthat is a running webpack/react/typescript app. \nYou would need to install inversify 2 into that, and hack the tsconfig.json file\nThen after you have done that you can simply open the FrontEndWebSite folder in a command line and run webpack on it (oh after getting NPM to download all the required depedencies that is)\nI would very grateful if you could find time to download that, and see what you make of it. @remojansen even if you can see anything obviously wrong with my setup that would be helpful, i'm really struggling. @remojansen I would be like over the moon if you came back to me anytime within a week to be honest. I am just completely stuck.\nI tried my best, I was an MVP for 9 years in C#, so hopefully I gave it my best try. I sadly lost MVP this year due to me spending more time on other stuff. You still are one right? Good for you.\nHonestly any help you can give me, even if it comes in 5 days would be VERY VERY happily (even gleefully) received\nI also wrote a container in C# (here if you want a gander : https://www.codeproject.com/Articles/552514/BarbarianIOC-A-simple-IOC-Container was fun). I think you would need to do \nNpm install \nBefore running webpack, as I didn't upload the node_modules folder (node creates big folder)\nHonestly be so grateful if you could try it. It would pull down quite few files but after that, you should be able to webpack without errors \nLike I say that's starting point after that you'd need to carry out the Inversify.js install and look at tsconfig.json to add Inversify.js bits\nI just wanted to show it working before I added Inversify.js \nProblem is to get your good start point you will need to suck down node packages \nSucks I know, but I try keep my repos as only source code\nThanks so much for looking so far. I will of course be happy to answer any c# queries you ever have in return for this favour \nLooks like great library but I'm fairly new to webpack and typescript so probably me doing something wrong. Ah darn it, I thought Npm install would fix this\nLeave this with me I'll clone it, get it to build after Npm install and let you guys know when I've pushed it again\nReally appreciate the time guys (I'm new to webpack/Typescript). Lets me fix this, I'll post back here when it builds ok after a pull from github.\nSound ok?. Cool leave it with me, sorry guys\nI'll ping you when I've got it working without Inversify.js in it\nSo it will be exactly what I have before adding Inversify.js \nShould be ok, I've just forgotten to use --save-dev in few places\nI'll buy you boys a beer if we can get me working\n;-) . @lholznagel @remojansen Ok I just pushed up a new git repo which should allow my raw code (without Inversify.js) to build\n\nGrab the repo again : https://github.com/sachabarber/MadCapIdea\nnpm install\nwebpack\nOpen FrontEndWebSite\\dist\\index.html in browser (I right click open with chrome normally)\n\nThat should all just work\n\nInstall Inversify.js following your own instructions, and modify tsconfig.json to add Inversify.js bit and bobs\n\nIt should not work after step 5, but it did in 4 (at least thats what happens for me). @remojansen you absolute star thanks so much\nIf you are ever in London I'll buy you a beer, or Brighton where I actually live . @remojansen honestly mate really appreciate that. Like I say if you find yourself in London ping me i'll take you out for a beer. \nBTW do you not sleep you push that PR through at like 1:00am or something, yikes. @remojansen take it you don't have kids, think they are real reason I lost mvp \nWas just too tired. ",
    "lynx-r": "The solution was easy. I missed setConfig(). I've answered on my question.. ",
    "orendin": "Hey @remojansen, super quick response time, thanks!\nIt is imported inside the inversify.config.ts at the top (as outlined in the code in the issue, sorry for the long post...).\nHmmm... the globals in mocha. I have already done some research into this and could not find anything useful. But your hint helps to refine the search.\nHere we have a 'manual' way of trying to store and reset a global after tests are run in a global hook.\nhttps://github.com/mochajs/mocha/wiki/Mess-with-globals\nThis would mean trying to store a reference to the original Reflect and then resetting it back after the tests ran... I'll give this a shot, thanks!. I can't seem to get a proper snapshot of the Reflect \"Instance\" to reset back to.\nimport \"reflect-metadata\";\nlet refl: any = Reflect;\nThen in the global after hook, I'm trying to resets the global Reflect back to the original:\nafter(() => {\n    (<any>global).Reflect = refl;\n});\nBut this doesn't do the trick. I don't have time to fiddle around with this any more at the moment and will keep the work-around for now. I'll come back to this later. Thanks!. ",
    "codeandcats": "I believe I have the same issue with parcel, which watches my React App and performs hot module reloading when source changes. \ud83d\ude1e. FYI, I've created a PR to address this issue.\nThe PR exposes a function to disable throwing an error on duplicate injectable decorators. This allows keeping the default functionality while letting devs suffering from this error ignore them.\nThat said, I don't believe there's actually any benefit from throwing the error at all. Even if the developer has mistakenly applied an injectable decorator twice somehow, there's not really any harm in simply ignoring the \"mistake\". I don't see a benefit in breaking hard and fast in this particular scenario given it breaks tools which watch like mocha, jest, parcel, etc.. \ud83d\udca1 Friendly tip, if you use VSCode I recommend this excellent extension. I'm a terrible speller so this was life changing for me. \ud83d\ude05 . Also...\n. Hi @remojansen, I'd love to get this in if possible.. ",
    "z-f-t": "I can confirm that typescript compilation goes without any errors.\nAlso, when you have @RequestBody(\"title\") title : string it'll extract \"title\" parameter from the body, it \"title\" parameter is part of the body, but if parameter \"title\" doesn't exist, it'll pick up entire body.\nI would say that behaviour isn't consistent. If it's designed to extract entire body, that shouldn't extract any parameter in any case. . ",
    "meltedspark": "The docs still state that RequestBody annotation does get an argument. Probably should be fixed.. I'd like this very much. The typical case for me is working with Observables. If you subscribe to an observable within a service that is not a singleton, you should unsubscribe once the service is destroyed, otherwise you'll get notifications in a service that doesn't exist anymore.. ",
    "theodesp": "Whats the plan on this is it nice to have?\n. Ok let me try to understand this ticket.\nWhen you call get<T>, getNamed<T>, getTagged <T>, getAll<T>  with a default value it should proceed with the whole plan and create the request and then proceed with the resolve.\nNow in the Planner, we have the following decisions:\nIf there are no bindings available here\nor we have multiple bindings available here = >\nShall we just proceed as normal and throw the Error?\nNow in the Resolver, we have the following decisions:\nIf there are no bindings available and the target request is optional here => Shall we return the default value instead?\nIf the user forgot to setup a BindingToSyndax here => Shall we return the default value instead?\n. Any further reply on this? hacktoberfest is live!. You mean something like that:\n```\npublic get(serviceIdentifier: interfaces.ServiceIdentifier, defaultValue?: T): T {\n        if (this.isBound(serviceIdentifier) || !defaultValue) {\n            return this._get(false, false, TargetTypeEnum.Variable, serviceIdentifier) as T;\n        } else {\n            return defaultValue\n        }\n    }\npublic getTagged(serviceIdentifier: interfaces.ServiceIdentifier, key: string|number|symbol, value: any,  defaultValue?: T): T {\n        if (this.isBoundTagged(serviceIdentifier, key, value) || !defaultValue) {\n            return this._get(false, false, TargetTypeEnum.Variable, serviceIdentifier, key, value) as T;\n        } else {\n            return defaultValue\n        }\n    }\npublic getNamed(serviceIdentifier: interfaces.ServiceIdentifier, named: string|number|symbol, defaultValue?: T): T {\n        if (this.isBoundNamed(serviceIdentifier, named) || !defaultValue) {\n            return this.getTagged(serviceIdentifier, METADATA_KEY.NAMED_TAG, named) as T;\n        } else {\n            return defaultValue\n        }\n    }\npublic getAll(serviceIdentifier: interfaces.ServiceIdentifier, defaultValue?: T[]): T[] {\n        if (this.isBound(serviceIdentifier) || !defaultValue) {\n            return this._get(true, true, TargetTypeEnum.Variable, serviceIdentifier) as T[];\n        } else {\n            return defaultValue\n        }\n    }\n``\nThe problem I see is that internally theisBound,isBoundNamed,isBoundTagged` will all throw an error when the lookup fails here:\nhttps://github.com/inversify/InversifyJS/blob/4b2cf1a6d3dc07d98f15c57d4ab28b03d1910d6d/src/container/lookup.ts#L46-L49\nso inevitably will throw errors if there are no bindings.\nWhat do you suggest?\n. Remo, I find that very interesting. \nDo you mean in general we need to provide some kind of a LifeCycleManager to handle the lifecycle calls or attach on* methods on the container similar to Windsor\nhttps://github.com/castleproject/Windsor/blob/aa9b8b353ee2e533d586495eec254e216f800c09/docs/lifecycle.md?\nWhat do you think of the usage of interceptors? That potentially will give a different way of doing the onActivation handling\nhttps://github.com/castleproject/Windsor/blob/aa9b8b353ee2e533d586495eec254e216f800c09/docs/interceptors.md#interceptors.\nAlso, I was thinking of investigating of pairing them up with mixin style calls similar maybe to Django Rest Framework mixins http://www.django-rest-framework.org/tutorial/3-class-based-views/#using-mixins. \nor this article\nhttps://blog.mariusschulz.com/2017/05/26/typescript-2-2-mixin-classes\nThe idea is to attach mixins than are used independently for each lifecycle call.\nWhat do you think?\n. That looks interesting. If I'm not overloaded with work this week I might work on it. What insights can you give for this?. So I should be able to add additional check to check for Symbol Equality by value possibly using Symbol.keyFor or Symbol.for ( I need to check for browser support) and perform the check and as for the Abstract<T> I should be able to compare their .prototype property.\nI'm looking at the test cases here\nhttps://github.com/inversify/InversifyJS/blob/1bdb3ac5b4ac7c756cbf90998a0492c155aa0765/test/inversify.test.ts#L2264\nand I should be able to add more tests based on this. \nIs that a valid plan?. I would like to ask what are the plans for the binding type.\nFor example I have the following scenario:\n```\n let TYPES = {\n        Ninja: \"Ninja\",\n        NinjaMaster: Symbol(\"NinjaMaster\"),\n        NinjaStudent: Symbol(\"NinjaStudent\"),\n        Weapon: \"Weapon\",\n    };\ncontainer.bind(TYPES.Ninja).to(NinjaMaster).whenTargetNamed(\"lethal\");\ncontainer.bind(TYPES.Ninja).to(NinjaStudent).whenTargetNamed(\"non-lethal\");\ncontainer.bind(TYPES.Weapon).to(Katana).whenInjectedInto(TYPES.NinjaMaster);\ncontainer.bind(TYPES.Weapon).to(Bokken).whenInjectedInto(TYPES.NinjaStudent);\nlet master = container.getNamed(TYPES.Ninja, \"lethal\");\nlet student = container.getNamed(TYPES.Ninja, \"non-lethal\");\nThat will fail because\nError: No matching bindings found for serviceIdentifier: Weapon\nRegistered bindings:\n Katana\n Bokken\n```\nWhen the compiler assembles the plan it will go over the bindings and it Will try to do a Request using  TYPES.Ninja as a service identifier on the left-hand side and calling\ntypeConstraint(parent)(request.parentRequest);\nwhen it comes to narrow the bindings.\nIn the first case parent is TYPES.NinjaMaster and request.parentRequest is the NinjaMaster\nSo it will try to compare TYPES.NinjaMaster with TYPES.Ninja to see if there is a match. How can I make sure that I Find the correct binding for the correct target?\nAs far as I understand we need to Match .to(NinjaMaster) with the constraint whenInjectedInto(TYPES.NinjaMaster)\n. Don't worry Remo. I'm looking forward to your new book! I have a Safari books online Subscription!. Any further reply on this? hacktoberfest is live!. Amazing work by the way. You are a God.. PR https://github.com/inversify/InversifyJS/pull/608. Closed as it's been merged. It's a good idea to write tests for both scenarios as we need to document the side-effects.. tiagoschenkel Your changes look good. I think it's important to give readability some credit first and then look for alternatives in terms of performance. Maybe we need to warn if we detect a deep hierarchical system of containers.. https://github.com/inversify/InversifyJS/pull/613. Fixed by https://github.com/inversify/InversifyJS/pull/613. Simplified path. Simplified path. Ok I can revert that. ",
    "Aboisier": "Related to : https://github.com/inversify/InversifyJS/issues/576. I think the other issue is descriptive enough, I don't have anything to add for now. I think you can close this one. Thanks @remojansen !. Will it be possible to access the class name even when the code is minified? If not, would it be possible to use something like the @targetName decorator?. Ok, good to know! And if we wanted the non-minified name, would we use the @targetName decorator? I feel like this not how targetName was idiomatically designed, so please correct me if I'm wrong!\n```js\n@injectable()\nclass SomeClass {\n    private logger: Logger;\n    public constructor(\n        @inject(\"Logger\") @targetName(\"SomeClass\") logger: Logger\n    ) {\n        this.logger = logger;\n    }\n    public doSomething() {\n        this.logger.log(\"I'm doing something!\");\n    }\n}\n[...]\ncontainer.bind(\"Logger\").to(Logger).onActivation((context, currentRequest: interfaces.Request, loggerInstance) => {\n        const targetName = request.target.name;\n        loggerInstance.className = targetName ;\n        return loggerInstance;\n});\n```. Awesome! Shout out to your responsiveness @remojansen and to the contributors who worked on this feature, it is much appreciated!  \ud83d\udcaf \ud83e\udd47 . ",
    "shaunc": "How about this: \n\nuse bindNamed().toFactory() to bind the various IStream possibilities, taking base stream as argument where necessary.\nhave a bind('IStreamConfig').toConstant(['CompressedStream', 'EncryptedStream', 'FileStream'])\nuse toDynamicValue(...).whenTargetIsDefault() for the default value that uncoupled clients will see:\n\nts\n    bind('IStream').toDynamicValue(({container}: Context) => {\n      const config = container.get('IStreamConfig')\n      let stream: IStream | undefined = undefined\n      while (config.length) {\n        stream = container.getNamed<IStream>('IStream', config.pop())(stream)\n      }\n      return stream\n    }).whenTargetIsDefault(). After fiddling with alternatives over several days, I thought of the following:\n```ts\ninterface IWeaponFactory { create(damage: int): IWeapon }\nnamespace Katana {\n  @injectable()\n  class Factory implements IWeaponFactory {\n    constructor(private @inject(SCABBARD) scabbard) { }\n    create (damage: number) {\n      return new Katana(this.scabbard, damage)\n    }\n  }\n}\nclass Katana implements IWeapon {\n    constructor(readonly scabbard: Scabbard, private damage: number) { }\n}\n...\ncontainer.bind(\"WeaponFactory\").to(Katana.Factory)\nWhich allows:ts\n@injectable()\nclass Ninja {\n@inject(\"WeaponFactory\") weaponFactory: IWeaponFactory, \ncurrentWeapon: Weapon,\n\npublic equip( damage: number ) {\n\n    this.currentWeapon = weaponFactory.create(damage);\n    console.log(\"Weapon scabbard\", this.currentWeapon.scabbard);\n\n}\n\n}```. @remojansen Thanks for the reply. I took the plunge and adopted anyway, and seems to be working. (I did have some issues injecting static class properties, but worked them out, and I'm not sure if doing that isn't an anti-pattern anyway.)\nMy concern stands though -- you've built a big and popular package. Maybe you should put a call out to collect a committee to go through outstanding issues, build/maintain a roadmap, etc. I don't think I'd be a good member both because of time pressure and because I'm just getting started using inversify. Given its popularity, however, I would bet you could gather a qualified group of stakeholders.. ok ...  keep in mind you can probably reach out for help given the popularity of the package.(And better to do it early than after people start to drift away if their issues are stagnant.)\nIf \"inversifying\" the current project works well, we have another coming up in a couple months that will require webpack deployment. I do see some open issues mentioning webpack... (And I might even be able to help -- though webpack is even more black magic to me than inversify.)\nIn any case -- thanks so much for inversify! I wish it continued growth.. ",
    "krzkaczor": "@remojansen is there a good way to access parent request? In my case context.currentRequest.parent it's just circular reference oO\ncontext.currentRequest.bindings[0].implementationType.name points me just to logger symbol and thus is null. I tried: context.currentRequest.parentContext.plan.rootRequest.bindings[0].implementationType.name but this gets only root request obiously.. @guscastro thanks! It works!. @remojansen thanks for a quick response! Yes, I was aware of this problem that it could break existing code :/ Your solution sounds good! I will work on it today. . @remojansen yes! you're right. Initially, I thought that returned function is being called much later. That's why I also \"unwrapped\" function there to get symbol itself. \nOnce I realized that it's called right after I noticed that it doesn't solve the problem of circular dependencies (i also tested it locally with my repro example). So what I did now is that I unwrap lazy wrapper during getting dependencies on subrequest method. I will update PR in a sec. . @remojansen done! Let me know what do you think. Now, locally my repro works (After adding LazyServiceIdentifer). @remojansen awesome! Thanks! I am gonna update our app ASAP to use newer version. \nBtw. I would suggest considering making breaking change on next major release to always force using () => symbol with @inject. This would make LazyServiceIdentifer redundant and would avoid circular dependencies by design. This is exactly what typeorm does. . ",
    "dagatsoin": "Yes it works but my IDE (which is IDEA) mark an warning:\nArgument type Types is not assignable to parameter type etc... surely because Enum is not an allowed type for bind()?. Just in IDEA on code inspection.. Do you see any inspection error in VS?\nBecause it could be IDEA which is using its bundled version of TS (which is 3.2.4 actually).\n. Sure, actual version of Idea use a version of TS < 2.4\nNo doubt it will erase the editor red lint when they will bring the 2.4.\nLe 8 juil. 2017 \u00e0 23:42, Remo H. Jansen notifications@github.com<mailto:notifications@github.com> a \u00e9crit :\n@dagatsoinhttps://github.com/dagatsoin did some work this week on VS with the latest version of TS and I could not see any errors. Can you check this with the IDEA team, please?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHubhttps://github.com/inversify/InversifyJS/issues/582#issuecomment-313882718, or mute the threadhttps://github.com/notifications/unsubscribe-auth/ADgDCi1VgN5oreDxOGqjh53sErDV0fWaks5sL_epgaJpZM4N8jft.\n. ",
    "ianloverink": "If you have typescript >= 2.4 installed you can update IDEA to point to the newer version rather than the bundled in the settings.. ",
    "abarmawi": "@remojansen \nthis is my IServer \ninterface IServer {\n    bootstrap(): IServer;\n}\nexport { IServer };\nthis is my Server\n```\n// Import npm dependencies\nimport * as bodyParser from \"body-parser\";\nimport * as cookieParser from \"cookie-parser\";\nimport * as express from \"express\";\nimport * as logger from \"morgan\";\nimport * as path from \"path\";\nimport errorHandler = require(\"errorhandler\");\nimport methodOverride = require(\"method-override\");\nimport \"reflect-metadata\";\nimport { injectable, inject } from \"inversify\";\n// Import app dependencies\nimport { IndexRoute } from \"../routes/indexRoute\";\nimport { IAuthentication as IAuthenticationV1 } from \"../AuthenticationLayer/V1/\";\nimport { systemConfig as systemConfigV1 } from \"../Config/V1\";\nimport { TYPES, myContainer } from \"../Helpers/IOC/InversifyJS/\";\nimport { IServer } from \"./IServer\";\n/\n * The server.\n \n * @class Server\n /\n@injectable()\nclass Server implements IServer {\npublic app: express.Application;\n\n\nprivate iAuthentication: IAuthenticationV1;\n\n/**\n * Bootstrap the application.\n *\n * @class Server\n * @method bootstrap\n * @return {ng.auto.IInjectorService} Returns the newly created injector for this app.\n */\npublic bootstrap(): Server {\n    return new Server();\n}\n\n/**\n * Constructor.\n *\n * @class Server\n * @constructor\n */\nconstructor() {\n\n    // create expressjs application\n    this.app = express();\n\n    // configure application\n    this.config();\n\n    // add routes\n    this.routes();\n\n    // add api\n    this.api();\n\n    // start web server\n    this.start();\n}\n\n/**\n * Create REST API routes\n *\n * @class Server\n * @method api\n */\npublic api() {\n    // empty for now\n}\n\n/**\n * Configure application\n *\n * @class Server\n * @method config\n */\npublic config() {\n    // add static paths\n    // this.app.use(express.static(path.join(__dirname, \"public\")));\n\n    // configure pug\n    // this.app.set(\"views\", path.join(__dirname, \"views\"));\n    // this.app.set(\"view engine\", \"pug\");\n\n    // use logger middleware\n    this.app.use(logger(\"dev\"));\n\n    // use json form parser middleware\n    this.app.use(bodyParser.json());\n\n    // use query string parser middleware\n    this.app.use(bodyParser.urlencoded({\n        extended: true\n    }));\n\n    // build & configure auth process.\n    this.iAuthentication.configure(this.app);\n\n    // use cookie parker middleware middleware\n    this.app.use(cookieParser(\"SECRET_GOES_HERE\"));\n\n    // use override middleware\n    this.app.use(methodOverride());\n\n    // catch 404 and forward to error handler\n    // this.app.use(function (err: any, req: express.Request, res: express.Response, next: express.NextFunction) {\n    //     err.status = 404;\n    //     next(err);\n    // });\n\n    // error handling\n    this.app.use(errorHandler());\n}\n\n/**\n * Create router\n *\n * @class Server\n * @method api\n */\npublic routes() {\n    let router: express.Router;\n    router = express.Router();\n\n    // IndexRoute\n    IndexRoute.create(router);\n\n    // use router middleware\n    this.app.use(router);\n\n    // catch any error and forward to error handler\n    this.app.use((error: any, req: express.Request, res: express.Response, next: Function) => {\n\n        console.log(\"test test test\");\n        console.log(error);\n\n        res.status(500).json(error).end();\n    });\n}\n\n/**\n * Starts web server on specific port.\n */\npublic start(): void {\n\n    const port = systemConfigV1.SystemConfig().API.PORT();\n\n    this.app.listen(port, (error: any) => {\n        if (error) {\n            console.log(`can't start server. error : ${error}`);\n        }\n        else {\n            console.log(`Server started on port ${port}`);\n        }\n\n    });\n}\n\n}\n// Export module\nexport { Server };\n```\nand this is how i call \n```\ntry {\n    // start the server.\n     let server = myContainer.get(TYPES.IServer);\n} catch (error) {\n    console.log(\"An error occurred while boot strapping app.\");\n    throw error;\n}\n```. @remojansen \nit's working fine now\nthe only thing i did is just install \"inversify-inject-decorators\", the every thing works fine.\nthen i uninstalled it \"inversify-inject-decorators\" but every thing works find!!!\nany explanation? . ",
    "oneassasin": "It`s just example :) \nThe problem is this: in the method for installing controllers, there is no search in the class prototype. Also, for using Get, Post, Update and Delete decorators class need to declare class with injectable decorator. Maybe, need to add checking if class is abstract, skip this condition?. What decorators are you meant?\n@Controller, @Get? Its decorators from inversify-express-utils. Now their names @controller and @httpGet.. ",
    "rmblstrp": "@oneassasin @remojansen  Here's a workaround I made for my own controllers to inherit from a parent.  When I get time I'll put this into a PR.\n```typescript\nfunction mergeInheritedControllers() {\n    function getControllersFromMetadata(): Function[] {\n        const arrayOfControllerMetadata: interfaces.ControllerMetadata[] = Reflect.getMetadata(\n            \"inversify-express-utils:controller\", Reflect\n        ) || [];\n    return arrayOfControllerMetadata.map((metadata) => metadata.target);\n}\n\ngetControllersFromMetadata().forEach(controller => {\n    const methods = mergeInheritedMethods(controller);\n    Reflect.defineMetadata(\"inversify-express-utils:controller-method\", methods, controller);\n\n    const parameters = mergeInheritedParameters(controller);\n    Reflect.defineMetadata(\"inversify-express-utils:controller-parameter\", parameters, controller);\n});\n\n}\nfunction mergeInheritedMethods(controller: Function): interfaces.ControllerMethodMetadata[] {\n    function getControllerMethodMetadata(constructor: Function): interfaces.ControllerMethodMetadata[] {\n        return Reflect.getOwnMetadata(\"inversify-express-utils:controller-method\", constructor);\n    }\nconst methods = [].concat(getControllerMethodMetadata(controller) || []);\nif (controller.prototype.__proto__ !== Object.prototype) {\n    const inherited = mergeInheritedMethods(controller.prototype.__proto__.constructor);\n\n    for (const item of inherited) {\n        if (isObject(item)) {\n            if (methods.filter(map => isObject(map) && map.key === item.key).length === 0) {\n                methods.push(Object.assign({}, item, {target: controller.prototype}));\n            }\n        }\n    }\n}\n\nreturn methods;\n\n}\nfunction mergeInheritedParameters(controller) {\n    function getControllerParameterMetadata(constructor: any): interfaces.ControllerParameterMetadata {\n        return Reflect.getOwnMetadata(\"inversify-express-utils:controller-parameter\", constructor);\n    }\nlet parameters = Object.assign({}, getControllerParameterMetadata(controller));\nif (controller.prototype.__proto__ !== Object.prototype) {\n    const inherited = mergeInheritedParameters(controller.prototype.__proto__.constructor);\n    parameters = Object.assign({}, inherited, parameters);\n}\n\nreturn parameters;\n\n}\n```. ",
    "tioback": "@Deviad - please create a separate issue.. ",
    "kbirger": "With the way that this has been fixed, it has broken another use case in a very strange way. I've logged https://github.com/inversify/InversifyJS/issues/854 to track the new behavior.. Thanks @AltekkeE, it's no trouble.. I can confirm that I was mostly correct. The line with childContainer.getNamed(...) is the source of the crash, but it is not the cause of the error.\nThe actual cause of the error is in the forEach of registerControllers. What seems to be happening is that both StuffController and PrivateStuffController are getting metadata for getPrivateThings, but obviously only one of them has the handler method. \nI have a fix. It works. But I am not sure if it is the best way to fix the problem. I will keep looking, but maybe I can get an early opinion on the following diff. @remojansen since you were just in this code, what do you think about adding something like this to the registerControllers method? \nts\nif(controllerMetadata.target.prototype[metadata.key]) { \n    /* snip */\n   this._router[metadata.method](/*snipping out existing params to the call for clarity*/)\n}\nIt seems a little bit inelegant, yes, but I don't think there's a clear way to avoid that metadata getting picked up from the start since we are using getMetadata  instead of getOwnMetadata now (which I definitely think is the way to go).\nIf this all sounds good, let me know and I can put in a PR with some tests to boot.\nedit\n@AltekkeE I just saw your reply after submitting mine. Let me have a look at your test code and see if I can get a unit test that reproduces it. I'll try to do that this evening.\n. @AltekkeE In my example the controllers have different base routes. If you change the TestController route to /api-int/test the tests you posted will throw the following error (which matches what I was seeing in live code). \n\n(node:21116) UnhandledPromiseRejectionWarning: TypeError: Cannot read property 'apply' of undefined\n    at InversifyExpressServer. (C:\\Users\\kbirger\\Documents\\git\\inversify-express-utils\\src\\server.js:198:38)\n    at step (C:\\Users\\kbirger\\Documents\\git\\inversify-express-utils\\src\\server.js:32:23)\n    at Object.next (C:\\Users\\kbirger\\Documents\\git\\inversify-express-utils\\src\\server.js:13:53)\n    at C:\\Users\\kbirger\\Documents\\git\\inversify-express-utils\\src\\server.js:7:71\n    at new Promise ()\n    at __awaiter (C:\\Users\\kbirger\\Documents\\git\\inversify-express-utils\\src\\server.js:3:12)\n    at C:\\Users\\kbirger\\Documents\\git\\inversify-express-utils\\src\\server.js:190:35\n    at C:\\Users\\kbirger\\Documents\\git\\inversify-express-utils\\src\\server.js:214:19\n    at Layer.handle [as handle_request] (C:\\Users\\kbirger\\Documents\\git\\inversify-express-.\n...SNIP....    at InversifyExpressServer. (C:\\Users\\kbirger\\Documents\\git\\inversify-express-utils\\src\\server.js:105:29)\n    at step (C:\\Users\\kbirger\\Documents\\git\\inversify-express-utils\\src\\server.js:32:23)\n    at Object.next (C:\\Users\\kbirger\\Documents\\git\\inversify-express-utils\\src\\server.js:13:53)\n    at fulfilled (C:\\Users\\kbirger\\Documents\\git\\inversify-express-utils\\src\\server.js:4:58)\n    at \n    at process._tickCallback (internal/process/next_tick.js:188:7)\n(node:21116) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1)\n(node:21116) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.\n\nTo add more context, I have an application whose single instance serves endpoints available to the internet, and another set of endpoints under a different route that is only available internally. This is handled by another appliance that does reverse proxying (Kubernetes stuff). This probably wouldn't be an issue if the routes were distinct, but I was asked to make the internal route contain all of the endpoints from the public one, to make it easier on internal services calling the one I am developing.. @dcavanagh , sorry I should have just posted a complete test file as you have. I've gone through and noted the differences between what you and I had separately. \n```ts\nimport * as supertest from \"supertest\";\nimport { expect } from \"chai\";\nimport { InversifyExpressServer } from \"../src/server\";\nimport { httpGet, controller } from \"../src/decorators\";\nimport { Container } from \"inversify\";\nimport { cleanUpMetadata } from \"../src\";\ndescribe.only(\"Unit Test: Issue 854 - kbirger\", () => {\nbeforeEach((done) => {\n    cleanUpMetadata();\n    done();\n});\n\nit(\"should support inherited methods\", (done) => {\n    let container = new Container();\n\n    @controller(\"/api/test\")\n    class BaseController {\n        @httpGet(\"/public-things\")\n        public getPublicThings() {\n            return { things: [\"a\", \"b\"] };\n        }\n    }\n\n    @controller(\"/api-int/test\")\n    class TestController extends BaseController {\n        constructor(/* deps */) {\n            super(/* deps */);\n        }\n\n        @httpGet(\"/private-things\")\n        public getPrivateThings() {\n            return { things: [\"c\", \"d\"] };\n        }\n    }\n\n    let server = new InversifyExpressServer(container);\n    let app = server.build();\n\n    // diff1 - this succeeds\n    // instead of /api-int/test/public-things, /api/test/public-things\n    supertest(app).get(\"/api/test/public-things\")\n        .expect(\"Content-Type\", /json/)\n        .expect(200)\n        .then(response1 => {\n            expect(response1.body.things[0]).to.equal(\"a\");\n        });\n\n    // diff2 - this fails with the reported stack\n    // instead of /api-int/test/private-things, /api/test/private-things\n    supertest(app).get(\"/api/test/private-things\")\n        .expect(\"Content-Type\", /html/)\n        .expect(404) // diff3 - this should be a 404\n        .then(response1 => {\n            done();\n        });\n\n});\n\n});\n```. Thanks for the workaround @remojansen. Do you have any thought on the patch I proposed to registerControllers in server.ts above? I'm not sure if it would cause any other issues, but it does seem to address this particular care.. @remojansen I decided to try the workaround you suggested. Were you able to get it to work? For me it responds to /api/test/private-things, though it shouldn't. Oddly enough if I print all of the bindings that one doesn't show up. Could be a related issue.. ",
    "jonfasking": "Let me just say I really like what you guys are doing with this library. I've been waiting for something like this for a long time. \n@remojansen As I stated in my use case, I am using express to serve up a socket.io client that has a great deal of functionality. With express I have more granular control on requests, serving up additional static content, and other things. I want an IOC container & DI under the hood for channels, svcs for those channels, data store interaction, etc. etc. The statement \n\nit makes no sense to start a express server without registered routes.\n\nis just flat out not accurate. \nHowever, I could see where you could make the argument that I could simply use inversify in my particular case if I do not have any controllers yet. If you agree with this statement though, you are stating that this library is ONLY FOR express apps utilizing controllers. If this truly is the case, so be it. However that is not documented anywhere in the readme. On the same note, it does not mean you could gracefully handle something as simple as no controllers = do not invoke registering things that do not exist. \nIf this was something that you intentionally planned and threw .a specific error, I could live with that. However, you have been told about an error that you're deeming is \"OK\" because it justifies a rule you're just now adopting. This is not good practice and should not be wrote off as OK. \nEither way I'm going to continue using the library for this particular use case and will continue to do so for my other express apps. \n-Jon . ",
    "miroslavvojtus": "I'd would like this feature as well.\nWe have a simmilar use case where we have a set of handlers for web socket messages. \nCurrently we have to ensure the handlers live in singletone scope all the time or manage the lifecycle ourself as we do not know when to detach the handlers.\nHaving @preDestroy would make the code more SOLID as now we have to handle some concerns out of bean definition.. To impelement SOLID and espetially Interface segregation it would be nice to have such a feature.\n```javascript\nconst A = Symbol(\"A\");\ninterface A {\n  fnA(): void;\n}\nconst B = Symbol(\"B\");\ninterface B {\n  fnB(): void;\n}\nclass ComplexLegacyAB implements A, B {\n  // ...\n}\n// in module registration\n// internal\nbind(ComplexLegacyAB).toSelf().inSingletonScope();\n// exposed\nbind(A).to(ComplexLegacyAB); // should poitn to the same singleton;\nbind(B).to(ComplexLegacyAB); // should poitn to the same singleton;\n```\nNow I have to create implementations for A and B which delegates the calls to ComplexLegacyAB what is annoying espetially when there are dozen of implemented interfaces.\nIf I could inject the ComplexLegacyAB instance by the interface it would allow me to step by step separate the legacy code.. ",
    "the-owl": "Unfortunately, it is not possible, because delete is a reserved word and it cannot be used as an identifer. Usage of delete decorator will require doing import { delete as Delete } from 'inversify-express-utils'. ",
    "asykes74": "Yes.  The link makes sense.  Thank you for providing it.  One question: my original code injects the actual Model into the repository object.  To avoid drastically changing code, is there a way that I could modify the container.bind above to accommodate injecting just the Model object into the repository?  Please explain how I can tailor the container.bind to fit the scenario below, if not possible, I will change to fit the example you provide in the link.\nHere is a sample of my UserRepository definition:\n```\nexport class UserRepository extends RepositoryBase implements IUserRepository {\n    userSchemaModel: Model;\nconstructor (@inject(\"Model<IUserModel>\") @named(\u201cuserSchemaModel\") userSchemaModel: Model<Document>)\n\n```\nHere is the container.bind code currently:\ncontainer.bind<Model<IUserModel>>(TYPES.User).to(model.user).whenTargetNamed(\"userSchemaModel\");\nHere is the sample of my base repository definition:\n```\nexport class RepositoryBase implements IRepository {\n        protected _model: Model;\n    constructor (schemaModel: Model<Document>) {\n        this._model = schemaModel;\n    }\n\n```\nHere is the sample of the IUserModel:\nexport interface IUserModel extends IUser, Document {\n. ",
    "Bloodjunkie": "\n\n. I've pushed a small example with my problem. I've tried with lazyInject and without. I think the problem is, that the the hirarchy is broken cause the modules are maybe loaded to early. Or maybe i still do not understand the procedure :(\nhttps://github.com/Bloodjunkie/InversifyTest\nI'm deeply gratefull for any help :). Is it not possible or thought to use Inversify in a amd scenario or what could be the problem?. ",
    "ecspand": "Is Inversify anyway thought to work with requirejs? I think i have a general problem here. Modules are loaded before the main and the config file is loaded, cause of the import in this files.. ",
    "tiagoschenkel": "@remojansen, a quick solution for the issue can be find here:\nImplements #611\nSince is possible to get a service from a parent container, it should also be possible to check if the child container can solve the binding, directly or indirectly.\nBut before closing this issue, I would like to ask if the the methods getTagged and getNamed should have the same behaviour, that means, check if a parent can also solves the request. If yes, the methods  isBoundNamed and isBoundTagged should also verify if a parent container can solve the binding.\nBut then, because I don't know all the details of the architecture of the binding system, I'm unsure if we can generalize this without breaking any previous feature or intended behaviour.\nAlso, I was doing some experiments with the isBoundNamed and isBoundTagged methods, but then I realised that I was generating performance problems. The time to create a binding was increased and was higher than 1 ms. Off course, since the method need to check also the parent, the time to solve the request will grow and will depend of how many leves are concatenated though the entire three. Checking all the three up will create performance issues, there is no other way around.\nLet me know if we can quickly solve this issue, or if we should discuss also the behaviour of other similar methods.. There is this comment above the isBoundTagged:\njavascript\n// Note: we can only identify basic tagged bindings not complex constraints (e.g ancerstors)\n// Users can try-catch calls to container.get<T>(\"T\") if they really need to do check if a\n// binding with a complex constraint is available.\nThis method throws a error if the serviceIdentifier is not directly available from the binding dictionary of the current container. At least for me, add a try / catch statement only to prevent this erros doesn't look to be a proper solution.\nAs far as I understood, the isBoundTagged method get a list of services that could be returned from the serviceIdentifier parameter, then check if one of these bindings could also match the key and value parameters. These parameters are used as a filter.\nBut then, if the current container can't solve the binding, we need to check if the parent can solve it, but then a try / catch statement is needed because we only know that the current container can't solve it if a error is generated.\n@remojansen, is there another way to know if the current container can solve the binding without force the generation of a error?. I implemented a way to solve the issue without trowing a error. The isBound methods are checking if a parent container can also sove the request.\nI already created a pull request. I understand the necessity of this improvement, but I would like to point out that this merge request caused a break in the Public API, since the method guid was renamed to id.\nFollowing basic semver guidelines, this change generates a new major release:\n\n\nMAJOR version when you make incompatible API changes,\nMINOR version when you add functionality in a backwards-compatible manner, and\nPATCH version when you make backwards-compatible bug fixes.\n\n\nThis change should force the release of version 5.0.0 instead of released version 4.14.0.. The Public API changed when the method guid was renamed to id. Also, instead of returning a string, the method is returning a number.\n```typsecript\nlet idCounter = 0;\nfunction id(): number {\n  return idCounter++;\n}\nexport { id };\n```\nThe version 4.14.0 is actually the version 5.0.0, at least now is explicit that there is a breaking change. I pointed this out in #882.\nI only discovered this problem because greenkeeper tried to update the inversify dependency on my project, :).\nThank you @dcavanagh for taking care of this!. ",
    "jpsfs": "Hi!\nHaving the isBound method checking the parent seems a great feature to me (to be honest I thought it already worked like this).\nNow the issue is that unbind only does this for the current container, and throws an error if there is nothing to unbind. With this change, the following pattern doesn't work:\nts\n        if (container.isBound(\"a\")) {\n            container.unbind(\"a\");\n        }\n        container.bind(\"a\").toConstantValue(entity);\nAny idea?. ",
    "DrJonki": "~~Having the same problem.~~\nEdit: Nevermind, was able to fix it by decorating the 3rd party base class using decorate().. ",
    "jsamr": "I just misunderstood the API.. @remojansen I have spotted other occurrences of this pattern (throw new Error(error.message)).\nAre you OK that I dig further and replace'em all in a PR ?. @remojansen Thanks a lot for your reactivity !. @remojansen you're welcome :-). ",
    "ajafff": "I'm also in the need of this feature.\nThough I'm a little confused by the different names used in the description above.\n@amcdnl Do you want a new abstraction named Injector added? Or do you actually only want to inject the Container and Injector is just used to show how Angular does that?\nSo your code from above would then become:\nts\nclass Api {\n  constructor(parent: Container) {\n    const container = new Container();\n    container.parent = parent;\n    controllers.forEach(p => container.bind(p).toSelf());\n  }\n}\n\n@remojansen would you accept a PR that adds an identifier Container to every Container instance that resolves to this instance?\nThat could be considered a breaking change as it might break users that already provide a binding for Container. To avoid that one could introduce a new identifier ParentContainer or similar.. ",
    "MrDarkSkil": "I succeed in doing what you want.\nIn entities.ts\n```typescript\nimport Dom from \"./services/Dom\";\nimport Logger from \"./services/Logger\";\nexport default [\n    Dom,\n    Logger\n]\n```\nIn index.ts\n```typescript\nimport \"reflect-metadata\";\nimport { Container, injectable } from \"inversify\";\nimport entities from \"./entities\";\nimport Dom from \"./services/Dom\";\nlet container = new Container();\n@injectable()\nclass App {\n    constructor(private dom: Dom) {\n        console.log(dom);\n    }\nlol(msg: string) {\n    this.dom.test(msg);\n}\n\n}\nfor(let entity of entities) {\n    if (entity) {\n        container.bind(entity).toSelf().inSingletonScope();\n    }\n}\nconst dom = container.resolve(App);\ndom.lol('THIS IS A TEST !');\n```\nDom.ts\n```typescript\nimport { injectable } from \"inversify\";\nimport Logger from \"./Logger\";\n@injectable()\nexport default class Dom {\n    constructor (private logger: Logger) {\n    }\ntest(msg: string) {\n    this.logger.debug(msg);\n}\n\n}\n```\nLogger.ts\n```typescript\nimport { injectable } from \"inversify\";\n@injectable()\nexport default class Logger {\n    constructor () {\n    }\ndebug(msg: string) {\n    console.log(msg);\n}\n\n}\n```\n. ",
    "SiriuxB": "+1. ",
    "jguerra1991": "+1. ",
    "Juandavi1": "i have same problem. . ",
    "agomezgu": "Hi Lholznagel , \nOff course you are right ... i need inject the Http class , but i don't know what is the correct way to inject it , because this library is part of \"@angular\" Core.\nCan you give me some advice?\nThank for all.. Hi Guys..\nFinally I found a very usefull tool named InjectionToken , you can resolve dependencies using Interfaces, the principal advantage is, using InjectionToken you're using Angular Core and no external Libraries. ",
    "ajdnik": "Since the feature was implemented and PR was merged I will close the issue.. ",
    "stephandrab": "I just found #576, which may be related to this. I am having the same problem in this environment:\n- Mac OSX 10.13.6\n- node 10.15.0\n- typescript 3.2.4\n- jest 23.6.0 and 24.0.0\n^ do you have an idea when this may be fixed?. I am having the same problem in this environment:\n- Mac OSX 10.13.6\n- node 10.15.0\n- typescript 3.2.4\n- jest 23.6.0 and 24.0.0\n^ Frankly I cannot use toDynamicValue... :-/ Do you have an idea when this may be fixed?. ",
    "ezk2410": "@lholznagel Is there a way to create HttpServer without using inversify-express-utils ?. ",
    "mindhacker42": "\ud83d\udc4d . ",
    "mbayou": "I know but I propose an enhancement. \nBy default inversify return 200 if all is ok. But when I don't return anything I think is better if inversify return by default a 204 to correspond to http code, and if I want a specific return we can set a custom code.. Ok I understand, I thought inversify manage some behaviors. So If you think it's really impossible I'll try to talk about that with express people. \nThanks for your responses ;). ",
    "r0bnet": "@robertmain i think i don't get your question? I use router.param in some other projects but i don't see the connection to the link you posted.. Sorry that i didn't respond earlier.\n@AltekkeE  that is not what i meant. I know that feature you mentioned but what i'm looking for is another functionality that enables you to define one middleware function that is called on each route that contains a specific variable (like id in my example above). And it will be called before the route function is called.\nThis is helpful for instance if you need to receive an object from a database and if that object does not exist the middleware will already end the chain and respond with a 404. If the object is found you can bind it to the request object so that it can be used in subsequent middleware (e.g. the route function/middleware).. ",
    "osi-oswald": "Maybe the option should be called autoBindInjectable instead, not sure.... ",
    "sleepysort": "This is expected. Inversify will resolve dependencies when objects are instantiated via the container. In this case, the factory method that you are binding here:\njavascript\ncontainer\n    .bind(TYPES.ChildStore)\n    .toFactory(\n        () =>\n            () => new ChildStore());\nis creating a ChildStore via its constructor, instead of through the container. What you want is probably:\n```javascript\n// Bind the ChildStore class\ncontainer.bind(TYPES.ChildStore).toFactory(ChildStore);\n// Bind the factory\ncontainer\n    .bind(TYPES.ChildStoreFactory)\n    .toFactory(\n        () =>\n            () => container.get(TYPES.ChildStore));\n```. ",
    "546342": "Hello! I have the same problem. What do you think about this workaround:\n```\ncontainer.bind('ISomeService').to(SomeService).inSingletonScope();\ncontainer.bind('IDisposable').toDynamicValue(context => context.container.get('ISomeService')).inSingletonScope(); // resolve and cache it\n...\ncontainer.getAll('IDisposable');\n```\nOr maybe there are better ways now?. ",
    "ouranosv": "Thanks for your answer.\nI already have types/node installed, so this is not the problem.\nAny other ideas?. Yes, i have already installed it. I followed the install instructions as mentioned on the site.. ",
    "amc6": "I ran into something similar. It looks like adding the line \"types\": [\"reflect-metadata\"] causes typescript to ignore all other types defined in the node_modules/@types directory. https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\nMy solution was just to leave that line off. I've gotten the basic example from the README up and running. So hopefully that line is unneeded and this won't come back to bite me down the road.. I'm also on typescript 2.5.3 if that matters. I set the project up with create-react-app and microsoft's react-scripts-ts. So its possible that has configured something in some non-standard way that is causing this.  \u00af\\_(\u30c4)_/\u00af\ncreate-react-app my-app --scripts-version=react-scripts-ts. ",
    "lexon": "Any updates here?. ",
    "PowerMogli": "One of the :fire: and most requested features for us! . Ah cool. You fixed it very fast. But unfortunately we use makeFluentProvideDecorator to generate a @provideFluent instead of @provide. The reason is we have a function defined like this:\n```ts\nconst container = new Container();\nconst provideFluent = makeFluentProvideDecorator(container);\nconst provideSingleton = (identifier: any) => {\n  return provideFluent(identifier)\n    .inSingletonScope()\n    .done();\n};\n```\nDo you have any tip how we can apply your commit to makeFluentProviderDecorator?. It works great, but we see a big problem: providing the decorator multiple times, inversify creates every time a new instance of the decorated class. Our intention was to generate only one instance of the class but decorated by multiple different identifiers. \nLets consider the following example:\n```ts\n@provideSingleton(VIEWSTATE.ViewStateSynchronizer)\n@provideSingleton(TYPE.PatientComponentModel)\nexport class PatientComponentModel extends BaseComponentModel, IViewStateSynchronizer {\n....\n}\nexport class PatienComponent {\n@lazyInject(TYPE.PatientComponentModel) patientComponentModel: PatientComponentModel;\n....\n}\nexport class DataSync {\nconstructor(@multiInject(VIEWSTATE.ViewStateSynchronizer) private viewStateSynchronizers: IViewStateSynchronizer[]){}\n...\n}\n```\nDataSyns service and the PatientComponent (Angular 2) have to get the same instance of PatientComponentModel injected. But both have to inject it by a different identifier.\nI hope I could explain it clear enough and you can help us out here (again) \ud83d\udc4d . @Recodify Sorry, we did not raise an issue. Just because we moved away from InversifyJS to Angulars own DI with 'multiple' feature. And Angular had big problems when building our project with InversifyJS and in production mode.. ",
    "Recodify": "@PowerMogli Did an issue ever get raised to cover your scenario above. I am trying to accomplish exactly the same thing and am observing the same behavior where my \"singleton\" is created twice, once for each binding.\n@remojansen Did you ever come up with the workaround, would be great if you could share if you did.. ",
    "timtrinidad": "I ran into this issue today so I gave the PR a try. It's my first contrib to InversifyJS so let me know if there's something amiss!. ",
    "ae-draft": "Yes, but module typings is obsolete!. Thank you! I'm sorry, it's my problem.. ",
    "johnathandinh": "Figured it out from here: #581 . ",
    "svallory": "Hi @ remojansen, thank you for the quick reply. As I suspected, the problem is somewhere in the project, the decorator is fine. I created a simple example later yesterday and could not reproduce the issue either.\nWhat I actually want here is tips on how to find the issue. Something like \"Check the metadata key FOO on the controller\" or \"active debug(\"inversify:injecting\")\" I don't know... I've spend around 10 hours on this and can't find the problem.\nIn my case, the contianer is instantiated in @cashfarm/plow (as a real singleton here, then imported, configured and exported by @cashfarm/tractor (the hapi wrapper) and imported and further configured by the actual project. Ok, I just posted the message before so the scenario where the bug appears is clear. As I published the projects so other people could reproduce the bug, it disappeared.\nMy only guess is that it has something to do with using a container in linked modules. As I can not debug further and add more information, I'm closing this issue. Thank you for the help @remojansen!. Sheeeet! That info about reflect-metadata is really surprising. I had no idea that importing it would delete the metadata. That's really a problem. No library can include an import for it then. Thank you for that, I'll check my OS projects. ",
    "babbarankit": "```\ntype DbConnectionProvider = () => Promise;\ncontainer.bind(SERVICE_IDENTIFIERS.DbClient).to(Connection).inSingletonScope();\ncontainer.bind((context) => {\n  return async () => {\n    const connection : Connection = await createConnection();\n    return connection;\n  };\n});\n```\nI am trying to then use it in\n@Injectable()\n@EntityRepository(UserEntity)\nexport class UserRepository  {\n  public constructor(\n    @inject(SERVICE_IDENTIFIERS.DbClientProvider) private provider: DbConnectionProvider) {}\n    add(input: IUserInput) : Promise<IUserPayload> {\n      //What to do to save? how to access the db??\n    }\n}\nI wish to then use it create/save/edit users using this repositry. I am not clear about my approach.\n. I just created a DB Connection in my index file and then used getConnection() from typeorm in constructor of user repository and my work got done!\nI am still not convinced though if its right way.  will be grateful for a right advice :-)\n(or Feel, free to close the issue)\nThanks. . ",
    "matthewjh": "@remojansen: what exactly is the problem with using Symbol(\"a\")? The reason you were using symbols in the first place was to prevent collisions, no? Using Symbol.for seems little different to using strings, i.e. it collides.. @remojansen: yes, that's right. I presumed people were only using Symbols by declaring them in advance, as you said.\nBut how is Symbol.for(\"XXXX\") any different to just using \"XXXX\" (as a string)? I thought the only justification for using Symbols with inversify was the very fact that they're unique (no collisions), hence my confusion over the PR. :P. @remojansen \nHow will `Symbol.for\" protect you from collisions, though? If you call Symbol.for twice with the same string in the same JS context, you're going to get back the exact same symbol:\nSymbol.for(\"a\") == Symbol.for(\"a\") // true\nSo I don't see how it provides any collision protection over strings. If you have a large team with two classes with the same name, and each team uses Symbol.for(\"CLASSNAME\"), these two symbols will be identical just as if strings were used.. Or are you saying that people can easily switch from Symbol.for to Symbol as and when they encounter collisions?. @remojansen: that would work. I guess I don't see the point in using Symbol.for over a string in that case.\nconst TYPES = {\n  MyType: \"MyType\"\n};\ncan easily be changed to \nconst TYPES = {\n  MyType: Symbol(\"MyType\")\n};\nif uniqueness is desired and vice-versa.\nUsing a string is well-understood; using Symbol.for is more obscure and less clear. People may confuse why you're using Symbol.for over a string, just as I did, given their functional equivalence. Unless you're aiming for uniqueness, I would use strings. And if you are aiming for uniqueness, then use Symbol(\"name\"). That's clearer, IMO.. ",
    "dropdevcoding": "Probably this will help your investigation:\nWith\ninversify: 4.6.0\ninversify-restify-utils: 3.3.1\nrestify: 5.2.1\nthe error does not occur\nwhen upgrading to \nrestify: 6.3.4\nI'm getting the same error\n . ",
    "idandrd": "The documentation states that the use of Symbols is meant to prevent collisions. Using Symbol.for re-introduces this exact problem, rendering the use of Symbols useless, since it now has the exact same effect as using string literals, just with more code.\nAm I missing something here?. ",
    "nicolasgramlich": "A sidenote if it helps debugging, the (unexpectedly) reinitialized singletons also don't have their constructor parameters or attributes re-injected.. ",
    "m3l7": "the problem is in binding.ts, line 62.\nThe snapshot function will clone all the singletons and set them to not activated.\nProbably in the clone function there should be a check whether the class is a singleton? (I'm new to inversify.js, I don't have any idea). @remojansen I've made a PR with a possible solution. Not sure if I took the correct approach though. yeah, actually I didn't check if the instance gets copied or not. Probably the PR is completely wrong. @rostislavprovodenko is there a working to get a new instance of a singleton?\nright now I'm trying something like:\n  inversifyContainer.snapshot();\n  inversifyContainer.unbind(Db);\n  inversifyContainer.bind<Db>(Db).toSelf();\n  let db = inversifyContainer.get<Db>(Db);\n  inversifyContainer.restore();\n\nbut it's not working properly. N.B: the commit reference to a wrong issue (#721). Not sure how to fix the reference. @remojansen ok, right now I'm testing the fix in my project. So far no issues, the singletons are restored correctly. I managed to solve the issue. Basically in my entry point source (the script actually being run) I was importing some modules before loading the inversify.ts module and at the same time I was importing the \"reflect-metadata\" package in every module.\nRemoving the multiple metadata import and keeping the inversify.ts import at the beginning solves.. ",
    "SylvainEstevez": "@remojansen Any news on this one? Snapshots are a awesome for tests, but if I can't use them with singletons (think database instances for examples), then I'm afraid I'm can't use them at all, which removes a good part of DI benefits :(. ",
    "guruprasadgvmf": "same issue as above, since the singletons have already been created, rebind doesn't have any effect making it hard to unit test.. ",
    "cyberhck": "Hi, thanks for your immediate response, I love it, I didn't know inversify had that. I have one follow up question.\nDoes this also work with static methods?\nI'll close this issue, I'm really happy that @injectable does that, I thought @injectable is only for making a class injectable.. ",
    "btkostner": "Looking at the code, it seems this is by design.\n\n// Throw if a derived class does not implement its constructor explicitly\n // We do this to prevent errors when a base class (parent) has dependencies\n // and one of the derived classes (children) has no dependencies. \n",
    "silkentrance": "A PR for this can be found here https://github.com/inversify/inversify-inject-decorators/pull/48. ",
    "DonJayamanne": "@remojansen Thanks for the response, I'll ping @rbuckton.\nIs it possible for Inversify not to use reflect-metadata or for a user of Inversify to provide the functionality exposed by reflect-metadata (by providing its own API for storage and retrieval of the metadata)?\nAt the end of the day reflect-metadata is not an optional module of inversify, users of inversify MUST install reflect-metadata.\n. ",
    "rbuckton": "This should now be fixed in reflect-metadata@0.1.12 or later. However, if an earlier version of reflect-metadata (<= 0.1.10) is loaded after the 0.1.12 version, this problem will still occur.. ",
    "NaJ64": "I am hoping @remojansen & @rbuckton may be able to provide some insight here...\nFor one of our front-end projects we are currently using InversifyJS as well as Aurelia and Webpack 3 (via aurelia/webpack-plugin and aurelia/bootstrapper)  The issue described above with reflect-metadata@0.1.10 actually provided unintended behavior that we considered advantageous up until updating to reflect-metadata@0.1.12.\nI believe the recommended usage for the Aurelia webpack-plugin is to pair it with either the aurelia/bootstrapper or aurelia/bootstrapper-webpack module as the entry point being\nspecified in webpack.config.js.  These modules bootstrap the aurelia app by searching the DOM and subsequently loading your main/index.js file where we have our import 'reflect-metadata'.\nUnfortunately, the Aurelia bootstrapper(s) will first load aurelia/polyfills which includes a Reflection API implementation.  For some reason, this implementation was causing the InversifyJS injectable() decorators to be ignored at run-time when resolving dependencies from the container.  I am not sure how the implementations differ between rbuckton/reflect-metadata and aurelia/polyfills, but to make a long story short our application only works if reflect-metadata overrides the other Reflection polyfill.\nSince the Aurelia Reflect polyfill always got \"clobbered\" by our initial import 'reflect-metadata', we never had any issues until the most recent changes came in reflect-metadata@0.1.12.  However, a recent npm install revealed this issue (and led me here.)\nI realize this is more of an issue with the Aurelia bootstrapping code for Webpack rather than InversifyJS or even reflect-metadata, but i still wanted to point out that the change in behavior could have adverse effects on users of InversifyJS / Aurelia / Webpack if they actually WANT reflect-metadata to override other polyfills.. ",
    "mnifakram": "sorry it was my mistake used @injectable instead of @injectable(). ",
    "anteburazer": "Thanks @remojansen for the response.\nI will definitely try it out and give you a feedback if anything goes wrong.. ",
    "jan-molak": "Thanks for the prompt reply, @remojansen! Yes, I've gone through the @controller code already and noticed that it's also retrieving the controllers bound to the container, so I was hoping that binding could be done explicitly.\nUsing @controller as a function is a lovely idea, thanks for that :) I think I could do that as part of my container module definition to keep it clean:\n```typescript\nexport const context = new ContainerModule((bind: interfaces.Bind) => {\n    bind(Types.SomeMicroservice).to(SomeMicroservice);\ncontroller('/api/some-service', ...someMiddleware)(SomeRestAdapterForMyMicroservice);\n\n});\n```\nThis way the controller is only registered when the ContainerModule is loaded. Granted, as a side effect, but I can live with that until ZafiroJS is ready.\nThanks for your help!\nJan\n. ",
    "npetersz": "Hi!\nAre you still working on the auto-generation of OpenApi specification feature?. ",
    "lonix1": "@jan-molak Your solution is outstanding for another reason too:\nI can easily define paths without using magic strings! That is not easy or neat to do within a decorator.\n@remojansen This approach is so good it should be added to the docs as an alternative. The benefits as I see them are:\n- registration is explicit: it doesn't occur as a side effect, and so is predictable and maintainable and testable\n- eliminates magic strings in paths (can be kept in one place, e.g. a config class)\nEDIT:\nThat eliminates magic string on the controller, but the action methods still have magic strings... :disappointed: . I don't think this applies anymore, it works for me.\nI throw from a route, and my error handler kicks in.. @lefebvresam Did you figure it out?. Seems inversify won't work on the express server without it. I don't understand why, but it is needed after all.. ",
    "kristianmandrup": "Ah, I guess they are just string values (ids), so they could be fx \"Ninja\" for ninjaId etc.. Thanks a lot for the explanation. I didn't notice any documentation on ids, but might be scattered around. The example in point didn't make it clear, would have to search/read all the docs then in any case. . Thanks @remojansen :) I think the first one is a beautiful example demonstrating various techniques and would fit well in the wiki as an example for how to customise a setup using the inversify API.\nI will for sure use the first technique, as it is more efficient and more clear. Makes perfect sense. \nJust didn't know to use toFactory or how to use it properly. Thanks again. Made my day :). Thanks for adding it to wiki, however in the wiki entry.\nYou start out by saying: a Warrior has a property named weapon ...\nBut in your example, there is only a Character class, no Warrior class. \nAlso, the example looks overly complex for my needs. What do you need the OrphanWeapon for?\nI guess this is for when no weapon is assigned (yet?)?\nFor this part:\njs\n  public constructor(\n    @inject(TYPE.FactoryOfWeapon) factoryOfWeapon: FactoryOfWeapon\n  ) {\n    this.name = \"Ninja\";\n    this.weapon = factoryOfWeapon(this);\n  }\nI'm mainly interested in being able to inject the class (or factory) being used, without auto-instantiating an instance on injection, so that I can then used the injected class/factory in the constructor block passing this as argument, in order to pass the parent instance to the delegate class.\nWould sth like the following be possible as well?\njs\n  public constructor(\n    @inject(TYPE.Weapon) Weapon: IWeapon\n  ) {\n    this.name = \"Ninja\";\n    this.weapon = new Weapon(this);\n  }\nThanks.\n. Trying to scale you example to my use case, with one class having multiple (up to 5 or even 10) delegate classes...\n```js\nimport { inject, injectable, Container, interfaces } from \"inversify\";\nimport \"reflect-metadata\";\ntype FactoryOfWeapon = (parent: IWeaponHolder) => IWeapon;\ntype FactoryOfShield = (parent: IShieldHolder) => IShield;\nconst TYPE = {\n  OrphanWeapon: Symbol.for(\"OrphanWeapon\"),\n  OrphanShield: Symbol.for(\"OrphanShield\"),\nFactoryOfWeapon: Symbol.for(\"FactoryOfWeapon\"),\n  FactoryOfShield: Symbol.for(\"FactoryOfShield\"),\nWeaponHolder: Symbol.for(\"WeaponHolder\"),\n  ShieldHolder: Symbol.for(\"ShieldHolder\")\n};\ninterface IHolder {\n  name: string;\n}\ninterface IShield {\n  parent: IShieldHolder;\n}\ninterface IWeapon {\n  parent: IWeaponHolder;\n  use(): string;\n  owner(): string;\n}\ninterface IShieldHolder extends IHolder {\n  name: string;\n  shield: IShield;\n}\ninterface IWeaponHolder {\n  name: string;\n  weapon: IWeapon;\n  fight(): string;\n}\n@injectable()\nclass Weapon implements IWeapon {\n  private readonly _name: string;\n  public parent: IWeaponHolder;\npublic constructor(name: string) {\n    this._name = name;\n  }\npublic use() {\n    return this._name;\n  }\npublic owner() {\n    return Owned by ${this.parent.name}!;\n  }\n}\n@injectable()\nclass Shield implements IShield {\n  private readonly _name: string;\n  public parent: IShieldHolder;\npublic constructor(name: string) {\n    this._name = name;\n  }\npublic use() {\n    return this._name;\n  }\npublic owner() {\n    return Owned by ${this.parent.name}!;\n  }\n}\n@injectable()\nclass Character implements IWeaponHolder, IShieldHolder {\n  public weapon: IWeapon;\n  public shield: IShield;\npublic name: string;\n  public constructor(\n    @inject(TYPE.FactoryOfWeapon) factoryOfWeapon: FactoryOfWeapon,\n    @inject(TYPE.FactoryOfShield) factoryOfShield: FactoryOfShield\n  ) {\n    this.weapon = factoryOfWeapon(this);\n    this.shield = factoryOfShield(this);\n  }\n  public fight() {\n    return Using ${this.weapon.use()}!;\n  }\n}\nconst container = new Container();\n// We declare a binding for Weapon so we can use it within the factory\ncontainer.bind(TYPE.OrphanWeapon).to(Weapon);\ncontainer.bind(TYPE.FactoryOfWeapon).toFactory(\n  (ctx: interfaces.Context) => {\n    return (parent: IWeaponHolder) => {\n      const orphanWeapon = ctx.container.get(TYPE.OrphanWeapon);\n      orphanWeapon.parent = parent;\n      return orphanWeapon;\n    };\n  });\ncontainer.bind(TYPE.OrphanShield).to(Shield);\ncontainer.bind(TYPE.FactoryOfShield).toFactory(\n  (ctx: interfaces.Context) => {\n    return (parent: IShieldHolder) => {\n      const orphanShield = ctx.container.get(TYPE.OrphanShield);\n      orphanShield.parent = parent;\n      return orphanShield;\n    };\n  });\n// How can I make this scale to 5 or more child classes (delegates) that can be injected on a parent class??\n// Where do I configure the Weapon and Shield being used (injected) !?\n// does this make sense? yes, if character is a singleton\ncontainer.bind(TYPE.WeaponHolder).to(Character);\ncontainer.bind(TYPE.ShieldHolder).to(Character);\nconst character = container.get(TYPE.WeaponHolder);\nconsole.log(character.fight());\n// weapon has owner\nconsole.log(character.weapon.owner());\n// breaks here, since I get Character as an IWeaponHolder which is not compatible with IShieldHolder\nconsole.log(character.shield.owner());\n```\nThis doesn't scale. Breaks down on adding a second child class. I would then somehow have to use a more generic IHolder interface in the mix. Any ideas how this can be resolved or scaled better?\nThanks again!. Ideally, I think to scale this I would need to use a custom decorator, similar to the one used in Angular components, with a list of classes to be injected, and then the decorator handles correct injection. This is the basic pattern I'm trying to use, where the delegate classes are then configurable/injectable so that they can be easily substituted in different environments (such as for testing etc.)\n```js\n export class Flow extends Context {\n  protected executer: FlowExecuter = new FlowExecuter(this)\n  protected builder: FlowBuilder = new FlowBuilder(this)\n  protected errorHandler: FlowErrorHandler = new FlowErrorHandler(this)\n  protected statusHandler: FlowStatusHandler = new FlowStatusHandler(this)\nconstructor(public configs = {}) {\n    super()\n  }\n}\n``. Ideally I'd like a new@injectClassdecorator which gives me a class from the container which I can then call the constructor on withthis, or even better, return a higher level no-args function wherethis` is already implicitly set to the parent class or sth.\nAlso experimenting with custom decorators...\n```js\n@delegates({\n  configuration: MyConfiguration,\n  executer: MyExecuter,\n})\nclass MyPerson {\n  public name: string;\n  configuration: IConfiguration\n  executer: IExecuter\nconstructor(name: string = 'kristian') {\n    console.log('MyPerson', {\n      name\n    })\n  }\n}\n```\n. That looks awesome! Thank you! Would be a good example for illustrating use of contextual constraints, so perhaps add it to the wiki as well.\nFor now I've resorted to writing my own class decorators and containers to perfectly suit my needs and requirements. Will likely publish it as a library shortly. . ",
    "juanenrisley": "@remojansen Hi! I am facing the same problem. I have two modules, let's call them A and B. Module A exports all classes that I want to be injected and module B exports the inversify configuration (container initialization, bindings declaration and decorators creation). I think that the problem comes with circular dependency. Module A is imported in module B to declare the bindings and module A imports the lazyInject decorator from module B, then the error occurs.. ",
    "Halynsky": "I had a similar issue because lazyInject was exported from my configuration after it was used in service. So that's why it was undefined in runtime.. The same case I wanted to reproduce with @lazyInject but unfortunately, it doesn't work. I have another error but still. \nHere is a sample of my code:\n```\nimport { FooService } from \"../services/FooService\";\nimport { HelperService } from \"../services/HelperService\";\nexport const container = new Container();\nexport const { lazyInject } = getDecorators(container, false);\nimport { FooService } from \"../services/FooService\";\nimport { HelperService } from \"../services/HelperService\";\ncontainer.load(buildProviderModule());\ncontainer.get(FooService);\ncontainer.get(HelperService);\n======================================\n@provideSingleton(FooService)\nexport class FooService {\n@lazyInject(HelperService) helperService: HelperService;\n\nconstructor() {\n    setTimeout(() => {\n        console.log(this.helperService);\n    }, 2000)\n}\n\n}\n@provideSingleton(HelperService)\nexport class HelperService {\n@lazyInject(FooService) fooService: FooService;\n\nconstructor() {\n    setTimeout(() => {\n        console.log(this.fooService);\n    }, 3000)\n}\n\n}\nSo at runtime, I am getting an error. throw new Error(ERROR_MSGS.NULL_ARGUMENT); Error: NULL argument``` It is thrown becouse FooService in the HelperService is null. But interesting thing is that HelperService in the FooService is defined. So I tried to investigate what is the reason for such behavior. And the reason is an order of imports of this services into the main file like app.ts or inversify.config.ts\nimport { FooService } from \"../services/FooService\";\nimport { HelperService } from \"../services/HelperService\";\nProperty service is allways undefined in second imported service. I think its not correct behavior of lazyInjection.\nYour Environment\n\"node\": \"9.11.1\"\n    \"inversify\": \"4.13.0\",\n    \"inversify-binding-decorators\": \"4.0.0\",\n    \"inversify-express-utils\": \"6.1.0\",\n    \"inversify-inject-decorators\": \"^3.1.0\",\n    \"inversify-logger-middleware\": \"3.1.0\",\n. It is normal behavior. In your case, you wrote the same method twice. So only one of them is registered by the server. You have two methods with the same path \"/\". It is similar logic to a signature of the method in some languages. You cant create two methods with the same signature (@queryParam are not a part of signature). So just make another pass for your second method.. It seems that you trying to call your service from the container before it is created and binded in it. Check your call stack. You need to be sure that first you are importing and binding your services and then you are trying to get them from the container. For simple test just put some logging in the constructor of target service.. Can you show original ts code?. I have tried to reproduce the same case (A injected in B. B injected in A.) with @lazyInject but also getting an error. And also I tried an example with the service identifier.\nhttps://github.com/inversify/InversifyJS/issues/865. ",
    "timargra": "Same issue here. Tried every suggestion here, but still get this error.. ",
    "RPallas92": "@remojansen  How can we bind HttpContext in integration tests? \nWe are getting Error: No matching bindings found for serviceIdentifier: Symbol(HttpContext)\nAnd it does not allow me to bind a mock HttpContext, if I try to do:\ncontainer.rebind<interfaces.HttpContext>(\"HttpContext\")\n    .toConstantValue(MockHttpContext)\nI get the following error:\nnode_modules/inversify/lib/container/container.js:174\n            throw new Error(ERROR_MSGS.CANNOT_UNBIND + \" \" + serialization_1.getServiceIdentifierAsString(serviceIdentifier));. Ok I fixed by, first, creating a MockHttpContext:\n```\nimport { mockReq, mockRes } from 'sinon-express-mock'\nimport { interfaces } from \"inversify-express-utils\"\nconst mockRequest = mockReq()\nconst mockResponse = mockRes()\nconst mockUser: interfaces.Principal = {\n    details: \"\",\n    isAuthenticated: () => Promise.resolve(true),\n    isResourceOwner: () => Promise.resolve(true),\n    isInRole: () => Promise.resolve(true)\n}\nexport const mockHttpContext: interfaces.HttpContext = {\n    request: mockRequest,\n    response: mockResponse,\n    user: mockUser\n}\n```\nAnd second injecting it this way:\n```\nconst injectMockHttpContext = (container: Container) => {\n    container.bind(Symbol.for(\"HttpContext\")).toConstantValue(mockHttpContext)\n}\ndescribe(\"AuthorizationService\", () => {\n    injectMockHttpContext(container)\n    const authorizationService = container.get(TYPES.AuthorizationService)\n```. ",
    "brunoscopelliti": "Any thoughts?\nAs workaround, I'm now not using Container.merge; I pass a reference to the container instance to  each module, that possibly could register new interfaces on it. This works nicely, but Container.merge would have been a cleaner/simpler solution (at least in my case).. Yep. I did what stated in my previous comments.\nI opened this issue mostly cause I was surprised by the default behaviour.. ",
    "BMalaichik": "@brunoscopelliti \nHm, looks interesting\nWhy do you need multiple containers to be used over applications?\nyou can share single merged container instance\nyour approach seems illogical to me.\nIf you need to have some overrides\\add-on's, you can use container modules & load them on demand\nhttps://github.com/inversify/InversifyJS/blob/master/wiki/container_modules.md. ",
    "lrembacz": "Any updates here? I guess ContainerModules works the same so singleton is not rly singleton.  @brunoscopelliti, did you solve your problem any nice way? \nMy solution for now is just calling static method which return one instance. But it would be better if Modules or Merge would actually grant this out of the box i think.\nbind<LoadingMediatorInterface>(SHARED.LoadingMediatorInterface)\n    .toDynamicValue(() => {\n       return LoadingMediator.getInstance\n    });. There is actually a simple fix available in merge function. We just need to check if scope of binding is a Singleton and we are just passing reference instead of cloning binding.\nhttps://codesandbox.io/s/olmkvvpmx5\nIt could be done with argument in merge function as well.. ",
    "zveljkovic": "Will this be included soon into master?. ",
    "omairvaiyani": "+1 I have resorted to inRequestScope instead and added some workaround checks to ensure my class (which should otherwise be a singleton) does not repeat initialisation steps when re-instantiated.  Would very much appreciate this being merged! I also came across the bug during unit testing with snapshots.. ",
    "dcherman": "I hacked up a proof of concept that I'm using inside of an existing project, and it's working pretty well so far.\nhttps://gist.github.com/dcherman/5b84d0598c7e985e125b130e05dfea3e\nThat's not quite how I'd implement it in the actual library since I'm abusing types a bit by returning a function and calling it an HttpResponseMessage in order to work with the existing API, but the basic concept works fantastically.\nUnit testing is great as well since you can just do stuff like:\nconst response = await instance.getResource('someid');\nexpect(response.statusCode).toBe(200);\nexpect(response.content).toBe('foo');\nAnd there is no need to worry about mocking the entire HttpContext and subsequently inspecting specific properties of the response. So I'm starting to work on this off and on; got a question for you.  How far would you like to go with this API?  Most of the helper methods in Web API 2 returns IActionResult versus HttpResponseMessage, however IActionResult only makes sense if we start to consider implementing more of the full feature set of Web API, and I'm not sure whether or not that is something you want to support going forward as a part of the publicly supported API here.\nWhile I'm only implementing a minimal set of APIs in this first go-round rather than the entirety of the APIs, changing the return value from HttpResponseMessage to IActionResult would be a breaking change in the future, so I wanted to get your thoughts on where you see this going.. I would say yes.  I am not planning to expose all of the public properties for the various ActionResults at this point in time, but just a minimal set to accomplish each of them.  We can consider exposing additional properties as use cases that need them come up.. Closing this out since this was implemented a while back.. Since HttpContext can only ever exist in a per request scope and at the time that top level middleware is bound, that can't be available, the way that you're trying to do this will probably not be feasible.\nLooking at the code, there is no point in time where you can inject a global middleware that can receive per request injections.\nhttps://github.com/inversify/inversify-express-utils/blob/01725a5eb7bbad0de08326472ea10ee134a90424/src/server.ts#L224\nProbably wouldn't be a bad idea to implement something like Web API's various filter interfaces like https://msdn.microsoft.com/en-us/library/system.web.http.filters.iauthenticationfilter(v=vs.118).aspx\n(Not a maintainer here, just a drive by suggestion)\n. \ud83d\udc4d \nA misunderstanding of how Symbols work doesn't mean that we should change examples to use something that has the potential for global collisions.  Instead, we should encourage people to learn how Symbols work by linking to MDN documentation, examples, etc.\nEnough people just straight copy and paste examples that they should be based on best practices with explanations about why it's being done in a particular way.. ",
    "ankitcf": "Makes sense. Only required in some rare cases where it is needed to store\nsome state at server level. e.g. We have a controller which just returns a\nboolean status that is used by load balancer to direct traffic. During\ndeployments we first make the controller return bad status so that load\nbalancer stops sending traffic to this instance before we stop this server\nand upgrade it. We were storing this in the singleton controller itself in\na variable.\nIf no other solution exists, we will move this to another singleton class.\nJust curious but isn't creating a new controller object for every request\ncostly for high throughput systems ?\nOn Thu, 1 Feb 2018, 20:36 Remo H. Jansen, notifications@github.com wrote:\n\n@ankitcf https://github.com/ankitcf this was a delivered decision with\nthe goal of supporting request scope because it was needed to support\nHttpContext and AuthProvider. You can make the dependencies of your\ncontroller singleton with inSingletonScope or inRequestScope (singleton\nper HTTP request). Why do you need a singleton at controller level? Maybe I\ncan help you to find an alternative way.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/inversify/InversifyJS/issues/781#issuecomment-362293422,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AUXy2C-9srRVOmAO2t5uDFVmMcAKB6zHks5tQdLjgaJpZM4R1nmn\n.\n. \n",
    "kevynb": "Hello, Really sorry for not responding in due time.\nI'm convinced this would have worked but we changed the way the apps were built and the problem disappeared. \nThanks for your time, Inversify is a great library!. ",
    "leoperria": "Great ! . ",
    "mactanner": "@AltekkeE thanks for your reply.\nI did the same changes to my code. Unfortunately that doesn't work for me yet.\nThere's only one chunk mentioned on the console. file.on('end', (),... is never reached.\nOUT File [DSC_0040.JPG] got 572 bytes\nThat's probably the reason why I didn't get the Can't set headers after they are sent. error...\nIs that maybe a problem with my setup of the inversify express server?\nconst server = new InversifyExpressServer(container);\n    server.setConfig((application: express.Application) => {\n        application.use(absoluteUrlMiddleware(container));\n        application.use(cors());\n        application.use(bodyParser.urlencoded({ extended: true }));\n        application.use(bodyParser.json());\n        application.enable('trust proxy');\n    });\n. ",
    "Place1": "To use inversify with react you need to use lazy injection because the container isn't responsible for constructing your react components, react is.\nHave a look at this library: https://github.com/inversify/inversify-inject-decorators\nOr this other library that I created to reduce boilerplate as well as provide lazy injection: https://github.com/Place1/inversify-stereotype-decorators\nLazy injection is basically just a new decorator that already knows about the IoC container. This allows the decorator to resolve dependencies itself rather than requiring the class to be created by the container itself, this get you around most of the hurdles in react.. ",
    "DaZiYuan": "I already used typescript-ioc,it seems work. ",
    "JerryYu2014": "@AltekkeE thank you for your reply.\nMy code sample show as below:\nILogger.ts:\ntypescript\nexport interface ILogger {\n    info(obj: any): void;\n    debug(obj: any): void;\n    error(obj: any): void;\n    fatal(obj: any): void;\n}\nloggerType.ts\ntypescript\nconst LoggerType = {\n    Logger: Symbol.for('Logger')\n};\nexport { LoggerType };\nlog4jImp.ts\ntypescript\nimport { injectable, inject } from 'inversify';\nimport 'reflect-metadata';\nimport * as path from 'path';\nimport { ILogger } from '../interfaces/ILogger';\nimport { LoggerType } from '../types/loggerType';\nimport * as log4js from 'log4js';\n@injectable()\nclass Log4jImp implements ILogger {\n    private logger: log4js.Logger;\n    constructor(category: string) {\n        log4js.configure({\n            appenders: {\n                file: {},\n                dateFile: {},\n                out: { }\n            },\n            categories: {\n                default: { appenders: ['file', 'dateFile', 'out'], level: 'info' }\n            }\n        });\n        this.logger = log4js.getLogger(category);\n    }\n    public debug(obj: any) {\n        this.logger.debug(obj);\n    }\n    public info(obj: any) {\n        this.logger.info(obj);\n    }\n    public error(obj: any) {\n        this.logger.error(obj);\n    }\n    public fatal(obj: any) {\n        this.logger.fatal(obj);\n    }\n}\nexport { Log4jImp };\ninversify.config.ts\n```typescript\nimport { Container } from 'inversify';\nimport { LoggerType } from './types/loggerType';\nimport { ILogger } from './interfaces/ILogger';\nimport { Log4jImp } from './implements/log4jImp';\nconst IocContainer = new Container();\nIocContainer.bind(LoggerType.Logger).to(Log4jImp);\nexport { IocContainer };\n```\nI resolve dependency like this:\n```typescript\nimport { IocContainer } from '../inversify.config';\nimport { LoggerType } from '../types/loggerType';\nimport { ILogger } from '../interfaces/ILogger';\nconst log4jHelper = IocContainer.get(LoggerType.Logger);\nlog4jHelper.info('garden server has started!');\n``\nbut I don't know how to pass initialization parameters toconstructor(category: string)inlog4jImp.ts`.\n. ",
    "zachrbrown": "You'd probably want to bind the initialization parameters to a constant or dynamic value and let the container inject them into the constructor for you.\ntypescript\n// inversify.config.ts\nconst container = new Container();\ncontainer.bind<ILogger>(LoggerType.Logger).to(Log4jImp);\ncontainer.bind('LoggerCategory').to('myCategory');\ntypescript\n@injectable()\nclass Log4jImp implements ILogger {\n    constructor(@inject('LoggerCategory') category: string) {\n        // ...\n    }\n}. ",
    "AdelBachene": "I'm facing the same Issue, and you cannot inject all constructor variable because the will be called in different locations, did anyone figure out a better solution?. ",
    "chapterjason": "@zachrbrown \nThat's not so nice.\ncontainer.bind('LoggerCategory').to('categoryA');\nconst aLogger = IocContainer.get<ILogger>(LoggerType.Logger);\ncontainer.bind('LoggerCategory').to('categoryb');\nconst BLogger = IocContainer.get<ILogger>(LoggerType.Logger);\nSomething like this would be better.\nconst aLogger = IocContainer.get<ILogger>(LoggerType.Logger, 'categoryA');\nconst BLogger = IocContainer.get<ILogger>(LoggerType.Logger, 'categoryB');. ",
    "paulspiteri": "I think all autoBindInjectable does is bind a type (E.g. TravelAgentServer) to itself. \nThat would allow you to .get() that concrete type explicitly (not via your TYPES.ITravelAgentServer symbol)\nI might be wrong though but that's my understanding.. Container.Merge has the same problem too. ",
    "hong-duc": "After a while I get it. So I must return promise reject and it will call the next(error) and I cannot call it by my self. ",
    "vemuez": "Hi @hong-duc, is it possible to share an example of how you resolved this issue, i'm having the exact same problem haha, but I'm using try and catches \ud83d\ude04 . Nevermind, I missed out a section from the docs. I didn't see server.setErrorConfig(). ",
    "jacobEAdamson": "Oh thanks, glad you liked it :D\nOn April 13, 2018 12:59:28 AM \"Remo H. Jansen\" notifications@github.com\nwrote:\n\nHi @jacobEAdamson https://github.com/jacobEAdamson awesome PR! thanks a\nlot for this contribution \ud83d\udcaf\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/inversify/InversifyJS/pull/841#issuecomment-381056330,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AA8JBKLF4fHG-qSgCW7EKDb_ZO1Cb2iOks5toFrfgaJpZM4TFwzz\n.\n. \n",
    "rtang03": "How can I install this latest build? The npmjs repo does not include this feature yet.. ",
    "hlibco": "Hi @remojansen I saw you closed the issue #703 (similar to the one I just opened) by suggesting to upgrade to restify@6.3.4. It didn't work to be (but 6.3.2 did). However, upgrading to restify@7.1.1 (latest - at the time of this post), the error persists.\nAny idea of how inversify-restify-utils users should proceed?. The inversify-restify-utils on github has its dependencies being updated by greenkeeper. That's great. It would be even better if the up-to-date version on github could be published to NPM. It would fix the #847\nI manually changed the version of restify which inversify-resity-utils dependends on (from 6.3.2 to 7.1.1) and it fixed the issue.\n. ",
    "mgebundy": "I'm also blocked upgrading to the most recent versions of Inversify and Restify by this. Could a new version be published to npm? That would be incredibly helpful.. @hlibco inversify-restify-utils has been updated, the new v3.4 should be compatible with the most recent version of inversity and restify v7. @remojansen cheers, i appreciate you taking the time, good luck with the book!\nI'll continue making PRs where needed to that repo, and we'll be happy to take on its maintenance, seeing as we use restify in the majority of our nodejs services.. ",
    "jinghualin": "I resolved this problem in current version\n - restify@7.2.1\n - inversify@4.13.0\n - inversify-restify-utils@3.3.1\n - typescript@2.9.1\nwith manually install restify-errors.\nFrom restify version 6 I have same problem, when I do not install the restify-errors module.\n. ",
    "Bon4ik": "@AltekkeE I had a trouble with creating container with a few nested services. Do u know how to do it??\nSomething like this \ncontroller = new UserController(new UserService(new MongoDBClientMock()));\n but with container.. @AltekkeE thanks a lot. It works. Can u help me with this question: https://github.com/inversify/inversify-express-example/issues/327 ?? I will be very thankful ??. @JoA-MoS What r u trying to do? Can u share some part of code?? If u would like just to mock some util function which not connected to inversify u can use rewire or something like this :\n```\nimport { someFunction } from 'utils/someFunction';\njest.mock('utils/someFunction');\nsomeFunction.mockReturnValue(value);\n```. ",
    "JoA-MoS": "@Bon4ik I dont see jest having a mock function on the global scope. I see jest.mock() which can be used to auto mock a file. How did you make this work?. ",
    "josecolella": "@dcavanagh Do you have an example where the controller has middleware. Or would that not be tested in the controller.test?. Having the same issue. @jwldnr Please share if you are able to fix it. @viglucci I'm using inversify on a server-side application. Webpack provides optimized builds that minimize as well as provides other features. I understand your point of using tsc, but I would like to understand why this does not work?. By changing the transform function from:\nts\nprivate getRequestOptions(queryParameters: { [key: string]: string }): rp.OptionsWithUri {\n    return {\n      uri: `${this.host}/endpoint`,\n      method: 'GET',\n      json: true,\n      headers: { Token: this.jwtToken },\n      simple: false,\n      family: IP.V4,\n      qs: queryParameters,\n      transform2xxOnly: true,\n      transform: this.transformResponse\n    };\n  }\nto:\nts\nprivate getRequestOptions(queryParameters: { [key: string]: string }): rp.OptionsWithUri {\n    return {\n      uri: `${this.host}/endpoint`,\n      method: 'GET',\n      json: true,\n      headers: { Token: this.jwtToken },\n      simple: false,\n      family: IP.V4,\n      qs: queryParameters,\n      transform2xxOnly: true,\n      transform: (body) => this.transformResponse(body)\n    };\n  }\nThe returnType now maps to the type I want to construct. Is there a better way?. ",
    "pondpremt": "Upgrading to 6.0.0 doesn't seem to solve the problem. requestBody implementation doesn't change from 5.2.2 to 6.0.0. Is the decision to get rid of 'name' parameter intentional/permanent?. ",
    "madshargreave": "Interested in this as well. ",
    "rmvermeulen": "use decorate, also from inversify.\nimport { decorate, injectable } from 'inversify'\ndecorate(injectable(), SomeClass)\n. ",
    "RastriginSergey": "@rmvermeulen Thank you!. ",
    "josete89": "+1. ",
    "jlopezmartinez": "+1. ",
    "bodograumann": "Yes, please fix this.\nThis was my first proper encounter of Symbols and it was quite confusing to say the least.\nI'm still not sure if there is any real difference between using \"Ninja\" vs. Symbol.for(\"Ninja\").\nTo prevent naming conflicts you definitely have to use Symbol(\"Ninja\").\nThe caveat of that solution is that you have to access the symbol definition from everywhere that you want to inject something, plus in your composition root.. I have the same problem. My injectable classes live in their own packages. Now I changed the interface of one injected dependency, but there was no error message, because the identifier stayed the same.\nUsing classes as identifiers would not work, because the child package should not be aware of the parent package or any other global type storage.. This does look kind of convenient, but I\u2019m not sure it can work for my use case.\nConsider that there are two independant packages, which define their own TokenStorage interface, say TS1 and TS2 for brevity. Will the bind directive assign the implementation LocalStorageBasedTokenStorage which implements TokenStorage, to TS1 and TS2, when those are copies of TokenStorage, not the original class itself?\nSo I guess what I\u2019m asking is, is this actual type checking, or checking identity of the class used as type identifier?. Thanks for the suggestion, I will try this out.\nAnother way to write it, fyi:\ntypescript\ncontainer.bind(TokenStorageTS2).toService(TokenStorageTS1);. What I found out:\n\n\nYou can leave away the @inject, but only if you leave it away for all the arguments. As I need to mix string service identifiers and class service identifiers, the @inject needs to stay (for now).\n\n\nThe type error message, when something goes wrong is a little confusing.\n\n\nConsider this toy example:\n```typescript\n  import \"reflect-metadata\";\n  import { Container, injectable, inject } from \"inversify\";\nabstract class Warrior {\n    abstract fight(): string;\n  }\nabstract class Weapon {\n    abstract hit(): string;\n  }\nabstract class ThrowableWeapon {\n    abstract throw(): string;\n  }\n@injectable()\n  class Katana implements Weapon {\n    public hit() {\n      return \"cut!\";\n    }\n  }\n@injectable()\n  class Ninja implements Warrior {\n    public constructor(private weapon: ThrowableWeapon) {}\npublic fight() { return this.weapon.throw(); }\n\n}\nconst myContainer = new Container();\n  myContainer.bind(Weapon).to(Katana);\n  ```\nNow when we incorrectly bind Katana to ThrowableWeapon with\n  typescript\n  myContainer.bind(ThrowableWeapon).to(Katana);\n  we get a nice error message:\nArgument of type 'typeof Katana' is not assignable to parameter of type 'new (...args: any[]) => ThrowableWeapon'.\n    Property 'throw' is missing in type 'Katana' but required in type 'ThrowableWeapon'.\nWhen we try to use toService though\n  typescript\n  myContainer.bind(ThrowableWeapon).toService(Weapon);\n  the error message is not helpful at all:\nArgument of type 'typeof Weapon' is not assignable to parameter of type 'string | symbol | Newable<ThrowableWeapon> | Abstract<ThrowableWeapon>'.\n    Type 'typeof Weapon' is not assignable to type 'Newable<ThrowableWeapon>'.\n      Cannot assign an abstract constructor type to a non-abstract constructor type.\n\nWhen using bind(ThrowableWeapon).toService(Weapon), inversify does not type check Katana against ThrowableWeapon, but instead checks Weapon against ThrowableWeapon.\n\nSo if we had a Katana that implemented both Weapon and ThrowableWeapon, we would have to use a more complex syntax to achieve proper type checking. Directly binding both to different instances of Katana would work of course. Otherwise the following does the trick:\ntypescript\n  myContainer.bind(Katana).toSelf().inSingletonScope();\n  myContainer.bind(Weapon).toConstantValue(myContainer.get(Katana));\n  myContainer.bind(ThrowableWeapon).toConstantValue(myContainer.get(Katana));\nIt is not very beautiful though.\nLuckily this case is rare.. What I currently do, but which seems a little ugly, is the following:\ntypescript\ncontainer\n  .bind<IAddFoodLog & IGetFoodLogById>(TYPES.AddFoodLog)\n  .to(InMemoryFoodLogRepository).inSingletonScope();\nconst foodLogInstance = container.get<IAddFoodLog & IGetFoodLogById>(TYPES.AddFoodLog);\ncontainer\n  .bind<IGetFoodLogById>(TYPES.GetFoodLogById)\n  .toConstantValue(foodLogInstance);\n. Have you tried using transitive bindings?. ",
    "asdanilenk": "Merged with PR above.. Hi @dcavanagh , I'm talking about this PR \nhttps://github.com/inversify/InversifyJS/pull/882. ",
    "TheAifam5": "Maybe that help you: https://github.com/inversify/InversifyJS/blob/master/wiki/provider_injection.md. ",
    "ifree92": "Actually I'm looking for the same functionality.\nTo be able to have provided instance automatically and delegate execution async factory to inversify, instead call it manually . ",
    "episage": "+1, looking for the same thing for transparent Unit of Work implementation. ",
    "whyvra": "+1. Do you have an example in a controller of your solution? Or can we get this fix? This is currently stopping me from using inversify-express-utils at all! I need view engine support :/. ",
    "aescarcha": "I had the same issue, wrapping the res.render() in a Promise worked, but not ideal.. Hi, in my solution all the controllers extend an abstract BaseController which has the custom render method. this is my code:\n@injectable()\nexport abstract class BaseController {\n    public render(res: express.Response, template: string, options = {}): Promise<string> {\n        return new Promise<string>((resolve, reject) => {\n            res.render(template, options, (err, compiled) => {\n                if (err) {\n                    console.log(err);\n                    reject('500 when rendering the template');\n                }\n                resolve(compiled);\n            });\n        });\n    }\n}\n```\n@controller('/')\nexport class ListingController extends BaseController {\nconstructor(@inject(TYPES.ApiService) private apiService: ApiService) {\n    super();\n}\n\n@httpGet('/')\npublic async get(\n    @request() req: express.Request,\n    @response() res: express.Response,\n) {\n    // Do things...\n    const data: IListingData = await this.apiService.get(params);\n    return this.render(res, 'listing/listing', data);\n}\n\n}\n```\nI hope it helps!. ",
    "AshMcConnell": "Hi Folks,\nFound the issue.  I am using file:// for my npm dependencies.  There is a bug with yarn that copies over the node_modules when using local file.  See here: - https://github.com/yarnpkg/yarn/issues/1334. ",
    "XanderEmu": "Actually I solved it for the projects I work with by using classes instead of interfaces (where applicable). As I wrote above:\n\nit's interesting how TypeScript can treat an abstract class as an implementable interface that stays in a runtime\n\nSo you can have abstract classes that you will treat as interfaces, e.g.:\nts\n// no need to use @injectable() on this\nabstract class TokenStorage {\n  abstract getToken(): Promise<Token>;\n  // other stuff\n}\nSo in your actual implementation you implement it instead of extending. TypeScript will just treat it as an interface, e.g.:\nts\n@injectable()\nclass LocalStorageBasedTokenStorage implements TokenStorage {\n  async getToken(): Promise<Token> {\n    return localStorage.get('token');\n  }\n  // other stuff\n}\nUse the abstract class as the id for your service:\nts\ncontainer.bind(TokenStorage).to(LocalStorageBasedTokenStorage);\nand then, in other services that require the above as a dependency, you don't need to use @inject at all:\nts\n@injectable()\nclass AuthManager {\n  constructor(\n    private tokenStorage: TokenStorage, // inversify will resolve it properly\n  ) {\n  }\n}\nAlso, you won't need to specify a type when getting such service directly from a container:\n```ts\ncontainer.get(TokenStorage); // like this\ncontainer.get(TokenStorage); // this works too but why bother? ;p\n```\nThis solution solves the problem for MOST of my cases. When dealing with some external depencencies, you need to be a bit more creative ;/ For example, you would need to do some runtime checks in the constructor.. I guess that if you use TokenStorage from TS1 as an ID then it won't be resolved properly for TS2.\nHowever, maybe the problem can be resolved on some other level?\nThe question is: where do you configure your bindings? If you configure it in your top-level application which uses TS1 and TS2 as dependencies then maybe this would solve your case:\n```ts\nimport {TokenStorage as TokenStorageTS1} from 'TS1';\nimport {TokenStorage as TokenStorageTS2} from 'TS2';\nimport {Container} from 'inversify';\nconst container = new Container();\n// bind one implementation\nbind(TokenStorageTS1).to(LocalStorageBasedTokenStorage).inSingletonScope();\n// then EITHER alias the second implementation to the first one\nbind(TokenStorageTS2).toDynamicValue(ctx => ctx.container.get(TokenStorageTS1));\n// OR just bind the same class to another id, in this case they will use the same localStorage under the hood, anyway\nbind(TokenStorageTS2).to(LocalStorageBasedTokenStorage).inSingletonScope();\n```. ",
    "gordysc": "Just hit this today.. any plans on this being published in a release soon?. Adding this here for visibility.  I'd like to know this as well regarding the following fix that was merged a bit ago:\nhttps://github.com/inversify/InversifyJS/issues/914. ",
    "zandroid": "@dcavanagh can you release these changes? Because it requires to make monkey-patching of inversify v4.13.0 in my project to use it in such cases.. @dcavanagh Thank you to notify me.. This test case covers the issue #914 . ",
    "kalahari": "I would love to see a new release for #913 as well!. ",
    "jrhite": "@zerox12311 In case you haven't figured it out, it is possible. I took a couple wrong turns, but got it working nicely.\nThe main problem I had was injecting the GraphQL middleware. GraphQL middleware is created via function call which isn't directly injectable in inversify. Something like:\n@controller('/graphiql', graphqlHTTP({ schema: schema, rootValue: root, graphiql: true }))\nclass GraphIQLController extends BaseHttpController {\n  @httpGet('/')\n  public async get() {\n    // do stuff\n  }\n}\nBut our root resolver is likely an injectable class:\n```\n@injectable()\nclass Resolver {\n  constructor(@inject(TYPES.UserRepository) private readonly _userRepository: UserRepository) {\n  }\n// ...\n}\n```\nOops! We can't inject the function. I initially tried the inject a function recipe, but that didn't work out for a variety of reasons, mostly because the injected functions were being injected before my main reference container had a chance to load its dependent modules.\nAfter that misattempt, I quickly found BaseMiddleware which makes it all work. My solution looks something sorta like:\n``\nconst TypeDefs =\n  type Query {\n    users: [User]\n  }\ntype User {\n    userId: String!\n  }\n`;\nconst Schema: GraphQLSchema = buildSchema(TypeDefs);\n@injectable()\nclass Resolver {\n  constructor(\n    @inject(TYPES.UserRepository) private readonly _userRepository: UserRepository) {\n  }\nusers() {\n    return this._userRepository.getUsers();\n  }\n}\n@injectable()\nclass GraphQLHttpOptions implements graphqlHTTP.OptionsData {\n  graphiql = true;\nconstructor(\n    @inject(TYPES.Schema) public schema: GraphQLSchema,\n    @inject(TYPES.Resolver) public rootValue: Resolver) {\n  }\n}\n@injectable()\nclass GraphQLHttpMiddleware extends BaseMiddleware {\n  private readonly _middleware: graphqlHTTP.Middleware;\nconstructor(@inject(TYPES.GraphIQLHttpOptions) options) {\n    super();\nthis._middleware = graphqlHTTP(options);\n\n}\npublic handler(request: Request, response: Response, next: NextFunction) {\n    void this._middleware(request, response);\n  }\n}\nconst GraphQLHttpModule = new ContainerModule((bind: interfaces.Bind) => { \n  bind(TYPES.Schema).toConstantValue(Schema);\n  bind(TYPES.Resolver).to(Resolver).inSingletonScope();\nbind(TYPES.GraphQLHttpOptions).to(GraphQLHttpOptions).inSingletonScope();\nbind(TYPES.GraphQLHttpMiddleware).to(GraphQLHttpMiddleware).inSingletonScope();\n});\n@controller('/graphiql', TYPES.GraphQLHttpMiddleware)\nclass GraphIQLController extends BaseHttpController {\n  @httpGet('/')\n  public async get() {\n  }\n@httpPost('/')\n  public async post() {\n  }\n}\nHope this helps!\n```\n. Yeah, that seems to be the best workaround right now. Dislike changing design just to make tests work due to a bug, but it's effective. :wink:. ",
    "oguimbal": "FYI I just released a lib that does just that:  https://github.com/oguimbal/inversify-graphql\nIt does not use inversify-express-utils, but you can integrate it through \n```typescript\nconst server = new InversifyExpressServer(container);\nserver.setConfig((app) => {\n        // ..... other setup ....\n        const srv = new ApolloServer({\n            schema: inversifySchema(container, mySchema),\n        });\n        srv.applyMiddleware({ app, path: '/graphql'});\n});\n```. ",
    "NickTsitlakidis": "No comment or merge for this?. ",
    "AlexTugarev": "Sounds good, thanks for the feedback!. ",
    "shlomokraus": "@remojansen Why is that relevant for the main repo? \nI thought this is a behavior of the express-utils project.. @remojansen \nAs in this line: \nhttps://github.com/inversify/inversify-express-utils/blob/206a8b1b541c4abdaf49cf20d65855e9abef5f14/src/decorators.ts#L20. ",
    "viglucci": "Out of curiosity, what is your intention behind wanting to create your production bundle using webpack?\nI am fairly new to TypeScript, but wouldn't it be more traditional to use something like ts-node + nodemon to run your application in development, and then create a production build using tsc (typescript compiler)? \nAm I misunderstanding, and you are creating a client-side application with inversify vs a server-side application?\n. ",
    "chrisabovo": "When we initialize the decorator @controller('/sample-path').\nIf webpack minimize=false he will generate the function name correctly.\nexample: \n    { \n        middleware: [],\n        path: '/sample-path',\n        target: [Function: SamplePathController] \n    }\nif webpack minimize=true he will change function name to 't', and not using the classname as function name.\nexample:\n    { \n        middleware: [],\n        path: '/sample-path',\n        target: [Function: t] \n    }\nWhen inversify will registerControllers he will use the function name to verify if alrealdy was initialize, so occors DUPLICATED_CONTROLLER_NAME.\nInversify need store the name in decorator @controller.. ",
    "johndoe2361289638165": "Any update on this?. ",
    "bowd": "@dcavanagh somehow this reply got lost in the weeds for me. Is this still of interest? I'll try to bang out a proof of concept, I have to reacquaint myself with the issue/solution a bit though it felt pretty straightforward if I remember correctly. . fix merged  \ud83c\udf89 . ",
    "betko": "Hi @inaiei,\nDid you find any solution for this problem?. ",
    "xxyuze": "I have the same problem in vue.js\nDid you find any solution for this problem?. ",
    "iuribrindeiro": "I\"m trying to get request scope as well but without success. Thought it was just .inRequestScope() like doc says. ",
    "rudfoss": "It seems a workaround is to return a function like so:\nreturn () => genericHandler(req, res, next)\nI'll do that instead.. ",
    "zerox12311": "I founded!\n. ",
    "baszczewski": "I found here probably another issue:\n```js\nconst parentContainer = new Container();\nparentContainer.bind(\"SHARED\").toConstantValue(\"V1\").whenTargetNamed(\"S1\");\nconst childrenContainer = parentContainer.createChild();\nchildrenContainer.bind(\"SHARED\").toConstantValue(\"V2\").whenTargetNamed(\"S2\");\nconsole.log('has2', childrenContainer.isBoundNamed(\"SHARED\", \"S2\")); // true\nconsole.log('has1', childrenContainer.isBoundNamed(\"SHARED\", \"S1\")); // also true! (it's weird because getNamed don't work with this params)\nconsole.log('get2', childrenContainer.getNamed(\"SHARED\", \"S2\")); // V2\nconsole.log('get1', childrenContainer.getNamed(\"SHARED\", \"S1\")); // error here\n```. ",
    "m4ss1m0g": "I found the reason: \nIn the not working service class I use the Store of vuex directly with import store from.\nRemoved the store and passed as function parameter all working correctly.. ",
    "simplegsb": "Example commit: https://github.com/simplegsb/inversify-express-utils/commit/cad4bac8dbc1b4848c2f91d5d323b468df620072. I just added steps to reproduce in my initial comment.\n@csuich2 I implemented my proposed solution in the commit mentioned in my previous comment and it is working fine. Child containers support this feature quite easily and were already used to inject the HttpContext itself. I have a branch in my fork that can be used as an NPM dependency if you want to try it:\n\"dependencies\": {\n  ...\n  \"inversify-express-utils\": \"https://github.com/simplegsb/inversify-express-utils.git#Issue#962_lib\",\n  ...\n}. @csuich2 I made a branch that has the lib and dts folders committed, that's why it can be used as an NPM dependency :)\n@dcavanagh I've just created a PR here: https://github.com/inversify/inversify-express-utils/pull/235. I've amended an existing test and added another based on the repro steps above.\nGlad I could help. I'm popping my open source cherry!. ",
    "csuich2": "I pulled in inversify-express-utils for the same reason - to create a per request DB transaction and am hitting the same issue. My dependencies are being reused by the next request to come in and thus the DB transaction is attempting to be reused.\n@simplegsb Did you find a workaround for this?\n@remojansen Any thoughts on supporting this? Or are we missing something that should allow this to work?. @simplegsb I didn't even think to use your sample commit as a package. Pulling it in seems to have done the trick! Have you thought about just opening your changes as a PR? Maybe @remojansen or @codyjs could take a closer look if they see a PR with the tests all passing.. ",
    "Stnaire": "If you look inside \"node_modules/inversify/lib/syntax/binding_on_syntax.js\" you got on the third line:\nvar binding_when_syntax_1 = require(\"./binding_when_syntax\");\nand in \"node_modules/inversify/lib/syntax/binding_when_syntax.js\" there is on the third line too:\nvar binding_on_syntax_1 = require(\"./binding_on_syntax\");\nHow can it work? I'm really surprised to be the only one having this problem.\nFor now I'm commenting the whole binding_on_syntax thing so I can compile:\n```\n// \"use strict\";\n// Object.defineProperty(exports, \"__esModule\", { value: true });\n// var binding_when_syntax_1 = require(\"./binding_when_syntax\");\n// var BindingOnSyntax = (function () {\n//     function BindingOnSyntax(binding) {\n//         this._binding = binding;\n//     }\n//     BindingOnSyntax.prototype.onActivation = function (handler) {\n//         this._binding.onActivation = handler;\n//         return new binding_when_syntax_1.BindingWhenSyntax(this._binding);\n//     };\n//     return BindingOnSyntax;\n// }());\n// exports.BindingOnSyntax = BindingOnSyntax;\nexports.BindingOnSyntax = function() { };\n```\nIt doesn't seem to break what I use so it will do for now, but help would be greatly appreciated.\nThanks.. Hi and thanks for your response.\nMy webpack config is a generic script driven by a YAML configuration file (kind of what I did with a gulp plugin I've made several years ago, gulp-yaml-packages).\nBut I created a sandbox project and I proceed to remove most of the code to create the simplest demo possible while still using the same code base.\nThat forced me to read the whole script again and...\nprivate getCommonPlugins(): any[] {\n    const output: any[] = [\n        [...]\n        new CircularDependencyPlugin({\n            exclude: /node_modules/,\n            onDetected({ paths, compilation }) {\n                compilation.errors.push(new Error(paths.join(\" -> \")));\n            },\n        }),\n    ];\n    [...]\n}\nI totally forgot about this CircularDependencyPlugin I've added here maybe 1 year ago. And because the error doesn't identify the plugin I didn't think about it...\nBut that's not enough, I've excluded node_modules in the configuration, so a circular dependency in inversify shouldn't trigger the error.\nIf I go in the plugin's source code, that's what I find:\n```\nfor (let module of modules) {\n    if (module.resource === undefined) { continue }\n    let maybeCyclicalPathsList = this.isCyclic(module, module, {})\n    if (maybeCyclicalPathsList) {\n        // allow consumers to override all behavior with onDetected\n        if (plugin.options.onDetected) {\n            try {\n                plugin.options.onDetected({\n                    module: module,\n                    paths: maybeCyclicalPathsList,\n                    compilation: compilation\n                })\n            } catch(err) {\n                compilation.errors.push(err)\n            }\n            continue\n        }\n    // exclude modules based on regex test\n    if (plugin.options.exclude.test(module.resource)) {\n        continue\n    }\n    [...]\n}\n[...]\n\n}\n```\nSo the isCyclic test is done before checking the exclusion rule, and if the configuration defines a onDetected callback then the error is sent to it.\nI had no idea that the exclude test what supposed to be done manually in the onDetected callback, and that's weird.\nI've updated the plugin to its latest version and now the code is:\n```\nfor (let module of modules) {\n    const shouldSkip = (\n        module.resource == null ||\n        plugin.options.exclude.test(module.resource)\n    )\n    // skip the module if it matches the exclude pattern\n    if (shouldSkip) {\n        continue\n    }\nlet maybeCyclicalPathsList = this.isCyclic(module, module, {})\nif (maybeCyclicalPathsList) {\n// allow consumers to override all behavior with onDetected\nif (plugin.options.onDetected) {\n    try {\n        plugin.options.onDetected({\n            module: module,\n            paths: maybeCyclicalPathsList,\n            compilation: compilation\n        })\n    } catch(err) {\n        compilation.errors.push(err)\n    }\n    continue\n}\n[...]\n\n}\n```\nNow they perform the exclusion test first and it solves the problem.\nBut still, it seems to me that there is a design problem anyway. Two files shouldn't depend on one another in such a way, a third component should be created to expose the functionality they both depend on.\nThanks for your response, that forced me to investigate deeper.\n. ",
    "tspoke": "@dcavanagh All primitives should be a good start ? (boolean, string, number, integer, float)\nMaybe it could be interesting to extends to array and enum.... @Jameskmonger Yes, of course. Even if it's by design, casting types into the wanted format should/could be a great feature for :\n\u2022 Type check on request (throwing wrong type exceptions)\n\u2022 Value casting for usage without casting by hand\n. ",
    "mmis1000": "I think that problably can't be done without read the type decorator generated by typescript directly(not enabled by default), and typescript doesn't even generate design time type decorator for complex type like array anyway.\nSo, even we do it, it will only support primitives.. ",
    "blocka": "I am also having the same issue with a class that extends EventEmitter. As a workaround, I'm no longer extending EventEmitter, but including an event emitter as an instance property, and manually creating proxy methods to call that event emitter.. ",
    "horyzont": "The same issue:\n\nWindows 10\nTypeScript 3.3\njest 20.0.0. \n",
    "shawnmclean": "Closing this as I'm learning more about typescript and it won't be possible until they publish metadata of complex objects (classes, interfaces).. ",
    "IsabellaCerbino": ":+1: . ",
    "peasey": "I've been able to get this working by binding with toDynamicValue instead. I've updated the minimal example on a new branch: https://github.com/peasey/minimal-typescript-inversify-jest/tree/using-dynamic-value\nLeaving the issue open for now.. ",
    "OlivierAlbertini": "Also appears in jest 24.1.0\ntypescript 3.3.3\nnode 10.15.0\nI cannot use toDynamicValue. ",
    "johnheroy": "@dcavanagh Sorry should have been more clear in the original issue post. The code snippet does not crash and sets a correct response (hence \"hacky workaround\" comment) but I'd like to be able to avoid having those lines observable.pipe(ignoreElements()).toPromise() altogether. . I'm getting a 204 response and after reading through the code for InversifyExpressServer, I'm fairly certain the issue is this line:\nhttps://github.com/inversify/inversify-express-utils/blob/master/src/server.ts#L266\n```ts\n// invoke controller's action\nconst value = await childContainer.getNamed(TYPE.Controller, controllerName)key;\nif (value instanceof HttpResponseMessage) {\n    ...\n} else if (!res.headersSent) {\n    if (value === undefined) {\n        res.status(204);\n    }\n    res.send(value);\n}\n```\nSo it looks like if a controller's method returns void (i.e., is async handling res object), then by default send a 204 status which makes the controller code throw the headers sent exception.\nLooking at the original PR to support async controller methods, the server only sends a response or sets a status code if there is a defined result returned by the controller method, but that assumption was broken in this commit. @pkeuter reported that this commit broke functionality for them in the issue.\nWhat do you think would be the best way to handle async controllers here? Perhaps one solution would be to explicitly provide some configuration to InversifyExpressServer at construction time to allow void return values from controller methods, e.g. (modified sample from above):\n```ts\n// invoke controller's action\nconst value = await childContainer.getNamed(TYPE.Controller, controllerName)key;\nif (value instanceof HttpResponseMessage) {\n    ...\n} else if (!res.headersSent && !config.allowVoidControllerMethods) {\n    if (value === undefined) {\n        res.status(204);\n    }\n    res.send(value);\n}\n```\nI'm happy to whip up a PR if someone can please give me some guidance. Thanks!. @dcavanagh friendly ping :). ",
    "Laazarus": "I am having the same problem with my test project,\nI cannot get the inject working with react.\nI am not getting any error when I run the application but simply I get the injected service is always undefined.\nBest Regards\n. @weilao  I tried everything I could and I found on the internet but I could not make it working...\nI ended up using another library for now that used inversifyjs behind the scene but i really would like to use this method because it feels like more official...\nI did not have any luck so far though.\nLet me know if you want to know the library I am using (that one works)but as said i really would prefer using this the method describe here\nAlso if you find the solution I would really appreciate if you could share it :)\nRegards. Thanks, it is a shame you cannot use the normal injection :(\nOn 18 Jan 2019 08:03, \u5a01\u8001 notifications@github.com wrote:\nUse a workaround to make the inject work.\nclass Game extends React.Component {\n  gameService: GameService = container.get(GameService);\n}\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHubhttps://github.com/inversify/InversifyJS/issues/1026#issuecomment-455459648, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AFdH2qkauahQCj1B-BLBuHAzVGvOCgZiks5vEX--gaJpZM4ZnAFa.\n. ",
    "Roustalski": "I created a demo repo of this for ease of reproducing.\nhttps://github.com/Roustalski/broken-inversify. ",
    "projekt86": "@Roustalski try to remove constructor and use property injection. I create PR to your repo.. ",
    "shevchenkobn": "I have fixed this issue.\nIf you have a complex project with lots of dependencies and you don't have to worry about the way they are resolved just add import './pass/to/your/di.container'; at the beginning of the file.\nExplanation:\nNode modules that have your @injectables probably import their @inject types directly (not for instantiation). Imports are done at the beginning of the file when @injectable type is not even declared. So if your module with @injectable is imported in DI container module, it may get an undefined instead of your @injectable. That is what I had. Inversify tries to report the problem and fails.\nMaybe a safeguard should be added to the library? It would be better to check if the type is undefined and report it before trying to read its name.\nSomething like Error: The dependency Symbol.for(type) is not defined. Consider reordering imports or import your container in the entry-point file.. ",
    "vlikin": "This is not an issue. You need to ask the question on stackoverflow. Use an approach that inversify-express-utils provide, make an injectable middleware, follow on the link https://github.com/inversify/inversify-express-utils#basemiddleware. ",
    "giancarlo-dalle-mole": "@vlikin There is an issue with the inversify-express-utils related to Middlewares instantiation, see pull request 235. Read below to discover what is happening.\nIf I understand correctly it is a problem our company faced 2 months ago:\nThere is a problem with middlewares instantiation in inversify-express-utils, they are singletons even if the classes are not marked as one. The pull request 235 fix that. \nThe way the inversify-express-utils Server works is the following: during the build process, the server instantiate all the controllers, services and middlewares to assure the DI is working correctly, but the code of the middleware has a flaw: it only instantiate once durring build and for every request it uses the same instance, making it a singleton as a side effect. If something is a singleton, it does not matter if you rebind something on per request, it will not affect the already created objects.\nAlso the way the wrapper sets the httpContext on the middleware instance, since it is an unintentional singleton, can make bad things happen: If a middleware is an async function and makes an async operation and another request start the same middleware, the httpContext of the middleware instance is replaced by the new request context. Unless you save the httpContex in a let/const on the top of the handler() function, it has the potential to change during the request and bugs will happen.\nIn our company we identify this issue and published a package (inversify-express) ourserlves with a fix to that and we made some other changes. Currently the version 0.0.3 of our package does not incude many breaking changes (except for the Pascal Case decorators), mostly fixes, but we are preparing a 0.0.5 that will add some breaking changes and our objective is to launch our own flavor of a wrapper over ExpressJS using inversify by the end of next year (2019).\n@Templaris there is a fix to your problem, but you have two options: wait the pull request I mentioned be merged (may take months to that happen) or use my company's forked package and make some changes. In case you opt-in our package, feel free to report feedback or bugs, because we use it in our main products we need to guarantee it works perfectly.. ",
    "arturgieralt": "I had the same issue  when I was using babel. Use tsloader instead of it!\nHere you can find my config files:\nhttps://github.com/arturgieralt/realTimeGame. ",
    "yaitskov": "so did anybody open an issue in babel project?. ",
    "gejgalis": "@annajolly have you tried with ! ?\n@inject(AUTH_TYPES.AUTH_SERVICE)\n  private readonly _authService!: AuthService;. ",
    "annajolly": "@dcavanagh @gejgalis Yes, I ended up using !, thank you!. ",
    "arnm": "I think this is related to an issue I just created #1053 \n. I think this is related to the issue I recently created #1053 . ",
    "weilao": "Same problem.\nAny idea?. As far as I know, it's caused by @babel/plugin-proposal-class-properties.\nThe code above was compiled to something like:\nts\nclass Game extends React.Component {\n  constructor() {\n     // This is why the injection broken.\n     this.gameService = undefined;\n  }\n}. Use a workaround to make the inject work.\nts\nclass Game extends React.Component {\n  gameService: GameService = container.get(GameService);\n}. ",
    "yuriCarlos": "In this week I started to learn about inversify with React too and I'm having the same issue...\nI got the basic example of https://github.com/inversify/inversify-inject-decorators and just pasted it on a new class in my project, just to test, and even the basic example was not working.\nI was looking in the implementation, trying to find some guess of what was happening...\nThis library (if I didnt get wrong) inject the properties on the prototype of the object, so the injection works only when you do a get on the property of prototype.\nWhen you do a get on the object, the js will look at the instance to see if the property exists there. If it doesnt then Js will look at the instance's prototype chain until get the value wanted.\nThe problem is that when you create a instance (new WhateverClass()) all properties will be in your instance, so js will never do a search on the prototype chain and, because of that, your instance will never be injected.\nTo exemplify what I'm talking about I got the basic example I said above and made some changes.\nThat's an example of what is happening here:\n@dcavanagh  and @remojansen, Do you have some guess about what is happening here?\n```\nimport \"reflect-metadata\"\nimport getDecorators from \"inversify-inject-decorators\";\nimport { Container, injectable, tagged, named } from \"inversify\";\nlet container = new Container();\nlet { lazyInject } = getDecorators(container);\nlet TYPES = { Weapon: \"Weapon\" };\ninterface Weapon {\n    name: string;\n    durability: number;\n    use(): void;\n}\n@injectable()\nclass Sword implements Weapon {\n    public name: string;\n    public durability: number;\n    public constructor() {\n        this.durability = 100;\n        this.name = \"Sword\";\n    }\n    public use() {\n        this.durability = this.durability - 10;\n    }\n}\nclass Warrior {\n    constructor(){}\n    @lazyInject(TYPES.Weapon)\n    weapon: Weapon;\n}\ncontainer.bind(TYPES.Weapon).to(Sword);\nlet warrior = new Warrior();\nconsole.log(warrior.weapon instanceof Sword); // false\ndelete warrior.weapon\nconsole.log(warrior.weapon instanceof Sword); // true\nexport default warrior```\n. ",
    "RevanScript": "Any updates on this?. ",
    "haggins": "I came up with the following solution:\nmyService.ts\n```typescript\n@injectable\nexport class MyService {\n    private readonly queue: IQueue;\nconstructor(private readonly config: IConfig) {\n    this.queue = queueFactory(this.config);\n    this.queue.isWaiting.subscribe(....);\n}\n\n}\nA `myServiceFactory`, which will also be exported:\n_inversify.config.ts_typescript\ncontainer.bind<(config: IConfigFormat) => MyService>(TYPES.MY_SERVICE).toFactory((context: interfaces.Context) => {\n    return (config: IConfigFormat) => {\n        return new MyService(config);\n    }\n})\nexport const myServiceFactory = container.get<(config: IConfigFormat) => MyService>(TYPES.My_SERVICE);\nAnd in my packages index.ts:typescript\nexport { MyService as InjectableMyService } from './services/MyService';\nexport { myServiceFactory as MyService } from './ioc/inversify.config';\n``\nThis way, package users can decide to either get an instance from the factory (let myService = MyService(config)) or to bindInjectableMyService` if they also use inversify.\n. ",
    "varogonz95": "Oh forget it, I just realized you can name classes from binding with:\njavascript\ncontainer.bind<Type>(Type).toSelf().whenTargetNamed(\"Some name\")\n:man_facepalming: . ",
    "lefebvresam": "Yes, I wrote the server implementation with web socket as following (intendation lost):\nimport \"reflect-metadata\"; // keep on first line!!\n// tslint:disable-next-line:ordered-imports\nimport bodyParser from \"body-parser\";\nimport { Request, Response, static as serveStatic } from \"express\";\nimport expressWs from \"express-ws\";\nimport { Container } from \"inversify\";\nimport { InversifyExpressServer } from \"inversify-express-utils\";\nimport path from \"path\";\nimport URLParse from \"url-parse\";\nimport WebSocket from \"ws\";\nimport { WebSockets } from \"./interfaces/websockets\";\nimport { bindings } from \"./inversify.config\";\nexport async function main() {\n  console.log(\"webserver: Starting webserver\");\nconst port = 3000;\n  // \"0.0.0.0\" for all interfaces on device\n  //const ipaddr = \"127.0.0.1\";\n  const ipaddr = \"0.0.0.0\";\n  // use \"/\" to define root as websocket\n  const websocketpath1 = \"/websocket\";\n  const websocketpath2 = \"\";\n  const websocketpath3 = \"\";\n  const apppath = path.join(__dirname, \"../../creaclics-frontend/dist/creaclics-frontend\");\n  const frontendpath = \"/\";\nconst container = new Container();\n  await container.loadAsync(bindings);\n  const server = new InversifyExpressServer(container);\nserver.setConfig(a => {\n    a.use(bodyParser.json());\n    a.use(bodyParser.urlencoded({ extended: true }));\n    a.use(frontendpath, serveStatic(apppath));\n    expressWs(a, undefined, {\n      wsOptions: {\n        verifyClient: (info: any) => {\n          const urlo = URLParse(info.req.url);\n          return (\n            urlo.pathname === websocketpath1 ||\n            urlo.pathname === websocketpath2 ||\n            urlo.pathname === websocketpath3\n          );\n        }\n      }\n    });\n  });\nserver.setErrorConfig(a => {\n    a.use((err: Error, req: Request, res: Response, next: any) => {\n      console.error(err.stack);\n      res.status(500);\n      res.send(\"Something broke, see logs for more detailled info.\");\n    });\n  });\nconst app = server.build();\napp.listen(port, ipaddr, () => {\n    console.log(\"webserver: Server running at http://%s:%i\", ipaddr, port);\n  });\nif (websocketpath1.length) {\n    app.ws(websocketpath1, (ws: WebSocket, req: Request) => {\n      WebSockets.addWebSocketInstance(websocketpath1, { ws, req });\n    });\n  }\nif (websocketpath2.length) {\n    app.ws(websocketpath2, (ws: WebSocket, req: Request) => {\n      WebSockets.addWebSocketInstance(websocketpath2, { ws, req });\n    });\n  }\nif (websocketpath3.length) {\n    app.ws(websocketpath3, (ws: WebSocket, req: Request) => {\n      WebSockets.addWebSocketInstance(websocketpath3, { ws, req });\n    });\n  }\n}\nexport function serverError(error: string) {\n  console.log(\"Webserver error:\", error);\n  return <head></head><body><h1>Internal Server Error</h1><p>${error}</p></body>;\n}. "
}