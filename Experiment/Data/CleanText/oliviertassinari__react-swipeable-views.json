{
    "oliviertassinari": "Resolved with c187a8a4cec227eb2d96cbd3541abcd40fe6c037\n. > Also on desktop with the mouse?\nWe could have this feature but I dont' think that it sounld be the default behavior. \n. > but in chrome I don't.\nDo you have a touch screen? My guess is that Chrome handles it better than Firefox.\n\nBy the way it was just a suggestion, I love what you did!\n\nThank! Feel free to submit a PR if you need this feature. It should be straitghtforward. However, as said, I think that there is an UX issue with this behavior. I don't want it enabled by default. \n. @giladbr That's another topic. Could you open an issue for this? That sounds fair, we could add it under a specific enable property.\n. A support section was added in the docs https://github.com/oliviertassinari/react-swipeable-views#browser-2. I think that we can close that issue now.. @lolJS Thank for this! However regarding the dangling-comma, I'm enforcing them (https://github.com/oliviertassinari/react-swipeable-views/blob/master/.eslintrc#L34)\nCould you let them untouched?\n. I'm going ahead and merging this.\nI will soon release with this change (I have to update the docs first) \n. @lolJS v0.3.0 was released with your PR.\n. Yes you can, the latest version (react-swipeable-views@0.3.0) drop the support of react v0.13.x. You need to use an older version \n. I'm glad to hear it.\nThat's weird. Do you confirm that your use case is similare to the third demo?\n. Oh I see what it's you need here. I have investigated this task a little. The hardest part here is to compute the height of each slide. Once we have it, we can update the height of the container accordingly https://github.com/oliviertassinari/react-swipeable-views/blob/master/src/index.js#L190.\n. I'm gonna have the same feedback for the coding style. I will add an eslint task.\nRegarding the result, I can't test it until tomorrow.\nI really appreciate the time you spent on this :+1:\n. Thanks for this :+1:\n. I'm up for this change :+1:, however, I have some feedbacks.\n. Still miss the update of the Readme with the new property to be perfect. If you don't have time to do it, I will merge this PR.\n. Thanks! \n. @zlangbert I have done some improvement regarding perf. I will soon publish.\n. :+1: \n. done\n. That's probably linked to https://github.com/callemall/material-ui/issues/1641. This is not specific to this lib. I'm closing the issue. \n. One way to fix it is to teleport the creation of the dialog dom outside the slider.\nBut I'm wondering what is exactly responsible for this behaviour \n. I'm talking about somethings like https://github.com/rackt/react-modal/blob/master/lib/components/Modal.js#L59.\n. @zlangbert We are working on this. https://github.com/callemall/material-ui/pull/2042 is the first step.\n. @zlangbert Can you try https://github.com/callemall/material-ui/pull/2129?\n. @zlangbert The PR is merged, could you try again?\n. I guess it would be something like\n\n(image from https://github.com/souporserious/react-motion-slider/tree/0.1.0).\nI don't have any plan on this, but it would be great.\n. This shouldn't be a lot of line changes, 50 or less, but can be tricky to get right.\nI will require to allow the index to go outside the allowed range.\nWe could apply this type of transformation http://www.wolframalpha.com/input/?i=1-e%5E%28-x%29 to the input.\n. https://github.com/oliviertassinari/react-swipeable-views/commit/bf4182551a03443e0076931f575da5c80242809c should fix this issue.\n. We first render one slide and then we render the other slides.\nThe goal is to render something interesting as quickly as possible.\nDo you also have this events when swiping?\n. > Multiple mounts for the same slide doesn't make sense though\nI agree, this should just be one mont and two renders. I'm gonna investigate.\n. https://github.com/oliviertassinari/react-swipeable-views/commit/a44b928070b88e4d4aabefb53a8922a5c63a49b4 solve this issue.\n. > I have noticed that after my app has been running for a bit, tab switching becomes very laggy\nDo you think we have some memory or node leak?\n. It's here https://github.com/oliviertassinari/react-swipeable-views/blob/master/package.json#L45.\nIf you make babel parse the source code of this project. You have to install the dependencies on your project too.\n. > Maybe document this in case others running into the same issue?\nSounds like a great idea.\nI feel like it's an issue with babel. \n. Done https://github.com/oliviertassinari/react-swipeable-views/commit/afcef71f71aa54075e49660e241148455a5fa354\n. I should probably be using an autoprefixer tool.\nBut regarding the small number of style, that should be enought. \n. @yuchien302 Thanks. I'm gonna do a release.\n. Interesting, following the doc:\n\nNote that when the referenced component is unmounted and whenever the ref changes, the old ref will be called with null as an argument. This prevents memory leaks in the case that the instance is stored, as in the first example. Also note that when writing refs with inline function expressions as in the examples here, React sees a different function object each time so on every update, ref will be called with null immediately before it's called with the component instance.\n\nhttps://facebook.github.io/react/docs/more-about-refs.html\nAlright, I should fix this!\n@echenley Is if (slide) { doing the trick?\n. Could you try https://github.com/oliviertassinari/react-swipeable-views/pull/21 for the original issue?\n. > fixed overlay\nI'm not sure to follow. What do you consider as a fixed overlay?\n. I see, thanks for the explanation. I'm gonna try to reproduce this issue.\n. https://github.com/callemall/material-ui/pull/2150 was merged to address your issue with the SelectField.\nJust wait the next release.\n. The fromIndex is a good idea. What is your use case for onSwitching?\n. Well, This is useful when you want to implement something corresponding to the current slide position.\nis enought. Thanks!\n. As responded here https://github.com/brentvatne/react-native-scrollable-tab-view/issues/44 for react-native.\nI would say that you can use https://github.com/orgsync/react-list on top of the SwipeableView component.\n. I have tagged this issue as a priority. I more or less know how to address it. I will try to find some time to work on it. I'm gonna have a look at the react-virtualize API to provide a clean API.\n. @jadus I have just started. I plan to provide it as an HOC (virtualize) with the following API:\njs\n      /**\n       * Number of slide to render before/after the visible slide.\n       */\n      overscanSlideCount: PropTypes.number,\n      /**\n       * When set, it's adding a limit to the number of slide: [0, slideCount].\n       */\n      slideCount: PropTypes.number,\n      /**\n       * Responsbile for rendering a slide given an index.\n       * ({ index: number }): node.\n       */\n      slideRenderer: PropTypes.func.isRequired,\nIt should work with react-dom and react-native.\n. @TCMiranda Oups :grin:, thanks for the feedback https://github.com/oliviertassinari/react-swipeable-views/commit/0cd450775212e082c4305dccfa5e5cd3408795f8.\n. I haven't seens any perf improvement using this method. Looks like React is already waiting requestAnimationFrame to rerender the component. \n. Well, that sounds like a valid use case :+1:.\nI will try to have a look.\n. > Did you find anything about it?\ni hadn't time to look at it.\n. Sorry for the delay, I have completely forgotten this issue.\n\nif it would be possible to validate if there is any native scroll before starting scrolling the swipeable views?\n\nYes, I think so.\nDuring the handleTouchStart, we could traverse up the DOM tree from the event target to the SwipeableViews root element. If we find a node containing a scroll bar, we could ignore this event.\n. > But it would be better to ignore it only if the element is in the middle of the scrollable area.\nYou are right, I was looking at how Google Weather handles this point.\nThe parent scroll container claims the scroll when the child element scroll is on the edge and the velocity of the movement is high enough. Otherwise, it's the child element that claims it.\nBut I'm not sure that checking the velocity worth the effort.\n. I have done a first implementation for the browser platform.\n. As I believe the feature is requested for this platform, I'm closing the issue.\n. Can't you use the style property to apply a style to the container?\nWhat do you think about passing all the properties like style and classname to the root component, and rename the current style property to containerStyle?\n. Fix with https://github.com/oliviertassinari/react-swipeable-views/commit/1cfc7685f6e617c6e5a6632e729f74a86554bb53.\n. Fix with the 0.4.0 release.\n. Could this be an issue react motion?\n. > I was able to downgrade this component temporarily\nWhat version of react-motion and react-swipeable-views is affected? And what version is fixing it?\n. I wasn't able to reproduce this issue :/.\n. Would using the index property of <SwipeableViews /> works?\n. > The problem is that item3 that now is item2 after I deleted one item have its slideIndex set to the same as the item that was deleted from the list.\n@funkyeah Oh, you are right, I have overlooked this sentence. That's proving that it's working fine.\nThanks \ud83d\udc4d .\n. Interesting issue. I think that we can fix it by calling preventDefault and by checking that the event wasn't prevented before handling it. \n. Fix with https://github.com/oliviertassinari/react-swipeable-views/commit/335c5dce319afbb779435eb736d485c5b91be637. Have a look at the demo n\u00b06.\n. I should remove the .babelrc from the npm package. I will fix this.\nOn Mon, 22 Feb 2016, 03:01 \u715c\u5bb8 notifications@github.com wrote:\n\nERROR in ./~/react-swipeable-views/lib/index.js\nModule build failed: ReferenceError: Unknown plugin \"transform-react-display-name\" specified in \"/Users/joe/Documents/WorkSpace/m-tanwan-react/node_modules/react-swipeable-views/.babelrc.env.development\" at 0, attempted to resolve relative to \"/Users/joe/.def/node_modules/@ali/builder-cake/node_modules/@ali/cake-webpack-config\"\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/oliviertassinari/react-swipeable-views/issues/34#issuecomment-186968783\n.\n. Fixed with https://github.com/oliviertassinari/react-swipeable-views/commit/9ffaa3315c4184f8593265d63a1cc31bac6dbdd2.\n. > For example if you refresh the page and it inits with with a heightLatest of 200, when you open a 600px size dropdown, the dropdown will get cut off and a scrollbar will appear.\n\nOne way to fix it is to have the root of the drop-down outside of the SwipeableView. That's how an html <select /> is working and how the <SelectField /> of Material-UI work.\n\nI propose to add an option to set a max/default heightLatest, or to fix the behavior to automatically adjust if something inside the SwipeableView needs more space.\n\nI'm open to a PR. Maybe using the style minHeight instead of height will do the trick.\n. @amangeot One work around would be to wait for the image to be loaded before mounting the <SwipeableViews />. \n. @patotoma Do you have another example where the height adjustment is not working?\n\nthis should be labeled as bug and should be fixed\n\nI see two options:\n1. We could defer the height measurement to when we actually need it. I mean, when we are transitioning between slides. I think that we would address the majority of our issues. Still not a 100% resilient approach.\n2. We make this feature optional and disabled by default. As it's having two drawbacks:\n- Isn't working in 100% of the cases\n- Reduce performances\n. What do you guys prefer?\nPersonally, I'm always setting a height when using it.\n. I went with option 2.\n. I'm using the first demo of the website. Could you post your result? I'm wondering if this isn't linked to the internal of react-motion.\n. @jardakotesovec Oh, that's interesting! Are you saying the memory increase is directly linked to V8?\n. @jardakotesovec Alright, let's close this issue, thanks :+1:.\n. I couldn't reproduce this issue. Are you applying some specific style to those elements?\nI'm closing this issue.\n. @VilleMiekkoja Thanks for opening this PR :+1:.\n. @VilleMiekkoja Thanks!\n. @alitaheri Yeah, that's pretty awesome.\nI have finally found a way to link the documentation and the source code.\nI will apply what I have learned here to material-ui :wink:.\n. I wouldn't have been able to do it without https://github.com/leecade/react-native-swiper :clap:.\n. Thank for providing more details here. I would say that it's a bug. At first glance, that looks tricky to solve. \n. Regarding how we can more reliability fix this issue.\nI think that we would have to listen to the scroll event. See what is going on and change the index if this is needed. We definitely don't want to end up between two slides.\n. > Is a scroll-event being fired when an input gets focus on a different slide\n@andrzey Good question, I haven't investigated. I can't tell for now.\n. The solution started here https://github.com/oliviertassinari/react-swipeable-views/pull/79/commits/e912808205a6daf2450c3e80d94d230372d22510 was interesting.\nI think that using the onScroll event is our best option.. The definition is here https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/react-swipeable-views/react-swipeable-views.d.ts :heart_eyes:.\n@mxl Thanks :+1:.\n. Hi, thanks for the feedback.\nGood question, this feature isn't implemented on RN neither on the browser.\nI have never investigated this use case.\n. Actually, there is a way. At @doctolib, we are adding an extra padding and allowing the overflow so slides on the edges are partially visible.\n. > Adding the possibility to autoplay would be nice\nThat would be nice. I think that we could create a HOC for this behavior :+1: \n\nAlso, prev/next method.\n\nI don't agree with this feature. That seems imperative and not declarative.\n. That would be good yes.\n. @sylvainbaronnet I'm working on the auto play feature.\n. Fix with https://github.com/oliviertassinari/react-swipeable-views/commit/da4e20e292e7694a36452f4ad114dc46d4f8c255.\n. I should be providing a better example. The auto play is provided with a High Order Component.\nFor now, you can have a look at the source code of the Demo 7.\n. @tomwalters Hi, what's your issue? Is this regarding iOS or Android?\n. @tomwalters Thanks, that's working :+1:.\nHowever, there is no transition when we switch from active slide. That's a missing feature that \nindex.native.animated.js does support.\n. @tomwalters I'm not sure to understand.\nTo clarify, I do think that the transition between slide should be animated by default (as it's with the browser version.\nWe could also add a property to disable this feature.\n. Awesome. \n. Thanks for trying something, but that doesn't look like the right way to do it. The core issue seems to be this one https://github.com/facebook/react/issues/6467.\n. I can release something for tomorrow. \n. Fix with https://github.com/oliviertassinari/react-swipeable-views/commit/8977ecf0c3254f20e11e9144704d466a3ebfbc38.\n. @tushartuteja What version of this package are you using. Could this be an issue with the Tabs component instead of this one?\n. @LunarSweeper Babel is adding an extra layer to support ES6 modules. You need to use this in a ES5 environment. \njs\nvar SwipeableViews = require('react-swipeable-views').default;\n. I'm closing this issue. I would need more detail. That doesn't seem to be directly linked to this repository.\n. @tomwalters Thanks for this PR, I'm glad someone is actually using it for react-native. I'm not yet in production\ud83d\ude01.\n. @tomwalters Any update on this PR? Thanks.\n. Have a look https://github.com/oliviertassinari/react-swipeable-views/issues/46#issuecomment-210997639.\n. @KevinHu2014 that's exactly the same. This HoC is logic pure and do no depend on react-dom nor react-native. I'm gonna improve the doc. \n. @funkyeah You are right, the API isn't consistent. Can you have a look at https://github.com/oliviertassinari/react-swipeable-views/pull/58? It should improve this.\n. Well indexStart and indexCurrent are used for different purposes.\n- indexStart is for adding some hysteresis.\n- indexCurrent is for reflecting the swipe position at the next render.\n. You raised some good points. I could have added some comment to be more explicit. Are even better test them.\n. It's working fine on Firefox v46.0. What version are you using?\n. I'm closing the issue as I don't have enough information to reproduce it.\n. Interesting PR.\nHandling the scroll event on the desktop platform makes me think about the React Native implementation. There is basically two ways to do it:\n- use the scroll component of the platform\n- emulate it\nOn the desktop, we are emulating it. On React Native, we have implemented both versions.\nYou gonna have to rebase this PR. You have added some files that are not supposed to be here.\n. @ErlendWade Thanks for this PR, you raised some good points.\nHowever, this PR isn't ready to be merged and has been inactive for quite some time. I'm closing it.\n. @markgoodyear Thanks for this PR! Could you fix the linting error? \n. @tomwalters That's going in the right direction \ud83d\udc4d.\n. At first glance, this change seems safe. Who could I reproduce this issue?\n. Oh, you are right. I'm gonna fix this.\n. This plugin tries to be unopinionated from the other modules of the stack. I won't add this to the core of the plugin.\nStill, you can use the onChangeIndex callback property to change the route.\n. I should probably release the native and the DOM version under two different packages.\nI will work on if it get enough attention.\n. Hi, thanks for the kind words.\nI have never used the experimental navigation. I'm clueless here.\n. I'm closing the issue as I don't have the answer and that has been inactive for quite some time.. Hi. No, the views are not lazy rendered.\nBut that responsability can be hanlded by the slides components. This what we are doing here (mobile phone).\n. How many views do you need to render? I think that my above solution can handle up to 50 views and still provide a good UX. \n. I'm closing this issue in favor of https://github.com/oliviertassinari/react-swipeable-views/issues/22. Thanks for raising that point. That seems like a quite needed feature. \n. I don't get it. That's gonna break the single data flow pattern that makes React so nice to play with.\nWhat's the issue that you are experiencing? Or even, better, what would be the use case? Don't we have better way to fix it?\n. Right, this package has a peer dependency on react-motion. Do you want to submit a PR to fix it? That would be great. Thanks!\n. Hi,\n- I don't think that we should build the keyboard navigation in the core of the lib.\n  But we could do something like the autoPlay HOC using react-event-listener \ud83d\udc4d .\n- Regarding the ARIA, I don't have any expertise on this field. What do you have in mind?\n. @jadus What platform are you targeting? It's kind of possible today depending on the platform.\nI should make this more straightforward and simple.\n. Wow, your needs seems quite challenging.\nThe best solution I can think of is using one <SwipeableViews /> and keeping adjacent slide scroll positions in sync. \n. Have you tried using the onSwitching property? \n. I'm closing the issue for inactivity. I believe onSwitching is what you are looking for.\n. The warning is quite interesting.\n\nThis occurs when Blink (Chrome's rendering engine) decides to delay executing a timer (like a function passed to requestAnimationFrame, setTimeout, or setInterval) because those functions are generally taking >50ms to execute and there is user touch input. It's done to prioritize handling user input (like scrolls and taps) above what the site is doing.\n\nSo it seems that rendering the images is quite an expensive task.\n- How big are those images?\n- In which browser do you see the jerky animation?\n. I'm closing the issue as I don't have enough information to reproduce the issue.\n. @funkyeah I do. I'm investigating on your issue. I'm looking at https://github.com/react-native-community/react-native-tab-view/blob/master/src/TabViewPanResponder.js at this moment.\n. @funkyeah Would the following code do the trick? If so, we could also update the browser version.\njs\nreturn Math.abs(gestureState.dx) > Math.abs(gestureState.dy) * 3;\n. > Honestly the best is still:\nThat's sounds good to me. Would you mind doing a PR for this?\nFrom my own testing, The Google YouTube app seems to have the same logic. \nI will implement a similar logic for the browser. It's going to be a bit more work. \n. @7kfpun Thanks!\n. @funkyeah Thanks! I will do a release shortly.\n. @darmie What do you mean by better. Do you mean with the right width?\n. @lpalmes Thanks.\n. @pnakibar You raised a good point. The index shouldn't go beyond his bounds.\nI think that it should be handled at the user level, still, it would be good to have a warning about it, so you know that it's wrong when working in the dev environment.\n. @pnakibar Yeah, that's exactly how I would have solved it \ud83d\udc4d. \n. > This can use left instead of translate3d transform to avoid this issue.\nFrom the https://csstriggers.com/transform:\n\nChanging transform does not trigger any geometry changes or painting, which is very good. This means that the operation can likely be carried out by the compositor thread with the help of the GPU.\n\nIt's not the case for the left property. This means that it's much better to use the transform over the left one from a performance point of view.\n\nso position fixed will not work inside the slide view.\n\nI'm wondering if something like a <Portal /> wouldn't be a better workaround. \n. I'm closing the issue for the Portal workaround.\n. @damianobarbati Thanks for sharing a use case of the Portal component of Material-UI. Keep in mind that the container property is optional. You are providing the default value. . @zhouyu11 I'm gonna close this issue as there is no context regarding the actual issue solved.\nNote that the transform property is supposed to provide better performance.\n. Oh right, so the related issue is #124. \n. > there are 2 renders per view\nWhere do you get this from?\nTo increase time to first paint, we first render the screen corresponding to the asked index. Then we render the other one.\nAs soon as your slides component are quite expensive to render, you need to implement a pure logic. \n. That looks good to me. Thanks for the fix. \n. I think that this feature would require changing the preventDefault logic.\n. This issue is also linked to https://github.com/oliviertassinari/react-swipeable-views/issues/26#issuecomment-241551403. They both deals with nested scroll container.\nThe overall UX should be pretty close. (@TCMiranda).\n@zetura Do you mind submitting a PR so I can have a better view of your approach?\nThat sounds something that needs to be configurable. I'm wondering if a property would be useful here.\n. @zetura Thanks. Don't we have an issue when switching back?\nI have found a better approach. I'm still trying to address #26 too. I will submit a PR once it's done.\n. @cinder92 Why do you mean it's not compatible?\n. I'm closing as the issue seems not relevant.\n. What's the error?\n. Thanks for those logs, that's very useful. It's linked to https://github.com/oliviertassinari/react-swipeable-views/issues/100.\nI have two workaround until the main package is split into two different one for each platform:\n- upgrade to npm@3\n- add react-dom@15.2.1 in your dependencies. \n. I have more experience with webdriverio now than a year ago. I would rather use the selenium js wrapper. Webdriverio has proven to cost more  (bugs, etc.) than it brings value.  . I don't get it. What's your issue?\n. The issue is at this line:\njsx\n<WalkThrough index={this.state.index} onChangeIndex= {() => this.handleChangeIndex()} />\nThat makes me realize one different issue. The HOCs don't forward the fromIndex property in the onChangeIndex.\n. > I can't set the position to absolute for the react-swipeable-views container\nWhy can't you?\n\nIs there any way to stop the bouncing effect on ios?\n\nWhere is the bouncing effect coming from? I can't reproduce it.\n. @jasan-s This issue sounds linked to a wrong usage of the component. I'm closing this issue until I have a better reproduction test case. You can use this workbench as a starting point http://www.webpackbin.com/VJjMoggnZ.\n. I don't understand. Everything seems to work as expected.\n. Oh right, thanks for beeing more explicit about the expected behavior. We should only re-schedule the interval if the index or the interval properties have changed.\nP.S. The example is inefficient from a CPU point of view. You could add a pure logic. That would also be a good workaround until this issue is properly solved. \n. What's the expected behavior and the current behavior?\n. Oh right, thanks for providing more details. So you are experiencing some junks. Basicaly, it's user responsability to avoid wasted rerendering. You can have a look at the Performance on browser docs section. \nI'm closing the issue. Feel free to improve the docs if you find anything unclear. \n. Using overflow-x/y: hidden; sounds like a good idea :+1:.\n. > The idea that we should enable overflowY: hidden on the start of animation and return previous overflowY value after animation will be finished.\nWouldn't we have a content jump if we do so? \n. > And what about compatibility with axis?\nThis property isn't fully supported right now. I wouldn't worry until some people complains about it.\nWould advising people to disable the overflowY: 'hidden' is they need so be an acceptable solution?\n. > Why you don't like my proposal?\nI'm not keen on adding a new layout element <div /> as it come with a larger overhead. Would be great to solve the issue without.\n. I don't have any benchmark. My point is, an additional layout div is more work for the browser to do.\n\nI only see two variants\n\nI have another option. You can apply the following style on each slides:\ncss\n    max-height: 200px;\n    overflow-y: auto;\nIf that's good enough, we can cherry-pick ed190a6 and add a demo with this behavior.\nI feel like we reach a point where I should finish #139 so we get some proper e2e tests.\n. @ashl1 Awesome, you can change the existing Demo 4.\n. You are in controlle of the children provided to the component.\nYou should make sure that the properties used are coherent.\nThe warning it here to help in that direction.\nYou can use Children.count(children) to prevent overlaping the bounds https://github.com/oliviertassinari/react-swipeable-views/blob/master/src/utils/checkIndexBounds.js\n. I'm glad you found a solution.\n. @mflores-verys I'm glad you found a solution :).. Oups, I think that the best option is to remove this line: https://github.com/oliviertassinari/react-swipeable-views/blob/master/.babelrc#L12.\nHaving babel-runtime makes the package smaller but force users to use it.\n. Actually, I'm gonna follow react-boostrap approach and add babel-runtime as a dependency: https://github.com/react-bootstrap/react-bootstrap/blob/master/package.json#L120.\nWe should have done it here and on Material-UI too in the first place.\nThe build is 4kB smaller (without the external dependencies)\n. This check is intentional, it's here for the controlled use case. If we compare to the state, we might have unwanted update.\nWhy not using the virtualize HOC?\n. I'm not sure to understand, why adding those new properties?\nWe can already use the style and slideContainer property to get the same result:\n``` jsx\n// @flow weak\nimport React from 'react';\nimport SwipeableViews from 'react-swipeable-views';\nconst styles = {\n  root: {\n    padding: '0 30px',\n  },\n  slideContainer: {\n    padding: '0 10px',\n  },\n  slide: {\n    padding: 15,\n    minHeight: 100,\n    color: '#fff',\n  },\n  slide1: {\n    backgroundColor: '#FEA900',\n  },\n  slide2: {\n    backgroundColor: '#B3DC4A',\n  },\n  slide3: {\n    backgroundColor: '#6AC0FF',\n  },\n};\nconst DemoWidth = () => (\n  \n\n      slide n\u00b01\n    \n\n      slide n\u00b02\n    \n\n      slide n\u00b03\n    \n\n);\nexport default DemoWidth;\n```\n\n. @Ftornik Thanks for this PR but I think @ashl1 is right.\nYou can compute the needed padding transformation.\nI don't see much value in adding those two properties just for the browser.\nStill, that's probably the path we gonna need to use to support the browser as the native environment.\nUntil someone needs it. I'm gonna keep thing simple and documented.\nI have added a demo as I think it's a feature we need to support \ud83d\udc4d .\n. @igorbt Thanks for this PR, but I don't think I'm gonna merge it until I figured out how to properly solve this issue (keeping a smooth animation).\nWell, at least without any tests.\n. > quite a rework of the current solution\nMuch of the work should be at the SwipeableViews level. We need a wait to add an offset to react-motion without killing the animation. It's basicaly introducting a discontinuity.\nWe should also make sure it's working on react native.\nI dont' have much time now. Have you tried using the overscanSlideCount to soften this issue?\nOtherwise, if you add a unit tests for this behavior and a comment in the code regarding temporary\nworkaround. I will merge it. \n. Having a look at the react-motion documentation, I feel like the only options is to render twice.\n- One time to apply the offset without transition and a second one to apply the transition.\n  That logic should start around here.\n- Then we will be able to apply the same logic than for going forward.\n. @igorbt Thanks for this PR, you raised some good points.\nHowever, I don't think that the solution is good enough. I'm closing this PR.\n. For simplicity. \nWe can add a fourth slide with a height going behond the max height. \n. @ashl1 I have added an example. Thanks for your help \ud83d\udc4d .\n. > It will be better to add \"this slide with max-height\" at the start of last slide.\nGood idea \ud83d\ude04 \n. @ashl1 Alright, I'm on it.\n. Could you provide more details? Thanks!\n. What's the expected result?\n. > confirms that it is treating all 3 divs as one index\nYes, it's his. Hence my second question.\nWhy using this style?\njs\n  slide: {\n    minHeight: 100,\n  },\n. You also need to provide a height to the containerStyle property.\nE.g. https://github.com/oliviertassinari/react-swipeable-views/blob/master/docs/src/demo/DemoAxis.js#L7.\n. > The HOCs shouldn't depend on the order they are applied, should they?\n~~The HOC composition order matters. virtualize needs to be the last one called.~~\nEdit: Hummm. I think you are right. Something weird is going on here.\n. I think I know what's going on.\nbindKeyboard as autoPlay are using the children property to determine the number of displayed slides. So he knows the bounds.\nHence what you are describing is the expected result.\nHowever, using virtualize with slideCount and bindKeyboard or autoPlay won't goes well when we reach the edge. That could easily be fixed by making the bindKeyboard and the autoPlay HOC looking at the slideCount property insted of Children.count(this.props).\n. To sum up.\n1. There is one bug with slideCount.\n2. The documentation is laking a section on the composition of HOCs.\n. @leMaik Turns out, the issue was more global than my previous points. I should have thought about the composition is the first place. It's going to be fixed with the next release.\n. Notice that the right usage is autoPlay(bindKeyboard(virtualize(SwipeableViews))). \n. Could you try out the v0.7.7 release? I think that it's fixed now.\n. The onSwitching callback is only called when the user is swiping. Not when the index is changing. Have you tried using the onChangeIndex callback instead?\nHere is your reproduction test case: http://www.webpackbin.com/4JaexIQ6b.\n. You need to move the following block outside of the render method.\nOtherwise, React thinks you are rendering a different component and start the unmounting / mounting process instead of the update process.\njsx\n        const AutoPlaySwipeableViews = autoPlay(SwipeableViews);\n        const BindKeyboardSwipeableViews = bindKeyboard(AutoPlaySwipeableViews);\n. Right, I was able to reproduce the behavior locally. I'm gonna have a look at it.\n. @ashl1 Sorry, but I'm not answering Material-UI issue here.\nRegarding animating the height of the SwipeableView, you can use one of the following property:\n- style\n- className\n- containerStyle\n- slideStyle\nWe don't provide inner className selector. I'm open to this type of properties if needed (containerClassName and slideClassName).\nHowever, if you are using the component to display on the all screen. You most likely don't want to animate the height.\n. Could you provide a reproduction test case?\nIf you are targeting the browser environment, you can use this playground: http://www.webpackbin.com/V10kOcV6-.\n. Thanks,  that makes much more sense. Well, that's the expected default behavior.\nThat's linked to the implementation approach used.\nYou have two way to solve it.\n1. You can set a fix height with the styles properties.\nYou can have a look at the demo source code.\n2. You can use the animateHeight property.  Again, have a look at the demos. \n. Same here. Some source code / playground would help understanding the issue \n. @janhartmann Thanks for finding this issue. I have just committed a fix taking your PR as inspiration.\n. > does not allow vertical scrolling\nAre you refering to the inertial scrolling of iOS? \n. It's most likely linked to this line.\nYeap, I have only noticed the issue on iPad so far.\n. Right, that would be good to support Windows Phone. However, that's not a priority for me.\nThat represent a very low fraction of the overall traffic (1.20 % of the mobile traffic, 0.8 % of the overall traffic on my end).\nI would accept a PR to fix it. But I won't work on it.\n. Based on https://github.com/oliviertassinari/react-swipeable-views/issues/183#issuecomment-280537197, we will most likely have to handle touch-action dynamically to prevent scrolling.. Ok, I have found a Browser compatibility section in the Web APIs | MDN.\nThe PointerEvent implementation isn't ready for prime time. Many browsers are lagging behind.\nImplementing it here would only increase bundle size. Also, the Windows Phone platform is dying.\nMaybe we can come back to this issue in 2 years.. You need to control the component (using onChange). Acception this PR will create unpredictible changing index. \n. This PR shouldn't have passed the test suite. I'm gonna add a test. \n. I have added a new test regarding this behavior 208bdd9d609a6ab98ce09455b3c8ad62e0d6bf22.\n. Thanks. \n. You can use the virtualize HoC with the slideCount property. \n. > What I want is just like a bootstrap carousel\nIn that case, use the virtualize with a proper renderSlide property fonction. There is some boilerplate at stake here. If it's a common pattern, we could provide an helper. \n. Sounds like a cool use case.\nWhat about adding a left and a right property to render some slides on the edges?\n. I agree, that sounds like a good property to have. \n. @vincentsels Could you open another issue with what you are trying to achieve and what's not working? Thanks!\nonTransitionEnd could help in other circumstances.\n. What version are you using? I have no idea where this warning is coming from.\n. I'm closing this issue. I believe that something is wrong on your side. Makes sure you don't wrap the component nor that you have two versions of React installed.\n. Have a look at this demo https://github.com/oliviertassinari/react-swipeable-views/blob/master/docs/src/demo/DemoNested.js\n. I have an hard coded timeout of 500ms as a work around for #152.\nAddressing the core issue of #152 should address this issue too.\n171 could help with a better workaround (quick-win),\n. I have just fixed a related issue on the browser and native.animated:  908edc4.\nBefore:\n\nAfter:\n\n. @jardakotesovec Could you post a full example into a different issue? That would help. Thanks!\n. Solved in https://github.com/oliviertassinari/react-swipeable-views/commit/5eeb421be1072a92068d65ef1eecfacb28fbfe01.\n. @jardakotesovec That was a different issue, I have opened https://github.com/oliviertassinari/react-swipeable-views/issues/184 for investigating a better solution.\n. @vincentsels Thanks for raising this issue. That's a very good starting point to work on some further improvements for the virtualized HoC.\n\nbe able to configure whether you want the component's current & previous index state to be changed on touch end or on transition end\n\nThere is one missing information that we have to take into account. The virtualized HoC is increasing the displayed window by 1 when users are swiping forward at the onTouchEnd callback. This allows users to swipe as fast as possible.\nFor some reason, there is a limitation for doing it when swiping backward (#152).\nI plan to fix the issue and to have the same behavior when swiping backward.\nHowever, you are right, there is room for improvement. E.g. on the Demo8 of the docs, slideRenderer is called 7+6 times when swiping forward and 6+6 times when swiping backward.\nI'm not sure what the best strategy is. We have two areas of improvement:\n- Mounting component\n  - We could be deferring the injection of the dom elements that are not on screen.\n- React.createElement\n  - We could be reducing the number of calls to slideRenderer.\n. I confirm, something weird is going one here.\nIt's linked to hasFoundNativeHandler that hasn't received a matrix rotation.\n. Here is a related issue #144.\n. > I would much rather see the height of the container get updated than dealing with a overflow auto scrollbar\nThat wasn't working before this change.\nDynamic content height is definitely not supported right now.\nYou can add an overflow-y: auto; style to the slides to fix the overflow issue.\nI have no plan regarding improving this point. I'm not sure what's the best approach is.\n. @DaveSpivey Any idea how we could improve this dirty hack? Maybe exposing a callback trigger.. @Nopik Or you could help fixing it ;). @kimown How is #169 different from your use case? I believe that's the same one.\nI feel like we should be adding a Demo for it. What do you think?\n. Here is an example of implementation with 3 different slides:\n``` js\nimport React from 'react';\nimport SwipeableViews from 'react-swipeable-views';\nimport virtualize from 'react-swipeable-views/lib/virtualize';\nimport mod from 'react-swipeable-views/lib/utils/mod';\nconst EnhancedSwipeableViews = virtualize(SwipeableViews);\nfunction slideRenderer(params) {\n  const {\n    index,\n    key,\n  } = params;\nswitch (mod(index, 3)) {\n    case 0:\n      return (\n        \n          {'slide n\u00b01'}\n        \n      );\ncase 1:\n  return (\n    <div key={key}>\n      {'slide n\u00b02'}\n    </div>\n  );\n\ncase 2:\n  return (\n    <div key={key}>\n      {'slide n\u00b03'}\n    </div>\n  );\n\ndefault:\n  return null;\n\n}\n}\nconst DemoHocs = () => (\n  \n);\nexport default DemoHocs;\n```\n\nThis API has some pros and cons\nPros\n\nRendering an arbitrary high number of slides isn't going to have a negative impact on performance. We have majored the complexity.\nWe have a better control on the React lifecycles rendering process.\n  E.g. We could add an extra performance optimization layer by caching answer of the slideRenderer callback property.\n\nCons\n\nThere is more boilerplate in the API.\nThe API is less user-friendly.\n. > I don't fully understand what slideCount does.\n\nIt's adding two boundaries. The index can go above slideCount and under 0.\n\nthere are times where it will not allow me to continue the scrolling the views.\n\nDo you have a screen recording showing it? If you do, could you post it on a new issue so we can investigate it further?\nOr you could use http://www.webpackbin.com/ to post a reproduction test case.\n. By controlling the component, you could override the user interaction when they try to move in the opposite direction.\nAlternatively, you could remove slide as user move in one direction. However, you might notice one issue with the animation when doing so with moving forward as #152 try to address.\n. Actually, the first option is probably the best one as it's gonna provide a better user feedback regarding the forbidden direction.\nI have modified the DemoTabs to get it working.\njsx\n  handleChangeIndex = (index) => {\n    const oldIndex = this.state.index;\n    this.setState({\n      index,\n    }, () => {\n      if (index < oldIndex) {\n        this.setState({\n          index: oldIndex,\n        });\n      }\n    });\n  };\n\n. IE10 was supported with an earlier version of React. By investing time, that could be done.\nBut that's 0.3% of the market share. I won't work on it.\nYou are right, we should add this limitation in the README.md \ud83d\udc4d . I'm on it.\n. Alternatively, we could be following slick solution with the floating: left. However, that layout approach is slower than the flexbox one on modern browser.\n. There is no onChange property on the SwipeableViews component. Use onChangeIndex.\n. @RByers Thanks for the link to the touch-action I'm adding it to #164.\nSide note, we have an extra level of complexity as we dynamically prevent the scroll. We wait for a clear signal from the user that he wants to swipe and not to scroll. We will see if adding the class dynamically works.. > do you want to make the decision based on something that has happened after the user's finger has contacted the screen\nWe wait some touchmove events to deduce the user intention. The heuristic is implemented here.\nChrome has a similar logic internally, but our check is more restrictive to apply first.\n\nInteresting. touch-action takes effect just before the touchstart listener is invoked. \n\nOh, that sounds like a dead end. Hopefully, blocking the scroll is a nice to have feature. We can live without. \n. Your resource is private. Could you post an image right on Github? Thanks.\n. I'm closing this issue for inactivity\n. Sounds like you are looking for some inertial scrolling.\nIt's quite done the other way around now.\nI mean, we set a target position and the transition is following some physic rules to reach the target.\n. I'm closing. It's out of the scope of the library.. @dnecklesportfolio It's not possible. You can only nest swipeable views. One would be on the x axis while the other one would be on the y axis. I never had this use case in mind when designing this component.\n. @antsav I'm not sure to follow the issue. I think that we should move the discussion to another issue. This one is about a new feature.\nA live reproduction example with an image showing what's wrong would be great. . @dnecklesportfolio I'm closing the issue as I think it will require too much effort to implement. Also, it doesn't fit into the vision of the project. Thanks for raising this point! . Is this example enough https://github.com/oliviertassinari/react-swipeable-views/blob/master/docs/src/demo/DemoAxis.js? \n. Have you investigated the preventDefault option on the event? I think that we should be able to address the issue that way. \n. @pbellon Oh, you are right. This problem is much more interesting to solve than I thought of.\nIt's even harder when we realize that only nested displayed SwipeableViews should handle the keystroke. That mean we should have slave and master keystroke handler.\nI see two ways to address this issue:\n1. The simplest one is on your side. You wrap the root Swipeable with the bindKeyboard HoC.\nYou then control all your Swipeable components. It's now your responsibility to handle the root onChangeIndex callback correctly to update  the right index.\n2. A more elegant one is at the library level. We would definitely need to rely on the context.\nEach slide should inject a context bus event that notifies when it became visible and when is not.\nThe bindKeyboard HoC would also inject a context bus event. That will be used to determine which <BindKeyboard /> component should be the master (root) and control the slaves (children).\nI think that option 1. is the best one. We will see if that's a common enough use case to integrate it in the core of the lib (as adding quite some complexitiy).\n. > However the issue #131 is still not possible to fix with a similar method. When we reach the last slide of a nested swipeable view, swiping to next slide should trigger swipe in parent view (A). You can swipe in the parent view but you have to swipe outside of the child (B) view.\nThat should be working. Can you provide a reproduction test case with http://www.webpackbin.com/?. > but not in the opposite direction (from 2.3 to 3).\nI confirm, that sounds like a regression. I'm gonna fix it.. @pbellon That should be good with fe6bca6c86246b960a34b0b31ca26f0a4b8e23c0.. I'm closing this issue as I don't see much value in option 2.\nI don't want to bloat that lib for a use case most people won't need. Thanks for raising that issue.. I don't get it, that seems to work fine: http://www.webpackbin.com/E10lR9IbG.\n. I'm closing it. I don't have enough information to reproduce it. Feel free to update the playground \ud83d\udc4d .\n. Would that comment help?\n. @jarandmi Right, that point is quite tricky. The component isn't fully controllable.\nIt keeps an internal state for performances concern.\nSo we need to render the component twice in order to get a proper rejection of the navigation.\n1. We first confirm\n2. We then reject\nAs far as I know, the dispatch action of redux is synchronously calling the render method.\nSo you shouldn't have any race condition here.\nI'm closing the issue. Hopefully, that's gonna help others.\n. Thanks for the archive, that was quite useful. The root issue seems to be at react-motion level. I have opened an issue: https://github.com/chenglou/react-motion/issues/404.\nI want to move away from react-motion since quite some time now. That would be another argument to do it.. @yoadsn Interesting approach! Have you tried implementing it? My only concern would be around performance. I'm not sure how it's gonna behave.\nI see two other options:\n- Switching react-motion for animated as we do on the native platform but that's increasing the build size (288 kB vs 162kB without any compression).\n- Prune the first render of react-motion in that case so we only keep the second one with a valid state.. The solution is quite simple. I have removed the react-motion dependency, making the implementation lighter.. I need to upgrade the dependencies.. Upgrading this one should be enough https://github.com/oliviertassinari/react-swipeable-views/blob/master/package.json#L91.. Close with 372379f5f4254d93cdd0413be9d83e6a9fe97cd9.. I don't understand. How is the source linked to the documentation? . Sorry, that doesn't make sense to me. . Well, could you provide a reproduction test case with what you are doing and where it fails? That would help a lot \ud83d\udc77 . http://www.webpackbin.com.\n. @emanuelsetitinger Thanks for the webpackbin example!\nI see two options here:\n1. You can use the containerStyle property to set a max height. E.g. http://www.webpackbin.com/Vy8VBGrMf\n2. You can scroll to the top when changing index. But I think that it should be users responsibility and not the lib.. @dnecklesportfolio I'm not sure that I will have time to work on your specific needs.\nI'm doing it for fun. Let's close this issue as I think we went down the rabbit hole \ud83d\udc30 .\nThanks.. @just-boris I'm not sure to understand the underlying issue. What do you want to achieve in the end?. Interesting, my only concern with this approach is regarding the build size and introducing a large dependency.. @wub Thanks for you point of view. I'm closing it for #254.. @just-boris Thanks!. @just-boris Yes, I'm on it.. What's blocking it? I don't have any dependency to it: https://github.com/oliviertassinari/react-swipeable-views/blob/master/package.json#L34-L43.. I'm closing this issue. I don't think that the root of the issue is here.. Thanks for raising this issue. I believe that it's a duplicate of #164.\nLet's move the conversation there.. Do you have a reproduction test case? . @mikehobi Thanks for the link, it can be implemented today, I'm closing this issue for #181.. > I'm having trouble coming up with a clever way to to a specific index.\nHave you tried the index property?\n\nIs there a way to simply rerender the current card?\n\nIs the parent component actually rerendered? I haven't added any pure logic, nor caching calls to slideRenderer yet. That should be working.\n. > The parent does in fact update, but the slides do not get rerendered (nor does slideRenderer get called).\nIf you find out what's going on, let me know. Thanks. . > looking at *demo code for virtualize and Read Me did not make it clear.\nI have no idea how to make it clearer.\nI'm closing this issue. If you find any tips, feel free to open a PR. I would love to merge it.. I'm adding #152 to the conversation as an early attempt to address the issue.. > Is it too ugly to create a timer\nThat was my first implementation, but then I had issues like this one to fix #174.\nI'm still not sure how we should be solving that issue.\nhttp://www.apple.com/ approach is interesting. I'm gonna investigate https://github.com/animatedjs/animated.\n. > eventually arriving at a \"last slide\"\nThat should be fixed with 9eee35972d5be26fd0f1419a54b60da3170ae1ee.. > using a bigger overscanSlideCount at the moment would make it harder to \"reach the last slide\"\nI feel like adding an overscanSlideCountLeft property would be the simplest fix for that issue.\nI can only think about two alternatives:\n- Implementing that logic: https://github.com/oliviertassinari/react-swipeable-views/pull/152#issuecomment-249381126 on all the platforms. That's quite some work.\n- making each slide absolute positioned. That's basically what react-virtualized is doing. But that raise some other issues. That layout needs some specific care as no longer determined by the children.. Thanks.. That's an excellent idea. Thanks for that PR.. Done https://github.com/oliviertassinari/react-swipeable-views/releases/tag/v0.8.3. I don't have any react-native-vector-icons reference in the project. I'm wondering what's going on.. I have published react-swipeable-views-native.. What you proposed was the original solution. But, react-motion is only a peer dependency for the browser platform. It simpler removing it\nHave a look at https://github.com/oliviertassinari/react-swipeable-views/issues/100. Have you tried controlling the component and rejecting the onIndexChange callback when it's not relevent? . I'm not sure what you want to achieve.\nWe are also exposing the onTouchStart / onTouchMove / onTouchEnd callbacks.\nThey can be used if you need a lower level API. I'm closing this question.. > dependency leading to a naming conflict\nWhat naming conflict are you referring to?\nDo you want to submit a PR? Is it linked to #207?. > This can lead to problems, and in my case is.\nWhat's your issue?\n\nReact-native for instance references react as a \"peerDependency\", not as a \"dependency\"\n\nSounds like a good idea.\nI think that we should be releasing the native version under a different npm package to simplify things (not shared with the browser one). . I have published react-swipeable-views-native.. > So the naming conflict will occur when you run material-ui/docs in react native\nIt's not supposed to be runned with react-native. But upgrading the dependency should fix that issue. . I can't find an obvious reason why wouldn't work. Could you try providing a live example with http://www.webpackbin.com? That would make is easier to investigate thanks.. Cool, I'm glad you figured it out.. Oups, I haven't moved the dependencies in the right packages.. Should be fixed by https://github.com/oliviertassinari/react-swipeable-views/commit/fd266a1f91e1ecc217fd71256abd908067b04654.. I confirm, I have tried it, it's \ud83d\udcaf % fixed. Thanks for the report.. What's the issue?. I'm closing it, waiting some feedback. . The graph of dependencies between the packages is the following:\n- 1 react-swipeable-views-core (core modules shared between the different packages)\n- 2 react-swipeable-views [1] (browser implementation of the <SwipeableViews />)\n- 3 react-swipeable-views-native [1] (native implementations of the <SwipeableViews />)\n\n4 react-swipeable-views-utils [1] (Higher order Component that can be used with the three different implementations available)\n\n\nShould install react-swipeable-views-utils in order to use virtualize?\n\nYes, you should. The native users are forced to do it right, for the browser users, I have kept the old modules, just adding a deprecation comment.\nBut it looks like I have forgotten to add react-swipeable-views-utils in  https://github.com/oliviertassinari/react-swipeable-views/blob/master/packages/react-swipeable-views/package.json#L25 to make it work \ud83d\ude48 .\n. I'm gonna\n- document what each packages is for\n- Add a deprecation warning when importing the old HoC packages\n- Add the missing dependency. Could you provide a reproduction example. That would help. Thanks :).. Actually, I think that I get your issue. I'm considered the component controlled as soon as a onChangeIndex property is provided: https://github.com/oliviertassinari/react-swipeable-views/blob/master/packages/react-swipeable-views-utils/src/autoPlay.js#L139-L145.\nI think that it should be the index that trigger that behavior.. I'm gonna do that tomorrow.. Could you provide a reproduction test case, using a tool like http://www.webpackbin.com/ ? That would help a lot, thanks.. I'm closing the issue, missing a reproduction test case so I can investigate.. I don't understand, that's the issue?. @scoot1585 Thanks for raising that issue. Following http://stackoverflow.com/questions/16688571/getting-a-divs-scrollwidth-when-it-has-an-absolute-positioned-child-div, I couldn't find any better solution than disabling the feature in that case.. Thanks for the support. Have you seen the last demo of the documentation?\nI think that it's what you are looking for:\n\nThe source.. :) . Do you have the stack trace? That would help, thanks!. npm install --save react-swipeable-views-native is correct.\nHave a look at the package structure for more details.. > You seem to have place a setState() inside your touch move event.\nWe use that setState to update the view position. That's a tradeoff use to simplify the implementation.\nWe could be more performance by using a data binding between the move events and the applied style.\nAdding a pure logic in the slide view solve 80% of the performance issue. Try that first.\nIf that still not acceptable, try the virtualize Higer-order Component.\nAnd if that's still not good enough. A pull request is welcome \ud83d\ude04 .. Did you had a look at the source code of the demos? For instance the DemoSimple.. > I need the swipeable view to have a height of 100%\nI don't see where it's the issue. You can add a height: 100% or apply the height of the container to the slide themselves. Have a look at the properties documentation/DOM structure/source. You should be able to customize anything you need.\nIt would be awesome to have the answer of your question once you figure it out :).\nHopefully, that can help others.. @stevewillard You can revert back to v0.9.3.. It should be fixed now.. I'm on it.. We don't provide any API to do that. I guess it could be hacked away by adding a transition-delay property. I'm not sure how it's gonna behave.. I'm closing that issue. Feel free to post the solution here if you find one. Hopefully, that will help others.. @tomvdv I'm all in to remove that Math.round. I don't think that we need it.\nDo you want to submit a PR?. @robrkerr Thanks!. I have been disabling flow lately as not providing a good enough value/cost ratio.\nOups, I'm gonna fix that issue. It's coming from that line.. I have reproduced the issue. I don't see better option than advising users to use the direction reverse property. Does that work for you? . The following example seems to work fine:\n```jsx\n// @flow weak\nimport React from 'react';\nimport SwipeableViews from 'react-swipeable-views';\nconst styles = {\n  root: {\n    direction: 'ltr',\n  },\n  slide: {\n    padding: 15,\n    minHeight: 100,\n    color: '#fff',\n    direction: 'rtl',\n  },\n  slide1: {\n    backgroundColor: '#FEA900',\n  },\n  slide2: {\n    backgroundColor: '#B3DC4A',\n  },\n  slide3: {\n    backgroundColor: '#6AC0FF',\n  },\n};\nconst DemoRTL = () => (\n  \n\n      slide n\u00b01\n    \n\n      slide n\u00b02\n    \n\n      slide n\u00b03\n    \n\n);\nexport default DemoRTL;\n```\n\nI think that I'm gonna have to set direction: 'ltr', internally and let users handling the right properties on their side. Would that work for you? I can't see a better solution.. @leMaik I think that you can try the containerStyle property. . > something similar and leave the responsibility for not having content scrolling to the developer.\nThat sounds like a good idea to add a ignoreNativeScroll property that would ignore native scroll.\nThat would solve your issue, but more important, that's a behavior that users might expect.. @RonjaO Thanks for confirming the fix \ud83d\udc4d .. @RonjaO Thanks.. Thanks.. Thanks for the example!\nThe seen behavior is indeed the expected one.\n\nWe have at most 5 slides rendered. We have the following snapshot once we change the current display slide:\n1. a left offset\n2. the right overscan slide\n3. the old current slide\n4. the new current slide\n5. the right overscan slide\nOnce the transition is finished, you get 4 slides with the following snapshot:\n1. a left offset\n2. the right overscan slide\n3. the current slide\n4. the right overscan slide\nThat extra first slide is deeply linked to #204. I think that we should allow users to customize the left and right overscanSlideCount independently.. I'm closing it for #204.. The component is only intended for touchscreens. We don't handle mouse events nor pen ones.\n164 suggest supporting the Pointer Events API. It's quite a new API not supported everywhere.\nThis issue sounds to me as a feature request: make the swipe work with a mouse.. @jmheik Feel free to open new issues if you find something else not working \ud83d\udc4d .. @America-first-melon What do you mean?. It's not live. Are you using a local fork?. It was fixed with #389.. @klis87 Thanks.. @robrkerr The mouse leave approach sounds good to me.. @robrkerr Thanks. I will have a deep look into it tomorrow.. @robrkerr Thanks for the effort. I'm continuing it with #266.. Thanks \ud83d\udd0d . I think that you are on you own here. The react native version is less popular than the web one.\nI haven't seen much how people are using it.\nHave you tried nesting the SwipeableViews? But it depends on the feature you are looking for. . Hi, thanks for digging into the performance of the component. Did you manage to get a working version with the ListView?\nNotice that we have another implementation using a animated.js that could perform better as well as a virtualize Higher order Component to handle a large amount of slides.. You need to control the component with the index and the onChangeIndex properties.. Changing the index from 4 to 0 after a click event on the button should do what you are describing.. The source code is right here https://github.com/oliviertassinari/react-swipeable-views/blob/master/docs/src/demo/DemoAutoPlay.js#L59-L63. Feel free to copy the component for your own needs \ud83d\ude04 .. That's a good question. I know that @bvaughn has been looking for a carousel use case of his react-virtualized project.\nOriginally, when I started the project, react-virtualized wasn't a thing.\nI believe that using react-virtualized under the hood would mean animating the scroll position over a transformation of an element. Actually, we could implement a scroll control of the component without react-virtualized, then integrating react-virtualized to provide the same feature as the virtualize() Higher-order component.\nThat would mean pretty much doing the same thing as I have done with native, trying out two implementation\n- Animated.js (Browser implementation is very close)\n- ScrollView (Conceptually close to what you are suggesting)\nI'm also really curious how well can react-native-web of @necolas brings the native implementation into the web.. No need to keep the issue open.. > The problem is that the render function is called for all components when the swipeable is first rendered.\nI have been implementing a logic to only rendering the displayed slide during the initial render then the other.\n\nHas anyone thought of adding a \"delayRendering\" boolean option to postpone rendering until the slide becomes active?\n\nThat's actually a good idea, some of those optimizations are done inside react-virtualize.\nI think that users should be able to handle it on their side. I have been implementing something like that at @doctolib. But sure, we could backed that into the component, for instance, we could expose an Higher-order component with that logic as I think that it can be shared with the native implementation (I'm assuming you are using the browser one).\nHave you tried using the virtualize() Higher-order component? I have been building it for that use case.\n. @wayofthefuture That's an alternative, let me know the solution you end up using. It would be great for other ending up in that thread or even for publish a new module with that responsibility.. I'm not sure to understand your use case. We expose properties so you can change the style of all the underlying nodes.. Right, you can use slideStyle as well as slideClassName to do that task.\n\nbut i still think that if a slide is null it shouldn't be rendered\n\nThat's a good question. What should be the expected result? I think that you are right here. . I'm gonna label that issue won't fix. Supporting it would mean complexifying the source code, I would rather have users providing the right list of children on userland. Still what can warn against such wrong usage.. @ofirpeer I wish the complexity was as simple on the library end but it's not. That's why I have introduced a warning as it's much simpler for users to take care of it. . Thanks! . If you are looking for a react-router@3 integration example, you can have a look at my project.\nHere is the routes and the render.\nI'm not sure how that could be elegantly combine with react-router@4, I haven't tried out.\nRegarding virtualized, I would rather use that component when you need to render a large number of slides, for instance a carousel on mobile.\nI hope that help. Feel free to submit your solution, hopefully that would help others.. I'm closing, not to stop the discussion but as I don't have time to provide a better answer.. Sounds like you are looking for a swipe to go back implementation, close to what iOS is doing.\nThat's definitely something not supported. I'm not sure that I want to go into that direction.\nHowever, I guess that it would be good if users could provide a transformation function for each slide (taking an index and a slide number as input and outputting a style). That would have an important implication on the library.. Actually, I think that it's more of a documentation issue. The underlying API is already available: onSwitching callback.. What's the behavior of a loop roll? . I'm closing the issue, you should be able to implement it on user land.. @Nopik Thanks for letting me know. Let's release it.. You can find all the demos in that folder.. To be more accurate, the SwipeableViews.scroll.js implementation works but the default one SwipeableViews.animated.js don't.. Use the enableMouseEvents property. . Good question, I would expect the component to work with SSR. If not, I'm willing to fix it. . Any update? . > in a way that isn't state based?\nWhat's wrong with a state-based solution? Controlling the index property sounds like the best solution. You could also keep both arrows, we haven't added any here.. Oh I see. I think that you should be using the count value at your advantage. You could have a instance variable containing it. The core of the issue seems to be with your responsive solution. \njsx\nrenderSwipeableViews = count => (\nIf you are interested in different solution, we have been developing a withWidth() Higher-order Component on Material-UI.. > Without calculating from index and indexLatest.\nThat's a one line logic. That sounds really simple. What do you have in mind? . Have you tried onSwitching? . Did you try nesting two SwipeableViews? I'm not sure to understand the result you are looking for. My be you have a video?. That's a complex use case, that I haven't anticipated when designing the component. Have you considered nesting two <SwipeableViews />?. @christianeide I have never pushed the component that far. Honestly, I don't have time to look at it in detail. Still, I would love to get the answer, that could help other!. Hey, setting the index property is making the component controlled, you need to handle the change event. Here is an example. That should fix your issue. Let me know if you find others.. I confirm, I'm on it, thanks for raising it!. Hey, I believe that this issue is a duplicate of #181.. It can be implemented as we are speaking, but the API could be improved. I would love your feedback on that point.. Great, thanks!. Let us know if you find something. Maybe the performance devtools of your browser could help. I haven't notice that delay yet. . @AlanFoster No, this change isn't impacting react-swipeable-views-native.. We could add a property for that.. Regarding the feature. I'm curious. What's the use case? Why would someone want to render all the slides on the server. Is it SEO related? . Yes, you can do such thing. <SwipeableViews /> should behave like a regular <div />. Same problem, same solution, just use an array of child as children.. Have a look at this section performance-on-browser.  Feel free to submit a PR to improve it if that's not clear enough.. That sounds like a regression introduced by #293 in order to support the Modal mode.. Do you have a reproduction example?. We don't give access to the event\n| Name | Type | Default | Platform | Description |\n|:-----|:-----|:--------|:---------|:------------|\n| onChangeIndex | function(index, indexLatest) | | all | This is callback prop. It's call by the component when the shown slide change after a swipe made by the user. This is useful when you have tabs linked to each slide. |\n. This package isn't published on npm. Good catch :) . Thank you. @dasblitz Thanks :). @dasblitz Can't that feature be already implemented with the existing API? I have at least one closed issue around that matter.. You could do something close to the Demo 7 of the documentation:\n\n. @tafelito This logic is here to improve the time to interaction metric.. @tafelito It's rending the first slide, then it's rendering the other slides. All of his occurs in two batches.. Fix the height of the parent of the slides. I have this example. Also, the demos of the documentation illustrate how to do it. It's Demo n\u00b03.. That looks great :) . Sorry, I'm not sure I can help.. Thanks for looking into it!. I can't see the difference with the styling changes. Could you disable it please? :) . No clue :/. I'm closing as I'm not able to reproduce on the demo/documentation. . Great :). @jardakotesovec i will release a new version today. . Done. > In my case, when I swipe slides via index prop\nSo, I'm assuming that you already have that information? I would rather no increase the API surface if not needed.. > I hope I've explained myself well.\nThat's all right, I think that you should be handling the onChangeIndex callback. And making the component fully controlled. . I have no idea: '0.13.3': '2015-05-08T23:40:52.344Z',. That's expected, you are making the component controlled. You need to listen for the change event to update the index value.. We could add a third argument to the onChangeIndex with some meta data, for instance, the reason behind the event. With that feature, you can filtre out TAB based events. . We don't support react@16 yet. We need to upgrade the peer dependencies.. What about using this pattern instead in order to avoid the warning?. The virtualize Higher-order Component is using a pure logic in order to avoid unneeded rerender.\nHere are some work-around. Let me know if that works out for you. We can think of changing the implementation otherwise.. Does that work without the virtualize HOC?. I have no clue, let us know if it's possible :).. Yeah, I'm always happy to hear more about how people use this lib! We could even use it to add a demo in the docs. . We have a demo with the expected result. Have a look at them. . @PardeepWildnet It's the demo n\u00b03 in the docs and this one in the source https://github.com/oliviertassinari/react-swipeable-views/blob/5835f94383ddbc7d16baea4df8404d3f70262830/docs/src/demo/DemoScroll.js. @Schlesiger We have many unit tests in the repository that are testing different swipe feature. I'm not sure they are high level enough for you.\nAlternatively, you can always simulate a onChangeIndex event.. That's close to an e2e tests. You can't use shallow for that. You need to mount the component. Honestly, I have never been writing such test while using the component multiple times. I can't see what value this test can potentially bring.. On the other hand, I still have an opened issue to run such test on the browser. Butt I have never found the time to work on it. Unit tests and manualy testing the demo website have been enough soo far. . https://github.com/oliviertassinari/react-swipeable-views/issues/136. Always happy to see an example. That something we could take advantage of later. . You can use onChangeIndex.. No, it wasn't designed for this use case.. @tOke3i There is no plan to add this feature. I don't think that it fits into the vision of the project. Let us know if you find a solution, that could potentially help others.. @Ixl123 Thanks. What version of flow are you using?\nWhat's the complete error message?\nWhat version of the lib are you using?. @skumblue Oops, for one moment, I have mixed jest and flow in my mind.\nSounds like you are mounting a component without having the browser environment variables. Add them and you should be good. For instance, here is our setup.\nhttps://github.com/oliviertassinari/react-swipeable-views/blob/3c03bd4f19f9a525f71de732309bbdfd96e2c4c1/test/dom.js#L8-L26. @gratiaa I believe the issue comes from the shallow API of enzyme that run the componentDidMount() hook. This hooks try to access an undefined reference:\nhttps://github.com/oliviertassinari/react-swipeable-views/blob/5047f04011d4fd6818823789e96ca12c29ced596/packages/react-swipeable-views/src/SwipeableViews.js#L260-L263\nYou can disable this behavior with the disableLifecycleMethods flag:\nhttps://github.com/oliviertassinari/react-swipeable-views/blob/4c887c9bd0694ca85a239413d5e6eae5935a84b8/packages/react-swipeable-views/src/SwipeableViews.spec.js#L589. You could be using something like a withWidth() Higher order Component to change the shape of the children (slide) based on the current width of the screen. . > How can I access react-swipeable-view-container class so that I can add the max-height property?\nYou can use the containerStyle property.. > Did you try to use ref and ref.updateHieght()?\n@ashl1 Does that work? Maybe we could be exposing a callback property close to the ref pattern to make it work.. @studentIvan I can't help without a reproduction example. But that sounds like an issue with the usage of the lib, not the lib itself. Closing for now.. codesandbox.io and webpackbin are two great tools. . Thank you. Yes, otherwise you need to use the virtualization. . @platonish Please don't comment on closed issue for a new one; \n\nHowever I still get a warning on my console saying Warning: react-swipeable-view: one of the children provided is invalid: null. We are expecting a valid React Element.\n\nThis mean one of your children is null.\n\nAlso, swiping right from slide 0 tries to render slide -1, then slide -2, and so on. This is also the case in the demo:\n\nYes, the virtualize HOC doesn't bound the index. It can go from -Infinity to +Infinity.\nYou have a slideCount property for bounding the index. . Let's try. . I'm going to close the issue for #339. This is a limitation of the component. I don't want to add any more logic to handle it. Thanks for raising it.. Elements absolutely positioned inside a slide are ignored by the native scroll handling logic:\nhttps://github.com/oliviertassinari/react-swipeable-views/blame/5835f94383ddbc7d16baea4df8404d3f70262830/packages/react-swipeable-views/src/SwipeableViews.js#L169-#L170\nI'm not sure to fully understand your question.. @warrenmcquinn You can't have both resistance effect and a vertical scrolling with the current implementation. You need to pick one. Browsers have an extra logic to handle this case. This is something we could do too.. I don't follow, how do you end-up clicking on an element when swiping?. > whenever the starting and ending position of my mouse event is still within the element\nFrom what I understand, the mouse doesn't change enough to be considered a swipe, hence, we don't do anything.. @hodgef Thanks for the extra information. I better understand what's going on now. I fear it's happening at a different level of abstraction. I don't see how it could be something handled by the library. I see two options:\n1. You stop the propagation of the mouse move event on the element that listens for the click event \njsx\n    <SwipeableViews enableMouseEvents>\n      <div style={Object.assign({}, styles.slide, styles.slide1)}>\n        <button\n          type=\"button\"\n          onMouseMove={event => event.stopPropagation()}\n          onClick={() => console.log('onClick')}\n        >\n          slide n\u00b01\n        </button>\n      </div>\n      <div style={Object.assign({}, styles.slide, styles.slide2)}>slide n\u00b02</div>\n      <div style={Object.assign({}, styles.slide, styles.slide3)}>slide n\u00b03</div>\n   </SwipeableViews>\nhttps://codesandbox.io/s/k56wzz4407\n\nYou can prune the false-positive click event:\n```jsx\nlet currentIndex;\n\nfunction App() {\n  return (\n     {\n        setTimeout(() => {\n          currentIndex = index;\n        });\n      }}\n    >\n      \n {\n            if (currentIndex === Math.round(currentIndex)) {\n              console.log('onClick');\n            }\n          }}\n        >\n          slide n\u00b01\n        \n\nslide n\u00b02\nslide n\u00b03\n\n  );\n}\n```\nhttps://codesandbox.io/s/yr27wxq19. @frendyguo Do you have a reproduction example?. I couldn't reproduce the issue. I'm suspecting the issue is not linked to this library. Please provide a reproduction example if you have one :).. @brason The question seems unrelated to the lib. You can always try on StackOverflow.. The best option would probably to add a div outside the component preventing the SwipeableView to receive the touch events.. > Having a div like this within the SwipeableView \n@mindnektar Have you tried putting the div outside of the component? However, calling  stopPropagation inside should definitely prevent the swipe. For instance: https://github.com/oliviertassinari/react-swipeable-views/issues/347#issuecomment-346952941. @mindnektar Could you setup a simple reproduction example on codesandbox? I think I know what's wrong. . It's already supported https://github.com/oliviertassinari/react-swipeable-views/blob/5835f94383ddbc7d16baea4df8404d3f70262830/packages/react-swipeable-views/package.json#L32. I need to upgrade react-native and react-dom at the same time for the documentation.. @roderickhsiao Thanks for the effort, but you changed the demo dependencies.. The source code is here https://github.com/oliviertassinari/react-swipeable-views/blob/5835f94383ddbc7d16baea4df8404d3f70262830/docs/src/demo/DemoWidth.js. ```jsx\nimport React from 'react'\nimport SwipeableViews from 'react-swipeable-views'\nimport virtualize from 'react-swipeable-views-utils/lib/virtualize'\nimport mod from 'react-swipeable-views-core/lib/mod'\nconst EnhancedSwipeableViews = virtualize(SwipeableViews)\nconst slideRenderer = ({ key, index }) => (\n  {index}\n)\nclass Demo extends React.Component {\n  state = {\n    swipeIndex: 0,\n  }\nhandleChangeIndex = (index) => {\n    this.setState({\n      swipeIndex: index,\n    })\n  };\nrender() \u00a0{\n    return (\n      \n\n this.setState({ swipeIndex: this.state.swipeIndex - 1 })}\n        >\n          previous\n        \n this.setState({ swipeIndex: this.state.swipeIndex + 1 })}\n        >\n          next\n        \n\n    );\n  }\n}\nexport default Demo;\n```\nhttps://codesandbox.io/s/x9pl77476o\n\nThe correct slide appears with no transition at all.\n\n@Rilliano I have tried reproducing your issue with no luck.\nThe only way I can reproduce this is by clicking very fast and repetitively on the previous button. It's the expected behavior when you reach the windowing edges. You can increase the windowing edges with the overscanSlideBefore and overscanSlideAfter properties.\n. @retrojorgen Sorry, your comment isn't actionable. It would be perfect if you could provide a reproduction example on codesandbox like the one I provided above.. Oops, I should I have been messing around the demo.. I'm closing this issue for #358.. It sounds like your best option is to reimplement the onSwitching behavior on userland and use disabled={true}. I don't see how we could support this niche use case in the core of the library without harming others.. @Schlesiger Thanks for jumping in. I better understand the use case now. I think that we can address the issue with a different approach. Going into #275 direction.\nWe can introduce a getContainerStyle function property that is called with the indexCurrent value and returns the styles applied to the container (where we apply the transform today).\nThis way, one user will have full control over how the dragging visually happen.. I fear there is nothing I can't do to solve the issue. Maybe with a reproduction example, I will be able to help.. > Is it possible to switch the index without swiping?\nYes, it's. You need to control the component with the index and onChangeIndex property. We have a demo demonstrating it. But for some reason it's no longer working #355. It's most likely a regression integration with Material-UI.. I will look into it. . We have an up-to-date demo in https://material-ui-next.com/demos/tabs/#full-width.. > The onChangeIndex isn't working for me. Could it be this is why tabs are not updating when view is swiped?\n@kmartinezmedia We had an issue with a beta version of React in the documentation. I have upgraded it to the latest stable version. The demo is now working as expected..  >I'm also trying to use the onChangeIndex but it is not firing when I programmatically change the index.\n@stevewillard onChangeIndex is not supposed to trigger when you change the index. It will fire when the user interacts with the component. This is how controlled components work.. > Maybe we could be exposing a callback property close to the ref pattern to make it work.\nHave you considered this option? We could provide a action callback property that use can use to trigger actions, this way, we don't encourage people to access private API.. @stfny222 Sure! . I have some small changes to do. I will take care of it later in the evening :).. @stfny222 Thanks for your resilience!. While I'm on this project, I will fix some issues before releasing.. I have published a new release.. The demo is using material-ui@next not material-ui@latest.. I'm closing as a duplicate of #358.. The corresponding issue is interesting to read. Thanks for opening this issue.\nThe current implementation tradeoff is explained in https://github.com/oliviertassinari/react-swipeable-views/tree/3c3e9f03dcf563169e8909df9ce3217e42b44867#performance-on-browser. Are the slides pruning the rerendering with a PURE logic? . I'm surprised pruning the children rendering isn't enough. I have experienced impressive speedup with such method in the past. How many slides do you render?\nGoing back to your question. Yes, I'm opened not to call setState during the touchmove event handling. It should be doable.. @sorin-davidoi Any update? Do we still need this performance improvement tip?. Oh, we should have tested it more thoroughly. What you are describing is expected. We need to bind the method. I'm on it.. @damusnet published, thank you for taking the time to open an issue!. If you have a fixed number of slide, you need to use the following documented property.\njsx\n      /**\n       * When set, it's adding a limit to the number of slide: [0, slideCount].\n       */\n      slideCount: PropTypes.number,\nIn your example, we try to render > 2 items upfront, hence, the mydata[index  = 2] is undefined.. @stropitek Sorry, I couldn't reproduce your issue with the provided snippet: https://codesandbox.io/s/00zqm7mpql.\n\n. Oh, it's good to see that the library works with preact :). It sounds like a preact related issue.. @bmueller-sykes Have closer look at our demos. You miss the key. . @bmueller-sykes This is expected. lifecycles hooks are different from the render calls.. > then I get 6 SLIDE MOUNT declarations when VirtualizeSwipeableViews first loads. Is that expected? \n@bmueller-sykes Yes, It's. We prerender the slides forward and backward.. @tanhauhau It's creating glitches.. @tanhauhau I encourage you to try out without this line commented.. It should be much better with #362. I'm gonna release it soon.. Also from your example, you have the opportunity to prune the rendering tree of the children with a pure logic. https://github.com/oliviertassinari/react-swipeable-views#performance-on-browser. > what do you mean by \"pure logic\"\n@razorxan You have an example here:\nhttps://github.com/oliviertassinari/react-swipeable-views/blob/06dab1f6990d06913b7034b2333b299228ea9499/docs/src/demo/DemoAnimateHeight.js#L37. Ok, it's a regression. I'm on it.. @necolas I have done two tentatives of implementing the library under this folder for react-native. I have lost interest in react-native recently, but I'm eager to unify the implementation! Actually, it's what motived https://github.com/oliviertassinari/react-swipeable-views/pull/378. What would be for me the best way to try out those two implementations with react-native-web? By the way, I'm also wondering if we don't have the opportunity to build a cross-platform material design library.\n. We have a demo with this use case. Is it enough?\nhttps://github.com/oliviertassinari/react-swipeable-views/blob/f06e45f1d22a6ee062a3892b862bd2f834239a1d/docs/src/pages/demos/DemoAutoPlay.js#L51. Your issue has been closed because it does not conform to our issue requirements. \nPlease provide a full reproduction test case. This would help a lot \ud83d\udc77 .\nA live example would be perfect. The codesandbox.io template may be a good starting point. Thank you!. I can't find any reference to minWidth. Let me know if you have more information about the issue.. @renaudtertrais I'm not sure it's the same use case. The only accessibility element we have is aria-hidden. Last effort on a11y was with https://github.com/oliviertassinari/react-swipeable-views/pull/245.. Ok, not the same use case, on the repository you linked, multiples card are shown at the same time. Here, we only show one slide at the time. This is what the aria-hidden property is for.. @renaudtertrais I don't have much knowledge of a11y. Nor I have an important drive in learning more about the topic. I'm reopening the issue as I'm not 100% confident with the current answer to the problem. I would love to get feedback from more people on the topic.. > you'd first want to make the control keyboard operable. \nRegarding making the control keyboard operable, we have a bindKeyboard() higher-order component abstraction to do so. Maybe it can help.\n\nthere's no way to send a signal to the swiper that it should advance to the next card\n\nWe have the option to display dots to signify the current position in the list. I'm not sure it can be used to signal.. We have a demo showing how to use the autoplay in the documentation. . Please refer to the RTL example of the documentation. Let us know if you find an issue with it. . @roderickhsiao Awesome! . @slorber I wish I could log in to Tinder, but I fear my girlfriend retribution \ud83d\ude92. . @slorber I have labeled the react-native (experimental) recently as I have lost interest in the native platform. But the code was definitely working at some point. I have even been working on two different implementations, they are still there.. @mrTuomoK Are you able to cherry-pick what introduced this regression? This would help a lot.. Thanks, so it's coming from this release: https://github.com/oliviertassinari/react-swipeable-views/releases/tag/v0.12.11.. It's most likely a font rendering issue. The height is computed upon the first mount. It's not updated later on when the font loads or an image loads. We are exposing an action property for this use case, you can call updateHeight() anytime you want. In the future, we could be using a mutation observer but browser support for this API is still low.. @qbitza SSR rendering is disabled with animateHeight. Hum, maybe it doesn't have to be this way. Anyway, I do no longer maintain this library, all my firepower is targeted at Material-UI. Feel free to work on it.. @qbitza The library is already pretty stable. Just have to find someone else to keep pushing it.. You can restrict the increment to one in userland. Unless the user didn't actually swiped two days, I will close the issue. . Maybe we can leverage threshold and hysteresis properties to prevent it in the first place?. @oshirok Thank you!. @oshirok Released. Use the index property.. The root of the issue is on Material-UI side. I'm closing for https://github.com/mui-org/material-ui/issues/10643.. I agree, we need to update the lifecycles!. @stop2stare Thanks for raising this consideration. It's something I have already been wondering about when designing the component. I'm against such change for the following reasons.\nUsing will-change trade memory for runtime performance. Firefox will raise a warning if more than 3 times the surface area of the screen is used for such property. The Swipeable component isn't supposed to be all over the screen. So, it should be pretty safe, no changing the code.\nOn the other hand, the change you are proposing introduce new problems.\n1. The index can change independently of the user touch interactions. For instance, you want the will-change property to be set when a timeout triggers and change the current page (automatic carousel). \n2. The touch end event isn't the end of the lifecycle of the component. Once the finger is released, the transition kicks in. We need the will-change to get a smooth animation. You are removing it.. Sorry, I'm focusing my time on Material-UI. I will try to review this pull-request at some point, maybe.. > However, is there a way to load the dynamic contents as well?\n@Sinha06 react-swipeable-views should be agnostic to this problem. So yes, you can load your content dynamically.. There is no exported SupportTouch, it's specific to the documentation.. @romainquellec Your imports are incorrect.. No, you can't.. @hartzis Thanks for the pull-request, yes, this can prevent unneeded calls to the ref function when the component rerender.. @hartzis This would be great :). @hartzis I don't care about the test coverage for this project. Thank you!. > This is the threshold used for detecting a quick swipe. If the computed speed is above this value, the index change.\n@TiagoSousa26 It's not about swiping fast, it about the inertia required of the movement to trigger a onChange event.. >  not doing swipe fast?\nWhat does it mean?. Sorry, I don't understand.. ?. > There is a way of only switch one slider every 2 seconds for example or when the animation ends? Basically, disable the swipe for a specific time.\nYes, you can control the component and have access to the transition end events. So you should be able to build this logic on userland. Feel free to share the result, that could help others.. @ykzts Thank you!. @yogesh-kamble Yes, you can. Feel free to share your solution.. > I need to show more than one item in the given window so tried to set a custom width but in doing that the edge cases stopped working properly.\nIt's not something we support. The closest example we have is: https://react-swipeable-views.com/demos/demos/#custom-width.. > Are you open to a PR to implement this?\n@varenya Thanks for asking. If the overhead for the project is minimal, yes. If it's significant, no.. @varenya Sounds like a plan :). @varenya Do we don't. The touch-move handler should be fast enough not to harm the JavaScript main thread. As far as I understand the problem, if we have two touch-move event triggered between two screens pain, it won't matter because the event handling logic is very fast.. @Bobgy You are right. Thank you for reporting the issue. Right now, the lazy loading only works with server side rendering. Using a setTimeout sounds like a great idea!. @KITSTABChrisGreen setWindow, as all the others imperative methods are a private API. Don't use them. In your case, you can control the index property.. @Jordy-A Let's keep the codebase simple.. I'm already working on it in #459.. @hackedbellini I don't have any ETA, it could take me 1-3 days, maybe, I don't know.. @hackedbellini Would you mind reopening the pull-request so I can continue your effort? Giving you some credit? Thanks.. done :). @hackedbellini I'm happy to hear it! I have been upgrading a lot of things. It could have went badly :). @Bobgy It's a great first pull request \ud83d\udc4c\ud83c\udffb. Thank you for working on it!. @JulioPablo Nice finding! Something went wrong in https://github.com/oliviertassinari/react-swipeable-views/commit/2eb528add3067e2e61e3786eac89fff7e48fd654. The correct wording is\n\nThis is the inlined style that will be applied to each slide container.\n\nDo you want to fix it :)?. @geminiyellow Good question, yes, we could export it like they do: https://github.com/archriss/react-native-snap-carousel#pagination-component.. @taion Yes, I agree. Thanks for raising!. @taion What do you think of removing this code? I think that it's time \ud83d\ude80 \nhttps://github.com/oliviertassinari/react-swipeable-views/blob/248fec18d3a8a947662fe59bc76be6d67d40f636/packages/react-swipeable-views/src/SwipeableViews.js#L25-L26. Plans are made to be changed :). . @digital-flowers Thank you. @digital-flowers I can grant you the access to the npm package.. Sure, I will do a release :). . I don't have the time needed to work on it. @digital-flowers Do you want to take the ownership of the native version?. I have invited you as a contributor :). If someone wants to lead the effort with the native version of the library, I would be happy to give him the necessary admin rights to execute :).. @yacut Thank you, I have given you the admin right for https://www.npmjs.com/package/react-swipeable-views-native.. @yacut Awesome, you did great :). @JulioPablo Thank you. @taion It's all good to me. Thanks. I will release a minor. . @bebraw Thank you!. @MastroLindus Well done, I'm sorry for the delay.. I'm cutting a release.. \ud83d\udc4d . @getogrand Well done, I'm sorry for the delay.. @santospatrick There is an \"unstable\" Portal API in React 15 that works really well. For instance: https://github.com/mui-org/material-ui/blob/v1.0.0-beta.47/packages/material-ui/src/Portal/LegacyPortal.js.. @aibrahim3546 No clue. Your warning is coming from the React codebase. Please provide a minimal reproduction. It will help people to help you.. Great, so we do support preact :). @munkk These callbacks aren't called when you are controlling the component. It would create an infinite loop.. @RosarioAleCali When the user interacts.. @diedsmiling Thank you!. @MatteoGioioso We could add a property for this behavior. Alternatively, you can control the index and ignore the looping index changes.. \ud83e\udd37\u200d\u2642\ufe0f. I'm flattered.. @minhna The properties should be forwarded. Have you tried providing an action property?. @Minishlink We don't support desktop mouse events by default. Only the first demo has this capability enabled. Have you tried with a mobile simulator? . thanks. @mikestaub We have a onSwitching prop for this use case.. @mikestaub It might do it yes.. I'm gonna add travis and an eslint check.\nI suspect a wrong indent here. \n. Could you add it to the Readme too ?\n. This extra check is not good for perfs.\nI think that I would be better\nTo not listen to the event. \n. https://github.com/oliviertassinari/react-swipeable-views/blob/master/.eslintrc\n. :+1: good example \n. Can we use the spread to get the disabled property?\nI plan to pass unused properties to the root div, so I need it.\nI also think that negation are harder to reason about.\n. (could be useful to add a className for instance) \n. Missing a last blank line\n. What is the ext option for? \n. It's linting the lib folder but shouldn't (e.g. /home/travis/build/oliviertassinari/react-swipeable-views/lib/index.js) \n. Can we move the Object.assign outside of the loop, like just before the childrenToRender?\nAlso, use Object.assign({}, styles.slide, slideStyle) instead.\n. \ud83d\udc4d \n. I'm not sure about this change.\nI feel like it's for updating offset.x that really on this.state.viewWidth and index.\nThe index will be the same, so what could have changed is this.state.viewWidth.\nShouldn't it be already handled by handleLayout?\n. I have added this commit to master https://github.com/oliviertassinari/react-swipeable-views/commit/c7768d8f2a7bd75e2d5dcf7e193a2e61c0848eef.\nRegarding this change, could it be because of unwanted call of handleMomentumScrollEnd or handleLayout?\n. @tomwalters Awesome. I'm gonna close this PR. Feel free to reopen it if needed.\n. Shouldn't we check the scroll position to know the direction?\n. That would also help to filter the scroll on the vertical axe.\n. This check seems useless.\n. Are you using animateTransitions={false}? If not, I would just remove this property \ud83d\ude01 .\n. Sorry, I should have been more explcit. Do you have a use case for this property? \n. I see. Let's add it then \ud83d\udc4d.\n. That sounds like an imperative method. Instead, what about using a property to disable the transition?\nWe have two complementary options:\n- provide a animateTransitions property as we have for the index.native.scroll.js version\n- provide a springConfig property as we have for the browser version\n. That's a great idea to add those two properties \ud83d\udc4d .\nI have done it for the browser version. Could we follow the same pattern: https://github.com/oliviertassinari/react-swipeable-views/commit/c6fc0c24ced7d7d8170636b53d9a70f43b2c2514?\n. What about moving it in the dependency section?\nThis modules shouldn't have any impact in production.\n. What's the goal of this check?\njs\n && index > 0\n. This issue can happen when the index is below zero. It would be better to remove it. \n. I thought we couldn't reach this state. How do you end up here? Sounldn't the React  life cycle hook prevent it in the first place? \n. I'm not sure it's what user expect. This indexLatest is in the <SwipeableViews /> referential, not in the HOC one.\n. > I was expecting to receive the indexLatest as per the documentation in my virtualize HOC anyway.\nYes, it's definitely an issue.\n\nI can work around it by looking at this.state.index because that would hold the same info\n\nthis.state.index should be correct \ud83d\udc4d .\n. That's only exposed on the browser platform. Use browser instead of all.. I should start adding some e2e tests infrastructure. That would make a great test.. I think that we should keep that role. At least bootstrap is going so.. data-swipeable=\"true\". I don't think that we need to persist it as it's synchronous. . Why preventing the default? Is it for the text selection? Could you add a comment?. event. I think that it should be users responsibility to prevent that behavior. . Do we need the event to be active (passive: false)? I would expect a regular onMouseMove callback property to be enough.. Oh, that's because of the following line \ud83d\udc4d  (.touches =). What's the logic/consistency on calling onMouseDrag in a onMouseMove listener?. If we don't need the listener to be passive, can we use the idiomatic way. I mean like onMouseUp for instance.. Defining the handler function in the render method is affecting performances. Using a handleTouchStart is preferable.. Calling onMouseUp in a onMouseLeave listener? What's the logic/consistency here?. We should be calling onMouseLeave no matter if enableMouseEvents is enabled or not. Otherwise the event is swallowed for our users.. I agree, it's even an issue when disabled is true.. Can we use the following wording: disableLazyLoading. \nThe name of the boolean properties should be chosen based on the default value. We are following the HTML specification. For instance, the disabled attribute on an input element. This choice allows the shorthand notation.. Missing dot at the end.. disableLazyLoading: false,. ",
    "twidi": "Also on desktop with the mouse?\n. Yes I understand but now this is unusable on desktop browsers if there is no tabs attached, so it cannot be used for apps that should work on mobile and desktop :(\nFYI here on Firefox desktop I have the message \"You need a touch device to swipe between the 3 slides.\", but in chrome I don't.\nBy the way it was just a suggestion, I love what you did!\nPS: last year I made a draft of something like that with hammerjs so it worked with mouse and touch, but I don't know if it is possible for you with the libs you use\n. Ahah you know what? I totally forgot one of my screen had touch features!\nSo when moving the chrome window on the touch-enabled screen, it works like a charm with a finger but not the mouse.\nAnd for firefox, yes, it doesn't work, even on the touch screen :( BUT of course in \"responsive design mode\" and when \"simulate touch events\" is activated, it works, with fingers or mouse.\nAbout the PR, yes I'll see, when I'll integrate your lib, if I can do something ;)\n. ",
    "giladbr": "Following this discussion, is there any chance this component would be adjusted to support \"swiping\" with the mouse on desktop? Maybe utilizing hammer.js/react-hammer?\n This would be of great use and I found no other react component that supports that.\n. Try react-slick. Very powerful, a lot of options, has swiping and many other abilities. Documentation a little lacking, which may lead to integration problems, but we used it successfully and boosted our site's user experience.. ",
    "lolJS": "@oliviertassinari done!\n. ",
    "miguel-ra": "I get this message on console when i run sudo npm install react-swipeable-views --save\n\u251c\u2500\u2500 UNMET PEER DEPENDENCY react@0.13.3\n\u251c\u2500\u2500 UNMET PEER DEPENDENCY react-addons-pure-render-mixin@^0.14.0\n\u251c\u2500\u2500 UNMET PEER DEPENDENCY react-dom@^0.14.0\n\u251c\u2500\u2500 UNMET PEER DEPENDENCY react-motion@^0.3.0\n\u2514\u2500\u252c react-swipeable-views@0.3.0 \n  \u2514\u2500\u2500 object-assign@4.0.1 \nnpm WARN EPEERINVALID react-swipeable-views@0.3.0 requires a peer of react@^0.14.0 but none was installed.\nnpm WARN EPEERINVALID react-swipeable-views@0.3.0 requires a peer of react-addons-pure-render-mixin@^0.14.0 but none was installed.\nnpm WARN EPEERINVALID react-swipeable-views@0.3.0 requires a peer of react-dom@^0.14.0 but none was installed.\nnpm WARN EPEERINVALID react-swipeable-views@0.3.0 requires a peer of react-motion@^0.3.0 but none was installed.\nnpm WARN EPACKAGEJSON .temp No description\nnpm WARN EPACKAGEJSON .temp No repository field.\nnpm WARN EPACKAGEJSON .temp No license field.\n. Thanks for the answer.\nsudo npm install --save react-swipeable-views@0.2.3\nWhen i try to install de 2.3 version i get this other message :S \n\u251c\u2500\u2500 UNMET PEER DEPENDENCY react-motion@^0.3.0\n\u2514\u2500\u252c react-swipeable-views@0.2.3 \n  \u2514\u2500\u2500 object-assign@4.0.1 \nnpm WARN EPEERINVALID react-swipeable-views@0.2.3 requires a peer of react-motion@^0.3.0 but none was installed.\nnpm WARN EPACKAGEJSON .temp No description\nnpm WARN EPACKAGEJSON .temp No repository field.\nnpm WARN EPACKAGEJSON .temp No license field.\nHow can i solve it?\n. Solved.\nAfter install the old version i will needed install react-motion dependency\n. ",
    "zlangbert": "Sorry I wasn't clear. I don't want to set a static height on the container and have to scroll. I'd like the container to expand and contract depending on the height of the active slide.\nSomething like: http://chenglou.me/react-motion/demos/demo4-photo-gallery/\n. Fixed all eslint errors.\nNp! I was about to create the same type of thing myself, glad I stumbled on this\n. Updated\n. Sorry, forgot. Added to readme\n. Changed the disabled code. Let me know if that's not what you meant\n. Added travis-ci badge as well\n. Thanks!\n. Any chance you could release this?\n. Ty sir\n. I think because the dialog is position: fixed it ignores the containers transform3d.\n\nOne way to fix it is to teleport the creation of the dialog dom outside the slider.\n\nWhat do you mean exactly? How would you render the dialog outside its parent?\n. Great to hear, thanks :+1: \n. @oliviertassinari Sorry I didn't get back to you. I was trying to test it out using material-ui checked out from git but I couldn't get my project to build with it. I just tried 0.1.4.0-rc1 though and it works perfectly. Thanks again for all your help, you guys are awesome!\n. > What is the ext option for?\neslint only seems to lint .js by default, --ext gets both extensions\n\nIt's linting the lib folder but shouldn't (e.g. /home/travis/build/oliviertassinari/react-swipeable-views/lib/index.js) \n\nAdded a .eslintignore. Are we good with linting the docs?\n. ",
    "wle8300": "Yea that's it! That's too bad! It would be nice if it had that.\nI've never really built anything with swiping/touching involved so I don't think I have the competency to give your a decent PR. Thank you for your reply though! Cheers.\n. I actually don't really understand any of the abstractions for animating stuff. I'm still kind of a noobie programmer\n. DUDE. YOU. ARE. FREAKIN. AWESOME.\nIn other words, thank you so much! I appreciate this project. Happy thanksgiving Olivier!\n. ",
    "sterlingwes": "Multiple mounts for the same slide doesn't make sense though. In this case I was fetching data for the view in that slide's componentWillMount, and with swipeable wrapping it that request went out twice due to that lifecycle event getting called twice at setup.\nSlick looking library though!\n. ",
    "NickNothom": "Would also really like to see this! \nI have noticed that after my app has been running for a bit, tab switching becomes very laggy on my Android device. Swiping up and down within each tabs remains smooth. And swiping back and forth while keeping my finger on the screen seems to work okay after a few seconds.\nBut when I swipe between tabs it gets choppy sometimes. Reinstalling the app fixes the issue for a bit. \n. ",
    "neekey": "Yes, I figured this out by doing exactly as what you pointed out, it works. \nMaybe document this in case others running into the same issue?\n. good work!\n. ",
    "yuchien302": "Cool! Autoprefixer is definitely the way to go we have time!\n. ",
    "echenley": "@oliviertassinari That should do it, thank you!\nOne sort of tangentially related issue with this and material-ui, since I notice you work on both :wink:. The transform used here breaks any fields that require a fixed overlay (i.e. SelectField). The fixed overlay will be positioned covering the first slide and will be unclickable for any other slide. This I think is due to the width of the slide container being fixed and allowing the slides to overflow.\nA quick fix is to add style={ { transform: 'translate3d(0,0,0)' } } to each slide. That creates a new context for the fixed overlay to attach to.\n. That PR fixes the original issue!\nBy \"fixed overlay\" I'm referring to the backdrop which you can click to dismiss the popup. It has position: fixed and is intended to fill the viewport. However, because this component uses transform: translate3d(), the backdrop of the SelectField component is affected by the following behavior: http://stackoverflow.com/questions/15194313/webkit-css-transform3d-position-fixed-issue.\nTo recreate the issue, put a select field inside of a swipeable view. Click the field and try to click away to close it. It will work inside of the first slide (if you click inside of the slide itself), but it will not work for any other slides since these are overflowing the container which the backdrop is filling. If you inspect the backdrop, it will be positioned over the first slide only, no matter which slide it originated from.\nOne way to fix that is to add transform: 'translate3d(0,0,0)' to each slide to create a new local coordinate system. It might also work to avoid overflowing slides out of the flex container and set it's width to 100% * number_of_slides, and set each child's width to 100% / number_of_slides.\n. :+1: Great, thank you so much!\n. ",
    "jardakotesovec": "@pke I would be also interested in infinite swipe support (meaning that last slide goes to first one and vice versa) - have you managed to solve it? \n. @oliviertassinari I tried to use profiling on one of the demos and did not see any memory growth. How  did you achieve this result?\n. Here is demo1 from website.\n\nBut for memory leaks I think its easier to spot them using Profiles -> Record Heap Allocations.  Which makes pretty easy to spot something unallocated. And in case of the first demo - it occasionally just produced some V8 stuff..  Which I think does not indicate leak in your code..  But someone more educated on V8 would have to answer that.\n\n. @oliviertassinari Yes, I think so... As described for example here. V8 does optimistic optimization which sometime goes wrong and has to fall back to original (In some cases its possible to fix code to avoid these deoptimization situation).  And these 'code deopt data' in Snapshot seems to me indicating just that...  and not actual leak in your code.  But I might be wrong... :-)\n. @oliviertassinari Just tried the new release, but still has that jumpiness that I described in initial description. Just to point out I am using keys in this case to go to the next slide - it slides nicely but shortly before the end it just jump to the final position.\nCan you reproduce on example from initial description?\n. @oliviertassinari I can, but I would copy&paste exactly the same description, because its still exactly the same issue I reported here, so reopening I think would be less confusing.\nWith regards to full example - I am using DemoVirtualize.js from react-swipeable-views/docs/src/Demo. And just adding springConfig with slower settings than its the default. And than using arrow keys to move between slides.\n. @oliviertassinari Thanks! \n. @oliviertassinari Thanks, when do you roughly see to cut release with this fix? Would be awesome if its in week or so.... ",
    "pke": "not yet @jardakotesovec. I am working on other parts of the app, atm. Will report back here if I find a solution.\n. ",
    "dbuarque": "+1\n. ",
    "joshjhargreaves": "+1\n. ",
    "ambewas": "Just to provide a temporary solution for anyone looking at this; I've managed to implement this infinite swipe using the onSwitching callback.\nNote that this only works if you set resistance prop to true. Otherwise, the index passed in onSwitching will never go below/above the lower/upper slide index .\n``` js\n  _handleSwitching(index, moveState) {\n    // check if we are moving the last tab further. If so, we want to scroll back to the first slide.\n    // and vice-versa.\n    const trigger = .1; // don't trigger slide change on small move\n    const furtherThanLastTab = index > (this.props.children.length - 1 + trigger);\n    const furtherThanFirstTab = index < (0 - trigger);\nswitch (moveState) {\ncase 'move':\n  // save sliding behaviour on upper scope\n  if (furtherThanLastTab) {\n    slidingFurtherThanLastSlide = true;\n  } else {\n    slidingFurtherThanLastSlide = false;\n  }\n\n  if (furtherThanFirstTab) {\n    slidingFurtherThanFirstSlide = true;\n  } else {\n    slidingFurtherThanFirstSlide = false;\n  }\n  break;\ncase 'end':\n  if (slidingFurtherThanLastSlide) {\n    this._setActiveTab(0);\n  } else if (slidingFurtherThanFirstSlide) {\n    this._setActiveTab(this.props.children.length - 1);\n  }\n  break;\ndefault:\n  break;\n}\n\n},\n```\nIn _setActiveTab I'm saving an index to the state; which is passed to the index prop on \n. I declared slidingFurtherThanLastSlide outside the component scope, but your solution looks good as well, I'll try it out later!\n. ",
    "theogravity": "I ended up creating the instance vars for slidingFurtherThanFirstSlide and slidingFurtherThanLastSlide and simplified \n``` js\n      // save sliding behaviour on upper scope\n      if (furtherThanLastTab) {\n        slidingFurtherThanLastSlide = true;\n      } else {\n        slidingFurtherThanLastSlide = false;\n      }\n  if (furtherThanFirstTab) {\n    slidingFurtherThanFirstSlide = true;\n  } else {\n    slidingFurtherThanFirstSlide = false;\n  }\n\n```\nto\njs\n        this.slidingFurtherThanLastSlide = Boolean(furtherThanLastTab)\n        this.slidingFurtherThanFirstSlide = Boolean(furtherThanFirstTab)\n. ",
    "jadus": "Great ! Any idea when we can test this ? I have to deal with hundreds of slides and will have to use virtualized if I want it to work.\n. Thanks a lot !\n. ",
    "TCMiranda": "@oliviertassinari thanks!\nDid you find anything about it?\nUntil now my only solution was to use nested native horizontal scroll instead of css transforms, which is a totally different approach :neutral_face:\n. Hey, thanks for getting back to this.\nI am actually using the package even with the issue I mentioned.. \nWe didn't had time to focus on it too.\nIt seems a good plan to ignore the event if a horizontal scrollbar is found.\nBut it would be better to ignore it only if the element is in the middle of the scrollable area. Handling the touch move would be required though...\nSo, I feel like I can help you with this in the next week, if that's ok.\nThanks!\n. ",
    "tconroy": "\ud83d\udc4d to this, looking for a similar feature myself.\n. Thanks for the reply @oliviertassinari. I haven't given it a go yet, but as long as there are no direct DOM references/manipulation in componentWillMount or the constructor it should be compatible. I'll try and see if I can get a working sample up.. Similar findings to @nirlendu. Great! :)  feel free to close this issue ( or maintain for future SSR discussions ) . ",
    "menelike": "works like a charm, thanks a lot @oliviertassinari. Great work!\n. ",
    "seejamescode": "I'm not sure about React-Motion, but the warning can be avoided as long as we insure that none of those values in the object equal NaN. If I have time, I will console log to see what kind of values are reaching it.\nThe odd thing to me is that it is a warning, but it stopped the component from rendering. I was able to downgrade this component temporarily to get it to work.\n. react-motion@0.3.1 and react-swipeable-views@0.3.6 are good.\nreact-motion@0.4.0 and react-swipeable-views@0.4.0 are bad.\n. Me either!\n. ",
    "andrzey": "Unfortunately that doesnt solve the issue.\n. But wont this make it impossible for any other input to have focus @brandonmp ? How is input 3 or input1 going to be able to be focused if input2 gets focus in the onBlur-function?\n. Is a scroll-event being fired when an input gets focus on a different slide @oliviertassinari ? I havent been able to see that yet.\n. @oliviertassinari check out ErlendWade\u00b4s fix on the tabbing-issue. I implemented it in my solution and it worked. Would be nice to have it in the npm-project.\nEdit: See that the solution don\u00b4t take into account vertical scrolling at this time.\n. ",
    "funkyeah": "Is this really a bug? Seems like this is a state management issue. Each item in the list needs to be given a unique identifier and the state/index of each swipeable should be associated with that identifier. Then when an item is deleted from the list the state is not tied to its position in the list. If you want to reset the index of all slides after an event like pressing of a delete button then that should be done from the list controller.\n. It looks like it should work to me. I'll be happy to give it a test when you want.\nThe only thing that looked a little fishy to me is the use of this.state.indexCurrent which often appears to be a duplication of this.state.indexLatest in https://github.com/oliviertassinari/react-swipeable-views/blob/standardize-onChangeIndex/src/SwipeableViews.js#L245\nAlthough that is not always the case in other files. I guess it's just a little hard to understand what they are supposed to mean at all times... but probably still functioning correctly.\n. I wouldn't go that for. I would say my points are OK at best. I'm more just pointer to things that are hard for me to understand, which only means that they are hard for a total beginner to understand, not that anything is necessarily wrong.\nAnyhoo, thanks for doing this project. I'm trying to use it in a react native app to setup gmail like swipe row items... basically the swipe to archive feature but instead swipe to mark as done. So the event API is what I'm depending on. \n. Adding some notes:\nPanresponder initialization happens in index.native.animated.js\nA similar issue was created in the react-native repo... reportedly about iPhone6 and 6s 3D touch causing issues... so it may be unrelated. \nOne fix listed there is to increase the threshold for the onMoveShouldSetPanResponderCapture  parameter. I think this might help here too.\nCurrently it's set so that if the x movement is greater than the y movement then swipeableViews claims the responder:\nreturn Math.abs(gestureState.dx) > Math.abs(gestureState.dy);\nMy theory is that its really hard to consistently tap a button or checkbox with no x movement so tweaking this code may help. Maybe:\nreturn Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.dx) > threshold;\nWhere threshold is either passed or some value that works experimentally. I'll give it a go and see what happens tonight.\n. My description of the issue above appears to be correct. \nI made the threshold = 3 and the nested checkboxes I have can be tapped without issue. With a threshold of 3 I also don't notice any interference with the swipe gesture itself.\n@oliviertassinari  Would you accept a pull request that modifies this? if so how do you think it should be modified? a hard-coded value or an additional API option? \n. Yeah, sorry I realized it was a dumb question as soon as I posted it... so promptly deleted.\nThis does look particularly relevant in TavViewPanResponder:\njs\n  function isMovingHorzontally(evt: GestureEvent, gestureState: GestureState) {\n    return (\n      (Math.abs(gestureState.dx) > Math.abs(gestureState.dy * 3)) &&\n      (Math.abs(gestureState.vx) > Math.abs(gestureState.vy * 3))\n    );\n  }\n. It certainly might work. I can try tonight and let you know. \n. @oliviertassinari I tried:\nreturn Math.abs(gestureState.dx) > Math.abs(gestureState.dy) * 3;\nand it recognized the tap event more consistently than existing code does but was still fairly error prone. I would say when casually tapping (e.g. when not specifically focusing on tapping without moving in the x and y direction) I had a 30% success rate with the original code. The change above got it to 50-50.\nIf I change it to:\nreturn (\n      (Math.abs(gestureState.dx) > Math.abs(gestureState.dy * 3)) &&\n      (Math.abs(gestureState.vx) > Math.abs(gestureState.vy * 3))\n    );\nIt works closer to 3/4 or 4/5ths of the time.\nHonestly the best is still:\nreturn Math.abs(gestureState.dx) > Math.abs(gestureState.dy) && Math.abs(gestureState.dx) > 3;\nThe tap is recognized correctly pretty much every time even with fairly sloppy taps, and I'm unable to perceive any negative impacts to the swipe gesture recognition.\nIf I set it to >2 it works a little better than the vx / vy route but not as good as >3.\nI also tried to find where on the upper end it starts to impact the swipe. At >8 you can just start to notice it if you move your finger really slow and are paying close attention. If you are moving your finger at a normal speed though it wouldn't be noticeable. At normal swipe speeds I couldn't really tell until somewhere around >20 and that is only when I was specifically looking for it. I don't think a normal user would notice until well beyond that.\n. Submitted a pull request and attached the note below to it, but putting it here for reference.\nBefore accepting this you may want to try it. Setting it to 3 is basically the minimum it can be, but a larger value (up to 8) might work better. Having it be a settable parameter is also an option.\nI looked at the Gmail app and it appears to have some sort of threshold for its swiping functionality too. As far as I could guage it seemed to be fairly large. The Inbox gmail app it seemed smaller.\n. Before accepting this you may want to try it. Setting it to 3 is basically the minimum it can be, but a larger value (up to 8) might work better. Having it be a settable parameter is also an option.\nI looked at the Gmail app and it appears to have some sort of threshold for its swiping functionality too. As far as I could guage it seemed to be fairly large. The Inbox gmail app it seemed smaller.\n. ",
    "saurabhsinha": "hi can you be more specific, I mean where to check that the even prevented before or not.. \n. ",
    "joebnb": "ERROR in ./~/react-swipeable-views/lib/index.js\nModule build failed: ReferenceError: Unknown plugin \"transform-react-display-name\" specified in \"/Users/joe/Documents/WorkSpace/m-tanwan-react/node_modules/react-swipeable-views/.babelrc.env.development\" at 0, attempted to resolve relative to \"/Users/joe/.def/node_modules/@ali/builder-cake/node_modules/@ali/cake-webpack-config\"\n. ",
    "jalooc": "Sorry, totally my fault - I rendered list of components instead of elements.\nIf anyone else sees this issue, just don't forget to wrap the stateless component in React.createElement(MyComponent); or <MyComponent />\n@oliviertassinari you can remove the bug label (or the entire issue if you prefer).\n. ",
    "vans163": "Im not sure what you mean. What does having the root of the drop-down outside the swipableview mean?  \n<SwipeableViews />\n  <div>Tab1</div>\n  <div>Tab2</div>\njust alone by itself like this, with the tab contents below it?\nIf say I expand a dropdown, the heightLatest stays fixed, but if I swipe it left and right the heightLatest correctly adjusts.  Why not just have the SwipableView adjust its heightLatest whenever a statechange occurs from a child of it (instead of only adjusting it after a left/right swipe). Not sure if this is correct new to react.\nCurrently I just set the whole tab content div to a fixed height, and that solves it somewhat, it leaves to much extra room though but that is better than a 200 height max.\n. ",
    "jgauthie": "Hi, having the same issue with height.\nI'm using SwipeableViews a lot, thx for your module by the way !\nThis problem happens a lot when you have dynamic content.\nFor example, a new chat message, if the conversation is in a swipeable block, won't appear automaticaly in this block if I don't force overflowY with a fixedHeight.\nIs it possible to force motionStyle over some conditions (height: 'auto' instead of calculatedHeight for example) for specifics swipeable content ?\n. ",
    "Gaubee": "@vans163  I have the same needs.\nwhen ChangeIndex , SwipeableViews recalculated height.\nTherefore, through this feature, you can do like this:\n``` js\nchangeTabIndex(index_value){\n      this.setState({\n          ...this.state,\n          index_value\n      });\n  }\n```\nhtml\n<SwipeableViews onChangeIndex={::this.changeTabIndex} index={this.state.index_value}>\n  <div onClick={()=>this.changeTabIndex(0)}>\n. ",
    "amangeot": "Hello,\nI am having the same issue dynamically loading a mosaic of images. \nThe page loads first, and then images. The problem is that the SwipeableViews is first loaded \"minimized\" and won't update its height after images have downloaded. So images are displayed in a small scrollable area. (Height is updated after you swipe)\nHas anybody solved this problem ? @vans163 ?\nI'd love to be able to use this module, it looks amazing!\n. ",
    "patotoma": "this should be labeled as bug and should be fixed\nuntil then as a workaround setting\nheight: auto;\nto wrapper element will do the trick\n. ",
    "Zetberg": "+1\nsame issue, I have tables with collapsed rows which expand on button click\n. ",
    "ecoquelin": "To be honnest, this is already far too old... I was testing react and some components like yours. Will revert back to you if starting again some work on this technology using your component.\n. ",
    "VilleMiekkoja": "No problem, thanks for you!\nBR,\nVille\nperjantai 4. maaliskuuta 2016 Olivier Tassinari notifications@github.com\nkirjoitti:\n\n@VilleMiekkoja https://github.com/VilleMiekkoja Thanks!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/oliviertassinari/react-swipeable-views/pull/39#issuecomment-192400282\n.\n. Yes, good idea so we only need to do it once.\n. \n",
    "alitaheri": "Wow :heart_eyes: \n. ",
    "brandonmp": "thanks @oliviertassinari \nin the mean time, if anyone else has this problem, here's my temp workaround:\noriginal code:\njsx\n<SwipeableViews>\n  <div1>\n    <input1 />\n    <input2 />\n  </div1>\n  <div2>\n    <input3 />\n  </div2>\n</SwipeableViews>\nwe do 2 things: assign a ref to the last input in a view, then setup a function handler to focus that component onBlur.  so:\njsx\n<SwipeableViews>\n  <div1>\n    <input1 />\n    <input2 \n        ref={(ref) => this.lastInput = ref}\n        onBlur={this.reFocus}        \n    />\n  </div1>\n  <div2>\n    <input3 />\n  </div2>\n</SwipeableViews>\nthen our event handler:\njs\n reFocus: function() {\n        this.lastInput.focus();\n    },\nETA: while this fix helps avoid the screen-hopping, it limits the ability for the user to focus on another field once they've entered input2.  after realizing this I removed this workaround, but leaving code b/c that limitation might be the lesser of 2 evils for some projects.\n. @andrzey yeah you're correct. shortly after i implemented that fix I realized that problem, so I ended up just going w/ a more traditional routing setup for my form pages. i'll edit that post to reflect the limitation--thanks!\n. ",
    "darioseidl": "We are also affected by this bug. Is there any news on it, or did anyone find a satisfactory workaround?  . Awesome, thank you! It's working as expected in 0.10.3 for us.. ",
    "nimahkh": "i still have this problem, my auto slider is half-way . \nmaterial-ui : 3.7.1\nlab : 3.0.0-alpha.16\n. <AutoPlaySwipeableViews\n                containerStyle={{height: 'auto', width: '20%'}}\n                onChangeIndex={this.changeIndex}\n                enableMouseEvents>\n                {items.map(item => (\n                    <div className={[classes.slide].join(\" \")} key={item.postId}>\n                        <img draggable={false} src={item.coverImage} className={classes.image}/>\n                        <Link to={`/tv/${item.postId}/${item.title.replace(/ /g, \"-\").replace(/\\//g, \"\")}`}>\n                            <Typography variant={'title'} className={classes.titleHead}>\n                                {item.title}\n                            </Typography>\n                        </Link>\n                    </div>\n                ))\n                }\n            </AutoPlaySwipeableViews>\n```\nchangeIndex = (index) => {\n        const {items} = this.props;\n        const remain = items.length % 5;\n    if (!Number.isNaN(index)) {\n        if (remain > 0) {\n            if (!Number.isNaN(index)) {\n                this.setState({index: index + 5 > items.length - 1 ? (items.length - 1) - index : index + 4})\n            }\n        }\n    }\n};\n\n```\n@oliviertassinari \nthis is my code and swipable views is 13, but index is NAN and error is showing in console. ",
    "sylvainbaronnet": "for prev/next maybe just an example in the doc ?\n. This is great ! Thank you \nI don't know if I miss something but (after upgrading) I just added autoplay={true} to my SwipeableViews component but there's no autoplay...\nEdit : \nif I do like in Demo7 : \n```\nimport autoPlay from '../../node_modules/react-swipeable-views/src/autoPlay';\nconst AutoPlaySwipeableViews = autoPlay(SwipeableViews);\n```\nIt works correctly\n. Thanks it works with code from Demo7\n. yes for me it doesn't make sense to assume the component is \"controlled\" since onChangeIndex is just an event. My guess is we can just remove the else and do the setState everytime.\nI'm not sure how (or if) you should detect the component is controlled, maybe an explicit method like stopAutoplay is enough. Thank you, can you publish a new version ?. ",
    "tomwalters": "On iOS changing the index wouldn't actually change the active slide for me, this code seems to resolve it\n. @oliviertassinari Happy to look at an animation for a new PR, just didn't want to bring in the 'animated' aspect for scroll?\n. @oliviertassinari Sounds good, I'll look at it this week and fire over a PR!\n. @oliviertassinari That's what I'd have thought, but for some reason it doesn't get updated unless the index is directly set. Happy to dig around a bit more and see if there's a better way, unless you have any thoughts?\n. Tested with that new addition and all appears to be working! Not entirely sure what was causing the issue previously.\n. Yep, check line 128\n. Yep good point, as it's already within the if. This is what you get for coding late in the day\ud83d\ude05\n. So in my case: I have infinite scroll implemented with slide 0 representing the last slide in my deck. When i get to it I want to jump to the end without animation \n. ",
    "juliengroch": "You know when this correction is available ?\n. oh ! great reactivity. Thx :)\n. ",
    "tushartuteja": "getting another error \nbundle.js:7644 Uncaught TypeError: Cannot read property '_currentElement' of null\nfirst time I get the error mentioned in the above comment and then the above mentioned error.\n. 0.5.1\n. ",
    "LunarSweeper": "I'm using 0.5.3 and have the same problem. I'm importing react-swipeable-views in NodeJS env with require:\nvar SwipeableViews = require('react-swipeable-views');\nThe content of SwipeableViews:\nObject {esModule: true}\n  __esModule: true\n  default: SwipeableViews(props)\n  __proto: Object\nI guess the component should export function SwipeableViews(props) and not the object.\n. Yep, thanks. Works like a charm.\n. ",
    "KevinHu2014": "@oliviertassinari How about Native?\n. ",
    "prashan9775": "Firefox version is 46 only.\n\n\n. ",
    "markgoodyear": "@oliviertassinari No problem, pushed that up. \ud83d\ude04 \n. ",
    "hannesj": "For those two versions to be equivalent, shouldn't this row be const indexStart = this.indexStart; instead of const indexStart = this.indexLatest;, as this.indexLatest is not initialized anywhere before. \nI'll try to do a small codepen of this tomorrow.\n. I think you would need to merge and release #237 in order to guarantee that the issue is fixed. Eg. yarn will not update dependencies unless specifically instructed. . ",
    "EvHaus": "Closing. This appears to be caused by inserting a <textarea /> element inside a swipeable view. Investigating more... This might be a React core bug.\nEDIT Turns out this was caused by the Grammarly Chrome extension...\n. ",
    "nabn": "I think @dbuarque is talking about NavigationExperimental\n. ",
    "vdrg": "We are going to use this for an e-reader, and the books can have hundreds of pages. I'll try to do it with the slides components, thanks!\n. ",
    "JisuPark": "Sure!\n. ",
    "tleish": "How would you sync the views so they slide simultaneously, rather than when the slider completes.\n. ",
    "darmie": "this gave a better UX\nimport SwipeableViews from 'react-swipeable-views/lib/index.native.scroll';\n. I can only explain it by showing you the video\nSee the difference\n\n. ",
    "pnakibar": "I got a workaround around this:\n``` jsx\n this.setState({ page: index })}\n\n\n```\n\nAnd then, whenever I need to reset the view, I call this.setState({ page: 0 }) and it's fine!\nPS: The initial state just contains { page: 0 }\n. ",
    "damianobarbati": "@oliviertassinari I just stumbled upon this but the Portal workaround works flawlessly \ud83e\udd19\ud83c\udffb\nFor anyone else stumbling on this, just wrap your absolute/fixed positioned element:\n```jsx\nimport Portal from 'material-ui/Portal';\n\n    ...my positioned element\n\n``\nI'm usingdocument.body` because I have a fixed element, watch out to use the correct container ref otherwise.. Oh ok, thanks for clarifying!. @chattes @brason this should help: https://github.com/oliviertassinari/react-swipeable-views/issues/124#issuecomment-356972288. ",
    "joeyparis": "I would like to add that the Portal component functionality used by Material-UI is a built-in ReactDOM feature if anyone is looking for a more barebones approach.\nhttps://reactjs.org/docs/portals.html\njs\nrender() {\n  // React does *not* create a new div. It renders the children into `domNode`.\n  // `domNode` is any valid DOM node, regardless of its location in the DOM.\n  return ReactDOM.createPortal(\n    this.props.children, // Whatever element you want rendered outside of the local transform coordinate-system\n    domNode // Any node outside of the local transform coordinate-system (e.g., document.body)\n  );\n}\n. ",
    "zhouyu11": "my scenario : I want to fixed a alert dialog to the html body , but we have\nused the transform3d in swipview container style,\nbut 'transform'  will renew the coordinate system , so the alert dialog\nwill fixed to swipeable-view container.\n[image: Inline image 1]\nSo I change it to this\nOn Thu, Aug 18, 2016 at 4:35 PM, Olivier Tassinari <notifications@github.com\n\nwrote:\n@zhouyu11 https://github.com/zhouyu11 I'm gonna close this issue as\nthere is no context regarding the actual issue solved.\nNote that the transform property is supposed to provide better performance\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/oliviertassinari/react-swipeable-views/pull/125#issuecomment-240659182,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AJYw-ZNMb8p4XmlQlMcfvhNq1HpD0i_Bks5qhBljgaJpZM4JgJJF\n.\n\n\nYu Zhou\nDeveloper\nEmail yuzhou@thoughtworks.com\nTelephone +86 1 <+86+18200277051>7090072590\n[image: ThoughtWorks]\nhttp://www.thoughtworks.com/?utm_campaign=yu-zhou-signature&utm_medium=email&utm_source=thoughtworks-email-signature-generator\n. ",
    "delta-9": "After lookout inside checkIndexBound.js, It seems you use import warning from 'warning';\nbut you don't specify this in dependency in package.json, I open a pull request.\nDoing npm i --save warning fix the problem\n. Should be Ok now\n. Yeah you right, I do that\n. ",
    "zetura": "I find a way to do it, but on the actual version available on npm.\nI moved the index variables over the preventDefault, and changed the preventDefault for stopPropagation, and I return if the index is over the indexMax or under 0.\nI had to change for stopPropagation because the preventDefault stops completely the touch move event on the parent at the start.\n``` js\nvar indexMax = _react.Children.count(_this.props.children) - 1;\n  var index = _this.state.indexLatest + (_this.startX - touch.pageX) / _this.startWidth;\n\n  if((index < 0 || index > indexMax)) {\n    return;\n  }\n\n  // Prevent native scrolling\n  event.stopPropagation();\n\n```\n. @oliviertassinari I can do that, yes, but since your code changed a lot since the last npm version. I'm not sure it would work the same way.\n. ",
    "pbellon": "Hi there, I'm having the same issue but I don't see where I could customize SwipeableViews to have this behavior. Let me show with a schema (A and B are SwipeableViews): \n\nThe issue is to be able to swipe in A when we arrive at the last slide of B. However the only way to do that is to swipe outside B. \n. This is more complicated than expected because the issue goes in both ways. B also needs to know if it can start to handle events (i.e when it is visible) otherwise even if we're not in the slide containing B, slides will change when a key is pressed. \n. That what I thought first but I didn't succeed from having the event being caught by parent SwipeableView (A). I tried to call event.preventDefault from the handleKeyDown function in bindKeyboard but it wasn't stopping propagation (stopPropagation didn't help either)\n. Thanks for the detailed answer. I will head toward option 1 :+1: \n. I've been able to implement option 1 :smiley: \nHowever the issue #131 is still not possible to fix with a similar method. When we reach the last slide of a nested swipeable view, swiping to next slide should trigger swipe in parent view (A). You can swipe in the parent view but you have to swipe outside of the child (B) view / container.. I've been able to reproduce it here but it only happens in one way: It works when I want to go on previous parent's slide (2.1 to 1) but not in the opposite direction (from 2.3 to 3).\n. Excellent :+1: \nThanks a lot!. ",
    "cinder92": "is not working, i'm receiving an error in version of react 15.2.1, i'm using react-native\n. after doing npm install --save react-swipeable-views react-motion, i'm getting this error\n```\nnpm WARN peerDependencies The peer dependency react-dom@^15.0.0 || ^0.14.0 included from react-swipeable-views will no\nnpm WARN peerDependencies longer be automatically installed to fulfill the peerDependency \nnpm WARN peerDependencies in npm 3+. Your application will need to depend on it explicitly.\nnpm WARN peerDependencies The peer dependency react@^15.3.1 included from react-dom will no\nnpm WARN peerDependencies longer be automatically installed to fulfill the peerDependency \nnpm WARN peerDependencies in npm 3+. Your application will need to depend on it explicitly.\nnpm ERR! Darwin 15.4.0\nnpm ERR! argv \"/usr/local/bin/node\" \"/usr/local/bin/npm\" \"install\" \"--save\" \"react-swipeable-views\" \"react-motion\"\nnpm ERR! node v4.4.4\nnpm ERR! npm  v2.15.1\nnpm ERR! code EPEERINVALID\nnpm ERR! peerinvalid The package react@15.2.1 does not satisfy its siblings' peerDependencies requirements!\nnpm ERR! peerinvalid Peer react-native@0.31.0 wants react@~15.2.1\nnpm ERR! peerinvalid Peer react-redux@4.4.5 wants react@^0.14.0 || ^15.0.0-0\nnpm ERR! peerinvalid Peer react-dom@15.3.1 wants react@^15.3.1\nnpm ERR! peerinvalid Peer react-motion@0.4.4 wants react@>=0.13.2 || ^0.14 || ^15.0.0\nnpm ERR! peerinvalid Peer react-swipeable-views@0.7.1 wants react@^15.0.0 || ^0.14.0\nnpm ERR! Please include the following file with any support request:\nnpm ERR!     /Users/dantecervantes/Documents/react-native/MiDiocesis/npm-debug.log\niMac-de-Dante:MiDiocesis dantecervantes$ \n```\nthis is my package.json\n```\n{\n  \"name\": \"MiDiocesis\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"node node_modules/react-native/local-cli/cli.js start\"\n  },\n  \"dependencies\": {\n    \"moment\": \"^2.13.0\",\n    \"react\": \"15.2.1\",\n    \"react-native\": \"0.31.0\",\n    \"react-native-vector-icons\": \"^2.0.3\",\n    \"react-redux\": \"^4.4.5\",\n    \"redux\": \"^3.5.2\",\n    \"redux-thunk\": \"^2.1.0\"\n  }\n}\n```\n. ",
    "jasan-s": "sorry, I got it working . silly question. \n. Thanks, missed it. Wasn't passing in anything to the handle change. \n. @oliviertassinari  thanks for the link. I used the demo as an example,and made an attempt , but there is still a problem, My first (top) nested  slideContainerX in List A doesnt  register vertical swipe up, thus I can't switch to List B view. It only registers the swipe on the area that is not taken up by slideContainerX.  However the slideContainerXB in List B does register a swipe down no matter what size I make the slideContainerXB, so I can switch to List A view.  Is there something I'm doing wrong, or is this a library limitation?  : \nthe code:\nconst styles = {\n  slide: {\n    padding: 15,\n    minHeight: '80vh',\n    minWidth: '94vw',\n    color: '#fff',\n  },\n  slideContainerY: {\n    height: '80vh',\n    minWidth: '94vw',\n    color: '#fff',\n  },\n  slideContainerX: {\n    backgroundColor: 'tomato',\n    height: '72vh',\n    minWidth: '50vw',\n    color: '#fff',\n  },  \nslideContainerXB: {\n    backgroundColor: 'tomato',\n    height: '72vh',\n    minWidth: '50vw',\n    color: '#fff',\n  },\n  slide1: {\n    backgroundColor: '#FEA900',\n    height: '80vh',\n    color: '#fff',\n  },\n  slide1A: {\n    backgroundColor: 'green',\n    height: '50%',\n    width: '100%',\n    color: '#fff',\n  },\n  slide1B: {\n    backgroundColor: 'blue',\n    height: '50%',\n    width: '100%'\n  },\n  slide2: {\n    backgroundColor: '#B3DC4A',\n    height: '80vh',\n    color: '#fff',\n  }\n}\n      <SwipeableViews axis=\"y\" containerStyle={styles.slideContainerY}>\n        <div style={Object.assign({}, styles.slide1)}>\n          LIST A\n        <SwipeableViews axis=\"x\" containerStyle={styles.slideContainerX}>\n        <div style={Object.assign({}, styles.slide1A)}>\n         LIST A item 1\n        </div>\n        <div style={Object.assign({}, styles.slide1B)}>\n          LIST A item 2\n        </div>\n        <div style={Object.assign({}, styles.slide1B)}>\n          LIST A item 3\n        </div>\n      </SwipeableViews>\n        </div>\n        <div style={Object.assign({}, styles.slide2)}>\n          LAST B\n      <SwipeableViews axis=\"x\" containerStyle={styles.slideContainerXB}>\n        <div style={Object.assign({}, styles.slide1A)}>\n         LIST B item 1\n        </div>\n        <div style={Object.assign({}, styles.slide1B)}>\n          LIST B item 2\n        </div>\n        <div style={Object.assign({}, styles.slide1B)}>\n          LIST B item 3\n        </div>\n      </SwipeableViews>\n        </div>\n      </SwipeableViews>\n. My component was rendering with null in a conditional case. . ",
    "xialvjun": "@oliviertassinari , you didn't see it? In this webpackbin, the AutoPlaySwipeableViews didn't autoplay.\n. @gaearon how about the name defer which is more general than hidden?\njsx\n<div>\n  {list.map((item, index) => (\n    <div key={item.id} defer={index !== current_index}>{item.content}</div>\n  ))}\n</div>. ",
    "bikashsharmabks": "@oliviertassinari Thanks for the reply... \nThe issue is with swipe transition being laggy - when I swipe the slider view, the event onChangeIndex is called which calls the function introSlider() there I have  logic written to toggle the slider dots (causing a re-render of view)  which makes the slider bit laggy and the transition from left - right not so smooth as compared to if we don't have the onChangeIndex callback\n. ",
    "ashl1": "This is more complex problem.\nThe current solution in ed190a6 breaks possibility to use maxHeight CSS-attribute for slides container.\nFor example, it breaks the code:\n``` html\n<SwipeableViews\n  animateHeight={true}\n  containerStyle={{\n    maxHeight: 80,\n  }}\n\n\n    Content for the height greater than 80px\n  \n\n    Small text\n  \n\n```\n\nThe idea that we should enable overflowY: hidden on the start of animation and return previous overflowY value after animation will be finished. And this is what not simple for me.\n. Yes, You are right.\nWhat about to create addition <div> wrapper to slide? I tried in Chrome inline editing for that:\nhtml\n<div style=\"max-height: 80px; transform: translate(...) ...\">\n  <div style=\"width: 100%; flex-shrink: 0; overflow-x: auto; overflow-y: hidden;\">\n    <div style=\"overflow-y: auto; height: 100%;\">\n      <div>\n        User slide content\n      </div>\n    </div>\n  </div>\n</div>\nAnd change updateHeight to something:\njs\nupdateHeight(node) {\nif (node !== null) {\n  const child = node.children[0].children[0];\n  if (child !== undefined && child.offsetHeight !== undefined &&\n    this.state.heightLatest !== child.offsetHeight) {\n    this.setState({\n      heightLatest: child.offsetHeight,\n    });\n  }\n}\n}\nThe idea that first div wrapper handle the whole user content in according of max-height and add scrollbar if needed. The second div wrapper used in animation and shouldn't show changed scroll bars at all.\n. And what about compatibility with axis?\n. I'm talking about not simple behavior in which I need in the future.\nWhy you don't like my proposal?\n. Sorry, I don't really now about that overhead. Could you please refer me to the measurements?\nI only see two variants (theoretically possible): make this with JS or give the browser ability to do it job - manage the visual to meet declared properties.\nI will open a PR in 5 days...\n. I'll try it test it tommorow or at last - next day.\n. @oliviertassinari You are right! That's solves the problem.\nThink I open PR to add this case to Examples\n. I'm agree with @oliviertassinari \nIt is possible to do with existing API. Your options just repeat existing features.\nJust try to make the formula of the calculation. And it might be static as well.\n. Sorry, I didn't see your proposal. Why don't I add new demo? Think it's good point to compare two cases.\n. I agree with you about simplicity, but think that is hard to find out this sokution from the demos, especially with no description said about this. It will be better to add \"this slide with max-height\" at the start of last slide.\n. Could you add this to not open small PR?\n. Hmmm... Looks like the same source of the question as I mention in #159 \nCurrently we has one more problem with nested swipeable-views which I will describe in next issue. Did you try to use ref and ref.updateHieght()?. This's really strange because I cannot reproduce the problem on simple model. Will go deeper.. Hmmm... If the slide isn't changed the height changes relative to its context.\nAlso, I've been found this.context.swipeableViews.slideUpdateHeight() method which might help to force update the height, am I right?\nAnyway I can't see the problem when use autoHeight prop and dynamically changed content if content don't contain animated transition itself.\n@stfny222 Could you provide an example of the problem?\n@oliviertassinari The real problem I mentioned #344 happens if the slide content changes with animation (so the activeSlide.offsetHeight changes every frame). The only solution I can see is set new height manually from outside the SwipeableView.\nCan I make a PR for the changes? Could you @oliviertassinari look at it?. ",
    "janhartmann": "Nevermind! I did not see containerStyle could be passed! Closing....\n. Adding a dev dependency on \"babel-runtime\": \"^6.11.6\"  of course solves this issue, but it probably should be addressed ;-)\nI, by the way, absolutely love this library.\n. Great stuff, fits me fine! :-) Thanks a lot!\n. Ah, yes. True - it works then. \nBut it appears the slide transition (x-axis) is not performed? See: http://www.webpackbin.com/4klWr8QTb\n. Great! You rock! :-) \nThanks - I might have another issue, but I'll just test it though before creating a new one. Thanks alot!\n. Awesome! I really appreciate your work! The library is fantastic! :-)\n. Beautiful! :-) Thanks a lot! \nI'll let you know if I run into other small issues.\n. On my onMouseEnter event I set an component autoplay property to false but the slide transition after the interval is done. And then its stopped.\n. ",
    "mflores-verys": "@oliviertassinari is there any way to pass styles for the child of the container that receives containerStyle? I'd like to override overflow. \nEdit: that is the slide container, and can be override with the slideStyle prop.. ",
    "igorbt": "OMG, sorry, I didn't saw the update! I was using 0.7.2 :). Thanks! I will close the issue then.\n. @oliviertassinari, It would be great to keep smooth animations and fixing this issue., but I'm afraid that this would require quite a rework of the current solution. Do you think you have the time to do this?\n. I tried overscanSlideCount before thinking of anything else, but unfortunately it didn't help for this specific use-case of continuously and fast swiping back the slides. The issue is happening after few more swipes, and that's not really helpful.\nI will try to add an unit test for this behavior. Actually I tried to do this from the beginning, but didn't quite understood at first glance how the things works there. But I will try more.\n. I agree, @oliviertassinari, that's not good solution for the problem, it's at most a workaround. I'm not using it anymore myself. Actually, I'm not using virtualize at all because of this bug. I hope you or someone else will have the time to work on the proper solution, maybe the one you mentioned above.. index > 0 checks if there are more slides to display to the left. Maybe that's unnecessary, but I'm double checking.\n. ",
    "Ftornik": "You're right, we can do this simple example with padding. But there is one big problem (as for my project).\nI know width of slide and margin between them from photoshop. And I need to calculate root padding, based on slide width and margins. It is not very easy as for me.\n. ",
    "tomkel": "Here's a gif of what happens. Because I'm only swiping once, it should navigate to the second div. After swiping, it shows in the react dev tools that the currentIndex state of SwipeableViews is 1, which confirms that it is treating all 3 divs as one index.\n\n. Because that was in the source code for the demo. \nAnyway, changing it to something else like height: 100 doesn't have any effect.\n. ",
    "romainwn": "I know it is a closed issue, but what if the expected result is the following : if we swipe once, then it treats only one div ?\nI'm trying to do the exact same thing, except I want to deal div per div, and not the 3 at the same time. ",
    "leMaik": "Indeed, the order does matter, but it seems strange to me.\n. @oliviertassinari Glad that this behavior is at least documented now. :+1: \n. The right usage doesn't work for me, though. :confused: I'll keep it \"wrong\" until the right usage works. :smile: \nAfter pressing the right arrow key, the slide is missing and the console is flooded with Warning: react-swipeable-view: the new index: NaN is out of bounds: [0-0].\n. Oh, my bad. Updating to 0.7.7 fixed it.\n. To reproduce this, just visit http://oliviertassinari.github.io/react-swipeable-views/ and add direction: rtl to the body. It looks fine at first, but try swiping to a different tab.. @oliviertassinari Is there a way to only set the direction for the root element and apply the inherited direction to the slides so that it wouldn't be required to re-specify the direction?. ",
    "galki": "Sure. Please check http://www.webpackbin.com/4ye_XPSTb\nNotice the white space within the border.\nOn Wed, Sep 28, 2016 at 8:27 PM, Olivier Tassinari <notifications@github.com\n\nwrote:\nCould you provide a reproduction test case?\nIf you are targeting the browser environment, you can use this playground:\nhttp://www.webpackbin.com/V10kOcV6-.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/oliviertassinari/react-swipeable-views/issues/160#issuecomment-250140983,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AHgHbYuk6pJ0zRwMx9aeKGWJ0Gk4Ihsfks5quk8lgaJpZM4KIkDE\n.\n. Thanks.\n\nOn Thu, Sep 29, 2016 at 4:32 PM, Olivier Tassinari <notifications@github.com\n\nwrote:\nThanks, that makes much more sense. Well, that's the expexted default\nbehavior.\nThat's linked to the implementation approach used.\nYou have two way to solve it.\n1. You can set a fix height with the styles properties.\nYou can have a look at the demo source code.\n2. You can use the animateHeight property. Again, have a look at the\ndemos.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/oliviertassinari/react-swipeable-views/issues/160#issuecomment-250392326,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AHgHbV2vmVQ9LLQHYh0X2qlVnvq2ZqQjks5qu2magaJpZM4KIkDE\n.\n. It was an unrelated css issue. Sorry for that.\n. \n",
    "nasredin": "same for me 0.7.9, ipad not scrolling 0.7.8 is ok\n. ",
    "simonwatt": "It makes sense that you don't want to work on something with such low usage, however I think the documentation is inaccurate (and should be updated) as it shows that Edge is supported when it's not actually responding to touch gestures.. ",
    "michaellopez": "@oliviertassinari Thanks to you too, glad I could be of help. Looking at your improved test I see what you were referring to in my original PR, makes perfect sense. \ud83d\udc4d \n. @oliviertassinari Yes, I can see that. But virtualize augments <SwipeableViews/>, does it not? I can still define onChangeIndex for a virtualize HOC and it will still work just not like the documentation says due to this issue.\nMaybe this is a documentation issue then, if this is your desired behavior. I was expecting to receive the indexLatest as per the documentation in my virtualize HOC anyway. I can work around it by looking at this.state.index because that would hold the same info, right? \n. ",
    "ChengGC": "I also need\n. ",
    "zhouzhongyuan": "@oliviertassinari  Sorry, I think I didin't say it clearly.\nI have only three items: 1, 2, 3 . I use the autoPlay.\nWhat I want :  it plays like 1 -> 2 -> 3 -> 1 -> 2 -> 3 -> 1 -> 2 -> \u2026\u2026\nThe importance : when in \"3\", how can go to \"1\"?\n                            (BUT Now, when in  \"3\", I only can go back to \"2\")\nWhat I want is  just like a bootstrap carousel\n\n. @oliviertassinari  Thanks.\n. ",
    "vincentsels": "Thanks for the quick response and implementation!\nUnfortunately I realize now that this alone doesn't solve the intended problem. When using a virtual component, the slideRenderer will still be triggered by onChangeIndex - and it's this that uses the cpu and causes the long frames during the animation. Additionally, having the component's internal state change at onChangeIndex-time and then changing application state at onTransitionEnd time causes very weird behavior.\nMaybe a better approach would be some kind of switch instead, which toggles when the component's state should be changed and the callback should be called: on swipe end, or on transition end. For instance an optional boolean property changeIndexOnTransitionEnd.\n. Good point about being able to swipe fast, before animation ends. Hadn't thought about that at all :/.\nNot sure if I fully understand those two dimensions you refer to though.\nI suppose ideally we should render a configurable number of 'excess' views on animation end, and only render a view ad-hoc during an animation when it was not yet rendered but would appear inside the viewport.\nAlternatively, you could work with some sort of placeholder which gets displayed for unrendered views in the viewport, and always only start actually rendering them on animation end. This seems like a really big change though.\n. @steezeburger: No - I had to switch back to onChangeIndex.. ",
    "abuddiga": "Sorry @oliviertassinari should have included that originally. We are using the following:\n\"react-swipeable-views\": \"0.7.10\",\n\"react-swipeable\": \"3.1.0\",\n\"react\": \"0.14.8\",\n\"react-motion\": \"0.4.5\"\n. ",
    "steezeburger": "@vincentsels curious if you ever got any type of solution working.\nI have the exact same use case and have tried all kinds of crazy stuff like grabbing prop values from  my swipeable components, setting slideIndex on my component (not in state because updating state in slideRenderer causes issues), and using that in onTransitionEnd to grab the current card by index and use the cards data-prop to grab my currentCategory then calling a redux action in onTransitionEnd, but the indices don't seem to be lining up properly.. I was able to get this to work with your exact setup, and I sort of got it to work by passing in my pre-made views (React components), but I get some errors because the keys are not unique (the keys are built somewhere else when I create my views). I was able to get the slides working, but they are not actually circular. \nI tried many things to add the key from slideRenderer to my returned views, including React.cloneElement (which was very non performant). Do you have any ideas here?\nI also noticed that it simply doesn't work if I don't include the slideCount prop on my virtualize HOC. I don't fully understand what slideCount does. Can you elaborate on this?\nEdit: actually, even following this example exactly, there are times where it will not allow me to continue the scrolling the views. There are no errors or anything, so I'm not exactly sure where the error lies. Have you seen this happening since you've been working on the infinite swipe?\nEdit2: can styles affect this? I guess if some element are overlapping the touch stuff could get screwy. This example works well when I removed my styles.\n. Doh, index property works. Forgive me, I thought I had scoured the documentation.\nAs for the second part, it does not seem to be working this way. The parent does in fact update, but the slides do not get rerendered (nor does slideRenderer get called).. Closing this till I do more research into my rendering issue, but wanted to say thanks for this great library and for your quick replies to issues!. ",
    "Bobgy": "Got into the same problem. I did something similar to @steezeburger has described, as setting a slideIndex on my own component, and managed to get it working mostly fine with some minor issues, but I don't yet have time to tidy up the code and share it. just FYI that's feasible.\nedit: add some context of my use-case, I have a tab that shows current index. If I change index at onTouchEnd, the tab has to re-render and it's slow enough to cause a jank on the transition animation.\nso instead, I want the index change happening at transition end, so that the re-render would happen when no animation is going on. That makes the jank not noticeable.. @oliviertassinari Can I get some explanations?. @gaearon I'm happy to hear that, it will make this implementation a lot simpler.\nJust curious about some details.\nI think a common tricky case is that:\n1. a component with some heavy invisible children is rendered and has an onMount animation\n2. invisible children rendered asynchronously, but still right after, then it could cause a jank because that's slow\nIs the new first-class API able to handle that (particularly, mount heavy invisible children at the correct timing without causing jank)? just guessing probably with some requestIdleCallback magic?. There seems to be a network error when installing dependencies on circle ci. Can someone with write access retry it?. @oliviertassinari I checked your new changes. They really made this more readable. Awesome work!\nThank you for the follow-up fix.. ",
    "norpisdev": "Thanks for the quick reply. I would much rather see the height of the container get updated than dealing with a overflow auto scrollbar :/\n. ",
    "torte": "Having the same problem. I basically load the content of each container in the list of swipable containers, after the swipable views has been rendered the first time. If the animateHeight property is set to true the first views does not render correctly. I tried to hack this and set the animateHeight to false the first time I load the component and then change it to true once I do the first swipe, but this results in weird jumps on the page once I set the property to true. Hope this can be fixed soon. Thx.\n. :+1: \nAssuming that this is related to isFirstRender state in the SwipeableView component and how it is used. The problem we are facing is that this will not render all views when doing server-side rendering. We should be able to overwrite that behavior somehow.. Our primary reason is SEO as you already guessed. We could work around this not using SwipeableViews when on server-side, but then we need add custom code just for this. . ",
    "DaveSpivey": "This isn't ideal, but I used a callback for any event affecting the height to call forceUpdate() on the component that renders SwipeableViews. Made even hackier by the fact I had to put it in a setTimeout so it would wait for a child's height transition to complete before re-rendering and recalculating height. Works, but makes me a little sad.. ",
    "Nopik": "I was pretty happy with this component, but since I discovered this issue, it is a show-stopper and I'll have to find some alternative ;(. Yeah, trying to, actually ;) In my case force refreshing the whole container should work. If the container would expose some callback, I can call it to, after my content changes. Not ideal, but will do the job.\nheightLatest is already in the state, and there is updateHeight method, though its argument makes it extremely hard to use from client code. It should be easy to expose more convenient method to the client, as you know all the nodes (can remember array of refs, not doing that at the moment) and index of currently selected node. So, argumentless updateHeight should be quite easily possible.\nThen, client should call that after content change, and it theoretically should work, if I didn't overlooked something.\nAlso, having such method available in context would be great, too, so there would be no need to remember refs on client side and pass update callback through possible large number of prop layers.\nAnd indeed, when I did a quick and dirty new function (which would have height as a single argument and setState it to heightLatest), exposed it via context and called from child deep in the hierarchy, the height nicely animated to the correct value. Interestingly, even if I provided too high value, like 2000, the container height updated to the correct value (565 in my test case). I guess, extra update was there.\nAdding it in a proper way (not requiring a height as an argument, but having an array of refs & taking the height of the correct one), would solve the problem for me.. So, for now, taking an advantage that there is extra update in meantime, I modified my function to set latest height to zero, and being argumentless. So, it is easy to call from client code, and the resulting effect on screen is exactly what I want.\nThat should definitely be improved later on to cleaner version & proper algorithm described above, but for now it does the trick. I'll try to fork and issue PR for it - as the change is additive, it wont break any existing code, but for those in need it will be a help.. Issued https://github.com/oliviertassinari/react-swipeable-views/pull/279. Btw. it seems that setting height to 0 will actually animate it from current height to zero, then to the desired height. Setting it to currentHeight + 1 gets rid of that effect.. Closed by #280 . Yeah, seems essentially the same. I'm OK with this.. I'll try that on my app when I'll have a chance, but I expect it will work better than my crude solution so dar.. Just tested it against my app, it works fine, as expected. Looking forward to see that on npm ;). ",
    "kimown": "@oliviertassinari Awesome, loop mode is a common function in slide component, thanks. \n. Thank you!   :+1:\nBut I have a question: why can't we reuse the existing instance of  AutoPlaySwipeableViews, and only add an argument, like loop:true/false config to determine we use circular slides or not.\n. @oliviertassinari  I am sorry for disturbing you again, but I don't know how to find the real reason of the problem, I have tried many solution I can found from Internet, like \ncss\n-webkit-backface-visibility: hidden;\nthey did works, but the flicker still exists, not frequently, but I want to remove the flicker completely like other browsers, can you give me some suggestions or advice, thanks in advance.. ",
    "yoadsn": "I think I can shine some light on this.\nWhen swiping to the left (for example) very fast, you could swipe fast enough that onTransitionEnd has no chance to be called and so setWindow is not called either.\nIn that case if you reach the last rendered slide, for some reason (I'm not sure yet) rendering is not taking place for additional slides.\nYou have to slide right, wait for the transition to end, and then start swiping left again.\nI would speculate it has something to do with this change:\nhttps://github.com/oliviertassinari/react-swipeable-views/commit/c34e5dd4488a3c7600583f5187f45281d60bb93f\ncould be related to #204 \n. I'm considering the usage of react-swipeable-views for a new component - Should this be a concern? Does it reproduce on every use case of this library when rendered on safari? (Assuming safari support is important and mandatory for me)\nIs there any simple workaround?. @oliviertassinari See my comments on the https://github.com/chenglou/react-motion/issues/404 issue you opened. This might provide an insight of the problem.. @oliviertassinari I only crafted the example bin around your initial bin demonstrating the problem. I did not see react-swipeable-views' code back then and now I know you based that off a simpler version of this library. It proved this solves the problem.\nIt is clearly a hack, since you would like to manage the translate animation over the entire container butTransitionMotion wants to know your children to take into account their entering/leaving for animation window persistence.\nTechnically speaking, we could recreate the logic of TransitionMotion directly on top of Motion and in that case react-swipeable-views would have to keep around the dom elements of \"removed\" slides until their animation is done. I would think that is the best way to go.. Might go for a PR but I am not sure would have enough time to create the required tests to prove no regression bugs are intoduced.\npruning the first render seems even more error prone.. this heavily relies on the existing behavior of react-motion and the specific use case.\nHow does animated solve this problem? renders the immediate transition with the state change?\n. After reviewing the PR I would not call re-implementing DOM level css transitions \"quite simple\" but you seem to know what your doing here.. Thank you!. In the meanwhile and for readers of this problem, as @oliviertassinari suggested on #152 using a bigger overscanSlideCount at the moment would make it harder to \"reach the last slide\" within the animation time and so would reduce the probability of this problem to occur.. @oliviertassinari Reading the suggestion, which makes sense but also is a big effort. I wonder, if just to overcome this bug there could be a workaround. After all, if the onTransitionEnd callback would have been called the setWindow would resolve the problem.\n(I assume it is not called since I do that one last swipe which is considered by react-swipeable-views to be a \"display same slide\" case which disables the motion)\nIs it too ugly to create a timer which is scheduled upon every index change and cleared when onTransitionEnd is called or when another index change is invoked - and if this timer is gets to fire (after a delay which is say 1.5X the animation delay) we can use that to just do a setWindow that would \"add\" the missing slides.\nI think it's OK to arrive at an end, and \"add\" the missing slides after some time.. this would give the impression of lazy loading to the user and may even be more elegant then actually trying to have slides coming in from the left no matter the speed and distance of swipe..\nIt's a naaive suggestion but I would take that without thinking twice over the existing behavior.. > I feel like adding an overscanSlideCountLeft property would be the simplest fix\nWith some grief, I tend to agree.\nThe next best thing is absolute positioning - I will dive deeper into \"react-virtualized\" to see how it's implemented there.. Awesome. Thank you.\nDo you have any plans rolling out a release?. ",
    "wysj": "You can ues  'autoPlay(virtualize(SwipeableViews))' this way to solve you problem.. thanks\uff01. ",
    "Asthonishia": "@oliviertassinari Any possibility to completly disable touch swipe ? ( PS : your demo link is KO now ). ",
    "JCofman": "@kimown I had to make this library to work on IE 10 there is an easy workaround which works for me you basically have to add the special IE 10 flexbox classes to the container ( I made a pull request for that #334  )\n.react-swipeable-view-container {\n        display: -ms-flexbox;\n      }\n .react-swipeable-view-container > div {\n          -ms-flex-negative: 0;\n      }. ",
    "knipferrc": "Any updates on this?\n. accident. ",
    "RByers": "As for the warning from Chrome: sorry for the trouble, this is a breaking change in Chrome 56 to improve scroll performance.  There's probably a missing touch-action CSS rule, which is necessary to support touch on IE/Edge anyway.. Interesting.  touch-action takes effect just before the touchstart listener is invoked.  So you can change it dynamically between gestures, but not once a gesture has started (the whole point is that we don't want to wait for JavaScript to decide whether scroll can start).  Is that good enough for your case, or do you want to make the decision based on something that has happened after the user's finger has contacted the screen?  I.e. what's the distinguishing factor between a swipe and a scroll?\n. > Chrome defers making a decision on whether a gesture should cause scrolling until the first touchmove event is dispatched. At that point, it looks at the direction of movement and compares it against the settings in the touch-action style as recorded prior to touchstart being dispatched\nThis is all accurate.\n\nIf the direction changes after this (e.g. the first movement is horizontal and is then followed by vertical movements) the style is checked again, and this check uses the current version.\n\nIf this is true it's a bug (and probably not interoperable with Edge, or something that'll remain reliable in Chrome as we make more performance optimizations).  Looking at the style is done only here in TouchEventManager::UpdateTouchAttributeMapsForPointerDown which is invoked only before dispatching touchstart. Can you provide a repro?\n/cc @dtapuska @flackr. ",
    "jh3141": "@oliviertassinari - my testing of dynamically changing touch-action is that it's more complex and subtle than as described in @RByers' comment above.  AFAICT, Chrome defers making a decision on whether a gesture should cause scrolling until the first touchmove event is dispatched.  At that point, it looks at the direction of movement and compares it against the settings in the touch-action style as recorded prior to touchstart being dispatched.  If the direction changes after this (e.g. the first movement is horizontal and is then followed by vertical movements) the style is checked again, and this check uses the current version.. ",
    "NgKhanh": "I'm sorry, I edited image link https://drive.google.com/file/d/0B340TdZgUeBFM1ltTmJyVjFZQXc/view?usp=sharing\nI mean how to config to show 2 items, 3 items or 2 + 2/3 items on display container . ",
    "antsav": "really need a nested swipable view on y axis inside line of x views\nlike so: \n|   1   |   2   |   3  |\n        |   2a  |\n        |   2b  |\nright now if I put \njsx\n<SwipeableViews>\n   <div id='1' />\n   <SwipeableViews axis='y'>\n      <div id='2' />\n      <div id='2a' />\n      <div id='2b' />\n   </SwipeableViews>\n   <div id='3' />\n</SwipeableViews>\nit's kind of makes what i want and on position 2 vertical slide is present, but all children are stacked in first vertical slide and bottom 2 slides are just blank. \nany walk around to solve this ? . ",
    "moussasarr": "Perfect. Thanks for your fast response.\n. ",
    "abelovic": "@oliviertassinari - I just put together a more complex sample and can't reproduce it either :( There must be something else going on in my app that is not obvious. If I do find an issue with this component (it is awesome btw) I will let you know.\nhttp://www.webpackbin.com/EynCRTIZf\nPS I have never used webpackbin before - its very cool!\n. ",
    "jarandmi": "Yeah, maybe. But i cant get it to work like i want it to.\njavascript\ngoToSlide = (index) => {\n        let oldTabIndex = this.props.registerTab;\n        if(index < oldTabIndex){\n            this.props.changeRegisterTab(index)\n        }\n        else {\n            this.props.changeRegisterTab(oldTabIndex)\n        }\n    }\nchangeRegisterTab updates the redux store and the store gets the right tabIndex, but it still slides to the next and prev slide.\nThis is my component\n``` javascript\n<SwipeableViews\n   children={ FormInputs }\n   slideStyle={ slideStyle }\n   containerStyle={{ height: \"100%\" }}\n   resistance={ true }\n   className=\"list\"\n   index={ this.props.registerTab }\n   onChangeIndex={ this.goToSlide }\n\n```\n\nBut i got your example to work when i use local state and the state callback. Can you see why my example isn't working?\n. Ah, its because of the async callback from setState(). I got it to work with setTimeout\n``` javascript\ngoToSlide = (index) => {\n        let oldTabIndex = this.props.registerTab;\n        this.props.changeRegisterTab(index)\n    setTimeout(() => {\n        if(index < oldTabIndex){\n            this.props.changeRegisterTab(oldTabIndex)\n        }\n    }, 1)\n}\n\n```\n. ",
    "vomchik": "I have the same problem with HOC virtualize. \n\n. Why it happen only in Safari? How can explain this?. @oliviertassinari  did you know how fix this?. ",
    "nareshbhatia": "Hopefully you can fix it soon. I am running into an issue with the library and I thought that the best way to replicate it might be to modify the demo.. Ok will do. Thanks.. ",
    "DennisBecker": "Can you also release a new version which supports react-tap-event-plugin v2.0.1 ?. Sorry, my fault, I have mixed my browser tabs, I wanted to open a new issue for that.. ",
    "dnecklesportfolio": "It doesn't? \nLet me back up a bit, currently the way it works if i am in row A and I swiped down 4 cards, then i swipe to the right, i would see the 4th card of the next row( row B ). Right?\nI want to change that so you see the first card in row B. This would require not moving the whole grid and just the row down... does that help.. @emanuelsetitinger Thanks for the webpackbin, Your example was close, but not it.  i will make a demo. . @oliviertassinari If i wanted a custom version of the component how much do you charge per hour to development. I realize that you don't understand my initial ask so I will make a demo to explain... Actually, I just noticed that my issue is similar to #204, (instead of moving on the x axis, my project appears in both axis a checkerboard grid. I will look at the suggestion you gave him and see if it works for me.. And I will also create a code sample. I guess you can close it for now.. ",
    "emanuelsetitinger": "Since I've already encountered the same behavior, I'm also interested in ideas on this. Please find the following reproduction test case on webpackbin:\nhttp://www.webpackbin.com/VyDZsfMMf \n(EDIT: If the webpackbin above doesn't work, please try this one:\nhttp://www.webpackbin.com/NkCs5FQMM)\nReproduction steps:\n1) scroll down to the bottom of the first slide\n2) switch to slide 2\n3) you end up well below the content of slide 2\nIs it possible to end up at the top of slide 2 after switching?\n@dnecklesportfolio I hope I didn't misunderstand your question.\n. Thank you for the answer! I fully agree that the options you pointed out are superior to changing the lib. This helped me a lot!. ",
    "just-boris": "Exactly the same as @giladbr said:\n\nis there any chance this component would be adjusted to support \"swiping\" with the mouse on desktop?\n\nHammer.js will emit consistent events for you, so you don't need to worry about differences in platforms. Mouse drags on desktop will be converted into touch events as well. Also, I believe that issues like #164 will also be fixed, but it needs more precise check. Done.. @oliviertassinari could you make a new realease, please?\nCurrently, I depend on my fork to have this feature.. ",
    "j6k4m8": "I think I agree with this \u2014 the benefit of using a standardized library like hammer I think outweighs the weight of the library. (Hammer is pretty well-vetted, too \u2014 so no possibility of it disappearing or changing API dramatically!)\nRight now I'm trying to find workarounds to get this library to work with mouse-events. Having native hammer support would be awesome.. ",
    "wub": "Can anyone link me to an example of a well-known site that uses mouse-swiping on desktop? I feel like this is only a nice feature for devs who want to test out the features. Swiping with the mouse on desktop isn't (in my view) a common pattern at all.\nIf you really want to test it, you can turn on mobile mode in dev tools.\nIf it solves a raft of mobile bugs, then that's great. Naturally you'd want to be aware of filesize implications.. ",
    "mikehobi": "Take a look at the virtualize example:\nhttps://github.com/oliviertassinari/react-swipeable-views#example-with-virtualize. ",
    "mschipperheyn": "You use react-native and react as direct dependencies which means they get downloaded in the react-swipeable-views node_modules folder. This can lead to problems, and in my case is. What you should do is remove these from the dependency list, since they are already in the environment. \nReact-native for instance references react as a \"peerDependency\", not as a \"dependency\"\nI came across this referencing: \nhttps://facebook.github.io/react/warnings/refs-must-have-owner.html\nI then ran yarn list react (npm ls react) and found react-swipeable-views). Well, I first got errors with react-native complaining about duplicate modules. I then removed the react-native library that existed in react-swipeable-views/node_modules folder. That solved that. . ",
    "emaillenin": "@oliviertassinari material-ui/docs is using react-swipeable-views (https://github.com/callemall/material-ui/blob/master/docs/package.json). So the naming conflict will occur when you run material-ui/docs in react native. This is the error:\nError building DependencyGraph:\n Error: Naming collision detected: /Users/lenin.rajasekaran/codebases/material-ui/docs/node_modules/react-swipeable-views/node_modules/react-native/Libraries/Renderer/src/renderers/shared/stack/event/eventPlugins/TouchHistoryMath.js collides with /Users/lenin.rajasekaran/codebases/material-ui/docs/node_modules/react-native/Libraries/vendor/react/browser/eventPlugins/TouchHistoryMath.js\n    at HasteMap._updateHasteMap (/Users/lenin.rajasekaran/codebases/material-ui/docs/node_modules/react-native/packager/react-packager/src/DependencyResolver/DependencyGraph/HasteMap.js:123:13)\n    at /Users/lenin.rajasekaran/codebases/material-ui/docs/node_modules/react-native/packager/react-packager/src/DependencyResolver/DependencyGraph/HasteMap.js:94:28\n    at tryCallOne (/Users/lenin.rajasekaran/codebases/material-ui/docs/node_modules/react-native/node_modules/promise/lib/core.js:37:12)\n    at /Users/lenin.rajasekaran/codebases/material-ui/docs/node_modules/react-native/node_modules/promise/lib/core.js:123:15\n    at flush (/Users/lenin.rajasekaran/codebases/material-ui/docs/node_modules/react-native/node_modules/promise/node_modules/asap/raw.js:50:29)\n    at nextTickCallbackWith0Args (node.js:420:9)\n    at process._tickCallback (node.js:349:13)\nSimilar issues - https://github.com/d-a-n/react-native-webbrowser/issues/2#issuecomment-246318298. ",
    "quadsurf": "@mschipperheyn i tried doing as you suggested, with:\n\"engine\": {\n    \"react\": \"15.3.1\",\n    \"react-native\": \"0.32.1\"\n  },\nbut get the following:\nnpm WARN react-native-orientation@1.17.0 requires a peer of react-native@>=0.5 but none was installed.\nnpm WARN react-native-popover@0.2.0 requires a peer of react-native@>=0.4.4 but none was installed.\n[and many other 3rd-party libraries that are peer dependent on react-native in node_modules]\nError: Cannot find module '.../node_modules/react-native/local-cli/cli.js'. ",
    "svanschooten": "I found the issue, it was a webpack issue (it still had a cached package with the same name...).\nThanks a lot for the fast response!. ",
    "habib786": "Still having this issue, can you guide me? . ",
    "yacut": "@habib786 please try to clear cache and reinstall npm packages:\nsh\nwatchman watch-del-all\nrm -rf ./node_modules\nrm -rf ~/.rncache\nyarn install. @oliviertassinari I kann contribute this project.... @oliviertassinari give me the admin rights please. I will lead the native version.. Thank you @oliviertassinari\nI will make a release this weekend.. I hope the issue can be closed. The new native version is published: https://www.npmjs.com/package/react-swipeable-views-native. ",
    "danmatlam": "Can I set a timer on autoplay?... Im using it, it\u00b4s awesome but still lookin for time setting.. ",
    "damusnet": "Hi @oliviertassinari \nSame here, I really like what you have done with this library and thank you very much for it.\nI have the same issue/requirement, and I have been through Demo 12, but I think my use case is slightly different. Demo 12 allows you to peek at the next slide, but you can still only have one slide per screen-width. Here is what I am trying to accomplish:\n\nThere are two issues in this scenario. The first one, is that it scrolls one \"screen-width\" for each swipe. So in effect, page 2 looks like this:\n\n...when really I wished to have \"slide n\u02da2\" on the far left edge of the screen after the first swipe.\nThe second issue is that since slides are shorter than the screen-width, there are a number of empty pages that the user can scroll through at the end.\nDo you see a way to accomplish that? If it's not already possible, would you be open to add that feature? I am happy to try and submit a pull request if you like the idea and with your guidance.. Scratch that! I was able to achieve what I thought was Issue n\u02da1. Here is my code for anyone trying to do the same:\njsx\n<SwipeableViews\n  style={{\n    paddingLeft: spacing.normal,\n    width: '40vw',\n    overflow: 'visible',\n  }}\n  slideStyle={{\n    paddingRight: spacing.normal,\n    paddingBottom: spacing.normal,\n    flex: 'none',\n  }}\n/>\nThe user can still scroll to what is essentially an empty page at the end, but that's less an issue I think.\nWhat a great library!. Not that I could find. We have the remaining space as well but decided it\nwas okay.\nOn Jul 31, 2017 3:14 AM, \"Kunal Arora\" notifications@github.com wrote:\n\n@damusnet https://github.com/damusnet Hey, is there any way to specify\nthe number of slides ?\nI implementing something like your recently viewed tabs, But the issue\nwith that is the last slide will have empty space in the right,\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/oliviertassinari/react-swipeable-views/issues/229#issuecomment-319026905,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAadAe1SbjsvZC4xtxMfWXWCJECxYg4yks5sTakJgaJpZM4Lc5ar\n.\n. Thank you Olivier, you're the best!. I have verified that it works fine now! Thanks again for a great addition, and for your reactivity!. \n",
    "florianbepunkt": "this might be related to the install instructions:\non github it reads npm install --save react-swipeable-views-native while on npm it reads npm install --save react-swipeable-views\nwhich one is correct? the former throws the error descrbibed above, the latter throws a different error when importing and using the component (see screenshot below)\n\n. @oliviertassinari Alright, thank you!. ",
    "hackingbeauty": "In the source code for DemoSimple, minHeight is 100 which sets a value of 100px for min-height on the swipeable view.\nHowever, I need the swipeable view to have a height of 100%, the full height of the container.\nIs there another demo that demonstrates how to do this?. ",
    "stevewillard": "Ran into this issue too. Is there a version that I can downgrade to, which react-swipeable-views works in Firefox?. Thank you!. I'm also trying to use the onChangeIndex but it is not firing when I programmatically change the index.. ",
    "seleckis": "The problem is, that on iPhone swipe animation is a bit twitchy when animateHeight is set. So I'm looking for solution for this issue.. Do you mean to add disabled={true}, then add swiping event and handle it? In this case I need to use another library. But as I see, swiping in swipeable views works very well and I just don't want to use another library for this. That would be great to have an ability to just disable dragging, but onSwitching could work as it works right now. E.g. prop disableDragging could be the best solution.\nTo be more clear please check this video. This is what I need to implement.\nhttps://streamable.com/s/2e3ax/segobi. ",
    "robrkerr": "I just realised I can set the container styles manually (using the containerStyle prop) as a workaround which is nice. . Thanks for the quick response! And good suggestions. So I'll put it behind an option that is off by default. \nAnd regarding your second point: are you worried that touch events on mobile will be triggering by touch and mouse events (and therefore calling these functions twice)? If that's what you meant, I can look into that and see if there's a nice way to avoid that. . Ok, so I've moved this feature behind a flag 'enableMouseEvents' so that it is disabled by default. However, I'd be inclined to have it enabled by default so that you get the same behaviour on mobile and desktop - don't you think that would be what people would tend to expect?\nI've also added separate callbacks for the mouse events and made sure that only the appropriate callback is triggered for the different events. I've called it 'onMouseDrag' instead of 'onMouseMove' because it is only gets triggered while the user is holding down on the mouse button (dragging) - consistent with the 'onTouchMove' behaviour. . I found an issue with the mouse leaving the swipeable region and subsequent 'mouseup' events being missed. I've implemented one solution to this: end the mouse drag action when this happens (see commit above). \nAnother option would be to try and catch the 'mouseup' events regardless of where the mouse ends up. I think this solution is fine but let me know what you think. . Just realised I should have been using the enhanced event listener - fixed this now. . @oliviertassinari: Thanks again for your feedback! I think I've fixed up everything you were concerned about - please let me know if I haven't. \nI've also renamed the original 'handleTouchStart', 'handleTouchMove', and 'handleTouchEnd' functions (which can now be target by either touch or mouse events) to 'handleSwipeStart', 'handleSwipe', and 'handleSwipeEnd'. What do you think of these names? Maybe 'handleSwipe' would be better as 'handleSwipeMove'?\nIs there anything else you think needs fixing / changing?. I was getting a react warning about modifying a shared event otherwise. This stopped the warning from appearing but maybe there is a better way. . In my case, I had an image in the panel that has a default drag behaviour. This was to prevent that from happening. . Sure. I guess these 'onTouch/Mouse' handlers don't need to be remove here because they will simply get overwritten right? . ",
    "frieman": "Hi,\nI'm still getting the:\n\"Unable to preventDefault inside passive event listener due to target being treated as passive.\"\nWhat i should do in order to resolve it?\nThanks.. ",
    "toddtarsi": "Haha, I aim to break things \ud83d\ude1b! Thanks for the merge and the quick feedback!. ",
    "sstubbs": "I can confirm I get the same issue.. I have tried adding axis={'x-reverse'} with direction rtl and it still seems to be broken.. I get similar behaviour with axis={\"y\"} and axis={\"y-reverse\"} even with direction set to ltr. It seems to show them all on first slide then nothing on the next two. I wonder if this is related.. I confirm setting the direction of the root to ltr and the slides to rtl works.. ",
    "scoot1585": "thanks for the quick fix! appreciate it. ",
    "RonjaO": "I'm sorry that I get back to this subject only now. \nScreen readers read a web pages usually one DOM element at a time and tell information about the elements. I tested the listbox role with the most popular screen readers: NVDA and Jaws in Windows, and VoiceOver in iOS and OS X. My results are that the listbox role doesn't work in this case. If we have this role in a div element that is not really a listbox (an element that creates a list from which a user may select one or more items) none of the screen readers that I tested work right with it.\nMy test code was about following:\n<div role=\"listbox\">\n<h2>Heading</h2>\n<p>Text</p>\n</div>\nNVDA says only \"listbox\" and none of the texts inside the element.\nJaws says all the text of the listbox element like it's a single sentence, and tells that it is listbox (in my test case: \"Heading Text, listbox\").\nOS X VoiceOver says \"listbox\" and a user must go to \"inside\", so that VO says the elements (heading and text) inside the element with listbox role.\niOS VoiceOver says \"list start\" on the first element inside of the listbox and \"list end\" on the last element (in my test case: \"Heading, heading level 2, list start. Text, list end\").\nI'm happy that you have deleted the roles in your code. :) Now the svipeable view component are greatly more accessible for screen reader users.\nI don't understand why Boostrap uses the listbox role in this way.... ",
    "klouskingsley": "thanks a lot. ",
    "jmheik": "This PR still needs some work as shown by this test case. Scrolling doesn't work in last slide in either horizontal or vertical case.. PR is updated to handle all scenarios found in my test cases. The last slide issue was caused by using page indices in findNativeHandler as it doesn't grow after last slide. Using pageX and startX worked for this in all my tests. I also moved native scroll detection after we are likely swiping/scrolling as doing detection first showed to be too sensitive in the nested test case.. Thanks! I'll test it out, and file separate issues if other things noticed in the original PR are still valid.. ",
    "artsx": "Yes it's a good idea, I had not thought it was only for touchscreens.\nIt would be appreciable also to have a props which allows to add the dots automatically also :P\nThanks for your quick return !\nNice plugin !. ",
    "America-first-melon": "Where is the demo9 of the sample diagram?. @oliviertassinari  I didn't find this on demo folder.\n\n. @oliviertassinari  No, i used the native example of the home page. And i want to achieve vertical slide on the native. Just in time saw the issues.. ",
    "rehnarama": "I submitted a pull request for this issue. If anyone need a quick fix for this issue I published this fix at https://www.npmjs.com/package/react-swipeable-views-iss258. ",
    "rakesh5987": "Hi,\nThanks for Quick reply.\nI think you did not get my issue.\nMy issue is If I am on 5th slide. I have a button that should move me to first slide. But I am unable to find such method to move to first slide using that button.\nPlease provide me a solution so I can use to move to first slide from any other slide.\n. ",
    "bvaughn": "\nActually, we could implement a scroll control of the component without react-virtualized, then integrating react-virtualized to provide the same feature as the virtualize() Higher-order component.\n\nI made an animator wrapper component that you might be interested in a month or so ago because someone asked how they might do it. It's here if you'd be interested. Could probably be improved upon. \ud83d\ude04\nI would love to see a carousel built on top of react-virtualized. If you're interested in trying it, and I could be of any help, I'd be happy to!. Agreed \ud83d\ude04 . ",
    "wayofthefuture": "Haven't tried that. I will take a look. Why not just put a component in between the Swipeable component and the View with a prop called \"shouldRender\" or something, then use componentWillReceiveProps to trigger a render. The component that sits in between can render a blank page (total views - 1, blank pages). On index change can change the prop, then set a timeout equal to the slide time ms in componentWillReceiveProps, triggering a render at the end of the slide, and it should work right?. ",
    "ofirpeer": "Sorry i had a mistake in my question, I meant SlideStyle and not ContainerStyle.\nI want to use different SlideStyles for different slides, aka applying different to the div that wraps the slide (<div aria-hidden=\"false\" data-swipeable=\"true\"... ).\nIf it's not possible, is there a value i can send as a slide that won't render? (this relates to the second part of the question) \nEDIT:\nI solved my problem in some other way, but i still think that if a slide is null it shouldn't be rendered . Hey,\nSorry for late comment, but it might help @maximux13  .\nWhen i was struggling with the problem i tried to play with the source code and this change in the render function solved my problem:\nSending null as a view will return null.\nDidn't test it, so it might fail somewhere:\n```\n...\nreturn (\n       { this.rootNode = node; }}\n        style={Object.assign({}, axisProperties.root[axis], style)}\n        {...other}\n        {...touchEvents}\n        onScroll={this.handleScroll}\n      >\n         { this.containerNode = node; }}\n          style={Object.assign({}, containerStyle, styles.container, containerStyleProp)}\n          className=\"react-swipeable-view-container\"\n        >\n          {Children.map(children, (child, indexChild) => {\n      //CHANGE:\n   if(child == null){\n      return null;\n   }\n //CHANGE END\n\n        if (isFirstRender && indexChild > 0) {\n          return null;\n        }\n\n        let ref;\n        let hidden = true;\n        ...\n\n```\nJust wanted to share\n. ",
    "maximux13": "@oliviertassinari I'm using this library too and I have a similar issue, I have a modal that have 3 tabs but I want to hide the last slide if the object doesn't have nothing to show in that tab, but instead I get an empty slide. I think that in that case nothing should be rendered instead.. ",
    "AntonioRedondo": "I came across with the same issue.\nBasically if the child is null, undefined or not valid react-swipeable-views shouldn't render anything instead of rendering an empty <div> which becomes a blank swiping surface as it happens now.\nThis need is a common use case when the children you pass to react-swipeable-views are coming from iterating an array, and from some reason an array's position doesn't need to be rendered, then you return from that position null/undefined.\nWouldn't be a much time consuming task to make changes around L817 (plus updating tests) to return null when the child isn't valid?\nIf the changes are a more complex task then I think at least the ticket should be left opened. It looks like it's a feature with demand. It doesn't make much sense to render a blank swiping surface if a child is incorrect. With the warning in console is enough.. ",
    "cstrat": "Any examples on how we can best implement this?\nI've got a slide which contains a truncated list, with a button saying 'show more'... if they hit that then the slides height needs to update.. ",
    "BennyHoang": "Thank you @oliviertassinari . ",
    "nirlendu": "I've given it a try. It works on SSR. First Slide is lazy loaded and the rest are done after the component is mounted.. I can just say for my use case. I'm looking for SSR for a page, and it looks ugly if one slide appears first and the rest loads once the js files are loaded by the browser.. ",
    "wieseljonas": "Seems like calculations break with ssr when w add padding to the root look at my pagination dots\nWorking without SSR\n\nWith SSR\n\n```\nimport React from 'react';\nimport { css } from 'react-emotion';\nimport PaginationDot from './PaginationDot';\nimport SwipeableViews from 'react-swipeable-views';\nconst styles = {\n  root: {\n    width: '126px',\n    padding: '0px 54px',\n  },\n  slideContainer: {\n    width: '18px',\n    height: '18px',\n  },\n};\ntype Props = {\n  index: number,\n  slideCount: number,\n  onChangeIndex: (index: number) => void,\n};\nconst Pagination = ({ index, slideCount, onChangeIndex }: Props) => {\n  const children = [];\nfor (let i = 0; i < slideCount; i += 1) {\n    let moreState = false;\n    if (i === 5 && index < 3 && slideCount > 7) {\n      moreState = true;\n    } else if (\n      i === slideCount - 6 &&\n      index > slideCount - 4 &&\n      slideCount > 7\n    ) {\n      moreState = true;\n    } else if (\n      (i > 4 || i < slideCount - 5) &&\n      index > 2 &&\n      index < slideCount - 3 &&\n      (index === i + 3 || index === i - 3)\n    ) {\n      moreState = true;\n    }\nchildren.push(\n  <PaginationDot\n    key={i}\n    index={i}\n    active={i === index}\n    moreState={moreState}\n    onClick={(event, newIndex) => onChangeIndex(newIndex)}\n  />\n);\n\n}\nlet fixedIndex = index;\n  if (index < 2) {\n    fixedIndex = 2;\n  } else if (index > slideCount - 3) {\n    fixedIndex = slideCount - 3;\n  }\nreturn (\n    position: absolute;\n        display: flex;\n        justify-content: center;\n        bottom: 8px;\n        right: 8px;\n        left: 8px;}\n    >\n      \n        {children}\n      \n\n  );\n};\nexport default Pagination;\n```. Was an issue with border-box\nadd to make sure the container add these styles\n* {\n    box-sizing: border-box;\n}. ",
    "LucasKA": "@oliviertassinari I guess there's nothing wrong with a state based solution, as much as responsively knowing which one is the last index.\nhttps://gist.github.com/LucasKA/4a6558a00c7ca70f38c502d72d936963\n. ",
    "christianeide": "What I want to do is to be able to swipe on a parent container, and then reveal/swipe inn a child container over the parentcontainer.\n\nI can think of two ways to do this: \n1. Let the parent be child nr 1 and then be able to not swipe away the parentcontainer, only swipe the child over the top of the already existing parent. I couldnt find a way to do this?\n\nPlace the parent in its own < SwipeableViews> and use the swipe event to toggle the index state of the child between 0 and 1. Im currently doing the switch on the onTransitionEnd. This works, but it will toggle between 0 and 1 on all swipeevents in all directions, not just the way you swipe. So it doesnt feel like a native swipe.\n\n```jsx\nhandleShowEkstraData() {\n    this.setState({swipeIndex: 1 - this.state.swipeIndex}); //Toggles between the states\n  }\nrender() {\n    return (\n      \n\n\n\n          <SwipeableViews \n          index={this.state.swipeIndex} \n          onChangeIndex={this.handleShowEkstraData} >\n                <div></div>\n                <div className=\"fane\" onClick={this.handleShowEkstraData}>Sidetest</div>\n          </SwipeableViews> \n  </div>\n  )\n\n}\n```\nAny suggestions is appreciated! . Take a look at this quick video i made: https://youtu.be/G_GL9h-Uzqo\nIm swiping the grey div (className=\"fane\") over MyComponent. So MyComponent triggers the swipe in of the grey div, but doesent move it self. This works, but as you can see from the video, I can swipe in all directions to trigger change. Now I just toggle the animation in and out regardless of the direction you are swiping.\n. Hi again. Tried to nest two <SwipeableViews /> without any luck. In my test that would mean that the parent also would swipe, which I dont want. Do you have any other suggestions?. ",
    "MonsieurBlutbad": "That did it, thank you very much!. ",
    "license2e": "@oliviertassinari Just a heads up, this fix MAY have introduced a noticeable delay in the swipe functionality on mobile devices. I haven't tested builds comparing both, but intend to, and will let you know if this was the cause.... Based on my non-scientific tests, there is a perception that version 0.12.2 is a smoother swipe operation than version 0.12.3.\nI dont have the capacity at this moment to record a test of both and overlay them to tell the difference.... ",
    "AlanFoster": "Does this require a 0.12.3 release of react-swipeable-views-native to have this fix?. @oliviertassinari I've poked further into this -\nWhen providing an external previous/next button, and managing the index externally, the double navigation is only caused when the animateTransitions value is true:\njs\n      index={index}\n      slideRenderer={PageRenderer}\n      onChangeIndex={onChangeIndex}\n      animateTransitions={true}\nWhen animateTransitions is false and you click the previous/next buttons there is no bug present. I believe is is due to the the handleTransitionEnd callback which triggers an additional onChangeIndex event via setWindow.\nThis additional handleTransitionEnd callback is the same reason that there are multiple re-render requests are triggered when dragging/left right and pushing the new index into the component.\n\nOverall I'm not sure what the 'nicest' solution is \ud83e\udd14\nI think for the swiping mechanic we could only trigger the onChangeIndex callback once handleTransitionEnd has fired successfully and we are no longer animating. Currently if you swipe and let go, the onChange callback is immediately fired when you are 'halfway' between two screens. I've noticed that this can lead to some levels of jank if you are making additional requests for the newly requested pages etc. . ",
    "zhantx": "Hi there, I created a PR to fix this issue #306. Hi @oliviertassinari , I made the changes as requested, plz review it again :). ",
    "Nelo-cool": "addition to the above, application build with Cordova 6. ",
    "jkallunki": "I had the same issue but got it fixed in my project for now by using this:\nimport SwipeableViews from 'react-swipeable-views-native/lib/SwipeableViews.scroll';. ",
    "Ricardo-Marques": "Closing, didn't realize I wasn't on the newest version. Thanks for your work on this lib!. ",
    "MaxInMoon": "How to reproduce\n1 - Create a app with create-react-app\n2 - Add folowing code in App.js:\n```jsx\nimport React, { Component } from 'react';\nimport SwipeableViews from 'react-swipeable-views';\nimport './App.css';\nclass App extends Component {\nonSwipeableViewChanged = (e, value) => {\n    console.log(value);\n  }\nrender() {\n    return (\n      \n\nWelcome to React\n\n\n\n\n              View 1\n            \n\n              View 2\n            \n\n              View 3\n            \n\n\n\n    );\n  }\n}\nexport default App;\n3 - And padding to test easily:jsx\n.swipeableView {\n  padding: 6em 4em;\n}\n```. @oliviertassinari seems obvious now, sorry for my low discerning, thanks. ",
    "mxl": "I see, you use Lerna to publish multiple packages.. ",
    "dasblitz": "Ah the pull request was supposed to go into my own fork. I'm using bitbucket normally instead of github so I got confused by the interface. I'll close this one. Great library btw!. Mm the setup with Lerna actually makes it a bit harder than expected to just point to my fork in the package.json of the project I need react-swipeable-views for. \nIs it an option to actually merge the pull request in? (It adds two props to prevent forward/backward swiping). It might be to specific to our use case, so I'd understand if you prefer not to. Or if you like the functionality but prefer a different implementation I'd be happy to discuss :). Ah should have looked in closed issues first, my bad, I'll try the #179 solution. Tnx!. ",
    "tafelito": "Hi, quick question regarding this. What's the point of having a flag isFirstRender=!disableLazyLoading if on componentDidMount is then reseting it to false again? \nThis will prevent not to render the rest of the slides on the first render, but it will render them after the componentDIdMount change the isFirstRender to false. Is that how it's suppose to work? Am I missing something? . So it won't lazy load the other views, is that what you're saying? . ok I see \nThanks for the clarification. ",
    "chamini2": "What if we want to not render at all the others unless they are shown?. ",
    "Liqiankun": "@oliviertassinari Need your help! \ud83d\ude04. Thank you man! @oliviertassinari  I got it done!. @oliviertassinari Height is find now. When I scroll second view the first view's contentOffSize still change! \n\n. @oliviertassinari  Finally I fixed it! Thanks man!. I got another issue! @oliviertassinari \nthis is my code\n```\n           this.setState({ index })}\n          >\n            {categories.map((category, index) => {\n              return (\n                 this.props.loadMoreProducts('0')} showActionBar={index === 0} />\n              )\n            })}\n          \n//here is ProductTab\n        \n          {views}\n        \n```\nWhen I click first cell to the detail, then back. It shows well. \n\nAfter the fifth It shows this way. the Banner is hidden(banner is also using react-swipeable-views )After I scroll the view a little bit,it shows well again!\n\n. @oliviertassinari Thank you all the same!. ",
    "eugenehp": "@oliviertassinari I pushed something that worked for me in emulator. Let me know if you need further explanation on what I'm trying to do here.. @oliviertassinari here you go https://github.com/eugenehp/react-swipeable-views/commit/d1b5049a3cbe0bddef2eb7054e9ea37bb6121c54. ",
    "rizkiandrianto": "well, trying to reproduce your sample code will cause this too in my case.\nis the react version (or other depedencies) will affect this?. ",
    "orballo": "Actually, in that case yes, I could access that info from my redux state.\nBut when I do swipe directly from the component and I want to do the work after the transition, I can only get that info from onChangeIndex and that makes me duplicate the state.\nThe way I see it, correct me If I'm wrong, onTransitionEnd should have the same parameters that onChangeIndex has, so I can use one or the other when it better suits me.\nOr onChangeIndex should be triggered when I swipe via index prop, so I can work the same way I do when I swipe directly from the component.\nI know my solution is not great, but it helps if I have the latest index saved in my state, and I want to compare it with the current index I get from onTransitionEnd as if I was using onChangeIndex.\nI hope I've explained myself well.. ",
    "yohio": "Having the same warning as well. The issue is mostly because the situation is as follows:\nI have a reactive view that updates when something is changed, it's a list of items similar to a ToDo list.\nOnce I finish a task it updates the list cards and since the animate height is useful to me because each ToDo item has the 2nd swipe for details that has more content than the Title on the 1st.\nI need the min height to prevent the view from pushing users to the top when the entire list turns to 0 height and grows to the size of the card which also is very annoying flashing the view.\nI would say that this warning should be more of a \"console.info\" and I would think it is useful if one is to set a fixed height or max-height, min-height is not going to block the swipeable views from growing but it is going to set a base to which size it will grow from.\nWhile I agree that it could be misused and render the animated height useless, it is useful to others who need it not to have the warning as it might present a problem when deploying and having the app under review on the app/play stores.\nIs it possible to change the warning to be an info and to remove the min-height from the logic for it?\nThanks. Didn't work for me, everything still sizes up from a height of 0. ",
    "geooogle": "is it possible to remove this warning? . ",
    "imerkle": "@oliviertassinari  that pattern also works. ",
    "kunal-arora": "Okay, will check it.. Hey @oliviertassinari sorry for a late reply, doesn't seem to be working for me. I am trying to implement dynamic data slides using the normal swipeable-views component. . ```javascript\nrender() {\n        const categoriesProps = this.props.categories;\n        console.log(categoriesProps);\n        let categories = false;\n        let categoryProducts = false;\n        const currentCategoryTabIndex = this.props.currentCategoryTabIndex;\n    if (categoriesProps) {\n        categories = Object.keys(categoriesProps).map((category, val) => {\n            if (categoriesProps[category].name) {\n                return (\n                    <li key={`categoryList${categoriesProps[category].id};`}>\n                        <button \n                            key={`categoryBtn${categoriesProps[category].id};`}\n                            onClick={() => { this.handleClickOnCategory(categoriesProps[category].id, val); }}\n                        > \n                            { categoriesProps[category].name }\n                        </button>\n                    </li>\n                );\n            }\n            return null;\n        });\n    }\n\n    if (categoriesProps) {\n        categoryProducts = Object.keys(categoriesProps).map((category, val) => {\n            if (categoriesProps[currentCategoryTabIndex].categoryProductsData !== undefined && (val === currentCategoryTabIndex)) {\n                const categoryProductsDisplay = categoriesProps[currentCategoryTabIndex].categoryProductsData;\n                categoryProductsDisplay.map((products) => {\n                        console.log(products.sku);\n                    return (\n                        <div key={`categoryCont${categoriesProps[category].id};`}>\n                            <p key={`categoryName${categoriesProps[category].id};`} >{products.sku}</p>\n                        </div>\n                    );\n                });\n            }else {\n                return (\n                    <div key={`categoryNoCont${categoriesProps[category].id};`}>\n                        <p key={`categoryNoName${categoriesProps[category].id};`} >loading...</p>\n                    </div>\n                );\n            }\n        });\n    }\n\n    if (categories) {\n        return (\n            <div>\n                <ul>\n                    { categories }\n                </ul>\n                <SwipeableViews\n                    index={currentCategoryTabIndex}\n                    onChangeIndex={this.handleChangeIndex}\n                >\n                    {categoryProducts}\n                </SwipeableViews>\n            </div>\n        );\n    }\n    return null;\n}\n\n```\nThis is what my render function looks like without virtualize. The console shows the products sku's but for some reason they don't get displayed. I am a bit confused and I am not able to figure out what am I doing wrong here.. ",
    "storrisi": "Done! I'll post here the solution if you want. ",
    "PardeepWildnet": "@oliviertassinari  can you please provide the link for example where i can see expected result.\nThanks. As per this demo, I am able to set static height of content let's say its 100 in this case, but i want to set height as per content size not static. \nFor example content for tab1 is of 400px height and for tab2 its 50px\nso height should be 400px and 50px respectively not 400px for both.\nI hope you get my point.. RESOLVED !! closing this...\nJust need to bound \nanimateHeight = { this.state.customizeHeight }\nwith some variable and need to toggle their value to true on swipe and on Tab change, because if you set value of animateHeight = { true } this is causing issue for the first time.. ",
    "Schlesiger": "Thanks! The test I am attempting is more \"blackbox\" than the examples; I am avoiding .instance().\nHere's a rough example of what I am trying:\njs\nconst DrawerContent = ({\n  currentDrawer,\n  drawers,\n  onSwipe,\n}) => {\n  return (\n    <SwipeableViews\n      index={drawers[currentDrawer] ? currentDrawer : 0}\n      onChangeIndex={(index) => {\n        onSwipe(index);\n      }}\n    >\n      {\n        drawers.map((drawer) => {\n          return (\n            <div key={drawer.name}>\n              {drawer.name}\n            </div>\n          );\n        })\n      }\n    </SwipeableViews>\n  );\n};\n```js\ntest('Select 2nd tab', () => {\n  const whenDrawerSelect = jest.fn();\nconst content = shallow(\n    \n  );\ncontent.simulate(\n    'touchStart',\n    {touches: [{\n      pageX: 50,\n      pageY: 0,\n    }]}\n  );\n  content.simulate(\n    'touchEnd',\n    {touches: [{\n      pageX: 100,\n      pageY: 0,\n    }]}\n  );\nexpect(whenDrawerSelect).toBeCalledWith(1);\n});\n```\nHowever, the function whenDrawerSelect is never called. I have also tried content.child().simulate without effect. . Rats. I didn't know shallow would prevent this. I can't use mount in my case because I have nested components relying on HOC context. If start initializing HOC's, the test complexity goes way up and I may as well just run a full e2e test - exactly what I wanted to avoid. I was trying to improve coverage but perhaps this case isn't worth the effort.\nAs far as the react-swipeable-views project is concerned, I can't say whether broader e2e is required. My project has several \"touch\" libraries involved and I do think additional testing is valuable to ensure interoperability. I will be trying Nightwatch for \"full\" e2e testing. I can comment back here with working examples if you like.. If I may add to this; it would be nice to disable dragging in certain directions as well. Perhaps something like:\njs\ndisableDragging={'left'|'right'|true|false}\n...where true would be both and false neither.. ",
    "WalkerZhan": "I resolved the. ",
    "tOke3i": "it would be cool if  you add it because sometimes the amount of tabs can be more than 10 for example it looks not so good. Are you going to add functionality? Thank you for your answer! @oliviertassinari . ",
    "dmoli": "@oliviertassinari I use ^0.12.8 version, and this is the complete message error:\n\n. I solve this mount whit enzyme:\nimport { mount } from 'enzyme';\nconst wrapper = mount(<MyComponent />);\nThanks!. ",
    "ManuSevenval": "I got the exact same error message with the current version of react-swipeable-views.\nthe snippet by @oliviertassinari did not solve the issue for me.\nAre there any other hints I could try besides using enzyme's mount ? . ",
    "gratiaa": "I also had a similar problem.\nI was testing using storyshot from storybook.\nIn my case, shallow rendering from Enzyme also works well.. @oliviertassinari \nThank you for your reply \ud83d\ude38 didn't know the flag exists...\nBut in my storyshot testing code, i just use shallow rendering from enzyme\nand it worked well, no need to add disableLifecycleMethods flag.\nMy testing code is like this:\njs\ninitStoryshots({\n  test: ({ story, context }) => {\n    const storyElement = story.render(context)\n    const shallowTree = shallow(storyElement)\n    expect(toJson(shallowTree)).toMatchSnapshot()\n  },\n}). ",
    "Olivr3": "Thx! I missed this property in the docs. . ",
    "stfny222": "@ashl1 here's my problem. I have a list of comments, when more comments are loaded, the slide won't resize, it only does when I change tabs. Here's an example:\n\nAnd this is how my react DOM tree looks like:\n\nI'm gessing this happens since the content that changes is not a direct child from ReactSwipableView, but it's deeper in the tree because of the multiple apollo-client HOCs.\nI came to this conclusion since I tried with a much simpler example and it worked fine:\n\nThis is how the tree looks like here:\n\n\nMaybe we could be exposing a callback property close to the ref pattern to make it work\n\nI think the solution proposed by @oliviertassinari should work great. You're totally right. I added a callback property \"action\" based on the ref pattern, with a parameter \"actions\" that consists in an object containing all posible actions that could be triggered programmatically (in this case, only the updateHeight function was included).\nIt can be used like this:\n```jsx\n {\n    this.swipeableActions = actions;\n  }}\n\n{'slide n\u00b01'}\n{'slide n\u00b02'}\n{'slide n\u00b03'}\n\n```\n\nSo actions can be triggered later in your component like this:\njsx\nthis.swipeableActions.updateHeight(). @oliviertassinari can you take a look at this? :). ",
    "studentIvan": "@oliviertassinari is there something like CDN for react-swipeable-views to up it to jsfiddle for example?. Ok, I can't implement it using codesandbox, but I also solved it on my local project. If somebody will catch the problem, the solution is\n1. onComponentDidUpdate check that state index should be changed and change it on not full, e.g. 0.1 for 0 and 0.9 for 1\n2. onTransitionEnd\nonTransitionEnd={ () => { if (this.state.slideIndex % 1 !== 0) {\n  this.setState({ slideIndex: Math.round(this.state.slideIndex) });\n}}}. ",
    "platonish": "Hi, I tried using the virtualize HOC as explained in this demo: \n```javascript\nconst VirtualizedSwipeableViews = virtualize(SwipeableViews);\nconst slideRenderer = ({ index }) => (\n  {\n    0: ,\n    1: ,\n    2: \n  }[index]\n);\nclass HomeComponent extends React.Component {\n  constructor(props) {\n    super(props);\nthis.state = {\n  screen: 0\n};\n\n}\nhandleSwipe = value => {\n    this.setState({ screen: value });\n  };\nhandleBottomTabSelect = (event, value) => {\n    this.setState({ screen: value });\n  };\nrender() {\n    const { screen } = this.state;\nreturn (\n  <StyledHomeComponent>\n    <AppBar />\n    <VirtualizedSwipeableViews\n      index={screen}\n      onChangeIndex={this.handleSwipe}\n      className=\"content-wrapper\"\n      overscanSlideAfter={0}\n      slideRenderer={slideRenderer}\n    />\n    <BottomTabs value={screen} onChange={this.handleBottomTabSelect} />\n  </StyledHomeComponent>\n);\n\n}\n}\nThe second and third screens are lazy-loaded only once the user swipes left to them, so that works great. However the swipe animation goes back and forth once every time I swipe to a new screen. Here's a [screencap](https://youtu.be/08Sw434hShI). Thanks in advance!. I fixed this by adding a `key` prop to every element in `slideRender` (as clearly mentioned in the demo), like so:javascript\nconst slideRenderer = ({ index, key }) => {\n  return(\n    {\n      0: ,\n      1: ,\n      2: \n    }[index]\n);\n};\n``\nHowever I still get a warning on my console sayingWarning: react-swipeable-view: one of the children provided is invalid: null. We are expecting a valid React Element`. Also, swiping right from slide 0 tries to render slide -1, then slide -2, and so on. This is also the case in the demo: \n\nI'm currently doing the following to prevent this behaviour:\n-  added a prop overscanSlideBefore={1}\n- disabled touch events using the disabled prop\n- added one more case \"-1\": <div key={key} /> in slideRenderer(). ",
    "warrenmcquinn": "Ok, thank you for answering my question.. Okay, I just want vertical scrolling. I disabled resistance, and I still can't scroll vertically when on the first / last slides. \nThe logic seems pretty straightforward, and I think this feature would make this code the best available view component for React. . Perhaps I can explain better:\nI have a SwipeableView component with height 100vh. Once the user has the component fully in view, they should be able to leave if they swipe down while on the first slide, or swipe up while on the last side.\nThat makes sense, no?. ",
    "frendyguo": "I have no problem on mobile device, but on a desktop view (with mouse event), whenever the starting and ending position of my mouse events are still within the same element (with onclick event listener), it triggers the click event. > From what I understand, the mouse doesn't change enough to be considered a swipe, hence, we don't do anything.\nBut it did swiped, the only way to prevent the click is to swipe beyond it's container. Anyway, do you have any workaround for this ?. ",
    "hodgef": "I am having this issue as well. If you have an element with an onClick, swiping over this element will trigger the onClick, when it should not. This happens when mouse events are enabled (enableMouseEvents=\"true\").\nIt seems that enableMouseEvents is triggering all onClick, onMouseUp, onMouseDown, etc events on children elements on swipe.\nAny thoughts on this @oliviertassinari ?. ",
    "lsirivong": "Here's an alternative solution for anyone else coming across this.\nAttempting to detect a drag on the clickable element before preventing the click handler:\n```jsx\nclass SwipeableLink extends React.Component {\n  handleMouseDown = e => {\n    // store mouse position when click starts\n    this.x = e.screenX;\n  }\nhandleClick = e => {\n    const delta = Math.abs(e.screenX - this.x);\nif (delta > 10) {\n  // If mouse moved more than threshold, ignore the click event\n  e.preventDefault();\n}\n\nthis.x = 0;\n\n}\nrender() {\n    return (\n      \n        {this.props.children}\n      \n    );\n  }\n}\nfunction App() {\n  return (\n    \n      {[1, 2, 3].map(i => (\n        slide${i}])}>\n          \n            slide n\u00b0{i}\n          \n\n      ))}\n    \n  );\n}\n```\nhttps://codesandbox.io/s/4qyyo1j2mx\n. ",
    "bhar4t": "I am using  react-swipeable-views inside this I am using iFrame, when I want to swipe from iFrame view to another view which is not working.. ",
    "brason": "Why was this closed? I am wondering the same thing. . ",
    "mindnektar": "Could you provide an example on how to do this? Having a div like this within the SwipeableView does not work, swiping within it still triggers SwipeableView:\n```jsx\n { event.stopPropagation(); event.preventDefault(); }}\n    onTouchMove={(event) => { event.stopPropagation(); event.preventDefault(); }}\n\n[...]\n\n\n```. Thanks for your answer! My specific use-case is a slider within a swipeable view. I want to be able to  drag the slider handle using my finger without triggering any SwipeableViews handlers, so I tried wrapping my slider in a div that stops all touch event propagations. For some reason, this does not work, however. Because said slider is supposed to be part of the swipeable view, I cannot put it outside of it. The issue you pointed to seems to be dealing with mouse events, which I'm not handling at all.\n\nAnother thing: I noticed that the slider component itself is stopping touch event propagation. When I drag the slider handle, no touch events are propagated to my surrounding div--yet the SwipeableView is still doing its thing. Why would that be?. Gladly. Here's a very reduced example: https://codesandbox.io/s/8xp3pj6k7l. I understand, but I cannot do that because the slider component that is using these events is an external dependency.. ",
    "thientran1707": "@mindnektar do not use onTouchStart, onTouchMove and onTouchEnd, if you use addEventListener() then it will work. ",
    "roderickhsiao": "Thanks man! forget to check the mono repo :) . @slorber we are using for Tinder web (https://tinder.com)\nIts' on your own profile or the recs card (profile card you are swiping on :)) \n\n\n. unfortunately we are not using react native for the native app. And yes, Tinder web is a kind of a hidden product that is not widely known \ud83d\ude05. ",
    "retrojorgen": "I am having the same issue in my project. Actually the animation stops at the third slide (3/8 slides)\nAny solution to this?. So, I think I found the issue. its in getDisplaySameSlide.js in core. \nit says \nvar oldChildren = props.children[props.index]; But props.children[0] is where the list of items actually recides. so this will fail after the second slide. ",
    "Jianru-Lin": "This bug happens when you put this line inside render function:\nconst EnhancedSwipeableViews = virtualize(SwipeableViews)\nI made this mistake, and when I move it outside everything becomes fine.\n\ud83d\ude38 . ",
    "ikelee": "Did this work for you? It worked for me a couple times but its causing a crash as soon as I swipe. .   This is what I have, maybe it's requiring too much processing power? I don't really know why it's crashing\n. ",
    "Dmitry-N-Medvedev": "It could help a lot if the  onChangeIndex (index, prevIndex, meta) would expect a bool return which would tell the Swipeable if the index should be changed.\nImplementing this via messing with styles IMO is architecturally wrong.\nUse case:\n1. a DaysSwipeable that is passed an array of pre-rendered react components (days).\n2. a MonthSwipeable that is passed an array of pre-rendered react components (months).\nWhen a user swipes the MonthSwipeable, children of the DaysSwipeable get rerendered. Every time. Even though, the developer could pre-render all the 31 child for the DaysSwipeable and just control how far a user is allowed to swipe depending on the number of days in the month specified via the MonthSwipeable. In Feb the user would be able to swipe either to the 28th or the 29th. In the rest of the months it would be possible to swipe to either 30th or 31st. Without any re-rendering of the DaysSwipeable's children at all.\nPS: I personally believe that there should be one more event: onIndexChanging(index, prevIndex) for the sole purpose of deciding if the current index change should succeed or not.. ",
    "kwkau": "@oliviertassinari  thanks for the quick response sorry for not including my code in my earlier post.\ni hope you can resolve this issue for me.\nimport * as React from 'react';\nimport {Tabs, Tab} from 'material-ui/Tabs';\nimport SwipeableViews from 'react-swipeable-views';\nconst styles = {\n  headline: {\n    fontSize: 24,\n    paddingTop: 16,\n    marginBottom: 12,\n    fontWeight: 400,\n  },\n  slide: {\n    padding: 10,\n  },\n};\nexport class EmployeeSetup extends React.Component {\nconstructor() {\n    super();\n    this.state = {\n      slideIndex: 0,\n    };\n  }\nhandleChange = (value) => {\n    this.setState({\n      slideIndex: value,\n    });\n  };\nrender() {\n    return (\n      \n\n\n\n\n\n\n\n            Tab 1\n          \n\n            Tab 2\n          \n\n            Tab 3\n          \n\n\n    );\n  }\n}. ",
    "kmartinezmedia": "The onChangeIndex isn't working for me. Could it be this is why tabs are not updating when view is swiped?. ",
    "lotusms": "This update is genius, however, the height doesn't update when there are items hidden and shown on a toggling-view function.\naction={actions => {\n    this.swipeableActions = actions;\n  }}\nThe above adjusted the height so that it is isolated to the tab content, which it's outstanding! However, the updateHeight function only works when changing form tab to tab. \nHere is a picture of my tab loaded for the first time (no scrolling needed or showing. Before there was scrolling generated by anothe tab with lots of scrolling) This is good.\n\nThis is what happens when I change the option in the New Schedule dropdown and it shows a hidden are on the right that affects the height. (note the cut-off part under \"Every\")\n\nAnd this is how it looks after I change tabs and go back to this tab. It finally shows because the updateHeight fires and corrects the height. (interestingly enough, if I idle the tab for a while, it also corrects the height and shows the cut-off part)\n\nI updated to your last version 0.12.16, didn't fix it\nI also tried this.swipeableActions.updateHeight() in componentWillMount and the console reports that Cannot read property 'updateHeight' of undefined\nAnything on this? Thanks\n. ",
    "sorin-davidoi": "There were some which weren't pruned, but even with pruning it takes 10-15ms (Chrome, desktop) for React to run. It still janks on mobile.\nScreenshot from the dev tools while swiping (Chrome, desktop) - between 20 and 30 frame per second.\n\nCode running on each touchmove event:\n. We have five slides. I'll double check to make sure I didn't miss any pruning. If not, I'll see if I avoid setState.. Yes, I'd say it is still needed. I didn't miss any pruning and it still janks in Firefox on Android. Unfortunately, I don't know when I'll have time to attempt a proper fix - the small snippet I posted is not enough.. Thank you for looking into this!. ",
    "stropitek": "Thanks for taking the time to try it out.\nI was a bit confused at the beginning but then I realized I included the example in a project using preact (it uses webpack's resolve to replace imports from react to preact, therefore the misleading code snippet).\nHere is another example using preact: https://codesandbox.io/s/jmkrl2p29\nI don't know if you support preact... feel free to reopen this if you do. And sorry about the confusion!. ",
    "bmueller-sykes": "I'm actually seeing a similar issue. Not sure if I should open a new ticket or append to this one, so I'm going to try appending to this one for now.\nThe code below is running as the only React component inside my top-level App.js component. I'm running on top of create-react-app, React 15.6.2, react-swipeable-views 0.12.12, react-swipeable-views-utils 0.12.11, and material-ui 0.19.2. \nHere's the entirety of the code:\n```\nimport React, { Component } from 'react';\nimport MuiThemeProvider from 'material-ui/styles/MuiThemeProvider';\nimport { Tabs, Tab } from 'material-ui/Tabs';\nimport SwipeableViews from 'react-swipeable-views';\nimport { virtualize } from 'react-swipeable-views-utils';\nconst VirtualizeSwipeableViews = virtualize(SwipeableViews);\nclass Slide extends Component {\n  componentDidMount () {\n    console.log(\"MOUNT\", this.props.index)\n  }\ncomponentWillUnmount () {\n    console.log(\"UNMOUNT\", this.props.index)\n  }\n  render () {\n    return (\n      \n        Slide {this.props.index}\n      \n    )\n  }\n}\nconst slideRenderer = ({key, index}) => \nexport default class Swipe extends Component {\nconstructor(props) {\n    super(props)\n    this.state = {\n      slideIndex: 0\n    }\n  }\nhandleTabChange = (index) => {\n    this.setState({\n      slideIndex: index\n    })\n  }\nrender () {\n    const { slideIndex } = this.state;\nreturn (\n  <MuiThemeProvider>\n    <div>\n      <Tabs\n        onChange={this.handleTabChange}\n        value={slideIndex}\n      >\n        <Tab value={0} label='One' />\n        <Tab value={1} label='Two' />\n      </Tabs>\n      <VirtualizeSwipeableViews index={slideIndex} slideRenderer={slideRenderer} />\n    </div>\n  </MuiThemeProvider>\n)\n\n}\n}\n```\nWhen I run the code locally (localhost:3000) I see this:\nMOUNT 0\nMOUNT -3\nMOUNT -2\nMOUNT -1\nMOUNT 1\nMOUNT 2\n...and then when I switch, I see this in the console:\nMOUNT 3\nUNMOUNT -3\n...and switching back, I see\nUNMOUNT 3\nMOUNT -3\nSo that seems broken in two ways. First, I don't understand the multiple \"MOUNT\"s, and second, it seems odd that the indexes would be 3 and -3, rather than 0 and 1, (since random indices make it hard to line up with, say, an array of components to render). @oliviertassinari Thanks for the reply! I'm looking at the demos on this page:\nhttps://react-swipeable-views.com/demos/demos/\n...and I don't see where I'm missing the key. There already is one in the slideRenderer function (<Slide key={key} index={index} />). There wasn't one in my Slide component, but if I do add one to the render method:\nrender () {\n    return (\n      <div key={this.props.key}>\n        Slide {this.props.index}\n      </div>\n    )\n  }\n...I get the same behavior. In fact, if I add a console statement to the render method, I see that there are six initial renders with index values going from -3 to 2 (-3, -2, -1, 0, 1, 2). \nI'm probably missing something stupid, and if so, I apologize, but I can't see what I'm missing here.\nThanks!. Actually, quick update, I just realized that key isn't even passed down to my Slide component, so adding a key within that component's render function isn't even possible. So I'm still stumped. . Okay, again, sorry if I'm missing something simple, but something still looks broken to me. I've simplified the demo a bit, to get it more in line to your demos. Here's what I have now:\n```\nimport React, { Component } from 'react';\nimport MuiThemeProvider from 'material-ui/styles/MuiThemeProvider';\nimport { Tabs, Tab } from 'material-ui/Tabs';\nimport SwipeableViews from 'react-swipeable-views';\nimport { virtualize } from 'react-swipeable-views-utils';\nconst VirtualizeSwipeableViews = virtualize(SwipeableViews);\nconst slideRenderer = ({key, index}) => {\n  console.log(\"RENDER\", key, index)\n  return (\n    \n      Slide {index}\n    \n  )\n}\nexport default class Swipe extends Component {\nconstructor(props) {\n    super(props)\n    this.state = {\n      slideIndex: 0\n    }\n  }\nhandleTabChange = (index) => {\n    this.setState({\n      slideIndex: index\n    })\n  }\nrender () {\n    const { slideIndex } = this.state;\nreturn (\n  <MuiThemeProvider>\n    <div>\n      <Tabs\n        onChange={this.handleTabChange}\n        value={slideIndex}\n      >\n        <Tab value={0} label='One' />\n        <Tab value={1} label='Two' />\n      </Tabs>\n      <VirtualizeSwipeableViews\n        index={slideIndex}\n        onChangeIndex={this.handleTabChange}\n        slideRenderer={slideRenderer}\n      />\n    </div>\n  </MuiThemeProvider>\n)\n\n}\n}\n```\nWhen the component first loads, I get this in the console:\n\n...and then, when I click on the TWO tab, I get this in the console:\n\nI think I have all the key props in the right places, so I'm really struggling to see what's going on here. My simple example appears to be rendering properly, but if I put a React component in the slideRenderer function, then it's going to mount and unmount several times during slide changes.\n. Okay, please answer one more question? (-;\nSo if I change the body of slideRenderer to this:\nconst slideRenderer = ({key, index}) => <Slide key={key} index={index} />\n...and then have this:\n```\nclass Slide extends Component {\ncomponentDidMount() {\n    console.log(\"SLIDE MOUNT\")\n  }\ncomponentWillUnmount() {\n    console.log(\"SLIDE UNMOUNT\")\n  }\nrender () {\n    return (\n      Slide {this.props.index}\n    )\n  }\n}\n```\n...then I get 6 SLIDE MOUNT declarations when VirtualizeSwipeableViews first loads. Is that expected? That seems less than ideal, especially if there were side effects like a data fetch in componentDidMount().\nSwitching from one tab to another triggers only a single MOUNT and a single UNMOUNT, so that seems right.\nSorry to pester.. Oh, right! I'm so sorry! I get it now. Thanks so much for your patience.. ",
    "tanhauhau": "Can explain more about the glitches?. ",
    "razorxan": "can you explain me what do you mean by \"pure logic\" and guide me through the process?. ",
    "necolas": "Have you looked into implementing this package on top of the react native API (for web and native)? That provides APIs for RTL and more, as well as being where the (up-to-date) implementation of Animated lives. > What would be for me the best way to try out those two implementations with react-native-web?\nI'd probably start with whatever code is maintained, isolate any use of DOM APIs and then replace them with equivalent RN APIs. If some APIs can't be replaced, they can live in a separate .web.js file with a native equivalent in .native.js.\n\nI'm also wondering if we don't have the opportunity to build a cross-platform material design library\n\nYeah we previously discussed that here:\nhttps://github.com/mui-org/material-ui/issues/593\nAnd this is another attempt that could be made to work on web with RNW:\nhttps://github.com/callstack/react-native-paper\nI'm biased, but my experience building Twitter for Web makes me think all React components (for web or native) should now be implemented using the core RN APIs/Components. It provides many of the building blocks that component libraries end up trying to make themselves, but anything built on RN can easily interop with other things built on RN.. ",
    "yinsang": "WebkitOverflowScrolling: 'touch' may lead to iOS 11 broken. Wish you can have some ideas.. ",
    "alanbuchanan": "I missed that! My mistake.. ",
    "chrismowbray": "With further inspection it looks like the react-swipeable-views component is enforcing an min-width. ",
    "renaudtertrais": "Thanks for your response. The link I shared was just to show the explanation of @robdodson on the advantage of using <ul /> tag for list in general, not to compare the use case. If you take a look to W3C recommendations, it seems that even for \"Carousel\", <ul><li /></ul> is the good choice. It will help screen readers (an users) to know how many views are available.\nhttps://www.w3.org/WAI/tutorials/carousels/structure/\nWe could enable to change tags thought props or at least add roles:\n- parent div: role=\"list\"\n-  children: role=\"listitem\"\nWhat do you think ?. ",
    "robdodson": "That's an interesting proposal @renaudtertrais. I think there may need to be a bit more work to make the cards accessible. Currently when a card is offscreen is has aria-hidden applied to it, and there's no way to send a signal to the swiper that it should advance to the next card (at least, no instruction is conveyed to a screen reader). Before worrying about how a screen reader will announce a card, you'd first want to make the control keyboard operable. Once that's fixed, you could then explore how to make it convey the correct semantics to a screen reader.. ",
    "Klynger": "@oliviertassinari about this use case of showing multiple slides at once, is this a feature that you think is applicable here? If not, do you know any other library that has it implemented and works well with SSR? Thanks. ",
    "codecov[bot]": "Codecov Report\n\nMerging #402 into master will increase coverage by 0.19%.\nThe diff coverage is n/a.\n\n\n```diff\n@@            Coverage Diff             @@\nmaster     #402      +/-\n==========================================\n+ Coverage   89.96%   90.15%   +0.19%   \n==========================================\n  Files          18       17       -1   \n  Lines        1026      985      -41   \n==========================================\n- Hits          923      888      -35   \n+ Misses        103       97       -6\n```\n| Impacted Files | Coverage \u0394 | |\n|---|---|---|\n| ...ges/react-swipeable-views-core/src/computeIndex.js | 77.77% <0%> (-3.31%) | :arrow_down: |\n| ...react-swipeable-views-core/src/checkIndexBounds.js | 100% <0%> (\u00f8) | :arrow_up: |\n| packages/react-swipeable-views-core/src/mod.js | 100% <0%> (\u00f8) | :arrow_up: |\n| ...ackages/react-swipeable-views-core/src/constant.js | | |\n| ...ct-swipeable-views-core/src/getDisplaySameSlide.js | 100% <0%> (+15.78%) | :arrow_up: |\n\nContinue to review full report at Codecov.\n\nLegend - Click here to learn more\n\u0394 = absolute <relative> (impact), \u00f8 = not affected, ? = missing data\nPowered by Codecov. Last update 42e0270...ae086f4. Read the comment docs.\n. \n",
    "soroushm": "@oliviertassinari but why ? \ni try to remove \"SwipeableViews.js\" line 50 direction and working fine \nwhy we need somethings like that ?\nBR,. ",
    "slorber": "@roderickhsiao do you mean the web or RN version? where?. Thanks good to know\nI'm more looking for a RN carousel solution so was wondering if this lib RN code was used for the app version (which would have surprised me, does not look exactly the same). Didn't know tinder was available on web too. yes have seen that, and it's still working inside a snack correctly. ",
    "mrTuomoK": "@oliviertassinari Haven't had time to dig into this yet :/ I'll try to figure out which versions are the last working ones.... OK the last working version is apparently 0.12.10 (with *-utils on 0.12.11) so something breaks after that. Appears so. We might have something on it, but can't confirm yet.... will be back later on if it works @Sebruck . ",
    "Sebruck": "I have the same problem, any ideas how to fix it?. ",
    "liamqma": "Hey @mrTuomoK, I am having a similar issue. Do you have any work around?. ",
    "Tsymalyi": "I have the same problem.\nHow long wait for fix ? :)\n. ",
    "MatteoGioioso": "Same problem here. If you need any help or tell me where to look, I could help you on this. Thanks. @oliviertassinari if you could add the property would be great.. ",
    "LaurentRos": "Hi @dola !\nDid you find a solution to your problem ? How did you do it ?\nI'm facing the same problem here =/. ",
    "gazpachu": "I'm also facing the same issue. ",
    "fssantos": "Guys, one way I found was adding onTouchStart={(e) => {e.stopPropagation()}} as a div props nested in the SwipeableView. It solved my problem but right now I'm getting a Chrome warning:\n\n[Intervention] Ignored attempt to cancel a touchmove event with cancelable=false, for example because scrolling is in progress and cannot be interrupted.\n\nIt's fired when SwipeableViews.js tries to make a event.preventDefault() as show below probably because it's not the best approach to solve the problem.\n// We are swiping, let's prevent the scroll event.\n      event.preventDefault();\nActually I can't understand why SwipeableViews is receiving the event since the stopPropagation for me means a real stop propagation.\nAny ideas or other approachs?. ",
    "Ephys": "\nI can't understand why SwipeableViews is receiving the event since the stopPropagation for me means a real stop propagation.\n\nI have the same issue. I think it's because react-swipeable-views uses the native DOM event handlers instead of react's synthetic events.\nMy solution was to do the same:\n```javascript\nclass MyComponentWhichMustBlockTouchEventsSoItsContentIsScrollableAgain extends React.Component {\n  container = React.createRef();\ncomponentDidMount() {\n    const containerNode = this.container.current;\nif (!containerNode) {\n  return;\n}\n\ncontainerNode.addEventListener('touchstart', this.isolateTouch, { passive: true });\ncontainerNode.addEventListener('touchmove', this.isolateTouch, { passive: true });\ncontainerNode.addEventListener('touchend', this.isolateTouch, { passive: true });\n\n}\ncomponentWillUnmount() {\n    const containerNode = this.container.current;\nif (!containerNode) {\n  return;\n}\n\ncontainerNode.removeEventListener('touchstart', this.isolateTouch, { passive: true });\ncontainerNode.removeEventListener('touchmove', this.isolateTouch, { passive: true });\ncontainerNode.removeEventListener('touchend', this.isolateTouch, { passive: true });\n\n}\nisolateTouch(e) {\n    e.stopPropagation();\n  }\nrender() {\n    return (\n      \n        {this.props.children}\n      \n    );\n  }\n}\n```\n. ",
    "phumaster": "@Ephys Thanks, you saved my life.. ",
    "dominhhai610": "@Dmitry-N-Medvedev\nThere is my custom component with:\nA = B = 150px\nMain = 375px\n```\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport styled from 'styled-components';\nimport classNames from 'classnames';\nimport SwipeableViews from 'react-swipeable-views';\nconst styles = {\n  root: {\n    padding: '0px 28px 0px 0px',\n    width: 675,\n  },\n  slide1: {\n    width: 150,\n    background: '#FEA900',\n  },\n  slide2: {\n    width: 375,\n    background: '#B3DC4A',\n  },\n  slide3: {\n    width: 150,\n    background: '#6AC0FF',\n  },\n  slideStyle: {\n    width: 'auto !important',\n  },\n};\nexport default class Ranking extends Component {\n  constructor() {\n    super();\n    this.state = { tabIndex: 0 };\n  }\nhandleMainChangeIndex(tabIndex) {\n    this.setState({\n      tabIndex,\n    });\n  }\nrender() {\n    const swipeableViews = classNames({\n      'app-custom1': this.state.tabIndex === 0,\n      'app-custom2': this.state.tabIndex === 1,\n      'app-custom3': this.state.tabIndex === 2,\n    });\n    return (\n      \n\n\n            A\n          \n\n            B\n          \n\n            C\n          \n\n\n    );\n  }\n}\n```\nCss\n```\n.app-custom1 {\n  position: relative;\n  left: 0px;\n}\n.app-custom2 {\n  position: relative;\n  padding-left: 250px !important;\n}\n.app-custom3 {\n  position: relative;\n  padding-left: 700px !important;\n}\n```\n\n. ",
    "jdwhite88": "Similar issue here. I have a SwipeableViews with animateHeight={true} and tabs. My initial tab gets cut off on the bottom before the first swipe (consistently within tab, randomly between tabs). After the first swipe the height is correctly recalculated.. ",
    "qbitza": "I think you're missing the part where this is an SSR issue. \nClient side rendering works.. A pity, as we really would have loved to use this component.. ",
    "sergivillar": "Sure I can, but if I do this, the animation is made in the opposite direction, I mean, if you are in slide 1 and you go to de right and the swipe said the next slide is number 3, I can force it to be number 2, but the animation is incorrect and it appears from right to lefr (because I force the slide number 3 to be number 2, as if I was swiping backwards). I've already tried this, I think that the problem is that the swipe is such a fast that the setState\u2019s callback inside the handleTouchEnd is not executed ecery time I do a swipe, sometimes the handle is executed twice but the callback only one (I added some console.logs to see this) what do you think? . ",
    "TiagoSousa26": "@sergivillar Did you fix your problem?. Oh ok, thanks. But there is a way of not doing swipe fast?. > not doing swipe fast?\n\nWhat does it mean?\n\nChange fast between slides with swipe.. For example, you swipe and it changes one slider, but you do this pretty fast.\nThere is a way of only switch one slider every 2 seconds for example or when the animation ends? Basically, disable the swipe for a specific time.\n\n. Sorry, I was editing the comment to provide more information.. I tried to toggle the prop disabled to not be able to swipe after changing slide, but it takes more time than it was supposed. For example, I set 500 miliseconds of interval and it take like 2 seconds.. ",
    "eladonline": "I join this issue as well. ",
    "AdamLantz": "The parent component of A and B can handle the shared stated. This state can be used as the index prop of both A and B.. ",
    "sebastianvoss": "Same issue here (even without having a MUI select in the view). Reverting back to v0.12.4 solves the issue.. ",
    "stonerworx": "I worked around it by capturing the onTouchStartevent in the inner swipeable-view by wrapping it in another component and stopping the propagation:\n```typescript\nimport * as React from 'react';\nimport SwipeableViews from 'react-swipeable-views';\ninterface ImageSliderProps {\n  children: children: ReadonlyArray;\n  className?: string;\n}\nexport class ImageSlider extends React.PureComponent {\n  public render() {\n    return (\n      \n{this.props.children}\n\n    );\n  }\nprivate onTouchStart = (e: React.TouchEvent) => {\n    e.stopPropagation();\n  };\n}\n```. ",
    "malash": "BTW. I found a hack way to solve this problem. I don't know why but it works for me. https://codesandbox.io/s/3187wxkkrm. ",
    "matviishyn": "found one similar issue (closed) https://github.com/oliviertassinari/react-swipeable-views/issues/257. ",
    "JennieJi": "Similar issue but my case is horizontal scroll. Can simply trigger with any nested overflow items with -webkit-overflow-scrolling: touch.\nTried react-swipeable-views: 0.12.12, 0.12.18, 0.13.0\nTriggerable in iOS >= 10\nDemo: https://codesandbox.io/s/xv4xyw7n9q\n. BTW, this temporary solution works: https://github.com/oliviertassinari/react-swipeable-views/issues/408#issuecomment-421276447. ",
    "mpodlasin": "There is also third issue with this line, which works well one swiping only one slider, but in my case user will often swipe more than one slider at once (with one continuous movement). If for example user swipes up, delta will always be negative and index 7.3 will be rounded to 8, even though it would make more sense to round it to 7, since it is a closer index. \nFrom perspective of the user after ending swipe wrong item appears as centered - not closest to the center of container, but the one above it.\nAgain I have a fix, which I can provide. It should not change behaviour of typical one-element-visible-at-once sliders. :). I'll try to do it today. ",
    "jackdh": "Hey @mpodlasin could you make that pull request please?. ",
    "anulalbs": "Yes possible \nOn  <SwipeableViews onSwitching = { this.updateScrollBars}\nand on updateScrollBars function write the code to scroll the div to the top\nHope this helps. ",
    "RosarioAleCali": "@anulalbs Do you have a working example? For some odd reason I can't get onSwitching to fire.. @oliviertassinari So, when are those callbacks called?. ",
    "kenttan0214": "I need this feature as well. ",
    "RyanLiu0235": "@oliviertassinari Thank you very much for the explanations, I got it.. ",
    "kallehjerppe": "Hey! Any comments @oliviertassinari? :). ",
    "xAlstrat": "\nSorry, I'm focusing my time on Material-UI. I will try to review this pull-request at some point, maybe.\n\nI have the same problem, my components are too large. I tried the code shown here and it worked perfectly. Could you merge this pull request please?. ",
    "romainquellec": "Same with some other demos.. @mxl @DeividasBakanas. ",
    "iivn": "Yes, it is!\ndisableDragging={'left'|'right'|true|false}\n:). ",
    "hartzis": "@oliviertassinari would you like me to include cleaning up those null checks in this PR?. @oliviertassinari cleaned up those null checks.\nThoughts on the \"failing\" codecov?. ",
    "varenya": "Are you open to a PR to implement this?. okay tried to implement it but ran into a bunch of edge cases with it let me explore a bit further if I can get it done will raise a PR and you can review it. Thanks for your time. . one more thing @oliviertassinari did u try throttling the touch events seems like its getting triggered too often. Might help with performance.. yeah I didn't see any lag at all,  the code is really readable and well implemented \ud83d\udc4d . ",
    "Sw0rdstream": "Same problem for me as well. \nWith regards, but personally think it a bad practice to upgrade babel in a revision update.. ",
    "gaearon": "We're going to have a first-class API for mounting invisible components asynchronously without blocking the thread in the future, right inside React. Stay tuned :-). Normally React wants to keep the UI consistent with what you told it to render.\nSo if you render\njs\nfunction Slideshow() {\n  return (\n    <div>\n      <Expensive1 />\n      <Expensive2 />\n      <Expensive3 />\n    </div>\n  );\n}\nthen it will have to call render methods and create DOM nodes for the whole trees of Expensive1, Expensive2, and Expensive3, when Slideshow is being mounted.\nHowever, maybe you're only showing Expensive1 on the first render, and Expensive2 and Expensive3 are not immediately visible. Like if this is really a side show.\nToday, it's idiomatic to render just the current node, e.g.\njs\nfunction Slideshow(props) {\n  return (\n    <div>\n      {props.current === 0 && <Expensive1 />}\n      {props.current === 1 && <Expensive2 />}\n      {props.current === 2 && <Expensive3 />}\n    </div>\n  );\n}\nThe upside of this is that now your first render of <Slideshow current={0} /> only includes Expensive1. However, the downside is that the moment you switch to <Slideshow current={1} />, you will experience jank from creating and rendering the whole Expensive2 tree.\nIdeally what we want to do is to tell React that when we render <Slideshow current={0} />, we want to show Expensive1, but we want to start preparing Expensive2 when the browser is idle. This way it won't block the initial render or cause jank, but by the time you click \"next\" Expensive2 might just already be complete, and in this case it'll just replace the DOM node.\nThis is exactly what time slicing which I partially demoed in my talk will allow. Your code might look something like:\njs\nfunction Slideshow(props) {\n  return (\n    <div>\n      <div hidden={props.current !== 0}>\n        <Expensive1 />\n      </div>\n      <div hidden={props.current !== 1}>\n        <Expensive2 />\n      </div>\n      <div hidden={props.current !== 2}>\n        <Expensive3 />\n      </div>\n    </div>\n  );\n}\nNote that hidden is a real HTML attribute. (It acts similar to display: none.) But it could also serve as a hint to React that the tree inside it doesn't actually need to be committed immediately \u2014 because it's not visible anyway. Also note: this is not a final API, I\u2019m just explaining what it lets you do.\nSo when you render <Slideshow current={0} />, React mounts\njs\n<div>\n  <div hidden={false}>\n    <Expensive1 />\n  </div>\n  <div hidden={true}>\n    <!-- not ready yet -->\n  </div>\n  <div hidden={true}>\n    <!-- not ready yet -->\n  </div>\n</div>\nand whenever the browser is idle (e.g. when you look at the first slideshow item), it will start working on Expensive2 in small chunks. When it's ready, it will just append it to the hidden div \u2014 which won't be observable to the user because it's hidden.\njs\n<div>\n  <div hidden={false}>\n    <Expensive1 />\n  </div>\n  <div hidden={true}>\n    <!-- not visible, but prepared during idle periods and now ready! -->\n    <Expensive2 />\n  </div>\n  <div hidden={true}>\n    <!-- not ready yet, but React will start working on it next -->\n  </div>\n</div>\nNow if you switch to <Slideshow current={1} />, React doesn't need to do any extra rendering because it has already \"prepared\" Expensive2 ahead of time.\nAnd if you switch too fast, and React hasn't been able to fully prepare Expensive2 yet, it will just pick it up where it left off but set a much more aggressive deadline since we want to see results within ~150ms.\nI hope this explains it a bit! The crucial part here is time slicing. This optimization wouldn't make sense if pre-rendering Expensive2 or Expensive3 blocked the thread since in this case it wouldn't be worth slowing down the interactions while Expensive1 is visible. But thanks to React's architecture, we can actually start pre-rendering Expensive2 and Expensive3 in small chunks without blocking the thread, and that's what will enable this optimization.. @demiacle I don't understand the question. Can you explain in more detail?\n. @demiacle If the \"use case\" you're referring to is capturing props at the time constructor was called then yes, you might capture them earlier than intended if you use pre-rendering. I'm struggling to understand why you'd want a component API like this since it's pretty unintuitive that changing a prop has no effect later. This is why we discourage it. I wouldn't say pre-rendering would \"break\" this \u2014 it's just that you need to decide whether you want pre-rendering or you want this behavior (which is fundamentally incompatible with the idea of pre-rendering).\n@Raigasm It might (note you won't have to use it but might find it beneficial). We'll see.. >What I'm wondering is if this has applications beyond the case where all the components are expensive.\nI'm using the word \"expensive\" to better get the point across. It doesn't have to literally be expensive \u2014 no matter how fast your rendering is, it would still be faster to do it earlier in an idle period (and then switch instantly).. It's pretty early to see right now. We'll see how it evolves after we use it for a while.. @ChrisLincoln No, my explanation is about a future feature of React. It doesn't exist today and won't work for you the way I described.\n@josgraha I don't know, we'll think more about this before finalizing the API.. ",
    "demiacle": "cool beans, but doesn't this break instances where a component gets initial state from a prop and is rendered before they are expected?. Hmm just double checked for sanity, It's discouraged in the docs on constructor so its probably an anti pattern, but it does have a use case. I was playing around with it here. Essentially with your proposed solution, clicking the button wouldn't change any text because the state was already derived from the props.. With programming its never about the why though haha, if it can happen it will. I was only interested in being explicit because in the example I presented, there are 2 identical components that are rendered differently. Just thought it should be noted. Anyways super cool stuff!. ",
    "Raigasm": "Will this change the way we approach route/page transitions in React?. What I'm wondering is if this has applications beyond the case where all the components are expensive.\na la your example:\n<div>\n  <div hidden={false}>\n    <Inexpensive /> \n  </div>\n  <div hidden={true}>\n    <Expensive1 />\n  </div>\n  <div hidden={true}>\n    <Expensive2 />\n  </div>\n</div>\n. ",
    "denis-n": "Dan's example reminded me of tabs and how the content of active one is shown only...\nBut still the content off all tabs is there somewhere.\n\"\u0422\u044b \u0441\u0443\u0441\u043b\u0438\u043a\u0430 \u0432\u0438\u0434\u0438\u0448\u044c? \u0418 \u044f \u043d\u0435 \u0432\u0438\u0436\u0443. \u0410 \u043e\u043d \u0435\u0441\u0442\u044c\". ",
    "dcollien": "This is very cool. Purely speculating here without a solid use case: would there be a way to specify rendering priority? As per the above description it seems like the background rendering is perhaps prioritised by the order in which components are specified, or just spread across all equally in some piecemeal way, but I imagine that it may be the case in a more complex layout that one hidden component that is definitely going to be the next thing the user sees should be prioritised over some other hidden component which may have lesser importance (e.g. less important for it to be jankless, or it is suspected to be more likely to come into play later, or perhaps very few people even reveal that component, etc)\nI can imagine this being useful when you have a primary user pathway which can be optimised to have the best jank-free experience, when there exists less important, but potentially very expensive to render hidden components off to the side. ",
    "vladnicula": "@demiacle I was thinking at the same thing as you. With this api we could have both benefits if we split the component that needs the initial state from a prop into a wrapper that just computes/stores this state and a child that is used inside a hidden div.\nThis would help me with a few \"render only when visible\" cases where content is not reliant on any API data. \njsx\nclass ExpensiveOnDemand extends React.Component {\n  constructor (props) {\n     super(props);\n    // do stuff with state and initial props\n    this.state = { ... };\n  }\n  render (props) {\n    return (\n        <div hidden={!this.props.visible}>\n            <ExpensiveStuff {...this.props} {...this.state}/>\n            // or maybe something with this.props.children\n        </div>\n    );\n  }\n}\nThis will probably need more work for sub components that fetch data on componentDidMount, which has been a common practice for me when rendering tabs on demand. . ",
    "ChrisLincoln": "In our app, we generally would not have rendered Expensive2 or 3. Should we be adopting a technique where they are hidden, for instance with DOM or CSS attributes?. ",
    "josgraha": "@gaearon is there a plan for an opt-in component like <React.Prerender> that can optimize parts of the tree that want to coerce prerendering and opt-out for everything else?  Do you even see a use case for that given the hidden attribute (or whatever prop you finally go with) already does this implicitly?. ",
    "studevsdev": "I am using swipeable to swipe gvis charts. The json data for each chart I fetch from my S3 API each time a swipe occurs. To solve the problem when it's not ready I have a loading spinner like this:\n```\n\n{\n  this.state.dataLoadingStatus === 'ready' ? (\n    \n{index}\n      \n      {this.state.urlVar}\n    \n  ) : (\n    \n\n\n      )\n}\n   \n```\nIt does not fetch all the json at the same time from my API, but it renders the chart component for all items . So it seems to work. I will see how 230 items work or if it's get to slow.. ",
    "dhleong": "@oliviertassinari it looks like the unit tests are failing due to circle CI's caching being disabled for some reason, but they did pass on the first build. I just changed the exported library name for the packaged UMD to the more canonical SwipeableViews. I've run the tests locally and they seem to still pass.. @oliviertassinari I've rebased against master and updated the rollup config for the release version of babel 7. ",
    "KITSTABChrisGreen": "Hi Olivier, it appears I'm having the same issue as per https://github.com/oliviertassinari/react-swipeable-views/pull/455\nThanks for your help in advance. \nChris . ",
    "Jordy-A": "@oliviertassinari isn't this possible?. ",
    "bellini666": "@oliviertassinari oh, didn't know that! Ok, will abandon this.\nDo you have an ETA to when babel7 support will be available at npm? I'm trying to upgrade my project here and this dependency is the only one preventing me from doing that. @oliviertassinari ok, I'll wait until #459 is done! Thanks. @oliviertassinari hahaha there you go! Thanks :). I saw that you merged this and released a new version! Can you ping me here when it is available on npm? I just checked and it wasn't yet =P. @oliviertassinari thanks! Just updated my project, everything working great now :). ",
    "JulioPablo": "Sure! As soon as I'm able to I'll fix it.. ",
    "geminiyellow": "\ud83d\udc4f  thank you!\nand the Cover , we have the code, right, just export it as package looks ok. . @leonardovillela take it, kill it, plz.. hey, how about now? need a new release. @oliviertassinari @yacut . \ud83d\udc4f  big news. thanks all. @yacut @oliviertassinari . \ud83d\udc4d  . ok, i got the Right Behavior, maybe the doc need fix.\ni do something like this:\n```\n\nconst slideRenderer = ({ index, key }) => (\n  <View\n    key={key}\n    style={{ padding: 15 }}\n\n<Tile name={key} code={'#1abc9c'} />\n\n\n);\n```\n\n\n. and the flat ignoreNativeScroll: true  cannot fix this .. @oliviertassinari hey sir, could you help me?. ",
    "leonardovillela": "Can i take this issue?. ",
    "Aendir": "Any updates?. ",
    "taion": "Okay, it turns out there's no actual exception here to catch. What do you think of adding some sort of function to disable the \"style injection\" behavior?. I'd be all for it. It's not quite 2019 yet, though.. Thanks!. ",
    "Faolain": "can this package please be updated on npm?\nhttps://github.com/oliviertassinari/react-swipeable-views/issues/468. thanks @digital-flowers I tried doing that but am getting the following:\n``\nLoading dependency graph, done.\nerror: bundling failed: Error: Unable to resolve modulereact-swipeable-views-corefrom/Users/user/Desktop/novo_app/app/node_modules/react-swipeable-views-workspace/native/packages/react-swipeable-views-native/src/SwipeableViews.animated.js: Modulereact-swipeable-views-core` does not exist in the Haste module map\nThis might be related to https://github.com/facebook/react-native/issues/4968\nTo resolve try the following:\n  1. Clear watchman watches: watchman watch-del-all.\n  2. Delete the node_modules folder: rm -rf node_modules && npm install.\n  3. Reset Metro Bundler cache: rm -rf /tmp/metro-bundler-cache-* or npm start -- --reset-cache.\n  4. Remove haste cache: rm -rf /tmp/haste-map-react-native-packager-*.\n    at ModuleResolver.resolveDependency (/Users/user/Desktop/novo_app/app/node_modules/metro/src/node-haste/DependencyGraph/ModuleResolution.js:209:1301)\n    at ResolutionRequest.resolveDependency (/Users/user/Desktop/novo_app/app/node_modules/metro/src/node-haste/DependencyGraph/ResolutionRequest.js:83:16)\n    at DependencyGraph.resolveDependency (/Users/user/Desktop/novo_app/app/node_modules/metro/src/node-haste/DependencyGraph.js:238:485)\n    at Object.resolve (/Users/user/Desktop/novo_app/app/node_modules/metro/src/lib/transformHelpers.js:180:25)\n    at dependencies.map.result (/Users/user/Desktop/novo_app/app/node_modules/metro/src/DeltaBundler/traverseDependencies.js:311:29)\n    at Array.map ()\n    at resolveDependencies (/Users/user/Desktop/novo_app/app/node_modules/metro/src/DeltaBundler/traverseDependencies.js:307:16)\n    at /Users/user/Desktop/novo_app/app/node_modules/metro/src/DeltaBundler/traverseDependencies.js:164:33\n    at Generator.next ()\n    at step (/Users/user/Desktop/novo_app/app/node_modules/metro/src/DeltaBundler/traverseDependencies.js:266:307)\n```\ntried all the suggestions and still no resolution. I believe it's not finding the react-swipeable-views-core library located in packages which I believe during an npm installation installs them normally. Should I also manually install this through yarn? Lastly I'm trying to use the SwipeableViews.scroll but I'm encountering Cannot read property 'style' of undefined. thanks @digital-flowers really appreciate it! Since you are now a collaborator is it possible for you to publish the npm package or is that only something @oliviertassinari can do? . @digital-flowers also seems like the scrollview doesn't work as it Cannot read property 'style' of undefined? Does a similar change need to be done for that component as well?. Thank you! @oliviertassinari , I assume this issue will close once you do? . ",
    "digital-flowers": "@Faolain until this published you can use my fork to solve this issue\nnpm i --save https://github.com/digital-flowers/react-swipeable-views\nbut you need to change your import to something like this:\nimport SwipeableViews from \"react-swipeable-views-workspace/native/packages/react-swipeable-views-native/src\";\n. @Faolain sorry i forgot to mention that you have to download that module separately, something like npm i react-swipeable-views-core --save, my bad sorry :(. @Faolain i didn't face this issue yet, also for npm, npm has a separate account credentials to publish and manage packages. @oliviertassinari  sorry, the problem that I am very busy these days, if you want add me as a contributor and i can help when i have a time, what do you think ?. @oliviertassinari appreciated  :). ",
    "bavicj": "Hi guys, any idea when will it be released?. ",
    "mahdiG": "\nI also need to change style (overflow) of these children.. ",
    "slide13": "\ncan anyone tell me how can i remove overflow which can inside tab container.\nthanks you\nMehul Jariwala\n\nI think you can only override it by replacing css class\n.react-swipeable-view-container > div {\n  overflow: unset !important;\n}\n. ",
    "AK-101111": "Another 'hacky' way is adding a little padding through the attribute \nslideStyle={{padding: '5px'}}. ",
    "benesva4": "Try to add slideStyle prop:\n<SwipableViews slideStyle={{ overflow: 'visible'}}>\nslideStyle according to Component API: This is the inlined style that will be applied on the slide component.\n. ",
    "MastroLindus": "duplicate of #476\nissue created three times because github apparently is exploding right now.... duplicate of https://github.com/oliviertassinari/react-swipeable-views/issues/476\nissue created three times because github apparently is exploding right now.... @oliviertassinari  I know you are busy with material-ui, however as you are the only maintainer it would be really appreciated if you could take the time to review and merge this PR when you can.\nIt only changes one file (and one additional test that would fail before and it is now passing) so it should take just a few minutes, and it fixes 2 currently open issues.\nAppreciated!. ",
    "Benew": "hum hi. I really need this. @MastroLindus could you squash your commits so that the review gets smooth ?. @MastroLindus trying to make another PR #498 but I didn't expect the tests to support null children.\nDid you find a workaround ?. @oliviertassinari is there a reason why this is not merged (other than lack of time to maintain this and review the code I mean) ?\nThis issue is a huge one (to me). @oliviertassinari \ud83d\udc4dthat was quick. @oliviertassinari better late than never! Thank you and @MastroLindus\nLe sam. 19 janv. 2019 \u00e0 01:30, Olivier Tassinari notifications@github.com\na \u00e9crit :\n\n@MastroLindus https://github.com/MastroLindus Well done, I'm sorry for\nthe delay.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\nhttps://github.com/oliviertassinari/react-swipeable-views/pull/480#issuecomment-455729884,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ABI5IgRj7Z9NyaPHsTF6WDJ7Ch432J2Iks5vEmc2gaJpZM4X3Seq\n.\n. @oliviertassinari are you going to publish an update to npm ?. \n",
    "diondiondion": "\nIn my case, inside the container i have an element with position: fixed, like a modal that needs to get in front of everything, and transform cuts the behavior it needs.\n\nSeems like using React's Portal API would be a much better way of solving issues like this one. You really don't want your users to suffer through animations of the left property.. ",
    "santospatrick": "Thats another problem because i have react 15.x in the project (it is a big code base) and it doesnt achieve all requirements it needs to update react without having to refactor some code to 16 version which has portals, another idea of how i could solve this?. > @santospatrick There is an \"unstable\" Portal API in React 15 that works really well. For instance: https://github.com/mui-org/material-ui/blob/v1.0.0-beta.47/packages/material-ui/src/Portal/LegacyPortal.js.\nThis should do the trick, thanks! I am closing this issue for now.. ",
    "aibrahim3546": "The problem was solved.\nTo solve this problem I had to install these two packages and the problem was solved:\nnpm install --save-dev preact-compat/react preact-compat/react-dom\nI found the solution at here #459\nThank you for replying @oliviertassinari . ",
    "diedsmiling": "\ud83d\udc4d Thanks for merging, any chance to rebuild https://react-swipeable-views.com/api/api/ ?. ",
    "jsantos": "This boy is getting famous https://twitter.com/svensauleau/status/1096481692234199042. ",
    "xtuc": "Hey @voleggold, I appreciate that you removed the repos. That said, I didn't expect that fame.. ",
    "minhna": "It works by adding this:\naction={(actions) => { this.swipableViewsActions = actions; }}\nI don't have to use ref anymore. Thank you.. ",
    "Minishlink": "Thanks @oliviertassinari ! I sent a PR to update the doc, to mention this :) . ",
    "mikestaub": "Do you think updating the css value via js will be performant?. "
}