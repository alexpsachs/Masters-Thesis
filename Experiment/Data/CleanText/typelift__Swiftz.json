{
    "cartazio": "i'm not sure, but it does look like the proper generic map can be defined at the use sites\nmy current strawman for functor is \n``` swift\nprotocol Functor {\n typealias A\n typealias FA\n typealias B\n typealias FB\n func fmap(FA,A->B)->FB\n}\n```\nbased upon my reading of the spec, anything that defines the \"right\" generic  map functor for itself (which is expressible at the data type defn site), will be construed to have this protocol. But i've not tried yet\n. theres a twist!\ni'm having trouble with a toy example \n```\nprotocol Functor {\n typealias A\n typealias FA\n typealias B\n typealias FB\n func fmap(FA,A->B)->FB\n}\nclass MyArray{\n    init (marr : Array){ container=marr }\nvar container : Array<A> = []\nfunc fmap<B>(f: A->B, inmap:MyArray<A>)->MyArray<B>{\n    return MyArray(inmap.container.map(f))\n}\n\n}\n```\ni get the message\nMyArray<A> does't conform to protocol B\nin the return line\n. ahah! got it working\n```\nclass MyArray{\n    init (marr : Array){ container=marr }\nvar container : Array<A> = []\nfunc fmap<B>(f: A->B, inmap:MyArray<A>)->MyArray<B>{\n    let newArray : MyArray<B>(inmap.container.map(f))\n    return newArray\n}\n\n}\n```\n. yup, thats not possible right now afaict :'( \n. I assume semigroups should be in too\n. though maybe the <> should be defined out of band of protocol and just assume protocol but invoke mappend\n. whats NEL?\n. max raised the valid issue that its better to do the newtype style class wrappers than this, \n. merged it. Thanks!\n. once work stuff stabilizes i'll have a go, which could be a while :) \n. the conflation of reads and writes with the same syntax worries me :/\n. also <- (being the flip of ->) seems like high value syntax\n. (though i'm still fuzzy on how the swift module system/name space works, so that might be a non issues)\n. my main concern is the use of the same operator for reads and writes, but maybe thats fine. \n. @sritchie  if you renamed your Injection stuff to \"read and show\" or \"printable\" and \"readable\" yes. They're not bijections. \n@sritchie addable is just Semigroup. We have that merged in already https://github.com/maxpow4h/swiftz/blob/master/swiftz/Semigroup.swift\nI'm pretty sure we've got a lot of semigroup / monoid stuff,but having decent counting structures could be cool. though it might be a good idea to be conservative on how much gets in, i'm not sure how often ios/os x applications need server class approximate counting data structures.\nI assume you mean the stuff in https://github.com/twitter/algebird/tree/develop/algebird-core/src/main/scala/com/twitter/algebird ?\n. @maxpow4h  oh, those are Lens Isos? I thought it was A->String and String->A only, rather than proper Isos ala lens\n. ohh, yeah, they are Isos  and prisms, my bad :) \n. @sritchie  the idea is the  a-> Either a b is an injection  (aka prism)\nbecause you can't write a safe Either a b -> a \n. http://hackage.haskell.org/package/lens-4.2/docs/Control-Lens-Prism.html#g:2 shows some machinery for prisms\nreplicating it inline \n``` haskell\ntype Prism s t a b = forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)\n-- some ways to construct prisms\nprism :: (b -> t) -> (s -> Either t a) -> Prism s t a b\n--- a way to construct a simple prism\nprism' :: (b -> s) -> (s -> Maybe a) -> Prism s s a b\n```\n. so in the really simple case we could have\nhaskell\nprism' :: (a-> s) -> (s -> Maybe a) -> Prism s s a a\nwhere s=  Either a b\nmight be one choice in s\n(this is just a teeny piece of the awesome generality of lens (which I myself am still learning))\nso a simple prism might be formed out of \nhaskell\nfoo :: a-> Either a b \nbar :: Either a b -> Maybe a\n. 'Bijection class definition.' dont you mean injection?\n. usability I'd imagine.\n. ",
    "mxswd": "Yeah, i've changed it to have all the type aliases. It will need to be that way.\n. Absolutely, if anyone has radr numbers I can add keep track of them on the README.\n. My initial feedback is:\n- it looks like a good approach.\n- I'm going to try this to get lens functor definitions in terms of fmap.\nI think there is a correction for fmap type:\nfmap<FA : Functor where FA.U == U>(f : FA.A -> B, _ a : FA)\n                                               ^ **A -> B**\n. yeah, I say add it.\n. Monoid and semigroup should be relatively not a problem!\n. We now have Semigroup and Monoid with a bunch of instances!\n. :ok: \n. added in 63c63fac8c31b27177c20330aa8201a5543eed73\n. Yeah, I've worked out, since an extension can't add to the init, we can't use extensions for explicit type class instance passing. So I would opt out of this for now. Things could change.\n. Awesome. Nicely done!\n. Awesome stuff! Those dictionary extensions look very useful. Thanks! :cookie: \n. I am pretty sure the way it works, is you can declare as many instances of an operator as you like, so long as the types are different. So this looks pretty good to me.\n. Yeah, I prefer <-. An infix operator is useful in a lot of cases, and this seems like a good name for one.\nThanks!\n. Set was always on my wish list! I would love to merge it in. (Keeping the tests in a separate test file).\nEdit: See #17\n. The trade off is, NSSet doesn't have types (is not parametric in a type, such as an Array is parametric in T) :cry: \n. added the stub file in e3408064bf\n. I would love to have them in this project. Immutable data types are a core need for functional programming. The benefit of doing so, is any operators or protocols we implement on them (map, leftmap, rightmap, etc.) will always be on the same version and compatible with the data types.\n. I think having an empty set constructor Set() is handy.\nAlso I changed any to return an A?.\nhttps://github.com/maxpow4h/swiftz/commit/6a38379a72d7875adf831bcf66e9210707469b56\nLGTM to merge :)\n. Awesome. Thanks a lot, I will merge this locally and push it up later today.\n. > extension to the pair (CGVector, CGPoint), but I get the error\n\nNon-nominal type '(CGVector, CGPoint)' cannot be extended.\n\nMy \"Go to\" workaround for this is to make a singleton class. It acts as the \"record\" to lookup functions in, by literally having functions on the class. Instantiate the object once, and pass it in as required. Something like:\n```\nlet actionTuple = ActionTuple()\nclass ActionTuple {\n  typealias A = CGVector\n  typealias M = CGPoint\n@infix |> (a: CGVector, x: CGPoint) -> CGPoint {\n    switch ((a, b), (c, d)) = (a, b) {\n     case let ((a, b), (c, d)): mkCGPoint (a + c) (b + d)\n  }\n}\n// then later on\nlet xs = someA actionTuple.|> someB\n```\nSomething like that.\nBut, another thing to ask is, why use a type class pattern? Most type classes are defined by some laws. This is what makes them useful. Maybe just a function on CGVector would be fine for this problem in particular?\n. Try out:\n```\nfunc foo(a: CGVector) -> Float {\n    switch (x, y) = (a.x, a.y) {\n        case let (x, y): return x + y\n    }\n}\n```\n:smile: \n. Thanks heaps! Looks good to me. :star2:\nFor the inference problem, check out #22 and let me know what you think.\n. @joshaber @cobbal\nThe #1 example is (a -> a) -> f a -> f a. I can't get codegen to work for fmap :: (a -> b) -> f a -> f b.\nI think we should work off this until we find a better way.\nThis approach is sound, but verbose. (I will move it out of the unsound dir after merging).\n. It seems we can either get inference on which lens to use (with respect to what functor) or we can have one Functor definition of a lens, and we have to specify which Functor to use with the lens.\nI'm opting for the current / first option, to require multiple definitions. It is more usable.\n. Well, that explains a lot about my programs not compiling! Thanks!\n. @sritchie Hey!\nI am absolutely taking any PRs of associative data structures, like in Algebird.\nAs @cartazio mentioned, I have added a couple of instances semigroup and monoid. They are here. https://github.com/maxpow4h/swiftz/blob/27031fea2ce7496715e4d5345149fd8f156b24e5/swiftzTests/swiftzTests.swift#L268-L277\nMore useful instances would be very good! I just added those ~3 to define a Monoid type that can satisfy lots of different problems. (The technique I use in Monoid stops you from needing an Int, Int8, etc. version of everything).\nAs for Bijection / Injection, they would be very useful! My only ask, is if you could name them Isomorphism and Prism respectively.\nThanks! :smiley:\n. @jonsterling That protocol is a Simple Prism. I.e. Prism s s a a.\nBut I don't think we can support polymorphic lenses any time soon ;)\n. Yeah, so #34 has convinced me Control.Lens is not useful in Swift, but Data.Lens is.\nSo a \"Prism\", which would be a Function, becomes a class.\nswift\nprotocol Prism {\n  let apply: A -> B\n  let invert: B -> A?\n}\nexactly the same as the --Bijection-- Injection class definition.\nEdited that, accidentally hit ctrl enter\n. We are talking about the same things, I would just prefer to use the Lens version of terminology :smiley: \n. Yes.\n. Thanks :smile: \n. Thanks! I've tidied them up. I will remember to watch for this in PRs.\n. Nicely done!\n. Thanks a lot :smile: ! Merged.\n. Thanks! I keep forgetting to use them.\n. @jckarter Thanks! I didn't know about them, that's exactly what I need.\nI've switched over the uses of malloc in this commit 5704cd1848353fc757ba6f8479b13fe647cfcf92.\n. Merged. That's excellent! Thanks a lot!\n. Merged, thanks! Can't wait to try it out.\n. Yeah I've experienced this too with chaining lots of operators.\n. Great idea! Added in 784996cff4\n. @pthariensflame Ok wow, Data.Lens lenses are definitely more useful. My only question is, can Lens now become a struct?\n. Thanks a lot! Lenses for all indeed! :smiley: \n. Awesome. I will add a better MVar test. Thanks again!\n. I want to add GCD queues as soon as feasible. :)\nIt would be a new ExecutionContext a user could select to use.\nSome refactoring is needed though.\n. Nicely done! Better in every way I tested. :+1:\n. I see the main benefit in the function names and types are specialised. This can help in type errors (I.e. You have a NSError where an Int was expected, vs you have $T4 where int was expected). It helps for the same reason in type inference. It helps in \"value\" and \"error\" are more validation sounding than \"left\" and \"right\". And it helps in that we can't write type aliases in the global space, so it would need to be attached to some object, so we would have to prefix the type. \nDoes this make sense? It isn't the strongest case indeed. I will add to and from's between either and result so they can be used together. \n. Added the manual conversions in https://github.com/maxpow4h/swiftz/commit/ef76e39b33e6e15af95e8c20d01894d7c539d4fc#diff-e0824c2ad2591840ddf17c38135cb4f3R87\nTurns out you need type equality. Awesome!\n. Looks good to me! Thanks!\nAs it stands, Swift can't support functions over arbitrary sized tuples. A hlist structure would be my ideal solution to this problem. This also means we need a OneTuple (I would advocate adding a OneTuple to swiftz as it is, in case someone wants to do code generation that results in tuple structures, they can standardise on our OneTuple).\nEither way, it is an interesting topic!\n. Ha..., nice find. I do, of course, want to sort ImArrays, and this is the best way to do it.\nWhen it gets fixed, we can remove the work around :)\n(I've taken that approach with everything else so far).\nSo I'm going to go ahead and merge this.\nThanks a lot :smile: \n. Thanks! It's super.\nMy only feedback is to use:\n(Party.lpartyHost() \u2022 User.luserName()).set(party, \"Max\")\nin the test, hopefully as a good example for future readers.\n:wine_glass: \n. Awesome! Thanks! \n. I can understand your motivation here, but I would suggest attempting to program against my current API because I think you may find that to not be a problem. Specifically, if you have a class A which you store and load from core data, the json decode function is always an optional A?. When you are decoding, if you expect a string but got a null, then you get back nil from decode. I believe this will be more helpful to you than an empty string. \nI also recommend using https://github.com/maxpow4h/swift-gen to generate to and from json functions for types, but currently it's json support is limited. Give me an example and I will try to implement it. \n. map is overloaded depending on what type is at the front of the list. So it picks the next map function depending on head. This doesn't link (or run?) yet. \nEdit: merged without map, so you can still nil or cons.\n. ``` swift\nimport Foundation\nprotocol TypeEquality {\n  typealias From\n  typealias To\n  func apply(a: From) -> To\n}\nstruct Refl : TypeEquality {\n  typealias From = X\n  typealias To = X\n  func apply(a: From) -> To {\n    return a\n  }\n}\nstruct Tuple2 {\n  typealias T = (A, B)\n}\nextension Array {\n  func lookup.T>(ev: EV, key: Key) -> Value? {\n    return nil\n  }\n}\nlet xs: Array = []\nlet r: String? = xs.lookup(Refl(), key: 1)\n//     ^ This is impossible, Refl.apply is Int -> String\n```\n. @jonsterling Yup, I agree. I removed it in 4959b4d428989ee6386024386cf51db0b9c40a16.\nOne point though, type equality is definitely expressible in swift in a sound way, as a function.\nhttps://github.com/maxpow4h/swiftz/blob/master/swiftz_core/swiftz_core/List.swift#L55-L64\nLeibniz equality would also be much better. One day...\nOn the representation, I think sealed / closed protocols would stop people from defining their own axioms.\n. @jspahrsummers I'm going to try to put this together next. Would you depend on it via a git submodule or something else? If so, the layout would be:\n- Xcode workspace\n- swiftz-core project (you would Xcode depend on this, not the workspace?)\n- swiftz project, depends on swiftz-core\n2 products, both frameworks / static libs. \nSound good to you?\n. Looks all good to me! Thanks!\n. Thanks! :100: \n. Thanks :)\n. Thanks! Looks good.\n. that would be awesome! :)\n. It looks like you don't have swiftz_core_ios in your project, but you do have swiftz_ios.\nI pushed some changes, can you check that and try it with the new xcode config?\n. Thanks! We should do up a table of what's a \"Functor-ish\", \"Monad-ish\", \"Comonad-ish\", etc.\n. Thanks! I see the value in this.\n. Thanks again!\n. Yeah it should be. \nWe could also define it as:\nfunc flip<A, B, C>(f: A -> B -> C)(b: B)(a: A) -> C\nAny thoughts? I think this is more practical for point-free expressions. \n. I've added both flips in e9dcab68d99e9f5a4e90a288a0eed2cdab60b1d2\nThe problem is, you need to label the arguments b: x, a: x.\nThey overload fine.\n. @ikesyo yup!\n@maxcan Awesome! Thanks! All fixed up :)\n. Cool, thanks! We can probably put @final on them too.\n. Awesome!\n. Thanks for finding that! Fixed in ed51eccd50b960f6a132488545919737e5a9e14d\n. Yeah I agree. Same as #60.\nWe should also have:\nfunc curry<A, B, C>(f: (A, B) -> C, a: A) -> B -> C\nI can add them soon. We can have all of them with overloading. \nSwift should consider all functions to take 1 argument :/\n. @akuraru @pthariensflame I think for functions we are going to use to compose point-free functions, we can provide a couple of overloaded versions. This proved useful in writing a point-free list reverse.\n. Yeah, I'm not sold that we should have to do this though.\n. Yeah, I'm still thinking about what to do. It seems we need to add error catching to be a \"feature-full\" future. The other thing to consider is, it would be great if we could use framework specific library extensions such as from https://github.com/mxcl/PromiseKit. We want to keep swiftz general, but allow importing framework specific functionality.\n. Yeah, van-Laarhoven lenses are not going to be possible / useful until we get * -> *. I'm pretty happy with the representation in the PR, it will work for a lot of problems. :+1:\n. :+1: \n. These are all good ways to include the framework into a project. Another approach you may consider due to the early stages of development swiftz is in, is to use a source dependency. For an example on how to do this, see https://github.com/ReactiveCocoa/ReactiveCocoa/commit/c47558730b98d90196dec3504ae3541fa4952e7c\n. Let us know if there are any other problems. Things will be a bit rough until the end of the beta.\n. Yeah I'm pretty happy to merge this! :+1:\n. @CodaFi I just gave it a try, can't work it out either. That is strange. \nEither way, I've removed the named params from the inits to save us some typing. cf3855f97dfef0612588348c5656d695ba00475e\n. Thank you!\n. I'm just thinking, would it be more useful if we put these functions in global scope and take an array as an argument for now, instead of as an extension? Then when it is fixed, we move them back into an extension.\n. Looks great to me! Thanks a lot. Ok to merge whenever :smile: \n. @maxcan yeah, but sometimes it is useful to provide less general functions that serve the same purpose. With either, the type error you get lets you know it was an Either, not a a : BiFunctor. Also, it could help with type inference. I would merge it.\n. @pthariensflame I think you are discrediting functions too early. Functions provide proofs, and even if evidence is not identity, so long as it is a real function it can carry some proof of equivalence.\nNot to say I wouldn't like a real GADT type equality in swift, that just doesn't work yet. \n. @pthariensflame I think this representation is better https://github.com/maxpow4h/swiftz/commit/ef76e39b33e6e15af95e8c20d01894d7c539d4fc#diff-a4dcb30b1452bd198ad7e9d82df8ee78R11\nBut it triggers a (known) bug in the compiler.\nA valid (and useful) representation would be like http://en.cppreference.com/w/cpp/types/is_same but that requires function specialisation, which will probably trigger the same bug as above.\nSo for now, this representation is good because it works. But I would like to find another representation that works, or wait till things get fixed.\n. Just to double check, did you mean this instead:\njson\n[\n   {\"post\": { \"title\": \"foo\", \"body\": \"...\" }},\n   {\"post\": { \"title\": \"foo\", \"body\": \"...\" }},\n   {\"post\": { \"title\": \"foo\", \"body\": \"...\" }}\n]\n. Yeah, so that is how I would do it, match on the d value then construct a value. (This is the representation I used for generics in argonaut).\nInitially, it would seem limiting that all the values have to be the same type. However, this is a feature and helps us!\nYou can switch on the d to see if it is a d[\"post\"] or a d[\"reblog\"] or a d[\"comment\"], then construct a Post type. However, the definition of a Post should be:\nswift\nenum Post {\n  case BlogPost(title: String, body: String)\n  case Reblog(blogPost: Post, time: DateTime)\n  case Comment(parent: Post, body: String)\n}\nNow everything is of type Post, and you have a product of different Posts (cases in the enum). Less bugs. No reflection.\n:)\n. Wow, great work! :smile: \n. Thanks, but I also tidied up some strange xcode duplicate lines.\n. I'm going to review this first.\n. Well done everyone! Merged! Let me know if you spot anything out of place.\nThat's pretty awesome, we should be able to make JSON / XML lens traversals now. Composing this with a HTTP lib (:wink:) with a lens API like wreq should let us compose anything.\n. Yeah, so we could change it, but we do get the right type errors if you use the wrong one. You can't bitshift a functor-ish type.\n. Ok, I'm down for >>-.\n. :sparkles: Fixed :sparkles:\n. Awesome, useful stuff. But where did find go?\n. Was join fixed this beta? Last beta I was getting segfaults.\n. Merge away! :smile: \n. :+1: \n. If there is one thing we need, it is more documentation.\n. Awesome stuff! I'm merging the other PR now.\n. Yeah, anyone know how to add one?\n. Thanks.\n. Perfect! Thank you :smile: \n. Finally got a chance to look at everything.\nYup, this is awesome.\nWe should probably add some tests to demonstrate how to use it (and update the README one day...).\nI'm curious how \"do-notation\" would work :open_mouth: \nFinally, we will probably want to use some code generation to build a lifted base of IO functions.\n. Done done done! Awesome work! :+1: \n. Yeah thanks, my bad. \n. Thanks!\n. This is too big to merge. I'm going to do a subtree split on swiftz_core and we can work on them individually. \n. Yeah, sure thing. Also in swift you can choose to only import parts of a module, that might help but I'm not sure if in this exact case.\n. @andymatuschak Check out page 978 of The Swift Programming Language ebook. \n. @andymatuschak @lsavino \nI've updated my code generator to use the new type names (and published the cgi program http://maxs.mobi/cgi-bin/swift-gen-cloud). Hopefully that will be better than writing those JSON instances manually. It is missing some types though (and the error messages are cryptic). Let me know what problems you encounter.\n. Thanks a lot! Works for me too.\nI've removed that swiftCheck call too.\n. Yeah, we should really have a blog post or something explaining that.\n. I don't think member is useful. What do you think?\n. very cool!\n. Do you want to put this into a new swiftz/Box.swift? I've got a feeling this is going to be useful when I implement Tree.\n. I think we should just call it head and tail. If we want a fast head that could crash, we can call it unsafeHead. :)\n. My old code:\nParty.lpartyHost().modify(party, { User.luserName().set($0, \"Max\") })\nis now equivalent to:\n(Party.lpartyHost() \u2022 User.luserName()).set(party, \"Max\")\nOr even:\nhostnameLens.set(party, \"Max\")\n(But don't use hostnameLens, because the struct / class bug doesn't go off then.)\n:smile: :boom: \n. Cool, I didn't know about that. I will file a radar suggesting that list should be expanded. Thanks. :smiley: \n. I think this line is meant to be deleted. Same as a bit further down. \n. Why not use result() instead of sig?\n. I'm not so sure about the Future.init anymore.\nShouldn't you write instead:\nhs\nmv <- newEmptyMVar\nnewFuture $ runSomeAsyncLibFunctionWithCallback $ \\r -> putMVar a r\nfmap mv $ \\result -> ...\n. Interesting, I didn't know about this promise pattern.\nI would suggest using a Future and MVar. We can add a function that conveniently wraps this pattern.\nI will also be removing the empty init from future to more closely represent a Future async package.\n. ",
    "tonymorris": "The test is whether you can write a function that works on all functors, without repetition.\ne.g.\n(<$) ::\n  Functor f =>\n  a\n  -> f b\n  -> f a\na <$ b = \n  const a <$> b\n. List is to NEL as Monoid is to Semigroup so they should all be separated as in #2\n. data NonEmptyList a = NEL a [a]\n. ",
    "jonsterling": "This actually sounds a lot more harmful than not writing it; it's not just boilerplate, it's more problematic than that.\nAnd it's still not clear that the (f b) part can be expressed at all.\nSent from my iPhone\n\nOn Jun 2, 2014, at 5:17 PM, Maxwell Swadling notifications@github.com wrote:\nWith these 2 problems:\nNo implicit resolution of instances.\nNo kinds.\nI propose explicitly providing FA and FB and writing lots of code.\nAlternatively, in xsharpx and functional java, you just write map on everything and don't inherit.\nI'm not sure what is the best approach. Ideas?\n\u2014\nReply to this email directly or view it on GitHub.\n. Yeah... Until the problems with the language get fixed, I think we should remove Functor as well as any other thing which depends on faked higher-kinded quantification. As implemented, they are not even typesafe, and are probably more harmful than helpful.\n. @cartazio +1, agreed. Though I also don't quite know how namespacing works in Swift.\n. Likewise, >> is little confusing, since it is expected to mean m a -> m b -> m b for a Monad. Just my 2c; it's not really clear to me that an operator is needed for these things (put and take or some variant of those sounds fine to me).\n. Hm, this is an interesting hack. It's so weird though, I'm not sure it's worth shipping it! Perhaps we should just wait for higher-kinded quantification.\n. @maxpow4h I was not aware that prisms were injections?\n\n[Sorry folks, pressed the wrong button there!]\n. There seems to be a much more fundamental problem with this definition beyond the bug in the typechecker: You've essentially defined equality of types S,T to be witnessed by a single function S -> T. By this definition, every type is equal to any pointed type.\nswift\nstruct UtterlyBroken<T> : TypeEquality {\n    typealias A = T\n    typealias B = String\n    func coe(a: A) -> B {\n        return \"Welp\";\n    }\n}\nIt is not clear to me that a TypeEquality type can be expressed in Swift, since it would seem that at the very least you would need to be able to be polymorphic over type constructors to achieve Leibniz equality, which is not presently possible. I suggest that things like this which are presently not possible be avoided, since it seems more harmful than helpful to cloak incorrect definitions in the trust-inducing vocabulary of Type Theory.\n. Seems to me that a much better solution would be to wait until we've got higher-kinded quantification and then just give leibniz equality...\n. ",
    "joshvera": "I think our best hope is to file radars. The developers have acknowledged this and it seems like they'd be open to making these changes.\n. :pray: \n. :package: Let me know if there's anything I can clean up or add.\n. :gift_heart: How's that?\n. ",
    "cobbal": "Using unit types as associated types for ensuring the same functor, I've managed to get something working. There are some weird looking casts, but I think it's actually safe(ish, assuming convention is followed for U).\nprotocol Functor {\n    typealias A\n    typealias U\n    class func fmap<FA : Functor where FA.U == U>(f : FA.A -> A, _ a : FA) -> Self\n}\nextension Array : Functor {\n    typealias A = T\n    typealias U = Array<()>\n    static func fmap<FA : Functor where FA.U == U>(f : FA.A -> A, _ a : FA) -> Array {\n        return (a as FA.A[]).map(f)\n    }\n}\nI'm not quite sure if this is any better than the currently attempted ways at doing it though. Anyone smarter than me have thoughts on it?\n. ",
    "CodaFi": "Because the general case is impossible, we have settled for a middle ground of brute force and explicit typealiases with more ceremonial than literal meaning.  \nWith the bitterness of disappointment in my tools, I will be closing this.\n. If you're still interested in doing this, I'd be happy to look over anything you submit.\n. It's been about a year since this was first opened.  The idea is still interesting and a great thing to have.  Reopen this if you ever get around to porting that kit.\n. Looks like Dictionaries have been made Equatable in a more recent release of Swift.\nClosing this.\n. @ejenk Given we're now at 1.1, I don't have high hopes for us getting multi-parameter typeclasses, and even less for the chance you'll get any kind of verification of rules.  There's serious language limitations standing between you and satisfaction that Swift will probably never be able to get over.  You can certainly fake it, and fake it hard, with individual witnesses like Max was saying, but it quickly turns into a Yak shaving competition.\nFor now I will close this issue, but rest assured any breakthroughs or midnight epiphanies means this gets reopened.\n. Advancement of the Data.Lens stuff makes this issue a bit irrelevant at the moment.  Closing.\n. Yeah.  Terrible, really, that all of this still works.\n. The last time I had a crack at this, the problem was if you tried to express something like X : Y, Y : X or X == Y, Y == X, Swift would complain about you having a duplicate type variable -- which is kind of the point, and this is when it doesn't outright crash.  It's disgusting trying to express these kinds of equalities still.\n. The Traversals side of this is causing a lot of headaches.  I need quantification over Applicative things of kind * -> * otherwise I'm stuck unsafeBitCast'ing a solution I neither need nor want.\n. JSON has been moved out of the framework.. Concurrency primitives have been removed from the framework.  Continue all discussion over at TypeLift/Concurrent\n. Thanks!  I'll add a few tests and try to get left/rightMap going again.\n. Alright.  I've given up hope for left/rightMap.  Their current definitions type check, but without a Bifunctor instance for any of the raw types it can't be.. well, used.\nWith that, I'm ready to go.\n:sailboat: \n. Thank you kindly.\n. @levinotik #182 has been merged.  Can you try again?\n. Me and @pthariensflame can handle that part.  Open the pull request and we'll sort this out.\n. Done!  Thank you all for the request.  This should make Swiftz more accessible.\n. Oh, it's no problem.  That's entirely my fault for not doing that in the first place.  Swift has quite a bit of trouble accepting the types of these expressions in practice, which makes examples challenging...\n. I've also omitted from this pull request a do-notation function I had put into SwiftCheck.  Any thoughts regarding something like:\ndo_ {\n   // Attempt magic here\n    return IO.pure(x)\n}\n. Thanks!  :smiley: \nIt's actually a really simple definition.\npublic func do_<A>(fn: () -> IO<A>) -> IO<A> {\n    return fn()\n}\nSwift's syntax optimizations get us to the example I gave in the last comment.  I see this being more an opportunity to explicitly set out imperative code instead of actually, you know, desugaring the do-block.  The nice part is that it still does give you lazy effects like you would expect.\nAlso, Swift really, really hates having to unify the type of closures on the right hand side, which I've found are necessary to use bind in a do-like way.\n. Shifted into the Basis.\n. This pull request is not about bloat, it's about deduplication.  I'm just as wary as you are of adding new dependencies, but the basis split is in line with essentially just making Swiftz_core its own separate module.  As for typical Swift programs, I intended the Basis to be about writing functional Swift, and serve as a full-fledged introduction to the concepts of the same.  Any issues of practicality need to be settled later.\nI fully understand the need for a reduced prelude that includes only the bare essentials (and I hope the Basis is/becomes modular enough that individual files can be pulled out on their own for that), but I was always under the impression that Swiftz was not the place for that.  \nI think the division is clear enough to warrant such a change: Link with the Basis is you need data structures, algorithms, and minimal examples of famous typeclassss.  Link with Swiftz for advanced structures, more complex algorithms, and more obscure typeclasses.\n. Sure, this one is easy because the Basis and core are going away soon.  We're going to be gently merging it into Swiftz.  The floor that will replace Swiftz_core will either be LlamaKit or some other repository.  We haven't quite worked that out yet.\nWhat will eventually happen is Swiftz will be split into more focused projects.  You can see that already with the Parallel (soon to be Concurrent) repo.  Eventually there'll be one for serialization, networking, PRNGs, QuickCheck (and possibly a library dedicated to the more esoteric parts of category theory.  You never know :smirk: )\n. How about a wiki page?\n. @liweiz Good thing you brought this up, actually.  I've changed the raison d'\u00eatre for the Basis to be exactly that.  It is a library for exploration and learning rather than expressing idioms (which is what Swiftz is for).  Open your comment as an issue over there.\n. In light of recent restructuring, this issue has become irrelevant.\n. Yeah.  Apparently it was broken when they did allow it.  All of that code has got to go.  Or (WOLOG) we could wrap an optional in a Maybe and extend that.\n. For now, I've dissolved the extensions and made a number of small patches to Swiftz to keep it compatible until the GM is released.  See #111 \n. Alright, Xcode 6.1 is out.  I know @maxpow4h has already greenlighted it, but any other objections @typelift/fp ?\n. Alright,  merging.  Hopefully we can revert this when Swift 1.2 comes around.\n:boat: \n. Ping @typelift/fp?  I feel weird merging my own PR without comments.\n. This has been open for too long.  I'm going to bite the bullet and merge this now.\nThanks for taking a look @tLewisII \n. First of all, thank you.\nI understand the cata change, but the projection functions don't seem very useful to me as case analysis is a more general and clean abstraction.  Maybe it would be more useful to think about this the other way and add a toLeft and toRight to Optional.\n. If you could give a nice upstream pull for me, that'd be great.\n. I've pushed to master with some fixes and Travis integration so I'd like to get each of the open pull requests run through Travis before a merge from now on.  To do that, you need to push a commit, and I figure pulling from upstream (here) and merging would kill two birds with one stone.\n. :+1: Now about those projection functions...\n. Actually, I think the cata stuff you did means you can keep this open.  I'll definitely merge that stuff if you decide to resubmit.\n. :sailboat:\nThanks again!\n. First, can I get you to run a clean (\u2318+\u21e7+\u2325+K).  Then rebuild\n. It's weird you would say that.  I've got four buildable schemes and all of them test just fine.  In fact, even Travis can see them and is giving us the all clear.  What happens when you add a copy files phase to the test schemes, set the path to \"frameworks\", and add the appropriate swiftz_core?\n. If you want to use it in an Application, you'll need to do the following:\n- Add the appropriate Swiftz.xcodeproj as a subproject by dragging it into the file tree just below your own project.\n- Select your application's entry in the file tree\n- Select the \"Build Phases\" tab\n- Expand \"Target Dependencies\".  Click the +.  In the resulting dialog, select the appropriate Swiftz or Core\n- Click the small plus just above \"Target Dependencies\"; Select \"New Copy Files Phase\"\n- Change its path to point to \"frameworks\"\n- Expand the new phase, click the +.  Select the appropriate Swiftz or Core.\n. Did you drag in the workspace or the xcodeproj?  The workspace is where we keep both projects as a convenience, but each individual xcodeproj is what you should probably be using here.\nIf you did, it's because Xcode will not allow you to have the same project open in more than one window.  Submodules included.  sigh .  Close both windows, then reopen your project.\n. Frameworks, please.  The dyld will thank me later.\n. Go under your project's \"Build Settings\" tab, search for \"Embedded content contains\"\nYou should see \"Embedded content contains Swift Code\" No  Change it to Yes\n. Okay.  I've come at this fresh with a sample project of my own.  Here's the revised steps I'm considering submitting to a new README:\nAdding Swiftz to a Project\n\nClone swiftz into the directory of your choice.\nDrag and drop swiftz.xcodeproj into your application's Xcode project or workspace.\nAdd swiftz to the \"Target Dependencies\" phase of your project.\nUnder the Build Phases tab, add swiftz to the \"Link Binary with Libraries\" phase.\n   5a. Add swiftz.framework to the \"Copy Files\" phase.\nIf you do not have a \"Copy Files phase\", select the + at the top left and add one.\nMake sure the Destination field is set to Frameworks.\n     5b. Add swiftz_core.framework to the \"Copy Files\" phase.\nUnder \"Other Code Signing Flags\" in the Build Settings tab, make sure --deep is set.\n\nWith these instructions I can get any number of applications up and running from Xcode's default templates.  If you'd like I can send you a working project of mine to see if it isn't just on your end.\n. You can't bundle frameworks and dylibs with command line tools.  You need a static library for that, and our hands are tied on that front by the language.\n. We may be spinning forever in the ArrayLiteralConvertible constructor.  Gimme a sec to check.\n. Welp, that was the weirdest debugging session ever.  You're absolutely right about it being the runtime that hangs.  I'm filing a radar I have filed a radar for that problem (rdar://18903483), in the meantime #120 should do right by you.\n. I wasn't around when it was first written, but that sounds about right.  Recursive enums were always trouble, but I've never seen this before.\n. Alright, then. \nIf you have anymore questions, don't hesitate to open another issue.\n. If it's all the same, I would prefer something easier to type like elm's <| which I can see has been commented out for quite some time.  It's a stable operator at this point, just needs some patched up generics.\n. Data flows towards bindings, not towards ; as in C.\nlet y = f <| g <| h x\n<|, $, and \u2022 can be read as \"after\".  At least, that's how I always hear it in my head.\n. Travis is happy and so am I.\nThanks!\n. OK.  If I've done this correctly, the only thing that should break are the bifunctor instances (which nobody is using anyways).  \n@typelift/fp We good to go?\n. Don't worry, I promise to revert everything to structs and protocols the second they give us parametrizable protocols (:pray:).  That's what this is trying to emulate anyhow.\n. I'm gonna give this 24 hours more.  Speak now or forever hold your peace.\n. \n:boat: \n. I'll tag 0.1.0 once #164 is merged and any post-cleanup has happened.  By then, this issue will also go away because all open pull requests solve it.\n. Resolved completely by #149 \n. Looking at it now, I think the types in its definition might be wrong.  I need to have \"Kinds\" merged before it goes any further, though.\n. OK, now that that's over I looked at making a Comonad over in typelift/Basis#5 and we definitely have some type signature issues in that module.  It might also be interesting to discuss whether or not Copointed is a necessary intermediary for Functor and Comonad.\n. Oh.  Sharp eyes, man.  Thanks!\n. Thank you!\nI've been meaning to do this for quite some time.  If you see anything else in typelift that does this, don't hesitate to open the same kind of pull request.\n:boat: \n. It's not a compiler error, our type signature for flip is weird.  I think\nflipSubtract(a: 5, b: 3)\nshould do it.\nIf you want to curry that thing for real this time and submit a pull request, I'd be happy to merge it.\n. When you use Swift's currying syntax you're not allowed to elide names with _ like that anymore.\n. Resolved by our discussion here and in #124 \n. Thanks, much.\n:boat: \n. So it has come to pass.\n:boat: \n. We need a more serious discussion of switch-case alignment and whitespace control.  I am firmly against Swift's aligning the switch and case labels and often inlining the return value.  It's too hard to read the cases and make a clear distinction or see what that particular case actually does.  I've seen a number of opinions even in our own codebase which I've tried to enumerate here with pros and cons:\nThe Collapso\nswift\nswitch self {\ncase let Error(e): return .Left(Box(e))\ncase let Value(v): return Either.Right(Box(v.value))\n}\nPros:\n- It's incredibly concise and matches the Swift Book most closely.\nCons\n- I cannot differentiate the cases as easily.\n- { has always meant the next line is indented in C-like languages.\nThe Mambo\nswift\nswitch self {\n    case let Error(e): return .Left(Box(e))\n    case let Value(v): return Either.Right(Box(v.value))\n}\nPros\n- Concise and more readable than The Collapso\nCons\n- Uses slightly more whitespace (Pro?).\n- It is harder to see the return value of each case.\nThe Line Dance\nswift\nswitch self {\n    case let Error(e): \n    return .Left(Box(e))\n    case let Value(v): \n    return Either.Right(Box(v.value))\n}\nPros\n- Easy to read each case and return value.\n- Less horizontal whitespace.\nCons\n- Uses much more vertical whitespace.\n- Too easy to read; cannot differentiate case and return.\nThe Rumba\nswift\nswitch self {\n    case let Error(e): \n        return .Left(Box(e))\n    case let Value(v): \n        return Either.Right(Box(v.value))\n}\nPros\n- (IMO) The most readable\nCons\n- Uses the most vertical and slightly less horizontal whitespace than all others.\n. You have such high expectations of what Xcode can do my friend.   clang-format should support swift soon, but I did all this with unexpand and a little bash.\n. @sharplet That's a great compromise.\n@pthariensflame Yeah, I'm not sure I want to see returns outdented like that either.\n. Well, I'm split between the tango and the rumba.  For our purposes, the former is more readable, but the latter makes more sense because it matches the style given in the Swift book.\n. In the interest of making a decision, I've decided to dance @sharplet's Tango.  We can revisit this later, but for now it's blocking some pull requests.\n. Well my fear is, because Swift's operator overloading is whitespace based, that we could create some potentially confusing situations.  Like how my example now makes\nswift\n10 +5\na type error.\n\nIn retrospect that's probably a feature, not a bug.\n. Absolutely, yeah.  I think this belongs in the full framework anyhow which speaks to your point about conditional imports. \nWell, the last thing I have to say is that it will be an incredibly tedious task converting each of the operators in the STL (I assume they've explicitly specialized the arithmetic operators to better enable optimizations).   Our own should be fairly easy.\n. Bump #167.\n. Almost fixed by #231\n. \n. The big issue (h/t @robrix) is that it overlaps with a few of the operators the STL defines.  Notably, this makes prefix-minus ambiguous.  My thinking is that it's not such a big deal because if you mean -1 as a number or a function, you usually inline it and let the type checker do its job.\n. You know, that's not a half bad idea.  It certainly gets rid of the ambiguities.\n. You know, I'm thinking we just pull a Haskell 98 and forbid the right section of minus.\n. So it has come to pass.  The last thing I'm worried about is the comparisons and equality operators.  I purposely left out any operator with an = in it because I'm not entirely sure how to curry some of them or what purpose they would serve (what does it mean to &= across a collection of booleans?).  On top of that the compiler doesn't like it when I define prefix-< for some reason.\n. Okay.  I'll left-section the assignment operators and file a radar (rdar://19081384) about the comparisons.\n. Done\nOkay, hit a snag with the assignment operators.  In order to do them we need by-ref capture of inout variables + closures.  The closure takes its own copy of the variable (still by reference, but not our reference), and updates are no longer visible to the outer var.  To solve this we'd need... First class mutable cells, which kinda defeats the purpose of sectioning specific operators anyways.  I can at least push the equality operators now.\n. That should be the last of em'\n. If you don't want to do all that crap by hand, here's my first go at sectioning assignments.\n. Alrighty then.  I think half a month is time enough.\n:shipit: \n. After thinking this over, I believe the premise for this issue was valid but the vision is wrong.  We can give meaningful names to the parameters of the functions we leave uncurried, and perhaps find new names for things along the way to make using this library very natural and Swift-y. We should stand in sharp contrast to the fully-curried Basis where only combinator names indicate intention.\nAs such, I've made this and documentation a priority for our next dot release.\n. Bumped this back to 0.3.0\n. @pthariensflame Any other thoughts on this?\n. Down it goes, then.\n:ship: \n. :boat: \n. Nice catch.\nAt this point I have a feeling the liftN functions are being left out because of the amount of work it would take to write ~5 for each of the monad instances we have.  That said, if you're up for it, feel free to submit a pull request.\n. Fixed by the merge of #249.\n. 6.1.1 seems to do the trick just fine.  Our cartfile would be empty anyhow, so all you'd need to do is touch it.\n. @jspahrsummers Good to know!  I still want to get a clean version tagged before anything happens.\n. A quick question though: Is there any way to tag the Core and Swiftz as separate entities to carthage or do we need to follow through with #142?\n. Thanks! :sparkles:\nI'm gonna need you to do one more good upstream pull before I can review this.  Quite a bit has changed since the commit you're working on top of.\n. There's another conversion down on line 48 that probably shouldn't be there either.\n. Danke Sch\u00f6n\n. Fingers crossed.\n. Fixed by #148 \n. I did find quite the passionate discussion between you and Tony once while doing a bit of research.  IIRC his thing was that Copointed was being applied to too many types to force values rather than actually, you know, copointed things.\n. Exactly!  Well, how about this other sneaky issue of Copointed being a subclass of Functor.  It seems Edward Kmett has taken it upon himself to divorce the two citing a free theorem from fmap and copoint (much the same reasoning for throwing out Pointed).  I think as long as we're playing fast and loose with the law anyhow it's fine, but there's quite a few more instances I could cook up if Copointed weren't a Functor.\n. This pull request now depends on #144.\n. Ugh.  Soooo many weird linker bugs still reside in Swiftc.\n. @pthariensflame  Ready for Review\n. No.  I'm going to leave the Basis around as an exploration of pure declarative programming in Swift rather than just FP idioms like we're doing here.  I will mark it as such.  The code it produces is horrendously inefficient but tremendously beautiful.  Such a creature cannot be allowed to ship...\nThe Core at this point is Box, Result, Either, List, the operator sections, and some combinators and I would like to see it removed from Swiftz so we can focus on higher abstractions and instances instead of rudimentary data structures.\n. Reminds me too much of my poor Swift-Extras :)\nSpitballing Here:\n- LambdaKit\n- CoreFP\n- SwiftPlus\n- Abstraction\n- TypeKit\n- Prelude\n- STLExt\n- LiftKit\n. Or \n- AirLift\n- LiftedSwift\n- BaseLift\n- TypeLiftCore\n- Skyline\n- CoreData /s\n. @gfontenot :smiling_imp: \n@pthariensflame \nThis is tough... I'd prefer we follow both the Swift and Cocoa framework naming conventions.  Cocoa necessitates expanding acronyms and either ending with -Kit, or beginning with Core.  Swift prefers concrete nouns.  That means either TypeLiftKit (which implies we're sticking all the work of the org in one place), or some other noun that truly encapsulates what it means to cram a bunch of foundational data types into a lib -without calling it Foundation :P.\n. OK.  Let's a least offer 3 of our favorites so we can narrow the field.  No decisions yet:\nFor me it's\n- AirLift\n- TLKit\n- LiftKit\n. @pthariensflame Do you have two more suggestions picked out?\n. CoreFP maybe (punning CoreFoundation)... I'm starting to warm to that kind of name.\n+1 SwiftX too.  Implies we're just extending the STL rather than throwing in a bunch of new stuff like Swiftz does.\n. :bulb: How about a different stylization of SwiftX?  As in Swiftx.  If you want full Swiftz, you just move over a key :)\n. Then.\nTonight's the night.\n. Finished.\n. Fixed by the merge of #249.\n. I have a feeling we need to go fully recursive for a lot of these combinators (or use a lazier iterator).\n. :bulb: What if we cache length in the Cons case for O(1) access?  Infinite lists have a count of -1 internally and throw an exception when we try to take their length.  Infinite lengths propagate through appends or additional cons'es. \n. I'm quite happy with this right now.\nReady for review @pthariensflame \n. You never have to apologize for that kind of thing!  As long as I've got the greenlight, then :boat: so I can push more stuff through and hit 0.1.0 hard. \n. :boat: \n. If there are no objections, by the power vested in me by the Internet, I now pronounce this marriage...\nannulled!\n:hocho: \n. Thanks for the patch!\nThe only thing left to do is turn those spaces to tabs and I'll merge.\n:sparkles: \n. Beautiful.  I'll let Travis chew on it, then :ship: \n. :fireworks: :boat: :fireworks: \nThanks again!  Happy holidays and a great New Year.\n. I still can't believe the types still works with the protocols we have, but\n:boat: \n. @typelift/fp This is a long-term project here.  Any thoughts at all are welcome.\n. This is the final issue keeping us from 0.1.0.  Let's knock it out and put out a good clean release. \n. For now, I think I've written enough examples.\nReady for review.\n. I think it's good now. \n\n. Onward to v0.1.0!\n:boat: \n. I held off on the lens hierarchy out of respect.  Is there anything you would like me to focus on documenting it?\n. Then merge I shall.\n:boat: \n. I think Max flipped fmap to better align with Swift's \"syntax optimizations\" for closures.  I agree it's confusing, but it's still Functorial.\n. Bind is in its \"natural order\" with the monad in the left and the function on the right, as in\nswift\nMaybe.some(5) >>- { Maybe.some($0 + 5) }\nMaybe.some(5).bind { Maybe.some($0 + 5) }\nFmap, not so much:\nswift\nMaybe.some(5) <^> (+5) // currently\n(+5) <$> Maybe.some(5) // \"correctly\"\nMaybe.some(5).fmap(+5)\n. (<^> and <$> are the same thing.  I'm showing you how you'd like it in Swift versus Haskell).\nBut yes, it makes it very awkward for Fmap.  I believe we sectioned the operator, so it's possible to compose with it the way you might be used to\nswift\n(f <^>) \u2022 (g <^>) = ((f \u2022 g) <^>)\nI can't do anything about the function fmap in our Functor protocol.  It's the backwards one here.\n. I think the confusion here is where each function is applicable and what each does.  Bind is defined for all Monads, but only some Functors.  Bind is also inherently sequential composition, so it makes total sense to write equations from monad left to function chain right and see them evaluated as such. \nFmap is a generalization of map for Functors.  It takes a function first and applies it to the contents of a Functor because map takes a function first and a list second.  The important thing to remember here is fmap is not compositional by default.  It needs \u2022 in order to have coherence laws, so it makes more sense for it to appear \"out of order\".  \nReally, bind is the backwards one here.  It's written to allow imperative looking code (left to right) instead of the normal equational looking code (right to left).\n. Bind is meant to be non-traditional to enable do-notation.  We should not be consistent between the two operators because they are built for vastly different generalizations of structures with different purposes.  Besides, if you flip bind backwards, you get a new operator -<<.  If you flip fmap you get fmap.\n. We wish to enable declarative-looking code.  Imperative-looking code is easy enough to do without this framework.\n. Remember, fmap is not meant to be compositional. Fmap is map.  You can compose maps together, but you need a composition operator.  Bind is Kleisli Composition in an operator.  \nTry to run your example through GHCI.\n. Compositional means the whole \"chaining them together\" thing.  Not every function is meant to mesh together (because types!) with ease because not every function is built with that in mind.  Of the big three typeclasses (Functor, Applicative, and Monad), only the last has compositional operators for a specific kind of semantics.  For everything else there's \u2022.\n. OK, let's try this again now that I've found a proper computer instead of my old iPhone:\n\nIs there a reason why <^> and >>- don't take their args in the same order? Should one of them be switched (eg <^>) or do you recommend using the map method directly in that case?\n\n<^> is a synonym for fmap, or a Functorial Map\nhaskell\nfmap :: (a -> b) -> f a -> f b\nAs such the map is the most important part of the signature.  The map is the reason the word Functor was stolen from the Category Theorists.  The map is the point of us stealing it from Haskell.  While it may be a combinator, it is not compositional, in that its coherence laws require the presence of a real composition operator like \u2022\nhaskell\nfmap (f \u2022 g)  ==  fmap f \u2022 fmap g\nOne does not compose Functors with fmap without \u2022 just as one does not compose functions without \u2022 because it just doesn't work.\nMonads, on the other hand, were built with sequencing in mind rather than the proper coherence laws implied by their unit triangle.  Haskellers quickly realized that sequential composition could be made to look highly imperative, and so introduced do-notation which desugared into >>= and >>\nhaskell\nmain :: IO ()\nmain = do\n  putStrLn \"Phlakaton!\"\n  args <- getArgs\n  putStrLn $ show args\n  return ()\n\nhaskell\nmain :: IO ()\nmain = putStrLn \"Phlakaton!\" >> getArgs >>= { \\args -> putStrLn $ show args } >> return ()\nBut in doing so, they had to \"flip\" the traditional right-to-left evaluation semantics, otherwise you'd be reading do-notation from bottom to top.\nIn keeping with tradition, we have left <^> and >>= in the order implied by their semantics, rather than the order that would be most convenient for a certain person (mostly because we also supply the combinators flip and \u2022).  While it may seem that the two are \"opposite\", the comparison is what's really at fault here.\n. The practical reason not to flip it is we provide it flipped in the Functor Typeclass, and we provide the combinator flip ;)\n. @refried  Any further input, or has this thread run its course?\n. Then let's start over.\nRestate the question and I'll try to reply more in-depth this time.\n. UserExample.swift has a pretty good example of using <^>\nSwift\npublic class func fromJSON(x: JSONValue) -> User? {\n    var n: String?\n    var a: Int?\n    var t: [String]?\n    var r: Dictionary<String, String>?\n    switch x {\n    case let .JSONObject(d):\n        n = d[\"name\"]   >>- JString.fromJSON\n        a = d[\"age\"]    >>- JInt.fromJSON\n        t = d[\"tweets\"] >>- JArray<String, JString>.fromJSON\n        r = d[\"attrs\"]  >>- JDictionary<String, JString>.fromJSON\n        // alternatively, if n && a && t... { return User(n!, a!, ...\n        return (User.create <^> n <*> a <*> t <*> r)\n    default:\n        return .None\n    }\n}\nIf you're asking for something like fmap \u2022 fmap \u2022 fmap I'll refer you here.\n. The reason I continue to bring up Haskell is that as a language it has a beautiful and straightforward approach to laying out the kinds of abstractions we're using here.  Our work stems from that, and our semantics does the same.\n. This is one of those cases where semantics transcends language boundaries.\n\nBut an example in Swift is an easy thing to produce.  The interpretation of a Functor that we take (because we're restricted to the Category of Swift Types- hereafter $) is an Endofunctor- or a Functor that maps the same domain to the same range ($ -> $).  The members of the category $ are any valid Swift structure, protocol, and class, the arrows are the free and member functions that map them between each other.  Because we're restricted to Endomorphic behaviour, our fmap must take Functors over one Swift type to Functors over other Swift types.  Such a function looks like this:\nswift\nfunc fmap<T, U>(f : T -> U, fun : Functor<T>) -> Functor<U>\nwhich is curried as:\nswift\nfunc fmap<T, U>(f : T -> U) -> Functor<T> -> Functor<U>\n\nIs there a reason why <^> and >>- don't take their args in the same order? Should one of them be switched (eg <^>)\n\nTake a look at that type signature one more time.  \nswift\n(T -> U) -> F<T> -> F<U>\nNotice anything special about the last half of the function?\nswift\n(T -> U) -> (F<T> -> F<U>)\nfmap is lifting a function to a function over Functors.  It is not binding data, it's lifting functions.  The function is the most important part of the type signature, and so we keep it as such.  If we flip the types around we get:\nswift\nF<T> -> (T -> U) -> F<U>\nThis appears to be nothing important.  It's certainly convenient, but we lose the meaning behind fmap.\n\n\nThanks -- that is certainly a different use case than I expected: producing a partially applied lifted function. Is that the expected use case?\n\nYes and no.  Yes in the sense of the wall of text I just posted.  No in the sense that because we can't actually use Functors in general because of Swift's type system, we instead use the protocol Functor to mark structures that can map themselves over to different types.  We define a large amount of those structures that perhaps overload Functor to perform a little more than lifting (JSON stuff mostly).  Ultimately they all accomplish the same thing: Lifting a function to a function over a Functor.\n. I'm a chronic overthinker :(\nIf you think of a way to reformulate this question, reopen this issue.\n. > I read your answer again this morning, just wanted to add a quick note to say that even though I don't feel that it answers my question, it was informative and interesting. So thanks for now! \nYou're very welcome.  I'm terribly sorry I'm incapable of grokking your question right now.  I don't want this to wind up as a situation where you get turned off by jargon, or feel like FP means I can't help you.  You're absolutely \"smart enough\" to ask questions around here!\n\n\nIf you flip the types around, you get:\nF -> (A -> B) -> (B -> C) -> ... -> (Y -> Z) -> F\nHow would you do that instead now? Thanks!\n\nShort Answer: \nswift\nflip(<^>)\nLong Answer: \nBy virtue of our definition of Functor we already give you an fmap that looks like\n``` swift\nF -> (A -> B) -> F\npublic protocol Functor {\n    /// ...\n    /// Map a function over the value encapsulated by the Functor.\n    func fmap(f : A -> B) -> FB\n}\n```\nThough it may not look like it, Every member function in Swift actually looks like this internally:\n``` swift\nstruct Foo : Functor {\n    func fmap(f : A -> B) -> Foo { // do stuff }\n}\nfmap : Foo -> (A -> B) -> Foo\n```\nbut you have to invoke it statically (Foo<A>.fmap rather than Foo<A>().fmap) to see that.  By yet another virtue, this time of the language, . to invoke functions can be used to compose fmaps rather than \u2022 like function composition, albeit backwards.\n\nYou has previously pointed out that\n(f <^>) \u2022 (g <^>) = ((f \u2022 g) <^>)\nbut is there an example in swift?\n\nYes!  I'll show you with the Identity Functor (Box) out of laziness.  Throw this in a playground\n```\n// --------- Prerequisites ----------- //\npublic class K1 {}\ninfix operator \u2022 {}\npublic func \u2022(f: B -> C, g: A -> B) -> A -> C {\n    return { (a: A) -> C in\n        return f(g(a))\n    }\n}\npublic protocol Functor {\n    /// Source\n    typealias A\n    /// Target\n    typealias B\n    /// A Target Functor\n    typealias FB = K1\n/// Map a function over the value encapsulated by the Functor.\nfunc fmap(f : A -> B) -> FB\n\n}\n/// The Identity Functor holds a singular value.\npublic struct Id {\n    private let a : @autoclosure () -> A\npublic init(_ aa : A) {\n    a = aa\n}\n\npublic var runId : A {\n    return a()\n}\n\n}\nextension Id : Functor {\n    public typealias B = Any\npublic func fmap<B>(f : A -> B) -> Id<B> {\n    return (Id<B>(f(self.runId)))\n}\n\n}\n//--------------!!--------------//\nlet id = Id(5)\nlet f : Int -> Int = { x in x + 5 }\nlet g : Int -> String = { x in String(x) }\nlet x = id.fmap(f).fmap(g).runId // String(\"10\")\nlet y = id.fmap(g \u2022 f).runId // String(\"10\")\nx == y // true\n```\n. (Unfortunately for my poor fingers) Yes.  We have to write an fmap for every Functor.\n. :boat: \n. h/t @vendethiel\n:boat: \n. The same thing is happening with the Basis.  Something about the testing bundle (I suspect codesigning) is causing xcodebuild to crap out.  Weird that both cases work with Travis but not that\n. Before we do this, if you want to rename the target we had best do it here and now.  Perhaps capital Swiftz?\n. Seems only one of the targets got a name change.  No matter.  We can sort this out later when I get around to part 2 or #116.\n. That is to say :boat:\n. I see one Box def in this entire repository, and while it may live in the Core directory I thought I removed the core as a dependency and just included the files anyway so you wouldn't have to link both libraries.\n. Bump #149 \n. Fixed by #149\n. :boat: \n. I use <%> in the basis because it was the closest thing to <$> on the keyboard.  I wonder what other languages with Applicative Functors do.\n. As an aside: we really should radar for the use of $ in operator identifiers.  It's ridiculous that the language designers get to have it all to themselves just because they use it for one feature.\nDupe'able at rdar://19528489\n. This thread should be moved into typelift/Operadics.  I'm going to close it here.  If there's any interest reopen it over there.\n. :boat: \n. I am actually worried about how this interacts with Carthage.  When it builds frameworks in workspaces, do the individual projects get their own directory?  Worst case scenario: xcodebuild dumps both frameworks into the same directory and bad things happen\u2122 \n. Also, I'd like to intercalate this with the solution to #142. Ideally we\n- Rename Swiftz_Core\n- Perform a Subtree Split\n- Fix the workspace(s)\n. I say that because the Basis appears to only be building the Mac target for some reason.  I'll investigate a bit after the subtree split.\n. Closing; #164 \n. :boat: \n. \n:boat: \n. \nReady for review.\n. Lucky for you the changes are entirely cosmetic.  Just want you to make sure I didn't Bork the transition (like how this didn't work for the past zillion commits because git's \"you renamed this file\" implementation is case-insensitive-I blame HFS).\n. That's the last uncaught change I can see.  This will go through when Travis gives me the green light.\n. :boat: \n. The deprecation starts in 0.2.1.  Removal in 0.3\n. Step 1 accomplished with the merge of #192.\n. But specifically those variables?  I'm not gonna nuke the header, I just want to know what those things are doing there in the first place.  A traditional framework header is just a bunch of imports and maybe some macros.\n. Okay, I've been informed that the version number variables are entirely unimportant,  and that the imports in the header have no bearing on Swift at all.  We can just keep it empty. \n. @pthariensflame You gonna take this one when you fix the formatting?\n. :boom: :camel: \n. My god, this is beautiful.   Absolutely beautiful.  :+1: \n2 things:\n- Type annotation, colon, and identifier are separated with spaces.  -At least, that's how I like to see it, and Idris throws a fit when you use colons like that....\n- Can you change the Semigroup and Monoid examples in the README?\n. \"All of the formatting\" appears to be in spaces and not tabs :P\n. Dank\u00eb.  I will tag version 0.1.1 shortly after the merge goes through.\n:boat:\n. Tagged. Thanks again for all of this.  I've been wanting to redo Num for a while, and this is like reading my mind :sparkles:\n. :boat: \n. I hope this makes it easier that much easier to knock out #58\nReady for review.\n. Welp, now I'm paranoid.  I'll deal with typos before the next point release.  There's still more I want to do with this before 1.4.\n. Nevertheless, :boat:\n. :boat: \n. Strictly alternating pre-products get tricky with strict languages.\n. Any way to make it find the workspace instead of the projects?\n. Welp, I'll look into making that happen then.\nFor now, I know you're horrendously overbooked on the message front.  Thanks a ton!  :sparkles: \n. Until Carthage supports building workspaces or multi-project repos there's nothing I can see that can be done about this.  The only thing we can do is offer to keep carthage build --no-skip-current working for each target (which is becoming a PITA without Travis).\n. The frameworks have the same product name, which created some interesting errors when I last tried this.  Then again, that was months ago.  Let's see what happens.\n. @jspahrsummers Hmph, this is going swimmingly.  I can't recall a precise reason I starting splitting the project files, but whatever it was is gone now.\nLooking forward to closing this.\n. Yay, everything works again!\nFixed by the merge of #197.\n. That was put there by Xcode 6.4.  I haven't update the podspec because of it (It's release is imminent anyways).  If you'd like to submit a pull request changing it I'd merge it,\n. Give 'er one final carthage update, would ya' please.\n. How about we call this thing a Dither?  As in both \"indecisive\" and \"Di-Either\".\n. Dammit, just thought of Vacilloid.  Oh well, I'll live with the consequences of my bad puns ;)\n :boat: \n. Mmm, yeah.  I know exactly what's happened.  Gimme a few minutes.\n. OK.  Checkout #176 and make sure that's fixed everything for you.\n. When Travis gives me the green light I'll merge it.\nThanks!\n. :boat: \n. :boat: \n. Nice catch!  \nI've left some style notes in comments.\n. Indeed it is.  Thank you kindly for the pull request!\n:boat: \n. :boat: \n. :boat: \n. Okay, I've reached the tail end of these changes for Friday's Merge-Despite-Travis\u2122.  @pthariensflame documentation is sorely lacking all over this thing.  If you have any suggestions (especially for the Lens hierarchy), I'd love to hear them.\n. OK, so any tests involving ArrowOf are not to be trusted at the moment.  Must remember to hold off on asserting those properties until something more concrete is available in SwiftCheck.\n. TONIGHT WE DINE IN HELL\n:boat: \n. Way ahead of you, bro #181 :dash: \n. OK.  6.3 is public today, so we're just waiting on travis-ci/travis-ci#3216\n. I won't go through with a merge until Travis can give us the thumbs up (see the issue).\n. Okay, this is starting to get ridiculous.\nI'm throwing in the towel for now on Travis (a month is too long to hold up features and releases).  #181 will be merged automatically this Friday regardless of our build status at that time.\n. Done!\nFixed by the merge of #181\n. With the renaming of type parameters in the Swift STL the point is now moot.\n. :heart: \n. :boat: \n. Ugh, this again.  Swift has trouble exporting public symbols from extensions on generic classes.  Can you try moving the ArrayLiteralConvertible extension in List.swift to the main struct declaration and recompiling?\n(Hopefully this is fixed in Swift 1.2).\n. Then the last thing I can think of is doing a full clean (SHIFT+OPT+CMD+K) and rebuild.\n. Now that #181 has happened, any updates on this?\n. It has been a month, so I'm closing this due to inactivity.  Reopen it if your concerns are not addressed.\n. Mm, yeah.  I'll open an issue as a reminder (because every other language with typedefs and generics doesn't seem to have a problem with this).\n. OK.  Ready for review.\n. :boat: \n. Thus begins the nitpicking session.\n. Thus endeth the nitpicking session.\nI know I've already said it once, but thank you for your contribution and taking the time to draw up this pull request.\n:boat: \n. You're asking for something that I can't express in Swift.  Lenses into JSON + this stuff requires higher kinded types at a minimum (for Traversals).  We can implement a stopgap, but it seems to me NSJSONSerialization is good for getting the subpart if you don't want to go through bind\nswift\nJSONValue.decode(userjs) >>- { $0[\"user\"] } >>- User.fromJSON\n. It's been 3 months, so I will go ahead and close this\nA lot has changed between now and then, so if you have any updates feel free to open a new issue or reopen this one as appropriate.\n. OK, so we can't match on tuples (plan A), but I at least want to remove boxes from the enum cases.\n. Apparently we can match on tuples, or rather expressions returning tuples https://gist.github.com/jckarter/019f317b669961add5a3\n. Why did you close this?\n. You already closed it, but I have the power to close and reopen these things too, which is what I'd like to do.  If you don't have any more changes to make, I'm going to reopen and merge this.  It's a great change to have.\n. Alright then.  \n:boat: \n. Thank you kindly.\n:boat: \n. With this divorcing from concurrency primitives, you could say we're being left... single-[threaded]! \n:boat: \n. When and if they request it, sure.  But I haven't seen activity from a lot of them in a while (for some of them with good reason).  For now just you and me seems prudent.\n. Also, thank you so much for this change @ikesyo!  Is there a way we can alter Travis to run a build on the CP spec too (not that it matters too much right now)?\n. For now I will declare defeat on reversal.  I need higher-kinded types for any sane implementation and the a generic typealias for a not-so-sane implementation.\nReady for review.\n. Then :boat:\n. Deprecated in #255.  Will be removed very soon.\n. Yes please!\n. Whoa, we fixed this a long time ago.\n. This pull request and subsequent version increment marks strike 2 against the Concurrency primitives.\n. :boat: \n. Character needs a CoArbitrary instance in SwiftCheck before those function specs can be uncommented.\n. OK.  The tests, like, actually run now.]\n@pthariensflame Ready for review.\n. Eyy,\n:boat: \n. They have another structure called XOr that is left biased that might be nice to have, but I have come back to that thread over and over and can't really argue with that after all this time,\n. Dupe of https://github.com/Carthage/Carthage/issues/436\nI don't know what else to tell you, but they seemed to have worked it out.\n. What happens when you manually checkout master and run carthage build --no-skip-current?\n. Despite this being a pathological case, this issue is gonna stay open for now.  If you manage to fix this on your end by fiddling with something we can fix it once and for all.\n. We should have patched that in the latest master if that were the case..\n. This is horribly frustrating (I just reproduced this after an xcode-select).\nFor any who come across this issue, xcode-select the latest beta and pray DevTools doesn't break anything further.\n. @griotspeak Does 6.4 fix any of this?\n. Fixed by Xcode 6.4+\n. OK, I've pushed the podspec to trunk.  Give it a bit and try again.\n. @jdesiloniz The podspec is up so I'm going to close this.  Reopen it if you encounter further issues.\nCheers! :sparkles: \n. I'd love to test Carthage too, but #201 strikes again.\nOh well,\n:boat: \n. @vendethiel You know it!\n:boat: \n. It has been changed in the latest dot releases and not pushed to cocoapods yet (I'm trying to put out a larger release with more bug fixes).  If this is a show stopper I can forgo my plans and push anyway.\n. Looks like my evil plans worked out before you could respond again.\nShould be all patched up now.\n. Oh boy,\n:boat: \n. :boat: \n. This is a very dangerous proposition, now that I think about it.  In Scala and Haskell you have the GC around to clean up most Ptr mistakes.\n. Closing.\n. Our little lens hierarchy and anything with an Ix in it.\n. @pthariensflame I think now is the time to do it, especially with the Swift 2.0 changes going into a new release.  Got a name?  Lens, Optics?\n. Focal.framework has a nice ring to it.\n. RefractiveCocoa :trollface: \n. /cc #216 \n. :warning: Executive decision made :warning:\n216 will be assimilated into Focus.framework\n. :boat: \n. :boat: \n. Done!\n. :boat: \n. :boat: \n. :boat: \n. :boat: \n. :boat: \n. Ninja Edit\n. I'm going to blame autocorrect for all of this.\n:boat: \n. Shit, wrong branch.\n. Welp, now we know what the pull request for swift-develop -> master is going to look like.\n. Eyyy\n:boat: \n. I realize now I made a mistake implementing MonadFix the way I did in the Basis.  The \u03b7-expanded one is probably more appropriate to lift here.\n. Welp, we're back to crashing the compiler again.\n. Alright, this is ready.\n:boat: \n. Got the too-much-compiler-crashing sweats.\n:boat: \n. I'll kill two birds with one stone here: yes, it is redundant.  Every non-static member function of a Swift class or structure actually takes the form Self -> Args ... -> Result, you just get to see the form where self is partially applied in normal use cases.  Your typechecker woes are a direct consequence of this; you can't pass the function part first, you have to pass the self part first.\nUsing this and the fact that we implement fmap [as just map] and you get a function that behaves exactly as you intended (albeit with flipped arguments, but we have combinators for that):\nflip(Array.fmap)(Phrase.init) <^> arbitraryFunctionA()\nAs for your elegance problem, you might try a more Swift-y way of expressing yourself:\nA().map { $0.map(Phase.init) }\nOr a more Swiftz-y way even\ncurry(<^>)(Phrase.init) <^> A()\n. So it is.  Assuming your types are all correct, I'd be willing to bet it can't see your overload of map.  This would make for an interesting bug report.\n. This one will also start the process of removing Maybe from Swiftz.  It is unnecessary now that we can extend Optional\n. :boat: \n. Can do.\n. The difference is Ratio is a fully expanded noun and a concept all on its own, whereas Num is a Haskell-ism we don't necessarily need to keep around.  What other name could there be for a structure of 2 Integral values related by the division operation?\n. Tying this to #230 \n. I'm going to cap this pull request here and stop making changes.  The Fractional hierarchy will come in a later pull request.\nReady for Review.\n. :boat: \n. :boat: \n. :boat: \n. :boat: \n. I'm happy\n:boat: \n. :warning: Don't merge this yet.  There's a weird build error on my end I want to fix first :warning: \n. And with that, she builds.\n:boat: \n. I do eventually, maybe 1 more beta, but that branch is still very very experimental and in a state of flux that's mostly unsuitable for any \"real\" development (outside of TypeLift).  But that's me.  If the group would prefer it, I will back down.\n. Certainly Swiftx is stable enough that I'd feel comfortable doing that there now.\n. I've changed the default in Swiftx for now.  When Swift stabilizes (and stops crashing trying to do trivial things that worked in earlier betas) I'll take this up again.  But by then Swift will probably be out of beta and the issue will have resolved itself with the merging of master and swift-develop.\nThanks all :sparkles: \n. It's totally the submodules.  The pod needs to track swift-develop and the new Operadics module.  The changes should be few enough you could probably make them yourself and submit a pull request.\n. That looks like it's something got lost in the Swiftx split.  How it builds on my end I'll never know.  Let me see what I can do.\n. OK, so I was going through the source of the thing and I don't think you're actually on swift-develop when you're pulling the Pod.  Try a fresh clone for me?\n. I'm also re-opening this until this gets resolved.\n. :exclamation: I know what happened here :exclamation: \nThe file Combinator.swift was moved from Swiftz to Swiftx a little bit ago as part of the cleanup of each framework.  In the process I purposely removed those specific sections because I didn't have valid operator declarations for them pre-Operadics, but I must have forgotten to tell git to stop tracking the file.  At the same time I updated Swiftx and didn't include the new Optional extensions there because they were already covered by OptionalExt.    \nSo: CocoaPods downloads Swiftx and builds Optional.swift, then downloads Swiftz and attempts to build OptionalExt.swift and crash.  Simultaneously, it tries to look for the operator declarations for the defunct extra Combinators.swift file and can't find them because they've been removed crash!\nI will be remedying this shortly.\n. The only thing standing in the way of this is a new podspec.\n@rexmas? \n. Fixed by the merge of #244.\nThank you all for bearing with me :sparkles: \n. :boat: \n. :boat: \n. No.  Travis only supports 1.2 so is only reliable when you target master.\nAs long as you're happy\n:boat:\n. Sorry for the late reply, I was away from anywhere I could test this for a while last night.\nAnyways, it builds on my end just fine.  Thank you so so much for your contribution and for bearing with my crazy mistakes (maybe now you see why I didn't want to switch to swift-develop so hastily \ud83d\ude05).\n:boat: \n. Fixed by the merge of #246 \n. :boat: \n. :two_hearts: \n:boat: \n. It is done\n. - Also updates stuff to work with the GM, but that comes later.\n. Fixes #136 and #143\n. @pthariensflame Ready for review\n. Done :boom: \n. There, all better.\n. @pthariensflame See anything now?\n. :boat: \n. We're using gitter now so this issue is closed.\n. I think the first half is a fantastic idea, but I worry about the second.  This library involves a lot of concepts that I firmly believe need thorough and (sometimes) rigorous introduction before they can be properly grokked, even by beginners.  The concepts in this library have almost no Objective-C equivalents that would make any sense to somebody coming from that side of the aisle, and shimming in a bunch of metaphors to make it so is something I can very much promise will be vetoed by me immediately.  Just as Haskell is a complete inversion of belief for these kinds of people, Swiftz and whatever the hell \"Practical Swift\" are sit at different ends of the spectrum for them.  tl;dr I don't want this library to turn into another LYAH because there are much better places you can get that stuff.\nThat said, and please don't take the above as an anti-novice rant, the docs suck compared to things like Apple's own stuff.  I'd like to have an editing spree for the next couple releases before we try to aggregate things together into a nice playground.  That way we get a feel for how hard it is to explain each thing in the small before we try it in the large.\n. Perhaps you could help by being more specific about which structures you would like to see more documentation for?\n. Yes.  I'm planning to release with/slightly before Xcode 7 on all of TypeLift.  As for the errors, I have an open branch waiting to fix them.  Downstream has to be updated to.  I'll have free time tomorrow to do it (unless somebody beats me to it).\n. It's not about the lack of changes so much as my lack of faith there won't be some breaking something or other with Swift between GM and release.  That and I need time to prepare the entire organization for this switch which takes a significant effort between each package.\n. Basically the sooner SwiftCheck gets updated the sooner everything else does too.\n. Fixed by the merge of #255 \n. Is the destination for the copy files phase /Frameworks?\n. I've just pushed the 0.3.0 pod.  Closing this.\n. Mhm.  That's a fun one introduced around beta 6.  I had to break up the user spec like this:\n``` swift\npublic class User : JSONDecodable {\n    let name : String\n    let age : Int\n    let tweets : [String]\n    let attr : String\npublic init(_ n : String, _ a : Int, _ t : [String], _ r : String) {\n    name = n\n    age = a\n    tweets = t\n    attr = r\n}\n\n// JSON\npublic class func create(x : String) -> Int -> ([String] -> String -> User) {\n    return { y in { z in { User(x, y, z, $0) } } }\n}\n\npublic class func fromJSON(x : JSONValue) -> User? {\n    let p1 : String? = x <? \"name\"\n    let p2 : Int? = x <? \"age\"\n    let p3 : [String]? = x <? \"tweets\"\n    let p4 : String? = x <? \"attrs\" <> \"one\" // A nested keypath\n    return User.create\n        <^> p1\n        <*> p2\n        <*> p3\n        <*> p4\n}\n\n}\npublic func ==(lhs : User, rhs : User) -> Bool {\n    return lhs.name == rhs.name && lhs.age == rhs.age && lhs.tweets == rhs.tweets && lhs.attr == rhs.attr\n}\n``\n. Still, #261 definitely should address this.\n. It's been quite a while since @zbeckman has updated this issue.  I'm going to close it.  Reopen if you have any updates.\n. Fixes #252 \n. @pthariensflame :ship: ?\n. :boat: \n. Is this really how CocoaPods works with dependencies like this?  We need those multiple definitions (compiled into different targets, obviously) to work around Swift's sad overloading resolution.  So, if you can come up with a way to alter our source search paths or something to fix this, I'm all ears.\n. Fixed by the merge of #258.  Please update your dependency lists to tag0.3.1`\n. Does it go back any further than this?\n. Cool :sparkles:.  Last thing:\nCan you alter the README to mention the new target bounds (down near the bottom there).\n. Once Travis gives us the green :boat: \nDo you need a release for this ASAP or are you willing to wait?\n. Well, thank you so much for it then.\n:boat: \n. :boat: \n. :boat: \n. This is awesome and I would love to see it happen, but alongside our current Applicative.  Swift does not support tuple extensions, so any generality we could extract would have to be by writing 7 billion overloads again.  Basically, until Tuple stops being an amorphous compiler hack I don't think this would work in quite the way you'd expect\n. So, how much boilerplate is enough boilerplate then?\n. Which is to say: I definitely agree that that looks more natural, but am I gonna have to maintain 15 more structs in the near future?\n. Then to 22 we shall go!  Would you like to draw up a pull request, or shall I?\n. Do whatever is most natural (which probably means separate at first).  We'll worry about the nitty-gritty in code review.\n. Whatever happened to this proposal?  Should I draw up the pull request for this myself?\n. Right now, it feels very bare.  If anyone has anything they want to add, I'm all ears.\n. @mpurland Done.  See anything else?\n. We have our own solution, Operadics, because Runes is woefully incomplete.  Our operators are 100% compatible with Runes when imported into the same translation unit if it helps.\n. Great. I'll close this, then.\n. \"Not complete\" in the sense that we don't cover Foundation classes is a feature, not a bug.  Foundation, and the implicit overloads it introduces, need to stay as far away from us as possible.  Use our existing instances as a guide for writing out the missing ones.\n. We would be open to having a standard repo/gist extending Swiftz with Foundation support. Hell, a new library splitting out the JSON stuff may even be called for (or we could remove it altogether, but then we'd get issues screaming at us about it.\n. First off: Thanks for contributing! :star2: \nI've left a couple of style notes (sorry about making you clean up stuff you didn't write too).\n. More importantly, the tests should be expressed as SwiftCheck properties.  Namely, to make sure that a \"round trip\" to and from JSON is an identity both ways.\n. I think this is fine.  Once Travis gives the green light I'll merge this and work on translating the tests over to SwiftCheck.\n. And there it is.\nThanks again :sparkles: \n. A simple thing would be any feedback you have on #261.  Then tests and documentation.  We could always use more of that any time.\n. I need to think more about how to generate JSON.  But it's not a big deal right now seeing as all we're doing is shunting whatever value foundation gives us back into the JSONValue struct. To test that would be to test NSJSONSerialization, not anything Swiftz-related.\n. I was thinking of creating an ArbitraryJSONValue struct that simultaneously constructs a JSON string and a parallel ideal JSONValue and testing against that.\n. But I wonder what that amount of engineering would actually accomplish in terms of testability.  So I've got JSON, I've got a model \"built\" from it.  Great.  What invariants hold about the structure?  None I can think of.  \nI took a look, and Aeson uses a set of big JSON files along with its test suite to stress-test and have some real-world use cases.  That seems more productive in the long run.\n. I'll try this again later.\n. Can you reopen this in Operadics please?\n. And we're off\n:boat:\n. :+1:\n:boat:\n. This one, too, seems old.  I want to keep the dictionary and array extension stuff tho (but obviously have it in the right place and not with JSON).  Do you want to update this branch or open a new pull request?\n. OK, now this is getting serious.  We need to start considering completely severing the JSON part of this package from Swiftz if we're going to start writing instances for everything.\n. I'm just worried that this seems to be the only part of the framework that requires integration with Foundation, and that is degrading the safety of the other components (I hate the implicit overloads it introduces automatically and without warning).  If we're going to integrate further, even an inch, it makes sense to me to divorce ourselves from the JSON part.\n. Sure.  But I think we should draw the line at collapsing Optional to ?.  If anything, Optional needs to be as expanded as possible in type signatures so it's obvious that we treat it as a datatype and not as the syntactic sugarhigh it is.\n. Done!\n. :boat:\n. Shit, sorry about that.  Let Travis do its magic again.\n. I was thinking the 2nd, as we've had so much success with it in the past (see Concurrent, Focus, Swiftx).  If users still wish to use Swiftx and Swiftz, they can update their cartfiles and pods as much.\n. I mean we create our own package and keep everything within the typelift ecosystem following the models of those aforementioned frameworks, then deprecate Swiftz's stuff and put out a new point-release.\n. Also, seeing as you've probably got more edits of that code than anyone (probably even Max at this point), I think you deserve admin access to anything we create.  Even to TypeLift  as a whole if you're up for it.\n. Great!\nOK, well Aeson, Jason, and JSON would be too blatant a violation of others' work. Continuing the greek trend \n- Thessalus, son of Jason\n- Tyro, father of Aeson, grandfather of Jason\n- Promachus, brother of Jason\n. Or just something with a hard J in the front.\n. I like Tyro for length, Zetes for the pun, and Alcimede because she's a badass.  Any more, or start narrowing?\n. Oh, I've always wanted to name something janeway, or in this case JWay\n. Well, @mpurland you have the rights to do whatever you like right now.  Go ahead and pick a name and a make a new repository. \nWould you like us to close out all the existing pull requests and try again on the new repo after it's made, or would you prefer we merge first and ask questions later?\n. :+1:  Let's do it.\n. :+1: \n:boat: \n. I don't know what we gain by each unless you intend to rename Addable and Multipliable to some Semigroup puns, Subtractable as the mate of Semigroup and Invertable and move Signum somewhere else entirely.  Basically, I think Haskell's authors, when they were writing Num, just shot for the minimum viable structure they could start defining easy arithmetic operations on.\nFor what it's worth, this would go great in the Algebra package, though.\n. Yeah.  First I have to see if that thing doesn't crash Swiftc and merge that leftover PR.  Could you open the build script pull request over there too while you're at it?\n. This is... quite aggressive, but we're right in the range where we should probably release a new dot version anyhow.\n:+1:\nSince this is so big: @pthariensflame do you see anything?\n. Yep\n. Definitely need to get around to finalizing the API over in Tyro before this lands.  I'm drawing up something now.\n. Always good to see progress like this\n\n:boat: \n. That was moved into the Operadics README because those operators now apply to every repository in TypeLift not just Swiftz.\n. Agreed.  I suck at writing these kinds of things, and I wrote them all :sweat_smile: \n. Give this one the old rebase and it'll be good.\n. :boat: \n. Already done!\n. Absolutely.  Would you like to contribute an implementation, or shall I?\n. @mpurland Wanna race?  \ud83d\ude2c\n. With the merge of #284, this issue is now closed.\nThanks everybody! :sparkles: \n. :boat: \n. Rebase\n. :boat: \n. I believe the test cases in the Writer Spec should port over with very little resistance.\n. It's missing the global functions ask and asks.\n. :+1: Give it the old rebase and we're good to go\n. :fire: \n:boat: \n. :boat:\n. This is ready for review.\n. :boat: \n. :boat: \n. The test suite isn't using Reader properly anyway.  I've updated it in #286 to test only the public API and make the @testable import redundant.\nThanks for offering a fix anyways!\n. Could you also take a look at typelift/SwiftCheck#129?  I think these two might be related.\n. :boat: \n. Yassss\n:fire: :+1: :fire:\n. At this point, not really.  Wanna write us a pull request ;)\n. Submit it to master please.\n. :boat: \n. @gcornut Yeah, thanks!  :sparkles: \n. Thanks so much :sparkles: \n:boat: \n. This is on my list for when 2.2 drops.  I need SwiftCheck to work before any of these packages, so the majority of my efforts and tests are over there right now.\n. Fixed by the merge of swift 3 support.  Please tag release 0.6.0 or greater in your package manifest.\n. No Swiftz-related API changed, but we did migrate the framework to Swift 3.0 so that means whatever changes one would expect from that they can expect to see as well migrating to the latest release of Swiftz.  Essentially, breaking changes ahead because Swift is breaking everybody.\n. Looks great!  Can you throw in the bare minimum SwiftCheck properties for all of these (basically this)?\n. Oh god, that looks like Swift thinks we need rank-2 polymorphism. \n. The file I linked to is on a branch where I fixed the order issue and committed that test.  Use it instead of master. \n. @ryanbooker If you want me to write the tests for this, I can merge this and do it.\n. I can take a crack at it with the tests.\n. Traversable isn't typesafe in this language and doesn't generalize from Foldable at all.  However, MonoTraversable will work great.  As for the tests, I've implemented either Arbitrary or the WitnessedArbitrary shim for each one.\n. Yep!  It's mostly for the order invariant.\n. Yeah, that's to be expected.  What happens if you use take on arbitrary subsequences to lower the law to the array ones?\n. No, leave it in.  But equality on streams is not a thing, but equality on lists is so you see how in the Stream Spec I lower all the equality calls with take to equalities on streams of arbitrary stream heads?  That's what I mean.\n. Yeah, so rather than invoke sequence on the Stream, just take an arbitrary number of elements and sequence the resulting Array instead.\n. Not like we can, though.  The laws require an equality that necessitates forcing the stream.\n. Welp, given the issues we discussed seem hard limits, and in the interest of honoring the great work you did here, I feel it's only appropriate to merge this.\nThanks for putting up with me through review :heart: and for the patch :sparkles: \n:boat: \n. We are not 2.2 compliant yet (have to put out Swiftx's 2.2 support first).  \nThis issue and #295 are related nonetheless.\n. :boat: \n. :boat: \n. :boat: \n. My bad!  Fixed.  Thank you for the bug report.\n. I feel bad about having to drop down to equality on lists, but then again I can't think of a better way to go about doing this than sampling the stream.\n. :boat: \n. I feel bad about you having to work around the compiler for us like this (I can also vaguely remember doing the reverse of this pull request at some point!). \n. A general style fix before I merge: we use this form for type signatures: thing : Type.\n. We should wait until Swift 3 stabilizes the ABI before providing binary-only releases.  Also need to get this thing working with the package manager which is going to require major dependency tree changes.\n. Thank you for this.  Did you notice any other places where it was slow?\n. Oh, whoops.  Sorry for leaving this to sit for so long.  As I said in the last pull request, I think this is great work, thanks \u2728 \n. \u26f5 \n. If there are no objections,\n\u26f5 \n. We based our implementation on Haskell, and your example behaves as intended if that is the semantics we're after.  In your implementation example, the result should actually be [[1],[2],[3,2],[3],[4]]\n. So sorry for letting this sit and rot for so long.  Thank you for your contribution!\n. \u26f5 \n. \u26f5 \n. \u26f5 \n. \u26f5 \n. \u26f5 \n. :boat: \n. \u26f5 \n. \u26f5 \n. CocoaPods will be supported when they fix the bug that rewrites repository origins.  Until then I can't trust them to build this package or any other under this organization.  If that is the case and I missed something please submit a pull request that uncomments this line: https://github.com/typelift/Swiftz/blob/master/.travis.yml#L13\n. 0.6.3 was just pushed to trunk.. You will also need a swift-version file to convince cocoapods to run in 3.0 mode\n. 0.6.3 was just pushed to trunk.. Apologies, it seems the package format changed slightly after we initially supported SwiftPM.  The problem lies in the layout of Swiftx, not Swiftz if the error is to be believed.  I need to reorganize the tests directory into a more modular form (a la SwiftCheck).  If you would like to do it, however, that would be fantastic.  Just take a look at how we do cross-platform testing in SwiftCheck as a model.\n. No problem!  Thank you for the patchsets.\nBy the by, it looks like the project in question doesn't actually need the full power of Swiftz.  Swiftx should suffice, right?\n. Can you run git submodule foreach git pull origin master to bring in the latest Swiftx changes too please?  I'm going to put out a new version soon, so please bump up the package version range to accommodate that\n. Ah, looks like one of the tests must be updated with a bit of new syntax for some of the methods in SwiftCheck.  I have it set up so it should appear as fix-it suggestion if you simply rebuild the testing target for Swiftz.\n. Looks good.  Last thing to do is bump this version requirement up a skosh to match the new version of Swiftx.\n. Yep\n. \u26f5\ufe0f \n. New version incoming.\n. This is a consequence of SE-110 being partially implemented.  \nswift\npublic static func iterate(_ f : @escaping (Element) -> Element, initial : Element) -> List<Element> {\n  return List(initial, self.iterate(f, initial: f(initial)))\n}. Resolved by the merge of #321.  Thanks!. Thanks!\n\u26f5\ufe0f . \u26f5\ufe0f . \u26f5\ufe0f . Right now!. \u26f5\ufe0f . \u26f5\ufe0f . Yeah, this is a problem on CocoaPods' end related to code signing - I would have loved to have pushed to their trunk last year but I cannot get the pod to validate.  The 1.6 beta does work under some circumstances so I'll give that a try this evening.. Meh, I'll take it as-is.. Resolved by version 0.7.0.. Resolved by version 0.7.0.. \u26f5\ufe0f . \u26f5\ufe0f . \u26f5\ufe0f . \u26f5\ufe0f . \u26f5\ufe0f . I'm unsure of what I'm suppose to do to fix this.\n. You ought to bring this up with the CocoaPods folks then.  I've clueless when it comes to our pod specs (if they pass validation, it ships).. I can see how Cocoapods validation would miss this - still feels bad.. \u26f5\ufe0f . \u26f5\ufe0f . 2 things:\n- Did this number come from Haskell's precedences?  It's a bit too low compared to everything else in the Swift STL (about 90-255).  Maybe 100 or 110 would be better.  Then again, we haven't quite gotten around to giving any of these things relative precedences yet.\n- This operator associates to the right.\n. Interesting.  Well, give it a 0 then!  Could you do the same to |>? \n. Single line please:\npublic func flip<A, B, C>(f : A -> B -> C) -> B -> A -> C {\n    return { b in { a in f(a)(b) } }\n}\n. Terminating newline here, please.\n. We still can't publicly export extensions to generic types.\n. The first half of the second sentence is awkward.\n. @pthariensflame this was left commented out but it seems to work fine and it typechecks.\n. Inconsistent capitalization of nouns like Monoid and Semigroup\n. I've always preferred this style of operator declaration.  Seeing the associativity and precedence fields aligned with the declaration was too hard to read.  In addition, I've kept the documentation style used in the Basis of [Colloquial] Name | Documentation because I believe every operator should at least be pronounceable.\n. Needs more appropriate wording than \"inside\".\n. This should be pure(a : A)\n. Same thing here: >>- <A, B>(a : Set<A>, f : A -> Set<B>)\n. Awkward construction.\n. Emphasize left ness and rightness of this and that.\n. Newline here.\n. I have a request to remove this entirely.  A future pull request will do so.\n. Removed for now.  When #143 gets fixed it will return.\n. By all means try it yourself.  Don't worry about having to teach anybody anything, that's what the Basis is for.\n. We were using them in our tests so I can't be confident other people haven't either.  But I can remove them if I'm just being paranoid.\n. Want a go at it?  I've written a million explanations before but they're not appropriate for the kind of documentation I want here.\n. That's not a keychord, that's a module :stuck_out_tongue_closed_eyes: \n. Was gonna bring this up: So awkward!  I have an intuitive understanding of Comonads but putting it in words is so hard for me...\n. If only Apple actually followed through on their promise to support reStructured Text :angry: \n. It just seems to simplistic.  Kind of like we're implying Functors are Boxes, and ye gods that's the opposite of what I want.\n. :+1:\n. Ack!  I confused imap and xmap!\n. Good idea.\n. Hmph... Probably should have checked that before merging #115.\n. Reverted.\n. @pthariensflame Better?\n. \"Purely Functional\" is definitely the wrong phrasing here.\n. Probably should make sure these examples still compile, what with all the changes of late...\n. Needs spaces between the operator and generics.  Will submit a PR for this to here and the Basis.\n. :warning: Breaking API Change :warning: \n. Excellent catch.  #155 \n. :+1: \n. Does Swift let us use __builtin_unreachable()?  That won't get optimized away in release.\n. Let's be mutually recursive here and mention Swiftx.\n. Should I reprint these examples here?\n. Do you have anymore suggestions for examples?   We don't have anything related to Zippers, Concurrency, the Lens Family (besides a few small methods), and the typeclasses\n. This should be a Monoid, no?\n. I'm open to ideas on this one.  Aeson uses .:, which Swift throws a fit at.  In fact, any permutation of dots and colons is a no go.  Maybe <? to emphasize this is the total version of retrieve and use <! as a version that forces the Optional?\n. sigh. 8 space tabs again...\n. See _sigh_ing above.\n. Probably should make this a function in ArrayExt\n. While I certainly appreciate the sentiment, default: here please!\n. I believe this is equivalent to return (list, [T]())\n. Tabs over the whole thing, please\n. Meh, we get one less loop in the grand scheme of things, but may as well.\n. This assert will go away in release builds.  Maybe\nif vs.isEmpty {\n    error(\"...\")\n}\n. Newline here.\n. As a matter of style, we separate name, colon, and identifier with spaces\npublic func coalesce<T>(all : @autoclosure () -> T? ...) -> T? {\n. And here.  Can Swift not infer this?\n. And here.\n. And here.\n. Oh, silly me. The and here comments are all about the above comment about separating identifier, colon, and type with spaces.  The only newline I want is at the end of this file.\n. Uncomment this if you dare.\n. Thanks for noticing this.  It will be fixed if it ever stops inducing SEGFAULTs in the compiler when you uncomment this.\n. Uh... What the hell did I do to make that happen?\n. I'll just rewrite the thing.\n. Another thing rewritten!  I'm not sure it's the best way I could have put it, but it's better than this.\n. nil here please.\n. and here\n. here\n. here\n. here\n. There should be a space between identifier and type here.\n. And here\n. and here\n. and here\n. and here\n. and all down here\n. Does this still not work as one gigantic expression?\n. Humph.  I broke it up the first time because of this, and I keep hoping each release that they'll let us do it again.\n. It is, definitely.  No sense in forcing you to do something the compiler wouldn't accept :smile: \n. Tag Operadics/master in the cartfile and run Carthage update.  I'll put out a proper release later tonight.\n. Same thing about spacing between colon and identifier above ^^\n. This should not be public.  It is not typesafe in all cases\n. This should not be public because it is SPI.\n. Why isn't this in the extension, or a private function?\n. Is there a more vivid name for this combinator?  mapAssoc or mapAssociate, etc.?\n. I've seen it called label somewhere.  I quite like that idea.\n. Newline here please\n. The usual typelift colons style please!\n. SwiftCheck can generate this function\n. Link to https://github.com/typelift/Operadics#operators to have it jump to the table\n. Newline here\n. Remove this\n. This is an interesting approach to MonadReader, but I don't think it gets us much.  Still, I think there's something here that can be applied to the codebase as a whole in the future.  Can you draw up an issue discussing this style?\n. TypeLift colons, pls\n. Should be\nreturn Reader<R, B> { (environment : R) -> B in\n        let a = r.runReader(environment)\n        let readerB = f(a)\n        let b = readerB.runReader(environment)\n        return b\n}\n. They definitely are.  But what I want is to introduce them all at once into a future major version of the framework.  For now, I think we should hold off on introducing them into just one place and plan for bigger things.\n. This should just be a monadic action in the reader monad.\nswift\npublic func ask<A>() -> Reader<A> { //... }\n. I've never seen this particular overloading before.  What's the expected use case?\n. I think it's subsumed by just passing. identity\n. I thought hard about what it would mean to leave the constructor public and I didn't see a reason to keep it around in the presence of the actual reader function, which calls through to this as an implementation detail.  In the future (not saying we should ever do this) should we need to alter the definition of reader's internals, the initializer can be altered without fear of leaking API details.\n. Can this take an arbitrary head of the sequence (an extra forAll)?\n. What does limiting the size of generated lists do (either with custom arguments or Gen.fromElementsIn(1...10), etc.)?\n. Damn :confused: \n. How deep should we go here?  Cats goes to 22, but that will balloon the implementation.\n. Overload or productN?\n. This is using the old-style package manifest dependency definition syntax.  Is that intentional?. ",
    "joshaber": ":+1: \n. Alright, added a test for none as well.\n. #1 looks much better since it doesn't require subclassing, assuming it's sound.\n. :+1: \n. If it works then it's better than what we had!\n. ",
    "relrod": "There's a comment about this here.\n. ",
    "moriturus": "I tried to implement C++'s stream like operators instead of golang like.\nBut It seems to be slight redundancy.\n```\n@infix func <<(chan: Chan, value: A) -> Void\n{\n    chan.write(value)\n}\n@infix func >>(chan: Chan, inout dest: A) -> Void\n{\n    dest = chan.read()\n}\n// usage\nvar chan = Chan\nchan << 10\nvar value : Int = 0\nchan >> value\n``\n. Just for locking/unlocking of threads, I haven't written any code yet, how about to usedispatch_semaphore_tinstead ofpthreadmutex?dispatch_semaphore_tdoes not need to doalloc/free`.\n. ",
    "tLewisII": "Cool. I will get it setup and send a PR.\n. You may be able to implement a type safe set using NSSet underneath, though I just used a Swift Dictionary for my implementation.\n. I have an immutable array going over here, and was planning on doing an immutable Dict plus other structures as well. Would you want these included in this Repo, or keep a separate one for just Data structures such as Array, Dict, Set etc?\n. @pthariensflame That is what I was thinking myself. \n. Empty set is useful also, and any should have returned A? in the first place. Also, it would probably be good to be able to bridge this to NSSet, but I can add that is a future PR.\n. This is rather finicky at the moment. If you try to compose more than 4 functions it usually does not build, but sometimes it does. I got 4 working in the tests, and have gotten 8 before, but it seems like it has a problem building in playgrounds and Xcode sometimes.\n. This seems to be good now, so I am going to close this.\n. JArray is typed, class JArray<A, B: JSON where B.J == A>: JSON and here you have not given it a type, So it cannot know what it should do. You should be able to get it to work if you do let events = d[\"events\"] >>= JArray<TypeToParseTo, TypeToParseFrom>.fromJSON I do believe.\n. @mpurland I was about half way through this process myself, I will pull this down and look at it a bit closer, thanks!\n. @mpurland Looks good, I will go on and merge it. Thanks!\n. @tonyd256 Optional would be the right way to go here. Also, you might want to stash the changes, pull the beta 4 upgrades and then re-apply, since at the moment you have merge conflicts.\n. @pthariensflame Yeah, the \"Constructor\" ones I was not really sure about. Are key and nth correct? \n. Since this is not a sound implementation, I am going to go on and close this and reference #77\n. What we want? Data.Aeson.Lens. Though I suspect this would probably be good enough for most people until we get higher kinds. Is the IxStore way that much better than the Van-Laarhoven style?\n. So we just need Functor for the van-Laarhoven it seems?\n. @pthariensflame Nothing waiting as far as I know, I will go on and merge.\n. @maxcan Cool beans, thanks.\n. Alright, I moved these to global scope for now. Also, I though the zip functions might work, since we have == implemented for tuples, but they still don't.\n. @pthariensflame If you want to get the merge conflicts fixed, I will go on and merge this in.\n. I did hear of some problems with >>= and the new ?? operator. Something about the precedence of >>= needing to be higher or lower, and not being able to change it. Though in that case parens would solve the problem. \n. @maxcan I would rather not do that. I think it would be best to keep the operators as standard as possible, since many already have established meanings in other langs. In this case, it might be acceptable to go with >>>, though that is already defined as left to right composition of Categories and Arrows (in Haskell), but it is less well know.\n. So I was looking through the tests, and I noticed find was blue, like a library function, and it turns out is a library function, func find<C : CollectionType where C.Generator.Element : Equatable>(domain: C, value: C.Generator.Element) -> C.Index?. Except it returns an index instead of a value. I deleted it since the tests were passing and I thought it was using the library function, but I will put it back.\n. It built and tests passed, also works in the playgrounds. This is using the join defined in ArrayExts, not the std lib.\n. I think Swift support is still a work in progress.\n. @CodaFi So I hate to be that guy, but I would like to have documentation and maybe some examples-as-tests for this (and all other PR's) going forward.\n. @CodaFi No objection from me.\n. @CodaFi Looks pretty good. I will pull it down later tonight and take another look.\n. Yeah, it might not be used. I just went down the NSSet documentation and implemented most of that to make sure I did not miss anything. You can take it out if you want.\n. I will do that.\n. ",
    "singpolyma": "I needed sets for my project and ended up using NSSet\n. ",
    "pthariensflame": "Now that Swift's arrays have full value semantics, can't we just provide those functions as extensions on them?\n. @maxpow4h I don't see why not!  I'll make that change.\n. @maxpow4h Done!\n. You can actually make \"manual type aliases\" with @conversion __conversion(...) in each direction, if I'm not mistaken.\n. Once we get sealed hierarchies, we'll be able to express it as:\nswift\n@sealed protocol TypeEquality {\n  typealias A\n  typealias B\n  func apply(v : A) -> B\n  var inverse: TypeEquality<B, A> { get }\n}\nstruct Refl<X>: TypeEquality {\n  typealias A = X\n  typealias B = X\n  func apply(v: X) -> X {\n    return v\n  }\n  var inverse {\n    return self\n  }\n}\nI agree with @jonsterling though, and would get rid of this until then.\n. Or wait until this works:\nswift\nstruct TypeEquality<X, Y> where X: Y && Y: X { ... }\nI seriously doubt Swift is gaining higher kinds any time soon.  :(\n. I just confirmed that the following code causes the compiler to segfault:\n``` swift\nprotocol TypeEquality {\n  typealias A: B\n  typealias B: A\n  func apply(v: A) -> B\n  func unapply(v: B) -> A\n}\nstruct Refl: TypeEquality {\n  typealias A = X\n  typealias B = X\n  func apply(v: X) -> X {\n    return v\n  }\n  func unapply(v: X) -> X {\n    return v\n  }\n}\n``\n. Doesswiftzuse anything other thanFoundation(andXCTest)?  If not, this addition should be near-trivial.\n. This looks good to me.\n. We should really have both my new variant and your new variant; will overloading work?\n. @maxpow4h Yeah; even if it just treated \"foreign\" functions as _actually taking a tuple_ it wouldn't be quite as bad as the three-way unfortunateness that is curried vs. uncurried via tuples vs. \"primitively\" uncurried.\n. The labels are still needed with that, unfortunately.  I'm not sure if it's a bug or a feature.\n. @bleis-tift There's an _internal_ notion of currying, due to the presence of cartesian products in the object theory, which you pointed out.  There's also an _external_ notion of currying, due to the presence of cartesian products in the metatheory, which is reflected by the signature(s) of Swiftz'scurry` function.  Both of them are deserving of the name.\nPerhaps you would like to read up on the connections between cartesian categories and multicategories?\n. Neider am I, but until Apple gives us the official go-ahead (or not), I'd like to stick to what the spec describes.  :)\n. Or you could give a type signature to events; that would work too.\n. More than half of these are \"false lenses\"; the way you can tell is that they have nonunifiable initial and final target types (in this case String? vs. String, Int? vs. Int, etc).\nI'm still working on how to represent Prisms in an IxStore-compatible way, but those should be used here instead.  I'll see what I can do right now.\n. @tLewisII Not really.  They're not quite as bad, but they should still be Traversals rather than Lenses.  A good rule of thumb is that anytime you're trying to construct a lenticuloid (of any sort), if you have to resort to optionals, you're probably doing something wrong.  :)\n. This is relevant to #76.\n. @tLewisII The van-Laarhoven style requires higher kinds in order to work properly at all.  :)\nIf it worked in Swift it would be amazing, but we would also be able to expand the IxStore-esque representations accordingly.\n. @tLewisII:\n- For van-Laarhoven Lens, we need Functor.\n- For van-Laarhoven PartialLens, we need Pointed.\n- For van-Laarhoven NonEmptyTraversal, we need Apply.\n- For van-Laarhoven Traversal, we need Applicative.\n- For van-Laarhoven Iso, we need Profunctor.\n- For van-Laarhoven Equality, we don't need any type classes, but higher kinds are still required.\n- For van-Laarhoven Prism (and the remaining others), we need various subclasses of Profunctor.\n. Bump.  @maxpow4h @tLewisII Should this be merged, or are we waiting for something?\n. What's typical (for me, anyway, having worked on ObjC projects before) is to include the framework as a bundle-resource-like thing.  You build Swiftz separately, as a framework (two of them, actually), and then you copy the framework physically into your project folder, or perhaps a subfolder for organizational purposes.  Then you add the framework(s) to XCode as dependencies of your project, the same way you would add, say, SpriteKit or XCPlaygroundKit.\n. There are actually a couple different things wrong with this explanation:\n- The first signature should be a static.  I understand that you're trying to evoke the idea of \"moving it into Signal\", but for that very reason, it should be presented as a true before-and-after, rather than an after-and-also-after as it is now.\n- The second signature is no longer that of merge; it's just bind.  Indeed bind(identity) is equivalent to merge, but that's a characteristic of bind, not of identity.  In particular, you can't reliably use a function as an \"evidence\" parameter for equality, because the function might in fact not be identity in any given case.\nReally, hijacking the identity function for some kind of half-assed notion of type equality is not going to go anywhere good, in the end.  Now that I'm aware that this seems to be a chronic problem in Swift, I'll try to redouble my efforts at a true type-equality solution that integrates properly with the language.  I think I have some ideas, but we'll see.\n. @maxpow4h Ok, but a function \"carrying a proof of equivalence\" is really asking for it to be an Iso, not just a function.  And if all you actually need is a function, then you should probably rethink why you were expecting to need a full equivalence.  @jspahrsummers's merge combinator is a good example of that; when you realize that all you need is a function rather than an Iso, you should probably ask yourself if you're actually implementing the function you think you're implementing, rather than a higher-order \"generalization\" of sorts (in this case, bind).\n. @jspahrsummers @maxpow4h Sorry for coming across as angry, by the way.  I just reread my first comment and felt an apology was needed.  :/\n. @jspahrsummers Well, since fmap+join is exactly equivalent to fmap+bind, it ends up not mattering.  You can implement all three in either case, and in particular you can implement the missing one generically (pending language support for higher kinds).  :)\n. @tLewisII Done!\n. @tLewisII @maxcan @ryanbooker >>- is actually fairly well-established now as bind for not-quite-monads, and doesn't look too bad as an operator, while not messing with any of Swift's assignment conventions.\n. Not so far.  I can take a look at it and see how hard it would be.\n. You're using Swift 1.2 and Swiftx and Swiftz only work with Swift 1.1 right now.  This is the reason for at least some of the errors you are getting.  See #182.\n. Just for the sake of being helpful, there is a way to create an alias on import in Swift, you just have to do it \"manually\".  :)\nCreate a new file, import the objectionable value, type, or member in that file, then provide an internal alias to that value, type, or member (through let/var/func, typealias, and/or extension as appropriate) in that file.  You can use the same file for multiple such \"renaming imports\", but it should be used for nothing else.  I like to call it RenameImports.swift, but that's just me.  :)\n. This is looking good to me, although I'm a little worried we're locking ourselves into this kind of thing even if higher kinds someday become available.  Maybe not, though.\n. A comonad instance for Box is a good idea; the non-indexed special case of IxStore would be an instance if Swift allowed that kind of type alias.\n. I'm in favor of The Rumba.  On a related note, does Xcode have extensible code formatting, or will we have to create an external tool?\n. Another possibility (though one I'm not sure I like) is The Tarantella:\nswift\nswitch self {\n    case let Error(e):\nreturn .Left(Box(e))\n    case let Value(v):\nreturn Either.Right(Box(v.value))\n}\nPros:\n- very clear divisions\n- internal lines won't get too long\nCons:\n- Looks awful\n. I think it's worth it, since there's really no reason to reuse an operator name unless there's some connection involved with the original.  I don't think we'll actually be \"polluting\" anything, in terms of how Swift code is actually written.  Also, the process can essentially be automated, so if and when we ever get compile-time metaprogramming we'll be able to do it for everything.  Even if that feature never shows up in Swift, external code generation tools are not exactly foreign to us anyway. :)\n. It's already a syntax error, and anyone using our library will know exactly what we've done.  It's not like we'd be creating a complete incomprehensible mess here.  Also, if the users don't want to deal with it, they can simply not import those overloads.  We can make that supremely easy for them by, say, having them in a separate module (the way we do with swiftz_core already).\n. Looks OK to me, although I don't have access to Xcode right now to test if it works.\n. Alternately, we could make like Mozart/Oz 3 and overload prefix ~.  :P\n. I'd be fine with that.\n. The left sections of the assignment operators have a sensible semantics; for example, reduce(1 ... 10, x+=, 0) should be equivalent to x += 55.  The right sections don't, though, barring first-class mutable cells.\n. Could you please add it to OpenRadar?\n. Ok!  Looks good to me; since this is a major addition, we should give the others the opportunity to comment.  @typelift/fp, any objections?\nIf/when this gets merged, I'll also take some time to attempt to figure out assignment sectioning, because I feel like it should be doable.  We'll see, though.  :)\n. Why not infix forms for the other arities, taking tuples?\n. This looks good to me, now.  I do have other thoughts, but I think I should save them for later, since they're vague and only tangentially related to the core topic at hand.  :)\n. It's something @maxpow4h and I discussed offline, but I'm waiting for Xcode 6.2 to officially come out so that certain needed features are in place for most developers.  Thanks for opening an issue though; it'll be a lot easier to keep track of, and I don't know why I didn't think of it before.  :)\n. The last time I tried this, the entire Lens hierarchy failed to compile, for no easily discernible reason.  That was during Swift 1.0 days, though; perhaps swiftc is better about that kind of thing now?\n. Perfect.\n. I think Copointed is a good idea (as is Pointed), but I'm finding it hard to articulate my reasoning.  Obviously, Tony Morris and Edward Kmett both disagree with me, but I've never been able to understand their reasoning either.\n. Ah, that makes a bit more sense, then!  I think we of the @typelift/fp team will be able to avoid that.  :P\n. Sure!  There are pointed objects that aren't functors.\n. @CodaFi :(\n. :+1:\n. In the absence of objections, merging.\n. Isn't that what typelift/Basis is for?\n. How about \"SwiftX\", then?\n. How about TLKit, if we want that style of name?\n. Of those, three, I favor TLKit, but not super-strongly.\n. I think I already suggested SwiftX, but I could also maybe get behind SwiftFP, or TLCore, or most anything of those patterns.\n. Swiftx is perfect!\n. Fine with me.  Full higher kinds are needed for any sort of true type class or Swiftish protocol to accurately represent monads, so any kind of kludge is acceptable right now.\n. In response to discussion on typelift/Aquifer#10, we should consider using >>->> for (forward) Kleisli composition.\n. Reviewing slowly via mobile.  Anyone else in @typelift/fp want to join in?\n. Sorry for taking so long!  I've got no real problems with this.  :)\n. :+1:\n. :+1:\n. Looks good to me.  Any thoughts, @CodaFi?\n. Given that Travis thinks it's fine, I'm willing to give this the thumbs up.  :+1:\n. @CodaFi still thinking  :P\n. Tell me when you think you've gotten all the grammar stuff done.  :P\n. This looks fine to me!  I still have to get around to writing the in-code docs for lenses, though.  :/\n. Wow!  This is a lot.  I think I'll go over this in the morning instead of right now.  :P\n. @CodaFi Everything in the current diff has either passed my inspection or been commented upon (or both).  Re:  documenting the lens hierarchy, I can handle that while I'm doing the other things we've discussed.  Thanks for putting together such a comprehensive pull request!  :)\n. Modulo what we've already discussed, this is now looking pretty good to me.  Feel free to merge at any time.  :)\n. Don't merge this yet.  I'm still working on how to make Carthage behave.\n. This is now ready!  The only thing is that Carthage can't directly build Swiftz for some reason, so any users have to attach it as a dependent subproject to their own.  It'll still fetch it, place it in its proper location, and keep it up to date, though.  :)\n. Sure! I'll do this as soon as I'm back at my keyboard.  :)\n. Ah, that was the problem, then!  I was linking both.  Perhaps we should put a warning of some sort in the Readme?\n. I think I like <\u00a7> rather than <$>, for the reasons cited in the OP.  That being said, I'll go with whatever is most comfortable with the general populace of our users, since Swiftz is above all else supposed to be usable.  :)\n. Option-5, for me, since I'm using U.S. Extended.  :)\n. @sharplet You can have your thumb (of either hand) on Option while your pinky finger (also of either hand) is on Shift.  This is generally what I do, and it works pretty well (it's also agnostic to your particular keyboard layout, since the MOD keys aren't going to move).\n. Thanks, @CodaFi!\n. Looks good to me!  This might let Carthage actually build it directly, as well.\n. Carthage in particular shouldn't have a problem, as it only ever builds one target (if it can find one, which is apparently harder than it looks, given the troubles we've had).  In general, though, ...\nYeah, we should take a look at what actually happens, just in case.  :/\n. Also integrating with #142 is such a good idea that I had though that was the plan from the beginning.  :)\n. Well, this'll take a while.  :P\n. Ok.  Looks good to me, but I'm trusting Travis more than myself on something like this.  :P\n. We should probably update the version number in our plist (which then gets exposed by the public header) in synchrony with the release number on Github.\nBesides that, the public header is supposed to be used to import any ObjC components of a mixed-language framework.  For our purposes, it can also be exploited as a kind of \"reexport\" mechanism; we should probably think about doing that with Swiftz and Swiftx.\n. Apple wants them there, apparently.  :P\nI suspect that they get used for module-level reflection when importing a framework into a Playground.  Even if that's not the case, I think we should still keep them around just in case they turn out to have some other use.  :)\n. Yup!  See #247 now.\n. How does that look?  @typelift/fp\n. :scream:\n. You're very welcome!  It took the impetus of seeing how ugly explicit dictionary passing actually was to get me to do it.  :P\n. This will take a while.  :P\n. This looks fine to me, now!  I wouldn't be surprised if there were spelling errors somewhere, though; I couldn't hold the whole thing in my head at once as I usually can with pull requests.  :P\n. This should actually be [(A, B)] on the inside, because of monoidal collapse.\n. @CodaFi You know, you can just have Xcode 6.4 download the \"iOS 8.3 emulator\" and it'll let you target 8.3 from then on.\n. Done!  :)\n. Heh, okay!\n. Can we add conversions between State<S, A> and IxState<S,S,A>?\nIf only Swift supported generic typealiases\u2026\n. To be fair, if you're not careful, type-level lambdas (which is what generic type aliases amount to) can break the decidability of type-checking.  Still. something should be able to be done\u2026\n. :+1:\n. @CodaFi Do you want to include @maxcan, @tLewisII, and/or @mxswd as authors, in addition to you and me?\n. I'm fine with that.  Merging!\n. This looks fine to me!  Or, at least, it looks reasonable given the above discussion.  :)\n. :tada:\n. :+1:\n. Because we're following Haskell.  If we were to follow Rust instead, we'd end up renaming it to Result (with constructors Ok and Err) and making it left biased.  :)\n. No idea what might be wrong, but I'll update the version in the podspec.\n. No problem!  So is this issue now resolved, then?\n. Great.\n. :+1: Just have to think about API design.\n. Yeah, this isn't Rust.  We don't have any way to tell the compiler that our references should only be valid for the duration of the original object.  :(\n. I'd be OK with maintaining them separately, if we do decide to split them out.\n. Well, lens is already taken in Haskell, and I'm using refraction and TeaLeaves for my WIP ports to Rust and Ceylon, respectively.  My attempt at one for Scala (before Monocle existed) was called Lentil\u2026\nHow about Bifocals?\n. Or, rather than the awkward adjective, how about Focus?\n. > principle\n_AAAAAAUUUGH!!!_\n. O_O\nFlatten and rebase pls!\n. :+1: \n. I'd be OK with that, but we might consider renaming the new Integral to IntegralType as well, if we go that route.\n. This looks fine to me.  :+1:\n. :+1:\n. Looks good so far!\n. @CodaFi This might be a good opportunity to switch the primary branches to the Swift 2 ones.  Do you want to do that?\n. I'll leave it up to you.  I have no real opinion on this issue.\nClosing.\n. It may have something to do with missing submodules.  Generally, @CodaFi and I use Carthage rather than CocoaPods, so I can't tell you what exactly to do.\n. :+1:  You had the same idea I did after I saw your tweet!   :)\n. :+1:\n. Yay!\n. Update Operadics again plz?\n. :+1:\n. This looks good!  Merge when ready.  :)\n. Having read through this thread, I've just created https://gitter.im/typelift and invited @CodaFi.  Anyone else want in?\n. I guess we can make it public, but I don't know how to do that!\n. Maybe?  I'm on mobile right now, so it'll have to wait for a few hours.\n. Okay, https://gitter.im/typelift/general has just been created, and it's public!\n. :+1:\nNo idea what it should be called, though\u2026\n. Another option along the same lines would be Alcimede.\n. XD\n. This looks okay to me, although it's midnight where I am, so take any of my recommendations accordingly.  :stuck_out_tongue_winking_eye: \n. :+1: from me, although I skimmed a few parts in the interests of time.\n. Yay!  \ud83d\ude04 \n. That should be Xcode's job, but I'll see what I can do.  :/\n. Promises are pretty inherently mutable; the Futures API should be much more like that of Haskell's async package (conceptually, anyway).\n. We should probably change this to ->>, for consistency's sake.\n. This should probably be lhs shouldn't it?  And the same for the one after?\n. I just noticed:  why is this not a class func?\n. Oh, right.  I forgot!  :/\n. I think this needs a bit more description, but I can have a go at it if you would rather not deal with trying to explain zippers to the incoming Objective-C crowd.  :)\n. Should these really all be unconditionally unavailable?  Why not just get rid of them, period?\n. :(\n. Should probably be either Ctrl- or ^, to match what Apple uses.\n. This is not what imap does.  imap stands for \"index map\", and it's purpose is to be the \"alternate\" (left) map function for right-leaning bifunctors (whose right map function is just fmap).  It's used in this capacity by IxState, IxStore, etc.\n. Should we mention that the context here is comonadic?\n. Very.  :open_mouth: \n. At the time it was commented out, it didn't compile.  I had intended to do exactly what you just did at some point, but it seems I forgot.  :)  Thanks!\n. Is there a way to mark inline code snippets in whatever \"SwiftDoc\" uses?  That would be the ideal solution here.\n. This is fine by me.  I also prefer the indentation of operator spec data.  :)\n. \"Contained within\"?\n. We should probably use \"type\" here rather than \"set\", since Swift types are not really sets in any mathematically sensible way, and people not familiar with abstract algebra and/or category theory will be confused by the fact that there is also a Set collection type.\n. How about:  \"Returns a Lens that targets the newline-seperated sections of a String\"?\n. I'm used to seeing a space between the @autoclosure and the (), but I guess that's just stylistic choice.\n. Should probably be:\nswift\nf \u00a7 g \u00a7 h \u00a7 x = f(g(h(x)))\nI don't think what currently written there is valid Swift!  :P\n. Option-Shift-5, for me.  :/\n. Leaving them unconditionally unavailable is fully equivalent to just removing them outright, except you get to control the error message they get.  :)  I'm not sure how much that buys us, here.  They'll have to update their code no matter which of the two we pick.\n. Sure.  Leave this sentence here, then, so I can prod myself about it later.  :)\n. Well, for now, then, let's make it initial caps when referring to a type and all lowercase when referring to a concept.  Good?\n. No big deal.  :)\n. \"Encapsulated by\", \"in the context of\", \"lifted into\", \"pseudomodal via\", the list goes on and on...\n. In that case, I can try.  :)\n. Top and Bottom are two very different types.  In poetic terms, they are the trivial and the impossible, respectively.\nUnfortunately, Void in Swift is not the same as Void in Haskell, but rather the same as void in the extended C language family.  In fact, it's defined in the standard library as a typealias for Unit.\nWe could go with the name Nothing, or we could switch to Bottom (in which case we should also have typealias Top = Unit), but we shouldn't get rid of this entirely, and we definitely shouldn't use the rewrite that you have done here.  An enum with no cases is the only way to represent the Bottom type in Swift right now;  Void is not the same thing in this language.  :(\n. I would change \"an array with a zipper\" to \"a zipper for arrays\", but yes, this is better.  Thanks!  :)\n. :)\n. Yay!\n. I think so; that way, anyone who wants to look at them doesn't have to go digging through the codebase.  The downside is that they'll have to be updated in synchrony.\n. I'll take a closer look at what we have right now, and see how we can improve and expand it.\n. Yes.  I don't know how I missed that.  :O\n. That sounds good to me!\n. I'll change it, then.\n. You may want to reconsider this change, and some of the ones above and below it.  :\u00fe\n. While I'm thinking about it: should we make this init!(arrayLiteral:) instead of trapping unconditionally?  The use of implicitly-unwrapped optionals should mean swiftc is fine with the overriding of an init with an init!.\n. This sentence is in severe need of some commas!\n. I think we can go to three, and leave anything higher to individuals who might need it (since they can implement them trivially with what we give them).\n. Overload, since Swift allows it, but I don't actually care that much either way.  \ud83d\ude04 \n. ",
    "ejenk": "In this case, the law I want is for the action to play nicely with vector addition, so that (v + w) |> x is equal to v |> w |> x. But is there even a way to make sure the law is obeyed without using dependent types? (Idris has ruined ordinary functional languages for me.)\n. :unamused:\n. ",
    "ikesyo": "According to the generated Swift standard lib header in Xcode, LogicValue protocol and its func getLogicValue() -> Bool is used for some control statements and pattern matching. If it is implemented by extensions, this might be enabled (but I did not tested yet).\n. @levinotik Those undeclared types are included in a separate Swiftx framework (as submodule). I think you should add \"Carthage/Checkouts/Swiftx/Swiftx/*.swift\" to s.source_files.\n. @levinotik I'm sorry, we should include submodules as the source. So this works: \n``` ruby\nPod::Spec.new do |s|\n  s.name        = \"Swiftz\"\n  s.version     = \"0.2.1\"\n  s.summary     = \"Swiftz is a Swift library for functional programming.\"\n  s.homepage    = \"https://github.com/typelift/Swiftz\"\n  s.license     = { :type => \"BSD\" }\n  s.authors     = { \"CodaFi\" => \"devteam.codafi@gmail.com\"}\ns.requires_arc = true\n  s.osx.deployment_target = \"10.9\"\n  s.ios.deployment_target = \"8.0\"\n  s.source   = { :git => \"https://github.com/typelift/Swiftz.git\", :tag => \"v0.2.1\", :submodules => true }\n  s.source_files = \"Swiftz/.swift\", \"Carthage/Checkouts/Swiftx/Swiftx/.swift\"\n  # \"Operators.swift\" is also exist in Swiftz.\n  s.exclude_files = \"Carthage/Checkouts/Swiftx/Swiftx/Operators.swift\"\nend\n```\nand pod spec lint --allow-warnings Swiftz.podspec. :wink: \n. @levinotik No worries! But I'm not going to maintain the spec. So I hope anyone else do that instead. :sweat_smile: \n. @CodaFi Done in #194. :zap: \n. You should see swift-develop branch.\n. Okay, I've rebased and this only contains the actual fix now.\n. You should specify :submodules => true option.. And also this line does not matches the current layout:\nhttps://github.com/typelift/Swiftz/blob/0f9c0d9fbed34a6e67ecc2233b44f3076e3f2e8f/Swiftz.podspec#L15. Submitted #336. ",
    "kastiglione": "I was trying to get Functors working using the same technique as this Monad implementation, but the compiler rejects my code, though Xcode's checker does not.\nhttps://twitter.com/cobbal/status/475743791668662276\nEDIT: I see this was already posted in https://github.com/maxpow4h/swiftz/issues/1#issuecomment-45433411\n. ",
    "sritchie": "Another extension to Monoid I was playing around with:\n``` swift\n// This protocol allows you to call plus directly on an instance.\nprotocol Addable {\n    func plus(x: Self) -> Self\n}\n// And an example of how to implement Addable for some type.\n// This feels repetitive... there's certainly some better way to write this thing.\nextension Int: Addable {\n    var monoid: IntMonoid { return IntMonoid() }\n    func plus(x: Int) -> Int {\n        return monoid.plus(self, x);\n    }\n}\n```\nLet me know!\n. Oh man, somehow i wasn't getting updates for this thread. Glad I checked in. Let me read up, one sec.\n. @cartazio As the author of that library, I COMPLETELY understand, and will for all time, that those examples are not Bijections. That doesn't mean that bijection isn't a useful typeclass. (The Bijection library is mostly full of injections,btw.)\n@maxpow4h about the Monoid and Semigroup, I did a bit more playing around and came up with this:\nhttps://gist.github.com/sritchie/27bdf9329027d5cdf02e#file-algebra-swift-L70\nUsing \"Self\" removes the need for the duplication in the type parameter. You also don't have to supply the monoid or semigroup instance as the first argument anymore.\nHappy to make that change too and update the tests if you're interested.\n. @cartazio that's correct about those algebird data structures, I'd love to get some of those in.\n. @maxpow4h about the Injection as a Prism, I'll have to read up.\n. @cartazio yeah, I get that (the injection vs bijection thing). It's a prism vs an injection because of the extra type parameter on Either, correct?\n. ",
    "jckarter": "These already exist on UnsafePointer as the 'alloc' and 'free' methods. 'CMutablePointer' and so on are just implicit conversion conduits for C interop; you can pass UnsafePointers, addresses of variables, or arrays to them directly without constructing them yourself.\n. ",
    "ryanbooker": "At the risk of invoking the wrath of the gods, have you considered \u2022 or \u00b7 for composition? Easy to type on a Mac: Option + 8 or Option + Shift + 9.\n. Yeah fair enough. I like that it's >>=, but was concerned about confusion.\n. re: the \"hard to type\" fear, \u00a7 is just as easy to type as $, ^ or %\u2026 it's \u2325 6 (Option 6) on a Mac keyboard. I suspect we'd get used to typing it very quickly. Just an idea. I guess switch from a shift to option is a small pain. :)\n. Ah, fair enough. I suppose it may be cumbersome for some language keyboards?\n. Just wondering if there is any plan to have full Carthage support? Or even is there anything a contributor could do to help achieve that?\n. Fantastic. Thanks for that. Much appreciated.\nIs it intended that the iOS projects in Swiftx/z/Check have an 8.4 deployment target? This restricts the projects to Xcode 6.4 beta at the moment (i.e. builds fail with Xcode 6.3)\u2026 however the projects do build in Xcode 6.3 for 8.3 if you change the deployment target back manually.\n. Yep no problem. I'll get to that in the next day or so.\n. @CodaFi I have some questions with the tests.\nWhile looking at your SwiftCheck test for sequence on Gen, I noticed (at least it looks like) the order is being reversed by sequence. Is that intended?\nIs the shape of a test for a give type M supposed to look like the following?\nproperty(\"Gen.sequence occurs in order\") <- forAll { (xs : [String]) in\n    return forAllNoShrink(sequence(xs.map(M.pure))) { ss in\n        return ss == xs\n    }\n}\nIf so, it seems that forAllNoShrink etc need to be implemented for all the types being sequenced, in SwiftCheck\u2026 Is that correct or have I missed something?\n. Sorry. I was totally side tracked by Easter and work. I'm happy to write the tests, but I think I need some pointers/direction. I'm not particularly familiar with QuickCheck style testing. My first question:\nIs the shape of a test for a give type M supposed to look like the following?\nproperty(\"sequence occurs in order\") <- forAll { (xs : [String]) in\n    return forAllNoShrink(sequence(xs.map(M.pure))) { ss in\n        return ss == xs\n    }\n}\nIf so, it seems that forAllNoShrink etc need to be implemented for all the types being sequenced, in SwiftCheck\u2026 Is that correct or have I misunderstood what is happening?\n. A Haskeller friend also pointed out that sequence . fmap (what I actually needed sequence for) is traverse, should I/we look into that?\n. To check my understanding, is this the right track?\nproperty(\"sequence occurs in order\") <- forAll { (xs : [String]) in\n    return forAllNoShrink(Gen.pure(sequence(xs.map(Optional.pure)))) { ss in\n        return ss! == xs\n    }\n}\nxs.map(M.pure): transform the list into [M x]\nsequence: sequence that list to get an M [x]\nGen.pure: create a generator for the M [x]\nThen compare the [x] with xs\n. Tests added. Stream test is commented out. It causes the test suite to grind to a halt. I also added a special case to sequence for Arrays. If there's a better way, please let me know. But it was needed to ensure sequence([]) returns [], rather than [[]].\n. I'm not sure I understand what you mean. Do you mean basically remove sequence for Stream? So the test would be something like (or not even needed):\nproperty(\"sequence occurs in order\") <- forAll { (xs : [String]) in\n    let seq = sequence(xs.map({ Stream.pure($0).take(1) }))\n    return forAllNoShrink(Gen.pure(seq)) { ss in\n        return ss.first ?? ss == xs\n    }\n}\n. It seems to be the actual sequence call that can take forever\u2026 I only compare the head of the stream against the original list for equality, and changing that to use take doesn't help. I assume I've just made a mistake that I can't see due to an incomplete understanding of Stream.\n. Yeah, ok. That's what I did above. But that's not really testing sequence on Stream then.\n. Thanks. No drama. It was a good learning process. Seems only fair seeing I use the project. :)\n. Me either. Just noting that it no longer works (I was using Carthage, but need to move to Cocoapods).\n\nOn 9 Feb 2018, at 13:35, Robert Widmann notifications@github.com wrote:\nI'm unsure of what I'm suppose to do to fix this.\n\n. Ah! Great. Thank you for the tip and the fix. Cheers.. It slows down to the point of not completing in any reasonable time. Assuming you mean wrapping it like other uses of take.\nreturn forAll { (n : UInt) in\n    ...\n    }\n. Doesn't make a difference, even with 1...2.\n. ",
    "rnapier": "See #37 for an example of what I'm talking about with GCD. What other GCD features were you thinking about?\n. ",
    "jspahrsummers": "What's the linker failure?\n. :100:\n. I would suggest breaking swiftz down into multiple discrete frameworks if possible. Utility toolkits generally don't (and, arguably, shouldn't) see much use on their own, because a lot of the API surface would go unused by most consumers.\nIMHO, swiftz should mean \u201ctype-level primitives missing from the standard library,\u201d and other components can be grouped into other small projects as appropriate\u2014JSON, Future, Parser, etc. all seem nicely separable.\nOf course, it's your baby, so the decision is ultimately yours. I'll just be happy to have a core library that's primarily type system stuff. :smile: \n\nproject (you would Xcode depend on this, not the workspace?)\n\nYup, exactly. This is how Mantle, RAC, etc. works today.\nThe advantage of this is that the library workspace can include all of its dependencies, leaving them out of the project file, and then the application workspace can include exactly one copy of every dependency, no matter how deeply nested or duplicated.\n\n2 products, both frameworks / static libs.\n\nI could be way off-base, but my impression is that Swift development is going to greatly favor frameworks, since they correspond more closely to LLVM modules, and can now be used on iOS too. A static library version might be unnecessary.\n. :100::bow: Is there any reason not to put swiftz_core into its own repository too?\n. \n. FWIW, this merge combinator comes from a monad implementation that explicitly does not follow Haskell's example. It is based around fmap and join (merge) instead, so I disagree that bind is any kind of generalization here.\n. I'm a huge :-1: on this. I just want Box, Either, and Result, and every new dependency and unnecessary module increases my maintenance burden as a library author, and increases the perceived bloat of my library.\nIn order for this to be viable for me, I would want Basis to contain only those things that are essential to writing typical Swift programs. To me, that does not include IO, types from category theory, etc.\n. @CodaFi You shouldn't need a Cartfile if it would just be empty. The main thing would just be making sure everything builds with carthage build --no-skip-current.\n. @CodaFi There's no way to treat them separately except with separate repositories. :confused: \n. Carthage reads schemes from one project file. You'll have to put both platforms' targets in the same project for it to work.\n. Nope.\n. @CodaFi You can combine the targets into one project file. That's the typical thing to do anyways, because it helps with dependency resolution in other multi-platform projects.\n. :sparkles:\n. The Swift Programming Language says:\n\nCustom operators can be defined only with the characters / = - + * % < > ! & | ^ . ~\n\nSo this may not work in the future.\n. ",
    "mpurland": "Is this still an issue in Swift 2? \n. It would be nice to update the JSON error handling to return an Either for JSON results of the given type or an error.\n. It looks like it's a bit more complicated than that. Particularly with ListGenerator.\n. See this pull request https://github.com/maxpow4h/swiftz/pull/73\n. Closing this for now. There's more to be done.\n. Code review updates committed. I'm excited to move to Beta 4 too.\n. Tuple2 is still here even though Swift 2 support went in. Shall I do a PR to remove it?\n. Typically, this will happen when the sub-expression is too complex. I've seen this happen when the type is \"too hard\" to infer. So in by helping the compiler by adding the type: let p1 : String?  should help.\n. The JSON example could use some updating now that the JSON example has changed. I would either remove the User.create function or convert it to a explicit curried function.\n. @CodaFi I think this is good for now, but we should add documentation for using <?? and enums. This could even be broken out into a separate JSON serialization documentation README. What do you think?\n. That makes sense. Thanks. \n. To fix the issues with the JSON decoder related to NSNumber. Would you be open to pull requests to fix it?\n. @CodaFi I was thinking that as well. Mainly, there's an issue around the numbers implementation in JSON. It doesn't fully support integers and unsigned long integers. I was thinking to add on to JSONValue with support for Int, Int64, and Float. I'm fully prepared to fix it.\n``` swift\nextension Int : JSON {\n    public static func fromJSON(x : JSONValue) -> Int? {\n        switch x {\n        case let .JSONNumber(n):\n            return Int(n)\n        default:\n            return Optional.None\n        }\n    }\npublic static func toJSON(xs : Int) -> JSONValue {\n    return JSONValue.JSONNumber(Double(xs))\n}\n\n}\n```\nNotice it is a JSON extension to Int, but fromJSON lets the JSONNumber (which is currently only a Double) to an Int. Also, toJSON here converts the Int to a JSONNumber with a Double value.\nExample JSON:\njson\n{\n    \"id\" : 103622342330925644\n}\nBut when loaded in with Swiftz, it becomes 1.036223423309256e+17.\nA failed unit test fails with: failed - expected to equal <103622342330925644>, got <1.036223423309256e+17>\nDoes a pull request with those outlined additions/fixes sound good?\n. Submitted PR #264 \n. Closing this as #264 was merged.\n. @CodaFi Your welcome. I'm happy to contribute. I've updated the PR with updates from your code review.\n. @CodaFi Great, thanks! Anything else currently needing looked at on Swiftz? I would love to help out. I'll start looking at SwiftCheck to help with unit tests in the future.\n. Will do.\n. @CodaFi What about negative tests for JSONValue.decode?\n. That could work. I wonder if that could be used in conjunction with generators for each JSONValue type array, object, string, and all types of numbers.\n. I think so too. I was trying to accomplish that on a small scale (at least for numbers) in JSONSpec. If more tests were added (like in Aeson) I think it would accomplish enough test coverage for the JSON decoder & encoder.\nReference: https://github.com/bos/aeson/tree/master/benchmarks/json-data\n. Not sure if this issue should go here or Operadics.\n. Done\n. Should be good to go after tests are complete.\n. :+1: \n. Let me know if this works.\nI updated it to just use l.mapKeyValues { $0 } because l.mapKeyValues(identity) doesn't seem to compile on the Travis CI server (Compiles on my machine using Xcode 7.1.1 though)\n. I'll create a new pull request for the dictionary and array extensions. I'll have more updates coming soon too related to Tyro. Closing this PR for now.\n. I think it could be separated out, but I think this is possibly the last of the extensions. I can't think of anything else that would be needed out of the box for json. Thoughts?\n. We could create another subproject like you have done with Swiftx and Operadics. Perhaps a library around JSON, Foundation, or UIKIt related extensions that would be functional in nature? \nAnother possible way is to use protocol extensions to avoid the implicit overloads. This would force the client to have to explicitly opt-in.\n``` swift\npublic protocol DateTimestampJSONConvertible: JSON {\n}\nextension DateTimestampJSONConvertible where Self: NSDate {\n    public static func fromJSON(x : JSONValue) -> NSDate? {\n        switch x {\n        case .JSONNumber(let value):\n            return NSDate(timeIntervalSince1970: value.doubleValue / 1000.0)\n        default:\n            return nil\n        }\n    }\npublic static func toJSON(date: NSDate) -> JSONValue {\n    return JSONValue.JSONNumber(date.timeIntervalSince1970 * 1000.0)\n}\n\n}\n```\nThe opt-in:\nswift\nextension NSDate: DateTimestampJSONConvertible {}\n. No longer applicable. Closing.\n. That makes sense. I'll draw up a PR. \n. PR #273 \n. I think you are right, it is the only section of Swiftz that requires Foundation and is completely separate in principle from the rest of the library. We could separate it out. I think there are a couple of paths.\n1) Separate out JSON parsing as-is into a different framework with Swiftz as a dependency. (implicitly also Swiftx and Operadics). Perhaps we could call it Swiftj? \n2) Use a separate framework like Argo for JSON parsing. There would be a migration and backwards compatibility problem with this approach.\n. @CodaFi To clarify, do you mean to separate the Swift JSON parsing in Swiftz into a separate framework (like you are saying with Concurrent, Focus, Swiftx, etc) or to deprecate/remove it entirely and give a migration path to users of Swiftz to use another library like Argo?\n. @CodaFi I'm up for it, thanks. Any thoughts about the name of the new package?\n. I like those ideas. Tyro or Thessalus would be good. Also, we could consider Zetes (The Boreads, brothers Calais and Zetes) \"They were Argonauts and played a particularly vital role in the rescue of Phineus from the harpies.\" since it contains a z. \n. I think these are good options. I also like Tyro for the length, Zetes because of the inclusion of z, and Alcimede sounds good.\n. Janeway would be alright. JWay would sound a little too much like a Java framework.\n. @CodaFi Thanks. Yes, let's merge what is currently there (if it makes sense) and then start using the latest in master as a base. What do you think?\n. @CodaFi This is a first pass. I'll create the official repository after I can put a little more time into it. Take a look here: https://github.com/mpurland/Tyro\n. I believe it's ready to be reviewed (https://github.com/mpurland/Tyro). Let me know what you think. I've added Travis CI integration and have ~75% test code coverage so far. I'll be adding more tests later with exact tests around the same json-data as Aeson and performance tests around large json data sets.\n. :boat: See https://github.com/typelift/Tyro\n. Should I move this over to Algebra?\n. How I long for the days that Swiftc doesn't crash...\nWill do. I'll update the remaining projects with the build scripts this evening.\n. Since this will be a breaking change, should the next version be 0.4.0?\n. @CodaFi Any red flags so far?\n@pthariensflame If you have a chance, let me know what you think of Tyro. \n. Now it's time to wait and see how many issues come in.\n. If this works and is acceptable we can probably use this across the rest of the TypeLift projects\n. Took me awhile last night to figure out why the iOS tests were stalling in Tyro on Travis...what a headache. Hopefully this works...\n. :boat: \n. Looks good. Can you change the Tyro PR to use it?\n. A reader monad would be nice. :+1: \n. I can take a look and see what I can come up with unless you want to @CodaFi?\n. Here's my first attempt. Let me know what you think of the PR. \n284\n. :+1: \n. @CodaFi Any thoughts about the ask/asks api? I tried to match as closely as I could to Haskell mtl in Swift.\n. @CodaFi Latest commit with update based on your comments.\n. Rebased from master now. After tests pass should be all ready to go. :)\n. :+1: \n. Not sure why it worked on Travis, but not through Carthage. This should fix it. I can confirm it's fixed locally when pointing to my branch.\n. :+1: :boat: \n. :+1: \n. I wonder if the two are related as well.\n. (Tuples need more formal support in Swift, but let's leave that for swift-evolution) :)\n:+1: \n. :boat: \n. Resolved. See #293 \n. :+1: \n. :+1: \n. :boat: \n. @gcornut Thanks for the PR!\n. The Reader issue seems to be an issue related to associated types.\n\n. Do we need to write the sequence function for Reader? I'm worried this may be a language/compiler limitation.\n. Everything looks good.\n:+1: :boat: \n. I like it. :+1: \n. The problem with prebuilt binaries is that they only work for the version they were compiled with. Has this changed?\n. @blender Good point about the source compatibility. Including a binary for Xcode 7.3/Swift 2.2 would allow easier use and faster build times with Carthage.\n@CodaFi Thoughts?\n. When you go past a few statements without telling the Swift compiler the type it will fail with:\nExpression was too complex to be solved in reasonable time; consider breaking up the expression into distinct sub-expressions since it would have to infer the types.\n. I keep hoping that also. As far as I can tell it seems like a toss up. Is it okay to keep it broken up like this?\n. :+1: \n. :white_check_mark: \n. I'll make it private it again, but will work on an implementation that is typesafe in all cases and allows returning a proper error. I'm thinking something similar to Aeson's eitherDecode using an Either sort of type.\n. Come to think of it a more fitting name might be zipMap or groupBy. A similar function is called groupBy in Scala, but to accomplish this similarly we could just take in a function f that returns a key k for the value v corresponding to that element. Pseudo code:\nzip(map(f)).toDictionary\nThoughts?\nSent from my iPhone\n\nOn Nov 13, 2015, at 5:29 AM, Robert Widmann notifications@github.com wrote:\nIn Swiftz/DictionaryExt.swift:\n\n@@ -6,14 +6,24 @@\n //  Copyright (c) 2014 Maxwell Swadling. All rights reserved.\n //\n+extension Array {\n-   /// Creates a dictionary from the array given a transformer function that returns \n-   /// a (key, value) pair for the dictionary, if nil is returned then the value is\n-   /// not added to the dictionary.\n-   public func mapKeyValues(f : Element -> (K, V)?) -> [K: V] {\n  Is there a more vivid name for this combinator? mapAssoc or mapAssociate, etc.?\n\n\u2014\nReply to this email directly or view it on GitHub.\n. I haven't heard of label, but that could make sense in that you're applying a label (a key) to each value.\n. @CodaFi Just did another commit attempting to pull in the idea of label and pairs. I also found a cleaner way to create a Dictionary from a list.\n. Sorry about that, probably missed it when I was grabbing it from the other PR.\n. I'm assuming you mean through the use of ArrowOf<Int, String>?\n. :+1: \n. :white_check_mark: \n. I think in many cases protocols are the way to go, but may not be needed in some places.\n. Sounds like a plan. :+1: \n. This was supposed to be just a helper, but can be removed.\n. It was intended to give ask functionality of the form A -> A to support runReader. \n\n``` swift\nlet lengthResult3 = runReader(ask())(1234)\nXCTAssert(lengthResult3 == 1234)\nlet lengthResult4 = runReader(ask)(1234)\nXCTAssert(lengthResult4 == 1234)\n```\nI'm open to suggestions. How would you update the ask function to be a monadic action in the reader? So far I've run through a few different options, but each isn't working as I saw it should with runReader.\nThese are some of the options, but none of these are right.\n``` swift\npublic static func ask() -> (R -> A) -> Reader {\n    return { (f : R -> A) in\n        return Reader(f)\n    }\n}\npublic static func ask() -> A -> Reader {\n    return { a in\n        return Reader { _ in a }\n    }\n}\npublic static func ask(f : () -> A) -> Reader {\n    return Reader { _ in f() }\n}\n```\n. @CodaFi Should I remove the global ask function then? What do you think?\n. What's the reason making this non-public?\n. ",
    "maxcan": "doesn't seem like it.  I'm preparing a pull request.\n. This would definitely be cleaner, but I can't seem to get it to build (screen shot below).\nAlso, when I was working on this, I had to add swiftz_core.xcodeproj to swiftz in order to have swiftz build either on its own or as a sub project of my app.  Is there a reason not to do this?\n\n. Works for me, thanks!\nOn Sat, Jul 5, 2014 at 5:20 PM, Maxwell Swadling notifications@github.com\nwrote:\n\nIt looks like you don't have swiftz_core_ios in your project, but you do\nhave swiftz_ios.\nI pushed some changes, can you check that and try it with the new xcode\nconfig?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/maxpow4h/swiftz/pull/55#issuecomment-48099704.\n. :+1: \n. thanks @ikesyo \n. I just realized that second A is the \"type to parse from\" looking at the comments on #72 .  that may fix this.  but, how come JArray needs that second argument?\n. related: #69 \n. I've actually been using the libraries slightly differently and including the .xcodeproj bundles in my main project and letting xcode sort out the dependencies.  its a bit of a non-trivial process.  I haven't documented it because I have no idea if its the \"right\" way to do things in xcode land but it feels better to me.\n\nalso, I suspect that most contributors here, myself included, have far more experience in something like haskell, ocaml, or scala than cocoa/obj-c.  so, there might be some confusion as to the best way to do things in the xcode world.\n. my PRQ into this branch will resolve the merge conflict and issues I described above.  still unclear on the Future.sig issue though.\n. nevermind.  I just realized that bifunctors will completely implement, more generally, the functionality here.\n. If you're happy, I'm happy.\nOn Monday, July 28, 2014, Maxwell Swadling notifications@github.com wrote:\n\n@maxcan https://github.com/maxcan yeah, but sometimes it is useful to\nprovide less general functions that serve the same purpose. With either\nyou know it was an Either, not a a : BiFunctor. Also, it could help with\ntype inference. I would merge it.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/maxpow4h/swiftz/pull/83#issuecomment-50318423.\n. got the mvar pattern working.  will submit another PRQ only resolving the merge conflict for #82 \n. Might it make sense to prefix all of the swiftz operators with an unusual\nbut legal character so that they're easy to spot and so that we get a bit\nof namespacing out of it?\n. i think that swift support is basically ready, users just need to write a pretty simple bridging header file and its good to go.\n. I think that labeling this as internal will break my use case where I initialize a future, return it, and then asynchronously sig it in a call back.\n. result() just get's the result right?  here's my basic flow in a slightly bastardized haskell\n\n``` haskell\ngetFuture :: Future A\ngetFuture = do\n    a <- newFuture  -- Future.init\n    runSomeAsyncLibFunctionWithCallback $ \\result -> a.sig(result)\n    return a\nuseFuture = do\n    val <- getFuture\n    -- Future.map\n    val.map $ \\result -> ...\n```\n. I'll try that.  it may create some deadlocking issues.  I  was following a pretty common pattern in JS promises where you init, return, async-satisfy.  does that break some kind of invariant in the futures spec?\n. I see the immutability value.  I'll try the future + mvar pattern.\nOn Sat, Aug 2, 2014 at 5:48 AM, Maxwell Swadling notifications@github.com\nwrote:\n\nIn swiftz/Future.swift:\n\n\npublic func sig(x: A) {\ninternal func sig(x: A) {\n\n\nInteresting, I didn't know about this promise pattern.\nI would suggest using a Future and MVar. We can add a function that\nconveniently wraps this pattern.\nI will also be removing the empty init from future to more closely\nrepresent a Future async package.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/maxpow4h/swiftz/pull/82/files#r15728875.\n. \n",
    "mlen": "Wouldn't it be better this way?\nfunc curry<A,B,C>(f: (A, B) -> C)(a: A)(b: B) -> C {\n  return f(a,b)\n}\nI find this syntax cleaner (apart from the ugly labels that need to be used during function calls).\n. ",
    "akuraru": "I had thought it this way\nfunc curry<A, B, C>(f: (A, B) -> C) -> A -> B -> C {\n    return ({(a: A) -> B -> C in\n        {(b: B) -> C in\n            f(a,b)\n        }\n    })\n}\nI made \u200b\u200ba issue without thinking. Do you have precedent implementation of now?\n. ",
    "bleis-tift": "current curry function is NOT curry.\nyou should rename it to more correct name.\n```\ncurry: (A\u00d7B -> C) -> (A -> B -> C)\nuncurry: (A -> B -> C) -> (A\u00d7B -> C)\nf: int\u00d7int -> int\ng: int -> int -> int\nf = uncurry(curry(f))\ng = curry(uncurry(g))\n```\n. ",
    "tonyd256": "So if I just want to have an array of dictionaries should I type it as a JSValue array like : let events: [JSValue] = d[\"events\"] >>= JArray.fromJSON or like this: let events = d[\"events\"]>>= JArray<JSValue,  JSValue>.fromJSON?\n. A few nit picks and questions but otherwise :+1: \nHope this gets merged soon I want to move to beta 4 :smiley: \n. I think returning JSNull would also be a good option if you'd rather not have it be an optional.\n. @tLewisII should be all set now.\n. Thanks everyone for the suggestions.  Currently I have the 2 projects (swiftz and swiftz_core) imported into my workspace and liked the frameworks in the \"Linked Frameworks and Libraries\" section under the app target.  This works fine except that I have warnings/errors in my build that Live Views won't render because it can't find \"@rpath/swiftz_core.framework/swiftz_core\". It's not a huge deal because I can still build and run, but I can't view my Live Views.  Also, running the app on a device crashes with that same error.\nI tried building the project separately and grabbing the .frameworks it generates but linking against those some how didn't work.  It didn't recognize any of the classes such as JSValue that I was trying to use even though i was importing them.\nSo for now I'll stick with having the source in there.  I'm hoping the most of the issues i'm seeing are due to beta things and will resolve eventually.\n. if you do this above then you probably don't need the switch anymore since every case is going to go through case _:\n. extra line here\n. should this still be final as well as public?\n. ",
    "subdigital": "Yes, that is what I meant :)\n. I guess I can get around this by making Post a bit more flexible:\nswift\nif let innerPost = d[\"post\"] as? JSValue {\n   return fromJSON(innerPost)\n}\n...\nThen this works:\nswift\nlet posts = json >>= JArray<Post, Post>.fromJSON\n. It seems a bit limiting that JDictionary only works when the entire dictionary has the same type of value.  Since this is very rarely the case in practice, I'm wondering when this class would prove useful.\n(Just thinking out loud, because there is not much written on the topic)\n. Just wanted to leave a note of thanks.  I made a couple of screencasts covering the JSON parsing design here:\nhttp://nsscreencast.com/episodes/130-swift-json-redux-part-1\nhttp://nsscreencast.com/episodes/131-swift-json-redux-part-2\n:+1: \n. ",
    "amackworth": "Seems to work for me as well. \n:+1: \n. Yay, fixed by #98! \ud83c\udf89\n. ",
    "lawrencelomax": "Most confusingly for me is the associativity of >>= due to the overload. In the Swift stdlib, it is declared as:\ninfix operator >>= {\n    associativity right\n    precedence 90\n    assignment\n}\nThis means I need to add brackets in order to ensure the compiler interprets as if each application of bind was left-associative:\n// The parser functions are curried and return optional xml values\nlet code = ((xml >>= XMLParser.parseChild(\"CrsCode\")) >>= XMLParser.parseText) //Correct\nlet code = xml >>= XMLParser.parseChild(\"CrsCode\") >>= XMLParser.parseText //Compiler Error\n. ",
    "sebinsua": "Has anybody created a spec for this yet?\n. ",
    "levinotik": "I'm not very familiar with cocoapods (or swift for that matter), but I went ahead and tried to create a podspec file. The file I created looks like this: \n``` ruby\nPod::Spec.new do |s|\n  s.name        = \"Swiftz\"\n  s.version     = \"0.1.4\"\n  s.summary     = \"Swiftz is a Swift library for functional programming.\"\n  s.homepage    = \"https://github.com/typelift/Swiftz\"\n  s.license     = { :type => \"BSD\" }\n  s.authors     = { \"CodaFi\" => \"devteam.codafi@gmail.com\"}\ns.requires_arc = true\n  s.osx.deployment_target = \"10.9\"\n  s.ios.deployment_target = \"8.0\"\n  s.source   = { :git => \"https://github.com/typelift/Swiftz.git\", :tag => \"v0.1.4\"}\n  s.source_files = \"Swiftz/*.swift\"\nend\n```\nAs you can see, it's set up to grab the v0.1.4 tag from the repo. \nThen I ran pod spec lint which grabs the tag from the repo and runs the linter. I got the following errors:\n``` bash\n\u279c  Swiftz git:(cocoapod) \u2717 pod spec lint\n-> Swiftz (0.1.4)\n    - ERROR | Returned an unsuccessful exit code. You can use --verbose for more information.\n    - WARN  |  Swiftz/Swiftz/ArrayExt.swift:89:34: warning: extraneous '#' in parameter: 'rhs' is already the keyword argument name\n    - ERROR |  Swiftz/Swiftz/Arrow.swift:68:8: error: class methods are only allowed within classes; use 'static' to declare a static method\n    - ERROR |  Swiftz/Swiftz/Arrow.swift:98:8: error: class methods are only allowed within classes; use 'static' to declare a static method\n    - ERROR |  Swiftz/Swiftz/Arrow.swift:173:8: error: class methods are only allowed within classes; use 'static' to declare a static method\n    - ERROR |  Swiftz/Swiftz/Arrow.swift:190:8: error: class methods are only allowed within classes; use 'static' to declare a static method\n    - ERROR |  Swiftz/Swiftz/Bounded.swift:14:8: error: class methods are only allowed within classes; use 'static' to declare a static method\n    - ERROR |  Swiftz/Swiftz/Bounded.swift:15:8: error: class methods are only allowed within classes; use 'static' to declare a static method\n    - ERROR |  Swiftz/Swiftz/Category.swift:33:8: error: class methods are only allowed within classes; use 'static' to declare a static method\n    - ERROR |  Swiftz/Swiftz/Functor.swift:30:19: error: 'autoclosure' attribute is now an attribute of the parameter declaration, not its type\n    - ERROR |  Swiftz/Swiftz/Functor.swift:69:19: error: 'autoclosure' attribute is now an attribute of the parameter declaration, not its type\n    - ERROR |  Swiftz/Swiftz/Future.swift:37:43: error: 'autoclosure' attribute is now an attribute of the parameter declaration, not its type\n    - ERROR |  Swiftz/Swiftz/HList.swift:16:8: error: class methods are only allowed within classes; use 'static' to declare a static method\n    - ERROR |  Swiftz/Swiftz/HList.swift:17:8: error: class methods are only allowed within classes; use 'static' to declare a static method\n    - ERROR |  Swiftz/Swiftz/HList.swift:18:8: error: class methods are only allowed within classes; use 'static' to declare a static method\n    - ERROR |  Swiftz/Swiftz/HList.swift:19:8: error: class methods are only allowed within classes; use 'static' to declare a static method\n    - ERROR |  Swiftz/Swiftz/JSON.swift:198:8: error: class methods are only allowed within classes; use 'static' to declare a static method\n    - ERROR |  Swiftz/Swiftz/JSON.swift:203:8: error: class methods are only allowed within classes; use 'static' to declare a static method\n    - ERROR |  Swiftz/Swiftz/List.swift:38:16: error: 'autoclosure' attribute is now an attribute of the parameter declaration, not its type\n    - ERROR |  Swiftz/Swiftz/MVar.swift:40:29: error: 'autoclosure' attribute is now an attribute of the parameter declaration, not its type\n    - ERROR |  Swiftz/Swiftz/Monoid.swift:12:8: error: class properties are only allowed within classes; use 'static' to declare a static property\n    - ERROR |  Swiftz/Swiftz/Monoid.swift:23:20: error: 'autoclosure' attribute is now an attribute of the parameter declaration, not its type\n    - ERROR |  Swiftz/Swiftz/Monoid.swift:40:20: error: 'autoclosure' attribute is now an attribute of the parameter declaration, not its type\n    - ERROR |  Swiftz/Swiftz/Monoid.swift:57:20: error: 'autoclosure' attribute is now an attribute of the parameter declaration, not its type\n    - ERROR |  Swiftz/Swiftz/Monoid.swift:82:20: error: 'autoclosure' attribute is now an attribute of the parameter declaration, not its type\n    - ERROR |  Swiftz/Swiftz/Monoid.swift:103:20: error: 'autoclosure' attribute is now an attribute of the parameter declaration, not its type\n    - ERROR |  Swiftz/Swiftz/Num.swift:13:8: error: class properties are only allowed within classes; use 'static' to declare a static property\n    - ERROR |  Swiftz/Swiftz/Num.swift:14:8: error: class properties are only allowed within classes; use 'static' to declare a static property\n    - ERROR |  Swiftz/Swiftz/Pointed.swift:12:8: error: class methods are only allowed within classes; use 'static' to declare a static method\n    - ERROR |  Swiftz/Swiftz/SYB.swift:15:8: error: class methods are only allowed within classes; use 'static' to declare a static method\n    - ERROR |  Swiftz/Swiftz/SYB.swift:17:8: error: class methods are only allowed within classes; use 'static' to declare a static method\n    - ERROR |  Swiftz/Swiftz/Semigroup.swift:28:19: error: 'autoclosure' attribute is now an attribute of the parameter declaration, not its type\n    - ERROR |  Swiftz/Swiftz/Semigroup.swift:45:19: error: 'autoclosure' attribute is now an attribute of the parameter declaration, not its type\n    - ERROR |  Swiftz/Swiftz/Comonad.swift:23:11: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Comonad.swift:34:11: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Comonad.swift:40:11: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Pointed.swift:15:11: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Pointed.swift:21:11: error: use of undeclared type 'Result'\n    - ERROR |  Swiftz/Swiftz/Pointed.swift:29:11: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Those.swift:12:12: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Those.swift:13:12: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Those.swift:14:13: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/NonEmptyList.swift:13:20: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/ArrayZipper.swift:46:25: error: binary operator '<^>' cannot be applied to operands of type 'A -> B' and '[A]'\n    - ERROR |  Swiftz/Swiftz/Arrow.swift:135:22: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Arrow.swift:137:23: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Arrow.swift:140:23: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Arrow.swift:145:23: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:44:19: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:42:16: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:48:57: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:57:40: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:61:41: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:38:8: error: type 'EitherBF' does not conform to protocol 'Bifunctor'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:49:10: error: 'EitherBF' does not have a member named 'e'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:50:9: error: enum case pattern cannot match values of the non-enum type '<>'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:52:9: error: enum case pattern cannot match values of the non-enum type '<>'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:110:24: error: argument for generic parameter 'S' could not be inferred\n    - NOTE  |  Swiftz/Swiftz/Iso.swift:32:13: note: in call to function 'identity'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:114:21: error: argument for generic parameter 'S' could not be inferred\n    - ERROR |  Swiftz/Swiftz/Chan.swift:25:9: error: cannot assign to 'mutex' in 'self'\n    - ERROR |  Swiftz/Swiftz/Chan.swift:26:8: error: cannot assign to 'cond' in 'self'\n    - ERROR |  Swiftz/Swiftz/Chan.swift:29:8: error: cannot assign to 'matt' in 'self'\nAnalyzed 1 podspec.\n[!] The spec did not pass validation.\n```\nI'm not sure if I'm even going about this correctly, but wanted to report back my firsts efforts. Perhaps others have ideas about how to proceed. Might just need to fix those linter issues?\n. @CodaFi thanks. Ran it again against the latest from master and got different errors:\n``` bash\n\u279c  Swiftz git:(cocoapod) \u2717 pod spec lint\n-> Swiftz (0.2.1)\n    - ERROR | Returned an unsuccessful exit code. You can use --verbose for more information.\n    - ERROR |  Swiftz/Swiftz/Comonad.swift:23:11: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Comonad.swift:34:11: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Comonad.swift:40:11: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Pointed.swift:15:11: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Pointed.swift:21:11: error: use of undeclared type 'Result'\n    - ERROR |  Swiftz/Swiftz/Pointed.swift:29:11: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Those.swift:12:12: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Those.swift:13:12: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Those.swift:14:13: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/NonEmptyList.swift:13:20: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/ArrayExt.swift:312:9: error: cannot invoke 'span' with an argument list of type '([A], () -> )'\n    - NOTE  |  Swiftz/Swiftz/ArrayExt.swift:312:13: note: expected an argument list of type '([A], (A -> Bool))'\n    - ERROR |  Swiftz/Swiftz/ArrayZipper.swift:46:25: error: binary operator '<^>' cannot be applied to operands of type 'A -> B' and '[A]'\n    - ERROR |  Swiftz/Swiftz/Arrow.swift:135:22: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Arrow.swift:137:23: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Arrow.swift:140:23: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Arrow.swift:145:23: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:44:19: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:42:16: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:48:57: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:57:40: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:61:41: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:38:8: error: type 'EitherBF' does not conform to protocol 'Bifunctor'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:49:10: error: 'EitherBF' does not have a member named 'e'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:50:9: error: enum case pattern cannot match values of the non-enum type '<>'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:52:9: error: enum case pattern cannot match values of the non-enum type '<>'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:110:24: error: argument for generic parameter 'S' could not be inferred\n    - NOTE  |  Swiftz/Swiftz/Iso.swift:35:13: note: in call to function 'identity'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:114:21: error: argument for generic parameter 'S' could not be inferred\n    - WARN  |  Swiftz/Swiftz/Chan.swift:66:7: warning: 'write' was deprecated in * version 2.1: Concurrency primitives are being moved to Concurrent.framework\n    - WARN  |  Swiftz/Swiftz/Chan.swift:72:14: warning: 'read()' was deprecated in * version 2.1: Concurrency primitives are being moved to Concurrent.framework\nAnalyzed 1 podspec.\n[!] The spec did not pass validation.\n```\n. @ikesyo Thanks. Added it and got: \n``` bash\n\u279c  Swiftz git:(cocoapod) \u2717 pod spec lint\n-> Swiftz (0.2.1)\n    - ERROR | Returned an unsuccessful exit code. You can use --verbose for more information.\n    - ERROR |  Swiftz/Swiftz/Comonad.swift:23:11: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Comonad.swift:34:11: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Comonad.swift:40:11: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Pointed.swift:15:11: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Pointed.swift:21:11: error: use of undeclared type 'Result'\n    - ERROR |  Swiftz/Swiftz/Pointed.swift:29:11: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Those.swift:12:12: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Those.swift:13:12: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/Those.swift:14:13: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/NonEmptyList.swift:13:20: error: use of undeclared type 'Box'\n    - ERROR |  Swiftz/Swiftz/ArrayExt.swift:312:9: error: cannot invoke 'span' with an argument list of type '([A], () -> )'\n    - NOTE  |  Swiftz/Swiftz/ArrayExt.swift:312:13: note: expected an argument list of type '([A], (A -> Bool))'\n    - ERROR |  Swiftz/Swiftz/ArrayZipper.swift:46:25: error: binary operator '<^>' cannot be applied to operands of type 'A -> B' and '[A]'\n    - ERROR |  Swiftz/Swiftz/Arrow.swift:135:22: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Arrow.swift:137:23: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Arrow.swift:140:23: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Arrow.swift:145:23: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:44:19: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:42:16: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:48:57: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:57:40: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:61:41: error: use of undeclared type 'Either'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:38:8: error: type 'EitherBF' does not conform to protocol 'Bifunctor'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:49:10: error: 'EitherBF' does not have a member named 'e'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:50:9: error: enum case pattern cannot match values of the non-enum type '<>'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:52:9: error: enum case pattern cannot match values of the non-enum type '<>'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:110:24: error: argument for generic parameter 'S' could not be inferred\n    - NOTE  |  Swiftz/Swiftz/Iso.swift:35:13: note: in call to function 'identity'\n    - ERROR |  Swiftz/Swiftz/Bifunctor.swift:114:21: error: argument for generic parameter 'S' could not be inferred\n    - WARN  |  Swiftz/Swiftz/Chan.swift:66:7: warning: 'write' was deprecated in * version 2.1: Concurrency primitives are being moved to Concurrent.framework\n    - WARN  |  Swiftz/Swiftz/Chan.swift:72:14: warning: 'read()' was deprecated in * version 2.1: Concurrency primitives are being moved to Concurrent.framework\nAnalyzed 1 podspec.\n[!] The spec did not pass validation.\n```\n. @ikesyo Great, so you'll PR that and we can have cocoapod distribution soon? :)\n. ",
    "andymatuschak": "@maxpow4h Whoa cool! How do you import only part of a module?\n. Whoa! I had no idea! Thanks for sharing, @maxpow4h. :dancer: \nWe're actually trying to use JSValue, so we'd need import aliasing to resolve this issue, which it looks like Swift doesn't support.\n. \u2764\ufe0f\nOn Tue, Sep 30, 2014 at 5:14 AM, Maxwell Swadling\nnotifications@github.com wrote:\n\n@andymatuschak @lsavino \nI've updated my code generator to use the new type names (and published the cgi program http://maxs.mobi/cgi-bin/swift-gen-cloud). Hopefully that will be better than writing those JSON instances manually. It is missing some types though (and the error messages are cryptic). Let me know what problems you encounter.\nReply to this email directly or view it on GitHub:\nhttps://github.com/typelift/swiftz/issues/106#issuecomment-57304183\n. Nice, thanks\n\nOn Wed, Oct 1, 2014 at 9:12 PM, Alexander Altman notifications@github.com\nwrote:\n\nJust for the sake of being helpful, there is a way to create an alias on import in Swift, you just have to do it \"manually\".  :)\nCreate a new file, import the objectionable value, type, or member in that file, then provide an alias to that value, type, or member (through let/var/func, typealias, and extension as appropriate) in that file.  You can use the same file for multiple such \"renaming imports\", but it should be used for nothing else.  I like to call it RenameImports.swift, but that's just me.  :)\nReply to this email directly or view it on GitHub:\nhttps://github.com/typelift/swiftz/issues/106#issuecomment-57581000\n. \n",
    "lsavino": "@maxpow4h Yeah, I think here it'll still conflict (if I'm understanding it right). Will send pull request in a minute ;)\n. ",
    "liweiz": "A bit offtopic. Just had a look at Basis. Is that a repo for layman like me to learn fp in Swift and using Swiftz? I'm trying to learn fp with Swiftz, but the learning curve for beginners seems high. What I'm doing is to try to read through the code in Swiftz to learn(and yes, a lot of Google), but I'm also looking for better ways. I read through the readme file over there, but still hope to get a clearer answer.\nI know it has nothing to do with this repo to provide materials for learners. However, this perhaps the best place to ask this question.\nThanks in advance,\nLiwei\n. @CodaFi Thanks a lot for your quick reply. I'll open my comment as an issue there:)\n. @CodaFi I saw there is a big sign for \"Breaking Changes Ahead\" for 0.6.0. Is there any information you could share with us?\n. @CodaFi Thanks for your quick response. No Swiftz-related API change is good news.\n. ",
    "dtchepak": "No worries! Thanks for taking a look. :smile: \nCheers,\nDavid\n. I'm not sure what you mean? (rebased? amended with projection functions removed?)\n. Amended this PR (force-pushed to my branch). Rebased on top of bbdc8f30504d702baeb7e9051973183616ce9bef.\n. Haha, fair enough. Will close the PR. :)\n. ",
    "michaelgwelch": "This is more of a general question so I asked at Stackoverflow as well. http://stackoverflow.com/questions/26691653/how-do-i-link-to-a-3rd-party-swift-framework (I can't even figure out how to  consume my own frameworks.)\n. Sure. I did the following. Pulled the latest code as of just a few minutes ago. Followed your key combination to clean build folders.\nI then rebuilt. I then paid closer attention to the \"schemas\" available. I'm referring to the list of \"targets\" in the menubar just to the right of the run and stop buttons. I currently see 8 listed. \nTwo of the entries are named \"swiftz (swiftz project)\". I can successfully build and test these.\nTwo of the entries are named \"swiftz_core (swiftz_core project)\". I can successfully build but not test these.\nTwo of the entries are named \"swiftz_core_ios (swiftz_core project)\". These run and test successfully.\nTwo of the entries are named \"swiftz_ios (swiftz_project)\". These build. There apparently are no tests.\n. Ok. Let me address your first comment first. Obviously something is wrong with my working directory. \nRunning git status shows no local changes but I'm going to do a git clean -fxd and/or clone a fresh copy of the repository.\n. Well, git clean made a change. Now I see 5 schemes. 4 of them look like yellow lunch boxes, but 1 is a white lego (swiftz_iosTests somehow is listed separate from swiftz_ios).\nOk, going to pull a fresh clone. (I'm using XCode Version 6.1 (6A1052d) by the way).\n. Success! I cloned a fresh copy. Still had issues running the tests for swiftz_core. Said it couldn't load the swiftz_coreTests bundle at /Users/mgwelch/Library/Developer/Xcode/DerivedData/swiftz-dfchxmsrsusopsgocnqvrawwpzyp/Build/Products/Debug/swiftz_coreTests.xctest/Contents/MacOS/\nI went to that location. Deleted the binary that was there. Rebuilt. And then the tests passed.\nThis doesn't make any sense to me since but I'm now building and successfully running all tests.\n. Now I just have the final question of which of these frameworks do I need and how do I add them to another workspace and/or project? \nIn a .Net language using Visual Studio, I'd just right click the project and say \"Add Reference\".\nIn  C/C++ (which I've not used a ton but have used them) I'd add the library to a linker setting and make sure the library was in my link path.\nI really have no clue what to do for frameworks. Apple makes it look like it's as simple as drag/drop or click a + key and add the framework. However, the linker never finds the library I've added. Perhaps I need to make sure the library is copied to the right location when I drag/drop and then make sure some link path is up to date?\n. Just a quick question about dragging the project into the file tree. It looks like you did this in the swiftz project as well, as swiftz_core is embedded under the swiftz project. And the whole swiftz_core project is shown embedded under swiftz.You can expand it and see all the files.\nWhen I drag swiftz into my project, I just get an icon for the project, but none of the files under the project are there. I can't expand the project and navigate. Is this a problem? Can I ignore that? \n. I dragged the xcodeproj. I tried it from Finder. I tried it from one XCode window to another. \n\n(This is not how you consume objective-c frameworks right? This is just a \"stop-gap\" solution until Apple solidifies their swift runtime and adds true support for reusing binary form of swift frameworks? Because this seems to not work too well.)\n. Ok, you do not want to have swiftz open in XCode when you do the drag/drop. That was my problem. I'll move onto the next step now. (Fortunately, I eventually got an error telling me that it couldn't open up swiftz project because it was open already.)\n. Finally, in the copy file phase, the default destination is Resources. Is that correct or should I select Frameworks.\n. Well, thanks for all your help. I'm getting closer but I'm getting a dyld error anyway. \ndyld: Library not loaded: @rpath/libswiftAppKit.dylib\n  Referenced from: /Users/mgwelch/Library/Developer/Xcode/DerivedData/playwithswifts-attigdsrimbroebdxizhevdsxpls/Build/Products/Debug/swiftz_core.framework/Versions/A/swiftz_core\n  Reason: image not found\nOf course, when I look at that location the framework is there. I'm less than enthused with the amount of polish Apple has put into XCode to support Swift. This doesn't seem like a released version of a product, yet.\nNot sure why it's looking there anyway. Shouldn't it be looking wherever we copied them to in the copy files phase?\n. I believe up above when you told me how to add to my project, you skipped a step. I need to add the appropriate framework to the Link phase correct?\nI've done that. Still dyld error.\nNow, I have an extra bonus problem.Now whenever I have swiftz_core framework in the copy phase I get the following build error (which wasn't happening 10 minutes ago).\nUnable to run command 'PBXCp swiftz_core.framework' - this target might include its own product.\nWell, I truly appreciate all of your help. I'm going to call it a night. \nI sure wish Apple had more support for this stuff. This doesn't seem \"ready for prime time\".\n. Ok, maybe I need to try reinstalling XCode. Still get a linker error, but I looked more closely at it. I thought it was saying it couldn't find your framework. But it's a swift runtime framework it can't find:\ndyld: Library not loaded: @rpath/libswiftAppKit.dylib\nSomething like this question might be related: http://stackoverflow.com/questions/24972359/unable-to-load-swift-runtime-library-image-not-found\nI'm going to look into the settings mentioned there.\n. I can link it to a Cocoa App (really wanted a command line app) but decided to play with that. \nI ran all the default tests in the default app template. They run. \nThen I add the following line to a test:\nvar x = List<Int>.Nil;\nor\nvar x:List<Int> = [1,2,3]\nand set a breakpoint. The tests break at that line. But if I try to step into them or step over, or just run the tests without breakpoints - the tests just hang.\nThis is actually the same result I got when I tried creating my own recursive enum implementation of List a few days back. It really seems like my installation of XCode is sick. I think I'll bite the bullet, uninstall, clean the best I can, and reinstall.\nThanks for all of your help.\n. I give up. Still can't get it to work. I could try to troubleshoot by figure out where it's looking for rpath but I'm not familiar enough with the build tools to even know how to get it to spit out what it thinks @rpath is.\nI reinstalled XCode, created a default projected, made all the changes you said and still dylib can't find the swift library listed above. Feel free to close this issue, I think you did about all you can on this one.\nI'll just play around with swiftz in your test projects or try it from a playground.\n. Wait, I just re-read what you typed. You can't bundle frameworks and dylibs with command line projects? \nNow that would be a useful thing for XCode to tell you upon adding a framework to your link phase when you are in a command line project. \nOk, then I guess I'm just left to figure out why whenever I write (or you write) a recursive enum list List, the runtime just hangs when trying to construct one in a test.\n. Cool! I just opened up a stack overflow question on this and was going to try to debug. I would have never guessed to box the first parameter of Cons. Wow!\nThanks for filing the radar.\nhttp://stackoverflow.com/questions/26792577/why-does-this-recursive-swift-enum-hang-xcode/26792757#26792757\nI assume this broke \"recently\" as I'm sure this code worked when it was first written?\nWhat tool would you use to debug this? Instruments?\n. :+1: for Project Structure\n. Thanks. I was wondering about coding guidelines. \nI'm out now. I'll fix it later. \n\nOn Nov 8, 2014, at 6:37 PM, Robert Widmann notifications@github.com wrote:\nIn swiftz_core/swiftz_core/Functions.swift:\n\n@@ -49,8 +49,12 @@ public func flip(f: (A, B) -> C)(b: B, a: A) -> C {\n/// Flip a function's arguments and return a curried function that takes\n /// the arguments in flipped order.\n-public func flip(f: A -> B -> C)(b: B)(a: A) -> C {\n-  return f(a)(b)\n  +public func flip(f: A -> B -> C) -> B -> A -> C {\n  Single line please:\n\npublic func flip(f : (A, B) -> C) -> (B, A) -> C {\n    return { t in f(snd(t), fst(t)) }\n}\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "mgwelch": "@CodaFi I think this issue can be closed now. All of my issues were resolved or explained.\n1. Can't create command line tool (yet) using a 3rd party framework. \n2. The hanging of List\nThanks\n. Yeah, must be a compiler issue. I completed removed swift_core and sleipnir from my example and still get the error. I'll file a radar.\nrdar://18919562\nGo ahead and close this. Sorry for polluting your issues with this.\n. I think it's a bug. I shouldn't haven't to specify the labels. I think the type signature looks fine for a curried function.\nSo how do you normally correct a signature if you don't want to have to specify labels? You put an underscore in front of the parameter in the function definition. Go ahead and try that. Now you'll have compiler warnings basically telling you \"Hey you don't need underscores, There are no labels associated with these parameters\" Here is the precise warning:\n/Users/mgwelch/Documents/Projects/thirdparty/swiftz/swiftz_core/swiftz_coreTests/FunctionSpecs.swift:1:43: Extraneous '_' in parameter: 'b' has no keyword argument name\nHere's my test program that has 2 errors and 2 warnings.\n```\npublic func flip(f: A -> B -> C)( b: B)( a: A) -> C {\n    return f(a)(b)\n}\npublic func useFlip() {\n    let subtract = { (x:Int) in { y in x-y }}\n    let result = flip(subtract)(5)(3);\nsubtract(4)(3);\n\n}\n```\n. So yeah, this is a work around. Don't use the currying syntax:\n```\npublic func flip(f: A -> B -> C) -> B -> A -> C {\n    return { (b:B) -> A -> C in\n        { (a:A) -> C in\n            f(a)(b)\n        }\n    }\n}\npublic func useFlip() {\n    let subtract = { (x:Int) in { y in x-y }}\n    let result = flip(subtract)(5)(3);\n}\n```\nThen it's fine. If nothing else I still think this is a worthy compiler enhancement (if not a bug). It's not clear to me why using the \"convenience\" syntax should come with a \"penalty\".\n. Yeah, I'll submit a pull\n. Pushed a new commit with tab removed.\n. ",
    "sharplet": "Yeah I get that. I think it has a couple of things going for it though: it scans well and stands out at the end of a long line, and I think it pairs really nicely (in a both a visual sense and in ease of typing) with \u2022.\nSomething I've also been thinking is that it helps you to think in terms of \"applying a function to its argument\", when reading left to right (f \u00a7 a), whereas the directional <| reads more from right to left as \"passing an argument to a function\" (f <| a).\n...I don't know if I expressed that particularly well, but I think there's a subtle difference, even though they're semantically identical. \u00af_(\u30c4)_/\u00af\n. And thanks for the \"after\" tip!\n. @CodaFi I've amended the original commit with the correct associativity and precedence. Also added a couple of new commits, restoring <| and adding an implementation.\n. Thank you! :grinning: \n. No worries! :thumbsup:\n. The Tango? (Collapso with a little Rumba mixed in)\nswift\nswitch self {\ncase let Error(e): \n    return .Left(Box(e))\ncase let Value(v): \n    return Either.Right(Box(v.value))\n}\nPros:\n- Works pretty well with Xcode's auto indentation\n- Consistency with the Swift book\n- Visibility of return value\n- Scales well to multi-line cases and more complex patterns (e.g., with tuples, like case (.Some(let a), .Some(let b)): ...\nCons:\n- Same point about { meaning indent next line\n. :+1: \n. @refried Permit me to dump some of my random thoughts for a moment!\nSomething I've observed in learning a bit of Haskell is that pervasive currying really seems to affect the way arguments are normally ordered. Whereas in an OO, imperative language like Swift you might see something like\nswift\n// [Int] -> (Int -> String) -> [String]\nlet repeated = numbers.map { x in \"\\(x)\\(x)\" }\nin Haskell this might look like\nhaskell\n-- (Int -> String) -> [Int] -> [String]\nlet repeated = map (\\x -> show x ++ show x) numbers\nThe interesting thing with the Haskell style is when you partially apply the map function, and you get this:\nhaskell\nrepeatTwice :: (Show a) => [a] -> [String]\nrepeatTwice = map (\\x -> show x ++ show x)\nThe interesting thing to me about repeatTwice here is that you've taken a function that works on normal values (i.e., (\\x -> show x ++ show x) :: (Show a) => a -> String) and \"lifted\" into a function that does the same thing but works on a list and then returns a list (Show a => [a] -> [String]).\n\nThis same style is possible in Swift, and it looks to me like that's what's primarily influencing the order of the arguments for <^>. However if you look at one of the examples of map as defined in the Swift standard library, it's the reverse:\nswift\n// kind of looks like [a] -> (a -> b) -> [b]\nfunc map<S : SequenceType, T>(source: S, transform: (S.Generator.Element) -> T) -> [T]\n(As an aside, is it just me or does having the types mixed in with the parameter names make it much harder to read?)\nThe method form of map must implicitly accept the array (or optional or whatever) first, followed by the transform function. But the free function <^> is, ahem, free to accept arguments in the other order.\n\nI'm not familiar enough with the history of Haskell's design to say just how intentional this is, but it feels fairly intentional to me!\nHTH. (@CodaFi please jump in if you have anything to add to that!)\n. I wish <\u00a7> wasn't such hell to type :disappointed:\n. @pthariensflame Actually what I was getting at was that you have to switch modifier keys and back again: Shift-, - Opt-6 - Shift-.. I personally find it quite cumbersome, but maybe I'm doing it wrong? Compared to <*>, <%>, or <^>, where you can just hold down shift and you're off to the races.\n. But I'm also a big fan of the consistency argument, so really I'm just torn!\n. Nope, I just read that it has the \"lowest precedence\" in Haskell, and haven't looked it up. There's quite likely a better value.\nMy bad about the associativity!\n. Found a table that lists operator precedence: http://kevincantu.org/code/operators.html. It's given as 0 there. Maybe in Swift it should use the lowest legal value?\n. Ok so valid Swift precedence values are 0 to 255: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/doc/uid/TP40014097-CH34-XID_543.\n. ",
    "bontoJR": "It would be great to add version 'tags' in the master branch to support Carthage builds.\n. ",
    "robrix": "Prefix ~ is the bitwise complement operator, so this trades ambiguity on negation for ambiguity on complement. Complement is relatively uncommon in practice, so that may be ok.\n. ",
    "mgp": "Yup, sorry. I'm closing this one. https://github.com/typelift/swiftz/pull/139 has just this change.\n. Good catch! Updated.\n. ",
    "gfontenot": "... CoreData seems like a bad choice.\n. ",
    "kasrak": "Happy holidays! :santa: \n. Added!\n. ",
    "aryairani": "Like better type inference? Or what do you mean?\nWas it not an issue for >>- ?\n. I like the monad on the left and the function on the right, but doesn't <^> currently use the reverse of that?\n. Ok I think you're saying <^> and <$> should have the function on the left and the FA on the right, possibly to match how functions appear on the left when they're invoked in Haskell.\nCurrently that's how they are defined in swiftz too, afaict.  But that makes it very cumbersome to chain with <^> doesn't it?  Or is it easy to compose those functions before a single map?\nIs fmap also defined as in your example above? Where can I find it in the source?\nThanks!\n. Sorry, when you said <$>, I had read it as <*>.  Is there even a <$> in Swiftz? I don't see one.\nSo why does <^> take its function first?  To read like Haskell? Or is there some Swift-related benefit to doing it that way?  Why not write <^> to allow \"imperative-looking\" code too?  (andThen semantics instead of compose).  Or is there already a way of doing that?\nYou could write bind right-to-left too if you wanted; it wouldn't make it less or more equational, but I don't think it'd be a good idea either.\nThanks!\n. More importantly, why not be consistent in the syntax between <^> and >>-?\n. Sure, but it's in the exact same \"do\" situation that you'd want map to be right to left, right?\nfa bind f1 map f2 bind f3 map f4 map f5\nArgument order doesn't intrinsically make things more declarative or more imperative, does it?  Or did you mean \"Haskell-looking\" vs \"Swift-looking\"?  Surely you don't mean that the big contribution of this framework is a particular argument order?  I'd think that's the most arbitrary part and not at all what's awesome about swiftz.\n. I guess I don't understand what you mean when you say it's not meant to be compositional.  It's definitely convenient to be able to chain them together like I showed, even if it wasn't meant to be.  \nDoes the current parameter order maybe enable some other convenient usage, besides making it difficult to chain together?  If not, maybe it'd be worth switching the current syntax around.  And if there is, maybe it'd be worth adding the alternate syntax in addition to the current syntax!\nCheers,\nArya\n. I'm trying to ask if there's any advantage to keeping the order the way it is \u2014 because there is an advantage to switching it.\n. Hi @sharplet, I can appreciate random thoughts, thanks for sharing them.\nI'm not super familiar with Swift, if only because Playgrounds are super crashy and I get angry whenever I try :-/ I am familiar with Scala and Scalaz (which I assumed Swiftz was related to) though.  \nCould you show an example of partially applied <^> in Swift?\nRe mixing parameter types and names, I have mixed feelings.  :-) \n. Hi, thanks for the reply.  I could be way off base here, but I think all of the examples and rationale above are in Haskell.  Wouldn't it make sense to discuss Swiftz decisions in relation to Swift?\nI'm not suggesting to change the library for a certain person, I'm asking if there's any practical reason not to flip it, because there is a practical reason to flip it. If there were also a practical reason to not flip it, then it might make more sense not to flip it.  I'm asking if the current order is most convenient for anyone in any context, in Swift, and if so, could you enlighten me with an example?\nOr if the first goal of Swiftz is simply to write code that looks as close as possible to historical Haskell code, then it's fine to say that explicitly.  If that's not the primary goal, then it doesn't really matter what Functors or Monads were built with in mind, because that was in the past.\nAm I making any sense? Thanks!\n. Oh hello :)\nWell, to be honest, I was left with the feeling that I wasn't able to get\nmy point across at all. Is that something you'd be interested in still?\nOn Thu, Jan 8, 2015 at 22:35 Robert Widmann notifications@github.com\nwrote:\n\n@refried https://github.com/refried Any further input, or has this\nthread run its course?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/typelift/swiftz/issues/152#issuecomment-69288959.\n. Thanks -- I guess to start, could you show a working Swift example of the\nanticipated use case for <^>? (hopefully including composition?)\nOn Thu, Jan 8, 2015 at 23:51 Robert Widmann notifications@github.com\nwrote:\nThen let's start over.\nRestate the question and I'll try to be more succinct about replying this\ntime.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/typelift/swiftz/issues/152#issuecomment-69292981.\n. Thanks -- that is certainly a different use case than I expected: producing a partially applied lifted function.  Is that the expected use case?\n\nThe second link you sent was in Haskell though, so it didn't answer my question about Swift at all.\n. I understand that, but it doesn't help. My question was about Swiftz, which\nI'm assuming only exists at all due to the fact that Swift is not the same\nthing as Haskell.\nOn Sat, Jan 10, 2015 at 19:42 Robert Widmann notifications@github.com\nwrote:\n\nThe reason I continue to bring up Haskell is that as a language it has a\nbeautiful and straightforward approach to laying out the kinds of\nabstractions we're using here. Our work stems from that, and our semantics\ndoes the same.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/typelift/swiftz/issues/152#issuecomment-69478624.\n. I think I must not be smart enough to know how to ask a question that you\ncan understand and answer in such a way that it is recognizable to me as an\nanswer to my question.  Thanks anyway!\n. I read your answer again this morning, just wanted to add a quick note to say that even though I don't feel that it answers my question, it was informative and interesting.  So thanks for now!\n. If you flip the types around, you get:\n\nF<A> -> (A -> B) -> (B -> C) -> ... -> (Y -> Z) -> F<Z>\nHow would you do that instead now?  Thanks!\n. You has previously pointed out that\n(f <^>) \u2022 (g <^>) = ((f \u2022 g) <^>)\nbut is there an example in swift?\n. Does swiftz include an fmap implementation for every <^> implementation?\n(since AFAIK, swift won't let us share one single definition)\nOn Sun, Jan 11, 2015 at 12:56 Robert Widmann notifications@github.com\nwrote:\n\nI read your answer again this morning, just wanted to add a quick note to\nsay that even though I don't feel that it answers my question, it was\ninformative and interesting. So thanks for now!\nYou're very welcome. I'm terribly sorry I'm incapable of grokking your\nquestion right now. I don't want this to wind up as a situation where you\nget turned off by jargon, or feel like FP means I can't help you. You're\nabsolutely \"smart enough\" to ask questions around here!\nIf you flip the types around, you get:\nF -> (A -> B) -> (B -> C) -> ... -> (Y -> Z) -> F\nHow would you do that instead now? Thanks!\nShort Answer:\nflip(<^>)\nLong Answer:\nBy virtue of our definition of Functor we already give you an fmap that\nlooks like\nF -> (A -> B) -> F\npublic protocol Functor {\n    /// ...\n    /// Map a function over the value encapsulated by the Functor.\n    func fmap(f : A -> B) -> FB\n}\nThough it may not look like it, Every member function in Swift actually\nlooks like this internally:\nstruct Foo : Functor {\n    func fmap(f : A -> B) -> Foo { // do stuff }\n}\nfmap : Foo -> (A -> B) -> Foo\nbut you have to invoke it statically (Foo.fmap rather than\nFoo().fmap) to see that. By yet another virtue, this time of the\nlanguage, . to invoke functions can be used to compose fmaps rather than \u2022\nlike function composition.\nYou has previously pointed out that\n(f <^>) \u2022 (g <^>) = ((f \u2022 g) <^>)\nbut is there an example in swift?\nYes! I'll show you with the Identity Functor (Box) out of laziness. Throw\nthis in a playground\n// --------- Prerequisites ----------- //\npublic class K1 {}\ninfix operator \u2022 {}\npublic func \u2022(f: B -> C, g: A -> B) -> A -> C {\n    return { (a: A) -> C in\n        return f(g(a))\n    }\n}\npublic protocol Functor {\n    /// Source\n    typealias A\n    /// Target\n    typealias B\n    /// A Target Functor\n    typealias FB = K1\n/// Map a function over the value encapsulated by the Functor.\nfunc fmap(f : A -> B) -> FB\n}\n/// The Identity Functor holds a singular value.\npublic struct Id {\n    private let a : @autoclosure () -> A\n```\npublic init(_ aa : A) {\n    a = aa\n}\npublic var runId : A {\n    return a()\n}\n```\n}\nextension Id : Functor {\n    public typealias B = Any\npublic func fmap<B>(f : A -> B) -> Id<B> {\n    return (Id<B>(f(self.runId)))\n}\n}\n//--------------!!--------------//\nlet id = Id(5)\nlet f : Int -> Int = { x in x + 5 }\nlet g : Int -> String = { x in String(x) }\nlet x = id.fmap(f).fmap(g).runId // String(\"10\")\nlet y = id.fmap(g \u2022 f).runId // String(\"10\")\nx == y // true\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/typelift/swiftz/issues/152#issuecomment-69503679.\n. :)\nOn Sun, Jan 11, 2015 at 13:07 Robert Widmann notifications@github.com\nwrote:\n(Unfortunately for my poor fingers) Yes. We have to write an fmap for\nevery Functor.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/typelift/swiftz/issues/152#issuecomment-69504088.\n. \n",
    "vendethiel": ":+1: that was quick!\n. +0 \u2212309 always feels great :)\n. I tried to (github) (file) search for \"optics\" and \"optic\" and didn't find anything. I don't know much, so which files are you talking about?\n. Seems weird to have an issue to rename Num to (possibly) NumericType, then introduce \"Ratio\", no? (even if \"Rational\" is introduced the same commit)\n. Seems like a great github change :+1: \n. typo \"reciever\" (and everywhere else as well)\n. wouldn't sacrifying beauty for efficiency make more sense here?\n. spurious backtick before \"the\"\n. typo: \"a the rest\"\n. (same typo here)\n. ",
    "majorgilles": "worked fine on my end, thanks! (pr/176)\n. Sorry, didn't do the trick (moved the initialiser and the type alias in the main struct, put the ArrayLiteralConvertible protocol next to the declaration of the main struct, aka  public struct List : ArrayLiteralConvertible\nAlso recompiled swiftz separately by selecting its scheme and rebuilding.\nstill getting:\nUndefined symbols for architecture x86_64:\n  \"**TFV6SwiftZ4ListCU__fMGS0_Q__Ft12arrayLiteralGSaQGS0Q**\", referenced from:\n      TFC20TestLiteralFixSwiftZ14ViewController11viewDidLoadfS0_FT_T_ in ViewController.o\nld: symbol(s) not found for architecture x86_64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n. Didn't do anything either. Will come back later when swift 1.2 is out :)\n. ",
    "hffmnn": "Should be all fixed now.\n. ",
    "BrianDoig": "Sweet!  Didn\u2019t see that when I looked at the branches.\nOn Feb 10, 2015, at 4:01 PM, Robert Widmann notifications@github.com<mailto:notifications@github.com> wrote:\nWay ahead of you, bro #181https://github.com/typelift/Swiftz/pull/181\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/typelift/Swiftz/issues/182#issuecomment-73810945.\n. ",
    "rodrigoelp": "Do we know how much is it going to be until the merge happens?\n. ",
    "mareklug": "I'm sorry, it was a mistake on my part. I am only learning how to use git. Who exactly closes this?\nSent from my iPhone\n\nOn Mar 17, 2015, at 10:47, Robert Widmann notifications@github.com wrote:\nWhy did you close this?\n\u2014\nReply to this email directly or view it on GitHub.\n. Thank you. No more changes at this point.  I hope to pick up all the nuances soon. ;)\n\nMarek\nSent from my iPad\n\nOn Mar 17, 2015, at 12:49, Robert Widmann notifications@github.com wrote:\nYou already closed it, but I have the power to close and reopen these things to, which is what I'd like to do. If you don't have any more changes to make, I'm going to reopen and merge this. It's a great change to have.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "griotspeak": "Thank you for that. Someone there mentioned 6.4 beta working and, following that lead, I now have different and considerably more concise console output \n```\n$ carthage update\n Fetching Swiftz\n Checking out Swiftz at \"v0.2.2\"\n xcodebuild output can be found in /var/folders/dw/rbk312qs7q74dpqcrdvrxbtm0000gn/T/carthage-xcodebuild.iPn1fl.log\n Building scheme \"SwiftCheck\" in Swiftz.xcodeproj\n Building scheme \"SwiftCheck-iOS\" in Swiftz.xcodeproj\nA shell task failed with exit code 65:\n2015-05-24 22:43:18.892 xcodebuild[44468:3141413] stream error: stream error at offset 29: created by an unsupported XCDependencyGraph build\n* BUILD FAILED \nThe following build commands failed:\n    Check dependencies\n(1 failure)\n```\n. Seems like a command line Xcode problem. swift builds in Xcode.app and the beta.\n. Same thing. In any case, it doesn't seem like a swiftz issue. This is my first try with Carthage so I was unaware of the current problems. Thank you for the help.\n. It looks like the problem could be with checking out swiftz. The issue only happens when building the iOS targets and\n```\nThe deployment target for SwiftCheck when cloned 'by hand' is 8.3\n\u2026                         swiftz when cloned 'by hand' is 8.3\n\u2026                         swiftx when cloned 'by hand' is 8.3\n\u2026                         swiftx when checked out by carthage for swiftz is 8.4\n\u2026                         SwiftCheck when checked out by carthage for swftz is 8.4.\n```\n. Thank you for confirming. It is, for me, less frustrating now that the general problem has been identified and confirmed.\n. ",
    "jdesiloniz": "Thanks a lot for updating the version @pthariensflame !!\nSwiftx is already working for us... we weren't using submodules in our Podfile. Sorry about that! :)\n. Yes! Thanks!\n. ",
    "badeleux": "Solution is awesome. I have one doubt:\n\nEvery  non-static member function of a Swift class or structure actually takes the form Self -> Args\n... -> Result, you just get to see the form where self is partially applied in normal use cases. Your \ntypechecker woes are a direct consequence of this\n\nMy static map implementation is a static function, isn't it?\n. ",
    "rexmas": "Added the following to my Podfile but seem to get a ton of errors when I update and compile\npod 'Swiftz', :git => 'https://github.com/typelift/Swiftz.git', :branch => 'swift-develop'\nE.g.\n\nand\n\n. Thanks, makes sense, I'll see if I can get this to work with a custom Podfile then :+1: \n. So I created an private podspec to test this out\n```\nPod::Spec.new do |s|\n  s.name        = \"Swiftz\"\n  s.version     = \"0.2.4\"\n  s.summary     = \"Swiftz is a Swift library for functional programming.\"\n  s.homepage    = \"https://github.com/typelift/Swiftz\"\n  s.license     = { :type => \"BSD\" }\n  s.authors     = { \"CodaFi\" => \"devteam.codafi@gmail.com\", \"pthariensflame\" => \"alexanderaltman@me.com\" }\ns.requires_arc = true\n  s.osx.deployment_target = \"10.9\"\n  s.ios.deployment_target = \"8.0\"\n  s.source   = { :git => \"https://github.com/typelift/Swiftz.git\", :branch => \"swift-develop\", :submodules => true }\n  s.source_files = \"Swiftz/.swift\", \"/Swiftx/*.swift\", \"/Operadics/.swift\"\nend\n```\nBut for whatever reason on every operator implementation I'm still receiving\n\nAnything look off to you?\n. :branch => \"swift-develop\" is right there in the Podfile right?\n. And thanks for being so responsive, much appreciated :)\n. Started from scratch and used the podspec I posted. Did a pod update and still getting the same errors. What's strange is Operators.swift is being included into the pod but Combinator.swift doesn't seem to recognize the existing operators. :\\\n\n. So the only way I'm able to get this to compile is if I create a .podspec for Swiftx that includes Operadics and then in my .podspec for Swiftz I include s.dependency  'Swiftx'. Then in my Podfile I include\npod 'Swiftx', :podspec => 'podspecs/Swiftx.podspec'\npod 'Swiftz', :podspec => 'podspecs/Swiftz.podspec'\nHere I'm a little confused on why just directly including the Operadics source doesn't work in Swiftz like it does in Swiftx.\nAnyway, from there I compile and then have to go to all the files in Swiftz where there's an error and alter the files to manually import Swiftx, which is not ideal. Makes me wonder though, assuming Swiftx can act as it's own module, shouldn't it always be compiled separately and therefore require Swiftz to have these imports anyway?\n. Take that back, I jumped the gun because a few errors started vanishing, but that still didn't solve those operator declaration errors.\nRealized however, that those operators are declared as infix and not prefix or postfix.\nAdding the following for all operators seems to fix the remaining errors and I can likely remove the Swiftx podspec altogether once they're all added.\nswift\nprefix operator \u2022 {}\npostfix operator \u2022 {}\nThis seems to be missing from the codebase in swift-develop. Since all the operators are defined in Operadics I opened a PR there https://github.com/typelift/Operadics/pull/2\nThis didn't solve everything though, there's also 3 redeclared interfaces between Swiftx and Swiftz.\nE.g. Swiftx - Optional.swift\n\nSwiftz - OptionalExt.swift\n\nSince ? is just syntactic sugar for Optional<T> the declarations are the same. However, one implementation is using map while the other is using fmap...\nIf Swiftz is dependent on Swiftx then it seems like we should pick the one that's correct and add those to Swiftx and the 3 redeclared methods in OptionalExt.swift should simply be removed from Swiftz altogether.\nIf both are needed then this may indicate the need of a new operator or function name but it looks like fmap just returns self.map anyway.\n. Opened a PR that includes the podspec that worked for me https://github.com/typelift/Swiftz/pull/244\n. Awesome! Looks like this should do the job :+1: should we be concerned with the CI failure however?\n. ",
    "zbeckman": "Thanks. (Assuming you know that Xcode 7 GM is out \u2013\u00a0so, effectively it has been released, there will be no changes between the gold master and the final version).\n. Happy to help test it out... ;-) I'm on the crux of a project and have to choose either SwiftyJSON, Scalaz, or some other solution. Hoping a Swift 2 branch shows up soon \u2013\u00a0I'd much prefer to use Scalaz.\n. And trying with the Podfile in swift-develop results in a lot of operator-specific errors.\n. Yes \u2013\u00a0but... I reset to a clean build, did it all over again, and this time it worked. :( Maybe stale info in derived data. Sorry for the distraction \u2013\u00a0and glad it is working!\nHowever, the issue with the Pod version is still there... but I think you are well aware of that one.\n. ",
    "timbodeit": "Same for 0.39.0.beta.3. Is there a known CocoaPods version for which it does work?\n. ",
    "NachoSoto": "Since it's a dynamic framework, iOS 8 is required to be able to link it on iOS, so this is the lowest it can go :)\n. Good point, done!\n. Nah, I'm building with Carthage from a fork anyway, so I'm in no rush!\nI just figured I'd send this one commit :)\n. ",
    "adamkuipers": "Yeah, there would probably have to be a ProductN boilerplate type like Zip2Sequence.\nWhat I like about the ProductN route, though, is that it would only have to be used internally and would be transparent to the client. No longer will the client be required to define a curried initializer create.\nInstead of Foo.create <^> fa <*> fb <*> fc we would have map(fa, fb, fc) { Foo($0, $1, $2) }, which looks more natural in Swift land IMO.\n. Scala seemed to have made the decision for everyone that Tuple22 was enough \ud83d\ude03\n. I might have time tonight to get something going. Would you want Applicative to be defined in terms of Monoidal, vice versa, or independent of one another?\n. Unrelated, but have you considered opening a gitter channel for this project? I think I remember a talk where @non mentioned that it contributed Cats growing community but maybe I made that part up.\n. What's nice about gitter is that it's discoverable. And you don't need a slack account.\n. Is it not going to be a public channel?\n. Isn't it just \"Create Room\" -> Repository -> Swiftz?\n. ",
    "DanielAsher": "I've got TupleOf to TupleOf5 if that helps. Couldn't give up on shrinking in SwiftCheck...\n. I promoted the creation of a slack channel - typelift.slack.com -  but it's pretty lonely there at the mo. Will look into gitter.\n. right. slack is cumbersome for unpaid use. discoverability is precious too.\n. I'd love to give gitter a go.\n. Hurrah!\nOn Tue, 27 Oct 2015 at 00:46, Alexander Altman notifications@github.com\nwrote:\n\nOkay, https://gitter.im/typelift/general has just been created, and it's\npublic!\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/typelift/Swiftz/issues/260#issuecomment-151327332.\n. Here's an implementation I'm using - no List mojo I'm afraid :-/\n\nextension Array {\n    // group into subarrays by applying predicate to adjacent elements in the source array.\n    // let groups = [1,2,3,2,3,4].groupAdjacent { $0 < $1 } (EDITED) \n    // groups == [[1,2,3], [2,3,4]]\n    func groupAdjacent(predicate: (Element, Element) -> Bool) -> [[Element]] {\n        guard let head = self.first else { return [] }\n        return self.dropFirst().reduce( [[head]] ) { xss, x in\n            guard let last = xss.last!.last else { return xss }\n            var xssc = xss // copy required to mutate\n            predicate(last, x) ? xssc[xss.count-1].append(x) : xssc.append([x])\n            return xssc\n        }\n    }\n}\n. Oops - the predicate in the example should read { $0 < $1 } of course. \nOK - understood. I'll close this one. \n. ",
    "joamaki": "Btw, regarding the need for the boilerplate curried constructor, in Swift 2 this now works:\nswift\nstruct Foo { let a: Int, let b: String }\ncurry(Foo.init) <^> 1 <*> \"hello\"\nOf course you'll end up hitting the \"expression too complex\" pretty quickly...\n. ",
    "sendyhalim": "Oh nice, thanks! :beers: \n. @CodaFi You're welcome \ud83c\udf7b . ",
    "mathonsunday": "I'll contribute something and then you all can let me know what you think. \n. I spent Sunday working on an implementation in line with other ones in the project. Unfortunately I wasn't able to get it into a functional state. Need to get a better understanding of it myself. I'm with my family for the next week so someone else is free to contribute the implementation. \n. ",
    "gcornut": "Ok sure, should I do it on swift-develop or master?\n. You're welcome \ud83d\udc4d\ud83c\udffb. It wasn't much \n. ",
    "blender": "@CodaFi Don't feel too bad, I generated this via a script. However before merging I suggest you also confirm that the compile time is lowered since this can affect negatively everyone using the library.\nI'll try to address the compile time of some other functions in other pull requests.\n. Also I suggest attaching binaries to releases like so: https://github.com/Carthage/Carthage#archive-prebuilt-frameworks-into-one-zip-file\n. I don't think there is Application Binary Interface (ABI) stability yet but anyways the source code will compile only with Swift 2.2 \nEDIT: ABI will be reached in Swift 3.0 https://github.com/apple/swift-evolution\n. i'm closing this pull request and will submit another with more optimizations including this one. \n. If you decide to go for it it would be a welcome addition to attach binaries also for the other projects. Tyro, Concurrent etc...\n. These are the offenders that are still left and that impact negatively all other compile times of libraries that link to Swiftz\n251.4ms /Users/blender/Code/lab/Swiftz/Swiftz/StringExt.swift:210:13 public func sequence(ms: [String]) -> [String]\n119.7ms /Users/blender/Code/lab/Swiftz/Swiftz/ArrayExt.swift:128:14 public func foldMap<M : Monoid>(f: A -> M) -> M\n118.2ms /Users/blender/Code/lab/Swiftz/Swiftz/List.swift:359:14 public func groupBy(p: (Element, Element) -> Bool) -> List<List<Element>>\n91.7ms  /Users/blender/Code/lab/Swiftz/Swiftz/StringExt.swift:59:14 public func reverse() -> String\n71.8ms  /Users/blender/Code/lab/Swiftz/Swiftz/ArrayExt.swift:105:14 public func mzipWith<B, C>(other: [B], _ f: A -> B -> C) -> [C]\nUnfortunately I can't figure out what is confusing the compiler and I think we'll have to live with it. \n\ud83d\ude1e \n. ",
    "jd230912": "Thanks. \nUnfortunately, I'm not aware of the bug. Based on what i was able to google:\nLooks like similar issue: https://github.com/CocoaPods/CocoaPods/issues/5828\nWhich should be fixed as part of https://github.com/CocoaPods/CocoaPods/pull/5822\nAnd released in 1.1.0.rc.1\nThis comment states that the bug was fixed in 1.1.0.rc.2: https://github.com/CocoaPods/CocoaPods/issues/5828#issuecomment-250965249\nHere is the latest release which should work correctly: https://github.com/CocoaPods/CocoaPods/releases/tag/1.1.0.rc.3\nCan you please verify whether the bug is fixed in 1.1.0.rc.3 and enable cocoapods back if it is so?\n. ",
    "yurrriq": ":+1:. Works for me, thanks!. ",
    "apparition47": "Got it, thanks. The issue seems to be happening with both Swiftx and Swiftz. I'll try to put in a PR for both if someone doesn't beat me to it.\n. Please review my PRs for both Swiftx and Swiftz. One thing I wasn't sure about was your LinuxMain.swift that you had in SwiftCheck. Is this needed for testing on Linux? I don't have access to a Linux system right now to check. \nThanks!\n. Solved with 0.6.1. Thanks.\n. It might not right now but Swiftz seems relatively lightweight enough to include the whole kitchen sink for future additions. Great library. Thanks again!. Done -- I think I did it 7c28c51\n. My bad, I should've ran through that before I did the PR. Thanks.\n. 0.5.1..0.5.1 is okay?\n. ",
    "wpoosanguansit": "Hi,\nI am using pod to install the lib but it does not look like it is usable yet.  From what I can see, not all the code is being brought in.  I could not get the code in the intro to compile at all.  Thanks.\n\n. ",
    "tcldr": "FYI This still points to my fork of Swiftx as some files were moved around to work with the SPMv4 format.. Strange. I don't remember adding that!. ",
    "JadenGeller": "There's a bug in the current version of swift that prevents this inference.\n. I'm having a little bit of trouble understanding where you are wanting the newlines. From what I can tell it is consistent with the style of the rest of the codebase.\n. "
}