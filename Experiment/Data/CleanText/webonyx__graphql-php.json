{
    "dmongeau": "Yes, updated!\n. That was my problem, I didn't see how I could modify the output without overwriting one method. Everything is so encapsulated in GraphQL. I knew I could use the getPrevious method but there was no way \"to reach\" it.\nYour solution works better, thanks a lot!\n. Ok I understand, sorry about that! Actually, it's not coming from me. Someone as filled an issue on laravel-graphql.\n. ",
    "vladar": "Definitely. It's really in pre-release state now. We still explore usage scenarious ourselves and will probably make significant changes to API before first usable release.\nBut if you want to experiment with it, check out tests as usage examples, say:\nhttps://github.com/webonyx/graphql-php/blob/master/tests/StarWarsSchema.php\nhttps://github.com/webonyx/graphql-php/blob/master/tests/StarWarsQueryTest.php\n. Added quick README for now. Feel free to open specific issues if something requires additional clarifications in Readme.\n. I'd be happy to do so, but realisticly - can't provide any timeframes on when this will be done. Contributions are welcome if you get there before me! \nSeparate repo is another option.\n. @arec about RelayJS schema - use query from GraphQL\\Type\\Introspection::getIntrospectionQuery() to generate schema.json. It's a regular introspection feature of GraphQL.\nI currently do it via custom node-js script that uses same introspection query from graphql-js, in case if someone is interested:\n``` javascript\n!/usr/bin/env babel-node --optional es7.asyncFunctions\nimport fs from 'fs';\nimport path from 'path';\nimport { introspectionQuery } from 'graphql/utilities';\nimport rp from 'request-promise';\nvar options = {\n    uri: 'path-to-your-graphql-endpoint',\n    method: 'POST',\n    form: {\n        query: introspectionQuery\n    }\n};\nconsole.log('Requesting schema from', options.uri);\nrp(options)\n    .then((result) => {\n        var fname = path.join(__dirname, '/schema.json');\n        console.log('Successfully retrieved schema (' + (result||'').length + ') . Writing to ' + fname);\n    fs.writeFileSync(\n        fname,\n        result\n      // JSON.stringify(result, null, 2)\n    );\n})\n.catch((result) => {\n    console.error(result);\n});\n\n```\nWanted this to be integrated with JS workflow, hence JS version vs PHP.\n. @Gugudesaster Tools in https://github.com/graphql/graphql-relay-js are simple helpers around GraphQL system.\nThey do not provide special structures or algorithms - they just slightly simplify creating GraphQL types specific for Relay. You should be able to create such types even without those helpers.\nCan you share what exactly blocks you?\n. Also check out Relay specs for GQL types: https://facebook.github.io/relay/docs/graphql-relay-specification.html#content\n. @ivome That's great! When you're done - post the link here to your repo and I'll add it to Readme.\n. Nice! Will throw away my current hackish helpers and use your repo instead.\nAdded section to Readme on Complementary tools. Guess I can finally close this issue %)\n. Fixed in https://github.com/webonyx/graphql-php/commit/d982bad63a561197ac7db53711e60f605b690577\n. Hey thanks! Will do! :)\n. Hey, nice to see that you tried to use map :)\nThis feature was trying to solve the N+1 problem in generic way, so that you could do bulk operations, like Redis MGET or SQL IN(...).\nBut as you discovered map doesn't work well with some use-cases like Relay connections, when item is wrapped with some other type (there are also other cases where it doesn't work).\nSo at this point I can say that this feature failed to solve original problem. And I will probably revert it until better generic solution reveals itself.\nOther GraphQL implementations also discuss this problem. Check out https://github.com/graphql/graphql-js/issues/111 and https://github.com/graphql-dotnet/graphql-dotnet/issues/21 for example.\nFor now you can work around it in the user-land with regular resolve by preserving original list together with value and resolving field for all items in list on first resolve call. For example:\nphp\nclass Value {\n    /** @var Value[] */\n    public $parentList;\n}\nThen in your resolve:\nphp\n'fieldName' => [\n    'resolve' => function (Value $value, $args, $context) {\n        if (!isset($value->fieldName) {\n            // Resolve field for all items in list on first resolve call:\n            $list = $value->parentList ?: [$value];\n            foreach ($list as $item) {\n                $item->fieldName = 'something';\n            }\n        }\n        return $value->fieldName;\n    }\n]\nThis is way more ugly than map, but it does work in all cases.\nI realize that N+1 problem is severe (especially in pure PHP world without async operations) and it would be great to have some clean and expressive solution on library level instead of user-land hacks, but for now, map is just not the way to go.\nWhen good-enough solution will be ready - I will add separate section to README for it. If you have any thoughts on how to make it work for all use-cases - please share your thoughts!\n. Closing this as map is reverted now. Will add note in README when alternative is ready.\n. Nice. Thanks for submitting!\n. Performance is definitely a priority. I planned to revisit executor code some day. Will take a look at your implementation when I have a chance. \nFeel free to submit it as pull request if you already have working implementation.\nThe roadmap I had in mind so far is:\n1. Try out breadth-first approach (probably without recursion) - this may also help solving N+1 problem we discussed in #6.\n2. Write optional PHP module for the most expensive areas.\n3. Consider implementing parallel execution for HHVM (and probably ReactPHP)\nBut I do not want to start optimizing stuff prematurely, until we get clear usage patterns and see all weaknesses of GraphQL in php in general.\nObviously PHP execution model is very different from Node, so this project will diverge a lot from GraphQL JS eventually.\n. Hey, I checked your implementation, but memoization you propose affects the result of query execution. When you memoize results of resolve method for a field, you don't take into account possible arguments or resolveInfo, which alter results for different resolve calls.\nTest suite obviously fails hard in such approach. \nIn other words, the work performed by library that seem useless is actually necessary.\nThe problem is that resolve and even collectSubFields are context-specific (e.g. resolve depends on arguments and resolveInfo), so you can't memoize them effectively at executor level. \nThere is also a chance that I am missing something in your idea. If you could make test suite pass with your implementation - that would help me to understand it better.\n. Actually resolve should be called only once per field (for the same value and same position in query). If resolve is somehow called multiple times - this is probably a bug. Did you face a situation when it has been called multiple times?\nAs for collectSubFields memoization - it is tricky because of complex types (interfaces, unions). Consider following query:\n```\nquery Test {\n  content {\n    id\n    ... on Image {\n      width\n      height\n      ...A\n    }\n    ... on Attachment {\n      size\n      ...B\n    }\n  }\n}\nfragment A on Image {\n  y: a @include(if: $somevariable)\n}\nfragment B on Attachment {\n  z: b\n}\n```\nCall to collectSubField for content field will return different results depending on current value and query variables. If value is of Image type - subfields will be (id, width, height, y), for Attachment type it will be (id, size, z)\nDirectives and aliases may also affect actual subfield structures.\nI guess the only place where we could memoize such calls is when processing homogeneous lists (lists of ObjectType)\n. Yeah. Now I see what you mean. Sorry that I didn't get your idea in the first round :)\nTo make this optimization work library have to somehow be aware of value identity. I see you use SplObjectStorage with object hash as identity. \nWill recheck why exactly this optimization breaks the test suit.\n. @johanobergman Merged your tweaks to code base with some modifications to make test suite pass. CollectSubFields are also memoized now, but per ObjectType to make Abstract types work.\nThanks for these ideas! \nAlso note that I reverted map feature which added some overhead as well. This could slightly improve performance as well.\n. @smolinari Yeah, that would be great. But it's hard to say when I'll have enough time for these big changes, so no estimates yet.\n. Try again on latest commit. Changed the way of handling complex types - now field uid also depends on exact type name.\n. Yes, that's probably because of map removal. In the version with map you only called getFieldUid once per list. Now it's called once per each list value (as in original graphql-js).\nWill probably revisit this once I get to N+1 problem.\n. Closing this for now.\n. PHP used to be bad choice to handle subscriptions. Now things change slowly with some of new libs like ReactPHP. But most of the real-world projects still use node or other tools for websockets / comet.\nSo the solution for subscriptions in graphql-php will probably be different than in graphql-js. I will evaluate possible approaches, but probably not until next month. \nIf you have any thoughts on subject of handling subscriptions in PHP - please let me know!\n. @smolinari Yeah, honestly I expected to see PHP / Hack version of GraphQL, but instead they released js version. So had to build this library to integrate with existing PHP project.\nAs for performance concerns - most of them equally apply to ORMs or custom solutions in PHP. Actually such library has some advantage over custom per-project solutions in that it could be re-implemented as PHP module (as drop-in replacement). \nAnd I think it is a direction to follow eventually. But I suspect that even pure PHP implementation may perform reasonably well if you replace recursive Executor with iterative one (as PHP is slow in handling deep recursion). So that is probably the next step.\nAs for async - if you're stuck with plain PHP it doesn't matter if you use GraphQL or other tools - you don't have async anyway %)\nTargeting for HHVM only is not an option at this point, but I would like to have a version that can handle async features of HHVM for those who can afford to use it.\n. @chrissm79 Yes, the goal is to be abstract enough for different backends. Unlike Node PHP doesn't have first-class support for such things, so it doesn't make sense to force concrete implementation.\nSo I do agree with you: most likely we'll have separate types for subscriptions, but underlying communication / transport layer will be app-specific.\nEventually some backends may be added as optional plugins to simplify initial setup.\n. Closing this as actual subscription implementations may vary depending on the environment. We won't ship out of the box solution until there is no such solution in the PHP core.\nThis lib already enables execution of subscriptions but each project will have to come up with own implementation. I encourage everyone to build such implementations as separate projects and link here so that we could add them in the docs.\nSiler link above is a good example.. Hey, thanks for contributing!\nHowever, I think it is possible to use custom formatting of output without code changes. Every GraphQL\\Error references previous exception (say the one thrown in your resolve method).\nAnd GraphQL Executor returns instance of ExecutionResult, which you can format as you wish in your code.\nHere is an example of how this can be achieved:\n``` php\nfunction myFormatError(GraphQL\\Error $error) {\n    $formatted = GraphQL\\Error::formatError($error);\n    if ($error->getPrevious() instanceof MyResolverException) {\n        $formatted += $error->getPrevious()->myCustomErrorFields;\n    }\n    return $formatted;\n}\nfunction myGraphQLExecute(GraphQL\\Schema $schema, $requestString, $rootValue = null, $variableValues = null, $operationName = null) {\n    try {\n        $source = new Source($requestString ?: '', 'GraphQL request');\n        $documentAST = Parser::parse($source);\n        $validationErrors = DocumentValidator::validate($schema, $documentAST);\n    if (!empty($validationErrors)) {\n        return ['errors' => array_map('myFormatError', $validationErrors)];\n    } else {\n        $result = Executor::execute($schema, $documentAST, $rootValue, $variableValues, $operationName);\n        return ['data' => $result->data, 'errors' => array_map('myFormatError', $result->errors)]\n    }\n} catch (Error $e) {\n    return ['errors' => [myFormatError($e)]];\n}\n\n}\n```\nPlease let me know if that helped. \n. Actually I just refactored library facade to simplify custom formatting. From now on you can use:\n``` php\n$executionResult = GraphQL\\GraphQL::executeAndReturnResult($query);\n$data = [\n    'data' => $executionResult->data,\n    'errors' => array_map('myFormatError', $executionResult->errors)\n];\n``\n. Hey, I am not familiar withlaravel-graphql, but in puregraphql-php`, mutations do work with Relay for me with following helper (basically ported from https://github.com/graphql/graphql-relay-js):\n``` php\n<?php\nnamespace MyGraphQL;\n// See https://github.com/graphql/graphql-relay-js/blob/master/src/mutation/mutation.js\nuse GraphQL\\Type\\Definition\\InputObjectType;\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\ResolveInfo;\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Utils;\nclass Mutation\n{\n    public static function mutationWithClientMutationId(array $config)\n    {\n        Utils::invariant(\n            isset($config['inputFields'], $config['outputFields'], $config['mutateAndGetPayload']),\n            \"Invalid mutation config: make sure that options 'inputFields', 'outputFields' and 'mutateAndGetPayload' are set\"\n        );\n    $outputType = new ObjectType([\n        'name' => $config['name'] . 'Payload',\n        'fields' => $config['outputFields'] + [\n            'clientMutationId' => [\n                'type' => Type::nonNull(Type::string())\n            ]\n        ]\n    ]);\n\n    $inputType = new InputObjectType([\n        'name' => $config['name'] . 'Input',\n        'fields' => $config['inputFields'] + [\n            'clientMutationId' => [\n                'type' => Type::nonNull(Type::string())\n            ]\n        ]\n    ]);\n\n    return [\n        'type' => $outputType,\n        'args' => [\n            'input' => ['type' => Type::nonNull($inputType)]\n        ],\n        'resolve' => function($_, $args, ResolveInfo $info) use ($config) {\n            $payload = call_user_func($config['mutateAndGetPayload'], $args['input'], $info);\n            Utils::invariant(is_array($payload), 'Function \"mutateAndGetPayload\" is expected to return array');\n\n            return $payload + [\n                'clientMutationId' => $args['input']['clientMutationId']\n            ];\n        }\n    ];\n}\n\n} \n```\nThen your mutation type can be defined as:\n``` php\nnamespace MyGraphQL;\nuse GraphQL\\Type\\Definition\\ResolveInfo;\nuse GraphQL\\Utils;\n$toggleLikeMutation = Mutation::mutationWithClientMutationId([\n    'name' => 'ToggleLike',\n    'description' => 'Toggle like',\n    'inputFields' => [\n        'id' => [\n            'type' => Type::id()\n        ]\n    ],\n    'outputFields' => [\n        'story' => [\n            'type' => $myTypes->get('Story'),\n            'resolve' => function($payload) {\n                // fetch and return liked story by id\n            }\n        ]\n    ],\n    'mutateAndGetPayload' => function(array $input, ResolveInfo $info) {\n        // ... perform mutation ...\n        return [\n            'id' => $input['id']\n        ];\n    }\n]);\n```\nAnd then don't forget to add it to your Schema:\nphp\n$schema = new Schema($queryType, new ObjectType([\n    'name' => 'Mutation',\n    'fields' => [\n        'toggleLike' => $toggleLikeMutation\n    ]\n]))\nThen check your schema.js for Relay. It should have types ToggleLikeInput and ToggleLikePayload. Relay expects them to exist to perform mutation correctly.\n. Glad to hear! Feel free to reopen this if you have other problems with mutations.\n. @chrissm79 Yeah, you need Node interface and each of your entity types must implement this interface.\nBasically this interface only has one field id of type ID (Type::id()). Then when you map response in Mutation.getConfigs(), Relay expects you to use id field (not entity_id as you do now).\nSo your getConfigs() would look like:\njs\n{\n  type: 'FIELDS_CHANGE',\n  fieldIDs: {\n    customer: this.props.customer.id, // <-- note, this must be field `id` of type `ID`, not `String`\n  }\n}\nAlso note, that Relay requires your Query type to contain top-level field node of type Node with id argument.\nAnother requirement is that you must be able to fetch your entity using this id. For example in my case id is composed of entity_id and entity_type, so that it globally identifies your entities.\nMake sure to check docs on https://facebook.github.io/relay/docs/graphql-object-identification.html\nAlso, this JS helper has some hints on how to define these types: https://github.com/graphql/graphql-relay-js/blob/master/src/node/node.js\n. No, graphql doesn't provide any opaque ids automatically. Your data is your data. Maybe laravel-graphql does something here, but I am not aware of that.\n. Yes, you can use such tools. base64 is just one of the options. Relay doesn't care much on how you encode your ids.\nBut note, that you should be able to fetch any node given the id only.\nSo, in RDBMS terms, if you have 10 tables for entities with autoincrement ids, Relay id must somehow encode both - table + row id, otherwise you won't be able to determine which table to query against.\n. Summary:\n1. Input objects should be passed in as variables, not inlined\n2. Field clientMutationId is required for your UpdatePostInput type, so valid value for your input type is: {id: 10, title: \"New title\", clientMutationId: 1}\n. This project contains helper methods and documentation on how to use this library with Relay.\nBut if you are not using Relay, then a mutation is just a field with arguments on Mutation type. For example:\n```php\n$mutationType = new ObjectType([\n    'name' => 'Mutation',\n    'fields' => [\n        'myMutation' => [\n            'args' => [\n                'mutationArg1' => ['type' => Type::string()],\n                'mutationArg2' => ['type' => Type::string()],\n            ],\n            'type' => new ObjectType([\n                'name' => 'MyMutationResult',\n                'fields' => [\n                    'ok' => ['type' => Type::boolean()],\n                    'someData' => ['type' => / Some of My Types /] \n                ]\n            ]),\n            'resolve' => function($root, $args) {\n                // do something with $args['mutationArg1'] and $args['mutationArg2']\n                return [\n                    'ok' => true,\n                    'someData' => [/ some value /]\n                ];\n            }\n        ]\n    ]\n]);\n$schema = new Schema([\n    'mutation' => $mutationType\n]);\n```. If some of your mutations return the same result then, of course, you can re-use this type for all mutations.\nThe other option you have is to use interfaces. For example, if you have some CRUD operations and each of your entity implements Node interface, then you can introduce single type for all create/update mutations:\n```\ntype NodeCreateResult {\n  ok: Boolean!\n  created: Node!\n}\ntype NodeUpdateResult {\n  ok: Boolean!\n  created: Node!\n}\ninterface Node {\n  id\n}\ntype MyEntityType implements Node {\n  id\n  someField\n  someOtherField\n}\n```\nBut that's all project-specific. \nAs for InputObjectType - you use it when your mutation needs complex arguments. For example when you create some deeply-nested structure.\nIt is also useful in the context of query when your fields have complex filters (e.g. DateRangeInput as typical example).. This should be available with 0.7.0 release.\n. Fragments are part of GraphQL syntax (it's like sub-select in SQL). You don't write them in PHP. You write them in GraphQL language. \nThis library will parse your GraphQL query and match it against type system that you express with this library to produce final result.\nPerhaps if you provide concrete example of what you're trying to achieve I could explain it better.\n. This question is related to GraphQL language syntax in general. Check http://graphql.org/docs/queries/ for details.\nBack to your question. Your Query should look like this:\n```\nquery FetchUsers {\n  users(id:\"2\") {...UserFragment}\n}\nfragment UserFragment on User {\n  id\n  username\n}\n``\n. Given your description, it sounds like you do not use type-casting in GraphQL query. So for example you haveCharacterInterfaceand specificDroidandHuman` types. \nThen your query should look this way:\n```\n{\n  character {\n    name\n    someOtherInterfaceField\n... on Droid {\n  modelNumber\n}\n\n... on Human {\n  dateOfBirth\n}\n\n}\n}\n```\nBut to say for sure I need to see your query, because DocumentValidator runs against GraphQL query document, so query is important here to debug.\nAlso I do use this library with Relay and haven't seen such issues, so it's likely not a bug.\n. Thanks for submitting! \nCan you provide an example schema to reproduce this? GraphQL shorthand notation will work (like interface Character {name: String}, type Human : Character {name: String}, etc)\n. Hey, maybe I am missing something, but graphql-php supports closures for field types for recursive cases like this. Have you tried it?\nSomething like this:\n``` php\n$blog = new ObjectType([\n  'name' => 'Blog',\n  'fields' => [\n    'owner' => function() use ($typeFactory) {\n      return $typeFactory->user();\n    }\n  ],\n  'interfaces' => [],\n]);\n$user = new ObjectType([\n  'name' => 'User',\n  'fields' => [\n    'blogs' => Type::listOf(function() use ($typeFactory) {\n      return $typeFactory->blog();\n    })\n  ]\n]);\n// Same should work for interface fields as well\n```\nBut I guess I understand what you mean - having whole fields / interfaces array as closure is a better way to do this than defining closures per-field.\n. Fixed in https://github.com/webonyx/graphql-php/commit/98e5835620ec14c8b24fb178dfabd2d8abdf03c2\n. As @ooflorent mentioned subscriptions are not implemented in this library yet, but I still merged your PR to enable compatibility with Relay / GraphQL-js introspection tools.\nThanks for submitting! \n. It should be InputObjectType\n. Check #11 for some insight on mutations (Relay flavor).\n. Also check out https://github.com/ivome/graphql-relay-php#mutations \nFile uploads is something orthogonal to GraphQL, you will have to handle them in your app code.\n. Yes, you can. But you will have to replace GraphQL::execute() facade with it's contents:\n``` php\nuse GraphQL\\Executor\\ExecutionResult;\nuse GraphQL\\Executor\\Executor;\nuse GraphQL\\Language\\Parser;\nuse GraphQL\\Language\\Source;\nuse GraphQL\\Validator\\DocumentValidator;\ntry {\n    $source = new Source($requestString ?: '', 'GraphQL request');\n    $ast= Parser::parse($source);\n// Here you can access ocument AST and reference operation type and name:\n// (you can also descend deeper to AST tree to get whatever you want from query)\nif (isset($ast->definitions[0])) {\n    $d = $ast->definitions[0];\n    $operation = $d->operation ?: 'query';\n    $name = $d->name ? $d->name->value : null; // mutation name in case of mutation\n}\n\n$validationErrors = DocumentValidator::validate($schema, $ast);\n\nif (!empty($validationErrors)) {\n    return new ExecutionResult(null, $validationErrors);\n} else {\n    return Executor::execute($schema, $ast, $rootValue, $variableValues, $operationName);\n}\n\n} catch (Error $e) {\n    return new ExecutionResult(null, [$e]);\n}\n```\n. Should be fixed in https://github.com/webonyx/graphql-php/commit/b890ef7cfe1b9805cafb53fd284c164a0894a521\n. This should be available as of 0.7.0 release\n. Managed to miss interface field definitions somehow. Thanks for catching!\nShould be fixed in https://github.com/webonyx/graphql-php/commit/d37fb34e96d2f399bff8ffa65b897b767133fc32\n. While AST can be useful by itself, you can still use it by including whole graphql-php repo and just using AST classes.\nThat's how js reference implementation repository structured as well. \nOr maybe I am missing something?\n. What would be really great - is having AST as PHP module written in C. There is already C library for graphql parsing - https://github.com/graphql/libgraphqlparser with ruby and pythong wrappers around it. \nIt would definately make sense to have it as separate repo if it was built as PHP module.\n. For now I am closing this, as there is no problem in using AST classes directly from this project.\n. Yeah, Sangria provides some insights. I think we can implement similar concept, but I suspect that they do several executor passes on the query.\nThat may affect performance, because PHP is not a perfect tool for such tasks. Ideally we'd want this with some sort of PHP module for parser / executor.\nOr at least have some profiling tool to make sure that new features do not affect performance significantly.\n. As a workaround for now (just an idea) - you can set up complexity tracking by wrapping all field \"resolve\" methods with some closure and using ResolveInfo to collect complexity data. Then throw if it reaches threshold.\nBut since you won't be able to get children complexity in parent resolve, you will have to set complexity multiplier in parent and apply it to all children scores when descending deeper during execution.\n. @ivome I think it makes sense to perform several passes on query - one for analysis (optional), another one for execution. \nI am also monitoring graphql-js activity on optimizations subject (https://github.com/graphql/graphql-js/pull/304). Will likely move forward when there is some clear vision on this subject in graphql-js, as this project tries to match reference implementation when possible.\n. @ivome Another idea is that you could probably write custom validation Rule that will test query fields against schema to check for complexity. It might be the way to go with this feature. \nSee DocumentValidator::validate() - last argument is the set or rules for validation. You can inject your own rule there if required. \nObviously you will have to avoid using GraphQL\\GraphQL facade for your project in this case. Guess I will experiment with this first thing. In case if it makes sense - will add section to docs on custom query validators.\n. @mcg-web That would be awesome! I would definately use such rules in my projects.\n. Closing this as now we have validator rules for query depth and complexity, thanks to @mcg-web! \n. Done. And thanks for fixing this!\n. There are several things to say about this:\n1. Error in one field doesn't affect whole query if the type of this field is nullable. If it is non-nullable - GraphQL will find first nullable ancestor field and set it to null in response (and will add entry to errors). If there is no such ancestor - only then whole query fails and returns null. \n   So in your example if field users is nullable then field posts will be still executed.\n2. graphql-php returns plain list of errors versus nested as defined in spec - http://facebook.github.io/graphql/#sec-Errors Most of the time those errors are for debugging the query, not for consuming them in your app logic. These errors provide line and column position of field in query that produced error.\nSome clients like Relay (and GraphiQL in future) - will expect errors in this form to assist developers in debugging.\nBut if you want to use custom errors in your app logic then you need to format errors yourself. Use GraphQL::executeAndReturnResult vs GraphQL::execute. Returned value will have errors property with array of entries of GraphQL\\Error type, which in turn preserves original exception (you can access it with $error->getPrevious()).\nAs for hierarchy of errors - there is probably no easy way to reconstruct it right now (in theory this is possible with ASTs traversing and line/column matching, but not easy). I will likely add tools to make it easier one day, but no timeframes yet.\nAlso if you define custom error formatting - keep in mind that errors field in response is defined by specs, so for custom hierarchy of errors you should probably pick another field in response.\n. Fixed in https://github.com/webonyx/graphql-php/commit/68d868198359f8c29190c271f8108f37f6fa2f51\nThanks for reporting!\n. I am curious about your exact use-case. Can you provide an example?\nBut in general, if you reuse the same type - just re-use the same object for this type %) \nSchema contains map of all types by name. If you have different objects for the same type name, which one should it return when calling $schema->getType($name)?\nAnother reason is that it is very easy to incidentally add two different types with same name.\ngraphql-js has exactly the same invariant - check https://github.com/graphql/graphql-js/issues/146\n. @bwaidelich You don't have to build types as singletones. The only requirement is that same schema must contain only one instance with same type name.\nThe common way to fit into this requirement is to have factory instance per schema (some people call these type resolvers).\nSimple example:\n``` php\nclass TypeFactory\n{\n    private $types = [];\npublic function myType()\n{\n    if (!isset($this->types['MyType'])) {\n        $this->types['MyType'] = new MyCustomType();\n    }\n    return $this->types['MyType'];\n}\n\n}\n```\n(obviously you can add some dynamism to avoid boilerplate). \nThen in your types (even if you extend ObjectType) you can use this factory:\nphp\nclass MyCustomType extends ObjectType\n{\n    public function __construct(TypeFactory $types)\n    {\n        $config = [\n            'name' => 'MyType',\n            'fields' => function() use ($types) {\n                return [\n                    'recurse' => ['type' => $types->myType()],\n                    'field1' => ['type' => $types->someOtherType()],\n                ];\n            }\n        ];\n        parent::__construct($config);\n    }\n}\n. Hey, thanks for your work! Just wanted to let you know that I am looking forward into merging it, just need to find time to review and digest it.\n. I am ready yo merge this, but just curious - what is your use case that requires lazy initialization of interface implementations?\n. Yeah, looks like you are right. I will also rework test case for interface definition via Closure to check for this.\n. Hey, thanks for proposing PR!\nActually I've been waiting for new major graphql-js release to start importing latest changes. And already started working on this. Will post here when scope of changes will be more clear for me.\nIt is also a good moment to add changes specific to graphql-php so that we only had one breaking change migration. \nSo if anyone have ideas or proposals - feel free to post them while it is not too late for this %)\n. Yeah, I completely agree with you. I've been thinking about annotations too. Also I know that some people use custom builder classes to reduce the boilerplate.\nNever found time to experiment with it, but it can be definitely implemented as a layer on top of graphql-php. \nI will be happy to accept a PR for this, but it can easily be a separate project as well.\n. New version of the library will also contain Schema Definition Language parser. So in theory another option for type definition could be something like this: https://gist.github.com/vladar/5def770be005cd9218560c80aa133715\n@jayS-de I don't quite get what you are saying. Can you provide more context / examples on your idea?\n. @jayS-de That's so great. I've been thinking about such general test suite too. It makes so much sense for projects like GraphQL. I will be happy to integrate it when I have a chance. Thanks for sharing!\n. @mcg-web I am all for it. Added you as collaborator for this project as a first step %)\n. @ivome Thanks a lot for upgrade document. I just published 0.7.0 release which corresponds to april 2016 specs. My apologies for the long delay with this. But feel free to post pull requests - things will go much faster this way %)\n. This seems redundant. Also first notation adds some performance overhead because every field type has to be checked with is_callable and then validated against base Type class.\nPretty much everything you can do with first notation can be done with second as well. Also that's how reference js implementation works. It turns out that maintaining this library is way easier when there is little deviation from reference implementation (at least until things settle down with GraphQL itself).\nBut if you have any use-cases which require this feature - please describe them. That's pretty much the reason why I created these issues - to start a discussion if somebody needs them %)\n. Done in https://github.com/webonyx/graphql-php/commit/c11f25794a16863ad727c844ca9083bf1cb3c3d1\n. @Alexandru-Dobre We can discuss it, but first I would like to figure out why it is impossible to change the code of your library for this notation (as it is also the only way reference js implementation allows you to define fields). I am pretty sure there should be a way to do this.\nWhat will happen if you change these lines to:\nphp\n$typeArray = [\n    'name' => $type['name'],\n    'fields' => function() use ($type) {\n        $fields = [];\n        foreach ($type['fields'] as $fieldKey => $fieldValue) {\n            $fields[$fieldKey] = $this->buildField($fieldKey, $fieldValue);\n        }\n        return $fields;\n    }\n];\nif (!empty($type['description'])) {\n    $typeArray['description'] = $type['description'];\n}\n$this->alambicTypes[$typeName] = new ObjectType($typeArray);\nObviously you will have to remove closure for type option in buildField (it is also quite possible that you will have to wrap remaining code of this method to same closure as well).\nWhy this will not work?. Nice!. Mostly because there is additional validation after schema construction which requires all options to be set before validation is performed. In your example this validation would have to be called explicitly at some point of time. \nAnother reason is that I am personally not a fan of partially initialized objects and try to avoid them when possible %)\nBut I do agree that it might be convenient, so maybe it makes sense to add Schema builder class which will have all options expressed as chainable methods.\n. @mcg-web On schema validation - that's pretty much how it works in reference implementation. But I've been thinking about changing this. Because in PHP world we don't have a luxury of having one schema instance for all requests, instead every request has it's own instance and it doesn't make sense to validate schema every time.\nIn our case schema validation should be a part of development workflow and probably build / deployment step. But it shouldn't be executed on every request on production. Still it should be enabled by default for backwards compatibility (but with ability to disable it for production).\nAlso based on your feedback I will definitely add some chainable syntax for schema creation - either via separate Builder class or to schema class directly.\n@jayS-de It kinda works, but I think fluid interface (chainable methods) is more expressive and convinient way to do this.\n. @ooflorent I've been thinking about this. \nBut I suspect that deserialization might be even slower than creating new schema object (with disabled schema validation). \nIt's been a long time since I wanted to build some profiling tests for parsing, validation, execution and schema building steps in order to make rational decisions on various performance improvements. Never found time though %)\nIf deserialization proves to be faster - we can move in this direction. Another thing to consider is that application may define own callbacks for type definitions (e.g. similar to how validation rule for query complexity expects some callbacks in type config). \nSo deserialization must be extendable in app-space.\n. Another alternative to schema deserialization is constants expressions (new feature of PHP5.6+). Nice blog post on the subject - http://blog.blackfire.io/speeding-up-autoloading-on-php-5-6-7-0-for-everyone.html\nSo the idea is that schema could be dumped into pure constant array shared by all requests. Then you can avoid deserialization step completely and reduce memory consumption by re-using this immutable schema array in all requests.\nThe downside is that it requires major code rewrite and 5.6 as minimal PHP version.\n. @mcg-web Just wanted to note that I remember discussion about chainable syntax, but decided to release what was ready at the moment. Will get back to this in future versions. In the meantime it is quite possible to implement schema/types builder as a separate project with rather simple set of classes.\n. Closing, as this is already done, but created separate issue #58 to track schema builder question\n. What is the point of ExecutionResult extensions? They don't seem to be referenced anywhere in the codebase?\n. First of all, there is a new branch which reflects graphql-js 0.5 with new way how interface resolution is handled. It is different now. Possible interface implementations are all moved to schema vs staying at interface object itself. It makes sense because same interface may have different implementations in different schemas (even if it is just theoretical).\nSo you could try this branch before applying any fixes. Maybe your case is covered there. If not - we can dig deeper. \nThe problem with new branch though is that it is the first version with breaking changes since the initial release and it requires some changes in app code. I planned to write changelog or migration guide on this, but didn't have a chance to do this yet.\nIn short - there are several breaking changes:\n1. Schema constructor will accept config now vs separate arguments for query, mutation and subscription types\n2. signature of GraphQL::execute and Executor::execute is changed - contextValue is added to arguments alongside rootValue\n3. 3rd argument of resolve method now accepts this contextValue and ResolveInfo is now 4th argument.\n4. There is a way to pass types to schema in constructor separately. It is required for cases when some object types are only used as interface implementations and are never added to schema.\nThis pretty much reflects breaking changes of graphql-js 0.5. Most of fixes are trivial. I plan to move this branch to master and release new version soon.\nAlso make sure to check https://github.com/webonyx/graphql-php/issues/35\n. FYI I added your test class to april-2016 branch version and it worked fine without any code modifications. So I guess you will just need to update once new version is released (somewhere on week-end).\nThanks for investigating this! And we'll use your test to catch regressions if it's ok.\n. I see what you mean. That's exactly the reason why types option was added to schema in graphql-js and now in graphql-php. \nWhen your type is only referenced in schema as interface implementation and is not referenced anywhere else, it remains invisible for GraphQL during validation phase.\nSo one way to make such types reveal themselves for GraphQL is to pass them to Schema explicitly. That's the route that graphql-js chose. Another option would be to allow interface define the list of possible implementations as a hint. \nFor now I keep this library as close as possible to graphql-js, so we also have types option for this purpose now. But the other option seems viable as well and may give us better granularity for types initialization some day.\nI will create separate feature request for this. But if you have other ideas on how to make this work better, please let me know.\n. Also note that it is not really lazy initialization of implementors, but rather late or deferred one. All types, including all implementors are initialized on schema creation anyway. \nThis is something I want to improve one day, but now there is no on-demand or lazy initialization of types.\n. After more thinking: this is bad idea. Looking for better ways to solve original issue.. Thanks for brining this up. \nBut that is really something that could be built on top of graphql library. The goal of this library (as well as reference implementation) is to provide rather simple but powerful tools that others can utilize to build application servers like the one from the article.\nThe problem with PHP though is that it is not the best tool for reactive applications (at least pure PHP at it's current state). See #9 for more discussion on this topic.\n. We should keep this library decoupled from any specific library for promises.\nJS version just uses isThenable function to check if something is a promise (which by default only checks if object is returned and if it has method then). \nIf we choose this path, users will be able to pick any library for their app. Alternatively, I know that there is a discussion about PSR for Promises. \nIf they come up with some generic interface, then we could use it instead of isThenable function.\nBut another question is why do you need promises at all? They seem to be useless in pure PHP and only make sense for some event-loop projects like ReactPHP and possibly in HHVM. Do you work in such environment?\nBecause we really need at least one maintainer who uses this feature in real async environment, otherwise it might be a pain to maintain (and use for end-users).\n. @mcg-web But you can't use Dataloader to defer requests with promises unless you are in event-loop/async environment. To rephrase - when/where will you call resolve on your deferreds? \nAll promise libraries mentioned here do require specific environment (ReactPHP for React/Promise, amphp for amphp/amp, guzzle is mainly used for http requests where async tools are possible with curl or non-blocking sockets).\nBut maybe I am missing something, so please let me know if I do. Example would help a lot.\nAt the same time I do agree that leveraging Dataloader concept would be beneficial. But this will require deeper modification of execution process with another step in execution process to run promise resolvers. Alternatively we could do this without promises (but just adding defer callback to field definition along with resolve)\n. @smolinari In terms of performance, graphql-php application has little difference over any complex php application, so your statement about PHP (in it's current form) being bad backend for graphql applies to any complex PHP application.\nAs for this library it will stay focused on vanilla PHP. Yet if we manage to integrate promises then event-loop based engines for PHP could use it as well.\nBut what we really need to make it work - is a person (or group) who works with graphql-php in threaded (or event-loop) envrionment and can report bugs or even help with maitainance in such environment.\n. @ooflorent Thanks for bringing this up. I've been watching for this thread for a while. I think it requires much more efforts and tests before it could be integrated. This stuff is really complex with it's own pros and cons.\nYet in vanilla PHP we need something like this to enable batching queries (e.g. with Dataloader). I also followed similar discussion in dotnet implementation - https://github.com/graphql-dotnet/graphql-dotnet/issues/21\n. I'll close it for now. Feel free to reopen if you have new ideas or pull requests.\n. We should consider how to approach this fix properly. I did have a bad feeling about this optimization when implemeted it on request, but couldn't come up with example that would break it.\nNow when we have such example we can think of better ways to implement such improvements. I am personally a fan of React's approach when you build your component and then can improve it's performance by using hooks to provide hints for rendering process.\nI guess we could come up with some optional per-field (or per-type) hooks. The question is how to make such hooks easy to use and clear for end-users.\nBut for now I guess we'll have to just disable memoization for lists.\n. Cool, will you work on this? I've got some unexpected personal stuff to figure out which distracted me from the project for a while, but hopefully will be back on track soon.\nAs for this issue, I guess the test case is the most important part of this to catch possible regressions in future perofmance optimizations.\nAlso just FYI - I plan to add a suite of benchmarks using https://github.com/phpbench/phpbench Then we will have some grounds to work on future performance optimizations.\n. Sorry for long delay on that. You are correct with this change, so it is merged.\n. Yeah, I agree that it is convenient and I don't envision any significant cons. Will be happy to merge a PR for this. So feel free to submit it when you have a chance.\n. Fixed in https://github.com/webonyx/graphql-php/commit/5148c3bf03973c6643f55361b52c739e3bf0bce8\n. @geshido Try GraphQL Feen - works nice for me and has more features than ChromeiQL\n. The error you mentioned and fix are valid - introspection query with deprecated fields should still run correctly\n. Thanks! I added link to your example in Overview section of Readme.\n. What do you use as context? Is it array or object?\n. Arrays are passed by value in PHP. If you use an object for context it will be passed by reference copy. So the quick solution would be to replace array with new ArrayObject() and then pass it as $context instead (or create an object wrapper for your context array).\nI do not want to pass $context by reference because it has it's own disadvantages, including accidental null'ing and possible performance overhead for read-only access.\n. Yes, this is quite expected behavior. \nAlso I am curious why do you need to modify context in resolvers? While this operation is valid but I never really needed to do this (returning custom values was usually enough). \nJust want to better understand use-cases for future lib maintenance.\n. Thanks. This seems reasonable. Current user or rules depending on current user is a primary use case for context, it's just that usually it is defined on the top-level (vs in resolvers), but I guess cases like yours also make sense.\nI'll close this issue, but feel free to reopen or fill another one if needed.\n. Right now query validation requires all types to be loaded in schema. So even if you do this - all types will be loaded on validation step.\nI've been thinking about ways to relax this requirement, but it will have a price of some invalid queries passing through without errors on validation step and failing on execution step (ot not failing which may be even worse). \nSo this will come at a cost, yet the payoff might worth it. I'll keep it open as it makes sense to investigate, but it might be not a simple change (at least from what I remember), so no promises on when it will be done. \nIf you are interested, feel free to investigate this question further and post your findings / pull requests. \nThe only note - I would not recommend passing class name of the type (because this way you are supposed to force class constructor signature, which is a bad idea).\nInstead we should have TypeFactory in Schema which accepts type name (or any other type identifier) and returns type object.\nIn such case you can implement your own TypeFactory and use any type identifier as convinient for you. But default TypeFactory will be just a pass-through (expecting type instance) for backwards compatibility.\n. @smolinari You can disable or you can keep it. Depends on your system. If all of your production queries are safe and you do not expose graphql endpoint to public then it makes sense to avoid validation, otherwise (e.g. you expose your graphql to 3rd parties) - you might want to keep it.\n. @rudiedirkx at this point yes - this implementation mirrors JS reference implementation, but in order to make it work as you describe several significant modifications have to be made. I don't want to break connection with reference implementation until spec becomes stable. But at some point in time this will be done.\nYet if you find elegant way to do this - feel free to post your findings - we'll incorporate them into library code.\nAs for lazy loading of fields - sometimes it is just inevitable because your fields may reference the type that is not defined at the moment of field definition. So this 'fields' closure is not really related to performance, yet it might help in future performance optimizations.\n. I close this in favor of #62. Feel free to re-open if you have any problems with proposed solution.\n. You are correct. We need to fix this for next version. Feel free to send a PR if you have a chance %)\nIn the meantime you have full control of how response is serialized. Just use GraphQL::executeAndReturnResult vs GraphQL::execute and apply your own transformation of GraphQL\\Executor\\ExecutionResult to array.\n. Throwing exception in resolver only stops query execution if the field type is marked as non-null. Otherwise (for nullable fields) error will be added to execution result and field value will be returned as null.\nAs for execution context - it is not passed to resolvers at all as it is executor implementation detail. Instead GraphQL::executeAndReturnResult returns instance of GraphQL\\Executor\\ExecutionResult which contains all errors generated, including your custom resolver exceptions (which should be available via $executionResult->errors[$X]->getPrevious()).\nYou might be confusing execution context with app context which you pass as 4th argument to GraphQL::executeAndReturnResult and which is later propagated to all resolvers in 3rd argument. But app context is your own variable, errors are never added to it and it is not used by GraphQL at all (it is just passed to resolvers as 3rd argument). \nSo if you pass an array as such app context - you will get an array in 3rd argument of your resolvers, if you pass object as context - you will get exact same object. GraphQL itself never touches your context.\nTechnically throwing exceptions in resolver is the way to go (when your error/exception prevents from resolving field). But if you just want to add notice/warning - you can use your app context for that as well (just pass any object as app context and it will be passed by reference copy to your resolvers, so that you could modify it)\n. Closing this as it is not an issue. Feel free to reopen if I am missing something.\n. Closing in favor of #82. Nice catch %) \nLooks like we need to convert empty arrays to stdClass explicitly for such cases. Alternative is to use separate array-like class implementing JsonSerializeable in Executor, yet this will be way slower, so will likely just use stdClass.\n. I already fixed it, just not pushed yet because still doing some other improvements to the library. Will post a link to commit here when closing.\n. Fixed in https://github.com/webonyx/graphql-php/commit/a612b780c9c08e96f969e609093e793050cfd76b\n. Yes this is a well known N+1 problem. And you are correct - executor uses Depth-First algorithm vs Breadh-First (same as reference implementation). \nI posted this comment one day about how to workaround this in the user land.\nAs for solution in core - there is no such thing yet. But I do understand that we need one. The question is which approach will work best (and if I can find enough time to implement it).\nOne option is to use breadth-first execution as you suggest. But this is really major change and I never found enough time to experiment with it (I actually tracked some other implementations, like .NET which also had plans for breadth-first execution, but never started too).\nOther option is to add rather minor modification to support Deferred (Lazy) values which will enable batching. \nThen your resolver would look like this:\n``` php\n'resolve' => function($obj) {\n    $this->someBuffer[] = $obj->someId;\nreturn new GraphQL\\Deferred(function() use ($obj) {\n    $values = DataLoader::loadAll($this->someBuffer); // must load stuff only once obviously\n    return isset($values[$obj->someId]) ? $obj->someId : null;\n});\n\n}\n```\nOther suggested syntax:\nphp\n'buffer' => function($obj) {\n    $this->someBuffer[] = $obj>someId;\n},\n'resolve' => function($obj) {\n    $values = DataLoader::loadAll($this->someBuffer); // must load stuff only once obviously\n    return isset($values[$obj->someId]) ? $obj->someId : null;\n}\n(see also this thread for related discussion)\nThis is actually how JS version works (Facebook created separate project called DataLoader to help implementing this approach).\nThis way of doing things is probably less powerful than BFS, but it is realsitic in terms of finding time to implement at some point %) Plus it is rather easy to understand.\nAnyway, if you find it interesting to experiment with breadth-first execution, I am open to ideas and PRs.\n. Those solutions are just proposed. They are not implemented yet. Obviously they will require changes to Executor code. Actually it will be a mix of depth-first and breadth-first in such case (JS version does similar thing with promises while still logically working as depth-first algorithm).\nAt this moment the only existing way to workaround this issue is the one described in this comment\nAs for map. It was my experiment in this library only, it is not a part of GraphQL spec. The idea was that instead of defining resolve for field you defined map and always worked with list of values vs single value as in resolve. \nIt allowed to optimize some cases (like yours), but it didn't work for many other situations. Which means it was not general enough to maintain, hence reverted. \n. I'd say don't do it %) While it might seem tempting, but you place yourself into very dark territory by doing this. \nThe reason is that a) it makes query dependent of execution order, b) stateful\nFor example in JS app order of fields execution is not guaranteed (they might run parallel executors for different fields some day) and you may end up with very weird situations which are very hard to debug.\nWhile it is unlikely that we'll have parallel executors in PHP world, but still - good workaround shouldn't force you to rewrite queries. \nHave you tried original workaround proposed? While it is also not perfect, but at least you don't have to rewrite queries like this.\n. Another option is to analyze nested fields in some parent field (e.g. in reservations and just pre-fetch data required for nested fields resolution). \nFor example:\nphp\n'resolve' => function($user, $args, $context, ResolveInfo $info) {\n  $nestedFields = $info->getFieldSelection(/* to depth */ 3);\n  // analyze $nestedFields here to prefetch data\n  if (isset($nestedFields['resource'])) {\n    // prefetch by user id\n  }\n  if (isset($nestedFields['resource']['expensive']) {\n    // prefetch even deeper\n  }\n}\nNot sure if it will work for your case with interfaces, but still may be useful.\n. I guess we simply missed that when implemented ResolveInfo. Feel free to add a PR for this or I can add it based on your comment some time later.\n. As for cases like reservation > players - I bet you'll have to run separate queries for such cases in almost any app. There is just no good (and maintainable) way to write this. At least I am not aware of such tools %)\n. Nice. Feel free to send a PR if you make it work. \nAlso note that Executor follows closely JS version which already supports promises, so it might make sense to simply follow their solution. \nThe problem though is how to test this feature with PHPUnit / Travis CI.\n. @chrissm79 Full-featured support for such things as arguments and directives actually means that you need to visit related ASTs %) It makes little sense to introduce new structures that will basically duplicate existing AST.\nSo the simple answer - just use ResolveInfo to walk through field AST and get the information you need (maybe using getFieldSelection as a reference for your implementation). \nAlso note that getFieldSelection will be likely deprecated exactly because real-world look-ahead solutions are complicated (see related discussion in https://github.com/webonyx/graphql-php/pull/61).  In short, fragment spreads can by typed and currectly this function doesn't account for that (as well as for inline fragments).\n. @chrissm79 After some thinking I realized that I may be wrong and convenient look-ahead tool in the core could be useful (at least it is requested often). So I created #65 to discuss possible implementation. Feel free to post your idea / use-cases there.\nYet I doubt that I'll find time for this anytime soon, so any help would be appreciated.\n. Closing this in favor of #65 and #66\n. @rudiedirkx Not really. I guess good solution requires breaking change anyway.\nI incline to deprecating this function and introducing new one wich will handle Inline fragments in more elegant way.\nI guess I could merge this, but don't see much point since it will be deprecated anyway.\nBut technically it shouldn't block you. Just extract this piece of logic into your own utility function accepting ResolveInfo as argument and do the same.\nMaybe eventually you will come up with brilliant solution and contribute it back %)\n. @rudiedirkx See #65 to track this. Looking forward to hear your thoughts and ideas.\n. I plan to work on performance improvements. \nIn general the plan is to release new docs + version 1.0 then work on performance improvements for 1.1.\nAs for this proposal - it might have different advantage for future. PHP 5.6+ has constant arrays. They are stored in byte-code cache together with class definition. So a) PHP doesn't need to parse these arrays on every request b) they are stored in shared memory (basically it is the only way to share something as variable between requests in PHP, without using serialization/deserializtion).\nAs for performance penalty for creating whole schema on each request - I am researching ways to avoid it. Actually it is clear now that it is possible with some relaxed validation and minor modifications to type resolution in schema.\nThe main problem here is that the only way to get all interface implementors on validation step is by scanning all object types and comparing if it implements the interface. Disabling validation rules that call this logic should do the work (+several Schema tweaks...).\nAlternatively I've been thinking about adding implementors option to interfaces to avoid this problem alltogether (see #40), but it might be actually evil to do if you have such definition in two places (ObjectType interfaces or InterfaceType implementors), so need to consider this carefully.\n. @intellix Those two things are not related. \nAbility to define schema as array is desirable for performance. Even if you define your schema using GraphQL schema language you must still parse it and represent as PHP value.\nSome people prefer to avoid parsing overhead to get best performance.\nAs for GraphQL schema language - we do have parser for it (see related test + example of schema definition), but it only produces AST. One step is missing - to recreate actual type definitions from this AST.\nRight now this step is hard to implement in generic way (due to resolve, resolveType handlers and some other things), but you can write glue code for your own projects which will transform such ASTs to actual type definitions.\nP.S. If you decide to do so - maybe you will be able to write it in generic way and can contribute it back. PRs are welcome! %). This feature requires more efforts than provides benefits.. @rudiedirkx There are couple other options:\n\n\nUsing doctrine annotations (experimental projects here and here).\n\n\nUsing GraphQL type language. Not documented yet, but simple example is available here.\n\n\nYou never had to define everything in one place. This example shows how you can split types to files.. It is not a bug. ListOf and NonNull are not named types (their name is null). Instead wrapped type is stored in ofType field.\n\n\nChange your query to:\n{  \n  __type(name: \"User\") { \n    name \n    fields { \n      name \n      type { \n        kind\n        name \n        ofType {\n          name\n        }\n      } \n    } \n  } \n}\nand you will see what I mean.\nIf you try graphql-js at http://graphql-swapi.parseapp.com/ and run the same query against any type containing nonNull or listOf field - it will return the same result.\nAlso I am curious where do you use this?\n. No problem! %)\n. @decebal Oh, sorry I missed your comment somehow. \nI'd appreciate your PR. Can't guarantee that I'll merge it (since we still need complete solution that answers all questions), but it will be useful anyway (as insight, or as direct solution for item 4 from this list).. @chrissm79 No they are not possible directly, see #42 for full discussion on this subject. Yet we may adjust executor to postpone deferred values up until later point. \nHere is a simple example:\ngraphql\n{\n  a {\n    b\n    deferred {\n      c {\n        d\n        e\n      }\n    }\n  }\n  f\n  deferred2 {\n    h {\n      i\n    }\n  }\n}\nCurrent executor runs fields serially: a, b, deferred, c, d, e, f, deferred2, h, i (depth-first)\nNew executor would evaluate them in following order: a, b, deferred, f, deferred2, c, d, e, h, i (mixed depth-first and breadth-first)\nActual code will be more complicated, but that should demonstrate the idea.\n@mcg-web Why closing this?\n. @mcg-web I don't quite understand how promises help us in case of sync code. My current understanding is that promises will only work for async environments. In sync environments they don't help too much: wait method simply blocks execution, but doesn't change the order in which fields are executed.\nSee example query above - how promises can help to achieve this order of field execution in sync environment? Sorry, maybe I am missing something.\n. It's not the deferred/promise interface or syntax that bothers me. I don't understand how Promises (any implementation) can help us to defer field execution in sync environment. \nThe only conceptual thing we need in sync environment is resolver returning some callable that will be called only after all other available fields are executed.\nHow this callable is implemented (wait method of some interface or wrapped Closure/Callback) - is a secondary question.\nThe main question is - how do we actually defer execution of this callable until completion of all other available fields?\nThat's what bothers me and I don't understand the value of Promises for this deferring process in sync environment. They just don't provide any help here (unless I am missing something).\nMy current understanding is that there are two (quite orthogonal) mechanisms:\n1. Promises in async environment do help to defer execution by leveraging underlying event-loop\n2. In sync environment you need to write custom mechanism for deferring fields (which won't get much help from promises)\nSo technically this issue is not about adding promises support, but about changing the algorithm of field execution in sync environments.\nDoes it make any sense?\n. After some thinking one idea I have on how to leverage Promises for sync environment - is by implementing our new executor algorithm as event loop (technically field-loop in our case). \nThen in environments with native event loop (like ReactPHP) we can use promises directly, but in sync environments we will run custom field loop (which in turn will call wait method from your example).\nI guess it is similar to what @ivome mentioned in this comment.\n. @shadowhand Simple implementation with JsonSerializable won't work. After calling resolve value is passed to nested object resolvers. In this case - your deferred value with no data, which will actually emit null for all nested fields.\n. @shadowhand Ah, agree %) \nThere is actually one way how Promises can potentially help. See discussion in https://github.com/webonyx/graphql-php/pull/67 \nI have big doubts about it's convenience though, but need to play with it first before making conclusions.\n. For anyone interested - we added ability to defer field execution in master. Still experimental phase, but all tests pass and it's time to play with it.\nThe syntax for standard sync mode is the one I described previously, namely:\n```php\n'resolve' => function($obj) {\n    $this->dataLoader->buffer($obj->someId);\nreturn new GraphQL\\Deferred(function() use ($obj) {\n   // This will internally load all buffered ids (once) and return the one requested here:\n    return $this->dataLoader->fetch($obj->someId);\n});\n\n}\n```\nIt is fully backwards compatible and works in standard PHP versions (no need for ReactPHP or other async platforms to leverage this feature).\nTechnically it simply alters the order of field execution. Deferreds are skipped for resolution until all non-defered fields are resolved. It enables quite effective batching of queries. \nUnder the hood it uses Promises as main concept for deferring. Promises do help even in sync environment when combined with queues. \nWe could implement it without promises (by using field queue instead), but with promises we can leverage any async platform which supports them (like ReactPHP, HHVM, icicle.io, php threads, etc). Obviously the syntax will be different in this case comparing to sync mode (you will return promises of the platform of interest vs GraphQL\\Deferred), but conceptually it will work the same way.\nThanks a lot to @mcg-web for contributing Promises support and tests!. Docs entry: http://webonyx.github.io/graphql-php/data-fetching/#solving-n1-problem. Will do - hopefully till Monday. In the meantime, I posted null value support + some other changes to master and it seems to be conflicting now with this PR. Can you resolve the conflict when you have a chance?\n. Hey that's awesome and very close to what we want! I'll post comments inline for follow-up.. @mcg-web It's awesome! I will likely do minor refactoring after merging (will convert Executor to instance to avoid passing context everywhere and instead have context and promise adapter as properties of this instance), will also try to implement sync version of adapter to avoid hasPromiseAdapter() checks (we will always have such adapter even for sync case to enable fields deferring out of the box for sync environments).\nAlso I will probably release 0.8.0 before we merge this in: it is a big change and we want to play with it for some time before releasing. So please let me know when it's ready for merge and I'll merge it when ready.\nThanks a lot for your great work!. @mcg-web I'll merge this somewhere this week when I get a chance. Want to give some room for 8.0 bugs to get reported (if any). Sorry for the delay.. I am not aware about laravel package details, but there is separate project https://github.com/ivome/graphql-relay-php for integration with Relay (it is referenced in Complementary tools section in README)\n. Closing this. But feel free to re-open if that didn't help %)\n. This was added as experimental feature in v0.9.0, but unfortunately it doesn't work out of the box: eager type loading is still the default. \nOne might override it by providing typeResolution option to Schema which must be an instance implementing GraphQL\\Type\\Resolution interface.\nRelease v0.9.0 contains experimental GraphQL\\Type\\LazyResolution as sample implementation, but it requires some workflow in order to actually load types on demand:\n\n\nDump schema descriptor, prodced by EagerResolution strategy (probably during build step in some CLI tool):\nphp\n$descriptor = $schema->getDescriptor();\nfile_put_contents($baseDir . '/my-schema-descriptor.php', \"<?php\\n return \" . var_export($descriptor, true));\n\n\nSet lazy loading for production environment:\nphp\n$descriptor = include $baseDir . '/my-schema-descriptor.php';\n$typeLoader = function($typeName) {\n    $className = 'MyNamespace\\\\' . $typeName;\n    return new $className();\n};\n$lazyTypeResolutionStrategy = new GraphQL\\Type\\LazyResolution($descriptor, $typeLoader);\n$schema = new GraphQL\\Schema([\n    // ...\n    'typeResolution' => $lazyTypeResolutionStrategy\n]);\n\n\nThis is experimental feature, there are still no benchmarks to see if it gives major benefits. So until we do have some evidence that it helps - it may be a subject to change.. Forgot to post results of my research on why trully lazy type loading is problematic (without external hints about schema structure) and what we will have to sacrifice to implement it:\nThe most important problem: we must either sacrifice validation of fragment spreads in some cases or introduce type loader (similar to classloader in PHP). Consider this schema:\ninterface Pet {}\ntype Dog implements Pet {}\ntype Query {\n  pets: [Pet]\n}\nAnd query:\n{\n  pets {\n    .. on Dog\n    .. on NonExistingType\n  }\n}\nWe don't know actual return type of pets field during validation step (as validation is static analysis). And type Dog is not loaded at this moment (as it wasn't mentioned anywhere before in the query) + we have no knowledge on how to load it. \nWe solved similar problem previously with types option to Schema. But that problem only affected a small portion of types, while this new situation may affect almost any object type.\nOptions are:\n1. Blindly allow both on Dog and on NonExistingType fragments in such case: execution will just return nothing for most of invalid fragments\n2. Introduce type loader and ask it to load type Dog for us + continue validation. But this is a major breaking change.\n3. Combine two options above with stricter validation when type loader is defined and relaxed validation without type loader.\nBut even with type loader we will have to give up validating fragment spreads when fragment is of Interface type and it is spread on field or other fragment of interface type:\n```\ninterface Pet {\n  name\n}\ninterface Being {}\nfragment on Pet {\n   ... on Being\n}\n```\nRight now if two interfaces have intersecting implementations this query will validate, but if not - it will fail the validation. With lazy approach it will always pass the validation, but then return nothing. I guess this case is extreemly rare.\nOne more problem I've discovered is that we will have to force resolveType in interfaces and give up on trying to guess actual object type with isTypeOf. Such guessing requires prior knowledge about all possible implementations of interface which is only available if you scan the whole schema upfront.\nIn general these trade-offs seem a reasonable price, but require major version dump. Also the type loading solution requires some further thinking. Re-opening this just to keep visible for next version.. @AndreasHeiberg Current implementation works, but it requires separate build step. Basically you must analyze whole schema and save somewhere all types existing in schema and (most important) all interface implementations. Current solution requires these hints for lazy type loading. \nIn theory, it is possible to prepare other solution which will load types on deman without separate build step. But such solution will have one restriction: you won't know all interface implementations.\nSo any code that relies on this knowledge (like isTypeOf or some validation rules) will not work and requires different approaches.. As for performance improvement - it should be quite constant in ms accross queries. Technically it saves time on schema building, so query size is not that important (but the impact will be smaller on bigger queries, simply because they do init more types during execution).\nAs for the interface issue. This is not the same case as I described. You spread object types on interface field, but the case I described relates to spreading interface type on field of other interface type. \nSo your example should always work - in both old and new anticipated solution. Given your result - it is either a bug in current solution or some error in your custom code. If you're sure this is bug - can you create reproducible test case and open new issue? (I need to see data and resolvers to figure out what's going on). @olragon Thanks for sharing this! Performance improvement is proportional to schema size (number of types and fields). \nI am not sure, but having fields in all types defined as closures may also affect performance in positive way (but I guess you already do so).. Finally, the new implementation doesn't require a separate build step. Only type loader passed directly to schema. Will be released soon in v0.10.0.. @tpetry I do agree that it is convenient, but it should be optional. \nOne of the reasons why array-based definitions were chosen as default is performance. Like it or not, but when you have hundreds of types and thousands of fields it means you get thousands of builder function calls on schema creation (likely tens of thousands). They are cheap, but when cheap is multiplied 10000x it gets expensive.\nIf it was other language (where schema could be created only once and re-used for every request) - it would made much more sense to prefer builder as a default. But in PHP you have to look for balance.\nNow when we have some options for loading types/fields on demand (see #69) such builder makes more sense. \nAs for gigantic file - you don't have to use single file with all definitions. See example for type per file.\nAlso check out this PR for work in progress on this issue - maybe you will post your thoughts / comments on implementation.. I thought about it (and even wrote a POC). But things are a bit more complicated when it comes to interfaces. \nWe do have rules during query validation phase (and also during execution) where we need to know all interface implementors. Currently you have to scan through all types to figure out all types that implement given interface.\nTechnically we could remove these checks from static query validation step, but then we loose some of the nice benefits of static query analysis, which makes such solution incomplete.\nBut yeah - if we fail to implement a solution which is both - complete and performant - we can return to this path.. Use https://github.com/simPod/GraphQL-Utils or other tools mentioned here instead.. Hey by the way - will be very glad to see this feature in our lib. Thanks for this work!\n. Feel free to merge it yourself when ready. \nOne thing that is missing though is documentation. New docs are stored in /docs folder. Please add new file about builder when you have a chance. I guess it makes sense to explicitly mention that it is experimental API which will likely to change (docs are powered by mkdocs, so documentation site structure is defined in mkdocs.yml).\nAlso just a friendly request - can you avoid Traits? I know it is opinionated view, but if we can avoid them without major impact on codebase - I'd appreciate it. If not - I can still live with it.\n. I think I can merge it before the next version release. So just keep it as is. Actually, I am not sure if we do need it at all (since many people introduce their own methods of building types or use framework-specific libs which do it for them).\nAdding it to the main library may add some confusion about the right way to do things. @mcg-web what do you think about it? Will you guys use these builders for symfony bundle?. I do agree with some of your statements and disagree with some others.\nFor example about using publics vs getters/setters - this is because of performance reasons primarily. PHP is not the best tool for parsers and huge queries already produce significant overhead. It is not uncommon to use public props for this. For example Doctrine ORM does the same for the most intensive cases: https://github.com/doctrine/doctrine2/blob/master/lib/Doctrine/ORM/Mapping/ClassMetadataInfo.php#L46\nAs for other notes and changes - will get back to you as soon as I get a chance. Give me some time to digest it %) \n. I reviewed your changes and will definitely cherry-pick some of them. Yet there are two main principles which I prefer to follow in this lib:\n1. Backwards compatibility and deprecation strategy vs breaking\nIn other words - deprecated stuff stays in library long enough for all users to adapt (with optional E_USER_DEPRECATED notice) - for at least one medium release (better longer if possible).\nIt is not always possible, but very desireable. We only had one release with major BC break since the inception of this lib (if my memory doesn't lie) and even then the only reason for break was that it was almost impossible to introduce needed change via deprecations.\n2. Keeping surface area of library API small\nIt is hard to do in PHP, so we should probably document it instead (in new docs + maybe using @api dockblock as symfony used to do). \nSo we do expose:\nparse() -> AST tree\nvalidate() -> Error[]\nexecute() -> ExecutionResult\nPlus type definitions and AST structures. (maybe there are couple other APIs which I forgot to mention now - we definitely need to document all of them).\nEverything else is pretty much implementation detail and should not be relied upon by end-users. Every exposed API requires time and efforts to maintain (or irresponsibility in exposing it in the first place with the cost of breaks and errors in future).\nObviously these are just principles. Sometimes they are hard to follow, but we try in this lib.\nAs for DI. The trick with DI is that you only need it if you do want to expose something for extension or when you need polymorphism for your internal implementations. Same applies to Interfaces and other polyporphism-related tools in general.\nBut if you do not expose something - polyporphism-related tools often complicate things (at least when they introduce new entities like interfaces, factory classes, etc which you could avoid otherwise, hence breaking Occam's razor rule). Doing these things mechanically somehow became a rule of thumb and good practice, but I do not subscribe to this point of view %) \nFor example changing parse() to new Parser(new Lexer)->parse() pretty much exposes implementation details of the Parser. Do we want to add other lexer in our implementation? No. Do we want to allow end-users define their own Lexers and are ready to maintain Lexer interface for that? No. Then why doing this?\nSo to summarize - I am very much in favor of polymorphism-enablement (DI, interfaces, etc) for cases where we decide to expose some functionality to end-users for extension or when we do need it for our own implementations. But not mechanically.\nAs for your changes - I do agree with some of them (style changes, changes of statics to objects where appropriate) - will cherry pick them when I find time to work on lib next time.\npublics will stay because of performance and backwards compatibility. \nWe can consider replacing them with getters/setters for type definitions, yet I do not see any particular advantage in doing this (more lines of code to maintain, worse read performance, bigger serialization size if we decide to allow definition serializations in the future). But even if we do - we'll add __isset, __get, __set for BC.\nAnyway I am really glad to see your PR and will be happy to see other PRs as long as they follow two principles above. I'd like to keep this library open to contributions!\n. Hey, your PRs are welcome anyway! Even if they break stuff - we can negotiate %)\n(but it makes sense to create github issue first for discussion)\n. Closing as I cherry-picked several commits from this PR.\n. Thanks for PR! But actual implementation for null values affects a bit wider scope than just AST and Parser. See https://github.com/graphql/graphql-js/pull/544 for reference. \nI can merge this PR as is, but if you wish to contribute other missing pieces as well - that would be great. If not - nevermind, since I plan to work on this further sometime soon, will use your PR as a base then.\n. Will merge it when I start the work on importing new features from reference implementation for 8.0.\n. Support for NullValues is in master now\n. @mcg-web We can use interfaces of course, but I suspect that type definitions will require some boilerplate code anyway. For example:\n```php\nclass AbstractObjectType \n{\n    private $fields;\npublic function getFields()\n{\n    if (null === $this->fields) {\n        $this->fields = [\n            // ...\n        ]; \n    }\n    return $this->fields;\n}\n\n}\n```\nWe can automate it in abstract types. \nOther thing is that naming is important :) ObjectType or InterfaceType names are already taken by existing implementation. And adding Interface suffix is something I'd like to avoid (just read InterfaceTypeInterface) %)\nOther option is to put them in separate namespace, but then you will be annoyed by IDE autocomplete with identical names (Exception class names - I am looking at you!)\nBut this is all about brainstorming for now, so maybe we'll stick with interfaces in the end if we can address those issues somehow.. @tpetry Sounds like an argument %)\nThis is exactly the purpose of this issue - to discuss possible use-cases and ideas. Interfaces would work at the cost of more user-land code. So this is really about finding the right balance between ease of use and flexibility.\nCan you share what traits would you use to reduce boilerplate? Maybe we can include some of them (or at least something similar) in the library so that users do not need to re-invent the same stuff all the time.. Hey, thanks for reporting. Looks like it's not the order that is wrong - it's just that keys are set as strings vs int.\nI don't think ksort is a proper fix for the problem, so need a bit more info on how to reproduce it:\n1. Do you use ReactPHP or some other async environment? \n2. Also I am curious if you return \"Promise for list\" or \"List of promises\" in resolver?\nAs for adding event loop to tests - I wanted to leverage HHVM in Travis CI to test it, but couldn't find decent promise library for HHVM. Any hints how to integrate async stuff with Travis are welcome!. Sorry I am a bit slow today, so just to clarify...\nThe question is who actually creates this array with gaps? Is it produced by your resolver/promise or produced by graphql?\nIn the former case the result is expected. Here is a simple test which produces the same result as you describe:\nphp\n$a = [0 => 'a', 1 => 'b', 100 => 'z'];\necho json_encode($a);\nIf your app returns array with such keys - it should be probably fixed in the user-land (but we can think about forcing arrays with valid keys). But if you return array with ordered integer keys without gaps and graphql re-orders them - this is a bug.\nSo which is the case?. Thanks a lot for the test case! Will check it as soon as I have a chance.. I suspected that it could be caused by ReactPHP all, but you are right - we should probably force proper keys in array when expected return type is List. I'll create separate issue to track this.. @lordthorzonus I think we should add ksort to ReactPromiseAdapter::all anyway. Can you change this PR accordingly (move ksort from Executor to ReactPromiseAdapter)? I'll merge it then.. @mcg-web You are right. ksort will mess keys of associative arrays. I guess what we need in ReactPromiseAdapter::all is something like this:\nphp\nfunction all(array $promisesOrValues)\n{\n    $result = \\React\\Promise\\all($promisesOrValues);\n    return $result->then(function($values) use ($promisesOrValues) {\n        $newResult = [];\n        foreach ($promisesOrValues as $key => $value) {\n            $newResult[$key] = $values[$key];\n        }\n        return $newResult;\n    });\n}\nIs it what you mean?. @lordthorzonus I don't think we should add it as dev dependency. I don't want to create impression that ReactPHP is somwhow required for development when using this lib. It is 100% optional stuff and composer suggest is appropriate for it.\nWhat we could do with reagrds to tests: \n1. Add tests for ReactPHP promise adapter, but exclude them in default phpunit.xml.dist\n2. Add composer require react/event-loop to .travis.yml (similar to how we do it with coveralls) + add ReactPHP tests for Travis builds only.\nIf you do not want to bother with this - just add tests for ReactPHP that you find appropriate - and exclude them in default phpunit.xml.dist. We'll manage Travis stuff when we find time.\nP.S. Glad that you are using this async stuff! %). @lordthorzonus Great work. Thanks!. This is actually invalid (no such issue), so closing.. First released in v0.9.0. Thanks!. Thanks for PR!. This is done for compatibility with graphql-js. \nAnd they add this constraint for purpose. The idea of enums is to provide clear human-readable entries via it's definition. For example:\nenum Gender {\n  MALE\n  FEMALE\n}\nwhich is self-explanatory. But what you are trying to do is to define this Enum as:\nenum Gender {\n  1\n  2\n}\nIt is explicitly prohibited by this constraint. \nEnum definitions can be sometimes confising. So I'll try to explain it a bit...\nIn graphql-php each enumeration entry is presented by name and value (same for graphql-js). The full form for Enum definition is:\nphp\n$genderType = new EnumType([\n    'name'=>'genderEnum',\n    'values' => [\n        ['name' => 'MALE', 'value'=> 1],\n        ['name' => 'FEMALE', 'value'=> 2]\n    ],\n]);\n(short form where name is set via array key is equivalent of this full form).\nBut in graphql spec there is no VALUE part. Enum entry is only represented by it's NAME. So VALUE is implementation detail. It is only used when internal representation of enum entry in your app differes from it's exposed name (actually VALUE can be anything, even Closure).\nYour resolvers are supposed to return VALUE for enum fields. For example: \nphp\n'gender' => [\n    'type' => $genderType,\n    'resolve' => function($value) {\n        return is_male($value) ? 1 : 2;\n    }\n]\nBut graphql-php will transform this VALUE to NAME to include in response. So response will actually contain: \"gender\": \"MALE\" (or \"gender\": \"FEMALE\")\nReverse transformation happens for inputs. Clients send NAME in mutations (or field arguments), e.g:\nquery GetBestEmployee {\n  bestEmployee(gender: MALE)\n}\ngraphql-php will convert it to VALUE before passing to your resolver in $args:\nphp\n'bestEmployee' => [\n    // ...\n    'args' => [\n        'gender' => [\n            'type' => $genderType,\n        ]\n    ],\n    'resolve' => function($value, $args) {\n        // Note: $args['gender'] contains either 1 or 2, but not \"MALE\" or \"FEMALE\"\n    }\n]\nFortunately, enums are way easier when NAME and VALUE are the same. Then you can define it like:\nphp\n$genderType = new EnumType([\n    'name'=>'genderEnum',\n    'values' => [\n        'MALE', 'FEMALE'\n    ],\n]);\nor \nphp\n$genderType = new EnumType([\n    'name'=>'genderEnum',\n    'values' => [\n        'FEMALE',\n        'MALE' => ['deprecationReason' => 'Replaced by robots']\n    ],\n]);\nHope this helps. But if I misunderstood something in your issue - please clarify.. Closing it. But feel free to re-open if I missed something.. Thanks for reporting! \nThere is no standard for GraphQL HTTP endpoint, so hello world just expects GraphQL query in request body (for simplicity), while ChromeiQL and GraphiQL Feen conform to express-graphql style and send JSON in request body: object with query and variables keys.\nWhile technically this is not a bug, we probably should consider conforming to express-graphql even in hello world.. Awesome! Thanks.. Looks like it's the same as #201 . Nice catch, thanks!. Unfortunately not yet. PR is welcome!\nAs for direction...\nCurrent parser is capable of parsing schema definition language. It produces AST document for schema definition. The one step which is missing is to actually traverse this AST and create type definitions along the way.\nSo here is an example of Schema language parsing: SchemaParserTest.php. We tried to keep this project as close as possible to graphql-js so it maps directly to schema-parser-test.js\nNext you can look into buildASTsSchema.js which traverses this AST. Most of the methods and variable names are the same or similar in this lib, so make sure to search through the codebase to avoid unnecesarry work %)\nDifferencies are mainly in dropping prefixes and porting js functions as static methods:\ne.g. use GraphQL\\Type\\Definition\\ObjectType vs import GraphQLObjectType from '../type/definition' or GraphQL\\Utils\\AST::valueFromAST import { valueFromAST } from './valueFromAST';\nAnd feel free to ask any questions along the way.. Looks ok to me, except for tests as coverage has dropped significantly.. Thanks for your work! I will publish 0.9.4 release soon with this feature included.. Thanks for the fix!\nI do agree that assertSame is usually more appropriate, but my IDE shows diff of expected / actual result when assertEquals fails and shows nothing useful  for assertSame (apart from error message). Streamlines writing tests a lot.. I could not reproduce it, so need a bit more info to understand what is going on. Please answer following questions:\n\nWhat URL do you use as endpoint (in ChromeiQL)?\nWhat happens if you open this URL in browser tab directly?\n. This response means that server is working, but there is some problem with ChromeiQL - it doesn't get the result of schema introspection.\n\nPlease open Network tab in Chrome developer tools and look at what happens on ChromeiQL page refresh - does it send initial XHR request to localhost:8000? If yes - what is the response?\nAlso have you tried other extension: GraphQL Feen - do you get the same result?. You attachments are not published on github. I can't get them.. You use the wrong version. Latest \"webonyx/graphql-php\" version is \"0.9.5\".\nAs for \"Failed to fetch\":\n1. Enable php error logs and paste error here (if any)\n2. Check \"Network\" tab in chrome developer tools, refresh ChromeiQL page and post HTTP status code here as well as response body\nThis issue requires some debugging and unfortunately I can't do it for you, because I can't reproduce it.. See error description. It says that you are still trying to install version 1.0.0. Remove composer.lock, edit composer.json manually and change webonyx/graphql version to 0.9.5, then try composer install. . But your error description mentions 1.0.0:\nProblem 1\n    - The requested package webonyx/graphql-php No version set (parsed as\n1.0.0) is satisfiable by webonyx/graphql-php[No version set (parsed as 1.0.0)]\nIs it your actual error? If so, please double-check contents of your composer.json (and composer.lock file) - entry related to webonyx\\graphql-php must reference version 0.9.5. \nOr better start from clean directory if you can't figure out what's going on (I just tried on both PHP5.6 and PHP7.0 and it installed without any problems).\nIf you have other problem - please clarify what is this problem exactly.. Closing. Provide new details to re-open.. Hey thanks!\nI looked into node agent and it seems to modify original schema by looping through all fields and wrapping their resolvers with optics functions. Technically you can do the same with graphql-php schema. \nBut on the other hand iterating over hundreds or thousands of fields is not the best way to do it in PHP. So it might make sense to provide hooks before/after field execution on library level.\nPR for this feature is welcome!\nIf you decide to prepare such PR I suggest you to wrap this call with before and after callbacks and introduce static method on Executor to set these callbacks (like setFieldHooks(callable $beforeResolve, callable $afterResolve)).\nPrefer static at this point because we may refactor executor later and it will be way easier to maintain backwards compatibility for simple static hooks. But if you have other opinion - I am open to discussion.. One more thing to keep in mind for your optics agent is that resolvers may return promises. So promiseAdapter must be also passed to hooks (in addition to other arguments) in order to check for isThenable and act appropriately. . For anyone interested, there is another proposal on how to enable apollo tracing for any existing schema: see https://github.com/webonyx/graphql-php/issues/289#issuecomment-399633709 PRs are welcome!. You can use $info->getFieldSelection() for now. See comments on how to use it.\nBut it will be likely deprecated in favor of #65 one day (no timeline set yet). We deprecate things without breaking usually (by issuing E_USER_DEPRECATED warning), so you will have time to migrate when it happens.\nOr you can implement #65 yourself and submit a PR %). Have you figured out everything you need?. There are two kinds of validations:\n1. Formal type vaidation\nWhen you need to make sure that args provided by user match your type definitions. GraphQL does it for you automatically. So for example you have following mutation:\nphp\n$mutations = new ObjectType([\n  'name' => 'Mutation',\n  'fields' => [\n    'updateRecord' => [\n      'type' => $somePayloadType,\n      'args' => [\n        'alias' => Type::nonNull(Type::string()),\n        'is_visible' => [\n          'type' => Type::nonNull(Type::boolean()),\n          'defaultValue' => false\n        ]\n      ],\n      'resolve' => function($record, $args, $context, ResolveInfo $info) {\n        // here `$args['alias']` is always set and is string\n        // and `$args['is_visible']` is always set and boolean (false by default if omitted in query)\n      }\n    ]\n  ]\n]);\nIn other words you can safely rely on $args being formally valid inside resolve. If user provides invalid args (for example object for alias arg which expects string) - graphql will return error in response and will not call resolve.\n2. Domain or business logic validation\nIt is perfectly fine to do additional business logic validation in resolve method. The only thing you should consider is how to return errors.\nOne option would be to just throw in resolver. Then you will get error entry in response automatically. Other option is to include userErrors field in your mutation Payload type to differentiate formal errors (which are usually client developer errors) from app logic errors.\nBut I have a feeling that I am missing something in your problem, so if it doesn't answer your question - feel free to continue asking %) I am totally fine with it.. All errors are caught because GraphQL spec defines what should appear in result and what shouldn't in different error scenarios. In order to ensure that all implementations do follow the spec we handle this logic automatically.\nAnother reason is that whole query shouldn't fail if some nullable field throws (it's the same idea why php has notices and warnings - errors in nullable fields are not fatal for query to be processed and shouldn't affect user experience).\nBut every exception you throw in resolver must be available via $error->getPrevious(). If you don't get it somewhere - then this is a bug. Can you provide a test case when you can't get your error this way?. Also note that it makes sense to use different approach for business logic / domain error handling: do not throw in resolver but have common interface for all mutation payload types, e.g.:\n```\ninterface MutationResult {\n  ok: Boolean!\n# Contains errors which are safe to show to end-user:\n  userErrors: [String!]\n}\ntype UpdateRecordPayload implements MutationResult {\n  ok: Boolean!\n  userErrors: [String!]\n  myField: String\n  myOtherField: String\n}\ntype Mutation {\n  updateRecord(alias: String!, is_visible: Boolean!): UpdateRecordPayload\n}\n```\nThen your resolver could do something like this:\nphp\n'resolve' => function($record, $args, $context, ResolveInfo $info) {\n  if (!isUnique($args['alias'])) {\n    $errors[] = 'Alias must be unique';\n  }\n  if (somethingElseIsWrong($args['alias']) {\n    $errors[] = 'Something else is wrong';\n  }\n  if (!empty($errors)) {\n    return ['ok' => false, 'userErrors' => $errors];\n  }\n}\nWe do use similar approach internally. \nNote that your userErrors can be of object type vs string to include additional data, e.g. initial argument name that caused an error, code of the error, severity, etc.. What is ErrorsType? Why is it extending Type and implements InputType, OutputType, LeafType? Where did you get this? This is never needed - these are pretty much internal stuff in graphql-php, you shouldn't be touching it this way.\nYour custom error type should be ObjectType or just String (if you only need message for errors).\nAs for resolver, mutation query and response - everything looks correct. And yes - client is supposed to request errors in query explicitly. . On best practices - see this discussion and answers of Lee Byron who is an author of the specification and graphql-js.\nAbout error type.\nYour error should be object type. GraphQL doesn't support arbitrary keys in responses (and your ErrorsType is definitely not a best practice), so what you actually want is something like this:\n```graphql\ntype UserError {\n  message: String!\n  code: Int\n  # Here you store original argument that caused an error (if you need it)\n  inputKey: String\n}\ntype Mutation {\n  updateRecord(alias: String!, is_visible: Boolean): UpdateRecordResult\n}\nThis type can implement some interface common to all mutations\ntype UpdateRecordResult {\n  ok: Boolean!\n  userErrors: [UserError!],\n  # This is not included in response when there are errors\n  # Alternatively you can just add payload as fields of this type directly (but then all of them must be nullable)\n  payload: UpdateRecordPayload\n}\ntype UpdateRecordPayload {\n  field1: MyType!\n  field2: SomeOtherType\n}\n```\nI forgot about one more option you have to return several errors. You can do so by returning array of exceptions from your resolver. GraphQL should convert them all to errors (but I don't remember excactly, so you should try it first)\nAlso this discussion is not related to graphql-php itself. It's about general GraphQL concepts and approaches. I shared my vision, but you may also ask at graphql spec repo where authors of spec can help you with idiomatic best practices or on stackoverflow.. Actually += is mostly useful for associative arrays vs int-indexed arrays. Can you please update the PR with PHPUnit test case which you are trying to fix? As it is not clear from this PR what bug it actually tries to fix?\nThis is a test class for ResolveInfo which you can update: https://github.com/webonyx/graphql-php/blob/master/tests/Type/ResolveInfoTest.php. @decebal, now I see what you mean. The issue occurs when two fragments request the same field with different sub-selection. Current solution would only include selection of first fragment visited, while we actually need to merge them all.\nThanks for noticing and fixing! Please let me know when you are done with PR, I'll merge it.. It is a known problem (with known solutions). I'll walk you through the process of type registration in schema to provide an overview...\nWhen you create schema what happens is graphql-php scans all fields and all nested types from the very root to all leafs.\nThe problem is that while traversing this tree of types GraphQL only sees field Record with type TestInterface. That's the only visible types in your schema.\nUnfortunately this data is not enough to figure out that you have other types as implementations of TestInterface, hence the error you see. It happens with object types which only show up in schema as implementation of some interface and are not referenced anywhere else.\nSo your options:\n1. Add field anywhere in schema of your Test type (e.g. in Query or other visible object type)\n2. Pass such \"invisible\" types in special option types of schema constructor. \nIn your example option 2 would look like this:\nphp\nnew GraphQLSchema([\n    'query' => ...,\n    'types' => [$testType]\n]);\nThis problem is common to all graphql implementations I am aware of, including graphql-js.\nP.S. I'll close this, but feel free to ask further questions if you need. Thanks!. @PowerKiKi Thanks for the PR!\nAs for the standard - I started the work on GraphQL\\Server which will likely eventually replace GraphQL\\GraphQL facade, so yeah we will provide common tools.. @PowerKiKi Not really. At this point we don't have that many bug reports, so feel free to create an issue on Github for any questions / discussions. This way we can also keep the knowledge base in one location and don't split the community.. You are placing resolve in the wrong place. It belongs to field definition, but you placed it in type definition. Given what I see in your code you must move your resolve function to field user of Query type like so:\n```php\n $config = [\n            'name' => 'Query',\n            'fields' => [\n                'site' => [\n                    'type' => new SiteInfoType(),\n                    'description' => 'Returns all detail about the social network'\n                ],\n                'user' => [\n                    'type' => Type::listOf(new UserType()),\n                    'description' => 'Returns all users or by id',\n                'resolve' => function($value, $args, $context, ResolveInfo $info) {\n                  $users = $context->users->findList(0, 50);\n                  $allUsers = array();\n                  $i = 0;\n                  foreach ($users as $user) {\n                    $allUsers[$i]['id'] = $user->id;\n                    $i++;\n                  }\n                  return $allUsers;\n              }\n            ],\n            'hello' => Type::string(),\n        ],\n        'resolveField' => function($val, $args, $context, ResolveInfo $info) {\n            return $info;\n        }\n    ];\n\n``. Everyresolvein your last example is a part of field definition (entry withinfieldsarray). Butresolvein your original example is a part of type definition (it is not insidefieldsarray). Right.resolveFieldis only called if there is no specificresolve` function for given field.. I'll describe our experience. We had similar problem with ZF1 app, but migrating to Doctrine was not an option, since the app was huge and it would mean almost complete rewrite. So we chose conservative approach.\nWe added GraphQL to the stack, using existing models (based on Zend_Db_Table). Building types and enabling queries was fast and easy, but mutations were way harder: we had part of the logic in ZF controllers and other part in our busniless logic layer, so moving this to mutations took some time, but we approached them sequentially when needed by new client app. \nThen we were able to call mutations in ZF controllers where BC was required. In the end we had GraphQL API in place using most of our old backend logic (old app was still in place, waiting when it's obsolete parts would be removed as we build new client app).\nWhen GraphQL API is in place - it is way easier to rework backend separately, because you effectively have an interface between client and server (which is also easy to test by recording-replaying GraphQL queries). So next time we have a chance - we will consider switching to Doctrine/DBAL.\n@mcg-web Do you guys use Doctrine internally? Can you share your experience?. Great works guys. I guess we can close this issue now.. While this feature makes sense I must think about it. The problem is that we'll have to mantain it and always make sure that schema is serializable in future versions. \nAs for implementation:\n1. I don't think Introspection even needs to be changed - it is not a part of schema - it is called during query execution in runtime. If it is not the case - then we should investigate why and probably fix (vs adding serialization to these closures)\n\nI would really like to avoid external library dependencies. One option how we could do this is to add separate classes for object types created by buildSchema (which extend base ObjectType and InterfaceType) and can sleep and wakeup. This way we don't need to serialize closures.\n\nPlease let me know what you think.. @AndreasHeiberg not in current form.\nI agree that we need a way to avoid unnecessary parsing for those using buildSchema. But I do not agree with implementation using serializable closures (and internal comparision of types changing from === to ==).\nI'll add separate task to track this feature request. Will include it in next major version of the lib, but it depends on some other work in the backlog.\nIn the mean-time I am curious about performance difference of caching AST + calling buildSchema on it vs caching whole schema. Have you tried benchmarking it?\nAs for AST as array - that is also something we do consider. Mostly because of possible libgraphqlparser integration. So if that would work for you - this is the PR I am ready to accept. Will open separate issue for this as well.. FYI I just made a quick benchmark which shows that unserializing AST and then calling BuildSchema is only ~10% slower than unserializing schema itself in PHP5.6 and actually a bit faster on PHP7.0+. So this might be a best way to do it for now.\nBenchmark code in case if I missed something:\n```php\n<?php\nnamespace GraphQL\\Benchmarks;\nuse GraphQL\\Language\\Parser;\nuse GraphQL\\Utils\\BuildSchema;\n/*\n * @BeforeMethods({\"setUp\"})\n * @OutputTimeUnit(\"milliseconds\", precision=3)\n /\nclass BuildSchemaBench\n{\n    private $astSerialized;\n    private $schemaSerialized;\npublic function setUp()\n{\n    $ast = Parser::parse(file_get_contents(__DIR__ . '/schema.graphql'));\n    $this->astSerialized = serialize($ast);\n\n    $schema = BuildSchema::buildAST($ast);\n    $this->schemaSerialized = serialize($schema);\n}\n\n/**\n * @Warmup(2)\n * @Revs(10)\n * @Iterations(3)\n */\npublic function benchCachedSchema()\n{\n    $schema = unserialize($this->schemaSerialized);\n\n    // Try this to make sure all types are loaded\n    // $schema->getTypeMap();\n}\n\n/**\n * @Warmup(2)\n * @Revs(10)\n * @Iterations(3)\n */\npublic function benchCachedAst()\n{\n    $ast = unserialize($this->astSerialized);\n    $schema = BuildSchema::buildAST($ast);\n\n    // Try this to make sure all types are loaded\n    // $schema->getTypeMap();\n}\n\n}\n```\nSo I think the best option is to implement #108 (AST as array) instead, which should make numbers even better for cached AST (since AST array could be stored in PHP file and won't require any unserialization).. @jrichard0725 Not yet, but in new version 0.10.0 it is possible. Check out these docs from future branch: https://github.com/webonyx/graphql-php/blob/v0.10/docs/type-system/type-language.md#performance-considerations\nAnd this part on lazy schema:  https://github.com/webonyx/graphql-php/blob/v0.10/docs/type-system/schema.md#lazy-loading-of-types\nWill be released soon (I hope).. Instead of serializing the schema, the recommended way (as of v0.10.0) is to serialize/cache the AST. BuildSchema::build() is now lazy by default, so it should be more efficient than any serialized schema.\nSee related entry in docs.. It should be easy to implement in user-land code. Just call GraphQL::execute() (or GraphQL::executeAndGetResult) in a loop and then combine results (unless I am missing something about this feature).\nWe will likely add some helper tools in future to enable this out of the box, but this should be easy to do even now.. Next version (v0.10.0) will contain Standard Server implementation with batching support. One of the major benefits over sequence of GraphQL::execute() calls is that Deferred resolvers won't be isolated in queries.\nSo for example following batch will require single DB request (if user field is deferred):\njson\n[\n  {\n    \"query\": \"{user(id: 1)} { id }\"\n  },\n  {\n    \"query\": \"{user(id: 2)} { id }\"\n  },\n  {\n    \"query\": \"{user(id: 3)} { id }\"\n  }\n]. Released in v0.10.0. See documentation. \nIt is not battle-tested yet, so please report in new issues if you encounter any problems.. I removed it. But also changed Node::toArray() signature to Node::toArray($recursive = false) to preserve backwards compatibility, so double check if your custom code uses this method.. Instead of serializing the schema, the recommended way (as of v0.10.0) is to serialize/cache the AST. BuildSchema::build() is now lazy by default, so it should be more efficient than any serialized schema.\nSee related entry in docs.. Unfortunately, after looking deeper into this I realized that this would be a really major break + it will make dealing with ASTs way less pleasant from IDE. \nI implemented a different solution to enable compatibility with libgraphqlparser: now it is possible to create AST from array returned by libgraphqlparser. \nTo make such conversion performant I had to replace all arrays of nodes (such as selections, directives, arguments, etc) with NodeList class which lazily converts arrays from libgraphqlparser to Node instances.\nThis way typical integration with libgraphqlparser (e.g. using graphql-parser-php) would looks like this:\n```php\n$parser = new \\GraphQL\\Parser(); // graphql-parser-php\n$astAsArray = $parser->parse('query { name }');\n// Convert AST array to lazily-evaluated DocumentNode:\n$ast = GraphQL\\Language\\AST\\DocumentNode::fromArray($astAsArray);\n$result = GraphQL\\GraphQL::execute($schema, $ast);\n```\nIt is also possible to convert our AST to array format:\nphp\n$astAsArray = $ast->toArray(true);. Released in v0.10.0. See docs on how to convert AST from/to array. \nThis is a lazy operation (array is converted to AST as it is traversed), so should be performant enough.. As of my experience you want two things for DB-layer performance (assuming you use relational database):\n\n\nDo not re-fetch rows which you have already fetched during this query execution. It is actually up to you how to do it. If you use Doctrine - it will handle it for you via IdentityMap. Facebook's dataloder and it's PHP version also does that out of the box. But if you use your own custom data access layer - it is your responsibility to choose and implement runtime caching strategies.\n\n\nBatch multiple requested rows into single query to avoid N+1 problem. Read this entry in docs for details. You have two options here - implement your own buffers or use DataLoader implementation.\n\n\nAs for fine-grained list of columns in your SQL query... If you use per-row caching - it makes little sense (you don't want to cache partial data for the row). \nBut if you don't use per-row cache and your app is relatively simple - then you can use the method which @VaclavSir mentioned - by using $info->getFieldSelection() in your resolver to figure out which sub-fields were requested and query the database for those fields/columns only.\nAlso a separate note about \"query only what you need\": keep in mind that this principle is applied to client-sever communication, not to internal data access layer. \nIt is very important for slow mobile connections to receive only what was requested, but that doesn't mean that your internal data-access layer (which is very fast comparing to client-server communication) has to implement the same granularity level.. While it makes sense for me, but deprecation is not described for input object types in GraphQL specs (or reference implementation). So I guess this question should be first raised in spec repo.\nI'll close it for now, but will track specs / reference implementation updates in this regard.. See https://github.com/webonyx/graphql-php/tree/master/examples/02-shorthand (via #142) and docs (as of v0.10.0). @mcg-web Can you please review this PR as query complexity is something you contributed in past?. Thanks for this PR!. Fixed in https://github.com/webonyx/graphql-php/commit/f668300cd87c471a026fd0026c9b9e65e7765554. Thanks for the suggested fix. But I think the better solution would be to just prefix resolvers method names with resolve (so that full method name became \"resolve\" . ucfirst($fieldName)). This is example after all, so I'd like to keep it clear for end-users what's going on.\nIf you agree to change the fix - I'd greatly appreciate your help!. I fixed it in https://github.com/webonyx/graphql-php/commit/f668300cd87c471a026fd0026c9b9e65e7765554. I do understand your intent, but I'd like to do some benchmarks first. Default resolver may be called thousands of times per query and replacing operation (instanceof) with function call (is_callable) might be expensive. \nAlso even with current implementation you can set your own default resolver if you need such behavior. I am on vacation now, but will take a closer look at this once I am back.. FIY, I did some benchmarks, and the results are tolerable. Can you change target branch of this PR from master to v0.10 - then I'll merge it.. That's funny (actually not) %) Anyway, I think I'll revert this PR. \nOne of the new features in v0.10.0 is ability to pass custom default resolver to Executor::execute() (different from static one). So if laravel-php needs this, they can just pass their own default resolver.\n@johanobergman Thanks for sharing this!. Thanks!. If you need out-of-the-box solution, check out DataLoader, otherwise you will have to write your own batch loading functions/classes. \nExample is described in http://webonyx.github.io/graphql-php/data-fetching/#solving-n1-problem Please let me know what is not clear for you in these docs?. Oh, you are right. This is a bug.. Fixed in https://github.com/webonyx/graphql-php/commit/6fb62b25b35f7252e8b2c3baad7540cfa73ec8a5\nWill be included in next 0.9.10 release.. None that I am aware of. As of version 0.10.0 there is a PSR-7 compatible standard server. It should be possible to use it as is with Zend Expressive.. @PowerKiKi You don't need following lines:\nphp\n$parsedBody = json_decode($request->getBody()->getContents(), true);\n$request = $request->withParsedBody($parsedBody);\nThey seem redundant as the server should already do it (if Content-Type header in the request is application/json). \nFollowing should work as is (if something doesn't work, then it is probably a bug):\nphp\npublic function process(ServerRequestInterface $request, DelegateInterface $delegate)\n{\n    $schema = new Schema();\n    $server = new StandardServer([\n        'schema' => $schema,\n        'queryBatching' => true,\n        'debug' => true,\n        'fieldResolver' => new DefaultFieldResolver()\n    ]);\n    $response = $server->executePsrRequest($request);\n    return new JsonResponse($response);\n}\nAlso, there is complementary project https://github.com/phps-cans/psr7-middleware-graphql. If parsedBody is empty, then it is a bug. Will appreciate if you open an issue for it. But are you sure Content-Type header is set properly to application/json in your case?. Can you provide a reproducible example for this error?. Sorry for long delay on this. \nThis test doesn't seem right. Validator works against AST values which are always strings (provided by parser). So if you want to test that object value fails on argument of string type it must be written differently. Like this:\nphp\n    /**\n     * @it Object into String\n     */\n    public function testObjectIntoString()\n    {\n        $this->expectFailsRule(new ArgumentsOfCorrectType(), '\n        {\n          complicatedArgs {\n            stringArgField(stringArg: {prop: \"val\"})\n          }\n        }\n        ', [\n            $this->badValue('stringArg', 'String', '{prop: \"val\"}', 4, 39)\n        ]);\n    }\nvs:\nphp\n   /**\n     * @it Object into String\n     */\n    public function testObjectIntoString()\n    {\n        $this->expectFailsRule(new ArgumentsOfCorrectType(), '\n        {\n          complicatedArgs {\n            stringArgField(stringArg: 1)\n          }\n        }\n        ', [\n            $this->badValue('stringArg', 'Object', ['prop' => 'val'], 4, 39)\n        ]);\n    }\nBut then the test passes. So it is still not clear what your actual problem is.. Actually I've figured out what you mean (but unfortunately test case didn't help much). Fixed in https://github.com/webonyx/graphql-php/commit/8fe26a1a21e3a96e470b5712bc9d392239e8308f. Agree. In general invariant violation should be used for system errors only. This exception should not be used for errors exposed to clients. \nCan you prepare PR for suggested changes? Let me know if you need anything from me to make it happen.. I started fixing this, but then I realized that something is wrong. String values shouldn't be allowed as input for floats at all. There are following checks in float type parsing:\nphp\n    public function parseLiteral($ast)\n    {\n        if ($ast instanceof FloatValueNode || $ast instanceof IntValueNode) {\n            return (float)$ast->value;\n        }\n        return null;\n    }\nSo StringValueNode should never be parsed as float (there are also tests for this). Can you double check if ArgumentsOfCorrectType is actually executed in your case?. Or maybe you are actually passing these arguments as variables vs literals?. Ok, I think I know what's going on. It is caused by QueryComplexity rule (when it is enabled). This rule throws when it operates on invalid query, hence your error.\nI added separate check to skip query complexity analysis when there are other validation rules. Which should likely fix your issue, but may be not enough in the long run.\n@mcg-web please review the commit with my fix: https://github.com/webonyx/graphql-php/commit/bc4b990946cbaf1fca34b3dff0488b46d37af242. Also does it make sense for you to add try {} catch() block in QueryComplexity rule?. @mcg-web Well, in theory it could be a security issue in some edge case. But if you never execute when there are validation errors, then it should be OK.\nAs for try{} catch() - this is an alternative solution, because this rule was throwing vs returning array of errors. With try {} catch() it could simply add exception message to list of errors vs throwing.\nJust a thought. But if you don't mind current fix - it should be enough I guess.. Fix is included in 0.9.10. I'd really like to accept this PR. Minor breaks are ok for next major version, but this PR breaks every PHP version older than 7.0+. And we must still support previous PHP versions. Can you try running tests on PHP5.6 and fix failures?. Thanks! I'll merge it when I start working on next major version. @danez Can you change target branch of this PR from master to v10.0 ?. Awesome! I was aware that current solution is suboptimal and had plans to rewrite it as soon as someone complains about parsing performance %) Really happy that you nailed it, thanks! \nBut I have to do some internal testing with this new version before merging. . Closing this. Other solution is implemeted in v0.10 branch via https://github.com/webonyx/graphql-php/commit/a0657b784779d770b2aeef80bd98ed36c19dbc70. \nI encourage everybody interested to test their queries against it to catch possible bugs earlier %). Such type is not included for a reason.\nThere were many discussions about it in graphql-js repo, and the general response is that it is not best practice to use such type. I do agree that some projects may need this feature, but including it in main repo may send the wrong message to library users (as if GraphQL encourages it, which is not true). GraphQL encourages strict schema.\nBut you still can add such custom type to your own projects.. That's great. Thanks!. Just published in 0.9.11. Thanks!. Every resolver has following signature: ($value, $arguments, $contextValue, ResolveInfo $info)\nNote that $contextValue is your own value which is passed in 4th argument of GraphQL::execute() call:\nphp\nGraphQL::execute($schema, $query, $rootValue, $contextValue, $variableValues);\nSo you can easily pass your own context object with any error collecting logic. Also ResolveInfo has all the information you may need to enhance error reporting (e.g. $info->path property).\n. Yes, you can skip validation. GraphQL::execute is just a conveniece facade over parsing, validation and execution steps. You can unwrap it and create your own facade with custom validation logic.\n```php\ntry {\n    if ($requestString instanceof DocumentNode) {\n        $documentNode = $requestString;\n    } else {\n        $source = new Source($requestString ?: '', 'GraphQL request');\n        $documentNode = Parser::parse($source);\n    }\n$queryComplexity = DocumentValidator::getRule('QueryComplexity');\n$queryComplexity->setRawVariableValues($variableValues);\n\n// You should change this line as you need:\n$validationErrors = DocumentValidator::validate($schema, $documentNode);\n\nif (!empty($validationErrors)) {\n    return new ExecutionResult(null, $validationErrors);\n} else {\n    return Executor::execute($schema, $documentNode, $rootValue, $contextValue, $variableValues, $operationName);\n}\n\n} catch (Error $e) {\n    return new ExecutionResult(null, [$e]);\n} \n```\nSee the DocumentValidator::validate() call. It has 3rd argument which accepts an array of validation rules to be executed (or you can just skip validate step entirely for your whitelisted queries).\nP.S. We will likely improve facade in future versions, so I'll keep this issue open until then.. New signature of GraphQL::execute (and GraphQL::executeAndReturnResult):\nphp\n    function execute(\n        Schema $schema,\n        $source,\n        $rootValue = null,\n        $contextValue = null,\n        $variableValues = null,\n        $operationName = null,\n        callable $fieldResolver = null,\n        array $validationRules = null\n    )\nSetting $validationRules to empty array will let you skip the validation. Will be published in v0.10.0.. @tsingsun query is required part. I am curious which version you were using before (which allowed query to be null)? That previous behavior was actually buggish, not the current one.\nQuote from GraphQL spec: \nThe query type must always be provided, and is an Object base type.\nIf you really want to have empty query, just pass an empty (but named) object type:\nphp\n$result = new Schema([\n  'query' => new ObjectType(['name' => 'Query', 'fields' => []])\n  'mutation' => $mutation,\n  'types' => $types\n]);\nBut note, that if you are not using queries, you are probably using the wrong tool, as the strentgh of GraphQL is it's type system/runtime not mutations. If you only use mutations, you should probably look at tools like gRPC instead.\nAlso check out similar discussion in graphql-js thread: https://github.com/graphql/graphql-js/issues/448. Benchmarked proof-of-concept version of new lexer, here are results (ignore absolute numbers, as tests were executed on VM with limited resources, only relative numbers matter here):\n1. Query Length = 2500\ncode | mem_peak | mean     | diff\n-----|----------|----------|------ \nNew  | 875,736b | 12.391ms | (winner)\nOld  | 859,056b | 29.050ms | +134.44%\n2. Query Length = 5000\ncode | mem_peak | mean     | diff\n-----|----------|----------|------ \nNew  | 935,616b | 23.931ms | (winner)\nOld  | 917,408b | 87.143ms | +264.14%\n3. Query Length = 10000\ncode | mem_peak   | mean      | diff\n-----|------------|-----------|------ \nNew  | 1,058,416b | 46.790ms  | (winner)\nOld  | 1,043,528b | 291.631ms | +523.27%\n4. Query Length = 100000\ncode | mem_peak   | mean         | diff\n-----|------------|--------------|------ \nNew  | 3,596,272b | 466.447ms    | (winner)\nOld  | 3,603,536b | 24,299.349ms | +5,109.46%\nThe difference of O(N) and O(N^2) is obvious, but real-world apps will unlikely notice the difference, since real queries are usually not that big.\nThese results are for PHP5.6, PHP7+ gives even bigger performance difference.. Implemented in https://github.com/webonyx/graphql-php/commit/a0657b784779d770b2aeef80bd98ed36c19dbc70. Will be released in 0.10.0. Thanks, will look into this. @orls Thanks for your research. You are correct about the cause of this issue. \nBut the general rule for both: this lib and reference graphql-js implementation is that type must be represented by single instance. That's why we recommend using type registry. \nAllowing multiple instances of the same class may cause other sort of issues if type class is extended and stateful.\nIn short, type loader of this example is incorrect. It has to return the same instance from registry. So it should be expressed like this instead:\nphp\n    $schemaConfig['typeResolution'] = new LazyResolution($schemaDescriptor, function ($typeName) {\n        $method = lcfirst($typeName);\n        if (method_exists(Types::class, $method)) {\n            return Types::$method();\n        }\n        return null;\n    }\nBut obviously the library does too little to instruct user about this. In our case it must throw when it sees different instances for the same type name with clear message of what is going on. \nThat is the solution I plan to implement to fix this, but please let me know if you guys have other thoughts.. @AndreasHeiberg Thanks a lot for reproducible test case!. Added check with meaningful error message to make sure loader always returns the same instance (in v0.10.0).. Done in v0.10.0. Short answer is: you can't. You must create separate UserInputType with some fields from UserType which make sense in write context. \nBut you can re-use scalar and enum fields from UserType, for example:\n```php\n$userType = Types::UserType();\n$userInputType = new InputObjectType([\n  'name' => 'UserInputType',\n  'fields' => [\n    $userType->getField('id'),\n    $userType->getField('email'),\n    // etc...\n  ]\n]);\n```\n. No. Input and output types are separate by GraphQL design and spec. \nAnd in practice, write and read models are often different. You may have lots of fields in your UserType which shouldn't be allowed in write context (say list of user friends which may be nested indefinitely).. You are right, this is a bug. In the meantime you can use 0 and 1 for values instead.. Closed via https://github.com/webonyx/graphql-php/commit/bc6a7a3d1dd7b3d3f6b242fd94fc628c28c9c1cb (will publish in v0.9.12 soon). Thanks a lot!. @janschoenherr This question often arises in graphql-js repo as well. The general answer is that all of your exceptions are available in ExecutionResult after execution, so you can filter them before displaying to a client, log, re-throw, etc.\nBut can you elaborate a bit more on what you are trying to achieve with regards to error handling that isn't possible now?. Also, the reason why custom errors are caught is that error in a single nullable field is not fatal for the whole query. Since the field is marked as nullable we can safely return null for this specific field vs killing the whole query.. The problem is that if you catch only known exceptions you will make the whole query fail in unexpected situations even if only one minor nullable field throws.\nIf you can provide a formally valid result to end-user - why should you kill the whole query in such case?\nSo the actual problem is that you really don't want to deliver error messages of \"unsafe\" exceptions to clients (as it happens today). \nYou can do this already with custom error filtering and formatting. But default error formatting should be also safe and don't expose sensitive error messages. \nIn version 0.10.0 default error formatter will display \"Internal error\" message for resolver exceptions unless exception implements GraphQL\\Error\\ClientAware interface (it is a breaking change, but documented in UPGRADE.md). It is similar to this project.\nI also consider introducing GraphQL\\Error\\CriticalError interface so that when exception implementing such interface is thrown anywhere during execution - it is re-thrown by the executor and whole execution process is stopped.\nYou should be able to catch such exceptions in outer try{} catch() statement. Please let me know if that would solve your issues?. > However to me it seems like the whole query should indeed fail in unexpected situations - even for a minor nullable field. The data might be incomplete and not usable anyway.\nThat is wrong. GraphQL schema is a contract between a client and a server. And if server schema says, that field can be null, it means that client must take nullability into account anyway. \nIf the data is incomplete without the field, this field must be explicitly defined as notNull.. And you can actually do what you need even now. Maybe it requires some efforts to filter and format exceptions, but at least you can do it. \nSay throwing 401 is possible by scanning ExecutionResult and re-throwing HTTPException if found after execution.\nBut if the default is not to catch exceptions and to throw even on minor errors in nullable fields - then other projects will suffer without any options to solve their problems (like our project for example, which can tolerate partial data, but not 500 errors on every minor field error). \nAnd we won't have any options because an exception that is not caught will break Execution process without any way to resume it. So you have options now, but with your proposal, we will have none.\nThis choice to error handling is actually made in graphql-js, so I guess Facebook engineers faced with the same dilemma. You might be also interested in reading related discussions in graphql-js repository for insights. Like: https://github.com/graphql/graphql-js/issues/225, https://github.com/graphql/graphql-js/issues/773. Added new docs on error handling which should make the life a bit easier.. You are missing at least some more details to reproduce this %)\nAt least:\n1. What example you were using?\n2. What was the GraphQL query you were trying to run\n. Quick search over source files doesn't find any GraphQL\\Blog\\Data namespace.  Only GraphQL\\Examples\\Blog\\Data. \nSo I am curious which code is producing this error. Is it your custom code or code of one of the examples?. Thanks!. In the v0.10.0 version, we do have Schema validation (based on assertions). GraphQL\\Type\\Definition\\Config is deprecated, so following should be used instead:\nphp\n$schema = new Schema([/* my opts */]);\n$schema->assertValid(); // this will throw GraphQL\\Error\\InvariantViolation on errors\nMethod assertValid should not be used in production environment (because it is expensive) but can be useful during build step or in CLI commands to make sure Schema is defined correctly.. Done in v0.10.0. This error is not related to recursive definitions. You are creating a new instance of a type in every definition and most likely you have multiple instances of GroupType or UserType in your schema.\nEach type must be represented by single instance within one schema. So you need some sort of registry for your types. Make sure to read the section of docs about type registry . Makes sense, thanks for your advice.. Done in v0.10.0. I am curious, have you tried the same with just GraphQL\\Deferred (without DataLoader)? \nLooks like DataLoader project wraps original adapter, so it's hard to say without digging deeper if this is a bug in this library or in DataLoader.\n@mcg-web any thoughts?. I forked your repo and replaced DataLoaders with regular GraphQL\\Deferred calls. It works as expected.\nI guess the bug is somewhere on DataLoader side.. @mcg-web If I add DataLoader::await() to queue progression, it works, e.g.:\n```php\n    /\n     * Synchronously wait when promise completes\n     \n     * @param Promise $promise\n     * @return mixed\n     /\n    public function wait(Promise $promise)\n    {\n        $dfdQueue = Deferred::getQueue();\n        $promiseQueue = SyncPromise::getQueue();\n    while (\n        $promise->adoptedPromise->state === SyncPromise::PENDING &&\n        !($dfdQueue->isEmpty() && $promiseQueue->isEmpty())\n    ) {\n        Deferred::runQueue();\n        SyncPromise::runQueue();\n        DataLoader::await();\n    }\n\n    /** @var SyncPromise $syncPromise */\n    $syncPromise = $promise->adoptedPromise;\n\n    if ($syncPromise->state === SyncPromise::FULFILLED) {\n        return $syncPromise->result;\n    } else if ($syncPromise->state === SyncPromise::REJECTED) {\n        throw $syncPromise->result;\n    }\n\n    throw new InvariantViolation(\"Could not resolve promise\");\n}\n\n``\nSo the whole queue must be progressed together. I guess you guys will have to write your ownwait` implementation to make it behave as expected.\nObviously, I am not 100% sure that this is enough to fix it (as I am not aware of DataLoader::await implementation details). \nBut let me know if I can make it easier for you somehow (e.g. by changing an interface of SyncPromiseAdapter or maybe changing how Executor calls wait).. Works for me, pragmatically %) Can anyone prepare PR for this? I'll merge it.. Thanks! Merged and released 0.9.14. Closing this. Feel free to re-open if it is still broken.. Use printer:\nphp\nGraphQL\\Language\\Printer::doPrint($myAst);\n. Which part of AST?\nResolver signature is function ($value, $args, $context, ResolveInfo $info).\nResolveInfo has $info->fieldNodes (AST of the resolved field), $info->operation (AST of the operation definition) and $info->fragments (list of operation fragment ASTs). Thanks for reporting! Somehow screwed it up during rebasing together with tests. Fixed in https://github.com/webonyx/graphql-php/commit/d95fb461eefe23f357fa6471f5b30e00a04ac974 (will publish v0.10.1 as soon as travis build completes). The server is a new component, not battle-tested yet (although it's main logic is covered by tests), so please report any errors encountered :) \nI will integrate it to an existing project rather soon, so hopefully, it will evolve fast.. It's easy to check by github tag: https://github.com/webonyx/graphql-php/blob/v0.10.1/src/Server/StandardServer.php#L76\nAlso, I updated to 0.10.1 myself and it worked fine. I suspect something is wrong with your composer setup. Maybe try a fresh install?. Oh, sorry. Forgot to delete this dev branch. Deleted now.. @lordthorzonus as far as I remember you were experimenting with ReactPHP version. Any hints how to use it?. This is not specified yet. \nSee https://github.com/facebook/graphql/issues/197 for details. I'll close this issue for now, but will get back to it as soon as this feature gets reflected in the specification.. Yeah, it makes sense. Fixed in master, will release 0.10.2 with a fix in couple minutes. This structure is not a list, so you can't use listOf here. \nRight now there is an ongoing discussion about adding Map type to the specification, but in general, GraphQL is designed as a strictly typed system. Using it in such a way may be a sign that you chose a wrong tool for your tasks in the first place or that you are trying to use it in a way that is against it's design. \nAs I see you actually have two options: \n\nSerialize such structure to regular String yourself (using json). \nIntroduce intermediate type to represent list item:\n\ngraphql\ntype OperativeControlItem {\n  key: String!\n  value: OperativeControlValue\n}\ntype OperativeControl {\n  que: [OperativeControlItem]!\n}\nThen your response will look like this:\n{\n  \"data\": {\n    \"operative_control\": {\n      \"que\": [\n        {\n          \"key\": \"1\",\n          \"value\": {\n              \"R\": \"4\",\n               ...\n           }\n        },\n        ...\n      ]\n    }\n  }\n}\nIn such case, client will have to reduce this structure to actual Map.. Can you shed some lights on how do you expect it to work? Say your object (returned by findOneById) has 10 fields, but a user only requested two fields in his query (not even saying about deeper nesting).\nHow do you expect JsonSerializable to help in this situation?\nAlso, make sure you understand how resolving works and what a default resolver is (Note: it supports array, simple objects with public props and ArrayAccess interface). \nIf default resolver doesn't work for you, you can override it via fieldResolver argument of executeQuery.. I am not sure that we are on the same page, so feel free to ask more question when you get them %). 1. Download source files\n2. Set up PSR4-compatible autoloader (example) \n3. Set \"GraphQL\\\" namespace to point to \"src/\" folder of library source files\n4. Profit!\nIn general, it's a standard PHP library, so nothing special.. This error means that you pass empty query to execution. So what does var_dump shows for the $query variable before execution?\nI suspect that you have invalid request (either GET vs POST or unexpected request body structure). You may try StandardServer instead, which will parse the request for you and report request-related errors.. As you can see, there is nothing in $raw_input. You simply don't pass a query in your request body. Debug it starting from the browser and make sure that:\n\nNetwork request is a POST request\nPOST body contains valid JSON object with query and variables keys\n\nBut this is a basics of PHP debugging, so please respect my time as well %) I'll gladly help if you have issues with the library itself.. The tool is sending a regular network request. Open developer tools in your browser and check what exactly it sends to the server (headers, body).\nAlso now the error is different. It looks like you got your response, but it contains invalid JSON. Did you remove var_dump output? So in addition to request, also make sure that response contains valid a JSON.. Sweet! I'll look into your work on the weekend and will likely add to complementary tools section (if you don't mind).. I added a mention about your library in docs (marked as experimented as README says that it is under development). Thanks!. Have you seen this?\nhttp://webonyx.github.io/graphql-php/type-system/type-language/#defining-resolvers. I guess the documentation is not clear enough, but it mentions resolveField option. So in short, you should do something like this:\n```php\n<?php\nuse GraphQL\\Utils\\BuildSchema;\n$typeConfigDecorator = function($typeConfig, $typeDefinitionNode) {\n    $name = $typeConfig['name'];\n    // ... add missing options to $typeConfig based on type $name\n    switch ($name) {\n        case 'Parent':\n            $typeConfig['resolveField'] = function($value, $args, $context, $info) {\n                return $value->{$info->fieldName};\n            };\n            break;\n    }\n    return $typeConfig;\n};\n$contents = file_get_contents('schema.graphql');\n$schema = BuildSchema::build($contents, $typeConfigDecorator);\n```\nOr alternatively, define your own default resolver.. Make sure you use v0.10+ (this function did not exist in v0.9+). Yeah, makes sense. Thanks!. You shouldn't copy examples folder to root. Just run them from their location.\nBut if you copied them to root, you must also:\n\n\nAdjust this line and make sure that it actually points to composer autoloader.\n\n\nAdjust example namespace and make sure it points to the correct folder. The first version seems correct (examples/01-blog/Blog/), but I can't help debug it remotely. This issue is related to composer project setup and doesn't relate to the library itself.\n\n\nTo try these examples you can always deploy them locally:\ngit clone https://github.com/webonyx/graphql-php.git .\ncd graphql-php/examples/01-blog\nphp -S localhost:8080 ./graphql.php\n. I suspect it's because your default field resolver ($typeRepository->decoratorFieldResolver) doesn't resolve arrays, and as a result is incapable to resolve introspection query.\nWe should probably force resolver for introspection. In the meantime, you can adjust your resolver to work with regular arrays.. This is very project-specific and depends on your database abstraction layer. Here for example, how you can use it with doctrine ORM: for PHP7+ or for PHP5.5+.\n. Sorry, I don't have time for this. You should raise an issue in this repo.. It is an intended behavior for args with description. A spec-compliant parser should be capable to parse this definition. Have you tried to parse it with our parser? \nIf parser can't parse it then there is likely a bug in the parser not in the printer.. That's weird. I am pretty sure they use a standard parser from the graphql-js package. I just tested it and graphql-js parsed this schema just fine. Also, their printer produced the same output as in our library (with double \"\\n\" between args).. Actually assertValid loads all types it can extract from the schema (by calling getTypeMap()) internally. \nThis exception will also happen without lazy-loading because you can't infer all existing types from this schema.\nFor example, if you start scanning from the Query type, you can only find Node and String. With such schema, you must register all remaining types in types option of the schema.\nOne way to combine types option with lazy-loading is to pass types as a Closure. It is only called when loading the whole schema (e.g. by assertValid) and won't be called for regular queries.. @mcg-web Yeah, we use it in BuildSchema to create schema from type language. So take a look at this piece of code for reference.. Nice approach!\nI think you should consider porting findBreakingChanges (as you mentioned the task is similar). One thing we can consider is to add information about type and field to breaking change result. \nThen you could take these breaking changes and additionally check them against your deployed queries using Visitor. \nIt is much easier to maintain stuff that already exists in the reference implementation. But that's just my thoughts on this subject. Maybe there are other ideas?. @roippi Any follow-up here or should I close?. I guess we can close this one as well, but let me know if you have anything else in mind regarding this issue.. Thanks for reporting. Can you provide an example query which failed for your case? \nI see your PR, but I must review it carefully before merging. And having more context/examples would be very useful.. Looks like boolean coercion is broken because it mirrors graphql-js. And here is a related bug in reference js implementation.. Thanks a lot for your work! I merged your PR and will release it in 0.11.0 version. Unfortunately, I can't release in 0.10.x series because it may potentially break existing apps (even if it is a bugfix).. FYI, released v0.11.0. GraphQL schema is just a set of PHP objects. You can create them in any way you want (explicitly via PHP classes, using type language and BuildSchema or write your own custom builder).\nThe way how you do it is out of the scope of this library. \nI would personally store type definitions as text files written in type language. Then I would collect them from all microservices and combine to single schema file + build using buildSchema() at separate build step.\nBut there are definitely other ways to do it as well.. I don't see mergeSchemas in reference graphql-js implementation, so it's unlikely that we'll include it in this repo. Maintenance costs of such features may be quite high. . Yeah, Apollo has many nice tools, but we won't be able to port and maintain all of them. So it should stay separate from this repo, same as apollo tools repo is separate from graphql-js.. Not really. This is useful for clients and less useful for servers, so we skipped it. But such utility does exist in the reference implementation (BuildClientSchema), so PR is welcome.. I guess you've figured this out already.. I am curious what is your use case? I.e. do you reference such types in schema definition file even if they are not there?. Is there any reason why you can't use typeConfigDecorator (2nd argument to BuildSchema::build) to pass serialize, parseValue and parseLiteral options? E.g. \n```graphql\nin .graphql file:\nscalar Email\ninput MyInput {\n  email: Email\n}\n```\nphp\n// in php:\n$schema = BuildSchema::build($schemaStr, function($typeConfig, $typeDefinitionNode) {\n    if ($typeConfig['name'] === 'Email') {\n        $typeConfig = array_merge($typeConfig, [\n            'serialize' => function($value) {\n                // ...\n            },\n            'parseValue' => function($value) {\n                // ...\n            },\n            'parseLiteral' => function($ast) {\n                // ...\n            }\n        ]);\n    }\n    return $typeConfig;\n});\nObviously, it is better to automate such mappings by name instead of hard-coding.. Closing due to inactivity, feel free to re-open if it is still relevant. Yeah, the reason is that we don't scan type fields when using lazy type loading. So internal types were added explicitly on schema creation. \nI just implemented a workaround where you can override internal types using types option of the schema. It should be available in v0.11.1 (just published). \nPlease try it when you have a chance.. Sorry, it's a mistake in docs. You should call $document->toArray(true). Simple toArray() does just a shallow conversion of AST to an array, toArray(true) will convert recursively.. Fixed docs. Thanks!. Not directly. Usually, they move uploads to separate endpoint with progress reporting, etc.\nBut you should be able to integrate it with GraphQL mutations as well, using existing PHP tools like $_FILES in your mutation resolver. \nIf someone has experience with file uploads + GraphQL, please share.. I am curious what problems do you guys have with uploads (apart from lack of \"multipart/form-data\" support in the StandardServer)?\n@PowerKiKi since PHP supports file uploads natively, we could do it too, but would you be ready to maintain this type / code in the future? %) If yes, I'll accept your PR. This is awesome! I've added a mention to complementary tools documentation.. Closed via https://github.com/webonyx/graphql-php/pull/300/commits/750ce383eccd2b4633b998b531b7c4a7c86a5d28. So it fails not when you create a schema, but when you issue a query against it, right?. I just tried, but it worked for me. Look at the test case below and help me reproduce your situation:\n```php\n    public function testRecursiveTypes()\n    {\n        $body = '\ninterface Thing {\n  id: ID!\n}\ntype Query {\n  userList: [User]\n}\ntype User implements Thing {\n  id: ID!\n  self: User\n}\n';\n        $doc = Parser::parse($body);\n    $schema = BuildSchema::buildAST($doc);\n    $this->assertInstanceOf(Schema::class, $schema);\n}\n\n```\nI also tried executing a query against this schema and all worked fine. What should I add to see the bug?  \nAlso please make sure that it's not your typeConfigDecorator which causes the error (i.e. maybe it adds fields as array vs Closure). @bryan-havenly I think it's because you call $typeConfig['fields']() inside typeConfigDecorator itself.\nInstead you should redefine $typeConfig['fields'] with your own closure and call previous one inside it. I.e.:\nphp\n$typeConfigDecorator = function ($typeConfig) {\n    if ($typeConfig['name'] === 'MyObjType') {\n        $fieldsFn = $typeConfig['fields'];\n        // Note: you shouldn't call $fieldsFn here, instead redefine 'fields' \n        // and call from there:\n        $typeConfig['fields'] = function () use ($fieldsFn) {\n            $fields = $fieldsFn();\n            // do whatever you need with $fields here\n            return $fields;\n        };\n    }\n    return $typeConfig;\n}. That would be nice, but it's unlikely we'll port it soon (too little time now). So PRs are welcome!. It has been ported into https://github.com/webonyx/graphql-php/blob/master/src/Utils/SchemaExtender.php. @Torsten85 Can you please clarify as you are the one ported this utility?. Fixed via https://github.com/webonyx/graphql-php/commit/1487741f37d8e6b183c678a7a041b2be1f6c7fd2. You can try using type language. \nBut if you want to define schema in json, you will have to create your own builder which will convert your json to type definitions. There is no ready tool for this in this package.. Also look at this repo: https://github.com/overblog/GraphQLPhpGenerator maybe it will be useful for you (they use it internally in Symfony GraphQLBundle). I don't think that replacing standard types with custom types is a good idea because their parsing behavior is defined in spec and clients rely on it (except maybe ID type).\nOn the other hand, I do agree that serializing process is a bit different and could be customizable to some extent. Two options I see:\n\nIntroduce strict/weak mode for serialization\nAllow defining optional custom serialization function\n\nI'd like to keep this issue open for a while for discussion (maybe others will post their thoughts as well). Maybe I'll reconsider this and just allow defining own standard types.\nIn the meantime, the only workaround for you is to use Reflection to override GraphQL\\Definition\\Type::$internalTypes.. Sorry, missed your last comment somehow. But I am not sure I am following it. $value ? true : false is a current behavior. But then what's your problem with it (again, I feel that I am missing something)?. It's the same:\n```php\n$foo = 'foo';\n$bar = !!$foo;\nvar_dump($bar);\n// outputs: bool(true)\n```. Thanks for noticing! But for some reason, this PR includes 3 commits (with some old ones) so I am not sure if it will process the merge correctly. So I just fixed it in master myself. Thanks again!. Just curious, do you plan to add extendsSchema functionality in this PR or plan to open another one? I would recommend putting all changes into single PR so that I could review the whole thing before merging. Thanks!. It's hard to say without test case. But https://github.com/webonyx/graphql-php/blob/master/src/Error/Error.php#L164 is executed only if error does not implement ClientAware interface.\nIf you could build a simple reproducible test case - I could take a look. But before you do, please make sure that you don't catch and re-throw these exceptions somewhere in your code.. I don't think I understand the question. Can you provide some example of what you are trying to achieve?. GraphQL is designed with flat mutations at the root. There is some discussion in reference repo and specs about something similar, but nothing like this is supported yet. You may check these repositories for similar questions, maybe you'll find something relevant.\nBut I may be still missing something from the textual description. Can you post GraphQL mutation example of what you are trying to achieve? E.g. \ngraphql\nmutation {\n  field1 {\n    id # I want this to be passed to field2 args\n  }\n  field2(id: $id) {\n    id\n  }\n}. Well, technically you can do something similar by utilizing context (e.g. setting some value in the top resolver and then reading from context in the nested resolver). \nBut this is against GraphQL design (again, right now specs declare mutations as flat list, no nesting) - this is reflected in the fact that root-level fields of mutation type are resolved sequentially, but all other fields can be resolved by the server in parallel.\nSee also https://github.com/facebook/graphql/issues/252 and https://github.com/graphql/graphql-js/issues/672. So I guess we can close it until some solution emerges in the spec (until then anyone interested can use workarounds listed above).. Can you provide a test case to reproduce this?\nOr at least your type definition, and data which causes this?. You must understand that ID type expects a string, not custom objects.\nSo you have two options:\n\nFor each id field - define a resolver which will return a string representation of the ID, e.g.:\n```php\n$idField = [\n    'type' => Type::id(),\n    'resolve' => function ($value) {\n        return (string) $value->getId();\n    }\n];\n\n$myType = new ObjectType([\n    'fields' => [\n        'id' => $idField,\n    ]\n]);\n```\n\nCreate your own custom scalar ID type and pass it in types option of the Schema instance (note that you must use v0.11.1+ for this to work).. Closing, but feel free to re-open if it's not solved for you. Check out this entry in docs and let me know if it works for you.. Thanks for the PR! While it seems logical, I am not sure if it should be included in this lib. The reason is that we actually embrace pure resolvers. And this PR may create an impression that the lib advocates for impure resolvers.\n\nSomeday I plan to implement memoization for the most common cases, which will be impossible in the general case with impure resolvers (or may produce unexpected results).\nOf course, users can write impure resolvers even now (with context or statics), but this situation is very different from the situation when the lib embraces such behavior.\nBut if other library users will find it useful I can change my mind.. Note that even if we choose to merge this, the extensions section defined in specs is expected to be a Map, not a List.. After some thinking I agree that we need a way to help setting extensions from resolvers, but this is such a sugar feature that I don't like the idea of modifying execution context or ResolveInfo (the name implies that it is a readonly structure).\nI suggest a different approach by adding GraphQL\\ExtensionsContainer interface (suggest a better name) which anyone can implement in the user-land context class (we can also provide a trait with standard implementation as it is trivial).\nThen after execution is complete and if context implements this interface we'll copy it to ExecutionResult->extensions. This way the feature will mainly stay in the user-land.\nAlso it will require less typing in resolvers since user context is a 3rd argument, and ResolveInfo is 4th.\nPlease let me know if it works for you.. This feature will make them impure anyway but adding singleton here is even a bigger sin. Right now resolvers are not even aware of the executor, there is no reason to couple them like this. \nPlus technically it is possible to have multiple executors (for testing or some non-trivial usages).. You are not forced, it's an opt-in and convenience feature. Just don't implement this interface and keep using your context as is. You can always set extensions manually the way you want (or don't set them at all).\nGraphQL class is just a convenience facade class. You can use this library without it and certainly shouldn't rely on it for any specific logic.. Hey, thanks for the update, I'll merge it as soon as I get a chance to work on the next release (but maybe will rename ExtendableContext, so open to suggestions as well). So what would you suggest on the subject of this PR (it is not entirely clear from your last reply)?. @mcg-web But if you use the server it requires a bit more efforts to achieve the same result, so it's not always that obvious. \nBut yeah, I still hesitate too. The other thing that bothers me is that reference implementation doesn't have this feature too, and they may add it in future in a conflicting manner, which will indeed make the maintance harder for us.. I tend to close this PR because it leads us to the wrong direction. We shouldn't encourage using of context (and resolvers) in such a manner on a library level - it will be way harder to \"undo\" later then not doing at all.\nInstead, I think that we should follow the other route altogether, which I outlined in #225\nEventually, it will allow us to do what this PR suggests and much more (like optional resolver memoization).\nIn the meantime, the simple temporary workaround could be adding one more option to the standard server prior to result serialization where users will be able to modify extensions as needed.. @adri Sorry I've missed your comment in this thread. I like the middleware approach but we will likely keep following the reference implementation. So they must implement it first for us to follow.. It is supposed that you use a custom error handler to add logging, so I am curious why it doesn't work for you?\nAlso, have you tried debugging tools?. You can do it in formatter, but formatter is mostly for formatting an exception to an array. It is more appropriate to use errors handler, but that's after you.. There are lots of ways to do this. But it depends on constraints of your data structure.\nSome variants:\n1. Do a separate SQL query for this field\n2. Fetch same children as in \"childs\" field (but use some data caching layer to avoid double fetching)\n3. Use a getter for \"childs\" which saves the result in BoardEntity class\n4. Prefetch children in parent field and include it in your BoardEntity class so that $value->childs always returned same children\netc, etc. This is your app logic after all.. Not really an issue, so closing. But feel free to ask more question if needed.. Thanks, we also need some tests for it. Dupe of #178 (#220 is also related). You should not direct OPTIONS requests to GraphQL. They are sent by browser automatically (used for cross-origin resource sharing) and have nothing to do with GraphQL. Just process OPTIONS separately as required by CORS.. Do you use any web framework? Most of them provide some means to handle different HTTP methods separately for the same URI.\nWithout a framework, you can just do something like this:\nphp\nif ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {\n    // Do your CORS logic here\n} else {\n    $server = new GraphQL\\Server\\StandardServer(/* $options */);\n    $server->handleRequest();\n}\n. Awesome! I'll review a bit later and will merge as soon as you finish with tests. Thanks!. So is it ready for review/merge?. Thanks a lot! Really useful stuff!. One thing why this is problematic for me right now is that we may implement it in a different way comparing to the reference implementation, which will make further maintenance much harder (or will require breaking changes).\nSo I think it makes sense to wait until they resolve https://github.com/graphql/graphql-js/issues/284 and follow up after that.. Well, actually composing resolvers is a recommended way to do this right now. If you do this in a lazy type loader - it should be ok.\nI prefer using class-level resolveField callback in types and don't use field-level resolvers. In this case, the number of wrapping operations is way lower. Other option would be to wrap all resolvers inside definitions (of course if you have full control over your types):\nphp\n'myField' => [\n    'type' => Type::string(),\n    'resolve' => MyUtils::wrap(function() {\n    })\n]\nAs for default resolver - you have full access to it, so you can replace it with whatever you want.. Closing because no action is pending on this right now from our side. We'll get back to it as soon as graphql-js moves forward with logging support.. For anyone interested, there is another proposal on how to enable apollo tracing for any existing schema: see https://github.com/webonyx/graphql-php/issues/289#issuecomment-399633709 PRs are welcome!. Feel free to submit a PR, I'll merge it.. This issue should be fixed as a part of #248 (with new way of defining descriptions in SDL). For now, it is recommended to use your own custom ID scalar type if you need custom behavior. ID is the only built-in scalar type which can be overridden by passing it via types option to the schema.. OK, I'll reopen.\nThis lib's minimum PHP version is 5.5+ which has no Throwable support. Also, it will silently convert arrays to \"Array\" string which is not desirable (although I guess we could ignore this case).\nSo the only good way I see how this can be fixed is by additionally checking for:\nphp\n!(is_scalar($value) || (is_object($value) && method_exists($value, '__toString'))\nDo you see any drawbacks to it?. Someday it will happen, but not yet as there are still projects on PHP5 who may use this lib.. I personally know legacy projects on PHP5 who haven't transitioned yet to PHP7, but who do use this library, so we won't switch before the next major version of this lib.. Fixed in #210 . Hey, sorry I can't understand what your actual problem is. It would be great if you provide a test case to reproduce it because the solution in this PR doesn't seem right to me. \nI may be wrong, but to clarify this I need a test case that fails on the current version and passes on yours. . In short, there is no resolve option on the type level, because GraphQL resolves data at the individual field level. It is done on purpose, the way you want to use it is not recommended.\nBut you can use resolveField option instead.. I am really surprised that it worked for eager loading because there is no resolve option on the type level regardless of lazy/eager loading mode.\nAs for this feature in general - it will be very confusing for newbies. Resolving process is the one that causes most questions when starting with GraphQL. We actually want to keep it as simple as possible. Adding more features here is something we want to avoid.\nAlso, keep in mind that one of the main principles of GraphQL is to resolve only what is needed and the lib is trying to help people start thinking in these terms. Resolving the whole type if a client asks for 2 fields only is against this principle. . I am not sure I understand the question. It would be easier to understand with a schema example (in GraphQL SDL) + your query, variables, and expected result.. This is not how GraphQL works. If you need arguments in the specific field - just pass arguments on that level in the query:\ngraphql\nquery {\n  operatingSystems(\n    filter:{\n      field:name,\n      type:LIKE\n      value:\"Andro\"\n    }\n  ){\n  id\n  name\n    versions (filter: { versionFilter: \"something\" }) {\n      id\n      version\n      osId\n    }\n  } \n}\nOtherwise, it is your responsibility to pass these values down the query. Options are:\n1. Since you rely on those to resolve nested field - include them in the value returned by parent resolver\n2. Use context to pass it to the deeply nested resolvers\nBut both of those methods are not recommended. The recommended one is to pass arguments directly to the field that needs them.. It is documented here. You have at least couple options:\n\n\nSince these errors are domain errors vs GraphQL errors - model them in your schema. See https://github.com/webonyx/graphql-php/issues/97#issuecomment-287260324 and related discussion.\n\n\nCollect all errors in your resolver, throw a custom exception with those errors attached and then add entries for each of your errors manually using custom error handling, for example:\n\n\nphp\n'resolve' => function($_, $args) {\n    $errors = [];\n    if (empty($args['name'])) {\n        $errors[] = 'Name could not be empty';\n    }\n    if ($args['age'] < 18) {\n        $errors[] = 'Age has to be 18+';\n    }\n    if (!empty($errors)) {\n        $e = new MyValidationException();\n        $e->myErrors = $errors;\n        throw $e;\n    }\n}\nThen in custom error handler:\n```php\n$myErrorHandler = function(array $exceptions) {\n    $errors = [];\n    foreach ($exceptions as $exception) {\n        if ($exception->getPrevious() instanceof MyValidationException) {\n            foreach ($exception->getPrevious()->myErrors as $message) {\n                $errors[] = [/ Format the error as you want /];\n            }\n        } else {\n            $errors[] = [/ Format the error as you want /];\n        }\n    }\n    return $errors;\n};\n$result = GraphQL::executeQuery(/ $args /)\n    ->setErrorsHandler($myErrorHandler)\n    ->toArray(); \n```. Oh yeah, and one more option I keep forgetting about is to return an array of exceptions from your resolver (vs throwing them).\nBut that's not certain. I remember that we discussed it at some point, just don't remember if it is actually implemented %) so try it yourself.. Thanks for your feedback. Have you seen https://github.com/webonyx/graphql-php/pull/193 ? Would it work for you?\nAlternative is just to add an option resultFormatter to the server where you will be able to do whatever you want with execution result. Which solution would work better for you?. For anyone interested, there is another proposal on how to enable apollo tracing for any existing schema: see https://github.com/webonyx/graphql-php/issues/289#issuecomment-399633709 PRs are welcome!. You have $context for this. Make a separate class for your context and pass your errors/notices/warnings to it. Then use custom error handler to add your own errors to final result.\n```php\nclass MyContext {\n    private $errors = [];\n    public function addError(MyException $e)\n    {\n        $this->errors[] = $e;\n        return $this;\n    }\n}\n// Later in your resolver:\n'resolve' => function($value, $args, MyContext $context) {\n    $context->addError(new MyException('Whatever you want'));\n    $context->addError(new MyException('Whatever you want 2'));\n}\n// Now querying graphql:\n$myContext = new MyContext();\n$result = GraphQL::executeQuery($schema, $queryString, $rootValue, $myContext);\n$result->setErrorsHandler(function($errors, $defaultFormatter) use ($myContext) {\n    $formattedErrors = array_map($defaultFormatter, $errors);\n    foreach ($myContext->getErrors() as $error) {\n        $formattedErrors[] = [\n            // format your error as you need\n        ];\n    }\n    return $formattedErrors;\n});\n```. Thanks for the PR. This is basically what we discussed in https://github.com/webonyx/graphql-php/issues/203#issuecomment-348707573\nI would appreciate if you add couple test cases in https://github.com/webonyx/graphql-php/blob/master/tests/Type/ScalarSerializationTest.php \nThen it will be ready for merging.. Drop it in the same folder for now, just name with a Stub suffix. I'll move it later when working on next release.  Note that you may have to require it manually in test class - I just don't remember if we have autoloading for test classes.\nAs for using objects for ids - it should be OK. One problem that this solution doesn't solve though is parsing. Some ID types could be transformed back to object from string (like Relay's global id where you often concat type name and type instance id). \nBut this is out of the scope of this PR. For now we should at least support __toString casting, so your PR is ok.. If you use it for entity identification then ID is what you need. But if you rely on the fact that it is UUID anywhere in your code, then you should have a separate type.\nAs a rule of thumb - if you can safely replace your ids with any other unique string without breaking clients - then it qualifies as ID type. Otherwise use custom scalars.\nAlso in a future version of GraphQL we can see this feature - https://github.com/graphql/graphql-js/pull/914 which can make custom scalars more convenient.. Thanks! Released in v0.11.5. I wouldn't use separate UUID type in your case.. Resolvers may accept different values. Just create a wrapper class for your json and pass it down to resolvers. Then in your resolver check what type of value you got and resolve accordingly.\nAnother option is just to introduce an interface that field resolver accepts and have multiple implementations. Polymorphism ftw.. GraphQL is designed without normalization. So there are no built-in tools at the moment. If you need normalized data output, you should probably consider using other tools (i.e. Falcor).\nBut if you still want to do it with GraphQL (even if it's against GraphQL design), you'll have to use GraphQL::executeQuery() and then transform the result manually. \nOne thing which may help you a bit is a __typename field which you should add to every object field in the query. Technically you can do it as a custom validation rule which alters query AST.\nThe rule itself could look something like this:\n```php\nuse GraphQL\\Validator\\Rules\\CustomValidationRule;\nuse GraphQL\\Language\\AST\\SelectionSetNode;\nuse GraphQL\\Language\\AST\\FieldNode;\nuse GraphQL\\Language\\AST\\NameNode;\n$myRule = new CustomValidationRule(function() {\n    return [\n        NodeKind::SELECTION_SET => function(SelectionSetNode $selectionSet) {\n            $newSet = clone $selectionSet;\n            $newSet->selections[] = new FieldNode([\n                'name' => new NameNode([\n                    'value' => '__typename'\n                ])\n            ]);\n            return $newSet;\n        }\n    ];\n});\n```\nI am writing this off based on memory, so not 100% sure that it will work out of the box. Feel free to ask more questions if needed.\nThe closure passed to the constructor of CustomValidationRule is a rule for visitor.. Actually, I am probably wrong. Validation will ignore your AST changes as it is read-only. You will have to do a separate pass on your query before execution to get __typename:\n```php\n$myVisitor = [\n    NodeKind::SELECTION_SET => function(SelectionSetNode $selectionSet) {\n        $newSet = clone $selectionSet;\n        $newSet->selections[] = new FieldNode([\n            'name' => new NameNode([\n                'value' => '__typename'\n            ])\n        ]);\n        return $newSet;\n    }\n];\n$documentNode = Parser::parse($request->queryString);\n$modifiedDocumentNode = Visitor::visit($documentNode, $myVisitor);\n$result = GraphQL::executeQuery($schema, $modifiedDocumentNode);\n// transform $result->data as you need\n```. Closing, but feel free to re-open if needed. We considered adding it in #78 but the more I think about it the more I incline not to introduce any base classes or interfaces. There is a good reason why smart people prefer composition over inheritance.\nInterfaces are fragile and hard to modify. Say we have an interface in the library and many projects start using it. Then at some point, we decide to add an optional method to this interface or even rename a method. It will introduce an unnecessary breaking change. An alternative here is to add new interfaces for each minor tweak.\nWith data structures instead of interfaces, we can provide reasonable defaults ourselves and avoid many breaking changes. We can also do much smoother deprecations.\nAnother problem is that having two ways of defining types makes maintenance much harder. It also introduces different experience for library users and makes it harder to communicate and solve issues.\nThat's why I am actually re-considering if we need #74 at all (even though it's just a syntax sugar). \nThe way you want to define your types is quite possible with composition. Just use your own classes and have a separate factory which builds actual definitions. For example:\n```php\nclass UserType\n{\n    public function getFields(): array\n    {\n        return [\n            'email' => MyTypes::string(),\n            'friends' => MyTypes::listOf(MyTypes::user())\n        ];\n    }\n// getDescription, getInterfaces etc.\n\n}\nclass MyTypes\n{\n    private $types = [];\nfunction user()\n{\n    // obviously you can automate this for all types:\n    $myUserType = new UserType();\n    return $this->types['user'] ?? $this->types['user'] = new ObjectType([\n        'name' => $myUserType->getName(),\n        'fields' => [$myUserType, 'getFields'],\n        'myClass' => $myUserType, // just in case if you'll need a reference later\n    ]);\n}\n\n}\n```\nActually some framework wrappers (like laravel graphql) do exactly this.\nI do understand that PHP is heavily infected by OOP, but it doesn't mean that it is the only right way to do things %). >  I don't understand why you're against it now since you originally proposed it yourself\nBecause I had quite bad experience since then maintaining interfaces. Commenting methods in them is a nice workaround but it just proves the point. Also, you haven't covered method renamings and signature changes.\n\nI don't consider it a good solution - it would only add unnecessary transformations everywhere slowing down the application.\n\nHow much will it slow down the application? It may have some memory overhead, but in general, with type lazy loading, I do not think it will be significant (claiming otherwise requires some evidences for rational decision making, otherwise it sounds like premature optimization).\nThis solution is actually good enough. Yes, it is more of a functional approach than OOP, but it is OK (even if you don't like it).\n\nI've already heard claims that webonyx is in fact much slower than Youshido\n\nClaims, really? If you have doubts - do your benchmarks. But keep in mind that there are at least 3 stages - parsing, validation, and execution. In order to compare apples to apples, you must have all 3 stages feature-complete in both libs, properly configured (lazy type loading?) which is not the case. Otherwise, you would probably pick the other option, right?\n\nAnd the code would look very ugly in some cases where it would not be possible to abstract.\n\nSeeing real-world examples would be nice?\n\nAlso I should note that this library is still in 0.x.y versions which is a pre-release stage\n\nIt just mirrors versioning of the reference implementation to simplify understanding of compatibility between them.\n\nTo use composition to its full potential you need interfaces defining the contract between classes so that you can replace any class with your own implementation if necessary. \n\nExcept that providing such contracts we also establish a fragile public API which we'll have to respect for BC. We do not provide such interfaces intentionally. \nInstead, we split the processing into steps of data transformations and if you need something - you can do it yourself between those steps. Other things you can solve with composition (like resolver composition). It actually allows us moving without major breaks.\n\nI want to achieve a state where a Type definition uses composition for the fields instead of defining them by itself\n\nI would really prefer an example of what you are trying to do which is impossible now. That would help much more than such an abstract discussion. For now, I see only your personal preferences.\nOne thing you should understand is that this lib is a direct port of graphql-js. Moving too far away from it means it will be much, much harder to follow. And that's one of the main reasons why we were able to port most of their features (and there are lots of them). Deviating significantly means making lib maintenance orders of magnitude harder.\nWe are quite open to helping solve real problems, but in order to do so, please start by providing real examples of what you couldn't do with the lib. The fact that you don't like the solution proposed is just not good enough reason for a change (doesn't pass cost-benefit analysis).\nAlso, note that the issue #78 is still open because I am still waiting for a real-world data of benefits from it. If we see significant performance benefits on real-world projects or something major that really can't be done with current implementation and can be done with interfaces - we will move forward, but I haven't seen enough evidence yet that we really need it.\nTo summarize, give us some numbers/examples.. Closing as dupe of #78 We'll continue this discussion there.. Not enough information to understand what's going on. What is your query? Did you try to reduce the case to only the failing field with arguments?. So why do you expect args in resolveField? There are no args for id or name field in the query, so there are no args in the resolver.. The following query will produce args on resolveField:\ngraphql\nquery test {\n    test {\n        id(myArg: \"one\") \n        name(myArg: \"two\") \n    }\n}\nresolveField is actually the same as resolve for each field, except it is moved to the type level. You use it like this:\nphp\n'resolveField' => function(User $user, $args, $context, ResolveInfo $info) {\n    switch ($info->fieldName) {\n        case 'id':\n          /* Here $args['myArg'] === 'one' */\n          return $user->getId();\n        case 'name':\n          /* Here $args['myArg'] === 'two' */\n          return $user->getName();\n        default:\n          return null;\n    }\n}\nRelated docs. No, it's dumb and simple. Also, you shouldn't rely on parent args in your child types. The reason is that exact same type can be used in different fields with different sets of arguments. Relying on parent arguments like this is a bad practice and will lead to fragile code.\nBut if you really, really need it, the only way you have right now is to pass them yourself via $context (setting them to context explicitly in the parent and reading in the child).. setTypes is allowed to be closure for a very specific use case. In general, you just pass it as an array. Why do you need to pass your other types as closure?. I see. The issue with custom ID type occurred couple times already, so we obviously need a way to fix it (#174 was just a workaround). \nOne idea I had was to exclude ID from global types (but keep existing Type::id() for backward compatibility and for those who uses simple strings as IDs)\nThe other option was to allow setting custom serialization/deserialization methods to existing ID type (but that would be global, which is probably not the best way to go).\nIf you have other ideas how to resolve it, please share. PRs are welcome as well (but better after discussion).. Will track this in #301 as it better reflects what has to be done.. It introduces a possible breaking change, so we'll have to release it in the next major version. Will merge it as soon as I start working on it (unless you need it for your other PRs).. So when we merge uploads this PR will make no sense, right?. Yeah, will gladly accept such PR!. Looks awesome, but I have couple notes:\n\n\nI would like to separate utils like this from core types defined by GraphQL spec. So we should use something like Utils\\UtilTypes::psrFile() for this instead of Type::file(). Also the type itself should live somewhere under Utils namespace (or maybe all of it should be placed under the Server namespace - what do you think?).\n\n\nThe server has to support \"multipart/form-data\" for default PHP globals method as well. Right now when you send multipart/form-data the server just won't do anything. But it should actually process the query passed in a request the same way it does for regular application/x-www-form-urlencoded. Then one can use $_FILES manually in the mutation resolver.\nWe can probably implement a similar scalar type (e.g. Utils\\UtilTypes::phpFile()) which just returns corresponding entry from $_FILES in the resolver.\n\n\nI am not convinced that https://github.com/jaydenseric/graphql-multipart-request-spec is a way to go for us because it introduces separate request format which is different from what we currently use for application/x-www-form-urlencoded. I'd prefer to stay consistent here. We do not support batched queries for application/x-www-form-urlencoded anyways.\nWe should probably stay closer to express-graphql, e.g. how they suggest doing uploads (with a difference that we use scalar type vs object type as in their example)\n\n\nPlease let me know what you think.. We have a separate endpoint for file uploads (not doing it via GraphQL). And also use our own simple GraphQL client (not Apollo or Relay)\nI actually didn't realize that you want to implement some 3rd-party spec, just thought we'll mirror multipart/form-data after application/x-www-form-urlencoded with some sugar (as express-server does via multer).\nAs for graphql-multipart-request-spec... the problem is that we can't really say that it is a standard. Apollo server by itself doesn't support file uploads, Relay recommends doing it this way (a-la express).\nI think it's better to extract this implementation as a separate project (same way as apollo-upload-server is separate from apollo-server). But still, the question remains if we can make life simpler in a Standard Server for those using such tools.. Actually apollo-server (at least for express) uses the same approach as express-server, so this actually looks like a standard for me.\nP.S. I somehow managed to miss the part about graphql-multipart-request-spec you mentioned in the original PR proposal, my apologies for this.. @PowerKiKi I do agree that we should keep docs and examples (as they are rather small), but everything else can be dropped (I've seen codebases where vendor folder grows > 1gb which is insane). \nSo I think following entries could be safely deleted:\n/benchmarks export-ignore\n/tests export-ignore\n/tools export-ignore\n.gitattributes export-ignore\n.gitignore export-ignore\n.travis.yml export-ignore\nCONTRIBUTING.md export-ignore\nmkdocs.yml export-ignore\nphpbench.json export-ignore\nphpunit.xml.dist  export-ignore\n@giansalex  Can you update the PR and I'll merge it?\n. Docs are quite useful at least for offline mode. Some people also like doing docs search straight in their IDEs, so there are valid cases for docs in a release. Plus docs and examples take ~200kb which is tolerable.. Thanks a lot!\nP.S. Looks like Travis experiences some troubles now, I'll merge it as soon as Travis recovers and we get it built correctly.. What's wrong with:\ngraphql\n{\n  posts(hasComments: true) {\n     id\n     comments {\n       id\n       ...otherFields\n     }\n  }\n}\n?\n  . Not sure what is the problem here. If you use SQL you would do something like this in your posts resolver:\nphp\n'resolve' => function($root, $args) {\n    $sql = 'SELECT id FROM posts';\n    if (!empty($args['hasComments']) {\n        $sql = '\n            SELECT p.id FROM posts p \n            WHERE EXISTS (SELECT 1 FROM comments c WHERE c.post_id = p.id)\n        ';\n    }\n    // execute query and return your rows \n    // (or if you use data loader - also call $dataLoader->loadMany($ids) on fetched ids)\n}\nThe idea is the same for other data engines - you filter posts in your posts resolver.. Check out this comment in the reference implementation and the whole thread.. The link explains why there is no default date or time type.\nDates are fundamentally hard (apart from simplest cases). We used different solutions depending on a project. One time we even had to express dates as object types which included timestamp, expected local time, factual local time with timezone (timezones and DST rules also change from time to time).\nSo it depends mostly on your project and applies equally to GraphQL or any other API design. You've seen solutions proposed in the referenced thread - any of them can be valid in different situations.. I did some testing. Could not reproduce on PHP7, but I got the segfault on PHP5.6 too. Looks like PHP is not happy about how we use LinkedList in Lexer. I had plans to get rid of it, but no ETA yet. \nIn order to make it work on PHP7, try following:\n1. Use dev-master version of the library (I just pushed some fixes to serialize/unserialize)\n2. Use noLocation option of the parser, which will exclude location data generation (useful for debugging only anyway) e.g.:\nphp\n$result = \\GraphQL\\Language\\Parser::parse($cachedAST, ['noLocation' => true]);\n$arr = \\GraphQL\\Utils\\AST::toArray($result);\nIt may help but in general, I doubt that you will achieve anything useful in PHP with a schema of such size. Exported JSON AST of this schema is ~20mb (and you'll get similar JSON sizes with any implementation, I tried with graphql-js). \nSimply reading such JSON into PHP variable will take ~200 mb of memory (rough estimate) and half a second. That's only json_decode, before we even start any GraphQL operations.\nSchema of such size makes sense when it is loaded once and shared between many requests. It just doesn't make sense for PHP's share-nothing + execute-and-die model. Of course, it might be possible to workaround some limitations of this PHP model, but in general, the tool doesn't seem right for your case.\nAnyways, let me know about your progress as this journey is useful for the lib anyway.. Note that buildSchema is not the only option. One way how this would be possible in pure PHP:\n\n\nCreate a regular schema with lazy type loading. On schema initialization, you only need Query and Mutation types.\n\n\nWrite separate cached AST file per each type.\n\n\nWhen a query is executed, in your type loader - read AST file of the corresponding type and construct type instance yourself in the runtime. Refer to the source code of the BuildSchema class on how this can be done.\n\n\nTechnically you can make some of the BuildSchema methods public to allow it build individual types in addition to the whole schema (will appreciate a PR).\nSo in short, using chunks of schema definition files may work for you. You may prefer holding AST data in shared memory instead of files, but this is something worth benchmarking.. @spawnia Why not? Parser simply produces an AST. You can easily parse type files separately and then extract specific type AST from the resulting document and construct the definition in the type loader (only when it is needed by the query).\nAlternatively, you could try using PHP Immutable Arrays (and one more document) for AST cache. But it requires code-generation to store AST in PHP files.\nI guess the best solution is to combine both of those. As for me, immutable arrays is a must if you build the schema from AST. It just makes so much sense to keep this cache in PHP AST memory zone (which is shared by different requests) and do not copy the entire array all the time.. It is not a hack. GraphQL document is not limited to full schema definition or queries. Any syntactically correct GraphQL string can be parsed into a valid document (that's why document node exists in place).\nBut only a subset of documents can be used for execution or buildSchema (they are validated separately).\nBut yeah, utilities like the one you mention are quite useful for AST manipulation. Feel free to submit a PR for things you think belong to this lib (probably under Utils or Language namespace).. Please post the reproducible example of the code which causes this.. How do you run graphql-php? Using StandardServer or just GraphQL::executeQuery? I mostly need graphql-php related code to repro.. Closing due to inactivity, feel free to re-open with new data.. Need more data to reproduce. Type/schema definition/query causing this?\nOn Jan 19, 2018 20:28, \"Cristian Rusu\" notifications@github.com wrote:\n\nHello\nI try to run a query with meta field \"__typename\". For some reason I get\nthis error:\nField \\\"__typename\\\" is not defined for type\nDo I need some config or changes in order to resolved this automatically?\nThank you\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/webonyx/graphql-php/issues/231, or mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AAHDrLx4uiM73mftim9dDKz7_yIlGYwsks5tMJiZgaJpZM4RkecX\n.\n. Can you please enable debugging to see the trace? In case of StandardServer it is debug option.. No problem. Oops, good catch, thanks!. I do understand these concerns, BUT the whole point of the spec is to have common grounds for GraphQL ecosystem of existing (and future) tools. Allowing customizing these constants means treating the spec as an advice vs strict rules. We won't do it in this library.\n\nThere is a similar discussion in spec repo with some advises, including:\n\nusing floats\nusing Strings\nusing custom scalar (for example something similar to Int53 mentioned there)\n\nSorry for making it harder, but I do believe that sticking to the spec (as a rule) has more value in the long-term. Easy doesn't always mean right.\n. Sorry, I don't want to make it easier to break the spec.. What is the point of silencing trigger_error?\nThe whole idea behind it is to actually trigger an error. PHP has quite good error_reporting settings + ability to define custom error handler if required to intercept those.\nWe also have a GraphQL\\Error\\Warning to set up warnings which can be suppressed on demand. If you need suppressing those errors then it is better to convert trigger_error calls to corresponding GraphQL\\Error\\Warning::warnOnce or GraphQL\\Error\\Warning::warn and use GraphQL\\Error\\Warning::suppress with error ids.. Something is wrong with your setup configuration. I just tried to follow instructions from scratch and everything worked. It looks like your ChromeiQL is not sending valid queries to the endpoint.\nNeed more info to help you. Please check the network tab of your browser dev tools when using ChromeiQL and let me know what is getting sent in the browser request and what HTTP method is used.. As far as I understand this PR doesn't make sense as a standalone PR anymore? Or am I missing something?. I already ported this as a part of the work on v0.13. Hey @danez this is cool! I will be able to review/merge them somewhere at the beginning of the next week. Feel free to port as much as you want %) Thanks for those PRs!\n. Finally merged %). GraphQL is a better fit for highly structured content (when you may request lots of different subsets of data). It is not the best fit for situations when you only query for a list with a bunch of flat attributes (unfiltered).\nCustom REST endpoints will always outperform GraphQL in such scenario because well, you don't need most of the features of GraphQL for such queries!\nAs for performance issues - there is indeed an overhead for each field, we do have plans to adjust common scenarios to use short evaluation paths and memoization, but no ETA for this feature.\nActually, it is better to watch after graphql-js thread you mentioned, as they also experiment with such optimizations and we'll likely follow the same route they choose eventually.\nBut also make sure your data layer is optimized as (usually) it is the bottleneck. Say how many requests to the underlying store do you make? How is your internal data structured, etc?. Do you use default field resolver? It is hard to say anything without seeing some code (or better) reproducible example (since data layer is not the case - I guess we can just stub it with arrays to reproduce reliably).. I tried to reproduce this issue on your codebase, but couldn't. Check out https://github.com/vladar/graphql-perf-debug and run it on your machine.\nMine laptop returns about 0.43 second to execute the query against an in-memory store (with dataloader, etc) on PHP 7.2 (but make sure to run it several times to populate PHP cache)\nSo result contains 100 entries, each containing 100 attributes (10000 total). Maybe I've missed something, so feel free to adjust the code to reproduce.. And make sure you have xdebug (and other similar tools) disabled when testing.. Closing this for now. But if you have fresh details, feel free to re-open!. Thanks for the further details! Actually, I did some profiling and the bottleneck is not graphql, but dataloader.\nThose lines are to blame: https://github.com/overblog/dataloader-php/blob/master/src/CacheMap.php#L63-L71\nIt makes any cache operation O(N) vs O(1) with obvious consequences. I did a quick change locally to just use array key vs looping over all cache entries and the total time for your test_2.php had dropped from 6s to ~0.7s\nEven here the overhead above 0.4s is caused by other tools, not graphql. There is no special caching right now on the graphql side of things. So for graphql it is irrelevant if you have 100 same attributes or different.\n@mcg-web Can you share some thoughts on why you guys use looping vs lookup in the lines above and can you change this?. So this is actually not a problem of this lib, closing. Technically you are right, but I can't accept the solution proposed (array_values($values) !==  $values). This comparison is O(N) which will add up significantly to the execution time of EVERY list.\nAlso, we need tests for those cases. I can't accept a PR without related tests. I'll keep this issue open because it is a valid request, but we really need to approach it more carefully and cover with tests to avoid regressions in future.. Awesome! Let me know when you are done, I'll review and merge it. Thanks!. This is fantastic! I wanted to port these changes in near future, just couldn't find big-enough time window (as I've been quite busy recently). So your PR is sooo helpful, thanks again! But reviewing it will also take some time %). One major problem is a removal of a typeConfigDecorator from the buildSchema. We actually used it to attach resolvers to fields and types. Not just to make interfaces and unions resolvable.\nAs far as I understand regular buildSchema doesn't allow you to do this and just asks to rely on root value for resolution process? If so, then this is something we will probably have to revert.. Merged! One final thing that concerns me is that we expose Utils::undefined() in scalars types. It is kinda hack to simplify maintenance and was not supposed to be exposed to library users (and it will happen when users will start building their custom types looking at existing internal types).\nHow do you think can we just throw instead of returning undefined? Looks like exceptions in those methods are handled correctly, so there shouldn't be a major difference, right?. And thank you so much for this huge work!. @danez So any ideas about throwing vs returning Utils::undefined() (see the comment above). Will it work, how do you think?. Cool, as soon as we switch to throw vs Utils::undefined(), I'll release version 0.12. Thanks!. Cool, glad that you've figured it out!. Thanks for the PR! One problem with selected implementation is that I'd really want to avoid another function call  (offsetExists) there: this method is used quite often, so it is critical to keep the number of function calls there as low as possible.\nI guess we could change the implementation a bit:\n1. Just use foreach loop vs for (it will account for missing keys much more efficiently)\n2. Do not use unset in offsetUnset and instead, splice an array (to always have sequential keys). Newer versions of PHP have optimizations in place for such arrays\n3. Make NodeList immutable (prohibit unset and set) and just require a new NodeList in such situations (but this is a BC break)\nAs far as I understand you do use unset for some of your code. Can you share your thoughts on those options?. @spawnia We needed it for lazy initialization of AST object tree from an array. Without NodeList you'll have to traverse such array twice: the first time when initializing AST from an array, the second time when you actually visit it during validation or schema creation.\nYou may need it in couple cases:\n\nWhen you use C-based parser\nWhen you serialize and cache AST as an array (especially big schema language AST)\n\nNodeList enables us to create a Node instance on the first visit (thus only visiting it once).. @spawnia Please check the conversation in the referenced PR and my last question. Do you have any preference on it?. Looks like this PR breaks some tests, can you please double check?. This should be fixed actually as a part of #248. As far as I remember it was done in #170. It was actually a valid issue (at least for strings and booleans). A related issue in graphql-js - https://github.com/graphql/graphql-js/issues/771 (yet they seem to fix only string case, not boolean or int).\nSo do you need to accept strings as integer input?. Sorry for the long delay with a response, I suggest to send a PR after I merge #248 (hopefully on this weekend). @mcg-web Can you check if the new version (in master) works for you and close if it is OK?. Do you use proxies for circular types only? Have you seen this article in docs and why it won't work for you?. I am curious why your proxy manager (or DI container) creates multiple instances for the same underlying type? This seems wrong to me. It leads to subtle errors and may cause significant performance overhead (as basically, you have {number of fields of this type} objects per type vs 1) unless I am missing something.\n. Closing after conversation in #257 . Can you provide a test case which fails on the previous version and works on this one? It will help to catch regressions later and to make sure we are on the same page with this issue.. Thanks!. This functionality existed in one of the first versions of the library but was deprecated in favor of callables in fields (and yes, some traces of it still exist in the code). It caused more troubles (with maintenance and performance) than gave benefits. I don't see any reason why we should restore it.\nYou are the first who needs it in 2.5 years of library existence for a quite specific reason (trying to avoid registry/factory of types). But I'll keep this PR open to collect more evidence that this feature is needed by other library users as well.. I've posted you a link on how to deal with circular types.\n```php\nclass User extends ObjectType\n{\n    public function __construct(TypeRegistry $types)\n    {\n        parent::__construct([\n            'fields' => function() use ($types) {\n                return [\n                    'lastPost' => [\n                        'type' => $types->post(),\n                    ]\n                ];\n            }\n        ]);\n    }\n}\nclass BlogPost extends ObjectType\n{\n    public function __construct(TypeRegistry $types)\n    {\n        parent::__construct([\n            'fields' => function() use ($types) {\n                return [\n                    'author' => [\n                        'type' => $types->user(),\n                    ]\n                ];\n            }\n        ]);\n    }\n}\n```\nWhy doesn't this work for you?. 2. Withing User __construct $types->post() is called\nNo, it is not called within constructor, because fields is a closure. It is called later during execution. The whole point to make fields (and interfaces) a closure to break a cycle.\n. I don't see any resolvers attached to fields. There is also no root value to get data from. Have you read an entry about data fetching in docs?. We will support PHP5.6 and 7.0 at least until the end of the year (when PHP security support will end). But we can drop PHP5.4 and 5.5. Please adjust your PR and I'll merge it. . @simPod not really. At least not yet. I think we should do a prior notice before doing such major things. So we will release one more version with 5.6 support and the next major version will only support PHP 7.0+. But even in Doctrine announcement, they write: \"Since many people are encountering issues with these updates...\"\nI wouldn't call this a good approach to deprecations/upgrades.. Thanks!. Reference implementation library graphql-js had recently opted into a different way of defining descriptions by using strings (and multiline strings) vs comments.\nWe will have it as well in the next version and this issue should be resolved by itself.. I think we should wait for a fix in the reference implementation.. The reality is that we keep following reference implementation (graphql-js) and deviations from their core logic are costly in terms of maintenance. \nWe do deviate when a feature is really important, but the only serious problem I see in your description is Xdebug stack traces (and it probably requires some investigation).\nEverything else can be implemented in the app code. I.e. just don't use Debug::RETHROW_INTERNAL_EXCEPTIONS and throw manually after execution (if it is a part of your app logic):\nphp\nif (isset($result->errors[0]) {\n    if ($result->errors[0]->getPrevious()) {\n        // Error caused by the app-resolver\n        throw $result->errors[0]->getPrevious(); \n    } else {\n        // GraphQL-specific error\n        throw $result->errors[0]; \n    }\n}\nIf you need all exceptions in Sentry, I am pretty sure it supports logging exceptions without throwing.\n\nFurthermore, in the client there needs to be additional code to parse the error data and find out which data is affected, because \"an exception happened fetching this data\" and \"the data is null\" are two very different things.\n\nI don't see how throwing one exception is more useful for the client than returning a partial result with the same exception included in the errors. With exception thrown, you won't even have any way to \"find out which data is affected\" because there is no data.\nSo if you don't need it - just look at errors[0] and if it exists - process the error the same way you would do with an exception thrown.\nIf some nodes of a result may end up in a domain error - they should be modeled as a union: DomainError | MyObjectType and resolved accordingly.\n\nTherefore I suggest implementing a configuration flag that completely disables the exception handling in graphql-php (i.e. run the same code but not inside a try) and leaves that to the application.\n\nApart from maintenance costs, configuration options multiply possibility of bugs (i.e. feature affects execution path with try/catch, but missed the path without) and complicate bug reproduction since reporter must post all of their options as a part of a bug report (and very few people do it during the first iteration).\nWe've seen too many times how a bunch of configurations simplifies work at first but complicates it during other stages of the app lifecycle.\nSometimes configuration options are inevitable, but if they can be avoided, it is better to avoid them.. Closing due to inactivity. Looks like command is outdated. It must also include content type:\ncurl -H \"Content-Type: application/json\" -d '{\"query\": \"query { echo(message: \\\"Hello World\\\") }\" }' http://localhost:8080\nBut if you are on Windows, there may be issues with curl quotes escaping, so use the following command instead:\necho {\"query\": \"query { echo(message: \\\"Hello World\\\") }\" } | curl -H \"Content-Type: application/json\" -d @- http://localhost:8080\nI'll update docs when I have a chance (or send a PR, I'll merge it!). Yeah, that's because CURL would send Content-Type application/x-www-form-urlencoded by default and we do support this type as well but then expect query prop in $_POST which is obviously not there.. You create a new instance of IntType on every call. Type::int() on the other hand creates an instance on the first call only and then re-uses it on every other call.. Thanks!. Yeah, we should probably throw in this case.. PR is welcome!. You can implement caching logic in your app.\nIf you know that the query is valid just pass an empty array of validation rules.\nFor the Standard Server:\nSee validationRules option.\nFor the GraphQL::executeQuery facade method:\nPass a custom set of validation rules in the last argument.\nThere is also an entry in doc which is not directly related, but which may be useful: http://webonyx.github.io/graphql-php/executing-queries/#custom-validation-rules\nIn general, the most performant solution is to use persisted queries. With a standard server, you can enable them by setting persistentQueryLoader option and setting validationRules option as a callable (see docs for clarifications).\nThe idea of persisted queries is that you save your queries somehow on the server and get queryId which you later use on the client instead of query. Then on the server, you store cached AST of the query and disable validation. This way you bypass both parsing and validation steps of a query.. Cool, feel free to re-open if needed.. You want to use version v0.11.6 (just released) as it has some performance improvements for the case with an empty list of validation rules.. GraphiQL doesn't support this as far as I know.\nUsually persisted queries require build step for the client-side code. In a development environment you use full queries but during a build step, you submit all client queries to the server and server returns you an ID for each query.\nThen you use this id in production instead of a query string. Obviously, client code must be written in a way where you can replace a query with an id.\nThe process of saving queries is not implemented by the StandardServer. It has to be done separately by your app. Server supposedly parses and validates the query once during saving, and then just uses cached AST for later requests.\nSo back to this lib... When the StandardServer sees documentId (or queryId as an alias) in the request, it attempts to load the query AST (using persistentQueryLoader). Obviously parsing is skipped in this case, but validation is not skipped by default (yet you can adjust the list of rules yourself via validationRules callback).\nFor example, following JSON request will trigger persistent query logic:\njson\n{\n    \"documentId\": \"some-server-generated-id\",\n    \"variables\": {\n        \"myVariable\": \"test\"\n    }\n}\nJust to recap, persisted queries usually require:\n1. An endpoint for query saving (and getting back an id)\n2. A build step for your client-side code\n3. Client-side code is written in a way that supports replacing query with it's id\n4. A server capable to execute queries saved by the endpoint (point 1)\nThis lib only provides you 4.. Oh, makes sense. Thanks!. @adri Master is far ahead from where 0.11.5 ended, so we need to branch from 0.11.5 and merge your commit there. I think it worth doing, I just need to find some time for this.. @mcg-web Thanks a lot! I cherry-picked several other commits (non-breaking), so will release 0.11.6 from this branch as soon as Travis checks it.. Just released 0.11.6. Thanks!. Introspection only supports type kinds defined by spec. I am not sure if we should support custom extensions like this. Did you try it with existing tools like GraphiQL? Does it work?. I do agree that input union is a useful thing and I miss them myself. But I don't agree that we should allow non-spec-compliant custom type kinds in the base library.\nThe way to go for this kind of change is to support the RFC you posted previously and have it included in the spec eventually.. Currently project description says \"Details coming soon\". Ping me when it's ready and I'll merge this PR. This is an issue in spec and reference implementation. See https://github.com/graphql/graphql-js/pull/1274 We will likely use the same solution eventually.. Yes, but this will be likely a part of 0.13 release. Unfortunately no, we've just released 0.12. But chances are high that it will take much less time than 0.12 %). I did plan to include it in 0.13 but have little time now. And we already delayed the release for a while. Also in the reference implementation, it is a part of the 14.0.0 release.\nWe could include it in our 0.13 if someone ported these changes in the next couple of days. I'll try to find time but can't promise it.. Well, technically a query is just a field in a QueryType object.\nSo you can do something like this instead:\n```php\nclass UserQuery\n{\n    function getField()\n    {\n        return [\n            'name' => 'user',\n            'type' => Registry::userType(),\n            'resolve' => [$this, 'resolveUser']\n        ]\n    }\nfunction resolveUser()\n{\n    // resolve the query\n}\n\n}\n$userQuery = new UserQuery();\n$schema = new Schema([\n    'query' => new ObjectType([\n        'fields' => [\n            $userQuery->getField(),\n            // add others\n        ]\n    ])\n]);\n``. Yes, it's the same asTypes::userType(). Just yourUser` type from a registry.. We will probably have to deviate from the reference implementation eventually when defining scalar types. I need some time to consider if chosen path is a correct one as both solutions (undefined vs throw) have their pros and cons.. Can you share the version of the lib you are referring to? Also, can you take a look at the master branch (there were multiple changes in this area recently)?\nYou may also find useful following readings (later are more relevant):\n170\n184\n254\n. Yeah, there were different opinions on this subject and the reference implementation choice had won this dispute in past.\nSo I think the best way to fix it is to report this issue in the reference implementation repo. If they admit it then we can revert back to our original fix (or use the solution they introduce eventually).. @spawnia Reference implementation can't be non-spec-compliant %) So if they refuse to change, they will also have to clarify/change the spec (they are pretty much the same people who write the spec).\nOne thing I can say for sure that we won't have any configuration option. Excessive configuration options are an easy-at-first path which has many side effects in the long run (and not just technical).. Good news. I regret that I've published 0.12 with a reverted behavior. Will probably have to fast-forward to 0.13 with a recommendation to avoid 0.12 if scalar serialization is important.. You can try this instead for now:\nphp\nuse GraphQL\\Utils\\AST;\n// ...\nif (is_array($input)) {\n    return AST::fromArray($input);\n}\nBut we should implement it in the core lib eventually. PR is welcome!. Fixed via #281. Thanks!. Can you create an issue first with some details of your problem? The fix proposed doesn't seem right to me, but maybe we can do something else here.. Ideally, we should follow PSR-2. But since there is no automatic PHP code style checks or PHP code style fixer in Travis, this is not enforced yet.\nThe best solution would be to set up code style checks or fixer for PSR-2, but I never found time for it. PRs are welcome!. Yeah, sorry, I meant PSR-2 initially. Doctrine code style looks reasonable for me. Go ahead with it if you have a moment!. @simPod looks like code coverage is not captured by the scrutinizer. Is there anything I can do to help enable it?. Can you also add a note to CONTRIBUTING.md about code style requirements?. @mfn Thanks for the suggestion! I've been thinking about this myself as code style checks just add unneeded resistance for those wishing to contribute. So the tool like this makes perfect sense. I'll review it when I have a moment. Maybe you have a sample project which we can use as a reference to set it up?. @simPod The point is to have all the benefits of enforced code style with no cost for contributors (automatically fixed errors). If we can achieve it with phpcbf - it would be great. I know there is also prettier-php, but it is pretty much alpha and it is a bit weird to use js-based tools for this.\n. Yeah, the code base starves for a cleanup and maybe some code style analysis applied. PRs welcome! %) \nThis particular issue is caused by the fact that originally lists were just arrays, but docblocks were not updated.. Looks like I misunderstood the following note:\nphp\nGraphQL\\Language\\Parser::parse('type Foo { bar: Int }')->definitions[0]->fields[0]->arguments\n=> []\nIf it's the case, then it is a bug. AST must contain NodeList here. But I can't reproduce it. For me it returns NodeList, not [].\nWhich version do you use? Can you double check with the latest?. Yeah, that was a primary reason why they are marked as SomeNode[]. This has more value over just NodeList.\nPHP type annotations are too weak to express complex types. Maybe some IDEs do support things like NodeList<SomeNode> but obviously not all of them.. For me, it's rather pragmatic - IDEs must correctly handle such definitions. If this notation enables better IDE support - this is great. But if it breaks them, then it's a problem.. DocBlocks should be fixed via PR #323. You mean the reverse order of type hints?. Those hints are just workarounds anyway. Only parameterized types in PHP type system would allow typing it correctly, but they don't exist. Everything else is just hinting / hacks around weak type system.\nAnyways re-opening, feel free to submit a PR with fixes you expect.. Then it's the best way to go! I didn't realize PHPStorm understands this.. It should be easy to debug. Just record stack traces inside the constructor of\nyour interface. The constructor should be called once. If it is called multiple\ntimes - check stack traces\n. I meant inside the constructor of InfoScheduleItem\n. Next major version (0.13) will use PHP7.1+, so we can start converting the code to PHP 7.1. Will this PR check pull requests only or will it fail builds after a regular push as well (if coding standard is not followed)?. Can you also add composer scripts for linting and fixing?. Yes. At least linting the whole project. We can probably add fixing the whole project later %). @simPod I've merged the PR, but it looks like it checks the whole project. Now build is failing on code style (with a ton of errors).\nI doubt that we'll have enough time soon to fix all code style errors, so can you double check that it actually only checks PRs and maybe send a fix for it?. Actually, ignore it. I commented out a check of the whole project. Only new PRs are checked for now.. Hey, we discussed this feature couple times. Please check #200 and #94 for reference.\nIn short, we discussed two ways how to do this at the library level:\n\n\nAdd a mechanism for logging and metadata collection (we'll do this after the reference implementation, see https://github.com/graphql/graphql-js/issues/284)\n\n\nLoop through all types in a schema and wrap all field resolvers of all types with apollo-metrics closure. Apollo JS server does this. The problem with this approach in PHP is that schema is created on each request (vs once in nodejs), so there is a huge overhead when doing so.\n\n\nCurrent workaround: wrap all resolvers in the userland code when defining a type.\n\n\nBut we've got type loading mechanism since then and I think we can do something else now: we can wrap type loader with our own closure which will, in turn, wrap all field resolvers of a type being loaded.\nSo any schema using type loading can benefit from it. It will be still not ideal in terms of performance (still have to loop through all fields of all types loaded during a query), but it will be way more performant than full schema scan.\nPRs are welcome! I guess we can just write a simple function somewhere under GraphQL\\Utils for such a wrapper.. Yeah, I guess such tool would be useful for starters to work with batching. Feel free to send a PR mentioning your lib in this section of docs and I'll merge it.. Closed via #298. At the moment - no. We didn't port buildClientSchema from the reference implementation, because it has way less value for the server implementation (even the name of the utility suggests this).\nI guess we could accept a PR for it, but any utility has a maintenance cost. So I am curious what is your use case? Why do you need it?. Thank you!. Hey, your PR fails code style checks ;). Thanks!. Thanks!. Best practice is not to look ahead %) It is rather fragile. But if you really need to, then scanning AST as you do is the only way right now.\nThere is #65 with an idea of a better API for this. PRs are welcome!. Thanks!. We follow graphql-js reference implementation which doesn't provide such tools at the moment. Following both Apollo tools and graphql-js is a bit too much for us in terms of maintenance.\nSuch extensions should be possible to implement separately, I encourage you to do so in a separate project. Will be happy to link to it in our complementary tools docs.. Actually, we do miss the documentation on how to implement custom directives. I created a separate issue to track it: #308 which may be useful for you once complete.. @rovansteen Please explain a bit more what you are trying to achieve, preferably with an example.. Yes, this type of custom directive is not an easy one at the moment, since it requires execution flow adjustment. There are various hacks, but no out-of-the-box solution yet. I believe the same applies to the reference implementation.\nWhat hacks you can apply at the moment:\n1. Composing resolvers. The common outer resolver can read directives from $info (4th argument of the resolver) and return null conditionally.\nBut it requires the field to be marked as nullable. It may be actually better than stripping the whole field out (as skip and include do) because at the moment all GraphQL tools expect a value (or null) for a field if it was requested. And only @skip and @include directives are allowed by the spec to exclude fields. So custom directive which removes a part of the response may be confusing to other GraphQL tools.\n\n\nPre-processing of the query AST. You can modify query AST and replace your directive with @include or @skip prior to execution. But if your logic requires the runtime value of the object (1st argument of the resolver) this method won't work, since it happens before the execution.\n\n\nPost-processing of response. With this method, the field is executed but stripped out later in another pass on the response data.\n\n\nOne problem with your approach is that directives should not break spec and the directive you describe will do so. So the solution described in my first example may be even more appropriate.\nAs for the ability to override parts of the execution flow... we will follow the reference implementation decisions here.. Looks like documentation was deleted here. I missed this, but will restore it as soon as I have a moment. Or you can send a PR to restore it.\nAs for other options - you can try wrapping typeLoader and enhance all type's fields on load. This is still  not ideal, but can work.. Thanks!. FYI, published this in the v0.12.3. Please share your use case for overriding internal types. We do have plans to allow overriding ID type (last time discussed in #217), would it be enough for you?\nIn short, internal types are static because they implement the spec. In theory, they shouldn't be overridden ever (except for ID which we will allow overriding in future). That's why I am curious about your use case.. Continue in https://github.com/webonyx/graphql-php/issues/401. That's an issue, I've missed it when reviewed 0.12 PRs. We should restore it. PR is welcome!. Released in https://github.com/webonyx/graphql-php/releases/tag/v0.12.4. Why not? We actually exclude ReactPromise from the default test group. But we still want to test it in Travis.. Because it is an optional feature which relies upon ReactPHP promises which is not installed by default (it is suggested in the composer config, not required). What is data provider? If you need to express some field as an array, just return an array from the field resolver (or return an instance of Traversable). GraphQL doesn't care where you get this array from, mysql, mongo or anything else.. This is likely a bug. Can you provide a smallest possible test case on how to reproduce it?. Initially, this server was supposed to mirror express-graphql logic. And they return status code 500 in such case (here).\nSo status 400 is obviously invalid. But the question is if we should switch to Apollo-style and return 200 or be compatible with express-graphql and return 500 (which is also more semantically correct for HTTP in case of execution errors).. How do you initialize your schema? If you use schema language, have you read this in docs?\nAnyways, it's really hard to help you without some code. Ideally a reproducible example.. If you use Schema Language and cache resulting AST (as suggested in docs) and then using BuildSchema tool - you shouldn't have any performance issues even with large schemas.\nBuildSchema produces a lazy schema by default. It only constructs types on demand during a query execution (unless you do schema validation or some other operations which perform full schema scan).\nThis is the most performant way to do this. There are some other possible tweaks, but they are mostly for memory savings, not performance.\nSo your issue is probably specific for your case. And in order to help you, I need to see some code example of how you use it.. Each app has very different requirements to date formatting (that's why DateTime has no __toString() method). We prefer staying close to PHP logic here and only convert things with __toString() method.. I afraid no. It is too much for us to maintain. But you can build a separate project on top of graphql-php (same as original apollo graphql-tools are built on top of graphql-js). Hey, it is very interesting! Curious to see your final benchmarks. But keep in mind that GraphQL execution is nuanced and has edge cases. So you can't be sure that you've got significant performance benefits until full test suite passes.\nAlso, one thing you should be aware of is that this project is a direct port of the graphql-js. So the executor mirrors their executor for about 95%. This was a pragmatic choice for us to make maintenance of this library realistic. And we try to keep as close as possible to the reference implementation exactly due to the cost of maintenance.\nSo for this PR to be merged into the lib, we must be sure that you will be ready to maintain it for some foreseeable future (meaning bug-fixes and keeping it up-to-date with the future versions of the spec). Because currently it's the matter of porting changes from the reference implementation, but if we switch to the new executor the cost of changes will be much higher.\nBut anyway, if you succeed with major performance improvements we can actually back-port them to the graphql-js and suggest for merging (since they have a similar issue - https://github.com/graphql/graphql-js/issues/723). So I am really curious to see your final results! \nNow back to your questions:\n\nValueNode interface doc comment says that VariableNode is a ValueNode. But VariableNode does not implement it. Is it intentional, or a bug?\n\nThis is probably a bug.\n\nThis might be quite a lot of changes. Is there a way to check code style? (I've run composer run lint, however, PHP-CS reported issues even with current files.)\n\nYeah, we just started integrating code style checks into the code base (#284). At the moment only Error and Server namespaces were cleared. Others are yet to come. You can use phpcs against your code directly for now.\n\nBut this would be big breaking change. Should I continue with stdClasses, or use arrays?\n\nWe'd like to avoid severe breaking changes. I guess it shouldn't be that hard to pass an array by reference instead of just stdClass or am I missing something?\n\nI started typehinting all new methods. But then I realized the library still supports older PHP versions. Is there a plan to drop old versions support?\n\nYes there is. Basically the next major version will require at least PHP7.1. Sounds promising! Will look into it closer when I have a chance.\nOne major issue for me though is that you got rid of PromiseAdapter. There are other projects already which depend on this feature, like dataloder-php + I know people who do use it with ReactPromiseAdapter in production.\nAlso, I am curious what would happen if we apply memoization for collectSubFields for list items. This optimization is actually already merged into graphql-js (here) but we didn't port it yet.\nWould be great to compare. By the way, do you have any benchmarking project? I'd like to play with it too, just need some common ground to check against.. Oh, ignore about promise adapter part, I see it is still there. Just misinterpreted your notes %). I did a quick benchmark and looks like the improvement suggested in the reference implementation makes it very close to your implementation (with slightly better memory footprint).\n+----------------+---------------------------------+--------+--------+------+-----+------------+----------+----------+----------+----------+---------+--------+-------+\n| benchmark      | subject                         | groups | params | revs | its | mem_peak   | best     | mean     | mode     | worst    | stdev   | rstdev | diff  |\n+----------------+---------------------------------+--------+--------+------+-----+------------+----------+----------+----------+----------+---------+--------+-------+\n| ExecutionBench | benchNewExecutor                |        | []     | 10   | 3   | 5,872,848b | 7.554ms  | 7.602ms  | 7.572ms  | 7.679ms  | 0.055ms | 0.72%  | 1.00x |\n| ExecutionBench | benchOldExecutor                |        | []     | 10   | 3   | 3,272,136b | 15.500ms | 15.765ms | 15.873ms | 15.909ms | 0.187ms | 1.19%  | 2.07x |\n| ExecutionBench | benchOldExecutorWithMemoization |        | []     | 10   | 3   | 2,959,416b | 8.673ms  | 8.754ms  | 8.786ms  | 8.809ms  | 0.059ms | 0.67%  | 1.15x |\n+----------------+---------------------------------+--------+--------+------+-----+------------+----------+----------+----------+----------+---------+--------+-------+\nI just pushed this memoized version to master. Can you try it against your complex query?. Apart from performance, also keep an eye on memory footprint. Looks like the new executor is much heavier in this regard.. Numbers are great! Still hesitate though if 10ms difference for your 150ms query worth the complete rewrite (and increased maintenance costs in future).\nBut if we continue with the new executor we will still give users an option to switch between the old and the new one (at least for 0.13.x). So it makes sense to put it alongside with the old one (i.e. in the ExperimentalExecutor namespace) and add a static method to switch implementations on demand.\nThe reason for this is that while a test suite should cover most of the edge cases, there are still unknown unknowns. Pretty sure we'll get unexpected issues and it would be nice if users could report them and switch to the old implementation without major efforts until we fix everything.\nAfter the adoption period, we'll remove the switch (probably for 0.14.x).\nPlease let me know if it works for you.. @Smolevich likely somewhere in September. But I plan to release the memoization improvement of Executor in 0.12.x branch in next couple days (since it's a cheap and fully backward compatible change). FYI, I will get back to this PR after porting all of the changes for 0.13, so that we only need to resolve conflicts once before merge. Will post another comment here when ready for merge.. After some thinking, I decided to preserve reference executor as a default one for the upcoming version. \nBut we will encourage users to try the new Executor in UPGRADE docs. Given their feedback and how things go, we may change the default implementation in the next version for all users.\nThe reason is that it is hard for me to read and understand the new code, so maintenance of the executor will be mostly on your shoulders. We must make sure this cooperation works smoothly before making it a default.\nSo if it works for you, can you rebase it onto master? I am ready to release 0.13.x. Merged, thanks!\nI did some further research and the interesting thing about new executor is that it traverses fields in a different order. ReferenceExecutor is a depth-first while new Executor does a breadth-first traversal (scoped to a parent).\nImagine the following query:\ngraphql\n{\n  a1 {\n    b1 {\n      c1\n    }\n    d1\n  }\n  a2 {\n    b2 {\n      c2\n    }\n    d2\n  }\n}\nThe old executor would traverse it as a1 b1 c1 d1 a2 b2 c2 d2\nThe new executor would traverse it as a1 a2 b1 d1 c1 b2 d2 c2\nI am curious if actual performance boost occurs because of this. Will do some research in my spare time.\nAnyways, this should be totally OK in theory, but we need to collect some real-world feedback on the implications of this. Do you use it in production already?. @jakubkulhan @simPod Code coverage dropped to 84% because it won't run tests against the new Executor. Any ideas if can we make code coverage run tests twice (with different environment variables)?. Anyone willing to send a PR for coverage fix in Travis config?\n@simPod I think I can live with doubling of the tests runtime (sorry Travis). . > Although I've made one addition to the code we run in production - result caching. It can bypass calling resolvers for whole sub-graph and read result from the cache instead.\nVery interesting. How do you invalidate it (for the whole subgraph)?\n\nNow that this PR is merged, if you'd be interested, I might send the PR with this change. However, it would be only for the new executor, I don't see how it would be possible to port this to the old executor.\n\nI think we can add it in the next version. For now, we should just collect some feedback on the new executor. But it sounds pretty exciting.\nOne thing I am interested at the moment is benchmarks for old/new executor (I am still curious to test my hypothesis about effects of traversal path on performance). If you did something already - would be very interested to see under benchmarks (should be easy now when they both located alongside).. We focus on core implementation. Even if you write something like annotation-based definitions you still need to convert them to the lower-level object tree. And this project provides such low-level core implementation (same as facebook's reference implementation).\nFeatures you describe should be implemented in separate projects. And in fact, there are several projects doing something similar. The first one is for Doctrine with annotations. And the second one uses Schema definition language (with Laravel).\nI encourage you to take a look at those or to create your own project!\nAlso, take a look at complementary tools section of the documentation.. @mcg-web Can you take a look?. @mcg-web What about QueryDepth?. I am curious about when Node classes produce errors in this case? Do you have an example?. Agree. Well if you face it again, please let us know when and why had it happened. Errors handler affects the result of the GraphQL operation only. If you need to apply custom logic to PSR response, you can use server helper methods. E.g. something along the lines:\n```php\n$server = new StandardServer($config);\n$executionResult = $server->executePsrRequest($request);\n$psrResponse = $server->getHelper()->toPsrResponse($executionResult, $response, $writableBodyStream);\nif ($executionResult->data === null) {\n    $psrResponse = $psrResponse->withStatus(500);\n}\n``\nBut keep in mind that if you use query batching$executionResult` may be also an array, so real code will be more nuanced.\nAlso note that the StandardServer returning status code 200 for partial result is perfectly valid. The server changes status code when there is no data to return. But there is also #309, so things may change.. Thanks!. I see what you mean, but GraphQL was designed without normalization in the first place. They do plan to introduce normalization in the reference implementation (see this thread), but nothing was done so far.\nThis subject is much more complex than what you are trying to do. Consider the following query:\ngraphql\nauthor(name: 'wilson rawls') {\n    firstBook {\n      __typename,\n       id\n       title\n    },\n  },\n  book(id:1) {\n   __typename,\n    id\n    year\n  }\n(and there are many variations of it, including fragments, interfaces and unions, etc)\nYou can't just reference a first entry, you must also ensure it has all the same fields as the second one, taking in account aliases. The truth is that if you need normalized data in the first place, GraphQL may be not the right tool.\nConsider falcor although I am not sure if there are PHP implementations of it.. Actually, normalization is not the only approach on the client-side. If your source of truth is on the server, you can have a client which avoids normalization step. I am pretty sure that GraphQL was initially designed for such workflow.\nBut then client developers decided to go a bit further than that and introduced the normalization stage. That's why I am not entirely happy with Apollo or Relay - they add significant overhead on the client side by using normalization and don't use strong parts of GraphQL, instead focusing on its weak parts (lack of normalization).\nIt is beyond my understanding why there is still no good client which would utilize the power of GraphQL to avoid complexity on the client instead of adding it.. While I like the idea of resolver middlewares, we will implement it only if the reference implementation does it first. So I suggest you post this idea in their GitHub. If they implement it - we'll do it too.. Error codes are the part of your application. So you define them in your own exceptions which you throw in resolvers. They are later available via $error->getPrevious() in the error formatter.\nIf you use a StandardServer, take a look at the errorFormatter option\nSo in your resolver you throw:\nphp\nthrow new MyException(\"Error\", MY_ERROR_CODE);\nThen in the error formatter you do:\nphp\nfunction (\\GraphQL\\Error\\Error $error) {\n    $prev = $error->getPrevious();\n    return array_merge(\n        $prev ? ['extensions' => ['code' => $error->getCode()]] : [],\n        \\GraphQL\\Error\\FormattedError::createFromException($error)\n    );\n}\nNote that the newer version of the GraphQL spec asks you to put your custom error data under extensions key (and apollo server does this).. Yeah, I meant $prev. Seet, thanks! But can you please change the target branch from 0.12.x to master? I don't think we'll do much work in 0.12.x branch anymore (just minor fixes).. Yeah, but those fixes will stay in 0.12.x, or do you plan to merge them later to master? Master is just quite far away from 0.12.x branch, so there will be lots of conflicts during the merge.. Yes, please. @simPod mind to review? As far as I remember, you've authorized Travis-related stuff.. Please let me know if it's ready to get merged. Restarted, but it had failed again (on coding standard step).. @spawnia I'd like to keep it backward compatible. Can you add RETHROW_INTERNAL_UNSAFE_EXCEPTIONS flag instead which would do what you want?. @spawnia Not really. Internal exception is an exception that is stored in $graphQLError->getPrevious(). I agree that $isInternal variable name was a bit misleading. It should have been named $isUnsafe instead.\nTo sum up:\n- internal exception is any exception thrown in the userland\n- unsafe exception is a subset of internal exceptions which shouldn't be displayed to users in production\nI guess it makes sense to update variable names accordingly.. Yeah, it should be the next power of 2 (since we use bitwise operations there). In our case it's 8 in the Debug class.. Nice, thank you!. Thanks!. Great job!. Default values for input type fields are not supported in the reference implementation yet. They must implement it first.\nAt the moment you have to define defaultValue at the field level of your parent object type. And it provides some ambiguity which has to be described in the spec first.. ```graphql\ninput Input1 {\n  a: String = \"a\"\n  b: String = \"b\"\n}\ninput Input2 {\n  a: Input1 = { a: \"b\" }\n}\n```\nIn the example above - what value will be in a.b of Input2? Will it be null or \"b\". There are many possible edge cases with nested objects with default values. I am talking about this kind of ambiguity. It must be clarified in the spec.. I've posted a link in my first reply where you can track this. I suggest re-opening it after related spec updates are published.. But if your $root['short'] is a closure, why do you call it as a string here:\nphp\n$str = $root['short'].\"and Long text\";\nOf course you'll get this error.. But in your case, they are on the same level. long and short will get the same parent value of the greetings resolver.. Serializing and unserializing the schema is not the best way to optimize performance. For big schemas, deserialization will be quite expensive by itself (maybe even comparable to new schema instance creation). I suggest you do some benchmarking here.\nThe recommended optimization strategy is to use type loading instead. Only requested types will be initialized during a query in such case.\nAlso, I am curious how do you serialize closures (fields, interfaces, resolver)?\nI feel that I may be missing something, if so, please clarify (code example would work best). I guess such kinds of tasks could be solved with code generation vs serialization. But we already had several requests for internal types overloading, so will think about it more when I have a chance.. Continue in https://github.com/webonyx/graphql-php/issues/401. @spawnia You are right - it can't. That's why we have types option in the schema config.\nIt is the only way to discover such orphan types.. @chrissm79 Please let me know if it works for you.. As far as I remember types can also be a closure. It is called after every other method of type loading. This way you can diff the list of types loaded with your typeLoader against the list of all types (I assume you have it from AST) and return only those types that were not loaded with typeLoader.\nWe were doing it previously in BuildSchema.. I guess these are two different issues?\n\nThe first error should be a graphql error, not an internal one\nChanging the shape of the validation errors\n\nAs for 1 - it is clearly a bug, we should address it.\nAs for 2 - I would say that graphql error is not for the end user, but for the developer. It is supposed that the client developer does this kind of validation in the client code and that graphql errors are not displayed to the end-user. They are more like 400 errors in HTTP.\n. > Validation always has to be done on the server. \nIt is. But there are two layers of validation. First one is a formal validation of the contract between the client and the server schema.\nOriginally it was supposed that a valid client always sends formally valid queries. Because it knows the schema (either ad-hoc or via introspection) and can enforce formal query and variables validity.\nSo when an error occurs at this level - it is a sign that the client logic is flawed. We do report such errors under graphql category, but those errors are targeted towards client developers (like \"your app is broken!\") and were not meant for runtime consumption.\nThen when a query is formally valid - other layer of validation (app-related) occurs during an execution step.\n\nWhat i am trying to do is to consume the validation errors provided by the server and map them back to the original form. The current structure of the error messages makes that quite hard and i think can be improved upon.\n\nOriginally those errors were not meant for runtime validation because you could have figured out these errors before the query was sent (i.e. via introspection or ad-hoc validation). But I do understand that it might be convenient to just rely on the server errors for pragmatic app development.\n\nWhat do you think about the format i proposed?\n\nI don't think it will work. At least not in this form. First problem is that locations is a stack, not a list. It is  meant to track an error within a chain of fragments. Add couple named fragments and spreads in your query with an error deep inside a fragment  with multiple references and you'll see what I mean.\nSecond problem is that path is execution-related. It points to an entry in resulting data, not in the query. So path like ['foo', 0, 'bar'] would point to foo[0].bar in the response data. But errors we discuss here are emited before execution and point to input path, not output (i.e. ['foo', 'bar']), so they should be named differently (maybe queryPath)\nAnd most importantly your format targets a different use-case. Current errors serve a specific goal of debugging invalid queries. Your format serves a goal of runtime validation. Those are two different goals.\nSo what could be done?\nI see a couple options:\n1. Implement a custom validation rule which would do all validations for a field argument and store user-friendly messages and queryPath in extensions. Technically it could collect all existing errors in ValidationContext of field or argument (on leave) and group them in a single error. This rule could be optional and would be backward compatible. PR for such rule is welcome!\n\nChange the client-side code to use introspection for formal validation instead.\n\nLet me know what you think.. > Can you point me to a resource where i can read more about this? Are there examples in the tests to look at? The spec does say that locations is in fact a list.\nYou are right. In general case it is a list, so it would work. Reference implementation mostly uses it as a stack to track an error deep inside fragment chain, but there are also situations when it is used as a regular list.\n\nThe format i propose does respect that, the path only contains the field\n\nWhat I am saying is that an error in the same field may produce different paths for execution error and for static validation error. For example we have a query:\ngraphql\n{\n  a {\n    b {\n      c(d: \"e\")\n    }\n  }\n}\nThen if an error happens in the field c during static validation the path would be [\"a\", \"b\", \"c\"], but if an error happens during execution the path for the same field could be [\"a\", 0, \"b\", 3, \"c\"] (if a and b are List types)\n\nI do agree that the use-case is different. Do you think that it is less useful for debugging queries?\n\nAt least it won't work well with GraphiQL and other general-purpose tools (since specific messages are in extensions).\n\nIf we do implement this with a custom validation rule, would that mean we have to disable the original validation rule?\n\nGiven what I see in your description, this would be an aggregate rule. We could probably directly inject other rules it aggretates. Then it is up to the app developer to choose which rules to use. But we can create several rule presets to reduce the hassle.. Also check out this thread as it is pretty much related. In PHP, just use regular strings with line breaks (or double quotes with \\n).\nIn SDL - see an example in tests (for version 0.12).. @mfn You are right, but this is just an illustration to focus on the main point.\nIn the real-life, you would use some external service injected to your type definition one way or another.. > When I use this approach, I still need to use a global singleton, otherwise how would I be able to access the same instance from different places\nNot sure why do you need a singleton? Just inject it via type definition constructor (or some setter). It is a regular dependency injection stuff. Alternatively, yeah, you could put those instances to context.. Great! Looking forward to the extendSchema feature!. While it makes sense, can you do some benchmarks with/without this check for, say 5000 ops (with both - hits and misses)? This resolver is used very often and every additional check would affect every project out there, so I am quite cautious about such changes.. > To implement unions, we have no way to have the type determined right now and if ArrayAccess'able objects are allowed, we could have a workaround that way.\nTechnically, you can set your own default field resolver if needed.. Actually I missed the point of your PR at first. Makes total sense for me now.. @gillesmaes I believe the coding style part (replacing \\ArrayAccess with use) is the only thing to fix. Then I'll merge it.. Cool. But looks like some tests are failing.. Great work!. Is it ready for merge?. One reason why instanceof checks were not used there in the first place was performance. I was 100% sure that strict equality checks were faster than instanceof.\nSo changes like this do require some benchmarking (and we don't have a good enough benchmark for such things in our phpbench yet). I think we need some bench for a query with ~2000 field calls (and ideally make sure all changed paths are affected).\nThose micro-optimizations seem minor, but when we sum them up and then multiply x 1000 (or more) - it becomes noticeable.. Those benches just test instanceof hits, not misses. There are actually several use cases we need to bench: hits, misses, hits and misses on the parent type (like a extends b, $a instanceof b). I think the latest one is the one we actually use the most.. I am on christmas/ny vacation at the moment, will get back to it later.. Both of your types: user and post must have fields as a closure:\n```php\n$post = new ObjectType([\n    //...\n    'fields' => function() {\n        return [\n            'author' => [ 'type' => TypeRegistry::userType() ],\n        ];\n    }\n]);\n$user = new ObjectType([\n    //...\n    'fields' => function() {\n        return [\n           'posts' => [ 'type' => Type::listOf(TypeRegistry::postType()), ],\n        ];\n    }\n]);\n```. Sorry I didn't look at your code at first.\nThe error is here.\nYou must replace it with:\nphp\n$this->setFields(function() {\n    return [\n        // your fields\n    ];\n});\nThe whole point of making fields a closure is to postpone creation of the fields array and thus break the cycle. But you do create it first and then return it from the closure.. You see the array created here?\nIt must be created inside a closure (which is called later - during query execution), but you create it immediately in the constructor at this line.\nSo what you get is a following sequence of actions:\nphp\nPostType::__construct();\n  TypeRegistry::userType();\n    UserType::__construct();\n      TypeRegistry::postType();\n        // And here the fun happens because constructor of the PostType (at the very first line)\n        // didn't finish yet, so there is no instance in the registry yet and registry \n        // attempts to create a new instance, hence the loop\n        PostType::__construct();\nYou get a cycle in your code before parent::__construct() is even called.. Thanks!. Weird, but the build is broken. Can you double check your changes?. FYI, I added a note in UPGRADE.md for 0.11 -> 0.12 upgrade about AST cache incompatibility. Thanks for bringing this up!. We had plans to fix couple more issues before the release but may choose to postpone them to future releases and release immediately instead. If so, we'll release it in the next week. But no guarantee here.. Yeah, sorry for the delay. Just published v0.13.x.. $value is something that YOU return in one of your higher-level resolvers. In your example - you return it in the resolve method of Query type. And you do return an array (not object). And it has no type field hence the error.. Either interface or union type is what you use for such things. Such cases are exactly the reason why abstract types exist. Modeling your API is not something the library can do for you. \nAlternatively split your model to something like this:\ngraphql\ntype PostDetail {\n  body: String!\n  otherAuthSpecificField: String!\n}\ntype Post {\n  title: String!\n  isPublic: Boolean!\n  details: PostDetail\n}\nAnd then return null in your details for non-public posts.\nAnother alternative (which is more a hack) - mark all fields (except title) as nullable and just return nulls for them when there is no access.\nThere are plenty of ways to model it, but that is API modeling which is your responsibility as an API author.. If you don't need a title, then you can just return an array with 10 entries, but have nulls in place of entries which user can't read (since your types are defined as nullable):\nphp\n[\n  ['title' => 'post1'],\n  null,\n  ['title' => 'post3'],\n  ['title' => 'post4'],\n  null,\n];\nAlso you may try returning an Exception in place of null:\nphp\n[\n  ['title' => 'post1'],\n  new Exception('You cant read this'),\n  ['title' => 'post3'],\n  ['title' => 'post4'],\n  new Exception('You cant read this'),\n];\nIt will still return nulls in the final result but will also add two entries in errors section of the result.\nAnd yet another way is to have some field defined as non-null in your Post type and then throw there:\ngraphql\ntype Post {\n  title: String!\n  body: String!\n}\nIf you throw an exception in body resolver, the whole post in resulting list will be replaced with null (since post is nullable) and your error added to result errors.. Can I see the original error message and a stack trace of this internal error? (see here how to get it) My gut feeling is that we can just fix the underlying bug causing this to get proper error messages.. But how about the stack trace?. Thanks! Hope it will improve the UX for all library users.. This error means that you unintentionally create multiple instances of the same type (either somewhere in your type definitions or in your resolveType method). Instead of creating new type instance you must always re-use the same instance of a type (within one schema).\nSo double check where your types are being created (with the new keyword). My first guess is that you do it somewhere in the resolveType method of your interface type.. This should definitely work with mixed types. Can you create a reproducible test case for it (either in a separate github project or ideally as a phpunit test case)?. Both of the following forms should work (on v0.12.x), please try:\n```graphql\nmutation {\n  sendEmail(message: \"Hello,\\n  World!\\n\\nYours,\\n  GraphQL.\")\n}\nmutation {\n  sendEmail(message: \"\"\"\n    Hello,\n      World!\n     Yours,\n      GraphQL.\n  \"\"\")\n}\n```\nBut yeah, the best way to work with mutations is to send variables along with mutation string.. The best thing you could do is to add a test case in ParserTest to demonstrate the issue. Then it should be easy to fix.\nI guess I can add one myself when I have a chance, but not sure when I'll have time for this.. Why do you need the schema cacheable? Serializing and unserializing the whole schema will be not much more performant than creating one in the runtime. The most performance gains are possible from the type lazy-loading. Serialization won't give you much performance wins.. Also, take a look at this thread on performance optimizations. Can you add a test case for this to avoid regressions in future versions?. Thanks!. We actually have a bunch of tests for deferred lists resolving.\nI bet there is some bug in your code, but in order to help you find it, I need a reproducible test case or at least a repository where I can reproduce it.\nInformation in issue description is not enough to figure out what's wrong.. But how it can process id or handle without the corresponding event data? I feel that you misunderstand deferreds, but not sure how to help you here.. One comment I have though is that building SQL for a whole query is usually a bad idea. The best performance achieved usually by using multiple simple (and properly indexed) queries and using IN(?) for batching. Such queries can also be cached easily (and benefit from dataloader approach).\nDynamic query building is very limited (especially if you have abstract types in your schema). I think you faced those limitations already. Also, performance won't be stable because it is hard to build indexes for such queries.. As for Feature Request: Directive Visitors / Resolvers - it basically asks to port schemaVisitor from graphql-tools. But it doesn't require changes in this library core. Anyone can implement it on top of graphql-php library similar to how graphql-tools utilize graphql-js.\nWe just don't have resources to maintain all the features and 3rd-party projects inside this core library. But someone else can do it in a separate project (same as apollo does in their separate projects - they just wrap graphql-js)!\nThe thing is that if you have single core library - you get single project like graphql-tools built on top of it. But if you have multiple core libraries - each of them will require such higher level tools implemented independently. In reality you won't get 3 graphql-tools-php, you will probably get one for one core library, then you will have other useful higher-level library written for the other core-library. Hence fragmentation.\n\nI think both goals are reasonable. It's very reasonable to focus on following the reference implementation. It's also very reasonable to want the community to invest in a single GraphQL implementation and expand it to meet people's needs.\n\nNot expand it, but build on top of it the same way Apollo builds on top of graphql-js. The core library should provide spec-compatible means to extend it.\n\nBut those two goals are fundamentally in conflict. \n\nWhy so? I don't see any arguments in favor of this claim.\n\n(I think Apollo is pretty good proof that the reference implementation doesn't adequately meet people's needs.)\n\nApollo uses reference implementation under the hood basically everywhere. They don't replace it. They build on top of it.\nOne problem with the reference implementation (which we probably inherited) is that they include too much in their core. Things like buildSchema or findBreakingChanges are useful but they are not a part of the specification. So they could have put them in some other repository instead. Apollo do replace some of these tools (at least buildSchema), but that just prooves that the core includes too much now.\n\nCould you please clarify which of the two goals is going to be your primary focus going forward?\n\nSine I don't see a fundamental conflict in those two goals, I can't give the answer you would like.\nOur goal is to be fully spec-compliant but at the same time be open for spec-compliant extensions. The easiest way to be spec-compliant is to follow the reference implementation. But if reference implementation doesn't allow some spec-compliant extensions we are open to deviate from it (as we did with buildSchema by allowing $typeConfigDecorator argument which doesn't exist in the reference implementation).\nBut the truth is that the most important features eventually show up in the reference implementation itself! We had multiple sitations like this (in early stages of the library life) when we implemented some feature which was missing in the reference implementation only to find out that they added it later in a slightly different way and we had to introduce a BC break.\n\nIt also tells me that maybe I should seriously consider another library if it provides features I need that I feel this library is lacking (case in point, easy support for custom directives).\n\nOnce again - if you are talking about #299 - you can implement it yourself on top of this library same way as apollo implemented it on top of graphql-js. If you won't be able to do so because of some of the library limitations we are ready to introduce API changes required for you to go forward.\nEven with this example - Apollo team didn't open PR in the reference implementation asking to include this feature, because it is unnecessary.. > The thing that really stands out to me is that the features in question are very similar between the two threads: one is discussing directives including schema directives, whereas the other references schema decorators which are functionally very similar to schema directives.\nFirst of all, schema directives are already supported in the core. It's some convenience tools that are missing and which were proposed as a feature request in #299 (and they can be implemented on top of this library by anyone as I already mentioned).\nSchema decorators, on the other hand, is the spec-incompatible proposal. They are indeed hard to implement in the webonyx core because they break the GraphQL specification. Technically it was an experimental fork of the GraphQL itself (which was later proposed as a PR in graphql-js, which later turned into schema directives).\nThere is little benefit allowing spec-incompatible extensions points in the library core (like customizable parsers). You can still do it by forking the library and then proposing your experimental features to GraphQL spec (which would later show up in the reference implementation if accepted).. Thanks!. You could define types as a closure (which is called when such situation happens). If it doesn't happen, then those types won't be loaded. But yeah, this is an edge case which is hard to combine with lazy-loading.. Consider the following query:\n```\nquery {\n  ...F1\n  ...F2\n}\nfragment F1 on T {\n  field1\n}\nfragment F2 on T {\n  field1\n}\n```\nWhen field1 is resolved in the query which node should be in the fieldNode?. Yeah, you are totally right. We added our custom entries to error when there was no specification for extensions. Now that they added it we'll have to adjust. But that would be a breaking change, so we'll introduce it in 14.0. Actually we already have a breaking change about extensions, so I decided to include this in the 0.13 release. But only category key will move under extensions.\ndebugMessage and trace will stay at the top level because they are not intended for production and the UX of debugging with those items moved under extensions will degrade significantly.. I do see a value of the code of conduct when a community grows significantly and formal rules become necessary. But I don't think we need it yet. Code of conduct and other unnecessary \"rules\" also create an impression of a formal and unfriendly environment. So I would really postpone it until necessary.. But can't you already do the same using __invoke for such classes? A resolver is basically any callable, so you can wrap it as you want. Or am I missing something?. Thanks!. This is awesome! We actually have related issue https://github.com/webonyx/graphql-php/issues/70 but having such tools in a separate repo makes total sense to me. So I'll close it and recommend using your library instead.\nPlease post a PR with a link to your project in complementary tools doc.. From what I see the Folklore code causes an infinite loop. You should raise this issue in their repo. Thanks!. What is the scope of proposed changes? I suggest you start a PR with a couple of examples so that we could understand better what you mean.. We actually have a dedicated page for such tools at https://github.com/webonyx/graphql-php/blob/master/docs/complementary-tools.md. Use GraphQL::overrideInternalTypes(array $types) before any type definitions (or introspection calls). But note that this is just an escape hatch until we find a better way to do this.. But can you share what TypeError do you get there (message, trace)? Your fix won't work for everyone as ExecutionContext is expected to contain GraphQL Errors only.. The idea is that you don't run queries against an invalid schema. We don't have runtime validation of the schema because of performance. But you should do it separately via $schema->assertValid(); during development.\nPlease try it and let me know if it reports an appropriate error. If so then this is not a bug.. This is a nice feature, but it is not supported in this library. There is a related issue in the reference implementation: https://github.com/graphql/graphql-js/issues/113\nI think we'll wait until it is resolved there. Feel free to re-open when it happens.. What kind of error is this? Is it PHPStan?. This is actually an expected behavior. The path shows which data entry produced an error. It doesn't route back to the field of the query (location does that), it allows you to find an entry in your result which caused an error. So aliases and array indexes are both valid elements of the path.. FYI, path is defined in the section 7.1.2 of the spec:\n\nThis field should be a list of path segments starting at the root of the response and ending with the field associated with the error. Path segments that represent fields should be strings, and path segments that represent list indices should be 0\u2010indexed integers. If the error happens in an aliased field, the path to the error should use the aliased name, since it represents a path in the response, not in the query.\n\n. I guess it is a feature request then, not a bug report - please create another ticket for it as this one is a bit misleading.\nActually I am quite curious on what are you trying to route at all? Resolvers require just type and field names. There might be endless variations of paths in graph (especially if they are cyclical). So routing resolvers by the query field path might be not the best idea.\nBut even if you try it - I afraid that field path is not enough for your use case. Because there are abstract types. Consider the following schema:\n```graphql\ntype A {\n  a: B\n}\ntype B {\n  b: C\n}\ninterface C {\n  c: String\n}\ntype C1 implements C {\n  c: String\n}\ntype C2 implements C {\n  c: String\n}\n```\nAs you see a.b.c qualifies for both - C1.c and C2.c.. Thanks!. Makes sense to me, thanks! As for #398 I suggest you to send such small PRs if possible - they are focused and easy to review.. What version do you use?. There were some changes related to argument errors in 0.13.0, please check it when you have a chance.. Closing, but feel free to re-open if it is still relevant.. @jakubkulhan Could you please review it?. This is a breaking change which seems unnecessary at the moment. We can probably merge it before the next major release, so I'll keep it open until then.. This is also an unnecessary breaking change. I'll postpone it till the next major release.. You are right here. Types are being initiated on fields closure call. So even if you request single field of a type, all types for those fields are being instantiated.\nBut instance creation is not expensive. It's fields, arguments, and interfaces which add significant overhead. If you don't create them on type instantiation you should get a significant performance win (which we benchmarked).\nWe actually considered loading types by name, but it didn't pass a cost/benefit analysis at the moment (wins were little, costs to implement were relatively significant).\nAnyways, if you do some benchmarks, illustrating the opposite we can get back to this idea. But we really need some numbers to back it up.. Awesome, thanks!. Keep in mind that lists in JS and arrays in PHP are a bit different. You can't have gaps in JS arrays. If you write:\njs\nlet a = [];\na[2] = 'foo';\nYou will actually get a list of [undefined, undefined, 'foo'] which is not the case with PHP arrays. So indexes in the reference implementation are actually implicitly preserved, so no error there.\nAs for our implementation - we must enforce GraphQL spec which requires lists to be ordered. In other words, we must translate any PHP array with any custom keys to a simple ordered list (which is later transformed properly to JSON list). If you keep keys you will actually get JSON object vs list which causes lots of possible issues on the client (which expects list, but receives object).\nYou can see what I mean by running:\nphp\n<?php\n$a = [];\n$a[2] = 'foo';\necho json_encode($a);\nSo we are forced to reset keys here. Another option is us being more strict and forcing users to return ordered lists (throwing otherwise). But that's a bit too much as for me.. Yeah, you are correct, forEach seems to ignore keys. Then it could indeed be a potential issue in the reference implementation.\nAnyways as for our library, I've posted you an example explaining why we reset keys.. I think such change requires a test case with a link to this PR. Otherwise, it can get erased when we port changes from newer reference implementation versions.. It should be really straightforward to do in the userland by utilizing context. Something along the lines:\nResolver:\n```php\nuse GraphQL\\Error\\Error;\n'resolve' => function($parentValue, $args, $context, $info) {\n    $context->errors[] = Error::createLocatedError('Error message', $info->fieldNodes, $info->path);\n    return '';\n}\n```\nThen when you run the query:\nphp\n$context = new MyContext();\n$result = GraphQL::executeQuery($schema, $source, null, $context);\n$result->errors = array_merge($result->errors, $context->errors);. Yes, this was a breaking change. But it was intentional. We had to ensure that executeQuery always returned ExecutionResult and never returned a promise. A counterpart method promiseToExecute was added which always returned a promise, but also accepted a promise adapter as an argument.\nWe should have added a note in UPGRADE.md about it though. Feel free to send a PR with such a note.\nThe change you propose will introduce another breaking change and will get us back to the mess with multiple possible return types (array | Promise<array>) which is something we'd like to avoid.. Nothing out of the box. But it can be done.\nThis library uses Promises as an abstraction for concurrency. If you can manage to implement a promise engine with pthreads and then write an adapter for this library - it can work.\nI've seen the only implementation of promises with pthreads so far. You could try those and write a promise adapter for this lib (check out React PHP promise adapter as an example).\nLet me know if you have questions.. Closing due to inactivity. You are right, thanks!. This is great! I need some time to digest it before I can post any feedback or merge. Thanks!. Fair enough. Thanks!. Thanks!. Can we mark nightly builds with \"allow_failures\"? As they fail %). Thanks!. Cool, thanks!. This feature is available through the server. Read about persistentQueryLoader option there.\nBut it only integrates the loading of a query. Saving is individual per project, so it's up to you how to implement persisting.. This is out of the scope of this library. We aim to provide core features from the spec and graphql-js. \nYou can implement persisting as a separate project. Look at what apollo-server does for the reference. If you do implement such a server, please let us know and we'll add it in the complementary tools section in docs.. Done, thanks!. There is a SchemaPrinter utility. Check it out in docs. It will print SDL-representation of the existing schema.\nIf you need other types of documentation - there are separate tools (i.e. graphdoc). Check out more examples in the awesome-graphql repo. Yeah, switched to the new packagist syncing method (using webhooks). Thanks!. Awesome, thanks!. > How we can fix this at the package?\nUpgrading to the latest version?\n. If you are having trouble updating you could also fix it yourself by sending a PR in the 0.12.x branch and I would release a new patch version for 0.12.x. This library implements GraphQL spec which doesn't have support for module imports at the moment. Apollo example is based on comments. Technically you could do it yourself by analyzing resulting schema AST and merging ASTs of \"imported\" files.\nBut the simplest way is just to concatenate graphql files manually into a single string before parsing.\nAs soon as GrahpQL spec introduces imports we will implement them.. > I have the following resolver class:\nYou didn't explain where did you use it so I have to guess a bit.\nI assume you had assigned it to the resolveField of the User type. User type has no field user hence your case 'user' is never reached. Field user exists only in the Query type. You shouldn't use the same resolver for the fields of different types.\n\nThe first problem is that by default GraphiQL returns this error:\n\nUse debugging tools during development.\n\nProblem with this is that I want to use the type langauge so I have to use a custom resolver.\n\nSome hints on how to use custom resolvers with type language in docs\ni.e.\n```php\n$typeConfigDecorator = function($typeConfig, $typeDefinitionNode) {\n    $name = $typeConfig['name'];\n    // ... add missing options to $typeConfig based on type $name\n    if ($name === 'Query') {\n        $typeConfig['resolveField'] = new MyCustomResolver();\n    }\n    return $typeConfig;\n};\n$contents = file_get_contents('schema.graphql');\n$schema = BuildSchema::build($contents, $typeConfigDecorator);\n```. Default resolver is called for all fields which do not have their own resolvers. It is not recommended to use it the way you are trying to use it.\nI already posted you a preferred method of defining resolvers with schema defined via type language (see example in my previous comment).\nWith your current setup you'll have to check for both - type name (via $info->parentType->name) and field name ($info->fieldName) for custom resolve logic. And, the most important part - you must still resolve all other fields of all other types (see here on how standard default resolver does it).\n. GraphQL is about returning only what is requested. That's why resolvers are always defined on a field level, not a type level.\nYou may have 100 fields on a type, but if only 2 of them are requested in a query you don't want to fetch data for all 100 of those fields.. We actually have #436 which is a good fit for such use-case. Once it is merged we should consider adding a corresponding method to it.\nRight now the workaround is to create your own validation rule similar to QueryDepth and manually set max depth to your $context (3rd argument in resolves) after validation but before execution.. Makes sense for me. PR is welcome!. Thanks!. How do you JSON-decode those variables? This library expects variables to be decoded as an associative array:\nphp\n$variables = json_decode($variablesJSON, true);\nWe should probably communicate this somehow either via docs or via a descriptive error message (or both).. @simPod Yeah, we'll merge it in 14.0.0. Technically, we need to check for Traversable interface here, not ArrayAccess, because all we do later is iterating $result in foreach loop.\nWill merge this pull request if you change it to Traversable.\n. Can you replace $fragmentType . ':' . $name with just $name? Otherwise it breaks the contract of this function (where you could just query result by field name).\n. You are right. Need to think about it before merging\n. That is the part which makes me wonder. Calling wait here basically means resolve promise right away. It won't execute any fields in between resolve and wait calls. So there is no deferring/buffering actually. Am I wrong?\n. Looks like your example passes promise to nested field resolvers. I didn't think about it this way, as I only considered examples where resolvers received actual parent value (resolved promise value, not promise itself).\nThis is interesting approach. I do have doubts about it, yet I am really interested to see where it leads to. Looking forward to see your concrete examples!\n. Cool. I will be able to play with it somewhere on weekend.\n. I just realized that we must also cover case when fields and interfaces are defined via Closure. I guess addField is not enough here. I only see following as a solution, but maybe you have other ideas:\nphp\n$config = ObjectTypeConfig::create()\n  ->name('Test')\n  ->fields(function() {\n    return FieldsConfig::create()\n      ->addField('name', Type::string(), null, null, ArgsConfig::create()\n        ->addArg('arg1')\n        ->addArg('arg2')\n      )\n    );\n  );\nThen we can re-use FieldsConfig for interface type\nEdit: another possible approach:\nphp\n$config = ObjectTypeConfig::create()\n  ->name('Test')\n  ->fields(function(ObjectTypeConfig $conf) {\n    return $conf\n      ->addField('name', Type::string(), null, null, ArgsConfig::create()\n        ->addArg('arg1')\n        ->addArg('arg2')\n      )\n    );\n  );\nNot sure what complications it might cause though.\n. Another thing to consider is if we should put resolve as 3rd argument. The reason is that we also have resolveField callback in type config which makes resolve unnecessary (I personally prefer to use it vs resolve).\nDo you have any objections if we put $resolve after $args so that all definitions go first and callbacks after them?\n. I would also suggest to introduce addDeprecatedField() to make it visually different from regular fields. Then we'll have two methods:\nphp\naddField($name, $type, $description = null, ArgsConfig $args = null, callable $resolve = null, callable $complexity = null)\naddDeprecatedField($name, $type, $description = null, ArgsConfig $args = null, $deprecationReason, callable $resolve = null, callable $complexity = null)\nPlease let me know if it makes sense for you.\n. And yet another idea is to have some facade class which will allow us to avoid remembering ObjectTypeConfig, FieldsConfig, ArgsConfig, etc.\nMaybe some Config::objectType(), Config::fields(), Config::args() etc. Then we only need to use one class and can rely on autocomplete for different config sections. If it makes sense.\n. Sorry, couldn't find time on week-end, as there is lot of work now, but I remember about it %)\n. Just curious why do you do this? I've never seen a standard for coding style that enforces this. This repo is expected to use PSR for coding standards, which only requires line after namespace definition.\n. Do agree with this whole commit. What can I say - I miss arrow functions in PHP %)\n. @mcg-web I played a bit with your example. It appears that it doesn't actually defer fields execution. You will see what I mean if you change your query to the simplest possible variant:\ngraphql\n{ \n  character1: character(id: \"1000\") {\n    name \n  } \n  character2: character(id: \"1002\") {\n    name\n  }\n}\nSolution with deferred fields would do 1 round-trip to storage, but both examples do 2. Query with friends actually never defers too - I put a breakpoint to friends resolver and $character argument never arrives as promise - only as array value.\nThe number of requests in original examples vary that much due to cacheMap in dataloader and lack of IN(?)-style request of friends in without-dataloder example.\nI expected this because implementation of deferred fields just can't be that simple %) Though maybe I am missing something.\nAlso real test for deferreds should include at least following examples:\ngraphql\n  stories {\n    author {\n      name\n    }\n    likers {\n      edges {\n        node {\n          name\n        }\n      }\n    }\n  }\nIt covers different cases, including one where deferred entities are on different levels of query.\n. Sorry I didn't realize it is not complete yet.\n. I afraid this breaks spec compatibility in section about field execution order. \nThe basic idea is that root-level fields of mutations must be executed sequentially, but with this change order of their execution is not guaranteed (since if some field returns Promise we delay it until other fields complete).\nPreviously we always had sequential execution but with promises it is not the case anymore. So executeFields and executeFieldsSerially must behave differently.\nCan you change it to behaive according to spec?\nAlternative option would be to disallow Promises returned from root-level fields (for mutations only), but such limitation seems unnecessary.. One problem I have with wait method is that it only makes sense for sync environment. But if we integrate complete Promise support it doesn't make sense as a required part of Promise interface (say ReactPHP promises do not have to wait).\nOther problem is that we will likely need to create promises in Executor some day and then single PromiseInterface will be not enough. \nI had an idea to introduce PromiseAdapter interface instead of PromiseInterface, something along these lines:\nphp\ninterface PromiseAdapter {\n  public function isPromise($value);\n  public function then($promise, callable $onFulfilled, callable $onRejected); // -> Promise\n  public function runTillCompletion($result); // this is the same as current Executor::completePromiseIfNeeded\n}\nThis gives several benefits comparing to PromiseInterface:\n1. runTillCompletion can be optional depending on platform\n2. We do not need PromiseWrapper\n3. Obviously we can add other methods here like createPromise() or createRejectedPromise(), etc if we need to extend implementation (so no new abstractions are required).\nConcrete instance of PromiseAdapter will be injected to Executor.\nDefault NoPromiseAdapter will just throw on attempt to then and pass-through $result in runTillCompletion. GuzzleSyncPromiseAdapter can leverage wait, etc\nDoes it make sense? I'd like to hear your thoughs on this, maybe there are some cons which I didn't notice?. Hey I like your library - it's interface is similar to what I imagined. So we are likely thinking in the same direction.\nBut I'd like to avoid external dependencies for GraphQL lib. Actually I considered adding very simple and limited implementation for our sync case as most of the users do not need full-featured promises in sync environment.\nSo I'd really like to have some abstraction for Promises as a part of this library.  We can add your lib to composer suggests entry for those who need full-blown promise support.. As for wait method. My point about wait as a part of PromiseInterface is that in event-loop environment you do not need to block ever. In ReactPHP you would expect something like this:\nphp\nGraphQL::execute(...)->then(...)\nYou don't want to block untill all of our promises are resolved.\nAlso wait is simply not a part of common Promise interface. If you check ReachPHP promise interface or Promises A+ spec - they do not mention wait or block.\nGuzzle does, but that's because it works in non-event loop environment. And even their promises docs mention wait in section called Synchronous Wait. They had to add it, because Guzzle HTTP client is often consumed from sync environment where devs are used to do things synchronously.\nOf course you could force all promises to implement blocking wait, but for platforms with event-loops it would be an unnecessary limitation.\nAlso I don't think that your implementation of await for ReachPHP actually does what it claims to do, as it doesn't seem to block.\nAre you sure it works as expected in ReactPHP? As for me it looks like it will work only with resolved promises, but not those which are still pending. Though maybe I am missing something.. Please rename interface to PromiseAdapter. We don't use Interface suffix anywhere else in this code base. Also we should move Promise namespace to Executor\\Promise as it will only be used during Execution step.. It is a relaxed requirement, all existing calls to this method will work as they do now. I don't see how it is a BC break?. In theory this is possible, but we use this class as a container for pure stateless functions and reference these static methods directly by class name, so it doesn't imply any polimorphism. It is implicitly final. But yeah - we should probably mark such classes as final explicitly.\nAnyway it's too late: I released 0.9.4 even before your first comment %) But I am sure it won't break anyone, so let's cross the fingers %). This looks like a perfect InvariantViolationError for me, as it's server developer error (in type definition). Is there any reason why this must be UserError?. Yeah, I suspected that memory problems are possible with this approach (had previous experience with preg functions behaving unpredictably on large strings), but didn't have a chance yet to test it myself. Good that you found this issue before merging.\nI guess we should write own utf8 stream to actually resolve the issue.. @aelnagger I started experimenting with separate utf8 stream, but we should avoid duplicating our efforts, so please let me know if you are working on other solution now? If not, I'll continue.\nAlso, couple notes on best practices (regardless of our final solution):\n\n\nGraphQL queries shouldn't be big. We should use variables as much as possible instead of inline values (because variables are parsed on C-level by json_encode).\n\n\nIdeally parsing should be done by C module, so the most important issue for performance is #108. When it is implemented you should be able to use PHP module for parsing (e.g. https://github.com/dosten/graphql-parser-php) and then just pass this array to validation/execution steps.. I've built a proof-of-concept version without mb or preg usage, which shows good results (see https://github.com/webonyx/graphql-php/issues/137#issuecomment-310839638). Will push it to new branch for v0.10.0 when ready.. I don't think it's worth adding $code argument to GraphQL\\Error\\Error. This exception is for internal library usage and we don't use exception codes in the library.\n\n\nInstead, I suggest to include the code in formatted error only if there is a previous exception and this exception has a code. \nSo the only place which should be adjusted is GraphQL\\Error\\FormattedError. I am not familiar with overblog bundle as I don't use Symfony, but if you point me the line where it is misused, I'll take a look. Well looks like they just replace a message of some exceptions to \"Internal server error\". They don't use exception code for GraphQL\\Error\\Error as well. The way they use this class is aligned with the way how we use it in this library.\nI still don't quite understand why do you need code for base exception vs just using the code of the previous one?. I do understand this. And you can access this code from $error->getPrevious()->getCode(); right in error formatter. You don't need to add $code argument to constructor of GraphQL\\Error\\Error for this.. This is not spec-compliant. Enum names must be alpha-numeric strings.. How is this function different from regular map() in the same class, they look identical?. Thanks! But can you replace this with just json_decode($raw, true) ?: [] and remove these comments, since we use comments in examples to explain how graphql works vs php internals?. Empty is a bit too loose. I guess we should check for null only. Thoughts?. Yeah, you are right. Had no idea that ${typeName} is a valid form of variable interpolation in PHP. Cool %). Those paddings after the => are a bit insane. I understand when they are required for one-liners, but in this form when closures span multiple lines, they make so little sense. Are they really required by Doctrine CS here? Any way to ignore this rule? If not, I can still live with it, but it is still insane %). Is there any particular reason for this method? It makes AST a bit inconsistent since all other attributes are available as direct public props. I'd prefer to keep public props in AST (for performance considerations), but maybe there are arguments I am missing currently?. I do understand the motivation for this change, but an old form was chosen for performance. This method is called so many times during query execution that micro-optimizations which are usually unnecessary do make sense here. Can we optionally ignore code style checks for such intentional things?. Actually, your link says that getters do add a quite significant overhead to performance (8.21 vs 11.08 seconds in tests).\nAnd that's actually the main reason why AST is designed like this (without getters). PHP is not the best language for projects like this, so we really have to sacrifice some of the best practices for performance gains.\nSo I would actually suggest reverting the getKind() getter. And it's better to separate the work on the code style from changes to interfaces and logic, because those require some benchmarking first.. The new version is OK for me. Thanks!\nP.S. I used to write the code with paddings like in this code style, but it was such a pain when you renamed something, that I abandoned it. Suprised that Doctrine uses it, but I guess I can live with it with a help of IDE and auto fix.. Sure. Please do not delete those comments in tests. They are very helpful when migrating tests from the reference implementation.. I think we should use (bool) $value with a new code style. ! ! $value looks really weird. I am curious if this style of logic is recommended by the coding standard (when you return or continue and leave the main logic at the bottom of the function / loop)?. It contains the name of the mocha test case from the reference implementation. I.e. it('uses the stack of an original error').\nThis way it is easy to find the same test case in the reference implementation to check if something had changed there.. I don't care much as long as the original test description is preserved. I obviously know this style, but there is a long-living debate over \"should we minimize the number of returns in function\" vs \"should we prefer early exits\".\nSo I was curious if it is dictated by the coding standard or if it is your preference in this regard?\nI personally debug with simple dumps (sometimes) and such style makes it harder to find out return value of the function because you have to print near every return.\nAnother reason why this is written like this is a reference implementation - some functions mirror it almost exactly, so it is way easier to map changes back to their code when needed (and they don't use early returns).. So it is a sniff from the coding standard, right?\nReference GraphQL implementation. Ok, then we shouldn't disable it. Let's stick with the standard.. We removed this. Bin dir is now just a default composer vendor/bin. Why removing this?. oh, I see now. @mcg-web I don't think it's the case. It only throws this error when you check against constant (like null instanceof ArrayAccess).\n. You are trying inline values, but if you try any variable, it will work (I spelled it wrong - I meant not constant, but any inline value).. Maybe rename $iValue to $spread?. Actually, I've missed this part during a review. I'll restore it to the original version since instanceof is 2-10 times faster than is_callable() (and that's a reason why it was there in the first place). Actually, we don't use carriage returns anywhere, so \\n is appropriate. PHP_EOL is not for our case. I'll revert it.. We actually reverted is_callable() here back to instanceof Closure. Please revert this part and I'll merge. Thanks for noticing!. It doesn't bother me much, but just curious - is it phpstan requirement and we'll have to stick with it or just your preference?. @simPod I am travelling at the moment, so not always available. We shouldn't rely on static $fieldName here. In theory, you may have multiple rules running in parallel which would break with static variable here. See below for suggestions.. This message should be in a separate function (like badArgumentValue). Also, those functions shouldn't contain any logic related to errors - only formatting logic. The logic of triggering an error should be defined in the visitor.. You could put $fieldName at the top of the visitor function and then use it inside closures instead of having it defined as static.. Could you also change mixed[] to mixed for the $rootValue as it has the same issue?. $rootValue here should also be typed as mixed then. Why deleting this? Can't you just add queryPlan key to this list?. Sorry, missed your reply. Makes sense.. ",
    "TimothyKrell": "Thanks for the reply! I'll definitely do a pull request if I get there first, but I'm much more of a novice at PHP. Thanks for this library! I'm currently testing using it with out Laravel backend.\n. @arec, could you post a gist or something with your code for the NodeInterface, connectionTypes, and mutationTypes so I could see how you are doing it?\n. @ivome Nice! Can't wait to see what you come up with.\n@vladar Thanks for this awesome library. Currently I've been using these Laravel specific packages based off of your port:\n- GraphQL: https://github.com/Folkloreatelier/laravel-graphql\n- Relay helpers: https://github.com/nuwave/laravel-graphql-relay\nYou might want to add those to the Readme as well.\n. ",
    "arec": "I've already done this with a bit help from graphql-lavarel. Here are few things missing that I've done:\n1. [MOST IMPORTANT] a function to export a schema.json file for RelayJS. I'm currently using a really BIG QUERY to generate it. \n2. NodeInterface\n3. tool to generate connectionTypes and mutationTypes \n. Great thanks. Never notice that REALLY BIG QUERY is right there!\n. same issue observed\n. ",
    "beeb": "@arec +1, I'd really like to see what you've done!\n. ",
    "Gugudesaster": "Does anyone have a solution or workaround here? I would really like to play around with graphql and relay, but can't seem to get it working with the current package.\n. ",
    "ivome": "FYI: I'm currently working on an exact port of https://github.com/graphql/graphql-relay-js to PHP based on this repository here. Should be there soon... \n. I'm not done yet, but I just published the repo: https://github.com/ivome/graphql-relay-php\nThe basic helper functions are all in place along with their tests. There are still a few things left to be done. Especially documentation is lacking. If someone wants to help, check out the issues: https://github.com/ivome/graphql-relay-php/issues\n. Awesome, thanks for the quick fix! I found one more for InterfaceType, besides that, all other closure issues seem to be resolved with the latest fix. :+1: \n. The idea with wrapping all resolve methods could work, but seems a little bit hacky and repetitive. I think the best place for that would be the executor. \nMaybe we can add some functionality that enables us to use different executors that can optionally be passed to the execute function. That way we could have one that has complexity tracking built in and another one, that has the current implementation. With multiple executors we could also prepare for a future PHP module. \nOr we just pass an additional parameter $maxQueryComplexity. Whenever that parameter is set, the complexity analysis is executed, otherwise it is ignored (default). \nI think most projects that expose the server to the public need such an implementation anyways. \n. I am currently running the new branch in testing without any major issues (besides the ones discussed in other tickets). Anything we can help to get this released? \nI would be against switching $info and $context in the resolver signature: \n- We would divert from the JS library which could make other (future) ports of related libraries confusing\n- I think you are more likely to need the custom data from the $context than the ResolveInfo. In those cases you can omit the $info argument in the resolver function. I can imagine that's why they changed the signature in the JS library as well. \nIt only took me a few minutes to refactor my codebase with a simple find and replace...\n. @mcg-web I also have a project with hundreds of resolver functions. I replaced array $args, ResolveInfo $info) with  array $args, $context, ResolveInfo $info) on the whole codebase and I was done. So if you have consistent naming of function arguments, this shouldn't be an issue. Also, you will see immediately which functions you missed as soon as you execute the resolvers, since PHP will throw an error. \nI feel like we might end up doing a lot more typing further down the road when we switch those arguments, because we always have to implement ResolveInfo argument in each function when we want to access $context, even if we don't need it. \nSo I'd vote for leaving the interface as it is and releasing a new major version, so devs know that there are breaking changes. \nBesides that one, we also have other breaking changes: \n- Constructor of Schema\n- Signature of GraphQL::execute\n- All types that have interfaces need to be passed to schema, see #38 \nIf we add upgrade instructions I think we should be fine IMHO. \n. I updated the documentation and added upgrade instructions. What else is missing?\n. Thanks for your responses and for keeping up with the latest changes!\nI created a test and a fix for that specific issue:\nhttps://github.com/ivome/graphql-php/commit/53928c9265fef23acbf5cb5c3e3cc7fc34d548bd\nI only have one test failing now:\n```\n1) GraphQL\\Tests\\Type\\SchemaValidatorTest::testRejectsWhenAnImplementationIsNotAPossibleType\nFailed asserting that true matches expected false.\n/Users/ivo/Documents/workspace/opensource/graphql-php/tests/Type/SchemaValidatorTest.php:298\n```\nDoes that need to fail there or could we remove that check? The interface is injected and through the lazy initialization that I added becomes a valid type... Could also be a valid behavior IMHO or am I missing something?\n. Great, then I'll just use my fork until the new version is released. Thanks for adding my test to the new branch!\n. I tried out the new branch april-2016 and upgraded my codebase. Thanks for the great work, btw!! There are still some issues with the LazyInterfaces. I updated the testcase slightly so that it fails on the new branch now. \nhttps://github.com/ivome/graphql-php/commit/c1897ff70e263d6d7f6720239f966e0fc9441c96\nWithout that change the test runs fine. But it seems that right now all types that you want to call through the interface would have to be created in some other place of the Graph. Do you guys think this is solvable? \nI really would love to keep the lazy loading in place and not create ALL types on each request. \n. I upgraded graphql-relay-php to the new spec-april2016 branch and had the same issues there. Here is an example: \nhttps://github.com/ivome/graphql-relay-php/blob/feature/spec-april2016/tests/Node/NodeTest.php#L282\nIf I don't pass the types manually to the schema, the test fails because graphql does not initialize the types properly. \n. Thanks for the explanations. I guess late or deferred initialization is probably the better term. \nToo bad that PHP cannot keep the thread alive so that all the types have to be initialized on each request.... \nYour proposal in #40 sounds like a viable solution. But for now it also works with passing all types to the schema, even though it's a little bit slower. \nI haven't fully built my graph yet, so it might be the case that all the types have to be initialized anyways once I have all the fields in place. \nRight now there is a difference of > 10ms that gets added to each request with my initialization logic compared to deferred initialization. I haven't done any further optimizations yet though. \n. @lordthorzonus I like how they did it in the python graphql-core package: \nYou can pass an executor to the execute function that handles the event loop. That would also make it possible to further customize the behavior, add logging, profiling of resolvers, custom exception handling etc.\nhttps://github.com/graphql-python/graphql-core\n. ",
    "johanobergman": "Thanks for the comment!\nIt seems like it's a rather tough problem to tackle - there really should be a standardized solution to this in GraphQL. For now, your hack works pretty well and solved my problems.\nI've even experimented with passing down a query builder instance (from my ORM) alongside the parent list - this actually makes it possible to perform JOINs instead of IN(...)s.\n. I am a bit too unfamiliar with the graphql source to fully understand the tests and make them pass (perhaps my approach is fundamentally wrong as you say). I did the memoization under the assumption that resolveInfo and arguments were the same for every iteration of a given portion of the full query. You can see that I key the memoized data by an id constructed from the start and end location of the fieldAST.\nThis is a bit of a hack anyway - a different architecture which supports PHP better is by far a better approach.\n. > Actually resolve should be called only once per field (for the same value and same position in query). If resolve is somehow called multiple times - this is probably a bug. Did you face a situation when it has been called multiple times?\nI think this happened when the field owner was not a direct sibling of the other values with the same query position:\nquery Test {\n  todos {\n    ...\n    category {        <- field owner\n      translatedName  <- field\n    }\n  }\n}\nLet's say there are 10 categories in the system. The todos field may return several todos which in turn returns one category. It is likely that a given category will end up in a lot of todos, with resolve being called on its fields each time even though it has the same position in the query and the same value. In this case, resolving translatedName may cause significant (unnecessary) overhead since it will perform the translation several times.\n. Remember that it was only one of the optimizations. The memoization of resolveInfo, args, and collectSubFields were the ones that yielded the best result (although they too broke the test suite).\n. @vladar Good job! Something's not quite right though. Check out this comparision of my fork and graphql-php 0.5 https://blackfire.io/profiles/compare/f5f8ce8c-9ff2-4e9e-bbdf-b673719cbeb9/graph. I believe some methods are still called too many times.\n. Here's a detailed view of graphql-php 0.5: https://blackfire.io/profiles/e67292c1-5853-451f-85d5-60e64a77c873/graph\n. That works a lot better. Note that you don't have to do add [$runtimeType->name] in $exeContext->memoized['collectSubFields'][$uid][$runtimeType->name] since it's already in the $uid.\nI't still about 30% slower than my fork, getFieldUid is called 18000 times instead of 14000 times. $memoized contains the same values though, so it might be some of the recent changes that caused this (removing map or collectSubFields maybe).\nhttps://blackfire.io/profiles/compare/900c6539-0a2d-4d05-9b3b-bf0682f135dd/graph (it's a bit hard to read since method names have been changed)\n. That sounds good. Thank you for the work you put into this. The performance gain has been massive!\n. Yeah I originally requested this but as mentioned, it's not really the responsibility of this library. resolve not being called when the developer expects it to be was not ideal.\n. I'm having some trouble with the is_callable check. There's a field for a certain type in my schema called date, and during the execution of an introspection query, the is_callable check for that field is reached. Since date is a callable php function this results in a call to date() instead of returning the field name.\nIn order to support your use-case without errors, you might want to also check against property not being a string, but I'm not sure how that's going to affect performance.. @leocavalcante It's the field name, the value/type is a string.\n@vladar Sounds good! v0.10.0 looks promising, the improved lexer algorithm took one of my queries from 125 ms to 70 ms excluding validation, great work!. @leocavalcante To clarify: My field name is date, which during introspection means that for\nfragment FullType on __Type {\n    name\n}\nname will have a value of 'date', and that's where the error occurs. It would be same for any other property with a value which corresponds to a global function.. ",
    "smolinari": "Hi, \nI'm new to the project and I like what I see already, both from the concept of GraphQL and the work done here, I'd like to say, I would love to see this happen.\n\n\nConsider implementing parallel execution for HHVM (and probably ReactPHP)\n\n\nHowever, I am working with appserver.io. \nScott\n. No problem. It is an emerging technology, so there is some time to \"get it going\". \nI sure wish Facebook would open source their server side implementation. It would be neat to see how they use HHVM (and I would assume async()) to build their Type System.\nScott\n. If you ask me (and a little off topic), GraphQL with straight PHP is going to be a difficult mix from the start, as seen from the performance concerns already being found with this new project. I feel it is because of the sequential/ share nothing nature of PHP. There is a reason why Facebook created HHVM with Hack's async() function. It's to run requests to data services in parallel, which is also a need to allow GraphQL to perform well IMHO. I believe it is also why Facebook has turned to the NodeJS crowd for the server side. Why haven't they released a Hack version of a GraphQL type system? \nHmmm....\nScott  \n. > So had to build this library to integrate with existing PHP project.\nAnd thank you for doing so! :+1: \n\nAs for performance concerns - most of them equally apply to ORMs or custom solutions in PHP.\n\nAgreed. PHP7 will help this situation, but I am of the opinion, to scale a lot with PHP, we must break out of the current mold a bit. Facebook did it on their own with HHVM. And amazingly, PHP7 is as good or better as HHVM, even without a JIT compiler. That is really great news and looks promising for the future of PHP. But still, there are things we can do, to get even more performance. Non-blocking I/O and threading for example.\n\nBut I suspect that even pure PHP implementation may perform reasonably well if you replace recursive Executor with iterative one (as PHP is slow in handling deep recursion). So that is probably the next step. \n\nSounds good. I'll be keeping an eye out on these changes myself, as I am going to be attempting to do an appserver.io implementation of this library, where we will try to spread out the resolver work (and I am not certain that is the best cut point yet, but we'll see. If you have a better idea, let me know).\n\nAs for async - if you're stuck with plain PHP it doesn't matter if you use GraphQL or other tools - you don't have async anyway %)\n\nTrue. Thankfully there are other alternatives to plain PHP. :smile: \n\nTargeting for HHVM only is not an option at this point, but I would like to have a version that can handle async features of HHVM for those who can afford to use it.\n\nThis is what I was hoping Facebook would give us. I even asked them, what was the reasoning to go with Node instead of an HHVM implementation. I don't expect much of an answer, if any, but you never know.\nScott\n. FYI. https://github.com/graphql/graphql-js/issues/219#issuecomment-155284851\nScott\n. Did you also add the mutation to the configuration file, as explained here? (which seems to me to be a bit of a strange thing to have to do)\nScott\n. Sorry, I missed the \"Or\" just below the config note saying you can use the config OR use the facade. \nI am also not deep enough into graphql-php code to help further. Hopefully Vladamir (@vladar) can help.\nScott\n. Yes, thanks for the great response @vladar. :+1: It actually helps me too, with another concern I have.\nScott\n. A bit of an off-topic question, and because I am too lazy to go looking for the code, but does graphq-php make up the opaque IDs automatically or does that need to be covered by the underlying model to offer such IDs to graphql-php?\nScott\n. Cool. That is actually good and the answer I was hoping for, because I have a different method to create opaque (hashed) ids, than base64 encoding, like the Facebook docs suggest.\nScott\n. Yes, yes. Of course. :smile: \nOr, you actually have a database, which has defined, system wide unique ids for all records and can query on the ids to find the records directly and anywhere in the (distributed) system. :wink:\nSELECT * FROM someId \nThat is cool stuff, isn't it? Oh, and actually, all graph databases can do that, but with differing commands for their supported query languages. :smile: \nScott \n. :+1: Thanks for keeping up with the new stuff!\nScott\n. I'd say, absolutely yes, to adding some sort of protection. It is a necessity. However, I'd also be worried about bogging down the system with the checks. It's a difficult split to make.  \nScott\n. :+1:  For types defined with classes and interfaces.\nScott\n. I would imagine a \"features list\" of enhancements would be be a good start. Anyone willing to contribute can mention which feature they'd like to attack. :smile: \nScott\n. And this project isn't even 1.0.0 yet or beta for that matter. So, anyone using it should expect things to break or be broken. \nScott\n. @mcg-web - I am generally against holding back progress in the name of BC, especially when the change is worthwhile, which I feel this one is.\nScott \n. Ah, the dreaded core problem of PHP's shared nothing architecture (and why such things as constant expressions are created). This is why I am working with appserver.io and putting my graphql service in a servlet.:smile: \nI'd say any major change would need some sort of POC/ bench marking. And still, I'd bet everyone in this discussion a beer that the constant expressions would win over any caching solution.\nI personally don't see a PHP5.6 minimum as an issue either. :smile: \nScott\n. > Too bad that PHP cannot keep the thread alive so that all the types have to be initialized on each request.... \n@ivome - This is exactly the reason why we've chosen to work with appserver.io. http://appserver.io/\n:smile: \nScott\n. Thanks. That is what I thought. And, for one, I certainly appreciate your work with this library. \nIt's going to be fun, however, to pick it apart to make work properly in a threaded PHP environment (which is needed for reactive PHP apps). :wink: \nScott\n. To do a Promise, or even better Observables, right within graphql-php, you'd need to alter PHP (i.e. through event loop extensions), which means graphql-php couldn't be used with standard PHP installs. In other words, to make any library work asynchronously within PHP is a major architectural decision. \nPersonally, I can't see PHP serving as a performant and practical GraphQL backend for any kind of major application, without making some low level changes to PHP like adding event loops, or like in our case, using a threaded PHP environment, like appserver.io.  Or like Facebook using HHVM.\nIf you watch what Meteor is doing with their Apollo server, you can quickly imagine where PHP as a GraphQL server is going to be blown out of the water by such NodeJS solutions. \nSo, I guess what I am saying is, I am for the architectural decision to make graphql-php dependent on something that will make it more attractive for bigger projects. Because, if it stays as it is, I just can't imagine it ever taking off and I truly believe GraphQL has a future. Making this library was a great start for GraphQL in the PHP world. We shouldn't limit it, which plain vanilla PHP does, unfortunately.\nModern apps need modern APIs like graphql-php. The PHP internal devs need to finally get PHP into the big leagues with threading, event looping or asynchronous functions or anything along those lines. It's a huge decision for them I know, which needs a lot of poking and argumentation. This library being dependent on anything outside the PHP box will help make those arguments for sure! \nMy 2 cents. :smile: \nScott\n. > so your statement about PHP (in it's current form) being bad backend for graphql applies to any complex PHP application.\nAgreed.\n\nBut what we really need to make it work - is a person (or group) who works with graphql-php in threaded (or event-loop) envrionment and can report bugs or even help with maitainance in such environment.\n\nI'll do my best, when I get to that point. :smile: \nScott\n. I am not really in deep in this code or in GraphQL for that matter. I am only catching bits and pieces of concepts through the issues and lurking the repos of several GraphQL related libraries like this one. But, from what I understand, shouldn't query validation be more a development need, than a tool used at run-time for the entire program? I mean, couldn't you assume the developer, once he or she is finished with development, would have correct queries calling the server, which would mean the whole validation step could, at that point, be turned off?\nScott\n. Ah yes. That makes sense. I wasn't thinking about a public API.\nI think this then goes back to our discussion about regular PHP's shared nothing architecture not being the best architecture for supporting and scaling a GraphQL server. \nScott\n. ",
    "timbrandin": "I have a BIG problem with memoized results, in this example with memoizing on I get faulty result on the leaf node:\nQuery:\ngql\n{\n  surveys(school_category:SCHOOL) {\n    nid\n    modules {\n      survey\n    }\n  }\n}\nFaulty result, survey in each module should match the nid from the survey.\njson\n{\n  \"data\": {\n    \"surveys\": [\n      {\n        \"nid\": 85,\n        \"modules\": [\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          }\n        ]\n      },\n      {\n        \"nid\": 707,\n        \"modules\": [\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          }\n        ]\n      }\n    ]\n  }\n}\nAnd if I turn off memoization I get the correct result:\njson\n{\n  \"data\": {\n    \"surveys\": [\n      {\n        \"nid\": 85,\n        \"modules\": [\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          },\n          {\n            \"survey\": 85\n          }\n        ]\n      },\n      {\n        \"nid\": 707,\n        \"modules\": [\n          {\n            \"survey\": 707\n          },\n          {\n            \"survey\": 707\n          },\n          {\n            \"survey\": 707\n          },\n          {\n            \"survey\": 707\n          },\n          {\n            \"survey\": 707\n          },\n          {\n            \"survey\": 707\n          },\n          {\n            \"survey\": 707\n          }\n        ]\n      }\n    ]\n  }\n}\nI'm not sure it's safe to memoize using the AST location and fieldname, my recommendation is to remove this performance optimization now until someone figures out how to look at the parent if that is different than previously memoized, but also that doesn't take into account if say any contextual parameter has changed. Say the user is added in some level of the graph and passed down, although atm it doesn't seem to be possible to reference the context in the resolvers to be able to add stuff (this works in the JavaScript implementation, context is passed as the third parameter). But that seems like another issue.\n. Sure @mcg-web \n. ",
    "mcg-web": "hi\u00a0@timbrandin can you open a new issue for this please? it will be much easier to follow thx\n. @vladar I confirm that using DocumentValidator::validate() is the solution. Here two examples that implement Query Complexity and Depth security. I think that the correct place for these rules are here. If needed I can contribute this feature here...\n. Nice, I will soon contribute it.\n. Thanks, can you bump this version please?\n. see #26 \n. The use case is simple, let say we have this:\ninterface A {}\ntype B implement A {}\n``` php\n$b = new ObjectType([\n      \"name\" => \"B\",\n      \"fields\" => [/.../],\n      \"interfaces\" => function() { / Some Magic loader / },\n]);\n$a = new InterfaceType([\n      \"name\" => \"A\",\n      \"fields\" => [/.../],\n]);\n```\nThis will not work because B is declared before A...\nThe Lazy Loader allow this, because objects interfaces will be treated only when really needed in the schema.\n. Yes the test will help for no BC on later modifications :+1:\n. @vladar can we also think of creating some type of community around graphql-php? because actually it look like the project relies only on you. This could help to be more reactive on updates and bug fixes... This is just a subjection but some colleagues thinks this could be a good idea. \n. @vladar Thanks for adding me as collaborator :+1: ! We'll see how to create a reactive community for this project (like the js implementation)...\n. I'm trying to integrate the new specs (april 2016), I think that we should switch $context and $info to limit BC. So resolver signature we look like this resolver($value, $args, $info, $context) and not resolver($value, $args, $context, $info). This avoid of rewriting every single resolver using $info.\n. Wrong button :crying_cat_face:\n. @ivome in a single project like graphql-relay it is easy to manage this BC, but for a project with a huge schema (more than 300 types) with multiple resolver (>500), this BC could push some dev to don't make the move to the next version. That's not an important change if compare to the JS version, i think that when a BC can be avoided, then it should be... this is an open source project so we not the only one to use it...\n. @danez @smolinari That's the only major change between these two versions for dev. After yes we a not version 1.0 but we'll reach it by adding BC when we can easily avoid them? \n. :+1: for this change! it will be much more easier to implements dynamics fields without having to used hacks.\n. Why not make use of this change to be a little more OOP:\nphp\n$schema = new GraphQL\\Schema();\n$schema->setQueryType( $objectType)\n    ->setMutationType($mutationType)\n/* Other possible setters:\n   ->setDirectives($directives)\n   ->setTypes($types)\n*/\nDoing so it will be easier for php developers to get the possible options...\n. I think that schema construct does too much validation... It is not possible to instantiate schema before instancing all other types. The array options force to add custom validators. Using setters add TypeHint and help to produce more comprehensive code.\n. The specs says that extensions:\n\nentry is reserved for implementors to extend the protocol however they see fit, and hence there are no additional restrictions on its contents...\n\nIn my use case it help me send some warnings without breaking graphql protocol.\n. In older versions of the lib, even while using callbacks to describe interfaces, it was called when an object implemented this interface. The full explanation of the why is detail in PR #33. But your trouble seems to come from somewhere else, because we use the same implementation with latest lib version without no error. Here's the code with node relay and fragment that works https://github.com/overblog/GraphQLBundle/blob/master/Tests/Functional/Relay/Node/NodeTest.php#L72-L79. Can you provide some PHP example please?\n. When working on very big schema (+250 Types), promise is very useful to gain performance. Promise helps to put performant data loaders in place, gathering a max of info before requesting DB.\nExample:\nlets say we have:\n``` graphql\ntype Human {\n  name: String!\n  dogs: [Dog]\n}\ntype Dog {\n  name: String!\n  owner: Human!\n}\ntype Query {\n  humans: [Human]\n}\n```\nquery:\ngraphql\nquery humanList {\n  humans: {\n    name\n    dogs {\n      name\n      owner: { name }\n    }\n}\nwith promise we can get all Humans ids and request all Dogs for these Humans in one single request to DB.\nThat just an example but in a more complex schema this can help to gain execution time...\n. @chrissm79 i'm not talking of async for the moment but just deferred promise to help gather all resolvers needs before querying DB. The next step could be event-loop but in a separate project would be great.\n. @vladar not really, React/Promise and [React/Event-loop] are totally separated. That mean that we can use promise in a sync environment to deferred execution of resolver (defer callback can be the solution for Dataloader in fact). Don't have examples for the moment but I'll try to work on a POC as soon as possible.\n. What's your Type System Definition please? I'm going to try to write a test to \nreproduce this bug and fix it...\n. :+1: for disabling this, I think the good solution is to leave optimizations / caching to developers, most already have a caching system in their apps, that can be easily reuse...\n. I can take this fix, not really a huge modification :+1:\n. the issue seem to come from your query, try this please:\nquery try {\n  today\n}\n. Thank you @geshido and @aponscat ! @geshido can you create a PR to fix it please?\n. Nice ;), thank you for the fix\n. Thank you @geshido ;)\n. @geshido I don't have this error when running introspection query with graphiQL, what version are you using?\n. Hi we using a generator that look like what you want to do @vladar but it compile php classes behind the scene for performance issue :D.\n. I think that deferring syntax is the best. To keep flexibility a chaining system should also be implemented. I like the guzzle implementation of Promises/A+. \n. @vladar sorry I push the wrong button. Dataloader should be implement in a external lib like Facebook js implementation. I open a PR #67 that could be a good start for this...\n. @vladar First you create a promise that add the object id to your dataloader, the wait method calls the dataloader to fetch the data, at that point dataloader have all needed ids so can easily regroup request... I'll write a small example for better explanation...\n. here a fast example:\n``` php\nnamespace GraphQL\\Promise;\nclass DeferredPromise implements PromiseInterface\n{\n    private $callback;\nprivate $dataLoader;\n\nprivate $id;\n\npublic function __construct($id, callable $callback)\n{\n    $this->dataLoader = DataLoader::getInstance();\n    $this->dataLoader->buffer($id);\n    $this->id = $id;\n    $this->callback = $callback;\n}\n\n/**\n * Waits until the promise completes if possible.\n *\n * @return mixed\n * @throws \\LogicException if the promise has no wait function or if the\n *                         promise does not settle after waiting.\n */\npublic function wait()\n{\n    $object = $this->dataLoader->fetch($this->id);\n\n    return call_user_func($this->callback, $object);\n}\n\n}\n```\n. The sandbox-dataloader-graphql-php is up to date with the query:\ngraphql\n{ \n  character1: character(id: \"1000\") {\n    name \n  } \n  character2: character(id: \"1002\") {\n    name\n  }\n}\nI approach a little more the js implementation, is for that reason i must add more tests to be sure that promise work properly on error flow.\n@vladar i'm waiting for your review :)\n. Here the new implementation with PromiseAdapter interface, the reactPhp adapter comes out of the box. The dataloader example is also up to date.  I started to implement the async tests, must finish this before merging... ping @vladar. I'll refactor before submitting this to merge no deal. This was a fast implementation, to confirm that we Okay before continuing. Thanks for your feedback! . @vladar if test run correctly and you ok, you can merge this, so we can start playing with it. I'll continue adding promise tests and documentation in others PR. Moving promiseAdapter in ExecutionContext left to you :D. This PR is becoming to huge :trollface: . Have you try to use nuwave/laravel-graphql-relay?\n. @vladar can you review this please? if OK for you i'll add tests to cover remaining code\n. Ok i'll work on this later :+1: \n. I completely forgot this PR, I will add documentation this week end so we can merge it :+1: . I'm Improving the coverage to be sure to don't miss nothing... I'll submit my changes this morning.. @vladar this can be merge in master or we must wait for next major release?. OK here is the initial issue #70. No in the bundle we using the generator types so no need of this. We can close this. Less codes to maintain :D.. I love this idea but why not using interfaces instead of abstracts ?. Ok ok, anyway this will help to add flexibility to types definition(abstract or interface that not a big deal :-) ).... Hi, can you tell me what promise adapter are you using?. Hi @vladar, I think that ksort is not a reliable solution, why not implement something similar to this ?. Yes @vladar, you got it :+1: . Yes @vladar the bundle is compatible with doctrine, we using symfony property access component to ease the work... Here the default resolver (method defaultResolveFn) that is use to do that. Next step is to use directly doctrine schema through a plugging to generate the graphql schema... . That exactly what we doing in the bundle. A next solution is to implement a guzzle http batching system sending request to your main endpoint separately. Last solution is the best because you can async batching so doing win runtime.... Ok i'll PR this. Thank you for quick answer ;).. @vladar your commit look good to me but this also mean that any error can prevent checking complexity this could maybe lead to a security issue ? try/catch block  is not a need to me. . @vladar without a complete use case it will be difficult to give my help on this... @n1ru4l  with a complete example I can maybe get what going wrong :). I am trying to get why @n1ru4l . if I don't get i'll create the issue on dataloader repository :)\n. Yes that where the bug is coming from, thank you. it works if we add the dataloader::await but only if we keep the wait of the override method. here a solution that works:\n\nwe add two hooks to GraphQL lib\n\n```php\n// src/Executor/Promise/Adapter/SyncPromiseAdapter.php\n/**\n * Synchronously wait when promise completes\n *\n * @param Promise $promise\n * @return mixed\n */\npublic function wait(Promise $promise)\n{\n    $this->beforeWait($promise);\n\n    $dfdQueue = Deferred::getQueue();\n    $promiseQueue = SyncPromise::getQueue();\n\n    while (\n        $promise->adoptedPromise->state === SyncPromise::PENDING &&\n        !($dfdQueue->isEmpty() && $promiseQueue->isEmpty())\n    ) {\n        Deferred::runQueue();\n        SyncPromise::runQueue();\n        $this->onWait($promise);\n    }\n\n    /** @var SyncPromise $syncPromise */\n    $syncPromise = $promise->adoptedPromise;\n\n    if ($syncPromise->state === SyncPromise::FULFILLED) {\n        return $syncPromise->result;\n    } else if ($syncPromise->state === SyncPromise::REJECTED) {\n        throw $syncPromise->result;\n    }\n\n    throw new InvariantViolation(\"Could not resolve promise\");\n}\n\n/**\n * Execute just before starting to run promise completion\n *\n * @param Promise $promise\n */\nprotected function beforeWait(Promise $promise)\n{\n}\n\n/**\n * While running promise completion\n *\n * @param Promise $promise\n */\nprotected function onWait(Promise $promise)\n{\n}\n\n```\n* we modify DataLoader custom implementation to do the work\n```php\n    protected function beforeWait(Promise $promise)\n    {\n        DataLoader::await();\n    }\nprotected function onWait(Promise $promise)\n{\n    DataLoader::await();\n}\n\n``\n@vladar tell me what do you think of this solution please?. I'll submit it, thank you @vladar ;). thanks again ;). @n1ru4l [new release here](https://github.com/overblog/dataloader-php/releases/tag/v0.5.2), also require to update graphql to 0.9.14 (graphql is not a requirement of the lib).... That the idea @vladar :+1: for this solution :). thank you @vladar this fix it!. Here a solution that I'm implementing inoverblog/graphql-bundle, It only add a new config entryscalarType` (a scalar type instance or a any callable returning a scalar type instance) on custom scalar.\nThis does not introduce any BC and simplify config decorator:\nphp\n$schema = BuildSchema::build($schemaStr, function($typeConfig, $typeDefinitionNode) {\n    if ($typeConfig['name'] === 'Email') {\n        $typeConfig = array_merge($typeConfig, [\n            'scalarType' => function() {\n                return new EmailType()\n            },\n        ]);\n    }\n    return $typeConfig;\n});\nI can submit a PR here if needed @vladar \nHere is my implementation:\n```php\n<?php\nnamespace Overblog\\GraphQLBundle\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\CustomScalarType as BaseCustomScalarType;\nuse GraphQL\\Type\\Definition\\ScalarType;\nuse GraphQL\\Utils;\nclass CustomScalarType extends BaseCustomScalarType\n{\n    public function __construct(array $config = [])\n    {\n        parent::__construct($config);\n    $this->config['scalarType'] = isset($this->config['scalarType']) ? $this->config['scalarType'] : null;\n    $this->initOptionalFunctions();\n}\n\n/**\n * {@inheritdoc}\n */\npublic function serialize($value)\n{\n    return $this->call('serialize', $value);\n}\n\n/**\n * {@inheritdoc}\n */\npublic function parseValue($value)\n{\n    return $this->call('parseValue', $value);\n}\n\n/**\n * {@inheritdoc}\n */\npublic function parseLiteral(/* GraphQL\\Language\\AST\\ValueNode */ $valueNode)\n{\n    return $this->call('parseLiteral', $valueNode);\n}\n\nprivate function call($type, $value)\n{\n    $scalarType = is_callable($this->config['scalarType']) ? $this->config['scalarType']() : $this->config['scalarType'];\n\n    return call_user_func($scalarType ? [$scalarType, $type] : $this->config[$type], $value);\n}\n\nprivate function initOptionalFunctions()\n{\n    foreach (['parseLiteral', 'parseValue'] as $field) {\n        if (!isset($this->config[$field])) {\n            $this->config[$field] = static function () {\n                return null;\n            };\n        }\n    }\n}\n\npublic function assertValid()\n{\n    parent::assertValid();\n    if (isset($this->config['scalarType'])) {\n        $scalarType = $this->config['scalarType'];\n        if (is_callable($scalarType)) {\n            $scalarType = $scalarType();\n        }\n\n        Utils::invariant(\n            $scalarType instanceof ScalarType,\n            sprintf(\n                '%s must provide a valid \"scalarType\" instance of %s but got: %s',\n                $this->name,\n                ScalarType::class,\n                Utils::printSafe($scalarType)\n            )\n        );\n    }\n}\n\n}\n```. Here an example of how this can be done in project:\n```php\nuse GraphQL\\GraphQL;\n$contextValue = new \\ArrayObject(['extensions' => ['foo' => [], 'bar' => []]]);\n$result = GraphQL::executeQuery($schema, $requestString, $rootValue = null, $contextValue , $variableValues = null, $operationName);\n// here you can do what you want with information you added in your resolvers, just using $contextValue\n```\nEdit: I understand the need and I'm not against adding contextValue to ExecutionResult  but I just find this over-scaled to do so easy task.. The JS implementation is the reference, i tomorrow their add a feature doing the same thing but a different way this feature will become a legacy that and not so easy to removing it without adding a useless BC. This feature can be simply implement using ArrayObject or any other array access object... I think just adapting the api of the server will be more flexible (server is this lib feature so no big deal of changing it).. Sorry my phone keyboard disapair at the wrong moment, i ll finish my explanation on my computer. I updated my comment and I will soon add a poke to show how we could move to that without loosing your work @aelnagger but keeping the lib public api the same :+1: . Hi, I push a proposal that introduce extensions handler, to give user some more power on extension without touching the main api it's a concept totally aside like the error handler... tell me what you think about this please?. This look like a cleaner way of doing that and it offer more possibility in the future. :+1: for me anyway.. Hi @vbelorus, you should open this PR on the bundle or just join us on the symfony slack, If the problem is coming from the lib we'll then open a PR here. Also provide your schema It will be easier to find what going wrong.... @vbelorus the behavior is null but your field is not nullable so set it to null throw on invariantException on field parent (node). Nice to hear that! :+1:. Next time open PR directly on the bundle or just slack us :D. Hi, mutation is like resolver you can return from your mutation any array or object representing your output type.. here an example. When using dataloader with collections you can pre-filter, retrieving only ID's with a simple request (like this: SELECT id FROM posts WHERE has_comments) then return $dataloader->loadMany($ids);. For more performance you can use nested dataLoaders, one that retrieve all commented posts ID and the second that effectively load posts, so doing only 2 requests will be done to retrieve posts... \n  . Giving user some liberty of choice is not a bad thing and not fundamentally changing the global spec of graphQL... But this is an useless debat because this issue can just be fix by creating a custom int64 scalar type and use it instead of int.. ok didn't know about those tools, i will remove this commit :+1: . hi, why do you want to change a deprecated method signature? It would not be easier to use directly new methods?. Hi,\nhave you try using variables instead of literal:\ngraphql\nquery ($codes: [String!]!){\n  families(codes: $codes) {\n    code,\n    attributes {\n      code\n    }\n  }\n}\nvariables:\njson\n{\"codes\": [\n     ... 100 family codes\n]}\nThis should ease the parser work.. @vladar thank you for the feedback. We should give this a deeper look but we'll fix it a fast as possible :+1:.. Hello,\nThis is normal behavior you define your type as [OperatingSystemInput!], remove Types::listOf() if this is not what you want...\n . I don't understand the issue with variables as an array. Changing this is totally against GraphQL specs, I don't think @vladar will agree with that :laughing:. This is out of my scope I'll leave @vladar decide.... My trouble is that string is no more accepted as int also int is not accepted as string in parseValue method but with serialize both works. I can submit a PR that show what I'm waiting for if you want?. Nice! Thank you @danez :+1: . . It seems to be OK! Thank you @vladar and @danez :+1: . @vladar I created a branch 0.11 with @adri commits. I'm not sure that's what you wanted to do but If this can helps, otherwise just delete this branch :+1: .. Here a way this can be done right now for QueryComplexity:\n```php\n<?php\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\n$myLogger = new MyLogger();\n$type = new ObjectType([\n    'name' => 'MyType',\n    'fields' => [\n        'someList' => [\n            'type' => Type::listOf(Type::string()),\n            'args' => [\n                'limit' => [\n                    'type' => Type::int(),\n                    'defaultValue' => 10\n                ]\n            ],\n            'complexity' => function($childrenComplexity, $args) use ($myLogger) {\n                $myLogger->debug('\"someList\" field childreen complexity: '.$childrenComplexity)\n            return $childrenComplexity;\n        }\n    ]\n]\n\n]);\n``. right now we don't have no way to add debug message for QueryDepth. @simPod this look good to me. @vladar 0.12 is break for php 7.3 nightly and platform config was hiding this. That the reason why I added this on 0.12 because this helps to fix some issues.. 0.12.x should always be merged in master, this is the best way to maintain both branch while 0.12 is still maintained, yes I will merged it in master.. @vladar can you please review this and tell me if I need to split this in two PR. I need to fix nightly build for the bundle ;). Thank you I'm working on a PR to merge these changes in master?. why tests should be tested? this is only for the package not the source code . I'll work on feedback today :+1: . @simPod what is the command to automatique fix phpcs please?. thank you @simPod :+1: . I can't fix CS on this PR right now cause it will remove all@itannotations. I'll rebase this PR on master after merging #334 .. I rebase it but when I fix cs it is changing a lot of thing, is this normal?. @simPod @vladar last feedback please and we ready to merge! thank you..We went looking everywhere, but couldn\u2019t find those commits.`?. It look good to me now, It seems that Scrutinizer fails on an old part of the code, can you please check this out @simPod :+1: . . that's where the chaining promise enters in action! let's say we have this query:\njs\n{\n  user1: user(id: 1) { name friends { name }}\n  user2: user(id: 2) { name friends { name }}\n}\nuser resolver:\nphp\nfunction ($id) use ($userDataLoader) {\n  return $userDataLoader->load($id);\n}\nfriends resolver:\nphp\nfunction ($value) use ($userDataLoader) {\n  return $value->then(function($ids) use ($userDataLoader) {\n    return $userDataLoader->loadMany($ids);\n  } \n}\nwait will call user resolver that return promise for user 1 that is resolve by the data loader, resolving promise for user 1 will also resolve user 2 promise (thanks to dataLoader). friends for user 1 will be resolve and same for friends for user 2. only 2 requests to db against 2 + (x * friends user 1) +  (n * friends user 2)...\nIt is difficult to show without a concrete example, thats what i'm working on...\n. Here the concrete example. Need some cleanup again but it works. 2 requests against 9 without data loader...\n. ok no prob for the order of the addField Arguments, also +1 for the addDeprecatedField.  we must be careful of reusing  fields definition in closure because same instance will be share in interface and object. I'll work on all this latter. Thanks for the review :)\n. I'll try to defer the resolution of the promise later in the process, this should do the job...\n. yes this more an introduction to dataLoader and promise, after working on this , I'm sure now the easiest way without adding BC is to implement 100% promise support following node version... The only difference is promise will be send by executor only if need a promise. I create a little lib that abstract promise and can help to easy do that here. . wait method is equivalent to await in node implementation (with react vs with guzzle) . this helps to get promise completion without parsing by then. Minimum interface to promise should be like that. I try a lot different promise implementation in past weeks. I can provide a full working version (with all tests) using my lib. No more need of using PromiseInterface or PromiseWrapper with this lib. I can understand that using a external requirements it not really what we want here, but promise is a more and more a global need for a lot of projects, for example thats what we use in dataloader lib. We can think of a PromiseAdapter but in a separate project, to be easily shared.... To implement promise in this lib we need Promise.all, Promise.resolve, Promise.reject without all this it is impossible. I'll propose my full implementation using my lib and a that moment ,we'll see if it possible to do the same an another way. If you want to understand my lib install it and watch tests. event-loop need calling run method to really work, this behavior is equivalent wait.. you can use constants here please :). @vladar here is a BC this should not be released in a minor version?. its a BC because the signature change, this class is not final then it can be override :). extends InvariantViolation to avoid BC, next major version we can change this.. BC is never acceptable or not it is just a reality, if your new release reflects the BC no trouble but it is very important to dependencies.... ok i'm rolling back this one!. Remove this to test lib in environment without faking platform.. cause phpstan require php 7.1 ;). I m not on master ;) but 0.12.x. Yes this is it :+1:. This PR is targeting 0.12.x we'll see how to clean it for master when it will be merged. Right now lets just focus on this PR please ;). Because it is a duplicated in job entry. We using this only for src in this case so no need an extension for phpunit. cause phar has less dependencies and this lib don't likes to have useless requirements. I'll change it :+1: . But this version is correct too, I'll change if this can make the code great again :laughing:. done!. Can you please do a single review I'm done of changing code every second, thank you ^^. It's seems that this syntax introduce error phpcs https://travis-ci.org/webonyx/graphql-php/jobs/423635233 can you please tell me what is going wrong here?. can you please provide a example I don't really get how to note an annotation sorry. thank you :+1: ;). Why removing this rule?. why change phpstan tmp dir? the default sys tmp seems to be good choose, no?. maybe we should add this to the documentation? cause composer documentation push to use composer.phar direct in the project itself. but I agree this is no a big deal. . Should also test if is an object since instanceof will throw an php error (PHP Fatal error:  instanceof expects an object instance) if $value is not an object. (is_array($value) || (is_object($value) && $value instanceof ArrayAccess)). ```\n08:07 $ php -a\nInteractive mode enabled\nphp > var_dump('' instanceof \\stdClass);\nPHP Fatal error:  instanceof expects an object instance, constant given in php shell code on line 1\nphp > var_dump(1 instanceof \\stdClass);\nPHP Fatal error:  instanceof expects an object instance, constant given in php shell code on line 1\nphp > var_dump((new \\stdClass) instanceof \\stdClass);\nphp shell code:1:\nbool(true)\n```\nThat's what I have when I test this, but maybe I'm just doing something wrong.. You right $v = 1; var_dump($v instanceof \\stdClass); this work, inline has a different behavior.. ",
    "chrissm79": "@vladar I'm wondering if the way to go about it would be for this package to allow us to define Subscription Types, but leave it up to the developer on how to implement it. If you're in the process of creating functionality to handle subscriptions, maybe it's a separate package? \nNot sure what the final spec will look like (seems that they're still flushing out details). But I'm personally thinking that Ratchet with WAMP and ZeroMQ may be the way to go for me. Laravel allows you to easily broadcast events and I'm thinking I will create a custom driver for this setup. Others may find it better to implement some sort of Node/Redis setup. Not sure if something like Pusher would work, but that may another possibility for some (again, depending on what the final spec looks like).\nIMO, the way I see it is that GraphQL allows us to define our subscriptions, but doesn't get down into the details of how it's implemented.\n. I did add it to the config file (this is a fairly common setup in Laravel). Overall everything has been really easy to work with except for mutations. Just trying to determine if this is an issue with the laravel package or if I'm not setting up my mutation properly. \nI did see that the controller is passing through 'params' from the request instead of 'variables'. After switching that out, I'm hitting a different error message which leads me to believe that I need to make a change in my mutation, just not sure what:\n\"Variable $input_0 expected value of type updateCustomerEmailInput but got: {\"entity_id\":\"2\",\"email\":\"john.doe@example.com\",\"clientMutationId\":\"4\"}.\"\n. @vladar Thank you!! I'll give this a try, but thank you for providing this, it ought to be a big help for anyone trying to leverage GraphQL/PHP and Relay. There are a few other helpers I found in the graphql-relay-js package that I'll try to migrate over, but this is a great start.\n. @vladar Did you have to create some sort of interface for your types? I'm having an issue when attempting to run an update mutation. It successfully sends the request to the server and gets a successful response with the updated data, but the component never reflects any of the changes. Asking around, someone mentioned that it may be an issue with Object Identification. Just curious if you've found a solution for this as well. Thanks again @vladar !\n. @smolinari That's pretty slick that OrientDB can do that! I'll have to check that out. \nUnfortunately, I am indeed working with data that is in a MySQL DB and auto-increments all of it's IDs (it's a Magento store). So, since that's the case what I need to do is create a resolve function on my Type's id field that encodes the ID plus some sort of identifier (to tell me which GraphQL Type it is), correct? Just want to clarify for anybody who may be following along. \nThe only piece I'm confused on now is what gets called on the ObjectType that is returned from the Interface? The README states that Interface types do not participate in data fetching. They just resolve actual object type which will be asked for data when GraphQL query is executed. So I'm returning the ObjectType based on the decrypted id argument and I get:\njson\n\"errors\": [\n    {\n      \"message\": \"Trying to get property of non-object\",\n      \"locations\": [\n        {\n          \"line\": 17,\n          \"column\": 7\n        }\n      ]\n    }\n  ]\nSo it appears to be calling something on the ObjectType that is returned, but I don't know what it is.\n. Thank you! I was going through the Executor and getting the ExecutionContext, but this is much cleaner!\n. @mcg-web In order for this to work we would need to execute everything in an event loop, correct? I took a look at FB's DataLoader and that seems like a great idea for a separate package that could work with graphql-php to optimize queries to the DB. But I've yet to run this library in an event loop environment so not sure how difficult/easy that is.\n@vladar Not sure how much work it would be to add a thenable check into this library, but if it could be done (and if it's maintainable) it seems that it would open up the door to some interesting possibilities.\n. @vladar I'm starting to work on a solution using the pre-fetch idea you pitched here and using a central repository to store/retrieve the data in the resolve functions. \nHowever, using ResolveInfo's getFieldSelection helper only provides the name of the fields (which is still very helpful), but they don't include the arguments. So if I have a connection field that needs to just retrieve the first 5 items, I would need to resolve that information from the arguments. Is there a method you recommend to accomplish this with this package? Thanks!!!\n. @vladar Really excited about the possibilities here! Adjusting the getFieldSelection to incorporate arguments ended up being pretty painless, I just needed to grab the arguments off the field and include them in the output:\n``` php\n/\n * Prefetch data.\n \n * @param  ResolveInfo $info\n * @param  int $depth\n * @return void\n /\npublic function prefetch(ResolveInfo $info, $depth = 1)\n{\n    $fields = [];\n/** @var Field $fieldAST */\nforeach ($info->fieldASTs as $fieldAST) {\n    $fields = array_merge_recursive($fields, $this->foldSelectionSet($fieldAST->selectionSet, $depth));\n}\n\nreturn $fields;\n\n}\n/\n * Fold field selection set.\n \n * @param  SelectionSet $selectionSet\n * @param  int          $descend\n * @return array\n /\nprivate function foldSelectionSet(SelectionSet $selectionSet, $descend)\n{\n    $fields = [];\nforeach ($selectionSet->selections as $selectionAST) {\n    if ($selectionAST instanceof Field) {\n        $fields[$selectionAST->name->value] = $descend > 0 && !empty($selectionAST->selectionSet)\n            ? $this->buildOutput($selectionAST, ['children' => $this->foldSelectionSet($selectionAST->selectionSet, $descend - 1)])\n            : $this->buildOutput($selectionAST);\n    } else if ($selectionAST instanceof FragmentSpread) {\n        $spreadName = $selectionAST->name->value;\n        if (isset($this->fragments[$spreadName])) {\n            /** @var FragmentDefinition $fragment */\n            $fragment = $this->fragments[$spreadName];\n            $fields += $this->foldSelectionSet($fragment->selectionSet, $descend);\n        }\n    }\n}\n\nreturn $fields;\n\n}\n/\n * Build field output.\n \n * @param  Field  $field\n * @param  array $data\n * @return array\n /\nprivate function buildOutput(Field $field, $data = [])\n{\n    $args = [];\nforeach ($field->arguments as $argument) {\n    $args[$argument->name->value] = $argument->value->value;\n}\n\nreturn array_merge([\n    'parent' => isset($data['children']),\n    'args' => $args,\n], $data);\n\n}\n```\n. @vladar @mcg-web Are promises possible in a non event loop environment? Or can a loop be created for each request? If we can do the latter, I would agree with @mcg-web that the Guzzle (or ReactPHP) implementation would be a great fit. \nHowever, if this forces the rest of a project to run inside an event loop environment I think this would have to be something that is optional.\nRegardless, I'm really excited to see the discussion of some sort of incorporated DataLoader getting started!\n. @vladar The repo's been updated along with the initial set of docs. v2.0 is cut and ready to use! \nThanks @kikoseijo!!. #### Test\n```php\n/*\n  * @see it('gets execution info in resolver')\n  /\npublic function testCallsObjectTypeInterfaceCallback() : void\n{\n    $NamedType2 = new InterfaceType([\n        'name'        => 'Named',\n        'fields'      => [\n            'name' => ['type' => Type::string()],\n        ],\n        'resolveType' => function (\n            $obj,\n            $context,\n            ResolveInfo $info\n        ) use (&$PersonType2) {\n            return $PersonType2;\n        },\n    ]);\n$PersonType2 = new ObjectType([\n    'name'       => 'Person',\n    'interfaces' => function () use ($NamedType2) {\n        return [$NamedType2];\n    },\n    'fields'     => [\n        'name'    => ['type' => Type::string()],\n        'friends' => ['type' => Type::listOf($NamedType2)],\n    ],\n]);\n\n$QueryType = new ObjectType([\n    'name' => 'Query',\n    'fields' => [\n        'named' => [\n            'type' => $NamedType2,\n            'resolve' => function () use (&$NamedType2) {\n                return $NamedType2;\n            }\n        ]\n    ]\n]);\n\n$config = \\GraphQL\\Type\\SchemaConfig::create()\n    ->setQuery($QueryType)\n    ->setTypeLoader(function ($name) use (&$QueryType, &$NamedType2, &$PersonType2) {\n        switch ($name) {\n            case 'Query':\n                return $QueryType;\n            case 'Named':\n                return $NamedType2;\n            case 'Person':\n                return $PersonType2;\n        }\n    });\n\n$schema2 = new Schema($config);\n\n$ast = Parser::parse('{\n    __schema {\n        types {\n            kind\n            name\n            possibleTypes {\n                name\n            }\n        }\n    }\n}');\n\n$result = GraphQL::executeQuery($schema2, $ast)->toArray();\n$interface = current(array_filter(\n    $result['data']['__schema']['types'],\n    function ($type) {\n        return $type['name'] === 'Named' && $type['kind'] === 'INTERFACE';\n    }\n));\n\n$this->assertCount(1, $interface['possibleTypes']);\n\n}\n```\nNote: This may just be an issue when using the SchemaConfig class rather than defining the Schema with an array config.. Thanks for the feedback @vladar!! I can just set up a config option in our package to switch over to using the types option if needed which would resolve this issue.. @mcg-web Love the syntax for this, it's really clean! I went the pre-fetch route for my Laravel package and was able to minify my requests to the DB, but I much prefer this promise based approach. \nLike @vladar I didn't consider passing down the promises through the resolvers either. Interested to see your examples... might have to throw away my implementation :-)\n. ",
    "leocavalcante": "If it helps as reference implementation:\nhttps://siler.leocavalcante.com/graphql/subscriptions.html\nhttps://github.com/leocavalcante/siler/tree/master/src/Graphql. Updated base branch to v0.10.. Hi @johanobergman, I can see that, but to clarify: is the field name date or its value is date?. ",
    "tankerkiller125": "Something that could be done here for subscriptions is something kind of like Laravel does for the Broadcast service where the lib would do pub/sub using redis and then a very basic nodejs server to actually handle the websocket connections.\nIt wouldn't be the best system, I know that, but it would be a workaround that would work.. ",
    "tim-field": "@vladar If you get a moment would you also be able to show what the corresponding Relay query would look like in the above comment ?\nI'm trying something like this currently:\njson\n{\"query\": \"mutation M { updatePost(input: {id: 10 title: \\\"New title\\\"}) { title }} \"}\nBasically I'm not sure how to pass the input argument correctly. The above complains with \nArgument \"input\\ expected type UpdatePostInput! but got: {id: 10, title: \"New Title\"}.\nI've got the the following mutation defined in schema so far ( sorry too much code ) \n``` PHP\n    function updatePostMutation() {\n        return Mutation::mutationWithClientMutationId([\n            'name' => 'UpdatePost',\n            'inputFields' => [\n                'id' => [\n                    'type' => Type::id(),\n                ],\n                'title' => [\n                    'type' => Type::string(),\n                ],\n            ],\n            'outputFields' => [\n                'post' => [\n                    'type' => $this->getPostInterface(),\n                    'resolve' => function($payload) {\n                        return get_post($payload['id']);\n                    }\n                ]\n            ],\n            'mutateAndGetPayload' => function(array $input, ResolveInfo $info) {\n                // ... perform mutation ...\n                wp_update_post([\n                        'ID' => $input['id'],\n                        'post_title' => $input['title']\n                    ], false);\n            return [\n                'id' => $input['id']\n            ];\n        }\n    ]);\n}\n\n```\n. Thanks you are quite right, I needed to read this some more. \nThanks again for a great library. \n. ",
    "crirus": "Hello\nI am just starting up with graphql-php. Is there any complete example on writing mutation?\nThank you.. Thank you for your reply.\nI understand this example. Is there any way to reuse the type definitions from query side?\nI managed to make that work pretty well with one of my database entity and now I am facing a redo for all the fields defined there?\nI read somewhere that the Input and Output are separate, but still... can't we just use one type?\nEdit: Another question related to mutation is: Where does InputObjectType comes into play?\nAgain, a full featured example could help, same like blog one for Query :)\n. Thank you, this is probably what I was looking for, a way to build some types without having a class implementation upfront.. Hello again,\nAfter some more reading there seems to be some implementations regarding multiple graph APIs stitching.\nBasically they introspect each API via URL and combine the schemas as well as linking types together on the stitcher side. Is there any plan for adding this to graphql-php?. const schema = mergeSchemas({\n    schemas: [universeSchema, weatherSchema],\n    links: [\n      {\n        name: 'location',\n        from: 'Event',\n        to: 'location',\n        resolveArgs: parent => ({ place: parent.cityName }),\n        fragment: fragment WeatherLocationArgs on Event {\n            cityName\n          },\n      },\n    ],\n  });. Actually they work on this concept in apollo here\nhttps://github.com/apollographql/graphql-tools/tree/f03ae91d7daee20d0768557458819725b529a9b7/src/stitching\nRegards.. Oh, well, maybe as a tool then. Will see what I can do about it and post back if I produce anything.. Do we have in grapql-php a transformation function from schema Introspection to actual schema?. Sorry, false alarm from my IDE display where it wont show all nodes with large recursive location subtree. Closing this.. Well, I just added that enctype to StandardServer.\nI send the files as a normal post upload and mention in graphql a field with a Input  type that validates the file and store it.\nSomething like this.\nphp\n$config = [\n            'name' => 'UploadInput',\n            'description' => 'Provide field name of the file input or URl to fetch the file from. If name is provided, a file must be uploaded',\n            'fields' => [\n                'field_name' => Types::string(),\n            ],\n            'resolveField' => [$this, 'resolveUpload']\n        ];. Hello guys,\nI already have the code ported along with a merging/stitching function taken from Apollo. It's not 100 percent as they keep pushing more features but I can drop it on a repository so you can play with it and maybe help polishing the code. @greyexpert  here is the initial code, any questions let me know\nhttps://github.com/crirus/graphql-php-tools\n. I\"ve also ported some of the apollo tools in a package, maybe you can use the code there. https://github.com/crirus/graphql-php-tools. Sure, have fun. I am still not done with this, have a final issue with resolving extended fields from a schema to another, otherwise it's working fine delegating each field to it's own schema as well as creating extended schema and attaching resolvers to it. Let me know what you can figure out.. It depends if  you want this part in the main project, I already have something in a separate repository crirus/graphql-php-tools, but it's not mature enough for a merge with main library.\nI have there both extend and merge functionality. However, in that code there is a lot that sounds like BuildSchema bits.\nMaybe someone can help tidying it a bit.\nI am deep into building microservices graphql now, will get back to merging when I have those micros up and running.. Well, I create a mutation with complex types inside, not a flat field set under root types.\nBasically I have createUser who's in a new category, for example. Category could be created on it's own resolver then ID passed back to main data structure for user to be created with the category associated.\nI can see the root resolver receive all data, but wouldn't be nice to identify all inner types used and if they have a resolver to get called from the deepest up and replace the data node with whatever resolver returns?. php\nmutation {\n   createUser {\n      name: \"user1\"\n      createCategory {\n          name: \"category1\"\n      }\n   }\n}\nIn the end, it will first execute createCategory since I have resolver in CategoryType saving new category, wich return ID:1, then data is passed to createUser resolver with $args['createCategory'] = 1.\nOk, I already resolved all this by splittling the root resolver in calls to resolvers I can find for each type, but would be nice if graphql itself can recursively go deep into each type for a resolver and process the data received for it if any.. This is how I resolved it.\n```php\n//Mutation resolver\npublic function resolveMutation($val, $args, $context, ResolveInfo $info){\n        DebugBreak('1@localhost');\n        foreach ($args as $mutationArgName => $mutationData) {//loop in mutations data\n            //get the argument object; this data suppoe to represent full object to be saved\n        $mutationArg = $this->getField($info->fieldName)->getArg($mutationArgName);\n        $mutationArgType = $mutationArg->getType();\n\n        //particular call to final execution code, eg. save, update, etc. Throws error and halt if not callable found\n        $call = $this->getCallableMutator($info->fieldName, $mutationArgType);\n\n        //process inner types first, saving as necessary, then save mutation data altered (eg ID instead full inner object data)\n        if ($mutationArgType instanceOf BaseInputType){ \n            $args[$mutationArgName] = $mutationArgType->resolveInnerMutation($mutationData);\n            //call final outer object save here\n        }else{\n            //with simple input types, just pass them along to save\n        }\n        call_user_func($call, $args[$mutationArgName]);\n        //return output mutation object\n    }\n}\n\n```\n... in OfferInputType class, extending BaseInputType used to define all mutations arguments like \n```php\n                    'createOffer' => [\n                        'name' => 'createOffer',\n                        'type' => Types::get('OfferOutput'),\n                        'args' => [\n                                'offer' => Types::get('OfferInput')\n                        ],\nphp\npublic function resolveInnerMutation($inputData){\n    $inputDataResolved = [];\n    $fields = $this->getFields();\n    foreach ($fields as $field) {\n        if(!isset($inputData[$field->name])) continue;//skip where we have no data received\n        $fieldType = $field->getType();\n        if($fieldType instanceOf BaseInputType){//loop into objects and execute the nested resolvers\n        if(!empty($inputData['id'])){\n            $inputDataResolved[$field->name] = $inputData['id'];//no creation, just use provided id\n        }else{\n            if(is_callable($fieldType->config['resolveField'])){\n            $inputDataResolved[$field->name] = call_user_func($fieldType->config['resolveField'], $inputData[$field->name], $field);\n            }else{\n            $inputDataResolved[$field->name] = $inputData[$field->name]; //Don't lose data where there are no resolvers defined\n            }\n        }\n        }elseif($fieldType instanceOf ListOfType){\n        $fieldType = Type::getNamedType($fieldType);\n        if($fieldType instanceOf BaseInputType){\n            foreach ($inputData[$field->name] as $key => $inputItem) {\n            if(!empty($inputItem['id'])){\n                $inputDataResolved[$field->name][] = $inputItem['id'];//no creation, just use provided id\n            }else{                      \n                if(is_callable($fieldType->config['resolveField'])){\n                $inputDataResolved[$field->name][] = call_user_func($fieldType->config['resolveField'], $inputItem, $field);\n                }else{\n                $inputDataResolved[$field->name][] = $inputItem;//Don't lose data where there are no resolvers defined\n                }\n            }\n            if(!isset($inputDataResolved[$field->name][$key])) throw new \\Exception('Something went wrong processing sub-resolvers; Lost data?');  \n            }\n        }else{\n            $inputDataResolved[$field->name] = $inputData[$field->name];\n        }\n        }elseif($fieldType instanceOf NonNull){\n        $fieldType = Type::getNamedType($fieldType);\n        $inputItem = $inputData[$field->name];\n        if($fieldType instanceOf BaseInputType){\n            if(!empty($inputItem['id'])){\n            $inputDataResolved[$field->name] = $inputItem['id'];//no creation, just use provided id\n            }else{                      \n            if(is_callable($fieldType->config['resolveField'])){\n                $inputDataResolved[$field->name] = call_user_func($fieldType->config['resolveField'], $inputItem, $field);\n            }else{\n                $inputDataResolved[$field->name] = $inputItem;//Don't lose data where there are no resolvers defined\n            }\n            }\n        }else{\n            //Set alias where available\n            $inputDataResolved[$field->name] = $inputItem;\n        }              \n        }else{\n        //field is basic scalar, doesn't need a mutation\n        $inputDataResolved[$field->name] = $inputData[$field->name];\n        }\n        if(!isset($inputDataResolved[$field->name])) throw new \\Exception('Somethingwent wrong processing sub-resolvers; Lost data?');\n    }\nreturn $inputDataResolved;//Done with this mutation InnerResolvers\n\n}\n```. Why not having a singleton for Executor and access it via a static like Executor::instance()->setExtension() within a resolver?\nLater edit: Because of making resolvers impure.... How about GraphQL class then? We already use it to set promise adapter. \nCould be better used to add extensions than forcing my context class to use a graphql interface?. I pushed this change to my old PR, here is the code if you want to merge it alone\nsrc/Server/Helper.php on line 72\nphp\n            } else if (stripos($contentType, 'multipart/form-data') !== false) {\n                $bodyParams = $_POST;. Should not be a big deal, basically I have a resolver for Query Type where I get the arguments, then I have multiple other resolvers for each field where I don't get arguments received from client.\nWould be nice to be able to access them anywhere natively.. Here is a query I am working on\nquery {\n  operatingSystems(\n    filter:{\n      field:name,\n      type:LIKE\n      value:\"Andro\"\n      versions:{\n        field:version\n        type:LIKE\n        value:\"update\"\n      }\n    }\n  ){\n  id\n  name\n    versions{\n      id\n      version\n      osId\n    }\n  } \n}. Ohh, I tried that, was the first logical idea, but I misplaced the args, instead having them in OperatingSystemType, I put them in OperatingSystemVersionsType, one level too deep.\nThanks for the hint this solved this whole nested args issue that I had, gracefully.. How are these @=hasRole('ROLE_ADMIN') working, can you give a schema definition example?. Well, I can send an argument, but not sure how to select and filter out posts without comments in resolvers. Basically it will read all posts and then will read comments with dataloader, but then how do you drop the empty comment posts?. Hello\nQuery is as simple as this\nquery {\n  publishers{\n    userId\n    __typename\n  }\n}\nIt works just fine for any field except when typename is added I get\n{\n  \"errors\": [\n    {\n      \"message\": \"Field \\\"__typename\\\" is not defined for type \\\"PublisherDetailsOutput\\\"\",\n      \"locations\": [\n        {\n          \"line\": 2,\n          \"column\": 3\n        }\n      ],\n      \"path\": [\n        \"publishers\"\n      ]\n    }\n  ],\n  \"data\": {\n    \"publishers\": null\n  }\n}. __typename is supposed to be auto filled on any type, right?. Apparently it was some of my code $someType->getField($field_name) I called\nthrowing the error, if I skip  prefixed values there, it's fine.\nSorry for false alarm\n. I need that a list, but then in variables I have to send a list even if I have a single element.\nHowever, in query that is not mandatory.\nI found the issue in Values.php.\nwith this code we could solve the issue\n...\nif (is_array($value)) {\n                if(!is_numeric(key($value))) {\n                    $val[]  = $value;\n                    $value = $val;\n                }\n$tmp = [];\n...\nOn a ListOfType we should have a 0 indexed array not directly objects, otherwise make one from the whole value received there. It's not really an issue, since we can always send array even with single element.\nI just pointed out that while on DocumentValidatior that parses full query this is handled even if I send a single object, not wrapped in array, with variables you can't really tell that received array is a list or the actual object as array.\nOne way to figure that out is to test if it's associative, and if true, it is safe to assume that's the actual object not array of single object, so you can wrap it in array.\nThe thing is, graphIQL is not forcing me to send variables as array.. Yes, too bad as I have some enum with numbers that should show up in GraphIQL as so, not something like _1, _2. I removed mapValues, wasn't aware at the time of all the porting you did there with different names than JS version. ",
    "ozziest": ":+1: \n. ",
    "AhmadAudeh": "thanks for the replay,\nFor example if I have the following class witch represent a user type, then how could I create a fragment that includes the id and username fields ?\n```\nclass UserType extends GraphQLType {\n    protected $attributes = [\n        'name' => 'User',\n        'description' => 'A user'\n    ];\npublic function fields()\n{\n    return [\n        'id' => [\n            'type' => Type::nonNull(Type::string()),\n            'description' => 'The id of the user'\n        ],\n        'username' => [\n            'type' => Type::string(),\n            'description' => 'The email of user'\n        ], \n         'count' => [\n            'type' => Type::int(),\n            'description' => 'count of the users'\n        ],\n        'friends' => [\n            'type'=> function () {\n                return Type::listOf(GraphQL::type('user'));\n            },\n            'description' => 'frinds information'\n        ]\n    ];\n}\n\nprotected function resolvefriendsField($root, $args)\n    {\n        // resolve code \n    }\n}\n```\nBecause right now my query is like : \nFetchUsers{users(id:\"2\"){id,username}}\nand I want it to be something like :\nFetchUsers{users(id:\"2\"){...UserFragment}}\n. :+1: \nOk, thanks :)\n. ",
    "ooflorent": "Sure. \n``` js\ninterface Node {\n  id: ID!\n}\ntype User implements Node {\n  id: ID!\n  blogs: [Blog!]!\n}\ntype Blog implements Node {\n  id: ID!\n  owner: User!\n}\n```\nNote that the structure is similar to Relay but is not. Our schema is so big that our types must not be defined in specific order. We use closures to define fields. e.g.\n``` php\nabstract class ObjectDefinition {\n  abstract protected function name() {}\nprotected function fields() { return []; }\n  protected function interfaces() { return []; }\npublic function toType(TypeResolver $resolver) {\n    $resolveFields = function () use ($resolver) {\n      $fields = $this->fields();\n  foreach ($fields as $name => &$def) {\n    $def['type'] = $resolver->resolveType($def['type']);\n  }\n\n  return $fields;\n};\n\n$resolveInterfaces = function () use ($resolver) {\n  $interfaces = $this->interfaces();\n\n  foreach ($interfaces as $name => &$def) {\n    $def = $resolver->resolveType($def);\n  }\n\n  return $interfaces;\n};\n\nreturn new ObjectType([\n  'name' => $this->name(),\n  'fields' => $fields,\n  'interfaces' => $interfaces,\n]);\n\n}\n}\nclass Blog extends ObjectDefinition {\n  protected function name() {\n    return 'Blog'; \n  }\nprotected function interfaces() {\n    return ['Node'];\n  }\nprotected function fields() {\n    return [\n      'id' => ['type' => 'ID!'],\n      'owner' => ['type' => 'User!'],\n    ];\n  }\n}\n``\n. Your snippet would work but is not a viable solution. The bug is introduce byObjectType::initialize. Removing the validation logic and moving field-related checks togetFieldsand interface-related fields togetInterfaceswould solve the issue (just like the JS implementation). Such modification would reduce the configuration complexity of object types. \n. Subscriptions are not implemented yet in the library.\nSee #9 \n. Is there any reason why? What's the motivation behind this change?\n. One thing that is important (in my opinion) is that the schema must be serializable (and so cacheable). Ifresolve*properties are no longer closure but _something_ that is understandable by a service (e.g. an expression language string, a serializable callback, etc) then the schema may be easily cached to avoid build or validation costs.\n.graphql-js` has an opened experimental PR (https://github.com/graphql/graphql-js/pull/304) to introduce execution phases. If implemented in PHP, it would enable deferred data fetching.\n. Extra line \ud83d\ude01 \n. ",
    "andytruong": "Thanks!\n. ",
    "jenschude": "Yeah had some time to try a little bit around. For my project i only need the language part. The rest is not so interesting for me. And as there are some graphql ports to be found at packagist. Nearly all look the same when taking a look at the language part.\nBut yes a C module would be really nice. But as long as it's not out we have to stick to native implementation. :)\n. Why not trying jmespath? It allows to create data extract queries in the result. The queries are compiled and cached. This approach is for example used by the AWS SDK.\n. @vladar I think I just got it wrong :) I was talking about the result set.\nYou can find example usage here:\nhttps://github.com/jmespath/jmespath.php#jmespathphp\nThis would prevent expensive mapping of the result to objects, but still it would be convenient to access the results.\n. Btw. a collegue of mine just promoted this project here. GraphlQL compatibility acceptance tests. It may be worth to consider to be used and be more in line with the spec. https://github.com/graphql-cats/graphql-cats\n. Or use named constructors:\nphp\npublic static function byTypeMutationType($queryType, $mutationType) {\n  return new static(['query' => $queryType], 'mutation' => $mutationType]);\n}\npublic static function byTypeMutationTypeDirectives($type, $mutationType, $directives) {\n  return new static(['query' => $queryType], 'mutation' => $mutationType, 'directives' => $directives]);\n}\n. Another possible one:\nhttps://github.com/guzzle/promises\n. ",
    "gabym": "Thanks for fixing so quickly\n. ",
    "bwaidelich": "Thank you for the quick reaction!\nMy bad. I have a rather complex schema, so I created one class per type extending ObejectType and using it like:\n'fields' => [\n    'someField' => [\n        'type' => new CustomType(),\n    ],\n    // ...\n(must have been late ;))\nWhen reusing the same instance it does work indeed.\nBut I do wonder about the best way to split this up into multiple classes, especially with things like Dependency Injection.. I'll probably have to go for singletons.\n. @vladar I forgot to respond: thanks for the tip, that's what I basically meant with \"singleton\" because the factory/resolver needs to be one. It works out quite nicely and I created a little bridge-package to make use of this in Neos Flow: https://packagist.org/packages/wwwision/graphql\n. ",
    "danez": "What bugs me the most currently is defining types. It feels a little bit weird to define the types completely with arrays - especially interfaces - , although php can handle classes and interfaces just fine.\nWhat I wanted to try is creating a system where one could define types with real classes and annotation, like this https://gist.github.com/danez/34e3fd37201c69395317c70b44410299 I haven't really thought about this in depth, but I think it should be possible. It should be like doctrine.\nThis doesn't necessarily needs to go into this library, but could also be a layer above graphql-php, because usually in production apps you want to precompile annotations anyway.\n. Is there any news on that? I saw that there is already a branch for it and we are waiting for a fix for #38. Anything that needs to be done? Can I help somehow?\n. Im also in favor of what @ivome said. Even if it is a large project it shouldn't be extremely complex to replace all resolvers. And if you make a new semver major version of graphql-php, it is clear that there are breaking changes. \n. It was meant to be bc, besides the change of the interface. I had #126 before which broke php <7, this should have been the fixed version.\nLet me check.. Okay I fixed it.. Done. Thank you very much for the quick response, I will test now.. Worked perfectly. This is not included in the other big PR as the other PR was only adding stuff up to 0.12.3, and this is part of 0.13. But i guess i will create a new PR at some point with all the 0.13 changes.. Okay I added all the relevant commits from 0.11 till 0.12.3 from graphql-js.\nThere are a couple of breaking changes, most of them I either already added to UPGRADE doc or made them backwards compatible.\nMajor changes are the new SchemaDefinitionLanguage from the spec, a new SchemaValidator,  updated validation rules, more breaking changes detection.\nLots of validations stuff was already removed from the constructor here, which they now also did in the  JS library. I tried to sync the two libraries in this topic and moved some logic from TypeClasses (for example Directive) to the SchemaValidationContext.\nThere are still some checks left in Type::assertValid() but most of them are now not related anymore to the Schema but more to the configuration of the types (ala checking if typeresolver is function etc.) Maybe this can now be cleaned up better than the current status.\nI thought about moving all the new Validation of the Schema to the corresponding Type classes, but that way it will be way harder to make updates from upstream, so I left it for now in the SchemaValidationContext.\nI also run phpbench. Before\n```\n\u276f bin/phpbench run\nPhpBench 0.15-dev (@git_version@). Running benchmarks.\nUsing configuration file: /Users/danieltschinder/Documents/Github/graphql-php/phpbench.json\n\\GraphQL\\Benchmarks\\HugeSchemaBench\nbenchSchema                   I0 P0     [\u03bc Mo]/r: 152.723 152.723 (ms)  [\u03bcSD \u03bcRSD]/r: 0.000ms 0.00%\nbenchSchemaLazy               I0 P0     [\u03bc Mo]/r: 0.008 0.008 (ms)  [\u03bcSD \u03bcRSD]/r: 0.000ms 0.00%\nbenchSmallQuery               I0 P0     [\u03bc Mo]/r: 56.779 56.779 (ms)    [\u03bcSD \u03bcRSD]/r: 0.000ms 0.00%\nbenchSmallQueryLazy           I0 P0     [\u03bc Mo]/r: 56.413 56.413 (ms)    [\u03bcSD \u03bcRSD]/r: 0.000ms 0.00%\n\n\\GraphQL\\Benchmarks\\StarWarsBench\nbenchSchema                   R2 I1 P0  [\u03bc Mo]/r: 0.146 0.146 (ms)  [\u03bcSD \u03bcRSD]/r: 0.002ms 1.68%\nbenchHeroQuery                R2 I1 P0  [\u03bc Mo]/r: 1.258 1.258 (ms)  [\u03bcSD \u03bcRSD]/r: 0.060ms 4.80%\nbenchNestedQuery              R2 I1 P0  [\u03bc Mo]/r: 2.384 2.384 (ms)  [\u03bcSD \u03bcRSD]/r: 0.008ms 0.34%\nbenchQueryWithFragment        R2 I1 P0  [\u03bc Mo]/r: 2.462 2.462 (ms)  [\u03bcSD \u03bcRSD]/r: 0.104ms 4.22%\nbenchStarWarsIntrospectionQueryR2 I1 P0     [\u03bc Mo]/r: 23.645 23.645 (ms)    [\u03bcSD \u03bcRSD]/r: 0.219ms 0.92%\n\n\\GraphQL\\Benchmarks\\LexerBench\nbenchIntrospectionQuery       R2 I3 P0  [\u03bc Mo]/r: 1.309 1.307 (ms)  [\u03bcSD \u03bcRSD]/r: 0.018ms 1.38%\n\n10 subjects, 19 iterations, 170 revs, 0 rejects, 0 failures, 0 warnings\n(best [mean mode] worst) = 0.008 [29.713 29.713] 0.008 (ms)\n\u2140T: 332.260ms \u03bcSD/r 0.041ms \u03bcRSD/r: 1.335%\n```\nand after\n```\n\u276f bin/phpbench run\nPhpBench 0.15-dev (@git_version@). Running benchmarks.\nUsing configuration file: /Users/danieltschinder/Documents/Github/graphql-php/phpbench.json\n\\GraphQL\\Benchmarks\\HugeSchemaBench\nbenchSchema                   I0 P0     [\u03bc Mo]/r: 152.980 152.980 (ms)  [\u03bcSD \u03bcRSD]/r: 0.000ms 0.00%\nbenchSchemaLazy               I0 P0     [\u03bc Mo]/r: 0.009 0.009 (ms)  [\u03bcSD \u03bcRSD]/r: 0.000ms 0.00%\nbenchSmallQuery               I0 P0     [\u03bc Mo]/r: 59.479 59.479 (ms)    [\u03bcSD \u03bcRSD]/r: 0.000ms 0.00%\nbenchSmallQueryLazy           I0 P0     [\u03bc Mo]/r: 54.793 54.793 (ms)    [\u03bcSD \u03bcRSD]/r: 0.000ms 0.00%\n\n\\GraphQL\\Benchmarks\\StarWarsBench\nbenchSchema                   R2 I1 P0  [\u03bc Mo]/r: 0.149 0.149 (ms)  [\u03bcSD \u03bcRSD]/r: 0.004ms 2.55%\nbenchHeroQuery                R2 I1 P0  [\u03bc Mo]/r: 1.058 1.058 (ms)  [\u03bcSD \u03bcRSD]/r: 0.020ms 1.89%\nbenchNestedQuery              R2 I1 P0  [\u03bc Mo]/r: 2.242 2.242 (ms)  [\u03bcSD \u03bcRSD]/r: 0.081ms 3.60%\nbenchQueryWithFragment        R2 I1 P0  [\u03bc Mo]/r: 2.537 2.537 (ms)  [\u03bcSD \u03bcRSD]/r: 0.076ms 2.99%\nbenchStarWarsIntrospectionQueryR2 I1 P0     [\u03bc Mo]/r: 23.688 23.687 (ms)    [\u03bcSD \u03bcRSD]/r: 0.185ms 0.78%\n\n\\GraphQL\\Benchmarks\\LexerBench\nbenchIntrospectionQuery       R1 I0 P0  [\u03bc Mo]/r: 1.339 1.329 (ms)  [\u03bcSD \u03bcRSD]/r: 0.015ms 1.09%\n\n10 subjects, 19 iterations, 170 revs, 0 rejects, 0 failures, 0 warnings\n(best [mean mode] worst) = 0.009 [29.827 29.826] 0.009 (ms)\n\u2140T: 333.300ms \u03bcSD/r 0.038ms \u03bcRSD/r: 1.291%\n```\nSo the seems most benchmarks didn't change much.\nLet me know what you think, and sorry again for the huuuuggggeee PR. If I can make your life easier somehow with reviewing let me know. I created the checkboxes in the initial description that you might want to use to tick reviewed commits if you want to do reviews based on commits.\nIf this is done and you are happy with what I'm doing I can continue and move to 0.13, but for now I need a break :D. Okay I understand, I will add it back.. Okay I added it back and also fixed a bug with the lazy loading of types which I introduced.. \ud83c\udf89 Feel free to ping me if bugs come up.. Ah sorry I missed that comment. Yes good point, I guess throwing would have the same effect as Utils::undefined().\nWe just need to make sure that null isn't used for this as it can always be a valid value.. I will create a PR to do the Utils:undefined() vs throw change ASAP.. This problem should be fixed in #248 as the serialize and parseValue methods have been aligned together. https://github.com/danez/graphql-php/blob/3e067cc60fb720703453904f1351f3acbfb4b453/src/Type/Definition/IntType.php#L39..L52. It throws an empty exception as otherwise the error messages do not match anymore with the expected error messages copied from graphql-js. Not super nice, but the other solution would have been updating all tests and diverging from graphql-js in that sense.. This was also hard to get by. If we just return null in EnumType->serialize() then some tests fail, if I instead throw this here failed as astFromValue expects to return null on unresolvable Enum types.\nI came up with this, which should catch the Error thrown in serialize and handle it here, but any other error should just throw.. ",
    "decebal": "must compliment you guys for referincing this issue in the actual error message! :1st_place_medal: . @vladar I had to write a wrapper around ResolveInfo In my use case that answers  #4 in a similar way foldSelectionSet does.\nI can submit a pull-request with the wrapper in case you find it useful or maybe inspiring. Our use case is slightly different as we are not solving the fields one by one, rather using a top-down approach resolving the whole request at once and leaving it to this library to process the resulting array.. @vladar sure thing, I'll do the pull request asap (this week), while I really need to start working on this for my project as it currently has some ugly hacks in order to cover for missing type definitions in resolveInfo. @vladar I am not sure what you have in mind when stating += is mostly useful. The effects of it are reflected better on this thread . In my app, useful means no loss of selected fields as opposed to maybe array merging performance. One other way of improving the merge performance and keep the same merging method would be to change the structure of selected fields by using as keys global integers to identify types as opposed to what currently is defined as [type_name] => true, but that can prove ineffective for other purposes. . @vladar it's done now, unless there is something else I can relate to this, thanks. ",
    "Alexandru-Dobre": "Is there any chance the first notation could be permitted once again ?\nWe have a library that uses this and json models in order to build a loopback-like php graphql api factory. \nHaving to move the callback to the fields rather than the type of each field would greatly complicate things since the field is linked to the middleware-connector pipeline during field construction. Here's a link to the concerned code : https://github.com/ampize/alambic/blob/master/src/Alambic/Alambic.php. @vladar Thank you for the suggestion! It worked perfectly with minimum changes to our library code. The rest of the method doesn't need closures as only the \"fields\" part was exposed to a cyclic dependency issue (models for SQL databases had foreign keys pointing to each other) since we automatically exclude non-scalar fields as query args. . ",
    "feihe-houzz": "Thanks. I found out the issue. We can close it (can't close it myself)\n. ",
    "geshido": "Solved here by removing \"... extends PHPUnit_Framework_TestCase\" in file src/Validator/Rules/LoneAnonymousOperation.php\n. #50 \n. @mcg-web Oh, I see. I am using ChromeiQL extention and it runs outdated version of GraphiQL I suppose\n. ",
    "ChristophP": "Sorry I meant to post this on the graphql-laravel repo.\n. ",
    "JohnyDays": "An array, I don't usually use objects in my php code. \n. Alright, that sounds good. I'll probably end up doing that, although I will probably keep this solution for the time being.\nI find objects particularly cumbersome in PHP given that most utilities work with either objects or arrays, and only one of them (arrays) can play the part of both, but an exception for this specific case doesn't sound too bad.\nShould probably close this as expected behaviour right?\n. The way I'm using it that I have singularly defined types somewhere, but their behaviour depends on who their parent resolvers are. E.g while the \"Menu\" type is unfiltered if you are logging in through the admin entry, it will be filtered if the parent route is the regular entry.\nI could just pass the user through the context, or pass it down through all the resolvers, but one isn't generic and the other one sounds cumbersome. Plus I always prefer being explicit.\nWhat I'm doing is adding to context something like \nphp\n$context[\"rules\"] = [\"menu\" => [\"filter\" => [\"type\"=> \"userAuthentication\"]];\nOn the parent resolver, and then the child resolver checks for any rules it received and acts accordingly.\nCould I do this by passing it down through every resolver? Yes, but in other situations context is very necessary, such as when coordinating large transactions in a multi-threaded/event-loop scenario, which isn't the case in php, but I'm sure I could find some other problems solved by it given the time.\nAlso this means I can't accidentally expose the data by having a naming collision in the return type/passed down data.\nCheers \ud83c\udf70  Thanks for the library, it's been insanely helpful.\n. ",
    "rudiedirkx": "Validation requires ALL types to be loaded? Even if the query only touches 3 types, and there are 20 in total? Necessary, or just the way it was built? All fields of all types too? So absolutely no point in lazy loading (closures) any part of it?\nI'm trying a few things locally, but it's a lot harder than I hoped =)\n. I was thinking about ArrayAccess too, but you're probably right. It's unnecessary in 95% of cases, and way slower.\nI know too little about the code to fix it, but I am curious to see the fixing commit.\n. Some kind of preview would also be great: after parsing the query, without any eval, ask it which types are being requested. Or on any level, ask which types are on the next level(s). Any idea?\n. I don't understand how any of these solutions would work. If current implementation really is depth-first, it would have to resolve the first item before evaluating the second, right? So the buffer would never be used. I can't see how this would be possible with depth-first... The core would have to support it, no?\nI like the Deferred solution. It gives a lot of power to the implementor (me). But same problem (or I don't get it): if the executor needs the first object before resolving the second, how can it be deferred?\n. The linked issue/comment talks about map. Is that a GraphQL language thing, or a server/implementation thing? (I understand it's been reverted?)\n. I've found another way to userland it. It's also more response size efficient:\nquery {\n    user {\n        reservations(start: \"2016-10-14\", type: \"\") {   # query to load 30 reservations\n            id\n            date\n            resource {   # is a proxy object with only its id\n                save     # doesn't do a load, but saves id\n                # name   # this would do a (single) load for its properties\n            }\n        }\n    }\n    saved_resources {   # loads the N resources from the 30 reservations\n        id\n        name\n        more\n        expensive {\n            stuff\n        }\n    }\n}\nSince every saved_resource 146 will be the same for every reservation, there's no point in returning {id name more expensive { stuff } } 30 times.\nWith a little more polishing, it could even be very generic and easy on the server, defining it. It's a little more work for the client implementing the results, but it's fewer bytes to download... Is this a known 'solution'?\n. It would be even better, for the client mostly, if GraphQL could return an assoc list, to key saved_resources by id, for easier access. Does GraphQL have a list-type for that? I can imagine keying by id or date can be useful.\n. I haven't tried your workaround yet =) I didn't understand it before, but I think I do now. Just to be clear: remember the list of reservations when it's queried, and when the first resource is queried, I load all relevant resources by the remembered list of reservations. Right? That's doable and could be made generic-ish and readable-ish.\nBut I like getFieldSelection() even better! I didn't know that. That's 100% exactly what I meant in https://github.com/webonyx/graphql-php/issues/60#issuecomment-255479106\nI'll try both soon.\n. I already encountered dark territory btw =) It works decently for to-1 relationships like reservation > resource > sport, but it doesn't at all for reservation > players, because players is a list. To work around that messes up the entire beauty of GraphQL syntax. Actually it does for to-1 relationships too... And all the reasons you layed out!\nThanks for all the quick help!\n. Ah crap. getFieldSelection() doesn't return players inside ... on CourtReservation. Any way to get at that from outside the (inline-or-not) fragment?\n. foldSelectionSet() could include inline fragments. Something like this:\nelse if ($selectionAST instanceof InlineFragment) {\n    $subfields = $this->foldSelectionSet($selectionAST->selectionSet, $descend - 1);\n    foreach ($subfields as $name => $subdefinition) {\n        $fields[$selectionAST->typeCondition->name->value . ':' . $name] = $subdefinition;\n    }\n}\nbut I'm probably missing complex something in $selectionAST->typeCondition->name->value.\nThat would make $nestedFields:\n```\nArray\n(\n    [resource] => Array\n        (\n            [id] => 1\n            [name] => 1\n        )\n[CourtReservation:players] => Array\n    (\n        [costs] => 1\n        [user] => 1\n    )\n\n[ClassReservation:costs] => 1\n[ClassReservation:user] => Array\n    (\n        [save] => 1\n    )\n\n)\n```\nand that works for me. This allows eager loading, which makes a big difference in the number of db queries.\nIs there a reason foldSelectionSet() doesn't include inline fragments?\n. In my framework, I can eager load all kind of relationships, to-1 and to-many. The active records know where to fetch what for which ids:\n$reservations = someLogic();\n// to-1\n$resources = ARO::eagerOne($reservations, 'resource'); // Loads and attaches all 'resource' objects: $reservations[0]->resource\n$sports = ARO::eagerOne($resources, 'sport'); // And even the next level\n// to-many\n$players = ARO::eagerMany($reservations, 'players'); // Loads and attaches all 'player' objects: $reservations[0]->players[0]\nIf I know what to expect (with getFieldSelection), I can use that exact logic to eager load relationships, without any change in existing code. Schema could contain (custom) meta data to auto-eager-load relationships if they're in nestedFields.\nWe're getting somewhere! Thanks. I'm still trying your original workaround suggestion some time soon.\n. Promises in PHP. Makes no sense to me at all.\nIf #61 gets in, or something like it, the server implemenation can eager load most efficiently with existing architecture. Works for any number of levels down.\nSome kind of data loader would be nice too, but faking promises in PHP seems silly.\n. So many different opinions and best/good/decent practices! Speed is most important to me. The more awesome and more options, the slower, probably.\n. Have any brilliant solutions come up? With this, or something like it, I can make very efficient getters.\n. Sure, I could use my own method, but I rather use your shiny new very awesome new method. I'm very curious to see this more elegant way. Sneak preview anywhere? Create issue to track progress? You can close this PR.\n. I'm afraid that will be very slow. Seems like a lot of parsing before even parsing the query, and then executing it. Serialization is especially useful if it skips the expensive part, but serializing this wouldn't skip the expensive part (parsing it).\nMaybe there's a readable in-between solution: define a factory and accept string types. (Still using Type::listOf probably.)\nThis format is fantastic in JS because you can comments: [CommentType] and names: [String], because JS types are variables, but PHP doesn't have that, so maybe the schema syntax shouldn't try.\n(I'm mostly interested in speed, not configuration ease or prettiness.)\n. I didn't mean PHP parsing the array. I bet that's fast. I mean your code has to parse the array. It has to parse '[Mention!]' and 'Id' and there will be many of those. Every ms it's parsing and not yet executing is a waste. I'm very curious to see the performance difference.\nMy current (not big) schema takes 10-11 ms to init, and only then does it start parsing the query and executing it. I've tried a few different libraries and methods and this one's the fastest, done like in the README, with use (&$humanType, &$droidType) etc.\n. What's the current/dev best way to define a schema? Still everything in one place with many closures?, or have I missed a cool new feature in the meantine?. If I delete the User field to a CourtReservation, it also complains about Unknown type \"CourtReservation\", so at least it's predictably consistent. Not much better though.\nThe relevant schema (paraphrased, because it doesn't exist like this):\n```\ntype UserQuery {\n  user: User\n}\ntype User {\n  reservations: [ReservationInterface]\n}\ninterface ReservationInterface {\n  id: int\n}\ntype CourtReservation {\n  id: int\n}\ntype ClassReservation {\n  id: int\n}\n``. I guess I understand why it happens. An interface doesn't know its implementations. And there's no name-to-type registry. But how do I fix it without preloading all types in the schema?. I suppose that's exactly whattypes` is for...\n\nMost often it happens when the object type is never referenced in fields directly but is still a part of a schema because it implements an interface which resolves to this object type in its resolveType callable. \nhttp://webonyx.github.io/graphql-php/type-system/schema/#configuration-options\n\nSo lazy loading is not what I expected. It's not lazy-only-when-needed. It's more lazy-in-the-right-order.\nSorry! Carry on.. If __invoke is good enough for the graphql lib, that might be good enough for me. That depends on how callability is checked everywhere. You know that, I haven't checked.\nI'm gonna try it. Be right back.. Yes. That works perfectly! Thanks.. Not really. The type condition is important, because implementor A and B could both query field X, but have different children, because they mean something else:\n... on A {\n  some {\n    type\n  }\n}\n... on B {\n  some {\n    kind\n  }\n}\nsome isn't in the interface, because they're a different kind of some, they just have the same name.\nWould B win and overwrite A's type?\n. Maybe a new kind of nesting level instead of prefixing the key? Not very bc. Or returning a new, array accessible object with meta data like this? Could be bc, but might be overkill.\nAlso, I'm not sure this patch includes all cases: inline fragment, named fragment, inline fragment inside named fragment, etc. I've tried only 2 of many scenarios.\n. ",
    "lordthorzonus": "@vladar @rudiedirkx  I tried yesterday to quickly implement dataloader in PHP with ReactPHP and it works quite nicely : https://github.com/lordthorzonus/php-dataloader (Still quite much a work in progress though ). \nI'm interested in trying it out with the package. Basically I would need to edit the Executors executeFields and execute to support to wait all the field resolving stuff and return a promise if I understood the source right.. \nThen it should be just this at the endpoint : \n``` php\n$response = null;\n$eventLoop // get this from somewhere (the same event loop should be provided for the dataprovider).\nGraphQL::execute(...)->then(function($result) use (&$response) {\n  $response = $result;\n});\n$eventLoop->run();\necho json_encode($response);\n```\nI think I'll have time to play around with this later this week :). \n. I'm using ReactPromiseAdapter in a React event loop environment. \nThe batch loader I'm using returns a promise which resolves into a value (the relation between entities in this case is one eventParticipant has one contactInfo and contactInfo has one companyInfo).\nI think the problem is the wrong order of index keys in array. For my examples I shortened the responses (the real one would contain 600 entities), Sorry for being unclear :). I tried var dumping the execution result before json_decoding and the keys are integers like they should.  \nThe print_r looks following where the un-ordering first occurs: \n```\nArray\n(\n    [data] => Array\n        (\n            [eventParticipantsForAnEvent] => Array\n                (\n                    [0] => Array\n                        (\n                            [id] => 89906\n                            [masterContact] => Array\n                                (\n                                    [id] => 112218\n                                    [masterCompany] => Array\n                                        (\n                                            [id] => 25623\n                                        )\n                            )\n\n                    )\n\n                [1] => Array\n                    (\n                        [id] => 89919\n                        [masterContact] => Array\n                            (\n                                [id] => 112570\n                                [masterCompany] => Array\n                                    (\n                                        [id] => 25696\n                                    )\n\n                            )\n\n                    )\n\n                [2] => Array\n                    (\n                        [id] => 90531\n                        [masterContact] => Array\n                            (\n                                [id] => 112622\n                                [masterCompany] => Array\n                                    (\n                                        [id] => 25711\n                                    )\n\n                            )\n\n                    )\n\n                [3] => Array\n                    (\n                        [id] => 90541\n                        [masterContact] => Array\n                            (\n                                [id] => 112869\n                                [masterCompany] => Array\n                                    (\n                                        [id] => 25803\n                                    )\n\n                            )\n\n                    )\n\n                [4] => Array\n                    (\n                        [id] => 90547\n                        [masterContact] => Array\n                            (\n                                [id] => 113275\n                                [masterCompany] => Array\n                                    (\n                                        [id] => 25890\n                                    )\n\n                            )\n\n                    )\n\n                [549] => Array\n                    (\n                        [id] => 106767\n                        [masterContact] => Array\n                            (\n                                [id] => 460759\n                                [masterCompany] => Array\n                                    (\n                                        [id] => 25890\n                                    )\n\n                            )\n\n                    )\n\n            )       \n    )\n\n)\n```\nAs for the unit testing I think we just need to new up the event loop and run that explicitly before asserting the test results.\nPlease let me know if you need some more info! I can for example try to replicate this in a dummy repo with some mock data :).. Basically resolving promises async makes the array unordered. Here is a messy test to reproduce the problem.  We are expecting an array with of [1,2,3] (keys: 0,1,2) for the test field but we are actually getting it in order [1,3,2] (keys:0,2,1) as the second promise is resolved async later than the others. I think the problem happens somewhere when we are doing $promise->all(); The arrays keys are somehow preserved but the order changes as the values are resolved in different order.\n```php\n    public function testPromiseListsPreserveTheirArrayKeyOrder()\n    {\n        $loop = \\React\\EventLoop\\Factory::create();\n        Executor::setPromiseAdapter(new ReactPromiseAdapter());\n    $testData = [\n        new \\React\\Promise\\Promise(\n            function ($resolve) use ($loop) {\n                $loop->nextTick(\n                    function () use ($resolve) {\n                        $resolve(1);\n                    }\n                );\n            }\n        ),\n        new \\React\\Promise\\Promise(\n            function ($resolve) use ($loop) {\n                $loop->nextTick(\n                    function () use ($resolve, $loop) {\n                        \\React\\Promise\\resolve()->then( function() use ($resolve, $loop) {\n                            $loop->nextTick(function () use ($resolve) {\n                                $resolve(2);\n                            });\n                        });\n                    }\n                );\n            }\n        ),\n        new \\React\\Promise\\Promise(\n            function ($resolve) use ($loop) {\n                $loop->nextTick(\n                    function () use ($resolve) {\n                        $resolve(3);\n                    }\n                );\n            }\n        )\n    ];\n\n    $expected =  [ 'data' => [ 'nest' => [ 'test' => [ 1, 2, 3 ] ] ] ];\n    $expectedJson = json_encode($expected);\n\n\n    $data = ['test' => $testData];\n    $dataType = null;\n    $testType = Type::nonNull(Type::listOf(Type::nonNull(Type::int())));\n\n    $dataType = new ObjectType(\n        [\n            'name' => 'DataType',\n            'fields' => function () use (&$testType, &$dataType, $data) {\n                return [\n                    'test' => [\n                        'type' => $testType\n                    ],\n                    'nest' => [\n                        'type' => $dataType,\n                        'resolve' => function () use ($data) {\n                            return $data;\n                        }\n                    ]\n                ];\n            }\n        ]\n    );\n\n    $schema = new Schema(['query' => $dataType]);\n\n    $ast = Parser::parse('{ nest { test } }');\n    $result = Executor::execute($schema, $ast, $data);\n\n    $response = null;\n    $loop->run();\n\n    $result->then(function($value) use (&$response) {\n        $response = $value;\n    });\n\n    $this->assertEquals($expectedJson, json_encode($response->toArray()));\n}\n\n```. I investigated bit further and this could be a problem (or indented behavior) in ReactPHP itself. I opened a issue there : https://github.com/reactphp/promise/issues/74 .\nIf it's indented the question is should we ever expect a unordered array as a list? As it should be a list by GraphQl spec. Javascript doesn't have this problem as arrays are always in order and arrays with gaps are converted to json arrays correctly.\nThanks a thousand for help! :). @mcg-web @vladar  :+1: I was thinking the same. I'll update the PR. Do we want tests as well for this? Then we probably need to add react/event-loop and react/promise as a dev-dependency. Is it acceptable? . @vladar PR updated. Added tests and fixed the all() behaviour. \nReactPromiseAdapterTest is now excluded with phpunit's group feature from the default run (and travis runs them by using the group flag --group default,RectPromise. It's also marked as skipped if somebody tries to run it and hasn't got the react/promise package installed.\n. @vladar Yup! Currently running a small api gateway in prod and it works like a charm, thanks for the awesome package :). \n@adri We are using https://github.com/lordthorzonus/php-dataloader as the dataloader/batch-loader as it's integrated with React's event-loop. And then returning it's promises from resolvers. In our codebase it looks something like this: \n```php\n<?php\nclass EventType extends AbstractObjectType\n{\n    protected $name = 'Event';\n/**\n * @var TypeRepository\n */\nprivate $types;\n\n/**\n * @var CountryByIdLoader\n */\nprivate $countryLoader;\n\npublic function __construct(TypeRepository $types, CountryByIdLoader $countryLoader)\n{\n    $this->types = $types;\n    $this->countryLoader = $countryLoader;\n}\n\npublic function fields()\n{\n    return [\n        'id' => [\n            'type' => Type::int(),\n        ],\n        'country' => [\n            'type' => $this->types->getType(CountryType::class),\n            'resolve' => function (Event $event) {\n                return $this->countryLoader->load($event->countryId);\n            },\n        ],\n    ];\n}\n\n}\n```\nThen in our controller endpoint we are just executing the query, telling the event-loop to run and returning the resolved response. Note that we are using still older version of this package where the results could be either promises or ExecutionResults. (should update soon..)  This is not the case anymore if I have been following the package's development correctly. Now you should probably just call GraphQl::promiseToExecute() and be happy.  @vladar Can probably confirm this?\nPseudo code example:\n```php\n<?php\nclass GraphqlController extends Controller\n{\n    /*\n     * @var GraphQl\n     /\n    private $graphQl;\n/**\n * @var LoopInterface\n */\nprivate $loop;\n\npublic function __construct(GraphQl $graphQl, LoopInterface $loop)\n{\n    $this->graphQl = $graphQl;\n    $this->loop = $loop;\n}\n\npublic function queryAction(Request $request)\n{\n    $query = $request->getBodyParam('query');\n    $variables = $request->getBodyParam('variables');\n\n    $result = $this->graphQl->execute($query, null, null, $variables);\n\n    // There is a possibility in our API gateway that the query isn't using promises at all\n    // In that case a normal result is returned. Otherwise we'll handle the promise.\n    if (!is_array($result)) {\n        return $this->handlePromiseResult($result);\n    }\n\n    return $result;\n}\n\nprivate function handlePromiseResult(Promise $result)\n{\n    $response = null;\n\n    // Let the EventLoop run to resolve the promises.\n    $this->loop->run();\n\n    $result->then(\n        function ($promiseResult) use (&$response) {\n            $response = $promiseResult;\n        }\n    );\n\n    return $response;\n}\n\n}\n```\nThe graphql class that we use is just a small wrapper around https://github.com/webonyx/graphql-php/blob/master/src/GraphQL.php which just builds our schema and sets the correct PromiseAdapter in our DI container when it's constructed. \nThe same singleton EventLoop is injected from DI container to all our data loaders and to the controller.\nHope this helps! Ping me if there's something you would like to discuss, happy to help :).\n. ",
    "coveralls": "\nCoverage decreased (-0.1%) to 88.58% when pulling 6e0904bb6e0d5fa663b06c66e76911f1f22de6f6 on rudiedirkx:inlinefragment into 4a75bc6d2f97ca8717ab716b3279584769862941 on webonyx:master.\n. \n\nCoverage increased (+0.1%) to 88.458% when pulling 76c31df1af55d0a8ba8ddae9f8912f5df5a77be6 on mcg-web:promise into 49453174061bbbe61a8189f87bad0b708495ff9c on webonyx:master.\n. \nCoverage remained the same at 88.353% when pulling 4867c4ceca01c4157ef11d31fdf1fd6d598d39a7 on mcg-web:fix-missing-requirement into 986eff9bff5715c25d1452c51166fe59c3d786e5 on webonyx:master.\n. \nCoverage decreased (-0.2%) to 88.185% when pulling 4e6b052465fab954c010ad7d7452736cf608116b on mcg-web:optimized-travis-ci-tests into 986eff9bff5715c25d1452c51166fe59c3d786e5 on webonyx:master.\n. \nCoverage decreased (-0.1%) to 88.257% when pulling 0fc17595d89684fc75a1388d42aa961772bd586d on mcg-web:type-config-builder into 986eff9bff5715c25d1452c51166fe59c3d786e5 on webonyx:master.\n. \nCoverage increased (+0.06%) to 88.409% when pulling 95b46b7d34a7e5c80f5dcf6db778c948581d6e71 on mcg-web:type-config-builder into 986eff9bff5715c25d1452c51166fe59c3d786e5 on webonyx:master.\n. \nCoverage decreased (-0.3%) to 88.068% when pulling 31cdc0b8fe59987152a0b7e4bc97eb5704cfa9de on mcg-web:type-config-builder into 986eff9bff5715c25d1452c51166fe59c3d786e5 on webonyx:master.\n. \n\nCoverage decreased (-0.1%) to 92.745% when pulling 758294abe50233b4385b814cecc3bece0f974c10 on mcg-web:type-config-builder into a3f18b51f76d071652777ec17b6664525340849b on webonyx:master.\n. \n\nCoverage increased (+0.07%) to 92.939% when pulling 691f558101731ff7aaf39f8326c300070ebce70a on mcg-web:type-config-builder into a3f18b51f76d071652777ec17b6664525340849b on webonyx:master.\n. \nCoverage decreased (-0.006%) to 88.179% when pulling 428870aae42ca93bb35cc4b9213a6129cdb9d15b on AndreasHeiberg:add-null-value into 1ee29e373c91e00c0fb8a287594b575955568c33 on webonyx:master.\n. \n\nCoverage increased (+0.002%) to 89.542% when pulling b6132dd30388550eeb3f3750e2cf85f4baab5fcb on rocket-monkey:locations-patch into c5bba0e7d4a550409027c7658759be944b4fa959 on webonyx:master.\n. \n\nCoverage increased (+0.006%) to 91.889% when pulling 54ece56266519add982655cfa7acf1057c693a21 on lordthorzonus:nested-async-queries-mess-the-indexes-of-arrays into ff3a40d32969a1b32dd5219cdc31a8f5009a5bc9 on webonyx:master.\n. \n\nCoverage increased (+0.5%) to 92.418% when pulling e3a864f0711f4e171539e71d4e970235af7e7ccc on lordthorzonus:nested-async-queries-mess-the-indexes-of-arrays into ff3a40d32969a1b32dd5219cdc31a8f5009a5bc9 on webonyx:master.\n. \n\nCoverage increased (+0.5%) to 92.418% when pulling 8626e0b45d1305b43d9f9e297a608c6269e2b3c6 on lordthorzonus:nested-async-queries-mess-the-indexes-of-arrays into ff3a40d32969a1b32dd5219cdc31a8f5009a5bc9 on webonyx:master.\n. \n\nCoverage increased (+0.5%) to 92.418% when pulling 8626e0b45d1305b43d9f9e297a608c6269e2b3c6 on lordthorzonus:nested-async-queries-mess-the-indexes-of-arrays into ff3a40d32969a1b32dd5219cdc31a8f5009a5bc9 on webonyx:master.\n. \n\nCoverage remained the same at 92.418% when pulling 1adfe2118594e23366bf6ae1fa56964980d50f9b on bertrandgauthier:master into 595ae52e858eb89cdc73fe7a9b03611dd540ac06 on webonyx:master.\n. \n\nCoverage decreased (-0.1%) to 92.275% when pulling d022b19b4ea256573ca92fc33cb48a91d9d3c1e3 on OwlyCode:php7-errors-handling into 5be0944453728746ae7dd5d3100d20b3088f1b89 on webonyx:master.\n. \n\nCoverage remained the same at 93.123% when pulling 1ff9c429d60d5773bf198bec7bff3267c73b0e7d on danez:patch-1 into fa9611738deca949f79d61b1a33119428bd9919d on webonyx:master.\n. \n\nCoverage decreased (-0.05%) to 92.988% when pulling 060dc515952488bd4d6b3900a7127839e7b2bd35 on jane-olszewska:schema-description-in-comments into c18cd1696063ded179a51669592105127815d1ed on webonyx:master.\n. \n\nCoverage increased (+0.03%) to 93.064% when pulling 008fd20498b6634b9753b411a02bb6239f5afe98 on jane-olszewska:schema-description-in-comments into c18cd1696063ded179a51669592105127815d1ed on webonyx:master.\n. \n\nCoverage increased (+0.04%) to 93.101% when pulling 97674cbbb96f2668a80227f5f9e524d9a3382b69 on aldumas:assign_fix into c2f0749d8e9ed0edeaf7c9a206e28b1c5c45fe80 on webonyx:master.\n. \n\nCoverage decreased (-6.008%) to 87.093% when pulling 46fdc0d0220da6c08380c9ad30af861a887359fc on petecoop:build-schema into 0bd7c9d40562d3906b53fbe3e237a8b1d9c5fcc2 on webonyx:master.\n. \n\nCoverage increased (+0.5%) to 93.596% when pulling c5e3e167e4ef756c6a40c95f1b2a62fa77a2c476 on petecoop:build-schema into 0bd7c9d40562d3906b53fbe3e237a8b1d9c5fcc2 on webonyx:master.\n. \n\nCoverage increased (+0.5%) to 93.595% when pulling fc629a292d6319b00afe9d43e4e313fde9623b81 on petecoop:build-schema into 0bd7c9d40562d3906b53fbe3e237a8b1d9c5fcc2 on webonyx:master.\n. \n\nCoverage increased (+0.5%) to 93.595% when pulling 664af3d44a312bf4da04e2a64c0b5ce276a7a2a6 on petecoop:build-schema into 0bd7c9d40562d3906b53fbe3e237a8b1d9c5fcc2 on webonyx:master.\n. \n\nCoverage increased (+0.5%) to 93.595% when pulling 664af3d44a312bf4da04e2a64c0b5ce276a7a2a6 on petecoop:build-schema into 0bd7c9d40562d3906b53fbe3e237a8b1d9c5fcc2 on webonyx:master.\n. \n\nCoverage increased (+0.001%) to 93.596% when pulling e35b57601df3194cb4e1c79498b93a2239fa74f8 on webmozart:sync-promise-adapter-indices into ed41a4ce43e354a0e2218d11c78b5d1ab86e3140 on webonyx:master.\n. \n\nCoverage remained the same at 93.717% when pulling 51e67d49c7ab5bf78bc395d1e8d63a4e42c37503 on decebal:master into f77bd17eba9d4b2db5e128f2e943e8a577f83bf8 on webonyx:master.\n. \n\nCoverage remained the same at 93.717% when pulling ca92ae46887a393cf09af6508b3acde125da514c on decebal:master into f77bd17eba9d4b2db5e128f2e943e8a577f83bf8 on webonyx:master.\n. \n\nCoverage remained the same at 93.717% when pulling 070ab7d4302e1a03ac1755f6fc013161d71788a9 on PowerKiKi:patch-1 into 7ef9f9167296e8e25c53bc4cc9c2e33b735aaa63 on webonyx:master.\n. \n\nCoverage remained the same at 93.717% when pulling 5ca69c6ec8a5f4b57426b2533db05edc0a8911c3 on PowerKiKi:patch-1 into ac5c518cbe2e71fcad11b9131ff1f3fb7237ac2b on webonyx:master.\n. \n\nCoverage decreased (-0.3%) to 93.439% when pulling ed8bf4e2b2ec23f44a8d5b33dba9e1329d484671 on AndreasHeiberg:fix-to-string-node into cb40df220e47db3832fb0315b20a827fb5ac6e3d on webonyx:master.\n. \n\nCoverage increased (+0.02%) to 93.461% when pulling 11a1b13b722af292cbcaf1636458106e9cb530c6 on pascaldevink:add_directives_to_complexity_calculation into 5948d5198eb5f5a64edc7823792a819ac9a77752 on webonyx:master.\n. \n\nCoverage remained the same at 93.493% when pulling 1e89fcec253ad5aca7acaa9fdf20be8a578f6b54 on TerraSkye:patch-1 into 848f9c3edfbfbfa0903f4dd76ee2fec1cfb12224 on webonyx:master.\n. \n\nCoverage remained the same at 93.493% when pulling 8a5f337469c47f7f8696de7226cb9f7d58bd7f44 on leocavalcante:resolve-callables into 848f9c3edfbfbfa0903f4dd76ee2fec1cfb12224 on webonyx:master.\n. \n\nCoverage remained the same at 93.493% when pulling 06183635f58365278bca88ebbad929f55c9cc72f on shinderohitt:patch-1 into 848f9c3edfbfbfa0903f4dd76ee2fec1cfb12224 on webonyx:master.\n. \n\nCoverage remained the same at 93.493% when pulling a2062757c13be36f00e16ea50ca800eed252a771 on mcg-web:use-dedicated-exception-for-type-parsing-error into 53edfa0f84c3eda40ffb2093883125eeed80a9e1 on webonyx:master.\n. \n\nCoverage remained the same at 93.493% when pulling 6d5b4e5a379d98c2b901165f04b7e3072ac1a6eb on mcg-web:use-dedicated-exception-for-type-parsing-error into 53edfa0f84c3eda40ffb2093883125eeed80a9e1 on webonyx:master.\n. \n\nCoverage decreased (-0.03%) to 93.47% when pulling 2a992fac6d63c30fceb4cc0b0ca816eab51f04b7 on danez:throwable into e7cde5ecf3b0796db34d492f0698498eefe85bcf on webonyx:master.\n. \n\nCoverage decreased (-0.03%) to 93.447% when pulling 65ef159ddc0d53d6832a9eabefdefa6fd21ec52e on danez:throwable into a0657b784779d770b2aeef80bd98ed36c19dbc70 on webonyx:v0.10.\n. \n\nCoverage decreased (-0.02%) to 93.48% when pulling 66a1897dcba4566af55263a5186911d9ded54d50 on aelnagger:array_lexer into e7cde5ecf3b0796db34d492f0698498eefe85bcf on webonyx:master.\n. \n\nCoverage increased (+0.02%) to 93.517% when pulling beaf91d08089f457c1dac289297f68d03e492a94 on n1ru4l:feature-disable-introspection-validation-rule into e7cde5ecf3b0796db34d492f0698498eefe85bcf on webonyx:master.\n. \n\nCoverage increased (+0.02%) to 93.517% when pulling beaf91d08089f457c1dac289297f68d03e492a94 on n1ru4l:feature-disable-introspection-validation-rule into e7cde5ecf3b0796db34d492f0698498eefe85bcf on webonyx:master.\n. \n\nCoverage remained the same at 93.497% when pulling 6a4785dc4a8802a223df6862385139c68a204c77 on simPod:master into e7cde5ecf3b0796db34d492f0698498eefe85bcf on webonyx:master.\n. \n\nCoverage decreased (-1.04%) to 93.517% when pulling d2363aefd1136262788bc29a5fff2e9e959ed029 on lucasmichot:feature/master/psr2 into 141afc1cf7353753b0313e9ea17eea2560ded12d on webonyx:master.\n. \n\nCoverage decreased (-1.1%) to 93.451% when pulling d2363aefd1136262788bc29a5fff2e9e959ed029 on lucasmichot:feature/master/psr2 into 141afc1cf7353753b0313e9ea17eea2560ded12d on webonyx:master.\n. \n\nCoverage decreased (-1.04%) to 93.517% when pulling c20a1e7c5a31e8e7028e68ebcee86dfc19cd2934 on AndreasHeiberg:layz-loading-test into 141afc1cf7353753b0313e9ea17eea2560ded12d on webonyx:master.\n. \n\nCoverage remained the same at 93.874% when pulling 81376e7c34c4b48834dabc7f4dacf2c274515da8 on symm:shorthand-docs into bc6a7a3d1dd7b3d3f6b242fd94fc628c28c9c1cb on webonyx:master.\n. \n\nCoverage remained the same at 93.848% when pulling 7afd6d3f9abc21a4f658818f93cd88d882e451a9 on zeeshanu:patch-1 into 8fe26a1a21e3a96e470b5712bc9d392239e8308f on webonyx:master.\n. \n\nCoverage remained the same at 93.848% when pulling 658816180aa4a07d4cfcc6f075a230a6073506b0 on swinyx:patch-1 into fa17d6c4615b4956618a4176d8c6aab0bd1e4e91 on webonyx:master.\n. \n\nCoverage increased (+0.004%) to 93.852% when pulling 1c143360ca5fbb5d72246e37652fa07cc9502f9f on mcg-web:add-hooks-while-completing-sync-promise into 9d150c7702dd5705d5486e99869e4041cc96ca71 on webonyx:master.\n. \n\nCoverage increased (+0.06%) to 92.373% when pulling d22385cc93f8c7fe0558a9e47d7c54b428a71fdb on dereklavigne18:query_variable_coercion into 7cc863df37b2270ec2b57cb9d322da064d832a59 on webonyx:master.\n. \n\nCoverage increased (+0.07%) to 92.589% when pulling 440d38d3bce3b979953bd0423a579ebf26889a5f on GabrielDeveloper:develop into fb0ca607e2cab06caf321dddac087a5a79d8f04f on webonyx:master.\n. \n\nCoverage remained the same at 92.646% when pulling 3ed55307a7b2ff0a32f5165830694833d1267df5 on ivome:master into b17b1c33366d07877feb4299f207a420fbfe53b5 on webonyx:master.\n. \n\nCoverage decreased (-0.3%) to 92.31% when pulling 7e63e5750fe9ff1879f632353d949813369351e8 on crirus:master into 57f5ee37834c58c86e6dafa5b272ef9d11ca6dc5 on webonyx:master.\n. \n\nCoverage decreased (-0.2%) to 92.425% when pulling 64b1140be6da8e4212b39614fd2c044ea14aff96 on crirus:master into 57f5ee37834c58c86e6dafa5b272ef9d11ca6dc5 on webonyx:master.\n. \n\nCoverage decreased (-0.2%) to 92.413% when pulling c2d65143dbb56134c1ddb1bf1fb8c0a297f49388 on crirus:master into 57f5ee37834c58c86e6dafa5b272ef9d11ca6dc5 on webonyx:master.\n. \n\nCoverage remained the same at 92.646% when pulling cf3ca86246692b7664aee7f750f9d71851b86a9f on gabidj:patch-1 into 57f5ee37834c58c86e6dafa5b272ef9d11ca6dc5 on webonyx:master.\n. \n\nCoverage remained the same at 92.646% when pulling 9b449745ab5278de6edb2724fe029088403c2971 on gabidj:patch-1 into 57f5ee37834c58c86e6dafa5b272ef9d11ca6dc5 on webonyx:master.\n. \n\nCoverage remained the same at 92.646% when pulling 9b449745ab5278de6edb2724fe029088403c2971 on gabidj:patch-1 into 57f5ee37834c58c86e6dafa5b272ef9d11ca6dc5 on webonyx:master.\n. \n\nCoverage decreased (-0.007%) to 92.639% when pulling c62b2e7b9cb1b7cfc566eac326305259b7cb2a66 on aelnagger:extensions into eaadae4a5b3fe989ee4f614ab1c0ada7df4180cd on webonyx:master.\n. \n\nCoverage increased (+0.02%) to 92.668% when pulling 8e0696c48c9e5c5f50a91cddde1e890161a7f0b1 on aelnagger:extensions into eaadae4a5b3fe989ee4f614ab1c0ada7df4180cd on webonyx:master.\n. \n\nCoverage increased (+0.03%) to 92.673% when pulling a7dde50292d8fe485e1d9e6e2fef07112eab8920 on aelnagger:extensions into eaadae4a5b3fe989ee4f614ab1c0ada7df4180cd on webonyx:master.\n. \n\nCoverage increased (+0.007%) to 92.653% when pulling 91ea2366204355d35532cff2e39aa457204e7ec1 on aelnagger:extensions into eaadae4a5b3fe989ee4f614ab1c0ada7df4180cd on webonyx:master.\n. \n\nCoverage increased (+0.2%) to 92.873% when pulling 91ea2366204355d35532cff2e39aa457204e7ec1 on aelnagger:extensions into eaadae4a5b3fe989ee4f614ab1c0ada7df4180cd on webonyx:master.\n. \n\nCoverage increased (+0.2%) to 92.88% when pulling 0385acaa81e968ea854f037de6ab4305e3b0d941 on aelnagger:extensions into eaadae4a5b3fe989ee4f614ab1c0ada7df4180cd on webonyx:master.\n. \n\nCoverage decreased (-1.0%) to 91.667% when pulling 4ea6cbe839ad41e37840413fc83d6a463897ed69 on roippi:findbreakingchanges into eaadae4a5b3fe989ee4f614ab1c0ada7df4180cd on webonyx:master.\n. \n\nCoverage decreased (-0.4%) to 92.263% when pulling 3c0ed787ba5f9f49eb4d3771912c8755e1101df1 on roippi:findbreakingchanges into eaadae4a5b3fe989ee4f614ab1c0ada7df4180cd on webonyx:master.\n. \n\nCoverage increased (+0.1%) to 92.794% when pulling 533b8b8b5f499ac06a54baf48be55b72ee3bef0f on roippi:findbreakingchanges into eaadae4a5b3fe989ee4f614ab1c0ada7df4180cd on webonyx:master.\n. \n\nCoverage increased (+0.2%) to 92.847% when pulling b18dfd670ffa1891413044a9ea454242ba3307c8 on roippi:findbreakingchanges into eaadae4a5b3fe989ee4f614ab1c0ada7df4180cd on webonyx:master.\n. \n\nCoverage increased (+0.003%) to 92.649% when pulling 11c9429fabd8b646356fc30c65e7bb7a4e7f8a17 on PowerKiKi:support-non-parsed-psr7 into eaadae4a5b3fe989ee4f614ab1c0ada7df4180cd on webonyx:master.\n. \n\nCoverage increased (+0.005%) to 92.843% when pulling baa2eb5098ed7768ceff556d28ff75e7531509dc on otzy:master into 3536280fac093cd482c439d4cf361ff60d3e47e6 on webonyx:master.\n. \n\nCoverage increased (+0.004%) to 92.842% when pulling ffa7fa06cda8fb02bcc6e6ec40ffc805be8bf0e5 on otzy:master into 3536280fac093cd482c439d4cf361ff60d3e47e6 on webonyx:master.\n. \n\nCoverage remained the same at 92.838% when pulling 25e341e9d9309368f6399506febe71e09a0f2f46 on enumag:patch-1 into 3536280fac093cd482c439d4cf361ff60d3e47e6 on webonyx:master.\n. \n\nCoverage increased (+0.03%) to 92.866% when pulling 9e2c1dae8777663409b6b2773a1752b4134720b9 on enumag:patch-1 into 3536280fac093cd482c439d4cf361ff60d3e47e6 on webonyx:master.\n. \n\nCoverage remained the same at 92.866% when pulling f6c3fe3758b185c5b484f5ae4e71b05913ca8296 on enumag:patch-2 into b97cad0f4a50131c85d9224e8e36ebbcf1c6b425 on webonyx:master.\n. \n\nCoverage increased (+0.01%) to 92.877% when pulling 178b179db3b4fd6d0d9d5499ee99f9005b7ba415 on PowerKiKi:no-parsing into a3f18b51f76d071652777ec17b6664525340849b on webonyx:master.\n. \n\nCoverage increased (+0.004%) to 92.87% when pulling 9c855db9e1dcbe870778a11d88bc6844a28fc7b0 on PowerKiKi:upload into a3f18b51f76d071652777ec17b6664525340849b on webonyx:master.\n. \n\nCoverage remained the same at 92.866% when pulling 5c6f69c254062bb3d1a9cba153dc5bed48db07c2 on giansalex:master into a3f18b51f76d071652777ec17b6664525340849b on webonyx:master.\n. \n\nCoverage decreased (-0.01%) to 92.851% when pulling 90978ea78da9354c2ace52a1fbe0a68fc5073efd on giansalex:master into a3f18b51f76d071652777ec17b6664525340849b on webonyx:master.\n. \n\nCoverage decreased (-0.01%) to 92.851% when pulling 5cbaf973e18203541d107914933a3cc32b8349df on PowerKiKi:concise-tests into a3f18b51f76d071652777ec17b6664525340849b on webonyx:master.\n. \n\nCoverage remained the same at 92.84% when pulling dca2091351bdcad484df898d28c3be465f8bd756 on Poky85:fix-content-type-header into 7310b2573092b11ca84b451de1a0241256681e17 on webonyx:master.\n. \n\nCoverage remained the same at 92.84% when pulling 944ccebc088c9247d59477bf578cd9c27b7b003d on mcg-web:some-fixes into ccecc3ce1bc1021b708f8d63500613389848c7f7 on webonyx:master.\n. \n\nCoverage increased (+0.001%) to 92.841% when pulling 3f6b4786ac5185b3ba4afdba8c003fb89dc4aa9b on dimitri-koenig:feature/add-missing-promiseToExecute-params into ccecc3ce1bc1021b708f8d63500613389848c7f7 on webonyx:master.\n. \n\nCoverage decreased (-0.006%) to 92.834% when pulling b8429575760cdcce48cccb3994378a180319f62d on danez:013-interfaces into 94525c00252696b47673db1ca56fe0436c5949be on webonyx:master.\n. \n\nCoverage decreased (-0.08%) to 92.757% when pulling f475cdf20c4360207b5fa7e2ab928363e646fe7a on danez:012-block-strings into 94525c00252696b47673db1ca56fe0436c5949be on webonyx:master.\n. \n\nCoverage remained the same at 92.84% when pulling c2ca2f97e2ffef6026ab460858bb741868348954 on danez:012-typeinfo into 94525c00252696b47673db1ca56fe0436c5949be on webonyx:master.\n. \n\nCoverage remained the same at 92.84% when pulling 7e5d83caa29e69ee67f5b014fde18fef00b0bc3a on danez:012-uniform-parsing into 94525c00252696b47673db1ca56fe0436c5949be on webonyx:master.\n. \n\nCoverage increased (+0.05%) to 92.89% when pulling 51315af0b870dd7ca73c3c6bafa2684591e0a50c on danez:012-small-stuff into 94525c00252696b47673db1ca56fe0436c5949be on webonyx:master.\n. \n\nCoverage decreased (-0.05%) to 92.791% when pulling 18556f6caab3a01d430dd442449d1a178f189241 on danez:012-descriptions into 94525c00252696b47673db1ca56fe0436c5949be on webonyx:master.\n. \n\nCoverage increased (+0.07%) to 92.91% when pulling f6fd32dd71b1335db67b09619c67a87edee4129f on danez:012-parsing-default into 94525c00252696b47673db1ca56fe0436c5949be on webonyx:master.\n. \n\nCoverage decreased (-1.1%) to 91.738% when pulling 3e067cc60fb720703453904f1351f3acbfb4b453 on danez:012 into 94525c00252696b47673db1ca56fe0436c5949be on webonyx:master.\n. \n\nCoverage increased (+0.02%) to 92.855% when pulling 654c10e42e8cd59ee851717bc12a5d167af68912 on cpartica:master into 94525c00252696b47673db1ca56fe0436c5949be on webonyx:master.\n. \n\nCoverage decreased (-1.08%) to 91.761% when pulling 68eb325d1894fdf0e02f51cc7bf95bd5c09678bd on camuthig:fix-operation-param-operation-name into 94525c00252696b47673db1ca56fe0436c5949be on webonyx:master.\n. \n\nCoverage decreased (-0.07%) to 92.768% when pulling e2732ad486220f521ec4f76d26d00d1ce7d18925 on simPod:allow-callable-types into 94525c00252696b47673db1ca56fe0436c5949be on webonyx:master.\n. \n\nCoverage remained the same at 92.84% when pulling 2a4c0a111a21c982cd85b1ad0ae0ba797cfa759d on ScullWM:patch-1 into 94525c00252696b47673db1ca56fe0436c5949be on webonyx:master.\n. \n\nCoverage decreased (-0.02%) to 92.82% when pulling 658836cb3d725636de3e81f645282e15959ee0dc on samsouder:master into 94525c00252696b47673db1ca56fe0436c5949be on webonyx:master.\n. \n\nCoverage remained the same at 91.761% when pulling 9b94ac2f06a727b25338b3223300880f41341b46 on sarukuku:master into 7762430bc39c201a97ae6bb1c287ca45b068f899 on webonyx:master.\n. \n\nCoverage remained the same at 91.761% when pulling 66108bec84e27616bbeccbe6ae8d41a30e4adbf0 on ruudk:patch-1 into 87729589e084007030c0b9565fdbe4fd67b99d0e on webonyx:master.\n. ",
    "intellix": "Actually, why should the schema be defined as an array? I'm looking at defining types as string to use for mocking in the front-end and was searching for the ability to parse that in our graphql-php implementation to allow sharing the schema. Take a look at this: https://github.com/apollostack/graphql-tools\nIt would be awesome if we could define our Schemas to be platform/language agnostic so they can be shared between Backend/Frontend. It would make moving to other languages easier as well as you'd only have to redefine the resolver functions.. ",
    "roippi": "We can close this one out, via https://github.com/webonyx/graphql-php/pull/199. I think you're right - looking at the js implementation, it's simply a facade for comparing two TypeMaps.  Then the trick is just filtering oldSchema down to the types touched by deployed queries before running the comparison - Visitor would work for that part nicely.. We're going to do findBreakingChanges in the nearish future then revisit this.  Seems like the right approach. . Yes\n\nOn Nov 28, 2017, at 12:02 AM, Vladimir Razuvaev notifications@github.com wrote:\nSo is it ready for review/merge?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Ah.  That issue is coming up on its two-year birthday \ud83d\ude22 \n\nDisappointing but understandable; if there's any way around being blocked by reference impl here, I'd be interested to hear solutions.. I think I've managed to implement this without framework changes by wrapping resolvers.  We have a place where we ensure singleton class instances (which is mandated by the framework, of course) and I can drop something like this in the pipe:\nphp\n  /**\n   * @param \\GraphQL\\Type\\Definition\\Type $instance The type instance\n   *\n   * @return Type\n   */\n  protected static function maybeInstallTelemetry($instance) {\n    if (self::$telemetry && $instance instanceof ObjectType) {\n      foreach ($instance->getFields() as $field) {\n        $resolver = $field->resolveFn;\n        // TODO maybe we should instrument the default resolver too?\n        if ($resolver) {\n          $field->resolveFn = function(...$args) use ($resolver) {\n            list($beforeHook, $afterHook) = self::$telemetry;\n            $beforeHook(...$args);\n            $res = $resolver(...$args);\n            $afterHook(...$args);\n            return $res;\n          };\n        }\n      }\n    }\n    return $instance;\n  }\nIt works well enough for my needs, I think, though I haven't done much testing yet.  Is anyone else taking an approach like this?. We're going to be overriding this regardless whether you decide to accept this.  It's just a question of whether our override looks like this:\n$fixedInt = new class() extends IntType {\n  protected static $maxInt = PHP_INT_MAX;\n  protected static $minInt = PHP_INT_MIN;\n};\n... or whether our override is the entire original class copy-pasted with values modified.  I'd prefer the former since it's less fragile.. ",
    "shadowhand": "Promises might allow for loading data in parallel, but won't help with deferring. A simple check against a Deferred type should be enough. Really, any implementation of JsonSerializable should be sufficient. Effectively:\nphp\npublic function jsonSerialize()\n{\n    return call_user_func($this->finalResolver, $this);\n}\nWhere the finalResolver is the callback that executes the dataloader and returns the materialized result.\n. @vladar oh I didn't mean to imply this would be all that would be required. There would definitely have to be detection for these deferred values before final object resolution. My point was more about the fact that promises don't help with deferred values.\n. After reviewing #67 and overblog/dataloader-php I am actually in favor of the promise approach. For me, async data loading that solves the N+1 problem is the significant blocker to adopting GraphQL for real world applications.\n. ",
    "leemason": "thanks for the info, yes those resoures helped alot, i havent used them, but they have shown me the way to getting it all working. thanks again.\n. ",
    "andheiberg": "\nOne more problem I've discovered is that we will have to force resolveType in interfaces and give up on trying to guess actual object type with isTypeOf. [emphasis added]\n\nMeaning in it's current implementation this has not been done and something is broken?\nCould you elaborate on what is broken?\nI understand the example with Pet and Being is that the only thing?\n\nThis is experimental feature, there are still no benchmarks to see if it gives major benefits. So until we do have some evidence that it helps - it may be a subject to change.\n\nWould you be able to post the benchmarks you've found?. > Right now if two interfaces have intersecting implementations this query will validate, but if not - it will fail the validation. With lazy approach it will always pass the validation, but then return nothing. I guess this case is extreemly rare.\nI just added LazyLoading in a project to gather some benchmarks. I did see a substantial 20% improvement for a small query only touching a tiny fraction of our schema. I was about to test more complicated queries that touch more of our schema only discover what I think is this case?\nI must have been optimistic when reading your initial comment. Is what you mean that the following should fail accordingly:\n``` \ninterface Base {\n   fieldA\n   fieldB\n}\ntype One {\n   fieldA\n   fieldB\n   fieldC\n}\ntype Two {\n   fieldA\n   fieldB\n   fieldD\n}\n``` \nRunning a query against this to the effect of:\n{\n   base {\n        _typename\n        ... on One {\n           fieldC\n        }\n        ... on Two {\n           fieldD\n        }\n   }\n}\nReturns:\n{\n    \"data\": {\n        \"base\": {\n             \"__typename\": \"One\"\n        }\n    }\n}\nThis is not a small edge case nor extremely rare our schema has this all over :( any suggestions for how this could be fixed?. Right opened #138 PR as I thought it would be more clear for the reduced test case. But yeah seemingly it is a problem with the current implementation and not my custom setup.\nUnless you see an issue with my reduced test case?. Yeah totally up to you :) I was just playing about, wanted to use the parser for something else and \"needed\" / wanted it to resemble what is was replacing slightly more.\n. Glad to hear back from you so swiftly. Here's my thoughts:\nI don't think the public interface only extends to those 3 methods. When you do execution you might be looking at the AST in your resolve function to come up with a better strategy, so the entire AST is part of the public interface.\nHowever I fully agree that injecting the lexer is a bit of an odd move, it was only done to make the initial refactor pass fast. This is far from how I would ideally want the code to look. I can come up with an argument for injecting in lexers though. You talk about overhead of lexing the query. Well part of this is that you have a lexer that both does Schema and Query lexing. Since these never occur in the same payload you could split them, here DI could become useful. Again this is very contrived.\nBut yeah fully agree with your point that you shouldn't make decisions mechanically. That being said I don't see the advantage to your static approach.\nOn backwards compatible changes thats very subjective obviously. I think it's very early days for graphql and your lib and I worry that your putting too many limitations on your self. But I'm very much in the build fast and break things camp :D\nYou've done an amazing job writing this library though, so I really shouldn't be complaining :D thanks so much for all the hard work and attention to detail. It was amazing to see that your test coverage is  extensive when doing these refactors.\n. Will I mainly needed this related to the other PR I sent to you. Probably won't have time to look into this before you fix it :)\n. > I don't think Introspection even needs to be changed - it is not a part of schema - it is called during query execution in runtime. If it is not the case - then we should investigate why and probably fix (vs adding serialization to these closures)\nWell I only made these changes as they were breaking serialization of the output schema from BuildSchema. So it would appear you need to do some fixing. I don't really care about the internals of introspection, so I will leave that to you as for how you wanna solve it. But I can confirm that this PR is indeed a solution to the problem.\n\nI would really like to avoid external library dependencies. One option how we could do this is to add separate classes for object types created by buildSchema (which extend base ObjectType and InterfaceType) and can sleep and wakeup. This way we don't need to serialize closures.\n\nI have many things I would like to say about your internal class structure as I made clear in another PR trying to refactor your parser and AST. Yes in a sensible world there would be away for an AST to be written to array \ud83d\udc4d I did a practical approach to the problem and worked with what you have as I figured this would increase the likelihood of this being merged.\nAgain feel free to come up with a more sensible solution that requires more refactoring and/or fixing problems in existing code.\nThat being said having SerializableClosures was a great workaround for getting getting this in to APC in our particular setup and I would be happy to accept this as the long term story for how to do this. Granted an array serializable AST would be the dream!. @vladar thoughts? Is this something you would want to merge?. Funny you should mention it I was playing with that earlier https://github.com/AndreasHeiberg/graphql-parser-php-extension\nAlmost finished building the experimental branch which instead of outputting json outputs proper PHP objects but I never got around to finishing it. Currently there's a memory bug in there of any C++ devs are are super eager to help out I can create a reduced test case :) That being said improving parsing performance doesn't matter much as you generally can avoid doing that for actual prod requests. I was mainly entertaining the idea to get a consistent AST foundation that will not have to be maintained that other stuff can be build on top of.\n\nunserializing AST and then calling BuildSchema is only ~10% slower than unserializing schema itself\n\nInteresting approach hadn't thought about that at all. \ud83e\udd14  we could switch over to doing something like that. But we would still have to attach resolvers to that schema so yeah it would involve some overhead which is fine.\n\nBut I do not agree with implementation using serializable closures\n\nThat's fair it wouldn't have been my first choice either but I tried converting this into just a regular array as the closure is entirely unnecessary, but it's seems like the framework internals is dependent on it. \n\n(and internal comparison of types changing from === to ==).\n\nWe don't like this either but we frankly couldn't dedicate more time to getting the framework to play nicely with unserialised schemas. Would love to see at better implementation.\n\nWill include it in next major version of the lib\n\n\ud83d\udc4d \n. Just OCD I like consistency :)\n. Just noticed this isn't needed btw as it's in the toArray as well. Not sure how that was missed :(\n$tmp['loc'] = [...] being called in both __toString and toArray is redundant.. ",
    "olragon": "In my case, I can see 309% performance improved by using LazyResolution.\nIn screenshots below you can see: time in ms\n- schemaBuildTime: is the time it take to complete new GraphQLSchema([])\nBefore LazyResolution\n\nAfter LazyResolution\n\n. Thank you for your help and super useful/valuable in depth suggestions.\nYour estimate about memory size, run time is true.\nWe have some options here:\n- re-architecting this legacy app (Drupal 7) to reduce schema size\n- implement Drupal 7 in ReactPHP to share schema\n- implement GraphQL in another language (NodeJS, Golang, ...)\nFor now, I will close this issue, will update if we have something new.\nThank you for your great work.\n. ",
    "tpetry": "A ConfigBuilder like the OOP definition of Youshido/GraphQL would be a nice option. Because it would allow useful encapsulation instead of one gigantic file with dozens/hundreds of configurations.. > Now when we have some options for loading types/fields on demand (see #69) such builder makes more sense.\nI was directly thinking on such a load-on-demand. If you would encapsualte it with objects you would assign maybe 50-100 top-level types (for a large API) which would only be lazy evaluated. This means only their name is remembered.\nWith OOP in mind it could be completely lazy evaluated:\n1. Query contains Blog field at root-level\n2. BlogTypes definition will be loaded because it's requested\n2. call BlogType::evaluate with something like AST of the blog field\n4. it's call it's resolvers etc. and will again in it's OOP hierarchy again lazy-evalute it's child-types starting again with 1.\nSo if you have 50-100 root types defined like:\nphp\n'fields' => [\n  // asyncType returns a closure which can be called to really load it's definition\n  'echo' => EchoType::asyncType(),\n  'test' => TestType::asyncType(),\n]\nYou have never to evaluate the schema for the test type for something like query{echo(message:\"Hello World\")}. Abstract would mean there could be no user defined root class :( Why not choose interfaces with boilerplate provided by traits?\nWould be the most adaptable solution.. I sm not in need of anyone. That was simply an argument to your position to favor an abstract class indtead of an interface because the abstract class could implement the (possible) boilerplate code someone had to do with an interface.. ",
    "markhuot": "If there is any interest in this any more I've implemented a v1 builder class that allows you to do things like,\n```php\n// assume $object is any ObjectType such as the root Query or some deeper field type\n$object->addStringField('width'); // adds a string field with a name of width\n$object->addStringField('height'); // adds a string field with a name of height\n$object->addField('related')->type(Post::class)->lists()->nonNull(); // adds a related field of type [Post]\n$object->addField('person')->addStringArgument('email'); // adds a person field with an optional argument of email:\n$object->addField('posts')->resolve(function () use ($postRepository) { return $postRepository->all(); }); //adds a posts field that queries the DB for posts\n```\nThis is currently coupled in to https://github.com/markhuot/craftql. It's very early and needs some refactoring but I like where it's going and am happy to lend a hand to anyone who may want to abstract it out to it's own package.. Tests should pass now. Thank you and sorry about that.. ",
    "enumag": "Can we get this merged? Even without documentation the builders are quite clear from the testcase and I'd like to use them.. @mcg-web Awesome! :+1: . So, any progress? :-). Please wait for a bit. I dug a bit deeper into it and I think we might want to use a different approach. I'm writing an issue right now.. If this is not supported, please give me some tips how to implement it and I'll send a PR.. If this is not supported, please give me some tips how to implement it and I'll send a PR.. Thank you! Very helpful answer. After some hacking with Overblog/GraphQLBundle I managed to successfully use my own error handler. The problem now is that I want to use the default handler in most cases (such as syntax errors in the GraphQL query) and only use the customized one for some of my own exception. Any tip how I can re-use the default handler?. Ok I think I solved that on my own. Posting it here for anyone else looking for the same thing.\n```php\n        $defaultFormatter = FormattedError::prepareFormatter(null, $debugMode);\n    $executionResult->setErrorFormatter(\n        function (\\Throwable $exception) use ($defaultFormatter, $debugMode) {\n            if ($exception->getPrevious() instanceof MyException) {\n                return $this->formatException($exception->getPrevious(), $debugMode);\n            }\n\n            return $defaultFormatter($exception);\n        }\n    );\n\n```. I can do that. Just not sure where to put that class with __toString which is needed for this test.\nAlso do you think this is a good approach? I'm new to GraphQL so I'm unsure if it's expected for every GraphQL object to have an ID type field or if it's ok or even preferred to use a custom type for things like UUID (custom type might help with validation for example). I'm not even sure if it's good to use UUIDs with GraphQL in the first place.. Ok, I'll add the test. Still do you think I should write an UuidType for GraphQL? I can share it of course if I write it.. Test added.\nYour answer is a bit unhelpful... I use UUIDs as entity identification obviously AND rely on it being a valid UUID - if the user sends a string that is not a valid UUID it will cause an error.\nI can safely replace the ids with other strings. Or to be more exact with other unique and valid UUIDs. The clients wont break if I change the IDs but they too will rely on them being UUIDs.\nSo should I use custom type or not?. Alright, thank you!. @theofidry Damn. No of course not. I'm using tabs in my project so IDE automatically used them here... I'll fix it in another PR.. https://github.com/webonyx/graphql-php/pull/211. Yeah I know I can do it the way you describe but I don't consider it a good solution - it would only add unnecessary transformations everywhere slowing down the application. I've already heard claims that webonyx is in fact much slower than Youshido (but they don't have the benchmark sources anymore so I can't validate that claim) so I really don't want to add more layers to slow it down even more. And the code would look very ugly in some cases where it would not be possible to abstract.\nFirstly let me correct my previous comment a bit - when I talked about abstract class implementing the optional methods like getDescription and getInterfaces it should not be an abstract class but actually a trait. So custom types would look like this:\n```php\nclass UserType implements ObjectTypeInterface\n{\n    use ObjectTypeTrait; // empty getDescription and other optional methods\npublic function getFields(): array\n{\n    return [\n        'email' => MyTypes::string(),\n        'friends' => MyTypes::listOf(MyTypes::user())\n    ];\n}\n\n// ...\n\n}\n```\n\nInterfaces are fragile and hard to modify. Say we have an interface in the library and many projects start using it. Then at some point, we decide to add an optional method to this interface or even rename a method. It will introduce an unnecessary breaking change. An alternative here is to add new interfaces for each minor tweak.\n\nWhile true at first glance this is not actually the case. There is an approach to make such additions very smooth. When you need to add an optional method you add it but comment it out, implement it in the trait with default value and add a note to the change log that implementations of that interface that do not implement such method are deprecated. In the code you would use method_exist for now before calling it. Then you just uncomment the method in the next major release and remove the method_exist checks. This could break some applications of course, however since 99% of all implementations would use the trait anyway they would be uneffected because the trait would define it for them. This is how Symfony does BC breaks by the way. It works very well.\nOr you can add a new interface. Which way is better depends on the case.\nBesides the cases where you actually want to add such optional method are quite rare. It would certainly not be necessary for \"every minor tweak\" as you put it. In the lifetime of this library I don't expect more than one or two such methods to be added.\nAlso I should note that this library is still in 0.x.y versions which is a pre-release stage and BC breaks can occur according to semver. Still it's a good practice to make them smooth as I described above.\n\nThere is a good reason why smart people prefer composition over inheritance.\n\nThat's exactly why I'm proposing this. To use composition to its full potential you need interfaces defining the contract between classes so that you can replace any class with your own implementation if necessary. This library is very bad in this regard.\nI want to achieve a state where a Type definition uses composition for the fields instead of defining them by itself. Yes I could compose it using some factories and automate it as you described but its not a clean solution that I can recommend to others. If this library had some interfaces then I could write an article with recommended usage of this library and the code would look very good.\n\nAnother problem is that having two ways of defining types makes maintenance much harder. It also introduces different experience for library users and makes it harder to communicate and solve issues.\n\nThat's why this library should ultimately deprecate the current array configuration in favor of the interfaces and completely remove arrays in some future version.. I see now that #78 is exactly the same proposal. I don't understand why you're against it now since you originally proposed it yourself. It is the right direction, just interfaces and traits should be used instead of abstract classes as suggested by @tpetry. Your worry about extending the interfaces in the future is baseless - I guarantee you it would be needed very very rarely and can be perfectly smooth as described above.. I'l take a step back, reconsider my opinions and respond properly later. Thank you for taking your time to write such detailed response.. Thanks for the link. It's interesting but ultimately doesn't really help me.\nIs there some type outside of this repository you could recommend? Or some different approach? How are you solving this in your apps?. Well I just need a DateTimeType which represents a UTC time as ISO-8601 format. Pretty much the most simple thing.\nHere is my current implementation if anyone needs it:\n```php\n<?php declare(strict_types = 1);\nnamespace App\\Library\\GraphQL\\Type;\nuse DateTime;\nuse DateTimeImmutable;\nuse GraphQL\\Error\\InvariantViolation;\nuse GraphQL\\Language\\AST\\StringValueNode;\nuse GraphQL\\Language\\AST\\ValueNode;\nuse GraphQL\\Type\\Definition\\ScalarType;\nuse GraphQL\\Utils\\Utils;\nclass DateTimeType extends ScalarType\n{\n    /*\n     * @var string\n     /\n    public $name = 'DateTime';\n/**\n * @var string\n */\npublic $description = 'The `DateTime` scalar type represents time data, represented as an ISO-8601 encoded UTC date string.';\n\n/**\n * @param mixed $value\n */\npublic function serialize($value): string\n{\n    if (! $value instanceof DateTimeImmutable) {\n        throw new InvariantViolation('DateTime is not an instance of DateTimeImmutable: ' . Utils::printSafe($value));\n    }\n\n    return $value->format(DateTime::ATOM);\n}\n\n/**\n * @param mixed $value\n */\npublic function parseValue($value): ?DateTimeImmutable\n{\n    return DateTimeImmutable::createFromFormat(DateTime::ATOM, $value) ?: null;\n}\n\n/**\n * @phpcsSuppress SlevomatCodingStandard.TypeHints.TypeHintDeclaration.MissingParameterTypeHint\n *\n * @param ValueNode $ast\n */\npublic function parseLiteral($ast): ?string\n{\n    if ($ast instanceof StringValueNode) {\n        return $ast->value;\n    }\n\n    return null;\n}\n\n}\n```. This looks promising. I'll try it next week and post here what I end up with. Thank you!. Can you tell me how the persisted queries work? Even with this article I don't understand how the client is supposed to send an id instead of a query. What syntax should I use for testing it with GraphiQL?\nBtw. I can't reopen this issue since you're the one who closed it instead of me.. @vladar So will this be in 0.13 then? I noticed in another thread that you want to release it soon.. Tried it on my project and the experimental executor caused many of my tests to fail. The reason is that some resolve functions in my generated types receive a Promise instead of the real value now. I might be able to fix this on my side but I'm not certain yet.\nphp\n'resolve' => function ($value, $args, $context, ResolveInfo $info) {\n    return $value->getId();\n},\nError: Call to undefined method GraphQL\\Executor\\Promise\\Promise::getId(). I tried to change the resolver to this:\nphp\n'resolve' => function ($value, $args, $context, ResolveInfo $info) {\n    return $value->then(\n        function ($value) {\n            return $value->getId();\n        },\n        function () {\n            throw new \\Exception();\n        }\n    );\n},\nbut then I receive this error\nGraphQL\\Error\\InvariantViolation : Expected a value of type \"ID\" but received: instance of GraphQL\\Executor\\Promise\\Promise\n.../vendor/webonyx/graphql-php/src/Experimental/Executor/CoroutineExecutor.php:524\nI don't think I can fix this...\n. > Do you use a custom promise adapter?\nNot to my knwledge. I'm using the overblog bundle but I don't think it changes the promise adapter.\n\nCould you provide a minimal reproducible code?\n\nConsidering how complicated my setup is this could easily take days to prepare. I don't have that much time.. Ah ok, yeah there is a custom promise adapter in one of the overblog libraries (and yes, I'm using this adapter). It's for DataLoaders: https://github.com/overblog/dataloader-php/blob/master/lib/promise-adapter/src/Adapter/WebonyxGraphQLSyncPromiseAdapter.php. ",
    "fesor": "@vladar you could have both abstract class, interface + traits or custom user-specific code. Abstract class could just implement interface + use traits. If for some reason users will want some other parent class, they could just use interface. Perfect balance from my point of view.. @vladar \n\nthere is no automatic PHP code style checks or PHP code style fixer in Travis\n\nWhy not use php-cs-fixer in dry run to be sure that all commits has proper code style?. ",
    "vasily-kartashov": "If it's of any interest this is the sample_prof result on an actively developed application of mine. The result is stable in the top part of the table.\nPath | Line | Hits\n-----|------|-----\nsrc/Language/Visitor.php | 443 | 154261\nsrc/Language/Visitor.php | 455 | 99419\nsrc/Utils/Utils.php | 223 | 73642\nsrc/Language/Visitor.php | 450 | 70320\nsrc/Utils/TypeInfo.php | 85 | 33942\nsrc/Language/Visitor.php | 177 | 31358\nsrc/Language/Lexer.php | 546 | 25955\nsrc/Language/Lexer.php | 606 | 22674\nsrc/Utils/Utils.php | 303 | 21848\nsrc/Language/Visitor.php | 245 | 20102\nsrc/Type/Definition/Type.php | 246 | 20078\nsrc/Type/Definition/Type.php | 262 | 17920\nsrc/Type/Definition/NonNull.php | 46 | 17717\nsrc/Language/Visitor.php | 288 | 17582\nsrc/Language/Lexer.php | 534 | 16630\nsrc/Type/Definition/FieldDefinition.php | 220 | 16547\nsrc/Utils/Utils.php | 308 | 15583\nsrc/Type/Definition/FieldDefinition.php | 106 | 15075\nsrc/Language/Visitor.php | 183 | 14139\nsrc/Utils/Utils.php | 425 | 12962\nsrc/Utils/TypeInfo.php | 386 | 12913\nsrc/Language/Visitor.php | 473 | 12744\nsrc/Executor/Executor.php | 1359 | 12115\nsrc/Utils/Utils.php | 429 | 11194\nsrc/Utils/Utils.php | 34 | 10254\nsrc/Language/AST/NodeList.php | 117 | 10217\nsrc/Type/Definition/FieldDefinition.php | 245 | 9893\nsrc/Language/Visitor.php | 237 | 9733\nsrc/Language/Visitor.php | 227 | 9456\nsrc/Type/Definition/ObjectType.php | 149 | 9454\nsrc/Language/Visitor.php | 180 | 9197\nsrc/Utils/TypeInfo.php | 238 | 9030\nsrc/Utils/TypeInfo.php | 295 | 8233\nsrc/Language/Visitor.php | 363 | 7992\nsrc/Type/Definition/FieldDefinition.php | 266 | 7879\nsrc/Language/AST/NodeList.php | 119 | 7748\nsrc/Language/Visitor.php | 185 | 7530\nsrc/Utils/Utils.php | 444 | 7415\nsrc/Type/Definition/FieldDefinition.php | 185 | 7130\nsrc/Type/Definition/ObjectType.php | 123 | 7125\nsrc/Language/AST/NodeList.php | 106 | 7018\nsrc/Language/Visitor.php | 412 | 6910\nsrc/Language/Visitor.php | 428 | 6559\nsrc/Language/Lexer.php | 464 | 6453\nsrc/Type/Definition/NonNull.php | 61 | 6227\nsrc/Type/Definition/Type.php | 86 | 6200\nsrc/Language/AST/NodeList.php | 53 | 5941\nsrc/Language/AST/NodeList.php | 49 | 5794\nsrc/Type/Definition/FieldDefinition.php | 173 | 5557\nsrc/Language/Parser.php | 146 | 5411\nsrc/Utils/TypeInfo.php | 227 | 5231\nsrc/Type/Definition/ListOfType.php | 45 | 5061\nsrc/Executor/Promise/Adapter/SyncPromise.php | 72 | 4959\nsrc/Type/Introspection.php | 728 | 4922\nsrc/Type/Definition/FieldDefinition.php | 107 | 4897\nsrc/Utils/Utils.php | 309 | 4506\nsrc/Type/Definition/Type.php | 95 | 4504\nsrc/Type/Definition/Type.php | 39 | 4281\nsrc/Type/Definition/Config.php | 120 | 4182\nsrc/Executor/Promise/Adapter/SyncPromise.php | 33 | 3784\nsrc/Executor/Promise/Promise.php | 21 | 3667\nsrc/Type/Definition/NonNull.php | 22 | 3648\nsrc/Language/AST/NodeList.php | 108 | 3612\nsrc/Language/AST/NodeList.php | 31 | 3555\nsrc/Type/Definition/Type.php | 57 | 3387\nsrc/Language/Visitor.php | 417 | 3359\nsrc/Executor/Promise/Adapter/SyncPromiseAdapter.php | 23 | 3187\nsrc/Validator/ValidationContext.php | 158 | 3092\nsrc/Type/Definition/FieldDefinition.php | 96 | 3087\nsrc/Language/Visitor.php | 430 | 3084\nsrc/Executor/Promise/Adapter/SyncPromise.php | 79 | 3030\nsrc/Language/Token.php | 129 | 2972\nsrc/Type/Definition/FieldArgument.php | 113 | 2946\nsrc/Language/Parser.php | 484 | 2911\nsrc/Type/Definition/Type.php | 76 | 2787\nsrc/Type/Introspection.php | 749 | 2752\nsrc/Type/Definition/FieldDefinition.php | 75 | 2700\nsrc/Utils/TypeInfo.php | 127 | 2655\nsrc/Executor/Promise/Promise.php | 35 | 2646\nsrc/Type/Definition/FieldArgument.php | 60 | 2642\nsrc/Language/Visitor.php | 386 | 2594\nI am using the latest release verison \"webonyx/graphql-php\": \"*\". I guess it could work. Debugging tools are not quite as convenient, because I specifically want see things gone wrong in log files, sometimes days after an exception was registered.\nIs it the proper use of custom formatters?\nGraphQL::executeQuery(...)\n    ->setErrorFormatter(function(Error $error) {\n        $this->logger->warning('Exception while handing GraphQL request', ['exception' => $error]);\n        return FormattedError::createFromException($error);\n    })\n    ->toArray();\n. @spawnia PHPStorm and Psalm both understand this notation. I wrote a simple BatchProcessor that may help you to deal with this https://github.com/vasily-kartashov/graphql-batch-processing\nIn your case you would use it like following\n'resolve' => function($blogStory) {\n    return Batch::as('usersByAuthorIds')\n        ->collectOne($blogStory['authorId'])\n        ->fetchOneToOne(function ($authorIds) {\n            // here comes a repository method that returns a map from userId into User record\n            return $userRepository->findUsersByUserIds($userIds);\n        });\n}. ",
    "PowerKiKi": "I've been bit by this too. I'd suggest to improve the hello world, because it gives a bad first impression for newcomers. I'll try to submit a PR in the coming days if I find an easy way around that. As a sidenote if GraphiQL way of sending things becomes/became a de-facto standard, it might be worth considering a sort of helper so end-users don't have to re-implement JSON parsing.. Btw is there a Gitter or mailing list to talk about usage of this project ? Specifically I am interested in advice/experiences about integrating with doctrine.... Thanks all for the valuable feedback. I've been very busy the past few weeks migrating from ZF1 to Doctrine. But we have yet to introduce GraphQL (opposite migration order of @vladar's). So we are still open to various implementation suggestions.\n@sergiohermes, do you have any kind of documentation and/or example of usage for rahuljayaraman/doctrine-graphql ? How did it benefit your project ? Any downside to it ?. In the last few weeks, I had a look at rahuljayaraman/doctrine-graphql project. I saw interesting things, but it did not exactly fit my needs and back then it lacked documentation. So I started my own version of bridge between GraphQL and Doctrine. The result is MIT licensed and available at https://github.com/Ecodev/graphql-doctrine.\nIt significantly diverge from rahuljayaraman/doctrine-graphql in the fact that it relies heavily on PHP 7.1 type hinting, and only fall back to Doctrine annotations when necessary. Therefore it does not expose doctrine fields, but rather all entity getter methods (so in most case that would cover all fields in addition to custom getters). Another important point for me is that the project has a test coverage of 100%.\nI encourage you to read the docs and try both packages to see whichever fits best your project.\nFinally if you have questions or feeback your are welcome to share those on gitter.. As a follow-up, we just released 1.0.0: https://packagist.org/packages/ecodev/graphql-doctrine\nGoing forward we'll at least maintain the existing features for our project. We'll also seriously consider to expose the query builder features through graphql. This would reduce boilerplate in repositories and give more possibilities out of the box for frontend developers.. FYI, this is the integration I came up with. It could be cleaner, but at least it is simple. The middleware itself looks like:\n```php\n<?php\ndeclare(strict_types=1);\nnamespace Application\\Action;\nuse Application\\Api\\Schema;\nuse GraphQL\\Doctrine\\DefaultFieldResolver;\nuse GraphQL\\GraphQL;\nuse GraphQL\\Server\\StandardServer;\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\JsonResponse;\nclass GraphQLAction implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        GraphQL::setDefaultFieldResolver(new DefaultFieldResolver());\n    $schema = new Schema();\n    $server = new StandardServer([\n        'schema' => $schema,\n        'queryBatching' => true,\n        'debug' => true,\n    ]);\n\n    $parsedBody = json_decode($request->getBody()->getContents(), true);\n    $request = $request->withParsedBody($parsedBody);\n    $response = $server->executePsrRequest($request);\n\n    return new JsonResponse($response);\n}\n\n}\n```\nConfigure it in config/autoload/dependencies.global.php:\nphp\nreturn [\n    'dependencies' => [\n        'invokables' => [\n            GraphQLAction::class => GraphQLAction::class,\n        ],\n    ],\n];\nAnd declare a route in config/routes.php:\nphp\n$app->post('/graphql', Application\\Action\\GraphQLAction::class, 'graphql');. Thanks for mentioning psr7-middleware-graphql, I wasn't aware of it.\nThe parsing of JSON is necessary in my case, otherwise parsedBody is empty and the server will fail to decode json from non-parsed body. I was surprised by this behavior as I was expecting it would work out of the box as you described. Would you want me to open an issue for that ?\n. @vladar I will have to implement file upload for my projects. Would you be interested in getting a PR to be merged here ? or should it be part of another project ?\nBased on what I found, I believe we could implement something generic enough to to be usable by implementing the graphql-multipart-request-spec. From what I gathered so far, it would be a new Upload scalar type that expose a few properties to the resolver such as filename and mimetype. IMHO this would be \"low-level\" enough to be included in graphql-php, but if you disagree I'll keep that separate. What do you think ?. @caseycs did you try with apollo-upload-server ? If so would you be able to sump up the difficulties you had ?. Oh my bad, I meant apollo-upload-client of course. What difficulties did you have ?. @vladar the lack of \"multipart/form-data\" is precisely what I was gonna fix first. My idea is to have the standard server handle PSR7 requests with \"multipart/form-data\" (and maybe raw requests later on). And resolvers would not get a name from which to get the file globally, but rather the (meta)data of the file directly.\nIt's the kind of functionality I'll need in at least two of my projects, so I'll have to maintain it somehow. So it might as well be in this project so everyone else can benefit from it. But it if it's a burden for either of us, that could also be a separate lib. I'll experiment a bit more and see if I can come up with actual code.... Just released graphql-upload 1.0.0 which could be a solution to this issue.. I will most likely need it for the next PR, but let's wait and re-consider it when I have something more to share.... The upload PR does include this PR's commit too, so yes if upload PR is merged, then this one becomes useless. But it could also be merged separately... depending on how long it takes for upload PR to be merged.... > separate utils like this from core\nI suspected you would say that. I really don't mind at all. I would tend to go Utils\\UtilTypes rather than mix with server, because they could be used outside of standard server too.\n\nsupport \"multipart/form-data\" for default PHP globals\n\nI am not sure about that. I am actually not sure about the \"raw\" server at all. I feel supporting raw request (as opposed to PSR request) double our workload for really no gain. It's very easy to add a PSR compliant lib to parse globals just before calling the standard server. Supporting \"raw\" request is definitely convenient for new users, but I feel like it will bite us in the end, because we have to re-implement lots of PSR related things and maintain two very similar yet different paths in our code (one for raw, and one for PSR).\nInstead of implementing multipart/form-data for globals, I would take the drastic opposite decision of dropping the raw server entirely.\n\nnot convinced about graphql-multipart-request-spec\n\nThis might be a deal breaker for me. I use Apollo Client on the browser side and it seemed to me that apollo-upload-client was the de-facto standard in that context. It's about 1 year old and rather popular according to GitHub stars and forks. So I can only assume that the spec that came out of that project should reflect all the experience accumulated from real-world experiences. And I did made a proof-of-concept with this PR and apollo-upload-client in my project very easily. It's also the only attempt to create a specification about uploads AFAIK.\nI am not quite sure, but it seems that what express-graphql suggests would not be compatible (at all) with apollo-upload-client. And that would be a problem for me. I am willing to be convinced to use another format if there are ready-to-be-used solutions out there for Apollo, but I am not willing to work on a format that I could not use with Apollo on the client side almost out of the box.\nWhat do you use on client side ? would you have a suggestion to combine express-graphql and Apollo Client ?. Fair enough, I'll extract this PR as an independent project for the time being, and we can always re-consider the situation if/when a standard more clearly emerges.. Just released graphql-upload 1.0.0 for anyone interested.... I am not saying you should or shouldn't merge this, but you might be interested in having a look a current practice before merging. You might also consider that Composer itself stopped recommending the practice to exclude things.\nIMHO I would definitely not exclude any docs... and tests might be considered a form of documentation depending on the project.... Here are my observations after I tested the new executor.\nI have 3 queries that are ridiculously slow and that I benchmark specifically for execution time. They are all very similar but query less and less fields (A is the biggest, C the smallest). To give you an idea of scale, the Query A generate a ~3MB JSON.\n| Name    | Time before [s] | Time after [s] | Time %|\n|---------|---------:|------:|------:|\n| Query A | 1.584437 |  1.71129 | 108.01% |\n| Query B | 1.065754 | 1.053167 | 98.82% |\n| Query C | 0.711192 | 0.691833 | 97.28%|\nSurprisingly the new executor is becoming slower with huge queries.\nAlso in my regular test suite, I have 46 queries that are tested. Most of them are relatively simple, usually not going deeper that 3 fields deep. Those test execute real SQL queries, so there is quite a few variable things in the timing, but still:\n\nPHPUnit reported time before: ~3.6s\nPHPUnit reported time after: ~3.6s (very similar)\nFailing test after: 1\n\nOne of my query incorrectly relied on field evaluation order. I guess I could fix it rather easily, but seeing the mixed result of the new executor I might not do it straight away...\n. This is intended, as mentioned in commit message a null value would mean no body at all:\n\nA null value indicates the absence of body content.\n\nhttp://www.php-fig.org/psr/psr-7/#321-psrhttpmessageserverrequestinterface\nSo we test for an empty array, to try to parse the body ourselves. But if it was null it should throw an exception. IIRC the null case is correctly covered by pre-existing tests.. ",
    "Torsten85": "Am I missing something or do comments disappear when calling AST::fromArray? Calling AST::toArray correctly writes the comments in the returned array.. You are right! I'll keep an eye on that issue. Thank you!. it should be used exactly like the graphql-js counterpart (https://github.com/graphql/graphql-js/blob/master/src/utilities/extendSchema.js#L103).\nSmall example:\n```php\n$sdl = '\n  type Query {\n    defaultValue: String\n  }\n';\n$documentNode = \\GraphQL\\Language\\Parser::parse($sdl);\n$schema = \\GraphQL\\Utils\\BuildSchema::build($documentNode);\n$extensionSdl = '\n  extend type Query {\n    extendendValue: String\n  }\n';\n$extendedDocumentNode = \\GraphQL\\Language\\Parser::parse($extensionSdl);\n$extendedScheam = \\GraphQL\\Utils\\SchemaExtender::extend($schema, $extendedDocumentNode);\necho \\GraphQL\\Utils\\SchemaPrinter::doPrint($extendedScheam);\n```\nthis will echo:\ntype Query {\n  defaultValue: String\n  extendendValue: String\n}. @MidnightDesign you are completely right, this should work! (https://codesandbox.io/s/yjmpnop8k9) I've digged a little deeper and found a \"bug\" in my implementation. This PR should fix this: https://github.com/webonyx/graphql-php/pull/417. I did stumble over the same problem. Your proposed quick fix works great for me. Do you want to make a pull request for that?. I don't really know how to improve the test coverage of the static create method of SchemaConfig. I don't see any test for this method... could use some help here.. Yes I know, but I'm getting closer! I guess by monday this pr will have merge-quality ;) . Ok there is nothing more for me to do now. Scrutinizer declares some method / classes as too complex, but they match the reference implementation. . good enough? ;) . Thanks!. This line generates the error\nAccessing name on the interface GraphQL\\Type\\Definition\\NamedType suggest that you code against a concrete implementation. How about adding an instanceof check?\nHow should I handle this? There seems to be no interface that provides the \"name\" property . ",
    "petecoop": "Thanks for the swift reply and some direction, I will have a look into it when I can!. I've opened a PR #91 for this, not done just yet but passing the initial tests.\nIt's pretty much identical to the js code, although at one point the js just started using a scoped var so had to turn it into a instanced class rather than just all static methods. Hey @vladar yeah not finished just yet, tests are not done for BuildSchema as I had to write SchemaPrinter first, working on it!. Hey @vladar, this is now finished! All the tests are identical to graphql-js. And everything follows graphql-js almost 1:1.\nI did have some trouble with something I found in the lexer - where you're using mb_substr() but it's not technically identical to the js equivalent of slice(), I tried to fix it in the lexer but it caused other breaking tests elsewhere, so worked around it instead.. done!. ",
    "webmozart": "Thank you for the great work on this library by the way, I really love it! :ok_hand: . ",
    "boongbungy-ifeel": "\nwhen i run http://localhost:8000/ in chrome it ok\n\n{\n\ndata: {\nhello: \"Your graphql-php endpoint is ready! Use GraphiQL to browse\n  API\"\n  }\n\n\n\n}\n2 when i click chromeiql and set endpoint http://localhost:8000/?debug=1 it\nerror i attach error\nOn Fri, Mar 3, 2017 at 5:56 PM, Vladimir Razuvaev notifications@github.com\nwrote:\n\nI could not reproduce it, so need a bit more info to understand what is\ngoing on. Please answer following questions:\n\nWhat URL do you use as endpoint (in ChromeiQL)?\nWhat happens if you open this URL in browser tab directly?\n\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/webonyx/graphql-php/issues/93#issuecomment-283925469,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AHLnzHjA7hg4VIXTRernXNJagUWDOYQPks5rh_HCgaJpZM4MN8gU\n.\n\n\n-- \nBest Regard\nPisak Lekaphet\niFeeL Co.,Ltd\n80 M.1 Vichitsongkarm Rd, Kathu\nPhuket THAILAND\nTel : +(66) 84 192 0345\n. please see attach file\nthanks\n. ok now i update php composer.phar require webonyx/graphql-php=\"^1.0.0\" but\nnew error   TypeError: Failed to fetch\nand run in mac osx php PHP 5.5.29 and i run windows machine it ok but in\nphp version 7.0.15\nOn Sat, Mar 4, 2017 at 12:41 AM, Vladimir Razuvaev <notifications@github.com\n\nwrote:\nYou attachments are not published on github. I can't get them.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/webonyx/graphql-php/issues/93#issuecomment-284020238,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AHLnzDEvfOcyLD1cEZlaYbBD90KbJUj7ks5riFC4gaJpZM4MN8gU\n.\n\n\n-- \nBest Regard\nPisak Lekaphet\niFeeL Co.,Ltd\n80 M.1 Vichitsongkarm Rd, Kathu\nPhuket THAILAND\nTel : +(66) 84 192 0345\n. can not 0.9.5 version please look my cmd\nC:\\Users\\bee2\\Documents\\graphql-php-master\\graphql-php-master>php\ncomposer.phar\nrequire webonyx/graphql-php=\"^0.9.5\"\n./composer.json has been updated\nLoading composer repositories with package information\nUpdating dependencies (including require-dev)\nYour requirements could not be resolved to an installable set of packages.\nProblem 1\n    - The requested package webonyx/graphql-php No version set (parsed as\n1.0.0)\n is satisfiable by webonyx/graphql-php[No version set (parsed as 1.0.0)]\nbut the\nse conflict with your requirements or minimum-stability.\nInstallation failed, reverting ./composer.json to its original content.\nC:\\Users\\bee2\\Documents\\graphql-php-master\\graphql-php-master>\nOn Mon, Mar 6, 2017 at 12:48 PM, Vladimir Razuvaev <notifications@github.com\n\nwrote:\nYou use the wrong version. Latest \"webonyx/graphql-php\" version is \"0.9.5\"\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/webonyx/graphql-php/issues/93#issuecomment-284308518,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AHLnzPxfxdxDkA-VvxQprY2eH3DrE_ikks5ri54zgaJpZM4MN8gU\n.\n\n\n-- \nBest Regard\nPisak Lekaphet\niFeeL Co.,Ltd\n80 M.1 Vichitsongkarm Rd, Kathu\nPhuket THAILAND\nTel : +(66) 84 192 0345\n. No i install 0.9.5  this line\nC:\\Users\\bee2\\Documents\\graphql-php-master\\graphql-php-master>php\ncomposer.phar\nrequire webonyx/graphql-php=\"^0.9.5\"\nOn Tue, Mar 7, 2017 at 11:06 AM, Vladimir Razuvaev <notifications@github.com\n\nwrote:\nSee error description. It says that you are still trying to install\nversion 1.0.0. Remove composer.lock, edit composer.json manually and change\nwebonyx/graphql version to 0.9.5, then try composer install.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/webonyx/graphql-php/issues/93#issuecomment-284616102,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AHLnzDqojYjZeO0dJ7zTctjWrMpubXFCks5rjNffgaJpZM4MN8gU\n.\n\n\n-- \nBest Regard\nPisak Lekaphet\niFeeL Co.,Ltd\n80 M.1 Vichitsongkarm Rd, Kathu\nPhuket THAILAND\nTel : +(66) 84 192 0345\n. ",
    "adri": "Thanks a lot for your input :) I think for now I don't have the time to work on this.\nI might pick it up in a few months!. Sorry for the late answer. Thanks a lot! That's awesome.. Ops you wanted to keep the issue open :D sorry. Awesome! Thanks a lot @vladar :). Awesome thanks for the detailed example. This should be enough to get me started.\nI was wondering; how are your experiences using async libraries in PHP? I\u2019m thinking about e.g.  MySQL, Memcached and Redis. Any tips, also in regards to using react-php? \n. One concept for extensions that other GraphQL implementations adopted is the use of middlewares. E.g. see Absinthe (Elixir GraphQL Library) https://hexdocs.pm/absinthe/Absinthe.Middleware.html#content\nImplementing e.g. tracing becomes then quite simple and encapsulated:\nhttps://github.com/sikanhe/apollo-tracing-elixir/blob/master/lib/apollo_tracing/middleware.ex\nWould a middleware layer be an idea? It can be used for other functionalities like access control as well.  . Cool thanks for merging!. @vladar Would you mind releasing a v0.11.6 with this? :) That would be really awesome! . Awesome, thanks I\u2019ll try the branch . @jakubkulhan \n\nAlso we started caching parsed AST. \n\nSounds interesting. Do you maybe have an example how you did that? . @jakubkulhan thanks! Do you store the DocumentNode serialized? If yes, did you have issues with the library updating and changing properties that make unserialize fail? . ",
    "jasonbahl": "@adri @vladar I've got Instrumentation setup for WPGraphQL. I've followed the proposed spec here: https://github.com/apollographql/apollo-tracing\nYou can see my implementation here: https://github.com/wp-graphql/wp-graphql-insights\nIt's super early (just worked on it a few days last week), but it follows the same approach as the node instrumentations I've seen where it wraps the entire schema. So far, I've not seen any noticeable performance differences with the tracing enabled vs disabled. . .but, I haven't done any significant testing. . .\nI'm not sure what the best approach would be to create something that works for any implementation of this library though. I'm making use of WordPress hooks/filters to accomplish my implementation. \nFeel free to use anything I've done in my implementation, or even make suggestions on how my implementation could be better. \nThanks!\n====\nUpdate: I should mention that right now this just adds tracing. It doesn't send the trace data to Optics (yet). I've been discussing with @martijnwalraven and @rohit2b from the Apollo team to figure out options for transporting the traces to Optics. \nAt the moment they're transitioning from their Optics Agent model that sends protobuf-encoded trace data via a POST request to a proxy model where your endpoint would be proxied by an \"Optics Engine\" which would handle getting trace data to Optics and offer additional things, such as full-query caching, etc. \nNot sure how I'll end up handling getting the data to Optics. The proxy engine sounds cool, but not ideal for the WordPress community at large, so we'll see where I land on that \ud83e\udd14 \n. @symm This is pretty sweet. . .but doesn't this cause all the resolve functions in the rootValue to be executed every time GraphQL is executed whether the field is queried for or not? Or is the GraphQL internals smart enough to only execute the resolvers for that rootValue the same it does for the rest of the resolvers?\n. Ok, I've got the errors working in the Blog example of your repo, so something is definitely missing in my implementation. We can consider this closed and I'll dig into what's different in my codebase vs. the example. Thanks!. Just wanted to follow up. The issue was indeed another instance of a try/catch that I had in a separate piece of connected code. \nI have tracing setup per the Apollo Tracing spec, and I had some try/catch logic around using the Fields resolver, or falling back to the defaultFieldResolver. . .removing the try/catch here fixes the issue. \nThanks so much!. This looks sweet! \nI have Apollo Tracing implemented for WPGraphQL via instrumenting the entire schema, but a more native way to interact with extensions from within Resolvers looks fantastic!. ",
    "nepster-web": "Oh, thank you very much.\nI know GraphQL and this library badly, but maybe I will think up something later.\n. php\n...\n'args' => [\n    'alias' => Type::string(),\n    'is_visible' => Type::int(),\n    'translate' => new InputObjectType([\n        'name' => 'Translate',\n        'fields' => [\n            'title' => Type::string(),\n            'text_short' => Type::string(),\n            'text_full' => Type::string(),\n            'meta_title' => Type::string(),\n            'meta_description' => Type::string(),\n            'meta_keywords' => Type::string(),\n        ]\n    ]),\n],\n.... Yes, thank you. \nThe answer is:\n```\nuse GraphQL\\Type\\Definition\\InputObjectType;\n...\n'args' => [\n    'alias' => Type::string(),\n    'is_visible' => Type::int(),\n    'translate' => new InputObjectType([\n        'name' => 'Translate',\n        'fields' => [\n            'title' => Type::string(),\n            'text_short' => Type::string(),\n            'text_full' => Type::string(),\n            'meta_title' => Type::string(),\n            'meta_description' => Type::string(),\n            'meta_keywords' => Type::string(),\n        ]\n    ]),\n],\n...\n```. I'm interested in the second kind: \"Domain or business logic validation\".\nFor example, we have several fields:\nalias - must be unique\nname - must be string (min 5 and max 32 characters)\nlang - value from the list [ru, en, fr]\nMy app has a library for validation. Assume, client entered the wrong data and got 2 errors:\nalias - Already exists\nlang - Not found\nI can throw Exception and the error is automatically placed in the errors list.\nThe description of this is here: http://webonyx.github.io/graphql-php/error-handling/\nBut I would like to show the client all of the errors. What do I do?\nAnd one more question about \"Custom Error Formatting\":\nAssume I have my custom exception (MyCustomException) and I want catch it:\n```php\ntry {\n    $schema = new Schema([\n        // ...\n    ]);\n$body = GraphQL::execute($schema, $query);\n$status = 200;\n\n} catch(\\MyCustomException $e) {\n...\n} catch(\\Exception $e) {\n...\n}\n``` \nI can't do it because it falls in GraphQL\\Error\\Error and $error->getPrevious() even not  returns MyCustomException. I can't define my exception.\nWhy was this decision taken and what should I do?\n. 1 - about $error->getPrevious()\nI was checked it one more time and everything works correctly.\n2 - about errors\nI create my custom type:\n```php\nclass ErrorsType extends Type implements InputType, OutputType, LeafType\n{\n    public function __construct()\n    {\n        Utils::invariant('ErrorsList');\n    }\npublic static function getInstance()\n{\n    return new self();\n}\n\npublic function serialize($value)\n{\n    return $this->parseValue($value);\n}\n\npublic function parseValue($value = [])\n{\n    return $value;\n}\n\npublic function parseLiteral($ast)\n{\n    // TODO: test\n    return null;\n}\n\n}\n```\nAnd my test resolve:\n```php\n'resolve' => (function ($obj, $args) {\n$errors = [];\n$errors['alias'] = 'Alias must be unique';\n$errors['name'] = 'Something else is wrong';\n\nif (count($errors)) {\n    return [\n       'errors' => $errors\n    ];\n  }\n\n   return [\n       'alias' => $args['alias'] ?? null,\n       'is_visible' => $args['is_visible'] ?? null,\n   ];\n\n}),\n```\nAssume I do this query:\nmutation (\n    $alias: String, \n    $isVisible: Boolean,\n    $translateTitle: String,\n    ...\n) {\n    updateRecord(\n        alias: $alias,\n        is_visible: $isVisible,\n        translate: {\n            title: $translateTitle,\n           ...\n        }\n    ) {\n        alias,\n        is_visible,\n        errors\n    }\n}\nAnd get this answer:\n{\n  \"data\": {\n    \"updateRecord\": {\n      \"alias\": null,\n      \"is_visible\": null,\n      \"errors\": {\n        \"alias\": \"Alias must be unique\",\n        \"name\": \"Something else is wrong\"\n      }\n    }\n  }\n}\nor this (if there are no errors):\n{\n  \"data\": {\n    \"updateRecord\": {\n      \"alias\": \"test\",\n      \"is_visible\": false,\n      \"errors\": null\n    }\n  }\n}\nThere are two questions which I\u2019d like to know:\n1) Do I understand this idea correctly?\n2) Should client always ask for error attribute in the request?\n. I created ErrorsType for return an array of errors. \nIf I use Type::string() I must return json, like this:\nphp\n'resolve' => (function ($obj, $args) {\n...\n    return [\n       'errors' => json_encode($errors),\n    ];\n...\n}),\nI try use Type::listOf(Type::string()) but the response skipped array keys, for example:\n{\n  \"data\": {\n    \"updateRecord\": {\n      \"alias\": null,\n      \"is_visible\": null,\n      \"errors\": [\n        \"Alias must be unique\",\n        \"Something else is wrong\"\n      ]\n    }\n  }\n}\nSo I created custom ErrorsType and I can return correct errors list (with array keys). \nCan I do it in another way?\nA few words about explicit error field in the request:\n - error field  mixed with other fields. Are you sure those are best practices?\n - If error field is not empty then other fields is empty. It's not pretty.  What do you think about this? \nThank you.\n. Thank you very much. \nWhen I find this information, I will create the message here. I think it will be useful.. My apologies. I updated the version. This is fixed.. ",
    "Iscander1992": "Thank you very much. It works.. ",
    "Purus": "Thanks for your response. Let me try this when I get home.\nMeanwhile the below code works. I am using 'resolve' in the type definitions. How it's different from my actual question? Sorry if this seems to be a basic question. Today is my second day with GraphQL.\nphp\n<?php\nnamespace GraphQL\\Oxwall\\Types;\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\ResolveInfo;\nclass SiteInfoType extends ObjectType {\n    public function __construct() {\n        $config = [\n            'name' => 'SiteInfo',\n            'description' => 'Information about the social network',\n            'fields' => function() {\n                return [\n                    'url' => [\n                        'type' => Type::string(),\n                        'resolve' => function() {\n                            return OW_URL_HOME;\n                        }\n                    ],\n                    'name' => [\n                        'type' => Type::string(),\n                        'resolve' => function($entity, $args, $context, ResolveInfo $info) {\n                            return $context->config->getValue('base', 'site_name');\n                        }\n                    ],\n                    'description' => [\n                        'type' => Type::string(),\n                        'resolve' => function($entity, $args, $context, ResolveInfo $info) {\n                            return $context->config->getValue('base', 'site_description');\n                        }\n                    ],\n                    'tagline' => [\n                        'type' => Type::string(),\n                        'resolve' => function($entity, $args, $context, ResolveInfo $info) {\n                            return $context->config->getValue('base', 'site_tagline');\n                        }\n                    ],\n                    'email' => [\n                        'type' => Type::string(),\n                        'resolve' => function($entity, $args, $context, ResolveInfo $info) {\n                            return $context->config->getValue('base', 'site_email');\n                        }\n                    ],\n                    'maintenance' => [\n                        'type' => Type::boolean(),\n                        'resolve' => function($entity, $args, $context, ResolveInfo $info) {\n                            return (int) $context->config->getValue('base', 'maintenance') == 1;\n                        }\n                    ],\n                    'currency' => [\n                        'type' => Type::string(),\n                        'resolve' => function($entity, $args, $context, ResolveInfo $info) {\n                            return $context->config->getValue('base', 'billing_currency');\n                        }\n                    ],                            \n                    'version' => [\n                        'type' => Type::string(),\n                        'resolve' => function($entity, $args, $context, ResolveInfo $info) {\n                            return $context->config->getValue('base', 'soft_version');\n                        }\n                    ],\n                    'activePlugins' => [\n                        'type' => Type::listOf(new PluginType()),\n                        'resolve' => function($entity, $args, $context, ResolveInfo $info) {\n                            $plugins = $context->plugin->findActivePlugins();\n                            $activePlugins = array();\n                            $i = 0;\n                            foreach ($plugins as $plugin) {\n                                if (!$plugin->isSystem()) {\n                                    $activePlugins[$i]['key'] = $plugin->getKey();\n                                    $activePlugins[$i]['name'] = $plugin->getTitle();\n                                    $i++;\n                                }\n                            }\n                            return $activePlugins;\n                        }\n                    ]\n                ];\n            }\n        ];\n        parent::__construct($config);\n    }\n}. I understand. Please consider the issue as closed.\nIf I provide 'resolve' for each field in the query, I don't need 'resolveField, right?\nphp\n            'resolveField' => function($val, $args, $context, ResolveInfo $info) {\n                return $info;\n            }. Thanks for your thoughts.\nMy CMS does not contain information in a single table. Even for a single entity, multiple tables are involved in some cases. So ideally I have to fetch all columns irrespective of requested columns.. ",
    "sergiohermes": "https://github.com/rahuljayaraman/doctrine-graphql. @PowerKiKi , I used the idea of abstraction to build my own, soon create a repository solving this problem can add a huge amount, since I did not see much documentation about, or even implementation.\nI find it very valid to use the idea of this repository since it serves as a basis for using dbal's doctrine. It is extremely valid, and I think this project should evolve, since such integration is needed.\nI have not used it in production environments but rather to reuse the entities I have and abstracted for the REST concept and after that GRAPH.\nI hope to help, strong hug.. ",
    "rahuljayaraman": "Hey guys, I'm the author of doctrine-graphql. Thanks, @sergiohermes for mentioning it here & @elvismdev for opening up the issue. I plan to put up documentation & add some crucial features in the next couple of weeks. Will ping back here once it's done. Meanwhile, there's a short overview mentioned in the above issue. Please feel free to ping me with questions or feedback. Cheers!. I've updated the readme, please do have a look. Would appreciate feedback/feature requests etc. I'm planning to work on the issues listed here over the next few weeks.. ",
    "ir-regular": "\nI don't think Introspection even needs to be changed - it is not a part of schema \n\nIntrospection types are currently part of the schema. They are included in initial types of EagerResolution.\nSince the Resolution interface is marked as highly experimental, it's hard to know how to modify it. I have therefore included a further workaround which means that after unserialising Schema, introspection queries continue to work.. ",
    "jrichard0725": "If I have built a schema, is there a way to get the AST back out of it for caching?\nLooking for something like $schema->getAST() that I can then cache via memcached. Then load from memcached, deserialize then buildschema from.\nOr if there is a better solution to not having to run extractTypes every time that would be great too. It's killing our response times right now though and caching seemed like an obvious strategy.. @vladar I will give that a try today and see if it resolves our issue. Thanks. @vladar this indeed solved our issue. Thanks - You can close this issue.. ",
    "joseluisq": ":+1: . ",
    "VaclavSir": "I think this benefit is more important for the network performance - your app does less requests and transfers less amount of data. On the server-sice, there is usually no significant difference between SELECT u FROM User u and SELECT PARTIAL u.{id,name,city} FROM User u.\nBut when you measure that some data are expensive to fetch and your clients don't always need them, you can get the list of fields from the ResolveInfo object:\nphp\n$fields = $info->getFieldSelection();\nif (isset($fields['someExpensiveField'])) {\n    return $this->resolver->fetchWithTheExpensiveField();\n} else {\n    return $this->resolver->fetchWithoutTheExpensiveField();\n}. ",
    "bginsburg": "There is a PR that was created 9 days ago to handle deprecation of input fields.\nOnce it will be merged we can make the changes to this repo!\nhttps://github.com/facebook/graphql/issues/197. ",
    "lucasfeliciano": "\ud83d\udc4d  Nice one!. ",
    "TerraSkye": "you mean the \"likes\" is null?\ncan u please clarify what your trying to express. found the issue.\nUserType extends ObjectType \nObjectType extends Type\nType contains the static method \"id\"\nUsertype resolves \nif (method_exists($this, $info->fieldName)) {\n                    return $this->{$info->fieldName}($value, $args, $context, $info);\n                } else {\n                    return $value->{$info->fieldName};\n                }\ntherefore u get a return \"ID\" wich is a bug.\nrepreducable with the folowing query \n{\n  user(id:1){\n    id\n  }\n}\n. #115 a fix for your usecase. I also saw that its not the only point the problem occurs. So it needs a bit more wurk. Thnx that satisfied my needs. i solved it with returning an empty array.. To solve that u gotta leave query out of the array send too schema . i fixed it this way (https://github.com/TerraSkye/yii1-graphql/blob/master/components/GraphQL.php#L111) \ni made a port for yii1 of your implementation. and had the same issue.. @jakubkulhan  u should use ig_binary for serilazation it has performance increase over the default :\nNative PHP :\nPHP serialized in 2.91 seconds\nPHP unserialized in 6.43 seconds\nserialized \u201cString\u201d size : 20769\nIgbinary :\nWIN igbinary serialized in 1.60 seconds\nWIN igbinrary unserialized in 4.77 seconds\nWIN serialized \u201cString\u201d Size : 4467. I think its an acceptable BC, if we put in release notes, as it is a security enhanchement?. Yeah i forgot that part. My bad, your suggestion seems the best then!. ",
    "apapacy": "I want to see in the response\n{\n  \"data\": {\n     \"user\": {\n         \"id\": \"1\"\nbut get twise\n{\n  \"data\": {\n     \"user\": {\n         \"id\": \"ID\"\n\"ID\" is Type.name. Not user identifier.\n\"1\" is user idetifier.\nBut it not present in the response.. ",
    "akomm": "Added a test for the failure when passing object into string argument:\nhttps://github.com/akomm/graphql-php/tree/test-case-issue-121\n$ bin/phpunit --filter ArgumentsOfCorrectType\nSame happens, when you resolve an object in string type fields. I did not test, but I assume it will happen with all scalar types, which do not coerce from object (assoc array).\n```\nThere was 1 error:\n1) GraphQL\\Tests\\Validator\\ArgumentsOfCorrectTypeTest::testObjectIntoString\nArray to string conversion\n```. @yaquawa when the vendor logic (webonyx) goes through the resolve functions you define in your code and execute them, it checks for Deferred returned and when it finds one, it does not take it as a result, but collect it in a list. When it is done it execute the resolve logic of the Deferred (the closure/lambda). The closure has in some way access to a cache/collection (your apps logic) where you collected all the userIds. In the example case it is the MyUserBuffer you previously filled with ids. At this point you have all the Ids in the buffer when the deferred is executed. Then you can fetch all users using something like ->findUsersByUserIds in a single query. It is though important that the order of the ids passed to the Deferred resolve returns the actuall users in the same order as the passed ids, so the vendor logic (webonyx) can properly map the result to each location in the resolve graph it was previously running through.. ",
    "migsyboy": "In case someone encounters the same issue, what happened was that I was not passing an array of variables when calling GraphQL::execute.. ",
    "pascaldevink": "Sorry, I pressed the wrong button \ud83e\udd26\u200d\u2642\ufe0f\nIt seems that the ArgumentsOfCorrectType is not executed, or at least not before the QueryComplexity is. The way the rules are executed (seemingly in parallel, according to the visitInParallel function) makes it a little more difficult to debug and follow the trail. The complexity of the code doesn't help unfortunately \ud83d\ude1e . ",
    "aelnagger": "Sounds good! This was a blocker for us adopting your framework as a graphQL provider, but it was a relatively straightforward optimization to make. I think long term the ideal solution would be to find a real multi-byte compatible stream, but this at least makes things considerably better!. Hey @vladar - thanks for the feedback. I originally went digging through the codebase to figure out how to use extensions to enable instrumentation and cache control for a gateway I intend to use in front of the service I'm running using this engine, and was surprised to find that the implementation in the ExecutionResult wasn't accessible anywhere. That said, I'm not sure you'd be actively advertising impure resolvers. Honestly I suspect that the thorough documentation around Deferred for solving the N+1 problem is probably a larger issue for that!\nI certainly understand that you can use statics or the context to drive this sort of behavior, but I wanted to try to fit it into the framework in a way that didn't seem like flagrant disregard for the specification.\nI do think that you're going to see a number of people who are keenly interested in using extensions due to recent projects like apollo-tracing. I'll go ahead and ask folks that I know to comment on this patch as well!. @vladar That's an excellent point!\nI've amended the patch to ensure we get a map instead of a list.. Hey folks, I've updated my branch with a cleverly named ExtendableContext interface which allows the executor to pull extensions from the user-supplied context.\nI'm open to renaming if we can come up with something that more clearly communicates the intent.. Hey folks,\nI'd love to help push this request along, but I'm not certain how. I see a lot of concerns about undue maintenance burden, but am not familiar enough with how graphql-php maintenance is performed to make helpful contributions here. Can someone elucidate the main concerns for me? Is this a matter of concern in attempting to maintain API parity with the reference implementation which doesn't exist yet, or is there something more subtle that I don't understand at play here?. Sounds good @mcg-web I'm looking forward to it!. Unfortunately this is causing pathological memory usage for larger requests (current testing is attempting to allocate 256M for a 5M $body.. @vladar I have a naive implementation using the original $body string as a packed value. I have the tests passing on my Windows environment, but I'm getting segfaults in my CentOS VM (this might be related to some other customizations going on). That said, I don't have a real stream implementation, but given how inefficient the base PHP value types are, parsing as a C module would certainly be much better.. Hey @vladar, sorry for the silence yesterday, busy weekend! I worked up https://github.com/aelnagger/graphql-php/tree/utf_8_decoder a few days ago, passing all the tests, but haven't cleaned it up or run the benchmarks just yet. There's definitely an issue with garbage collection on larger queries though. Making use of graphQL variables is definitely the right solution.. ",
    "walid-bizid": "@NoMan2000 thank you for the solution.\nBut how can we now access to the result to display specific data. ",
    "n1ru4l": "Thanks for merging this :) Any information on when this  feature will be published?. @vladar Could you give me an example on how I could achieve something like the code I added in my last edit with GraphQL\\Deferred?\nI will try to setup a reproduction repository using laravel-graphql and dataloader-php.. @mcg-web Here is my reproduction repository: https://github.com/n1ru4l/laravel-graphql-dataloader-php-exception-reproduction\nThe relevant files are the Service Provider (app/Providers/AppServiceProvider.php), the types and queries app/GraphQL/* and the DataLoaders app/DataLoader/*.php\nYou will not need any database setup just use php artisan serve.\nYou can navigate to graphiql on /graphiql.\nThis query fails:\n```graphql\nquery type1 {\n  type1 {\n    __typename\n    id\n    items {\n      __typename\n      id\n      items {\n        __typename\n        id\n        items {\n          __typename\n          id\n        }\n      }\n    }\n  }\n````\nThis query works:\ngraphql\nquery type1 {\n  type1 {\n    __typename\n    id\n    items {\n      __typename\n      id\n    }\n  }\n}. @vladar Thank you for the fast response :) Is there any option to move this issue to dataloader-php repository?. OK cool, also thank you for the fast responses :). Thank you so much \ud83d\ude0a I will check that out on monday!\nOn Aug 18, 2017 7:23 PM, \"Jeremiah VALERIE\" notifications@github.com\nwrote:\n\n@n1ru4l https://github.com/n1ru4l new release here\nhttps://github.com/overblog/dataloader-php/releases/tag/v0.5.2, also\nrequire to update graphql to 0.9.14 (graphql is not a requirement of the\nlib)...\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/webonyx/graphql-php/issues/150#issuecomment-323412332,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/ANrH1_4Qa-8cXzOQLexbkYNfMnPmglLVks5sZciMgaJpZM4O6OO2\n.\n. \n",
    "clintburgos": "Wow, thanks for the quick reply. This is exactly what I was looking for and it works well. Thanks!. ",
    "tsingsun": "i update the issue..more description. $result = new Schema([\n            'mutation' => $mutation,\n            'types' => $types\n        ]);\nit does not work. ths,its usefull!! and sorry,I made a mistake,the graphql version is correct.. thx,is there a plan to support that?. ",
    "orls": "Note that you need to run the query twice on the head commit to see the error (first request doesn't use LazyResolution, so it can create the schema.descriptor file).. Ultimately, this is failing because of the strict equality check in Executor::doesFragmentConditionMatch.\nThe Lazy types resolver function creates a fresh instance of User on-demand; but the rest of the example fixures refer to a singleton created by Types::user().\nIf you replace the references to Types::user()  with the string 'User' in the example's  NodeType and QueryType classes, then this works.\nWhile it's possible to fix this example in that way, it does feel like a wider/general issue for the library. If lazy resolution is used, then for every place that the library does strict equality checks, the Type instances in question must all  come from the lazy type resolver originally. There's a lot of risk of users shooting themselves in the foot.\nWouldn't it be safe to just check that instances are of the same class? Or only allow specifying Types by their name, not providing whole instances? (i appreciate that's a bigger change for existing users). ",
    "symm": "@jasonbahl The anonymous functions will only be executed if the GraphQL lib needs to resolve them. You can verify by putting a sleep call on the Addition resolver and calling the echo method \ud83d\udc4d \nThat said, it's just a demo and I'd fetch the resolvers from a DI container in a real app.. ",
    "janschoenherr": "To add to this issue. Why does GraphQL try to catch all exceptions from user land code. Wouldn't it be better to catch specific GraphQL errors only. Currently it is not possible to handle custom exceptions that are thrown e.g. in the resolve callbacks. . Thanks I found the Exception in the ExecutionResult. However it seems a bit cumbersome to pull the original Exception from the \"Exception Chain\".\nWe are currently doing authorization logic in the resolve functions and are e.g. trying to throw an \"Unauthorized\" 403 Exception. The handling of that Exception is outside the GraphQL Execution. \nOr a simple case, where there is a PDO Database Exception. I'm not sure you'd want that in the errors result.\nIn case you'd want to throw a catchable Exception, it could be required to be a GraphQL Exception.. In general custom error filtering and formatting work fine. They introduce extra work on the user's part though.\nHowever to me it seems like the whole query should indeed fail in unexpected situations - even for a minor nullable field. The data might be incomplete and not usable anyway.\n\nSo the actual problem is that you really don't want to deliver error messages of \"unsafe\" exceptions to clients (as it happens today).\n\nThat's one part, yes. It seems to be solved with 0.10.0 as you've described. \nThe other part is, that I do want the whole query to fail in some cases. For example the user not being authorized to make the query.\n```php\n'fields' => [\n        'hero' => [\n            'type' => $characterInterface,\n            'args' => [\n                'episode' => [\n                    'description' => 'If omitted, returns the hero of the whole saga. If provided, returns the hero of that particular episode.',\n                    'type' => $episodeEnum\n                ]\n            ],\n            'resolve' => function ($root, $args, $context) {\n            if (!$context['user']->hasPermission('get_starwars_hero')) {\n                abort(401, 'Unauthorized action.'); // throws Framework's HTTPException\n            }\n\n            return StarWarsData::getHero(isset($args['episode']) ? $args['episode'] : null);\n        },\n    ]\n\n]\n```\n\nI also consider introducing GraphQL\\Error\\CriticalError interface so that when exception implementing such interface is thrown anywhere during execution - it is re-thrown by the executor and whole execution process is stopped.\n\nThat probably wouldn't help. As you'd have to again wrap the original Exception, if e.g. you are not the owner of the Exception. It might come from some library, framework or PHP itself.\nTo me it comes down to catching all Exceptions vs. GraphQL\\Error\\Error only. \nMaybe this behavior could be introduced by a configuration setting.\n. Thanks for the links and your thorough explanations!. Thanks, having the Debug::RETHROW_INTERNAL_EXCEPTIONS flag is great!. ",
    "nbulusanjr": "Hi vladar. I think i figured it out already. I forgot to do a composer install on the root directory. Thank you. . ",
    "SerafimArts": "'fields' can be callable. This resolves my solution.. @vladar I need this information for correct memory management. For example - information about the reflection of the field, about the type that is contained there. But Webonyx does not provide the ability to get information about the path to the field.\nAnd I cannot specify the route (ie, the resolver) that was hung this way:\nphp\n// it's physically impossible to match this route.\n$router->wherePath('a.b.c')->then(function (...) { return 42; });. > I guess it is a feature request then\nYep. > Actually I am quite curious on what are you trying to route at all? \nIt is assumed that this is an extended functionality of the ready-made routing (would you like some possibilities) =)\nExamples with interfaces and unions are already solved for my part on the basis of the argument \"on\": https://github.com/railt/railt/blob/master/resources/routing.graphqls#L17-L54\n...for the rest, it\u2019s a very long time to describe the benefits that can be obtained by having information on the real path, but in particular, I can then implement sharing of data into hereditary resolvers. Like this: \n\nNow the data can be shared not in all the resolver of descendants, but only in the immediate (ie, including aliases)\n. ",
    "rkrx": "Thank you! I've fixed the issue by ensuring, that only one instance of each definition is used per Schema. May be you should include a link to the registry-doc in that error message since the error-message is somewhat ambiguous.. ",
    "moon0326": "@vladar Thank you!\nIs there a way to access AST in a resolver?. @vladar That's all I needed. Thank you so much for taking for to reply!. @vladar Thank you for insight. I will look into it.\n@crirus That's interesting. Thank you so much! I will look into it.\nhave a great weekend both of you!. ",
    "justmoon": "@vladar Awesome, thanks for the super-quick reply!\nFantastic library btw! :+1:. ",
    "chrisharrison": "\nwill publish v0.10.1 as soon as travis build completes\n\nDoes this mean you expect it should be fixed in 0.10.1? Because I'm on that version according to composer and the constructor is still returning a new static.. Composer was resolving to 0.10.x-dev and it is not fixed on that branch:\nhttps://github.com/webonyx/graphql-php/tree/v0.10. \ud83d\udc4d Thanks! All working now.. ",
    "timur560": "I've fixed it just by additional check like:\nphp\nif (empty($variables)) {\n    $variables = null;\n}\nBut yes, it would be great to fix this in library code.. ",
    "Ngob": "@timur560 I am using StandardServer with the PSR-7 method, so I fixed it this way\n```\n  if (strtoupper($request->getMethod()) == \"GET\") {\n    $params = $request->getQueryParams();\n    $params[\"variables\"] = empty($params[\"variables\"]) ? null : $params[\"variables\"];\n    $request = $request->withQueryParams($params);\n  } else {\n     $params = $request->getParsedBody();\n     $params[\"variables\"] = empty($params[\"variables\"]) ? null : $params[\"variables\"];\n     $request = $request->withParsedBody($params);\n  }\n\n``\nBut it feels so hacky :(\nBy the way, thanks for your help :). At  the begininng I wanted to use the json's representation of my object to be used as the response (this way I just had to maintain jsonSerialize which is farily used in my application). If I understood right, the right way is using default resolver as you said, this way I can manage nesting \ud83d\udc4d \nBy the way, to manage If the users wanted 2 fields on 10 fields available, i would just calljsonSerializeand removing unneeded fields. But it seems it work wells in my app, as I rarely have to ask for a list of data so I do not have theN+1 problem`.\nSorry for disturbing.\nThanks a lot for your help.. Thanks you!. I will be honored if you do !\nThanks,. Thanks I am glad to help. PSR-15 is not accepted yet, so I will inform you once the package is stable.\nThanks again for your work.. I tried to parse it via apollo-server, it can not parse the double carriage return in argument's list.\nThanks for your response, I will just remove my description and wait the full support of type-def language in apollo-server.. Pretty weird. Here is my full type def:\n```\ntype Bill {\n  id: ID!\n  year: Int!\n  companyId: ID!\n  amount: Float!\n  toBill: ToBill!\n  billType: String!\n}\ntype Query {\n  billPerYear(id: ID!): Bill\n  toBillingCompanyByYear(id: ID!): ToBill\n  toBillingCompanyByYearList(\n    # limit\n    limit: Int\n    offset: Int\n  ): [ToBill]\n  toBillingCompanyByYearTotal: Int\n  toBillingCompanyByYearT1ableYearList: [Int]\n  toBillingCompanyByYearT1ableTotal: Int\n  toBillingCompanyByYearT1able(\n    # limit\n    limit: Int\n    offset: Int\n  ): [ToBill]\n  toBillingCompanyByYearT2ableYearList: [Int]\n  toBillingCompanyByYearT2ableTotal: Int\n  toBillingCompanyByYearT2able(\n    # limit\n    limit: Int\n    offset: Int\n  ): [ToBill]\n  toBillingCompanyByYearT3ableYearList: [Int]\n  toBillingCompanyByYearT3ableTotal: Int\n  toBillingCompanyByYearT3able(\n    # limit\n    limit: Int\n    offset: Int\n  ): [ToBill]\n  toBillingCompanyByYearT4ableYearList: [Int]\n  toBillingCompanyByYearT4ableTotal: Int\n  toBillingCompanyByYearT4able(\n    # limit\n    limit: Int\n    offset: Int\n  ): [ToBill]\n  toBillingCompanyByYearRegableTotal: Int\n  toBillingCompanyByYearRegable(\n    # limit\n    limit: Int\n# offset\noffset: Int\n\n): [ToBill]\n  toBillingCompanyByYearMinimalable(\n    # limit\n    limit: Int\n    offset: Int\n  ): [ToBill]\n}\ntype ToBill {\n  id: ID!\n  amount: Float!\n  companyId: ID!\n  year: Int!\n  billList: [Bill]\n}\n```\nI am sure the parsing fail on these lines (it work when I remove it):\n ```\n    # limit\n    limit: Int\n# offset\n\nApollo-server failed with the exception:\nExpected \")\", \"\\n\", \"\\r\", \"\\r\\n\", \"\\u2028\", \"\\u2029\" or [ \\t] but \"#\" found.\n```\nMaybe it is the adding of another description?. ",
    "cinder92": "thanks, after all i need to install composer, but now i'm having another issue, its the first on the list. can you please help me?. var dump\narray(4) { [\"request\"]=> array(6) { [\"cartstack_com-cartid\"]=> string(0) \"\" [\"__utma\"]=> string(54) \"111872281.82465390.1480367970.1496335355.1496339142.13\" [\"__utmz\"]=> string(70) \"111872281.1480367970.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none)\" [\"__atuvc\"]=> string(25) \"0|28,0|29,0|30,14|31,2|32\" [\"_ga\"]=> string(25) \"GA1.1.82465390.1480367970\" [\"SQLiteManager_currentLangue\"]=> string(2) \"10\" } [\"raw_input\"]=> string(0) \"\" [\"query\"]=> NULL [\"variables\"]=> NULL } {\"errors\":[{\"message\":\"Syntax Error GraphQL (1:1) Unexpected \\n\\n1: \\n ^\\n\",\"category\":\"graphql\",\"locations\":[{\"line\":1,\"column\":1}]}]}\nthis is query \n{\n  query {\n    echo (message: \"Hello world\")\n  }\n}\nand using GraphiQL returns this with POST\nSyntaxError: Unexpected token a in JSON at position 0. As you can see im using GrapQLi tool to send the query\n\nits possible that tool are not sending correctly? im sending a post...\n\nYour time its same valuable as mine, so. if don't have time to help then thanks.\n. ",
    "RedShift1": "Yes, also doesn't tell you how to do it?. Hmm I did try that earlier and that decorator function never got called (which is why I made this report - I thought it was the wrong way to go about it) . I will try again, maybe I missed something.. Aha it's working now. I was running version 0.9... Maybe mention in the docs this only works for versions > 0.10?. For example an Email type on a Input object. The ability to add custom types further describes and enforces the contract between client and server. Doesn't really make sense to describe an Email type in the .graphqls file if it only contains a String inside.\nPlus if you write the whole thing in PHP you have the ability to add custom types, so why wouldn't you when using the .graphqls file? It's a bit unrealistic to write the entire schema in PHP, the syntax is way to convoluted (it's basically unreadable). So writing the schema in graphql language makes much more sense and is compatible with other tools.. ",
    "galileomd": "i've updated the composer accordingly so that loads correctly, but since i'm running this from a remote server i'm not able to start a php session from inside the examples folder - this is the tree structure now:\n/\ngraphql.php\n   -vendor\n        -webonyx\n              -graphql-php\n                     composer.json\n                      -examples\n                             -01-blog\n                                     -Blog\nso does the psr-4 declaration still stay as this?\n      \"GraphQL\\Examples\\Blog\\\": \"examples/01-blog/Blog/\"\nor is it\n      \"GraphQL\\Examples\\Blog\\\": \"../../examples/01-blog/Blog/\"\nneither one is working for me currently.... looks like there is another composer.json in the root directory.\nadding the psr-4 namespaces there made it work :/. sure, was just curious how to the SQL calls were integrated into the resolver functions...\nthis looked like a neat demo, for anyone else looking for help. \nhttps://github.com/XAHTEP26/graphql-php-tutorial. ",
    "Chrisdowson": "@galileomd I have the some problem,How did you solve it?. ",
    "mirro-orrim": "Thanks to you, this resolved my issue!. ",
    "dereklavigne18": "The most common case I have noticed is the coercion of boolean query variables. Since there are not any checks on the value passed into a query variable declared as boolean (https://github.com/webonyx/graphql-php/blob/master/src/Type/Definition/BooleanType.php#L37) and the coercion relies entirely on what PHP interprets as truthy and falsey some unexpected values can be passed into the resolver. For instance, \"false\" and \"0.0\" are interpreted as truthy while \"0\" and 0.0 are interpreted as falsey. A client application of ours had at one point been sending \"false\" in a boolean query variable, which was then coerced to true and then passed off to the resolve function.  While the client application should not be passing arguments of the wrong type (especially since there is no way to know how they will be handled) the spec says it should raise a query error so the client knows it has done something wrong.\nHere's a quick PHP script I wrote to show how some edge case boolean query variables are being handled (apparently I can't upload .php files, so it's a .txt)\nboolCoercionExample.txt.\nI also included some tests in my PR that should confirm that the query variable type coercion meets the standards outlined in the specification. If you need anything else from me please let me know.\n. ",
    "dimitri-koenig": "Please reopen :-)\nWould be great to somehow be able to use .graphqls files with custom scalar types.\nRight now I'm using it your example from 21. Sept. But it's kinda ugly, especially when you get more and more scalar types. Any better idea to solve this?. That's a really good question. Sorry, didn't see that. Will change the call in another package which depends on this one. Thx anyway. ",
    "marhub": "@mcg-web how to get this to work properly ?\nEmailType must extend Overblog\\GraphQLBundle\\Definition\\Type\\CustomScalarType - i get that, but ... GraphQL\\Utils\\ASTDefinitionBuilder::makeScalarDef has GraphQL\\Type\\DefinitionCustomScalarType hardcoded, so my custom type is never resolved.... ",
    "remipelhate": "Perfect! Thanks for helping me out so quickly!. ",
    "caseycs": "@vladar I tried to make it work on the front-end side - but that was quite challenging, even while there are some apollo js components available on GitHub. I decided to use two-step approach for now - \"legacy\" ajax image upload to temporary storage returning uuid, which I use afterwise in graphql mutation.. @PowerKiKi I have PHP on the back-end, so was experimenting only with front-end part using https://github.com/jaydenseric/apollo-upload-client. @PowerKiKi thanks for your response! I was deeply investigating this issue 2-3 weeks ago, so do not have lots of context in my head ad-hoc. But I'll try to get back to in during upcoming few days. . @roippi I think Laravel is doing this is the same way - every middleware is wrapping another one, so you can always make a wrapper around your resolvers to handle, for example EntityNotFound exceptions.\nFor my handy use-case was to do instanceof check of final resolver in order to throw UserNotAuthorized exception when resolver implements AuthorizedUserOnly interface.. @enumag look at setErrorFormatter method. ",
    "bryan-havenly": "I read through the source of GraphQL\\Utils\\BuildSchema a little looking for the issue and it seems like it might be this chain of functions:\nmakeTypeDefConfig => makeFieldDefMap => produceOutputType => produceType => \ntypeDefNamed => makeSchemaDefConfig => makeTypeDefConfig => etc.... It fails during a request, but the infinite loop happens during the BuildSchema::buildAST call, not during GraphQL::executeQuery. So I would say that it fails while creating a schema.. I'm actually leaving on a vacation, but I work with @jrichard0725 and we've been having the same issue, so he can provide the code to reproduce.\nI think the issue actually is triggered by typeConfigDecorator, because at one point we call the fields Closure returned by the User type ($typeConfig['fields']()) in order to provide resolve functions for some of its fields. It seems like whenever that Closure is called it attempts to resolve all the types of the fields and recurses into oblivion.\nAnyway, @jrichard0725 can get you some code to reproduce this on Monday.. ",
    "greyexpert": "It work this way in graphql-js at the moment:\nThe extend type statement is not processed when you build schema in graphql-js using buildASTSchema. The statement is processed only in extendSchema which accepts already built root schema and applies extensions to it.\nWhat do you think, if we follow a slightly different approach:\nWe can add the support of extensions into BuildSchema itself without adding an extra utility like ExtendSchema. Having this feature supported, we will be able to build modular schema by just concatinating multiple schemas before passing them into BuildSchema::build\nFor example:\nRootSchema.graphqls\n```graphql\nschema {\n  query: Query\n}\ntype Query {\n  version: String\n}\n```\nUsersSchema.graphqls\n```graphql\ntype User {\n  name: String\n}\nextend type Query {\n  users: [User]\n}\n```\nThen, all we need is to concatenate them into result schema and pass to BuildSchema::build\n```php\n$schemaSources = [\n    file_get_contents(\"RootSchema.graphqls\"),\n    file_get_contents(\"UsersSchema.graphqls\")\n];\n$schema = BuildSchema::build(implode(\"\\n\\n\", $schemaSources));\n``\nThis feature will require less time, comparing to developing new utility. Also there are a lot of useful private methods inBuildSchema` class, which can be re-used.\nAnd, yes, I can create a pull request, if you guys don't mind this feature?\nRelated discussion in graphql-js repo:\nhttps://github.com/graphql/graphql-js/issues/922. @crirus \nIt would be great if you share your implementation. ",
    "MidnightDesign": "@vladar I'm sorry but I don't really get it. How is it supposed to be used? The class isn't referenced anywhere in the code and it has no public methods. Is it supposed to be extended? If so, why isn't it abstract and how is the inheriting class supposed to be used?\nEdit: I'm an idiot. I didn't see the extend() method down there.. @vladar I'm sorry if this is a dumb question, but is this supposed to somehow combine the two schema files\ngraphql\ntype Person {\n    name: String!\n}\ngraphql\ntype Person {\n    age: Int!\n}\ninto one\ngraphql\ntype Person {\n    name: String!\n    age: Int!\n}\nBecause that's exactly what I would need.. @Torsten85 \nIs the following supposed to work?\n```php\n$sdl = '\n  type Query {\n    defaultValue: String\n  }\n  type Foo {\n    value: Int\n  }\n';\n$documentNode = \\GraphQL\\Language\\Parser::parse($sdl);\n$schema = \\GraphQL\\Utils\\BuildSchema::build($documentNode);\n$extensionSdl = '\n  type Bar {\n    foo: Foo\n  }\n';\n$extendedDocumentNode = \\GraphQL\\Language\\Parser::parse($extensionSdl);\n$extendedScheam = \\GraphQL\\Utils\\SchemaExtender::extend($schema, $extendedDocumentNode);\necho \\GraphQL\\Utils\\SchemaPrinter::doPrint($extendedScheam);\n``\nI get aUncaught Type \"Bar\" not found in document.`. Obviously, this is because the extension schema references a type from the base schema, but what is this feature for if not for this use case?. ",
    "mariomka": "It's already implemented, I'm blind.... ",
    "Rendez": "@vladar thanks for the very quick answer. I agree let's keep this opened for a bit. Personally I do like option 1. because it plays nice when configuring PHP to run in either weak or strong typing mode.. Reading the spec for Boolean closer and given than PHP does have a bool type (unlike other langs), we're not limited to returning a coerced type. Therefore, even though is not coercing, I believe the next could be safe:\nphp\nclass BooleanType extends ... {\n    /**\n     * @param mixed $value\n     * @return bool\n     */\n    public function serialize($value) {\n        return $value ? true : false;\n    }\n}\n\n\"The Boolean scalar type represents true or false. Response formats should use a built\u2010in boolean type if supported; otherwise, they should use their representation of the integers 1 and 0.\"\n\nAgain, the point I'm trying to make is that PHP is already loose enough coercing types, and strict mode makes no difference to this behavior, leaving us with either tackling it here or using strict type with method return types: serialize($value): boolean { ... } which we do not use. As I understand, GraphQL philosophy is to avoid returning typing errors and instead coerce.\nThoughts?\n. Sure...\nphp\nreturn !!$value; // returns coerced value, e.g.:\n// IF $value = 'foo' THEN return !!$value EQUALS (int) 1\nphp\nreturn $value ? true : false; // returns boolean value\nWith the second approach we would make sure the coerced value is a boolean value, as expected. This IMO plays a very important role in type validation, avoiding potential pitfalls that come from checkbox value conversions, etc.\n. Oh my... echo VS var_dump, echo is obviously stringifying the real output. My bad...\nI feel after a few days even I got lost about the real issue, which was not being able to extend the scalar types. However, I'm closing this for now.. ",
    "apapazisis": "ok I think I have found it ScalarTypes. ",
    "mysiar": "each entity has id as below\nphp\n    /**\n     *\n     * @\\Doctrine\\ORM\\Mapping\\Column(type=\"uuid\")\n     * @\\Doctrine\\ORM\\Mapping\\GeneratedValue(strategy=\"CUSTOM\")\n     * @\\Doctrine\\ORM\\Mapping\\CustomIdGenerator(class=\"Ramsey\\Uuid\\Doctrine\\UuidGenerator\")\n     * @\\Doctrine\\ORM\\Mapping\\Id()\n     * @\\Symfony\\Component\\Serializer\\Annotation\\Groups({\"view\", \"list\"})\n     *\n     * @var \\Ramsey\\Uuid\\Uuid\n     */\n    private $id;. ",
    "jakubkulhan": "@vladar Superb, it works. Thank you!. > But keep in mind that GraphQL execution is nuanced and has edge cases.\nI get now what you meant. I had to give up the idea of separate compilation phase, because CollectFields() algorithm depends on the variables in the request, so execution pipeline can't be determined ahead-of-time, e.g.:\ngraphql\nquery Q($condition: Boolean!) {\n  foo @include(if: $condition)\n  foo: bar\n}\nThis query might call resolver for either foo, or bar - depending on the value of $condition.\n\nCurious to see your final benchmarks.\n\nHowever, I kept working with the simplified execution flow.  And it got me to an implementation that is, for our \"big query\", at least twice as fast.\nNew executor uses coroutines implemented using generators instead of promises and callbacks. For every object field resolution the Executor creates a new strand (also called fiber / green thread / lightweight thread / goroutine) and starts a new coroutine Executor::spawn(). Then it runs (Executor::run()) queued strands until completion. \nPromises are handled by Executor::$pending counter - when the execution is postponed by promise, pending counter is incremented. After the promise is fulfilled/rejected, pending\u00a0is decremented, strand is pushed back to the queue and the execution resumes. After all strands are completed, the main promise is resolved.\nCall graph is much simpler than before:\n\nA lot of performance improvements were gained by memoization, see ExecutionContextShared. Most importantly if there is an array of objects, sub-fields' collection and other computations are run only once. \nAnother 30 % improvement could be gained when schema sanity checks are removed, see https://github.com/jakubkulhan/graphql-php/compare/compiler...faster. However, it would mean some breaking changes (11 tests failing).\n\nYou can use phpcs against your code directly for now.\n\nOk, changes formatted by phpcbf.\n\nI guess it shouldn't be that hard to pass an array by reference instead of just stdClass or am I missing something?\n\nBecause of coroutines scheduling I don't know the point in which the resulting array should be checked whether it must be converted to stdClass. Instead, I've added Executor::resultToArray() that converts stdClasses to arrays at the end of the execution. It adds negligible overhead.\n\nSo for this PR to be merged into the lib, we must be sure that you will be ready to maintain it for some foreseeable future (meaning bug-fixes and keeping it up-to-date with the future versions of the spec).\n\nAs we use this library in production, I intend to do this :). > By the way, do you have any benchmarking project?\nI created a benchmark for our complex query (it does 1499 resolve calls, of which 449 are for __typename /the query is generated by Apollo Client/) with static data pre-generated from production & resolver like Executor::defaultFieldResolver\u00a0instead of individual resolve methods. But I don't think I'll be able to release this.\nResults are similar to yours:\n+-------------------+---------------------------------+--------+--------+------+-----+-------------+----------+----------+----------+----------+---------+--------+-------+\n| benchmark         | subject                         | groups | params | revs | its | mem_peak    | best     | mean     | mode     | worst    | stdev   | rstdev | diff  |\n+-------------------+---------------------------------+--------+--------+------+-----+-------------+----------+----------+----------+----------+---------+--------+-------+\n| ExecutorBenchmark | benchNewExecutor                |        | []     | 100  | 3   | 33,452,600b | 6.356ms  | 6.463ms  | 6.404ms  | 6.620ms  | 0.113ms | 1.75%  | 1.05x |\n| ExecutorBenchmark | benchNewExecutorNoSchemaChecks  |        | []     | 100  | 3   | 33,346,304b | 6.020ms  | 6.146ms  | 6.055ms  | 6.369ms  | 0.158ms | 2.58%  | 1.00x |\n| ExecutorBenchmark | benchOldExecutor                |        | []     | 100  | 3   | 9,369,216b  | 14.010ms | 14.105ms | 14.126ms | 14.192ms | 0.075ms | 0.53%  | 2.30x |\n| ExecutorBenchmark | benchOldExecutorWithMemoization |        | []     | 100  | 3   | 9,487,376b  | 9.394ms  | 9.635ms  | 9.672ms  | 9.860ms  | 0.190ms | 1.98%  | 1.57x |\n+-------------------+---------------------------------+--------+--------+------+-----+-------------+----------+----------+----------+----------+---------+--------+-------+\nReason, that old executor with memoization is worse than in your benchmark, is probably by new executor's short-circuit execution for __typename field. I think it could be added to the old executor as well.\nWe run queries with SyncPromiseAdapter, however, some fields return Deferreds to leverage batch loading from DB. So I re-ran benchmark with 15 % of calls to resolve methods return Deferred (about the same ratio of resolve calls that our real schema would return as async):\n+-------------------+---------------------------------+--------+--------+------+-----+-------------+----------+----------+----------+----------+---------+--------+-------+\n| benchmark         | subject                         | groups | params | revs | its | mem_peak    | best     | mean     | mode     | worst    | stdev   | rstdev | diff  |\n+-------------------+---------------------------------+--------+--------+------+-----+-------------+----------+----------+----------+----------+---------+--------+-------+\n| ExecutorBenchmark | benchNewExecutor                |        | []     | 100  | 3   | 54,489,368b | 8.319ms  | 8.354ms  | 8.361ms  | 8.386ms  | 0.028ms | 0.33%  | 1.08x |\n| ExecutorBenchmark | benchNewExecutorNoSchemaChecks  |        | []     | 100  | 3   | 53,846,080b | 7.597ms  | 7.728ms  | 7.638ms  | 7.950ms  | 0.158ms | 2.04%  | 1.00x |\n| ExecutorBenchmark | benchOldExecutor                |        | []     | 100  | 3   | 13,377,192b | 21.281ms | 21.487ms | 21.549ms | 21.658ms | 0.156ms | 0.72%  | 2.78x |\n| ExecutorBenchmark | benchOldExecutorWithMemoization |        | []     | 100  | 3   | 14,034,973b | 15.836ms | 16.142ms | 16.241ms | 16.387ms | 0.229ms | 1.42%  | 2.09x |\n+-------------------+---------------------------------+--------+--------+------+-----+-------------+----------+----------+----------+----------+---------+--------+-------+\nAlso if all calls to resolve methods return `Deferred`:\n\n```\n+-------------------+---------------------------------+--------+--------+------+-----+-------------+----------+----------+----------+----------+---------+--------+-------+\n| benchmark         | subject                         | groups | params | revs | its | mem_peak    | best     | mean     | mode     | worst    | stdev   | rstdev | diff  |\n+-------------------+---------------------------------+--------+--------+------+-----+-------------+----------+----------+----------+----------+---------+--------+-------+\n| ExecutorBenchmark | benchNewExecutor                |        | []     | 100  | 3   | 57,660,896b | 14.826ms | 15.154ms | 14.911ms | 15.749ms | 0.421ms | 2.78%  | 1.06x |\n| ExecutorBenchmark | benchNewExecutorNoSchemaChecks  |        | []     | 100  | 3   | 56,003,240b | 14.058ms | 14.308ms | 14.380ms | 14.520ms | 0.190ms | 1.33%  | 1.00x |\n| ExecutorBenchmark | benchOldExecutor                |        | []     | 100  | 3   | 17,371,088b | 36.865ms | 37.332ms | 37.500ms | 37.681ms | 0.344ms | 0.92%  | 2.61x |\n| ExecutorBenchmark | benchOldExecutorWithMemoization |        | []     | 100  | 3   | 17,139,288b | 30.933ms | 31.350ms | 31.212ms | 31.840ms | 0.374ms | 1.19%  | 2.19x |\n+-------------------+---------------------------------+--------+--------+------+-----+-------------+----------+----------+----------+----------+---------+--------+-------+\n```\n\n\nOld executor seems to perform worse if promises are involved.\n\nBtw still the benchmark results show overhead of old executor only about 20ms. I ran benchmarks on my local computer. I'll have to look why on the server overhead is so much bigger.. Fixed, reference cycles needed to be broken.\n+-------------------+---------------------------------+--------+--------+------+-----+-------------+----------+----------+----------+----------+---------+--------+-------+\n| benchmark         | subject                         | groups | params | revs | its | mem_peak    | best     | mean     | mode     | worst    | stdev   | rstdev | diff  |\n+-------------------+---------------------------------+--------+--------+------+-----+-------------+----------+----------+----------+----------+---------+--------+-------+\n| ExecutorBenchmark | benchNewExecutor                |        | []     | 100  | 3   | 10,168,368b | 8.193ms  | 8.243ms  | 8.211ms  | 8.325ms  | 0.058ms | 0.71%  | 1.06x |\n| ExecutorBenchmark | benchNewExecutorNoSchemaChecks  |        | []     | 100  | 3   | 9,523,752b  | 7.542ms  | 7.751ms  | 7.830ms  | 7.899ms  | 0.152ms | 1.96%  | 1.00x |\n| ExecutorBenchmark | benchOldExecutor                |        | []     | 100  | 3   | 10,926,120b | 22.744ms | 23.053ms | 22.853ms | 23.554ms | 0.357ms | 1.55%  | 2.97x |\n| ExecutorBenchmark | benchOldExecutorWithMemoization |        | []     | 100  | 3   | 11,391,309b | 17.129ms | 17.346ms | 17.197ms | 17.713ms | 0.261ms | 1.51%  | 2.24x |\n+-------------------+---------------------------------+--------+--------+------+-----+-------------+----------+----------+----------+----------+---------+--------+-------+. @vladar Yes, that sounds reasonable.. Rebased onto master, new executor implementation moved to namespace GraphQL\\Experimental\\Executor, GraphQL\\Executor\\Executor can switch between implementations. . @Smolevich Sorry, can't do, it uses our schema code. However, the query looks like this https://gist.github.com/jakubkulhan/e938b66d7e498d549d1d8727cddd3659. @vladar Ok, thank you. Let me know and I'll rebase the branch onto master.. @vladar I'll rebase new executor code in the next few days. Is there something I can improve, so the code could be easier to understand?. OK, rebase is complete.. @vladar Thank you for merging! \nAbout order of traversal, I've encountered this in some test cases (e.g. DeferredFieldsTest). I hope nobody's code depends on the specific order :) \nAlso the new executor may call resolvers for fields that won't be included in the result due to errors on sibling fields or sibling's sub-graphs. For example with schema:\ngraphql\ntype RootQuery {\n  foo: Foo!\n}\ntype Foo {\n  id: ID!\n  foo1: Foo!\n  foo2: Foo!\n  foo3: Foo!\n}\nFor query:\ngraphql\nquery Q {\n  foo {\n    id\n    foo1 { id }\n    foo2 { id }\n    foo3 { id }\n  }\n}\nAFAIK the old executor won't call resolver for foo3 if foo2 fails. However, the new executor will. As it will call resolvers for the whole foo3 sub-graph. This could be possibly eliminated by dependency tracking between execution strands. However, it unnecessarily slows down average-case execution, i.e. when no resolver fails.\nFor coverage, it should be possible to run PHPUnit with env variable EXECUTOR=couroutine\u00a0and w/o and then merge generated coverage reports - https://stackoverflow.com/a/30898560/149230\nWe've been using without any issue the new executor in production at Scuk.cz since the end of July when I committed the implementation that passed all tests. \nAlthough I've made one addition to the code we run in production - result caching. It can bypass calling resolvers for whole sub-graph and read result from the cache instead. Now that this PR is merged, if you'd be interested, I might send the PR with this change. However, it would be only for the new executor, I don't see how it would be possible to port this to the old executor.. @adri GraphQL::executeQuery() accepts both string and instance of DocumentNode (see https://github.com/webonyx/graphql-php/blob/master/src/GraphQL.php#L128-L132). We use two-level caching (in-process using APCu and out-of-process using Redis) for expression Parser::parse($query, [\"noLocation\" => true]) (noLocation is needed, otherwise parsed AST is really big) that gets passed instead of raw query string.. @adri Yes, it's stored serialized by PHP's native serialize(). To prevent issues with version upgrades, cache key contains graphql-php's package version obtained using ocramius/package-versions.. Hello, @enumag. Do you use a custom promise adapter? Could you provide a minimal reproducible code?. ",
    "spinx": "First of all @vladar thank you and other contributors for your work on this lib, it made our journey towards adopting GraphQL just immensely easier. \nI believe apollo-tracing is solving one of the biggest downsides of GraphQL, especially for smaller teams - that's being able to easily debug and resolve potential issues and having confidence when migrating to this weird new way that can result in hundreds of DB calls, where seemingly nothing can be cached super effectively. \nI'd expect libraries like graphql-php and others to implement tracing/debugging and other extensions as a core feature, or at least a way to add that as a 'plugin' very easily. \nHow this is implemented is another discussion altogether, perhaps more relevant to this thread. From a stand point of a lib, there needs to be a choice, obviously. And with that sorted I don't see a problem - I as probably many others will opt for unlocking the value that this would provide or at least weigh up prons and cons of different approaches - which can all be described in docs. . ",
    "freder": "update: sending the same query with graphiql works just fine. if I'm not mistaken the main difference seems to be the content-type request header:\n\napollo: application/json\ngraphiql: text/plain;charset=UTF-8\n\n\ud83e\udd14. @vladar I should have mentioned: was indeed talking about the automatic OPTIONS request by the browser.\ncould you elaborate a bit on processing OPTIONS separately \u2013 I'm not entirely sure what you mean.\nthank you.. thanks @vladar . ",
    "Poky85": "@szonov Thanks for suggested solution. There have been no PR for a long time, so I created mine in #253.. ",
    "theofidry": "@vladar I'm using it with OverblogGraphQLBundle so maybe it's an issue there but I wouldn't override the ID type as it's internal and used in Type::getInternalTypes() which is static (so even if we can extend type to override it it's not enough). So you would need to register a new type with a different alias and use that new alias, which is too much of a change as it requires to update all the front-ends as well.\nWe have a dirty workaround for now, but the fix in the core is rather simple...:\nphp\n    /**\n     * @param mixed $value\n     * @return string\n     */\n    public function serialize($value)\n    {\n        if ($value === true) {\n            return 'true';\n        }\n        if ($value === false) {\n            return 'false';\n        }\n        if ($value === null) {\n            return 'null';\n        }\n        try {\n             return (string) $value;\n        } catch (\\Throwable $throwable) {\n             throw new InvariantViolation(\"ID type cannot represent non scalar value: \" . Utils::printSafe($value));\n        }\n    } \n. That would work but there is a performance overhead as you would try to check if the method exists but if you want to support PHP 5.5 I don't think there's another way.\nIs there any reason not to push that library to PHP 7.1?. True but:\n\nPHP 5.5 already reached EOL\nPHP 5.6 & 7.0 are reaching EOL in 1 year\nthe adoption rate for PHP 7+ is quite good\n\nAnd sticking to PHP 5.5+:\n\nprevents you to leverage scalar typehints\nrequires you to check more PHP versions\n\nAnd we are talking for the new versions. It's not like the library is disappearing for the current PHP 5.5 users, they just wouldn't access to the latest version.\nBut ultimately, the burden is on the maintainer, you. So you're the one doing the call depending of what you need from this lib and what you're ready to maintain :). Cheers \ud83d\udc4d . For now the only two cases we have are the ID and the String.\nThe string was for a value object that was stringeable and the new version handles it correctly now so this will no longer be necessary after an upgrade.\nFor the IDs, we have an IntId class holding an integer value. When serialized, it should provide the int, but as there is not __toInt magic method or a way to convey it, we need to rely on a custom type for that:\n```php\nclass IDType extends NativeIDType\n{\n    /*\n     * @var string\n     /\n    public $name = Type::ID;\npublic function serialize($value)\n{\n    if ($value instanceof IntId) {\n        return $value->toInt();\n    }\n\n    return parent::serialize($value);\n}\n\n}\n```. \ud83d\udc4c . is it expected to have tabs here?. ",
    "otzy": "Hi @vladar,\nthanks for your response.\nI added a test, that fails on the current version.\nThe schema is defined in /test/LazySchema.php.\nSelfResolvedObject type has a resolve function. And this type is used as a field in Query type, but without resolve specified. My expectation was that if it's not specified for a field, then the 'resolve' function of type should be used to calculate values.\nIt works actually for normal, not lazy loading. So I think it's ok if lazy loading will have the same behaviour.. you are right, it's not really how GraphQL is designed. I was just confused, because the same worked for eager loading.\nOn the other hand it can be convenient when an object does not depend on the parent in hierarchy. For example you need to render some overal statistics, which you simply calculate with sql query.\nOr the object is dependent only on the parent object and does not depend on where it's used in schema. So you don't need to write a resolver every time you use the type (example - https://github.com/graphql/graphql-js/blob/master/src/tests/starWarsSchema.js - secretBackstory in Human and Droid)\nOr you want to add a field with profiling info and render it in very end.\nWith type-based resolver you can easily reuse a field in any schema (you can have multiple in the project) and don't need to write resolve function every time you include such field. > I am really surprised that it worked for eager loading because there is no resolve option on the type level regardless of lazy/eager loading mode.\nNow I'm testing and it does not work, probably I did something wrong when was learning the library.\n\nResolving the whole type if a client asks for 2 fields only is against this principle.\nTrue. Although in real life we have fully instantiated objects in most cases anyway and resolving is just selecting the requested fields from these objects.\nAlso following this principle makes schema definition a bit verbouse, leads to extra function calls and makes reusing of types more complex.\n\nI'm just starting with GraphQL though, so may be my mind will be changed after a while :). there was a bunch of closures in the trace, I'll try to reproduce. This is the top of trace.\nTo reproduce I defined type as something other than GraphQL\\Type\\Definition\\Type\nIt can be stdClass or even scalar, does not matter \n```\n(1/1)\u00a0FatalThrowableErrorType error: Argument 1 passed to GraphQL\\Executor\\ExecutionContext::addError() must be an instance of GraphQL\\Error\\Error, instance of TypeError given, called in vendor/webonyx/graphql-php/src/Executor/Executor.php on line 316\n--\nin\u00a0ExecutionContext.php\u00a0line 88\nat\u00a0ExecutionContext->addError(object(TypeError))in\u00a0Executor.php\u00a0line 316\nat\u00a0Executor->GraphQL\\Executor{closure}(object(TypeError))in\u00a0SyncPromise.php\u00a0line 144\nat\u00a0SyncPromise->GraphQL\\Executor\\Promise\\Adapter{closure}()in\u00a0SyncPromise.php\u00a0line 35\nat\u00a0SyncPromise::runQueue()in\u00a0SyncPromiseAdapter.php\u00a0line 140\nat\u00a0SyncPromiseAdapter->wait(object(Promise))in\u00a0GraphQL.php\u00a0line 88\nat\u00a0GraphQL::executeQuery(object(Schema), '{ getUser(db_id: 123){ name } profiler{ log }}',\u00a0array(),\u00a0object(PlayWithRelayController),\u00a0null)in\u00a0PlayWithRelayController.php\u00a0line 83\n``.$schema->assertValid();throws an exception with a suggestion to run assertValid():One of the schema types is not a valid type definition instance. Try running $schema->assertValid() to find out the cause of this warning.`\nIn the trace it's possible to find what was the invalid type, but it's not clear where it comes from. It would be nice to see a path to error node in a future release.\nRegarding the type hint in the addError() function - now it works in a way that we don't expect from exceptions. It replaces the real exception with unrelated one.\nAnd general thought -  if a function is called with an argument of wrong type it's a programmatic error. In this case addError() is called by another function of the same package, not from outside, so this looks like a bug.\n. ",
    "keithrobichaud": "I was originally thinking that #193 would be sufficient for our use case, but I'm not sure how we would be able to add request start/end times from within the context of a resolver without doing some super janky stuff. A resultFormatter would definitely work if I'm interepreting what you mean correctly (pass in a function that takes the result as a param and returns a new formatted version of the result). Actually, after further inspection, it seems I can already essentially do that using $result = $server->executeRequest() and then handling it in my application code. . just in case anyone is looking at this later, I had to do this in order for it to work:\n$myVisitor = [\n            NodeKind::SELECTION_SET => function(SelectionSetNode $selectionSet) {\n                $newSet = clone $selectionSet;\n                $length = count($newSet->selections);\n                $newSet->selections[$length] = new FieldNode([\n                    'name' => new NameNode([\n                        'value' => '__typename'\n                    ])\n                ]);\n                return $newSet;\n            }\n        ];. Quick update: I've defined a union type with a very similar format and that is working as intended. Very strange. Still trying to get the interface type working as that is the ideal solution.. I was only seeing it get hit once even when it wasn't working. I came back to it with a fresh set of eyes and I don't know what I did differently this time but it is now working. Sorry for the inconvenience!. ",
    "andrewmclagan": "Thank you! thats a great  direction to start. Basically we want to transform / normalise on our server and not our frontends. It saves data transmission size and workload on the frontends. I will keep this open with our progress. ",
    "alfaproject": "@vladar I updated the original post with a simple test, and with the value of $args in both resolvers. What do you mean?\n$args = ['id' => 'one'] as per the comment on the resolve method. Why is it not on the resolveField as well? That's what I'm not understanding.. I thought there would be some sort of inheritance going on or at least have a way to access the args further up the tree? ):. Makes sense and fair enough. Thank you for your help mate. (:. ",
    "vbelorus": "Maybe it's issue of overblog/graphql-bundle\nThis bundle generate such schema for this field:\nphp\n'name' => [\n                        'type' => Type::nonNull(Type::string()),\n                        'args' => [\n                        ],\n                        'resolve' => function ($value, $args, $context, ResolveInfo $info) use ($container, $request, $user, $token) {\n                            $resolverCallback = function () use ($container, $request, $user, $token) {\n                                return call_user_func_array(['Overblog\\\\GraphQLBundle\\\\Resolver\\\\Resolver', 'defaultResolveFn'], func_get_args());\n                            };\n                            $accessChecker = function ($value, $args, $context, ResolveInfo $info, $object) use ($container, $request, $user, $token) {\n                                return $container->get('security.authorization_checker')->isGranted(\"ROLE_ADMIN\");\n                            };\n                            $isMutation = $info instanceof ResolveInfo && 'mutation' === $info->operation->operation && $info->parentType === $info->schema->getMutationType();\n                            return $container->get('overblog_graphql.access_resolver')->resolve($accessChecker, $resolverCallback, [$value, new Argument($args), $context, $info], $isMutation);\n                        },\n                        'description' => null,\n                        'deprecationReason' => null,\n                        'complexity' => null,\n                        'public' => null,\n                    ]\nBut anyway, as I understand if I haven't access to the field only this field should be null, not all node, am I right?. @mcg-web you're right! If set this field nullable it works fine! Thanks a lot.. ",
    "SevInf": "@vladar we lazy-load our graphql  types with typeLoader option. At the same time, we want to load everything when validating the schema (similar to ##168). If we do it, we can't override id type anymore, since by the time callback-style $types is called default IDType is already added.. Also, i think spec and reference implementation changed since this PR.  Explicit \"null\" don't sets value to default anymore.. It looks like #262 resolves it. ",
    "giansalex": "I think that if someone wants to see the documentation, they should go to https://webonyx.github.io/graphql-php/. ",
    "Koredeoluwafemi": "<?php\nnamespace Schema\\Mutation;\n\nuse Core\\TypeRegistry;\nuse GraphQL\\Type\\Definition\\ResolveInfo;\n\nuse GraphQL\\Type\\Definition\\Type;\nuse GraphQL\\Type\\Definition\\ObjectType;\nuse GraphQL\\Type\\Definition\\InputObjectType;\n\nuse Helpers\\SimpleCurl;\n\nclass MutationType extends ObjectType\n{\n    public function __construct()\n    {\n        $config = [\n            'name' => 'Mutation',\n            'fields' => [\n                'signup' => [\n                   'type' => new ObjectType([\n                            'name' => 'CreateReviewOutput',\n                            'fields' => [\n                                'user_id' => Type::int(),\n                                'user_firstname' => Type::string(),\n                                'user_lastname' => Type::string(),\n                                'user_email' => Type::string(),\n                                'status' => Type::boolean()\n                            ]\n                ]),\n                'description' => 'Returns user by id',\n                'args' => [\n                    'user_firstname' => Type::nonNull(Type::string()),\n                    'user_lastname' =>Type::nonNull(Type::string()),\n                    'user_email' =>Type::nonNull(Type::string()),\n                    'user_phone' =>Type::nonNull(Type::string()),\n                    'password'  =>Type::nonNull(Type::string()),\n                    'business_name'  =>Type::nonNull(Type::string()),\n                    'status'  =>Type::boolean(),\n                ]\n            ],\n             'user' => [\n                'type' => TypeRegistry::user(),\n                'description' => 'Returns user by id',\n                'args' => [\n                    'id' => TypeRegistry::nonNull(TypeRegistry::id())\n                ]\n            ]\n        ],\n         'resolveField' => function($val, $args, $context, ResolveInfo $info) {                 \n            return $this->{$info->fieldName}($val, $args, $context, $info);\n        }\n    ];\n    parent::__construct($config);\n}\n\npublic function signup($rootValue, $args)\n{\n    $api_url = USER_SERVICE;\n    $api_url .= '/signup';\n\n      $fields['user_firstname'] = $args['user_firstname'];\n      $fields['user_lastname'] = $args['user_lastname'];\n      $fields['business_name'] = $args['business_name'];\n      $fields['user_email'] = $args['user_email'];\n      $fields['user_phone'] = $args['user_phone'];\n      $fields['user_password'] = $args['password'];\n\n    return json_decode(Simplecurl::post($api_url, $fields));\n}\n\n\npublic function user($rootValue, $args)\n{\n\n    $api_url = USER_SERVICE;\n    $api_url .= '/user/get/'.$args['id'];\n    return json_decode(Simplecurl::get($api_url));\n}\n\n}. thats my mutation declaration above and I am  returning\nobject(stdClass)[392]\n  public 'status' => string 'error' (length=5)\n  public 'msg' => string 'Business exists, please use a different name' (length=44)\n\nyet I still get \n@{\ndata: {\n           signup: null\n        }\n}\n\nwhats misssing, help me. I think I get it now, its working now, Thanks.. ",
    "spawnia": "@vladar Do you have any ideas on how the Parser could be improved to use less memory?\nAs you correctly assessed, parsing such large schemas on every request is too much. This is why we over at https://github.com/nuwave/lighthouse cache the AST and are even considering to split up the cache by type. However, we do require parsing the entire schema initally, as well as for schema manipulation.\nI thought about splitting all the types across seperate schema files and parse them seperately, but do not like the idea of forcing this file organization and structure upon the user. It would also complicate things quite a bit on our end. Could we reduce the memory footprint of the Parser by first implementing a light-weight way of splitting the schema into types and then parse and cache those seperately?. > You can easily parse type files separately and then extract specific type AST from the resulting document\nTo be honest, that feels like a bit of a hack. We use an extra class for partial parsing: https://github.com/nuwave/lighthouse/blob/master/src/Schema/AST/PartialParser.php If you are up for it, maybe we can implement something like this in the core library?\nThank you so much for the links, enabling OPCache did the trick - i am now able to parse my schema file in one go easily, and response time was cut in half.. Hey @vladar, to understand this better: What is the reasoning behind using NodeList in the first place?. I can confirm this, has happened to me as well!. I am using laravel-graphql which uses an older version: 0.10.2.\nWhile looking through the repo some more, i found pull request #171 which implements strict input type coercion. For a golden period of time, this actually was spec-compliant.\nUnfortunately, along comes #248 which reverts back treating input coercion for variables in parseValues() the same way that output coercion in serialize() is done. While this does mirror the reference implementation, it breaks spec compliance.\nI already opened an issue in laravel-graphql with a detailed example of what the loose input coercion leads to, please have a look. I just think that simply coercing away such bad inputs does not make sense and if i understand the spec correctly, it actually should not happen.\n. Actually, that is exactly what i did: https://github.com/graphql/graphql-js/issues/1324 I really hope they will respond soon and take care of this.\nThere is an argument to be made for doing some coercion for input variables: Since graphql does not specify a transport format, theoretically there could be a format that does not have native support for some of the scalars that graphql offers. Literals are different in that regard, since the query string itself has a well known format.\nRealistically, i have not heard of a case where variables are provided through anything else than a JSON object. Because of this, it is reasonable to assume that variables do have a direct equivalent to the scalar types defined by graphql. Should a use case pop up where variables are passed in a format that, for example, can only supply string values - then a more loose coercion would be necessary.\nSuppose the reference implementation stays with their current way of doing things, how would you proceed? I can understand not wanting to deviate from them, but on the other, deviating from what the spec is doing seems even worse.\nMaybe there is a way to both maintain feature parity with the reference implementation and offer spec-compliant strict input coercion for the 99% use case, which is variables passed through JSON, by offering a configuration option for it?. A PR in the reference implementation is on the way to switch to strict input type coercion: https://github.com/graphql/graphql-js/pull/1382. It does return NodeList in v0.12.4 indeed, so that seems like it was fixed.\nHowever, the main issue actually is that the return types for lists of nodes are still not correct. While it would certainly be an easy fix to change them all to NodeList, i do not quite like that this would then hide the underyling type.. I would still prefer correctness of the actual type hint over expressive pseudo type hints. Maybe like this:\n/**\n * @var NodeList|ArgumentDefinitionNode[]\n **/\npublic $arguments;. As i mentioned in a comment, i think #323 has the DocBlocks the wrong way around. The actual type should come first (NodeList) and the pseudo-type second.. @vladar #323 does not fix this, as the typehint is still wrong. Please reopen. I am still not quite sure whether NodeList or NodeList|SomeTypeOfNode[] is better. Both are certainly superior to SomeTypeOfNode[]|NodeList.\nThe issue i have with annotating multiple types is that it leads the unknowing developer to believe that it could be both, when in reality it is always a NodeList. However, that loses the information about what type is actually used. \nIt is a bit unconventional, but we might actually put the diamond operator in the DocBlock. While that is not a part of any standard whatsoever, it actually leads to the correct type being recognized, but also informs a developer of the underlying type. At least it works in PHPStorm.\n\n. The semantics of the current behaviour is off. \nI do have an Exception that implements ClientAware and isClientSafe() === true, thus it is seen as not internal. I expect it to not be rethrown. Currently it is.\nAs of now, a more accurate name for the flag would be RETHROW_EXCEPTIONS_THAT_ARE_NOT_INSTANCES_OF_GRAPHQL_ERROR_ERROR. I assume the point of RETHROW_INTERNAL_EXCEPTIONS is for debugging purposes, to handle exceptions that should not go in the response. This is why it does not rethrow GraphQL\\Error\\Error instances - it makes sense, as those Exceptions were expected to happen and are rendered to the client output.\nNow, the ClientAware interface seems like it should enable Exceptions to behave the same way. Those that are marked as client-safe can be rendered to the output safely, and may be expected runtime errors. They are not \"internal\", as the $isInternal = ! $e instanceof ClientAware || ! $e->isClientSafe(); line implies.\nThis is why i think the current behaviour is faulty and what i propose is a valid fix for that bug. It is a change in behaviour, yes, but it only affects a small slice of users, and only if Debugging is enabled. Production use will not break as a result of this.. That makes sense. I agree we should get rid of the naming mismatch.\nHow would i go about adding the new Debug flag RETHROW_INTERNAL_UNSAFE_EXCEPTIONS? Would it be an int = 8 in the Debug class?. I dug a little further into the code and found the root cause.\nYou can reproduce it with a schema like this and by using a typeLoader to lazily resolve the types.\n```graphql\n    interface Nameable {\n        name: String!\n    }\ntype User implements Nameable {\n    name: String!\n}\n\ntype Query {\n    namedThings: [Nameable!]!\n    # It does not find the User type if this is not present\n    # user: User\n}\n\n```\nGraphQL\\Utils\\TypeInfo::resolveInfo() is responsible for walking through a schema and recursively finding all types that are used. It does not find the User type if it is not explicitely used in a Query. And honestly, i do not have a clue how it might do that.. @chrissm79 I think the easiest fix for us is just to pass in the types directly. It is not like our type registry is doing any actual lazy type loading, so we do not lose out in terms of performance.\nLet's just use the Schema directly instead of the TypeRegistry. At least that will avoid duplicating the information in two classes when it is really the same. I will prepare a PR for it!. Validation always has to be done on the server. Client-side is an added bonus, that provides instant feedback, but the server always has the final word. There are also some constraints that can only be validated on the server, for example the uniqueness of a field.\nI do agree that the errors are meant for the developer, and yeah, i would not just dump the error JSON to the screen. What i am trying to do is to consume the validation errors provided by the server and map them back to the original form. The current structure of the error messages makes that quite hard and i think can be improved upon.\nWhat do you think about the format i proposed?. Hey @vladar, thank you for your detailed and well thought out response.\nAs you said, there is a notable difference between formal validation and app-related validation. However, there is value in having a unified response format for both. This becomes especially useful when using Scalar types for validation.\n\nFirst problem is that locations is a stack, not a list.\n\nCan you point me to a resource where i can read more about this? Are there examples in the tests to look at? The spec does say that locations is in fact a list.\n\nSecond problem is that path is execution-related.\n\nThe format i propose does respect that, the path only contains the field. Of course, the arguments are not part of the response, but they are only mentioned in the extensions key.\n\nAnd most importantly your format targets a different use-case.\n\nI do agree that the use-case is different. Do you think that it is less useful for debugging queries?\nIf we do implement this with a custom validation rule, would that mean we have to disable the original validation rule?\n. Shouldn't those be changed around (as well as in other places where NodeList occurs), because the property actually IS a NodeList. Two notes on this:\n\nSuch micro-optimization deserve a line comment.\nYes, there are comments to disable style-checks on a per-line basis. Depends on the tool that is used.. I believe that all lists of related nodes in the AST are actually of the type NodeList, so the type annotation should match that. It is fine to have the underlying type of the NodeList as a secondary hint, so it should be NodeList|DirectiveNode[]. I am not actually sure that having both is actually correct. I just looked up the meaning of the pipe character | in types. In this case, it actually always is one exact type, NodeList.. Agreed. Go ahead then. \n",
    "erangakm": "@vladar Sorry, I just realised I wrote the bug report saying strings aren't supported, it should be corrected to arrays aren't supported. I've edited the post.\nsending a request from a typescript app:\npublic sendRequest = async (): Promise<object> =>\n    callbackToPromise<httpRequest.RequestResponse>((cb) => {\n      httpRequest.post(this.options, cb);\n    }).then(this.handleResponses)\nThese are the contents of a this.options for a request when variables are set as an object array (working): \n{ headers: {},\n   method: 'POST',\n   url: 'http://xxxxx.ngrok.io/api/v3/graphql',\n   json:\n    { query: '\\n  mutation app {\\n    application_login(token: \"tok_123\") {\\n      query {\\n        viewer {\\n          uid\\n        }\\n      }\\n    }\\n  }\\n',\n      variables: { xxx: 567 } } }\nThese are the contents when the object array is JSON stringified (not working):\n{ headers: {},\n   method: 'POST',\n   url: 'http://xxxxx.ngrok.io/api/v3/graphql',\n   json:\n    { query: '\\n  mutation app {\\n    application_login(token: \"tok_123\") {\\n      query {\\n        viewer {\\n          uid\\n        }\\n      }\\n    }\\n  }\\n',\n      variables: '{\"xxx\":567}' } }\n. ",
    "bitrix1": "Hi! I have this problem.\nCompare:\nWork (addon ChromeiQL generate query)\n{\"query\":\"{\\n  echo(message: \\\"Hello World\\\")\\n}\\n\",\"variables\":null,\"operationName\":null}\nError (addon GraphIQL Feen! generate query)\n{\"query\":\"{\\n  echo(message: \\\"Hello World\\\")\\n}\\n\",\"variables\":\"\"}\n\nFatal error:  Uncaught TypeError: Argument 1 passed to GraphQL\\Validator\\Rules\\QueryComplexity::setRawVariableValues() must be of the type array, string given, called in /home/bitrix/www/files/graphql-php/vendor/webonyx/graphql-php/src/GraphQL.php on line 137 and defined in /home/bitrix/www/files/graphql-php/vendor/webonyx/graphql-php/src/Validator/Rules/QueryComplexity.php:61\nStack trace:\n0 /home/bitrix/www/files/graphql-php/vendor/webonyx/graphql-php/src/GraphQL.php(137): GraphQL\\Validator\\Rules\\QueryComplexity->setRawVariableValues('')\n1 /home/bitrix/www/files/graphql-php/vendor/webonyx/graphql-php/src/GraphQL.php(86): GraphQL\\GraphQL::promiseToExecute(Object(GraphQL\\Executor\\Promise\\Adapter\\SyncPromiseAdapter), Object(GraphQL\\Type\\Schema), '{\\n  echo(messag...', Array, NULL, '', NULL, NULL, NULL)\n2 /home/bitrix/www/files/crypto/test.php(409): GraphQL\\GraphQL::executeQuery(Object(GraphQL\\Type\\Schema), '{\\n  echo(messag...', Array, NULL, '')\n3 {main}\nthrown in /home/bitrix/www/files/graphql-php/vendor/webonyx/graphql-php/src/Validator/Rules/QueryComplexity.php on line 61. ",
    "danydev": "if you want to avoid copy-paste and the PR is not accepted, you can still go with the tougher path using runkit_constant_redefine \ud83d\ude04 . ",
    "ahocquard": "Hello,\nUnfortunately, it does not improve the performance.\nIt seems that it's due to the number fo fields to resolve (100 families with 100 attributes with 3 fields = 30000). GraphQL does some extra-work to handle a lot of unused thing in my case (directive and so on). I'm still pretty new with the technology though.\nDo you have some feedback with other projects about such performance problems?\n. Actually, I'm just doing 4 SQL requests. It costs \"only\" 260 ms when requesting all the data of the family entity. But it takes more than 6 seconds to return everything. Most of the time is spent by GraphQL resolver.\nMy SQL requests use the powerfulness of the newjson_arrayagg operator of Mysql 8.0.\nThe result is that hydration is not costly at all (almost all the job is done by Mysql). I'm satisfied with it, as it's outperform hydration done by Doctrine (for example).\nCombined it with a dataloader, and results are really good.\nFamily REST endpoint, on the other side, can trigger more than 300 SQL requests for such families.\nBut REST it's still 3 times faster. \nOf course, when I request only some fields, GraphQL outperform REST.\nTo be honest, I would bet on an improvement by 3 or 4x with GraphQL, as the SQL requests + hydration is highly optimized. \nThanks for reply.\nLooking forward for improvements!\n. It's a proof of concept, but you can access code is in this bundle: https://github.com/ahocquard/pim-community-dev/blob/poc-the-poc/src/Pim/Bundle/ResearchBundle/PimResearchBundle.php\nIt's not related to any other code of the whole software at this moment, so you can focus on it.\nI'm using dedicated resolverresolveField for each type.\nI will try to provide an example with the same volume of data and with fake repositories.\n. Hello,\nReally sorry for the delay, I was pretty busy.\nI really appreciated the test you did and it deserves some investigations on my side ;)\nI had the same results as yours with https://github.com/vladar/graphql-perf-debug (~400ms).\nI tested with my codebase as well (Symfony, DI, etc), by creating fake objects, and I had the same results.\nThe extra overhead of the SQL requests is about 250 ms.\nSo, I would expect a response in less than 700 ms (GraphQL 400 ms + 250 ms of sql request + 50 ms of extra-stuff). But I got 1 second. It means that GraphQL rendering costs about 700ms and not 400 ms as tested before. \nAnd I found the reason: the test you did was creating the same attributes for all the families.\nAnd GraphQL seems to already have an optimisation in such scenario.\nIf you have completely different attribute codes for each family, the result is pretty bad: ~6s5 on my computer (meaning 10000 different attributes).\nIf you have different attribute codes among 600 attributes (the real condition that I initially tested), it takes ~750ms. So, it's more or less what is expected.\nYou can test it here:\nhttps://github.com/ahocquard/graphql-perf-debug/\nIn conclusion, GraphQL implementation is pretty fast for most of the needs, but it can be pretty slow on large datasets, and it depends of the distributivity of the data.\n. ",
    "varbrad": "My apologies. I realise now after talking through the issue with a friend that when GraphQL is 'parsing' the Schema, it must pick one of the two types to 'parse' first, and at this point the other type does not yet exist. It seems some sort of loop then gets entered where GraphQL is constantly trying to create the necessary schema data and keeps going between the two types until it consumes all of the script memory.\nFor anyone else running into a similar issue, it is simply a case of defining the fields property of the Type configuration as a callable function, which I found here in the documentation.\nphp\nclass UserType extends ObjectType\n{\n  public function __construct()\n  {\n    parent::__construct([\n      'description' => 'A user',\n      // Fields is now a callable, that returns the original object with a resolver shown\n      'fields' => function () {\n        return [\n          'id' => Type::id(),\n          'username' => Type::string(),\n          'lists' => [\n            'type' => Type::listOf(Types::list()),\n            'resolve' => function ($value, $args, $root) {\n              return $root['db']->getUserLists($value['id']);\n            }\n          ]\n        ];\n      }\n    ]);\n  }\n}\nThis all works perfectly now, of course it was my own fault \ud83e\udd23 .\n\ud83d\udc4d \nTL;DR I should have RTFM.. ",
    "nagledb": "Running this:\nphp\n$data = ['a', 'b', 'c', 'd', 'e'];\nunset($data[2]);\n$count = count($data);\nfor($i = 0; $i < $count; $i++) {\n    echo $data[$i] . \"\\n\";\n}\nResults in this:\n```\na\nb\nPHP Notice:  Undefined offset: 2 in test.php on line 30\nd\n```\nNote that not only does it trigger an error notice when it tries to access the second element, but also it doesn't access the last item because there are only 4 items but the last item has index 4. The code in NodeList::getIterator has the same two issues.\nThis PR fixes the first issue, but it doesn't address the second. Using foreach as in option 1 would solve both issues.\nAs for option 2:\n\nDo not use unset in offsetUnset and instead, splice an array (to always have sequential keys).\n\nThat would actually be a breaking change. Let's pretend we have $nodes that contains a NodeList with 5 nodes whose names are \"a\", \"b\", \"c\", \"d\", and \"e\". If we ran this code:\nphp\n$count = count($nodes);\nfor($i = 0; $i < $count; $i++) {\n    if ($i == 1) {\n        unset($nodes[$i]);\n    } else {\n        echo $nodes[$i]->name->value . \"\\n\";\n    }\n}\nThen we'd see this:\n```\na\nd\ne\nPHP Notice:  Undefined offset: 4 in test.php on line 30\n```\nI would find that behavior very unexpected and arguably it even violates the spirit of ArrayAccess since it would be behaving very differently than a normal array would.. The reference implementation merged the referenced PR in April.. I'm very interested in using schema directives.\nIf I'm understanding the graphql-tools code right, it looks like Schema Visitor is applied on the schema prior to execution. So that approach wouldn't work with lazy-loaded types.\nOne possibility I'm thinking about is wrapping resolvers with code that checks for schema directives and applies them during execution. However, it seems like this approach would only work for field definition directives.\nFor other kinds of schema directives, the only way I can think of to get at them with lazy loading would be in the Executor. It looks like that would be pretty complicated and may involve a lot of duplication and modification to get the right changes in the right places, which doesn't sound ideal.\nAm I wrong on anything above? Is there a better approach I'm not seeing?. Actually I just spent some time digging into BuildSchema::build's $typeConfigDecorator and it looks like it might be able to support handling all the schema directive locations (except for on the schema node itself, but I can't think of any use cases for that). Is that what its intended purpose is? I couldn't find any documentation for it.. Sure, I reverted is_callable() back to instanceof Closure and updated the PR.. The current code uses Closure. The leading slash isn't needed because the file uses use Closure;.. Thank you for the thoughtful and patient response, @vladar!\nI actually didn't realize that Apollo was built on top of the reference implementation. That misunderstanding was pretty influential in a lot of my thoughts above. Knowing that definitely gives me much more confidence about using webonyx/graphql-php as a foundation and helps mitigate my concerns about the two goals being in conflict.\nThe other key takeaway for me is that you're willing to deviate from the reference implementation for spec-compliant features that cannot be implemented on top of the library's current API.\nYour point about creating new features in separate projects that build on this, rather than in this project, also makes a lot of sense to me.\nOverall everything you said makes sense and is very encouraging to me as a user of the library.. The FieldNode[] type is correct.\nIn my testing (including the three test cases you referenced), it always contains exactly one FieldNode. It's never null, and it never contains more than one FieldNode. Thus why I'm asking if there are any such cases.\nIf there aren't, maybe it should eventually get changed to $fieldNode as @var FieldNode? (It'd be a breaking change to the public API so I know it can't be changed easily.). Thanks for the example! I didn't even realize it was legal to have duplicate fields (but I do see it in the spec now that I know to look for it).. Thinking about this more, it looks like it would be better to handle this by using Visitor::visit on the query AST.. That makes sense to me. Thanks!. I suggested it because I saw at https://github.com/webonyx/graphql-php/community that we didn't have one and it's recommended. I also noticed that digiaonline/graphql-php had one but webonyx/graphql-php didn't. If someone's choosing between the two projects, it's not inconceivable that it would be a factor they'd consider.\nI haven't seen any signs that anyone here has problematic conduct. But having a code of conduct in place before a problem occurs will surely make handling such a situation easier if it does occur.\nIt also sends a pretty positive signal that the maintainers actually care about how people behave towards one another. That's not always a safe assumption.. GitHub's terms describes GitHub's expectations. The Code of Conduct describes the project maintainer's expectations.\nHaving a code of conduct says \"this project is explicitly inclusive and welcoming\". Deciding to not have one simply because it's a bit redundant would be a signal to me that the project doesn't actually emphasize or prioritize those values.\nI think a Code of Conduct is valuable. Lots of other projects have them and seem to find them valuable. GitHub itself recommends having one, so evidently they see value in a project having one.\nMaybe you don't see value in it and that's fair. But do you actually see harm in it?. The change is making it fail a unit test. You need update the expected output for function testWarnsAboutSlowIsTypeOfForLazySchema in tests/Executor/ExecutorLazySchemaTest.php.. ",
    "simPod": "The similar check is on Executor.php:942. Yup, only for circular types. I use dependency injection for types that I autowire and not using static (global) types which I consider to be a cleaner way. \nBut I might have found a way -> opening PR as I believe it's not working properly in this library.. The ocramius' https://github.com/Ocramius/ProxyManager creates multiple proxy instances with the same instance of underlying type within. Therefore, it doesn't create circular references when using DI. However I think this approach is no go with this library as it would require adding a new dependency.\nInstead I started using callables those when invoked return the actual type instance. This way I can avoid circular references and still use DI. (https://github.com/webonyx/graphql-php/pull/257#issuecomment-373685194)\n. I consider callables and their __invoke as something great when you want something to be lazy / performance sensitive.\nNot sure why I'm first tho. I guess it's because people gave up on circular schemas (just a thought \ud83e\udd14 ) \nI have a registry of types. Created a compiler pass that takes all type services from DI container and puts them into registry from where I can request them. \nThat doesn't solve the problem tho. When there's a type A in a registry that requires type B as a field's type and also there's type B that requires type A as its field's type, there's no other way how to create that. Type registry have no role it this case.\nThe only way to solve it (I might not have found 'em all) is to have eg. type A that has field with type B within a callback so it doesn't reference the type B directly. And vice versa. \nI, for example, set the type B of A type field as:\nphp\nType::listOf(\n        function () : Type {\n            return $this->typeRegistry->getTypeB();\n        }\n)\nSo type B is resolved only when needed and the infinite circular reference cannot happen.. Because TypeRegistry would look like this:\n```php\nclass TypeRegistry\n{\n    private $user;\nprivate $blogPost;\n\npublic function user()\n{\n    return $this->user ?: ($this->user = new User($this));\n}\n\npublic function post()\n{\n    return $this->blogPost ?: ($this->blogPost = new BlogPost($this));\n}\n\n}\n```\nSo then it goes like this\n\nUser is instantiated from TypeRegistry (new User called)\nWithing User __construct $types->post() is called\nIn $types->post() new BlogPost is called\nWithing BlogPost __construct $types->user() is called\nIt all repeats over and over. Oh, missed that one. Thanks, that works. Going to refactor my schema a bit but it seems to be a way and this PR is not necessary then I guess.. And don't we at least wanna lift the drop to 5.6 as well so at least 7.0 is required and we can start strict-typing things?. @vladar I must admit I really liked how Doctrine project did that http://www.doctrine-project.org/2017/07/25/php-7.1-requirement-and-composer.html and especially Why dropping PHP support in a minor version is not a BC break section there. But it's up to you, will add 5.6 tomorrow.. Yup but you took it out of context. They wrote so with intention to help inexperienced developers to cleanup their composer config. They didn't mean that it's a bad approach because it is not. \n\nThe only problem is that people often use dev-master as a dependency constraint, run composer update or do similar dumb things but that is not your responsibility as a dependency maintainer.\nIn my opinion it draws back progress and inovations when library tries to satisfy users with unconstrained dependencies but it's only my sole and humble opinion, no need to care about it ;) We can proceed with the merge, it's step forward anyway.\n. Needs rebase tho. There are no PSR-4 coding standards AFAIK \ud83e\udd14 \nSome defaults are MySource, PEAR, PHPCS, PSR1, PSR2, Squiz and Zend but are pretty useless in their raw form TBH (eg. missing useful sniffs).\nPersonally I fancy this one https://github.com/doctrine/coding-standard It's the most advanced coding standard out there currently.\nIf interested, I can look into it.. Kk, you can assign me to this issue. Expect PR next week.. @fesor Travis CS step will be part of the PR. @vladar I think retriggering the travis might work\nAs you can see https://travis-ci.org/webonyx/graphql-php/jobs/394049666\n\nI suppose it means it was not setup before the check passed so there was no place to upload clover. There's phpcbf binary, that fixes CS errors. IMO auto-commits to PRs from some 3rd party tool might not be always desired. Also, that tool will probably just run phpcbf as well. Personally, I think it does not add any value.\n@vladar what do you mean by that resistance? I can't imagine how while being a contributor coding standard prevents me from contributing. In this case, when checks are automated and the errors are automatically reported by the tool (Travis), it's very easy to fix those errors. Also, for me as a contributor, I can safely use auto format in IDE for files that are already fully compliant with the standard without making unneeded changes in those files. I have the coding standard preset configured in IDE and as many OSS projects use this CS, it's very convenient. Also, other advantage is that some part of \"non-business logic\" review is done automatically so when reviewing PR, focus goes to logic that matters and not to reviewing missing spaces.. @vladar yup, that's why I have converted two (?) folders in src already so phpcbf can be soon run very easily when I submit the rest.\nad prettier: why not but still alpha. It has a potential though.. For PRs, it will only check lines changed so people don't have to fix the whole file for build to pass but only their changes must be compliant.\nOtherwise, it starts full check when not PR.. Waht do you propose they should do? Fixing the whole project and linting the whole project / src+tests separately?. Irony lol. Tried to finish before going to bed, didn't wait for check :( :D. @vladar I think it's good to go now. Ah I see it is excluded in phpunit dist. Why is it so?. What if I make ReactPHP promises dev dependency and therefore simple vendor/bin/phpunit can be used without any group exclusion anywhere?. It will however ~double the CI test runtime, not a big deal I guess. But merging clovers cannot be avoided. \nWe can eliminate the double runtime by specifying eg. @group executor for tests that cover executor and running only those for new executor.. @mfn some changes were automatic, some not :) I was working on in for a few days when I had a spare time.\n@mcg-web sure it my listing correct that ValidationRule and QuerySecurityRule are those BCs? Have I missed something else?. Because tests can have bugs too. Tests describe what the source code should do. So tests (because they work as a specification) should be checked as well to easily discover poorly/wrongly written tests.. @mcg-web it is phpcbf but not recommended for now as all files are not migrated to new CS yet. So if you run it now, it will fix codestyle in all files and produce huge diff.\nIf you want specific files, you can run phpcbf <relative filepath>. Migration to CS is continuously in progress ;) https://github.com/webonyx/graphql-php/issues/284. @mcg-web merged ;). https://github.com/webonyx/graphql-php/pull/333#issuecomment-417638287 that's because it has not been migrated all yet\nTherefore, it's better to address those issues manually for now.\nI'm getting to the point when the whole code base is compliant with the CS.. This is still incorrect https://github.com/webonyx/graphql-php/pull/333/files/87ecc3eb23e318ef8d871a2060c052070b85a0f2#diff-b5af65a9ceb44d8fdf02823c66ccec3b. Ah wrong link\nhttps://github.com/webonyx/graphql-php/pull/333/files#diff-b5af65a9ceb44d8fdf02823c66ccec3bR64\nhttps://github.com/webonyx/graphql-php/pull/333#discussion_r213306378. @vladar I don't have the rights to restart travis job, can you please?. Yup, that was expected. Just needed that output. Thx . Most/all of it will resolve itself after merging https://github.com/webonyx/graphql-php/pull/334. @vladar IMO it's good to go. @vladar pls restart travis jobs ;). nvm, just succeeded. The official docs say there's no wrong or good way.\nBut there's actually a good way -> the standard and common one everyone use when they write their code. When you declare the method static, you call it using :: and not using ->, right? This messy habit of calling static methods using -> while working with PHPUnit has origin unknown to me \ud83e\udd14.\nThe main reason for this change, as I stated above, is that those static methods doesn't contain any instance-specific logic, they're static wrappers. Compare self::assertTrue() and $this->expectException() for instance. You simply cannot call self::expectException() because it works with test instance and have to be called using ->.\nAlso seems to me the whole test suite is now running faster according to travis' times.\nNext steps: When we want to enhance static analysis, PHPStan's Strict Rules analyse that Statically declared methods are called statically. You wouldn't want to exclude this check for your code. There's no reason to exclude it for tests either.. ;)\n\nNever occurred to me to statically analyze the tests ;)\n\nIt kinda forces you to write them more clean and also sometimes discover bugs in them like that they test something slighly different than you intended to.. Just gather all your ids in buffer:\nMyUserBuffer::add($blogStory['authorId']);\nAs return new GraphQL\\Deferred(* is returned, no actual data are returned yet from resolver.\nAll your resolvers would have returned Deferred for now (*) -> no data, just promises\nIn the end, when the Deferred promise is resolved, get() method on buffer is called.\nIn the buffer, you should check if there are any data available and if not, fetch all the data for all the ids in the buffer (eg. for database -> here you do only one query for all ids). Store the data in the buffer (**) and return only that for requested id.\nThen every consecutive get() would again check if data are available (true cuz (**)) and again return only that for requested id.. @mfn use a service for that injected via DI from your container\nThen call $yourBufferService->add() ;). Very easy to run BTW. @vladar seems to me that PHP is able to optimize (went long way since v 5 ;) ). I'm not well-aware of PHP internals but IMO from this condition (is_array($value) || $value instanceof \\ArrayAccess) it might usually evaluate only the first part and skip the other one.. BTW, you can fix a lot of CS violation by simply running vendor/bin/phpcbf. Yeap!. Yup, it is indeed but PHP has no better way yet (though I believe it might be changed in the future).\nI suppose I could add a default throw, that would make sense as all logical branches would be covered then \ud83d\udc4d . Seems like default: throw... statemens are not there for a reason (eg. they're handled later).. Started with a micro benchmark\n```php\n<?php\nclass A\n{\n    public $kind = 'A';\n}\n$s = microtime(true);\nfor ($i = 0; $i < 10000000; $i++) {\n    $a = new A();\nif ($a instanceof A) {\n}\n\n}\nvar_dump(microtime(true) - $s);\n$s = microtime(true);\nfor ($i = 0; $i < 10000000; $i++) {\n    $a = new A();\nif ($a->kind === 'A') {\n}\n\n}\nvar_dump(microtime(true) - $s);\n```\nOn PHP 7.2\n```\ndouble(7.4557127952576)\ndouble(7.6205501556396)\n``. Left xdebug enabled ;) Withphp -n` having similar numbers. @vladar just checked HugeSchemaBench and it seems that it does query operations on huge schema \ud83e\udd14 . What about this\n```php\n<?php\nclass A\n{\n    public $kind = 'A';\n}\nclass B extends A\n{\n}\n$s = microtime(true);\nfor ($i = 0; $i < 10000000; $i++) {\n    $b = new B();\nif ($b instanceof A) {\n}\n\n}\nvar_dump(microtime(true) - $s);\n$s = microtime(true);\nfor ($i = 0; $i < 10000000; $i++) {\n    $b = new B();\nif ($b->kind === 'A') {\n}\n\n}\nvar_dump(microtime(true) - $s);\n```\nfloat(0.54834389686584)\nfloat(0.62606191635132)\n\n```php\n<?php\nclass A\n{\n    public $kind = 'A';\n}\nclass B extends A\n{\n}\n$s = microtime(true);\nfor ($i = 0; $i < 10000000; $i++) {\n    $b = new B();\nif (!$b instanceof A) {\n}\n\n}\nvar_dump(microtime(true) - $s);\n$s = microtime(true);\nfor ($i = 0; $i < 10000000; $i++) {\n    $b = new B();\nif ($b->kind !== 'A') {\n}\n\n}\nvar_dump(microtime(true) - $s);\n```\nfloat(0.62735915184021)\nfloat(0.65307688713074). @vladar WDYT?. How do you execute the query, do you use a client like graphiql? It probably returns not-json formatted exception and client won't show it because you're not converting it to json. ur fields are not callable, you're resolving arrays instantly. Yup, on it. . This is the reason https://github.com/phpstan/phpstan/releases/tag/0.10.5 :). It is very well summed up here https://github.com/doctrine/coding-standard/pull/15\nTL;DR: it's faster ;). No, I have not done any. Can you add more info how to reproduce the issue? Just run tests and there always is StringValueNode. Some examples:\n\n\n\n. IMO if you put breakpoint to line :40/41 it can guide you to the place from where it is thrown and help you to find why is it so.. I guess it depends on you, AFAIK this is not part of GQL specification. \nI see two options:\n\nYou can return 8 ports in \"data\" and two errors in \"errors\" field of response\nJust return auth error for the whole request (easier ofc). @yaquawa 8 ports in data is simple, just return them. \n\nFor those errors, personally I would have \n1) created something like a ExposableExceptionsBuffer service\n2) during query runtime added exceptions into that buffer if access to Post is unauthorized\n3) formatted those exceptions from buffer when constructing response (\"errors\" field specifically)\nMaybe someone will have better way tho.\n\nBut you still want the normal user to see the title and the thumbnail of the premium post, how do you handle this?\n\nThat would be the first way I suppose\n\nYou can return 8 ports in \"data\" and two errors in \"errors\" field of response\n\nThere are 3 options we came up with but it all depends on your domain logic. For example if I had private repository here named FooBar, I wouldn't want you to know. Therefore https://github.com/simpod/foobar returns 404. But in your case you wouldn't return 404 ofc. . That's true, what if you return eg. PremiumPost object instead of standard post? And maybe Union Type would be suitable for that \ud83e\udd14 https://graphql.org/learn/schema/#union-types. None that I know of, I'd go with that buffer service I mentioned earlier. > sure I can, but the response still contain the body of the post even I have a has_permissions flag.\nThis could be IMO solved with Union Type. @vladar Don't why checks didn't trigger \ud83e\udd14 . github had issues https://status.github.com/messages. I'm just curious, what was broken exactly? \ud83e\udd14 . It seems weird to me that accessor ->resolveFn is not consistent with 'resolve' key \ud83e\udd14 \nEdit: I see http://webonyx.github.io/graphql-php/data-fetching/. kk sounds legit \ud83d\udc4d . I have replaced all documented array types with the closest concrete types I have been able to find.\nYou can run ExecutorTest::testProvidesInfoAboutCurrentExecutionState(), StarWarsQueryTest::testAllowsUsToQueryForTheFriendsOfFriendsOfR2D2() or ResolveInfoTest::testFieldSelection() where it contains FieldNode[]\nOf course it's possible some types are still not documented.. What is it good for? I mean in real life (read the links ofc). Personally, I have no experience with code of conducts. But as far as I can tell, if someone doesn't behave even after he has been given a warning, he is always cast out in some way (closing, locking issue, ban, w.e) from a project. With or without that code of conduct file present in the repository.\n\nIt also sends a pretty positive signal that the maintainers actually care about how people behave towards one another. That's not always a safe assumption.\n\nTo me that is implicit and covered by Github terms where needed. TBH I don't see any value in it (eg. issue and PR templates mentioned by that Community section are handy). I just simply think that it is a bit redundant as everything harmful is already covered by ToS. Just my 2c.. Github solves this by requiring you to add a conduct file into your repository. The file is unrelated to the source code and shouldn't be there. Github should create separate view like wiki or something, not force you to actually polute the code base :/ And be honest, nobody will ever read it, like nobody reads ToS anywhere ;). Yes. Occured in my library where I use PHPStan lvl 7.\nhttps://github.com/simPod/GraphQL-Utils/commit/6217e08cd95717b6d1f2639eb6e6c03336b050c1#diff-0847156bd64b0de0f4d91da2394ec0e8R8\n\nI'd like to move PHPStan here to higher levels as well but we must be careful cuz performance :D 1st step is here https://github.com/webonyx/graphql-php/pull/364. AFAIK you must validate it in your resolver, this is not in scope of GraphQL\n! handles non-nullability and not something like \"minimal count of items\". [Int!]! means you cannot pass null nor [null].. Yup, no rush. I'm continuously trying to add typechecks and reduce type variations like here int OR bool etc.. For anyone looking, this works https://github.com/garlicservices/graphql-php-tools\nAfter this gets merged https://github.com/garlicservices/graphql-php-tools/pull/2. I suppose it is \ud83e\udd14 \nhttps://github.com/webonyx/graphql-php/pull/440/files#diff-354f30a63fb0907d4ad57269548329e3R35. I guess that was not the proper way to define it. Now should be fine.. Not sure it that's what you're looking for. You can set custom default resolver using fieldResolver config option, see http://webonyx.github.io/graphql-php/executing-queries/\nAnd also custom resolver per field http://webonyx.github.io/graphql-php/type-system/object-types/#field-resolution. @hemratna see this http://webonyx.github.io/graphql-php/data-fetching/#default-field-resolver\nJust copy paste it into ur class and then you can start tweaking it for your needs.\n```php\nclass MyCustomResolver {\npublic function __invoke($source, $args, $context, \\GraphQL\\Type\\Definition\\ResolveInfo $info)\n{\n    $fieldName = $info->fieldName;\n    $property = null;\nif (is_array($source) || $source instanceof \\ArrayAccess) {\n    if (isset($source[$fieldName])) {\n        $property = $source[$fieldName];\n    }\n} else if (is_object($source)) {\n    if (isset($source->{$fieldName})) {\n        $property = $source->{$fieldName};\n    }\n}\n\nreturn $property instanceof Closure ? $property($source, $args, $context, $info) : $property;\n\n}\n}\nthenphp\n$result = GraphQL::executeQuery(\n    $schema, \n    $queryString, \n    $rootValue = null, \n    $context = null, \n    $variableValues = null, \n    $operationName = null,\n    new MyCustomResolver(), // Rather inject it through DI, though\n    $validationRules = null\n);\n```\nQuickly typed it here on github but should work. You get the idea.. @hemratna my example was without DI :)\nJust pass anything that's invokable for $fieldResolver. It gets invoked by executor so those args are passed there by executor as well.. php\n$result = GraphQL::executeQuery(\n    $schema, \n    $queryString, \n    $rootValue = null, \n    $context = null, \n    $variableValues = null, \n    $operationName = null,\n    ANYTHING INVOKABLE HERE, preferable with following arguments: $source, $args, $context, \\GraphQL\\Type\\Definition\\ResolveInfo $info\n    $validationRules = null\n);. Yes my bad, sorry. Will edit it.. I'd recommend using this https://github.com/simPod/GraphQL-Utils/blob/master/src/Type/DateTimeType.php. But just looking at it I don't see what might be wrong on your end. Cannot find difference between that basic DateTime type inplementation of yours and mine. . Can you show your DatePeriod extending ObjectType? And what is your query, what are your arguments and how resolvers looks like?\nIMO having type DatePeriod with from to fields of scalar DateTime must work or at least does for me.. You should get something similar in your resolver:\n\nBut I suppose you'd rather get object than array, am I right? AFAIK that's not possible and you should do it in your resolver. It seems to be handled here https://github.com/webonyx/graphql-php/blob/master/src/Utils/AST.php#L398. @vladar also this BC is related https://github.com/webonyx/graphql-php/pull/423. This actually is not CS related directly. But as I required declared strict types after <?php this part stopped working as it's not type-safe. I'll look into it again and see if I come up with more performant way.. We can leave them available publicly but create getters compliant with interfaces we define. getKind() is the first getter I defined.\nI planned to continue with defining other properties via interfaces so we can better leverage type-safety.\n\n\nSo I suggest to rework it as\nphp\n    public function getKind() : string\n    {\n        return $this->kind;\n    }\nPerformance shouldn't suffer as long as the property stays public https://steemit.com/php/@crell/php-use-associative-arrays-basically-never. Usually there's a way how to format the code better rather than ignoring the CS rule :) Check the last commit, I tried to separate the blocks. To me, they make better sense like this.. BTW the reason I'm doing all this is to (in the end) add types to this lib and make it better prepared for future php releases so it can leverage all the new features that are going to come (with performance gains as well :). PS: same for me. But it was the time when it was hard to hide whitespace in diffs (no such feature in github) etc. \nBut it seems to make code blocks to look well-aranged to me so I adopted it again :) Tools make it easy to use.. In the link it is said that 11.08s avg is for private properties but I suggested to keep having public properties and adding getters for gaining API advantage via interfaces.\nAlso, I understand that making such changes is better for separate PRs. I'll try to clean it up from this one and open PR when we can reopen this discussing, alright?. Could you be more specific please? Not sure what you mean by that. Thanks. Ah, I didn't touch this TBH. Only reformatted the annotation to be CS compliant.\nThe order of union type hints doesn't matter and sometimes can be relative. We have a CS check for having null as the last type but as long as there's no custom CS check for having NodeList as the first type, I don't really see a point in it.\nI'd suggest you open a issue / PR with union types proper ordering if you want to pursue this (inspiration https://github.com/slevomat/coding-standard/blob/master/SlevomatCodingStandard/Sniffs/TypeHints/NullTypeHintOnLastPositionSniff.php).. I'm pretty sure that there's tonz of typehints that are wrong in this library. I'm planning on fixing it after CS passes on whole project. I want to add proper interfaces and leverage type checks so wrong type hints are discovered automatically.\nBut still, not part of this PR as it's big enough. Fixed some typehints randomly and those that were discovered by Scrutinizer. This will be fixed later, the changed state is not worse than the current one :). AFAIK pipe means either a or b but haven't checked whether both are correct or just one.. why not simply use phpstan as a dev dependency? this looks unnecessarily complicated. This lib does too, hm \ud83e\udd14?. Ah, so this can be safely replace with clean dep dependency after rebase onto master, right? https://github.com/webonyx/graphql-php/pull/329#issuecomment-415332117. Not sure if I understand correctly :D This is how it should look like \nhttps://github.com/doctrine/dbal/blob/master/composer.json#L23\nAnd in travis, simply use script: vendor/bin/phpstan analyse. Ayright, what is @it annotation's meaning? . Yes, it's called early exit. It emphatises the actual logic so it is not unecessarily nested and all distracting conditions is executed before it.\nThe code is then easier to read as the possitive path is on the first level in the function. Typical example https://github.com/doctrine/dbal/pull/2937/commits/6013259628fae7ac1e5cddebce8f83528b9031a6. Agreed, double !! looks somewhat magical. TBH I had no idea what it does before.. Can we use * @see it('uses the stack of an original error') instead?. Cool, I'll use standard @see and we can drop confusing @it annotation ;). Don't see any advantage of not using early return, only that one that the code somehow mirrors that reference implementation, that would make sense.\nFor debugging, well, \u00af_(\u30c4)_/\u00af\nSince I use xdebug, I never dump values. Of course it's about personal preference but code should not be influenced by that preference.\nAlso, adding some more reference\nhttps://www.slideshare.net/guilhermeblanco/php-for-adults-clean-code-and-object-calisthenics 39+\nhttps://www.slideshare.net/guilhermeblanco/object-calisthenics-applied-to-php 9\nhttps://github.com/jupeter/clean-code-php#avoid-nesting-too-deeply-and-return-early-part-1\nhttps://github.com/jupeter/clean-code-php#avoid-nesting-too-deeply-and-return-early-part-2\nIt's your call, we can exclude that sniff ofc.\nWhere can I find the reference code BTW? Thanks!. Yes. Kk, so I guess that's all.\nThanks for the link btw. This comment looks like it can be dropped. as mentioned in https://github.com/webonyx/graphql-php/pull/333/files#r213260516, this should be reverted. as mentioned in https://github.com/webonyx/graphql-php/pull/333/files#r213260516, this should be reverted. I'd also add composer require --dev phpstan/phpstan-phpunit. 1) I'd add blank line below, \n2) typo introduced. why use phar instead of standard binary?\ncomposer require --dev phpstan/phpstan and then vendor/bin/phpstan. They're dev requirements so it doesn't really matter. Also, whether they're hidden in phar file or in vendor folder doesn't make much difference. And this requirement isn't useless at all ;)\nHowever, adding it via composer is more flexible (eg. easier to add phpstan phpunit or strict rules). Followup https://github.com/webonyx/graphql-php/pull/333#pullrequestreview-150080275 First let's resolve that . I like how you resolved those missing dependencies. Them being missing worried me for a long time. No more \ud83d\udc4d. Previous version was correct\n\n. this file should have .dist extension (phpstan.neon.dist)\nsame as for phpunit or phpcs configuration\nphpstan.neon should be added to .gitignore. I'd use alphabetic sorting for easier orientation ;). We should have 7.1 here (the minimum required version). If we leave 7.2, it will force features not available in 7.1.. Tryin' but I always find something new when I go through it again \ud83d\ude05 . I see. It looks like it's unsupported even by IDE, even though it's part of PSR-5\nhttps://youtrack.jetbrains.com/issue/WI-20193\nSo I propose to return your change Node[]|NodeList[] with note stating that it's actually (Node|NodeList)[]. * @param Node[]|NodeList[] $ancestors The type is actually (Node|NodeList)[] but this PSR-5 syntax is so far not supported by most of the tools. It is not part of this project and is rather user specific. \nIt should be eventually ignored globally. I see, I'll revert it. BTW, I'd use ArrayAccess and then only instanceof ArrayAccess here.\nGoing to submit CS PR that enforces it in minutes, hope it gets accepted ;).. GraphQL\\Tests\\Utils. not sure whats better, personally I'd use PHP_EOL constants twice (PHP_EOL.PHP_EOL). here we're missing return type, is it possible to add?. can we add return type? also, is the type of $arg known/not mixed?. is it possible to have return type?. same here. same here. same here. same here. same here. same here. same here. same here. same here. same here. same here. same here. same here. can assertions be called statically where appropriate?\nFor ref see https://github.com/webonyx/graphql-php/pull/354#issuecomment-422900157. Sounds reasonable \ud83d\udc4d . BTW those things would deserve a comment to explain why it is there if there's a reason like this.\nIt helps future refactoring as you know whether and how you are allowed to change it.. absolutely agree, I also prefer possitive form.\nBut in this case IMO there's no better way as return $errors; here is used as early exit. \nThere could also be count($errors) === 0 but not sure what we want to use. empty() has lower cognitive load then count()===0.. All is better then if($errors) though as that is very vague form. \"if $errors what\". PHPStan preference is not to use empty() at all but use count() (cuz empty() is less strict but IMO for arrays it's just fine). That's why I added it as excluded rule (otherwise it would force to change all empty()ies to count()s).\nBut here the check is that you have to use boolean comparison in IF statement, that is eg. if ($value !== null) instead of if ($value). @vladar what about this? Have I addressed everything?. @vladar  sure, thanks for letting me know. Enjoy ur travels ;). I wonder, what if I had an assoc array like for example [0=>0,1=>1]? IMO there's no way to detect whether it's \"associative\" or not. What would have happened if $array[$key] = self::resultToArray($item); was used just and only?. I'd rather not use abbreviations. $index would be \ud83d\udc4c . suggestion\n                    'resolve' => static function ($val, array $args, $context, ResolveInfo $info) : array {. Hi, for this is not project related you should add it to your global gitignore.. : void. if type what? I'd prefer to see more explicit and therefore readable condition. $type !== null ? \ud83e\udd14 . maybe simply self:: would do? I guess static:: works too but self is more common and I don't see a reason for static. we're missing a line feed\nIf you're using Jetbrains IDE, it can be automatically handled by Editor -> General -> Other\n. suggestion\n            throw new \\InvalidArgumentException('\"$config\" must be an array or a callable which returns such an array.');. suggestion\n    public function testWhenNullValueProvidedDirectly() : void. suggestion\n    public function testWhenNullValueVariableProvided() : void. suggestion\n        self::assertEquals(. suggestion\n        self::assertEquals(. IMO the @throws anotation can be dropped. I have never found a way how to sustainably maintain those across the whole project.. I guess we can typehint string $element. And then change variable name to $referencedType. I'd prefix with get. prefix get as well.. suggestion\n        return count(array_filter($this->referencedFields(), static function (string $referencedField) use ($field) {. suggestion\n    private function analyzeQueryPlan(ObjectType $parentType, ?array $fieldNodes) : void. can be dropped. Please fix typehint or handle nullability, otherwise it's not safe to iterate $fieldNodes, not sure what's correct here :). I think this cannot be null.. this can be dropped, no?. the var is private so I guess we can drop this. null is default, can be dropped. If meant as verb, the proper camel case is lookAhead. suggestion\nfinal class QueryPlanTest extends TestCase. you have 2 more spaces here. ",
    "isawk": "I resulted to  Apollo/NodeJS thanks\nOn Mon, Mar 26, 2018 at 6:51 AM, Vladimir Razuvaev <notifications@github.com\n\nwrote:\nI don't see any resolvers attached to fields. There is also no root value\nto get data from. Have you read an entry about data fetching\nhttp://webonyx.github.io/graphql-php/data-fetching/ in docs?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/webonyx/graphql-php/issues/259#issuecomment-376045599,\nor mute the thread\nhttps://github.com/notifications/unsubscribe-auth/AUDbqcgM-HmILPu3ZvtbP83W3DfLcwOTks5tiHPEgaJpZM4SiHxr\n.\n\n\n-- \nKwasi Gyasi-Agyei\nI am part of an EDGED crowd\nMobile +27 (81) 466 4488\nEmail kwasi@edged.agency\nSkype kwasi.gyasiagyei\nWeb  http://edged.agency\n. ",
    "galdiuz": "Ok, great. I will then close this issue.. ",
    "sarukuku": "Setting the content type works for me too. The error message was just a bit odd. I'll create a pull request later today to update the command.. There's now a pull request that updated the example curl commands.. ",
    "mgdigital": "In the current version 0.11.5 this creation of a null type allows us to break a GraphQL server using introspection queries, for example:\n{\n    __type(name: \"NonExistentType\") {\n        kind\n    }\n}\nFollowed by:\n{\n    __schema {\n        types {\n            kind\n            name\n        }\n    }\n}\nResults in Internal server error: Cannot return null for non-nullable field __Schema.types.\n. ",
    "alanpoulain": "No it's the issue, since it's throwing an exception, GraphiQL doesn't work.\nThe other solution would be to implement this type in graphql-php directly, even if it's not in the spec yet.\nI think there's really a need for this, there's even a pending RFC here: https://github.com/facebook/graphql/pull/395 (see also https://github.com/graphql/graphql-js/issues/207).. ",
    "mdio": "Since the PR on graphql-js has been merged, will the behaviour be ported to this library?. Thank you for the quick reply.\nIs there any ETA on 0.13?. Hehe, okay. Thanks!. ",
    "limweb": "Myexample:\n\n$useryqry = (new UserQuery())->getFields();  // type of Objectype\n$queryqry = (new QueryType())->getFields();  // type of Objectype\n$query = new ObjectType(['name'=>'Query','fields'=> $useryqry    + $queryqry]);\n$schema = new Schema([\n    'query' => $query\n]);\n\n$result = GraphQL::execute(\n    $schema,\n    $data['query'],\n    null,\n    $appContext,\n    (array) $data['variables']\n);\n\n. How  have a  good solution   thanks.. please give Registry::userType(),  a  sample  thanks.\nis sample is  Types::userType()  is  same ?   thanks\n. thanks. ",
    "terion-name": "For now I've handled it like this, but it more seems like a hack and I'm not sure, that it will work corretly in all cases:\nphp\nprotected function convertGraphQL($input)\n    {\n        if (is_array($input)) {\n            foreach ($input as $k => $v) {\n                $input[$k] = $this->convertGraphQL($v);\n            }\n            if (isset($input['kind'])) {\n                $class = \"\\GraphQL\\Language\\AST\\\\\" . $input['kind'] . \"Node\";\n                if (isset($input['loc'])) {\n                    $input['loc'] = Location::create($input['loc']['start'], $input['loc']['end']);\n                }\n                return @ new $class($input);\n            } else {\n                return new NodeList($input);\n            }\n        }\n        return $input;\n    }. @vladar thank you, more solid than my manual attempt). ",
    "ilusha2012": "The proglem is here vendor/webonyx/graphql-php/src/Executor/Executor.php:301. ",
    "mfn": "@vladar are you open for using a non-open source tool?\nhttps://styleci.io/ comes to my mind which has a very nice feature: you can configure it to automatically push a \"corrected\" source version on PRs (disclaimer: not 100% this works on PRs created from remote repos, but it can be set to work on master branch too).\nThis means: once a style has been configured/agreed upon, every PR or master will automatically receive commits from the service with the violations being resolved. No more manual checking or discussion what is correct.\nAlso: it's free for open source:\n\nWe love Open Source and as such, public PHP projects will always be free with StyleCI.\n\nI apologize in advance if this is inappropriate to suggest. I'm a commercial customer of the service for some time now. It's simply a blessing.\n(PS: it's not about StyleCI specifically, I just know this service. The point: auto-commit source correction saves everyone time).. Thanks for the answer, explains everything I wanted to know! \ud83d\udc4d . What is the authority on the expected behaviour here, regarding HTTP status code?\nI'm a GraphQL newcomer but immediately noticed this \u2026 incoherence? \u2026 regarding payloads/status codes. But the \"specs\" ( http://facebook.github.io/graphql/June2018/ ) don't mention anything regarding this (or I missed it).. PS: same applies to QueryDepth too.\nI'm not sure what qualifies a good design but I think a property on the plugin which can then be retrieved would suffice. . Can you please also add a test/example?. Soo many changes \ud83d\ude31 Was this all automatic or did you use a tool?. It's a \"chicken and egg\" problem, isn't it?\nYou can't prematurely resolve the fields on the same level so you can the \\Closure instance \"instead\", simply said?. What's the benefit?\nEven the official docs in their introduction to suggest the existing code: https://phpunit.readthedocs.io/en/7.3/writing-tests-for-phpunit.html\nAlso all test code I've ever seen uses $this-> for the assertions, so I'm wondering.\nThanks. > Also seems to me the whole test suite is now running faster according to travis' times.\n\ud83e\udd14\n\nNext steps: When we want to enhance static analysis, PHPStan's Strict Rules analyse that Statically declared methods are called statically. You wouldn't want to exclude this check for your code. There's no reason to exclude it for tests either.\n\nNever occurred to me to statically analyze the tests ;)\nBut hey, awesome, thanks for the details => much appreciated!. Sorry to jump in, but I've a question regarding this:\n\nMyUserBuffer::add($blogStory['authorId']);\n\nThis is kinda the textbook example :-) But no one really would use static method aka global function for that, would we?\nSo usually you would use something which only exists for the live-cycle of the current GraphQL request, which is destroyed afterwards i.e. temporary buffer (like, for example, the $context passed? just wondering).\nAre there any best practices how this is done in real code without polluting some global structure? I understand it's easiest this way because due to it's global nature you don't have to solve the problem of \"passing the context with the collected ids around until it's resolved\" (there, \"context\", I said it again).\nThanks!. > use a service for that injected via DI from your container\n\u2026\n\nsome external service injected to your type definition one way or another\n\nWhen I use this approach, I still need to use a global singleton, otherwise how would I be able to access the same instance from different places. In that regard I could as well use the StaticBufferClass:: approach.\nIs it a good practice to e.g. bind this to the $context being passed around? I would like to use something which is more tied to the GraphQL resolving life cycle than the whole request (think about long living PHP processes via react/swoole).\nThanks!. The switch (true) truly reads weird.\nOn a related note: shouldn't all those switch statements have a \"default: throw\u2026\" case? I noticed some have, some don't (I know, existing code).. Ops \ud83e\udd37\u200d\u2640\ufe0f Who would knew\u2026. wow, why do our numbers differ so much?\nphp -v\nPHP 7.2.10-0ubuntu0.18.04.1 (cli) (built: Sep 13 2018 13:45:02) ( NTS )\nCopyright (c) 1997-2018 The PHP Group\nZend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies\n$ php bench.php\nfloat(0.53607106208801)\nfloat(0.6186990737915)\n$ php bench.php\nfloat(0.49281096458435)\nfloat(0.59114003181458)\n$ php bench.php\nfloat(0.4991409778595)\nfloat(0.6029200553894)\nBut yeah, instanceof seems to be fater.\nDid you maybe forget a 0? In that case I get:\n$ php bench.php\nfloat(5.1001918315887)\nfloat(6.1185019016266). Or:\n\nYou only return 8 posts\n\n\ndoes not have the read permission of some of the retrieved posts.\n\nCounter-question: why are those then retrieved?\nJust throwing in some perspective, suggested points 1) and 2) are perfectly valid and it really depends on your use-case.\nIn my casts, as I'm working with a system which also has the concept of posts, the ones the user has no permission are never returned (and if you try to get a specific post you don't have permission it's treated as missing).. > But you still want the normal user to see the title and the thumbnail of the premium post, how do you handle this?\nHow about an additional field/flag on the post, giving indication about this? Like posts.has_permissions or something.\nDon't you need some information in the frontend to mark the as \"premium\"?\nI doubt a series of GraphQL errors is the right solution here; just IMHO.. > sure I can, but the response still contain the body of the post even I have a has_permissions flag.\nI understand, but for this example, this is an error in your resolver logic, isn't it?\nThe body could be null for that. Fun fact: if you make the body non-null but return null due to permissions, you automagicallly have this information in the graphql errors.. But: I understand you have a desire to solve this differently => not arguing against it and I'm following this discussion with interest!. I was facing the same problem but used \\GraphQL\\Type\\Definition\\ResolveInfo::getFieldSelection to eager inspect which fields are going to be required (in fact I need a derivative version because I needn't just fields, also it's arguments).\nI learned this works best on top of a specialized GraphQL query type which then, from the root, performs this inspection.\nIn my case I have a very complex SQL statement (nested with multiple sub-select, group by, window functions, lateral, etc.) on a table which has >90 columns (sorry, that sometimes is just the reality).\nYou would never load all fields in a batch, simply not practical for performance. Same as I don't expose all these fields anyway via GraphQL.\nHowever I learned you will more easily run into \"field dependencies\": sometimes you code requires a field present if when not explicitly selected the user.\nAll in all it's horrible to solve this well, but it works and I just slapped enough unit tests onto it to make sure it doesn't break unnoticed \ud83e\udd37\u200d\u2640\ufe0f\nI just wanted to give perspective of what we all strive to have and what we have to work with, in practice \ud83d\ude04 \nThe fact that it's solvable via the GraphQL library is also a testament how practically good the library is ;-)\n. The last (4th) argument passed to any resolver function is the \\GraphQL\\Type\\Definition\\ResolveInfo\nOn it, you can call \\GraphQL\\Type\\Definition\\ResolveInfo::getFieldSelection (with optional depth) and get back a plain array data structure with the field information and based on this, you can adapt your underlying storage layer.. Exactly my experience; the GraphQL type system has no preparation for this; use a custom resolver or your framework adapter might provide something (e.g. in some Laravel adapters you can configure laravel valiations \"on-top\").. There's no such code in the latest release (\u2026anymore), which version of webonxy/graphql-php are you using?. It is, see https://github.com/webonyx/graphql-php/releases => 0.13 is the latest.\nIf you're by chance using a Library on top of webonxy, you've to contact the library developers to upgrade.\nhttps://github.com/Folkloreatelier/laravel-graphql comes to my mind. It's orphaned but has many users and is stuck on 0.10.2 (coincidence?). Tests are absolutely required IMHO for this. Otherwise it will silently break in the future.. @shmax still if you ever follow up with the reference implementation and have or create an issue there, would be nevertheless be interesting to follow up! thanks. @hemratna does this answer help? https://github.com/webonyx/graphql-php/issues/316#issuecomment-408760772. But this changes the behaviour? What is the rational for this?\nWhat if I may want/desire the current behaviour and not differentiating internal exceptions?. Is there a real/technical benefit to this?\n\nI always prefer to read the \"positive\" form: \"if something is\u2026\"\n  than\nthe negated form \"if something is not \u2026\". What's up with the self:: vs. static:: calls here?\n\nMaybe it's through out the codebase and I just didn't notice it before \ud83e\udd14. ",
    "robbieaverill": "It's worth noting that the abandoned PSR-5 PHPDoc standard does support collections: https://github.com/php-fig/fig-standards/blob/master/proposed/phpdoc.md#collections\nAccording to the PHP-FIG mailing list, PSR-5 was split and looks like there are members trying to reboot it. Related post.. I had it when I made the pull request but probably couldn\u2019t quickly reassemble it :-) regardless, it\u2019s a possible execution path so seems (to me) like a safe change. Will do, thank you. ",
    "jfromell": "Running in to the same issue. Stack traces show only one instance ever being created of my interfaced type, yet queries against it says i have multiples of the same types declared. Changing the interface into a UnionType works, however.\nEDIT: This was solved by using the types parameter in the Schema config.. ",
    "arkonchik": "Thanks for the answer.\nI have a service that save graphql queries(persisted queries) \nBefore it saves the query it could try to validate them by introspection.\nIn this case i can try to validate this queries before save in gitlabci stage with javascript. ",
    "rovansteen": "@vladar how would something like that be implemented? It seems like we need to override the Executor but I don't see any way to do that.. @vladar I was trying to implement a custom directive, called @ability similar to @skip but rather than passing in a boolean you pass in a string which is internally used to check if the currently authenticated user has the ability (is allowed) to read that field. So the directive needs to drop the field from the request if the user is not allowed to read it.\nI wanted to do that by extending the functionality of the shouldIncludeNode method on the Executor class but I did not find any way to override that class or method.. I see my opening post was a little bit confusing. We are not serialising schema config (or anything from this library for that matter, except for the types). I agree with you that there's not much benefit there.\nI'm working on a library that generates a GraphQL schema based on models. So you just give it some models and say which fields/relations it has and it generated the types, mutations and queries for that model. That saves us from writing a ton of code but has the downside of giving quite some overhead on every request, which is unnecessary because the result is the same every time.\nOur library is like a wrapper for this library and so we are in the process of getting rid of all the closures in our library so that we can serialise it. The issue I'm running in to is that we can not serialise the internal types because we aren't able to re-use them because that gives the mismatch I was talking about. So that's why I'm hoping there is any way where these internal types can be passed in so that they matched the serialised ones.\nThis PR includes a big rewrite of the library to make it serialisable, if you are interested to see how we attempt to do that: https://github.com/scrnhq/laravel-bakery/pull/75\nIt's pretty big, but the most important part regarding the serialisation is in this file: https://github.com/scrnhq/laravel-bakery/blob/feature/model-schema/src/Support/Schema.php\nWhich is our schema that we aim to serialise.\nHope that clarifies the issue a bit. :). ",
    "diasfs": "An easy way to implement custom directive \nhttps://packagist.org/packages/diasfs/graphql-php-resolvers. ",
    "lexandre75": "Sorry i post to the wrong project. it's an Api platform issue.. ",
    "zorji": "Here is an example of a @cache(ttl: Int!) directive.\n```\nDirective definition in GraphQL language\nI am using GraphQL language in this example\nIf you are using PHP definition, please refer to \\GraphQL\\Type\\Definition\\Directive::getInternalDirectives\ndirective @cache(\n    ttl: Int!\n) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT\n```\n```php\n// Define some helper functions to get the directive in the current node\nclass Util\n{\n    /\n     * @param ResolveInfo $info\n     * @param string $name\n     * @return DirectiveNode|null\n     */\n    public static function getDirectiveByName(ResolveInfo $info, string $name)\n    {\n        $fieldNode = $info->fieldNodes[0];\n        / @var NodeList $directives /\n        $directives = $fieldNode->directives;\n        if ($directives) {\n            / @var DirectiveNode[] $directives /\n            foreach ($directives as $directive) {\n                if ($directive->name->value === $name) {\n                    return $directive;\n                }\n            }\n        }\n        return null;\n    }\n/**\n * @param DirectiveNode $directive\n * @return ValueNode[]\n */\npublic static function getDirectiveArguments(DirectiveNode $directive)\n{\n    $args = [];\n    foreach ($directive->arguments as $arg) {\n        $args[$arg->name->value] = $arg->value;\n    }\n    return $args;\n}\n\n}\n```\n```php\nUsage\nclass MyType\n{\n    public static function myNode($parent, array $args, ContextImmutable $context, ResolveInfo $info)\n    {\n        $fieldName = $info->fieldName;\n    $cacheDirective = Util::getDirectiveByName($info, 'cache');\n    if ($cacheDirective) {\n        $cacheDirectiveArgs = Util::getDirectiveArguments($cacheDirective);\n        /** @var \\GraphQL\\Language\\AST\\IntValueNode $ttlArg */\n        // Please node IntValueNode is not the only type, there are StringValueNode, etc\n        $ttlArg = $cacheDirectiveArgs['ttl'];\n        $ttl = (int)$ttlArg->value;\n    }\n}\n\n}\n```\nI got help from the answer provided by @vladar in https://github.com/webonyx/graphql-php/issues/299#issuecomment-417062970\n```\nGraphQL usage\nquery {\n  myType {\n    myNode @cache(ttl: 60) # cache for 60 seconds\n  }\n}\n``. > Sure, I revertedis_callable()back toinstanceof Closure` and updated the PR.\n@nagledb I think it should be \\Closure instead of Closure.. > The current code uses Closure. The leading slash isn't needed because the file uses use Closure;.\nOh, I thought the default resolver was provided as an template for users to start their custom resolver. Sorry about that.. My project has to stick with 0.12.6 because the environment has to stay in PHP 7.0 due to legacy dependencies.\nI have migrate some queries to GraphQL and recently found that one query in RESTful takes 600ms but GraphQL takes 1400ms.\n\n0.12.6 in PHP 7.0: ~1400ms\n0.12.6 in PHP 7.2: ~900ms\ndev-master in PHP 7.2: ~650ms (It is weird that the first few (less than 5) requests took around 1100ms, which is slower than 0.12.6, but after I rerun it, it dropped to ~650ms, I restart all my cache and even disabled my cache, it stayed in ~650ms)\ndev-master+useExperimentalExecutor in PHP 7.2: ~700ms\n\nI am not quite sure what caused the changes above but I am going to fork a copy make it compatible with PHP 7.0 and try again.\nUpdate\nI've done the PHP 7.0 port in https://github.com/zorji/graphql-php/tree/php-70\n\ndev-master in PHP 7.0: ~1400ms\ndev-master+useExperimentalExecutor in PHP 7.0: ~1400ms\n\nNo noticeable difference.. ",
    "jsiebern": "I can confirm this problem. Reproduction is fairly easy, just use any schema / resolver configuration (at least for me) and throw an error like so:\nphp\nthrow new \\GraphQL\\Error\\UserError('Any error');\nThis will return an http response with the code 400 instead of 200 which makes Apollo (as an example) not pick it up properly!. The issue seems to be here:\nhttps://github.com/webonyx/graphql-php/blob/392b567f235a528539f47e8c501f2daed029adeb/src/Server/Helper.php#L480\nWhere it probably should be empty instead of ! empty ?. I'd say in the context of the HTTP protocol, it makes sense to send status 4 / 500. But in a GraphQL context it makes sense to send 200 as the call itself has passed and the GraphQL implementation expects the client to handle those errors. There's no need to indicate it with another status (which apollo makes quite clear by failing on a not 200 code and not even displaying the actual errors).\nTo sum it up: I think 200 makes more sense as it reflects GraphQLs intention of leaving the client to deal with a GraphQL error (as the request itself has been handled perfectly well and therefore deserves a 200).\nSorry for my confusing writing, I hope my reasoning makes some sense.\nEdit:\nThere's still the possibility to pass 500 if that error is not intended by the developer. Maybe use 200 on the ClientAware implementations (where it is aware that the client will handle the error \ud83d\ude09 )?. ",
    "topikito": "Just want to add that this has nothing to do with an issue with the library itself, but is more a question regarding ways I can improve my use case. May this be by caching the Schema, etc\u2026. Thanks for the fast response.\nYes, thanks, Ive seen about Schema Language, really appropriate!\nIve edited the title now. My concern is more about being able to cache the resulting map when generating the queries and mutations and injecting them into the schema, kind of the same way Symfony would cache the routing to speed up initialisation of the app. I tried doing a var_export of the Schema after being initialised, but its way too big (memory issue).. Thanks @vladar - Ill take your comment in consideration.\nI guess this closes my question/issue.. ",
    "Smolevich": "@vladar, when do you plan to release version  0.13.x? Our team also use webonyx in preproduction and we interested in optimisation stage of executing.. @jakubkulhan, can you show code of benchmarks upper?. Do you have any benchmarks for this usecase?. ",
    "yaquawa": "@jakubkulhan\nWow! Very interesting!!\nWe got the same issue with the poor performance when executing against large schema.. and it's really a big pain for us.\n\nWe successfully refactored GraphQL schema so that types & fields are created lazily. Also we started caching parsed AST. This got us nice speed improvements.\ncompiled instructions could be cached instead of an AST\n\nWould you give me more details for how you optimized the execution performance ?\nPerhaps, create a new topic of this on the docs?. @vladar Thank you for checking this! Got it!. @vladar \nI think the spec already said the input object field can have a default value!\nhttps://facebook.github.io/graphql/June2018/#InputFieldsDefinition. @vladar You're right\u2026! will this be clarified in the spec in the future?. @simPod Thanks! But how can I \n\nYou can return 8 ports in \"data\" and two errors in \"errors\" field of response\n\nas you said? This is what I want to achieve. push some original messages to the error list.. @mfn For example, you have a system that has many posts, most of the posts are free, but some of the posts are premium user only. But you still want the normal user to see the title and the thumbnail of the premium post, how do you handle this?. @simPod Thanks!\nFor this\n\nformatted those exceptions from buffer when constructing response (\"errors\" field specifically)\n\nis there a way to collect the errors in the resolver and output the error automatically by just using the webonyx/graphql-php's function?. @simPod What I want to do is just as you said:\n\nYou can return 8 ports in \"data\" and two errors in \"errors\" field of response\n\nI want to know if there is a way to gather the error info in webonyx/graphql-php while resolving.\nCan you tell me how?\nThanks!. @mfn \n\nHow about an additional field/flag on the post, giving indication about this? Like posts.has_permissions or something.\n\nsure I can, but the response still contain the body of the post even I have a has_permissions flag.. > None that I know of, I'd go with that buffer service I mentioned earlier\nI thought webonyx/graphql-php has it's way to just do what you described.  How sad...\nUnion Type, of course. \nBut we have ton of models, not only the example Post. \nTransforming every model to a Union Type do not make sense\u2026. @vladar Thanks for your reply!!\n\nIt will still return nulls in the final result but will also add two entries in errors section of the result.\n\nI didn't expect that will happen, good to know!\nI guess this is the most ideal way to handle it in webonyx/graphql-php.. @mfn That's what I want! Thanks!!. ",
    "zzdjk6": "Encounter the same problems, thanks for this fix.\nI think this situation happens when the AST node has a lot of RECURSIVE information.\nThe data structure that causes json_encode failure is attached (in print_r format).\njson_encode_failed.txt. ",
    "shmax": "\nConsider the following query:\n\nAs a matter of fact, that's exactly what I typed in the first draft of my issue; I decided to simplify for the initial conversation. I guess I needn't have bothered. \ud83d\ude04 \n\nThe truth is that if you need normalized data in the first place, GraphQL may be not the right tool.\n\nThe irony here is that I have it already in my own custom-built solution. Like everybody else, I just sort of got swept up in all the GraphQL madness. It seems so strange that such a powerful technology would completely gloss over something like this!\nI've managed to get a crude version of this functionality working (with a few small tweaks) in a fork of this library. I think what I'll do is forge ahead and circle back to revisit this once I've seen what Apollo Client can do with it. \nThanks very much for the reply. Closing for now.. Well sure, no one says you have to use normalization on the front end, but from where I sit it's a good practice for the back end regardless of which client you use. You not only wind up with a smaller data payload, but it encourages habits that can save processing time on the back end (because you don't process the same field for a particular record more than once) and you wind up with a smaller JSON value to parse in the front end. This all assumes that the overall savings is not lost due to the extra work required to piece things back together again in the front end. We shall see! Thanks much for the comment.. > But instance creation is not expensive. It's fields, arguments, and interfaces which add significant overhead. \nWell, I make heavy use of inline schema definitions. All of my mutations, for example, are dynamically generated with custom types (with custom validation types, error codes, and so on), and many of my queries are also dynamically created. It's just a lot of busy work that I would rather not have happen if it doesn't need to. But as you say, I should do some profiling before pressing the matter. I'll see what I can come up with tomorrow.. I have some initial data.\nFirst, I profiled my existing code with the following simple query (Faction type has no dependencies on other custom types):\n{\n    faction (id: 1) {\n        id\n  }\n}\nBlackfire provides the following profile for this request:\n\nPHP spends about 124 milliseconds in Types::get. (563 milliseconds for the entire query; I have xdebug enabled for all these queries, so things are pretty slow in general overall, but we're doing apples to apples, here, so I didn't bother turning it off).\nNext, I doctored my Types::get method to always return the type for faction (I verified that the query still functions as expected after doing this), and get the following profile:\n\nThe time spent in Types::get drops away to 11 milliseconds (390 milliseconds for the entire query).\nI'll post my Types::get implementation here:\n```php\n    public static function get($name)\n    {\n        $cacheName = strtolower($name);\n//      $name = \"faction\"; // I uncomment this to simulate a perfect lazy loading scenario\n    if (!isset(self::$types[strtolower($cacheName)])) {\n        switch($name) {\n            default:\n                $method = lcfirst($name);\n                if(method_exists(get_called_class(), $method)) {\n                    $type = self::{$method}();\n                }\n                else\n                {\n                    $typeName = \"\\\\shmax\\\\api\\\\types\\\\{$name}Type\";\n                    $type = new $typeName();\n                }\n\n        }\n\n        self::$types[$cacheName] = $type;\n\n    }\n    return self::$types[$cacheName];\n}\n\n```\nIt's not practical for me to post my entire schema, as it's enormous, but if it would help I could prepare a sample repo that has a schema roughly equivalent in complexity. Or, I could just dive in and start trying to fix the issue, with your guidance.\nPlease advise, and thanks again!. > Tests are absolutely required IMHO for this.\nSure, no objection. The reference library doesn't have tests around this particular use case, and I was just following their lead. I'll come up with something.. I added a test, which was a good idea because it's making me rethink things. This PR does bring our functionality inline with the reference library, but I'm thinking that the bug is actually in the reference library, and that this codebase is correct. \nLet's have another look at the reference library code:\n``js\nfunction completeListValue(\n  exeContext: ExecutionContext,\n  returnType: GraphQLList<GraphQLOutputType>,\n  fieldNodes: $ReadOnlyArray<FieldNode>,\n  info: GraphQLResolveInfo,\n  path: ResponsePath,\n  result: mixed,\n): MaybePromise<$ReadOnlyArray<mixed>> {\n  invariant(\n    isCollection(result),Expected Iterable, but did not find one for field ${\n      info.parentType.name\n    }.${info.fieldName}.`,\n  );\n// This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n  const itemType = returnType.ofType;\n  let containsPromise = false;\n  const completedResults = [];\n  forEach((result: any), (item, index) => {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    const fieldPath = addPath(path, index);\n    const completedItem = completeValueCatchingError(\n      exeContext,\n      itemType,\n      fieldNodes,\n      info,\n      fieldPath,\n      item,\n    );\nif (!containsPromise && isPromise(completedItem)) {\n  containsPromise = true;\n}\ncompletedResults.push(completedItem);\n\n});\n```\nYou can see that while the keys are preserved for the purposes of computing path, they are not preserved for the result that is returned (he uses push). This means that if you were to write a resolver that prepares an array of mostly null rows and happened to call array_filter (which preserves keys) before returning the result, then the path would have an index in it that refers to something that is not in the result set.\nWhile that would be convenient for the code in my own project, it's probably not really correct.\nWhat do you think? Is this an oversight on the reference library?\n. > You will actually get a list of [undefined, undefined, 'foo'] which is not the case with PHP arrays. So indexes in the reference implementation are actually implicitly preserved, so no error there.\nSure, but it seems that forEach doesn't consider the non-existent array entries when iterating. I did attempt to verify this behavior for myself before raising this issue. Here's a fiddle:\nhttp://jsfiddle.net/epaz1m50/4/\nTo be fair, I have not gone as far to prepare a javascript graphql environment to verify that it is possible for the indices to get out of sync. That's a little more effort than I want to put into it at this point, but I might see if someone at work can try it out for me.\nI'll let you know. Thanks for the reply!\n. Oh, I've come around to thinking that this library is correct, and that the reference library is potentially wrong. I was waiting for the clarification that this library adheres more closely to the spec than the behavior of the reference library, which you've provided, so thank you. Closing.... Ah, this looks promising! I have to head to work, but when I get back I'll pull your branch and run my profiler. Very excited to see the results.... SGTM. ",
    "ilyazub": "Yes, you are right. But, when I throw new UserError('test', 'TEST_ERROR_CODE') and use specified above errorFormatter, $error->getCode() returns 0 instead of TEST_ERROR_CODE. Because of \\GraphQL\\Error\\Error constructor.\nAdded:\nOh, you've edited comment. Let me try.. It works, thanks. The only edit to your code:\ndiff\nfunction (\\GraphQL\\Error\\Error $error) {\n    $prev = $error->getPrevious();\n    return array_merge(\n-        $prev ? ['extensions' => ['code' => $error->getCode()]] : [],\n+        $prev ? ['extensions' => ['code' => $prev->getCode()]] : [],        \n        \\GraphQL\\Error\\FormattedError::createFromException($error)\n    );\n}. ",
    "bmfs": "Got it.\nFor future reference, just read the spec: http://facebook.github.io/graphql/draft/#sec-Descriptions. ",
    "Denys-Bushulyak": "Research showing that: short field didn't execute before passing as part of $root at long field Closure.\n$root['short'] instance of \\Closure and can't be concatenated to the string \"and Long text\". It's not obvious. Maybe I wrong but expected than each field resolver has to be executed before passing to next $root.. Agree.. ",
    "robsontenorio": "@vladar \nAbout \"2\", i agree with you: errors should be for developers, not for endusers.\nBut in this case, as well described by @spawnia, the issue is about how to better structure error messages, in order developers can friendly handle it. Because right now is hard to catch errors by \"field keys\". We just have a \"big error message\" (with multiple issues mixed) that should be parsed (maybe with some regex) in order to get a definition about each field error individually.\nAnd I'd venture to say, it's safe to handle this in the backend instead of relying on frontend validations.\n. ",
    "JetJsF": "It will be really helpful to throw any other exception instead of base \\Exception at parseLiteral()\nCan it be done?. ",
    "gillesmaes": "Sure thing :)\nOriginal:\n```\nPhpBench 0.14.0 (@git_version@). Running benchmarks.\nUsing configuration file: /Users/gilles/Server/graphql-php/phpbench.json\n\\GraphQL\\Benchmarks\\HugeSchemaBench\nbenchSchema                   I0 P0     [\u03bc Mo]/r: 114.146 114.146 (ms)  [\u03bcSD \u03bcRSD]/r: 0.000ms 0.00%\nbenchSchemaLazy               I0 P0     [\u03bc Mo]/r: 0.005 0.005 (ms)  [\u03bcSD \u03bcRSD]/r: 0.000ms 0.00%\nbenchSmallQuery               I0 P0     [\u03bc Mo]/r: 45.334 45.334 (ms)    [\u03bcSD \u03bcRSD]/r: 0.000ms 0.00%\nbenchSmallQueryLazy           I0 P0     [\u03bc Mo]/r: 42.947 42.947 (ms)    [\u03bcSD \u03bcRSD]/r: 0.000ms 0.00%\n\n\\GraphQL\\Benchmarks\\StarWarsBench\nbenchSchema                   I1 P0     [\u03bc Mo]/r: 0.165 0.165 (ms)  [\u03bcSD \u03bcRSD]/r: 0.003ms 2.07%\nbenchHeroQuery                I1 P0     [\u03bc Mo]/r: 0.807 0.807 (ms)  [\u03bcSD \u03bcRSD]/r: 0.005ms 0.65%\nbenchNestedQuery              I1 P0     [\u03bc Mo]/r: 1.739 1.739 (ms)  [\u03bcSD \u03bcRSD]/r: 0.015ms 0.85%\nbenchQueryWithFragment        I1 P0     [\u03bc Mo]/r: 1.971 1.971 (ms)  [\u03bcSD \u03bcRSD]/r: 0.038ms 1.93%\nbenchStarWarsIntrospectionQueryI1 P0    [\u03bc Mo]/r: 15.518 15.518 (ms)    [\u03bcSD \u03bcRSD]/r: 0.267ms 1.72%\n\n\\GraphQL\\Benchmarks\\LexerBench\nbenchIntrospectionQuery       I4 P0     [\u03bc Mo]/r: 1.048 1.043 (ms)  [\u03bcSD \u03bcRSD]/r: 0.013ms 1.23%\n\n10 subjects, 19 iterations, 170 revs, 0 rejects, 0 failures, 0 warnings\n(best [mean mode] worst) = 0.005 [22.368 22.367] 0.005 (ms)\n\u2140T: 248.072ms \u03bcSD/r 0.034ms \u03bcRSD/r: 0.843%\n```\nResults with ArrayAccess check:\n```\nPhpBench 0.14.0 (@git_version@). Running benchmarks.\nUsing configuration file: /Users/gilles/Server/graphql-php/phpbench.json\n\\GraphQL\\Benchmarks\\HugeSchemaBench\nbenchSchema                   I0 P0     [\u03bc Mo]/r: 119.750 119.750 (ms)  [\u03bcSD \u03bcRSD]/r: 0.000ms 0.00%\nbenchSchemaLazy               I0 P0     [\u03bc Mo]/r: 0.007 0.007 (ms)  [\u03bcSD \u03bcRSD]/r: 0.000ms 0.00%\nbenchSmallQuery               I0 P0     [\u03bc Mo]/r: 45.300 45.300 (ms)    [\u03bcSD \u03bcRSD]/r: 0.000ms 0.00%\nbenchSmallQueryLazy           I0 P0     [\u03bc Mo]/r: 42.770 42.770 (ms)    [\u03bcSD \u03bcRSD]/r: 0.000ms 0.00%\n\n\\GraphQL\\Benchmarks\\StarWarsBench\nbenchSchema                   R2 I1 P0  [\u03bc Mo]/r: 0.133 0.133 (ms)  [\u03bcSD \u03bcRSD]/r: 0.001ms 0.60%\nbenchHeroQuery                R2 I1 P0  [\u03bc Mo]/r: 0.812 0.812 (ms)  [\u03bcSD \u03bcRSD]/r: 0.020ms 2.44%\nbenchNestedQuery              R2 I1 P0  [\u03bc Mo]/r: 1.826 1.826 (ms)  [\u03bcSD \u03bcRSD]/r: 0.015ms 0.82%\nbenchQueryWithFragment        R2 I1 P0  [\u03bc Mo]/r: 2.190 2.190 (ms)  [\u03bcSD \u03bcRSD]/r: 0.103ms 4.72%\nbenchStarWarsIntrospectionQueryR2 I1 P0     [\u03bc Mo]/r: 15.337 15.337 (ms)    [\u03bcSD \u03bcRSD]/r: 0.095ms 0.62%\n\n\\GraphQL\\Benchmarks\\LexerBench\nbenchIntrospectionQuery       R2 I4 P0  [\u03bc Mo]/r: 1.046 1.050 (ms)  [\u03bcSD \u03bcRSD]/r: 0.007ms 0.67%\n\n10 subjects, 19 iterations, 170 revs, 0 rejects, 0 failures, 0 warnings\n(best [mean mode] worst) = 0.007 [22.917 22.917] 0.007 (ms)\n\u2140T: 253.652ms \u03bcSD/r 0.024ms \u03bcRSD/r: 0.987%\n```\nAcceptable for you guys? \nAs for my motivation for this change: we're running a custom resolution handler that allows us to use type language .graphql files while also having resolvers who use generated PHP classes that represent types. To implement unions, we have no way to have the type determined right now and if ArrayAccess'able objects are allowed, we could have a workaround that way. . > @vladar seems to me that PHP is able to optimize (went long way since v 5 ;) ). I'm not well-aware of PHP internals but IMO from this condition (is_array($value) || $value instanceof \\ArrayAccess) it might usually evaluate only the first part and skip the other one.\nIf the is_array check is true, the second part will indeed not be evaluated.. Done.. ",
    "agougousis": "You are right! I tried with Postman, too, but I get an empty body. However, the PHP error log says:\nPHP Fatal error:  Allowed memory size of 536870912 bytes exhausted (tried to allocate 20480 bytes) in C:\\laragon\\www\\graphqlphp\\schema\\Types\\PostType.php on line 15\nOf course, I suspect the circular dependency, but I don't know what am I doing wrong. I am using a type registry as recommended in the documentation.\n. Why ? If I am not missing something, the value of  $config['fields']   is an anonymous functions ( a closure). So, it can be called to return the fields.\nThe subclass is setting this through the parent's setFields() method. An anonymous function is also used in the documentation to get the fields.. I understand the purpose of the closure but I am not getting why the closure is not there. In the ObjectTypeExtension's constructor, I do:\n$config['fields'] = $this->fields;\n...\nparent::__construct($config);\nBUT before this constructor is called, the child constructor (of UserType or PostType) is called, which uses the ObjectTypeExtension's setFields() in order to assign to $this->fields an anonymous function that returns the real fields.\nSo, when the constructor of ObjectType is called, the value of the  $config['fields'] is a closure. As it is in the documentation: http://webonyx.github.io/graphql-php/type-system/object-types/#recurring-and-circular-types\nYou can verify this by putting a var_dump like this:\n```\nclass ObjectTypeExtension extends ObjectType {\nprotected $fields;\n\npublic function __construct()\n{\n    $config['fields'] = $this->fields;\n\n    if (method_exists($this, 'resolveField')) {\n        $config['resolveField'] = [$this, 'resolveField'];\n    }\n\n    var_dump($config);\n    die();\n\n    parent::__construct($config);\n}\n\n...\n}\n```\nMaybe, I am too tired to understand.  :-/. Damn me! Now I see! \nSo, even before the setFields() is called we are trapped into this loop trying to calculate the parameter. \nThanks guys!!. ",
    "steffans": "@simPod Sorry, found it. I was using a cached AST from 0.11, so with a 0.12 AST it works \ud83d\udc4d\ud83c\udffb. ",
    "jbtbnl": "@vladar I'm interested in a release containing the SchemaExtender as well. Are there blocking issues in dev-master that we can help fix?. @vladar thank you!. @vladar @simPod this is a test case:\n```php\n<?php\n$queryType = new \\GraphQL\\Type\\Definition\\ObjectType([\n    'name' => 'Query',\n    'fields' => [\n        'hello' => [\n            'type' => \\GraphQL\\Type\\Definition\\Type::string(),\n            'resolve' => function() {\n                return 'Hello World!';\n            }\n        ],\n    ]\n]);\n$schema = new \\GraphQL\\Type\\Schema([\n    'query' => $queryType,\n]);\n$documentAST = \\GraphQL\\Language\\Parser::parse('\nextend type Query {\n    misc: String\n}\n');\n$extendedSchema = \\GraphQL\\Utils\\SchemaExtender::extend($schema, $documentAST);\n$helloResolveFn = $extendedSchema->getQueryType()->getField('hello')->resolveFn;\n$assertTrue = is_callable($helloResolveFn);\n```\nPlease advice where to add this. Or feel free to copy/alter it.. I did a few queries with the experimental executor and didn't see any significant change in performance. Neither did I experience any unexpected behaviour.. ",
    "devalexandre": "thanks, I find in guide. ",
    "yura3d": "Of course, here it is:\n\nAnd here I'll simply repeat the output after my changes (for comparing):\n. I'm sorry, it took some time to remove all confidential data from the stack trace.\nhttps://gist.github.com/yura3d/48ebc6e91ef1a65b595043ceb0d7ec82. The changes have been made. ",
    "mikelikenike": "The only place I create a new type is in my Types class\npublic class Types {\n    public static function typeA(): TypeA\n    {\n        return self::$typea?: (self::$typea = new TypeA());\n    }\n    public static function typeB(): TypeB\n    {\n        return self::$typeb?: (self::$typeb = new TypeB());\n    }\n    public static function node(): NodeInterface\n    {\n        return self::$node ?: (self::$node = new NodeInterface());\n    }\n}\nBoth my types implement the NodeInterface.\n```\nclass NodeInterface extends InterfaceType\n{\n    public function __construct()\n    {\n        $config = [\n            'name' => 'Node',\n            'fields' => [\n                'title' => Type::string(),\n            ],\n            'resolveType' => function ($value, $context, ResolveInfo $info) {\n                switch ($value->getType()) {\n                    case 'typea':\n                        return TypeRegistry::TypeA();\n                    case 'typeb':\n                        return TypeRegistry::TypeB();\n                }\n            },\n        ];\n        parent::__construct($config);\n    }\n}\npublic TypeA extends ObjectType\n{\n    public function __construct()\n    {\n        $config = [\n                'name' => 'Type A',\n                'interfaces' => [\n                    TypeRegistry::node(),\n                ],\n            ];\n            parent::__construct($config);\n    }\n}\npublic TypeB extends ObjectType\n{\n    public function __construct()\n    {\n    $config = [\n                'name' => 'Type B',\n                'interfaces' => [\n                    TypeRegistry::node(),\n                ],\n            ];\n            parent::__construct($config);\n    }\n}\n```\nIn my query class, I want to do something like this:\n$config = [\n    'name' => 'Query',\n        'providers' => [\n            'type' => Type::listOf(TypeRegistry::node()),\n        ],\n    ],\n];\nbut it only seems to work if my result set is of the same type(either TypeA or TypeB). If I have a result set that contains objects of both types, that is when I get the error. So what I want to know is if this is feasible with both my types?. ",
    "roelofjan-elsinga": "I have this problem as well. It happens when I submit a mutation containing a string with linebreaks \"\\n\". Did you manage to fix this problem? @wanxe . @wanxe I've done some research and stumbled upon this post: https://stackoverflow.com/a/50764657/2482417\nSo instead of passing the string to the GraphQL mutation, pass a variable instead.\njs\nmutation($message: String) {\n  createMessage(fullName: \"FirstName LastName\", message: $message) {\n    any\n    other\n    fields\n    you\n    want\n    to\n    receive\n    afterwards\n  }\n}\nNow with the variables you can pass the multi-line string:\njs\nvariables: {\n  message: `\n    This is a string on \n    multiple lines, and\n    it works just fine\n  `\n}\nIt's kind of tedious, but it's a limitation GraphQL has and doesn't have anything to do with this specific library I think.. @vladar I've tried both of those and they didn't seem to work. Perhaps we're on different versions. Anyway, there are at least 3 different solutions in these comments, so hopefully it helps others.. ",
    "wanxe": "Not yet :(\nIn fact I've closed the issue thinking that is just a problem on my front end side but if you have the same problem... May be is a library problem related.. ",
    "Tam": "I've managed to get it somewhat working. I was trying to return the ObjectType again when resolving instead of the Deferred.\nI've now hit an issue where the query will stop at the first Deferred. If I run the following query, where events returns a Deferred:\ngraphql\n{ events { id handle } }\nthe query will stop at events and won't continue to process id or handle. Ideally I need the entire query to be processed before any deferred are resolved to allow me to build the SQL query.\nI've created a gist with my current progress: https://gist.github.com/Tam/e76c64130b69ef31e19106f798434838.. ",
    "Graziel": "tried it, run my project tests no problems yet, dont see any noticeable performance gains but the tests says it runs a bit faster (just a bit). ",
    "erikgaal": "The PR above is only a small change that could be merged with backwards compatibility.\nWhile inspecting the code further, I noticed that the changing the function signatures to the interface variants NamedType or NullableType and so on leaves mixed signatures with interfaces and concrete implementations. That is a code smell to me, and against SOLID principle to implement against abstraction. However, there is no governing Type interface, only the GrapQL\\Type\\Definition\\Type abstract class. My suggestion is to actually implement the Type interface with the methods (and PHPdoc properties) that are required for all types, but that leaves me with name exhaustion. So any suggestions for the names of the interfaces and classes would be really appreciated. \ud83d\ude04 . ",
    "NewOldMax": "sorry, fixed by escaping. ",
    "chriseskow": "@vladar Any chance you can release a new version with this fix soon?. ",
    "Teeoo": "\nThere's no such code in the latest release (\u2026anymore), which version of webonxy/graphql-php are you using?\n\n~0.10.2  Maybe my version is too low.. > It is, see https://github.com/webonyx/graphql-php/releases => 0.13 is the latest.\n\nIf you're by chance using a Library on top of webonxy, you've to contact the library developers to upgrade.\nhttps://github.com/Folkloreatelier/laravel-graphql comes to my mind. It's orphaned but has many users and is stuck on 0.10.2 (coincidence?)\n\nYes, now it is https://github.com/Folkloreatelier/laravel-graphql, I will contact the author to upgrade later.. ",
    "apoberez": "composer show webonyx/graphql-php    \nCannot create cache directory /var/www/.composer/cache/repo/https---repo.packagist.org/, or directory is not writable. Proceeding without cache\nCannot create cache directory /var/www/.composer/cache/files/, or directory is not writable. Proceeding without cache\nname     : webonyx/graphql-php\ndescrip. : A PHP port of GraphQL reference implementation\nkeywords : api, graphql\nversions : * v0.12.6\ntype     : library\nlicense  : MIT License (MIT) (OSI approved) https://spdx.org/licenses/MIT.html#licenseText\nsource   : [git] https://github.com/webonyx/graphql-php.git 4c545e5ec4fc37f6eb36c19f5a0e7feaf5979c95\ndist     : [zip] https://api.github.com/repos/webonyx/graphql-php/zipball/4c545e5ec4fc37f6eb36c19f5a0e7feaf5979c95 4c545e5ec4fc37f6eb36c19f5a0e7feaf5979c95\npath     : /var/www/backend/vendor/webonyx/graphql-php\nnames    : webonyx/graphql-php. ",
    "mad-ice": "Might be related to @shmax's issue: https://github.com/webonyx/graphql-php/issues/425. Didn't know that existed, thanks!. ",
    "skodak": "hmm, the fails in travis above do not seem to be related to my changes. done, I have readjusted the whole param block. done. done. ",
    "hemratna": "Hi @simPod \nThanks a lot for quick reply.\nFor the http://webonyx.github.io/graphql-php/executing-queries/ can you guide me on how to define the $fieldResolver in the below-suggested code?\n```\nuse GraphQL\\GraphQL;\n$result = GraphQL::executeQuery(\n    $schema, \n    $queryString, \n    $rootValue = null, \n    $context = null, \n    $variableValues = null, \n    $operationName = null,\n    $fieldResolver = null, //Custom field Resolver when using Type Language to define the schema \n    $validationRules = null\n);\n```\nFor the http://webonyx.github.io/graphql-php/type-system/object-types/#field-resolution, I am creating the GraphQL schema dynamically. I don't have the individual PHP class for each type in the schema where I can write the logic for data fetching as mentation on http://webonyx.github.io/graphql-php/data-fetching/.\n. Is there any way not to use DI?\nHow can I pass the arguments to the \npublic function __invokable($source, $args, $context, \\GraphQL\\Type\\Definition\\ResolveInfo $info) from $fieldResolver = new MyCustomResolver()\nThanks a lot for such a quick response. \ud83d\udc4d . Oh my bad.\nI have to change the __invokable to __invoke on your refrence code.\n. ",
    "Daniel15": "Actually, I guess this wouldn't need too much server support... You'd just need to use a script (eg. https://github.com/apollographql/persistgraphql) to scrape all the GraphQL queries from the client-side code, persist them somewhere, and have the server endpoint load the persisted queries. Could cache them in APC for improved perf. Would be good to have docs for how to do this, though!. Does this also support \"automatic persisted queries\" (see https://blog.apollographql.com/automatic-persisted-queries-and-cdn-caching-with-apollo-server-2-0-bf42b3a313de) or should I open a separate feature request for that? How would I integrate the persistence mechanism in order to automatically persist the queries? . ",
    "mariusklocke": "@simPod Thanks for sharing your implementation of a DateTimeType, but that does not cover compound types required for date periods.. @simPod That was my last try:\n```\nclass DatePeriodType extends InputObjectType\n{\n    use SingletonTrait;\npublic function __construct()\n{\n    $config = [\n        'fields' => function () {\n            return [\n                'from' => [\n                    'type' => DateType::getInstance()\n                ],\n                'to' => [\n                    'type' => DateType::getInstance()\n                ]\n            ];\n        }\n    ];\n    parent::__construct($config);\n}\n\n}\n```\nUsing that type for query arguments results in getting the value for that as associative array in my resolvers. I'd like to have an object instance if my custom class for DatePeriod instead, but i don't know where to put my serialization/parsing logic.\nYou can find all my project's code here: https://github.com/mariusklocke/liga-manager-api. That's a pity :(\nBut thanks for the quick support! Will then implement my own parsing/deserialization methods and invoke it in resolvers.\nI'll close this issue for now. If anyone knows a better solution, feel free to re-open ;) . ",
    "abdullahseba": "Of course! I forgot to mention that... the resolver is on executeQuery so:\nphp\n     $result = GraphQL::executeQuery(\n                $schema,\n                $query,\n                $rootValue = null,\n                $context = null,\n                $variableValues = null,\n                $operationName = null,\n                new MyCustomResolver()        \n            );\n Sorry for the late reply.. I see. I'm not actually using the type language. I just used it to represent my user type more simply.\nRight now my resolvers are under the Query type:\nphp\n     'name' => 'Query',\n        'fields' => [\n            'user' => [\n            'type' => Types::user(),\n            'args' => [\n            'id' => Type::nonNull(Type::id())\n            ],\n            'resolve' => function ($source, $args, $context, \\GraphQL\\Type\\Definition\\ResolveInfo $info) {\n                 ...\n                 return ['id'=>$user[0]->id,'firstName'=>$user[0]->first_name];\n            }\nI wanted to register a type's resolver under its self rather than under the Query type. But as far as I can see, only resolveField is supported directly under a type. So I thought the next best thing would be to have a custom resolver class that registered each type resolver. I could still do that under the Query type, but I don't think its as clean.. ",
    "djrumbold": "Thanks for the tip @vladar , that's solved it for us!\nWe were JSON-decoding without the second parameter -\n$variables = json_decode($variablesJSON);\nand ending up with a structure comprised of stdClass objects rather than arrays, which has worked up until this point but obviously doesn't work for input object types parsing.\n. ",
    "calvera": "so it is misused in overblog/graphqlbundle? @overblog uses it in errorhandler, see https://github.com/overblog/GraphQLBundle/blob/master/Error/ErrorHandler.php. as i understand your previous message, it is not supposed that anybody uses GraphQL\\Error\\Error. so https://github.com/overblog/GraphQLBundle/blob/0b3b90ec54f06c7cc686962b3528fc0aae0b2e5e/Error/ErrorHandler.php#L115 and https://github.com/overblog/GraphQLBundle/blob/0b3b90ec54f06c7cc686962b3528fc0aae0b2e5e/Error/ErrorHandler.php#L127 is therefore misuse...\nthose lines are the reason i propose my PR\nthanks!. yes, they do not use code, but i would like to throw exception with code in my resolver and have the code in the error\nafter the changes i propose, i get it like this:\nyml\n{\n    \"data\": {\n        \"checkOut\": null\n    },\n    \"errors\": [\n        {\n            \"message\": \"Cannot check out, not checked in\",\n            \"code\": 1052,\n            \"locations\": [\n                {\n                    \"line\": 2,\n                    \"column\": 3\n                }\n            ],\n            \"path\": [\n                \"checkOut\"\n            ]\n        }\n    ]\nwithout changes, the code is missing. good point, i did not notice error formatter, thanks!. ",
    "gabidj": "Sure. That was a quick solution. \nThe comments were actually for who reads this pull request so they know what was my issue.\nYou are right about the ?: [] syntax.  \nI will perform the changes.. ",
    "keulinho": "good catch :+1: \nthe convention seems to be self:: but i'm used to static::\nfixed it. nullability can be dropped as it isn't nullable in ResolveInfo. $fieldNodes isn't an array but an ArrayObject, type hinted iterable instead. queryPlan is declared private because it should only be loaded lazy when you call lookAhead()\nWhen you cast the resolveInfo to array now it cpontains some binary string instead of queryPlan because it is private.\nFurthermore i really saw no value added by this test, because every key mentionied there would be used for own assertions, so the test will fail anyway if you remove one of the public properties.. "
}