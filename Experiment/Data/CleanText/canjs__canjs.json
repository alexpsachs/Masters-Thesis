{
    "retro": "This is done.\n. This is done\n. What do you mean by \"the left hand side does not change location\"? \n. This is fixed. I've tested it with the \"Use of other libraries\" link.\n. This is fixed. The problem was a tab character after {% highlight javascript %} block. I've fixed all code blocks.\n. I've fixed this. We should use {% highlight erb %} instead {% highlight html %}.\n. Done.\n. I couldn't reproduce this. I tried in IE, FF & Chrome\n. Observe already has the sort plugin\n. If we implement it as a helper, we can support something like this:\n{{#def Todo.findAll}}\n    {{if isResolved}}\n        {{#value}}\n            ...\n        {{/value}}\n    {{/if}}\n    {{#if isRejected}}\n        Rejected\n    {{/if}}\n{{/def}}\n. What is the exact problem? Renderer function will return new documentFragment each time it's called so it will have unique data-view-id and a new hook.\nWhat is the preferred behavior?\n. There are some issues that I have to iron out before this could be merged to the main repo. But, it seems to be working with mustache pretty good so far.\n. One of the cases where the can.Model.Collection plugin would be super useful is implementation of the HyperMedia APIs like HAL or JSONAPI which all need to keep data and current params to be in sync\n. This kind of validations are currently not possible:\n```\nCustomer.validate('contractNumbers.*', function(val){\n    return val === '' ? 'contract number is mandatory' : null;\n})\ncustomer = new Customer({contractNumbers : ['foo', 'bar', 123, '']})\ncustomer.errors()\n{\n    \"contractNumbers.3\" : ['contract number is mandatory']\n}\n```\nAnother reason is, if validation is called on the parent object, children errors will be included:\n```\nvar Company = can.Observe({})\nCompany.validate('name', function(){\n    return 'name is wrong'\n})\nvar company = new Company;\nvar person = new Person;\nperson.attr('company', company)\nperson.attr('company.name', 'foo')\nperson.errors();\n{\n    'company.name' : [\n        'name is wrong'\n    ]\n}\n```\nOn the question of the structure of the returned errors object, I think this is a good pattern because it follows how attrfunction behaves. Also, I think it is more useful in this form for everyday use, there could be a function added that returns nested structure (nestedErrors  ?)\nFinally, for the example:\n```\nPerson.validate('company.name', function(val){\n    return val ? undefiend : 'no name'\n})\nvar company = new Company({})\nvar person = new Person();\nconsole.log('first errors', person.errors()) // does this have errors?\n```\n1. Yes\nperson.attr(\"company\",company) // does this trigger an error?\n2. No\nconsole.log('second errors', person.errors()) // does this have errors?\n3. Yes\ncompany.attr(\"name\", false) // trigger errors on person?\n4. Yes\nIn my opinion 1 & 2 might have a wrong behavior, while 3 & 4 have it right.\n. I've added ability to define validations with the * directly on the lists:\nhttps://github.com/bitovi/canjs/blob/60da1befd0e8253985d657d6fb15b75f6ad7b25d/observe/validations/validations_test.js#L168\nhttps://github.com/bitovi/canjs/blob/60da1befd0e8253985d657d6fb15b75f6ad7b25d/observe/validations/validations_test.js#L182\nAs for the error object structure, I like how keys can be immediately passed to the attr function to get the data back, but either way could work.\n. This is a great step to the right direction, but it's still not covering all edge cases. I've added a test that's failing ATM https://github.com/bitovi/canjs/blob/35a9e01e89580187707f5123f017a3fadc7f0dd4/component/component_test.js#L650-L671\nBasically, when a new content tag appears, it should re-render all content tags after it to get correct results\n. I agree, option 2 looks the best. It doesn't look like a string literal, and it doesn't look like a mustache expression which makes it (IMO) a perfect choice.\n. Should it just override the findOne function then?\n. I've added a change that wraps findOne automatically instead of using .get. I'm running all can.Model tests with this plugin, and they are all passing.\n@justinbmeyer and @daffl is there a chance to get this to 2.1 release? Implementation is done, and I can add docs tomorrow. I believe it would be great to have this on can.Model if can.List already implements it.\n. I'll fix this\n. Here's my take on validations. I've talked about it with @justinbmeyer today, and we agreed that validations plugin should cover these cases:\n1. Validation of the current state\n2. Checking if setting attribute to a certain value would produce the error state\nValidation of the current state\nThis one is pretty easy, and I already have an \"external\" validation plugin implemented that covers the following cases:\n1. Validation of attributes\n2. Validation of nested attributes\n3. Validation of arrays\n4. Validation of arrays that contain simple values (strings, numbers)\n5. Validation of a whole object\n1. Validation of attributes\nThis is works similarly to the current CanJS validation plugin:\n``` javascript\nvar validator = new ValidatorContext(modelInstance, {\n    username : [ValidatorContext.rules.presenceOf()],\n    password : [function(value, path){\n        if(!passwordIsValid){\n            return \"is invalid\";\n        }\n    }]\n})\nvalidator.errors()\n// returns\n{\n  username : \"can't be empty\",\n  password : \"is invalid\"\n}\n```\n2. Validation of nested attributes\nThis is same as the validation of attributes, but you can use the whole path:\n``` javascript\nvar validator = new ValidatorContext(modelInstance, {\n    \"user.username\" : [ValidatorContext.rules.presenceOf()]\n})\nvalidator.errors()\n//returns \n{\n  \"user.username\" : \"can't be empty\"\n}\n```\n3. Validation of arrays\nThis will validate password for each user in the users array:\n``` javascript\nvar validator = new ValidatorContext(modelInstance, {\n  \"users.*.password\" : [ValidatorContext.rules.presenceOf()]\n})\nvalidator.errors()\n//returns\n{\n  \"users.1.password\" : \"can't be empty\"\n}\n```\nFormat of the attributes that is returned from the validator is similar to the paths returned from the events triggered by can.Map\nYou can go to any depth with it. This will validate username property of the socialNetworks array of each user in the users array:\n``` javascript\nvar validator = new ValidatorContext(modelInstance, {\n  \"users..socialNetworks..username\" : [ValidatorContext.rules.presenceOf()]\n})\nvalidator.errors()\n// returns\n{\n  \"users.1.socialNetworks.2.username\" : \"can't be empty\"\n}\n```\n4. Validation of arrays that contain simple values (strings, numbers)\nYou can validate strings and numbers in arrays too:\n``` javascript\nvar validator = new ValidatorContext(modelInstance, {\n  \"users..socialNetworkUsernames.\" : [ValidatorContext.rules.formatOf(REGEX)]\n})\nvalidator.errors()\n// returns\n{\n  \"users.1.socialNetworkUsernames.2\" : \"is invalid\"\n}\n```\n5. Validation of a whole object\nSometimes you wan't to decide which attribute is invalid in the context of the validation:\n``` javascript\nvar validator = new ValidatorContext(modelInstance, {\n  \"*\" : [function(){\n    if(this.someThing){\n      return {\n        username : 'is invalid'\n      }\n    }\n  }]\n})\nvalidator.errors()\n// returns\n{\n  \"username\" : \"is invalid\"\n}\n```\nIn my experience this covers all possible validation needs. Although this library is \"external\", we could implement the validate plugin that would provide glue between the can.Map or can.List and the Validator. I think something like this could work:\njavascript\nvar User = can.Map.extend({\n  validate : {\n    username : [can.validate.presenceOf()]\n  }\n})\nThis could set a special @errors attribute with the validation results. That would fix any problem of live binding in the templates.\n@errors should also be settable from the outside so you can set it with the errors returned from the API layer:\njavascript\nuser.save().then(success, function(req){\n  user.attr('@errors', JSON.parse(req.responseText));\n})\nValidation of a future state\nAKA: will setting this attribute put my map into the error state?\nI'm not sure how to approach this, but I believe that it would be best to simply clone the current object, set the value on it and return errors.\nSomething like this could work:\n``` javascript\nvar errors = user.errorsFor({attribute : 'value'});\nif(errors){\n  // do something\n}\n```\nAny feedback on this API is welcome.\n. When we talk about validations it's important to separate them in 3 groups:\n- Protocol validation (format of data: email, ip address, url...)\n- Business logic validation (something that can't be easily shared between models)\n- Server side validation (uniqueness and other stuff that can't be validated on the client)\nIn my opinion it does make sense to expose protocol validations through the view interface:\n<input type=\"text\" can-validate-format=\"email\">\nOr through some similar API.\nThe trick is to have a system that can combine all three of these in to one errors object.\nThat way view based validations could just be weaved in with the rest of the validations.\n. It is possible to do this, although it might be not as intuitive as it should be. You need to pass a function that returns a function:\n$('#id').html(template({\n    selected : function(){\n        return function(){ ... }\n    }\n})\n. ",
    "ralphholzmann": "Currently sitting at 8.6k, have lots of work to do on this. Something got added in the pile of commits coming from all the jupiter devs in the last week that bumped up the size around 300 bytes.\n. Current size is 8.625kb.\n. Current size is 8.548 kb gzipped after 7bd4dd9c0a1ae8b5e23db6cd2e60f2eb8dddaba9\n. Good news. I updated the Google closure compiler.jar in steal (what I was using to test for filesize) and it took those extra 300 bytes off. What's better, I got it under 8.3k.\nCurrent size is 8.296 gzipped.\n. I'm +1 on this. We shouldn't perpetuate jQuery's mistakes. We could fix this in a single shell command.\n. This has been fixed in the new steal via stealconfig.js. You map the util call to the lib you want to load.\n. Closing this as can.view is being overhauled in the 1.1 release.\n. Hmmm, this sounds like a tricky problem. @justinbmeyer any ideas?\n. The temporary fix for this is checking if elements are defined before triggering on them. Checking if they're in the document before triggering will add a lot of code (to get it to work in IE6+). Perhaps we can revisit this in the future if it causes widespread headaches / leaks.\n. Pulled in the test. The fix is still forthcoming.\n. Fixed up the test for this. It works as intended if you access your property via attr instead of dot notation. e.g. facet.attr(\"id\") not facet.id\n. Great fix. Thank you!\n. Thanks for the heads up on this. We'll have to adopt a different technique sometime down the line, but this likely won't be a high priority issue until jQuery 2.0. The reason being is that sync ajax can.view calls are reserved primarily for development mode. After building your app, all the views will be packaged into your production.js, where their fetching will no longer be sync. That said, if you're using steal to develop with CanJS, you shouldn't have any sync ajax can.view calls because you should be specifying the templates you'll need for your controller in your steal call:\njavascript\nsteal(\"can/control\", \"can/view/ejs\", \"./init.ejs\", function() {\n   can.view(\"./init.ejs\", function( frag ) {\n     // Not sync ajax cause you stole it above.\n   });\n});\n. This has been fixed by ce06025794611fbc77b2f07adb1db65449c48731.\n. Great catch! If you can issue a pull request I'll pull it in, otherwise I can fix this up tonight.\n. Why not just change your static methods to use {_id} instead of {id}?\n. I just tested a generated download of only can.Construct, and the closure around the code seems to attach it to the window.\n(function(can, window, undefined) {\n    ...\n})(can={}, this )\nAre you specifically looking for the AMD exports stuff?\n. Fixed via pull request.\n. In the future, it'd be great if you could include feature along with the tests in the same pull request. Thanks!\n. Thanks @daniel-franz.\n. Hey @hyusetiawan. Your solution looks good. \nThis is a common question about lists. It's currently not possible to not re-render the entire list on change. We're looking at supporting this in the future, but not in the short term. @justinbmeyer has more insight on this problem.\n. Getting close on this one -- should have a fix this morning.\n. Thanks @roissard!\n. Just merged this in! Thanks! You'll definitely be getting a shout out in the change log for canjs.us and the docs!\n. Hey @trickeyone,\nThanks for the bug report. I can't seem to reproduce this bug writing a simple test. Can you tell me or give me an example of how you're removing the last item in the list to trigger this error?\nThanks\n. I'm sorry @trickeyone but you'll have to provide a better reduced test case. I can't seem toe figure out where your error is cropping up.\n. There are some changes coming to EJS in the next can release that should facilitate this. Hang tight. /cc @daffl\n. Awesome job on this @makebbekus. Merging.\n. Turns out my modifiers rewrite didn't cause this, it was a different bug fix. Nevertheless, fixed it in 220aefbdbf0b647a62294cc40233e9335c8a687e. Feel free to pull it into cohuman.\n. Ah, I actually rewrote this logic in 220aefbdbf0b647a62294cc40233e9335c8a687e to no longer use regex. But we really appreciate the fix!\n. Why would you put spaces between the equals sign?\n. Nah, I dont think its a good idea. It won't minify much smaller, and if there's multiple users working on the same code base, it can be confusing if one is using options and the other is using opts.\n. ",
    "justinbmeyer": "\njquery.js 301\nstring.js - 606 (from 560) (esc added b/c it was in 2 places)\nconstruct - 668\nobserve - 1.67\ndeparam - 362\ndestroyed - 143\nroute - 1.09\ncontrol - 1.18\nview - 1.14\nmodel - 1.32\ncontrol/route - 210\nejs - 2.07\n\nstrangly, it seems like everything has stayed about the same size.  I don't know where that is coming from.\n. combined, this means that ejs + view take up 30% ...\n. hmmm, hopefully we can get it to 8.5 at least soon. \n. We need it to 8.33KB by JSConf to be less than backbone.\n. can you post an update here and update CanJS's website to link to the downloads?\n. Austin,  can you post a status update here?\n. click a link like foo\nthe left hand side does not change to show the new position you are looking at.\n. duplicate\n. I think the mouse can scroll it.  As it hits the boundaries, it can move the list of items up and down.\n. can.Model.List is already in model. The on at can/model/list is not supported and should not be used. \nSent from my iPhone\nOn Mar 30, 2012, at 11:59 AM, Cohuman Developerreply@reply.github.com wrote:\n\nWe were running into some minor steal loading issues when using can.Model.List because it depending on jquery/model instead of can/model. It meant we had use a tiered \"stealing\" when including files with can.Model.List e.g.\nsteal('can/model').then('can/model/list') rather than steal('can/model', 'can/model/list') or even just steal('can/model/list')\nYou can merge this Pull Request by running:\ngit pull https://github.com/cohuman/canjs master\nOr you can view, comment on it, or merge it online at:\nhttps://github.com/jupiterjs/canjs/pull/23\n-- Commit Summary --\n- can.Model.List depends on 'can/model'\n-- File Changes --\nM model/list/list.js (4)\n-- Patch Links --\nhttps://github.com/jupiterjs/canjs/pull/23.patch\n https://github.com/jupiterjs/canjs/pull/23.diff\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/jupiterjs/canjs/pull/23\n. on it\n. checking it out\n. I'm re-opening, this will be fixed with the next version of steal.   People will map can/util to their library like:\n\nsteal.map('can/until','can/util/jquery')\nsteal('can/util')\n. The original problem is fixed. Make sure you are binding to your instance to get it in the store. \nSent from my iPhone\nOn Oct 9, 2013, at 3:13 AM, heikkiha notifications@github.com wrote:\n\nHi,\nIs there any solution to this problem? I have the latest version of canjs and the problem still seems to exist.\nHow should I change this code to make it work?\nmodel: function(attributes) {\nif (!attributes) {\nreturn;\n}\nif (typeof attributes.serialize === 'function') {\nattributes = attributes.serialize();\n}\nvar id = attributes[this.id],\nmodel = (id || id === 0) && this.store[id] ?\nthis.store[id].attr(attributes, this.removeAttr || false) : new this(attributes);\nif (can.Model._reqs) {\nthis.store[attributes[this.id]] = model;\n}\nreturn model;\n}\n\u2014\nReply to this email directly or view it on GitHub.\n. Use the define plugin to handle merging.  You can create a setter that does merging however you would like.\n. One thing I've been thinking about is letting people require only the parts of canjs they need.  The project is already broken up like this.  For example,\n\nrequire(['can/control'], function(can){\n})\nBut i'd still like people to be able to require(['can']) so they aren't always writing:\nrequire(['can/control','can/model','can/view/ejs','can/route'])\n. One thing I've been thinking about is letting people require only the parts of canjs they need.  The project is already broken up like this.  For example,\nrequire(['can/control'], function(can){\n})\nBut i'd still like people to be able to require(['can']) so they aren't always writing:\nrequire(['can/control','can/model','can/view/ejs','can/route'])\n. I'm not sure that would help as they wouldn't be present on can. You'd hace to create your own to map to the can object.\nBtw, deferred is a separate file. \nAnd outside deferred, there's little that could be swapped. \nAnd, we wouldn't want these things in zepto probably, but in can/util directly so they can be used by other base libraries. \nSent from my iPhone\nOn Aug 12, 2012, at 5:17 PM, Jeff Rose notifications@github.com wrote:\n\nAs part of this effort, it would be nice to see can/util/zepto/fill (and similar) broken up into separate files, like can/util/zepto/fill/promise, can/util/zepto/fill/ajax, etc. This would provide the flexibility of letting developers choose how to fill those gaps. For instance, using whenjs for promises.\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm not sure that would help as they wouldn't be present on can. You'd hace to create your own to map to the can object.\n\nBtw, deferred is a separate file. \nAnd outside deferred, there's little that could be swapped. \nAnd, we wouldn't want these things in zepto probably, but in can/util directly so they can be used by other base libraries. \nSent from my iPhone\nOn Aug 12, 2012, at 5:17 PM, Jeff Rose notifications@github.com wrote:\n\nAs part of this effort, it would be nice to see can/util/zepto/fill (and similar) broken up into separate files, like can/util/zepto/fill/promise, can/util/zepto/fill/ajax, etc. This would provide the flexibility of letting developers choose how to fill those gaps. For instance, using whenjs for promises.\n\u2014\nReply to this email directly or view it on GitHub.\n. yes, you are not using rhino.  Closing this b/c it's not a bug.\n. ./js can/util/make.js\n. You can edit the docs on this page and submit a pull request:\n\nhttps://github.com/jupiterjs/canjs/blob/gh-pages/index.md\n. I'm thinking we should actually deprecate providing a callback ... people should use the deferred in this case.  Thoughts?\n. I'm thinking we should actually deprecate providing a callback ... people should use the deferred in this case.  Thoughts?\n. good point ... I'm not sure.\n. good point ... I'm not sure.\n. Well first, my guess is that \n<textarea value=\"<%= obs.attr('foo') %>\"><%= obs.foo %></textarea>\nwill probably work.\nThe problem with:\n<textarea><%= obs.attr('foo') %></textarea>\nis as curtis said, there is no element we can hookup with at that point.\nMy initial thought on making this work would be to add a \"hookup\" on every textarea.  EJS would make accessible the previous element's list of hookups.  Which is hooks on this line:\nhttps://github.com/jupiterjs/canjs/blob/master/view/ejs/ejs.js#L461\nThen, we'd do some checking around here:\nhttps://github.com/jupiterjs/canjs/blob/master/view/ejs/ejs.js#L303\nIf we are currently in a texarea, just return the content, but add what would normally be hooked up (https://github.com/jupiterjs/canjs/blob/master/view/ejs/ejs.js#L398) to hooks (the previous element's list of hookups).\nThe problem with this is things like:\n<textarea>\n  <% if( obs.attr('show') ) {  %>\n    <%= obs.attr('foo') %>\n  <% } %>\n</textarea>\nMight get tricky.  This turns into something like:\njavascript\nview.push( can.EJS.txt(0,\"textarea\",0, this, function(){\n  var view = [];\n  view.push( can.EJS.txt(1,\"textarea\",0, this, function(){ obs.attr('foo') } )\n  return view.join('');\n})\nWe'd have to somehow tell the inner EJS.txt call that it is to just return the text and not to HOOKUP even if it finds it's function reading from an observe.\n. Well first, my guess is that \n<textarea value=\"<%= obs.attr('foo') %>\"><%= obs.foo %></textarea>\nwill probably work.\nThe problem with:\n<textarea><%= obs.attr('foo') %></textarea>\nis as curtis said, there is no element we can hookup with at that point.\nMy initial thought on making this work would be to add a \"hookup\" on every textarea.  EJS would make accessible the previous element's list of hookups.  Which is hooks on this line:\nhttps://github.com/jupiterjs/canjs/blob/master/view/ejs/ejs.js#L461\nThen, we'd do some checking around here:\nhttps://github.com/jupiterjs/canjs/blob/master/view/ejs/ejs.js#L303\nIf we are currently in a texarea, just return the content, but add what would normally be hooked up (https://github.com/jupiterjs/canjs/blob/master/view/ejs/ejs.js#L398) to hooks (the previous element's list of hookups).\nThe problem with this is things like:\n<textarea>\n  <% if( obs.attr('show') ) {  %>\n    <%= obs.attr('foo') %>\n  <% } %>\n</textarea>\nMight get tricky.  This turns into something like:\njavascript\nview.push( can.EJS.txt(0,\"textarea\",0, this, function(){\n  var view = [];\n  view.push( can.EJS.txt(1,\"textarea\",0, this, function(){ obs.attr('foo') } )\n  return view.join('');\n})\nWe'd have to somehow tell the inner EJS.txt call that it is to just return the text and not to HOOKUP even if it finds it's function reading from an observe.\n. I think I fixed this here: https://github.com/jupiterjs/canjs/commit/90186e504da84b02c48e727aea098bac0cb421cc closing\n. I think I fixed this here: https://github.com/jupiterjs/canjs/commit/90186e504da84b02c48e727aea098bac0cb421cc closing\n. Yeah, please check that out.  We removed sort to keep size low because sorting in the client is relatively rare (at least in the applications we make). \nWhat are you using sort for? \nI'm closing this.  Create a new one if there's things you need for the sort plugin.\n. Yeah, please check that out.  We removed sort to keep size low because sorting in the client is relatively rare (at least in the applications we make). \nWhat are you using sort for? \nI'm closing this.  Create a new one if there's things you need for the sort plugin.\n. why would you use it as an actual comment? I always use:\n<!-- comment -->\nI only use <%#\nis if I'm commenting out someone's code that I want to leave in source for future reference.\n. why would you use it as an actual comment? I always use:\n<!-- comment -->\nI only use <%#\nis if I'm commenting out someone's code that I want to leave in source for future reference.\n. So, I really appreciate your pull request ... anyone who submits a patch is awesome.  And better docs is always great too.  But I'm not sure <%# is the best way vs <!--\nA lot depends on how EJS is going to be used.  If the template is going to pre-processed and loaded in an production app with StealJS, using <%# is actually better because that comment will never be known to the production app.\nIn any other situation, <!-- is going to be better because it's less work for EJS to do.\nI'm not exactly sure what to show someone ...\n. So, I really appreciate your pull request ... anyone who submits a patch is awesome.  And better docs is always great too.  But I'm not sure <%# is the best way vs <!--\nA lot depends on how EJS is going to be used.  If the template is going to pre-processed and loaded in an production app with StealJS, using <%# is actually better because that comment will never be known to the production app.\nIn any other situation, <!-- is going to be better because it's less work for EJS to do.\nI'm not exactly sure what to show someone ...\n. So, I've many times made eval work better with EJS, but the browsers keep changing what's needed to make eval debug the text correctly. \nThis is a huge pain.  \nSourceURL works working fine for a while:\nhttp://blog.getfirebug.com/2009/08/11/give-your-eval-a-name-with-sourceurl/\nhttps://github.com/jupiterjs/canjs/blob/master/view/ejs/ejs.js#L721\nBut now it seems everything gets put on one line.\nI'd very much like to see EJS easier to debug (maybe with sourceMap too?).  If this is something you are interested in, please create another issue.  And, any help you could provide would also be great.  Thanks!\n. So, I've many times made eval work better with EJS, but the browsers keep changing what's needed to make eval debug the text correctly. \nThis is a huge pain.  \nSourceURL works working fine for a while:\nhttp://blog.getfirebug.com/2009/08/11/give-your-eval-a-name-with-sourceurl/\nhttps://github.com/jupiterjs/canjs/blob/master/view/ejs/ejs.js#L721\nBut now it seems everything gets put on one line.\nI'd very much like to see EJS easier to debug (maybe with sourceMap too?).  If this is something you are interested in, please create another issue.  And, any help you could provide would also be great.  Thanks!\n. looks good, but can.EJS.Helpers.prototype.list is going to be deprecated.  Can you change it to use\nitems.each(function( item ) {\ninstead?\n. looks good, but can.EJS.Helpers.prototype.list is going to be deprecated.  Can you change it to use\nitems.each(function( item ) {\ninstead?\n. Observe and Observe.List convert any nested object or array into an Observe or List letting you do:\njavascript\no = new Observe({ items: [ { name : \"Justin\" } ] })\no.attr('items.0.name')\no.attr('items')[0].attr('name')\netc\n. Observe and Observe.List convert any nested object or array into an Observe or List letting you do:\njavascript\no = new Observe({ items: [ { name : \"Justin\" } ] })\no.attr('items.0.name')\no.attr('items')[0].attr('name')\netc\n. Thanks for the test. Working on this now.\n. Thanks for the test. Working on this now.\n. I'm not sure how I feel about this. It's a very common pattern that findAll/findOne return varying amounts of data. Curtis, can you set this back until we've had some discussion on it. \nWhy was this added? Attributes are actually being removed by your service (and can't be set to null)?\n. I'm not sure how I feel about this. It's a very common pattern that findAll/findOne return varying amounts of data. Curtis, can you set this back until we've had some discussion on it. \nWhy was this added? Attributes are actually being removed by your service (and can't be set to null)?\n. It depends.  Often people load additional fields on a findOne.  Then if someone did another findAll, it would suddenly remove the extra fields.\nI find it odd that fields should ever be removed (typically they might be set to null).  However, I do understand having array-properties be updated.\nI'm  not sure that an array should even have a \"merged\" option.\nWe might need to add an option that turns this behavior off.  Model.removeAttributesOnUpdate = false\n. It depends.  Often people load additional fields on a findOne.  Then if someone did another findAll, it would suddenly remove the extra fields.\nI find it odd that fields should ever be removed (typically they might be set to null).  However, I do understand having array-properties be updated.\nI'm  not sure that an array should even have a \"merged\" option.\nWe might need to add an option that turns this behavior off.  Model.removeAttributesOnUpdate = false\n. Can you make a pull request w/ a test?  I'll pull it.  Thanks!\n. Can you make a pull request w/ a test?  I'll pull it.  Thanks!\n. This seems like I fixed this here: https://github.com/jupiterjs/canjs/commit/90186e504da84b02c48e727aea098bac0cb421cc\nNot sure why this isn't pushed out.  Can anyone confirm this?\n. This seems like I fixed this here: https://github.com/jupiterjs/canjs/commit/90186e504da84b02c48e727aea098bac0cb421cc\nNot sure why this isn't pushed out.  Can anyone confirm this?\n. Can you make a failing test?  Something with much smaller code than your fiddle (and does not use can.Control)?\n. Can you make a failing test?  Something with much smaller code than your fiddle (and does not use can.Control)?\n. Also, can you describe how this happens?  I don't understand it from your forum post either.\n\nThis returns all the DOM elements within mainContent to cleanData which then iterates over them and triggers the destroyed method. When this happens, this includes the div elements that were created to contain the up/down arrows. But when the element containing the collapsible control is processed it invokes the destroy method which deletes the added div elements before they are processed by cleanData.\n\nTriggers the destroyed method? You mean triggers the destroyed event?  \nInvokes the destory method?  What invokes the destory method?\nDeletes the div elements?  Div elements are never deleted, they are removed from the dom.\nCan you clean up your explanation?  Thanks!\n. Also, can you describe how this happens?  I don't understand it from your forum post either.\n\nThis returns all the DOM elements within mainContent to cleanData which then iterates over them and triggers the destroyed method. When this happens, this includes the div elements that were created to contain the up/down arrows. But when the element containing the collapsible control is processed it invokes the destroy method which deletes the added div elements before they are processed by cleanData.\n\nTriggers the destroyed method? You mean triggers the destroyed event?  \nInvokes the destory method?  What invokes the destory method?\nDeletes the div elements?  Div elements are never deleted, they are removed from the dom.\nCan you clean up your explanation?  Thanks!\n. I'm guessing length is changing because the array returned by getElementsByTagName is not actually an array .. but a live list of dom elements.\nDo you have a control that is listening to destroy and removing elements itself?  If so, why?\n. I'm guessing length is changing because the array returned by getElementsByTagName is not actually an array .. but a live list of dom elements.\nDo you have a control that is listening to destroy and removing elements itself?  If so, why?\n. this.element.find('.collapser').remove();\nWhy do you need that?\n. this.element.find('.collapser').remove();\nWhy do you need that?\n. I think it needs to copy the array and check if each element is in the dom.  Unfortunately, this might be too expensive ...\n. I think it needs to copy the array and check if each element is in the dom.  Unfortunately, this might be too expensive ...\n. Well, I'm happy with this change, we just need to do a little performance testing first.  Create a 1000 or so dom elements, call .remove on them.  What's the performance difference if you copy and check if each element is in the dom vs not doing it?\nIf it's not much much worse, we can probably fix it.\n. Well, I'm happy with this change, we just need to do a little performance testing first.  Create a 1000 or so dom elements, call .remove on them.  What's the performance difference if you copy and check if each element is in the dom vs not doing it?\nIf it's not much much worse, we can probably fix it.\n. .then is very old.  It was deprecated in JMVC 3.3.  It is gone from the new Steal.  You have to configure those files:\n{\n  meta: {\"jquery.dataTables.js\": { deps: [\"jquery\"] }\n}\n. .then is very old.  It was deprecated in JMVC 3.3.  It is gone from the new Steal.  You have to configure those files:\n{\n  meta: {\"jquery.dataTables.js\": { deps: [\"jquery\"] }\n}\n. Thanks for the fix! However, I'm thinking this is going to make a lot of requests if someone has a deeply nested structure.  Instead, I'm going to cache the deferreds and the renderers.  I'm about to submit this.\n. Thanks for the fix! However, I'm thinking this is going to make a lot of requests if someone has a deeply nested structure.  Instead, I'm going to cache the deferreds and the renderers.  I'm about to submit this.\n. It's possible there was some miscommunication between myself and @retro.  It was my understanding that this pull request fixed his problem, and the problem identified here: https://forum.javascriptmvc.com/topic/recursive-use-of-ejs by making multiple requests.\nThe core problem there was that adding a success handler to a deferred within another success handler was not synchronously calling the new success handler.\nFor example:\n``` javascript\nvar d = new can.Deferred();\nd.then(function(){\n  var a =0;\n  d.then(function(){\n    a++;\n  })\n  a // should be 1, but is 0\n})\nd.resolve();\n```\nSo, I had to change can.view to not do this.  Now it checks if the deferred isResolved and uses a cached renderer.\nThis might be irrelevant to your problem.\n. It's possible there was some miscommunication between myself and @retro.  It was my understanding that this pull request fixed his problem, and the problem identified here: https://forum.javascriptmvc.com/topic/recursive-use-of-ejs by making multiple requests.\nThe core problem there was that adding a success handler to a deferred within another success handler was not synchronously calling the new success handler.\nFor example:\n``` javascript\nvar d = new can.Deferred();\nd.then(function(){\n  var a =0;\n  d.then(function(){\n    a++;\n  })\n  a // should be 1, but is 0\n})\nd.resolve();\n```\nSo, I had to change can.view to not do this.  Now it checks if the deferred isResolved and uses a cached renderer.\nThis might be irrelevant to your problem.\n. > Wouldn't it be better to make the EJS view engine recognize the can.Deferred interface and postpone the final array join operation on the component results until all encountered deferreds have resolved?\nTalk about crazy generated code.  You'd have to wrap every prop access in something that checks if a deferred and has a callback to run when resolved.  I don't think that's actually possible.\nI hope they do not remove it.  If they do, we will likely have to re-enable it in CanJS's compatibility layer. I don't want to force users to always provide a callback when using a view.\nAlso, it's only a hack b/c we are modifying the data object's properties.  That can be changed very easily by copying properties to a new object and modifying the deferred ones there.  Otherwise, I think that is fine.\n. > Wouldn't it be better to make the EJS view engine recognize the can.Deferred interface and postpone the final array join operation on the component results until all encountered deferreds have resolved?\nTalk about crazy generated code.  You'd have to wrap every prop access in something that checks if a deferred and has a callback to run when resolved.  I don't think that's actually possible.\nI hope they do not remove it.  If they do, we will likely have to re-enable it in CanJS's compatibility layer. I don't want to force users to always provide a callback when using a view.\nAlso, it's only a hack b/c we are modifying the data object's properties.  That can be changed very easily by copying properties to a new object and modifying the deferred ones there.  Otherwise, I think that is fine.\n. I think if we look to implement our own version of mustache, the nested deferreds will be much easier to implement.\n. If you think it's a hack for another reason, then let me know.  Otherwise, if you create another issue, I'll make it so it doesn't modify the passed in data object.\n. I'm talking about property access, one is rarely (never) having a deferred that resolves to a string that is simply inserted.  You typically have a deferred that resolves to a model instance or some object.  Say a user's name.\n<%= user.name %>\nwhere user is a deferred passed to the template.  How could I know if user is a deferred?\n. > How could I know if user is a deferred?\nMeaning, if I were to replace <%= user.name %> with something like:\n__view.push( compile(\"user.name\") )\nI would have to parse JS and run it to see if any object is a deferred and then wait until it resolves until continuing reading name.  \nMustache, which doesn't allow property access outside it's API, would be a better candidate for this type of thing.\n. I see what you are saying, but I'm divided. A few points:\n- In practice, I don't think this makes the behavior more predictable. I always know if I'm giving a deferred a view or not. However, I can see use-cases where you want to pass both and have the code behave the same way.\n- I hate callbacks. The synchronous pattern allows people to modify the DOM (like attach widgets) after rendering without callbacks. \n- The vast majority of our apps pre-load the template in production, so there is no ajax request at all.  I don't want to force an async pattern when synch is what it ends up being.\nI suppose it comes down to if we expect CanJS to be used with steal so we favor a sync style because most templates will be pre-loaded.\nA possible compromise is having steal provide the render functions like:\njavascript\nsteal('foo.ejs', function(foo){\n  $(\"#bar\").html( foo( DATA ) );\n})\nHowever, if people used deferred loading templates internally, this would still have unexpected behavior.\nI want my sync, but understand what you're looking for. Hopefully we can think up a solution that works for everyone.  Thanks!\n. Now that steal supports providing a render function, we might be able to adopt an async can.view in future releases.  But for 1.1 this is probably not going to change.\n. Steal now supports returning renderers.  This (or a amd plugin that does something similar) is recommended.  Possibly for 1.3 we could add support for this ...\n. @rjgotten Added for 3.0.\n. Yes, listen to add/remove events and insert/remove. There's no way to do this with live binding. \nSent from my iPhone\nOn Jul 4, 2012, at 6:48 AM, Javier Martinez Fernandezreply@reply.github.com wrote:\n\nActually, when using live binding with list.each, the list is completely rendered every time a new element is added/removed.\nThis is quite expensive when using live binding with large collections.\nI'm missing some other way to do this?\nThank you.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/jupiterjs/canjs/issues/65\n. I'm going to close this.  I think we'll create a list widget in CanUI that does exactly this.\n. Can you create a test? Or a fiddle demonstrating? I find this unlikely. Also list is deprecated. \n\nSent from my iPhone\nOn Jul 24, 2012, at 1:03 PM, thecountofzeroreply@reply.github.com wrote:\n\nWhen doing something like this within an EJS:\njavascript\n<% list(things, function(t){ %>\n   <li <%= (el)-> el.data('thing', t) %>><%= t.name %></li>\n<% }) %>\nthe data attribute does not contain any data\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/jupiterjs/canjs/issues/68\n. Using jQuery alone doesn't help in the extreme case. Instead, it should get jQuery passed in as an arg to the wrapped function and aliased as $. \n\nSent from my iPhone\nOn Jul 24, 2012, at 1:09 PM, Peter Upfoldreply@reply.github.com wrote:\n\nBoth the download builder at the CanJS site, and the latest version of can.jquery.js from here, give you a copy of CanJS that is incompatible with jQuery.noConflict().\n(Both of these, I am informed, use the Pluginify part of Steal to be built.)\nIn a scenario where jQuery.noConflict() has been invoked, CanJS has multiple references to $, which is undefined, due to the use of noConflict().\nThis manifests itself as this syntax error:\nTypeError: 'undefined' is not an object (evaluating '$.extend')\non line 11: $.extend( can, jQuery, {\nThis can be worked around by doing a find/replace for $ and replacing it with jQuery, but it would be ideal if CanJS was noConflict() aware out of the box.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/jupiterjs/canjs/issues/69\n. I don't think findAll on a list is going to be supported.  You can get the deferred that resolves to the list from Model.findAll\n. The purpose is for uniquely identifying model instances for a whole bunch of things (keeping things in the store, knowing to call update or create, etc). Look where getId is used.\n. @hyusetiawan yeah, you should use {_id}.\n. your fiddle does not seem to show this.  I feel like we would have seen this already.  Can you create test and submit a pull request?  Thanks!\n. very weird ... thanks.  I know I've made things that split elements across lines. We'll get a fix after the pull request.  Thanks!\n. This is known and not something we can fix (without a lot more js parsing). \n\nSent from my iPhone\nOn Jul 28, 2012, at 2:46 AM, Daniel Franzreply@reply.github.com wrote:\n\nBlock scope by curly brackets seems to be lost, if the opening ejs-block is divided into more than one part.\nThis is working:\nvar text = \"<% for (var i = 0; i < test.length; i++) {\" +\n   \"if (test[i].length) {\" +\n[..]\nYou can merge this Pull Request by running:\ngit pull https://github.com/daniel-franz/canjs patch-5\nOr you can view, comment on it, or merge it online at:\nhttps://github.com/jupiterjs/canjs/pull/77\n-- Commit Summary --\n- Add tests for nested control structures\n-- File Changes --\nM view/ejs/ejs_test.js (15)\n-- Patch Links --\nhttps://github.com/jupiterjs/canjs/pull/77.patch\n https://github.com/jupiterjs/canjs/pull/77.diff\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/jupiterjs/canjs/pull/77\n. Block scope still works right?  It's just they are broken on a single line?\n. AngularJS does this?  Can you show me an example? I doubt it's \"keeping track of the focus\"; instead, it's probably not removing the current element that has focus.  This is more difficult with EJS.\n\nEJS is really live JS embedded in HTML where Angular has certain tags that control behavior like:\nhtml\n<li ng-repeat=\"todo in todos\">\nThis allows Angular to be a little smarter (but with a lot more code) than EJS.  For example, with a list, EJS just replaces the contents with HTML everytime the length changes.  \nAngular, getting it's hooks into that array, knows when a specific element is inserted or removed and now blow everything away.\nWe're working on CanUI, which will contain a \"list\" widget that will be smarter in this way. We should look to make this easy to hook up within EJS.\nCan you create a new Issue, with something along the likes of: \"Make EJS.Helpers.prototype.list update the DOM on 'add' and 'remove' events instead of 'length' events\".\n. Can you find that commit in jQuery?  I'm wondering why they did it.  Thanks.\n. No worries, I'll look it up w/ git blame when I have time.\n. Model lists automatically remove destroyed models.  This is probably the problem.  However, I can't tell because your example is complex to follow.  If you could clean it up, that would help.\nWhat needed model functionality?  You can add every model/observe plugin in a fiddle.\n. your example sets up fixtures, controls, models, etc, when all it probably needs is model.List.  Remove the unnecessary code.\n. You can use steal to load from http://donejs.com\nhtml\n<script src=\"http://donejs.com/steal/steal.js\">\n</script>\n``` javascript\n  steal('can/observe/sort', function(){\n})\n```\n. That's normally fine.  But you are using an unreleased plugin. There's not a packaged JS file you can use.\n. Can you remove fixtures and the need to click something?  Can't you just create a model list like:\n``` javascript\ncan.Model(\"Foo\")\nvar mylist = Foo.models({id: 1},{id: 2})\n// do whatever you need to break it\n```\n. Another thing, why 20 objects, this probably happens with 2. Apologies about being so demanding about this, but @ralphholzmann and I are crazy busy with our client work. It helps us a lot if we can quickly get some small code that shows the problem.  Something like:\n```\ncan.Model(\"Foo\",{\n  destroy: function(){\n    return new $.Deferred().resolve()\n  }\n})\nvar mylist = Foo.models({id: 1},{id: 2})\nmylist[1].destroy()\n```\nBut looking at the error, it seems that sort code is trying to run on a \"remove\" event.  That's not only wrong because it's trying to find an item that's been removed, it's unnecessary because the array should already be sorted.\n. why are fixtures needed?  Why can't you have destroy do what I showed in the example above?\n. I showed my model with the wrong static props.  It should be:\njavascript\ncan.Model(\"Foo\",{\n  destroy: function(){\n    return new $.Deferred().resolve()\n  }\n},{})\nThat should work w/o having to create fixtures.\n. What is meant by:\n\nThe updated one it a smaller run at it. \n. were you ever able to figure this out / make it smaller?\n. Steal already can do this build process.  It uses can.view.register to register a function by ID.  This way code doesn't have to change.\n. Also, we are planning on making steal return the compiled function. So:\n\nsteal('foo.ejs', function(foo){\n  $(\"#bar\").append( foo({}) ) \n})\n. You are using CanJS, but not EJS? Kinda like throwing the baby out with the bath water. Someone else who was doing the same thing didn't realize that EJS is bundled with CanJS. Was this why?  If not, why aren't you using EJS?\nIt is part of can.view.  You can use can.view.register to register templates by name.\n. Ralph, let's talk about this more before you pull. Couldn't splice be used?  Also if you are binding, there should be no need for comparing by ids. \n. Are you from the uk?  I've seen other people from the uk do that. \nSent from my iPhone\nOn Aug 30, 2012, at 11:34 AM, Ralph Holzmann notifications@github.com wrote:\n\nWhy would you put spaces between the equals sign?\n\u2014\nReply to this email directly or view it on GitHub.\n. Anyway you can create a pull request with this as a breaking test and we will fix it?\n. @daffl this still appears broken for me.  This test passes for you?\n. seems like it's a difference in FF?  Here's my output:\n\n```\nExpected:   \"\"\nResult:     \"\"\n```\n. Yeah, it passes in Chrome, not in FF.\n. Thanks, but fixtures can provide a status via their callback.  The return value with status codes is no longer supported.\n. Looks good, but we'll need to add a test before we can pull this. \n. You should never set a property directly on the model.  Ex:\nmodel.id = 123;\nShould always be model.attr('id',123)\n. but .. this is still a good fix.  Thanks!\n. Does observe.js even have map?\nobserve/list/list.js is certainly not a \"a+\" plugin It's not listed on CanJS's site right?\nHowever, please be cool about submitting bugs. The language of this ticket is odd. No need to bold wrong. \nIf map is not returning an other observe.list please say that, submit a test, a fixed pull request, etc. \nBeing vague helps nothing. \nSent from my iPhone\nOn Oct 4, 2012, at 4:35 AM, rjgotten notifications@github.com wrote:\n\nA map operation is supposed to work as a projection, which means it should be able to produce lists of a different resulting type. The strongest type Observe.List.prototype.map can safely return is a vanilla can.Observe.List. Anything else is plain wrong.\n\u2014\nReply to this email directly or view it on GitHub.\n. Whoops, from my email I didn't realize that the comment was part of a thread expressing your feeling about the fix, not the request for the fix. \n\nI need to work less from email. Apologies again. \nSent from my iPhone\nOn Oct 4, 2012, at 4:35 AM, rjgotten notifications@github.com wrote:\n\nA map operation is supposed to work as a projection, which means it should be able to produce lists of a different resulting type. The strongest type Observe.List.prototype.map can safely return is a vanilla can.Observe.List. Anything else is plain wrong.\n\u2014\nReply to this email directly or view it on GitHub.\n. You should look up the type to create like this.constructor\n. I meant \"new this.constructor(items)\" where this is the parent list. \n\nBut, yeah, checking obj.constructor.List would also be good. \nThe old $.fn.models did something similar. \nSent from my iPhone\nOn Oct 4, 2012, at 8:32 AM, noah notifications@github.com wrote:\n\nWell, it's tricky for map. The values could be heterogenous, so trying to infer the list type from the values could backfire if a new value maps differently or the list starts out empty.\n\u2014\nReply to this email directly or view it on GitHub.\n. Anyway you can submit a test showing this and we can look at fixing it. Thanks!\n. How does it know to call new Items or simply Items?  I don't know if this will work. \n. You can pass attributes functions. That will work. \n. attributes:{\n items: function(raw){ return new Items(raw) }\n}\n\nSent from my iPhone\nOn Sep 17, 2012, at 10:29 AM, Alex Osh notifications@github.com wrote:\n\nCurrently one can assign model/list name (string) as attribute type for automatic conversion. But if there is no such object in window context (for an example AMD case) it is impossible to do so.\nI would propose to use model/list objects it self for declaring attribute type.\nsteal('can/observe/attributes', 'items.js', function(Observe, Items){\nreturn Observer({\nattributes: {\nitems: Items // Items is object not 'Items' string\n}\n})\nthen observe knows what type to convert to.\n\u2014\nReply to this email directly or view it on GitHub.\n. There's no great way to tell a function that is intended to be called with new vs a normal function. \n\nIn js a constructor function is just a function. It's how you call it that matters. \nSent from my iPhone\nOn Sep 17, 2012, at 11:13 AM, Alex Osh notifications@github.com wrote:\n\nwhy call just Items, in what case does it make sense?\nat list if Items is Construct/Observer or Observe.List/Model.List it does make sense to all new Items, no?\n\u2014\nReply to this email directly or view it on GitHub.\n. Because it's very common to not pass a constructor and a function that might pick between various constructors. Or pass something like Date.parse. \n\nSent from my iPhone\nOn Sep 17, 2012, at 11:19 AM, Alex Osh notifications@github.com wrote:\n\nYes, using function is good, but why not make it automatically.\n\u2014\nReply to this email directly or view it on GitHub.\n. Can you create an example fiddle showing this problem?\n. You can test it by making sure FF / Chrome show the filename in their debuggers.\n. @SteveEisner, can you send us a page that consistently errors? \n\nMaybe a test that adds  /@cc_on!@/\ncc @dispatchrabbi\n. Fiddles on canjs.us's homepage and also here:\nhttp://canjs.us/recipes.html\n. Eventually, I'd like you to configure a service and apply that to a can.Map constructor function.  I think this is how Spine works.  I think this is best to revisit when we make those changes to can.Model.\n. Use a jquery Ajax prefilter to convert post/put into JSON across your app. \nExample: https://github.com/donejs/bitballs/blob/master/public/util/prefilter.js\ncan-connect now sends JSON by default. \nSent from my iPhone\n\nOn Sep 28, 2016, at 4:16 AM, beno notifications@github.com wrote:\nJust got bit by this again: I can't believe I am googling my own post here. Am I really the only one bothered by this?\nAnyway, the problem is submitting an object with a nested array of objects:\n{foo: \"foo\", bars: [{bar: \"bar\"}]}\nSubmitting a JSON here would be trivial, but posting a encoded form turns this into\nq = jQuery.param({foo: \"foo\", bars: [{bar: \"bar\"}]})\n    #=> \"foo=foo&bars%5B0%5D%5Bbar%5D=bar\"\nwhich on a server turns into\n{\"foo\"=>\"foo\", \"bars\"=>{\"0\"=>{\"bar\"=>\"bar\"}}}\nSo now I am forced to create different code paths for submitting a urlencoded form or a JSON, which is not an acceptable option. Any help here?\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Length is kinda a special event, mostly used to listen to add and remove without having to bind to both.  Can you let me know how listening to this on a nested list makes your life easier?  If you do, we'll pull it.  Thanks!\n. Anyway you can create a fiddle or a test?\n. This looks like the same type of issue as  #55.\n. @daffl Are these commits to master?  Please review any API changes with me.  It seems like you created a .observe?\n. This breaks against arrays (which are valid).  Also, isPlainObject is not implemented in other libraries.  And, this pull needs a test.  I'm not sure how to re-open this request.  We might need to re-create it.\n. Thanks for the patch! \n\nBtw, did you know that computes with other computes already work as long as the compute only gets its values from an observe?\nA minor issue with this might be that a compute that gets value from a compute that only gets its values from an observe like:\nvar me = new can.Observe({ first: \"Justin\", last: \"Meyer\"}),\n      fullName = can.compute(function(){ return me.attr('first')+me.attr('name') }),\n      greeting = can.compute(function(){ return \"Hello\"+fullName() })\nIn this situation, my guess is that greetings change event will fire twice on something like me.attr('first',\"Noah\").\nDoes it?\nIf not (probably because can.compute remembers the old value and compares), then ignore this problem. But, can you add a few comments about how this works?  Something about how when reading a value you can tell __reading which object and value is being read (or something similar).  \nThanks again?\n. Closing as duplicate of #121\n. I dislike quotes within quotes.  I purposefully wanted to ignore matching against values with spaces to make the syntax appear more easily.  This is because I've only ever needed rather basic delegate rules on observes.\nBut, I think this is a good change.  I need to schedule some time with you to see what you are building and how you are using delegate.\n. I think it's intended that way?  How are you using it? \nSent from my iPhone\nOn Oct 19, 2012, at 5:15 AM, Anthony Mann notifications@github.com wrote:\n\nSelectors containing wildcards are only firing the first change notification in a single batch:\nSee fiddle: http://jsfiddle.net/2L74R/2/\n\u2014\nReply to this email directly or view it on GitHub.\n. I typically don't want this. If a change event happens I typically update the dom, I don't want to update it multiple times.\n\nAre you intending to branch in your handler?  How?\nSent from my iPhone\nOn Oct 23, 2012, at 11:33 AM, Anthony Mann notifications@github.com wrote:\n\nSo i would like to fix this issue, but it seems to be in conflict with the following:\nThis test: https://github.com/jupiterjs/canjs/blob/master/observe/delegate/delegate_test.js#L168 is preventing the issue from being fixed. Why should compound sets only be notified of the first change in a set that matches either selector? Surely we should be firing all events that match either selector, even within a batch.\nI will happily create a pull request that changes compound sets and wildcards to be matched all events from a single batch.\n\u2014\nReply to this email directly or view it on GitHub.\n. @MrNibbles can you ping me on skype (justinbmeyer) or irc?\n. Thanks! We will fix this soon.\n. What do you mean by \nYou can now pluralise event names\n\n?  We're going to release 1.1 next week and I'm trying to get a handle on all these pull requests.  Do you have some time to go over the background of these awesome delegate improvements?\n. An interesting idea. So changes would listen for every event or just one?\n. For can.transaction() ... it was firing a changed event.\n. A few things to consider:\n1.  We can probably change the current behavior.  Now's a good time b/c we are releasing 1.1.  I want to get it right.\n2.  I'm wary of \"change\", \"changed\", \"changes\" as different event types.  That's  a lot to know.\n3.  We need to think about bind on change vs changes events.  These should be similar.\nI think we should document this in a gist or wiki and list a few examples for each case. \nHow many times is each callback fired (1,2,3)?\n``` javascript\nobs.bind('change', func)   \nobs.delegate('*','change',func) \nobs.bind('changes', func)          \nobs.delegate('*','changes', func) \nobs.bind('changed', func);\nobs.delegate('*', 'changed', func); // not supported yet\nvar t = can.transaction()\nobs.attr({first: \"Taylor\", last: \"Swift\"});\nsetTimeout(function(){\n  obs.attr(\"favorite\", true);\n  t();\n},1000);\n``\n. Assuming we made \"change\" only once perbatchNumchange, What wouldobs.bind('change', func)` even respond with?\n. You might want to sign up for Zoho, it's where we have these discussions.  All the other discussion on this topic is there.  I want to respond to your feedback, but won't because I'd want everyone else to see it.\n. @MrNibbles We've been thinking about delegate for 1.1 a lot.  There's been so much debate that we are unfortunately going to punt.  We are going to keep things the way they are for now, and start experimenting with what we want this functionality to look like.  It was taking us too long to get a consensus but we need 1.1 out for JMVC 3.3. \nThe core issue is that delegate was designed by me to match state.  This is what I find useful, but jQuery's delegate with events just matches against an event.  The doc not being very clear doesn't help much either.\nWe need, I fear, to start from scratch, to design both cases.  We're closing all existing Observe.delegate related issues an grouping them in a new combined issue.\nI REALLY appreciate you submitting this patch.  It's awesome to get fixes.  We just need to make sure they aren't breaking the other, existing use case.\nWhen this issue is created, we'll start posting our ideas and APIs for what Observe.delegate should look like.\nThanks again.\n. Thanks! Will fix soon.\n. Your example isn't exactly right w/o the defaults plugin.  But I'm about to fix calling the base constructor method.\n. Suggestions on what to call it?  We should probably do the same thing for model instances.\njavascript\ncan.Model({\n  modelsAttr: 'recipes',\n  modelAttr: 'recipe'\n},{})\n. I like that idea ...\n. It still needs to be documented. \n. Are you changing those properties?  I tend not to.  Plus, list doesn't support this.\n. Can those properties be accessed via .attr ?\n. CanJS doesn't override $.fn.html if you just pass it a string.  Are you sure this is a problem with CanJS?\nAlso, why would you ever have a script tag like this?\n. Canjs core does not do that. You might be thinking of the modify plugin?\nThe modify plugin can be changed because can.view only needs to operate on doc frags. \nSent from my iPhone\nOn Oct 30, 2012, at 5:41 PM, noah notifications@github.com wrote:\n\nSure it does. html always goes through modify and this:\nif ( hasHookups && args[0] && isHTML(args[0]) ) {\nSo html(string) will end up converting that HTML to a fragment if there are any pending hookups, which happens in practice (in our app) pretty often.\nWe have script tags in our legacy HTML that we load. We have a huge app, so we mix old style jQuery.load()s and JMVC frequently. The script tags setup the legacy dialogs, etc. and not having them execute is a problem.\n\u2014\nReply to this email directly or view it on GitHub.\n. We should add tests for ...\n\ncan.esc(false)\ncan.esc(NaN)\n. validations does not depend on model, only on observe.  It should be adding this functionality to Model similar to how attributes adds itself to model and observe.\n. The following works for me\njavascript\nsteal('can/model').then('can/observe/validations',function(){\n        var Person = can.Model({\n            init: function(){\n                this.validate(\"birthday\",function(birthday){\n                        if(birthday > new Date){\n                            return \"your birthday needs to be in the past\"\n                        }\n                    })\n            }\n        },{});\n        var p = new Person({birthday: new Date(new Date().getTime()+1000 )});\n        console.log( p.errors() );\n    })\n. ah, that was what you said should work ...\n. I think we will have to find another way to make this work.  Observe shouldn't really know much about ids.\nIf I'm reading this right (haven't pulled to test it yet) it seems the problem is you want to call:\njavascript\ntask.attr({ owner : { id : 29, name : 'Amy'}});\nAnd have that set a new Owner on the task.  Even worse:\njavascript\ntask.attr({ owner : new User({id: 29, name: 'Amy'})});\nwon't work.\nMy thought is that if there's a convert function specified by the attributes property, we should always run through the convert function.  Then we should check if the newVal is not an Observe in:\ncanMakeObserve(curVal) && canMakeObserve(newVal) && curVal.attr\nLet me know if that makes sense.\n. Why is this closed?\n. I don't think we are ever going to get to this.  I'm going to close and add a \"needs a champion\" to get it in.  It's just not priority for the core team.\n. So, I made my own test and imported andy's and this is working  in 1.2:\n``` js\n    var template = can.view.mustache(''),\n        data = new can.Map({\n            image: null\n        }),\n        url = \"http://canjs.us/scripts/static/img/canjs_logo_yellow_small.png\";\nvar frag = template(data),\n    img = frag.childNodes[0];\n\nequal( img.hasAttribute('src'), false, \"there is no src\");\n\ndata.attr(\"image\",url)\nequal(img.hasAttribute('src'), true, 'Image should have src')\nequal( img.src, url, \"images src is correct\" );\n\n```\nThis passes.  So I'm closing this issue?\n. We can open another issue that allows you to write this src=\"{image}\", but this doesn't seem to be the focus of this issue.\n. Do we have the ability to add things to the context via a helper?\nWe could have a name or var helper that takes 2 args. The first is the name of a property it will add to the current context, the second is the value. \nIt could be used like\n{{var thing .}}\nAnd then '.' could be referenced as thing in child contexts. \nSent from my iPhone\nOn Dec 11, 2012, at 2:24 PM, Austin notifications@github.com wrote:\n\n@whitecolor In your case you should just be able to do company.name and it should work. Handlebars isn't a full implementation of Mustache so it doesn't support nesting contexts and context jumping like we do.\n@moschel Brians case is valid though because if your in a nested loop like that you need the ability to hop up the stack to the parent context.\n\u2014\nReply to this email directly or view it on GitHub.\n. +1. \n. How to deal with context?\n. > One of the biggest powers of can.compute is that it performs computations in the scope of this\n\nI don't think it does.  But that makes me suspect I'm not sure what you mean.  Can you elaborate on this?\n. That syntax doesn't seem to work for the \"how to test for errors case\".\nSometimes you want to set a property even if it violates a rule, sometimes you don't want to set it until after you've tested if setting that value will cause an error.\nWith your example, this doesn't seem possible.\n. I think I'm not being clear ...\nI need to be able to \"test\" if setting the computes value will create an error.  Any cached value or errors would not help.\n. Moving to #1111.\n. Something like: scanner.before(function(template){ can't work with loading pre-processed templates. We would only be able to return a string.  Thus, it might work more similar to:\n``` javascript\n// registers a callback for when an attribute is matched\ncan.view.attr(\"value\", \n// callback is called during parsing and \"function\" generation.\n// this gives the user the ability to edit the compiled function\n// scanner - the scanner ... allows us to modify the generated \"function\"\n// contents - \"value='{{name}'\"\nfunction(  scanner, contents ) {\nif( contentsHasATemplate ) {\n    // insert needs to close _v1ew.push\n    scanner.insert( \"can.view.twoway.value( template, \"+contents+\");\"\n  }\n  // can modify the template if necessary, not necessary here\n  return contents;\n})\ncan.view.twoway.value = function(template, contents){\n// template might provide helpers to turn {{name}} into \nvar propName = template.getProperty(contents);\n\n// template might provide helpers to get the current context\nvar context = template.getContext()\n// registers a callback to run once the element \ntemplate.hook(function(el){\n\n  can.bind.call( can.$(el), 'change', function(){\n    context.attr(propName, el.value )\n  })\n})\n\n}\n```\nThere's probably a way to pretty this up ...\n. Another example ... hooking up a control:\nhtml\n<div data-control='controls/widget'\n   data-control-args='customer, name:fullName'>\n``` javascript\ncan.view.attr('data-control', function(scanner){\nscanner.insert(\"can.view.toway.control( template, \"+contents+\")\")\nreturn; // no need to add the attribute\n})\ncan.view.attr('data-control-args', function(scanner, contents){\n  scanner.insert(\"can.view.addData(\"+contents+\")\");\n})\ncan.view.toway.control = function(template, contents){\n  var control = require(contents);\n  template.hook(function(el, data){\n    new control( el, data['data-control-args'] );\n  })\n}\ncan.view.toway.addData = function(template, contents){\n  // break up contents and lookup\n  template.elementData(\"data-control-args\", DATA );\n}\n```\n. Unlikely. How a value is specified works differently in EJS vs mustache. \nSent from my iPhone\nOn Dec 14, 2012, at 4:18 PM, Jeff Rose notifications@github.com wrote:\n\nI would hope the two way binding is agnostic of the view engine.\n\u2014\nReply to this email directly or view it on GitHub.\n. can.Component branch offers everything this needs.\n. I'm not sure about that syntax.  How does it handle rejection?  How does it handle being queried about its state?  What happens when a function returns a deferred (as is the case with findAll)?\n\nEX 1\njs\nvar deferred = Todo.findAll()\ncan.stache(TEMPLATE)({deferred: deferred})\n{{#eq deferred.state \"resolved\"}}\n  {{#deferred.value}}\n    <li>{{name}}</li>\n  {{/deferred.value}}\n{{/eq}}\nEX 2\nCould we support an  {{#}} {{else}} {{pending}} {{/}} like thing in stache?\n{{#Todo.findAll}}\n  <!-- context is each item in the array -->\n  <li>\n    {{name}}\n  </li>\n{{else}}\n  <!-- context is the reason the deferred was rejected -->\n  <li>Error {{responseJSON.message}}</li>\n{{pending}}\n  <li>Loading</li>\n{{/}}\nMaking pending branch will actually be easy.  We could make some syntax that creates alternate subsections like: {{?pending}} to make that abstract.\nHowever, making the {{#}} able to deal with deferreds might be tricky.  The secret will be making them work with can.compute.read so they can be listened to.  To do this, we are going to have to weave in behavior to deferreds or if that is impossible use our own deferred library,\n. @andykant I assume there's nothing in handlebars / mustache about allowing arbitrary sub-sections?\n. @sporto can.List only works on lists, not single items or anything other than a can.List.  This is a more general solution.\nThe deferred can be passed to the view like:\ncan.view(\"template\", {todos: Todo.findAll({}), owner: Owner.findOne({})})\nHowever, I don't think in a practical sense, even Todo.findAll is going to be harmful 90% of the time as the templates are often tightly coupled to their data model.  Consider writing a template like:\n{{#each todosDeferred.value}}\n  <li>{{name}}\n         <button can-click=\"{showOwner}\">Show Owner</button>\n         {{#if showingOwner}}\n             {{owner.value.name}}\n         {{/if}}\n  </li>\n{{/each}}\nOwners could be an attribute of Todo implemented like:\njs\ncan.Map.extend({\n  define: {\n    owner: {\n      get: function(current){\n        return current || Owner.findOne({id: this.attr(\"ownerId\")})\n      }\n    }\n  }\n})\nThe nice thing about this is that you can just read \"through\" the deferred in the view.  \ncc @bmomberger-reciprocity b/c I've seen this kinda thing done quite a bit in his code base.\ncc @Bajix b/c this example shows functionality requested by https://github.com/bitovi/canjs/issues/1080\n. @sporto What is inconsistent?  Deferreds would still have a .isPending and .isResolved method like:\n{{#if todosDeferred.isPending}}\nThe .value is what would be the resolved value:\n```\n{{#if todosDeferred.isPending}}\n    {{#each todosDeferred.value}}\n{{/each}}\n{{/if}}\n```\nThere would probably be a .reason too.  Just like list promise's.\nIt's also possible we can make the following work:\n```\n{{#if todosDeferred.isPending}}\n    {{#each todosDeferred}}\n{{/each}}\n{{/if}}\n```\nI'm not sure what you are suggesting / saying.\n. Is anything really \"necessary\"?  We add features to make things easier. \nYou can not easily accomplish a deferred's entire pending/resolved/rejected/value/reason state with the define plugin. I've tried it, it's very difficult. \nIf you want an app with good error handling and have Ajax requests do not fit into lists, you'll know the pain of this situation. \nSent from my iPhone\n\nOn Aug 28, 2014, at 1:57 AM, Bajix notifications@github.com wrote:\nIs it even necessary to support this kind of functionality? In almost all cases you could utilize asynchronous getters/setters to create belated change events, at which point this is a simple matter of using section helpers. It's perfectly valid as well to both return a placeholder value (false maybe?), and later call setValue on done to force the section helper to inverse while pending.\n\u2014\nReply to this email directly or view it on GitHub.\n. A promise/deferred is already an observable control flow structure. We aren't attaching observability, we are simply making it visible to the view and to computes. \n\nTo make deferreds visible, all they need to do is call can.__reading. So there will be no overhead. \nWe are going to probably make everything observable with dirty checking eventually. Having as many types of things observable to the view as possible is a good thing. \nPlease share the compute that wraps the pending/resolved/value/rejected/reason state of a compute. I think after writing it, you will see why simply allowing promises would be way nicer. The reason is that you essentially have to recreate the promise structure. \nSent from my iPhone\n\nOn Aug 28, 2014, at 4:09 AM, rjgotten notifications@github.com wrote:\nIs it even necessary to support this kind of functionality?\nIt isn't and it also shouldn't be created.\nYou don't want the overhead of observability attached to a general purpose flow control construct such as a Deferred object, which can be used in lots and lots of other parts of code than just the line of data that is fed to your view bindings.\nAs I commented in #1207, if you really want observable result values from a Deferred object, you should wrap a custom can.compute around the deferred beforehand while preparing your view model.\nI reached the same conclusion you did; there's no reason you couldn't accomplish this with an asynchronous setter (through can.compute.async).\n\u2014\nReply to this email directly or view it on GitHub.\n. Having FRP (bacon) support in the view creates the same problems people are worried about as having promises. (But that's not to say we shouldn't support FRP, instead we should)\n\nTo me, a promise is state, plain and simple. If state changes, the view should be able to update itself. \nWaiting for promises to resolve before rendering is exactly the type of problem I want to solve. \nI think the concerns about breaking layer boundaries are valid. It can happen, but there are many cases where a deferred is part of the view-model and we shouldn't shy away from making this very useful feature because someone might blow their hand off. Consider angular where the view can define and add to the view model. \nSent from my iPhone\n\nOn Aug 30, 2014, at 4:01 PM, \"Brad (Bradley) Momberger\" notifications@github.com wrote:\nI actually agree with @gsmeets on this one. In GGRC, we mostly abstract the use of deferred away from the view layer. Even though we support a {{#defer}} helper that takes a deferred and renders when it resolves, it's rarely used. We prefer the more abstract {{#using}}, which syncs a stubbed object/list property of another object from the server, or {{#with_mapping}}, which refreshes a mapping (defined path through the object graph which yields a list) attached to an object.\nReally it seems to me that this is the problem that Bacon.js is at the ready to resolve. All your deferred objects are really iterators on streams waiting for data. Thus any deferred operation is really just a list iterator with a defined terminus. The view layer should treat the deferred as an iterator. {{HasNext}} (or {{pending}}) is true until the deferred resolves, false after resolution. Errors on the deferred pass an error as the final iteration (there are likely no success case iterations that happen, in this scenario), which can be caught with a special section, e.g. {{onError}}.\nDid this make sense to anyone else?\n\u2014\nReply to this email directly or view it on GitHub.\n. @gsmeets Thanks for your thoughts.  \n\nnew Foo would be semi-impossible to make work and be what people would expect in certain situations.  Consider what would happen if two instances of a model with the same id was desired?\n``` js\nt1a = new Task({id: 1})\nt1b = new Task({id: 1})\nt1a !== t1b\n```\nThis is different from how can.Model.findOne currently works:\njs\n$.when(Task.findOne({id:1}), Task.findOne({id: 1}) ).then(function(t1a, t1b){\n   t1a === t1b\n})\nThis is why promise support is the most elegant and simple (less APIs to add) way of handling this situation.\n. I'm not sure what you mean. If there's an issue/limitation to the define plugin, please describe it in another issue. \nSent from my iPhone\n\nOn Sep 8, 2014, at 9:16 AM, Guido Smeets notifications@github.com wrote:\nConsider what would happen if two instances of a model with the same id was desired?\n[..]\nThis is why promise support is the most elegant and simple (less APIs to add) way of handling this situation.\nOne of the confusing things about the define plugin is that this is exactly what happens if you were to add a Type and a setter function.\nIdeally what I want is to be able to pass an ID to my viewmodel, which in turn expands that into a full model by fetching it from the server. I'm currently refactoring a bit to make this possible. But the weird thing is I need to drop my explicit type definitions to get this to work. Otherwise the Type converter will have already converted my single id into a can.Map before I'm able to touch it in the setter function.\n\u2014\nReply to this email directly or view it on GitHub.\n. @rjgotten I like adding switch.  \n\nI was thinking that value, state, and reason would be special keys like @index and @key.  This makes sense b/c they are not actual properties on the promise.  This allows one to write it like:\n{{#with foo}}\n{{#switch @state}}\n  {{case \"pending\"}}\n    <span class=\"busy\">Loading: {{@progress}}% complete</span>\n  {{case \"rejected\"}}\n    <span class=\"error\">Unexpected error: {{@reason}}</span>\n  {{case \"resolved\"}}\n    {{#if @value}}\n      <span class=\"success\">{{@value}}</span>\n    {{else}}\n      <span class=\"empty\">No result found</span>\n    {{/if}}\n{{/switch}}\n{{/with}}\n. @rjgotten On:\n\nThose special keys make it look kind of nice, I admit. But that ties the interpretation of deferreds as computes back into the view engine, which takes away the possibility of establishing entire chains of computes that have 'deferred computes' as part of them.\n\nI'm not sure what you mean.  That syntax does not mean that a compute could not update itself when a promise changes.  A promise's .then method would call can.__reading.  Things like @rejected would hook into .then.\n. > I maintain that a user-controlled wrapping point where observability is added is the best solution that strikes a balance between usability and performance.\nIn my opinion, there's no need to strike a balance with performance. can.__reading is extremely light.  It will not slow any conceivable app down. \nhttps://github.com/bitovi/canjs/blob/master/compute/compute.js#L76\nstack.length would be 0 unless you were in a compute / view.  We'd be adding one function call and branch per promise (that wouldn't be in a compute).  You'd have to have 1000s of same-exectuation-thread .then calls to make a difference.\n\nThat does not yet cover promise-like results from every other library under the sun that returns its own flavor of 'thenables'.\n\nYup, those other libraries could convert those promises to the compatibility library's promise for observability.\n. Edit: to make jQuery work, there will probably also have to be an extra function call and a property assignment when any deferred is created.  This still will very likely not be enough to impact the performance of any application.\n. You can always wire that up yourself with can-inserted like:\n{{#if promise.isRejected}}<span class='rejected' can-inserted=\"{doSomething}\">{{promise.reason.message}}</span>{{/if}}\n. canComponent branch with can.view.Scope allows this kind of thing.\n. This doesn't really seem needed. You can easily use $.when and get the data and use it to render. \nSent from my iPhone\nOn Nov 29, 2012, at 1:52 PM, Basem Emara notifications@github.com wrote:\n\nIt would make sense to add the resolved data models in the callback of the view like this:\ncan.view('todos/todos.ejs', { \ntodos: Todo.findAll(), \nuser: User.findOne( { id: 5 } ) \n}).then(function(frag, data){ \nme.element.html(frag); \n//myFunction(data.todo); \n});\nThe data parameter does not exist in the API like above, but it would open doors if it could. Passing the data in the callback on line 361 of view.js did not work. Please see this forum thread for more details: https://forum.javascriptmvc.com/topic/get-model-in-view-callback-28-11-2012\n\u2014\nReply to this email directly or view it on GitHub.\n. I would think maybe:\n\njavascript\n$.when( \n  Todo.findAll(), \n   User.findOne({id: 5})\n  can.view.get('todos/todos.ejs') )\n  .then(function(todos, user, renderer) {\n  el.html( renderer( {todos: todos, user: user} )\n  // myFunction(todos, user)\n})\n. I don't think this is much of a problem now.  Live-binding tears itself down w/ the component, so it's rare that this would be a problem.  Closing.\n. This is expected ... however, destroy should also look like:\ndestroy: 'POST /users/{userId}/delete'\n});\nclosing ...\n. This is expected ... however, destroy should also look like:\ndestroy: 'POST /users/{userId}/delete'\n});\nclosing ...\n. This is expected ... however, destroy should also look like:\ndestroy: 'POST /users/{userId}/delete'\n});\nclosing ...\n. Reopened b/c we should update our docs to show this as the standard way of sending data.  We shouldn't show a vulnerability.\n. http://canjs.us/#can_model-findall\n. Nope, care to submit a pull?\nSent from my iPhone\nOn Dec 3, 2012, at 4:09 AM, Jeff Rose notifications@github.com wrote:\n\nI noticed that hashchange.js is jQuery hashchange 1.2 even though 1.3 is available. Is there a reason for not updating?\n\u2014\nReply to this email directly or view it on GitHub.\n. Check the list fiddle I tweeted for an implementation. \n\nSent from my iPhone\nOn Dec 4, 2012, at 7:24 AM, David Luecke notifications@github.com wrote:\n\nIt should be possible to replace on list with another so that list Controls can be initialized like this:\ncan.Control({\n    init : function () {\n        this.list = new Recipe.List();\n        this.element.html(can.view('list.ejs', list));\n        list.replace(Recipe.findAll());\n    }\n});\n.replace can take an array, another can.Observe.List or a Deferred.\n\u2014\nReply to this email directly or view it on GitHub.\n. @iamnoah Thanks for reporting this issue.  And thank you for all your active contributions to CanJS. This is a very interesting issue.  @moschel and I debated for a few hours tonight, tried different things and came to the difficult conclusion to close this as a wont-fix.  The following is why:\n\nThe short answer is: \nhttps://github.com/bitovi/canjs/pull/141\nThe longer answer:\n\nWe chose flexibility over what's possibly the more common and expected pattern (for now). \n\nHere's the problem. For 1.1, we decided that:\njavascript\ntask.attr({ owner: {name: \"Justin\"})\nMerges name: \"Justin\" into owner, while:\njavascript\ntask.attr({ owner: new User({name: \"Justin\"}))\nreplaces owner with the new User. This last behavior had been requested a few times, made things more flexible, was reasonable, so we added it for 1.1. \nCanJS's attributes plugin seems like (and is documented as such) it is used to specify a \"type\".  For example, with static properties like ...\njavascript\nattributes: {\n  owner: \"owner\"\n},\nconvert: {\n  owner: function(data) {\n      return data instanceof Owner ? data : new Owner(data);\n  }\n}\n... it is more than reasonable to expect that ...\njavascript\ntask = new Task({ owner: {name: \"Justin\"})\ntask.attr({ owner: {name: \"Brian\"})\n... would work like the previous example and simply update the owner's name to \"Brian\".  We could accomplish this by not running converters if the new value is an object and the current value is an Observe. This again seems reasonable if you're looking at attributes specifying a type.\nWe set about making this change, but then discovered that it broke the test from #141. #141 tests that the new value will always be a model from the store.  You had already identified this as the source of conflict. \nFor now, we are favoring flexibility. #141 is a less obvious use-case than what you are doing, but still one we want to support.  David's fiddle (http://jsfiddle.net/APMUc/2/) shows that it is possible to have converters do the expected behavior:\njavascript\nowner: function(data, oldVal) {\n  if(oldVal instanceof Owner) {\n    return oldVal.attr(data);\n  }\n  return new Owner(data);\n}\nWe're going to update the documentation to promote the fact that 'attributes' specifies a converter, a function that gets called with the new value no matter what and can decide to do anything.\nFor future releases, I'm happy to look at an alternative \"type\" specifier that works more closely to what this issue requests.  \nThanks again for all your contributions to CanJS. Hopefully you'll be able to update your converters to use this pattern without many problems. Thanks,\nJustin + Brian\n. People can overwrite the can module to require other things.\nI don't think we should remove the global can:\nhttps://twitter.com/TalentedMrJones/status/309481689468506112\n. on can/compute, it should be made to work without can/observe, but be able to work with it if it's present.\n. I think GLOBALCAN is a good enough solution for now.  If someone has problems with this, we can add can.noConflict() type thing that restores the original can.\nI'm not sure why AMD would complain though ... as long as you are using the can passed to you, you should be fine.\n. Wrap it how?\nOn Dec 17, 2012, at 7:15 AM, xjailbreaker notifications@github.com wrote:\n\nhttp://www.jqmobi.com/ - is the fastest of jQuery-family library in the world, it should be very great if CanJS will wrap it too!\n\u2014\nReply to this email directly or view it on GitHub.\n. Adding properties to a list isn't really supported.\n. For example:\n\n```\n    var list = new can.Observe.List([\n        { first: 'Justin', last: 'Meyer'}\n    ]);\n    var map = new can.Observe();\nmap.attr('nameMap', {\n    justin: list.attr(0)\n});\n\nok(map.attr('nameMap.justin') === list[0], \"same instance of an observe\" );\n\nmap.bind('nameMap.justin.last', function() {\n    ok(true, 'nameMap.justin.last changed:');\n});\n\nlist.bind('0.last', function() {\n    ok(true, '0.last changed');\n});\n\nmap.attr('nameMap.justin.last', 'foo');\n\n```\nthis works ... please re-open if this doesn't make sense.\n. This problem is typically caused by someone changing an observe within call to render the view.\nFor example:\nhtml\n<div class='<%= helper1() %>'>\n  <div><%= helper2() %></div>\n</div>\njavascript\nhelper1 = function(){\n  return obs.attr('name')\n}\nhelper2 = function(){\n  obs.attr('name')\n  return \"HERE\";\n}\nWe might be able to fix this by deferring the binding (https://github.com/bitovi/canjs/blob/master/view/render.js#L224) until the actual \"hookup\" code that sets update has been performed.\n. Is there a way to update a textarea's reset value?\n. The delegated object (what's inside {}) is always first, followed by bind args. \nSent from my iPhone\nOn Jan 23, 2013, at 5:23 PM, David Luecke notifications@github.com wrote:\n\nHm, the Control bindings for observes (what you show in the screenshot) have a different signature than if you bind directly using observe.bind, so the signature for can.route.bind is correct (I just tried it in a Fiddle).\nI have to admit that I'm often confused about the correct signature, too. Using things like event.target and event.currentTarget seems more straightforward to me than having to look up once again what exactly is being passed to the event handler.\n\u2014\nReply to this email directly or view it on GitHub.\n. I think this makes sense if easy to implement. \n\nSent from my iPhone\nOn Jan 9, 2013, at 3:06 PM, \"Brad (Bradley) Momberger\" notifications@github.com wrote:\n\nThe spec doesn't seem to cover context nesting; it just says that a partial inherits the current context, but it also says the same for a section (which, in CanJS's Mustache, does inherit the stack).\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes. \n\nOn Jan 10, 2013, at 5:48 AM, Alex Osh notifications@github.com wrote:\n\nIf there is a model with let stay:\ncreate: '/some/endpoint/{attrib1}/{id}'\nmodel's attribute attrib1 is not included in the POST request body. Is it by design?\n\u2014\nReply to this email directly or view it on GitHub.\n. I think model already adds any other properties.  Unfortunately, only jQuery's deferred seems to support multiple arguments when resolving.  But, you can overwrite created or destroyed and get access to the jqXHR object:\n\nhttps://github.com/bitovi/canjs/blob/master/model/model.js#L107\njs\ncan.Model.extend({\n  created: function(data, jqXHR){\n    this // -> created instance\n  }\n})\n. Is this documented on donejs.com?\nSent from my iPhone\nOn Jan 18, 2013, at 6:34 AM, David Luecke notifications@github.com wrote:\n\nLike I said in your forum post and demonstrated in this Fiddle, this is already implemented if you extend from MyItemClass.List.\nI will close this issue. Please reopen if this doesn't answer your question.\n\u2014\nReply to this email directly or view it on GitHub.\n. Something like model's CRUD methods and getter / setters ish things, but with push / splice etc.  Sounds good.\n\nStart designing the API.  It should be similar to what's there now on Observe.\njavascript\ncan.Observe.List({\n  add: function(items, success, error){\n    // do stuff\n  }\n})\n. You could do that in a define setter currently.\n. moving to can-define.\n. Can someone add a test for that?\nSent from my iPhone\nOn Jan 28, 2013, at 1:03 PM, \"Brad (Bradley) Momberger\" notifications@github.com wrote:\n\nWith the 1.1.4-pre version of CanJS, the workaround of putting the full attribute name and value in the block no longer works.\n\u2014\nReply to this email directly or view it on GitHub.\n. Yeah, this is a very hard, if not impossible fix without parsing JS. \n\nSent from my iPhone\nOn May 10, 2013, at 11:17 AM, Andy Kant notifications@github.com wrote:\n\nRecently ran into a similar issue while migrating a JMVC 3.1 codebase to latest. The workaround seems to be what Curtis mentioned (adding extra EJS tags to separate lines). It seems that EJS loses track of the number of brackets being opened and closed somewhere along the line.\nThis will generate a bad template:\n<% if (awardCodeList && awardCodeList instanceof Array) { %>\n        <% if (true) { %>\n                hi\n        <% }\n } %>\nWhereas this is a good template:\n<% if (awardCodeList && awardCodeList instanceof Array) { %>\n        <% if (true) { %>\n                hi\n        <% } %>\n<% } %>\n\u2014\nReply to this email directly or view it on GitHub.\n. Problem is, what if they try to insert the same template twice. \n\nSent from my iPhone\nOn Jan 19, 2013, at 7:02 AM, Mihael Konjevi\u0107 notifications@github.com wrote:\n\nThis change allows passing of document fragments directly to the template layer. They are live bound as they are never converted to the string. It allows syntax that looks like this:\nvar renderer = can.view.mustache('{{{ subview }}}');\nvar subview = can.view.mustache('Subview {{ foo }}');\nvar foo = can.compute(\"FOO\")\nvar div = document.createElement('div');\ndiv.appendChild(renderer({\n    subview : function(){\n        return subview({\n            foo : foo\n        })\n    }\n}));\ndiv.innerHTML // Subview FOO\nfoo(\"BAR\")\ndiv.innerHTML // Subview BAR\nYou can merge this Pull Request by running\ngit pull https://github.com/bitovi/canjs render_fragments_in_templates\nOr view, comment on, or merge it at:\nhttps://github.com/bitovi/canjs/pull/244\nCommit Summary\nImplement support for rendering document fragments returned from the renderer function in the Mustache and EJS templates\nFile Changes\nM view/view.js (6)\nM view/view_test.js (34)\nPatch Links:\nhttps://github.com/bitovi/canjs/pull/244.patch\nhttps://github.com/bitovi/canjs/pull/244.diff\n. I'm not totally clear. A demo fiddle might help a lot. \n\nSent from my iPhone\nOn Jan 22, 2013, at 11:05 PM, Alex Osh notifications@github.com wrote:\n\nThe idea is: Models are uniquely identified by ID. So if you get model data with the same id Can assumes that it is the same model and will update the store.\nOk that is very good point. I just don't undertand how nested lists where updated that caused the issue?\nMy particular case:\nI load from server a model, model contains nested list of items. Then I decide to synchronize model state with server, I load again the same model (with the same id). Between this two syncs new item was added on server to DB to the list. So I get new model with updated list that contains one new item. Items in the list say may have or have not field called 'finished', new item doesn't have it, but after loading can.Model adds this field (\"finished\") to new item and takes the value from first item of the list that where loaded previously.\nI hope I made my self clear.\n\u2014\nReply to this email directly or view it on GitHub.\n. Why did we do it this way? If you want those properties emptied, just have nulls in your json.\n. @moschel Link to the forum?\n\nAlso, I think overwriting serialize is exactly why we have it there.  Otherwise, it doesn't provide any functionality over .attr().\n. This should be fixed by the define plugin.\n. This is what's expected, you should be calling \njavascript\nstate.attr('arr').replace([\"c\"])\nThe existing functionality is there so:\n```\nvar objs = new List([{name: \"Justin M\"}, {name: \"Brian Moschel\"}])\nobjs.attr([{name: \"Justin Meyer\"}])\nobjs //-> [{name: \"Justin Meyer\"}, {name: \"Brian Moschel\"}]\n```\nworks ....\nI think the \"real\" problem is that \"remove\" should be the default and \"merge\" should require an extra param for both Observe and List.  Unfortunately, this is the sorta thing we can only change in a 1.2.\n. I think we should reverse the default behavior of merge / remove.\n. But, we shouldn't have one behavior for lists and another for objects. That's confusing. \n. Some people don't expect merge to happen on objects.  Doing things the same way is a super crazy important part of API design. I'm not going to violate that easily.\nFor now, you can overwrite model to do whatever you want it to do.\n. If you figure it out, we'd accept a patch setting this up for canjs. \nOn Mar 5, 2013, at 5:51 PM, Javier Martinez Fernandez notifications@github.com wrote:\n\nHow is this being done by jquery team?\n\u2014\nReply to this email directly or view it on GitHub.\n. Related: https://github.com/bitovi/canjs/commit/58a066271b5abb71d7e75dfcbd2f8dda2bb622b6\n. This is already possible by creating 2 routes. \n\nSent from my iPhone\nOn Jan 24, 2013, at 5:48 PM, nanotronic notifications@github.com wrote:\n\nLike backbone: \n\"A route of \"docs/:section(/:subsection)\" will match #docs/faq and #docs/faq/installing, passing \"faq\" to the action in the first case, and passing \"faq\" and \"installing\" to the action in the second.\"\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm not convinced it would be far better. Those aren't regexps. Are you using can.route directly or via control \"route\" events?\n\nBackbone's routes don't set state, they just match a URL. CanJS's routing system is much different. \ncan.route(\":foo\")\ncan.route(\":foo/:bar\")\nYou can do both already with one line like:\ncan.route(\":foo/:bar\",{bar:'\"\"})\nSent from my iPhone\nOn Jan 24, 2013, at 5:57 PM, nanotronic notifications@github.com wrote:\n\nI know, but its a little bit cumbersome...\nFar better would be RegEx-Routes.\n\u2014\nReply to this email directly or view it on GitHub.\n. Please post how you've done it, but I'm closing the issue because it's already possible via can.route(URL, DEFAULTS) and I'd prefer people use that.\n. I'm confused by what you are saying.  Can you clean it up a bit more?\n\nAre you recommending something for CanJS? Syntax like:\ncan.route( 'goto/:page(&view=:view)(&filter=:filter)(&sort=:sort)', {page:'home', view:'list', filter: 'default', sort: 'default'});\nOr are you asking about some plugin?\n. I bet the specification has something to say about this. \nIf not, I'm not sure the helper would have higher priority.  It might be more expensive to change a bunch of item's property names than to alias a helper.\n. Can you create a fiddle showing this because I'm not understanding what you mean exactly. \nSent from my iPhone\nOn Jan 28, 2013, at 9:55 AM, Richard Jones notifications@github.com wrote:\n\nFor links containing hash fragments like\n\nThe URL gets set to /articles/17%23references and window.location.hash == ''\n\u2014\nReply to this email directly or view it on GitHub.\n. It should matter in the same way (I think) that rail's routes matters.\n. There might be no reason. \n\nSent from my iPhone\nOn Feb 5, 2013, at 7:02 PM, David Luecke notifications@github.com wrote:\n\nAh looks like it is because of the special handling for the length attribute (it doesn't bubble).\n@justinbmeyer What was the reason for that again?\n\u2014\nReply to this email directly or view it on GitHub.\n. I've left some newlines in so debugging should be a bit easier.\n. Part of the issue is:\n\njs\ncan.route.attr({notifications: {messages: true}})\nYou are passing a non-string value, but this gets added to the hash, which converts it to a string, hence the double change.\nWe could try to force every incoming value to a string in can.route.\nCan you create a test?\n. I think you can fix this with the define plugin:\n```\nvar RouteState = can.Map.extend({\n  define: {\n    messages: {\n       type: \"boolean\"\n    }\n  }\n})\ncan.route.map(new RouteState);\ncan.route.ready()\ncan.route.bind(\"messages\", function(){})\ncan.route.attr(\"messages\", true);\ncan.route.attr(\"messages\", false);\n```\n. Can you use the attributes plugin with a converter?\n``` javascript\nThing = can.Observe({\n  attributes: { special : \"object\" }\n  convert: { object: function(newVal){ return newVal })\n},{})\nthing = new Thing({special: {foo: \"bar\"}})\nthing.attr('special') instanceof can.Observe //-> false\n```\nIt's my understanding now that converters are always called and if they are present whatever they return (observe or not) is what's set as the Observe's property.\n@moschel ?\n. I think we changed the meaning of convert to not do that anymore.  @moschel  ?\nIf convert worked that way, it would be capable of providing pretty much anything anyone wanted ... defaults, observe conversion or not.\n. @moschel It would be good to get this in 1.2.\n. This would be a breaking, although useful change.  I'm going to add this to 3.0.\n. Interesting, I'm surprised that the first\njavascript\nobserve.attr({notifications: {users: 10}})\ntriggers a notifications.users event at all.  I would assume it would only trigger a notification event.  It seems like it was, but being called notifications.users.\n. I just looked into this.  I'm not sure what to do about this.  Here's the central issue:\njavascript\nvar foo = {}\n$(foo).bind(\"one.two\", function(){ console.log('1.2')})\n$(foo).bind(\"one\", function(){ console.log('1')})\n$(foo).trigger(\"one\")\n// -> 1.2\n// -> 1\nThe problem is that jQuery's event system will dispatch a \"one\" event to listeners \"one\" and \"one.two\".  \nWe use this functionality in a few places (for observe's bubbling), but not enough so we need it.\nWe can either ...\n1. Use our own trigger that does not do this and \n   remove where we depend on this behavior\n   - Faster dispatching\n   - slightly bigger download\n   - might not work perfectly with jQuery's event system.  Say a component \n     triggers events on an object, can we listen to them. We might be able to \n     get around this by having an extra param on can.bind that says only match \n     the full event name. This param would be used by Observe's bind.\n2.  Wrap all observe binds in some magic that doesn't call the original callback\n   - another function !\n. I say we leave jQuery's event system for can.Map in 1.2.\n. something is probably not checking for undefined / null correctly\n. I bet that behavior is specified by Mustache\n. Start the project! What should we call it? What should it's api look like. I'm a big fan of can's short name:\njavascript\ncan.each()\ncan.bind()\ncan.trim()\nAs this is an effort similar to underscore/lowdash, it should have a short name.  Maybe \"u\" for \"universal.js\":\njavascript\nu.each()\nu.bind()\nu.trim()\nThe initial API should be something we can do:\njavascript\nvar can = {};\nu.extend(can,u);\nIt should use AMD so you can pull in things like:\n``` javascript\nrequire(['universal/core','universal/events'], function(u){\n})\n```\n. I think that goes against the trends in JS APIs. Most APIs are tending towards a few methods that do a lot.\n. Getting users is a huge concern for an open source library. I think even library builders are willing to trade 1/100th of a ms for a quick type detection and branch between two versions of each. Many libraries are built around jQuery.\nBut we can likely have our cake and eat it. We can have typed methods when necessary and still have u.each:\njavascript\nu.each()\nu.obj.each()\nu.arr.each()\nWe could make an \"api\" module that would go through each type and move all those methods to u.  If there was a conflict, it would setup a branching function based around the argument's type.\nI think jQuery's problem isn't that it's got a clever API, it's that it has always been \"built\" as a single file.  If it started with AMD (or steal), it could have the same API but be quite modular.\n. You should not have dummy links with #, javascript:// is better but still wrong. \nPrevent changing the hash with preventDefault()\nOn Feb 17, 2013, at 12:55 PM, DVSoftware notifications@github.com wrote:\n\nBreaks many places where \"#\" is placed as a dummy href and are handled through click events. It can be prevented with stopPropagation() but then it won't propagate to its parents. This fixes my case, but i'm not sure if it's desirable for others.\nYou can merge this Pull Request by running\ngit pull https://github.com/DVSoftware/canjs patch-1\nOr view, comment on, or merge it at:\nhttps://github.com/bitovi/canjs/pull/285\nCommit Summary\nDon't treat links to \"#\" as \"/\"\nFile Changes\nM route/pushstate/pushstate.js (18)\nPatch Links:\nhttps://github.com/bitovi/canjs/pull/285.patch\nhttps://github.com/bitovi/canjs/pull/285.diff\n. What do you mean catches them?  The route will change unless preventDefault is called, not stopPropagation. \n\nIt's not wrong to respond to changing the hash to #. If the hash changes, can.route should respond to it, whatever it is. Otherwise back button and bookmarking won't work as expected. \nOn Feb 17, 2013, at 1:18 PM, DVSoftware notifications@github.com wrote:\n\nBut it still catches them, unless i call stopPropagation(), which in my case breaks catching the outerclicks (i listen to clicks on body, to close modal windows etc), as it doesn't propagate further. I could change to \"javascript://\" but i kinda still think it's wrong to treat \"#\" as \"/\" route (at least with pushstate).\n\u2014\nReply to this email directly or view it on GitHub.\n. THis looks good.\n. Thanks ... but does this work w/o model and such?\n. Meaning, if you removed the model bits, does it still break?\n. I worry about basic apps. Those using can/control/route. \n\nOn Mar 5, 2013, at 10:08 AM, David Luecke notifications@github.com wrote:\n\nFor 1.2 we should default can.route.ready to always be false and let the user initialize routing in any case.\nWhen to use can.route.ready and when not seems to cause quite a bit of confusion and in almost every case you need it anyway. Plus we can get rid of the rather hacky document ready detection (which had to be added because the document ready handler in libraries other than jQuery doesn't get called if the document is ready by the time it is attached).\n\u2014\nReply to this email directly or view it on GitHub.\n. You can make a download without can/route. That should solve the issues you're having.\n. > If I don't use the complicated routes with parameters, it doesn't happen, but then i also can't use those features. I'm using the AMD / RequireJS version, not the downloaded bundle.\n\nWhat do you mean?  \n\nBTW, this bug ...\n\nThis issue is about can.route.ready being set to false.  I'm not sure exactly what you are talking about.  However, if you think there's another bug, can you create another issue?  Also, can you carefully describe the bug? Ideally someone should be able to read the comment and know immediately what you are talking about.  Thanks.\nEDIT:\nAfter spending some time trying to understand what you meant, I'm not even sure why #!active/andthis&butthis=thisval would be a route? Nothing in the app set it that way.  There's only one route:\nhttps://github.com/addyosmani/todomvc/blob/gh-pages/architecture-examples/canjs/js/app.js#L6\njavascript\ncan.route(':filter');\nWith just this one route, I would expect a hash like #!foo/bar to get converted to #!foo%2Fbar so can.route.attr() would return:\njavascript\n{filter: \"foo/bar\", route: \":filter\"}\nI think you might be misunderstanding the idea behind can.route.  can.route isn't as much about matching a hash as it is keeping state.  \nsay, for example there were two routes:\njavascript\ncan.route(':filter');\ncan.route(':filter/:something');\nAnd the user set can.route w/ .attr() like:\njavascript\ncan.route.attr(\"filter\",\"foo/bar\")\nThe hash would have to be set to #!foo%2Fbar.  If it was set to #!foo/bar, the data would be:\njavascript\n{filter: \"foo\", something: \"bar\", route: \":filter/:something\"}\nBasically, can.route does whatever it has to so the has represents one unique state.\n. If you are using the amd version, don't require 'can' directly, create a custom 'mycan' that requires only the modules you want.\nAlso, you might be able to simply call\njavascript\ncan.route.ready(false)\nand never call .ready(true).  As you are using requirejs, to use the plugin that prevent's jQuery's ready event from firing until all scripts have loaded.\n. > If it were actually expecting those routes .... the encoding would still happen and the routes would still break.\nThat's not right.  Check out the example in #330.\nI think the best solution for @jeffreytgilbert is simply not to load can.route if you aren't using it.  Don't waste time loading code you aren't using.\nIf we should call force a call to can.route.ready() when someone has included the plugin (indicating desire of its features) is another matter ...\n. Brought here from #475.  Again, my big hesitation is that we will have to tell people they MUST call can.route.ready() to even use routing in the first place.  The getting started guide will have can.route.ready().\n. With https://github.com/bitovi/canjs/commit/520f1b96fae68e178197018c28bd1c10612ae7e5, you MUST call can.route.ready.  This will be part of 1.2.\n. This breaks some other things, specifically around what goes in the model store.  The model function does not simply \"unbox\" the response data, it put things in the store.  I'm going to fix this.\n. This rears it's ugly head again with #560 and #561.\nThis needs to be fixed, but might require some breaking API changes.\n. Do you use jQuery?  If so, you already have that.  If not, I'd ask the underlying library for something like this.\n. I think this is up for mootools to provide.  Or for someone to create a mootools plugin. I think can/util should only power what's needed by canjs.  Maybe universal could have this. But this definitely should not be part of core. \nSent from my iPhone\nOn Sep 20, 2013, at 8:22 AM, David Luecke notifications@github.com wrote:\n\nThis was why I asked to submit the issue because only jQuery seems to support that (Moootols definitely doesn't) Which is why we think it makes sense to abstract global handlers in can.ajax (which is also a frequent question although easily resolve because most people are using jQuery).\n\u2014\nReply to this email directly or view it on GitHub.\n. Also, you \"should\" be able to do something like:\n\n``` javascript\nvar observe = new can.Observe({\n    firstName: 'Sam',\n    lastName: 'Sample',\n    fullName: can.compute(function () {\n        return this.attr('firstName') + this.attr('lastName');\n    })\n});\nobserve.attr('fullName')()\n```\nBut, you should probably be doing ...\n``` javascript\nvar Person = can.Observe({\n    fullName: can.compute(function () {\n        return this.attr('firstName') + this.attr('lastName');\n    })\n});\np = new Person({\n    firstName: 'Sam',\n    lastName: 'Sample'\n})\np.attr('fullName')\n```\n... instead.\nBut this doesn't work and I think this is a more serious problem.  The reason is that the fullName property of the prototype will point to a single compute. That compute will be shared by all instances.\nThe immediate fix is to do:\n``` javascript\nvar observe = Person({\n  init: function(){\n    this.fullName = can.compute(function () {\n        return this.attr('firstName') + this.attr('lastName');\n    }\n  }\n});\np = new Person({\n    firstName: 'Sam',\n    lastName: 'Sample'\n})\nc = p.fullName //compute\n```\nor\n``` javascript\nvar Person = Observe({\n  fullName: function () {\n        return this.attr('firstName') + this.attr('lastName');\n  }\n});\np = new Person({\n    firstName: 'Sam',\n    lastName: 'Sample'\n})\nc = can.compute(p.fullName, p)\n```\nThere are a few ways we could make this easier.  But, I want to first bring this up because you probably should be creating a Constructor function that has the fullName method on it and creating new Constructor functions instead of creating a bunch of observes with the same shape, but no \"shared\" behavior leveraged via their prototype.\n. I'm going to close this because can.compute(observe, method) does the trick.\n. Here's the solution to make fullName bindable:\n``` js\nvar Person = can.Observe({\n  fullName: function(){\n    return this.attr('first')+this.attr('last')\n  }\n})\nvar me = new Person({first: \"J\", last: \"M\"})\nvar fullName = can.compute(me.fullName, me);\nfullName.bind(\"change\", function(ev, newVal, oldVal){})\n```\nIt is a different API. You can't use me.attr('fullName') or me.bind('fullName',handler).\nTo make that work, we need something other than can.compute.\n. I'm going to reopen, because although what I showed provides the same functionality, it might be nice to bind directly to fullName.  I don't know if you'll wrap with can.compute however.\n. Oh this is already in 2.0 on this commit: https://github.com/bitovi/canjs/commit/2512d5b8f78664d7e3cddc9829d05793e58df093\n. http://canjs.com/docs/can.Map.prototype.COMPUTE-ATTR.html\n. Checkout http://jsfiddle.net/jandjorgensen/mhPq7/light/ which makes heavy use of it.\n. This is a good idea.  We should review this and get it in for 1.2\n. very cool!\n. can.extend(true, ...) doesn't exist in can already right?  We don't support deep extend in all libraries?\n. That's close to the plan for can.component.\n. why?\n. Yeah, but in a working app, this would never happen.  You just want to know the error faster?\n. $(\"wrong\").html() throws no errors\nSent from my iPhone\nOn Mar 13, 2013, at 11:27 PM, Curtis Cummings notifications@github.com wrote:\n\nAn app isn't always in a working state...\nThrowing an error when the element isn't found, especially when we know that was the code's intent) tells you exactly what went wrong.\n\u2014\nReply to this email directly or view it on GitHub.\n. We could break the API and make people put a \"#\" if they want an element.  But it would only look for an element.  The existing behavior would run if there's no #.  \n\nTo solve the other guys problem, maybe something similar if we find a \"/\" ... we assume ajax request?\nOr we have to provide 2 methods.\n. I think this is sorta dead because of the ubiquity of using a loader for templates.  Closing unless there's a hero to do it.\n. Why do you want this?\n. Can you create a test and submit a pull request?  Please keep the code to a minimum needed to break things.\n. Sorry, that message should have been for  @andykant. An object would be faster than an array.\n. @bmomberger-reciprocity This seems like a duplicate of #179 - Making Deferreds Observable.  Please comment and I'll re-open if I'm wrong about that.  Thanks!\n. js\ncan.Component(\"Todos\",{\n  init: function(element, scope){\n    scope.attr('todos', [{...}, ....]\n  },\n  template: \"<ul>{{#todos}}<li>{{name}}</li></ul>\"\n})\n. js\n            can.Component(\"tabs\",{\n                    init: function(element, options){\n                        options.attr('panes',[])\n                    },\n                    addPane: function(pane){\n                        if (this.options.panes.length == 0){\n                            this.options.select(pane);\n                        }\n                    this.options.panes.push({\n                        selected: false,\n                        pane: pane\n                    });\n                    },\n                    select: function(pane){\n                        can.each(this.options.panes,function(pane){\n                            pane.attr('selected',false)\n                        })\n                    },\n                    template: \n                        '<div class=\"tabbable\">' +\n                      '<ul class=\"nav nav-tabs\">' +\n                        '{{panes}}'+\n                        '<li class=\"{{#selected}}active{{/}}\">'+\n                          '<a can-click=\"select(pane)\">{{pane.title}}</a>' +\n                        '</li>' +\n                      '</ul>' +\n                      '<div class=\"tab-content\" can-select=\"*\"></div>' +\n                    '</div>'\n            });\n. 1 + 3.\nI think at the start, there will have to be normal elements (to support IE), but with a special attribute name.\nEventually, this can run on web-component technology when it's available in all browsers.  The biggest gap right now is mutation events and hooks into custom elements.\n. What about browsers that do not support animation events?\nSent from my iPhone\nOn May 17, 2013, at 5:59 PM, Matthew Phillips notifications@github.com wrote:\n\nFWIW x-tags (Mozilla's polyfill) uses animationstart as an alternative to mutation events.\n\u2014\nReply to this email directly or view it on GitHub.\n. It will just work as long as you are using jQuery or one of the libraries helpers to insert HTML. $().append, $().html, etc. In this way we can support older browsers, and how people typically manipulate the DOM.\n\nAlso, with live binding, the amount of DOM manipulation that goes on is exceedingly minimal lately.  It's almost always just:\nthis.element.html( can.view( ... ) )\n. By this, I mean, we don't really need to support document.createElement and such. We will support that directly in browsers that support it, but most people who use jQuery are accustomed to doing $().html() anyway.\nI've talked with James Burke about HTML imports, I don't care for them unless you can build it. We talked about how AMD / require / steal could support loading imports.\nBut yes, I agree that we need an easy way to share components, but dependency management is really the key because even if web components became popular, they will still have dependencies on libraries.\n. One more thing ... I don't think that the killer feature of can.Component will be:\n\nthe ability to add a tag to your markup and have it just work. \n\nThat's the killer feature of web-components as you correctly identified.  The advantage of can.Component over can.Control is first that it hooks up 3 extremely common items of a component by convention:\n- can.Control\n- A view-model (which is currently this.options, but this.options is extremely underpowered).\n- A live-bound template\nSecond, it allows you to \"pass\" a template to a control. I need a better term for this, but consider this example:\nhtml\n<h2>Things</h2>\n<ul can-component=\"List\" data-model=\"Things\">\n  {{#items}}\n  <li>{{name}}</li>\n  {{/items}}\n</ul>\nThe developer doesn't need to do something like this instead:\nnew List(\"ul\",{\n  model: Things,\n  view: can.view(\"list-of-things\")\n})\nThe designer can see more of the structure of the page all in one place. This is very nice for basic widget-y type controls that might need a micro template from the user.  The user doesn't have to define the template elsewhere.\nThis breaks down eventually as you want high-level components to carry their template with them. But, that's fine.\ncc @shcarrico (I've talked with Stan quite a bit about this)\n. @steeleprice did you read my previous comment about how can.Components main feature is NOT the ability to add custom tags?\n. @steeleprice anyway you can clean up that post a little to get more to the point.  I'm not really sure what you are saying.  I'll give you an example:\n\nThere is also some cross pollination here with Issue 305 if you want computes directly bound.\n\nWhat does this have to do with can.Component?\nYour post seems to be talking about other issues you are having and not related to this discussion.\n. @steeleprice btw, we use steal to package components.  Packaging is not something that we're looking to solve in CanJS.\n. I agree that any discussion outside the specifics of can.Component should be moved to the forums.  But I want to keep this discussion it's functionality.  If there are use cases you have around WebComponents, or thoughts, please write them in a forum post.\nHere's the functionality of can.Component:\nA merger of can.Control, an observable View-Model, and a template, that can be instantiated via custom tags (or other markup).\nThink about it this way, how often do you have a can.Control like:\njs\nGroupControl = can.Control({\n  init: function(){\n    this.options.usersLoaded = can.compute(false)\n    this.options.showUsers = can.compute(false)\n    this.option.users = can.compute()\n    this.element.html( INIT_TEMPLATE(this.options) )\n  }\n})\nAnd how often in a parent control are you doing:\njs\nthis.element.html(INIT_TEMPLATE)\nnew Group( this.element.find(\".group\"), {group: group});\nI do this all the time.\nI'd like to be able to do something like:\n<group>\n   <ul {{^showUsers}}style=\"display:none\"{{/showUsers}} class='users'>\n        {{#usersLoaded}}\n            {{#users}}\n                <li {{data \"user\"}} class='user'>{{name}} <button class='destroy'>X</button></li>\n            {{/users}}\n            {{^users}}\n                <li>No users in group</li>\n            {{/users}}\n        {{/usersLoaded}}\n        {{^usersLoaded}}\n            <li>Loading Data</li>\n        {{/usersLoaded}}\n    </ul>\n</group>\nAnd have Group look more like:\njs\ncan.component(\"group\",{\n  template: \"<h3>{{group.name}}</h3><div class='content'><content></content>\",\n  \"h3 click\": function(){\n     if( this.attr('usersLoaded') ){\n        this.attr('users', new User.List({groupId: this.attr('group')}, function(){\n          self.attr('usersLoaded', true)\n        })\n     }\n     if( ! this.attr('showUsers') ){\n       this.attr('showUsers', true)\n     } else {\n       this.attr('showUsers', false)\n     }\n  }\n})\nThe special parts of this are:\n1.  The group control is created automatically with this.attr(prop) having access to the current context of the template in which it was created.  This is how this.attr('group') works.\n2. The template the user provided is merged automatically with the group's template.\nAnd parts not shown:\n1. A can.component is really the view-model, so it will be like an observe, and have setters and such.\n2. Any templated event handlers like \"{users} change\" will be automatically updated without having to call .on().\n\nWhat we are going to try to nail down is the very common practice of having a can.Control wire up its view-model and template, and how it is invoked.  It's API isn't finalized, but this is the problem we are trying to solve.\n. I mean, it might be better to break up can.component's parts to be more like how mozilla's x-tags approaches it:\njs\ncan.component('group',{\n  template: \"the template\",\n  model: {\n    property: \"defaultValue\",\n    setProperty: function(){}\n  },\n  events: {\n    \"h3 click\": function(){\n      this.model.property\n    }\n  }\n})\n. So, I was kinda thinking that your comments were more about high-level application architecture instead of can.component.  Can you please sum them up in a forum post and remove some of the comments here to keep it can.component focused?\n. @matthewp to better separate the model code from event code.  I think it might make things easier to read.\n. Thanks for the explanation! But, I'm not sure I consider this a bug.  That isn't a valid route on load. There's only one route:\nhttps://github.com/addyosmani/todomvc/blob/gh-pages/architecture-examples/canjs/js/app.js#L6\njavascript\ncan.route(':filter');\nWith just this one route, a hash like #!foo/bar must get converted to #!foo%2Fbar so can.route.attr() would return:\njavascript\n{filter: \"foo/bar\", route: \":filter\"}\nI think you might be misunderstanding the idea behind can.route. can.route isn't as much about matching a hash as it is keeping state.\nFor example, consider if there were two routes:\njavascript\ncan.route(':filter');\ncan.route(':filter/:something');\nAnd the user set can.route w/ .attr() like:\njavascript\ncan.route.attr(\"filter\",\"foo/bar\")\nThe hash would have to be set to #!foo%2Fbar. If it was set to #!foo/bar, the data would be:\njavascript\n{filter: \"foo\", something: \"bar\", route: \":filter/:something\"}\nIn your example, can.route is trying to make sense of an invalid route and converting it to something valid.\n. Does resource solve this?  I think for most situations, it probably would.\n. closing unless this gets more interest. \n. Moving to can-connect.\n. This issue was brought up in #703.\n@rjgotten @daffl \nI'm pretty sure full modules ids are a best practice with requirejs, especially for libraries.\nYou should not be using map, you should be using path.  It should only require one simple path instruction to change the lookup of \"can\" to wherever you want.   Something like:\njs\nrequire.config({\n  paths: {\"can/\"  \"lib/can/\"}\n});\nmodule ids should really not be mutable.  \"can\" should always be \"can\".  Paths should be used to change where to find \"can\".  Map should only be used to rename \"can\" something else.  \nClosing for now.  I'll open if you can show I'm wrong.\n. > relative paths are common practise both in CommonJS and RequireJS. \nCan you point me to an example of an AMD similar to CanJS using relative paths?\n\nModule locations will still be immutable if you don't mess with the folder structure of the library\n\nWhat do you mean?\n\nmapping is indeed unnecessary for RequireJS and with relative paths you could just do a clear and simple require('path/to/can')\n\nBut that is not what you are supposed to be doing.  For example, you should always require(\"jquery\"), not require(\"path/to/jquery\").  This is for portability.    Consider using two projects where one did in 20 files:\nrequire(\"path/to/jquery\")\nand another did:\nrequire(\"different/to/jquery\")\nThis would be very difficult.  Instead, you always should require('jquery').  \nThe same thing is true of can.  Modules should never be relative in distributed projects.\n\nan avoidable barrier of entry.\n\nSpecifying paths to libraries like jQuery, underscore is completely known and understood part of using AMD.  It's not a barrier to entry using jQuery or underscore, why would it be for CanJS?\n. > so getting those to work will at best be annoying.\nI disagree with that assessment.  It will at worst be annoying.  At best be simply adjusting the path we write.\n. @stevenvachon I won't encourage people to do best practices, even in other libraries.  Loading CanJS relatively is a bad idea.\n. Node projects are not typically AMD. Dependency management on the client is very different than the server where it can go looking in folders and files to resolve a moduleID. \nThe downside is that someone might require 'can' relative and it would work. That's a mistake that I don't want to enable. \nSent from my iPhone\n\nOn Feb 8, 2014, at 2:04 PM, David Luecke notifications@github.com wrote:\nA good example for relative module paths is jQuery which recently migrated to AMD (example: data.js). Also every NodeJS project (e.g. Express) does it.\nI still fail to see why using relative file names internally in CanJS (just like jQuery does it) would have any downsides. All your points were using and re-using the reference (require('can')), require('can/view') etc.) in a project which doesn't really have anything to do with how the library references its dependencies internally.\n\u2014\nReply to this email directly or view it on GitHub.\n. I've asked the require forums. No response yet. \n\nI'm not sure how your points are a rebuttal. I know it's on the file level. I don't think someone should be loading relative 3rd party modules. \nHaving built steal to include the same moduleReference > moduleId > path conversion chain, paths should be the configured value. \nSent from my iPhone\n\nOn Feb 12, 2014, at 2:44 AM, rjgotten notifications@github.com wrote:\nFirst off, addressing the concern of @stevenvachon :\nWhat would be the mistake in requiring 'can' relatively? The possibility of it being loaded in twice?\nAMD loaders should internally normalize any relative IDs to absolute IDs and then register and load modules by said fully normalized IDs. RequireJS does this correctly and you don't get double loading.\nNext up, a rebuttal for what @justinbmeyer wrote:\nInstead, you always should require('jquery').\nThe same thing is true of can. Modules should never be relative in distributed projects.\nNo; that's a bad practice started by jQuery and a few other libraries that was cargo-culted into common accepted use for third party libraries. It has always been recommended to use anonymous modules and relative paths. Ask James Burke; the author of RequireJS, and I'm pretty sure you'll get a similar answer.\nYou should not be using map, you should be using path. It should only require one simple path instruction to change the lookup of \"can\" to wherever you want. Something like:\nrequire.config({\n  paths: {\"can/\"  \"lib/can/\"}\n});\nThe paths configuration is meant for setting up a mapping at the physical file level. Basically, you're lying to your application about where the CanJS files are located. It does NOT remap module IDs and does NOT factor into the normalization of module IDs.\nThis means that:\n1. it breaks the resolution of relative module IDs, and\n2. Should someone now request \"lib/can/\" in your application somewhere, it will be treated as a different module and you will infact be getting aforementioned double loading that you would not get with map configuration.\nAnd in closing to answer @stevenvachon again:\nI hadn't thought about parent paths; they kind of smell; though, not sure like what : )\nPray tell; how do parent paths smell more than hardcoded rooted paths requiring the mis-use of an explicit configuration flag that opens up the possibility of duplicate loading?\n\u2014\nReply to this email directly or view it on GitHub.\n. Get and remove probably shouldn't even be in a plugin. What's wrong with attr/removeAttr. \n\nSent from my iPhone\nOn Apr 3, 2013, at 9:41 AM, roelmonnens notifications@github.com wrote:\n\n.get(), .remove(), .slice(), .grep(), .match() are now in models/list/list.js.\nIt seems more correct that .get() and .remove() should be in the original Model.List and not in model/list/list.js (this extends Model.List).\nmodel/list/list.js also contains .slice(), .grep() and .match(). This would be better in a the plugin observe/list.\nobserve/list already exists and contains the .filter() and .map() functions.\nI add this issue on request of daffl with whom I have discussed this on irc.\n\u2014\nReply to this email directly or view it on GitHub.\n. Closing for #192. Model/List with live binding should not need get / remove.\n. Thanks.  Can you give some cases where you find yourself using it a lot?\n. You should check out fills: https://github.com/bitovi/canui/blob/master/fills/fills.js\n\nWorks pretty awesome.\n. I'm thinking property should be get so methods could potentially be read:\njs\nvar duration = can.compute(el.loadmetadata,{\n  context: el,\n  get: \"duration\",\n  bind: \"loadmetadata\"\n});\nThis would probably work too (using on and off):\njs\nvar duration = can.compute(el.loadmetadata,{\n  get: function(){\n    return el.duration\n  },\n  set: function(newVal){\n    el.duration = el;\n  }\n  on: function(updater){\n    el.addEventListener(\"loadmetadata\", updater, false);\n  },\n  off: function(updater){\n    el.removeEventListener(\"loadmetadata\", updater, false);\n  }\n});\n. @daffl \nI was actually thinking about\njs\nvar myObjectProp = can.compute(myObject, 'myProp', 'changeEvent');\nas a short hand. (I reversed prop / eventName order). But, I thought it might not be very clear and that an object form of can.compute is almost certainly necessary.\nBtw ...\njs\nvar myObserveProp = myObserve.compute('myProp')\nworks right now.\n. That's not how much templating systems work. For example:  <%= b %> and {{b}} would not leave the template tags in place if b does not exist.  Is this really what you need, or do you need a way to pass the equivalent of EJS's <%%= %>?\n. @schovi Thanks for submitting this issue.  However, I don't think it's something most people need, and its not something the framework needs.  can.sub is just a means to an end. Hopefully you can get this in lodash or some other micro-templating library.  Thanks!\n. I don't think we should support this. If you're passing an object, it should reflect what the observe looks like. \nSent from my iPhone\nOn Apr 7, 2013, at 1:39 PM, Austin notifications@github.com wrote:\n\nIf I try to set a nested property in a can.Observe using attr dot operators, it sets it on the root Observe instead of the nested object.  For example:\nvar animals = new can.Observe({\n    zoo: {\n        hasMonkeys: false\n    },\n    farm: {}\n});\nanimals.attr({\n    'farm': 'has no animals',\n    'zoo.hasMonkeys': true\n});\nanimals['zoo.hasMonkeys'] //-> true\nanimals.zoo.hasMonkeys //-> false\nhttp://jsbin.com/imonoc/1/\n\u2014\nReply to this email directly or view it on GitHub.\n. You could do:\n\njs\nanimals.attr({\n    'farm': 'has no animals',\n    'zoo': {hasMonkeys: true}\n});\n2 or so extra characters ( :{} ) - ( . ) = 2\n. I doubt it. Mustache incorrectly looks for properties on observables\ndirectly. Using attr won't help because it sets up bindings.\nOn Monday, September 30, 2013, Josh Dean wrote:\n\nThis should be working, looking into it now.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/issues/351#issuecomment-25372645\n.\n\n\nJustin Meyer\n847-924-6039\n. I think jQueryMX did this, but I removed it because why would you be calling destroy multiple times?\n. I wanted this error in the past because it meant I was doing something else wrong. \nCurtis, can you share some code that should be fine that creates this error. \nSent from my iPhone\nOn Apr 18, 2013, at 9:53 AM, David Luecke notifications@github.com wrote:\n\nI can see that this might happen. If it is as easy as adding if(!this.element) return; before https://github.com/bitovi/canjs/blob/master/control/control.js#L702 I don't see why it shouldn't be fixed.\n\u2014\nReply to this email directly or view it on GitHub.\n. Moving into 1111. Closing.\n. It used to be this way (likely JMVC 3.0), but we changed it because it was very hard to turn off attributes in inheriting constructor functions.\n. Define will inherit by default.  Use that in 2.1 going forward.\n. Unbound event handlers should probably not be called in the first place. Likely jQuery clones event handler array. \n\nSent from my iPhone\nOn Apr 17, 2013, at 6:09 PM, Austin notifications@github.com wrote:\n\nIf I have a Control that is listening for route changes and then I destroy the Control during change, the event is still called on the control.\nvar Files = can.Control({\n    '/:view route':function(){\n        this.element.html('WOO!')\n    }\n});\nvar Contacts = can.Control({\n    '/:view route':function(){\n        this.element.html('WOO!')\n    }\n});\nvar views = {\n    contacts: Contacts,\n    files: Files\n};\nvar ParentControl = can.Control({\n    '/:view route':function(route){\n        $(document.body).control().destroy();\n        new viewsroute.view;\n    }\n});\nContacts\nFiles\nWould probably be a good idea to add a controller.element check here: https://github.com/bitovi/canjs/blob/master/control/route/route.js#L11\nThoughts?\n\u2014\nReply to this email directly or view it on GitHub.\n. Closing as using controls for routing has been deprecated for over a year.\n. yes, it should be.\n. As noted in the forum, can you please describe why you are doing this?  I don't understand the use case. \n\nSent from my iPhone\nOn Apr 19, 2013, at 10:51 PM, jianlin notifications@github.com wrote:\n\nPlease see the details in:\nhttps://forum.javascriptmvc.com/topic/can-observe-objects-or-can-compute-can-bind-change-function-can-it-also-be-triggered-for-a-change#32525000001192153\nBasically, we can use can.trigger(myControl.options.val, 'change', [value, value]); to trigger a change event, but can it be made more parallel:\nval.bind(\"   \")\nval.trigger(\"   \")\n(val is a can.compute (or a can.Observe object))\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm not sure that it does. You should only get events on state changes. A manual trigger means that something else is broken. \n\nSent from my iPhone\nOn Apr 19, 2013, at 11:56 PM, Curtis Cummings notifications@github.com wrote:\n\nTo clarify, The request is to add a trigger method to can.compute and can.Observe.\nThese two classes have bind and unbind functions so it malkes sense to also have trigger.\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm not sure what trigger would help with this. \n\nSent from my iPhone\nOn Apr 20, 2013, at 12:48 PM, rjgotten notifications@github.com wrote:\n\nThis makes sense if you want to turn something that will have asynchronous value changes into a computed property. For instance, you could be wrapping the creation of a can.Deferred into a can.compute where you want the computed property to update when the deferred object resolves or rejects.\nWrapping a deferred object into a computed property makes it work with live binding, which is awesome for partial view updates with spinners while content is still loading.\n\u2014\nReply to this email directly or view it on GitHub.\n. Couldn't you just change the value of the compute to be what the deferred resolves to?  Going from undefined to some other value makes sense.\n. I mean like:\n\n``` js\nvar item = can.compute()\nItem.findOne({id: \"foo\"}, function(foo){\n  item(foo)\n})\n```\nThe value of the compute didn't change, just the state of an object inside it.  I'd rather be able to bubble events to their parent object.\nFor example, we could support being able to listen to state changes on objects within a compute like:\n``` js\n\"{compute} *.resolved\": function(){\n}\n```\nThis would be a nice feature.  For instance being able to listen to changes in an observe within a compute like:\n``` js\n\"{compute} *.change\": function(){\n}\n```\nI'm not a huge fan of the event name to listen for, but something like this would be better.\n. I don't think we should support this.  However, https://github.com/bitovi/canjs/issues/179 will make this possible by using a compute that wraps everything.\n. @daffl It shouldn't be converted, but it also shouldn't replace itself, but that's why I want: #366.\n. The homepage has instructions on how to develop canjs. \nIm not sure why would npm make it better?  People have git client already installed if they want to contribute. They just have to pull submodules. \nSent from my iPhone\nOn Apr 25, 2013, at 7:18 PM, Sebastian Porto notifications@github.com wrote:\n\nI forked the repo\nAnd tried to open the tests. But they don't work as they are looking for stuff that is not there. i.e. steal and funcunit.\nIt is hard to contribute this way. It would be much better if the repo is self contained OR use node modules that can be easily installed using NPM.\n\u2014\nReply to this email directly or view it on GitHub.\n. Those aren't the steps to currently do it, this is: http://canjs.com/#developing_canjs.\n\nI want to avoid npm to be a dependency unnecessarily. We've been considering making steal and funcunit submodules of canjs, allowing:\ngit clone git@github.com:bitovi/canjs can\ncd can\ngit submodule update --init --recursive\n. Can you add a test and I will fix it tonight. \nSent from my iPhone\nOn Apr 30, 2013, at 11:24 AM, Curtis Cummings notifications@github.com wrote:\n\nSeems this issue is a bit more serious than I first thought. It's not just a duplicate event that is emitted, the compute you get from Observe.compute will have its value changed to the Observe If you bind to the change event. So in the example above adding this:\nsetTimeout(function() {\n    console.log(name())\n}, 2000);\nWould log the Observe because the compute has been set to the Observe instance.\n\u2014\nReply to this email directly or view it on GitHub.\n. The test seems to pass for me.\n. I don't think the function type check is necessary. \n\nSent from my iPhone\nOn Apr 30, 2013, at 11:47 AM, Austin notifications@github.com wrote:\n\nFix for can.route references delegate but does not include it\n353\nYou can merge this Pull Request by running\ngit pull https://github.com/bitovi/canjs issue-353-route-delegate\nOr view, comment on, or merge it at:\nhttps://github.com/bitovi/canjs/pull/373\nCommit Summary\ncan.route references delegate but does not include it - https://github.com/bitovi/canjs/issues/353\nFile Changes\nM route/route.js (7)\nPatch Links:\nhttps://github.com/bitovi/canjs/pull/373.patch\nhttps://github.com/bitovi/canjs/pull/373.diff\n. I'm closing these were made for 2.0.  I'll re-open if I want to change compute.\n. Example code/test?\n\nSent from my iPhone\nOn May 2, 2013, at 6:03 AM, SteveEisner notifications@github.com wrote:\n\nJust an FYI since the \"1.1.6pre\" has been pushed to \"latest\" on the CDN.\nIn this version only (same code confirmed working when I switch back to 1.1.5) when rendering a model via mustache template, if I reference a can.compute property via {{name}} the context passed into the compute is the global window, rather than the model... Any compute that is trying to use \"this\" will break.\n\u2014\nReply to this email directly or view it on GitHub.\n. You shouldn't do it that way.  Closing this issue.\n. #305 shows how\n. This is now possible with options.scope.\n\nregisterHelper('rsvp', function(options){\n  options.scope.attr('property to find in scope')\n})\n. {{#attendee}}\n            <tr {{data \"attendee\"}}>\n                <td {{#editablename}}class='editable'{{/editablename}}>\n                    {{#editablename}}\n                        <div class='name-value'>\n                            <span>{{name}}</span> <span class='icon-pencil'></span>\n                        </div>\n                        <input type='text' {{value name}} style=\"display:none\" class='name-edit'/>\n                    {{/editablename}}\n                    {{^editablename}}\n                        <span>{{name}}</span>\n                    {{/editablename}}\n                </td>\n                {{#events}}\n                    <td class='{{status attendee}} day{{day}} event-attendence {{name}}'>\n                        {{{rsvp attendee .}}}\n                    </td>\n                {{/events}}\n            </tr>\n            {{/attendee}}\n. @alexisabril @daffl Can someone walk me through this today?\n. It's not better. It's better to have related code next to each other. Hard to forget writing a test when the test file is staring you in the face. \nSent from my iPhone\nOn May 17, 2013, at 12:39 AM, Felipe notifications@github.com wrote:\n\nIs it not better to have the test files in the test directory? Having the production code next to test code sounds strange for me... just my 2 cents\n\u2014\nReply to this email directly or view it on GitHub.\n. In my opinion, I feel strongly that it doesn't depend.  We have a culture of testing (FuncUnit), which is why we organize our tests this way.\n\nSay you have a big set of files.  How can you tell which ones are missing their test?  Keeping tests next to what they are testing makes it very easy to see that something is in fact being tested. The 1 to 1 pairing of module and test keeps people accountable.  \nFrameworks have lead people astray by promoting their own testing strategy that is not appropriate for large application development. For instance jQuery, ROR, and may more puts all of its tests in one folder.\nBut if jQuery grew like an application, into 100s of files, this would break down.  \nI've been quoted for this many times, but ... the secret to building large applications is to never build large applications, break them down into small pieces and assemble.\nA modules should be its own micro application.  It should have its own folder with its own:\n- tests\n- demo page\n- code\n- any any other resources needed for it to run (css, images, etc)\nIf there's no difference between a module and an application, you are doing things the right way. It makes it easier to import just the module (and its tests) into another application.\n. This should work with the branch I just added that rewrites scope. \nSent from my iPhone\n\nOn Nov 7, 2013, at 11:12 AM, Josh Dean notifications@github.com wrote:\nI've been working on this and have been overall happy with what I have. After talking with @daffl, expect the 2.1 launch to have a lot of goodies related to this such as:\n@index directive which outputs the index of item of an array/can.List\n@key directive which outputs the name of properties on objects and attribute names on can.Maps\neach iterator now works on generic objects as well as can.Maps\neach will be live bound on can.Map attributes\n@index will be live bound on can.List\nUnrelated but it will also have an implementation of {{log}} which will log the current context of where it appears in the template.\nYou can play with it in the indexKeyLogMustache branch.\n\u2014\nReply to this email directly or view it on GitHub.\n. agreed, a dev branch.  There were a lot of minor breaking changes I wanted\nto make to can.Component.\n\nJustin Meyer\n847-924-6039\nOn Thu, Nov 7, 2013 at 12:16 PM, David Luecke notifications@github.comwrote:\n\nWe probaby should have a general dev branch for the next minor/major\nversion so that we can keep master at the patch level.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/issues/383#issuecomment-27991519\n.\n. So was can.Model truly silently failing (no error in the console), or was the fail not called?\n\nIMO, an error is a different case than a ajax request fails to load.  I'm not sure the try-catch was ever appropriate.\n. Does the cross domain issue happen if you use $.ajax directly?\nSent from my iPhone\nOn May 10, 2013, at 9:00 AM, Adrian Maurer notifications@github.com wrote:\n\nNo deferred method is executed if invalid data is returned. For example:\nmyModel.findAll({myData: 'myValue'}, function(result) {\n    // do something here\n}).fail(function(xhr, textStatus, errorThrown) {\n  // do something here\n});\nSuccess callback or fail callback not called. This hold true for 'then'.\nIn addition, I noticed the same issue if the request was cross domain. My local proxies were not set up for testing some API's and it took me a while to realize this since my code was not succeeding or failing.\n\u2014\nReply to this email directly or view it on GitHub.\n. Can you put this in a fiddle, or fork and make a test?  Please make it work without the control and using can.fixture.\n\nThanks!\nSent from my iPhone\nOn May 10, 2013, at 3:25 PM, wDevil notifications@github.com wrote:\n\nModel:\ndefine(['can/model'], function(Model) {\n    'use strict';\n```\nActiveEvent = can.Model({\n    timeDiff: 0,\n    findAll: function() {\n        return $.ajax({\n            url: 'http://' + backendHost + '/activeEvents/GetEvents/userId/' + Environment.attr('idUser'),\n            type: 'get',\n            dataType: 'json'});\n    },\n    destroy: 'GET http://' + backendHost + '/activeEvents/DeleteEvent/Id/{id}',\n},{});\nActiveEvent.List = Model.List({\n    init: function() {\n        this.bind('remove', function(ev,newVal,idx) {\n            var time = 0;\n            if(can.isArray(newVal)) {\n                newVal.forEach(function(evt, idx){\n                    time += evt.time_effort;\n                });\n                ActiveEvent.timeDiff += time;\n            }\n        });\n    this.bind('add', function(ev,newVal,idx) {\n        var time = 0;\n        if(can.isArray(newVal)) {\n            newVal.forEach(function(evt, idx){\n                time -= evt.time_effort;\n            });\n            ActiveEvent.timeDiff += time;\n        }\n    });\n},\n\napplyActiveEventsTimes: function(maxTime) {\n    var tmp = maxTime + ActiveEvent.timeDiff;\n    ActiveEvent.timeDiff = 0;\n    return tmp;\n}\n\n});\nreturn ActiveEvent;\n```\n});\nController:\ndefine(['can/control'], function(Control) {\n    'use strict';\n    var ActiveEvents = can.Control({\n        events: false,\n        init: function( element, options ) {\n```\n    },\nrenderInit: function(events) {\n    if((typeof this.events) == 'object') {\n        var size = this.events.length;\n        for(var i = 0; i < size; i++) {\n            this.events.pop();\n        }\n    }\n\n    this.events = events;\n    Environment.attr('freeTime', this.events.applyActiveEventsTimes(Environment.attr('freeTime')));\n    this.element.html( can.view( 'views/activeEvents', {data: this.events}) );\n},\n\n'.activeEventDelete click': function(element, event) {\n    var activeEvent = element.closest('div').data('activeEvent');\n},\n\n'{ActiveEvent} destroyed' : function() {\n   Environment.attr('freeTime', this.events.applyActiveEventsTimes(Environment.attr('freeTime')));\n}\n\n});\nreturn ActiveEvents;\n```\n});\nWhen i'l try to get data from server:\nActiveEvent.findAll( {}, function(events) {\n            activeEventsControl.renderInit(events);\n        });\nSometimes i have this error:\nTypeError: this.events.activeEventsTimes is not a function\n[Break On This Error]\n...onment.attr('freeTime', this.events.activeEventsTimes(Environment.attr('freeTime...\nIn the debugger I saw that ActiveEvent model in the property ActiveEvent.List contains the prototype Model.List, not my extended List with activeEventsTimes function\n\u2014\nReply to this email directly or view it on GitHub.\n. Can you create a test or fiddle that always reproduces it?  We will solve it much faster that way. \n\nSent from my iPhone\nOn May 11, 2013, at 12:13 AM, wDevil notifications@github.com wrote:\n\nhttp://finanj.fromthecloud.ru/index_new.html - test instance of application. If you open in Firefox with firebug and refresh page(ctrl+f5) few times you can reproduce the problem\n\u2014\nReply to this email directly or view it on GitHub.\n. We comply with minimal API needed to power canjs based on the libraries that already expose a deffered like object. \n\nThis would be a fine goal for universal, but not for canjs. can.util is not really something can touts as a feature. \nSent from my iPhone\nOn Sep 25, 2013, at 4:43 PM, David Luecke notifications@github.com wrote:\n\nIt would be nice if at least our Deferred comply with the Promises/A+ spec.\nAs a side note, I also really like how RSVP.js does it by passing a function with resolve and reject callback to the constructor. No promise vs. deferred objects needed.\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm fixing a bunch of this stuff. \n\nSent from my iPhone\nOn Jun 19, 2013, at 2:29 PM, David Luecke notifications@github.com wrote:\n\ncan.view signatures aren't right (e..g returns a renderer function when you only give it a template name).\n\u2014\nReply to this email directly or view it on GitHub.\n. yes .. whoops.\n. Good fix. We've needed this forever. \n. Can you submit a pull request with a breaking test?\n\nSent from my iPhone\nOn Jun 5, 2013, at 9:06 AM, Taai notifications@github.com wrote:\n\nI'm using automatically packed version from canjs.com -> customize... This problem occurs in version 1.1.6.\nIt's nice that plugin can.Observe.attributes gives me an option to define defaults which are automatically set on my Models.\nSadly the plugin can.Model.Queue disables it.\nI made two examples.\nwithout can.Model.Queue (good): http://jsbin.com/olitit/2/edit\nwith can.Model.Queue (bad): http://jsbin.com/ijojep/2/edit\nThe code that I need to work:\nvar Car = can.Model({ defaults: { wheels: 4, color: 'red' } }, {});\nvar mycar = new Car();\nconsole.log(mycar.attr());\n// -->  {\"wheels\":4,\"color\":\"red\"}\nPlease fix that!\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm closing this as queue isn't heavily used and it's not in can-connect.\n. TODO:\n1.  Create an issue for a EJS / pages / tags page.\n. I am working on pushstate.\n. You need a wrapping element around live text elements.  Something like:\n\n<span>\n   {{#state.loading}}\n        Loading\n   {{/state.loading}}\n</span>\notherwise, we have no parent element to update the live part relative to.  We might be able to fix this by modifying the document fragment temporarily.\n. I think this is a reasonable suggestion, although a breaking change.  Currently, you'd have to do something like:\n['canjs', 'jquerypp'].forEach(function(project){\n  route(project+\"/:category\", {project: project});\n});\n['greatest', 'latest'].forEach(function(page){\n  route(page+\"/:category\", {page: page});\n});\nClosing and moving to: https://github.com/canjs/can-route/issues/3\n. @retro is this needed with new Todo.List({})?\n. I think we will fix this soon.  Thanks for pointing it out.\n. On first glance, there's two issues / questions I have:\n1.  Why would you need this? (vs just adding them to your child object-types).\n2.   Should:\njs\n{'company.name' : [\n    'company name validated from parent',\n    'validation from company'\n]}\nLook more like:\njs\n{'company' : {name: [\n    'company name validated from parent',\n    'validation from company'\n]}}\n?\n. Another question.  Say I have something like:\n``` js\nPerson.validate('company.name', function(val){\n    return val ? undefiend : 'no name'\n})\nvar company = new Company({})\nvar person = new Person()\nperson.errors() // does this have errors?\nperson.attr(\"company\",company) // does this trigger an error?\nperson.erros() // does this have errors?\ncompany.attr(\"name\", false) // trigger errors on person?\n```\n. Even if the following is not possible currently:\n``` js\nCustomer.validate('contractNumbers.*', function(val){\n    return val === '' ? 'contract number is mandatory' : null;\n})\ncustomer = new Customer({contractNumbers : ['foo', 'bar', 123, '']})\ncustomer.errors()\n{\n    \"contractNumbers.3\" : ['contract number is mandatory']\n}\n```\nWe should be able to do it like:\n``` js\nContractNumbers = can.List.extend()\nContractNumbers.validate(\"*\", function(){\n return val === '' ? 'contract number is mandatory' : null;\n})\nCustomer = can.Observe.extend({\n  attributes: {\n    // this isn't right, but should work\n    contractNumbers: ContractNumbers\n  }\n},{})\ncustomer = new Customer({contractNumbers : ['foo', 'bar', 123, '']})\ncustomer.errors()\n{\n    \"contractNumbers.3\" : ['contract number is mandatory']\n}\n```\n. > On the question of the structure of the returned errors object, I think this is a good pattern because it follows how attrfunction behaves.\nWhat is a good pattern?  The attr function, if you call it like .attr(), it returns a nested object.\n. @airhadoken Are you still interested in seeing this land?  I've got some time to look at new 2.1 features.\n. Thanks! I'm not sure if you've seen the \"mustache scope\" branch, but this would be the best place to get these things right as that is going to be the code that handles this stuff. \nSent from my iPhone\nOn Jun 28, 2013, at 5:55 PM, \"Brad (Bradley) Momberger\" notifications@github.com wrote:\n\nhttp://jsfiddle.net/air_hadoken/Xp9K8/3/\nWhen starting with different stub values (or no value) for an Observe's property, nested sections of a Mustache fail to update consistently for different patterns of nesting, especially around use of \"this.\" and use of dot notation, and a few cases with \"if\" mixed in. There seems to be a few groups of patterns: empty list, empty string, and non list/non string values are one. Empty object is the same as having an object with the child null. Null and undefined are the same. can.computes generally are consistent, though (not shown in the fiddle) if you replace a compute with an Observe, it will not work in any case.\n\u2014\nReply to this email directly or view it on GitHub.\n. Only valid state/hashes are allowed. Did you create a matching route?\n\nSent from my iPhone\nOn Jun 29, 2013, at 11:17 AM, h16bit notifications@github.com wrote:\n\nIve set route in Control like \"link route\": function(){}\nIf i open this like #!link its ok, but right after that i change hash by my hands (for example #!link2) and this route is not set, press Enter and hash droped to #!\n\u2014\nReply to this email directly or view it on GitHub.\n. @bmomberger-reciprocity Thanks so much for all the issues you submit.  To make things easier for us, can you include a brief explanation of what's breaking so that as we go through these issues, we don't have to study the fiddle to get what is breaking.\n\nHere's my summary (let me know if I have it wrong)\nPassing data like:\njs\nvar MyConstructor = can.Construct.extend({text: \"static text\"},{})\nMyConstructor.altConstructor = function(){\n  return MyConstructor;\n}\nvar data = {\n  Construct: MyConstructor\n}\nwith a helper that returns the hash's clazz's text property or the option's text property like:\njs\ncan.Mustache.registerHelper(\"helper\", function(options) {\n      return options.hash ? options.hash.clazz.text : options.text;\n  })\nto the following templates, produces the result after the =>\n```\n{{Construct.constructor.text}} => \"static text\"\n{{Constructor.altConstructor.text}} => \"\"\n{{Construct.constructor}}{{text}}{{/Construct.constructor}} => \"\"\n{{Construct.altConstructor}}{{text}}{{/Construct.altConstructor}} => \"\"\n{{helper Construct.constructor}} => \"\"\n{{helper Construct.altConstructor}} => \"\"\n{{helper clazz=Construct.constructor}} => \"\"\n{{helper clazz=Construct.altConstructor}} => \"bar\"\n```\nBasically, we need to decide to use the function or the function's result in the cases above.  Ideally we should consider if the function:\n- is a can.Construct or a can.compute.\n- is the \"end\" of the chain\n- is passed to a helper\nAny thoughts on what would make the most sense?\n. Yes, helpers should always get the raw stuff.\nYou are positive about:\n{{Construct.altConstructor.text}}\nnot working in mustache and handlebars?  Mustache describes what should happen when a function gets passed?\n. Your first fiddle isn't a great example because it's reasonable that mustache might look for the property on the function, if it doesn't exist, call the function.  However, I tried that:\nhttp://jsfiddle.net/mE49M/196/\nAnd it seems like it doesn't take this approach.\nBut ... I'm not sure how I feel about it because can.Component uses a lot of functions for derived values.  I'd rather not have people declare all of them as can.computes.\n. https://github.com/bitovi/canjs/blob/minor/compute/compute.js#L560\n. I am not so sure we should treat as plain objects and then treat as a function.  It means we won't only be testing \"context\" objects for some path, but any function we find.  Also, there will be some weirdness around properties like length which are on all functions.  Say I had a compute like:\njs\nvar items = can.compute(new can.List([\"a\",\"b\"]))\nAnd a template:\n{{#items}}{{.}}{{/items}}\nThis would hit the function's length property instead of reading the compute's value.\nI think the easiest thing is to treat functions that inherit from can.Construct as objects, every other function is run.\n. Not treating them as functions would break a lot of code, examples, etc.  For example:\n``` js\nPerson = can.Map.extend({\n  fullName: function(){\n    return this.attr(\"first\")+this.attr(\"last\");\n  }\n})\nvar me = new Person({first: \"Justin\", last:\"Meyer\"})\ntemplate({me: me});\n```\nhtml\n{{me.fullName}}\n. can you provide some breaking code?\n. Can you shorten the example to more clearly illustrate the problem?\nSent from my iPhone\n\nOn Jan 17, 2014, at 6:27 AM, Nguyen Kien notifications@github.com wrote:\nI've been recently using canjs and have encountered this problem. I'm using plupload plugin to handle file upload and canjs as my framework.\nvar File = can.Map.extend({});\n//the List is  used for live-binding feature for can.Mustache. Just need to use function Map.attr()\nFile.List = can.List.extend({\n        Map: File\n        //some functions here to work with files\n});\nvar FileUpload = new File.List();\nIn my controller:\nvar Controller = can.Control({\n        init: function (elements, options) {\n            console.log('Controller init!');\n            uploader = new plupload.Uploader({/* options */});\n```\n        can.bind.call(uploader, \"Init\", function (params) {\n            $('#fileList').html(\"Current runtime: \" + params.runtime + \"\");\n        });\n    uploader.init();\n\n    can.bind.call(uploader, \"FilesAdded\", function (up, files) {\n\n        //to preserve functions of file's objects created by plupload\n        $.each(files, function (index, file) {\n            FileUpload.push(new can.Map(file));\n        });\n\n        var output = new can.Map({\n            files: FileUpload\n        });\n\n        $('#fileList').append(can.view('templates/fileUpload.mustache', output, {\n            formatSize: function (Object) {\n                var file = Object.context;\n                //this is fired twice!\n                console.log(file.size);\n                return plupload.formatSize(file.size);\n            }\n            //other helpers\n        }));\n    });\n},\n'route': function (data) {\n    // Matches every routing change, but gets passed no data.\n    console.log(data);\n}\n\n});\n```\ncan.route.ready(false);\nController = new Controller('body');\ncan.route.ready(true);\n\u2014\nReply to this email directly or view it on GitHub.\n. @kiennguyen1101 is the template calling formatSize?  Sorry this is so late.\n. @rjgotten I'm not sure what you meant by \nwill then also call it with the view string, which again will be piped through can.view.frag for hookup.\n. Closing b/c it might not be a problem anymore and can.view won't be part of core in 3.0.\n. This isn't a problem with live binding it seems, more the model store.  If you change the appropriate instance, does the page update?\n\nIt's probably pretty easy to submit a breaking test for this.  Re-create the model association and do new Player(data) with the appropriate data.\nThen go through the instances it created and verify that ones sharing the same id share the same cid.\n. I'll take a look at it now ... \n. Thanks for the test, but don't create globals in them :-).\nGame = can.Model({\n. I fixed this by adding things to the store before the attributes are processed.\n. The second commit includes documentation changes that don't belong in this pull request.\n. So, it doesn't seem like this is a bug.  You are never binding on the instances so they don't get put in the store.\n. Your test doesn't show a bug.  I did not look at the fiddle.  Also, is this a problem with attributes or model?  If it only errors in attributes, the test should be in attributes.\n. I don't think changing the id is supported. \n. I'm confused why your fiddle doesn't work (even though what you seem to want is broken).  In my rewritten test (which is similar to your fiddle), here is what happens:\nWithout the attributes plugin:\nOn the first request, a single game instance is created (but it has some nested properties).  And it is put in the store.\nWhen the second request comes through, the object's properties are updated.\nWith the attributes plugin\nOne the first request, the top level data is converted to a Game, but while it is being converted, the nested Game is created and converted and set in the store. Finally the top level instance is created and overwrites the first instance in the store.\nAnother update should update the outer instance as that is what is in the store.  This doesn't happen in the fiddle, but the core problem remains anyway ... there are 2 objects with the same ID.\nI'm not sure right now how to fix this, but first I must ask ... why are you doing things this way?  You seem to be sending back duplicate information.  Why not have game ids in games?  It seems odd to have an object inside of itself.\n. > What do you mean, changing the id?\nI mean changing the identity properties value.  In the fiddle, the ID is \"name\", but the second response changes it.\n. Thanks brad!\nJustin Meyer\n847-924-6039\nOn Fri, Aug 16, 2013 at 3:03 PM, Brad (Bradley) Momberger \nnotifications@github.com wrote:\n\nPreviously in util/bind/bind.js\nthis._bindings--;\n            // If there are no longer any bindings and\n            // there is a bindteardown method, call it.\n            if(!this._bindings){\nIf _bindings was undefined, this sets it to NaN and then does the\nteardown. If in the teardown this object is touched again, having NaN for\nbindings will decrement to NaN again, still be falsy, and run the teardown\nagain (eventually leading to a stack fault).\nThe code in this pull request sets _bindings to 0 if it is undefined. Any\nsubsequent visit to unbindAndTeardown will then decrement it to -1 or less,\nwhich is okay because we've already started the teardown process.\nYou can merge this Pull Request by running\ngit pull https://github.com/bmomberger-reciprocity/canjs self-limiting-unbind\nOr view, comment on, or merge it at:\nhttps://github.com/bitovi/canjs/pull/461\nCommit Summary\n- Preventing infinite recursion on unbindAndTeardown by ensuring that\n  _bindings is always a number when incremented/decremented\nFile Changes\n- M util/bind/bind.jshttps://github.com/bitovi/canjs/pull/461/files#diff-0(8)\nPatch Links:\n- https://github.com/bitovi/canjs/pull/461.patch\n- https://github.com/bitovi/canjs/pull/461.diff\n. I bet calling unbind without calling bind might do it. \n\nSent from my iPhone\nOn Sep 19, 2013, at 4:24 PM, David Luecke notifications@github.com wrote:\n\nOk. Merging this in since it doesn't seem to break any of the existing tests.\n\u2014\nReply to this email directly or view it on GitHub.\n. thanks, but we've been adding documentation errors to the canjs.com repo:\n\nhttps://github.com/bitovi/canjs.com.  Can you add this there?\n. Did this get you on the right path?  If it did, can you close the issue?\n. Yeah, this is a problem with how mustache looks up properties (which now happens in Scope).  It looks up properties directly on the observable.  When a \"created\" event is added to a model's attrs, it doesn't overwrite model's created method.  \nThe fix is to change how observable values are search for.  Currently, there's not a good way of asking an observable if it has a value without telling a compute to bind on that property.  \nThis will be an even bigger problem when LazyMap and LazyList come into play.\nIn the short term, we can detect that it's an observe and look in ._data.  In the longer term we probably want a obs.has(properyName)\n. Thinking about this a bit more, there is a precedent issue. What if you added a method to an observe like:\nvar Thing = can.Map.extend({\n  created: function(){\n    return \"some value\"\n  }\n})\nThe problem is that even if I were to fix this, I would return objects found via . (DOT) over things in ._data, so you would still have the problem. \nI think people should avoid properties that conflict with methods on the prototype.  For example: attr.  Maybe we should rename created/updated/destroyed and people would have this conflict far less often?\n. Marking this as won't fix for now.  The temporary solution is to rename your created attr to createdAt or something else.  You can do this within can.Model.model.\n. Can you reduce the template to just what it takes to get it to break?\nSent from my iPhone\nOn Aug 26, 2013, at 4:48 AM, nvcnvn notifications@github.com wrote:\n\nI have this template, It should work fine:\n\n    <header>\n        <div class=\"headerbar\">\n            <input type=\"checkbox\" class=\"checkOn\" />\n            <input type=\"textbox\" value=\"<%= row.attr('Name') %>\"\n            class=\"textName\" /&gt;\n            <image  class=\"iconStoriesTypes\" style=\"width: 1.5em;\" src=\"/static/img/storytype/bulletin.png\" />\n            <select class=\"selectStoriesTypes\">\n                <option value=\"\"></option>\n            &lt;% data.gStoriesTypes.each(function(type) { %&gt;\n                <option value=\"<%= type %>\"&gt;&lt;%= type %&gt;</option>\n            &lt;% }); %&gt;\n            </select>\n            <select class=\"selectFeeds\">\n            &lt;% data.feeds.each(function(feed) { %&gt;\n                <option <%= (el) -> can.data(el, 'feed', feed) %&gt; &gt;&lt;%= feed.name %&gt;</option>\n            &lt;% }); %&gt;\n            </select>\n            req:<input type=\"checkbox\" class=\"checkReq\" />\n            <select class=\"selectGroupType\">\n                <option value=\"none\" style=\"\"></option>\n                <option value=\"gradio\" style=\"<%= colorSchema.gradio %>\"&gt;\n                    Start Radio Group\n                </option>\n                <option value=\"gusource\" style=\"<%= colorSchema.gusource %>\"&gt;\n                    Start Unique Sources Group\n                </option>\n                <option value=\"gssource\" style=\"<%= colorSchema.gssource %>\"&gt;\n                    Start Same Source Group\n                </option>\n                <option value=\"gend\" style=\"<%= colorSchema.gend %\">\n                    Start Normal Group\n                </option>\n            </select>\n            <button value=\"\" class=\"btUp\">\n                <img src=\"/static/img/up.jpg\" alt=\"Up\" />\n            </button>\n            <button value=\"\" class=\"btDown\">\n                <img src=\"/static/img/down.jpg\" alt=\"Down\" />\n            </button>\n            <button value=\"\" class=\"btDup\">\n                <img src=\"/static/img/duplicate.jpg\" alt=\"Del\" />\n            </button>\n            <button value=\"\" class=\"btDel\">\n                <img src=\"/static/img/delete.jpg\" alt=\"Del\" />\n            </button>\n        </div>\n    </header>\n    <div class=\"row-data\">\n        <table style=\"width:100%\">\n            <tr>\n                <td style=\"width: 15%;\">\n                    <input type=\"textbox\" style=\"width:100%\"\n                    class=\"textLikelihood\" />\n                </td>\n                <td style=\"width:45%\">\n                    <input type=\"textbox\" style=\"width:100%\"\n                    class=\"textConditions\" />\n                </td>\n                <td style=\"width:40%\">\n                    <input type=\"textbox\" style=\"width:100%\"\n                    class=\"textSetValues\" />\n                </td>\n            </tr>\n            <tr>\n                <td colspan=\"3\">\n                    <textarea style=\"width:100%\" class=\"textHeader\" rows=\"5\">\n                    </textarea>\n                </td>\n            </tr>\n        </table>\n    </div>\n\nBut then, if try to use any 'magic tag' in\nthen the template will not be render.\nNo error found in javascipt console.\nI'm using Chrome/Firefox lasted version.\n\u2014\nReply to this email directly or view it on GitHub.\n. JSON data couldn't hurt, but reducing the amount of HTML would help a lot too.\n. I'll merge sometime later.\n. You can use \n\njs\nreturn can.esc(\"<foo></bar>\")\nI don't think we can or should support SafeString, it's a strange name and call signature.  Having to use new?\n. Oh, you want to avoid the triple brace .. while still returning html from a template.  That's kinda strange.  I am not sure how I feel about that ...\n. Yeah, but not handlebars safestring API ... \nSent from my iPhone\nOn Sep 25, 2013, at 4:41 PM, David Luecke notifications@github.com wrote:\n\nThe escaping behaviour should indeed be consistent. I will look into this and see what we can do. I concur with having helper be able to return HTML that doesn't need the triple braces.\n\u2014\nReply to this email directly or view it on GitHub.\n. can.Mustache.safeString = function(str){\nreturn {toString: function(){\n  return str\n}}\n}\n. It's broke. I know how to fix it. Submit a test and I will make this part of 1.2. \n\nSent from my iPhone\nOn Aug 30, 2013, at 1:58 PM, David Luecke notifications@github.com wrote:\n\nI can confirm. @andykant Could you have a look at this?\n\u2014\nReply to this email directly or view it on GitHub.\n. Can you describe what's breaking a bit more?  We can't accept a pull without a test.\n. Ah, but if can.route was defined after your control this would work?\n\nI'm not sure what the behavior of calling can.route multiple times with different default values should be. Your fix basically says \"first in\" gets to set the behavior of the route.  But if someone was defining the route after the control, this would break their code.\nControl \"route\" events like \"content/:type\" are not the best way of doing routing with CanJS.  We should look to remove them.\nA better fix might be to have the route plugin test if the route exists.\n. I didn't read your code carefully enough.  You did exactly what I was thinking.  I'm going to add a test.\n. yes, it should.  Good catch.  Can you submit a pull request to fix it?\n. Does this work with lists?\n. @ccummings does this work with can.List?\n. @ccummings does this work with lists!?!?\n. I don't think there is going to be a 1.8.  So this is probably not worth bringing in.\n. What is this fixing exactly?  We need to see a test or at least some more info so we can write a test.\n. Anyway someone can reduce this to something I can add as a test?\n. @thecountofzero if you can reduce those fiddles into something testable by Monday of next week, I'll fix it.  Thanks!\n. @thecountofzero checkout that last commit that shows how to avoid globals and use attributes.\n. the compute created live-binding is listening to change?  It should not be.\n. There isn't a \"bar\" helper?\n. If you check out http://jsfiddle.net/V8VvF/3/ and open the console ... you see that \"foo is called\" twice total.  I'm not seeing the issue.  I'd expect it to be called 3 times if the problem you described was happening.\n. Sorry, I'm an idiot.  It shouldn't have been called the first time.\n. Awwww Thanks!  I confirmed this is a problem.  This will be fixed in 1.2.\n. Ok, I figured out what happens.  When is evaluating:\n{{#if quux}}\nIt looks up quux and then creates a compute out of it.  That compute is then read.  When the compute is read, live binding listens to the compute changing, but when the compute is read, it ends up calling obs.attr('quxx') which also sets up a live-binding on obs's quxx property.\nSo when quxx changes, it triggers a redraw, but that also changes the compute, which also triggers a redraw.\nIf you are reading a \"bound\" compute, it doesn't actually read from any child observes and just uses the cached value.  But the compute is not bound yet, so the read goes through to the child observes.\nThere's two fixes that should happen and each one would fix it.\n1.  A compute should use the same batchNum as the event that triggered them.  This is a hacky fix, but one that will improve performance in general.\n2.  I'm not sure about the other one.  We can't really avoid creating computes for arguments because this is how the two-way binding helpers works.  \nMight it be possible to create a \"capturing\" compute.  That you ignore any non-bound comptues?  No because you  might pass a non-bound compute to the template that gets read and you want to bind on it.\nMaybe it's possible to make a temporary compute that gets ignored if it's read within the master compute?  These computes will be created within can.Mustache ... if they are read within the primary compute's read ... the bindings get passed through.  I think this will work!\n(sorry for the random musings)\n. Another, possibility is to automatically prevent indicating that computes created within another compute are read.\nI'll put that another way ... the outer compute in:\n``` js\nvar me = new can.Map({name: \"Justin\"});\nvar outer = can.compute(function(){\nvar inner = can.compute(function(){\n    return me.attr(\"name\")\n  })\nreturn inner() + \" might have figured this out\"\n})\n```\nwill not listen to changes in inner.\nThe problem with this might be comptues that are used many times.  inner might be called many times.  Binding on it, and forcing it to cache it's value could have performance improvements.\nWhat's really needed is is a way to say \"you will be bound to\" to the inner compute and somehow prevent any reads within that.\nMaybe if there is a __reading ... a compute being read should add itself to the ___reading, basically preventing other reads.  Ah, I think this is it!\n. This will be brought in to master with 1.2\n. Thanks for using our frameworks. JMVC's and CanJS's X.X releases have never been fully comparable. 3.0 -> 3.1 -> 3.2 have always required changes. Fortunately, the upgrades are always relatively painless. Find/replace goes 90% of the way. \nJMVC 3.X has always been a collection of other projects. For 3.3, CanJS, jQuery++, and DocumentJS were overhauled. We are in the middle of doing the same for FuncUnit and then Steal. \nStability has not been an important factor for me for JMVC and our other technology. To maintain legacy code, you have to create a bigger download than is necessary. But more importantly, in the quickly evolving world of front end frameworks, we wouldn't be able to keep up. \nJMVC is 6 years old, but it now had things like live-binding and is about to have a component module. That's the promise if JMVC .... that the framework will be relevant 5 years from now against the backbones and angulars of the world. There will be breaking changes along the way, but you don't have to rewrite everything to keep up with the latest technology. \nI think that a more continuous release cycle might help. Fewer breaking changes at a time seems easier to deal with and easier to keep temporarily comparable. \nCanJS 1.2 will be backwards compat with 1.1, but 1.3 will not be backwards compat with 1.1. \nBut even though stability is not my focus, it's not something I am opposed to making better. If this is important to you, please help us by adding some build/test features like a way to maintain/run old tests against new code. \nSent from my iPhone\nOn Sep 19, 2013, at 3:16 AM, Wahyudinata Setiawan notifications@github.com wrote:\n\nI notice a trend of a lot of breaking changes as the framework gets updated and I am saying this as a long time user of bitovi frameworks, from JMVC 3.2 all the way to CanJS.\nFor example, our team already had a single page app written in JMVC 3.2, we assumed that upgrading to JMVC 3.3, would be a straight forward matter (it's not that we were jumping to JMVC4 we thought) but apparently not. The changes are quite fundamental that touches a lof of parts, here is the guide to upgrade, considering the size of the app, we definitely could not upgrade without investing in more engineering effort, so they are rewriting the app in CanJS instead.\nIt seems also JMVC itself is not getting a lot of love, so now the focus shifts to canjs, I might be wrong on this, but the state of the repo seems to indicate that pattern.\nI was hoping CanJS would be more stable in terms of future proofing, but alas, there are breaking changes planned already, which is the renaming of also the fundamental objects, such as Observe or List.\nSeeing this pattern is quite disheartening, it seems each update is a sweat inducing event. What will break? Do I need to refactor a lot of code? I am not sure if this qualifies as an issue, perhaps more of a request to the authors for stability, as a long fan of bitovi's work, it has been joyful to use but quite hard to keep up with the changes.\n\u2014\nReply to this email directly or view it on GitHub.\n. I've avoided semantic versioning because it doesn't easily distinguish between major breaking changes and minor. \n\nJMVC 3 was radically different from 2. Very few things would work in an upgrade.  While 3.1, 3.2, 3.3 had breaking changes, they were not breaking everything. \nThis is similar to jQuery's versioning that 1.0 -> 1.10 had breaking changes but 2.0 was very different. \nIf we followed semantic, this information would be lost. Kind of like how chrome versions have become meaningless. You can't easily label which version of chrome brought what feature. \nSent from my iPhone\nOn Sep 19, 2013, at 8:17 AM, Jared Stehler notifications@github.com wrote:\n\nIf I read the original post correctly, the main issue is not that things are changing at the API level, but that the versioning scheme is misleading. Perhaps if something more like Semantic Versioning (http://semver.org/) were used, such that breaking changes bumped the major number, that would make things clearer.\n\u2014\nReply to this email directly or view it on GitHub.\n. Ah, wow!  Good to hear from you again.  Spell checking helps.  \n\nI didn't mean to imply that we automatically look to change APIs and create legacy code.\nI was only trying to say that the most important thing to me for JMVC and CanJS is to push awesome new technology and features.  If the poor choices of the past (steal.then, can.Observe, can.Observe.List) get in the way of better ones ... the old ones have to go.  Backbone gained a ton of traction, but it's stagnated in terms of features and is being gobbled up by Angular.  \nBut, we can certainly do a better job of being backwards compat for at least one version, use semantic markup to better communicate breaking changes, and push out more versions more often.\nUnfortunately, we are limited in resources.  Getting help from the community to provide compatibility layers would make it much easier to smooth out release changes.\n. can.view(id) returns a renderer function which returns a string (not a live\nfrag). This is its API and not a bug.\nOn Friday, September 27, 2013, isadovskiy wrote:\n\nHello.\nUnder some circumstances can.view() and can.view.ejs() does not work with\nObserver/live data binding.\nHere is an example:\n\n    <p>Current Time &lt;%= model.attr('now') %&gt;\n\nvar model = new Observe({\n    now: new Date()\n});\nsetInterval(function(){\n    model.attr('now', new Date() );\n},1000);\nthis.element.append(can.view('myEJS', {model: model})); // works fine\nvar view = can.view('myEJS');\nthis.element.append(can.view('myEJS')({model: model})); // DOES NOT WORK\nthis.element.append(can.view.frag(can.view('myEJS')({model: model}))); // works fine\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/issues/483\n.\n\n\nJustin Meyer\n847-924-6039\n. It returns something different.  We probably should make these consistent.  Care to file another ticket that asks for this?\n. I can not make sense of this. Can you please describe it better?\nSent from my iPhone\nOn Oct 8, 2013, at 10:41 PM, liujingjun notifications@github.com wrote:\n\nvar me = this,\nEJS = can.view(\"app/view/view.ejs\");\nme.list = new model.List();\nme.element.append(EJS(me.list));\nWhen rendering the end when using me.List.Push ({XXX: \"XXX\"}) statement?\nme.List.Push ({XXX: \"XXX\"})?\n\u2014\nReply to this email directly or view it on GitHub.\n. @isadovskiy I would like to get this into CanJS.  Can I rename / cleanup the issue to make it clear that we would support plugins for building stache / mustache / ejs templates?  Thanks.\n. @isadovskiy are you interested in making this work similar to https://github.com/canjs/steal-stache for 3.0?  Our goal is to have these things in separate repos for 3.0, but list all of these 3rd party integrations on the homepage.  \n\nI'm going to close, but let me know and I'll create a require-stache repo.  Thanks!\n. We are going to remove this functionality in 3.0: #1435\n. @mihael has worked a bit on this. \nSent from my iPhone\n\nOn Oct 15, 2013, at 7:31 PM, Josh Dean notifications@github.com wrote:\nhttp://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/#toc-projection\nCurrently in can.Component, it seems that you can only use one tag in the component template, it seems like where components is going is to not only allow more than one content tag, but to specify what the content element projects. This is done via a select property on the content node.\nCurrently:\nDOM:\nBob\n\"hello\" Template:\n\nRendered:\nBob\nProposal:\nDOM:\n\nBob\nbob@bitovi.com\n\n\"hello\" Template:\nMy name is \nEmail me at \nRendered:\n\nMy name is Bob\nEmail me at bob@bitlvi.com\n\n\u2014\nReply to this email directly or view it on GitHub.\n. @whitecolor would you like to help make this happen?  @matthewp has been working on it.\n. As it would be a new feature, it has to be 2.2 at a minimum. \n\nSent from my iPhone\n\nOn Jun 20, 2014, at 9:18 AM, Guido Smeets notifications@github.com wrote:\nIf this gets bumped to 2.1.4 I'm willing to participate. ;) This feature is also high on my wishlist. And I have it rather sooner than later.\n\u2014\nReply to this email directly or view it on GitHub.\n. Closing for #2278 which will be far easier to implement.\n. For me, it just hasn't been an itch I've needed to scratch.\n\nYou could do something like:\njs\nresourcify = function(url, static){\n  return can.extend({\n    findAll: url,\n    findOne: url+\"/{id}\",\n    ...\n  }, static || {})\n}\njs\nMyModel = can.Model.extend(resourcify(\"/api/v1/items\"),{})\nwithout it being backed in\n. If we saw a pull request that documented it well, and didn't add much code, I'd accept it.  Thanks!\n. @mjstahl This should be a property, not a function, like:\n@property {String} can.Model.resource\nIt doesn't return anything.\n. @simpleTechs / @daffl \nAnyway you can provide a simple explanation of what's going on?  Reading this issue on its own gives no insight to the problem. \n. @ccummings can you include a bit more info directly in this issue so people don't have to dig to understand it?\n. I'm closing this unless someone really needs it.\nIn the mean time, I'll be focusing on landing slots: https://github.com/canjs/canjs/issues/2278 and inline partials: https://github.com/canjs/can-stache/issues/3 which should cover much of what's needed here.\n. A fiddle would not show this breaking because this is fixed for 2.0.1.  Have you tried it with that code?\n. why?  What good would this do?  It's nice to look at the DOM and have some idea of how things were passed to the component.\n. As can.Component's external API is designed for the benefit of non-JS devs, for example designers who know a bit of HTML, removing the attributes would be unexpected.  When you add attribute to a traditional HTML element, they are not removed.\n. The browser engine is not impacted in terms of performance. These things are not excessive to me. \nAlso, per our roadmap, we want to support attribute mutation events. This would allow you to change the value of the paginator attribute via $.fn.attr. In this case, it certainly makes sense to maintain the dynamic attributes because they are similar to className and other dom attributes. \nSent from my iPhone\n\nOn Oct 26, 2013, at 5:47 AM, Alex Osh notifications@github.com wrote:\nBesides I'm talking of removing attributes that contain data attributes names not string data (as they really can be used in CSS for example).\n\ndirection attribute can be lately used and it make sense to leave it alone, but \"paginator\" is exessive for user's eye and for browser engine either.\n\u2014\nReply to this email directly or view it on GitHub.\n. Deleting it would remove that property from the scope. \n\nSent from my iPhone\n\nOn Oct 26, 2013, at 3:57 PM, Alex Osh notifications@github.com wrote:\nI understand your point =) You are the boss, I'm not trying to persuade you any more. But I will state some logical flaws in your arguments (from my point of view) , maybe it will help later.\nWhen I talk that they are exessive I'm not even tacking about browser's performance.\n\"class\" attribute (as \"id\", \"name\" etc) are used to identify elements either in JS code or in CSS. When you change element's class it will probably impact the presentation of the element at once, or this change will affect some JS logic later. If it is not it should not be there \"just to explain to designer/dev/user how things work\".\nIn terms of my last point, even with mutation support it doesn't make sense to keep them after code caught up the event of attr change and hooked up new value. Then attr can be deleted again without any consequences. (actually I don't really understand the need of it. You can make now by some custom $.fn. function that would do that - only to get rid of some custom $.fn and use standard features)\n\u2014\nReply to this email directly or view it on GitHub.\n. The id element does not impact presentation. Also, changing the value of these attributes would almost certainly impact the presentation layer. \n\nSent from my iPhone\n\nOn Oct 26, 2013, at 3:57 PM, Alex Osh notifications@github.com wrote:\nI understand your point =) You are the boss, I'm not trying to persuade you any more. But I will state some logical flaws in your arguments (from my point of view) , maybe it will help later.\nWhen I talk that they are exessive I'm not even tacking about browser's performance.\n\"class\" attribute (as \"id\", \"name\" etc) are used to identify elements either in JS code or in CSS. When you change element's class it will probably impact the presentation of the element at once, or this change will affect some JS logic later. If it is not it should not be there \"just to explain to designer/dev/user how things work\".\nIn terms of my last point, even with mutation support it doesn't make sense to keep them after code caught up the event of attr change and hooked up new value. Then attr can be deleted again without any consequences. (actually I don't really understand the need of it. You can make now by some custom $.fn. function that would do that - only to get rid of some custom $.fn and use standard features)\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes, we should camel case hyphenated attrs.  \n\nSent from my iPhone\n\nOn Oct 29, 2013, at 4:00 PM, Alex Osh notifications@github.com wrote:\nGreat, interesting what HTML spec says about converting colon (:) in HTML attribute on JS side.\n\u2014\nReply to this email directly or view it on GitHub.\n. It is not used anywhere. \n\nSent from my iPhone\n\nOn Oct 25, 2013, at 8:03 AM, Alex Osh notifications@github.com wrote:\nI wonder why can.camelize was removed from can utils?\n\u2014\nReply to this email directly or view it on GitHub.\n. This might be fixed by #883.\n. Shoot. Fixed this last night but did not push. \n\nSent from my iPhone\n\nOn Oct 29, 2013, at 3:29 PM, Josh Dean notifications@github.com wrote:\nClosed #515 via 4e1580e.\n\u2014\nReply to this email directly or view it on GitHub.\n. A session isn't likely necessary for this one.\n\njQuery does a lot of special things when registering an event listener: https://github.com/bitovi/canjs/blob/master/lib/jquery.1.9.1.js#L2721\nFor example, it handles special events, event delegation, namespaces, events on HTMLElements.\nOur addEvent does far less:\nhttps://github.com/bitovi/canjs/blob/master/util/event.js#L8\nIt basically pushes the handler on an array.\nThere's a LOT of event binding going on when you render 200 items in TodoMVC.  It was the dominate part of the runtime.  We replaced the observable event binding with something MUCH faster.\n. This is partially because \njs\nfoo = {}\nfoo.foo = foo;\n$.extend(true,{}, foo)\nbreaks.  This might result in a won't fix as it would require replacing some jQuery functionality with our own.  It does support circular structures, just not on initialization.\n. Fixing a bug is normally a patch right!\nSent from my iPhone\n\nOn Nov 11, 2013, at 2:14 PM, David Luecke notifications@github.com wrote:\nI'm fixing this in another pull request. But has that event issue ever been dealt with? If our own stuff already breaks I am very opposed to changing this in a patch version.\n\u2014\nReply to this email directly or view it on GitHub.\n. This was not something we claimed to support. Other library versions don't have anything like it. \n\nSent from my iPhone\n\nOn Nov 11, 2013, at 5:00 PM, David Luecke notifications@github.com wrote:\nChanging the event system only fixed a rather minor bug and to speed things up. It's hard to believe that nobody will use something like ev.stopImmediatePropagation(); in their own CanJS based projects which will break when upgrading a patch version.\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes\n\nSent from my iPhone\n\nOn Nov 11, 2013, at 6:46 PM, David Luecke notifications@github.com wrote:\nI think I got that wrong anyway. Looks like we're still dispatching jQuery events in a control so it's just the can.Map event system right?\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks!  I'm going to work on fixing this for 2.0.1.  In the short term, if you do:\n\nhere is me {{#test}}{{firstname}} {{lastname}}{{/test}}\nit will work\n. https://github.com/bitovi/canjs/issues/milestones\n. If you believe this is a bug, please open a new issue and reference this commit.\n. We need to setup grunt to test different versions of jQuery.\nYou'll probably have to add other configurations to builder.json like \"jquery-1.9\" and \"jquery-2.0\" that load different things for \"jquery/jquery.js\".\nAnd, the gruntfile needs to be setup to test the different pages.  The qunit object should probably be built from builder.json.\n. Why bower? Would npm be enough?\nSent from my iPhone\n\nOn Nov 5, 2013, at 5:26 PM, David Luecke notifications@github.com wrote:\nThis pull request uses Bower to install Qunit, jQuery and Zepto and introduces a jQuery legacy (1.10) configuration (as mentioned in #526) and removes supported libraries from being checked directly into the repository.\nbower install will run as an NPM post-install script. Although this is considered to be an anti pattern this should be ok here as NPM is only used for development. Re-run npm install after updating from this PR to get the bower components.\nYou can merge this Pull Request by running\ngit pull https://github.com/bitovi/canjs bower-multi-jquery\nOr view, comment on, or merge it at:\nhttps://github.com/bitovi/canjs/pull/529\nCommit Summary\nChanging QUnit and references to Bower component.\nAdding bower.json for client side dependencies.\nMerge branch 'master' of github.com:bitovi/canjs\nMoving jQuery and Zepto to Bower components. Adding jQuery legacy (1.X).\nRemoving old Mootools version and Bower dependency (since it is pretty useless).\nFile Changes\nM .gitignore (1)\nA bower.json (18)\nM builder.json (25)\nM component/test.html (4)\nM compute/test.html (4)\nM construct/proxy/test.html (4)\nM construct/super/test.html (4)\nM construct/test.html (4)\nM control/modifier/qunit.html (4)\nM control/plugin/test.html (4)\nM control/route/test.html (4)\nM control/test.html (4)\nM control/view/qunit.html (4)\nD lib/jquery.1.9.1.js (9600)\nD lib/mootools-core-1.4.3.js (5905)\nD lib/qunit/qunit.css (244)\nD lib/qunit/qunit.js (2152)\nM lib/stealconfig.js (111)\nD lib/zepto.1.0.js (1565)\nD lib/zepto.1.0rc1.js (1355)\nM list/test.html (4)\nM map/attributes/test.html (4)\nM map/backup/test.html (4)\nM map/delegate/test.html (4)\nM map/setter/test.html (4)\nM map/sort/test.html (4)\nM map/test.html (4)\nM map/validations/test.html (4)\nM model/cached/qunit.html (4)\nM model/queue/qunit.html (4)\nM model/test.html (4)\nM observe/test.html (4)\nM package.json (84)\nM route/pushstate/test.html (4)\nM route/test.html (4)\nM test/amd/dojo.html (4)\nA test/amd/jquery-legacy.html (156)\nM test/amd/jquery.html (6)\nM test/amd/mootools.html (4)\nM test/amd/yui.html (4)\nM test/amd/zepto.html (6)\nD test/build/dojo.html (53)\nD test/build/index.html (55)\nD test/build/jquery.html (57)\nD test/build/mootools.html (53)\nD test/build/yui.html (53)\nD test/build/zepto.html (53)\nM test/dist/dojo.html (4)\nA test/dist/jquery-legacy.html (91)\nM test/dist/jquery.html (6)\nM test/dist/mootools.html (4)\nM test/dist/yui.html (4)\nM test/dist/zepto.html (6)\nM test/dojo.html (4)\nA test/jquery-legacy.html (83)\nM test/jquery.html (6)\nM test/mootools.html (4)\nM test/templates/configuration-amd.html.ejs (4)\nM test/templates/configuration-dist.html.ejs (4)\nM test/templates/configuration.html.ejs (4)\nM test/templates/test.html.ejs (4)\nM test/yui.html (4)\nM test/zepto.html (6)\nM util/event/test.html (4)\nM util/string/qunit.html (2)\nM view/bindings/test.html (4)\nM view/ejs/test.html (4)\nM view/live/test.html (4)\nM view/modifiers/test.html (4)\nM view/mustache/test.html (4)\nM view/scope/test.html (4)\nM view/test.html (4)\nPatch Links:\nhttps://github.com/bitovi/canjs/pull/529.patch\nhttps://github.com/bitovi/canjs/pull/529.diff\n. can.fixture is always asynchronous.  Why are you doing this?\n. We might be able to change that. But I wanted to know why you are making sync requests to get a feel for how common the use case is. \n\nSent from my iPhone\n\nOn Nov 8, 2013, at 4:15 PM, Karthi notifications@github.com wrote:\nOh I didn't know that 'can.fixture' is always async, thanks for letting me know.. I wanted to make a sync service call, till the service is ready I'm trying to mock the service call with fixture..\n\u2014\nReply to this email directly or view it on GitHub.\n. Can you create a test because #1 works for me?\n. This does not appear to be an issue.  The fiddle you linked to in 508 is broken because your code is incorrect. my-toggler's methods should be changing  \"shown\" not visible.  \n\n```\ncan.Component({\n    tag: \"my-toggler\",\n    template: \"{{#if visible}}{{/if}}\",\n    scope: {\n        shown: true,\n        show: function(){\n            this.attr('shown', true)\n         },\n         hide: function(){\n            this.attr(\"shown\", false)\n         }\n    }\n})\ncan.Component({\n    tag: \"my-app\",\n    scope: {\n        visible: true,\n        show: function(){\n            this.attr('visible', true)            \n        }\n    }\n});\nvar template = can.view.mustache(\"\"+\n    '{{^visible}}show{{/visible}}'+\n    ''+\n    'content'+\n    'hide'+\n    ''+\n    '')\nvar frag = template({})\n```\nWhat's your email address?  Can you shot me a message at Justin AT Bitovi?\n. I'm not sure what you are talking about. Please submit a breaking test. The code in your fiddle was wrong. \nSent from my iPhone\n\nOn Nov 11, 2013, at 5:12 PM, Alex Osh notifications@github.com wrote:\nWell there was another code in my version that I updated from master a couple of days before I found out this issue:\n// there's a value, setup two-way binding ...\n                twoWayBindings[name] = propertyDataFromScope.parent\nand in current version it is:\n// setup two-way binding\n                twoWayBindings[name] = computeData\nOk. But some problems still remain.\n\u2014\nReply to this email directly or view it on GitHub.\n. Nested properties as defaults will not work the way you are using them. \n\nSent from my iPhone\n\nOn Nov 11, 2013, at 5:32 PM, Alex Osh notifications@github.com wrote:\nthis is broken in latest version:\nhttps://gist.github.com/whitecolor/7422552\nbecause I try to bind the nested property\n\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes, but you should still be able to do this.attr('blocks', 45 ).  This keeps a component's internal API consistent no matter what you pass it.\n. Thanks!\n. Is it necessary to use the control in that example to create the memory leak?\n. I was stupidly not binding to a \"change\" event and unbinding it correctly.  GREAT pickup.  Seriously.  It would have taken a while to notice that.\n. It should not work like: can.route.attr('test/:id', { id: 123 })\n\nYou need to give your routes deterministic state like can.route(\":page/:id\")\nSent from my iPhone\n\nOn Nov 15, 2013, at 10:56 AM, David Luecke notifications@github.com wrote:\nThis looks pretty good. I always felt there is some weirdness going on in our routing. E.g. with can.route('test/:id') and can.route('other/:id') what happens if I do can.route.attr('id', 1234)?\nI think it should actually be can.route.attr('test/:id', { id: 123 }). This looks like a good step in the right direction.\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm open to this.  After talking about it with @daffl, we need to make matching state easier.  The delegate plugin is a (poor) attempt to solve this.   This looks like an interesting solution for 2.1.\n\nHowever, it seems like can.route() is being called for each control \"route\" method.  \njs\nif ( !can.route.routes[selector] ) {\n                        can.route( selector );\n}\nShould we turn that off and force people to define the routes explicitly?  I'm not sure how it actually works otherwise.  For example in:\n\"/r1/:id route\" : function () {\n            console.log('route updated to /r1/:id');\n        },\nis can.route.attr(\"view\") === r1?\n. I'm moving this to 3.0 because I think it's a great idea, but would require breaking API changes.\n. Actually, it's because this.on automatically calls the function back with this as the control so that var self is unnecessary.  Anyway you can submit a pull that just removes the var self?\n. Actually .. maybe not.  Great catch!\n. A short description / example of what's going on here would be really helpful.\n. I'm going to make this work with can.List by default and only use a delimitated string if the value of the cross bound property is a string.\n. Yeah, I even documented it.  Closing.\n. This is by design.  You shouldn't have cycles like this.  Use setters if you want to change the value.\nBut, in the case above, frag was never actually inserted into the page, that is why \"inserted\" never fired.  Good pickup.  I'm going to close the issue.\n. It would not be more efficient to pass a fragment and then convert it back to a string. Why not use  which the browser will not process the internals, already gives you a string, and works with can.view?</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Nov 18, 2013, at 9:40 AM, Steven Vachon notifications@github.com wrote:</p>\n<p>I am using cujojs/curl.js, similar to steal.production.js only smaller.</p>\n<p>I am loading in template html files that contain multiple <template> tags, to keep file size down:</p>\n<p>&lt;!DOCTYPE html&gt;\n<html>\n<head>\n<meta charset=\"utf-8\"/>\n<title>Application 1 Templates</title>\n</head>\n<body></p>\n<p><template id=\"main-part\">\n    main application template\n    {{#if something}}{{&gt;some-dialog}}{{/if}}\n</template></p>\n<p><template id=\"some-dialog\">\n    <aside role=\"dialog\">{{message}}</aside>\n</template></p>\n<p></body>\n</html>\nand registering them with:</p>\n<p>function registerTemplate(html)\n{\n    var fragment = can.view.fragment(html);</p>\n<p>```\nif (fragment.hasChildNodes())\n{\n    for (var i=fragment.childNodes.length-1; i&gt;=0; i--)\n    {\n        var child = fragment.childNodes[i];</p>\n<pre><code>    if (child.nodeType!==1 || child.nodeName!=\"TEMPLATE\")\n    {\n        child.parentNode.removeChild(child);\n    }\n    else\n    {\n        var contents = $.trim( child.content ? fragmentToString(child.content) : child.innerHTML );\n\n        can.view.mustache(child.id, contents);\n    }\n}\n</code></pre>\n<p>}\n```</p>\n<p>}</p>\n<p>function fragmentToString(fragment)\n{\n    var temp = document.createElement(\"div\");</p>\n<p>```\ntemp.appendChild(fragment);</p>\n<p>return temp.innerHTML;\n```</p>\n<p>}\nInstead of having to convert the fragment to a string (in modern browsers), it'd be much more efficient to just pass a fragment:</p>\n<p>function registerTemplate(html)\n{\n    var fragment = can.view.fragment(html);</p>\n<p>```\nif (fragment.hasChildNodes())\n{\n    for (var i=fragment.childNodes.length-1; i&gt;=0; i--)\n    {\n        var child = fragment.childNodes[i];</p>\n<pre><code>    if (child.nodeType!==1 || child.nodeName!=\"TEMPLATE\")\n    {\n        child.parentNode.removeChild(child);\n    }\n    else\n    {\n        var contents = child.content ? child.content : $.trim(child.innerHTML);\n\n        can.view.mustache(child.id, contents);\n    }\n}\n</code></pre>\n<p>}\n```</p>\n<p>}\n\u2014\nReply to this email directly or view it on GitHub.\n. But nothing within the script is processed unlike the template. </p>\n</blockquote>\n<p>No, it's converted to a function. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Nov 18, 2013, at 9:54 AM, Steven Vachon notifications@github.com wrote:</p>\n<p>Multiple <script> templates within a single file would still have to be parsed as separate elements.</p>\n<p>Doesn't can.view.mustache() just convert a string to a fragment before running other procedures?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. I'm not sure what you mean.  How does a template get imported just as text?\n. I'm not sure what you mean still.  Maybe you mean how would a \"template\" file get processed, not a \"<template>\" element if it was in another file?</p>\n</blockquote>\n<p>You typically wouldn't write <code>can.view(\"file.html\")</code>. You write <code>can.view(\"file.mustache\")</code></p>\n<p>This loads the string like:</p>\n<p><code>&lt;h1&gt;{{message}}&lt;/h1&gt;</code></p>\n<p>parses it, and converts it to a function like:</p>\n<p><code>js\ntemplate = function(data){\nvar str = \"'\";\nstr+=\"&lt;h1&gt;\"\nstr+= Mustache.get(\"message\", data)\nstr+= \"&lt;/h1&gt;\"\nreturn str;\n}</code>\n. closing this issue ...\n. By default, <code>attr</code> merges.  Add true to do a hard set:</p>\n<p><code>js\nabc.attr([], true)\nabc.attr([\"3\"], true)</code></p>\n<p>http://canjs.com/docs/can.List.prototype.attr.html#sig_list_attr_elements__replaceCompletely__\n. Not anymore. You can add defaults to the prototype directly now. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Nov 20, 2013, at 1:59 PM, David Luecke notifications@github.com wrote:</p>\n<p>Defaults should only work with the attributes plugin anwyay. I'll look into why it isn't updating that properly.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. http://canjs.com/docs/can.Map.prototype.DEFAULT-ATTR.html</p>\n</blockquote>\n<p>documented.  I'll change the test to reflect.\n. Arg, I should have sorted all this out for 2.0.  The problem is that updated / created is ran through Model.model() which creates a new instance.  That new instance will have default properties that will overwrite the original properties.\n. @daffl I'm not sure the best way of fixing this and keeping backwards compatibility. The problem is that\n.models should not be called by update and create.  But this was forced for #301.</p>\n<p>The long-term fix is to support a <code>.parseModel()</code> and <code>.parseModels()</code>.  These would be called to get data from the server.  <code>.model</code> and <code>.models()</code> would call this and so would <code>update</code> and <code>create</code>.</p>\n<p>For 2.0.3, I am thinking that if <code>.parseModel</code> or <code>.parseModels</code> is provided things will work.  If <code>.model</code> and <code>.models</code> are not provided, things will work.  But, if <code>.model</code> and <code>.models</code> are provided without <code>.parseModel</code> and <code>.parseModels</code> it will break.\n. Oh, if .models is a string, I will set that as .parseModels too.\n. If you are using the default .models method, set removeAttr to true:</p>\n<p><code>can.Model.extend({\n  removeAttr: true\n},{})</code></p>\n<p>This needs to be documented.\n. I think this is resolved.\n. I'm going to merge this into minor.\n. Why would other libraries have problems with it?  They are being tested. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Nov 25, 2013, at 9:36 AM, David Luecke notifications@github.com wrote:</p>\n<p>The component inserted event does not work with jQuery 1.10 (and probably 2.0). There is the possibility that other libraries have issues with that as well.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Where does it say a pushstate object is created?</p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Nov 25, 2013, at 11:00 AM, Steven Vachon notifications@github.com wrote:</p>\n<p>can.route.bindings.pushstate seems to work, but does not fit the docs.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. I'll update the docs.  Thanks for pointing this out.\n. The docs are incorrect.  I originally wanted <code>can.route.pushstate</code>, but changed the implementation so <code>can.route.bindings.pushstate</code> was much easier and smaller to implement. It also meant that you are able to toggle between pushstate and hashchange without refreshing the browser.</p>\n</blockquote>\n<p>However, to make this a little less verbose, we can add a <code>can.route.root()</code> method that does the same thing.\n. reopenned until I fix the docs.\n. The core reason this is happening is that not-yet-defined live binding only works on the most-likely and highest <strong>context</strong> for performance reasons.  That means if I do:</p>\n<p><code>{{#name}}{{age}}{{/name}}</code></p>\n<p><code>js\nvar person = can.Map({\n  name: {}\n})\ntemplate(person)</code></p>\n<p>When the template is rendered, <code>age</code> is undefined so it sets up a binding on the nested <code>name</code> map for \"age\".  This means if I were to do:</p>\n<p><code>js\nperson.attr(\"age\",31)</code></p>\n<p>The tempalte would not be updated, but it would be with:</p>\n<p><code>js\nperson.attr(\"name.age\",31)</code></p>\n<p>It's this way so we only have to read one context when something changes.  This makes it much faster to get a new value for live-binding.  The cached lookup path is used here: https://github.com/bitovi/canjs/blob/master/view/scope/scope.js#L274.</p>\n<p>How this relates to your fiddle ....</p>\n<p>When a component is created, a new context is created from the \"scope\" object on the component (terrible naming I know).  That context has no <code>notyetset</code> property.  When ___Click Me__ is clicked, it adds a <code>notyetset</code> to <code>this.counter</code> which is not the same object as the component's context.  This is why <code>notyetset</code> does not show up within the component ... it's looking for <code>notyetset</code> on the component's context.</p>\n<p>The only fix for this might be to make live-binding able to walk the entire context over and over (potentially binding on every can.Map in the scope) until a value is found, and then falling back to the higher performance method it uses today.</p>\n<p>A fix for this would be to add <code>../</code> in <code>{{../notyetset}}</code> like I've done here: http://jsfiddle.net/VRE8Z/4/.</p>\n<p>@daffl I'm not sure this should be in 2.0.4, 2.1 seems more reasonable as it won't be a super easy fix and there's a workaround.\n. Punting on this for 2.1 b/c there is a work around and I'm nervous to change the performance of apps when this release is so close.\n. This is probably much more easy to accomplish now that I've pulled out the compute that reads from the scope into this module: https://github.com/bitovi/canjs/blob/master/view/scope/compute_data.js#L39 to fix #1617.</p>\n<p>It should be possible now to detect if we've actually found the right root observable (because there is a value) and only then stop walking up the entire scope.\n. @gsmeets Help would be great.  However, my hesitation has been around performance.  With a very nested structure, this could mean making 50 or so bindings, one on every observable object in the scope chain.</p>\n<p>I suppose we could take the performance cost but let people know to either use:\n- leakScope: false\n- default their undefined values to null\n- use ../</p>\n<p>To get back any performance losses.\n. @gsmeets Added a pull request.  Please try this with your app and let me know if it works and performs ok.\n. Awesome!  Thanks for the test!\n. There is no way to do this other than to listen to the observable changing that causes the change in the DOM.  You can listen to DOM mutation events depending on your browser.</p>\n<p>This seems like more of a question, so I'm going to close it.  Questions like this are best asked on the forum.  If this is something you would like to see implemented, please create a new issue with a suggested approach.  Thanks!\n. How does it get the map?  Can you add a test or a better explanation of the setup code. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Nov 29, 2013, at 2:22 PM, David Luecke notifications@github.com wrote:</p>\n<p>A component with a simple template like</p>\n<p><code>&lt;ul&gt;\n    {{#each data}}\n    &lt;li&gt;{{@key}} : {{.}}&lt;/li&gt;\n    {{/data}}\n&lt;/ul&gt;</code></p>\n<p>Will not iterate as expected over the values in the data map. With a map like</p>\n<p><code>var data = new can.Map({\n    some: 'test',\n    things: false,\n    other: 'things'\n});</code></p>\n<p>The template in a component will output:</p>\n<p>: [object Object]\n: .map3\n: [object Object]\n: test\n: false\n: things\n: [object Object]\n: 5\nWhere the same template rendered via Mustache directly renders the correct</p>\n<p>some : test\nthings : false\nother : things\n\u2014\nReply to this email directly or view it on GitHub.\n. Odd, my email did not include the fiddle link, but the website does. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Nov 30, 2013, at 2:47 AM, David Luecke notifications@github.com wrote:</p>\n<p>I thought the Fiddle illustrates the issue. As far as I can tell it doesn't really matter how the component gets the map (pre-initialized, as a plain object on the prototype or set as .attr in the inserted event)..</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Thanks! We will need a test before it finds its way into core. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Dec 1, 2013, at 2:28 PM, Helidium notifications@github.com wrote:</p>\n<p>...)</p>\n<p>Hi I was using canjs with new pushstate functionality. All is working well in chrome / opera but not in firefox. The browser stopped listening to url changes all of the sudden after a couple of seconds of inactivity. The most bizzare situation which I am still not familiar with was when I changed any map property with attr the setState was called, otherwise not.</p>\n<p>Anyway I deleted the push/replacestate override and call the setState in the click handler.</p>\n<p>You can merge this Pull Request by running</p>\n<p>git pull https://github.com/Helidium/canjs patch-1\nOr view, comment on, or merge it at:</p>\n<p>https://github.com/bitovi/canjs/pull/584</p>\n<p>Commit Summary</p>\n<p>Update pushstate.js ( Fix for firefox push/replacestate override problem)\nFile Changes</p>\n<p>M route/pushstate/pushstate.js (16)\nPatch Links:</p>\n<p>https://github.com/bitovi/canjs/pull/584.patch\nhttps://github.com/bitovi/canjs/pull/584.diff\n. @daffl Any reason this would be in 2.1 instead of 2.0.4?</p>\n</blockquote>\n<p>@Helidium can you create a fiddle that shows this problem off?  It would help a lot.\n. I think the issue is that other libraries might call pushState and we want to know when that happens.\n. Moving to 2.2.\n. I'm not exactly sure how that example is working.  It should look like: http://jsfiddle.net/donejs/8DeMY/4/ (I've removed the can.Control b/c it is unnecessary).</p>\n<p>You need to call the renderer function.  jQuery's <code>append</code> must be calling it internally, but that's not how it's supposed to work.</p>\n<p>I'm closing b/c it doesn't seem to be a bug.\n. Yes, you can use can.Components within a control.  However, for the purposes of examples / tests / etc, it only complicates them.\n. As I hinted in my first comment, I bet if you pass <code>append</code> a function, it calls the function and uses the result to insert into the page.<br />\n. I think this might be best asked on the forums.  Also, I'm not sure what you mean by \"without creating a history index\".\n. this is with pushstate?\n. Can you create a fiddle showing this happening? If it looks like there's a bug, I'll reopen and change the issue's text to describe it as a problem, not a question.\n. Is it possible to register a few changes in the history, then call .back() and see if the url stays the same?\n. Can you add a description / example?  Why is trailing slash support needed?  If you wanted to match everything under <code>foo/</code>, you can set the root to <code>foo</code>.\n. I still don't really understand.  Can you give me a code example or fiddle?  Afaik, trailing slashes already work.\n. Could you change that to:</p>\n<p><code>js\ncan.route.bindings.pushstate.root = \"/\";\ncan.route(\":section/\");\ncan.route.ready();</code></p>\n<p>As far as the other example, that is what I would expect.  You can probably fix that like:</p>\n<p><code>js\ncan.route.bindings.pushstate.root = \"/\";\ncan.route(\":section/\",{\n  sub: \"\"\n});\ncan.route(\":section/:sub/\");\ncan.route.ready();\ncan.route.attr({section:\"test\",sub:\"\"});</code>\n. Ok, so that's a bug.  I'll try to fix this asap.\n. Ok, I created a test that looks like:</p>\n<p>``` js\n    test(\"trailing slashes (#588)\", function(){\n        can.route.routes = {};\n        can.route.bindings.pushstate.root = \"/\";</p>\n<pre><code>    can.route(\":section/\");\n    res = can.route.param({section: \"test\"});\n\n    equal(res, \"test/\");\n\n    var obj = can.route.deparam(\"foo/\");\n    deepEqual(obj, {\n        section : \"foo\",\n        route: \":section/\"\n    });\n\n});\n</code></pre>\n<p>```</p>\n<p>And it passes.  I'm a bit confused.  How are you creating the link?\n. If I do:</p>\n<p>```\n<script>\n    steal(\"can/route/pushstate\", function(){\n        can.route.bindings.pushstate.root = \"/\";\n        can.route(\":section/\");\n        can.route.ready();</p>\n<pre><code>    $(document.body).append(\"&lt;br/&gt;\",can.route.link(\"foo\",{\n        section: \"foo\"\n    }))\n\n    can.route.bind(\"section\", function(ev, newVal){\n        console.log(\"section updated to\",newVal)\n    })\n})\n</code></pre>\n<p>\ntest\n```\nThis calls back the section event handler.  You'll notice that the link has to include the root's / like: <a href=\"/test/\">test</a>.  To make this easier, use can.route.link.\n. I'm going to close unless as there does not appear to be a bug.  Please comment if I'm missing something.\n. @stevenvachon I'm not sure.  Let chat on skype tomorrow: justinbmeyer.\n. This is confirmed working with @stevenvachon \n. I've confirmed this is indeed more than 10x slower.  It seems that just setting madeMap = null; is the slow part.  I'm going to have to think over this one.\n. Ok, I figured this out.  The problem is not teardownMap.  The issue is that when teardownMap is removed, only 300 objects are created instead of 300000.  \nThis is because by removing teardownMap it doesn't re-create that big List of maps, it just uses the first one created when when the big plain array is passed to .attr('obj', objects) for the first time.  \nClosing... however, I'm going to work on getting a benchmark workflow into canjs.\n. Performance did not become worse.  There was a bug that made it appear faster than it was.  You could get the same speed as changing your above code to:\n``` js\nvar map = new can.Map(),\n      objects = [];\n        for (var i = 0; i < 100; i++){\n            objects.push({prop: 'prop', nest: {prop: 'prop', nest: {prop: 'prop'}}})\n        }\n        var objectList = new can.List(objects)\n        var start = new Date()\n\n        for (var j = 0; j < 100; j++){\n            map.attr('obj', objectList)\n        }\n        var time = (new Date() - start)/1000\n\n        // time is ten times more with tearing down than without it\n        console.log('time', time)\n\n```\nThis was added to solve #521 \n. Closing.  Can be moved into can-connect if it's important.\n. @matthewp can you add more details?\n. This means the items added are not properly registering themselves in node_list.\n. Closing because of pull request #614 \n. On first thought, this might be difficult to fix.  While parsing the template, can.Mustache essentially hard-codes something like {{name}} to call can.view.live.text.   We'd have to wait until \"runtime\" to determine if it should call can.view.live.html instead.\n. Did this include any docs?\n. This is not a bug.  There is no \"234\" value in the current scope of <results-tag>.  It is trying to look up a value called \"234\" finding nothing and maping \"234\" to undefined.\nHowever, to make what you want work, you can always read from el.attr(\"notworkingattr\").\n. Please provide an example of what you mean.\n. Thanks.  I will check this out tomorrow.\n. @marshallswain You are not able to do that with can.Control.  However, it's best to separate distinct ideas into their own issue so not to confuse / lose things.\nBtw, I'm of the opinion that can/control/route should be removed from CanJS.  You should be listening to changes in  can.route like you do a can.Map.  I've talked about this a lot on the forums.  If you want to know more, please bring it up there.\n. @marshallswain I'm not sure exactly what this fixes as a test is not included. Anyway you can share something that  I can verify breaks before and is fixed after the code changes?\n. @marshallswain Why are you putting slashes in-front of your routes?  Would everything work if you didn't have a slash?\nAlso, I think you should be checking if the route starts with can.route.bindings.pushstate.root not only /.  \nI'm going to move this to 2.0.5 as it needs some more discussion.  \nThanks a ton for your help!\n. Thanks.  Will checkout.\n. #620 includes a fix and your test.  Thanks for the test!\n. I didn't include https://github.com/bitovi/canjs/commit/deadeab6de507247fbe120d2cd8164480c5099fe and I wanted to make sure you didn't merge while I was still working on it.\n. I actually noticed that today while reviewing can.Map's source code.  _attrs doesn't call .attr() which calls can.__reading to signal live-binding.\n. Thanks.  Anyway you could add a test?  Also, can you add a check that it updates if you add a property too?  You will need to tell __reading about the __keys event (you can find this happening other places).\nAh, too bad you missed the hangout today where I went over can.Map in detail :-).\n. @onyxrev Thanks big time for the fix!\n. There already is custom Map support. Please check List's Map property. \nSent from my iPhone\n\nOn Dec 22, 2013, at 11:39 AM, Steven Vachon notifications@github.com wrote:\nI have written can.Transition.Map and can.Transition.List classes that extend their respective supers. It'd be great if I could, without modifying can.Map, easily set can.Transition.Map's .List from can.List to can.Transition.List.\n\u2014\nReply to this email directly or view it on GitHub.\n. Why did the test not catch it?\n\nSent from my iPhone\n\nOn Dec 23, 2013, at 5:55 PM, David Luecke notifications@github.com wrote:\ndfc88b4 introduced several fixes for #each but broke iterating over a previously undefined list.\nFiddle: http://jsfiddle.net/G54Vz/\nThis is a regression issue and worked in 2.0.3: http://jsfiddle.net/G54Vz/1/\n\u2014\nReply to this email directly or view it on GitHub.\n. We do. I think you have to set the static id property: http://canjs.com/docs/can.Model.id.html\n. In your example, what is the difference between {item} and  {{item}}?  Both would seemingly pass the item object in the scope.  Unless you were somehow specifying the presence or absence of 2 way binding between the component's scope's item and its source value.\n\nIn my opinion, it is unambiguous. It is always the object in the scope unless the component decides differently with:\njs\nscope: {\n  item: \"@\"\n}\nThis would be a big-time break of backwards compat so it's not really possible short term.  It might be possible to support something like:\nitem=\"@item\"\nfor strings and\nitem=\"{item}\"\nfor objects.  Plus, I want the templates looking pretty, so I'm not inclined to force {} all the time.\n. This is done in stache\n. Check if this also breaks with the define plugin and latest FF.\n. Closing for #1437.\n. How do I see @@!!@@ in the fiddle?\n. @stevenvachon why not just have can.mustache and can.ejs?  No one uses can.Mustache.\n. Couldn't the same be said of can.Construct and everything that inherit, uses it?\nWhat are you after that confuses you?  Almost everything important is in Mustache/EJS.\nI'm actually going to pull out bindings too. I don't want everything hidden under can.view. \nSent from my iPhone\n\nOn Jan 29, 2014, at 7:12 PM, Steven Vachon notifications@github.com wrote:\nIt just seems a little separated to me to have can.view and can.mustache when mustache is view-related. It confuses me every now and then and I've noticed the same for others on IRC. The separation in the docs sometimes creates a delay in finding what I'm after.\n\u2014\nReply to this email directly or view it on GitHub.\n. I just updated with can.view.attr's docs.\n. How does document.regsiterElement fit in with can.view.tag?\n. This has been merged into minor. #641\n. I assume it works if you aren't using Rails and uglify?  There's likely some setting that's removing the super check.  Can you look into what happens if you use regular ol uglify?  (I want to avoid setting up rails).\n. By \"it\" you mean some other case than the one tested in https://github.com/bitovi/canjs/commit/cb849f3daba0141f307dd327c8ae04107b771c92 ?\n. This seems to be related to using partials:\n\nhttp://jsfiddle.net/j9ZBw/5/\n. @AdamTourkow After looking at this fiddle for a bit, I hope this is just an example and your code does not work like this.  Items should not be capitalized, plus it's a map.\n. Here's a minimal breaking example: http://jsfiddle.net/j9ZBw/7/\n. It seems there is a difference between how the partial is found.  http://jsfiddle.net/j9ZBw/9/ breaks, but if you change:\n{{>anitem}}\nto \n{{>itempartial}}\nIt works.  My bet is that this is due to a bug with renderer functions not actually being renderer functions.\n. Nope, seems to be due to to reading a partial in can.view.render.txt being \"compute-itized\" .... \n. merged this into minor myself ...\n. @stevenvachon deparam should get the \"matching part of the url\" like:\nhttps://github.com/bitovi/canjs/blob/master/route/route.js#L426\nmatchingPartOfTheUrl returns the part of the url will match routes like \":/section\".\n. So yeah, deparam expects: \"test/\" so closing ...\n. .attr(\"prop\", compute) currently (and in my opinion) should set the value of prop to the compute.  When .attr(\"prop\") is called again, the compute is returned.\n. @whitecolor I'm not sure what\n\n// this would bring window-manager scope to \"windowManager\" scope property of current component\n\nmeans.\nAlso,\n'windowManagerProp': 'window-manager prop'\nshould be written (I think):\n'window-manager prop': 'windowManagerProp':\nThe API I'm thinking of is:\n@signature  \"COMPONENT-TAGNAME SCOPE-ATTRNAME\" : linkDefinition\nSpecifies a value to set on a parent component scope.   \n@param {String} COMPONENT-TAGNAME A value that specifies the [can.Component.prototype.tag tag] of a parent component or * which will find the first tag that is managed by a component. \n@param {String} SCOPE-ATTRNAME The attribute name that will be set on the matched \n@param {can.Component.types.linkDefinition} linkDefinition A function or string that defines the value to set on the parent component's scope.\nUse\nThe following has a window-manager component that displays a title set by a name-editor component:\n``` js\ncan.Component.extend({\n tag: \"window-manager\",\n template: \"{{title}}\"\n})\ncan.Component.extend({\n tag: \"name-editor\",\n template: \" \",\n links: {\n   \"window-manager title\" : function(){\n     return \"Edit \"+this.attr(\"first\")+\" \"+this.attr(\"last\")\n   }\n }\n})\nvar template = can.mustache(\"\")\ntemplate( new can.Map({first: \"Justin\", last: \"Meyer\"}) )\n```\n@typedef {String|function} can.Component.types.linkDefinition\n@option {String} If a string, it's assumed to be a property name of the current component's scope.\n@option {function(this:can.Map):*}  A function that returns the value to set on the parent component's attribute.  The this of the function is the \ncurrent component's scope.\n. Closing for #1209.\n. This breaks the tests.  Please fix and re-submit.\n. The arguments passing style isn't great, but overall, I like it.\n. @whitecolor Do you still support this issue?  Hopefully, can.view.tag gives you enough power to be able to mix in behaviors.\nThe problem with something like:\n<div my-comp=\"myCompOptions\" another-comp another-comp-prop=\"anotherProp\">\nIs \"who owns\" the template?\nI think a better solution would be enabling Components that don't have a \"template\" or \"tag\" property to be added via can.view.attr like:\n```\nvar MyComp = can.Component.extend({\n  scope: { ... },\n  events: { ... }\n});\ncan.view.attr(\"my-comp\", MyComp);\n```\nThoughts?\n. Related: https://github.com/bitovi/canjs/issues/1376\n. Adding the label can-component.  I'm going to try to run through all component related issues and move them as a group to the can-component repo.  My hope is that I can consolidate some of them.\n. Closing for: https://github.com/canjs/can-stache/issues/15\n. Closing because #1005 will have to provide this.\n. Looks like a good catch!\n. Actually, it's not :-). Your code should look like:\nhttp://jsfiddle.net/wr66r/4/\nor\nhttp://jsfiddle.net/wr66r/5/\n. Can you please describe a bit more what you are talking about?  Some context and an example would be great.\n. Also, jQuery functions on collections are typically referred to as $.fn.XXX and static utilities are $.XXX.  Do you mean $.fn.remove?\nAnd what does view/zepto mean?  There is no view/zepto module in CanJS.  All of our code uses can.remove.\n. @stevenvachon it's a best practice to identify something by where / how it is defined, not by how it's called.  Also, one calls $.fn.remove like collection.remove(), not $.remove().\njQuery will refer to $.fn.remove like .remove(), but never $.remove.  For example, $.data and .data() are two different things:\n$.data - http://api.jquery.com/jquery.data/\n.data() http://api.jquery.com/data/\n. It's important because I want to understand what you are talking about as quickly as possible. I was left wondering if CanJS was overwriting $.fn.remove when it should be overwriting $.remove. For instance there's an important difference between $.data vs $.fn.data, or $.fn.attr vs $.attr.  \nUnfortunately, I don't have a lot of time to spend thinking about what is \"meant\".  Labels like view/zepto and $.remove are confusing, so I have to follow up with a question and wait for an answer before I can get to fixing stuff.  That's time wasted from improving the CanJS.  I want to avoid follow up questions if possible.\n. What is the issue exactly?  I'm not sure what your test code does because it's only logging things and I don't know where the fail assertion should be.  Given your description:\n\nIf you have a pushstate root of \"/app/\" and you have a link within your app pointing to \"/other/\", it is currently be treated as a route in v2.0.4 because the host is the same. \n\nAre you saying that if I have:\njs\ncan.route.bindings.pushstate.root = \"/bitovi/src/app/\";\nand a link like:\n<a href=\"/bitovi/test/\"></a>\nWhen that link is clicked on, it will call ev.preventDefault() and do a pushState() instead of letting the link behave like normal?\nIf yes, that is certainly a bug.\n. Why?  They are very useful.\n. @andykant where did you get on fixing this?  This is breaking minor.\n. This test is still breaking for me in firefox.\n. Typically, we would have all urls under domain.com/app/ always be matched by can.route.  For your scenario, we'd link to a domain.com/files/ url that is outside what is matched.\nIf there needs to be exceptions, I'd rather register like:\njs\ncan.route(\"/app/files/\", false)\ninstead of having to remember to specify can-route on every link.  Especially as there might be other plugins / widgets making link outside CanJS that would not be easily able to add can-route='false'.\nAlternative API's might be:\njs\ncan.route.ignore(\"/app/files\")\ncan.route.ignore.push(\"/app/files\")\n... etc\n. @stevenvachon Any interest in making this happen?\n. Is it possible to register a few changes in the history, then call .back() and see if the url stays the same?\n. https://github.com/bitovi/canjs/blob/minor/view/mustache/mustache.js#L72\nhttps://github.com/bitovi/canjs/blob/minor/view/stache/mustache_core.js#L85\n. I think a \"resource\" url is what keeps coming up.  A baseURL is something that can be added pretty easily by jQuery.\n. Adding as a feature.   This and #501 are related.\n. Actually, closing as this IS #501.\n. I'm not sure what the problem you are trying to identify is.  Why are you using a deferred at all?  Its use seems irrelevant in your example and could be removed.\nWhy are you setting properties of list?  I'm not sure why someone would do:\njs\nvar list = new can.List();\nlist.attr(\"a\",\"a\")\nshould you be using a can.Map?\n. \"default-ness\" matters little if you are using require or steal.  Even if you are using a custom build, it's not hard to include hashchange.  \nIt's possible to fall back to hash-change already.  You call teardown and change the binding like you see here: https://github.com/bitovi/canjs/blob/master/route/pushstate/pushstate_test.js#L17\nIn the end, it depends on what browsers 3.0 support.  IE8 and 9 do not support pushstate: http://caniuse.com/#search=pushstate.  We will probably be supporting those browsers.\n. Yeah, I was clear on you wanting to reverse that.  But again, it depends on what browsers 3.0 supports.  If we say \"CanJS supports IE8\", it means its core supports IE8 (not a plugin that would require a different set of URLS).\nGoogle might be able to drop IE9 support, but it doesn't mean our community will by then.  IE8 is still at 10% according to that article.\n. I think we can do this for 3.0.\n. So hashchange is still going to be \"core\" in 3.0 mostly because it's tricky to setup routing without server support like DoneJS has.  I think this will have to continue indefinitely or pending some unforeseen browser technology.  \nClosing.\n. ok, so closing ... ?\n. @stevenvachon \nI'm wondering if there's a better name for \"unroutable\".  I would consider \"an external link on the same domain to be an error\" if it wasn't ignored with the api in: #655.  This means that \"error\" would be a valid name if the callback wasn't called for routes that were explicitly ignored.\nYou identified some cases where this would be called:\n- different host/port\n- external path (parent or sibling of can.route.bindings.pushstate.root)\n- ignored route (#655)\n- unrouted path (simulated 404)\nCould you identify some common things you would want to do?\nAlso, the following:\njs\n// stops links from refreshing the page (for whatever reason)\n    if (event.currentTarget.tagName == \"A\")\n    {\n        event.preventDefault();\n    }\nImplies there is a DOM event (click / keypress) that is causing the \"unroutable\" event to be fired.  However, it's very likely \"unroutable\" should be called if a user wrote: window.location.hashchange = \"#!adlfkjhaslkfh.asdf/asdf.a/\", or started with a url that included something unroutable.\nI think ev.preventDefault() could be available, but there are cases where it would not be.\n- AVAILABLE: click / keypress on a link\n- AVAILABLE: changed the hash (hashchange event) ... but .preventDefault() does nothing I think ... possibly sets back the previous url\n- UNAVAILABLE: coming to a page with that link / forward or back button\nActually, preventDefault might have two different uses.  One might prevent the URL from changing; however if you are using pushstate and want to take someone to another page rendered from the server, does preventDefault actually prevent the preventDefault we are calling to do a pushState instead?\nAnyway ... if you have sec, please flesh out a little bit more what the behavior is.  Ideally in a way that's similar to CanJS's docs ... and then we have docs ready when it gets added.\n. Despite changing preventDefault to return false, we still need an answer to what happens for return false. \nSent from my iPhone\n\nOn Jan 16, 2014, at 9:34 AM, Steven Vachon notifications@github.com wrote:\nIf \"error\" is used, then we'd need another event like \"ignored\" to handle #655. This might be fine, and is clearer than \"unroutable\".\nPerhaps event.preventDefault isn't what we'd want, but instead a return false; similar to what a forEach would expect.\nMainly, I'm looking to simulate 404s, but figured that I would throw in the other \"unroutables\" as well. While I currently cannot think of a valid use case for them, that doesn't mean there aren't any.\n\u2014\nReply to this email directly or view it on GitHub.\n. This will be related to #1111 it's a semi-validation issue.\n. Moving to can-route-pushstate\n. I think this is a great catch.  Here's a fiddle that shows it a bit more explicitly:\n\nhttp://jsfiddle.net/donejs/y2BXn/2/\nThanks.  I will fix this tonight.\n. This is expected behavior. You read that property like: \"my.item\". \nSent from my iPhone\n\nOn Jan 15, 2014, at 10:19 AM, Robert Preus-MacLaren notifications@github.com wrote:\nI believe I've encountered a bug/unexpected behaviour while trying to access the property of a Model. Say we have a model/map that looks like:\nvar test = new can.Model({\n    'my.item': false\n});\nand we access it by\nvar result = test.attr('my.item');\nthen result is === undefined, instead of false.\nI have a small change in mind which will resolve this issue, by making a change to this check https://github.com/bitovi/canjs/blob/master/map/map.js#L647 .\nvar value;\nif( typeof attr === 'string' && !!~attr.indexOf('.') ) {\n    value = this.__get(attr);\n    if( value !== undefined ) {\n        return value;\n    }\n}\nI have this ready for pull request, unless of course this is expected :)\nI have reproduced it in this fiddle http://jsfiddle.net/qd73h/1/.\n\u2014\nReply to this email directly or view it on GitHub.\n. Use the \".\"\n\nSent from my iPhone\n\nOn Jan 16, 2014, at 4:04 AM, Robert Preus-MacLaren notifications@github.com wrote:\nPrecisely @thecountofzero , there appears to be a check for \".\" and then to return that element if it is found. But the check is only if it's truthy, this is very odd behaviour, shouldn't it be one or the other? @justinbmeyer\nThe Attr functionality currently works like this\nvar result, test = new can.Model({\n    'my.enable': false,\n    'my.item': true,\n    'my.count': 0,\n    'my.newCount': 1\n});\nresult = test.attr('my.enable'); // result === undefined\nresult = test.attr('my.item'); // result === true\nresult = test.attr('my.count'); // result === undefined\nresult = test.attr('my.newCount'); // result === 1\nThat doesn't feel right to me.\n\u2014\nReply to this email directly or view it on GitHub.\n. Getting a falsey value should probably not work without the \"\\\".\n. This should be fixed by using the define plugin.\n. Are you sure this is a problem with CanJS?  This seems to be a problem with funcunit. cc @alexisabril \n. Actually, I wasn't aware this code existed in the first place.  It performs double reads for every attr call with a \".\".\n\n257 and #269 and this commit are related: https://github.com/bitovi/canjs/commit/a80bd62b9137d81a8d84ae0a2578ef981b87db19\nI'm not sure what to do as I'd prefer not to do double reads.\n. it's a good suggestion, but default is a keyword in old browsers, but it would be another API to document.  I'd rather make sure we add better docs about the default route.\n. @James0x57 Just a documentation change.  I can walk you through it.\n. Looks like test/dojo.html broke.  Try that page in your browser and see what happens.\n. So this is closed, but no commits are referenced.  @shcarrico can you point this thread to where these changes happened?\n. I think it would be better to just support nodeLists without the extra parameter. \nSent from my iPhone\n\nOn Jan 17, 2014, at 10:56 PM, Steven Vachon notifications@github.com wrote:\nWhen looping through node list collections (jQuery in particular), it'd be great if we could loop through them without having to check if the index is [similar to] an integer.\nInstead of having to do:\ncan.each( can.$(\"a\"), function(node, index)\n{\n    // Avoid length, and other non-array-like indexes\n    if ( isNaN(parseInt(index)) ) return;\nconsole.log( can.$(node) );\n});\n\u2026we would now have the proposed following:\ncan.each parameters\n@param collection {Object} \u2026\n@param callback {function()} ...\n@param arrayLike {Boolean} Ignores indexes that are not integers within strings.\nUse\ncan.each( can.$(\"a\"), function(node, index)\n{\n    console.log( can.$(node) );\n}, true);\n\u2014\nReply to this email directly or view it on GitHub.\n. btw, would a better way have been to use hasOwnProperty?\n. AFAIK this only breaks with conditional comments turned on or some other strange thing. But it does not break in IE8 with only canjs and jQuery. \n\nWe have looked into why this breaks and how to feature detect it with no luck. \nCc @imjoshdean\nSent from my iPhone\n\nOn Jan 18, 2014, at 10:50 AM, pYr0x notifications@github.com wrote:\nan easy sample:\nvar overviewRenderer = can.view(Config.baseUrl+'/js/templates/overview.mustache'); \nwill cause an error on IE8 on this line\nmyEval.call(out, 'this.fn = (function(' + this.text.argNames + '){' + out.out + '});\\r\\n//@ sourceURL=' + name + \".js\");\nthe problem is //@ sourceURL=' + name + \".js\" if i remove the comment the script works fine.\n\u2014\nReply to this email directly or view it on GitHub.\n. It was this bug: #108 cc @dispatchrabbi \n. @stevenvachon great catch.  @cklanac , this is maybe because two add events are fired and #each's add and remove handlers (https://github.com/bitovi/canjs/blob/master/view/live/live.js#L159) are not checking the batchNum.\n\nYou can see how https://github.com/bitovi/canjs/blob/master/compute/compute.js#L233 checks the batch num.\n... however on second thought, that doesn't seem like the likely problem. Maybe the arguments are not right for the add event.\n. As this isn't supported in all browsers, I'm not sure this is something we can support.  The live binding has to have control over the attributes it is keeping live.\n. Closing ... this is a rabbit hole I don't want to go down.  The rabbit hole is having us work around DOM changes that the user creates outside of live binding.  We could make it work in this case, but other cases would be very hard.  I would rather just say this doesn't work.\n. Thanks for the suggestion.  I'm gonna play devils advocate here:\nYou don't need to loop in reverse order to remove multiple indexes, you can use a while loop.\nCalling .reverse() isn't that bad.  It is pretty darn fast and won't change the limiting function of your code.\nI'd rather just add a reject method to lists that would remove those items like underscore's reject\n. Closing b/c this will all be possible for #1005 \n. > document.contains isn't provided by android stock browser and so, can.inserted fails and so can.view can't render.\nDoes this mean your patch doesn't fix the issue, it's just something you think might be better?\n. Oh, you are saying document.contains doesn't exist, but document.body.contain does.  \nAh, why not use document.documentElement?  That way anything inserted works (even something in the head).\n. Merged into minor.\n. Closing as it is part of #708\n. I'm personally not a fan of non-client side loaders for big applications.  You can not easily do progressive loading, etc.\nHowever, I want CanJS to support as many people as possible.  Assuming we could write out a CommonJS version of CanJS, what would we need to support infrastructure wise?  What does browserify need to install / load?  Would we need another repo with the output?\n. @daffl I'm pretty sure that AMD should not be relative.  I added a comment in #338 for why.  We'd probably have to write out relative for CommonJS though.\n. @curtis can defaults be a function?  I know we talked about this, but I don't know if it happened. \nSent from my iPhone\n\nOn Jan 28, 2014, at 5:10 PM, Josh March\u00e1n notifications@github.com wrote:\nSimply cloning can cause its own share of issues. For example, what does this code do?:\ndefaults: {\n  foo: new Thing() // does some kind of initialization for each instance -- I think can.compute works like this, even.\n}\nand even if you're willing to ignore cases like this, what do you do about these two cases?:\ndefaults: {\n  foo: {\n    state: clientState // There must be one clientState to rule them all. Please never copy this.\n  }\n}\n// and...\ndefaults: {\n  foo: {\n    bar: {} // Please don't share this instance, it needs to be unique for everything\n  }\n}\nI don't believe there is a single good-enough DWIM solution that works for all these cases. An alternative would be to force values in the defaults object to be either immutable data (strings, numbers, booleans), or be provided as a function that will be executed on every instantiation to create the default value in a predictable, unsurprising way:\ndefaults: {\n  foo: \"hey\",\n  bar: 1,\n  baz: true,\n  quux: function() { return new Thing(); } // this is safe\n}\nOf course, it kinda sucks to have to type out functions every time you want a mutable default. You could provide both interfaces (objects get auto-deep-cloned or auto-shallow-cloned, and function get executed), but that doesn't fix the original bug, which has to do with the principle of least surprise more than anything else, since the framework is already perfectly capable of working around this \"bug\" through the init method.\nThe tl;dr is that I think the only appropriate, unsurprising thing to do is to just yell at users when they put mutable objects in defaults when they're in dev mode, and document this issue in our documentation.\n\u2014\nReply to this email directly or view it on GitHub.\n. Sure, sounds good.\n. @shcarrico If you can get that to us this week, we can put it in 2.2.  Thanks!\n. When you steal \"can\", you get what's in can/can.js:\n\njs\nsteal('can/util', 'can/control/route', 'can/model', \n    'can/view/mustache', 'can/component', function(can) {\n    return can;\n});\nSo most likely something in your app is stealing the modifiers plugin.\n. @ccummings can you write a new test instead of modifying the old one?  As a div and image each take a separate path when being live-bound, we should keep a test for both cases.\n. I'm going to merge.  @ccummings please add this in for 2.1.\n. Does it work if your template ends with .mustache ?\nSent from my iPhone\n\nOn Feb 4, 2014, at 11:24 PM, Steele Price notifications@github.com wrote:\nI am having a major issue with v2.0.5.\nI have a working App that has had no other change except a straight replacement of v2.0.4 with v2.0.5 AMD.\nThese statements used to work:\n$(element).html(can.view(require.toUrl(\"comp/home/home.html\"), {}));\n$('body').append(can.view.mustache(\"\")({ session: attr.session }));\nNow they both fail in scanner.js at line 249 with Object doesn't support property or method 'replace'\nThis is because source is a document fragment.\nI can get around the first by first saving the view to a variable then setting html to the frag, but this seems weird to have to do when I never had to previously.\nThe second sample is even used in all the documentation for Components.\nAm I missing something that documents this and need to change my syntax?\nI'd consider this a pretty big deal since I would have to change at least dozens of places views are loaded.\nThanks\n\u2014\nReply to this email directly or view it on GitHub.\n. I built an example that works.\n\n``` html\n\n\n\n\n\n            require(['can','jquery'], function(can, $){\n                $('#element').html(can.view(\"home.html\", {}));</p>\n<pre><code>            $('body').append(can.view.mustache(\"Hello\")({ session: {} }));\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p></html>\n```\n. Changing it to:</p>\n<p><code>js\nvar str = \"home.html\"\n$('#element').html(can.view(str, {}));</code></p>\n<p>works too\n. @steeleprice ping me on skype / ghangout if you get your code to a minimal breaking case.  I was just about to update the site to show 2.0.5.  But I want to hold off if it's breaking.\n. @steeleprice I'm not sure you are correct.  The following works for me:</p>\n<p>``` html\n<html>\n    <body>\n        <div id='element'></div>\n        <script src=\"require.js\">\n\n            require(['can','jquery'], function(can, $){</p>\n<pre><code>            var str = \"home.html\"\n            $('#element').html(can.view(require.toUrl(\"home.html\"), {}));\n\n\n            $('body').append(can.view.mustache(\"Hello\")({ session: {} }));\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p></html>\n```</p>\n<p>Please reach out to me so I can stop worrying about this and make 2.0.5 official.\n. Wait ... why would you do:</p>\n<p><code>js\n$(element).html(can.view(require.toUrl(\"comp/home/home.html\"), {}));</code></p>\n<p>inside a component?  This seems like a mistake.  You should not be rendering things inside a component.\n. Btw, I am writing an article about how we are going to be backwards compatible / use semantic versioning: https://gist.github.com/justinbmeyer/8812069</p>\n<p>So if there is a breaking issue, I want to fix it ASAP so I'm not undermining the entire article :-)\n. Ok, I tracked this down to this pull request:</p>\n<p>https://github.com/bitovi/canjs/pull/647</p>\n<p>As supporting <code>baseUrl</code> was never  documented, this is a new feature and should have been part of 2.1 or 3.0.</p>\n<p>@stevenvachon and @daffl I think this is still not documented, anyway we can add this to <code>can.view</code>'s docs?\n. @steeleprice </p>\n<p>Don't you mean correct syntax for 2.0.5 is:</p>\n<p><code>js\ntemplate: can.view(require.toUrl(\"comp/home/home.html\")),</code></p>\n<p>Sorry about the break.  We are trying very hard to prevent that.\n. Agreed.  Adding it to 2.1 milestone.\n. you'll have to get us an example of it breaking.  Things are removed from the model store when they have no more listeners.  It's possible that an unbind that ejects the model from the store is happening right before a bind.\n. You can always bind on the model to keep it in the store. Or bind on the list which binds on its children. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Feb 12, 2014, at 11:21 PM, Alex Osh notifications@github.com wrote:</p>\n<p>BTW I think there is a need in a parameter that will be able to prevent automatic removal of the model from store when all the bindings are removed. Why? The case:</p>\n<p>1) I have some model that I loaded and present using some component (let's say the content of the tabs widget).\n2) Then I switch the tab and the component is removed. All the bindings are moved from DOM. And model is removed from store. But I didn't I had a refences to the model instance and actually want to keep it memory for further actions - when the tab is switched back, component initiated again and renders the instance that I have in memory.\n3) Then during due to some actions model data is updated from from server and I have incorrect behaviour because I don't have model in store,</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Yes, it looks odd, but it's exactly what any method we would add would end up doing. </p>\n</blockquote>\n<p>If you'd like to see something more explicit, please write up a proposed API. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Feb 13, 2014, at 5:39 AM, Alex Osh notifications@github.com wrote:</p>\n<p>Bind empty handler? Isn't it artificial and looks odd? Is the scenario that I described so rare, why do you not considering it?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Please request this in another thread as this doesn't directly relate to the issue. Speaking of which is there an issue still?</p>\n</blockquote>\n<p>Also, I don't think that API a good idea.  A permanent store is a very bad practice.  A setting that could be turned off or on I would be more likely to support.  </p>\n<p>Something more like <code>Task.storeAll(true)</code>.\n. It will. But does not currently .</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On May 14, 2014, at 1:09 AM, Alex Osh notifications@github.com wrote:</p>\n<p>This reason of experienced problem is the following:</p>\n<p>New data for Model {id1: name: 'John', status: 'live'}, new model is created as manually:</p>\n<p>var model = new Model(data) // new instance is place in Model.store with id = 1\nThen again data for Model {id1: name: 'John', status: 'dead'}, new model is created as manually again and new instance is placed to store.</p>\n<p>This can be avoided if new model is created using Model.model</p>\n<p>var model = Model.model(data) // new instance is place in Model.store with id = 1\nThe issue #962 says that Model.model can be removed and new operator will check Model.store.</p>\n<p>So, will</p>\n<p>new Model({id: 1, name: 'John'}) \nalways return the same instance as Model.model does?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Closing for an issue in can-connect.\n. Another explanation for myself:</p>\n</blockquote>\n<p>This fails because <code>#children</code> is always going to be found, so <code>{{&gt; #template}}</code> will be recursed indefinitely.</p>\n<p>There is not much we can do to prevent this.</p>\n<p>@daffl do we have an issue for <code>./</code> if we do, we should reference and close this issue.\n. So before you merge this kinda stuff, it's likely possible to make steal do this in stealconfig once for everything.  Our tests should be stealing 'qunit' like they used to.  We can probably also have something handle calling qunit's stop and start in stealconfig.\n. Actually, I can go back and change this later.  Once travis passes, be my guest to merge it.\n. Agreed.  Lets get this in 2.1.\n. There sort of is with compute. You can tell it how to get/set and know when a change happens. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Feb 6, 2014, at 8:54 PM, Thom Blake notifications@github.com wrote:</p>\n<p>It's nice sometimes to use __reading to manually set up binding on something that is not a can.Map or can.List, but it's obviously the sort of thing that's private and shouldn't be relied upon. It would be nice if there were a public version of this.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. @tomblake, if you give me an example of something you want to be able to bind to, I can probably show you how to set it up with a can.compute.  </p>\n</blockquote>\n<p>Or, failing that, a good example where a can.compute is not sufficient would give more of a reason why this API should be exposed.\n. This is going to happen in 3.0 here: https://github.com/canjs/can-observe-info\n. Closing for: https://github.com/canjs/can-stache-bindings/issues/5\n. I created #730 to talk about the larger discussion of how can.Component works with web component technology.  Closing this issue for now.  Reopen if needed once that other issue gets hashed out.\n. @matthewp My thoughts on your take below:</p>\n<h3>Scope</h3>\n<p><code>Object.observe</code> will probably be around in all browsers before document.registerElement.  </p>\n<p>What do you mean be \"part of the element's prototype\"?  Do you mean:</p>\n<p><code>js\nsliderEl.scope.attr(\"value\", data.progress);</code></p>\n<p>Or</p>\n<p><code>js\nsliderEl.attr(\"value\", data.progress);</code></p>\n<p>Both are possible, although the second one would be a little weird.  We have to inherit from HTMLElement, so we'd have to add can.Map's functionality, but not inherit it.</p>\n<blockquote>\n<p>ASIDE: Could it be desired that the API is something other than Scope?  That the <code>scope</code> would need to be protected?  I think scope can/should do that for itself.</p>\n</blockquote>\n<h3>Content</h3>\n<blockquote>\n<p>I don't think <content/> should be run through Mustache at all. Anything outside of a script tag should be left alone.</p>\n</blockquote>\n<p>What do you mean?  <code>&lt;content&gt;</code> is currently done via can.Component:  https://github.com/bitovi/canjs/blob/minor/component/component.js#L244, but using <code>can.view</code> of course.</p>\n<p>Just to clarify, your answer to:</p>\n<blockquote>\n<p>What does h1.html() look like?</p>\n</blockquote>\n<p>is: <code>&lt;content/&gt;</code>?</p>\n<p>And, <code>$('hello-world').html()</code> would give back: <code>Hi There</code>?</p>\n<p>I've seen what polymer does to polyfill the shadow dom, it's not easy.</p>\n<h3>Mustache</h3>\n<blockquote>\n<p>Here I would expect modifying scope properties would rerender the template.</p>\n</blockquote>\n<p>Notice that I'm modifying a parent element's scope properties.  </p>\n<blockquote>\n<p>What would be the argument against doing this?</p>\n</blockquote>\n<p>Difficulty. How does the child <code>&lt;hello-world&gt;</code> element know about it's parent?  How do those scopes get merged?  A possibility is that whenever a child element is inserted, it walks up the DOM to find a parent element's scope.</p>\n<blockquote>\n<p><code>&lt;my-parent&gt;&lt;/my-parent&gt;</code></p>\n</blockquote>\n<p>Yes, but what bout the content of <code>&lt;hello-world&gt;</code>?  Likely, it would go back to being empty because it would no longer have <code>message</code> in it's scope.  We'd need a mechanism for detaching parent \"scopes\".\n. Closing for https://github.com/canjs/can-component/issues/10\n. @thomblake Interested in taking this on?  I can show you how to add this.<br />\n. Closing.  Please re-open here if someone is interested in taking this on: https://github.com/canjs/can-event\n. new Model instances are automatically added to the store during a request.  For example <code>Item.findAll({})</code> will have all of its instances temporarily added to the store. </p>\n<p>But if there is no request, something like <code>new Item({id: 5})</code> will not be added to the store.</p>\n<p>Can you explain:</p>\n<blockquote>\n<p>I have a situation where after first request to server model is not added to store because of this check. Is this expected?</p>\n</blockquote>\n<p>A bit more.<br />\n. This article: http://bitovi.com/blog/2012/04/zombie-apocolypse.html</p>\n<p>Talks about why we add instances to the store during a request.\n. Closing.  Binding handlers is the way to go.  We could make it more simple.  <code>model.bind()</code>, <code>model.unbind()</code>.  If you like that, please create another issue.\n. This is probably inappropriate.  This should work like:</p>\n<p><code>js\nmodelInstance.attr(\"state\",\"published\");\nmodelInstance.save();</code></p>\n<p>Ideally, update would be able to see that the \"state\" changed from something to published and make sure action=publish.  However, this is currently not easily done.  I'm closing this b/c this should be part of https://github.com/bitovi/canjs/issues/1213\n. Playing devil's advocate.  I'm not sure we should add this.  The scope object that is being get / set is a <code>can.Map</code>.  This seems to hide that fact by suggesting a different interface than <code>.attr</code>.  </p>\n<p>One possibility is to overwrite jQuery's .attr on custom elements to allow getting and setting attributes like:</p>\n<p><code>js\n$(\"tab\").attr(\"title\",\"foo\")</code></p>\n<p>Or, we might want to only support .scope().attr().  It's long winded, but precise.</p>\n<p>Also, for this to land, it should include docs.<br />\n. It would be certainly 2.1.  It's not a bug fix.  Not only is this exending APIs, it's extending APIs that haven't been previously documented.\n. I'm not opposed to it.  I'm playing devil's advocate.  What about the alternative of overwriting jQuery's attr?\n. I'm interested.  I'd like to include docs for it before merging into minor.\n. I'm being sneak w/ the docs request b/c I'm not sure can.scope is documented at all ...\n. @shcarrico Force both ids?  But using == where you want type coercion makes sense.   Otherwise, where should <code>==</code> be used.\n. Hmmm, you are setting an expando property on a list:</p>\n<p><code>js\nitems.attr('spliced', true);</code>\n. You are right it should be allowed.  My comment was more a note for myself on where to start looking for the issue.</p>\n<p>That commit fixes the problem.\n. media-file=\".\"</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Feb 19, 2014, at 9:08 AM, Alex Osh notifications@github.com wrote:</p>\n<p>The case, say I have a model:</p>\n<p>track: {\n   title: ...\n   mediaFile: {filename: ..., url: ..., size: ....}\n}\nI have component to work with track model and I want to create a separate component to work with mediaFile object .</p>\n<p>If I want to pass a whole object to the component I have to do:</p>\n<p><my-track>\n    <media-file mediaFile=\"mediaFile\"></media-file> \n</my-track>\nbut if the component assumes working only with mediaFile attributes there is not sense to have mediaFile in scope, the scope could just have all the properties of mediaFile (filename, url, size)</p>\n<p>{{#mediaFile}}\n    <media-file url=\"url\" filename=\"filename\" size=\"size\"></media-file>\n{{/mediaFile}}\nbut the last looks cumbersome.</p>\n<p>Maybe consider something way to put a whole object in component's scope\n{{#mediaFile}}{{/mediaFile}}</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. If we are being precise, this (.) should be in can.Mustache.key. Same with (this) and (../). </p>\n</blockquote>\n<p>This is because attribute values are keys. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Feb 19, 2014, at 9:49 AM, Stan Carrico notifications@github.com wrote:</p>\n<p>Can you suggest a place where we might emphasize or add this to the docs?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. EJS and Mustache will be put in another project in 3.0.  They will be worked on there.\n. EJS and Mustache are in https://github.com/canjs/can-ejs https://github.com/canjs/can-mustache\n. What do you mean by: \"lists are not automatically updated in the DOM:\"\n. Yeah, I noticed this when implementing stash. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Feb 20, 2014, at 3:22 PM, Matthew Phillips notifications@github.com wrote:</p>\n<p>The inverse if is not documented so I'm not sure if this is really a bug but here is a fiddle.</p>\n<p>Problems in the fiddle:</p>\n<p>When falsey it shows the inverse section.\nWhen truthy it shows nothing.\n\u2014\nReply to this email directly or view it on GitHub.\n. Other things to consider:</p>\n</blockquote>\n<h3>Passing a Map constructor function</h3>\n<p><code>js\nAppState = can.Map.extend({ ... })\ncan.route.data(AppState)</code></p>\n<h3>Passing can.route an object of prototype properties</h3>\n<p><code>can.route.data({\n  setSearchTerm: function(){ ... }\n})</code></p>\n<h3>Serializing and de-serializing</h3>\n<p><code>js\nAppState = can.Map.extend({\n  setSearchTerm: function(newTerm){\n    return newTerm || \"\"\n  },\n  setFlags: function(newValue){\n    return typeof newValue === \"string\" ? newValue.split(\"\") : newValue || [] )\n  },\n  serialize: function(){\n    var s = this.attr();\n    s.flags = s.flags.join(\"\");\n    return s;\n  }\n})</code>\n. @moschel </p>\n<blockquote>\n<p>We'll possibly need options for that method to map appState properties to what they'll be called in can.route.</p>\n</blockquote>\n<p>I assume you mean if I do something like:</p>\n<p><code>js\nAppState = can.Map.extend({\n  doSomething: function(){ ... }\n})\ncan.route.data(AppState);</code></p>\n<p>You want someone to be able to write:</p>\n<p><code>can.route.doSomething()</code></p>\n<p>?</p>\n<p>Imo, Modules should not call can.route directly, they should instead be passed an observable and listen / make changes to it.  That means, <code>can.route.doSomething()</code>is not something we really need to support.  If someone must do that, they can do:</p>\n<p><code>can.route.data().doSomething()</code>\n. @retro any chance you are going to get to this?  Otherwise, please close.\n. Closing b/c it looks like this is in #760.\n. @booc0mtaco Thanks.  Add a invite to my calendar to review them.<br />\n. Also, I would not write it like this.  If you ask \"how should I write it\" on the forums, I'll show you.\n. That link does not work.\n. @pYr0x Are you available to talk about this issue?  Can you ping me on skype at: justinbmeyer.\n. @pYr0x nevermind.  This works with #1314.  I think the list.attr(5,value) problem had been solved some time ago.\n. This is expected.  It's a setter that is calling itself via this.attr(\"message\").  You should rename your method to updateMessage or something else.\n. Update them where / how?  There's not an ideal place for them.</p>\n<p>The only thing I can envision is a sentence on http://canjs.com/docs/can.Map.setter.html:</p>\n<blockquote>\n<p>If you are using the setter plugin, you should not call a setter directly.\n. @marshallswain Thanks for reaching out to us, but this is probably not the right place, unless you are suggesting a better error message.  Can you ask questions like this on the forums?  We try to keep this on bugs and feature requests.\n. Closing.  Use stache!\n. As event dispatching (<code>can.dispatch</code>) is one of the most expensive parts of canjs apps, this will have to be done with care to make sure the performance of apps that do not make use of this will not slow down.\n. <code>js\nvar Team = can.Map.extend({\n    attributes: {\n        players: Player\n    }\n}, {\n    players: []\n});</code></p>\n</blockquote>\n<p>Should not make items within the \"players\" array a \"Player\".  Instead, it will try to make the \"players\" array itself a Player.</p>\n<p>You probably need something more like:</p>\n<p><code>js\nvar Player = can.Map.extend({\n    name: function () {\n        return 'player name';\n    }\n});\nvar Players = can.List.extend({\n  Map: Player\n},{})\nvar Team = can.Map.extend({\n    attributes: {\n        players: Players\n    }\n}, {\n    players: []\n});</code>\n. @isadovskiy / @daffl is it possible to update the initial example with correct (but still breaking) code?   The following should not be part of it:</p>\n<p><code>js\nattributes: {\n        players: Player\n    }</code>\n. It's under utils b/c that's where it's code is found. The same argument could be made for putting it under can.compute.  We should link to it from other pages, but it should stay in util.  </p>\n<p>Eventually, we should have an \"can.events\" that could house it. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 12, 2014, at 4:28 AM, Brian Moschel notifications@github.com wrote:</p>\n<p>Right now, can.batch is kinda hidden under the utils section. It makes more sense under can.Map.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Closing for: https://github.com/canjs/canjs/issues/2392\n. @daffl or @colinexl anyway one of you can get a pull request / test in by tomorrow?  Otherwise, we might save this fix for 2.1.1.\n. There is another issue related to this. I'm away otherwise I would look it up. </p>\n</blockquote>\n<p>I'm not sure that the compute should take on the value of the resolved deferred. That will be a bit strange having a deferred then suddenly a value. Also, what happens on error and such?</p>\n<p>Instead, we might simply make deferreds call can.__reading and be \"bind able\". That way you could do something like:</p>\n<p>{{#eq deffered.state() \"resolved\"}}\n  {{deffered.value.name}}\n{{/eq}}</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 13, 2014, at 9:10 PM, Thom Blake notifications@github.com wrote:</p>\n<p>You can pass a deferred into a can.List, which allows you to render a template using that List and then the template will update when the deferred is resolved. The same functionality should be available for computes. (Raised by Colin Zhu and @moschel at canjs Silicon Valley meetup)</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. This won't have to modify the promise API other than making it listenable by a compute. Deferred.value is something mustache will provide. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 13, 2014, at 10:55 PM, Thom Blake notifications@github.com wrote:</p>\n<p>Awesome. Though modifying the behavior of deferreds might be problematic if\nyou ever switch over to a+ promises.\nOn Mar 13, 2014 8:45 PM, \"Justin Meyer\" notifications@github.com wrote:</p>\n<blockquote>\n<p>There is another issue related to this. I'm away otherwise I would look it\nup.</p>\n<p>I'm not sure that the compute should take on the value of the resolved\ndeferred. That will be a bit strange having a deferred then suddenly a\nvalue. Also, what happens on error and such?</p>\n<p>Instead, we might simply make deferreds call can.__reading and be \"bind\nable\". That way you could do something like:</p>\n<p>{{#eq deffered.state() \"resolved\"}}\n{{deffered.value.name}}\n{{/eq}}</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 13, 2014, at 9:10 PM, Thom Blake notifications@github.com\nwrote:</p>\n<p>You can pass a deferred into a can.List, which allows you to render a\ntemplate using that List and then the template will update when the\ndeferred is resolved. The same functionality should be available for\ncomputes. (Raised by Colin Zhu and @moschel at canjs Silicon Valley meetup)</p>\n<h2></h2>\n<p>Reply to this email directly or view it on GitHub.</p>\n</blockquote>\n<h2></h2>\n<p>Reply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/issues/786#issuecomment-37614383\n.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Closing for #179 \n. We should not really close this without testing against these browsers. I think once lazy map is done, we should add testing in android, iOS, and other browsers. </p>\n</blockquote>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 13, 2014, at 9:26 PM, Curtis Cummings notifications@github.com wrote:</p>\n<p>One of the methods that goes through this code path is a RegExp and in certain older browsers, RegExp is callable meaning using typeof on one returns'function'. So it passes the typeof check and when we try to use apply on the RegExp it throws an error.</p>\n<p>You can see bugs to fix this weirdness in all major browsers.</p>\n<p>The fix is to check method for apply instead of using a typeof check.</p>\n<p>Closes #681</p>\n<p>You can merge this Pull Request by running</p>\n<p>git pull https://github.com/bitovi/canjs 681-android-can-route-error\nOr view, comment on, or merge it at:</p>\n<p>https://github.com/bitovi/canjs/pull/787</p>\n<p>Commit Summary</p>\n<p>Changing typeof check to a check for apply\nFile Changes</p>\n<p>M route/route.js (2)\nPatch Links:</p>\n<p>https://github.com/bitovi/canjs/pull/787.patch\nhttps://github.com/bitovi/canjs/pull/787.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. I mean @daffl needs to hook us up with automated testee testing of android, iOS, and other browsers.\n. this change will need to be made here: https://github.com/canjs/can-set/issues/35\n. I think this is a duplicate issue. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 14, 2014, at 1:18 AM, Brian Moschel notifications@github.com wrote:</p>\n<p>It seems there is an inconsistency in how can.Map properties and can.List properties can be defined as computes. After defining a compute in can.Map, it can be referenced with obj.attr('computePropName'), but for can.List instances, list.attr('computePropName') returns a function, not the result of the compute.</p>\n<p>Person = can.Map.extend({\n    speak: can.compute(function(){\n        return \"foo\"\n    })\n})\nvar p = new Person();\nconsole.log('map speak', p.attr('speak'))</p>\n<p>People = can.List.extend({\n    speak: can.compute(function(){\n        return \"foo\"\n    })\n})\nvar list = new People([1, 2, 3]);\nconsole.log('map speak', list.attr('speak'));\noutputs the following:</p>\n<p>map speak foo \nmap speak function (c){if(arguments.length){var b=q,e=w.call(d,c,b);if(m.hasDependencies)return r.call(d);q=void 0===e?r.call(d):e;b!==q&amp;&amp;a.batch.trigger(m,\n\"change\",[q,b]);return q}a.__reading&amp;&amp;y&amp;&amp;(a.__reading(m,\"change\"),p.bound||a.compute.temporarilyBind(m));return p.bound?q:r.call(d)} \n\u2014\nReply to this email directly or view it on GitHub.\n. Try uncommenting it and seeing if our tests pass.\n. Thanks for using CanJs, but please do not ask how to questions on the issue tracker. The github issue tracker is only for bugs. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 17, 2014, at 7:05 AM, isadovskiy notifications@github.com wrote:</p>\n<p>Hello.</p>\n<p>I have a view, which is initialized via live data binding and depends on many different Map properties.</p>\n<p>I need to implement custom scroll bar for my view (specifically, http://baijs.com/tinyscrollbar/). I need to trigger it's \"update\" API method manually every time when the height of my content is changed to re-draw scroll bar and adapt it to new content's height.</p>\n<p>However with live data binding potentially any Map's property change could cause content height change. So instead of listening for every property change, which could change the height of the rendered view, I'm looking for the single event from view, which tells me, something is changed in. Is there a way to accomplish it?</p>\n<p>P.S. I do not like to listen for changes on Map's root since there are a lot of additional properties in Map, which are changed but did not impact specific view.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. This is heavily used by can/fixture.  A <code>subset representation</code> DOES contain less properties than a set.  Btw, this is the future of can.Object: http://github.com/canjs/can-set and explains why much better.</p>\n</blockquote>\n<p>This means that if I compare the <code>{}</code> in  <code>Todo.findAll({})</code> to <code>{due: \"today\"}</code> in <code>Todo.findAll({due: \"today\"})</code>, <code>{}</code> is a superset of <code>{due: \"today\"}</code>, but has less properties.</p>\n<p>The object compared here represent a set, they are not the set themselves.\n. can.Object is deprecated in favor of <a href=\"/canjs/can-set\">can-set</a>.  Closing.\n. <code>.empty()</code> will destroy controls within the element being destroyed. It will not destroy controls on the element being emptied.\n. Use #each. It doesn't redraw the whole list each time. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 19, 2014, at 7:20 AM, isadovskiy notifications@github.com wrote:</p>\n<p>Hello.</p>\n<p>I'm working with can.List, which is bound to my view via live binding functionality. I'm adding items to my list one by one with some delay and HTML reflects list's change by displaying new items. I'm using CanJs 2.0.5.</p>\n<p>What I noticed is every time i'm adding new item to the list, view update time takes more and more. Here is example: http://jsfiddle.net/HmnLt/1/</p>\n<p>As you can see it takes ~5ms to add and display first item. But to display 100th item it takes ~130ms. View update time is increased with every added item. Finally everything starts working very slow. It looks like whole view (all items) is re-rendered every time new item is added. However it should not happen! I do not modify existed items. I'm just adding new one. So I expect it will take ~5ms for adding every new item to the list.</p>\n<p>Another issue is noticed is</p>\n<p>list.push(item1);\nlist.push(item2);</p>\n<p>works noticeably slower than</p>\n<p>list.push(item1, item2);</p>\n<p>Again, it should not happen to my mind. You can compare http://jsfiddle.net/xnw5x/1/ and http://jsfiddle.net/6x3fH/1/. For 200th item it's ~460ms VS ~230ms (twice longer!!).</p>\n<p>It all should not happen to my mind. I expect it should take ~5ms every time i'm adding single item to my list and render it via live data binding. So please advice ot point how to fix it. Since right now it's completely unacceptable...</p>\n<p>Thanks</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. # is faster than #each when you are not incrementally adding and removing items. For example when all the items are replaced in the list in pagination.</p>\n</blockquote>\n<p>We leave both so people can be fast in either situation. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 19, 2014, at 10:24 AM, isadovskiy notifications@github.com wrote:</p>\n<p>BTW, wouldn't safe to handle {{#list}} in the same way as {{#each list}} automatically to avoid such issues, made by mistake? Looks like an easy fix - check for {{#xxx}} operand type and launch {{each xxx}} workflow for if it's an instance of can.List?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. @Alex-Krautmann If you have 30 min to an hour this week, I can work with you to setup a dev environment and fix this bug.  Ping me on skype: justinbmeyer, or shoot me an email: justin AT bitovi.  Thanks!\n. Yes, he's looking for a 404.  A developer can manually hookup their own fixture service and bypass the store all together if they need to show a 401.  Or they could use store's hooks internally:</p>\n</blockquote>\n<p>``` js\nvar thingsStore = can.store( ... );</p>\n<p>can.fixture(\"/things\", thingsStore.findAll);\ncan.fixture(\"/things/{id}\", function(request, response){\n  var item = thingsStore.find(request);\n  if(!item){\n    response(401,\"error\", ...)\n  } else {\n   ...\n  }\n})\n```\n. This has been implemented for 2.1.\n. Thanks for submitting the issue.  Is it possible to clean up the example to show the problem more simply?  For example, by removing the control and the template.<br />\n. @isadovskiy If you have the time, I'd like to talk to you about these attribute issues tomorrow.  Can you email me (justin AT bitovi) so we can coordinate?<br />\n. @isadovskiy it's designed this way.  It's also documented that way here:</p>\n<p>http://canjs.com/docs/can.Mustache.helper.html</p>\n<blockquote>\n<p>If a can.Mustache.key represents a can.Map attribute, it is converted to a can.compute getter/setter function. This enables 2-way binding helpers.</p>\n</blockquote>\n<p>As the documentation notes, providing computes enables more complex helpers that setup their own  bindings and behavior.\n. <code>js\ncan.Mustache.registerSimpleHelper = function(name, handler){\n  can.Mustache.registerHelper(name, function(){\n    var args = [];\n    can.each(arguments, function(arg, i){\n      args[i] = arg &amp;&amp; arg.isComputed ? arg() : arg\n    });\n    return handler.apply(this, args);\n  })\n}</code>\n. What do you mean by <code>init</code> in \"an init for 'info' property\"? \n. This has been fixed in minor.\n. @daffl It's \"better\" to be able to overwrite and then restore whatever is there.  We could also expand this to return the old fixture if you overwrite. Allowing:</p>\n<p>``` js\ncan.fixture(\"services/thing\", function(){ ... CODE A ... });</p>\n<p>var oldFixture = can.fixture(\"services/thing\",  function(){ ... CODE B ... });\n// run test\nTEST</p>\n<p>// restore old fixture\ncan.fixture(\"services/thing\", oldFixture)\n```</p>\n<p>@markfeimer if you have some time this week, I can walk you through setting up a CanJS dev environment and fixing this.  Ping me on skype: justinbmeyer.  Thanks!\n. Closing for the same issue in can-fixture.\n. It will mean different processing rules for {{}} within a custom element vs everywhere else.  Those <code>{{}}</code> would have to be ignored for later.</p>\n<p>Considering can-value / can-EVENT, would they look like:</p>\n<p><code>&lt;input can-value=\"{{item}}\"/&gt;\n&lt;button can-click=\"{{destroy}}\"&gt;</code></p>\n<p>Removing looking up <code>state</code> in state=\"state\" would be a breaking change ... unless it was done in stache ....<br />\n. Part of the issue ... I'm trying to transition away from mustache and <code>{{}}</code> in general to favor more of an html-only API. <br />\n. Although one could argue that looking up a value in a \"scope\" is inherently non-HTML ish ... it still feels great.</p>\n<p>@moschel There are no breaking changes in 2.1.  It's a minor release.  It would have to wait until 3.0 if its in mustache.\n. @moschel Still, I find there will be a lot of weirdness with can-value and can-EVENT unless we also change their APIs.   </p>\n<p>And, it will be strange if in can.stache, calling components looks different.  It will slow adoption for can.stache.\n. I agree there's a problem.  I'm not sure adding more <code>{{}}</code> is the ultimate solution.  We should at least check out how more html-centric view layers solve this problem.\n. Currently, if you write <code>can-value=\"{{prop}}\"</code>, it offers some additional flexibility.  For instance, I could render this with:</p>\n<p><code>js\n{prop: \"first\", first: \"Justin\", last: \"Meyer\"}</code></p>\n<p>And then changing prop to \"last\" would then change the cross-binding to operate on the last property.</p>\n<p>I'm not claiming that this is a very useful feature.  Just something to think about.\n. @shcarrico Yeah, this is what concerns me too.  Doing something like:</p>\n<p><code>$(\"&lt;my-component/&gt;\").appendTo(document.body)</code></p>\n<p>Is the thing I really want for 2.2.  However, I'm not sure what we even do with \"scope\" in this situation.  Do we walk up where we are inserting and look for elements that have been rendered with a scope?  </p>\n<p>Regarding:</p>\n<blockquote>\n<p>I am also curious why we need to use @ in the existing API.. couldn't we just pull the string value if the lookup failed?</p>\n</blockquote>\n<p>Not exactly .... it's possible someone want to do:</p>\n<p><code>html\n&lt;parent-component&gt;\n  &lt;child-component thing-id=\"thingId\"&gt;&lt;/child-component&gt;\n&lt;/parent-component&gt;</code></p>\n<p>(I will fill this part in later ... have to get back to training)\n. @sykopomp @moschel </p>\n<p>Basically, just review how this is done in more HTML-based views.  If they do not apply well to can.stache, you've got my support to make this change.</p>\n<p>Please hurry up on that research though.  I want to get out 2.1 pretty soon.\n. stash-only is ok for 2.1\n. To attempt at being more clear:</p>\n<p>If we are going towards templates without <code>{{}}</code>, I want to have better visibility into what they are going to look like without <code>{{}}</code> so that transition might be made more simply.\n. @sykopomp @moschel @daffl There's one hiccup with this ... can-EVENT.  In the future, I want to support being able to call method with specified arguments like:</p>\n<p><code>&lt;div can-click=\"removeFrom(parent, child)\"&gt;&lt;/div&gt;</code></p>\n<p>Where remove from might look like:</p>\n<p><code>js\nremoveFrom = function(parent,child){\n  parent.splice(parent.indexOf(child), 1)\n}</code></p>\n<p>This would mean changing it to look like:</p>\n<p><code>&lt;div can-click=\"{{removeFrom(parent, child)}}\"&gt;&lt;/div&gt;</code></p>\n<p>Or even worse:</p>\n<p><code>&lt;div can-click=\"{{{{removeFrom}}({{parent}}, {{child}})}}\"&gt;&lt;/div&gt;</code></p>\n<p>Thoughts?  </p>\n<p>In my opinion, this is so ugly, that I think we should still keep the existing behavior of can-EVENT.\n. In terms of adoption, I'm not very concerned.  This is a big part of the reason why people use Angular.  I believe Plolymer's Model-driven-views do something similar.</p>\n<blockquote>\n<p>prepared to offer the explanation</p>\n</blockquote>\n<p>You're very right about this.  I've given this explanation a few times, but I think the people who need it are a small group (knowledgeable/experienced enough to see a similarity with it and DOM0, but not experienced with Angular / Polymer to know why it's different).  And I think the people who hear it, understand it.\n. <code>{{can-click removeFrom parent child}}</code> brings things full circle.  This was already possible in 1.1.8.  `can-click=\"foo(bar)\" is much much more understandable in my opinion.  And imo, worth the cost of a little confusion if it contrasts with how values get passed to can.Component.\n. In my opinion, that is less obvious and harder to read.</p>\n<p>I don't think can-click is less obvious than can-event-click. \n. @matthewp 's comments here: https://github.com/bitovi/canjs/issues/730#issuecomment-38499772 are related to this discussion. \n. This made it into minor.\n. Yeah, I just noticed this yesterday.  @daffl, please fix it and we should get out a 2.0.7 monday.<br />\n. Yep, that was a bug that is now fixed in 2.1. Undocumented APIs should be documented or avoided. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 23, 2014, at 12:32 AM, Josh March\u00e1n notifications@github.com wrote:</p>\n<p>In 2.0, can.view.preload can be used when recompiling templates. The rendering function it returns can then be called to render the template into a document fragment. In 2.1, the rendering function returns a string, instead.</p>\n<p>While this isn't an externally-documented API, it's used by some external tools to prerender mustache templates, for example http://github.com/sykopomp/can.viewify and https://github.com/daffl/can-compile.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. A bit more of an explanation: </p>\n</blockquote>\n<p><code>can.view.preload</code> now takes a 'renderer' function.  Renderers were always supposed to be functions that resulted in a fragment.  However, there were places this was a mixed bag which was confusing and something we ( @daffl  and I ) wanted to fix in 2.1.</p>\n<p>In 2.0, <code>can.view.preload</code> was taking string renderers and converting them to renderers.  This was incorrect and doesn't work with stache (which can only return renderers).</p>\n<p>In 2.1, its now returning the renderer function one gives it.</p>\n<p>However, I've added a <code>can.view.preloadStringRenderer</code> that does the previous behavior.  External tools can call that to mimic the old behavior.</p>\n<p>We could leave .preload were it was, and instead create a <code>preloadFragRenderer</code> function.  However, I want <code>renderer</code> to now universally mean \"function that is called with data and returns a document fragment\" because having two different types of renderers was causing confusion.  So because none of this was documented, and we needed to change things for stache to work, I felt that getting it \"right\" was important now.\n. @daffl Sorry for the confusion.  The expected behavior is to pass <code>can.view.preload</code> a function that renders a document fragment.  <code>can.view.preload</code> just returns what it was given.\n. You could do this within set yourself:</p>\n<p><code>set: function(newVal, setVal){\n  if( can.isDeferred(newVal) ) {\n    newVal.then(setVal)\n  } else {\n    setVal(newVal);\n  }\n})</code>\n. &gt; Are you going to add here plain object/array attributes support (that won't be converted to can.Map)?</p>\n<p>Yes, you do that like:</p>\n<p><code>js\ndefine: {\n  plain: { type: \"*\" }\n}</code>\n. This relates to #819.  I'd like a getter API that used this:</p>\n<p><code>js\n{\n  define: {\n    todos: {\n      get: function(oldValue, setValue){\n          Todo.findAll({makeId: map.attr(\"makeId\")}, function(todos){\n            setValue(todos);\n          })\n      }\n    }\n  }\n}</code>\n. @matthewp Ha!  I forgot I created the other issue.  Closing that one.\n. @matthewp I like the idea.  It feels deferred ish.</p>\n<p>A small issue with that is it would involve creating 2 computes ... the initial one and the one that gets called when there are changes.  One would be setup to change the other.</p>\n<p>This 2x the number of change events being fired.  I'm not sure about performance.\n. I think a signature like:</p>\n<p><code>js\nvar todos = can.compute(new Todo.List(), function(newVal, oldVal, setVal){\n  Todo.findAll({makeId: map.attr(\"makeId\")}, function(todos){\n    setVal(todos);\n  })\n})</code></p>\n<p>will work now.\n. That will not work.  I was thinking something like:</p>\n<p><code>js\nvar obj = can.compute({}, {\n        value: {},\n    fn: function( curVal, setVal ){\n        if(a()) {\n            curVal.a = a();\n        } else {\n            delete curVal.a;\n        }\n        if(b()) {\n            curVal.b = b();\n        } else {\n            delete curVal.b;\n        }\n    }\n});</code></p>\n<p>But the problem with all of this ... what is the value of an unbound compute?  It will not be correct.\n. So, I think this should not be through the compute constructor because it is returning a compute that you can read but might not have the current best value.  Only a \"bound\" async compute will have the current value.</p>\n<h1>can.compute.async</h1>\n<p>@function can.compute.async</p>\n<p>Create a compute that can set its value after the computed function has been called.</p>\n<p>@signature <code>can.compute.async(initialValue, computed(currentValue, setValue(newValue) )</code></p>\n<p>@param {*} The initial value of the compute.\n@param {can.compute.asyncComputer} computed(currentValue, setValue) A function that returns the current value of the compute and can optionally later call its <code>setValue</code> callback to update the value.</p>\n<p>@return {can.computed} Returns a compute, but a compute that will possibly not have the correct value unless it is bound to.</p>\n<p>@body</p>\n<h2>Use</h2>\n<p>The following compute is a live list of todos for a given userId.  <code>todos</code> value would alternate between <code>null</code> and a Todo.List as <code>userId</code> changes.</p>\n<p>``` js\nvar userId = can.compute(5)</p>\n<p>var todos = can.compute.async(null, function(oldTodoList, setValue){\n  Todo.findAll({ userId: userId() }, function(todos){\n    setValue(todos)\n  });\n  return null;\n})\n```</p>\n<p>The following replaces the list in place:</p>\n<p>``` js\nvar userId = can.compute(5)</p>\n<p>var todos = can.compute.async(new Todo.List(), function(todoList, setValue){\n  todoList.replace( Todo.findAll({ userId: userId() })\n  return todoList;\n})\n```</p>\n<h1>can.compute.asyncComputer</h1>\n<p>@typedef {function(*,function)} can.compute.asyncComputer(currentVal, setVal)</p>\n<p>A function that determines a value for an [can.compute.async async compute].</p>\n<p>@option {function(*,function)} can.compute.asyncComputer(currentVal, setVal)</p>\n<p>@param {*} currentVal The current value of the compute.  This should be returned\nif you are doing an in-place compute. </p>\n<p>@param {function(*)} setVal(newVal) Called to update the value of the compute at a later time.</p>\n<p>@return The immediate value of the compute.  </p>\n<p>Thoughts?\n. I am not going to document this for 2.1.  can.Map define will use it, but I'm not sure it's super useful outside maps.  I've added the documentation but hidden it.  We can unhide it for 2.2 if people crave it.\n. How would you use async for a spinner image on its own?\n. I would not do it that way.  I would probably do it like:</p>\n<p><code>js\ncan.Component({\n  tag: \"img-spinner\",\n  template: \"&lt;img {{^ready}}style='display:none'{{/ready}} src='{{src}}' can-load='loaded'/&gt;\"+\n     \"{{^ready}}&lt;img src='{{spinnerSrc}}'/&gt;{{/ready}}\"\n  scope: {\n    loaded: function(){\n      this.attr(\"ready\", true);\n    }\n  }\n})</code></p>\n<p>stache:</p>\n<p><code>&lt;img-spinner src=\"cat.png\" spinner-src=\"dog.png\"&gt;&lt;/img-spinner&gt;</code>\n. As all of that happens in the same \"turn\", it should not miss load. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On May 6, 2014, at 9:19 AM, rjgotten notifications@github.com wrote:</p>\n<p>I would not do it that way. I would probably do it like</p>\n<p>Depending on the order at which the templating system creates image element, sets its src property and binds its load event (you're discarding the error handling case, btw.) , you may or may not run into a race condition where load is never triggered for images arriving from cache.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Can you write out how you would use <code>async</code> explicitly for image loading.\n. This isn't a bug.  Functions are methods, not attributes.<br />\n. Agreed, closing b/c the define plugin should allow you to control how everything works.\n. This is fixed in can-component.<br />\n. @daffl what do you mean by:</p>\n<p>I'm still not sure I fully understand the usecase. If nothing is listening, why have an observable list at all? Why not just implement an array-like construct that emits the events needed?</p>\n</blockquote>\n<p>It's common that not everything in a map is listened to right away.\n. Done in 3.0.\n. @neektza that is not the \"base\" sort that @alexisabril  is talking about. The sort that comes with can.List should just sort in place ... the sort plugin keeps it sorted when inserts happen.\n. @cherifGsoul it's not the same notation.  It does something very differently.\n. @cherifGsoul I think you will be after the 10th time writing it :-)\n. I've already added this in lazy-bubbling\n. Actually, yours has docs, so we will use yours.\n. This needs to include what those component methods look like.  Either <code>this</code> should be the raw element or the jQuery wrapped element.</p>\n<p>Raw:</p>\n<p><code>js\ncan.Componet.extend({\n  tag: \"my-greet\",\n  template: \"&lt;h1&gt;{{message}}&lt;/h1&gt;\"\n  scope: {message: \"Hi\"},\n  say: function(message) {\n    $(this).fadeOut();\n    this.scope.attr(message)\n    $(this).fadeIn();\n  }\n})</code></p>\n<p>jQuery</p>\n<p><code>js\ncan.Componet.extend({\n  tag: \"my-greet\",\n  template: \"&lt;h1&gt;{{message}}&lt;/h1&gt;\"\n  scope: {message: \"Hi\"},\n  say: function(message) {\n    this.fadeOut();\n    this.scope().attr(message)\n    this.fadeIn();\n  }\n})</code></p>\n<p>For ease of use today, jQuery would be obviously nicer.  But for the \"future\" <code>this</code> as the raw element is probably easier to work with registerElement.  Also, the raw element will make more sense from the outside's perspective ... the user is going to call <code>greetEl.say(\"Hello\")</code> and this will be <code>greetEl</code> not `$(greetEl).</p>\n<p>Also, just to make sure we are on the same page ... not only should it not be coping data (and just setting pointers), we should still make sure IE8 doesn't croak because I think it might create attributes whenever properties are set on an element.\n. Another consideration, what if a prototype method matches a scope value.  For example:</p>\n<p>``` js\ncan.Componet.extend({\n  tag: \"my-greet\",\n  template: \"<h1>{{message}}</h1>\"\n  scope: {message: \"Hi\"},\n  message: function(message) {</p>\n<p>}\n});\n```</p>\n<p>And your html looks like:</p>\n<p><code>html\n&lt;my-greet message=\"{{foo}}\"&gt;&lt;/my-greet&gt;</code></p>\n<p>Does this call the message function?  Does it pass it a compute and expect it to setup two-way binding itself to the message scope property?\n. Regarding the previous comment ... we might want to be able to define a getter / setter function on the element (and potentially future getter /setter) like:</p>\n<p>\"message\": \"scope.message\"\n. I like it a bit more directly on the component.  That way, \"this.scope\", potentially \"this.template\", etc make a bit more sense.  </p>\n<p>Instead of \"properties\", I would support a  \"define\" property that works like can/map/define.\n. Scope does not have access to the element (and should not). That's why it should be separate, it's a view model. But there's cases where having access to an element will be important. </p>\n<p>A. I'm fine not allowing scope/template as accessors on an event. </p>\n<p>B. Can be avoided.  </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Apr 13, 2014, at 12:56 AM, Josh March\u00e1n notifications@github.com wrote:</p>\n<p>I prefer @matthewp's approach. I do not believe we should automatically expose every single option/property on the can.Component (that means we should not expose scope by default. The component's API should be controllable by the component author, which means: A. They should be allowed to name their properties with any name they want without worrying about conflicts with Component options, B. They should not be forced to expose internal details of the Component (such as scope or template.</p>\n<p>There's also the issue with the message={{foo}} example. I think we're starting to go down the path where it would make sense to find a way to unify properties/define with scope (or specifically, get rid of scope as its own thing), but that's a more radical change for the API. I don't know why scope should exist as a separate thing from these properties and methods, though, beyond questions about the API -- considering, since we're making this be the HTMLElement itself, that we should now need to make .attr() available directly on the element to be able to do what we're used to doing. It would greatly simplify the API, though, and collapse three of the options into a single one: define, scope, and helpers would all become the same thing. events can stay separate, but would no longer be a repository for regular meth ods.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. A.  Plus you can't have this.scope access the scope or access a method named scope. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Apr 13, 2014, at 12:56 AM, Josh March\u00e1n notifications@github.com wrote:</p>\n<p>I prefer @matthewp's approach. I do not believe we should automatically expose every single option/property on the can.Component (that means we should not expose scope by default. The component's API should be controllable by the component author, which means: A. They should be allowed to name their properties with any name they want without worrying about conflicts with Component options, B. They should not be forced to expose internal details of the Component (such as scope or template.</p>\n<p>There's also the issue with the message={{foo}} example. I think we're starting to go down the path where it would make sense to find a way to unify properties/define with scope (or specifically, get rid of scope as its own thing), but that's a more radical change for the API. I don't know why scope should exist as a separate thing from these properties and methods, though, beyond questions about the API -- considering, since we're making this be the HTMLElement itself, that we should now need to make .attr() available directly on the element to be able to do what we're used to doing. It would greatly simplify the API, though, and collapse three of the options into a single one: define, scope, and helpers would all become the same thing. events can stay separate, but would no longer be a repository for regular meth ods.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. A view model should be independent of the element/dom/view. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Apr 13, 2014, at 4:06 AM, Josh March\u00e1n notifications@github.com wrote:</p>\n<p>can.Component.extend({\n    tag: 'shopping-list',\n    events: {\n        \".add-apple click\": function() {\n            this.list.add(this.makeApple());\n        }\n    },\n    properties: {\n        list: [],\n        add: function(item) {\n            this.list.push(item);\n        },\n        numberOfApples: {\n            get: function(){\n                return this.list.reduce(function(acc, item) {\n                    return acc + Number(item.name === 'apple');\n                }, 0);\n            }\n        },\n        makeApple: function() {\n            return {name:\"apple\"};\n        }\n    }\n});</p>\n<p><shopping-list list=\"{{listFromScope}}\"></shopping-list></p>\n<p>var list = document.querySelector(\"shopping-list\");</p>\n<p>list.add({name:\"apple\"});\nlist.numberOfApples === 1; // true\nlist.list.attr(); // [{name:\"apple\"}]\nlist.attr(\"list\", []);\nlist.numberOfApples === 0; // true</p>\n<p>but really I kinda like what x-tags does, too. Probably better than this approach. I think the way to describe it is that scope wouldn't be the viewmodel anymore. The component/element itself is the viewmodel. Or something.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. @sykopomp Could you elaborate more on the points you just made?  I'm not really sure what you are saying about mapping properties to attributes.  I assume you mean mapping the properties object to the element's attributes.</p>\n</blockquote>\n<p>I'll try to explain where I'm coming from a bit more:</p>\n<p>An element has an external API that is accessed as properties and methods directly on the element like <code>form.action = \"foo\"</code> and <code>form.submit()</code> and as attributes: <code>form.setAttribute(\"action\",\"foo\")</code>.  There's precedent that the properties do not behave the same way as the attributes (for example 'href' on a link).</p>\n<p>In the long run, I'd like to enable people to express all three of those APIs.  I'd also like those APIs to have the ability to do anything that our current views might not be able to express (for example running an animation).</p>\n<p>But, encouraging people to have a view model is important.  A view model should be very unit testable and not have access to an element as it is independent of any view.  You could theoretically wire it to a view made with Canvas / SVG / or Java Swing.  </p>\n<p>For your example, how would you run an animation that fades in the 'apple' item when <code>\"add\"</code> was called?</p>\n<p>Basically, you seem to be recommending exposing what is currently \"scope\" directly on the element. I'm not opposed to that as a short-cut for components who's \"scopes\" that don't need to talk to the <code>element</code> directly.  Your example is like this.</p>\n<p>But for elements who might want methods that need to interface with the element (run an animation), I'm opposed to view models that have this awareness.  It makes it much harder to tests and shouldn't be how people write things.</p>\n<p>This is why I think that there needs to be another area for methods / properties that can talk to the element, the template, and the view model/scope.  </p>\n<p>My first instinct was to put this as the prototype methods of the component:</p>\n<p><code>js\ncan.Component.extend({\n  scope: {\n    add: function(item){\n      this.list.push(item)\n    }\n  },\n  add: function(item){\n    this.scope.add(item);\n    var index = this.scope.list.indexOf(item);\n    this.element.children().eq(index).hide().fadeIn()\n  }\n})</code></p>\n<p><em>note: this example is possible to do by listening to events, but things get tricker if you wanted different methods that add items that would run different animations</em></p>\n<p>The reason why this is my first instinct is because <code>this.scope</code>, <code>this.element</code>, <code>this.template</code> will make quite a bit of sense.  I'm not opposed to putting that somewhere else.</p>\n<p>But, I do want to make sure people can build view-models independent of the DOM while enabling \"any\" type of interface.\n. This is part of #730.\n. Closing for #730 \n. weird, I can't imagine that we don't have a test for that.\n. Thanks!  I think another approach would be to make that code use \"root\": https://github.com/bmomberger-reciprocity/canjs/blob/route-without-bang/route/route.js#L535</p>\n<p>And then people can adjust the root to be whatever they want.\n. There is no call signature. But yes, something is wrong. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Apr 16, 2014, at 5:08 PM, Brian Moschel notifications@github.com wrote:</p>\n<p>http://canjs.com/docs/can.view.live.html</p>\n<p>Has a bug in the docs probably, nothing is really showing up. Its missing the call signature and example</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. <code>js\n\"\" != null</code>\n. Somewhat related to #450 \n. It was related.  I wrote a test, it was breaking and I pulled in yours and it works.  can.Component uses can.compute.read.\n. This can't be made to work and perform well.  It's a chicken - egg problem.  We can't have the element until mustache is processed.</p>\n</blockquote>\n<p>Stache will be able to provide the element though.\n. So makeEvaluator https://github.com/bitovi/canjs/blob/minor/view/stache/mustache_core.js#L417 does not get passed the element.</p>\n<p>What is \"this\" in the <code>activeClass</code> helper?  Currently, <code>this</code> is the scope in helpers.  Are you expecting it to be the element?  Why can't the \"activeTab\" value be in the scope?  Making it observable would work better b/c live binding will update the page automatically.\n. Thanks for the idea, but this is not a bug with CanJS.  If you would like to see this happen, maybe register it on canjs.com's repo. \n. This will need some docs.\n. Should you be adding yourself to the list of heroes?\n. Closing as <code>stache.from</code> does not do ajax requests. This is gone in 3.0.\n. Thanks!  For this to close those issues, we will need similar warnings in can.stache.  If you are interested, the similar place this happens in stache is here: https://github.com/bitovi/canjs/blob/minor/view/stache/mustache_core.js#L215\n. I think \"in mustache template\" in:</p>\n<blockquote>\n<p>Variable \"' + key + '\" not found in mustache template.'</p>\n</blockquote>\n<p>is imprecise.  Perhaps <code>\"Unable to find key value \\\"\"+key+\"\\\".\"</code> to parallel the other warning.\n. This should not only happen for findOne but probably update and destroy. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Apr 30, 2014, at 3:12 AM, Eric Kryski notifications@github.com wrote:</p>\n<p>When you make a request for the a resource id that doesn't exist in your fixture we now automatically return a 404 error. Closes #803.</p>\n<p>You can merge this Pull Request by running</p>\n<p>git pull https://github.com/ekryski/canjs fixture-findone-#803\nOr view, comment on, or merge it at:</p>\n<p>https://github.com/bitovi/canjs/pull/921</p>\n<p>Commit Summary</p>\n<p>adding 404 for can.fixture.store.findOne when resource not found\nFile Changes</p>\n<p>M util/fixture/fixture.js (13)\nM util/fixture/fixture_test.js (32)<br />\nPatch Links:</p>\n<p>https://github.com/bitovi/canjs/pull/921.patch\nhttps://github.com/bitovi/canjs/pull/921.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. @neektza What do you mean once tests are passing?\n. @ekryski What is hairy about mustache_core?  It has received a ton of love.\n. Thanks for looking into this.</p>\n</blockquote>\n<p>In https://github.com/bitovi/canjs/commit/1a8ae871e2b55c3385bdc23a98956a5fd6661460 I changed <code>isHelper</code> to <code>looksLikeAHelper</code> to hopefully clear up and confusion.</p>\n<p>The code in question might seem a bit more complex in can.stache than can.mustache, but can.mustache actually will check for a helper twice. can.stache is a bit longer winded, but it avoids this problem ... making finding a \"miss\" much faster.</p>\n<p>If you have questions / confusion, please don't hesitate to ping me (justinbmeyer) on skype.\n. @andykant something is still breaking.\n. It might be helpful to add a test directly against can.compute.read.\n. This plugin should not be used.  That's why it's not documented.  We wanted to remove it for 2.0, but it got passed somehow.  It's only there in case anyone was already using it.\n. Closing b/c we are going to remove that plugin in 3.0.\n. @moschel I'll be working on this over my flight.\n. I like the idea.  There's a few issues:</p>\n<p>map.serialize('local') will serialize the \"local\" property currently with the attributes plugin.  We couldn't support both attributes and define so this would have to wait until 3.0.</p>\n<p>The second option to serialize is currently the property so this would be another API change.</p>\n<p>What about making it easy to make your own serializer methods?  map.serializeToDB()?  That might be something we can get in earlier.\n. &gt; Well but could this be supported now for apps where \"attributes plugin\" is not included?</p>\n<p>Yes, but not also having both loaded without each module \"knowing\" about the other.\n. &gt; What do you mean by \"making it easy to make your own serializer methods\"?</p>\n<p>I mean that we could make it possible to create a <code>map.serializeToDB()</code> function that would look for \"serialize.serializeToDB\" properties in the define plugin.\n. I'm adding \"needs a hero\" label.  I'm happy to help make this happen, but I need a champion to do the heavy lifting.  </p>\n<p>Both <code>can-map</code> and <code>can-define/map</code> use a serialize helper to loop through each property and recursively call <code>serialize</code> or some other method on the value if appropriate: </p>\n<p>https://github.com/canjs/can-define/blob/master/map/map.js#L177</p>\n<p>The solution to this might be to make a <code>can-util/js/serializer</code> which essentially would be a helper that would do something similar, but exposed and documented so everyone could use it.<br />\n. Closing, I'll re-open if someone is going to help.\n. isResolved should probably be true if there is no active deferred on the list.  However, I'm not sure why you would use isResolved if you are providing the items to the list.  isResolved might return undefined in this case.</p>\n<p>Also, Why would list have a resolve method?  What would it be used for?  One should be resolving the deferred passed to the list, not the list itself.\n. I will fix this while fixing IE.\n. Awesome work!  But, I'm not sure about this b/c we have plans to make findAll return a list (with promises) in 2.2.  If this happens, there shouldn't be a <code>get</code> method.\n. @retro At this point, we can't get it in 2.1. We've regression tested IE8 + 9 and every other library.  Plus if you made it work with <code>findOne</code>, list does not work with <code>findAll</code> so there would be an inconsistency.  </p>\n<p>Adding a feature 14 hrs before a release is probably not wise.  But lets talk about making something happen for 2.2.<br />\n. closing.  once we added promise support in our templates, the importance of this faded a bit.\n. Can you please create a fiddle?  Also, update your example with the changes I suggested.<br />\n. Also, make sure that IE8 is in standards mode.  CanJS does not support quirksmode.\n. I understand it won't take much time (it will take longer than a minute to get a IE8 VM started), but there are other issues that have fiddles waiting. If this is urgent to you, it won't take much more than a minute to create a fiddle. \n. The shiv was not added to the fiddle.\n. So, it works for me in IE8 when I am using a locally served 2.0.7, but not when it is served from: <code>http://canjs.com/release/latest/can.jquery.js</code>.</p>\n<p>There might be a problem with how github pages is serving scripts.</p>\n<p>The HTML I got it to work with looks like:</p>\n<p>``` html\n&lt;!DOCTYPE html&gt;\n<html lang=\"en\">\n<head>\n    <title>IE8 failure demo</title>\n    <script src=\"../lib/html5shiv.js\">\n\n\n\n\ncan.Component IE8 failure test\n\n        <test-tag></test-tag>\n    \n</p>\n<pre><code>        can.Component.extend({\n            tag: 'test-tag',\n            template: '&lt;div&gt;this is the component&lt;/div&gt;',\n            scope: {\n                // no scope\n            },\n            events: {\n                // no events\n            }\n        });\n\n        $('body').append(can.view('test-template', {}));\n\n\n&lt;/script&gt;\n</code></pre>\n<p></body>\n</html>\n```</p>\n<p>Let me know if that works for you.\n. <img alt=\"dashboard\" src=\"https://cloud.githubusercontent.com/assets/78602/2874452/4460f1d6-d3e8-11e3-8f24-93ade768a1f3.png\" />\n. You can run just the output page, not the actual editing interface.\n. In my earlier comment, I said that it was not working when served from github, but worked locally:</p>\n<blockquote>\n<p>There might be a problem with how github pages is serving scripts.</p>\n</blockquote>\n<p>I'm not sure why that is.</p>\n<blockquote>\n<p>The login input fields behave strangely.</p>\n</blockquote>\n<p>What login input fields?\n. The forums are not written with CanJS.\n. https://github.com/bitovi/canjs/blob/minor/map/define/define.js#L220 looks like where this is happening, can you submit a pull request and test?\n. Why would you want this?</p>\n<p>You should listen to the \"post\" change event.\n. I think that should be outside define as it doesn't really require define to work.  It could still happen within the \"define\" object, but as another plugin.\n. Closing for: https://github.com/canjs/can-define/issues/15\n. @retro is this needed now that we have observable promises?  I'm closing, please let me know if we need to reopen.\n. I'm not sure where we would document this. Possibly stache.keys. The promises themselves are not observable by can.compute. Instead, the template engine creates a shim of the promise that is observable. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 4, 2015, at 3:14 PM, pYr0x notifications@github.com wrote:</p>\n<p>i do not found any documentation of that?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Your tests pass for me.  Is this expected?\n. Closing b/c the commits are in #961 \n. @whitecolor Sorry, I forgot to include all the information.</p>\n</blockquote>\n<p>For 3.0, I would like <code>new Model()</code> to be able to check the model store anyway, replacing <code>Model.model()</code>.  And <code>new Model.List()</code> should be used to replace <code>Model.models()</code>.</p>\n<p>There's still a minor possibility that people were using <code>Model.models()</code> because it could do a little data conversion, but I think people could handle that like <code>new Model.List( Model.parseModels( data ) )</code>\n. The define plugin does the same thing</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 20, 2014, at 2:11 AM, Alex Osh notifications@github.com wrote:</p>\n<p>Can you explain why remove</p>\n<p>computes directly on the prototype of a can.Map ?</p>\n<p>Here how I use computes currently</p>\n<p>scope: {</p>\n<p><code>items: can.compute(function(){\n        // some stuff\n        .....\n        return ....\n  })</code></p>\n<p>},\nevents: {\n      '{scope} items': function(){\n            // I would like to be able to handle items change here\n      }\n}\n\u2014\nReply to this email directly or view it on GitHub.\n. just move the function in the compute to define:{ items: { get:</p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 20, 2014, at 10:16 AM, Alex Osh notifications@github.com wrote:</p>\n<p>Could you elaborate my case using define plugin? So if I want to have some function and be able to handle it's change inside the code (like in my example).</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Closing for https://github.com/canjs/canjs/issues/2026\n. This is a problem with can/view/target\n. The problem is that when <code>{{#if}}</code> calls <code>options.fn()</code>, that calls <code>hydrate</code> to create the fragment, which eventually calls <code>tagHandler</code> which itself creates the instance of the child component.  When the child component is created, it calls <code>this.attr(data)</code> on its scope which sets up a binding on <code>_keys</code> for the <code>{{#if}}</code>.</p>\n</blockquote>\n<p>When the child component changes its scope attributes, it has the effect if re-running the <code>{{#if}}</code>.</p>\n<p>To fix this, <code>options.fn()</code> should be  \"shielded\" from a parent binding.<br />\n. Thanks for reporting, but it isn't a breaking change as our API never documented that functionality.  </p>\n<p>http://canjs.com/2.0/docs/can.proxy.html</p>\n<p>We changed to our own proxy b/c jQuery's code was slow.<br />\n. To be clear, can's util methods only have to provide what is documented, not the functionality inherited from jQuery or Mootools, etc.<br />\n. &gt; Maybe you should just stop cold with the partial inheritance/overriding of jQuery</p>\n<p>This is how we are able to keep CanJS's filesize small, by making use of the underlying library. This won't change.</p>\n<p>Using undocumented APIs is always risky.  If you would like to add some information on http://canjs.com/2.0/docs/can.util.html about how one should not assume functionality beyond what is documented, that would be very helpful.  Thanks. \n. It was certainly not snarky.  It's a big framework.  Any help we can get is appreciated.  </p>\n<p>Those implementations are less important.  90% of CanJS's users use jQuery so we heavily optimize its performance (and filesize).</p>\n<p>I disagree that it was a rash decision.  We are still semver compliant and improved the performance of 90% of CanJS users.\n. If someone wants jQuery's functionality, there's no harm in using $.proxy.\n. It should not be can. That forces a dependency on everything in core. It should be 'can/util'. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On May 12, 2014, at 5:10 PM, Guido Smeets notifications@github.com wrote:</p>\n<p>I've added another can import for view/stache/stache.js. Now I got stache precompiled templates running on node. I've imported can/util/library.js for lack of a better candidate. Doesn't seem to matter that much, as long as there's some prototype to extend that will be picked up later by other components.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. <code>can/util/library</code> should be <code>can/util</code>.\n. the can/util/library might have broken it.\n. We can ignore any special attributes registered with <code>can.view.attr</code>.</p>\n<p>Besides passing only attributes that has been predefined in scope will make component's API cleaner (from code perspective).</p>\n</blockquote>\n<p>This will create some unnecessary boilerplate.  Lots of APIs in JavaScript don't require you to enumerate the options.\n. This is a good idea.  Has to be 3.0.\n. I'm going to close this one and mark it as \"needs a hero\".  If you'd still like to see this happen, please open an issue in /canjs/can-component .  As the new view bindings are a bit more explicit, I'm hopeful this isn't really much of a problem.\n. @isadovskiy Although I find myself doing the apply trick all the time ... I'm wary of having methods on \"core\" can.List outside of what browsers provide on Array.  For example, we added filter, but filter is even in IE9: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter.</p>\n<p>Is there a pushAll on Array?  </p>\n<p>If not, I would rather see this go in a list extension plugin that we've wanted to add since we created CanJS, but have never had the time.  If you'd like to work on that, we can add things like this there.\n. Closing for #192.\n. Yeah, this should be fixed.\n. Computes can't always cache without creating a memory leak. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On May 16, 2014, at 2:09 AM, Bajix notifications@github.com wrote:</p>\n<p>A lot of times it's common to build out can.Map's before tying them into much. Unfortunately, when doing this, computes are not bound to anything, and thus fail to return cached values. This gets particularly problematic when returning objects, particularly deferreds.</p>\n<p>There is no documentation that expresses when can.Compute will/will not cache values, and it's not obvious that you need to bind a change handler to them for them to work in that manner.</p>\n<p>Computes should always cache values, or otherwise the documentation needs to be updated to make this crystal clear.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. @rjgotten you could absolutely do that. Closing for an issue in can-compute\n. In stache this is fixed with \"{{foo}}\" \"{foo}\" and \"foo\". </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On May 18, 2014, at 1:41 AM, Alex Osh notifications@github.com wrote:</p>\n<p>It seems I've asked a like question maybe on forum. But didn't get a satisfied answer.</p>\n<p>I believe it could be useful to have such thing:</p>\n<p>// this will take and bind name attribute from parent scope as usual\n<my-comp name=\"name\"></my-comp>\n// this will would take and bind attribute string value (as it was declared <code>name: '@'</code> on scope)\n<my-comp name=\"@John\"></my-comp>\n<my-comp name=\"@{{name}}\"></my-comp>\n\u2014\nReply to this email directly or view it on GitHub.\n. {foo} does what attr=\"foo\" used todo. attr='{{foo}}' will convert foo to a string and set that value as the scope attribute. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On May 18, 2014, at 12:21 PM, Alex Osh notifications@github.com wrote:</p>\n<p>What does {foo} mean? How to do i pass a parent scope's attribute name in one case and literal string in another?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Yes, I think it will always be an array</p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On May 18, 2014, at 3:19 AM, Josh March\u00e1n notifications@github.com wrote:</p>\n<p>Summary</p>\n<p>The can.List docs for event binding seem to be wrong about the removedElements value we actually get, and the add event actually returns a single value sometimes, which creates an ambiguity when listening to that event.</p>\n<p>Details</p>\n<p>The docs for can.List say:</p>\n<p>(for the add event)\n- newElements - The new elements. If more than one element is added, newElements will be an array. Otherwise, it is simply the new element itself.\n  (for the remove event)\n- removedElements - The removed elements. If more than one element was removed, removedElements will be an array. Otherwise, it is simply the element itself.\n  I could not find a case for the latter, since can.List#removeAttr() gives an empty array as removedElements, which is a pretty reasonable value. If that really is the case, the remove event docs should be updated to reflect this, and possibly even point out that you get an empty array back.</p>\n<p>For the add event, I couldn't find any regular can.List methods that triggered a newElements that wasn't an array of the actual values, except for can.List#attr, which does return the single item added. This creates a pretty problematic ambiguity, since users will have no way of distinguishing an add event where multiple elements were added from an event where a single array was added at a single index. Unless I'm missing something, this should probably be fixed, and the docs updated accordingly to note how newElements will always be an array.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. What is the issue?  It doesn't set constructor.name.\n. @DVSoftware Thanks for submitting this pull request.  I understand the use case, but I'm wary of using eval.  There are many environments that would forbid this.</p>\n</blockquote>\n<p>Is <code>displayName</code> supported in Chrome? https://code.google.com/p/chromium/issues/detail?id=17356\n. I'm fine with that.  Can you submit a pull request for that?\n. @ms Thanks for reporting! This fiddle seems to be working.  Maybe it wasn't working in the earlier version you linked to.  Closing.  Please re-open if there's still a problem.\n. What do you mean by:</p>\n<blockquote>\n<p>changes to child properties bubble out of parent properties. </p>\n</blockquote>\n<p>I'm not sure what you mean by \"out of\" specifically.  Can you explain a real-world use case?</p>\n<p>What about a \"changed\" event that would only call an event handler once per batch.  For example:</p>\n<p>``` js\nvar list = new can.List([{name: \"one\"}, {name: \"two\"}])\nlist.bind(\"changed\", function(){</p>\n<p>})\ncan.batch.start();\nlist.attr(\"0.name\", \"ONE\");\nlist.attr(\"1.name\",\"TWO\");\ncan.batch.end();\n```</p>\n<p>Real world scenario would be listening to can.route:</p>\n<p><code>js\ncan.round.bind(\"changed\", function(){\n  Items.findAll(can.route.attr()).then(function(items){ ... })\n});</code>\n. Sorry I'm being dense ... but when you say:</p>\n<blockquote>\n<p>each thing to come out of the parent, vs an atomic change for all child properties in one swoop.</p>\n</blockquote>\n<p>What do you mean by \"thing\" and \"come out\"?</p>\n<p>I think you mean that when you change multiple child observable's properties, numerous change events are dispatched on the parent.  For example:</p>\n<p>``` js\nvar child = new can.Map();\nvar parent = new can.Map({child: child})</p>\n<p>parent.bind(\"change\", function(ev, attr){\n  // called twice with attr = child.a and then child.a\n})</p>\n<p>child.attr({a: 1, b: 2});\n```</p>\n<p>Regarding the comment:</p>\n<blockquote>\n<p>// clientState would trigger one change event with an array of the above changes</p>\n</blockquote>\n<p>It couldn't be a  \"change\" event.   That would break the API of what change can be called with.  This is why I think a \"changed\" event would be more appropriate.\n. @mwilloam yes ... because there were multiple changes.  A lot depends on this, like live-binding.  That way a live binding on param1 and param2 will each get an event.\n. Binding to \"change\" is deprecated and will not be possible in <code>DefineMap</code> in 3.0.  Also, the use of the define plugin should remove the need to solve this problem in most apps and code.</p>\n<p>However, a solution to do this might look like:</p>\n<p>``` js\nvar handler = function(){\n  // stuff to do on one batch\n};</p>\n<p>var batcher = makeBatchBinder(handler);</p>\n<p>map1.bind(\"prop1\", batcher);\nmap2.bind(\"prop2\", batcher);</p>\n<p>makeBatchBinder = function(handler){\n  var lastBatch;\n  return function(ev){\n    if(!ev.batchNum || ev.batchNum !== lastBatch) {\n      lastBatch = ev.batchNum;\n      return handler.apply(this, arguments);\n    }\n  }\n};\n```</p>\n<p>If this is something someone would like to see in 3.0, please create an issue in /canjs/can-event .\n. Can you explain your example for needing it again and why returning a function doesn't work.\n. I think options.element makes sense.  In</p>\n<p>https://github.com/bitovi/canjs/blob/master/view/stache/mustache_core.js#L401</p>\n<p>I think <code>this</code> is the element.  You'd have to pass it to makeEvaluator (maybe as makeEvaluator's <code>this</code>) which would then have to be added to options.\n. I'd be happy to get this into CanJS, but I'm closing this do to lack of interest.  It's pretty easy to do if anyone wants to pick it up.  Please create an issue in <a href=\"/canjs/can-stache\">can-stache</a>. \n. Thanks for bringing this to my attention.  I just checked my benchmark and somehow stache performance is about 2x as slow as I left it.  I'll dig into it and discover why.  My guess is that a bug was fixed in a non optimal way.\n. So, this branch https://github.com/bitovi/canjs/tree/stache-perf has about 25% improvement (from 13ms to 9ms) where html bars is about 3ms.</p>\n<p>About 3ms of that difference seems to be how we are setting attributes so they \"might\" publish DOM modification events and we will set cssText for IE8 compatibility.  </p>\n<p>The rest of it seems to be around our events and computes.  We used to have live-binding not create a compute.  We might restore that.\n. So much of the remaining performance difference has to do with the way CanJS sets up live binding.  Ember does not support computed methods without explicitly specifying bindings.  CanJS does. CanJS uses the technique for computed methods when evaluating something like:</p>\n<p><code>{{content}}</code></p>\n<p>This technique involves calling a function, seeing what can.__reading calls it makes, comparing it with previous can.__reading calls.  That's unnecessary for a binding like <code>{{content}}</code>.</p>\n<p>I think we can improve performance significantly by optimizing for simple observable property binding.<br />\n. That gets CanJS down to 5ms per loop.  This makes CanJS faster than all the live binders except HTMLBars which is 3.6ms. I think this is sufficient gains to be included in a 2.1.2.</p>\n<p>Future gains can be had by:\n- removing the \"extra\" compute in attributes that are all mustache.\n- improving can.attr.set so it doesn't check MutationObserver.\n- improving attrParts performance\n. Down to 4.2ms.\n. If someone pulls this ... they should try to remove attrParts completely.\n. doesn't seem like it.</p>\n<p>Justin Meyer\n847-924-6039</p>\n<p>On Tue, Jun 10, 2014 at 4:25 PM, David Luecke notifications@github.com\nwrote:</p>\n<blockquote>\n<p>@justinbmeyer https://github.com/justinbmeyer Is there a pull request\nfor getting the stache perf branch into 2.1.2?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bitovi/canjs/issues/1011#issuecomment-45674004.\n. So, I thought about this while writing this code.  I've found that blowing things up when unbinding on events that were never bound useful for discovering errors in code.  </p>\n</blockquote>\n<p>Thoughts on this?\n. I believe dojo and yui do. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 10, 2014, at 4:58 PM, David Luecke notifications@github.com wrote:</p>\n<p>Maybe as a dev warning? Most DOM libraries don't error either when unbinding something that didn't have any events.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Just to make sure everyone knows this ... map.unbind('foo') does not unbind all 'foo' events. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 10, 2014, at 5:16 PM, DVSoftware notifications@github.com wrote:</p>\n<p>We have a really large code base, and after upgrading CanJS to latest, we started facing this bug, and we currently are not in a position to refactor all of the code to make this upgrade. I agree with daffl, most of the libraries don't error, they just unbind if events are set, and it makes sense. For example, i want to unbind all change listeners regardless there are any.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. You should be able to trim that fiddle up. For example a Model is unnecessary. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On May 28, 2014, at 9:12 AM, Lionhunter3k notifications@github.com wrote:</p>\n<p>Here's is the fiddle:</p>\n<p>http://jsfiddle.net/zuZg9/4/</p>\n<p>The basica idea behind this is to have multiple selects, and each time I choose an options from a select, that options is removed from the other selects. In Firefox and IE11, the \"UseReason\" method is called when selected, but in Chrome, this doesn't happen.</p>\n<p>I am not sure what to do. Thanks for any help.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. @shcarrico vote here: http://bithub.com/event/37416 :-)\n. I think it would have to be 2.2 at least.  I'm not sure how this fits in with semver.  Would we have to produce an empty can.construct.super.js util 3.0?\n. A bit different as there was never a <code>can.observe.js</code>.  can/observe was part of core.\n. Closing for https://github.com/canjs/can-construct/issues/4\n. Are you doing timeouts in between?  It won't come out this way synchronously.\n. @daffl Any thoughts about this?  We throttle route changes.  I'm going to close.  Re-open if you have an idea for some improvement.\n. Closing for the above issue in <code>can-route</code>\n. Thanks!  We'll look into this soon.\n. @epimeth Have you seen this outside JSFiddle?\n. I would rather invest time in making live binding faster. This is not something I want to work on. </p>\n</blockquote>\n<p>Make a version of stache that sets up live binding after rendering. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On May 30, 2014, at 3:12 AM, Brian Moschel notifications@github.com wrote:</p>\n<p>If this idea gets traction, it might also be useful to create a non-live-binding iterator (a loop that doesn't bind on length) for the same reasons as above. Something like:</p>\n<p>{{#~each contacts}}{{~name}}{{/~each}}\n\u2014\nReply to this email directly or view it on GitHub.\n. Are there docs?  Close if there are docs.  Thanks!\n. @moschel Can you clarify what you mean here:</p>\n<p>For example, if you have a rule like can.route(\":page.html\") and a url like foo/bar.html, can.route.attr('page') will be \"foo/bar\" and that value will get escaped.</p>\n</blockquote>\n<p>Specifically \"that value will get escaped\" ... what value?  Escaped how?\n. It will be much bigger. And it won't support Almond at first. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On May 30, 2014, at 8:35 AM, Steven Vachon notifications@github.com wrote:</p>\n<p>Interesting. What might the file size be like with the new Steal vs almond (RequireJS) ?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. This is no longer related to canjs. Can we move this convo to the forums. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On May 30, 2014, at 9:04 AM, Steven Vachon notifications@github.com wrote:</p>\n<p>Cool. Yep, I'll be there :)</p>\n<p>Are bundles only for cacheable components, or are they also used in creating a single distribution js file?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. @moschel emailed me:</p>\n<p>Looked into this a little tonight and it happens because the can.stache method is when all the can.view.attr callbacks are set up, so if a can.view.attr is registered after the template is parsed and preloaded, it won't run, even if the renderer function is run later.</p>\n<p>I think this would cause can.view.attr callbacks to not work in steal production mode, right?  If so this would be a bigger bug.\n. Yes, this is a \"wont-fix\".  The only alternative would be to re-process each template anytime anyone calls can.view.attr.  Instead just make sure can.view.attr is called first.</p>\n</blockquote>\n<p>@moschel this will work fine in production if you make sure the templates depend on the module that calls can.view.attr (which will have to be done with <code>deps</code>.\n. Sure, can you add it and submit a pull request?\n. This might be worth figuring out if we want to support dynamically importing components.\n. @imjoshdean can you take care of this today or tomorrow?  I want to get a release out soon.  Thanks.\n. @imjoshdean can you finish this up by tomorrow noon?\n. @yaroslavtsev I have time to work on this today.  Do you have  second to go over this with me.  Ping me on skype at justinbmeyer.  Thanks!\n. I showed how I fixed this here: https://www.youtube.com/watch?v=56DoykBew38&amp;feature=autoshare\n. Yes, use markdown where we can. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 6, 2014, at 9:56 AM, David Luecke notifications@github.com wrote:</p>\n<p>@booc0mtaco I think we should use actual markdown and not clutter it with custom tags. @param directives are a convention from documenting code and not part of any Markdown specification.</p>\n<p>For the future I'd also like DocumentJS to also parse the YAML frontmatter for markdown files instead of having to add things like the @page and @parent tokens.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. No. The form of the dependency will likely be independent of any loader. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 3, 2014, at 1:35 AM, Brian Moschel notifications@github.com wrote:</p>\n<p>doesn't this belong in the steal issues?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. &gt;  It can't be done as a helper.</p>\n</blockquote>\n<p>What do you mean by \"helper\"?</p>\n<blockquote>\n<p>Are you thinking of some type of mustache/stache syntax for this? </p>\n</blockquote>\n<p>I'm thinking the <code>&lt;module&gt;</code> tag or something similar.\n. Is the module's <code>src</code> attribute supposed to be the same as a <code>&lt;script&gt;</code>'s src attribute?  Or can it reference a moduleName that will be run through normalize / locate?</p>\n<p>Asked guy here: https://groups.google.com/forum/#!topic/systemjs/GcBp0LJhrKg\n. We can parse, get imports, wait, and then process the template. </p>\n<p>How are web components supposed to import their dependencies?</p>\n<p><code>&lt;link rel=module&gt;?</code></p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Oct 14, 2014, at 2:05 PM, Matthew Phillips notifications@github.com wrote:</p>\n<p>I don't believe that <module> can take module names. There was a time when it was supposed to but I believe they changed it. Now it's just a better <script> tag (not in the global scope, for example).</p>\n<p>I think we need some custom for this. <can-import> maybe.</p>\n<p>I think you have to consider how this will be parsed. If you have a template like this:</p>\n<p><can-import name=\"can/view/bindings\"/>\n<can-import name=\"my/custom/attr\"/></p>\n<p><input type=\"text\" custom-attr=\"foo\">\nWe have to make sure we import all of the imports before the rest of the template is parsed. Stache calls of it's callbacks when it parses (I believe, correct me if I'm wrong) and therefore the custom attribute custom-attr won't be initialized.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. I'm not sure we should be doing this.  There are lots of plugins and we don't warn about each one.\n. There is a branch for the new steal. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 3, 2014, at 6:59 AM, Marshall Thompson notifications@github.com wrote:</p>\n<p>Stealing a dev version of can isn't possible because the dev versions use a function that is undefined in the new Steal:</p>\n<p>//!steal-remove-start\nif (window.steal) {\n    steal.type(info.suffix + \" view js\", function(options, success, error) {\n        var type = $view.types[\".\" + options.type],\n            id = $view.toId(options.id + '');\n        options.text = type.script(id, options.text);\n        success();\n    });\n}\n//!steal-remove-end</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. @imjoshdean this currently isn't working in the new <code>can-fixture</code> because it operates on an XHR object instead of jQuery.  That filter would be added here: https://github.com/canjs/can-fixture/blob/master/core.js#L130</p>\n</blockquote>\n<p>Perhaps it could check <code>xhrSettings.data.canfixture</code>?</p>\n<p>I'm going to close this as it's implemented in CanJS.  Someone can open an issue if they need it in <code>can-fixture</code>.  Maybe an alternative would be something like:</p>\n<p><code>js\nfixture.off(function(){\n  return $.get(\"foo\");\n})</code>\n. The build failed. \n. I would make sure.\n. @moschel can you add some docs?\n. &gt; The value does get set when I change the selected item in the dropdown, but it doesn't get set initially.</p>\n<p>What do you mean?  Do you mean the dropdown doesn't get set initially or the value of \"foo.bar\"?\n. I have noticed this too, but when I tried to recreate it, I couldn't make it work.  It might have been due to the number == string issue.\n. Maybe ... if you think there's an issue, please create a fiddle.  Otherwise if it was your problem, can you close this one.\n. Yes</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 4, 2014, at 1:58 AM, Guido Smeets notifications@github.com wrote:</p>\n<p>The problem indeed goes away when I set my bars and bar properties individually instead of adding the model as a whole. The converters not being hit does seem to be a problem that could do with fixing though? Should I add a new issue for that?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. @shcarrico How would you improve the behavior?</p>\n</blockquote>\n<p>On:</p>\n<blockquote>\n<p>If I had bound to the info property, for instance, i would always want to merge the value instead of replacing it, as otherwise my handlers will all have to be re-bound.</p>\n</blockquote>\n<p>One should typically write <code>alice.attr(\"info\").attr(data)</code>, to avoid rebinding, like in JS you would need to write:</p>\n<p><code>js\n$.extend(alice.info, data)</code></p>\n<p>To avoid replacing <code>.info</code> all together.\n. Also, when you say:</p>\n<blockquote>\n<p>It is a valid thing to define a default value, then construct a map with said defaults, then set a value, and need to merge. </p>\n</blockquote>\n<p>It's nice to be able to have a setter syntax merge. But similar to JS, it might be confusing if someone did:</p>\n<p><code>js\nalice.info = data</code></p>\n<p>and that extended instead of set. </p>\n<p>I think maybe the problem is that:  <code>.attr(PROP, Object)</code> merges by default, but  <code>.attr(PROP, Map)</code> sets.  If this is true (not 100% sure), then the problem might be that <code>.attr</code>'s nature is ambiguous which is why making it extend might seem valid.\n. The latest commit passes all stache tests.  It doesn't completely avoid needing expandos on textNodes but instead of comparing against all live textNodes in the page, it compares a much much smaller set of textNodes. \n. I'm not sure what you mean. Render it like what?  Is this in stache only?</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 4, 2014, at 1:13 AM, Brian Moschel notifications@github.com wrote:</p>\n<p>In 2.0.7 you could name a component like tag: 'list' and render it like {{name}}.</p>\n<p>As of 2.1.0 any name not containing a dash doesn't work at all in this case. Not sure if this was intentional. Either needs better docs or a bug fix.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. This is still a bug. We can enforce it in 3.0. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 4, 2014, at 6:55 AM, Matthew Phillips notifications@github.com wrote:</p>\n<p>The custom element spec specifies that custom elements must contain a hyphen, so I think we should enforce that on our end.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. I'm not sure I agree with 3. {#if poeple} should warn</p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 4, 2014, at 2:37 AM, Brian Moschel notifications@github.com wrote:</p>\n<p>1) only show the construct.extend warning once per page\n2) only show each mustache key missing warning once per key (if this is in a loop it gets very noisy)\n3) only show mustache key warnings for rendering properties, not for arguments to a helper\n4) mustache key warnings were broken and showing up for all helper access also</p>\n<p>You can merge this Pull Request by running</p>\n<p>git pull https://github.com/bitovi/canjs less-noisy-warnings\nOr view, comment on, or merge it at:</p>\n<p>https://github.com/bitovi/canjs/pull/1051</p>\n<p>Commit Summary</p>\n<p>less noisy dev warnings\njshint\nFile Changes</p>\n<p>M construct/construct.js (7)\nM construct/construct_test.js (36)\nM map/setter/setter.js (8)\nM test/jquery.html (2)\nM view/mustache/mustache.js     (27)\nPatch Links:</p>\n<p>https://github.com/bitovi/canjs/pull/1051.patch\nhttps://github.com/bitovi/canjs/pull/1051.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. This should absolutely happen.  I'm not sure how I missed this.  Adding to can-connect's issues.  Thanks for reporting.\n. It's not the new default until 3.0. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 8, 2014, at 7:23 AM, Sebastian Porto notifications@github.com wrote:</p>\n<p>When using AMD, trying to use can.stache throws this:</p>\n<p>TypeError: can.stache is not a function\nThis is because can.stache is not required in the AMD dependencies of the main can entry point. If stache is meant to be the new default then it should be required.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. You should not extend can.event into can.Map. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 9, 2014, at 1:22 PM, Bajix notifications@github.com wrote:</p>\n<p>Generally, you can bind to events emitted from nested objects, such as \"{app} singer.shout\", which would listen to the shout event on the singer property of app. In this case, if you do can.extend(App.prototype, can.event), then the binding to singer.shout no longer functions.</p>\n<p>Working example, using attributes, no can.extend(App.prototype, can.event)\nhttp://jsfiddle.net/nSAab/1/</p>\n<p>Broken example, using attributes, using can.extend(App.prototype, can.event)\nhttp://jsfiddle.net/nSAab/2</p>\n<p>Broken example, using custom dispatched events, using can.extend(App.prototype, can.event)\nhttp://jsfiddle.net/nSAab/3</p>\n<p>Broken example, using custom dispatched events, calling can.event.dispatch.call without can.extend(App.prototype, can.event);\nhttp://jsfiddle.net/nSAab/4/</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. I've never found a need to emit custom events from a map.  Can you provide an example that would not be better served by just having some state change?  </p>\n</blockquote>\n<p>You can currently call can.dispatch on any object and have it trigger events.  However, it will not work with the DOT syntax and probably never because the DOT syntax relies on can.Map's bubbling which is unique to can.Map.\n. The example doesn't have to be a fiddle.  A conceptual example of what you are trying to accomplish will be enough.\n. Can you give me a real-world example of when you would need a precursor to updating the state?\n. There's probably a better way of doing this - creating an observable (but probably not can.Map) around the youtube player and keeping that separated from the Model that loads information about videos.</p>\n<p>Not sure if you've seen the example that hooks up a can.compute to a HTML5 video player, but this is what I mean by creating an observable around the youtube player.  </p>\n<p>I'm closing this b/c can.extent should not be extended into can.Map.  </p>\n<p>Can you attend the Friday hangout this week so we can discuss solutions to this problem?  We can possibly open another issue then.\n. Why wouldn't it create an event? In my example that would change the currentTime property and update the video controls.</p>\n<p>The view-model approach is the best possible approach most of the time.  CanJS might not be able to easily articulate the view-model you are looking for, but that doesn't mean the approach is not better than dispatching events.  I would much rather have CanJS able to make the view model you need instead of supporting dispatching arbitrary events.</p>\n<p>Look at can/map/bubble.js for how bubbling is controlled.  Basically only by listening to a \"change\" event or (dotted) \"foo.bar\" event does bubbling setup.  In the case of a dotted event, it just listens to change. </p>\n<p>As you are not dispatching a change event, the event will not bubble.  You have to dispatch a change event.</p>\n<p>Join us for Friday's meeting if you want to discuss more.  Thanks.\n. This is indeed a bug.  However, as can/control/route is deprecated, it's unlike we're going to prioritize fixing this.  Moving it to an issue <code>can-control-route</code>.\n. Stache or Mustache?\n. This is a bug.  But we aren't going to fix this in mustache.  Please switch to stache.  Fixing this in mustache would require much of the work done in stache.  It's simply not worth it when there is a much faster and highly compatible templating engine next door.\n. That's fine ... it dramatically improves performance and the return value was never documented.\n. @znajem Thanks!  If you have some time tomorrow, can you ping me on skype so I can get this fix in?  My screen name is justinbmeyer.\n. I'm in Chicago:</p>\n<p>Central Time Zone (UTC-06:00)</p>\n<p>Justin Meyer\n847-924-6039</p>\n<p>On Tue, Jun 17, 2014 at 11:38 PM, Ziad H. Najem notifications@github.com\nwrote:</p>\n<blockquote>\n<p>What's your timezone? I'm in Kuwait UTC+3.</p>\n<p>-------- Original message --------\nFrom: Justin Meyer notifications@github.com\nDate:18/06/2014 00:46 (GMT+03:00)\nTo: bitovi/canjs canjs@noreply.github.com\nCc: \"Ziad H. Najem\" znajem@computer.org\nSubject: Re: [canjs] Bug in view.mustache Passing Partials in Options\n(#1068)</p>\n<p>@znajem Thanks! If you have some time tomorrow, can you ping me on skype\nso I can get this fix in? My screen name is justinbmeyer.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bitovi/canjs/issues/1068#issuecomment-46395302.\n. This was fixed some time ago: https://github.com/canjs/can-mustache/blob/master/src/can-mustache.js#L1734\n. I think it should be optional.  I've found the use of the data/helpers of the parent component in light dom super useful many many times.  From the presentation I did today:</p>\n</blockquote>\n<p>``` html\n<my-app></p>\n<pre><code>&lt;div&gt;\n    {{link \"Drivers\", \"drivers\"}}\n    {{link \"DMVs\", \"dmvs\"}}\n&lt;/div&gt;\n\n{{#if showDMVS}}\n    &lt;dmvs&gt;&lt;/dmvs&gt;\n{{/if}}\n{{#if showDrivers}}\n    &lt;drivers&gt;&lt;/drivers&gt;\n{{/if}}\n</code></pre>\n<p></my-app>\n```</p>\n<p>link, showDMVS, showDrivers are all provided by <code>&lt;my-app&gt;</code>\n. Removed the bug label.  This might be a feature.  The switch is as easy as changing:</p>\n<p>https://github.com/bitovi/canjs/blob/master/component/component.js#L291</p>\n<p>and maybe</p>\n<p>https://github.com/bitovi/canjs/blob/master/component/component.js#L306</p>\n<p>To use <code>hookupOptions.scope</code> instead of <code>renderedScope</code>/<code>rendererOptions.scope</code>.  But I still think this should be optional.  A component might want to provide the light DOM helpers/data and callback methods.\n. The target audience for the light DOM is less JS developers and more HTML devs / Designers.\n. I don't have a better one, but I do have lots of random thoughts:</p>\n<p>The \"content\" is the \"light\" or \"user\" content/DOM.</p>\n<p>I'm afraid bindings is an overly used word in CanJS (and jQuery) that has other meanings. Dynamic is kinda vague.</p>\n<p>Maybe <code>addScopeToUserContent</code> or <code>addScopeToLightContent</code>.</p>\n<p>I don't like this because \"scope\" is over used.  If we change scope to viewModel in 3.0, and we wanted to be very explicit: <code>addViewModelToLightContentScope</code>.  A bit wordy.\n. leakScope</p>\n<p>Justin Meyer\n847-924-6039</p>\n<p>On Wed, Jun 18, 2014 at 10:04 AM, Matthew Phillips &lt;notifications@github.com</p>\n<blockquote>\n<p>wrote:</p>\n<p>Did we decide on a name for the property?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bitovi/canjs/issues/1069#issuecomment-46447700.\n. To be clear, they should be referenced, not documented in can.Component</p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 11, 2014, at 11:02 AM, Josh Dean notifications@github.com wrote:</p>\n<p>Functions/events such as:</p>\n<p>init\ninserted\nPossibly more\nIf they are vital to how can.Component works, they should be in can.Component.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Still probably a bug.  If a deferred is passed, it should use the deferred.\n. In chrome, example A shows numbers in the console.  Anyone else see that?\n. Both examples use the define plugin.  Are your examples broken?\n. This can't be turned on by default until 3.0. Please suggest an option to configure this behavior. </p>\n</blockquote>\n<p>Also, if a template is not provided, the current behavior should take place. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 11, 2014, at 10:40 PM, Josh March\u00e1n notifications@github.com wrote:</p>\n<p>Here's a first pass at implementing the semantics described in #1069</p>\n<p>You can merge this Pull Request by running</p>\n<p>git pull https://github.com/sykopomp/canjs 1069-lexical-content-bindings\nOr view, comment on, or merge it at:</p>\n<p>https://github.com/bitovi/canjs/pull/1076</p>\n<p>Commit Summary</p>\n<p>Fixes #1069 - can.Component now defaults to lexical semantics for light dom\nFile Changes</p>\n<p>M component/component.js (29)\nM component/component_test.js     (50)\nPatch Links:</p>\n<p>https://github.com/bitovi/canjs/pull/1076.patch\nhttps://github.com/bitovi/canjs/pull/1076.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. This isn't possible until 3.0. can.Component can't dynamically require mustache. It would be a breaking change. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 12, 2014, at 10:40 AM, David Luecke notifications@github.com wrote:</p>\n<p>Since there is now a replacement engine with can.stache, dependencies to can/view/mustache in e.g. can/component (https://github.com/bitovi/canjs/blob/master/component/component.js#L12) or can/view/bindings (https://github.com/bitovi/canjs/blob/master/view/bindings/bindings.js#L6) should be removed otherwise a production build will always contain the Mustache engine.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Closing as this is fixed in 3.0, but done in all of those individual repos.\n. Offset is documented as working?</p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 12, 2014, at 9:00 AM, Alexis Abril notifications@github.com wrote:</p>\n<p>@index directive within an #each, is correctly incrementing from 0, however not from the optional offset param when passed:</p>\n<p>http://jsfiddle.net/YN2CY/</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. You should be using a setter instead to change the value on the way in. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 12, 2014, at 10:18 AM, Bajix notifications@github.com wrote:</p>\n<p>If you use define with value to initialize a can.Map property, the getter will be passed the current value. However, after setting the current value, the getter is not being passed the new value.</p>\n<p>http://jsfiddle.net/wJV5j/</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. I'm not sure that can work. Get is called when a source observable value is changed. Your example has no source observables. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 12, 2014, at 11:14 AM, Bajix notifications@github.com wrote:</p>\n<p>Well, design philosophy aside, it is a bug if the expectation is that the getter is passed the current value, and this isn't reflected after updating the current value.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Sure, but my point is this use case might be something we can't support. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 12, 2014, at 2:08 PM, Bajix notifications@github.com wrote:</p>\n<p>That's only true if it's bound to. In this case, the getter is called twice; when initializing, and after setting. The second call should be passed the newly set date object.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. To be clear, it might be impossible to support the async getters AND a getter the way you are trying to use it. I'm not saying it isn't, just my instinct makes me think there are problems. </p>\n</blockquote>\n<p>That cached value comes from can.compute.async, which is setup to only keep a value when bound. So currently that value is meaningless when unbound. Somehow can.compute would have to make this meaningful. </p>\n<p>It might be possible, but this isn't how getters were designed to be used. </p>\n<p>I knew this problem existed when I made define; however, I didn't solve it because set can accomplish this use case. </p>\n<p>That's why I said use set. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 12, 2014, at 6:03 PM, Justin Meyer justinbmeyer@gmail.com wrote:</p>\n<p>Sure, but my point is this use case might be something we can't support. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 12, 2014, at 2:08 PM, Bajix notifications@github.com wrote:</p>\n<p>That's only true if it's bound to. In this case, the getter is called twice; when initializing, and after setting. The second call should be passed the newly set date object.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. I'm not sure how that did not get documented, I will fix that shortly. cc @brianmoschel</p>\n</blockquote>\n</blockquote>\n<p>There are things an async setter can not do. Check out the make model year demo. </p>\n<p>Until can.compute and mustache supports deffereds, returning an deferred is underpowered. This is because you can't easily do processing on the value. The point of this plugin is to make it possible to avoid setting up bindings. One would have to listen to the value change, wait until the deferred has resolved, and then update some other observable value. Async getters greatly simplify this. I think you can see this in the year property of the make model year example. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 13, 2014, at 2:41 AM, Bajix notifications@github.com wrote:</p>\n<p>First of all async getters are not documented whatsoever, and from a design perspective, a getter should always return a value immediately or return a deferred if applicable. Arguably, an async setter would be better in any scenario in which you'd want an async getter, as the results would always be synchronously available, and the live nature can be accomplished externally. If keeping async getters in is at the cost of making synchronous getters sane, it really might not be worthwhile to support async getters. It is really not that bad to simply return a deferred.</p>\n<p>I made a new example that has source observables, a binder, and that can only be represented using a getter, to demonstrate this issue more succinctly.\nhttp://jsfiddle.net/vsqC9/</p>\n<p>If it is in fact the case that this kind of functionality cannot be supported, then it's probably appropriate to change the call signature of getter to not be passed the currentValue. As it stands now, you can show this example to any dev and they will be beyond perplexed, and the documentation on these caveats is lacking, making for developers to feel like they're fighting the framework.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Here's the MMY demo's \"model\" function: https://github.com/bitovi/canjs/blob/master/map/define/doc/examples/makemodelyear.html#L133</p>\n</blockquote>\n<p>I'm very much not opposed to seeing this working.  I'm just not sure it can.  Can you create a test and I'll take a look at seeing how it can be made to work?\n. @Bajix you're right about the mmy example.  My original version used async, but then I changed it.</p>\n<p>It's not necessary, but it's very nice to be able to have a model without some external construct to listen, wait, and update.  It's easier to test.  Here's an example of that:  https://github.com/bitovi/canjs/blob/master/component/examples/paginate.html#L172</p>\n<p><code>.attr('items')</code> is really part of the grid's view model, but its behavior can't be easily tested.</p>\n<p>With async getters, I could write that like:</p>\n<p><code>js\ndefine: {\n  items: function(value, set){\n     this.attr(\"deferredData\").then(function(items){\n       set(items);\n     })\n  }\n}</code></p>\n<p>And be able to test it like:</p>\n<p><code>js\nvm = new VM({})\nvm.bind(\"items\", function(ev, newVal){\n  deepEqual(newVal, [\"a\",\"b\"]);\n})\nvar d = new can.Deferred();\nvm.attr(\"deferredData\",d);\nd.resolve([\"a\",\"b\"])</code>\n. Note to self: This would allow someone to read a value, if the value was previously set, it would use the current value; otherwise, this would go get the value.\n. &gt; It is really strange that we're using Type for constructors, and yet can.List/can.Map aren't applied using Type, but rather implicitly with if type: \"*\" isn't explicitly set. This is very inconsistent.</p>\n<p>This is how can.List and can.Map have always worked. They have always converted nested objects and lists into can.Map's and can.Lists. The obvious place for this to happen in Type/type.  Are you suggesting turning off this default behavior? This would break everyone's code and not be possible until a 3.0.\n. @Bajix taking a look at this again ... I'm going to make the original fiddle work.\n. @Bajix I'm having trouble understanding exactly what the issue is.  </p>\n<p>In \"Example B\", there's a property in the url (<code>task</code>) that is trying to set a <code>serialize: false</code> property. In general, a <code>serialize: false</code> property shouldn't have a corresponding property in the url.  </p>\n<p>Those properties can be set normally without them being removed: http://justinbmeyer.jsbin.com/cikeli/5/edit?html,js,console</p>\n<p>We have other serializer checkers we've added, so I'm not opposed, I just want to better understand the use case.  Thanks and sorry about the long delay.\n. @Bajix I'll reopen if you can get back to me on the details of the issue.\n. Are you using target? Afaik, it is not documented. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 12, 2014, at 2:45 PM, Curtis Cummings notifications@github.com wrote:</p>\n<p>In this commit ed24af0 by @justinbmeyer</p>\n<p>can.batch.trigger was changed to call can.dispatch instead of can.trigger. This has the effect of removing the target property (normally added by can.trigger from the event object for attribute and change events emitted from can.Map.</p>\n<p>Here's a simple fiddle demonstrating the 2.1.1 behavior: http://jsfiddle.net/W3kDk/</p>\n<p>Here's the same example but with the latest build (what will be 2.1.2): http://jsfiddle.net/nM4Lt/</p>\n<p>Can probably fix this easily by passing an event Object with type and target properties to can.batch.trigger instead of just the event name.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. I think there was a performance reason.  Make sure you check the live-binding performance after adding it back in.\n. Ok, that sounds good.\n. Don't remove it if it kills performance. Let's figure out a way to keep it he same. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 12, 2014, at 5:11 PM, David Luecke notifications@github.com wrote:</p>\n<p>This pull request removes the the evaluator caching for text section from can.stache which fixes the original issue #1065. Caching was done under the assumption that in a text sub section all expressions contain the same content making a simple template like the following fail:</p>\n<p><h2 class=\"{{#shown}}foo{{/if}} test {{#shown}}bar{{/shown}}\"></h2></p>\n<p>The only solution I could find was removing the evaluator caching which does slow down performance for the visual benchmark.</p>\n<p>You can merge this Pull Request by running</p>\n<p>git pull https://github.com/bitovi/canjs stache-truthy-attributes-1065\nOr view, comment on, or merge it at:</p>\n<p>https://github.com/bitovi/canjs/pull/1083</p>\n<p>Commit Summary</p>\n<p>Adding tests for truthy stache attributes (#1065).\nRemoving scope.__cache and updating test for #1065.\nFile Changes</p>\n<p>M view/scope/scope.js (1)\nM view/stache/mustache_core.js (9)\nM view/stache/stache_test.js (12)\nPatch Links:</p>\n<p>https://github.com/bitovi/canjs/pull/1083.patch\nhttps://github.com/bitovi/canjs/pull/1083.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks!</p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 12, 2014, at 6:35 PM, David Luecke notifications@github.com wrote:</p>\n<p>I just realized that we actually can cache normal property lookups (that don't have the mode set). Fixes the test and keeps the spinning circle performance the same as before :-)</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. I think there's another bug then. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 12, 2014, at 10:53 PM, Alexis Abril notifications@github.com wrote:</p>\n<p>When using \"resource\" as a shortcut in can.Model, the api signatures generated are incorrect when using the custom id property.</p>\n<p>var Foo = can.Model.extend({\n    resource: '/foos'\n}, {});</p>\n<p>var Bar = can.Model.extend({\n    id: 'Id',\n    resource: '/bars'\n}, {});</p>\n<p>Foo.findOne({ id: 0 });\n//Bar.findOne won't invoke an ajax request\nBar.findOne({ id: 0 });\nThis is due to https://github.com/bitovi/canjs/blob/master/model/model.js#L1077</p>\n<p>I believe that line should be:</p>\n<p>return resource + \"/{id}\"; //\"id\" will be looked up as model.id when we parse this string\n\u2014\nReply to this email directly or view it on GitHub.\n. @daffl Yeah, that's what I was thinking.  After talking with @alexisabril I'm not so sure it does.  @alexisabril is going to outline a \"Implementation / Use matrix\" with what works and what he thinks should work so we can discuss further and get this right.\n. Not sure why you wouldn't want everything to have that functionality?</p>\n</blockquote>\n<p><code>Item.List.mixin(can.List.sort)</code></p>\n<p>One thing to think about would be to make this work with the ideas around <code>can.connect</code>.  Basically, </p>\n<p>``` js\nTodo = can.Map.extend({ ... })</p>\n<p>can.connect(Todo, Rest(\"/todos\") )\n```</p>\n<p>So maybe some AOP is justified.  Considering that a plugin might have to weave into certain points in a certain order.\n. There is not a specification yet. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 30, 2014, at 4:47 AM, Mohamed Cherif Bouchelaghem notifications@github.com wrote:</p>\n<p>@justinbmeyer is there specification (doc) for can.connect? What about can.Model after that? does MVVM better than MVC?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. A \"single\" value compute like this will blow up, but why would you use that?  A function compute should work just fine.  <code>prop: can.compute(function(){})</code>.</p>\n</blockquote>\n<p>A Component is probably not necessary.  You could probably get this with a map:</p>\n<p><code>can.Map.extend({\n  prop: can.compute(false)\n})</code></p>\n<p>This probably has to do with compute's clone method.\n. I'm not sure it should be closed. It still technically a bug.\n. @patrickvogt Thanks a ton for pointing all of these out.  If you have a second tomorrow, I could show you how to submit changes to our docs.  If you're interested, ping me on skype at justinbmeyer.  Thanks!\n. What about supporting getter / setters properties in the future?  I'd like to make sure we have a plan for that.\n. I'm not saying it should, but you could do the same thing like</p>\n<p><code>value: $.cookie('user_id')\nset: function(id, setter){\n  User.findOne({id: id}, setter)\n}</code>\n. I'm saying I'm not opposed (not in support yet however).</p>\n<p>No, it would not set it to an id.  The value would only ever be the user instance.\n. I don't believe so.</p>\n<p>Justin Meyer\n847-924-6039</p>\n<p>On Thu, Aug 7, 2014 at 12:32 PM, David Luecke notifications@github.com\nwrote:</p>\n<blockquote>\n<p>Is this still an issue @justinbmeyer https://github.com/justinbmeyer?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bitovi/canjs/issues/1094#issuecomment-51504547.\n. http://jsbin.com/niruw/2/edit</p>\n</blockquote>\n<p>Works now.  The problem was the commas in the mustache helpers.\n. I believe they are in 2.1.2</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jul 10, 2014, at 4:32 PM, David Luecke notifications@github.com wrote:</p>\n<p>This is a big diff but it looks like when merging master into this branch that the changes are already in. Could you quickly verify those changes are in the current master already?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Another option ... <code>can-href</code> simply adds the behavior of the custom element.</p>\n</blockquote>\n<h3>Custom Attribute that hooks up other attributes</h3>\n<p><code>&lt;li&gt;&lt;a can-href page=\"recipe\" id='{recipe.id}'&gt;{{recipe.name}}&lt;/a&gt;&lt;/li&gt;</code></p>\n<p>Pros - still a link, fits in with how components get hooked up.\nCons - we'd want to pull out some of can.Component's guts to help set this up.\n. <code>js\n&lt;a can-href route-page=\"recipe\" route-id='{recipe.id}'&gt;{{recipe.name}}&lt;/a&gt;</code>\n. We are going the <code>&lt;a can-href route-page=\"recipe\" route-id='{recipe.id}'&gt;{{recipe.name}}&lt;/a&gt;</code> ... um ... route!  Although the object notation would be nice too.</p>\n<blockquote>\n<p>How would would you express the last two?</p>\n</blockquote>\n<p>This depends on what pretty routes you setup.  Put probably like:</p>\n<p><code>&lt;a can-href route-id=\"{id}\" route-action='edit'&gt;{{recipe.name}}&lt;/a&gt;</code></p>\n<p><code>&lt;a can-href route-id=\"{id}\" route-action='search' route-foo=\"bar\"&gt;{{recipe.name}}&lt;/a&gt;</code>\n. What's about:</p>\n<p><code>&lt;a can-href=\"{id: id, action: 'search', foo: 'bar'}\"&gt;{{recipe.name}}&lt;/a&gt;</code></p>\n<p>?</p>\n<p>Does React have 2 way routing?  CanJS treats all data the same.  There is no \"params\" vs \"query\" data.  The determinism of CanJS's routing, although confusing at first, is very powerful.  I don't think named routes would be a benefit.\n. @sporto it's all about how you setup your pretty routes.  But any other \"how to do canjs routing\" questions, please ask on the forums.  </p>\n<p>There's a lot of ways to structure your pretty routes depending on the situation.  If you're site was pretty uniform in the url structure, you could do:</p>\n<p><code>js\ncan.route(\"user/:userId/:part/:action\",{type: \"user\"});</code></p>\n<p>and</p>\n<p><code>html\n&lt;a can-href=\"{type: 'user', userId: user.id, part: 'comments', action: 'search', foo: 'bar'}\"&gt;Search&lt;/a&gt;</code></p>\n<p>If we made it possible to set \"merge\" and you were currently on the user/1 page, you would only have to write something like:</p>\n<p><code>html\n&lt;a can-href=\"{part: 'comments', action: 'search', foo: 'bar'}\" can-href-merge&gt;Search&lt;/a&gt;</code></p>\n<p>I suppose some naming might help make things nicer.  Being able to mixin: <code>{type: \"user\", part: 'comments', action: 'search'}</code> so you didn't have to write it so many times.</p>\n<p><code>js\ncan.route(\"user/:userId/comments/search\",\n           {type: \"user\",part: \"comments\", action: \"search\"},\n           \"user_comments_search\")</code></p>\n<p><code>html\n&lt;a can-href=\"{route: 'user_comments_search'}\" can-href-merge&gt;Search&lt;/a&gt;</code>\n. maybe this should be can-route as the attribute name.\n. For consistency, I think we are going to go with this:</p>\n<p><code>&lt;li&gt;&lt;a can-href='{page=\"recipe\" id=recipe.id}'&gt;{{recipe.name}}&lt;/a&gt;&lt;/li&gt;</code></p>\n<p>This will be easiest to implement and work similar to can-EVENT and passing options to helpers..\n. # can-href</p>\n<p>Sets an element's href attribute so that it's url will set the specified attribute values on [can.route].</p>\n<p>@siganture <code>can-href='{[attrName=attrValue...]}'</code></p>\n<p>@param {String} attrName\n@param {can.stache.key} attrValue</p>\n<h2>Use</h2>\n<p>With no pretty routing rules, the following:</p>\n<p><code>&lt;li&gt;&lt;a can-href='{page=\"recipe\" id=5}'&gt;{{recipe.name}}&lt;/a&gt;&lt;/li&gt;</code></p>\n<p>produces:</p>\n<p><code>&lt;li&gt;&lt;a href='#!page=5&amp;id=5'&gt;{{recipe.name}}&lt;/a&gt;&lt;/li&gt;</code></p>\n<p>If pretty route is defined like:</p>\n<p><code>can.route(\":page/:id\")</code></p>\n<p>The previous use of <code>can-href</code> will instead produce:</p>\n<p><code>&lt;li&gt;&lt;a href='#!page/5'&gt;{{recipe.name}}&lt;/a&gt;&lt;/li&gt;</code></p>\n<p>You can use values from stache's scope like:</p>\n<p><code>&lt;li&gt;&lt;a can-href='{page=\"recipe\" id=recipeId}'&gt;{{recipe.name}}&lt;/a&gt;&lt;/li&gt;</code></p>\n<p>If <code>recipeId</code> was 6:</p>\n<p><code>&lt;li&gt;&lt;a href='#!page/6'&gt;{{recipe.name}}&lt;/a&gt;&lt;/li&gt;</code></p>\n<p>If <code>recipeId</code> is observable and changes to 7:</p>\n<p><code>&lt;li&gt;&lt;a href='#!page/7'&gt;{{recipe.name}}&lt;/a&gt;&lt;/li&gt;</code>\n. @stevenvachon it wouldn't be more mustache/stache like.  Plus we already have a parser for <code>foo=bar</code>.\n. I sorta look at \"change\" as more of an inherited event from can.Map and there only really for \"bubbling\" on a can.List.  For that reason, I think having a string index / property everywhere is ok. </p>\n<p>If it's going to break our tests, it's probably not worth fixing unless there's a solid use case.\n. What do you mean by</p>\n<blockquote>\n<p>should be called with a success,</p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 25, 2014, at 12:31 AM, Brian Moschel notifications@github.com wrote:</p>\n<p>It seems like can/map/validate is sort of like can/map/define::setter but has several differences, and it might make sense to merge them.</p>\n<p>Setter supports async, validations doesn't.</p>\n<p>Validations supports an \"errors\" object and \"errors\" events, both of which are very useful.</p>\n<p>I propose merging the validations plugin into define. Or at least making them work together rather than separately.</p>\n<p>A couple thoughts:</p>\n<p>Although validate would be similar to set, I think validate should be separate, because I can think of cases where you'd want the hook provided by set and validation logic separate.\nThe validate callback should be called with a success, error so you can do serverside validations\n\u2014\nReply to this email directly or view it on GitHub.\n. @retro might have some input on this.\n. can.compute validations discussed in #111 are now part of this.\n. @retro What about observing when an error happens? That was the 3rd case.\n. @retro I care a lot about getting the \"simple\" case right too.  How could one add a simple email validation in the view layer?  Consider something like angular: https://docs.angularjs.org/api/ng/input/input%5Bemail%5D</p>\n</blockquote>\n<p><code>&lt;input can-value=\"{email}\" can-validate-pattern=\"\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}\\b\"/&gt;\n{{#if email.@errors}}\n  &lt;div&gt;{{#each email.@errors}}{{.}}{{/each}}\n{{/if}}</code>\n. Validation is not only a model concern. It is a view model concern. It is possible to want validations for the view model independent of the model. This is something we are currently dealing with. </p>\n<p>A good system allows both. </p>\n<p>This is akin to what we are suggesting for can.connect by separating CRUD behavior from the data model while still allowing them to be together in a nice package.  </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 9, 2014, at 1:51 AM, Guido Smeets notifications@github.com wrote:</p>\n<p>I still think validation is a model concern, not a view concern. That's something just about every framework out there does \"wrong\" as far as I'm concerned.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. We are seeing this in real apps. This is why we want to support both. </p>\n</blockquote>\n<p>Making a validator its own, data model independent, entity is the first step. Making that mixin-able in a model or a view is the second step. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 9, 2014, at 2:37 AM, Sebastian Porto notifications@github.com wrote:</p>\n<p>I agree, validation should be only in the models, I don't really like the way Angular forces you declare the validation in the form, that is just their workaround because they don't have models. Some people argue that you might want different validations in different contexts, but I don't ever see that need in real apps.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Reusability is greater with validation detachable from the model. </p>\n</blockquote>\n<p>Why are pure view validations are not discoverable? Things in the view tend to be the most discoverable. </p>\n<p>The input, as you somewhat accidentally allude to later (talking about email validation), does factor into the validation. Is something valid while someone is typing, after the input loses focus, or after all fields have been submitted?</p>\n<p>There's a tremendous amount of ways people do validations. The model-based validations simply have not scaled for us. We are seeking ways of having simple model-based validations and view-based validations based on a validation primitive. </p>\n<p>And yes, I'm aware of the great many problems facing making workable validation libraries. Most of the time you present the error as a warning, other times you prevent keyboard input (ex: numeric-only). Error levels are unnecessary if you can easily express what the behavior of being in a error state, or transitioning to or from an error state should be. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 9, 2014, at 2:32 AM, rjgotten notifications@github.com wrote:</p>\n<p>@justinbmeyer</p>\n<p>I'm seconding @gsmeets here:\nAllowing validation a hard link into the view tier is a pandora's box: people will abuse that and application code readability; discoverability and reusability will suffer for it. I've seen it occuring far, far too many times to have any faith left that people can use such a shortcut responsibly.</p>\n<p>You're validating attribute values set on a can.Map, that in this case just so happens to be updated via cross-binding to an <input> element. The actual <input> element does not factor into the actual validation cycle anywhere. Keep it that way, please.</p>\n<p>Also:</p>\n<p>a simple email validation</p>\n<p>Nice that you picked up exactly this example, because it allows me to request an additional validation feature.</p>\n<p>An oversimplified e-mail validator spitting out a hard error and not allowing a user to set a perfectly valid e-mail address is pretty much the poster-child of bad form-entry UX. (You do know that, I hope.)\nThe consensus is that if you perform client-side regex-based e-mail validation, the result should at most be a suggestive warning and never a hard error.</p>\n<p>So; how about adding 'error levels' to validation while we're at it? Explicitly marking hard errors and soft warnings would make it a bit easier to wire up such operations as deciding whether a model is 'error-free' and fit to be processed further. (For instance; when a user is editing a form.)</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Having a regexp was just an example of passing some parameter to some validation function. Don't get hung up on it. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 9, 2014, at 3:16 PM, Andrew Holloway notifications@github.com wrote:</p>\n<p>Agree with @shcarrico . The worst scenario is when someone mis-copies a template regex like this, and introduces subtle, incorrect behavior.</p>\n<p>There are also the form field types in HTML5. Could we use those http://diveintohtml5.info/forms.html#type-email? The new field types would affect the protocol validations mentioned above, and are well-defined, so they could be baked in. Using these types could have several benefits:</p>\n<p>preferring type=\"email\" instead of something like can-validate-format=\"email\" would provide enough information to select the right type of default validator\ntype=\"email\" would trigger the appropriate input keyboard on mobile devices (e.g., include the .com button on the keyboard)\nwould allow for any type of user-specified overrides in addition to a default email validation if necessary.\nOther types of validation could rely on the other standard input field attributes and would be written to \"just work\" when the validation engine is enabled.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. We already have an event when that happens - attributes. No need for another API. </p>\n</blockquote>\n<p>However, live binding will have to call can.view.attr when the attr is added back. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 25, 2014, at 12:37 AM, Brian Moschel notifications@github.com wrote:</p>\n<p>Is this something we want to support?</p>\n<p><div {{#if flag}}can-click='foo'{{/if}}>Click</div></p>\n<p>Right now, if flag gets set to true, then false, the event handler still attempts to run, but throws an error.</p>\n<p>To support this, we'd need an opposite method to can.view.attr like can.view.attrRemoved which is called whenever a certain attribute is removed from the page.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. We should add @index to #key. </p>\n</blockquote>\n<p>Sort should fire a remove and add event for the whole list. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 25, 2014, at 3:23 AM, asavoy notifications@github.com wrote:</p>\n<p>I'm trying to use .comparator and .sort() as described in can.Map.prototype.sort to change the sorting of a can.List that is bound in a Mustache template.</p>\n<p>The can.List gets correctly sorted, but there appear to be a few bugs that prevent the template from reflecting the sorted data correctly.</p>\n<p>Please refer to this JSFiddle:</p>\n<p>Calling list.sort() won't update the rendered template at all.\nBut calling can.trigger(list, 'length') or list.push(newItem) WILL force the update, but only for {{#key}}...{{/key}} syntax. It's not the worst workaround, but I prefer to use {{#each}} because that provides {{@index}}.\nThe {{#each}} syntax will never show list sorted, even after adding items to it.</p>\n<p>(Another weird thing is, in this case, adding an item will render the new item twice.)\nI've added tests that cover all of these issues.</p>\n<p>You can merge this Pull Request by running</p>\n<p>git pull https://github.com/asavoy/canjs bug-binding-sorted-list\nOr view, comment on, or merge it at:</p>\n<p>https://github.com/bitovi/canjs/pull/1114</p>\n<p>Commit Summary</p>\n<p>Added failing tests to show that sorting a list won't cause live-binded elements to reflect the sorted list correctly.\nFile Changes</p>\n<p>M map/sort/sort_test.js (64)\nPatch Links:</p>\n<p>https://github.com/bitovi/canjs/pull/1114.patch\nhttps://github.com/bitovi/canjs/pull/1114.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm not sure what <code>push</code> and <code>unshift</code> should do on a list with a comparator.  It might just add to the end or the start of the list and leave the user to call <code>.sort()</code> again.  The sort plugin might add an <code>add</code> method that would insert (via bisection) items into the sorted list.</p>\n</blockquote>\n<p>The <code>sort</code> plugin really needs an overhaul.  Maybe it's a good time to discuss what a really good sort plugin would look like.\n. Why would list need to support the 'move' event? Shouldn't an add event for the newly added item be enough?\n. There is a deprecation warning on EJS.  We ship it for people who used it in CanJS 1.0.  It is not part of core.\n. Thanks\n. To tabs.\n. The commit should only be changing one or two lines.  Instead, most of the file is changed.<br />\n. Can you make sure indentation is set to tabs?  It also might be the line endings.  I think that there's a way to specify line endings in git.<br />\n. Boo!  This will mean the parser has to count.  No more regexps.\n. Can you give an example?  Helpers are tested to work. Is it possible you are not in an  \"all stache\" situation?  Meaning the component is found in a mustache template, but rendering a stache template.\n. Yep, We have plans for can.connect which adds persistence to can.Map removing can.Model. Let me know if you're interested in working in this. </p>\n<p>I'm not a fan of custom Ajax methods. I like that can.Model provides an interface someone can count on. Plus if you wanted a custom save, you can add that to the prototype currently. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 27, 2014, at 6:45 AM, Alex Osh notifications@github.com wrote:</p>\n<p>I think canjs needs to implement more rubust API for making methods based on ajax request. In such API many things could be defined for ajax like timeouts or event local caching options.</p>\n<p>Maybe then a like API can be used to support other connection protocols (like websokets).</p>\n<p>Sketch of the API:</p>\n<p>var Item = can.Model({\n     // ajax method on class<br />\n     ajax: {\n          find: 'GET /api/items models' //shorthand the same as can.Model.findAll currently\n          search: {\n              url: '/mymodels',\n              type: 'get',\n              // allow custom data creator with context of Model\n              data: function(query){\n                   return query\n              },\n              models: true // means that response should be converted to models\n        },\n    }\n},{\n    //ajax methods on prototype\n    ajax: {\n        customSave: {\n            url: 'PUT /mymodels/{id}',\n            data: function(params){\n                var data = this.serialize()\n                delete data.someProp\n                return data\n            }\n        }\n    }\n})\nInteresting what you think about maybe you have some plans in this directions.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Closing for #1213.  Please add your input!\n. The define plugin does not work on <code>can.List</code>\n. ( this doesn't mean it should not )\n. @imjoshdean what would this look like?\n. @imjoshdean why couldn't that just be a simple function?\n. @imjoshdean somewhat yes, but there's also a need for setters, type conversion, async getters.  It would be weird to call <code>this.attr(\"fullName\", \"Something new\")</code> to write, but <code>this.fullName()</code>to read.  </p>\n</blockquote>\n<p>I think it's likely those things could be used on a list too.\n. yeah, probably.  I am actually thinking more about how define should be used for the items within the list, not the expandos.<br />\n. or <code>*</code> to apply to any item in the list.\n. ``` js\nvar MyList = can.List.extend({\n  define: {\n    idMap: {\n      get: function(){\n        var map = {};\n        return this.each(function(item){\n          map[item.attr(\"id\")] =  item;\n        });\n        return map;\n      }\n    }\n  }\n});</p>\n<p>var list = new MyList([\n  {id: 1, name: \"1\"},\n  {id: 2, name: \"2\"},\n  {id: 3, name: \"3\"}\n]);</p>\n<p>console.log(list.attr(\"idMap\"));</p>\n<p>list.bind(\"idMap\", function(){\n  console.log(\"changed\");\n});</p>\n<p>list.pop();\n```</p>\n<p>this should certainly work.\n. Does stache work?</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jun 30, 2014, at 6:39 AM, rjgotten notifications@github.com wrote:</p>\n<p>I think CanJS might want to consider including this workaround into the framework \n+1</p>\n<p>I'm currently using my own workaround for the cited <img src=\"...\"> case but had just about given up on SVG.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Did you create an issue?  I thought I remembered seeing it.  I don't think we'll target SVG for mustache.\n. Closing, please open an issue for stache if needed.\n. The test actually passes without the change the first time, until the hash has been updated.</p>\n</blockquote>\n<p>I'm not sure what this is actually trying to test.  Can you explain a bit more?</p>\n<p>The existing check of: <code>!twoWayBindings[camelized]</code> should prevent what you are talking about without any extra work.\n. The test needs to be async to pick up the behavior.  I understand the issue now.\n. What would this look like?  Please propose an API. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jul 1, 2014, at 1:08 AM, Jonathan Gros-Dubois notifications@github.com wrote:</p>\n<p>I'm working on a relatively complex 'single page' app which implement its own client-side page switching (with transitions).</p>\n<p>I researched can.route and the pushstate plugin but I wasn't able to find a way to use can.route to change the hash part of the URL without affecting the history.\nConsider the following scenario:</p>\n<p>A user is on a page and they click a button and that button causes part (but not all) of the page's content to be updated with new data. They might click through many such buttons. Now if they press the back button, I want to take them back to the previous 'proper' page - Not the previous app state (there might be a LOT of such states not related to page changes and it would be tedious to make them click back 50 times to get to the actual 'previous page'). When they click on a button, I still need to update the URL in case they want to bookmark the app's state or share it with someone else.</p>\n<p>I had to add some workaround code that made use of history.replaceState() to get this behaviour working - It would be great if there had been an option you could set when calling can.route() which would let you not save that particular route to history (but otherwise should behave the same).</p>\n<p>Maybe this already exists but I wasn't able to find any documentation.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. In keeping with how can.route is supposed to work, having a different <code>.attr()</code> signature might not be the best idea (although it would work).</p>\n</blockquote>\n<p><code>can.route</code> is designed to behave just like a normal can.Map, but have a side effect of updating the url.  A widget should be largely ignorant if it is using can.route or another can.Map.</p>\n<p>It seems to me that \"some\" changes you'd want to have the history change and others not.  Maybe it's possible to signal this some other way.</p>\n<p>I'm not proposing this API, but just to show you what I mean:</p>\n<p><code>js\ncan.route.ignoreHistoryOn(\"contentId\",\"visible\",\"login\");</code></p>\n<p>This would use replaceState if those attributes changed.</p>\n<p>Any thoughts on this?\n. Can you add a test for this?\n. @imjoshdean ?\n. In stache?  afaik, stache never puts placeholders.\n. I don't think that is loading can.stache as the plugin is not included.  It's probably rendering with Mustache.\n. stache example http://jsfiddle.net/qYdwR/1679/\n. Yeah, it's a bug.\n. Ok, so this is a problem b/c the knowledge that the inner read (<code>{{obj.val}}</code>) is within the outer section (<code>{{#obj.val}}</code>) is lost b/c this arrangement happens in render.  It needs to happen in scanner.</p>\n<p>However, this will be tricky.  Have you tried upgrading to stache?<br />\n. Closing b/c we aren't going to try to fix this as this is fixed in stache.  Here's the test I wrote:</p>\n<p>```\ntest(\"live binding attributes with input value (#1142)\", function(){</p>\n<pre><code>var map = new can.Map({\n    counter: {test: 0}\n});\nvar template = can.stache('&lt;input type=\"text\" {{#counter.test}}value=\"{{counter.test}}\"{{/counter.test}}&gt;');\nvar input = template(map).firstChild;\n\nequal(input.value, \"\", \"no value\");\n\nmap.attr(\"counter\").attr(\"test\",1);\n\nequal(input.value, \"1\", \"no value\");\n</code></pre>\n<p>});\n```\n. @cherifGsoul what do you mean by dependencies? Also, for benchmarking, what do you mean?</p>\n<p>@retro I think we should also add showing a compute's dependent values.  For instance a fullName compute would show <code>map</code> \"first\" and  <code>map</code> \"last\".\n. I up voted this here: http://bithub.com/event/41421\n. awesome.  This will be merged soon.\n. I changed the test to avoid comparing innerHTML.  IE capitalizes everything.\n. And the real problem is single character attributes right?\n. Probably a duplicate of #1142 \n. @asavoy can you share what's breaking for you?  I'm unable to recreate this issue.  My attempt looked like:</p>\n<p>``` js\n        var map = new can.Map({state: \"pending\"});\n        var source = can.compute(1)\n        var number = can.compute(function(){\n          map.attr(\"state\", \"resolved\");\n          return source();\n        });</p>\n<pre><code>    var template = can.stache(\"{{#map}}&lt;div&gt;{{#if state}}{{number}}{{/if}}&lt;/div&gt;{{/map}}\")\n\n    var frag = template({\n        number: number,\n        map: map\n    });\n    source(2);\n\n    ok(true);\n</code></pre>\n<p>```\n. Actually, I found it.\n. That seems fine to me. @andykant ?  I would check mustache / Handlebars for any existing conventions.</p>\n<p>Added this to the 2.2 milestone.\n. There isn't a synchronous version of this in the new steal.  The async version is System.normalize.\n. &gt; What is the equivalent of steal.id in the new Steal</p>\n<p><code>system.normalize</code> - https://github.com/bitovi/legacy-steal/blob/master/steal.js#L2326</p>\n<p>This will probably be hard to fix in \"synchronous\" <code>can.view</code> calls.</p>\n<p>I think for now, we can just normalize relative to the current file (using joinURL (or whatever its called) ) and to the baseUrl. \n. (basically, no map or paths config will work)\n. Make sure you import your modules that define your custom attrs. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jul 25, 2015, at 1:38 PM, Marshall Thompson notifications@github.com wrote:</p>\n<p>Is this what's keeping my can.view.attrs from working in partials? They work in the built production site, but not in development mode.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Your partials are importing them?</p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jul 25, 2015, at 11:46 PM, Marshall Thompson notifications@github.com wrote:</p>\n<p>I am importing them with <can-import> and they work in the main template\nbut not in the partials.\nOn Sat, Jul 25, 2015 at 2:05 PM Justin Meyer notifications@github.com\nwrote:</p>\n<blockquote>\n<p>Make sure you import your modules that define your custom attrs.</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jul 25, 2015, at 1:38 PM, Marshall Thompson notifications@github.com\nwrote:</p>\n<p>Is this what's keeping my can.view.attrs from working in partials? They\nwork in the built production site, but not in development mode.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.</p>\n</blockquote>\n<p>\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bitovi/canjs/issues/1159#issuecomment-124882339.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Your fiddle doesn't use the define plugin. Did you share the right one?\n. This is how you can do it: http://jsfiddle.net/xKc3H/421/\n. I'm not sure about this.  Does the parser behave differently if a is considered block or inline?  Could this break other behaviors?  For example, I think something like </p>\n</blockquote>\n</blockquote>\n<p><code>html\n&lt;td&gt;Cell 1&lt;a&gt;Foo\n&lt;td&gt;Cell 2\n&lt;td&gt;</code></p>\n<p>might break?\n. @isadovskiy yeah, that first fiddle should work.  I'm guessing it does in older versions?  I think 2.2 has a bug around leaking (not in terms of memory) <code>can.__read</code> calls.\n. Here's a smaller version of the first example: http://jsfiddle.net/jd44f/9/\n. What do you expect to happen? Clone?\n. @jawshooah, it might be better to clone.  I think not returning a <code>new</code> instance when <code>new</code> is called would be confusing.  Plus, I'm not sure that this can easily be made to happen with can.Construct.\n. @sporto I'm not sure the define plugin feels awkward.  It's much nicer for a user to write:</p>\n<p><code>&lt;client-list clients=\"{clients}\" selectable=\"true\"&gt;</code></p>\n<p>Instead of <code>=\"{true}\"</code>, I would encourage people to use the define plugin.</p>\n<p>However, I think it's not bad to have. \n. For convention, I would expect people to write components that take: <code>activated=\"true\"</code> and convert that too a boolean if activate itself is a boolean.  It's how we write our components.</p>\n<p>I agree the conventions are important. \n. Alternatively, we could add support for attributes that act like the DOM's binary attributes.  For instance:</p>\n<p><code>html\n&lt;x-tag {{#if selected}}checked{{/if}}&gt;</code></p>\n<p>We could make it so \"checked\" is <code>false</code> unless an attribute exists and is <code>true</code>.  There's not a great way of doing this currently.\n. <code>js\ndefine: {\n  checked: {\n    set: function(){\n      return true;\n    },\n    remove: function(){\n      // there's no way to leave false as the value instead of removing the attribute AFAIK\n    }\n  }\n}</code>\n. What do you mean by local / remote servers?  </p>\n<p>Is your server sending back the id of the newly created model?</p>\n<p>Are you calling <code>.save()</code> before the server has sent back the id?  If so, you should use the queue plugin.</p>\n<p>I'm closing b/c this is likely not an issue with CanJS, just how it's being used.  I'll re-open if a bug is found.\n. Yes. Queue fixes it. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jul 30, 2014, at 2:40 PM, Ricardo Obreg\u00f3n notifications@github.com wrote:</p>\n<p>Yes, the server is returning the id.\nI'll try queue plugin...\nThis \"error\" happened to me because I accidentally clicked a button twice (which executed todo.save()) and since the first request wasn't finished yet, then the model was created twice. So, the easy way to reproduce was the code I showed above.\nSo my question is: is this an expected behavior?\nThanks again.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. What browser are you using?  How is it running locally?\n. Thanks for posting.  Anyway you can make that fiddle a bit more simple?  I wasn't able at a glance to identify the problem.  Removing a few divs would help.  Thanks!\n. Not without breaking people's apps who rely on the behavior or adding more complex parsing rules. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 14, 2015, at 3:53 PM, Chris Gomez notifications@github.com wrote:</p>\n<p>@daffl Can we fix this in 2.3? It's a very common \"gotcha\" for new CanJS devs. Related: #1775</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Because people write markup like <li> without a closing tag pretty commonly. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 15, 2015, at 10:21 AM, savinger notifications@github.com wrote:</p>\n<p>Why would they rely on canjs to output markup different than what they declared?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. &gt; The way I see it, if we're going to aggravate one of the two types of users, I'd rather it be the experienced CanJS developer that decided to update and read the release notes.</p>\n</blockquote>\n<p>I'd rather not break promises (SEMVER).  That aggravates everyone. So we can't change this until 3.0.  But yes, we can make it opt-in configurable before then.<br />\n. Before doing this, we should get some measurement that it is worth it.  Given 10 templates, how much time is spent parsing vs inside the callbacks like https://github.com/bitovi/canjs/blob/master/view/stache/stache.js#L106.  It might not help very much and we would have to go to a \"deeper\" representation of stache templates.\n. Can you remind me what you mean by  \"slower performance\"?\n. It's jQuery's status I think.  Good find!\n. So, I'm a bit wary of mixin behavior like this in general.  Are you using some type of module system?  If so, it's easy to have a module like:</p>\n<p><code>js\n//types.js\nexport default {\n  currency: function(){ ... },\n  color: function(){ ... }\n}</code></p>\n<p>And use it like</p>\n<p>``` js\nimport types from \"types\"\nimport can from \"can/\"</p>\n<p>export default can.Map.extend({\n  define: {\n    revenue: {type: type.currency},\n    inTheBlack: {type: type.color}\n  }\n})\n```</p>\n<p>This has advantages in that your types are explicitly loaded and specified.  If you could add your own converters, its possible:\n- a module that uses them forgets to import them\n- someone wants a different \"currency\" type and overwrites it</p>\n<p>But in the end, I'm not opposed to people doing things their way.  How would you like to specify your own custom types?  (It should be called types, not converters.  Converters is a hold over from the attributes plugin).  I wonder if types should be made available outside just can.Map.  I think angular has some concept of \"coverters\" / \"types\".  cc @alexisabril \n. &gt; I think it's much more cleaner and clearer for our developers when the primitive-like types are all handled the same way. </p>\n<p>Agreed, but this might be an argument to remove our string serializers instead of allowing people to add their own. I tend to value correctness over consistency. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Aug 9, 2014, at 5:08 PM, Guido Smeets notifications@github.com wrote:</p>\n<p>I think it's much more cleaner and clearer for our developers when the primitive-like types are all handled the same wa\n. This looks like a good problem to solve, but it seems travis is breaking on the fix.\n. @ericcarino </p>\n</blockquote>\n<p>Why are you setting a compute as a property value?<br />\n. This is very likely a duplicate of another issue.\n. #326 #1031 #179 are all related.  We should update #179 to better reflect our architecture and close this.\n. Closing for #179.\n. Awesome!\n. #646 has suggestions on doing 3.1.  </p>\n<p>``` js\ncan.Component.extend({\n tag: \"window-manager\",\n template: \"<h1>{{title}}</h1><content/>\"\n})</p>\n<p>can.Component.extend({\n tag: \"name-editor\",\n template: \"<input can-value='first'/> <input can-value='last'/>\",\n links: {\n   \"window-manager title\" : function(){\n     return \"Edit \"+this.attr(\"first\")+\" \"+this.attr(\"last\")\n   }\n }\n})</p>\n<p>var template = can.stache(\"<window-manager><name-editor></name-editor></window-manager>\")\ntemplate( new can.Map({first: \"Justin\", last: \"Meyer\"}) )\n```</p>\n<p>To do this in CanJS 2.1, you would have to:</p>\n<p>``` js\ncan.Component.extend({\n tag: \"window-manager\",\n template: \"<h1>{{title}}</h1><content/>\"\n})</p>\n<p>can.Component.extend({\n tag: \"name-editor\",\n template: \"<input can-value='first'/> <input can-value='last'/>\",\n scope: {\n  define: {\n    title: {\n      get: function(){\n        return \"Edit \"+this.attr(\"first\")+\" \"+this.attr(\"last\")\n      }\n    }\n  }\n }\n})</p>\n<p>var template = can.stache(\"<window-manager><name-editor title='{title}'></name-editor></window-manager>\")\ntemplate( new can.Map({first: \"Justin\", last: \"Meyer\"}) )\n```</p>\n<p>This 2.1 code is nice because <code>title</code> is unit testable.  However, it still feels a little \"off\".</p>\n<p>@gsmeets Any suggestions for a replacement for <code>links</code>?\n. As discussed with @sporto, most problems can be solved by the child component, on inserted, adding its scope to the parent scope and possibly adding the parent scope to its scope. ( @sporto please let me know if there's a case this doesn't solve ).</p>\n<p>This looks like:</p>\n<p><code>js\n// in child component\ninserted: function(el){\n  var childScope = el.scope()\n  var parentScope = el.parent.scope();\n  parentScope.attr(\"child\", childScope);\n  childScope.attr(\"parent\", parentScope);\n}</code></p>\n<p>This allows one to accomplish all core use cases.  </p>\n<h3>2 Parent to Child</h3>\n<p><code>// parent\nscope: {\n  doSomething: function(){\n    this.attr(\"child\").doSomething();\n  }\n}</code></p>\n<h3>3 Child to Parent</h3>\n<p><code>js\n// child\nscope: {\n  doSomething: function(){\n    this.attr(\"parent\").doSomething();\n  }\n}</code></p>\n<h3>4 Siblings or All Children</h3>\n<p>If there are multiple children or siblings, one push into an array structure.  </p>\n<p><code>js\n// in child component\ninserted: function(el){\n  var childScope = el.scope()\n  var parentScope = el.parent.scope();\n  parentScope.attr(\"childen\").push(childScope);\n  childScope.attr(\"parent\", parentScope);\n}</code></p>\n<h2>Cost / Benefit</h2>\n<h3>Benefits</h3>\n<ul>\n<li>[x] - This works. @sporto let me know if there is a case where this doesn't.</li>\n<li>[x] - This is unit testable without the DOM.  You can create the View Model's independently and arrange them similar to how the DOM would be arranged:</li>\n</ul>\n<p>``` js\nvar childScope = new ChildScope();\nvar parentScope = new ParentScope();\n  parentScope.attr(\"child\", childScope);\n  childScope.attr(\"parent\", parentScope);</p>\n<p>```</p>\n<h3>Costs</h3>\n<ul>\n<li>[ ] - This is not easy for people to figure out.</li>\n<li>[x] - One has to probably teardown the relationship when <code>removed</code> events happen. </li>\n<li>[ ] - There's a lot to write for a common use case.</li>\n</ul>\n<h2>Suggestions</h2>\n<p>There are two suggestions I have:</p>\n<h3>Suggestion 1: \"element\" becomes part of the view model.</h3>\n<p>If element was added to the view model, one could easily walk the DOM structure themselves:</p>\n<p><strong>_3 Child to Parent</strong>_</p>\n<p><code>js\n// child\nscope: {\n  doSomething: function(){\n    this.attr(\"element\").parent().scope().doSomething();\n  }\n}</code></p>\n<p>This is easy to understand, but not easy to test.  One would need the DOM in place to call doSomething.</p>\n<h3>Suggestion 2: Dependency Injection</h3>\n<p>Give scope's a method(s) that by default can get sibling / parent / children view-models that can be injected for testing:</p>\n<p><code>js\n// child\nscope: {\n  doSomething: function(){\n    this.get(\"parent\").doSomething();\n  }\n}</code></p>\n<p>In the DOM, \"parent\" would, by default, map to the parent element's scope.</p>\n<p>While testing:</p>\n<p><code>js\nvar childScope = new ChildScope();\nvar parentScope = new ParentScope();\nchildScope.give(\"parent\", parentScope);</code></p>\n<p>This syntax still has much to be worked out, but would be easier to understand than setting up relationships oneself while still being unit testable.</p>\n<p>Thoughts?\n. What you suggest has the same amount of tight coupling. The parent knowing the tag/element is the same as knowing the scope attribute. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 9, 2014, at 2:07 AM, Sebastian Porto notifications@github.com wrote:</p>\n<p>@justinbmeyer this method of assigning an attribute on the parent e.g. parentScope.attr(\"child\", childScope); seem to cover a lot of the cases. But I cannot say is elegant, the issues I have with this are:</p>\n<p>Several children components could try to assign the same property e.g. child\nthe solution to this above would be to always use children, but then the component needs to assume that there is a children array on the parent\nthe parent component needs to know what the child component will set e.g. child or children\nI see tight coupling on this solution, personally I prefer not to go this way.</p>\n<p>For me the way to avoid coupling is:</p>\n<p>When passing messages down: the parent component already knows the tag for a child component, so it could call a method on the DOM element or get the scope of the DOM element and call a method on it.</p>\n<p>When passing messages up, either using events or callbacks.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. ah, this is why I was hinting at a dependency injection of method results like .find, .children, .parent, etc. A scope could request this.find(\"child-component\") and we would return the child-component element's scope. I'm not sure how someone could inject this value for testing. Maybe it's as simple as parentScope.find('child-component',childScope). </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 9, 2014, at 2:53 AM, Sebastian Porto notifications@github.com wrote:</p>\n<p>@justinbmeyer I think you are considering just the scope, I am thinking about the whole component, so the whole component has a template, the tag element is right there, is obvious.</p>\n<p>For example in:</p>\n<p>can.Component.extend({\n     tag: \"my-element\",\n     scope: {</p>\n<p><code>},\n  template: \"&lt;div&gt;\"+\n     '&lt;child-component /&gt;'\n    \"&lt;/div&gt;\",</code></p>\n<p>})\nI know I have access to child-component and can do things with it.</p>\n<p>On the other hand the scope attribute is nowhere to be found on the parent component definition. It is in the child component definition. In order to know that a property child exists I will need to go digging in the child definition component.</p>\n<p>You could say the same thing about methods in the child component, but this are the external API, so I think it is not the same.</p>\n<p>Maybe what is need is a way to tell the child component what property to set:</p>\n<p>can.Component.extend({\n     tag: \"my-element\",\n     scope: {\n        doSomething: function () {\n            child1.foo();\n        }\n     },\n      template: \"<div>\"+\n         '<child-component ref='child1' />'\n        \"</div>\",\n })\nThen I will know that I can talk to the child component using child1</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Add it.  Eventually, we need our templates able to declare dependencies.   But for now, it's expected that a template will probably have this as a dependency.\n. Related: #1126\n. The goal of this is to maintain can.Model's API.  </p>\n</blockquote>\n<p>@daffl I'm not sure what you are showing or what you mean by \"services\".  There's unlikely anything better than a \"mixin\" for decoupling the mixin's themselves.</p>\n<p>In your example, userService would still be coupled to \"Person\".<br />\n. I've not started showing how these would be implemented. The first step is to identify common use cases and then see what implementing them might be like. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Aug 25, 2014, at 8:45 PM, Matthew Phillips notifications@github.com wrote:</p>\n<p>What is the API that a connector is implementing here? I want to write a custom connector that connects to indexeddb or some other storage backend that probably won't be in core. How would I do that here?</p>\n<p>Also, you can connect multiple backends it seems, so how does it determine which gets called?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. findOne can do this</p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jan 15, 2015, at 6:01 PM, Alex notifications@github.com wrote:</p>\n<p>Is there any progress for this issue? BTW wy can.Model doesn't have default method like sync that would request server new data for partucular instance and merge it with existing data on the client?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Read it when it was first released. can.Map will still be around for the foreseeable future. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 12, 2014, at 6:14 AM, rjgotten notifications@github.com wrote:</p>\n<p>While dirty checking enables you to write directly against raw objects even for browsers that don't support Object.observe, it is a major, major resource hog.</p>\n<p>I'd encourage you to read the Change Detection document describing how change detection is going to be refactored in AngularJS 2.0 just to come to grips with the expense and the effort involved in trying to keep a handle on the performance.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Instead of returning a can.Map or a can.List and trying to keep them up to date (expensive), I think this should just return a \"shim\" object with a bind method like</p>\n</blockquote>\n<p><code>js\nvar listLike = can.observe([\"a\",1]);\nlistLike.bind(\"add\", function(ev, added, index){})</code></p>\n<p>Q: What to do if someone listens to change?\n. Here's a rough implementation: https://github.com/bitovi/canjsmeetup/blob/master/7_route/can.app.js\n. @cherifGsoul I'm not sure what you mean.  Please elaborate.  </p>\n<p>We create script elements for progressive loading.  Component might not be loaded into the page.<br />\n. I'm still not sure what you mean. Please break down more. Can you give an example?</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Aug 27, 2014, at 3:59 PM, Mohamed Cherif Bouchelaghem notifications@github.com wrote:</p>\n<p>Sorry for my limited english, what I mean is components files can be loaded all at once because there's no component instantiation if it's template is not present, what is the goal of the progressive loading in this case?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. What do you mean by \"treats\"?</p>\n</blockquote>\n<p>Components, like other modules, can be progressively loaded in larger apps. Say I went from /contacts to /admin. I might want to load the admin component when that happens. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Aug 28, 2014, at 9:42 AM, Mohamed Cherif Bouchelaghem notifications@github.com wrote:</p>\n<p>Im talking about the import part because IMO components dont need progressive loading, maybe im wrong because it treats components and other modules loading, I have a little idea that will be shared soon.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. I get a 404 when I click on your jsbin.   I'm still not sure what you are trying to say.  If the component's definition is already loaded, yes, progressive loading is not important.  But I want to enable apps where this is not the case.\n. It would also be nice to have some of this behavior possible via HTML only:</p>\n</blockquote>\n<p><code>html\n&lt;can-route pattern=\":page\" page=\"home\"/&gt;\n&lt;can-route pattern=\"contacts/:id\" page=\"contacts\"/&gt;\n&lt;my-app&gt;\n  &lt;navigation/&gt;\n  {{#switch can.route.page}}\n    {{case \"home\"}}\n       &lt;h1&gt;Welcome {{name}}&lt;/h1&gt;\n    {{case \"contacts\"}}\n       &lt;contacts page='{can.route.contactPage}'\n                     can-animate-removed=\"fadeOut\" \n                     can-animate-inserted=\"fadeIn\"&gt;&lt;/contacts&gt;\n    {{case \"contact\"}}\n      &lt;contact contact-id='{contactId}' \n                     can-animate-removed=\"fadeOut\" \n                     can-animate-inserted=\"fadeIn\"&gt;&lt;/contacts&gt;\n  {{/switch}}\n&lt;/my-app&gt;</code></p>\n<p>Things that would have to work:\n- [ ] - a switch statement that would integrate with the animations to remove an element before inserting it\n- [ ] - dynamic importing of a component\n. ```\n<can-route route=\":page\" page=\"todos\">\n   <todos-app></p>\n<p></todos-app>\n</can-route>\n```\n. @cherifGsoul Please remind me to get back to you next week.  Busy time for me.  Thanks!</p>\n<p>@stevenvachon It makes this functionality route-based, but the existing functionality will still be present.\n. while I think we need to do something here, this is mostly solved by donejs.. I'm not sure what you mean.\n. It should make use of the same mustache-helper parsing logic.  But that logic needs to be made more easily available to view bindings.\n. <code>can-EVENT</code> will be the same if you don't specify arguments.  </p>\n<p><code>key1</code> and <code>key2</code> represent a key in the scope.  http://canjs.com/docs/can.mustache.key.html \n. only 2.1.3?  What about 2.1.2?  Did you verify this?\n. @matthewp Can you update #1204 with <code>can.global</code> and merge to minor?\n. Yep, this is why we are transitioning to the new stealjs/SystemJS. Browserify can't do progressive loads easily. So it's less than ideal for big/complex projects. </p>\n<p>However, we can probably add cjs support for the 2.2 release </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 1, 2014, at 11:34 AM, Steven Vachon notifications@github.com wrote:</p>\n<p>If ES6 modules make their way into all modern browsers, browserify's usefulness\u2014outside of bringing existing Node modules to the browser\u2014will dissipate.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. CanJS will export AMD / CJS / ES6 / Steal and global formats.  No need to argue about what's better or worse ....\n. A static compute isn't a supported type of compute on a can.Map.  Only computes that take a function.  Also, the define plugin has replaced needing computes on the prototype of a can.map.</p>\n</blockquote>\n<p>Although we could make this work, it's not going to be high priority b/c there are better ways of doing this.</p>\n<p>Why are you doing <code>can.compute(false)</code> to begin with?\n. You can avoid this like:</p>\n<p><code>js\nmemberOf: {type: function(items){ return new Team.List(items) }}</code></p>\n<p>I don't want to allow something like: <code>\"User.model\"</code> because it encourages global identifiers.<br />\n. If the data is observable, a compute is passed.  This is so \"advanced\" mustache helpers can be created (like ones that setup their own two-way binding).  </p>\n<p>There's been a proposed \"registerSimpleHelper\" which would always give the values, never the computes.</p>\n<p>Closing b/c we aren't going to change this behavior, but we will make some other function to make simple helpers easier.\n. Send a tweet to @steeleprice https://twitter.com/steeleprice\n. Closing this b/c this is not an issue (yet).  If you have a more specific proposal, feel free to write more and discuss here.  Open it if there's something the core team needs to do.\n. @daffl or @stevenvachon can you clean up the issue?  so people know what the problem is on first glance.\n. Closed by #1696.\n. It would run much slower than phantom. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 16, 2014, at 10:11 AM, Steven Vachon notifications@github.com wrote:</p>\n<p>It's free for open source projects. This is not mentioned on their website anywhere. Proof: https://twitter.com/browserstack/status/510712861014753280</p>\n<p>Only condition is that you mention them on the GitHub page and website.</p>\n<p>This would alleviate the need for PhantomJS, SlimerJS, Karma or your own Silenium network.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. closing for #192\n. &gt; but it's not ES5-like.</p>\n</blockquote>\n<p>imo, that's not a reason for adding <code>every</code> when each does both .forEach and adds the exit behavior of .every.  And, imo, the utility of <code>every</code> is more about its return value being true or false, not for looping.\n. Yes, this is what I meant about it returning true or false. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 16, 2014, at 9:51 PM, Steven Vachon notifications@github.com wrote:</p>\n<p>I use it for returning Booleans as well.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. We don't have all es5 methods, just the most common ones. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 17, 2014, at 7:34 AM, Steven Vachon notifications@github.com wrote:</p>\n<p>I know, I'm just saying that I use every for that purpose as well. Being an ES5 function, I'd think that it might belong in core, whereas the underscore methods could be a plugin?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. forEach / each which returns the list is used a lot for chaining.  I find it much more useful than every.\n. good point ... even more reason to use each which provides the useful parts of every while returning the whole list.\n. Don't use <code>{{#each list}}</code>, just use <code>{{#list}}</code>\n. {{#list}} is a mustache spec.  I'm not sure if it provides @index.  It can be made to.</p>\n</blockquote>\n<p><code>{{#each}}</code> is a special helper linked to <code>can.view.live.list</code> which only is intended to keep DOM iteratively \"live\".  An attribute (with the exception of class lists) can not be kept iteratively live, there is only a single value.  This is in contrast to keeping a bunch of <code>&lt;li&gt;</code> live.  We can remove or add a single <code>&lt;li&gt;</code> at a time.</p>\n<p>We can (and probably should) make <code>{{#each list}}</code> work, but we will do it by simply calling back to <code>{{#list}}</code> anyway.\n. Closing for: https://github.com/canjs/can-stache/issues/8\n. Closing for: https://github.com/canjs/can-stache/issues/8\n. Stache?</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 20, 2014, at 3:12 PM, Steven Vachon notifications@github.com wrote:</p>\n<p><th {{#if ascending}}class=\"sort-{{#if ascending}}ascend{{else}}descend{{/if}}\"{{/if}}>\n    this will not render at all\n</th>\n<th class=\"sort-{{#if ascending}}ascend{{else}}descend{{/if}}\">\n    this renders\n</th>\n\u2014\nReply to this email directly or view it on GitHub.\n. Closing for the issue in can-stache\n. In 3.0 here's the binding setup on our observables:\n- <code>addEventListener</code> and <code>removeEventListener</code> - methods that any observable must implement to work with computes.\n- <code>on</code> and <code>off</code> - short hand for <code>addEventListener</code> and <code>removeEventListener</code>.<br />\n- <code>listenTo</code> and <code>stopListening</code> - registered event listeners.\n- dispatch - dispatch an event on the listener.\n- batch.dispatch - dispatch a batched event. \n. Couldn't this be done in the Component's viewModel's <code>init</code>?  There it would be called prior to the rendering:</p>\n</blockquote>\n<p>```\nvar VM = can.Map.extend({\n  init: function() {\n     // code\n  }\n})</p>\n<p>can.Component.extend({\n  viewModel: VM\n})\n```</p>\n<p>Closing b/c I think this will work.  Re-open if there's still an issue.\n. Can you do</p>\n<p>```\nHandlebars = {\n  registerHelper: (name, helper){\n    stache.registerHelper(name, <br />\n        function(){ \n            var args = // computes to value, leave everything else\n            // convert computes on hash\n            return helper.apply(this, args)</p>\n<pre><code>    })\n</code></pre>\n<p>}\n}\n```</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Oct 3, 2014, at 8:34 AM, isadovskiy notifications@github.com wrote:</p>\n<p>At the moment CanJS implementation of the stache/mustache API is different from the original Handlebars API (http://handlebarsjs.com/reference.html). It would be great to have original Handlebars API support (at least as a plugin). It will allow to use 3-rd party Handlebars plugins (like https://github.com/shannonmoeller/handlebars-layouts) with CanJS templates.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. There is already an issue for creating a registerSimpleHelper that would do the same thing. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Oct 3, 2014, at 9:51 AM, isadovskiy notifications@github.com wrote:</p>\n<p>Sure, it's not a problem to have such kind of wrapper.</p>\n<p>The reason I created this topic is just to track it as a feature request and possible location of the future pull requests.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. I dislike <code>Handlebars.create</code>.  CanJS has a much more elegant and appropriate pattern of allowing you to pass local helpers and partials to template.  This is much faster as a template does not require duplicated parsing.  And Stache itself doesn't need to be rebuilt.</p>\n</blockquote>\n<p>However, it can be simulated like:</p>\n<p>``` js\nvar makeHandlebars = function(viewEngine){\n  var helpers = {};\n  var partials = {};\n  return {\n    compile: function(template){\n       var renderer = viewEngine(template);\n       return function(data){\n         return renderer(data,{helpers: helpers, partials: partials})\n       }\n    },\n    registerHelper: (name, helper){\n        helpers[name] = function(){\n          var args = // computes to value, leave everything else\n          // convert computes on hash\n          return helper.apply(this, args)\n       }\n      }\n   },\n   create: function(){\n     return makeHandlebars();\n   }\n}</p>\n<p>var Handlebars = makeHandlebars(can.stache);\n```</p>\n<p>Would you be interested in making this as a 3rd party plugin?  This is low on our list of things to do and unlikely to get done for a long time.</p>\n<p>When we did our roadmap planning, the \"array helpers\" issue wasn't even supported and that's something many, many people have asked for.  </p>\n<p>If you have the inclination, create it as a plugin, we will promote it.  I can even help guide you through the implementation more.</p>\n<p>For now, I'm closing.  If this is upvoted a lot on bithub, we will reconsider.  (I will post the link to the issue on bithub shortly)\n. @pYr0x it's not documented.  I'm not sure if it will be.  Currently it's for internal use only.  It's a bit faster then <code>can.compute</code>, but not enough to make it worth it for everyone to use.<br />\n. It's probably a bug.  Can you create a fiddle demonstrating?\n. What are you trying to get working specifically?  Can you create a fiddle or show a specific example that is breaking.  </p>\n<p>Closing for now until there is enough information.\n. What examples and documentation is missing?  The documentation is here:</p>\n<p>http://canjs.com/docs/index.html</p>\n<p>Closing.  Please provide more details\n. You should create a default route like: can.route(\":page/:subpage\").</p>\n<p>If you have any further questions, please ask them on stack overflow.  Make sure you tag them with CanJS so we are notified.\n. The fix is to make can.Map treat can.Constructs on the prototype as defaults instead of methods.\n. This behavior happens around here: https://github.com/bitovi/canjs/blob/master/map/map.js#L62\n. Done in 3.0.\n. I'm being lazy, but what is the specific problem in the fiddle?  How can I see it breaking?  Thanks!\n. I don't think an option's value can be undefined, but it could be \"\".\n. Closing for issue in <code>can-stache</code>\n. no worries.  I think it might be working now except for the empty problem.\n. You can use can.view to load a template within a script tag. Or you can submit a pull request with test that does this. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Oct 9, 2014, at 6:35 AM, Guido Smeets notifications@github.com wrote:</p>\n<p>I've run into an interesting problem.</p>\n<p>I set classes on a can.Component's element inside the init event. This works perfectly fine until the component resides in a helper, i.e.:</p>\n<p>{{#if true}}<my-component />{{/}}\nI've done some testing, and it only happens when I use can.view(). If I manually render a template with can.mustache() everything runs as expected.</p>\n<p>If I disable the setting of the classes everything works fine too. Setting a style on the component has the same behaviour.</p>\n<p>I can't really put up a fiddle anywhere, unless someone shows me how I can hook up can.view to get a view asynchronously in jsfiddle.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. It might be difficult to solve this without using <code>try/catch</code>.<br />\n. Seems like stache handles this fine: http://jsbin.com/pofefu/edit?html,js,console,output\n. I'm not sure exactly what example you are looking for.  But generally speaking, you can make anything into a reusable component.  If you still have this question, please ask on the forums: http://forums.donejs.com/c/canjs\n. Namespaced events aren't supported.  We dropped using jQuery's event system because it was so slow.  In general, you shouldn't need to bind to things directly, instead using a component's \"events\" object.  If this is still needed in a modern CanJS application, please give an example and I'll reopen.  Thanks!\n. It is needed for Firefox. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Oct 23, 2014, at 2:42 PM, Chris Gomez notifications@github.com wrote:</p>\n<p>The define plugin's test page was throwing errors:</p>\n<p>@daffl Pointed out that the outer setTimeout shouldn't be there. Removing it got rid of the error.</p>\n<p>You can merge this Pull Request by running</p>\n<p>git pull https://github.com/akagomez/canjs fix-define-tests\nOr view, comment on, or merge it at:</p>\n<p>https://github.com/bitovi/canjs/pull/1285</p>\n<p>Commit Summary</p>\n<p>Remove outer setTimeout\nFile Changes</p>\n<p>M map/define/test.html (3)\nPatch Links:</p>\n<p>https://github.com/bitovi/canjs/pull/1285.patch\nhttps://github.com/bitovi/canjs/pull/1285.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. Interesting.  It would break one of every 5-10 tries in FF without this.</p>\n</blockquote>\n<p>Justin Meyer\n847-924-6039</p>\n<p>On Mon, Oct 27, 2014 at 3:25 PM, David Luecke notifications@github.com\nwrote:</p>\n<blockquote>\n<p>This works fine for me in Firefox (32) without the setTimeout and fixes\nevery other browser (where it is currently breaking).</p>\n<p>\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bitovi/canjs/pull/1285#issuecomment-60662993.\n. I am using browserify too and just noticed this problem.  I think the correct solution would be to check for <code>can.$.fn</code>\n. I mean <code>if(can.$.fn) { can.$.fn = function{ ... } }</code></p>\n</blockquote>\n<p>But people can use <code>$().scope()</code>\n. Basically, we shouldn't be checking for jQuery.  If can.$ is an interface to the underlying library's nodeList.  Perhaps can.$.fn should be its interface to adding additional methods to it.\n. This is how handlebars works. Also each iterating through keys or through indexes depending if the argument is list-like is very common. Both jQuery and underscore do this. </p>\n<p>So we are unlikely to change it. However if you like that style you can easily make an eachkey helper </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Oct 28, 2014, at 6:43 AM, Joseph Le Brech notifications@github.com wrote:</p>\n<p>In the docs the following lists the properties in an object:</p>\n<p><ul>\n  {{#each person}}\n    <li> {{@key}}: {{.}} </li>\n  {{/each}}\n</ul></p>\n<p>This looks to me like it's iterating through each person and not each key.</p>\n<p>I would rather have the same behaviour to look similar to this:</p>\n<p><ul>\n  {{#eachkey person}}\n    <li> {{@key}}: {{@value}} </li>\n  {{/eachkey}}\n</ul></p>\n<p>or something to that effect, which make it clear that I am iterating through the keys and not an array.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. If you don't want to do removeAttr, you can use the define plugin which can control how values are merged / set.</p>\n</blockquote>\n<p>There's not really an alternative solution that will cover every case.  </p>\n<p>can.List::attr merges just like can.Map::attr.  This isn't something we can change without breaking everyone's code.  And if we did change can.List::attr it wouldn't work the same as can.Map::attr.</p>\n<p>something like:</p>\n<p><code>define: {\n  attendees: {\n    set: function(newValues){\n      if(this.attr(\"attendees\") ) {\n        return this.attr(\"attendees\").replace(newValues);\n      } else {\n        return newValues;\n      }\n    }\n  }\n}</code></p>\n<p>closing as a \"won't fix\".  Please let me know if there's something I'm missing.\n. Closing for: https://github.com/canjs/can-component/issues/7\n. Closing for this issue: https://github.com/canjs/can-component/issues/7\n. Looks like this got fixed.</p>\n<p>https://github.com/canjs/canjs/blob/a3b566ceb93dc60e4f1e909f9a27123b4ff55771/view/stache/doc/helpers/sectionHelper.md thanks @James0x57 \n. Some definitions:</p>\n<h2>In Mustache</h2>\n<ul>\n<li>context - the initial object a template will look within for key values</li>\n<li>key - an identifier</li>\n<li>scope - a <code>can.view.Scope</code> that represents a context and a parent context.</li>\n<li>scope chain - all contexts a key might be found within for a certain area of a template</li>\n</ul>\n<h2>In attribute helpers</h2>\n<ul>\n<li><code>can-scope</code> - a helper that binds a component's \"scope\" to a particular key value in the current context.</li>\n</ul>\n<h2>In can.Component</h2>\n<ul>\n<li>scope - A definition of a <code>can.Map</code> that is used to render the component's template.  This is normally used as a view model.\n. Why is missing keys not used?  Is there a test?\n. @stevenvachon We've talked about this for a while.  It's a great idea.  The main issue with this is that we need a server that's going to run at the same speed on every run.  That takes a bit to setup.  I'm going to close this issue and label it as \"needs a hero\".  If anyone wants to help, I'd love to make this part of the release cycle.\n. Closed in 3.0\n. For my notes, the issue is when the inheriting constructor has a define property like:</li>\n</ul>\n<p>```\nvar ParentModel = can.Map.extend({\n    define: {\n        rawProp: {\n            type: '*',\n            value: {}\n        }\n    }\n});</p>\n<p>var ChildModel = ParentModel.extend({\n    define: {\n         // <br />\n    }\n});\n<code>``\n. @isadovskiy There's been no progress on this, but it's probably an easy fix.  First, you need access to the</code>base` can.Map in Map.setup: https://github.com/bitovi/canjs/blob/minor/map/map.js#L29.  It's the first argument so make that line something like:</p>\n<p><code>setup: function (baseMap) {</code></p>\n<p>Then, you need to copy everything in <code>baseMap.prototype.define</code> to a new object and then everything in <code>this.prototype.define</code> to that object.  Finally, set that object to <code>this.prototype.define</code>.  Something like the following might work:</p>\n<p><code>js\nif(baseMap.prototype.define) {\n  var defines = can.simpleExtend({}, baseMap.prototype.define)\n  can.simpleExtend(defines, this.prototype.define);\n  this.prototype.define = defines;\n}</code></p>\n<p>Now this will only copy properties, but not allow you to overwrite specific values within a property. For example, the following wouldn't work as someone might expect:</p>\n<p>``` js\nvar ParentModel = can.Map.extend({\n    define: {\n        rawProp: {\n            type: 'number',\n            value: 7\n        }\n    }\n});</p>\n<p>var ChildModel = ParentModel.extend({\n    define: {\n         rawProp: {\n           value: 8\n         } <br />\n    }\n});\n```</p>\n<p>For that to work, you need to recursively copy all properties over.  You might be able to use <code>can.extend(true, dest, source)</code>, but I think that might have unexpected results.  </p>\n<p>Better would be to only copy values two levels deep.  Maybe create a small helper function at the bottom of <code>can/map/map.js</code> like:</p>\n<p><code>js\nvar twoLevelDeepExtend = function(d, s){\n  for(var prop in s) {\n     d[prop] = d[prop] || {};\n     can.simpleExtend(d[prop] , s[prop])\n  }\n};</code></p>\n<p>And then:</p>\n<p><code>js\nif(baseMap.prototype.define) {\n  var defines = twoLevelDeepExtend({}, baseMap.prototype.define)\n  twoLevelDeepExtend(defines, this.prototype.define);\n  this.prototype.define = defines;\n}</code></p>\n<p>hit me up on gitter if you want to work on it.\n. Closing for https://github.com/canjs/can-map-define/issues/2 and https://github.com/canjs/can-define/issues/18.  Hopefully @chasenlehara can make this work over there.\n. nope.  But to add it to stache, you need to get makeLiveBindingPartialRenderer (https://github.com/bitovi/canjs/blob/minor/view/stache/mustache_core.js#L441) called with expressionData similar to how makeLiveBindingBranchRenderer is (https://github.com/bitovi/canjs/blob/minor/view/stache/mustache_core.js#L531).  I'm not sure why it isn't but I bet the fix is easy.  </p>\n<p>Then, you'll need (https://github.com/bitovi/canjs/blob/minor/view/stache/mustache_core.js#L456) to be passed something like <code>scope.add(newContext)</code>.</p>\n<p>To look up newContext, you can use </p>\n<p><code>var exprData = core.expressionData(expression),</code></p>\n<p>And b/c minor's exprData is much easier to use ... you should be able to something like:</p>\n<p><code>exprData._args[0].value(scope, options)</code></p>\n<p>Ping me on gitter if you want to help make this happen.<br />\n. Closing for issue in can-stache\n. <code>can.Construct._inherit = function (newProps, oldProps, addTo) {\n        addTo = addTo || newProps;\n        for (var name in newProps) {\n            if(Object.getOwnPropertyDescriptor ) {\n                var descriptor = Object.getOwnPropertyDescriptor(newProps,name );\n                if(descriptor.get || descriptor.set) {\n                    Object.defineProperty(addTo, name, descriptor );\n                    continue;\n                }\n            }\n            can.Construct._overwrite(addTo, oldProps, name, newProps[name]);\n        }\n    };</code>\n. Closing for this issue on can-route: https://github.com/canjs/can-route/issues/4\n. This is fixed when we made components be able to be torn down when their nodeList is destroyed.\n. Use this in a Component's event object and it should work.  It doesn't work anywhere else. The best way around it would be to listen to change and check if either valedictorian or valedictorian.GPA changed.\n. ``` js\n\"{scope} valedictorian.GPA\": function(){ ... }</p>\n<p>```\n. &gt; Well, so why should this be limited to only components?</p>\n<p>Performance is the big reason we don't do it.  Consider what happens if you do:</p>\n<p><code>js\nvar map = new can.Map({a: {}});\nmap.attr(\"a\", { .... });</code></p>\n<p>By setting \"a\", you might have to trigger off every combination of properties that someone might listen to:\n- \"a\"\n- \"a.b\"\n- \"a.b.c\"\n- \"a.x\"\n- \"a.**\"</p>\n<p>Instead, we only fire off \"a\".  Any listeners like \"a.b\" are not triggered.  \"a.b\" is only triggered when \"b\" is changed on \"a\".</p>\n<p>I understand how this can be confusing.  </p>\n<p>I think the right thing to do is make the delegate plugin work this way and advise that listening to nested properties with bind is possibly not what someone wants to do.\n. What do you mean by \"shallow event bindings on a specific subject\"? I would call bind(\"foo.bar\")  deep event bindings. </p>\n<p>I'm not really sure what you are saying about custom events. I don't see that code doing it. </p>\n<p>You can get the behavior you want by listening to change and using a regexp to check the attr arg like</p>\n<p>/cats.\\d+.cat.meow/</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jan 16, 2015, at 10:01 PM, Honey Bajix notifications@github.com wrote:</p>\n<p>Quick follow up</p>\n<p>So part of the reason why I see this type of functionality being immensely powerful is to be able to make shallow event bindings on a specific subject. This has the advantage of not requiring a lot of lifecycle logic, to teardown and rebind, or needing computes in luei of vanilla get/set functionality simply to coerce event handlers.</p>\n<p>This use case doesn't really fit very well with propagate, as propagate is bottom up whereas the bindings in this case would need to be top down. Of course, you could make what you're intended to observe extend can/event with propagate, and use change events to change the parent, however that's a considerable amount of glue and requires extended somewhat violates separation of concerns, as it would require changes to the bindee that should otherwise exist on the binder.</p>\n<p>A simple win here might simply be to exclusively use the shortest pathway when bubbling events, such that in a case where you could emit 'cats.0.cat.meow' or 'cat.meow', 'cat.meow' would always win out.</p>\n<p>It would be pretty sweet to be able to dispatch custom events from a can.Map in the same manor.</p>\n<p>var Map = can.Map.extend({}, {\n  define: {\n    cats: {\n      value: Array,\n      Type: Cat.List\n    },\n    cat: {\n      value: Object,\n      Type: Cat\n    }\n  }\n}), map = new Map();</p>\n<p>var Ctrl = new can.Control.extend({\n  defaults: {\n    map: map\n  }\n}, {\n  '{map} cat.meow': function() {\n    console.log('YAY!');\n  }\n});\n\u2014\nReply to this email directly or view it on GitHub.\n. &gt; By shallow event binding, I mean that the event would bubble specifically to the immediate parent.</p>\n<p>It currently does do this and continues to bubble up. I suppose you are wondering what would happen if you didn't keep bubbling up when you say:</p>\n<p>From a performance perspective, I'm kind of curios how emitting something like cats.*.cat.meow compares to only emitting cat.meow. Is the latter not more performant?</p>\n<p>But this makes think I'm still not communicating how bubbling works. Bubbling up to all parents is not the problem. The problem that if someone changes the \"cat\" property, you want a \"cat.meow\" event. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jan 17, 2015, at 12:08 AM, Honey Bajix notifications@github.com wrote:</p>\n<p>By shallow event binding, I mean that the event would bubble specifically to the immediate parent.</p>\n<p>So if I had a map foo with property bar that is a can.Map instance, and if bar dispatched an event, that event could be bound to like foo.bind('bar.{event}'), where {event} could be a property name, or the name of a dispatched event. In the previous example, cat could have a property meow that could trigger a change event or alternatively use can.batch.trigger/can.event.dispatch to dispatch a meow event with the same effect.</p>\n<p>I see what you mean about the regex approach and testing change - maybe simplified to /cat.meow$/?. Anyway, the problem with that approach though is that it would still pick up events emitted from objects that aren't your subject (in this case cat), and require instance checking. Even then though, that feels awfully spammy and doesn't let you split up bindings if you wanted to do this with multiple properties and have inheritance etc.</p>\n<p>From a performance perspective, I'm kind of curios how emitting something like cats.*.cat.meow compares to only emitting cat.meow. Is the latter not more performant?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. &gt; suddenly my binding that was working will no longer work.</p>\n</blockquote>\n<p>Ah, I get it.  This is because the same event can only fire once on an object.  This is to prevent cycles.</p>\n<p>I will have to think on a better (and still fast) way of solving this.\n. Anything that isn't closed is still potentially on the roadmap. I'd like to solve it, but I have no immediate plans to fix it. </p>\n<p>To be clear, the bindings \"work\" ... your page will result in the right thing, but there maybe undesirable side effects. </p>\n<p>If you'd like to help, that can move it along almost immediately. </p>\n<p>Another solution might be to apply all DOM changes at the end of a batch, in order. Every can.view.live would be applied in order. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 21, 2015, at 6:34 PM, Thomas Sieverding notifications@github.com wrote:</p>\n<p>@justinbmeyer Thoughts on getting this into the eventual roadmap? This is a very scary issue as it creates a scenario in which your bindings can break unexpectedly, for non-intuitive reasons.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Ah, I was thinking of #1866 .\n. @Bajix what's your email?  I'm sending you something to the email I have on file, but it bounced.  Can you email me at justin AT bitovi?  Thanks!\n. Closing for an issue in can-map. https://github.com/canjs/can-map/issues/2 I added a likely solution.\n. Does this happen in stache?\n. @zkat Amazing work on this pull request.  From the code, I'm not sure if the current component's values will be available as arguments or not.  For example:</p>\n</blockquote>\n<p>``` js\ncan.Component.extend({\n  tag: \"can-info\",\n  scope: {\n    data: {message: \"HI\"}\n  }\n})</p>\n<p>var tmpl = can.stache(\"<can-info can-click='{printOut data.message}'></can-info>\")\ntmpl({\n  printOut: function(text){\n    console.log(text);\n  }\n});\n```</p>\n<p>There's certainly a need for a component to be able to expose its own data to event handlers like this.  But as you're an advocate of lexical semantics, I can see you being a bit uneasy with this.</p>\n<p>I think we need a way to enable this \"now\" and have a good plan on enabling this in a better way later.\n. <code>@root</code> is off the table b/c we are using it for the \"highest level\" context (the application's view model).  We make this available even with <code>leakScope: false</code>  so components that want to interact with server-side rendering have access to the application model to register if they are doing something async that should be waited for.</p>\n<p>I think <code>%self</code> will work. \n. Closing for: https://github.com/canjs/can-stache/issues/12\n. This is a duplicate of #1219.  Can't agree more. But closing as that issue was first and includes ideas on how to pass the element and events objects.\n. Regarding this, would</p>\n<p><code>&lt;gt-placement-request param-new-name=\"{nameInput.value}\" this=\"{allPlacementsReq}\" can-request-done=\"{notifyDone allPlacementsReq.value}\"&gt;\n&lt;/gt-placement-request&gt;\n&lt;bs-button can-click=\"{allPlacementsReq.go placement}\"&gt;Submit&lt;/bs-button&gt;\n&lt;input this=\"{nameInput}\"&gt;\n{{#if allPlacementsReq.error}}\n    There's an error! {{allPlacementsReq.error}}\n{{/if}}</code></p>\n<p>Be enough?  This would one-way export <code>this</code> into the parent scope.\n. cc @daffl where did you get on this for 2.3?\n. @daffl checked what you did:</p>\n<p>```\ncan.view.attr(/[[\\w.]+]/, function(el, options) {\n        var prop = removeBrackets(el.getAttribute(options.attributeName));\n        var name = removeBrackets(options.attributeName, '[', ']');</p>\n<pre><code>    can.one.call(el, 'inserted', function() {\n        var value = can.viewModel(el);\n\n        if(prop !== 'this' &amp;&amp; prop !== '.') {\n            value = value.attr(prop);\n        }\n\n        options.scope.attr(name, value);\n    });\n});\n</code></pre>\n<p>```</p>\n<p>this won't change if the value.attr(prop) changes.  In that case, we should listen to changes in it and update the <code>scope.attr</code>.\n. This is closed with the introduction of the new event bindings:</p>\n<p><code>&lt;my-comp (view-model-event)=\"methodName()\"&gt;</code>\n. @daffl <code>value=\"__!!__\"</code> is only for mustache right?  We aren't going to fix these types of issues in mustache, only stache.</p>\n<p>@whitecolor You have to use <code>{}</code> to pass a value other than a string.  </p>\n<p>But, you can use <code>{{}}</code> to pass string values.  However, in this case, you really want to be passing a boolean.</p>\n<p>So with #1371 by @zkat the following should work in 2.2:</p>\n<p><code>html\n&lt;my-component {{#selected}}checked{{/selected}}&gt; ....</code></p>\n<p><code>can.Component.extend({\n  tag: \"my-component\",\n  scope: {\n    define: {checked: {type: \"htmlbool\"}}\n  }\n})</code></p>\n<p>Closing and marking this as 'wontfix' for now.  If I'm wrong, please comment and I will reopen.\n. And docs.\n. And docs.\n. @daffl @imjoshdean what would it take to get this in for can.List as well?\n. @daffl @imjoshdean what would it take to get this in for can.List as well?\n. @wishabhilash Imo, it doesn't make sense to use a Map.  After all, we only have can.Map to provide observability.  Your helpers \"objects\" don't need to be observable.  </p>\n<p>I'm going to close this b/c I don't understand the use case.  If you fell like this is a mistake, please try to explain more.\n. @wishabhilash Imo, it doesn't make sense to use a Map.  After all, we only have can.Map to provide observability.  Your helpers \"objects\" don't need to be observable.  </p>\n<p>I'm going to close this b/c I don't understand the use case.  If you fell like this is a mistake, please try to explain more.\n. I like the idea, but how would you prevent creating a can/control dependency of can/view/bindings?</p>\n<p><code>can.view.attr</code> is meant to be very low level.<br />\n. What happens when / if can.view.attr can accept the \"user\" template/dom?  In that case, creating component-like behavior would make sense.</p>\n<p>And, should we include some additional component::events behavior ... like the ability to rebind event handlers like: <code>\"{scope} property\"</code>.</p>\n<blockquote>\n<p>I like the idea, but how would you prevent creating a can/control dependency of can/view/bindings? </p>\n</blockquote>\n<p>This could probably be a plugin to can.Control that would wrap <code>can.view.attr</code>.  Ideally, you should be able to pass a can.Control constructor function too:</p>\n<p><code>js\ncan.view.attr('date-picker', DatePicker)</code>\n. I support this idea. I'm going to add \"needs a hero\" and close it.  If someone wants to pick it up, I'll re-open it.<br />\n. I support this idea. I'm going to add \"needs a hero\" and close it.  If someone wants to pick it up, I'll re-open it.<br />\n. Ah, this was reported here too: #632. </p>\n<p>Seems like we need a warning/docs to avoid the property name \"watch\".\n. Ah, this was reported here too: #632. </p>\n<p>Seems like we need a warning/docs to avoid the property name \"watch\".\n. Closing for #1437.\n. Closing for #1437.\n. @matthewp @whitecolor this will mostly be an internal method.  When a template like explained in #1390 finds a  <code>&lt;can-import&gt;</code>, it will call <code>can.import</code>.</p>\n<p><code>js\n&lt;script type='text/stache' id='basics' can-autorender&gt;\n    &lt;can-import from=\"can/view/autorender/tests/basics\"/&gt;\n    &lt;my-component&gt;&lt;/my-component&gt;\n&lt;/script&gt;\n&lt;script src='../../../node_modules/steal/steal.js' main='can/view/autorender/'&gt;&lt;/script&gt;</code></p>\n<p><code>can.import</code> can be wired to System / steal / amd / anything else.</p>\n<blockquote>\n<p>Is it possible to make it load multiple modules can.import(\"can-slider\", \"some-other\")</p>\n</blockquote>\n<p>I'm not going to support that.  This is an internal method.  Use <code>can.when([ can.import(m1), can.import(m2) ])</code> \n. @matthewp @whitecolor this will mostly be an internal method.  When a template like explained in #1390 finds a  <code>&lt;can-import&gt;</code>, it will call <code>can.import</code>.</p>\n<p><code>js\n&lt;script type='text/stache' id='basics' can-autorender&gt;\n    &lt;can-import from=\"can/view/autorender/tests/basics\"/&gt;\n    &lt;my-component&gt;&lt;/my-component&gt;\n&lt;/script&gt;\n&lt;script src='../../../node_modules/steal/steal.js' main='can/view/autorender/'&gt;&lt;/script&gt;</code></p>\n<p><code>can.import</code> can be wired to System / steal / amd / anything else.</p>\n<blockquote>\n<p>Is it possible to make it load multiple modules can.import(\"can-slider\", \"some-other\")</p>\n</blockquote>\n<p>I'm not going to support that.  This is an internal method.  Use <code>can.when([ can.import(m1), can.import(m2) ])</code> \n. Closing and moving into #1389.\n. Closing and moving into #1389.\n. @john-charles </p>\n<blockquote>\n<p>When including a partial the name passed in is to be resolved first against the vm and then treated as a raw value if not found in the vm. </p>\n</blockquote>\n<p>What do you mean by \"VM\"?  Do you mean view model?  In stache / mustache terminology, I think you mean the can.view.Scope.</p>\n<p>Ok, this is a bug.  We will fix.\n. @john-charles </p>\n<blockquote>\n<p>When including a partial the name passed in is to be resolved first against the vm and then treated as a raw value if not found in the vm. </p>\n</blockquote>\n<p>What do you mean by \"VM\"?  Do you mean view model?  In stache / mustache terminology, I think you mean the can.view.Scope.</p>\n<p>Ok, this is a bug.  We will fix.\n. Here's what the slider might look like with autorender:</p>\n<p><code>html\n&lt;script type='text/stache' can-autorender&gt;\n    &lt;can-import from=\"can-slider\"/&gt;\n    &lt;can-slider&gt;&lt;/can-slider&gt;\n&lt;/script&gt;\n&lt;script src=\"./node_modules/steal/steal.js\" main=\"can/view/autrender\"&gt;&lt;/script&gt;</code>\n. Here's what the slider might look like with autorender:</p>\n<p><code>html\n&lt;script type='text/stache' can-autorender&gt;\n    &lt;can-import from=\"can-slider\"/&gt;\n    &lt;can-slider&gt;&lt;/can-slider&gt;\n&lt;/script&gt;\n&lt;script src=\"./node_modules/steal/steal.js\" main=\"can/view/autrender\"&gt;&lt;/script&gt;</code>\n. Thanks for posting this.</p>\n<blockquote>\n<p>Here is a simple test to reproduce the issue</p>\n</blockquote>\n<p>Can you simplify it a bit more?  It's probably possible to create this situation without can.Model or can.fixture.  </p>\n<p>I'm asking because I can't follow the code immediately.  I would have to setup this test, which would take some time, and really dive in.</p>\n<p>If I can follow the code, it's possible I can immediately spot the problem and advise on a fix.  </p>\n<p>Thanks!\n. Thanks for posting this.</p>\n<blockquote>\n<p>Here is a simple test to reproduce the issue</p>\n</blockquote>\n<p>Can you simplify it a bit more?  It's probably possible to create this situation without can.Model or can.fixture.  </p>\n<p>I'm asking because I can't follow the code immediately.  I would have to setup this test, which would take some time, and really dive in.</p>\n<p>If I can follow the code, it's possible I can immediately spot the problem and advise on a fix.  </p>\n<p>Thanks!\n. Does this happen stache mustache?</p>\n<p>(edit stache for mustache)\n. Does this happen stache mustache?</p>\n<p>(edit stache for mustache)\n. Yes, the model layer keeps instances, but only while they are bound. Clearing the page should clean them up. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jan 13, 2015, at 3:54 PM, Jonathan Gros-Dubois notifications@github.com wrote:</p>\n<p>@justinbmeyer I will try to reproduce it using a simple Observe instead of the Model + Fixture combination - It might still leak.</p>\n<p>Ultimately, something appears to be holding on to references of the data. When I was debugging a while ago, I think I saw something about a _cache property somewhere in 'can' and I remember thinking that this could be the cause... Does that ring a bell?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Yes, the model layer keeps instances, but only while they are bound. Clearing the page should clean them up. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jan 13, 2015, at 3:54 PM, Jonathan Gros-Dubois notifications@github.com wrote:</p>\n<p>@justinbmeyer I will try to reproduce it using a simple Observe instead of the Model + Fixture combination - It might still leak.</p>\n<p>Ultimately, something appears to be holding on to references of the data. When I was debugging a while ago, I think I saw something about a _cache property somewhere in 'can' and I remember thinking that this could be the cause... Does that ring a bell?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. @jondubois I'm going to look into this Friday.  Anyway we can chat about it sometime on Friday?\n. @jondubois I'm going to look into this Friday.  Anyway we can chat about it sometime on Friday?\n. @jondubois I can confirm there is a leak in Mustache, but not in stache.\n. @jondubois I can confirm there is a leak in Mustache, but not in stache.\n. Seems valid.\n. Seems valid.\n. @alexisabril maybe we can fix this in can.Compute\n. @alexisabril maybe we can fix this in can.Compute\n. Still breaking: http://justinbmeyer.jsbin.com/tinece/5/edit?html,js,output.  I think this only happens with computes that are defined and called within a compute: http://jsbin.com/qovipi/edit?html,js,console,output Closing for: https://github.com/canjs/can-compute/issues/7\n. Still breaking: http://justinbmeyer.jsbin.com/tinece/5/edit?html,js,output.  I think this only happens with computes that are defined and called within a compute: http://jsbin.com/qovipi/edit?html,js,console,output Closing for: https://github.com/canjs/can-compute/issues/7\n. @sykopomp </p>\n<p>I like the explicit import tags and steal-based partial loading that PR supports. </p>\n</blockquote>\n<p>I know what you mean by \"partial loading\", but what do you mean by \"explicit import tags\"?  There are explicit import tags: <code>&lt;can-import&gt;</code></p>\n<blockquote>\n<p>I don't like automagic import any more than I would like magically trying to import can.Models based on their usage in JavaScript code</p>\n</blockquote>\n<p>What do you mean?<br />\n. @sykopomp </p>\n<blockquote>\n<p>I like the explicit import tags and steal-based partial loading that PR supports. </p>\n</blockquote>\n<p>I know what you mean by \"partial loading\", but what do you mean by \"explicit import tags\"?  There are explicit import tags: <code>&lt;can-import&gt;</code></p>\n<blockquote>\n<p>I don't like automagic import any more than I would like magically trying to import can.Models based on their usage in JavaScript code</p>\n</blockquote>\n<p>What do you mean?<br />\n. &gt; I like the explicit import tags and steal-based partial loading that PR supports.</p>\n<p>Actually, I'm not sure what you mean.  Do you mean my PR or yours?</p>\n<blockquote>\n<p>Nicer to use a parser anyway, I guess</p>\n</blockquote>\n<p>There's nothing to guess about.  It's supporting an intermediate representation of the parsed output.  It haves the time to a \"first\" render.  Which will make production bundles faster.\n. &gt; I like the explicit import tags and steal-based partial loading that PR supports.</p>\n<p>Actually, I'm not sure what you mean.  Do you mean my PR or yours?</p>\n<blockquote>\n<p>Nicer to use a parser anyway, I guess</p>\n</blockquote>\n<p>There's nothing to guess about.  It's supporting an intermediate representation of the parsed output.  It haves the time to a \"first\" render.  Which will make production bundles faster.\n. This is related to #629.\n. This is related to #629.\n. @hurgleburgler Can you and @daffl get this in for 2.2 this week?  Is there a pull request for this?\n. @hurgleburgler Can you and @daffl get this in for 2.2 this week?  Is there a pull request for this?\n. This isn't a bug.  Please ask this question on stack overflow, link to it here, and I will answer it.  Thanks!\n. This isn't a bug.  Please ask this question on stack overflow, link to it here, and I will answer it.  Thanks!\n. Thanks for reporting, but I think this is unlikely to be fixed.  2.2 is coming out soon and can.Mustache is deprecated. \n. Thanks for reporting, but I think this is unlikely to be fixed.  2.2 is coming out soon and can.Mustache is deprecated. \n. It is SemVer.  Unfortunately, Mustache will still be default (and deprecated).  But we still don't want people using it.  3.0 will probably be out next just so we can do away with Mustache as a default.\n. It is SemVer.  Unfortunately, Mustache will still be default (and deprecated).  But we still don't want people using it.  3.0 will probably be out next just so we can do away with Mustache as a default.\n. (I'll accept a fix if you submit one .. I'm just closing b/c I would rather spend time on improving other things and stache is a very strong replacement).\n. (I'll accept a fix if you submit one .. I'm just closing b/c I would rather spend time on improving other things and stache is a very strong replacement).\n. Is this an issue to remove that definition?  If so, and removing it causes no tests to fail, please remove it.  Thanks!\n. Is this an issue to remove that definition?  If so, and removing it causes no tests to fail, please remove it.  Thanks!\n. Because the inserted event does not bubble.  It would kill performance.</p>\n<p>However, are you only supporting modern browsers with mutation observers?  I can show you how to create a small plugin that will let you do something very similar to this.\n. Because the inserted event does not bubble.  It would kill performance.</p>\n<p>However, are you only supporting modern browsers with mutation observers?  I can show you how to create a small plugin that will let you do something very similar to this.\n. Closing because we can't add this to CanJS until we drop support for IE&lt;10.\n. I'm not planning on adding it, but if you'd like to add it, I'll accept a pull request with tests+docs. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jan 18, 2015, at 1:20 PM, Alex notifications@github.com wrote:</p>\n<p>Are you considering adding stache/mustach {{#is}} helper in the core?</p>\n<p>To allow view statement like this</p>\n<p>{{#is someAttr anotherAttr}} {{/is}}</p>\n<p>{{^is someAttr 'someConstantValue' }} {{/is}}</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. I would make it against master. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jan 19, 2015, at 6:45 PM, Alex notifications@github.com wrote:</p>\n<p>Should pull go to master or minor?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Awesome.  Thanks!\n. Thanks for submitting this. </p>\n</blockquote>\n<p>I think this might be possible currently with the define plugin. I don't think we can support it natively. I'm not a fan of calling it insertCompute. </p>\n<p>It seems you are just wanting to 2-way bind a compute to a map. I'm not sure why this would help components as they already make this happen. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jan 20, 2015, at 5:46 PM, Aldredcz notifications@github.com wrote:</p>\n<p>Hello,</p>\n<p>One feature I would really appreciate - insert can.compute (the value one, not the function one) into can.Map, so I can use it with normal can.Map interface and having all bindings working on 'both sides', as it works when inserting can.Map into other can.Map, example:</p>\n<p>var slaveMap = new can.Map({foo: 1});\nvar masterMap = new can.Map(innerMap: slaveMap);</p>\n<p>// then this works\nmasterMap.innerMap.attr('foo', 5);\nslaveMap.attr('foo') === 5; // true</p>\n<p>var compute = can.compute(1);\nvar map = new can.Map(insertedCompute: compute);</p>\n<p>// how it works\nmap.insertedCompute(); // yields 1\nmap.insertedCompute(5); // sets 5</p>\n<p>// how it would be awesome\nmap.attr('insertedCompute') // yields 1\nmap.attr('insertedCompute', 5) // sets 5\nWhat is the main goal? To get this pattern working:</p>\n<p>var map1 = new can.Map({a: 1, b: 2});\nvar map2 = new can.Map({c: 3, d: 4});</p>\n<p>var map3 = new can.Map({\n    a: map1.compute('a'),\n    c: map2.compute('c')\n});\nSince Components are based on data coupling it would be extremely useful to have this possibility.</p>\n<p>Unfortunately, there would be problem with backward compatibility, since someone could use it nowadays with current functionality, but it could be done by defining method like:</p>\n<p>var compute = can.compute(1);\nvar map = new can.Map({});</p>\n<p>map.insertCompute('nameOfAttr', compute);\n\u2014\nReply to this email directly or view it on GitHub.\n. With the define plugin:</p>\n</blockquote>\n<p>```\nvar MyMap = can.Map.extend({\n  define: {\n    nameOfAttr: {\n      get: function(val){\n        return val || val()\n      }\n    }\n  }\n});</p>\n<p>new MyMap({ nameOfAttr: can.compute(5) })\n```\n. Sorry, I'm not sure what you are saying. It's confusing because it's abstract, and you're showing map code, not components and views that assemble the behavior you are looking for. </p>\n<p>I'm not sure what you mean by \"you probably pass can.Map\". You normally pass each \"param\" individually as an attribute on the component. Ex <my-widget param1=\"{parent1Key}\" ....>. </p>\n<blockquote>\n<p>But another Widget using the same Component could have these parameters spread over many different objects.</p>\n</blockquote>\n<p>Yep, but it could pass them accordingly: <my-widget param1=\"{parent2.someObj.key}\" ....>. </p>\n<p>Hit me up on gitter Monday. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jan 31, 2015, at 6:23 PM, Aldredcz notifications@github.com wrote:</p>\n<p>Not sure, the define 'hack' is the case i want achieve.</p>\n<p>The case with Components:</p>\n<p>Imagine, you have a Component used by many types of parent Components (lets call it Widget). This Component accepts 3 parameters and modifies them. Since you can't pass computes directly into Component, you probably pass can.Map like:</p>\n<p>can.Map({\n    param1: value,\n    param2: value,\n    param3: value\n});\nOne Widget has all these parameters in one object, so you can just pass it as it is.</p>\n<p>var stuff = new can.Map({\n    // many params here including our 3\n    param1: value,\n    param2: value,\n    param3: value\n    // and many many more\n})\nBut another Widget using the same Component could have these parameters spread over many different objects.</p>\n<p>In this situation, this would be really good solution:</p>\n<p>var params = new can.Map({\n    param1: obj1.compute('param1'),\n    param2: obj2.compute('param2'),\n    param3: obj3.compute('notEvenNamedParam3')\n});\nAnd any change made would also be propagated to the original obj1/obj2/obj3 can.Map.</p>\n<p>About syntax, one more idea, what about extending can.compute prototype with a method, which would produce same compute, but when passing to can.Map, it would have described functionality?</p>\n<p>var params = new can.Map({\n    param1: obj1.compute('param1').methodName() // e.g. insertable?\n});\n\u2014\nReply to this email directly or view it on GitHub.\n. @Aldredcz Any more thoughts on this?  By gitter, I meant: https://gitter.im/bitovi/canjs .  Thanks!\n. Not sure. Alternatives might be:</p>\n</blockquote>\n<p><code>{{#and key1 key2}}</code></p>\n<p><code>{{#or key1 key2}}</code></p>\n<p>Or, we could possibly support  <code>&amp;&amp; and ||</code> in expressions.</p>\n<p>Or the names could be <code>all</code> and <code>any</code>\n. I think making <code>if</code> handle multiple arguments is great for now.  We'd have to see what it takes to include more logic in stache.</p>\n<p>Can you submit a pull request / test / docs?\n. If this is still desired, please open here an issue here https://github.com/canjs/can-stache\n. Looks very good.  I have some documentation suggestions.  Once those are fixed we can get this in.  Thanks!\n. Yeah, I'm totally fine with it making sure all arguments are the same.  However, I don't think 2 loops are necessary.  </p>\n<p>And, I'm unclear on this part:</p>\n<p><code>js\n  if (can.isFunction(expr)) {\n    curValue = can.compute(expr)();</code></p>\n<p>Normally, any function that is passed would be converted to a compute already.  There's no reason to do this afaik.</p>\n<p>I would think something like this would work:</p>\n<p>``` js\nvar lastValue, curValue;\nif(arguments.length - 2 &lt;= 0 ){\n  return options.inverse()\n}</p>\n<p>for (var i = 0; i &lt; arguments.length - 2; i++) {\n  var curValue = resolve(arguments[i]);\n  if(i &gt;= 0) {\n    if(curValue !== lastValue) {\n      return options.inverse();\n    }\n  }\n  lastValue = curValue;\n }</p>\n<p>return options.fn()\n<code>``\n. One thing I noticed is that this isn't using</code>can.compute.truthy`, so it's possible that there might be unnecessary renderings of something like:</p>\n<p><code>{{eq foo.length bar.length}}</code></p>\n<p>If foo.length and bar.length were to change together in a batch, and stay the same, this helper would be called twice.</p>\n<p>cc @akagomez \n. We can close them before that if they are in minor. Too bad github doesn't have some setting like this.\n. @asavoy I'm not sure what the correct behavior is.  You are resolving synchronously, which defeats the purpose of the async get.</p>\n<p>Without binding, there can be no value.  Or, perhaps, the value should be <code>undefined</code>.</p>\n<p>We can prevent the error from happening, by providing a callback, but (1) is not an appropriate use case.</p>\n<p>Proposals:</p>\n<p>A. Document how to use async getters.<br />\nB. Provide a callback when unbound. So no errors happen, but discard the <code>resolved</code> value.<br />\nC. Add a dev warning when .attr() is called on an async getter.  </p>\n<p>@asavoy any interest in helping?\n. &gt; B. I've had a crack at fixing this already, by eagerly binding an empty handler for any async getters, which I think is what you're describing here. I don't have a lot of confidence with Map/define/compute under the hood, so I'll need someone to review it. I'll push it up soon.</p>\n<p>I'm not describing eagerly binding an empty handler (at least I doubt it for memory-leak concerns).</p>\n<blockquote>\n<p>C. I don't think there should be a warning because I feel that one should be able to have getters dependent on async getters as done in http://jsbin.com/cunane/8/edit?js,console</p>\n</blockquote>\n<p>I didn't describe C fully.  I mean't that if <code>.attr()</code> is called on an async setter that is not bound, then produce a warning b/c the value returned is meaningless.\n. @asavoy If you're interested in working on this, lets talk tomorrow?<br />\n. As I don't think the eager binding can work in all cases, 3.0 will still not pass the resolve when unbound as this is useful information and gives someone the ability to handle that situation.</p>\n<p>Here's the issue to document it: https://github.com/canjs/can-define/issues/59\n. @alexisabril You shouldn't have to run <code>npm install jquery</code> for a peerDep. npm will install peerDeps.\n. We document add always getting an array.  Our code was broken.  This is a bug fix.\n. Exciting!\n. Closed for: https://github.com/canjs/can-map-define/issues/3\n. Oh, I forgot.  can.Model does call <code>.serialize</code> and passes that to updated/ created.  Does that work for you?\n. Seems like you found <code>.serialize</code> too.  Closing b/c I think that should be \"good enough\" not to warrant an API addition.  Thanks!\n. Thanks @asavoy! I'm closing as I think this will leak.   It's documented in 3.0 can-define that a getter called without binding will not be passed a <code>resolve</code> argument.\n. It doesn't work. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Feb 19, 2015, at 6:00 AM, Matthew Phillips notifications@github.com wrote:</p>\n<p>Looks like there is already code: https://github.com/bitovi/canjs/pull/1396/files#diff-95ad04d772620344cfa50f85ba7adb64R96</p>\n<p>I guess we just need a test to verify it is working?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. There's a test page for steal's integration. </p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Feb 19, 2015, at 7:46 AM, Matthew Phillips notifications@github.com wrote:</p>\n<p>Interesting, is there an existing demo page or something to test with? Otherwise I'll create one.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Yeah, this will be gone in 3.0</p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Feb 19, 2015, at 9:01 AM, Matthew Phillips notifications@github.com wrote:</p>\n<p>I really don't like doing an amd check in autorender but can't think of a better way.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Closing for: https://github.com/canjs/can-route/issues/7</p>\n</blockquote>\n<p>it can't be .unbind because that actually binds things on the <code>can.route.data</code>.\n. To be clear ... the model should still be in the store, only referenced by a new id.\n. Closing for: https://github.com/canjs/can-connect/issues/103\n. These controls have been replaced by the bindings methods which are exposed as a module.  However, we will document these methods as part of 3.0. Closing for: https://github.com/canjs/can-stache-bindings/issues/7\n. Indeed, this will be super useful. I'm wondering if it's possible to implement without depending on _computedBindings.\n. @akagomez Clean up is fine in this pull request as it may need to be cleaned before it gets added.  I'm going to look at it tonight.\n. I added some tests for a define get/set that \"should\" provide the same behavior that this pull request is providing (but without the special type) here:</p>\n<p>https://github.com/bitovi/canjs/commit/0e2ab190d95f14b5cf0936990dc1f43725f728b9</p>\n<p>This exposes a few problems with <code>can.compute</code> that I'd like to address and should make this functionality easier to implement.</p>\n<p>The primary problem is that I'd like to use only one compute to implement this functionality. That compute is the <code>compute.async</code> created by define.get.  </p>\n<p>The \"real\" problem is that setting a <code>compute.async</code> doesn't do any actual setting.  There are a few places I've started to fix this:</p>\n<p>Fix 1 - a setter should update the cached value when called.</p>\n<p><code>context = options.context || options;\n                                        get = options.get || get;\n-                                       set = options.set || function(){\n-                                               return value;\n+                                       set = options.set || function(newVal){\n+                                               return value = newVal;\n                                        };\n                                        //</code></p>\n<p>Fix 2 - When a compute is set, it should not assume that the passed value is the new cached value.  The following makes it call the compute's function to get the actual cached value.</p>\n<p><code>// If the computed function has dependencies,\n                                // return the current value\n                                if (computed.hasDependencies) {\n-                                       return get.call(context);\n+                                       return value = get.call(context);\n                                }</code></p>\n<p>Finally, even when setting a compute the following causes problems:</p>\n<p><code>js\nif (computed.hasDependencies) {\n   return value = get.call(context);\n}</code></p>\n<p>It calls the compute's function, but is not doing it in a way that re-evaluates the value and might trigger a change event.  </p>\n<p>Ideally, the code within <code>setupComputeHandlers</code>'s <code>onchanged</code> should be rerun. A \"set\" should be treated similar to a dependent observable changing.</p>\n<p>I'm thinking this work should be done in @alexisabril 's <code>can.Compute</code>\n. <code>can.Compute</code> passes tests #1482\n. So, I believe mustache and handlebars support ending with just <code>{{/}}</code>; however, I think they also throw warnings if the ending exists and does not match.  We should probably give a warning.\n. Closing for: https://github.com/canjs/can-stache/issues/13\n. I'm not so sure about this.  I think this is a useful flag to tell if a value is not directly on the map.\n. computedBindings is still useful, but we've removed trackCompute. Closing.\n. This is mostly closed by #1782.  It doesn't handle \"move\", however, simple mutations don't redraw the entire list.</p>\n<p>If there are other cases our diff can be better at, please open an issue.\n. This is on purpose. #each should be used for incremental situations. #section should be used when the whole list is going to be replaced. In situations where the whole list is going to be replaced, #section is faster to display and update as there's less work to be done. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 2, 2015, at 1:02 PM, Honey Bajix notifications@github.com wrote:</p>\n<p>When using lists within a section helper, if the list has a member added/removed, then the entire list is re-rendered.</p>\n<p>To demonstrate:\nhttp://jsfiddle.net/kaw0henc/</p>\n<p>List the {{#each}} helper, this should be optimized to reuse nodes as applicable</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. @daffl I'm assigning this to you as this might break a few of the <code>compute.async</code> tests.  You can probably comment them out in the legacy tests b/c they aren't a documented API.\n. Closing for: https://github.com/canjs/can-route-pushstate/issues/5\n. @alexisabril please add this this week or close the issue.  Thanks!\n. Are you looking to support direct property access?</p>\n</blockquote>\n<p>Instead of this, I've been thinking about a <code>can.define</code> that would let you to add behavior directly to prototypes like:</p>\n<p>``` js\nMyConstructor = function(...){...}\ncan.define(MyConstructor.prototype,{\n  first: \"string\",\n  last: \"string\",\n  fullName: {\n    get: function(){ return this.first + \" \" + this.last }\n  }\n});\ncan.event(MyConstructor.prototype)</p>\n<p>thing = new MyConstructor()\nthing.first = \"Alex\"\nthing.last = \"Osh\"</p>\n<p>thing.fullName // \"Alex Osh\"</p>\n<p>thing.bind(\"fullName\", function(ev, newVal, oldVal){ ... })</p>\n<p>thing.last = \"Oshkosh\"\n```\n. @whitecolor '*' would not work.  With only getter / setters, we would need to know every property ahead of time for computes to work.  </p>\n<p>Proxies would allow any property to work. Here's a prototype: https://github.com/canjs/can-observe.  Please join me in convincing Chrome to add them: https://twitter.com/mraleph/status/640144111627030528.</p>\n<p>If you are interested in making something like this work, I can add you to the can-observe project.<br />\n. Closing because this work should be done in can-observe.\n. Agreed. I must have forgotten to add it to the list of plugins so it gets built and tested. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 10, 2015, at 10:55 AM, Matthew Phillips notifications@github.com wrote:</p>\n<p>@daffl I think this definitely needs to be in 2.2.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. Underscore?!?\n. maybe there's code to import from can.route's tests that use iframes.</p>\n</blockquote>\n<p>Justin Meyer\n847-924-6039</p>\n<p>On Tue, Mar 10, 2015 at 12:31 PM, David Luecke notifications@github.com\nwrote:</p>\n<blockquote>\n<p>In the test runner. Seems like the way the QUnit test are run in the\niFrame it doesn't know what suite they belong to and thus gets stuck.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bitovi/canjs/pull/1504#issuecomment-78104906.\n. @whitecolor I agree.  The define plugin should solve this.  And can.Model.List should do it by default.  I'm not sure what it will look like, but we will want to be able to set it on lists themselves:</p>\n</blockquote>\n<p><code>can.List.extend({\n  define: { \n   \"*\": {merge: function(){ ...} }\n  }\n})</code></p>\n<p>This is clearly needed as @akagomez 's sort plugin does this (I think with some n^2 sort).<br />\n. <code>js\ncan.List.extend({\n  define: { \n   merge: function(){ ...}\n  }\n})</code></p>\n<p>?\n. Closing for: https://github.com/canjs/can-define/issues/17\n. use the inserted event</p>\n<p><code>events: {\n  \"inserted\": function(){\n    // initialize xcharts here\n  }\n}</code>\n. I don't think it's important because this is a bug that we can fix in 2.2.1 very quickly. But if it gets done before David gets the builder working, then it can be in. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 13, 2015, at 10:04 AM, Chris Gomez notifications@github.com wrote:</p>\n<p>We did this for <input type=\"text\"> here: #1443</p>\n<p>I'd hate for the one to be fixed in 2.2, and the others not.</p>\n<p>Just this morning @imjoshdean tried to rely on this and got burned: http://jsfiddle.net/imjoshdean/npwpa6v9/</p>\n<p>I think that as the Define plugin gets more popular this will become a greater issue.</p>\n<p>@daffl @justinbmeyer, Do you think this is important enough to hold up the 2.2 release?</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. fiddle seems to work now.  Closing.\n. That line existed before: https://github.com/bitovi/canjs/blob/v2.1.4/compute/compute.js#L337.</p>\n</blockquote>\n<p>I don't think that line is the problem.  Why is the getter called when the map is created?  I bet that wasn't happening before.\n. You can have a getter with a single arg that would make perfect sense with a value property. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 16, 2015, at 2:13 PM, David Luecke notifications@github.com wrote:</p>\n<p>As mentioned to @moschel, I am pretty sure that having a getter and a value is what is causing the issues. This causes the defaults to be set (in https://github.com/bitovi/canjs/blob/master/map/define/define.js#L30) and the getter to run during initialization.</p>\n<p>I can't think of a use case where you would have a value and a getter at the same time.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. This is now fixed in 3.0.  Sorry @akagomez for not getting back to you.<br />\n. <code>Todo.model(json)</code></p>\n</blockquote>\n<p>This is a duplicate of: #721</p>\n<p>Closing\n. In practice and in all commonly used versions of JS order is preserved. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 17, 2015, at 9:17 AM, David Luecke notifications@github.com wrote:</p>\n<p>It looks like some tests (AMD, distributables) are failing legitimately. I am also not sure if this is the right fix. The order of keys in objects is not determined and not necessarily the same as it was defined. #1521 is a a regression so it must have been introduced somewhere else.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. It's possible Travis / phantom does not respect order?</p>\n</blockquote>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 17, 2015, at 9:45 PM, Brian Moschel notifications@github.com wrote:</p>\n<p>This is still failing but I'm not sure why, the travis logs don't say which tests failed</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. @daffl @akagomez I think there's a bug here.  But maybe I'm misunderstanding.  What happens if I do:</p>\n</blockquote>\n<p>```\n        var map = new can.Map({\n            test: 1\n        });</p>\n<pre><code>    map.on('test', can.noop);\n            map.on('test', function(){});\n    equal(map._bindings, 2, 'The number of bindings is correct');\n\n    map.off('test', can.noop);\n    equal(map._bindings, 1, 'The number of bindings is still correct');\n</code></pre>\n<p>```\n. yeah, you're right.  nice work.<br />\n. Attr, change, created, updated, destroyed, init, setup. </p>\n<p>Any event triggered or method already on a model is off limits. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 18, 2015, at 1:58 AM, Alex notifications@github.com wrote:</p>\n<p>If model instance does have attribute created (that come from server) this attribute does not work.</p>\n<p>model.attr('created') - actually gets the value, but it does not apper in view.\nmodel.created - is function.</p>\n<p>Not sure if it shoud work by design. Ofcource there should be a list of reserved words by can, but I haven't seen such.</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. A \"created\" attr can't work in views.  The \"created\" model event would conflict with the \"created\" property change events.\n. &gt; Is that just a precedence problem that (Mu)Stache is trying to run the function right away instead of looking it up via .attr first?</p>\n</blockquote>\n<p>No, it's a different problem.\n. Closing because this doesn't really have a solution.  \"created\" is a reserved word in a <code>can.Model</code>.\n. Closing for: https://github.com/canjs/can-view-parser/issues/4\n. I believe it is available for dash</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Mar 22, 2015, at 4:54 AM, pYr0x notifications@github.com wrote:</p>\n<p>i have found these super helpful programs.\nit would be very nice if canjs will be available in thse documentation sets.</p>\n<p>Dash for ios\nVelocity for windows</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. If you are interested in ongoing support for Dash or Velocity, can you open an issue in documentjs?  We need to create a <a href=\"http://documentjs.com/docs/documentjs.generator.html\">generator</a> for these systems.  </p>\n</blockquote>\n<p>This is something that we need community support to accomplish.  I'm not prioritizing for our development.\n. Closing, I'll re-open if anyone actively picks it up.<br />\n. @rjgotten can.compute only calls the \"computing\" function when one of its source values change.  </p>\n<p>Lets say you did something like:</p>\n<p><code>{{compute1.promise.value.compute2.promise.value}}</code></p>\n<p>Where your data looked like:</p>\n<p>``` js\nvar params1 = new can.Map({});\nvar params2 = new can.Map({message: \"Hello There\"});</p>\n<p>var getData = function(params){\n  return new Promise(function(resolve){\n    setTimeout(function(){\n       var compute = can.compute(function(){\n         return {promise: getMessage(params2.attr()) };\n       });\n       resolve({compute2: compute2});\n    },100);\n  })\n};</p>\n<p>var getMessage = function(attrs){\n  return new Promise(function(resolve){\n    resolve(attrs.message);\n  })\n};</p>\n<p>var dataToTemplate: {\n  compute1: can.compute(function(){\n    return {promise: getData(params1.attr())}\n  })\n}\n```</p>\n<p>If I were to change <code>params2</code>'s message:</p>\n<p><code>js\nparams2.attr(\"message\", \"Goodbye\")</code></p>\n<p>Only <code>getMessage</code> will be called again.  <code>getData</code> will not.  </p>\n<p>The reason is that despite <code>compute1.promise.value.compute2.promise.value</code> having to be read, when <code>compute1</code> is re-read, it will return the same object in memory until one of its source observables has changed (in this case params1).  Because params1 has not changed, it uses the same promise originally returned by <code>getData</code>.</p>\n<p>So, I think the issue you are asking about is solved b/c <code>can.compute</code> kicks ass.\n. Just an FYI, it will render the component if the component is loaded prior to the template being processed.  <code>can-import</code> would allow this.\n. Closing for: https://github.com/canjs/can-component/issues/11\n. The solution to this is to add <code>{notContext: true}</code> metadata anytime \"@index\" is added to the scope, for instance:</p>\n<p>https://github.com/bitovi/canjs/blob/minor/view/stache/mustache_helpers.js#L34</p>\n<p>Scope already knows to skip these things: https://github.com/bitovi/canjs/blob/minor/view/scope/scope.js#L227\n. I just checked this, it does provide a textnode element.  Put a debugger in your fiddle and you'll see it's a text node.</p>\n<p>This is not a bug.  Closing.\n. This is not how stache works.  If the docs for stache says this, they are wrong.  Can you point to that in stache's docs?  I can update them.</p>\n<p>Stache should not work this way ... it would undermine a big part of its performance benefits.\n. If you need this, you can always swap in the element you need.</p>\n<p><code>function(){\n  return function(textNode){\n    var tagName = can.view.elements.tagMap[ textNode.parentNode.nodeName ] || \"span\"\n    var el = document.createElement(tagName);\n    $(textNode).replaceWith(el)\n  }\n}</code>\n. Math.random() gives you between 0 and 1 exclusive of 1 I believe.<br />\n. Yeah, this would be a <code>3.X</code> change.  I'm not sure about changing rand(-5,5) though.\n. Closing for the same issue in can-fixture\n. Thanks for reporting.  Taking a look!\n. This is because <code>.html</code> calls <code>.append</code> internally, so it's firing twice.<br />\n. I'll write up a guide about this for 2.3.\n. @daffl Added another change for this issue.  Realized I did not implement it right.\n. Closing for: https://github.com/canjs/can-component/issues/12\n. Closing for the functionality in https://github.com/canjs/can-validate which is observable.\n. Closing for: https://github.com/canjs/can-component/issues/8\n. http://jsbin.com/vuyexa/3</p>\n<p>Shows this working with the normal download.  @daffl Is the download builder updated with 2.2.4?\n. Or maybe the download builder needs to point to an updated StealJS?\n. @daffl It's older than what we are using to generate CanJS's download.</p>\n<p>@pYr0x Yeah, that's fine.  You shouldn't use the download with requirejs.\n. Yeah, this is sorta impossible the way stache currently works.<br />\n. Lets close this for now and re-open if we ever have a good idea how to make this work. \n. I'm not sure I understand the question.  </p>\n<p><code>js\nmap.attr( NEWVALUES, true)</code></p>\n<p>does what replace does.  the <code>true</code> does a hard set.</p>\n<p>However, there are still going to be 200 properties changing.  </p>\n<p>You could use LazyMap and LazyList which might perform better.</p>\n<p>If you are having performance problems, make sure that there are no \"change\" event handlers in your application.  \"change\" sets up bubbling, which adds a heavy cost.  You can avoid \"change\" event handlers by either listening to the specific values you want to change, or by wrapping the value you want to produce in a <code>can.compute</code>.</p>\n<p>I'm closing this issue, because there is a way to do what <code>.replace()</code> does.  If you have questions about performance, please create a stackoverflow question and link to it from here.</p>\n<p>Thanks!\n. Closing.  Will re-open if a breaking example is provided.\n. @mjstahl did your commit land?  Can you submit a pull request?\n. Closing for: https://github.com/canjs/can-view-autorender/issues/4\n. Updated to minor: http://jsbin.com/ziwuhe/edit?html,js,output</p>\n<p>I think there's several things going on here.</p>\n<p>With regards to <code>foo</code>, the most important thing to understand is that can.Component prevents cycles.  If a child changes a parent, the child can't change immediately. If a parent changes a child, the parent can't change immediately.</p>\n<p>So, what I believe is happening is that <code>foo</code> is being set to <code>false</code> on the child, but as there is no change (as get returns true), the parent is never updated.</p>\n<p>With regards to <code>bar</code>, the child's viewModel is being created with <code>bar=false</code>, however, it changes it to true before we've had the chance to setup any listeners on the child to reverse-propagate to the parent.  In fact, <code>can.Map</code> doesn't even produce events during <code>init</code>.</p>\n<p>The only solution to this would be to check what the viewModel's look like after being created, and try to update the parent view model if anything is different.</p>\n<p>Somewhere around here: https://github.com/bitovi/canjs/blob/minor/component/component.js#L219</p>\n<p>We could loop through <code>viewModel.attr()</code> and see if anything was different from <code>initialScopeData</code>.  If it was, we could try to set the value back to <code>twoWayBindings[prop].compute(update)</code>, but not before temporarily incrementing <code>viewModelPropertyUpdates[prop]</code> to prevent that change from updating the client viewModel.\n. Shows the new child-2-parent bindings can set this right: http://jsbin.com/vorote/edit?js,console,output\n. Closing because I'm betting this isn't a big problem with the new binding syntaxes.\n. We aren't supporting using can.stache and can.mustache together.  The reason is that their use of nodeLists are incompatible.  Making them work together would undermine a lot of the performance improvements in stache.  Stache doesn't have to look through a global nodeList map to build its hierarchy while Mustache does.  The only way for them to work together would be to have Stache also looking through this global nodeList map. \n. Can't we check the type?</p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Sep 17, 2015, at 1:58 PM, James Atherton notifications@github.com wrote:</p>\n<p>Sooo we need some discussion on this, via #1758</p>\n<p>Points of argument:\n1) The problem in #1758 says that if your can.List has a custom Map Type, pushing a new item which is already a map of some other type onto that list, you would expect the pushed item to be converted to the custom Map Type because the List's Map Type is set.</p>\n<p>2) The problem in this issue ( #1616 ) is that concat was serializing the items from each input list before creating the concatenated output List, which means:\nsourceList[ 0 ] !== ( sourceList.concat( [] ) )[ 0 ];\nwhich is wrong by typical definition of concatenation.\n-- The list created by concat uses the same constructor as the list on the left side of the argument</p>\n<p>Goals/Discussion:\n1) Be consistent. Which should we favor?:\n-- Any item in the List should be the same type as it's Map Type, so all List methods should type cast.\nOR\n-- List methods should behave like array methods ( without type casting the args ) so any type casting needs to be done manually.</p>\n<p>2) Should we give the option for either?\nsomeList.push( /* can push fn, type enforced / );\nsomeList.push.raw( / vanilla push fn, no type casting */ );</p>\n<p>3) Document this behavior for each method. ( even if we don't resolve the inconsistency? )</p>\n<p>\u2014\nReply to this email directly or view it on GitHub.\n. To further clarify, should it be more like:</p>\n</blockquote>\n<p><code>js\nconcat: function () {\n            var args = [];\n                        var MapType = this.constructor.Map;\n            can.each(can.makeArray(arguments), function (arg, i) {\n                args[i] = (arg instanceof can.Map) &amp;&amp; !(arg instanceof MapType) ? arg.serialize() : arg;\n            });\n            return new this.constructor(Array.prototype.concat.apply(can.makeArray(this), args));\n        },</code>\n. Closing for: https://github.com/canjs/can-list/issues/3\n. @brianmoschel I dont think this is the right fix.\n. So, looking into this issue, I think it's worth some discussion.</p>\n<p>I'm not sure comptues should be allowed as values of a can.Map.  The primary reason is that it will undermine a some of the performance gains in stache because we won't be able to use \"single bind\" computes.</p>\n<p>\"single bind\" computes are a strategy that if a single map property is being observed, we only listen to just that property change and never look for other observables to listen to.</p>\n<p>This speeds up live binding quite a bit.  Having a compute as a potential property means we might always need to check for that compute and listen to it.  </p>\n<p>Btw, this works if you don't initially have an empty property value.\n. If I were to remove the \"single bind\" exception, it drops the spinning circle speed from about 12ms per loop to about 16ms per loop.</p>\n<p>I suppose I could only setup \"single bind\" exception on values that were not <code>undefined</code>, or <code>computes</code>.</p>\n<p>So, if you switched from <code>undefined</code> to compute, live-binding would be slow, but would work.  If you switch from <code>undefined</code> to <code>\"foo\"</code>, live binding will be slow, but work.</p>\n<p>If you switched from <code>null</code> to a compute, live binding will not work. Same with \"foo\", to a compute.</p>\n<p>If you switch from <code>null</code> to <code>\"foo\"</code> live binding will be fast and work.</p>\n<p>Alternatively, there might be a way to detect a return of observable values and switch off the exception.  This would be ideal, but hard to wire up.\n. @dylanrtt I was able to \"have our cake and eat it\" with an improved compute that is able to switch between the \"single bind\" and the \"multi bind\".  This way we can have good performance, but if suddenly a compute is added, <code>can.stache</code> and actually <code>can.mustache</code> will handle it.\n. @daffl Bug? Or docs?\n. This is by design.  It's only undefined if you didn't bind on the property.\n. Related: #1416\n. @akagomez thanks for reporting this. It's a good fix for someone who needs a quick fix, but not good enough to merge into master.\n. This wasn't actually being tested.  About to submit a fix.\n. Closing for: https://github.com/canjs/can-connect/issues/105\n. I think we should make this change.  If some project is accidentally picking up Modernizr's <code>.bind</code>, that project can pretty easily patch can.proxy.</p>\n<p>Yes, jQuery's .proxy was slow, but not the bottleneck in performance.</p>\n<p>The BIG reason for this is debugging.  If you look at almost any function in CanJS, you get back a can.proxy generated function.  Instead if Function.prototype.bind is used, you will see your original source function.</p>\n<p>IMO, the trade offs are worth it.\n. @rjgotten I was aware of the issue with Firebug, but I still think it's worth it.  In my trainings, I think over 90% of people use chrome now.  </p>\n<p>Perhaps for other devs, we can put an __proxied property on the returned function that points to the original function.\n. @cherifGsoul Thanks for submitting this.  I think if the viewModel is expecting a role attr, role should be bindable.  We might need a way to make things like id / class / role / etc work.</p>\n<p>There's a few problems with the test (I'll comment on those in a second).<br />\n. this is closed for 3.0. \n. can-fixture does this now when passed a store.. cc @akagomez \n. Closing for: https://github.com/canjs/can-list-sort/issues/2\n. closing for: https://github.com/canjs/can-define/issues/17\n. @daffl Did the merge: #1806\n. related to #1231\n. Closed by #1696.\n. @brianmoschel Yes, your test is \"unfixable\". However, you can have a template with no parent, only you need to remove the parent.  If you changed your test to remove the parent of the template, all bindings should be removed.</p>\n<p>We could also allow people to pass their own nodeList and tear it down manually if they are in this situation.</p>\n<p>A warning should only be thrown if a nodeList isn't provided to the template.  There are many situations internally where they are.\n. This doesn't look like it is ever appending the   Fragment after the first time. This is because there are no divs to append it to. </p>\n<p>If that is the case, Stache will leak, but this isn't a valid use case. </p>\n<p>Sent from my iPhone</p>\n<blockquote>\n<p>On Jul 8, 2015, at 7:50 AM, Guido Smeets notifications@github.com wrote:</p>\n<p>This seems to leak even if I use a wrapping element:</p>\n<p><script src=\"/Scripts/1.0.0.0/lib/jquery/jquery-1.11.2.js\">\n\n\n    var template = can.stache( \"<p>{{test}}</p>\" );\n    var foo = false;\n    $( document ).click( function() {\n        if ( foo ) {\n            $( \"div\" ).remove();\n        } else {\n            var fragment = template({ test: \"test2\" });\n            $( \"div\" ).append( fragment );\n            foo = true;\n        }\n    });\n\nUsing the 3 snapshot technique:\nFirst snapshot after load.\nClick the screen,\nSnapshot\nClick the screen\nIf I change can.stache into can.mustache and repeat the procedure I don't get those dom nodes floating about.\n\u2014\nReply to this email directly or view it on GitHub.\n. > the next click the div is removed. It's definitely appended to the page.\n\nBut on all future clicks, there is no div right?\n. You could also pass your own nodeList and make sure you tear it down:\n```\nvar template = can.stache(\"{{something}}\");\nvar nodeList = [];\ncan.view.nodeLists.register(nodeList);\n$(document.body).append(template({},{}, nodeList));\n// sometime later ...\n$(document.body).empty();\ncan.view.nodeLists.unregister(nodeList);\n```\n. > This meant that any time a user would add an event handler like this.on('click', fn) and then call this.on() those event handlers were being wiped out.\nThis has always been true right?\n. @daffl @moschel Those videos are not part of the \"@description\" of the video.  And, they shouldn't be above the API signatures.\nOur docs are very \"precise\" and focused at the top.  A sort description and quick summary of the APIs / signatures.  These videos should be at the bottom.\n. This is likely due to can.Map thinking that compute represents a define.get.\n. Looked into this.  First, I don't think you should be writing your code like this.  There's no reason to bind to \"change\" events on can.Map anymore and you could use the define plugin to describe petInfo.\nI'm not sure why you would set a compute as a property value of an attribute either.\nAll that being said, it would still be nice to make this work.  The problem is that this code creates a \"cycle\" of binding that isn't being detected while unbinding.\n. #1231 is probably related\n. Closed by #1696.\n. Seems like the docs have it right, but the code has it wrong.  The oldVal argument with an \"add\" event should probably be undefined.\n. <select can-value=\"{state}\">\n  <option>Loading ...</option>\n. Closing for: https://github.com/canjs/can-stache/issues/15\n. @matthewp this seems done: https://github.com/canjs/canjs/blob/master/view/import/import.js#L25\n. @matthewp this is for can-ssr right?  <can-import> can export any import now, it's on can-srr to respect it?\n. I don't think this is a regression.  The event dispatching order of events handlers compared to the DOM is not documented or tested.  \nHowever, it might be possible to control for this deterministically.\nI think the internal control needs to be created after the rendering: https://github.com/bitovi/canjs/blob/master/component/component.js#L282\nIf you can submit a test (and maybe a fix if it's as easy as moving the control initialization under the template rendering), we can get it in a release.\n. I'm closing this and marking it as \"needs a hero\".  @lihan or anyone else who runs into this problem, I'm happy to pair on making the change.  Just ping me when you have an hour to work on it on gitter: https://gitter.im/canjs/canjs\n. I think this is working right?\nhttps://github.com/canjs/canjs/blob/master/util/inserted/inserted.js#L12\nShould be getting the owner document of the element being inserted (assuming document wasn't passed correctly).  \n@imjoshdean anyway you can create a test for this (or check that it's still not working)?  Presumably you could create an iframe and insert a template into it and see if stuff works.\n. this is resolved in 3.0.\n. This has probably existed forever because can.view.live.list only listens to add/remove events.\nI'm not sure what the right fix should be.  Possibly we should trigger an remove and add event whenever an index is updated in this way.\n. Btw, this should work w/o {{#each list}} and just using {{#list}} instead\n. This is still the case. \n. The solution is that when #each is creating a context, it should pass:\n- the property name that was used to get the context (as a compute in case the property name changes (ex: 0 to 1))\n- the object who's property the context is (basically if I get the context by doing foo.bar ... this is foo).\nThen, when reading a property like . or this, a compute should be given instead of the context.\n. Closing for: https://github.com/canjs/can-stache-bindings/issues/8\n. I wont add this for performance reasons.  Every single inserted element would have to have an event triggered on it that bubbles up to the document.\nIf you need this, describe a way to make MutationObservers work with can.Component.\n. @daffl yes.\n. @isadovskiy I don't think we are going to add this.  In 3.0, my plan is to switch to Mutation observers.  Hopefully you support only browsers that have this.\nIf not, I can probably show you how to hack this in.\n. We've talked about a & operator for a long time. Not sure why it was marked as won't fix. Easier to add now that expression logic has been improved. \nSent from my iPhone\n\nOn Aug 20, 2015, at 7:08 PM, dylanrtt notifications@github.com wrote:\nI can't accept \"won't fix\" as an answer for this anymore. This keeps coming up as a problem I need to workaround whereas angular 1.x provides this by simply throwing & on the directive definition (which is gross I know). We could probably do something like this:\n// passing function to component\n\n// passing function to can-EVENT\n\nHere's a simplification of a recent use case I encountered where I could not find a suitable workaround.\nmy-component.js:\ncan.Component.extend({\n  tag: 'my-component',\n  template: // my-component.stache\n  viewModel: {\n    myMethod() {}\n  }\n});\nmy-component.stache:\n stuff \n component somewhere in the middle \n\n more stuff \nmy-dialog.js:\ncan.Component.extend({\n  tag: 'my-dialog',\n  template: // my-dialog.stache\n  viewModel: {\n    // close dialog only if form validates\n    closeDialog(validator, myMethod) {\n      if (validator.validate()) {\n        myMethod();\n      }\n    }\n  }\nmy-dialog.stache\n\n\n\n\n\n\n\nThere is no way for me to pass myMethod to that function. If my-component's view model was exposed as a #reference then I could pass that in but that can't be done when all of this resides within my-component.stache.\nAngular 1.x lets you use the controllerAs property of a directive which namespaces the controller. This affects the component's template so I could probably pass myComponent to the click handler if I wanted to, but we don't have a way to reference the current template's context like that except for in can-EVENT which doesn't work here since the click event is too deep.\nHere are some alternatives I did not want to do.\nBad Alternative 1: I could pass @element to closeDialog and have it trigger an event which is hooked up to myMethod on the element via can-EVENT. I don't like the idea of triggering DOM events in the view model.\nBad Alternative 2: Adapting option 1 to not trigger in the view model, create a new view model property and change it just for this purpose. Add an event handler in the component that triggers the event... more convoluted.\nBad Alternative 3: Create another object on the my-component view model that exposes the method... it shouldn't come to this.\ndefine: {\n  api: {\n    get() {\n      return { myMethod: this.proxy(this.myMethod) }\n    }\nSimilar to method 3, the more traditional way would be to have my-dialog expect an object on which would be the method it should call. If it were just a dialog, that would make sense but my example above is a simplification; the actual scenario I have makes that seem inappropriate... perhaps because it needs to be partially redesigned but this all would have been so much easier if I could just pass a function reference in stache.\n\u2014\nReply to this email directly or view it on GitHub.\n. Should we use * or &? In C, * dereferences, & gives you the pointer address.  I suppose & makes sense. * would mean get the value ... & will mean give me the thing that can get me the value.\n\nI'd like to take this into account with calling helpers.  Would the following call myHelper with 5 if value=can.compute(5)?\n{{myHelper *value}}\nWhat would:\n{{myHelper &value}}\ndo?  Probably still just pass the compute?\nBehaviors:\nSomeone needs to fill out the following matrix:\nWhere things are called\njs\n// helpers\n// components\n// method calls\nx\nDifferent values\njs\n// can.compute()\n// function(){}\n// 5\nx\nDifferent operators\n``` js\n// *\n// &\n``\n. Here's how to add this to minor.  A few things to prepare yourself with:\n- Expressions like{{foo (bar &zed) 5 tex=\"mex\"}}` are tokenized, parsed and converted into \"expression data\".\n- They are tokenized here: https://github.com/bitovi/canjs/blob/minor/view/stache/mustache_core.js#L334\n- And parsed here: https://github.com/bitovi/canjs/blob/minor/view/stache/mustache_core.js#L291\n- Expression data ends up looking like:  https://github.com/bitovi/canjs/blob/minor/view/stache/mustache_core_test.js#L8\n- Component's don't use expression data.  They should!\n- can.compute.read can take options that control how something like \"foo.bar\" is read.  \nBasically, expression data is a bunch of expression objects.  You can get the value of an expression object like:\nexprData.value(scope, options) //-> * | compute\n1. Token &\nOk, so with that in mind, the first thing is to make sure & turns into a token.  That can be done by changing argumentsRegExp here: https://github.com/bitovi/canjs/blob/minor/view/stache/mustache_core.js#L34.\n2. Make ScopeExpression handle & and other options.\nScopeExpression is defined here: https://github.com/bitovi/canjs/blob/minor/view/stache/mustache_core.js#L107 as just taking a key to look up in the scope.  This probably needs to take an optional readOptions so I can do something like:\n```\nvar funcRef = new ScopeExpression(\"func\",{\n  returnObserveMethods: true,\n  proxyMethods: true,\n  isArgument: true\n});\nvar func = function(){}\nfuncRef.value(new can.view.Scope({\n  func: func\n})) //-> func\n```\nThe readOptions passed to ScopeExpression.prototype.value should be merged with the one passed in when the ScopeExpression is being created.\n3.  Make _expressionData create the right ScopeExpressions when it sees a &.\nBasically, we need something like:\njs\nif(token === \"&\"){\n  cursor.index++;\n  args.push( new ScopeExpression(nextToken, {\n    returnObserveMethods: true,\n    proxyMethods: true,\n    isArgument: true\n  } ));\n}\n4.  Test\nAt this point, there should be a test in https://github.com/bitovi/canjs/blob/minor/view/stache/mustache_core_test.js making sure that the new ScopeExpression functionality works and that .expressionData parses &s right.\nAt this point, you should be able to pass functions as can-EVENT arguments and to helpers.  YAY!  We should add some tests in stache/stache_test.js and bindings/bindings_test.js to make sure.\n5. Components\nOnce the basics of this works, we need to make components work.  The best way to do this would be to use .expressionData to parse each attribute value.  And use the resulting expression data to get the value / compute instead of doing it manually as is done here: https://github.com/bitovi/canjs/blob/minor/component/component.js#L161\n. If I understand you correctly, I think the default behavior is:\n|  | computes | functions | properties |\n| --- | --- | --- | --- |\n| helpers | R | (R) | (R) |\n| components | R() | R() | R |\n| methods | R() | R() | R |\nIf a helper is passed a function, I think that function is converted to a compute.  I might be wrong though.  This matrix would make good docs :-)\n. http://jsbin.com/pedavaqofo/edit?html,js,console\nIt's converted to a compute if the function reads an observable.\n. > I would say that is fine for & to pass along except that in order to know the function is observable, it has to be executed which I don't think is acceptable.\nI think it makes a lot of sense for a helper.  A helper really only gets \"values\" as arguments and needs to produce some sort of content.  It would be a very rare helper you needed to configure with a function.\n. @dylanrtt I'm going to try to make a document outlining the default behavior in almost any circumstance.  With that done, i'll revisit these * and &.  I've started the document here:\nhttps://docs.google.com/spreadsheets/d/1KytpEzS6dJX5Hd44otuFyWQunnKy9pNHHVz7GW73Ox4/edit#gid=0\nIt's a work in progress, but please feel to comment.  I might have a hangout Friday to go over it w/ some bitovi folks.  Let me know if you want to join us.  Thanks.\n. @dylanrtt I updated the first comment with a summary.  Easier to track there.  Please let me know what you think.  Thanks for your help on this!\n. Note to self, crazy stuff like this should work:\n{{ foo( &bar().listIt ) }}\n. @dylanrtt After a long talk with @mjstahl, we think that & and * is confusing.  We're thinking of changing it to ~ to make things give you a compute, and @ to give you what's directly AT a certain property value.\n{{helper @my.method}} will pass whatever it finds at my.method, be it a function, property value, or a compute.\n{{helper ~my.method}} will pass a compute similar to what is passed now.\nI'm going to update the summary with these changes.\n. btw, we could make these fill in for (.) like:\n{{helper models@Todo~findAll}}\nmodels@Todo would mean ... don't try to call the Todo constructor.  Todo~findAll would mean to convert the result of findAll to a compute.\n. Talking with a few old C folks at bitovi, they expected & to give them the compute.  As & gives you a pointer address, not the actual value, they expected it to make some value more \"abstract\".  I got them backwards myself last night.\n@pYr0x I think @index and @key would actually make more sense now.  \nYes, it might be confusing with the old \"@\" behavior in viewModels in can.Mustache.  But that's long forgotten.\n@ even sounds better.  It's giving you the value AT some property.  Everything is a reference in JavaScript.  Plus, @ is still going to give you a compute if the compute is at the end of your lookup path.\n. @dylanrtt @pYr0x we've been on gitter talking about this all day.  Please join us if you have time: https://gitter.im/bitovi/canjs\n. Oh, and the fact we can substitute . for @ and ~ really wins me over.  What does: \n{{helper models&Todo*findAll}}\nDo?  It looks like it does a bitwise operation and some multiplication.\nThe following might not be immediately obvious, but at least doesn't look like something it isn't.\n{{helper models@Todo~findAll}}\nThis might not seem that useful, but it's common for functions to have other properties on them.  can.Models are great examples that we currently special case.  But those functions might have observable properties that should be treated as a compute.\n. A reminder to myself, with expressions like:\nselectedPlate(value)\nThe default behavior if selectedPlate is an attribute, should be to call context.attr(\"selectedPlate\", value)\n. There's a problem with the proposal.  Should @foo in:\n{helper @foo}\nwith a context like:\njs\nvar bar = function(){};\nvar context = new can.Map({\n  foo: bar\n});\nbe passed as a compute that returns bar, or the bar function itself?\nIf it returns a compute(bar), then @'s behavior really only changes what value is represented (either the bar function or bar's return value.\nIf it returns bar, then @ not only changes what value is represented, but also how it is represented (the actual value or the compute).\nI think it should not change \"how it is represented\", making the first row of @key like:\n| @key | computes | functions | properties | general behavior |\n| --- | --- | --- | --- | --- |\n| helpers | {(R)} | {(R)} | {(R)} | pass a compute that returns a a function or compute at the end of the path. |\nI mean, this makes it so you can't pass a normal value using the old helper syntax.  However, we have a way to pass a normal value ... use CallExpressions.\n. | Type | Example |\n| --- | --- |\n| Parent to Child -0 way | <my-comp child-prop=\"foo\"/> |\n| Parent to Child -one way | <my-comp child-prop=\"{{name}}\"/> |\n| Two Way | <my-comp child-prop=\"{parent}\"/> |\n| Child to Parent - two way | <my-comp [parent]=\"{childProp}\"  /> |\n| Child to Parent  - one way | <my-comp ^parent=\"{{childProp}}\"  /> |\n| Child to Scope Variable -two way | <my-comp #ref=\"{childProp}\"/> |\n| Child to Scope Variable - one way | <my-comp #ref=\"{{childProp}}\"/> |\n. There's a problem with this and undefined values which is related to: #579.\nEssentially, if #foo creates a foo value in a \"references\" scope, it will be undefined temporarily in an example like:\nhtml\n<parent>\n<child>\n  {{foo}}\n</child>\n</parent>\n<something #foo/>\nIn this case {{foo}} will be bound to chid.foo.\nThere are two fixes:\n1.  Fix #579.\n2.  Change <my-comp #child/> to <my-comp @child/> and create @child in the references scope.  Make values like @NAME, if they aren't found, default to observing on the references scope.\nThese a probably about the same difficulty, however, #579 might involve binding on every single \"parent\" observable context.  BOO!\nI would prefer to write out references like <custom #foo/>, but @foo isn't so bad and wouldn't have potential performance issues.\n. @matthewp I don't like the = sign going the other way.\n. I'm proposing changing this to account for problems in #1770.  A detailed explanation of the problems is discussed here.  \nOn a high level ... stache/handlebars/mustache should be its own language.  Bindings should be an interface that gets applied after stache has done its business.\nOn a lower level ... the original proposed binding syntaxes: prop={} and prop={{}} suffer from two problems:\n1.  They make it difficult or impossible to use stache to \"program\" the bindings.  This is related to #1770.\n2.  They use an attribute name they are adding behavior to.  For instance, value=\"{key}\" would setup two-way binding on the value property.  Accounting for problem (#1), this means that the most straightforward implementation would have value set to \"{key}\" temporarily.\nFinally, after studying angular 2.0's syntax, it is able to smarty combine event syntax (event) with one-way binding [key] to setup two-way binding like: [(key)].  This is smart.  Lets steal it!\nSo, I'll be updating the proposal to closely match angular 2.0's syntax.\n. Here's the old proposal for safe keeping:\nTwo Way:\n<component child-prop=\"{parentProp}\">\nOne Way into child:\n<component child-prop=\"{{parentProp}}\">\n<component child-prop=\"[parentProp]\">\nOne way into parent:\n<component [parent-prop]=\"{{childProp}}\">\nOne way into variable\n{{#}}\n<component [parent-prop]=\"{{childProp}}\">\n{{/}}\n. The reference scope is a different scope that is local just to the current template.  This talks about it: http://canjs.com/2.3-pre/docs/can.view.bindings.reference.html\n. @matthewp So there, might be a need for parent after all.  Basically, I want a 1-way binding from a component property to &ref.  Something like:\n<my-component ^child=\"&ref\">\nBoo!  This makes me think that two-way binding might look like:\n<my-component [^child]=\"&ref\">\nvs\n<my-component [(child)]=\"&ref\">\nYarg.  I'm not sure what to do.  I thought about making \n<component &ref=\"foo\"\nDo one-way from &ref to foo.  However, I don't like that.  I think we should stick to the key always being the attribute value.\n. Alternatively, we could use {child}=\"parent\" for child->parent one-way binding.  Making [{child}]=\"parent\" also work for 2-way.\n. An alternate to the alternate would be to use:\n| Type | Example |\n| --- | --- |\n| one way - viewModel - parent to child | <my-comp child-prop{=\"parentProp\"/> |\n| one way - viewModel - child to parent | <my-comp child-prop}=\"parentProp\"/> |\n| two way - viewModel - child to parent | <my-comp {child-prop}=\"parentProp\"/> |\n| one set - viewModel - parent to child | <my-comp child-prop[=\"parentProp\"/> |\n| one set - viewModel - child to parent | <my-comp child-prop]=\"parentProp\"/> |\n. Can't use & for reference because {{&foo}} is a mustache thing.  Damn.  Switching to *.\n. This almost makes me want to wait for 3.0 for references.  We can drop {{&foo}}.\n. Updated to what I think is the final syntax.\n. @matthewp strangely I didn't notice an error.  Perhaps chrome removed it.  When you get latest minor, let me know if it happens to you.\n. @JustinLove I really like the idea that \".\" is reading from the element's viewmodel.  The rest of it I'm more ambivalent about.  Thanks for sharing!\nUnfortunately however, this issue is closed (It was going figuratively until minor is in master).  I've implemented the proposal listed in the first issue and we've updated our DoneJS guides with this.  And I've begun the documentation. There's just too much behind it now to have another round of discussion.  \nHopefully what's prosed, if not ideal for everyone, is good enough for everyone. Thanks again! \n. actually ... I'm going to close to signal an end to this debate.  If anyone wants to reopen, please start another issue for 3.0's binding syntaxes :-).\n. @imjoshdean In general, it's rare that something like:\nmap.attr('foo', 'bar');\nmap.attr('foo', 'baz');\nHappens within a batch.  If this is the case, then the logic to reduce the number of \"replaced\" events isn't worth it.\nAlso, while something like debounce would be useful for a single event handler, this pattern breaks down if you need to respond when length changes or some other event.  In this case you need to check the batch number.  Reducing the number of events would not help.\nIn general, using events to listen to view model changes should be avoided.  \n@akagomez If there are multiple calls to debounce on the same events object, you'd need to make sure each one has its own place to store it's batch num.\nSomething like this would have been useful for a long time.  But now with diffing, and the upcoming can-derive, it slowly has less utility.\nHowever, there are a few parts of CanJS's core that could use this ... not so much on a prototype, but using closures.\n. I'd implement the versions that are already sudo-implemented in CanJS's core.\n. Closing for: https://github.com/canjs/can-event/issues/3\n. Wanted to merg this into minor\n. Thanks.  This will be fixed in the next release.\n. Btw, are you using browserify? Which version?  With latest, you should only have to write:\nrequire('can')\n. Fixed now: http://jsbin.com/hebewe/edit?html,js,output\n. How exactly would this be documented?\nSent from my iPhone\n\nOn Sep 4, 2015, at 3:53 PM, David Luecke notifications@github.com wrote:\n@justinbmeyer this has indeed been added in #1540 but was never documented. I will add a promise.md that talks about how to use it.\n\u2014\nReply to this email directly or view it on GitHub.\n. Closing for: https://github.com/canjs/can-map-define/issues/4\n. @akagomez add, remove and set events are not triggered on a can.Map.  This is because they are rarely needed and would add performance overhead.  \n\nIs there a reason they are needed?  Closing for now.\n. Closing for https://github.com/canjs/can-list/issues/4.  @pYr0x please confirm it's the same issue.  Thanks!\n. I'm fine with this.  You would have to make the #each helper change the scope which it sets up here:\nhttps://github.com/bitovi/canjs/blob/minor/view/stache/mustache_helpers.js#L34\nInstead of .add(item), it would be more like:\nvar context = {};\ncontext[asValue] = item;\n.add(context);\nTo make \"as\" work, I think we do pass the expression data, so you could see that the argument name was \"as\".\n. @pYr0x or @whitecolor let me know if you want to tackle it.  Thanks!\n. @dylanrtt was looking for this too.\n. Closing as: https://github.com/canjs/can-stache/issues/16\n. Just an FYI:\n- Computes on the prototype are deprecated.  So 'foo': can.compute(0), shouldn't be done.\n- In general, using events on an \"events\" object should be avoided.  The define plugin on the viewModel can almost always be used instead.\n. I'm going to close this.  I don't think promises need to be bindable in events because they are non-leaky.  Someone can always listen to when the property changes and .then the promise like this shows:\nhttp://justinbmeyer.jsbin.com/petufa/edit?js,console,output\n. Anyway you can simplify this example?  I can take a look tomorrow.\n. Also, why do you say a memory leak?  I'm not easily able to profile that code b/c it's in an iframe, but it seems more like a problem with a compute binding to \"itself\", not a memory leak.\n. Thanks. Can you reduce what it takes to see the problem? Models are probably not necessary. \nSent from my iPhone\n\nOn Sep 8, 2015, at 3:13 AM, pYr0x notifications@github.com wrote:\nhi justin,\nwhats happening in my code example:\n1. disable auto-run js\n2. clear console output\n3. run js\n4. now the alert('memory leak'); will pop up and never end. and the counter \"j\" will increase.\nmaybe the title \"memory leak\" is not correct, there is an infinity loop witch raise an error\ni hope\n\u2014\nReply to this email directly or view it on GitHub.\n. @pYr0x anyway you can check this and see if it's still a problem?\n. @daffl @alexisabril if this is in minor should we close it?  I'm ok closing minor related things.\n. @rjgotten The way we do it was suggested by James Burke.\n. Btw, @rjgotten if you'd like to make exporting a relative version of CanJS's AMD easy ... it would just take creating a relative version of steal-tool's AMD helper: https://github.com/stealjs/steal-tools/blob/master/lib/build/helpers/amd.js\n\nYou'd just have to copy that and paste this line:\nhttps://github.com/stealjs/steal-tools/blob/master/lib/build/helpers/cjs.js#L113\nthat makes the CJS build relative in the right place.\nto export a relative version of AMD, i\n. @rjgotten if you'd like, can you email me at justin AT bitovi.com  Thanks!\n. @pYr0x Want to setup a time next week to go over this issue and #1743 ?\n. Closing for: https://github.com/canjs/can-list/issues/4\n. @alexisabril we should deprecate can.isDeferred and use can.isPromise everywhere.  They should be the same function.\n. @daffl we should release this in 2.3.  I didn't  notice that it was pushed to 2.4.  Why is that?  The old version remains so we aren't breaking any APIs.\n. Closing for: https://github.com/canjs/can-list/issues/4\n. @dylanrtt how would multiple args be passed?  I agree that we should fix this.  Thanks for pointing it out.\n. Closing for: https://github.com/canjs/can-stache-bindings/issues/9\n. @dylanrtt Just found this myself.  Thanks for reporting.\n. This is probably less likely to happen in minor because of the diffing.\n. @dylanrtt anyway you can simplify the test to something along the lines of: https://github.com/canjs/canjs/commit/1401c401c49609f2d8d369d5950cdcaf139e6018#diff-7bca9ce6f0378f28c17f2c02cd1eb9b0R1859 ?\n. @dylanrtt how can I see the error?  Thanks.\n. @dylanrtt is this how:\n1.  Select \"Alexis\", \"Curtis\", \"Curtis\".\n2.  Change the first select from \"Alexis\" to \"Curtis\" and then back to \"Alexis\"\n?\n. @dylanrtt thanks!\n. Checking out this problem a bit, it doesn't look like there is a \"nice\" solution.  Also, I'm not sure what the behavior should be.\nTwo-way binding behavior\nWhen Brian is removed, the <select>'s value becomes \"\".  Because of this, I think the right behavior might be to change the two-way bound value (person) to \"\" if there is an <option value=\"\">.  If there isn't an option with a value of \"\", then no option will be selected and the two-way bound value will be set to undefined.\nOne-way binding behavior\nWhen Brian is removed, the <select>'s value becomes \"\".  But this should be ignored.  When Brian is eventually put back, that <option> should be selected by setting the  <select>'s value.\nMaking it work\nIdeally, the bindings could setup a MutationObserver and know whenever the list of options has changed and either update the two-way bound value, or re-set the value.\nAs that's currently not possible in all the browsers we support, it means I'll have to create a bridge between can.view.live and can.view.bindings.  Somehow, can.view.bindings will have to be alerted when some live-binding activity happens within some <select>.  \nFor performance reasons, I want this bridge to run only when explicitly needed.  Also, ideally, this bridge would not be super-special cased.  There's a strong possibility we'd want to know when some other content is being updated.\nMy naive approach would be to have can.view.live.html and can.view.live.each simply check their parent.  If it's an <select>, look for any callbacks on that option. can.view.bindings would register a callback on <select>'s with bindings:\n``` js\ncan.view.live.registerMutationCallback(selectElement, function(){\n})\n```\nThis solution would be decently fast.  can.view.live would maintain a \"quick check map\" of just the elements that get this special callback check.  \nThere's one problem. <options> can exist in <optgroup>s. This wouldn't work because the parent isn't a <select> element.\nFortunately <optgroup>s can't be nested, so we could just check up 2 .parentNodes.  However, this is no longer generalized ... or we have to go slow and start walking up the parent chain a lot.\nCurrently, I'm leaning to one solution that uses MutationObservers for browsers that support it and another, slower, solution for browsers that don't.  \n. > Your suggested 2-way binding behavior might be the best option, but what should happen during initialization if the bound value is not present in the options?\nIn this case, if the parent scope has a value, say \"foo\", the parent value would remain.  \n\nMight that cause the selected value to change to \"\" unexpectedly or would batching likely prevent that?\n\nIt might, but hopefully batching would prevent that.\n. Corrected the two-way behavior to account for when <option value=\"\"> is not present.\n. There's a technical problem with one-way bindings.  Essentially, with a one-way binding, we need to constantly make sure that when the \"child\" changes, we try to overwrite that value with the parent.\nWith a one-way binding, we don't even bind to the child compute.  So there's not a great mechanism to make this happen.  I'm also not sure what this is conceptually ... it's sort of a \"sticky child value\" ... a type of child compute that will attempt to take on a certain value if possible.  But if not, it can have another value.  \nI'm trying to think of similar situations to figure out how to build this correctly.  For example, <input {$value}=\"name\"/>.  Similar to a <select> if a user changes the <input>'s value, the input should not snap back to the parent value.  There's not really an analogous situation to <select>'s having their value changed by removing their <option>'s and then having the \"sticky value\" added back.\nTo implement the \"sticky value\" .... I need to probably pass the parentCompute to the childCompute so the childComptue can read the parentCompute at anytime.  The other problem is that with one-way bindings, we don't actually bind (and eventually unbind) on the childCompute, so there's not a natural binding lifecycle we can access.  This is important because we only want to listen to mutation events when the select has a binding on it.\nOne possibility might be to just bind the childCompute in these \"sticky\" cases, but not use it to update the parent.\n. @wishabhilash This type of question is best on the forums: http://forums.donejs.com/c/canjs \nI'm not sure what you are planning on doing with localStorage, but it doesn't sound like the right solution to me. \n. Closing for: https://github.com/canjs/can-stache/issues/17\nThis would be solved like:\n<select {($value)}=\"booleanToString(model.flag)\">\n        <option>Select something...</option>\n        <option value='true'>True</option>\n        <option value='false'>False</option>\n</select>\ncan.stache.registerConverter(\"numberToString\",{\n  get: function(source){\n    return  source() ?  \"true\" : ( source() === false ? \"false\" : \"\");   \n  },\n  set: function(newVal, source){\n    source(newVal === \"\" ? null : newVal === \"true\"); \n  }\n});\n. closing ... if this is still an issue in can-map, I'll re-open there (or someone else can).\n. @dylanrtt @asavoy any interest in helping implement it?  I can walk through what's needed.\nAnyone think that:\n{{outer-helper inner-helper('abc') 'def'}}\nWould be more natural?\n. The place to start implementing this is to first get the parsing of sub-expressions working.  Currently, the parsing happens here:\nhttps://github.com/bitovi/canjs/blob/master/view/stache/mustache_core.js#L133\nFor something like {{outer-helper 1 name zed='ted' foo=bar}} this returns a data structure that looks like:\njs\n{\n  name: \"outer-helper\",\n  args: [1, {get: 'name'}],\n  hashes: {zed: 'ted', foo: {get: 'bar'}}\n}\nTo make sub-expressions work, we'd want to make this recursive.  Something like {{outer-helper inner-helper('abc') 'def'}} might return:\n{\n  name: \"outer-helper\",\n  args: [{name: 'inner-helper', args: ['def']}],\n  hashes: {}\n}\nWith that in place, the next work would need to be done in makeEvaluator: https://github.com/bitovi/canjs/blob/master/view/stache/mustache_core.js#L182\nThere is looks in args and in hashes for objects \"getter\" objects:\nhttps://github.com/bitovi/canjs/blob/master/view/stache/mustache_core.js#L208\nIf it found an object like {name, args, hashes}, it could actually call itself (makeEvaluator) with that object as exprData.   makeEvaluator returns a function that will need to be converted into a compute.\nAll in all .. pretty simple actually.\n. Related to #1888, I'm thinking that function calls are more natural when you might have multiple of them.  Compare:\n{{#each ( (game.statsForPlayerId player.id).filter type) }}\nvs\n{{#each gameStatsForPlayerId(player.id).filter(type) }}\n. I'm surprised this was working before.  Especially as I'm not sure how the parsing rules might have changed.  \nI'll have to see what happens in 2.6 with this code.\n. This is caused by this code:  https://github.com/bitovi/canjs/blob/v2.3.0-pre.2/view/stache/stache.js#L278\nThis was added so we can differentiate between two way {name} and one way {{name}} bindings in custom attributes.  For example:\n<my-el #other-export=\"{{name}}\">\ndoes something different than:\n<my-el #other-export=\"{name}\">\nI'm not sure what to do with this.  In the future, I'd like to replace can-value with just:\n<input value=\"{name}\"/>\nWith this, there's currently no \"meta\" way of providing the name of the attribute that should be two way bound.  Although, this would be interesting.\nFor example, perhaps:\n<input value=\"{| {{#contact}}contact.{{/contact}}name |}\">\nWould let you pass a renderer's output value as the property to be two-way bound.\nUnfortunately, I don't think this is something we can support in 2.3.  Can-value was never intended to work this way.  Instead, it would be good to find a work around.\n. @dylanrtt how about instead of:\n<input type=\"text\" can-value=\"{{#contact}}contact.{{/contact}}name\">\nWe support a [] operator.  Letting you write:\njs\nviewModel: {\n  nameUpdateProperty: function(){\n    return ( this.attr(\"contact\") ? \"contact.\" : \"\")+\"name\"\n  }\n}\n<input value=\"{[nameUpdateProperty]}\"/>\n. @dylanrtt regarding your last comment, I'm not entirely clear what you are saying:\n\nIn this case, I get the string \"{{ model }}\" instead of the value of model.\n\nAre you sure?  That seems like a bug if you do.  auto-complete won't be set to \"Person\" or  \"Car\"?\n\nbut it's not always clear just by looking at a template which attributes can be rendered with stache and which cannot because that is determined by whether they are registered with can.view.attr\n\nYes, this is why I would like to standardize on having things registered with can.view.attr always point to values surrounded with {}.  For example:\n```\nvalue=\"{key}\"\ncan-value=\"{key}\"\n(click)=\"{method(event)}\"\ncan-click=\"{method event}\"\n```\nThis way, at least by looking at a template, it would be obvious.\n. So, this wouldn't be a problem if we had something other than {{}} represent one-way binding.  Say, for instance, [] represented one-way binding.  This way, stache could render any attribute:\n<input value=\"[{{#contact}}contact.{{/contact}}name]\"/>\nThe problem is that {{}} already represents setting up a \"one-way to string\" binding when used like:\n<input value=\"{{contact.name}}\"/>\nSo, we simply wanted to make the same thing work for custom attributes, but remove the limitation of having to go to a string.  But this turns off stache processing inside custom attributes.\n. Actually, a problem with all of this:\n<input value=\"[{{#contact}}contact.{{/contact}}name]\"/>\nIs that we'd have to be writing out value=\"[contact.name]\" on the element.  Then, we'd have to read the attribute value and then change the value back.  Boo!\n. @dylanrtt well, I think we are going to propose something like angular 2.0's view binding syntaxes to fix this problem.  Fundamentally, I'd like to keep stache able to run in any attribute.  We can support this by moving the decorators from the attribute value, to the attribute name.\nI'm creating an issue for discussion.  There's lots of discussion going on starting here: https://gitter.im/bitovi/canjs?at=55f32a416fe7b2a123eb04d0\n. I'd say you should be using components 90% of the time. \nSent from my iPhone\n\nOn Jul 8, 2015, at 8:45 AM, Josh Hagins notifications@github.com wrote:\nGotcha, so I was right in thinking that Controls are more flexible in terms of behavior.\nThe equivalent of this.options for a Component would be this.viewModel, right? And any attributes set on the top-level element become members of that object?\n\u2014\nReply to this email directly or view it on GitHub.\n. They typically don't invoke methods on each other, instead they change each other's state.  After all, when a method is invoked, I'm betting you are changing state.\n\nUsing components requires changing how you think to a less functional and more state-based approach (which is much better for testing and correctness).\nFor example, I might have a modal with a \"visible\" state like:\n<my-modal visible>\nA parent component can connect to it and toggle it with it's own state like:\n<my-parent>\n  <button can-click=\"{saveItem}\">Save</button>\n  <my-modal {{#showingModal}}visible{{/showingModal}}>\n    Are you sure?\n    <a can-click=\"{hide}\">X</a>\n  </my-modal>\n</my-parent>\n``` js\ncan.Component.extend({\n  tag: \"my-parent\",\n  viewModel: {\n    saveItem: function(){\n      this.attr(\"showingModal\", true)\n    }\n  }\n});\ncan.Component.extend({\n  tag: \"my-modal\",\n  viewModel: {\n    define: {\n      visible: {\n        type: \"htmlbool\"\n      }\n    },\n    hide: function(){\n      this.attr(\"visible\", false)\n    }\n  }\n});\n```\n(closing b/c this isn't a bug, but feel free to keep asking questions related to this topic here).\n. @mickmcgrath13 I will often use a can.view.tag or can.view.attr to setup a can.Control for things that extend the DOM in some way.\nFor example @cklanac had some functionality where once an item was scrolled into view, it would mark itself as read.\nOne way to accomplish this would be to let user add a visible-able attribute on any element and register event handlers on any children you want to know when they have been scrolled into view:\n<ul visible-able>\n  <li (visible)=\"{markAsRead}\">\n  <li (visible)=\"{markAsRead}\">\n\n(visible) is the same as writing can-visible\n\nI would implement this something like:\n```\nVisibleable = can.Control.extend({\n  \"scroll\": function(){\n    ... figure out what just became visible ... \n   newVisibleElements.trigger(\"visible\")\n  }\n});\ncan.view.attr(\"visible-able\", function(element){\n  new Visibleable(element)\n})\n```\nI still mostly use templates to wire things up.  I just use controls for low-level things like this.\n. It would not.  We don't document these errors.\n. @akagomez can you submit a pull request for this?  Thanks!\n. Can you create a test like the ones listed here:\nhttps://github.com/bitovi/canjs/blob/master/component/component_test.js#L1519\nhttps://github.com/bitovi/canjs/blob/master/component/component_test.js#L1562\nhttps://github.com/bitovi/canjs/blob/master/component/component_test.js#L1612\nThese test potential memory leaks around \n. Can you attach them? There is almost always a way to sniff out a memory leak. \nSent from my iPhone\n\nOn Jul 11, 2015, at 1:39 PM, Guido Smeets notifications@github.com wrote:\nThose tests won't work. The dom nodes are detached, so they're not reachable from code. That means they're not available through the can.view.nodeLists.\nI've done some more testing, and it seems I'm getting 1 leaking document fragment per component that has a content tag. And all the contents in it leaks as well.\nDoesn't matter if I instantiate them once of a million times. Luckily that means the problem is less severe than I thought. :)\n\u2014\nReply to this email directly or view it on GitHub.\n. @gsmeets anyway you can make a test?  Thanks!\n. Is it possible you are looking at the document fragment and elements created and used by the templates?\n\nI can't seem to identify any other elements besides those.\n. Changing the test to:\n```\n<!DOCTYPE html>\n\n\n\n\ntest\n\n<script>\n\n    steal(\"can/component\",\"can/view/stache\", function () {\n        can.Component.extend( {\n            tag: \"mem-leak\",\n            template: can.stache(\"<p>test3<content /></p>\")\n        } );\n\n\n\n\n        $( document ).one( \"click\", function () {\n\n\n            for(var i = 0; i < 1000; i++) {\n                var template = can.stache( \"<mem-leak>test4<label>abc</label></mem-leak>\" );\n                $( \"div\" ).append( template( { test: \"test2\" }, {} ) );\n            }\n\n\n            $( document ).one( \"click\", function () {\n                $( \"div\" ).empty();\n            } );\n        } );\n    } );\n</script>\n\n\n\n```\nI see:\n\nWhich is what I expect.  So it doesn't seem like there is a leak.\n. So, I believe this is important for HTML like:\n<li>First\n<li>Second\nThis way, you don't have to close all your <li>s.\nSeems like this code got pushed and might have found its way into 2.2.7.  Hopefully it won't cause weird problems for anyone.\n. Weird. What the heck was I looking at?\nSent from my iPhone\n\nOn Jul 28, 2015, at 7:58 AM, Juan Orozco notifications@github.com wrote:\nWhew. Freaked out for a sec. Nope, it still works like you said: https://github.com/bitovi/canjs/blob/master/view/parser/parser.js#L97\nTo your point, though, if I were to hand write HTML like\nFirst\nSecond\nthe browser would attempt to self close them on it's own (sometimes?). But even if it doesn't, I kinda feel like Stache should just render what I give it, as broken as my template could be.\nIf the plan for Stache is to continue with auto-closing tags then it will need to process more than just inline vs block. There should be checks for all the content categories and their exceptions. That just sounds like a lot of maintenance to me, though. I mean, it would be cool but a lot of work.\nThe other option is for Stache to render what I give it and let the browser handle the broken parts.\n\u2014\nReply to this email directly or view it on GitHub.\n. HTML like:\n\n<li>First\n<li>Second\nis valid html.  We should handle it appropriately.\n. it would.  Currently, inline elements like\n<span>First\n<span>Second\nGets turned into:\n<span>First</span>\n<span>Second</span>\nThis would probably change it to something more like:\n<span>First\n<span>Second</span></span>\n. Are you sure bindings are setup? I can't think of a mechanism that would do this. Afaik, static values don't call can.__observe. \nSent from my iPhone\n\nOn Jul 9, 2015, at 2:50 AM, Alex notifications@github.com wrote:\nSometime models/maps object may also contain attributes with static (for example string) data, that is not supposed to change during app lifecycle.\nWhen such attributes are used in stache templates unnesessary bindings are created. I think this can affect perfomance in some way, is it possible to get rid of such exessive bindings in templates? Or it is not woth to bother about it?\n\u2014\nReply to this email directly or view it on GitHub.\n. You can use the define plugin. type: \"*\"\n\nSent from my iPhone\n\nOn Jul 12, 2015, at 5:02 AM, Guido Smeets notifications@github.com wrote:\nI have the same issue. I'm pulling some data from the server for some sort of logging timeline, and it generates 7K cid's (compared to 2.5K from the rest of the page) while it doesn't have to be live at all. Was wondering the same thing as whitecolor.\n\u2014\nReply to this email directly or view it on GitHub.\n. @whitecolor you can't have nested type definitions inside something with type: \"*\".  So:\n\n```\nname: {\n        type: '*',\n        value: {\n           first: '',\n           last: ''\n        }\n }\n\n```\nwont work.  The reason is that a map needs to be created for things like default properties to work in the first place.\nHowever, you can setup the object yourself in a setter:\nname: {\n  type: '*',\n  set: function(nameObj){\n    nameObj.first = nameObj.first || \"\";\n    ...\n    return nameObj;\n  }\n}\nclosing b/c \"*\" should provide a good enough solution for most of these problems.\n. I miss-read your code.  That should work, but that {first: '', last: ''}object would be shared by every instance of that map.  \nWhat do you mean by:\n\nAn I want this props to be out of live binding. But I a may want some other props be live binded so I have to use can.Map, not simple object or can.Construct for 'Person' class.\n\nwhat is  \"this propos\"?\n\n'*' can only prevent live bindings for \"nested\" properties like in this case {{name.first}}, but it can not prevent live binding of {{name}} property it self or {{age}} property that are directly on can.Map instance.\n\nYes, that is correct.  But I think that creating a binding of name or age is fine.  Otherwise, don't create a map in the first place if you don't want all 1st level properties to have bindings.\nThe only other alternative is to create a stache helper that prevents binding:\n{{~\"age\"}}\njs\ncan.stache.registerHelper(\"~\",function(prop, options){\n  return options.context[prop]\n})\n. Because live-binding is often less expensive then creating the observables. You aren't probably saving much time with this. \nSent from my iPhone\n\nOn Jul 13, 2015, at 2:34 PM, Alex notifications@github.com wrote:\nWhy not include it in core? Could be useful.\n\u2014\nReply to this email directly or view it on GitHub.\n. I'm betting this is fixed by #1803.  cc @daffl \n. Reopening b/c I don't think this is a bug.  I think:\n\njs\nvar c = can.compute(32);\nc.bind('change', can.noop);\nc.unbind(); // no error\nis actually more of a bug.  I think it should either throw an error or actually tear down all event handlers.  calling .unbind() is not valid.\n. Closing for: https://github.com/canjs/can-compute/issues/8\n. This error can and has served as a good warning that something is wrong. Are we sure we want to remove it?\nSent from my iPhone\n\nOn Jul 12, 2015, at 11:15 PM, Chris Gomez notifications@github.com wrote:\nAn error is thrown if unbind is called on a compute that has no bindings.\nThis PR addresses the issue by returning early when __bindEvents is falsy, as is done in event.js here: https://github.com/bitovi/canjs/blob/master/event/event.js#L196-L198\nCloses #1779\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/bitovi/canjs/pull/1780\nCommit Summary\nOnly attempt unbind when __bindEvents is defined\nFile Changes\nM util/bind/bind.js (3)\nPatch Links:\nhttps://github.com/bitovi/canjs/pull/1780.patch\nhttps://github.com/bitovi/canjs/pull/1780.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. I'd want an error thrown for that case. \n\nSent from my iPhone\n\nOn Jul 13, 2015, at 6:24 AM, Chris Gomez notifications@github.com wrote:\nI can't imagine we'd want to throw that error for the case I outlined.\nWhat others exist? Can you think of some off hand?\n\u2014\nReply to this email directly or view it on GitHub.\n. Calling unbind without arguments is invalid. Calling unbind that doesn't actually unbind is invalid. \n\nI've never been a fan of how jQuery swallows errors. I don't think we should do it too. \nSent from my iPhone\n\nOn Jul 13, 2015, at 6:24 AM, Chris Gomez notifications@github.com wrote:\nI can't imagine we'd want to throw that error for the case I outlined.\nWhat others exist? Can you think of some off hand?\n\u2014\nReply to this email directly or view it on GitHub.\n. Maybe is misunderstood what you are trying to do. Removing the error is different then making it possible to not pass an event handler and have all handlers removed. \n\nSent from my iPhone\n\nOn Jul 13, 2015, at 7:42 AM, Chris Gomez notifications@github.com wrote:\nMaybe there's a better alternative to my use case then. How I can I remove all bindings from a compute?\n\u2014\nReply to this email directly or view it on GitHub.\n. Looks good.  @akagomez anyway you can resolve the merge conflicts, make sure travis passes, and merge this into master?\n. @akagomez cc @daffl I think I misunderstood what this pull request does.  @akagomez can you confirm that it does not help actually remove all event bindings?  If this is the case, I still don't understand why this is useful.  An error is useful.\n. Currently, there's no way of doing this.  It might be possible to create a scope with a property.  For example:\n\njs\nnew can.view.Scope( child, parent, \"foo\")\nThis would mean child is the foo property of parent.\nHowever, this is going to get more complex with indexes which change.  You might be able to get the \"@index\", but it would be tricky.\n\nJust prior to submitting the form the entire root model is recursively validated. Individual components are bound to submodels. What I'm currently doing is re-evaluating every component individually as well, if I detected some error, but that's not that clean of a solution.\n\nWhy are you \"evaluating\" components?  Typically, validation can be done in the model layer and has nothing to do with a component.  Could this be done?  If not, can you go into detail how and why you are doing validation the way it is being done?  Thanks.\n. @gsmeets @Macrofig has been working on validations / error handling in CanJS.\nYour use case is needs some feature that I've been thinking about for a while, but never had a use case.  Thanks for giving me one!\nI think the solution to your problem is the ability to create a compute for a map attribute that will also contain any errors associated with that map attribute.\nFor instance, say I could do something like:\n``` js\nPerson = can.Map.extend({\n  define: {\n    name: {\n      validate: {\n        required: true\n      }\n    }\n  }\n});\nvar dude = new Person();\ndude.attr('errors') //=> {name: [\"name is required\"]}\n```\nI'd like to be able to create a compute that includes name's errors:\n```\nname = dude.compute('name');\nname() //-> undefined\nname.errors() //-> [\"name is required\"]\nname(\"Guido\");\nname.errors() //-> []\n```\nWith this, errors can exist with the value of a compute.  I think there's an issue for this.  I'll try to find it.\n. This was the issue: #173\n. keeping this issue closed.  I might reopen 173.\n. It does contain more then helpers.  I really don't have a good name for this.  For now, we might pass it as helpers and options but don't document it until 3.0.  With 3.0 we need to decide what the names of these things are.  Personally, I'm not sure the \"helpers\" should even exist.  It should just be something on the root of every template ... but on the normal scope chain.  No reason to have 2.\n. Thanks for letting us know this.\nAn array of top-level nodes can't be passed to appendChild so we should still return a fragment.\n. We can use jQuery.parseHTML.  The domManip being made private is more of a problem.\n. Closing for the changes in 3.0.\n. I believe we have already made this fix.  @chasenlehara ?\n. Duplicate of #1654\n. @gregfleury thanks for positing!  What do you mean \"format attr as an integer\"?\nDo you mean it will return the attribute as a number?\nIf so, shouldn't elements.getAttr be doing the type conversion?\n. @gregfleury can you let us know what causes that error? Some code that will show it?  We need to add a test to fix this and I'm not sure what that test looks like.\n. @nlundquist did you look into this?  Thanks!\n. We should feature detect if value is in the element.\n\"value\" in el\nSent from my iPhone\n\nOn Jul 29, 2015, at 9:22 PM, Nils Lundquist notifications@github.com wrote:\nI've answered my own question regarding 'input.value' vs 'input.setAttribute(\"value\", ...)'. It's a quirk of the DOM specs that I was unfamiliar with. For text input types, the HTMLInputElement 'value' property is the current value of the component, while the 'value' attribute is mapped to the defaultValue property. The defaultValue property, when changed, updates the value property, but of course not vice versa.\nSee http://zvon.org/xxl/DOM2reference/Output/HTML/attribute_value_HTMLInputElement.html for an excerpt from the DOM 2 spec regarding this.\nSo for good semantic reasons we should continue to special case setting the value attribute for input elements so we correctly change the value property directly instead of the defaultValue via the attribute. For all other elements value should be treated like a normal attribute.\n\u2014\nReply to this email directly or view it on GitHub.\n. All I am suggesting is not to hard code what element types to use the value property. \n\nSent from my iPhone\n\nOn Jul 30, 2015, at 12:13 AM, Nils Lundquist notifications@github.com wrote:\nThat couldn't be the only change however? The core issue is that an integer type is returned unexpectedly from attr.get, which should always return a string. If that were the only change an integer type could still be set / returned on, for example, an li element reproducing the issue at hand. If I'm understanding you correctly. This JSBin demos the issue I'm thinking of http://jsbin.com/jayetogafu/1/edit?html,js,console\n\u2014\nReply to this email directly or view it on GitHub.\n. Why does it break mootools?  I'd happily accept a pull request.  But 3rd party mootools library support isn't priority for us right now.  If you are interested in solving, let me know and I'll reopen.\n. This isn't possible given how scope currently works.  Either something is in scope or it is not.  Anything in the scope can be accessed.\n\nSo, there's not a way to put a viewModel in the scope, but only have certain parts accessible. \nIs there a specific use case you have for this?\nAlso, what would this look like?\n. @whitecolor thanks for your suggestion.  \nPreventing scope from leaking, especially when used with #REFERENCE attributes does \"allow only specific attributes to be propagated\". \nUnfortunately, without a use case or a proposed API, this isn't going to be a priority.  If this is something you'd like to see land in the framework, please create a proposed API to enable this.  Thanks!\n. > In general, does preventing scope leaking tend to improve performance?\nNot really.  I've never seen scope lookup be the dominate part of rendering.  I suppose it could be expensive if you had a lot of lookups for values that were initially undefined.\n. I'm closing this for now for lack of a specific proposal.\n. I have been thinking about that, but then noticed that it's deprecated in angular. Any idea why they did that?\nSent from my iPhone\n\nOn Jul 22, 2015, at 1:16 PM, dylanrtt notifications@github.com wrote:\nSometimes it's necessary for the Component's tag to be removed. For example, if I want a separate view model for each row of a table (partial does not suffice), using a Component presents a problem because the browser doesn't like random tags within a table.\nhttp://jsbin.com/zavozozowe/1/edit?html,js,output\nAngular has the replace:true option in directives that results in the tag being removed. CanJS should have this too.\n\u2014\nReply to this email directly or view it on GitHub.\n. Mixing in would be possible by doing the following:\n\nOn a high-level, it means creating an additional param for can.view.attr which will indicate it should callback attrHandler with the subtemplate option normally available on tagData.\njs\ncan.view.attr(\"something-something\", function(el, attrData){\n  attrData.subtemplate //-> a renderer function\n}, true)\nBut to make this work, stache.js will have to callback those registered attr helpers with a subtemplate.\ncan.view.tag already does this.  For instance, when the > is found in a starting tag end is called.  If it's part of a custom element, a new subsection is started here.\nLater, when that custom element's closing tag is found, it ends the subsection and sets up a callback to the can.view.tag handler here.\nYou would need to do something similar for attributes.  When a custom attribute is found that code would need to see if it's a custom attribute that expects the renderer.  If it does, it should mark that that a subsection should be started when end is called.  That same marking would probably indicate that the subsection should be ended at close.  And, somehow, once the subsection is closed and the renderer is created, it should be available when calling back the attr handler.\nI think @whitecolor has wanted this for a while too.  \nIt's not actually very hard if you understand this code.  But it's some of the hardest code in CanJS.  Let me know if you'd like to pair on it.\n. @whitecolor @dylanrtt let me know if either of you are interested in hacking on this.  I added details on how to accomplish it.\n. Closing for: https://github.com/canjs/can-stache/issues/15\n. I don't think this is valid. We can fix it, but the #if should go on the outside of the whole attribute. \nSent from my iPhone\n\nOn Jul 22, 2015, at 5:12 PM, Alex notifications@github.com wrote:\nin latest minor pre 2.3 code:\n\ncauses an error:\nUncaught TypeError: Cannot read property 'compile' of undefined .../node_modules/can/view/stache/text_section.js 29 TypeError: Cannot read property 'compile' of undefined\nit works in 2.2.6\n\u2014\nReply to this email directly or view it on GitHub.\n. We turned off processing in can.view.attrs to make it so we can switch between single binding and two way binding. \n\nSent from my iPhone\n\nOn Aug 20, 2015, at 7:13 AM, David Luecke notifications@github.com wrote:\nI'll have a look next week. If this worked in 2.2 we should probably find out what changed.\n\u2014\nReply to this email directly or view it on GitHub.\n. To be clear, a dynamic custom attribute was never intended to work. Just a happy accident. So it's a gray area if this is a bug or regression. \n\nHowever, we can still make it work by allowing can-value to make the attribute a template, running the template, and seeing the result. \nSent from my iPhone\n\nOn Aug 26, 2015, at 1:45 PM, beno notifications@github.com wrote:\nOK, thanks for the explanation, I get it now.\nUnfortunately, I don't think there's anything you can do within the context of your app to fix this without adding unnecessary complexity.\nSo there is no way to have any kind of dynamic custom attribute? That is quite the regression, don't think I have ever encountered something like this before. Besides, doesn't a 1-way vs 2-way binding only make sense in can-value attributes?\n\u2014\nReply to this email directly or view it on GitHub.\n. I didn't want to make it part of component because other things can have viewModels. I want this to work for them as well. \n\nSent from my iPhone\n\nOn Aug 26, 2015, at 12:45 PM, dylanrtt notifications@github.com wrote:\n@beno This only applies to custom attributes defined with can.view.attr which I've brought up in basically a duplicate issue here.\nWhat basically happens now is the can.view.attr callback just receives a string before processing. This is necessary to make the new references bindings work because the #-prefixed attributes need to see the raw string to determine whether to hook up a 1-way or 2-way binding. This probably would have been avoided if the references bindings were part of can.Component instead of a custom attribute pattern.\nThe probable resolution would be to modify existing custom attribute callbacks, particularly can-EVENT, to do the processing internally.\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes, but I think we could make \"{{#mobile}}touch{{else}}click{{/}}\" work too. \n\nSent from my iPhone\n\nOn Aug 26, 2015, at 3:16 PM, Matthew Phillips notifications@github.com wrote:\n@justinbmeyer can't we just check for {{foo}} and then lookup foo in the scope?\n\u2014\nReply to this email directly or view it on GitHub.\n. @whitecolor I don't think 2.3 supports this yet.  I never changed the behavior of custom attributes to not be processed.  However, reverting this change should be possible now.  Please revert it and let us know.  It would be good to get this in 2.3 while there's still time.  Thanks!\n. Did you try reverting? Does it work?\n\nSent from my iPhone\n\nOn Oct 27, 2015, at 1:27 PM, Alex notifications@github.com wrote:\nWhat about this?\n\u2014\nReply to this email directly or view it on GitHub.\n. A few comments previous, I mentioned trying to revert the change that custom attrs are not processed. \n\nSent from my iPhone\n\nOn Oct 27, 2015, at 2:30 PM, Alex notifications@github.com wrote:\nDid you try reverting? Does it work?\nWhat do you mean?\n\u2014\nReply to this email directly or view it on GitHub.\n. a test will speed up the process of getting this fixed.  What was the error?\n. @beno thanks!\n. @whitecolor what was the error you saw when you tried the above?  This isn't a super high priority fix for us.  We have it slated for 2.3.2.  But there's 20 or so other issues in this release.  Any help you can give will be greatly appreciated.\n. @whitecolor I changed the code, got no errors, and all tests passed, including the one submitted by @beno .  Can you confirm that you actually got an error?\n. This behavior is only added when the list is bound to. Otherwise a memory leak would be present. \n\nThis isn't a bug. \nIn an app, you would almost always bond to the list. If you use templates to render it, it is being bound to. \nSent from my iPhone\n\nOn Jul 25, 2015, at 1:05 PM, Caleb Cox notifications@github.com wrote:\nThe can.Model.List documentation says, \"When you destroy a model, if it is in that list, it will automatically be removed from the list.\" However, this is not working for me. For example in the following code, it reports that there are still three items in the list, when there should only be two (JSFiddle).\nvar Model = can.Model.extend('Model', {\n    destroy: function(id, params, success, error) {\n        return jQuery.Deferred().resolve({}).promise();\n    }\n}, {});\nvar list = new Model.List([new Model({ id: 1 }), new Model({ id: 2 }), new Model({ id: 3 })]);\nlist.attr('0').destroy().then(function() {\n    alert('There are ' + list.length + ' models in the list');\n});\nHowever, if I call list.bind('remove'); immediately after creating the list, it reports that there are two models in the list, just as expected. I am not familiar with the CanJS code base, but in my preliminary debugging, it looks like in the first case, the bubble rules are not being set up for the model list.\n\u2014\nReply to this email directly or view it on GitHub.\n. Closing, let me know if this makes sense.\n. This looks good to merge once travis passes.\n. Does this break if the inline template is stache?\n\nsteal(\n\"./date-picker.stache!\",\n//global\n\"can\",\nfunction (template, can) {\n    can.Component.extend({\n        tag: \"date-picker\",\n        template: can.stache(\"{{modifiedName 'randomName'}}\"),\n        scope: {},\n        helpers:{\n            modifiedName: function(name){\n              name = typeof name === \"function\" ? name() : name;\n              return \"Custom \" + name;\n            }\n        }\n    });\n}\n);\n. So, I created the following test, which passes.  Can you confirm that if it works for you?\n```\ncan.Component.extend({\n    tag: \"call-helper\",\n    template: can.stache(\"{{modifiedName 'randomName'}}\"),\n    scope: {},\n    helpers:{\n        modifiedName: function(name){\n          name = typeof name === \"function\" ? name() : name;\n          return \"Custom \" + name;\n        }\n    }\n});\nvar frag = can.stache('')();\nconsole.log(frag.firstChild.firstChild.nodeValue);\n```\nWhat version of CanJS are you using?  I think this works in the latest versions.\n. The actual test in case someone needs it:\n```\n    test('template helpers passed to template (#1808)', function(){\n    can.Component.extend({\n        tag: \"call-helper\",\n        template: can.stache(\"{{modifiedName 'randomName'}}\"),\n        scope: {},\n        helpers:{\n            modifiedName: function(name){\n              name = typeof name === \"function\" ? name() : name;\n              return \"Custom \" + name;\n            }\n        }\n    });\n\n    var frag = can.stache('<call-helper></call-helper>')();\n    equal(frag.firstChild.firstChild.nodeValue, \"Custom randomName\");\n\n});\n\n```\n. What do you mean by pre-render a component into the DOM?\nSent from my iPhone\n\nOn Jul 28, 2015, at 12:56 AM, opolyo01 notifications@github.com wrote:\nYes, your tests passing because you don't pre-render a component into the DOM. If instead of creating a fragment, you would do this --\n// var frag = can.stache('')();\n  // console.log(frag.firstChild.firstChild.nodeValue);\n  $(\"#out\").html(can.view(\"appMustache\", {}));\nWhere template is loaded from the .html file\n\n  <call-helper></call-helper>\n\nOn the side note I realized that I cannot steal('can' on its own to get access to can/stache, I also need to load a stache file. Not sure if it has anything to do with an issue.\n\u2014\nReply to this email directly or view it on GitHub.\n. I still need a breaking test case because I'm not sure what the problem is. \n\nSent from my iPhone\n\nOn Nov 7, 2015, at 1:31 PM, Gazy Mahomar notifications@github.com wrote:\nHas there been any progress on this issue? I'm having a similar issue, but I'm using RequireJS instead of Steal. If I register the helpers with can.stache.registerHelper, everything works fine. If I add them to the helpers property of a new Component, they don't work.\n\u2014\nReply to this email directly or view it on GitHub.\n. Here's a jsbin that points to latest: http://jsbin.com/tunutin/edit?html,js,output\n. Closing.  @gmahomarf I'll reopen if you can get me a failing example. Thanks!\n. It doesn't look like the docs are formatted right.  I can show you how to run them through documentjs.  Just ping me on gitter. \n. I'm not sure what you mean.  Do you mean:\n\n```\nvar MyMap = can.Map.extend({\n  define:{\n   '*': {serialize: false}\n  },\n  someAttr: true\n})\nnew MyMap().serialize().someAttr //-> true\n```\n?\nIf so, yes this is a bug.\n. It can load with steal in node, or browserify using require. \nIt does not load in node with a normal require call without having a DOM present in node.\nIf you look in dist/cjs you'll find the commonjs-ified distributable. \nSent from my iPhone\n\nOn Aug 2, 2015, at 10:28 PM, Thomas Sieverding notifications@github.com wrote:\nIn the latest release, 2.2.7, it's stated that CanJS was updated with the ability to load in NodeJS, however it's not obvious how to load it in NodeJS, nor are there any examples or documentation.\nSimply installing can@2.2.7 and using require within Node REPL results in:\nReferenceError: steal is not defined\nAssuming that CanJS can in fact be loaded into NodeJS, however indirectly via a loader, it would be really great to see a working example of how to do this, as well as updated documentation\n\u2014\nReply to this email directly or view it on GitHub.\n. We will. You can check out donejs.com for right now. All of this is not released yet. I've also got a github.com/bitovi/bitballs app using this stuff. \n\nSent from my iPhone\n\nOn Aug 2, 2015, at 11:15 PM, Thomas Sieverding notifications@github.com wrote:\nI've had issues loading it with StealJS as well as when loading the CommonJS distributable. For what it's worth, I'm also having tests fail on projects that use CanJS, such as can-ssr.\nJust looking at how can-ssr loads, there's a lot of configuration going into loading with StealJS, so it would be good to have a tutorial for doing this regardless.\n\u2014\nReply to this email directly or view it on GitHub.\n. CanJS is many things.  What part of CanJS?  Core, every module, those that work w/o a DOM?\n\nWhat end goal are you trying to accomplish?\n. So, our focus right now is on making everything work with DoneJS. DoneJS is designed to be a one stop solution because making things work with everything is super difficult. It's been painful enough making CanJS work in browserify/amd/systemjs. To make CanJS work in browserify, I had to submit a change to browserify. As node lacks some form of mapping or patching construct, something very different from the others will need to be done. CanJS needs a DOM. We can ensure one loads with stealjs. \nOnce that's done, making all of these auxiliary projects work too will take time. \nI'm not opposed to it, but someone else is going to have to do the heavy lifting. \nIf you want to meet to go over how this can be done, I'm happy to show you. Thanks!\nSent from my iPhone\n\nOn Aug 3, 2015, at 6:43 PM, Thomas Sieverding notifications@github.com wrote:\nWell, there are several use cases I envision here, mainly around doing server side plugins. For example, broccoli-can-stache would benefit from being able to use can's built in template parsing. can-ssr would benefit from being able to load can without all of the ceremony.\nThe problem, as it stands now, is that a lot of aspects of CanJS, and more specifically DoneJS, are built around a one stop solution for everything, and encompass a seriously large number of tools that would otherwise be independently valuable in their own right, and more palatable to include in a standalone fashion. This limits the ability for outside developers to build their own tools for new purposes in mind, or to incrementally shift over.\nFor example, StealJS on Node is a very recent thing, and there are a lot of projects that aren't going to abandon their existing build system or otherwise don't feel comfortable making the transition for one reason or another, but would appreciate being able to use optimized templates, or alternatively to use optimized AMD bundling with RequireJS. Say for example you have a Grunt/Broccoli build pipeline, and are using SASS as a CSS pre-processor; you're probably not going to want to use StealJS because it only supports LESS.\n\u2014\nReply to this email directly or view it on GitHub.\n. Closing.  If someone wants to pair on this, let me know and I'll help make it happen.  But right now, it's not priority to make happen.\n. Seem to have been fix: http://jsbin.com/fubeli/edit?html,js,console,output\n. Thanks for the reminder. Ill hopefully get to this today. \n\nSent from my iPhone\n\nOn Aug 5, 2015, at 2:25 AM, Alex notifications@github.com wrote:\ndocs are not genearted on windows because names contain |\n\u2014\nReply to this email directly or view it on GitHub.\n. Closing for: https://github.com/bitovi/documentjs/issues/104\n. Closing for: https://github.com/bitovi/documentjs/issues/104\n. Breaking this down a bit:\n\nUser initiates a change to the application route to go to another page\nIf they click a link, we are intercepting it, so we have the ability to prevent the URL from changing, although it might be difficult to wire up correctly.\nIf they click the back button, I don't think there's a way to prevent the url changing.  But, we should investigate.  Perhaps a beforeonunload event is fired, but I doubt it.  If there isn't a way to prevent the url from changing, we need to prevent appstate from committing the change, and if the change is prevented, rolling back the url (a replace state) without causing any other can.route property changes.\nBefore changing the route DATA the application checks to see if a model is dirty.\nI propose a \"changing\" event that could be paused, resumed and canceled like:\njs\ncan.route.bind(\"changing\", function(ev){\n  if( model.isDirty() ) {\n    ev.pause();\n   $.modal(\"do you want to stay on the page\", {\n     yes: function(){\n       ev.cancel();\n     },\n     no: function(){\n       ev.resume();\n     }\n   })\n  }\n});\nFor this to work, an async form of dispatch will be needed.  I think something like including a 4th argument will make it async:\ncan.dispatch.call(target, event, [ args ] , defaultBehavior)\ncan.Map would use it internally like:\njs\ncan.dispatch.call(this, \"changing\", [ attr, how, newVal, oldVal], function(){\n   // code that actually sets the value here\n})\nI believe you'd have to overwrite can.Map.__set and can.dispatch in a plugin.\n. Breaking this down a bit:\nUser initiates a change to the application route to go to another page\nIf they click a link, we are intercepting it, so we have the ability to prevent the URL from changing, although it might be difficult to wire up correctly.\nIf they click the back button, I don't think there's a way to prevent the url changing.  But, we should investigate.  Perhaps a beforeonunload event is fired, but I doubt it.  If there isn't a way to prevent the url from changing, we need to prevent appstate from committing the change, and if the change is prevented, rolling back the url (a replace state) without causing any other can.route property changes.\nBefore changing the route DATA the application checks to see if a model is dirty.\nI propose a \"changing\" event that could be paused, resumed and canceled like:\njs\ncan.route.bind(\"changing\", function(ev){\n  if( model.isDirty() ) {\n    ev.pause();\n   $.modal(\"do you want to stay on the page\", {\n     yes: function(){\n       ev.cancel();\n     },\n     no: function(){\n       ev.resume();\n     }\n   })\n  }\n});\nFor this to work, an async form of dispatch will be needed.  I think something like including a 4th argument will make it async:\ncan.dispatch.call(target, event, [ args ] , defaultBehavior)\ncan.Map would use it internally like:\njs\ncan.dispatch.call(this, \"changing\", [ attr, how, newVal, oldVal], function(){\n   // code that actually sets the value here\n})\nI believe you'd have to overwrite can.Map.__set and can.dispatch in a plugin.\n. js\ncan.dispatch.call(target, event, [ args ] , defaultBehavior, cancelBehavior)\n``` js\nif(this.__bindEvents.changing) {\ncan.dispatch.call(this, \"changing\", [ attr, how, newVal, oldVal], function(){\n     // code that actually sets the value here\n  }, function(){\n     can.dispatch(this, \"change-prevented\", [ ]);\n  })\n} else {\n  // do normal stuff\n}\n```\njs\ncan.route.data.bind(\"change-prevented\", function(){\n  // set url back to what it was\n})\n. js\ncan.dispatch.call(target, event, [ args ] , defaultBehavior, cancelBehavior)\n``` js\nif(this.__bindEvents.changing) {\ncan.dispatch.call(this, \"changing\", [ attr, how, newVal, oldVal], function(){\n     // code that actually sets the value here\n  }, function(){\n     can.dispatch(this, \"change-prevented\", [ ]);\n  })\n} else {\n  // do normal stuff\n}\n```\njs\ncan.route.data.bind(\"change-prevented\", function(){\n  // set url back to what it was\n})\n. info: https://groups.google.com/a/chromium.org/forum/#!msg/blink-dev/tW6Lr5nA1pY/BOedStgP2pEJ\n. info: https://groups.google.com/a/chromium.org/forum/#!msg/blink-dev/tW6Lr5nA1pY/BOedStgP2pEJ\n. Implemented in 2.3 this way.\n. Implemented in 2.3 this way.\n. @dylanrtt Thanks for your input!\nIt's confusing in my opinion if we don't do this. It took me a few minutes to understand why my model attribute wasn't set when I did something like:\n<select can-value=\"{game.round}\">\n  <select value=\"1\">1</select>\n  <select value=\"2\">2</select>\n  <select value=\"3\">3</select>\n  <select value=\"4\">4</select>\n</select>\nSometimes, because I wasn't selecting a value, game.round would be undefined.  But when I did select 2, 3, 4, suddenly my game had a round. \nIf you looked at the form I was submitting, it certainly looked like the game should be round 1 to the user.\nTwo way binding does get hate for confusing side effects, however, I think the 2 way-ness of 2-way binding is something we should maintain.  If the value of the  is 1, so should game.round.  This way it's actually doing 2-way binding.\n. @dylanrtt Thanks for your input!\nIt's confusing in my opinion if we don't do this. It took me a few minutes to understand why my model attribute wasn't set when I did something like:\n<select can-value=\"{game.round}\">\n  <select value=\"1\">1</select>\n  <select value=\"2\">2</select>\n  <select value=\"3\">3</select>\n  <select value=\"4\">4</select>\n</select>\nSometimes, because I wasn't selecting a value, game.round would be undefined.  But when I did select 2, 3, 4, suddenly my game had a round. \nIf you looked at the form I was submitting, it certainly looked like the game should be round 1 to the user.\nTwo way binding does get hate for confusing side effects, however, I think the 2 way-ness of 2-way binding is something we should maintain.  If the value of the  is 1, so should game.round.  This way it's actually doing 2-way binding.\n. Btw, you can see my form here: https://bitballs.herokuapp.com/#!&tournamentId=1\nI think that form, when submitted, should have round = 1 and court = 1.\n. Btw, you can see my form here: https://bitballs.herokuapp.com/#!&tournamentId=1\nI think that form, when submitted, should have round = 1 and court = 1.\n. Ah. The first option should not be displayed. Thanks!\nSent from my iPhone\n\nOn Aug 10, 2015, at 7:05 PM, dylanrtt notifications@github.com wrote:\nIf the property is undefined, the  should probably not display the first option as being selected. As far as I can tell, that's how it worked before so you might have accidentally changed it recently when fixing live binding with dynamic select menus (#1762).\nHere it is in 2.2.6 with no displayed selected value:\nhttp://jsbin.com/mogocoteje/edit?html,js,output\nIf the blank option is not desirable then the developer should define a default and problem solved.\n\u2014\nReply to this email directly or view it on GitHub.\n. Ah. The first option should not be displayed. Thanks!\n\nSent from my iPhone\n\nOn Aug 10, 2015, at 7:05 PM, dylanrtt notifications@github.com wrote:\nIf the property is undefined, the  should probably not display the first option as being selected. As far as I can tell, that's how it worked before so you might have accidentally changed it recently when fixing live binding with dynamic select menus (#1762).\nHere it is in 2.2.6 with no displayed selected value:\nhttp://jsbin.com/mogocoteje/edit?html,js,output\nIf the blank option is not desirable then the developer should define a default and problem solved.\n\u2014\nReply to this email directly or view it on GitHub.\n. Updated the title and issue description to reflect what we should do (which is the 2.2.6 behavior).\n. Updated the title and issue description to reflect what we should do (which is the 2.2.6 behavior).\n. @pYr0x thanks for pointing that out again.  I will fix this.\n. @pYr0x thanks for pointing that out again.  I will fix this.\n. I'm going to close this and move into #2027.  In short, I'll try to make can-value work the way it used to (not updating the scope). \n\nHowever, in 2.3, using {(value)}=\"key\" will update key.  \n@dylanrtt I know you dislike this, and for reasonable reasons.  Perhaps we can come up with another syntax that avoids this?  Created an issue for discussing it here: https://github.com/canjs/canjs/issues/2050\n. I'm going to close this and move into #2027.  In short, I'll try to make can-value work the way it used to (not updating the scope). \nHowever, in 2.3, using {(value)}=\"key\" will update key.  \n@dylanrtt I know you dislike this, and for reasonable reasons.  Perhaps we can come up with another syntax that avoids this?  Created an issue for discussing it here: https://github.com/canjs/canjs/issues/2050\n. @ilyavf Once you made the change above, please feel free to merge. Thanks!\n. @ilyavf Once you made the change above, please feel free to merge. Thanks!\n. I'll take a look today. \nSent from my iPhone\n\nOn Aug 8, 2015, at 8:42 AM, Matthew Phillips notifications@github.com wrote:\nI have an element like:\n\nsetPhoneValue being a viewModel function. Previously @element.val would be called as a function but now instead the function itself is passed into setPhoneValue. I assume this is related to the new subexpression behaviors.\n\u2014\nReply to this email directly or view it on GitHub.\n. I'll take a look today. \n\nSent from my iPhone\n\nOn Aug 8, 2015, at 8:42 AM, Matthew Phillips notifications@github.com wrote:\nI have an element like:\n\nsetPhoneValue being a viewModel function. Previously @element.val would be called as a function but now instead the function itself is passed into setPhoneValue. I assume this is related to the new subexpression behaviors.\n\u2014\nReply to this email directly or view it on GitHub.\n. btw, I think:\n\n{setPhoneValue (@element.val)}\nmight work.  This is sorta the reason I think the other syntax would be better:\n{setPhoneValue @element.val()}\nBecause I think in 3.0, the only way to have a function run automatically is if you call it.  This means there will be lots of (prettyDate) and not prettyDate().\n. btw, I think:\n{setPhoneValue (@element.val)}\nmight work.  This is sorta the reason I think the other syntax would be better:\n{setPhoneValue @element.val()}\nBecause I think in 3.0, the only way to have a function run automatically is if you call it.  This means there will be lots of (prettyDate) and not prettyDate().\n. @matthewp that pull request fixes this if you need it.\n. @matthewp that pull request fixes this if you need it.\n. implemented in 2.3\n. implemented in 2.3\n. Fixed by #1889\n. Fixed by #1889\n. I just added this to can-connect. You can use it along-side can.Model.  Would you consider using that?\n. I just added this to can-connect. You can use it along-side can.Model.  Would you consider using that?\n. Travis started having problems with CanJS, that is why the build is failing. All of its tests pass.  I use have to update Travis, which I'll do later today. \ncan-connect is arguably better documented:\nhttp://connect.canjs.com/doc/index.html \nWhere can.Model has all its features merged into one construct, can-connect has many simple behaviors, each documented. It makes documenting can-connect much easier. \ncan-connect has many more features then can.Model. I'm not sure what gave you the perception that it does not. What did?\nI'm not sure what you mean by a better plugin implementation with less dependency, but that sounds like exactly what can-connect is. With the exception of its CanJS specific parts, it doesn't depend on CanJS or even jQuery.  \nSent from my iPhone\n\nOn Aug 12, 2015, at 3:11 AM, Vincze Tam\u00e1s notifications@github.com wrote:\nWell yes and no :)\nSorry for my bad english...\nI would say yes because the feature is written there, and I am willing to use any good code made by the open source community. But,\nI say no because, can-connect seems like (dont be mad at me, I had just a couple of minutes on the github site, and at the downloaded source):\nthe build is failing - and I need this for production in two weeks\nnot well documented, if I learn it from reading the codes I have to teach my colleagues, rather sending just a link to the doc page\nlooks like Its not adding fetures to can.Model, but creates another implementation, that sould be learned, and not all the features in can.js are in can-connect. Also I cant see how to implement on top of can.js. But maybe its only in my head because I cant see the big picture without proper documentation.\nI would like better a plugin implementation with less dependency\nIm sorry if my statements are incorrect, but I'm not familiar yet with can-connect, and it seems like I wont without a documentation like can.js has.\n\u2014\nReply to this email directly or view it on GitHub.\n. Travis started having problems with CanJS, that is why the build is failing. All of its tests pass.  I use have to update Travis, which I'll do later today. \n\ncan-connect is arguably better documented:\nhttp://connect.canjs.com/doc/index.html \nWhere can.Model has all its features merged into one construct, can-connect has many simple behaviors, each documented. It makes documenting can-connect much easier. \ncan-connect has many more features then can.Model. I'm not sure what gave you the perception that it does not. What did?\nI'm not sure what you mean by a better plugin implementation with less dependency, but that sounds like exactly what can-connect is. With the exception of its CanJS specific parts, it doesn't depend on CanJS or even jQuery.  \nSent from my iPhone\n\nOn Aug 12, 2015, at 3:11 AM, Vincze Tam\u00e1s notifications@github.com wrote:\nWell yes and no :)\nSorry for my bad english...\nI would say yes because the feature is written there, and I am willing to use any good code made by the open source community. But,\nI say no because, can-connect seems like (dont be mad at me, I had just a couple of minutes on the github site, and at the downloaded source):\nthe build is failing - and I need this for production in two weeks\nnot well documented, if I learn it from reading the codes I have to teach my colleagues, rather sending just a link to the doc page\nlooks like Its not adding fetures to can.Model, but creates another implementation, that sould be learned, and not all the features in can.js are in can-connect. Also I cant see how to implement on top of can.js. But maybe its only in my head because I cant see the big picture without proper documentation.\nI would like better a plugin implementation with less dependency\nIm sorry if my statements are incorrect, but I'm not familiar yet with can-connect, and it seems like I wont without a documentation like can.js has.\n\u2014\nReply to this email directly or view it on GitHub.\n. Why couldn't you navigate to the subdocumentation?\n\ncan-connect has a \"mostly\" backwards compatible can.Model so if you've started using can.Model, your code won't have to change.  Furthermore, the can/map behavior produces Maps that looks almost identical to can.Models.  Also, that is the extension that adds the isSaving method.\nPlease read this section about migrating can.Model's to can-connect:\nhttp://connect.canjs.com/doc/can-connect%7Ccan%7Cmodel.html#section_Upgradingcan_Modelstocan_connect\nHopefully you'll see it's pretty straightforward.\nI'm about to add a .findAll / .findOne alias to .getList / .get so upgrading should be even easier.\n. Why couldn't you navigate to the subdocumentation?\ncan-connect has a \"mostly\" backwards compatible can.Model so if you've started using can.Model, your code won't have to change.  Furthermore, the can/map behavior produces Maps that looks almost identical to can.Models.  Also, that is the extension that adds the isSaving method.\nPlease read this section about migrating can.Model's to can-connect:\nhttp://connect.canjs.com/doc/can-connect%7Ccan%7Cmodel.html#section_Upgradingcan_Modelstocan_connect\nHopefully you'll see it's pretty straightforward.\nI'm about to add a .findAll / .findOne alias to .getList / .get so upgrading should be even easier.\n. I added the link to the docs in github after you first pointed it out.  It's there now.\n\nMy problem is the lack of info on can.js that can.Model will be deprecated and I should use can-connect instead.\n\nTypically, we don't deprecate something until we have the fully fleshed out alternative totally ready.  I'm currently in the process of officially releasing can-connect.  Until then, I'm not going to put the deprecation notice.  I was planning on getting it done last week, but won't be able to resume it until after next week.  \nAlso, the can.Model produced by can-connect passes almost all of can.Models tests.  So there will be a version of can.Model for many, many years, to come.\nI'm just suggesting you try can-connect now because it solves your problem and will get you \"ahead\" of things.  The super-model is really useful: http://connect.canjs.com/doc/can-connect%7Ccan%7Csuper-map.html.  We've started to use it in production apps internally.  \n\nCan you verify that can.Model will be deprecated and can-connect will be the \"official\" server saving thingy for can.js?\n\nYes, I can verify this.  The goal of can-connect is to be a much better replacement for can.Model while still:\n- providing a high-fidelity backwards-compatible version.\n- providing can/map which makes a map instance that looks and works very similar to a model instance.\n\nYou should consider also implementing a isCreating, and a isUpdating function so if sbdy needs exactly know \"how\" its being saved.\n\nI was thinking about that, but you can simply combine isNew with isSaving like:\n{{#if thing.isSaving}}\n  {{#if thing.isNew}}Creating{{else}}Updating{{/if}}\n{{/if}}\nThat being said, create an issue in can-connect and I'll add them.\n. I added the link to the docs in github after you first pointed it out.  It's there now.\n\nMy problem is the lack of info on can.js that can.Model will be deprecated and I should use can-connect instead.\n\nTypically, we don't deprecate something until we have the fully fleshed out alternative totally ready.  I'm currently in the process of officially releasing can-connect.  Until then, I'm not going to put the deprecation notice.  I was planning on getting it done last week, but won't be able to resume it until after next week.  \nAlso, the can.Model produced by can-connect passes almost all of can.Models tests.  So there will be a version of can.Model for many, many years, to come.\nI'm just suggesting you try can-connect now because it solves your problem and will get you \"ahead\" of things.  The super-model is really useful: http://connect.canjs.com/doc/can-connect%7Ccan%7Csuper-map.html.  We've started to use it in production apps internally.  \n\nCan you verify that can.Model will be deprecated and can-connect will be the \"official\" server saving thingy for can.js?\n\nYes, I can verify this.  The goal of can-connect is to be a much better replacement for can.Model while still:\n- providing a high-fidelity backwards-compatible version.\n- providing can/map which makes a map instance that looks and works very similar to a model instance.\n\nYou should consider also implementing a isCreating, and a isUpdating function so if sbdy needs exactly know \"how\" its being saved.\n\nI was thinking about that, but you can simply combine isNew with isSaving like:\n{{#if thing.isSaving}}\n  {{#if thing.isNew}}Creating{{else}}Updating{{/if}}\n{{/if}}\nThat being said, create an issue in can-connect and I'll add them.\n. Also, some other uses of can-connect:\nhttps://github.com/donejs/bitballs/tree/master/public/models\n. Also, some other uses of can-connect:\nhttps://github.com/donejs/bitballs/tree/master/public/models\n. Are you using latest?  I thought this was fixed.\nhttps://github.com/bitovi/canjs/blob/master/compute/get_value_and_bind.js#L33\nand\nhttps://github.com/bitovi/canjs/blob/master/compute/proto_compute.js#L49\nshould prevent a compute from calling itself while it is being observed.\n. Are you using latest?  I thought this was fixed.\nhttps://github.com/bitovi/canjs/blob/master/compute/get_value_and_bind.js#L33\nand\nhttps://github.com/bitovi/canjs/blob/master/compute/proto_compute.js#L49\nshould prevent a compute from calling itself while it is being observed.\n. How would we be able to get the right context/scope value?\nThe only way I think you could do it would be to add it to each . If you're doing that, you might as well be binding an event handler anyway. \nSent from my iPhone\n\nOn Aug 13, 2015, at 8:20 AM, Chris Gomez notifications@github.com wrote:\nMaybe it's a stupid idea, but I'm curious if something like this could be valuable:\nvar list = can.List([0, 1, 2]);\n\n  {{#each list}}\n    {{.}}\n  {{/each}}\n\nIdeally the increment method would have the same call signature as if I had added the can-click binding directly to each .list-item element.\n\u2014\nReply to this email directly or view it on GitHub.\n. How would we be able to get the right context/scope value?\n\nThe only way I think you could do it would be to add it to each . If you're doing that, you might as well be binding an event handler anyway. \nSent from my iPhone\n\nOn Aug 13, 2015, at 8:20 AM, Chris Gomez notifications@github.com wrote:\nMaybe it's a stupid idea, but I'm curious if something like this could be valuable:\nvar list = can.List([0, 1, 2]);\n\n  {{#each list}}\n    {{.}}\n  {{/each}}\n\nIdeally the increment method would have the same call signature as if I had added the can-click binding directly to each .list-item element.\n\u2014\nReply to this email directly or view it on GitHub.\n. Yeah, but I wouldn't use that syntax.\n. Yeah, but I wouldn't use that syntax.\n. Well, maybe ... it's a bit strange.\n. Well, maybe ... it's a bit strange.\n. I'm closing unless there's a lot of other support.  I think events object is the right tool here if this kinda performance is needed.\n. I'm closing unless there's a lot of other support.  I think events object is the right tool here if this kinda performance is needed.\n. I thought this was tested. I think it should work the way you describe. \n\nSent from my iPhone\n\nOn Aug 19, 2015, at 7:57 PM, dylanrtt notifications@github.com wrote:\nIf I do the following:\nouter scope: {{parentAttr}}\n\n  light DOM: {{parentAttr}}\n\nhttp://jsbin.com/zajiloqaze/edit?html,js,output\nThe outer scope can see the value of parentAttr but the user content of my-component cannot. With leakScope:true, you could just read directly from childAttr but it's not clear where that is coming from so being able to do the above could be useful.\nI like the idea of being able to explicitly expose a component's view model to the outer context primarily because it allows you to use properties/methods of the component's viewmodel even when its defined with leakScope:false which I prefer to always do because:\n1) it forces data to be passed in explicitly which increases clarity\n2) it prevents random junk from leaking into the component's template or light DOM\nAt the very least, I think the light DOM should be able to access exported viewmodels with leakScope:false but I don't care as much about leakScope:true because I try to avoid it anyway. I originally expected it to work because in theory the light DOM would be reading directly from the outer context but I was unpleasantly surprised. :(\n\u2014\nReply to this email directly or view it on GitHub.\n. I thought this was tested. I think it should work the way you describe. \n\nSent from my iPhone\n\nOn Aug 19, 2015, at 7:57 PM, dylanrtt notifications@github.com wrote:\nIf I do the following:\nouter scope: {{parentAttr}}\n\n  light DOM: {{parentAttr}}\n\nhttp://jsbin.com/zajiloqaze/edit?html,js,output\nThe outer scope can see the value of parentAttr but the user content of my-component cannot. With leakScope:true, you could just read directly from childAttr but it's not clear where that is coming from so being able to do the above could be useful.\nI like the idea of being able to explicitly expose a component's view model to the outer context primarily because it allows you to use properties/methods of the component's viewmodel even when its defined with leakScope:false which I prefer to always do because:\n1) it forces data to be passed in explicitly which increases clarity\n2) it prevents random junk from leaking into the component's template or light DOM\nAt the very least, I think the light DOM should be able to access exported viewmodels with leakScope:false but I don't care as much about leakScope:true because I try to avoid it anyway. I originally expected it to work because in theory the light DOM would be reading directly from the outer context but I was unpleasantly surprised. :(\n\u2014\nReply to this email directly or view it on GitHub.\n. I thought this should fix it: https://github.com/canjs/canjs/issues/2029\n\nDo you have 2.3.1?\n. I thought this should fix it: https://github.com/canjs/canjs/issues/2029\nDo you have 2.3.1?\n. minor is not being used right now.  master is where everything goes until probably we start putting things in the major (3.0) branch.\n. minor is not being used right now.  master is where everything goes until probably we start putting things in the major (3.0) branch.\n. It might be a tiny bit slower to setup, but as fast or faster to update.  Very little performance implications.\n. The DOM is supposed to \"never\" throw errors.\nI think a warning is more appropriate.\n. Closing for: https://github.com/canjs/can-view-import/issues/2\n. This should be fixed with https://github.com/canjs/can-stache/issues/17 like:\n```\n  True \nFalse \n```\ncan.stache.registerConverter(\"not\",{\n  get: function(source){\n    return !source();   \n  },\n  set: function(newVal, source){\n    source(!newVal); \n  }\n});\n. Closing as can-href is deprecated.  I'll include a fix if someone submits a fix w/ a test.\n. @mjstahl @daffl is this \"closed in a branch\"?\n. It's not, but could be. I'd need to listen on attribute changes. \nSent from my iPhone\n\nOn Oct 1, 2015, at 8:51 AM, Matthew Phillips notifications@github.com wrote:\n@justinbmeyer Would this be fixed by the new binding syntax?\n\u2014\nReply to this email directly or view it on GitHub.\n. @beno Updated the test here: https://github.com/canjs/canjs/pull/2066\n. Well, I'm not a fan of this use case.  If you want the todos in your view model, you should probably add:\n\njs\ndefine: {\n  todos: {\n    value: Todo.getList.bind(Todo, {status: \"complete\"})\n  }\n}\nit's strange to have the template adding values like this I think.  I want to encourage the viewModel to run the show as much as possible.\n. @matthewp can we close this?\n. Closing for now ...\n. So is the real problem here #1866 ?\n. This has nothing to do with routing.  It has to do with child \"sections\" being notified before their parent of a change.  I'm not sure how exactly to fix the problem.\nThe example is something like the following:\n``` js\nif( page === \"foo\" ) {\n  if( action === \"view\") {\n    console.log(\"VIEW foo\");\n  }\n  if( action === \"edit\") {\n    console.log(\"EDIT foo\");\n  }\n}\nif( page === \"bar\" && action === \"edit\") {\n  console.log(\"EDIT bar\");\n} \n```\nThe problem is that the \"child section\" bindings, the ones inside page === \"foo\" like action === \"edit\" are being called back before page === \"foo\" updates.  This means that \"EDIT foo\" is shown temporarily, before page === \"foo\" fires and removes that binding.\nI'm not sure what the best fix is.  Ideally, parents would always update before children.  But for that to happen, children need to know about their parents or vice versa.\nHowever, we've removed the parent / child nodeList relationship  in most cases with can.stache to improve performance.\nA \"hack\" fix would to to not nest your if statements within components.  Make a helper that takes an page / action combo like:\n{{#onPage 'bar' 'edit'}} <page-edit/> {{/}}\nI'll think about how this can be fixed.\n. Unfortunately, the order of binding doesn't help anything.  This is because in this example the \"action\" event is fired before the \"page\" event.  So even though the outer sections are binding before child sections, the \"action\" event is still fired first.\n. One solution might be to have a special type of event binding that takes into account the ordering of the binding when dispatching.  \nEssentially, we could look at the target of everything we are about to dispatch batch events to ... and sort by when the binding took place.  It would run in O( n log n ).\nThis way, regardless if you listened to page or action ... whichever compute listened first would get that event dispatched first.  \nThis raises a question ... should the order of event.type matter in a batch?  Probably not.  It's all supposed to be one transaction.\n. So, I think my solution for #2093 can probably be re-purposed for this.  Essentially, it keeps track of updates to computes based on a \"depth\".  Computes get updated in order of their depth. The same thing can be done for this issue.  Essentially, each live-binding section compute includes the number of its parents as part of its depth value.  \nThe good thing about my solution is that it doesn't require sorting.  \nThe trick will be that this depth is different from the current compute depth (which is the number of computes a compute depends on).  A compute like {{#eq page 'foo'}} could still depend on a lot of computes, but need to be re-evaluated before a child like: {{#eq action 'view'}}.\nI'll probably release 2.3.3 w/o a fix for this issue, and then start looking how I can share the same code.\n. If we were to add this, we would follow jQuery's convention and have calling unbind() with no arguments unbind every event handler.\n. @akagomez Did you add this functionality already?  I feel like we talked about it.\n. @akagomez you didn't work on making .unbind() unbind all event handlers?  I thought we looked at this and it was already working.\n. Closing for: https://github.com/canjs/can-event/issues/4\n. Do this in minor.\n. totally different now in 3.0.\n. Interesting.  I assumed it work would b/c readonly is configured here: https://github.com/bitovi/canjs/blob/minor/util/attr/attr.js#L47\n. @alexisabril this is probably pretty simple.  Although the test should probably take place in can/util/attr.  I would start there to make sure it's doing what it should be doing.\n. #1699 should be taken into account.\n. Chris said he can port the fix to 2.2.8\n. @pYr0x It will be in 3.0. But we can't do that until then.  Perhaps we could make some type of configuration.  If you are interested in making that happen, let me know and I'll re-open the issue.\n. Can you elaborate on what this means?\n. https://github.com/canjs/can-event will now house it.\n. Certainly a bug.\nSeems like there are 2 problems.  First, when setVal is called, it's not dispatching in a batch.\nBut the more important problem is likely when this.attr('foo') is being called ... it's actually setting up a binding on two things:\n1. the \"foo\" property, which is correct.\n2. the internal compute of the \"foo\" property, which is incorrect.  This is happening here: https://github.com/bitovi/canjs/blob/minor/map/map.js#L259\nThe solution is probably to change:\nhttps://github.com/bitovi/canjs/blob/minor/map/map.js#L259\nTo something like:\njs\ncan.__notObserve(function(){\n  computedAttr.compute();\n})\nBut, I would avoid re-creating the function each time and have a helper like:\njs\nvar readButDontObserveCompute = can.__notObserve(function(compute){\n  return compute()\n})\nAnd then call:\njs\nreturn readButDontObserveCompute(computedAttr.compute);\n. If you can submit a test, I'll get this in 2.3.8 asap. \nSent from my iPhone\n\nOn Dec 26, 2015, at 9:20 AM, Alex notifications@github.com wrote:\nI experience I think a like problems with computes, I tried solution above, it doesn't seem to work.\n\u2014\nReply to this email directly or view it on GitHub.\n. Pull request here: #2060 waiting on merge from @alexisabril \n. @Alfredo-Delgado That wouldn't work with {{baseUrl}}../../path.png sorta thing.  But a cool idea.  We could actually make {{#join}}../../path.png{{/join}} work.\n\n@matthewp for now, I'm going to go with joinBase.  Most helpers are camelCase.  I'm going to make this change now b/c I need it for tests to pass.  \n. Closing for the issue here: https://github.com/canjs/can-event/issues/4\n. @shcarrico DOM-less should probably be using the ol' Object.prototype.toString.call(arr) === \"[object Array]\" trick if Array.isArray doesn't exist.\n. Closing for: https://github.com/canjs/can-define/issues/13\n. Maybe move this to can/list/reduce and make it work for older browsers.\n. This shouldn't be added to 2.3.2.  It would be new functionality. It would need to be scheduled for a 2.4.\n. This probably would work now in 3.0.  Please make this change in can-define.  Thanks!\n. I mostly agree ... but this would be a breaking API change.  It's something we could do for ($submit) however.\n. btw, for the chat app, use can-enter on the input, no need to use submit.\n. It's too late for this. \nWe could ... allow multiple expressions in call-expressions.  \n<form ($submit)=\"%event.preventDefault(); yourMethod()\">\nBut I think some special syntax might be ok too.\n<form ($!submit)=\"yourMethod()\">\n. Closing for: https://github.com/canjs/can-stache-bindings/issues/10\n. Did you set your id property to \"basket_id\":\nModel.extend({id: \"basket_id\" ....\nAnd then change update to \"PUT http://192.168.0.110/api/v1/basket/{id}\"\nSent from my iPhone\n\nOn Sep 24, 2015, at 8:19 AM, Boris notifications@github.com wrote:\nIn model I define update url as:\nwhen try to call save method of instance, I see in console\nPUT http://127.0.0.1:9000/ 404 (Not Found)\nthis url from browser address bar.\nTo solve this problem I commented one line in makeRequest method:\nif (type === 'update' || type === 'destroy') {\n            console.log('id model obj', getId(modelObj));\n            // args.unshift(getId(modelObj)); \n            console.log('unshifted args', args);\n        }\nand one line in ajaxMaker:\n// data = ajaxMethod.data ? ajaxMethod.data.apply(this, arguments) : data;\n            return ajax(str || this[ajaxMethod.url || '_url'], data, ajaxMethod.type || 'get');\nBut this way does not look right.\nWhat is purpose of this commands and how can I get rid of this problem?\n\u2014\nReply to this email directly or view it on GitHub.\n. Can you paste the relevant parts of your model in a jsbin: http://jsbin.com/fuhawa/1/edit?html,css,js,output ?\n\nI'll check it out.\n. So this seems to be a documentation fix for now, and an improvement in can-connect.\nWhomever takes this over, please make sure the docs explain this.  And if this is unnecessarily confusing, make sure there's an issue in can-connect for what the right behavior should be.\n. Is this the console.log getting hit in can.Construct?  \nhttps://github.com/bitovi/canjs/blob/master/construct/construct.js#L496\nWhat line does the error happen?\nAs of CanJS 2.0, you should always use can.Construct.extend.  CanJS 3.0 will likely enforce this.\n. http://canjs.com/docs/can.Control.html mentions that the Constructor(proto) signature is deprecated.  However, we should be using the @deprecated tag.\n. IE8 isn't supported in 3.0.  I'm going to add a label \"needs a hero\".  We'll fix it if someone submits a pull request.\n. closing as can.view is deprecated.\n. @cherifGsoul that page doesn't seem to exist anymore.  Can you let us know how you navigated to it?  Thanks!\n. @marshallswain What I've done in the past is create a legacy branch of a tagged version like: https://github.com/canjs/canjs/tree/1.1-legacy\nThen I make changes there and point documentjs to that.\n. canjs.com's documentjs.json needs to point at that branch: https://github.com/bitovi/canjs.com/blob/gh-pages/documentjs.json#L39\n. Bug \nSent from my iPhone\n\nOn Oct 1, 2015, at 8:04 AM, Alex notifications@github.com wrote:\nAfter change of comparator on the list @index in view does not change:\n1. 700\n2. 800\n3. 300\n   after sort (using chage of comparator value I get:\n4. 300\n5. 700\n6. 800\n   Is it a feature or a bug?\n\u2014\nReply to this email directly or view it on GitHub.\n. @akagomez Any thoughts on this?  Does a change of the comparator only issue \"move\" events?  If so, are they getting their computeIndex updated?\n. It doesn't look like indexMap is updated. An example of it being updated in add:\n\nhttps://github.com/bitovi/canjs/blob/master/view/live/live.js#L285 \nRemove does something similar.\nThis needs to happen in move.\n. @pYr0x Yep.  Someone just has to do the merge.  cc @joe-crick ?\n. @lukewhyte I'm  not sure what's happening, but that form of compute-on-a-prototype should not be used anymore.  Instead use a define.getter.  I'll make sure a deprecation notice gets added.\n. closing as this is deprecated. \n. I've fixed this in my branch.  There's a few context bugs that I've found.  I'll push what I have tomorrow.\n. I think this is fixed.\n. It hasn't. Another change needs to be made. I changed how the .hash method works. \nSent from my iPhone\n\nOn Oct 6, 2015, at 12:14 AM, David Luecke notifications@github.com wrote:\nI think the change you mean has been made in canjs/can-connect#35 (at least the only difference I can see in can/view/href in this commit is https://github.com/bitovi/canjs/pull/1972/files#diff-c41f9367c9bc3372297f1cf3fc7f217fR20),\n\u2014\nReply to this email directly or view it on GitHub.\n. https://github.com/canjs/can-connect/blob/263c195103926e89179764b9417d8e45ae447823/src/can/tag/tag.js#L98 needs to be changed.\n. For #1, I would avoid using @viewModel as your key.  I'd just call it \"item\" or something.  @ is reserved.\n\nBut the easy solution is probably to use a viewModel function;\njs\ncan.Component.extend({\n  tag: \"item\",\n  viewModel: function(attrs, parentScope){\n    return parentScope.context\n  }\n})\nviewModel functions let you specify any crazy stuff you want.\n. Closing for: https://github.com/canjs/can-stache-bindings/issues/6\n. This is a bug.  Returning 0 to get an empty string wouldn't make sense and its not documented that way so it's ok to change prior to 3.0.\n. ``` js\nvar algebra = set.Algebra(\n  set.comparators.id('_id')\n};\nvar store = fixture.store([{_id: 5, ...},..], algebra);\nfixture(\"/something/{_id}\", store)\n```\n. @julia-allyce Can you update to latest and try again?  I fixed a similar bug last week.  Hopefully that removes this.  \nBtw: https://github.com/julia-allyce/routing-example doesn't seem to be public.  Maybe put it in a jsbin?\n. Thanks for submitting.  Anyway you can get it to break without components and can/route?  Just templates and maps.  Thanks!\n. ah, read page and assumed.  Can you remove the component?\n. btw, a binding like:\n<foo-bar page-name=\"{{page}}\"></foo-bar>\nIs going to give strange results.  Any reason you are using that instead of:\n<foo-bar {page-name}=\"page\"></foo-bar>\nor the older:\n<foo-bar page-name=\"{page}\"></foo-bar>\n. @dylanrtt it is supported, but it sets up a binding on an attribute value ... not a direct binding to the scope.    It can only bind to string values ... and isn't synchronous as attribute events are fired next-turn.  In summary:\n- it's slower\n- it's more limited\n- and not synchronous like everything else\n. > I recognize the value in using the new syntax for 1-way bindings (especially being able to pass non-strings), but I wouldn't expect those cons to cause this issue.\nI don't really either, but things to eliminate.  We aren't going to be able to look at it until next week so I'm trying to share ideas on things to try to isolate the problem so it will be faster when we have time to look at it.\n. Closing this.  If someone else spots it and can isolate the test a bit more, we'll fix it. \n. That a warning is console.log-ed?  We don't document that we do that elsewhere.  Why do you think it should be documented?\n. Ah, I don't really know what to consider tagging something like this.  I suppose it's a feature, but we tend to reserve that for things that would need a minor version change.\n. good find. I'll fix this right now.\n. @whdigger Thanks for offering to help.  We are going to release a new guide with 2.3.  At that point, getting a russian translation would be great.  Thanks!\n. Looks like a bug.  I'll take a look in 20 min.  Thanks!\n. So, it seems like the problem is calling .empty() right?  This issue makes it sound like you can't do #each.  You can do #each, just the tearing down isn't working right?\n. So there is something I would like to get rid of, but can't until 3.0.  \nBasically, the current behavior is to call functions if they are on a can.Map, but not to call functions if they are not.  \nFortunately, call expressions clean this up by always calling functions.  \nIn 3.0, we will probably clean this up, or make helper expressions adopt call expression behavior entirely.\nFor now, I'm going to add a special flag to can.compute.read that HelperScopeLookup expressions will use to say \"give me the function, unless it's on a can.Map. If it is on a can.Map, call the function and give a compute\". \n. There are run times that don't support eval. We want to support those runtimes. \nSent from my iPhone\n\nOn Oct 20, 2015, at 6:57 AM, Ivan Zhidkov notifications@github.com wrote:\ncan.jquery.dev.js doesn't actually include dev parts of code. I also tried to build canjs manually but got the same result.\nI wanted the class naming (via eval) chunk of code in can.Construct.extend. Had to insert it by hand into my can.jquery.js. Why it is even stripped out in non-dev builds? I know eval is evil and stuff... But console.log is much less convenient without proper class names.\nWell, I can live with this, but people will think \"class naming feature doesn't work, a bug?..\"\n\u2014\nReply to this email directly or view it on GitHub.\n. But if can.jquery.dev.js doesn't include dev parts, that is a bug.\n. For some reason, steal-tools must be removing:\n\n//!steal-remove-start\nThis should be a configurable option in steal-tools with removeDevelopmentCode: http://stealjs.com/docs/steal-tools.transform.options.html\nPerhaps the build config isn't setting it right: \nhttps://github.com/bitovi/canjs/blob/master/build/config_stealPluginify.js#L189\nlooks like it is.  Somewhere this is breaking down.\n. I think making extending components work is the ultimate goal here.  \nIn the short-term, I'm pretty sure you can already do this with:\ncan.Component.prototype.leakScope = false;\nclosing.  reopen if that doesn't work.\n. This is almost certainly a problem with can.view.live.list not listening to set events.\nSimilar to how can.view.live.list listens to add events:\n- handler - https://github.com/bitovi/canjs/blob/master/view/live/live.js#L236\n- binding - https://github.com/bitovi/canjs/blob/master/view/live/live.js#L423\nIt needs to be doing a similar thing with set.  But when a set events happens can sneakily call remove() and add methods with the updated item similar to how diffing does it: https://github.com/bitovi/canjs/blob/master/view/live/live.js#L402\n. I originally misread what this issue was saying.\nYes, it's expected that a model like:\ncan.Model.extend({\n  create: \"POST /things\"\n},{})\nMUST return JSON.  I do think setting the dataType property makes sense.\n. It seems like it's already set to default to 'json':\nIn can-connect: https://github.com/bitovi/canjs/blob/master/model/model.js#L85\nAnd in can/model: https://github.com/canjs/can-connect/blob/master/src/data/url/url.js#L231\nIf this is the case, the parse error should be given.  So I'm not sure if there's anything to be done.  Please advise.  Thanks!\n. merge it.\n. fix is to probably sniff out if the element is SVG and change how you set the value.  \nBasically class here: https://github.com/bitovi/canjs/blob/master/util/attr/attr.js#L41\nShould be changed to do setting with a function more like:\nhttps://github.com/bitovi/canjs/blob/master/util/attr/attr.js#L50\n. Thanks!\n. thanks!\n. @dylanrtt a decent amount of thought has been put into this.  Two way binding values to the references scope is an important and commonly used feature in many of the apps that have begun to use it.  \n<date-picker {(time)}=\"*date\"/>\n<date-slider {(time)}=\"*date\"/>\nWe need *date set to the child time if either of these controls has a value.\nWith giving people the ability to control the directions of bindings, most scenarios where this is a problem (child has a value that you actually want to set to undefined) are very minimal.\nYou are right that this could cause some breaking changes with upgrading.  And while the behavior was never documented (it is now), if this problem arises, I can make the old binding syntax follow the old behavior.\nI agree that it violates top-down data flow, but I don't think it opens a bunch of debugging problems.  The initial value might be surprising (I thought the old behavior was surprising) , but binding from that point forward will behave the same was as previously.  I think debugging \"bindings\" is more complex then initial value problems.\nThis behavior is settled for 2.3.  But 3.0 is next.  For 3.0, we could perhaps control the rules with changes like:\n- {()} -> parent wins\n- ({}) -> child wins\n. @dylanrtt I'm sorry about those breaking changes.  And, I appreciate you voicing your concern.  \nI don't think there's any cases since 2.0 where we have broken documented features.  \nBut, I admit that we've played fast and lose with undocumented features.  The lack of documentation isn't a connivence.  If things are not specified, it's often for a reason.  We are unsure of the behavior.\nMost of the times when we change things, it's for good reason.  \nI'm guessing, for instance, that when you upgraded to 2.2, some computed value behavior was different.  Upgrading broke several of our apps too.  This change fixed a bug with computes getting re-evaluted too many times.  The change didn't break any documented APIs so it wasn't a 3.0.  \nThe behavior of the new component bindings during initialization is actually now specified because we finally came to some agreement on it.\nFixing the #eq problem is high priority once DoneJS it out.  \nIf this is the tipping point that makes you not recommend CanJS, I regret that.  However, I will leave this issue open and get out a 2.3.1 with the old binding behavior restored.\nIf there are other things that you find breaking, please let us know.  By us labeling it 2.3 it means it's API complete, not perfect.  There still might be regressions not found by our test suite.  We're happy to fix them.\n. Also, what you are experiencing is a bit by design (though I want to be getting ever more stable).  Instead of releasing 3.0 with HUGE changes from 2.0 (like angular 1.0 to 2.0), we make a lot of stepwise changes.  It's annoying more often, but when stretched out, we think it's much more likely those updates happen.\n3.0 will be largely backwards compatible to 2.3.  Ideally, they will be the same except for some defaults will be switched (ex: mustache -> stache).\nAnd hopefully, these regressions, as our test suite keeps growing and growing, will be fewer and further between.\n. One more thing ... hopefully final ...\nI think what could help a lot is breaking up CanJS into individual projects.  If you could have different versions of can.Component and can.stache, it's probable you could upgrade one for bug fixes without the other.  \nThis way bug fixes wouldn't have to be bundled with feature or breaking changes.  \nI think it's possible to still have a core \"can\" that includes certain versions of things ... similar to what we are going to do with DoneJS.  But for advanced people ... this means we could probably get new releases and fixes out much much faster.\n. @Alfredo-Delgado Here's where the child->parent updating is taking place: https://github.com/bitovi/canjs/blob/master/component/component.js#L236\nThe fix would be to track on bindingsData what type of binding it is .. a \"new\" syntax binding or an \"old\" syntax binding.  If it's an \"old\" syntax binding, don't update the parent.\n. To be clear, we are not reverting the binding rules for the new bindings.\n. I don't think foo === foo.bar is unexpected as long as you know that undefined parent values will be set to their child value.  It should be clear that foo.bar is undefined, so it will take on the value of b, which will be a.\n. 2.3.2 should be out tomorrow.  There's one issue to go. I'm working on it now. \nIf you'd like to be part of these decisions, send me an email: justin@bitovi.com.  We're looking for contributors and it's pretty easy to be part of the team: http://donejs.com/About.html#section=section_Coreteam\n. > Except my code pre-existed that rule and running npm install can@2.3.0 did not impart that knowledge :stuck_out_tongue: (might be a bug with npm). \nYeah, regressions will occur, especially if functionality is untested and not documented, but we will fix it in patch releases.\n. Thanks!\n. I'm not sure what's breaking: https://travis-ci.org/bitovi/canjs/jobs/87143498#L2388\nAnyway you an check it out?\nThe easy way is to run:\ngrunt testify\nAnd then open test/amd/jquery-2.html and see if that's breaking in the browser.\n. - [ ] - https://github.com/canjs/canjs/issues/962\n. ## Breaking Changes\n- You have to use Construct.extend, no more Control({}) to extend Control or any other type.\n- No more adding to the global scope with Construct.extend(\"Foo.Bar\",..).  You must write Foo.Bar = Construct.extend(\"Bar\", ...)\n- Controls use a raw element for this.element instead of a jQuery element. Fix is to wrap with $(this.element)\n- Event binding like ($click)=\"something(%element)\" calls back with raw element, not jQuery wrapped element.\n- No more can.view to load things (for at least the time being).  Register partials yourself or use a module loader.\n- leakScope will be false by default\n- inserted and removed events are fired async.  There will be a sync beforeremove event triggered on components only that will substitute for removed.\n- Native promises are needed and used (or a polyfill); .fail() is replaced with .catch(), and .done() is no longer available.\n- Native promises only allow one argument sent to callbacks; ajax() will now only provide the XHR object to the error handler, where before it provided XHR, status text, and response body.\n- {{helper .}} passes a compute now if within an {{#each}}\n. @matthewp you can pass partials to your helpers argument.\nrenderer(data,{partials: {name:  @otherRenderer}})\nI made a simple stache hook:\nstache.registerPartial(\"name\", textOrRenderer);\n. ## Important Remaining 3.0 Changes\n- [x] - https://github.com/canjs/can-stache-bindings/issues/8 - make . live-bindable\n- [x] - https://github.com/canjs/can-component/issues/22 leakScope: false\n. Yarg ... that's dumb.  So for this to work in all browsers, we'd have to add an empty ?\n. This is a special case because FF forces it to be. \nIdeally, we wouldn't do special casing here. I wonder if it's possible to tell if the value was actually set, or just defaulted to the first item. \nSent from my iPhone\n\nOn Oct 29, 2015, at 8:23 AM, Matthew Phillips notifications@github.com wrote:\nNormally when two way binding we set initial values based on which has a value. In this case the parent doesn't have a value but the child does, so we are making an exception for selects and saying that their value doesn't matter?\n\u2014\nReply to this email directly or view it on GitHub.\n. @Alfredo-Delgado I checked out your solution after I did mine (in bindings).  Yours seems better, but some tests of mine did not pass.  My pull request is here: #2076.  @daffl If it passes, lets get that in and we can investigate making this work directly in attr later.\n. Please correct it!  Otherwise we will get to it.  Thanks!\n. Style needs to be special cased similar to how textareas are special cased. \n\nSent from my iPhone\n\nOn Oct 29, 2015, at 3:29 AM, Alex notifications@github.com wrote:\n@marshallswain well that works\nvar map = new can.Map({color: 'green'})\n$('body').append(can.stache('{{{colorHelper}}}')(map, {colorHelper: function(){return 'body{color: ' + map.attr('color') +'}'}}))\nbut it is not very convinient\n\u2014\nReply to this email directly or view it on GitHub.\n. @whitecolor I think it's an interesting idea.  I wonder what advantageous it would have over simply changing an element's style properties?\n\nTo do this right, you'd want a CSS parser, and a CSS target, and cssRule can.view.live method.  This way, the updates to CSS rules can happen efficiently.  \nBrowser support with CSS rules is a bit all over the place I think if you go back far enough.\n. @whitecolor you mean:\njs\n$('head').append(can.stache('<style>body {color: {{color}} }</style>')(map))\nright?\n. Fixed this in #2083.  @whitecolor check it out.\n. Yeah, the normal helper is what we ended up promoting now.\n. Yes, it should. \nSent from my iPhone\n\nOn Oct 29, 2015, at 12:55 PM, Matthew Phillips notifications@github.com wrote:\nShouldn't this be done in can/map itself?\n\u2014\nReply to this email directly or view it on GitHub.\n. @matthewp Can you make the changes we talked about on Friday tomorrow?  I'd like to get 2.3.2 done.  Thanks!\n. @matthewp made them.  This just needs to be merged: https://github.com/canjs/canjs/pull/2045\n. We can maybe \"sneak\" this into 2.3 undocumented and then make a 2.4?\n. Closing then.  I'll reopen if someone asks for it in can-view-scope.\n. @matthewp is this closed?\n. This shouldn't be reading className. I think it should just detect if the element is an svg element and set the attribute. \n\nSent from my iPhone\n\nOn Oct 30, 2015, at 5:31 PM, Alfredo Delgado notifications@github.com wrote:\n\u2026ot be written to like svg. Resolves #2015\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/canjs/canjs/pull/2048\nCommit Summary\nAdded a setter for class attr to handle elements where className cannot be written to like svg. Resolves #2015\nFile Changes\nM util/attr/attr.js (14)\nM util/attr/attr_test.js (20)\nPatch Links:\nhttps://github.com/canjs/canjs/pull/2048.patch\nhttps://github.com/canjs/canjs/pull/2048.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. Also, I think if someone set a className to {toString: function(){ return \"something\"}}, this would fail.\n. Is this causing actual problems?  With https://github.com/canjs/canjs/pull/2046, which will restore the old behavior of not setting parent scope even if it's undefined, the legacy behavior should be restored, so there shouldn't be a regression with foo=\"{bar}\".\n\nThis behavior is by design w/ the new syntax.  It makes the parent the final arbiter of truth.  What's happening is that the child is being set, the parent changes, and whatever the parent's new value is is set to the child.\nThis is valuable because if the child changes to a value like \"5\", and the parent then updates its own value to 5, the child will then be set to 5.  Updating a child always gets the resulting parent value set back on the child.  \nHowever, the child should not end up having a \"change\" or other event fired in the case the default value is set twice.\nThe only place where I can see this being a problem is if a setter is doing complex logic. However, it can check the current value and just do nothing if the new set value equals the current value.\nThis is actually how 2.2.9 worked, just not during initialization.  So, the only regression is with initialization. \n. The references scope can't have setters, so what you are saying is valid. But references is a special case. For the most part, bindings don't know if they are binding to a reference or any other type of value. \nI'd prefer not to add code for a special case unless someone sees real-world problems with this. It just feels a bit strange to have this behavior with every other observable except for can.view.Scope.Ref. \nSent from my iPhone\n\nOn Nov 4, 2015, at 1:14 AM, dylanrtt notifications@github.com wrote:\nI thought on this some more. When a child updates the references scope, what is the point in setting that value back on the same child that caused the update if the references scope can't possibly have changed the value because it can't have setters?\nIn general, I think it is important to prevent unnecessary updates as much as possible because I have run into valid situations where unexpected updates have instigated complex logic.\n\u2014\nReply to this email directly or view it on GitHub.\n. arg.  will look at it.\n. The problem here seems to be that a compute is built around *refKey:\n\n{^@method}='*refKey'\nSo, when the reference scope's *refKey vale is set, the compute tries to update its internal value.  So, it tries to read *refKey instead of @*refKey.\nI'm not sure what the best solution is.  One possibility is to get people to write (and make this work):\n<foo-bar {^@foo}=\"@*bar\"></foo-bar>\nI think this makes sense because this is what would have to be written if two-way binding a function was ever to be done.  Ugly, but works.\nAlternatively, I could special case one way bindings to not create a compute around the value that is going to be set.\nI might need to make both work.\n. Ok, so I made this work right now the ugly way: <foo-bar {^@foo}=\"@*bar\"></foo-bar>.  I'm not happy with this.  But it will at least let you move forward and us get out a 2.3.2.\nTo make it work without the double @, it seems to require a bit of additional code.  \nCurrently, we know which context to set because we always read the current value and set the first context that has a value.  If no context has a value we set the top of the scope.\nTo set a value, we'd need some similar logic, but something that is able to tell if a property is in some context of the scope without actually reading it.  \nEssentially, I would need some type of \"scope.hasOwnProperty\". But this would extend to can.compute.read and eventually to maps.\nThis is a problem I've know about, but it wasn't a problem because computes were always read first, so the set context was known.  Always seemed like a cheat.\n. I'm going to add some docs for this ugly way until #2065 is working.\n. @alexisabril can you merge this.  Also, please watch out for unnecessary spacing changes in your commits. Thanks!\n. @DesignByOnyx cc @matthewp looks like CI fail is due to can-simple-dom changes: https://travis-ci.org/canjs/canjs/jobs/90006250#L1998 .  I thought these had been resolved?\n. It should be %index, but work both ways for now.\n. @julia-allyce @tracer99 do we have a property named watch?  What's the actual problem?\n. @tracer99 where in the attr function did you use this?  in ___get? https://github.com/canjs/canjs/blob/master/map/map.js#L260\n. > FF has an internal function called watch.\nIs this on Object.prototype?\nMy concern would be more about performance.  We'd want to feature-detect this and only add this check for this property, specifically when the feature is detected.\n. @tracer99 let me know if you'd want to pair on it.  I'm available most times.  Just hit me up on gitter.\n. @prashantsharmain do you want to pair on it this week?\n. @pYr0x I'm going to put a deprecation notice on can/map/validations and point people at can-validate.  I'm also going to mark this as wont-fix because it's not something we are going to prioritize (but I will accept a pull request).  \n@Macrofig where are the generated docs for this plugin?\n. Re-openning until the deprecation docs are in place.\n. Documentation is wrong.  $element is wrapped.  %element is raw element.\n. My guess is that is because ($click) is bound before '.level-two click'.  \nIt's like if you do:\n$(\"#item\").click(a);\n$(\"#item\").on(\"click\",\".something\", b);\nI believe a will be called no matter what b does.\nI'd have to confirm.  But it this is the case, we might be able to make ($click) happen after '.level-two click'.\n. I confirmed: http://jsfiddle.net/a1j9jqcr/6/\nThere's no \"reasonable\" way of making this work.  So, I'm going to close.  If you have an idea, please let me know.\n. You tried this with master?\n. @whitecolor I get no errors with:\njs\ntest(\"conditional attributes (#2077)\", function(){\n    can.Component.extend({\n        tag: 'some-comp',\n        viewModel: {\n            define: {\n                disabled: {\n                    type: 'htmlbool'\n                }\n            }\n        }\n    });\n    var template = can.stache(\"<some-comp {{#unless allowSome}}disabled{{/unless}}></some-comp>\");\n    var map = new can.Map({allowSome: true});\n    template(map);\n    map.attr(\"allowSome\", false);\n    map.attr(\"allowSome\", true);\n});\nCan you submit a test?\n. So the problem was that this was never working great to begin with.  However in 2.0, it was working on component initialization because attribute callbacks were called before tag callbacks.  \nThis meant that next-page=\"{nextPage}\" was added to the element before the tag was created.  \nNow this happens after.  \nI'm trying to track down why we made this change, although I think it makes sense that components are invoked first. \n. This commit changed each attribute to be added to the front: https://github.com/canjs/canjs/commit/bdb06d6a92e4b8de3a59d897fba03808f71cf80d\nThis has the effect of making the tag run last because it will be added first.\nThis was added because bindings needed the view-model to be created before they ran. This is no longer the case because can-component sets up bindings itself.\nSo the hack solution is to reverse this.  This will bring back compatibility.\nBut the better solution is to be able to handle attributes being added and removed.  \nThe better solution isn't easy to write because binding split between components and can/view/bindings.\nI might make this work with can/view/bindings without components first, and then make components do it and try to share as much code as possible.\n. @whitecolor to be clear ... the \"good\" short term fix for this is to have nextPage added at end of turn.  This is slightly different then the behavior in 2.2.  However, we can fix that later by having some sort of can.view.tagStart() and can.view.tagEnd().  tagStart will be called before any can.view.attr, and tagEnd will be called after all can.view.attr.  \nHaving both will allow us to turn off all the view-binding attrs and then initialize the component once all the attributes have been written.\n. There was another issue.  It needs to be {^@save}=\"@*save\"\n. See: https://github.com/canjs/canjs/issues/2065\n. Yeah, sounds like the right thing to do. Can you give an example of this happening?  Thanks!\nSent from my iPhone\n\nOn Nov 12, 2015, at 3:05 PM, Stan Carrico notifications@github.com wrote:\nif you create a can.Map instance, and supply it to a component, then to can.route, you will get a `%root% property serialized into your route..\nI worked around by adding a define block with serialize : false to the aforementioned Map instance, but should this property be defaulted to serialize : false some way?\n\u2014\nReply to this email directly or view it on GitHub.\n. @shcarrico Why was a viewModel being serialized?  It will help inform the fix.\n\nWe added %root to help make can-ssr able to know what ajax requests a page was making. @matthewp is working on a better way of identifying these things, making %root unnecessary in the future.\nMy first impulse is to simply take whatever can.Map is the view-model and overwrite it's .serialize() to delete the %root that would be returned.\nIt's kinda hacky, but should work automatically for most situations, and we can pull it when %root is removed (or deprecated) in 3.0.\n. js\nvar oldSerialize = viewModel.serialize;\nviewModel.serialize = function(){\n    var result = oldSerialize.apply(this, arguments);\n    delete result[\"%root\"];\n    return result;\n}\n. @prashantsharmain Please make the test work with can.stache does it work then?\n. @meconcomputer When you say:\n\nUsign Mode 1, the eventWithOn is rebound as expected if and only if the event has a special character and the eventWithOnHandler has the same name as the event (see https://github.com/canjs/canjs/blob/master/control/control.js#L102)\n\nI'm confused.  Why would someone use both this.on and an action to  listen to the same event.  In the following example, why would someone have the this.on when foo.bar is already going to listen to what they want:\n```\n  can.Control.extend('EventWithOn', {}, {\n    init: function() {\n      this.on(this.element, 'foo.bar', 'foo.bar');\n   },\n   'foo.bar': function(){\n}\n``\n. The reason why I wrote the previous comment is that.on` doesn't rebind any events .. ever.  The only reason it seems like a rebinding is happening is because the \"Mode 2\" binding:\n'foo.bar': function(){  }\nis listening to the same thing and being rebound.\nSo the rules are simple:\n- Actions are rebound\n- bindings with this.on are not rebound.\nWhat is an action is anything that:\n- has a special character\n- in $.event.special\n- or is a DOM event like \"click\", \"keypress\", etc\nBtw, are you making heavy use of Controls?  You might switch to components which are able to avoid a lot of the manual event binding that was associated with can.Control.\n. Closing as can-component in 3.0 is able to rebind w/o calling .on(). It should probably not be used to create application wide types. This is mostly why it's not documented. There's a issue where I go into this. But I'll write up the explanation when I have a bit of time. \nSent from my iPhone\n\nOn Nov 13, 2015, at 6:53 AM, meconcomputer notifications@github.com wrote:\nWhen using can.Map.define plugin, the can.define object is not documented (see https://github.com/canjs/canjs/blob/master/map/define/define.js#L6)\nIt should be properly documented (http://canjs.com/docs/can.Map.prototype.define.html), because:\nit uses a global attribute on can object to store it's types\nit helps users to understand that it can be used when they need to declare application wide define.types\n\u2014\nReply to this email directly or view it on GitHub.\n. @Tarabyte it leads to dependency problems.  Better is to create a \"define-types\" module helper and do:\n\n```\nvar types = require(\"define-types\");\nvar MyMap = can.Map.extend({\n  define: {\n    createdAt: {\n      type: types.moment\n    }\n  }\n})\n```\nWhen people set define's globals, they tend to treat them like a global, not specifically requiring them for every module that depends on them.  Plus, these globals can conflict.  If you created a define-types module, you could share that with the world, and it would work if someone else created a similar moment type.\nWe could document can.define, but I'd put warnings against adding custom global types.\n. @pYr0x anyway you can update this pull request to remove or shorten the big example and merge it into master?\n. Closing for new 3.0 docs.\n. @pYr0x @roissard 2.3.3 has a very different batching mechanism.  It's possible that this is already fixed.\n. The examples seem to be using mustache templates. Remember that if template is a string, it's assumed to be mustache. \nSent from my iPhone\n\nOn Nov 18, 2015, at 1:14 PM, Chris Gomez notifications@github.com wrote:\nWhile searching for the source of a memory leak in my app I found several ways to influence the leak by manipulating my templates.\nI extrapolated my findings into a few tests and committed them here in the stache-leaks branch.\nThe test involves adding/removing 1000 items to DOM several times. Each test renders the items in a slightly different way (i.e. with the  tag, without, with/without parent nodes, using the {{@key}} helper, etc)\nThe tests can also be run on JSBin: http://output.jsbin.com/yowaru\n/cc @justinbmeyer @daffl @imjoshdean\n\u2014\nReply to this email directly or view it on GitHub.\n. There's a <content> within an {{#each}}.  This is not officially supported.\n. <content> is based off the W3C <content> tag.  This type of use will be impossible with that standard.\n. It says \"insertion points\" for the \"source elements\" which mimics the spec language.  It doesn't say a \"re-rendering of the light/user subtemplate\". \n. Please propose an alternate API. Something like . \n\nSent from my iPhone\n\nOn Dec 26, 2015, at 9:09 AM, Guido Smeets notifications@github.com wrote:\nI would like you to seriously consider officially supporting this, or support it in some other way. Repeatable templates is a very important feature.\n\u2014\nReply to this email directly or view it on GitHub.\n. @akagomez <user-template> would behave how our current <content> tag works, leaving <content> to work like how the spec <content> tag works.\n. I liked to the wrong place.  I meant to link here: http://canjs.com/docs/can.Model.models.html\n. Per web-components ... only one  <content> rendering makes sense.  I'm not sure this sorta thing should be officially supported.\n. @dylanrtt We have tests for cases extremely similar to this.  In fact, these types of race conditions were a primary focus of 2.2.  CanJS has over 1700 tests with almost 5000 assertions.\n\nCombining the features in tests is not the solution as:\n- this error can probably be reproduced with just computes. \n- tests that combine features are extremely difficult to debug when regressions happen.\n- the number of combinations of technologies are infinite.  It would be impossible to track which cases are not tested and fill in those gaps.  Unit tests closer to the code being used are much more easy to identify which api's or cases are not being hit.\n. note: this is probably a regression from changing binding from breadth-first-search to depth-first-search in 2.3 to improve compute performance times.\n. The problem can bee seen with just computes:\nIn 2.2.9, change is called just once:\nhttp://justinbmeyer.jsbin.com/ruqufe/1/edit?html,js,console\nIn 2.3.2, change is called twice:\nhttp://justinbmeyer.jsbin.com/ruqufe/2/edit?html,js,console\n. @dylanrtt I think the answer to the problems are:\n1.  Keep building up our unit test coverage to include more and more cases.\n2.  Respond to issues like these quicker.  (I'll try to get this in this week).\n3. Make it clear when a release is approximately \"production\" ready.  \nFor #3, I'm not sure the best way of doing this because our goal is to be able to make a release whenever our test suite passes and APIs are stable.  I want to avoid an endless and meaningless string of .pre and .beta releases. I suppose the official release article comes out when our minor releases are pretty stable.\n. @dylanrtt I would encourage you to only upgrade once a Minor release has got past the 3rd patch release.  It will probably continue to happen if you upgrade immediately to a new minor release.  \nThere's just not a good path around this considering resources and time to delivery.\n. > There's just not a good path around this considering resources and time to delivery.\nMeaning ... if the ultimate goal is to get new features and the performance features within a minor release into your code base as soon as possible, we have to get out the \"regression filled\" minor release as soon as possible to find these bugs.\nProactive \"random\" testing isn't going to discover these faster than getting them out, people encountering them, getting good tests added, and fixes and patches back out.\nIf you don't want to be part of that process, I don't blame you, but I think we need it.  You can avoid it by waiting for a few patch releases before upgrading.\n. @dylanrtt We do upgrade our client apps.  I think we code in probably a more uniform way and are less likely to encounter bugs the community finds.  \nBtw, if you would like to have a voice in our priorities, please join us on our Wednesday meetings.\nFinally, I'm about to submit a fix.  I was happy that it didn't effect our hard earned compute performance gains.  Please check it out and let me know if it fixes your overall problem.\n. Yes, it's a problem that we worked on solving in 2.2. It's a tricky problem, but we came up with a well reasoned solution. \nMy guess now is that batching isn't being propagated through events correctly. To make nested computes work, batching and event ordering needs to be right. My guess is that set is getting in the way of that. I'll check it out. \nSent from my iPhone\n\nOn Nov 23, 2015, at 6:55 PM, dylanrtt notifications@github.com wrote:\nI just tested this out and it fixes the use case I provided in the first post, and the ordering issue you demonstrated with computes, but it seems to happen again when I add more depth to the 'computes'.\nconsole.clear();\nvar Map = can.Map.extend({\n    define: {\n        root: {\n            value: 'a',\n            set: function(val){ return val; }\n        },\n        child: {\n            get: function() {\n                return this.attr('root');\n            }\n        },\n        grandChild: {\n            get: function() {\n                return this.attr('child');\n            }\n        },\n        combine: {\n            get: function() {\n                return this.attr('root') + this.attr('grandChild');\n            }\n        }\n    }\n});\nvar map = new Map();\nmap.bind('combine', function(ev, newVal, oldVal) {\n    console.log('newVal: ' + newVal);\n});\nmap.attr('root', 'b');\nThe problem still goes away when the setter is removed from root and I'm not sure how that plays a role.\nI could not reproduce this problem with just computes like you did earlier.\nUpon further review, I think you and I might be talking about different problems. It seems you think the problem is that change fires twice in 2.3.2 and once in 2.2.9, but what I initially described seeing was 2 changes in 2.2.9, which while sounding like something I would normally complain about, was not yet my concern; that also no longer seems to be happening in my 2.2.9 example so I am now confused...\nAm I correct in understanding that the goal is to minimize change events while infinitely nesting compute dependencies? Sounds like a tricky problem.\n\u2014\nReply to this email directly or view it on GitHub.\n. Tracking it down a bit more.  Setters create's its own batch.  Not sure why that affects things.  I'm going to keep digging.\n. I can break it with just computes and a batch.\n\n``` js\nvar root = can.compute('a'),\n    childB = can.compute(function() {\n        return root();\n    }),\n    grandChild = can.compute(function(){\n        return childB();\n    }),\n    combine = can.compute(function() {\n        return root() + grandChild();\n    });\ncombine.bind(\"change\", function(ev, newVal) {\n    equal(newVal, \"bb\", \"concat changed\");\n});\ncan.batch.start();\nroot('b');\ncan.batch.stop();\n```\n. So this breaks in 2.2.9 as well: http://justinbmeyer.jsbin.com/ciwebu/2/edit?html,js,console\nI think I know what the problem and fix is ... but haven't seen what other problems the fix will cause.\n. Ok, so I fixed this, but it introduces about a 25% increase in the spinning circle demo.  This is due to 2x more bindings and 2x more events.\nThe solution I came up with is that when \"root\" computes (or maps) change in a batch, all computes that might depend on those changes are notified.  For example, if I have computes like:\nvar root = can.compute('a'),\n    child1 = can.compute(function() {\n        return root();\n    }),\n    child2 = can.compute(function() {\n        return root();\n    }),\n    grandChild1 = can.compute(function(){\n        return child1();\n    }),\n    res = can.compute(function() {\n        return child2() + grandChild();\n    });\nIt might look like:\n\nWhen root changes, it sends out a \"change#notify\" event which propagates to every compute.  It increases a counter that tracks how many dependency \"change\" events it needs before it can re-calculate its value:\n\nOnce we have that, we start firing \"change\" events in breadth-first-search.  But a compute only re-evaluates once it receives the right number of \"change\" events.\n. I really want to figure out a way to make this work faster than it currently does.  Making the extra bindings and producing extra events is what's slowing things down.  However, this is a nice approach because it uses existing APIs.  \nAnother alternative would be for computes to add a reference to themselves on their source observables.  For example, c2 could add itself to root.__computedBy[c2._cid] = c2.  Then, the process of having root inform c2 and all of its other dependent computes would be much faster.\nHowever, this means that any dependent observable will potentially get a __computedBy object.  \nSo, I like the purity of my solution, but not the performance.  Maybe there's a way to have both.\n. It's probably possible to avoid the __computedBy directly on the object because we can use a store for this.\njs\ncomputedBy[root._cid][c2._cid] = c2;\ncan/util/batch would have to know about this structure.  But that's probably alright.\n. @daffl @dylanrtt After implementing the above, there's about a 20% slow down. Still not happy.  \nI thought about it some more and realized that what really matters is \"depth\".  I'm thinking that it might be faster to calculate depth of every compute, and re-evaluate computes by order of their depth.  This will mean we don't have to span the graph twice.  Hopefully keeping performance approximately just as fast as it was before.\n. @marshallswain Anyway you can create a stache test and test w/ that branch?  Thanks,\n. Another example:\n```\n{{#start}}\n    \n{{/start}}\n{{other}}\n.\n\n```\n. @marshallswain anyway you can get this into a CanJS test?  You can see some examples in route_test that use an iframe to simulate similar situations.\n. #2108 solves this.  Closing as duplicate.\n. @rjgotten can you share an example (or make a pull request with some breaking code).  Thanks!\n. @prashantsharmain did you try the solution I posted in the issue: \nvar oldSerialize = viewModel.serialize;\nviewModel.serialize = function(){\n    var result = oldSerialize.apply(this, arguments);\n    delete result[\"%root\"];\n    return result;\n}\nputting that in can.Component should fix the problem no matter what.\n. I might do a quick fix so that <foo-bar {@child}=\"@parent\"></foo-bar> works.\n. This one was caused by unifying all binding logic.  Essentially, a compute is made for child.  When the compute is set to a function, computes automatically re-read themselves to get their new value.  \nIn this case \"child\" is read, which ends up calling the function.  Instead if @child was read, things will work.  This is also needed for two-way binding.\n. Yes, it's the necessary syntax.  Unless we want to special case things.\n. @dylanrtt the reason is that {^method}=\"parent\" would call method and set parent to its return value, while {^@method}=\"@parent\" would export the function itself to @parent.\nRegarding #2065, yes, I might be able to special case @ so it's not needed on both sides in 1-way bindings.  Basically, I can prevent the \"setter\" compute from having to ever read itself.  \nBut I want to think about it a bit first.\n. Could it have meaning?  Say we had data like:\nvar compute = can.compute();\nvar map = new Map({compute: compute});\nWould there be a difference between @compute and compute when setting?\n. @pYr0x what needs to be documented better?  There's an example showing how to export a parent function, with an example.\n. @pYr0x well, we should probably add a similar example for the other direction: http://canjs.com/docs/can.view.bindings.toChild.html\n@dylanrtt I've made it possible to drop the @ on the receiving side of a one way binding.  So {child}=\"@method\" and {^@method}=\"parent\" will work.  I think a lot of people will try this.  And it should work.  It's likely that even if there could be a difference between:\n- {child}=\"@method\"\n- {@child}=\"@method\"\nThat difference would only matter if in fact child pointed to a compute and we could detect that and do the right thing, while still allowing {child}=\"@method\" for the vast majority of use cases.\nI think the docs should continue to show @ on both sides.  I think it's good guidance because they are needed for two way bindings.\n. @pYr0x it works both ways.\n. I think setting the child to undefined is probably the right behavior.  If the child had a value, the one-way binding should probably overwrite it to undefined.\nThe double set is certainly a bug.  Will fix tomorrow. \n. > When I ran it in an actual browser, the test passed correctly.\nHow are you running it in an actual browser?\n. @meconcomputer Thanks for reporting this.  The modifiers plugin isn't used much anymore so fixing this bug isn't priority.  I labeled it \"needs a hero\" which means that if you'd like to assist on a fix, we will work on it.  We can even setup a time to pair.  Thanks.\n. modifiers will be removed in 3.0.\nif you want to work on it, we can setup a hangout (`justin@bitovi.com).  Just let me know when is a good time for you.\n. Is this present in 2.3.5? \n. What code causes this? I need a breaking test case. \nSent from my iPhone\n\nOn Dec 5, 2015, at 5:10 PM, Alex notifications@github.com wrote:\n2.3.4\nUncaught TypeError: Cannot read property 'pop' of undefined .../node_modules/can/compute/get_value_and_bind.js 160 TypeError: Cannot read property 'pop' of undefined\nLast releases are full different of erros.\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes, the latest releases contain a big rewrite to fix compute and batching bugs. However, we will keep getting out releases quickly until everything is stabilized. Thanks for reporting. \n\nSent from my iPhone\n\nOn Dec 5, 2015, at 5:10 PM, Alex notifications@github.com wrote:\n2.3.4\nUncaught TypeError: Cannot read property 'pop' of undefined .../node_modules/can/compute/get_value_and_bind.js 160 TypeError: Cannot read property 'pop' of undefined\nLast releases are full different of erros.\n\u2014\nReply to this email directly or view it on GitHub.\n. I think I know how to reproduce.  Checking ...\n. Can you write up an example. What you show works for me if I'm using stache\n. also, the example has modelView not viewModel\n. @whitecolor If you can get me an example soon .. I might be able to get a 2.3.6 out tomorrow with a fix for this an the other issue.  Thanks!\n. http://justinbmeyer.jsbin.com/wowome/edit?html,js,console,output shows that passing attrs works.\n. I think #2139 will fix this.  I'm closing on that assumption.  Please re-open if you continue to find this problem.\n. What version are you using? The latest CanJS is much faster than old versions. \n\nSent from my iPhone\n\nOn Dec 6, 2015, at 11:26 PM, roger-ng-helloworld notifications@github.com wrote:\nHello,\nI built this search widget: http://helloworld.com.au/l/cheap-domestic-flights\nThe loading time is alright on Desktop but it'll take 10 to 12 seconds to load on mobile. Basically, the widget comprise of 37 classes (some classes get instantiated more than 4 times). I found out the instantiation of classes are slowing down the loading time. Plus I'm using a lot can.Map and can.List.\nOne of the solutions I'm toying around is to merge some of the classes but that would be anti-pattern. I'm hoping I don't have to merge the classes. Is it expensive to use a lot of can.Map and can.List? My other solution is to consolidate some of the can.Map and can.List.\nPlease help.\nRog\n\u2014\nReply to this email directly or view it on GitHub.\n. Also, do you mean the creation of the classes themselves or do you mean instances of the classes?\n\nSent from my iPhone\n\nOn Dec 6, 2015, at 11:26 PM, roger-ng-helloworld notifications@github.com wrote:\nHello,\nI built this search widget: http://helloworld.com.au/l/cheap-domestic-flights\nThe loading time is alright on Desktop but it'll take 10 to 12 seconds to load on mobile. Basically, the widget comprise of 37 classes (some classes get instantiated more than 4 times). I found out the instantiation of classes are slowing down the loading time. Plus I'm using a lot can.Map and can.List.\nOne of the solutions I'm toying around is to merge some of the classes but that would be anti-pattern. I'm hoping I don't have to merge the classes. Is it expensive to use a lot of can.Map and can.List? My other solution is to consolidate some of the can.Map and can.List.\nPlease help.\nRog\n\u2014\nReply to this email directly or view it on GitHub.\n. 2.3 is over-all much faster. Can you try upgrading?\n\nOr, can you share the code that is running slow so I can experiment?\nAre you listening to change events? Those are really slow. \nSent from my iPhone\n\nOn Dec 7, 2015, at 4:45 PM, roger-ng-helloworld notifications@github.com wrote:\nHi Justin,\nI'm using version 2.1.2 and I mean instances of classes. I seriously hope the instances of classes wouldn't cost that much because I'm not looking forward to merging some of the classes. Also, I'm using a lot of can.Map and can.List instances, would that be the reason why it's almost grinding to a halt on mobile?\nRog\n\u2014\nReply to this email directly or view it on GitHub.\n. Creating instances of Map and List is fast unless you are using them in certain situations. \n\nAnother option, if you can't share the code, would be to hire us under contract to check it out. \nSent from my iPhone\n\nOn Dec 7, 2015, at 4:45 PM, roger-ng-helloworld notifications@github.com wrote:\nHi Justin,\nI'm using version 2.1.2 and I mean instances of classes. I seriously hope the instances of classes wouldn't cost that much because I'm not looking forward to merging some of the classes. Also, I'm using a lot of can.Map and can.List instances, would that be the reason why it's almost grinding to a halt on mobile?\nRog\n\u2014\nReply to this email directly or view it on GitHub.\n. @roger-ng-helloworld I'm going to close this until you get us a sample of the slow code.  Unfortunately, the site itself running in production minified is a bit difficult to figure out what's going on.\n\nI'll reopen if you can get us an example.\n. Closing for: https://github.com/canjs/can-map-backup/issues/3\n. @rjgotten This should be a pretty easy fix.  Simply change the logic around:\nhttps://github.com/canjs/canjs/blob/master/compute/proto_compute.js#L384\nTo check if isNaN(newVal) ? ! isNaN(oldVal) : newValue !== oldValue.\nAnd add a test.\n. Yeah, this should be fixed by #2139.  Please re-open if you continue to find this.\n. Does {^.}=\"yearSelector\" do it?\nSent from my iPhone\n\nOn Dec 9, 2015, at 7:22 AM, Matthew Phillips notifications@github.com wrote:\nI think this should do it:\n\u2014\nReply to this email directly or view it on GitHub.\n. {{year}} is not the two way binding syntax. {(key)} is. \n\nSent from my iPhone\n\nOn Dec 9, 2015, at 7:28 AM, Alex notifications@github.com wrote:\n{{year}}\n. @whitecolor I'm planning on working on it now.\n. We should close this one and move those fiddles into the other one.\n\nI actually wrote a test and it didn't experience this problem. \nI'll checkout the bins. \nSent from my iPhone\n\nOn Dec 14, 2015, at 2:11 PM, David Luecke notifications@github.com wrote:\nRelated #2092\n\u2014\nReply to this email directly or view it on GitHub.\n. Closing for the other issue.\n. There's a plus operator? I have no idea how the other one works?\n\nSent from my iPhone\n\nOn Dec 14, 2015, at 2:08 PM, Kevin Phillips notifications@github.com wrote:\nArithmetic such as {{%index + 2}} does not work in stache templates. {{@index + 2}} works as expected.\nThe right-most column in this example shows the unexpected behavior: http://jsbin.com/kahibegune/1/edit?js,output\n\u2014\nReply to this email directly or view it on GitHub.\n. This isn't valid syntax. Write it like:\n{{ greet name=uppercase(username) }}\n\nSent from my iPhone\n\nOn Dec 15, 2015, at 8:12 AM, nauman notifications@github.com wrote:\nstache template with following experssion throws error Unable to understand expression\n{{ greet name=(uppercase username) }}\nboth greet and uppercase are helpers\n\u2014\nReply to this email directly or view it on GitHub.\n. @organic-scholar it's not valid stache syntax.  We decided we liked:\n\n{{ greet name=uppercase(username) }}\nmore than the handlebars syntax.\n. @organic-scholar this works: http://justinbmeyer.jsbin.com/resipu/edit?html,js,console,output\n. I'm pretty sure you can mix helper and call like: {{#each foo(bar)}}, but it seems that a helper hash doesn't work with a call expression like: {{helper hash=call()}}.  It's a bug we will fix for the next release.\n. Works: http://jsbin.com/xotunitoya/edit?html,js,console,output\nSo, there really isn't a problem. The confusion is that the results of call expressions are passed as computes to helper expressions.\nHelper expressions get computes by default. \nSent from my iPhone\n\nOn Dec 18, 2015, at 10:40 AM, nauman notifications@github.com wrote:\nhere is another example failing, this one with unnamed params.\nhttp://jsbin.com/niseji/edit?html,js,console,output\n\u2014\nReply to this email directly or view it on GitHub.\n. Helpers are always passed a compute with any observable data. Even functions are converted to a compute. So it's consistent. \n\nSent from my iPhone\n\nOn Dec 20, 2015, at 5:34 AM, nauman notifications@github.com wrote:\nbut i think this behaviour is inconsistent beacuse we called the expression its is not instead it is passed as compute.\n\u2014\nReply to this email directly or view it on GitHub.\n. @m-mujica seems like there's a problem with this.  Ping me tomorrow and lets take a look.  (I'll be around tonight if you want to look at it too). Thanks!\n. > Could even create an interface so that other types of observables than can.computes can be bound.\n\nProbably not necessary b/c can.compute is an interface that allows other observables to become computes.\ncan.compute(initialValue, {\n  on, off, get, set\n})\n. What other use cases do you think people would want this?\n. done. https://github.com/canjs/can-view-live\n. @DesignByOnyx would this also do the wrong thing if I did:\njs\nvar div = document.createElement('div');\ndiv.innerHTML = \"<script>var foo='bar';</script>\";\nIs parser.parse(\"\"+html) aware of this rule?\n. Closing for https://github.com/canjs/can-view-parser/issues/7\n. Closing for https://github.com/canjs/can-view-parser/issues/7\n. @gsmeets can you provide a breaking example?  I'm not sure exactly what you are describing. \n. @gsmeets can you provide a breaking example?  I'm not sure exactly what you are describing. \n. My example was wrong\n. My example was wrong\n. Thanks!\n. Thanks!\n. closing for can-list issue.\n. closing for can-list issue.\n. @akagomez please fix this tomorrow.  I can show you how if you need help.  Thanks!\n. @akagomez please fix this tomorrow.  I can show you how if you need help.  Thanks!\n. value shouldn't behave the same as can-value.\n. value shouldn't behave the same as can-value.\n. @phillipskevin Yep.  We should let people know that their choice of property/attribute matters with ({$value})\n. @phillipskevin Yep.  We should let people know that their choice of property/attribute matters with ({$value})\n. If type was a property you wanted live-bound:\n{$checked}=\"eq(%element.value, type)\" ($change)=\"attr(type, %element.value)\"\nSomething like that might work.  I'm not sure the first %element.value will work (but that can be fixed).\nI've also thought about supporting:\n{$checked}=\"eq(%element.value, type)\" ($change)=\"type = %element.value\"\nor\n{$checked}=\"eq(%element.value, type)\" ($change)=\"type(%element.value)\"\nbut both feel weird.\n. If type was a property you wanted live-bound:\n{$checked}=\"eq(%element.value, type)\" ($change)=\"attr(type, %element.value)\"\nSomething like that might work.  I'm not sure the first %element.value will work (but that can be fixed).\nI've also thought about supporting:\n{$checked}=\"eq(%element.value, type)\" ($change)=\"type = %element.value\"\nor\n{$checked}=\"eq(%element.value, type)\" ($change)=\"type(%element.value)\"\nbut both feel weird.\n. @marshallswain Because can-value's behavior was odd.  It didn't bind to input.value in checkboxes and radios. Instead it bound to the checked property.  {($value}) is extremely consistent. \n. @marshallswain Because can-value's behavior was odd.  It didn't bind to input.value in checkboxes and radios. Instead it bound to the checked property.  {($value}) is extremely consistent. \n. Closing for #2210\n. Closing for #2210\n. This is a reversal of another filed bug. I think the solution is to mark everything as block and require that people close all tags. \nSent from my iPhone\n\nOn Jan 6, 2016, at 7:25 PM, Ryan Wheale notifications@github.com wrote:\nI have content which looks like this:\nSome text with an anchor in it\nbut since the anchor is defined as a block element, it is getting converted to this:\nSome text with an anchor in it\nThe anchor element is an inline element, but per html5 spec it's the only inline element which allows block level children. The parser should take this into consideration. The \"a\" tag should be part of the \"inline\" set of elements (not the \"block\" group), and conditional logic should be used to prevent the \"a\" tag from being closed when a block element is encountered.\n\u2014\nReply to this email directly or view it on GitHub.\n. This is a reversal of another filed bug. I think the solution is to mark everything as block and require that people close all tags. \n\nSent from my iPhone\n\nOn Jan 6, 2016, at 7:25 PM, Ryan Wheale notifications@github.com wrote:\nI have content which looks like this:\nSome text with an anchor in it\nbut since the anchor is defined as a block element, it is getting converted to this:\nSome text with an anchor in it\nThe anchor element is an inline element, but per html5 spec it's the only inline element which allows block level children. The parser should take this into consideration. The \"a\" tag should be part of the \"inline\" set of elements (not the \"block\" group), and conditional logic should be used to prevent the \"a\" tag from being closed when a block element is encountered.\n\u2014\nReply to this email directly or view it on GitHub.\n. I don't think a should be special cased, we probably need a variable that contains other elements that could be treated like an 'a'. \n\nSent from my iPhone\n\nOn Jan 6, 2016, at 7:40 PM, Ryan Wheale notifications@github.com wrote:\nFixes #2169\nThe also preserves the ability to have block elements as children of an anchor - there is still a test for that still passes.\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/canjs/canjs/pull/2170\nCommit Summary\nAllow anchor tags to be children of inline elements and contain block elements\nFile Changes\nM view/parser/parser.js (13)\nM view/parser/parser_test.js (12)\nPatch Links:\nhttps://github.com/canjs/canjs/pull/2170.patch\nhttps://github.com/canjs/canjs/pull/2170.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. I don't think a should be special cased, we probably need a variable that contains other elements that could be treated like an 'a'. \n\nSent from my iPhone\n\nOn Jan 6, 2016, at 7:40 PM, Ryan Wheale notifications@github.com wrote:\nFixes #2169\nThe also preserves the ability to have block elements as children of an anchor - there is still a test for that still passes.\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/canjs/canjs/pull/2170\nCommit Summary\nAllow anchor tags to be children of inline elements and contain block elements\nFile Changes\nM view/parser/parser.js (13)\nM view/parser/parser_test.js (12)\nPatch Links:\nhttps://github.com/canjs/canjs/pull/2170.patch\nhttps://github.com/canjs/canjs/pull/2170.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. @DesignByOnyx I don't I was being clear.  \n\nwhile (last && inline[last] && last !== \"a\") {\nHaving \"a\" special cased like this vs something more like:\nvar blockAndInline = {\"a\": true}\nchanges the while loop to:\nwhile (last && inline[last] && !blockAndInline[last]) {\n. @DesignByOnyx I don't I was being clear.  \nwhile (last && inline[last] && last !== \"a\") {\nHaving \"a\" special cased like this vs something more like:\nvar blockAndInline = {\"a\": true}\nchanges the while loop to:\nwhile (last && inline[last] && !blockAndInline[last]) {\n. >  If we really want to replicate html then we stop auto-closing tags altogether \nThat actually wouldn't be replicating HTML.   Replicating HTML would involve more complex parsing that was better able to tell when to auto-close tags.  HTML does auto-close tags.\nThe CI is erroring.  If you'd like to see this in 2.3.9, please remove the special casing from the while loop and get Travis to pass.\n. >  If we really want to replicate html then we stop auto-closing tags altogether \nThat actually wouldn't be replicating HTML.   Replicating HTML would involve more complex parsing that was better able to tell when to auto-close tags.  HTML does auto-close tags.\nThe CI is erroring.  If you'd like to see this in 2.3.9, please remove the special casing from the while loop and get Travis to pass.\n. Even better ... I wonder if there's a way to include 'a' in both the block and inline list and have the logic work.\n. Even better ... I wonder if there's a way to include 'a' in both the block and inline list and have the logic work.\n. I think re-implementing push might work ... just loop through the array and set arr[i].. I think re-implementing push might work ... just loop through the array and set arr[i].. Is there some part of the docs you are missing?  There's been many projects developed from CanJS.  Please provide any specific concerns you have that we can address.\n. Is there some part of the docs you are missing?  There's been many projects developed from CanJS.  Please provide any specific concerns you have that we can address.\n. Closing for: https://github.com/canjs/can-list/issues/5\n. Closing for: https://github.com/canjs/can-list/issues/5\n. Related issue: https://github.com/jquery/jquery/issues/2225\n. Related issue: https://github.com/jquery/jquery/issues/2225\n. @rjgotten I thought about that, but knew I had the buildFragment that worked everywhere else.  Also, I wanted to avoid another \"convert to a fragment\" step.  Meaning, that yes, we were creating a fresh fragment (via DOM clone method), but my thought that .clone() would be much faster than having parseHTML break the DOM into an array, and then us re-assemble it into another fragment.  clone() presumably doesn't have to keep updating .nextSibling references.\nWe can maybe check if the performance is about the same.\n. @rjgotten I thought about that, but knew I had the buildFragment that worked everywhere else.  Also, I wanted to avoid another \"convert to a fragment\" step.  Meaning, that yes, we were creating a fresh fragment (via DOM clone method), but my thought that .clone() would be much faster than having parseHTML break the DOM into an array, and then us re-assemble it into another fragment.  clone() presumably doesn't have to keep updating .nextSibling references.\nWe can maybe check if the performance is about the same.\n. @mjstahl what did you change when you fixed the merge conflicts?  It seems things are breaking now.  Is there a merge commit?  \nAlso, I noticed the view/stache/test/system/test.html file looks different than the standard test.html file.  Where did you get that structure from?  steal-qunit should be imported, not loaded via script tags.\n. @mjstahl what did you change when you fixed the merge conflicts?  It seems things are breaking now.  Is there a merge commit?  \nAlso, I noticed the view/stache/test/system/test.html file looks different than the standard test.html file.  Where did you get that structure from?  steal-qunit should be imported, not loaded via script tags.\n. @mjstahl this is what I see when I open that page.\n\n. @mjstahl this is what I see when I open that page.\n\n. Ah, it seems that wasn't intended to be opened as a standalone test page. I'm going to rename it.\n. Ah, it seems that wasn't intended to be opened as a standalone test page. I'm going to rename it.\n. A breaking example in stache in 2.3.8: http://jsbin.com/patiho/edit?html,js,output\n. A breaking example in stache in 2.3.8: http://jsbin.com/patiho/edit?html,js,output\n. A workaround would be to make your helper check if it's still a compute and keep calling the compute.  We will look to have a fix soon.  Thanks for reporting.\n. A workaround would be to make your helper check if it's still a compute and keep calling the compute.  We will look to have a fix soon.  Thanks for reporting.\n. Yeah, this isn't so much of an issue. I suppose we could leave arrays as arrays if List isn't imported. \nSent from my iPhone\n\nOn Jan 12, 2016, at 9:43 AM, Manuel Mujica notifications@github.com wrote:\nThis is in can@2.3.9\nimport Map from 'can/map/';\nconst bar = new Map({ foo: [1, 2, 3, 4] });\nTypeError: List is not a function\n    at Map.can.Map.can.Construct.extend.__type (http://localhost:3000/js/node_modules/can/map/map.js:323:14)\n    at Map.can.Map.can.Construct.extend._set (http://localhost:3000/js/node_modules/can/map/map.js:302:28)\n    at Map.can.Map.can.Construct.extend._setAttrs (http://localhost:3000/js/node_modules/can/map/map.js:489:12)\n    at Map.can.Map.can.Construct.extend.attr (http://localhost:3000/js/node_modules/can/map/map.js:200:18)\nmy workaround is import can/list along with can/map.\n\u2014\nReply to this email directly or view it on GitHub.\n. Yeah, this isn't so much of an issue. I suppose we could leave arrays as arrays if List isn't imported. \n\nSent from my iPhone\n\nOn Jan 12, 2016, at 9:43 AM, Manuel Mujica notifications@github.com wrote:\nThis is in can@2.3.9\nimport Map from 'can/map/';\nconst bar = new Map({ foo: [1, 2, 3, 4] });\nTypeError: List is not a function\n    at Map.can.Map.can.Construct.extend.__type (http://localhost:3000/js/node_modules/can/map/map.js:323:14)\n    at Map.can.Map.can.Construct.extend._set (http://localhost:3000/js/node_modules/can/map/map.js:302:28)\n    at Map.can.Map.can.Construct.extend._setAttrs (http://localhost:3000/js/node_modules/can/map/map.js:489:12)\n    at Map.can.Map.can.Construct.extend.attr (http://localhost:3000/js/node_modules/can/map/map.js:200:18)\nmy workaround is import can/list along with can/map.\n\u2014\nReply to this email directly or view it on GitHub.\n. The reason why it's done this way is that it's good to build thing independently.  In 3.0, it will leave Arrays as plain Arrays unless can.List is imported.  \n\nClosing for: https://github.com/canjs/can-map/issues/4\n. The reason why it's done this way is that it's good to build thing independently.  In 3.0, it will leave Arrays as plain Arrays unless can.List is imported.  \nClosing for: https://github.com/canjs/can-map/issues/4\n. seems like this has been done.\n. seems like this has been done.\n. Yes. It was worse when it didn't. \nSent from my iPhone\n\nOn Jan 21, 2016, at 9:47 AM, David Luecke notifications@github.com wrote:\nThis seems like a lot of additions. Should that still live in our main repository?\n\u2014\nReply to this email directly or view it on GitHub.\n. Yes. It was worse when it didn't. \n\nSent from my iPhone\n\nOn Jan 21, 2016, at 9:47 AM, David Luecke notifications@github.com wrote:\nThis seems like a lot of additions. Should that still live in our main repository?\n\u2014\nReply to this email directly or view it on GitHub.\n. Did you write your template correct? The input should be blank with {($value)}=\"*bar\"\n\nSent from my iPhone\n\nOn Jan 12, 2016, at 4:55 PM, pYr0x notifications@github.com wrote:\n {{_bar}}  \n. Instead of\n\n{$value}=\"foo\"\nDo\nvalue=\"{{foo}}\"\nSent from my iPhone\n\nOn Jan 12, 2016, at 4:55 PM, pYr0x notifications@github.com wrote:\n{$value}=\"foo\"\n. closing for the can-stache-bindings issue.\n. Thanks @phillipskevin .  Anyway you can remove the use of the component and routing?  It will be probably ready for a quick insertion into a test at that point.  Thanks again.\n. @phillipskevin It would be in can/view/stache/stache_test.js.  Ideally you shouldn't have to append it to the DOM like the vast majority of the other tests.\n. @phillipskevin I'd be interested if #2189 fixes it.  You might try to make that small change locally and see if your problem sticks around.\n. Yes, this is a consequence of an \"undefined\" behavior when events are triggered outside of a batch within another batch being dispatched.\n\nMy guess is that if you changed your code to do:\n// Start batch #1\n// Trigger A\n// Stop batch #1\n// Handle A\n  // Start batch #2\n  // Trigger B\n  // Stop batch #2\n  // Start batch #3 \n  // Trigger C\n  // Stop batch #3\nEverything would work fine.\nOne option might be to force any triggering of events to be part of a \"solo\" batch.   This would automatically dispatch C after B without having to wrap it with start/stop.\n. Closing for those can-event issues.\n. What does this mean?. please try with 2.3.10 and let us know if this is still breaking.\n. seems similar to #2186\n. @cherifGsoul What problem is is this causing?  What's the use case for having a virtual property be returned by keys?  \nI wonder if there wouild be a high correlation with  serialize: true virtual properties and the properties you'd want to be present in .keys()\n. Closing for: https://github.com/canjs/can-map-define/issues/5\n. Thanks for reporting.  Moving to https://github.com/canjs/can-map-backup/issues/2\n. Issue moved to canjs/can-list #35 via ZenHub\n. > Currently there is no way to use the ($event) syntax to call a handler with the default arguments (element, event, scope, arguments...).\nYeah, you do:\n($event)=\"method\"\n\nWhen you do expr(), the default arguments for handlers should be passed in.\n\nI don't think that should happen.  Sometimes methods check the number of arguments and you'll need a way to call an argument without any arguments.\nI think we need an %arguments special key and a spread operator.\n. Closing for https://github.com/canjs/can-stache-bindings/issues/9\n. I'm thinking of changing the logic to always call .attr(prop) and if that returns undefined, to return this[prop].  This will allow map._cid if someone wants it.\n. @dylanrtt closing for: https://github.com/canjs/can-stache/issues/18\n. The following test passes:\njs\n        test(\"leakScope:false preserves context of parent\", function(){\n            can.Component.extend({\n                tag: \"outer-leak\",\n                viewModel: {\n                    tag: \"outer-leak\"\n                }\n            });\n            can.Component.extend({\n                tag: \"inner-no-leak\",\n                template: can.stache(\"<content/>\"),\n                viewModel: {\n                    tag: \"inner-no-leak\"\n                },\n                leakScope: false\n            });\n            can.stache.registerHelper(\"getContext\", function(c1, c2){\n                equal(c1, c2, \"same object passed\");\n                equal(c1.attr(\"tag\"), \"outer-leak\");\n            });\n            var template = can.stache(\"<outer-leak><inner-no-leak>{{getContext . this}}</outer-leak><inner-no-leak>\");\n            template();\n        });\nI noticed that if a component doesn't have a template, it leaks scope regardless. \n. @dylanrtt With a template, the scope is not leaked: http://justinbmeyer.jsbin.com/sihogovema/1/edit?html,js,console\nCan you remind me again of why you would have a component without a template that you would not want to leak?\nI'm not sure if this behavior is documented outside of the code: \nhttps://github.com/canjs/canjs/blob/master/component/component.js#L103\nIf it is documented (I'm on a very slow internet), then if this is a good change, it will have to wait until 3.0 to change it.  If it's not a documented behavior, we maybe be able to change it earlier.\n. Issue moved to canjs/can-component #94 via ZenHub\n. @reno1979 We do this because setAttribute doesn't support attribute names like {foo} in chrome.\n. I think this is fixed now ... we use innerHTML and then copy the attribute.\n. The reason for this is that the value is type coerced into strings: http://justinbmeyer.jsbin.com/megixa/edit?html,js,console,output\nThe only fix I can think of is that we overwrite .__set or maybe .__type on the route's map to automatically convert all values to strings.\n. @pYr0x yes, it should be possible.\n. We do for can-value. What is confusing specifically?\nSent from my iPhone\n\nOn Apr 6, 2016, at 12:39 PM, pYr0x notifications@github.com wrote:\nwe should document that behavior for checkboxes and radiobuttons... still confusing for users\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. Closing for https://github.com/canjs/can-stache-bindings/issues/49\n. The fix I did for #2267 adds nodeLists on view.attr\n\nhttps://github.com/canjs/canjs/pull/2267/files#diff-d034a26ce8c4a4ae48f82780eca645cbR242\n@dylanrtt What you are doing is likely fine. If your code looked like:\n```\ncan.view.attr('my-attr', function(el, attrData) {\n  var frag = can.stache(\"{{something}}\")(attrData.scope);\n  var livePart = frag.firstChild;\n  $(el).after(frag);\ncan.one.call(el, 'removed', function() {\n    livePart.parentNode.removeChild(livePart);\n  });\n});\n```\nThis wouldn't work because live text nodes without a parent element can't listen on a parent to know when to teardown their binding.\n$.fn.wrap might also cause problems. But I'd have to experiment.  I think the nodeLists should still contain the right things even if the DOM is in the wrong order.\n. attr now gets node lists.\n. closing for issue in can-stache-bindings\n. Yes. Seems like a bug. \nSent from my iPhone\n\nOn Jan 28, 2016, at 6:00 PM, dylanrtt notifications@github.com wrote:\nIf I define a compute that returns a new canMap(), changes to the map cause the compute to re-execute\nhttp://jsbincom/suxayikepu/edit?html,js,console,output\nvar c = cancompute(function() {\n  return new canMap();\n});\ncbind('change', function(){});\nvar map = c();\n// recomputes c\nmapattr('foo', 'bar');\nShouldn't the compute in this example only ever be evaluated once? It appears to be binding to its own return value\n\u2014\nReply to this email directly or view it on GitHub.\n. my best is there is a call to call can.Map.keys somewhere during init that shouldn't be there.\n. @rjgotten Yeah, setters shouldn't be observable.  Going to work on a fix now.  Thanks!\n. @chasenlehara this would be very nice for 3.0.  Any chance you get get a day or so to make it happen?\n. closing for can-stache-bindings issue.\n. https://github.com/canjs/canjs/blob/master/view/parser/parser.js#L300 is almost certainly where the error is.  It should probably be counting starting #, ^ and ending / sections. \n. This is due to the return readButDontObserveCompute(computedAttr.compute); added in #1915.\n. Instead of the solution for #1915, we should probably observe on the compute and not on the property itself.  Basically flip the behavior around.  Perhaps __get should check if it's a computed property and not call can.__observe around here: https://github.com/canjs/canjs/blob/minor/map/map.js#L246\n. A more simple test would probably have something like:\n\nc = can.compute(function(){\n  return m.attr(\"p\");\n})\nWhere p is a async defined property on map m.\n. This is working now.  Something must be wrong with our build that it sometimes forgets to run this script.\n. closing for issue in can-map-backup\n. @matthewp it doesn't have a scope.\n@rjgotten after a quick read, yes this seems like it would be nice.  I'd like to see the difference between this and how non-evaled code currently performs.  But even it was big, the real-world cost would probably be pretty low.\n. Sorry, I mean I'd like the code as it is right now when eval is removed compared to new Function. Right now eval only exists in dev so I don't care about its performance. I do care about performance of \"production\" CanJS. \nMy assumption is that new Function is going to add another function call and be slightly slower overall. \nSent from my iPhone\n\nOn Feb 4, 2016, at 4:05 PM, rjgotten notifications@github.com wrote:\n@matthewp \nIs new Function really more performant that eval? I wonder why that is.\nBecause it constructs an isolated function in the global scope. You don't have the possibility of outer functions' closure scopes influencing the function or vice-versa. Normally, to perform a lot of code optimizations safely, a JS compiler needs to be able to do static code analysis to figure out how to cope well with closures. Straight-up eval makes that impossible, but the isolation of new Function means it is not necessary to be able to still apply a great deal of optimizations.\n@justinbmeyer \nI'd like to see the difference between this and how non-evaled code currently performs\nWhile I don't have a testcase at hand, testing by Modus Create at one point showed new Function can be 50x faster than eval. And iirc one of the Chrome dev people once held a presentation regarding the internals of V8 stating that it could make up to a 100x difference.\n\u2014\nReply to this email directly or view it on GitHub.\n. @rjgotten this is great!  I'm moving the issue to can-construct.  I'd love to see a pull request land there if you have the time.  Thanks.\n. @alexisabril did we fix this?\n\nThe solution is to make the context observable on a Scope and to make it possible to set the context on a scope.\n. @prashantsharmain yep.  How does your Friday look?  It will be the only day I have available.\n. solved in 3.0\n. @Alex0007 yes, the peerDeps were removed, but not added to devDeps so the package wasn't working.  I've got a pull request in right now that should fix it.\n. https://github.com/canjs/canjs/pull/2242\n. @dylanrtt \n\nI also think that this should return the map rather than the object (always thought that was a bug).\n\nWhat is that? I'm not sure what you mean.\n. @amitbikram Just a heads up, EJS is no longer actively supported.  We'll accept bug fixes, and even help you debug them (if you want to pair over skype or google hangout).  But we aren't devoting resources to EJS.  \nPlease let us know if you'd like to pair on fixing this, or need help in the right direction.  \nClosing and marking as \"needs a hero\"\n. Mustache is also deprecated.  https://canjs.com/docs/can.mustache.html . Please switch to stache.  If the bug happens there, we will fix it asap: \n. Probably in a week or 2. \nSent from my iPhone\n\nOn Feb 11, 2016, at 3:22 PM, abs notifications@github.com wrote:\n@justinbmeyer I have have a pull request for this. When would would it be available if the fix looks good?\n\u2014\nReply to this email directly or view it on GitHub.\n. Is this fixed by: https://github.com/canjs/canjs/issues/2220?\n. @chasenlehara is a component necessary?  Does it work if you simply .attr(\"collection\", [{objectProp:'object prop'}] )\n. There's an issue keeping this for 3.0.  Essentially, live-binding relied on a synchronous notification of removed events to teardown the bindings.  \n\nIn 3.0, for performance reasons, I was hoping to use MutationObservers to know when elements are added or removed.  MutationObservers dispatch at the next turn.\nI'm going to try to come up with a way for this to work without having to resort to synchronous \"removed\" events.\n. actually, listening to nodeLists teardown should work.\n. Issue moved to canjs/can-stache-bindings #278 via ZenHub\n. Templates don't have to be registered. At parse time.  The tags just need to have a hyphen. \nSent from my iPhone\n\nOn Feb 11, 2016, at 7:10 AM, Matthew Phillips notifications@github.com wrote:\nYeah, the components must be registered when the template is parsed. You can work around this using a custom element and doing:\n{{#show}}\n  \n{{/show}}\n\n\n\nHowever... we already have for exactly this purpose. It doesn't work with HeadJS though, are you married to using that library? can-import works very nicely with stealjs\n\u2014\nReply to this email directly or view it on GitHub.\n. Duplicate of #2255\n. @phillipskevin preload probably isn't needed in a modern / donejs application. What are you using it for?\n. gone in 3.0.\n. In 3.0, we should make setting a compute not return the new value of the compute.  This will greatly simplify computes behavior and make situations like this less common.\n. Ok, I discovered the cause.  With the new batching system, any use of can.batch.after needs to be part of the batch that it is trying to hook into.\n\n```\ncan.batch.start();\n// MAKE CHANGES\ncan.batch.after(function(){\n  // do stuff when current batch has completed\n})\ncan.batch.stop();\n```\nPreviously, this would hook into the \"last batch\" which wasn't necessarily the batch that we actually might have just created.\n. cc @nlundquist \n. We should only be converting the serialize-able properties.\n. @BigAB I mentioned a few reasons in the bitovi chat a while ago.  Three major reasons:\n1.  We probably don't want to overwrite a behavior the browser might provide.  <content> was probably a mistake if <content> was actually ever supported.\n2.  It's easier, and CanJS is already setup to identify sub-templates that are <tag> based and not attribute based.\n3.  Attribute-based tags need to have an element associated with them.  Say I wanted to position pure text content like: {{first}} {{last}}.  You couldn't do that, you'd have to add a <span> or some other element.  Also, it seems that the spec leaves in <slot> elements.  Not sure I like that.\n. To be clear, I'm not sold on <template> and <content> and while <tags> are easier than attri=butes, the burden of making that work shouldn't keep us from using them.  However, I'm wary of always having to have that <span>.\nOne other point, all the <x-template> renders will be put on the viewModel as templates.  This would allow the shadow DOM to also be written like:\n<b>Name</b>:\n  {{#if templates@fullName}}\n    {{{ templates.fullName }}}\n  {{else}}\n     {{{ templates.firstName }}} {{{templates.lastName}}}\n  {{/if}}<br>\n  <b>Email</b>: {{{templlates.email}}<br>\n  <b>Address</b>: {{{templates.address}}}\nHowever, I like using elements for simplifying setting up default content.\n. Moving to can-component\n. Scopes have it, but not component viewModels. This needs to be present for ssr. \nSent from my iPhone\n\nOn Feb 22, 2016, at 12:24 AM, Chasen Le Hara notifications@github.com wrote:\nWhen a component is set up, %root was added to the initial viewModel data so it would be available in every scope. However, can.view.Scope already has a special case for %root, so it\u2019s not necessary for can.Component to do that.\nFixes #2250\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/canjs/canjs/pull/2282\nCommit Summary\nAdd failing test for component/define/type/list/map issue\nDon\u2019t include %root in a component\u2019s initial viewModel data\nFile Changes\nM component/component.js (4)\nM component/component_test.js (37)\nPatch Links:\nhttps://github.com/canjs/canjs/pull/2282.patch\nhttps://github.com/canjs/canjs/pull/2282.diff\n\u2014\nReply to this email directly or view it on GitHub.\n. @chasenlehara I'm curious why the initial data would cause the breaking behavior you identified.  It doesn't make sense to me, which makes me think there's a better fix somewhere.\n\nAlso, you should be able to demonstrate this w/o a component.  Just create the VM in the same way can.Component does, with initial data like new YourMap({\"%root\": new can.Map()})\n. @chasenlehara good explanation.\n. Closing for: https://github.com/canjs/can-stache/issues/60\n. Live reload works.  I assume you mean live-reload while keeping the state?\n. > A feature of can.Map is that if you call attr() with an object as the first argument (and no 2nd arg), all properties of the object that are undefined will be removed from the map.\nOnly if you call a map like map.attr(VALUES, true) do undefined properties in VALUES get removed from map.\nUnless you are talking about properties like {prop: undefined} where the property is actually defined, but it's value is undefined.\n. closing for P1 issue in can-route\n. This doesn't seem like a bug.  can.stache returns a function, you need to call it like:\ncan.stache('<my-component></my-component>')()\nExample: \nhttp://jsfiddle.net/kmqys2fw/4/\n. closing for issue in can-map.\n. When you use a call expression, there really shouldn't be an options object.  \nInstead page='home' should pass an object like {page: \"home\"} as the first argument and true as the second.\n. @gmahomarf I'm a bit confused.   Does it not work the way I suggested in my comment?\nIf yes, then this is a bug, not a problem with the docs.\n. Canjs is not a priority for me this week. I'm working on can-set issues currently. If you want to help fix it, I can pair with you this week and close it out. Otherwise it will probably have to wait until next week. \nSent from my iPhone\n\nOn Feb 29, 2016, at 5:46 PM, Gazy Mahomar notifications@github.com wrote:\nAny news on this?\n\u2014\nReply to this email directly or view it on GitHub.\n. closing for issue in can-stache-bindings.  We can port it back to 2.3 if someone else needs it.\n. CommonJS shouldn't load the can/view/stache/system plugin.  That's only for SystemJS/StealJS.\n. Ah, I guess I should say it only works with StealJS then.  JSPM doesn't support a @loader which is necessary if you want to have multiple loader objects operating at once.  You cant rely on the System being global.\n\nWhy are you using jspm instead of Steal?  They are similar except that Steal will work out of the box with CanJS perfectly.\n. You might be able to do:\nSystem.set(\"@loader\", System);\nSystem.config(...);\nAnd have the system plugin work.\n. closing as this is how 3.0 will be and we aren't going to do it for 2.3.\n. @lastzero how did this fail?\n. meaning ... is there some code that you ran that caused the error?\n. Although we might put this in 2.3.18, it will not be documented, so don't use it.\n. Another important one might be:\n<input type=\"checkbox\" {($checked)}=\u201cinList( list, item )\" />\njs\ncan.stache.registerConverter(\"inList\",{\n  get: function(list, item){\n    return list.indexOf(item) !== -1;   \n  },\n  set: function(newVal, list, item){\n    var index = list.indexOf(item);\n    if(newVal){ \n      if( index === -1) {\n        list.push(item)\n      }  \n    } else {\n      if( index !== -1 ){\n        list.splice(index,1);\n        // might need to look for others here\n      }\n    }\n  }\n});\n. @dylanrtt this was the first thing I tried (and got working through some ugly hacking).  However, I worried what if someone did something like:\ncan.stache.registerHelper('convertNumber', function(source, radix) {\n  var rad = radix();\n  return can.compute('', {\n    get() {\n      return source()+'';\n    },\n    set(val) {\n      source(val === '' ? null : parseInt(val, radix) );\n    }\n  });\n});\n. My guess is that a new compute would be created and then value would be connected to that new compute.\nThe problem is there's not a good way of having computes within computes in this way.  The outer compute creates and depends on the inner compute.  So if any other dependency of the outer compute changes, a new inner compute is created.\n. @dylanrtt yeah, this is why I think my solution is technically easiest.  It just needs some API love ontop to make it easy for people to make their own two-way converters.\n. js\nvar data = {\n  people: new can.List([{name: \"alexis\"}, {name: \"brian\"}]),\n  state: new can.Map();\n}\n<select {($value)}=\"selected(~data.state.person, data.people)\">\n  {{#each data.people}}\n    <option value=\"{{%index}}\">{{name}}</option>\n  {{/each}}\n</select>\njs\ncan.stache.registerHelper(\"selected\", function(newVal, item, list){\n    if(newVal instanceof can.expression.SetIdentifier) {\n        item( list.attr(newVal) );\n    } else {\n        list = item;\n        item = newVal;\n        return list.indexOf( item() );\n    }\n});\n. This isn't a bug.  By default passing objects merges properties.  If you want to replace it, the second one should be:\nitem.attr({ foo: new can.Map({ id: 0 }) })\n. item.attr('foo', {}) will do a replace.  Not a conflict.\n.attr(VALUES) -> merges\n.attr(\"prop\", value) -> replaces\n. I think the error when merging is a good idea. Regarding:\n\nNever recycle/merge can.Map instances when we intend to replace them.\n\nI'm not sure we can identify those scenarios.  What case is this happening?  The only thing I can think of is with a component that is trying to export to a property on a plain JS object that happens to be a can.Map or a can.List.\n<my-component {^export}=\"value\"/>\nthat might be rendered with:\njs\n{value: new can.Map()}\n. I should point out that this merge ability is there for can-value in situations like this one: https://github.com/canjs/canjs/blob/master/view/bindings/bindings_test.js#L669\ncan-value exports plain JS objects.\n. > The childToParent binding should probably just always be a vanilla compute.\nBut that's not always the case as indicated in the above test.  \n\nbinding a model to the root viewModel:\n\nWhat would this look like?\n. closing for can-stache-binding issue\n. Thanks for submitting.  \ncan/view used for loading is really deprecated in favor of <can-import>.  <can-import> should normalize based off the moduleName of the current file.  Normalizing of the baseURL is less than ideal in a package (npm) workflow. \nWe are removing the jQuery/Mootools/YUI/Zepto compatibility layer from CanJS 3.0.\nIn the same vein, I've been considering removing <can-import> from CanJS 3.0 and having them be 2nd or 3rd party modules.  can.view is very likely going to be removed as well.  \nIf it does stay in CanJS, this will have to be something the community creates.  I'll keep it open and label it \"needs a hero\".\n. Closing.  @rjgotten that's a great tip.  \nhttp://canjs.github.io/canjs/doc/can-view-import.html is going to be in its own module in 3.0.  But for build other system specific integrations, we have the ecosystem category with things like steal-stache.  My hope is that people can make browserify, amd, jspm, etc extensions and we can list them there.\n. null and undefined should bypass type conversion.\n. Problem is here in can-map-define: https://github.com/canjs/can-map-define/blob/master/can-map-define.js#L275\nAnd here in in can-define: https://github.com/canjs/can-define/blob/master/can-define.js#L352\nPlease solve this in both repos.  Then look into:\n- [ ] https://github.com/canjs/canjs/issues/2372\n. 1.  I'm torn about this.  While I think that 90% of the time, converting null to false will be ok because they are both falsey.  Consistency is important.  We don't change number types given null to 0.  My gut tells me we should leave null as null.\n2.  I think we can punt on this.  These behaviors could already be controlled with a custom type or setter.  If this becomes a common need, we can create alwaysString, alwaysNumber, alwaysBoolean or some other types.\n. very likely related, might already be working: https://github.com/canjs/canjs/issues/2238\n. Still a bug: http://jsbin.com/buhosip/edit?html,js,output\n. Closing for the fix in 3.0.  If someone wants to merge the pull request into the 2.3-legacy branch, we can get it for a future release.\n. https://travis-ci.org/canjs/canjs/jobs/115994897#L1717\nThat's the test that is breaking. \nSent from my iPhone\n\nOn Mar 17, 2016, at 2:49 PM, Mohamed Cherif Bouchelaghem notifications@github.com wrote:\n@justinbmeyer Can you tell me please why the build dosent work?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly or view it on GitHub\n. can you create that w/o components?\n. Why is this considered out of order?   \n\nI think the outer component should be notified first of the change.  This is important if it happens to be removing the inner component, preventing it from seeing the change.\nI'm not sure this is a bug.\n. So, the problem here seems to be that binding updates now happen as part of another batch.  \nConsider: {foo}=\"bar\".\nWhen bar changes, the update to foo will not be part of the same batch. It will be part of its own batch.\nFor the most part, this is what you want.  \nbar might be calculated from a whole host of other observable properties.\nSetting foo might kick off updating another host of observable properties.\nI have to noodle on this a bit.  It might be possible to have bindings pretend they are part of the same batch. \nAlternatively, we might need to bring back some of the old depth-first way of doing batching.  Maybe at least with when the callbacks get called.\n. I have an update to the batcch.stop function that makes batch callbacks get called after all \"synchronous\" sub-batches get called:\n``` js\n        stop: function (force, callStart) {\n            if (force) {\n                transactions = 0;\n            } else {\n                transactions--;\n            }\n            if (transactions === 0) {\n                collectingBatch = null;\n                var batch;\n                if(dispatchingBatches === false) {\n                    dispatchingBatches = true;\n                    var callbacks = [],\n                        i;\n                    while(batch = batches.shift()) {\n                        var events = batch.events;\n                        callbacks.push.apply(callbacks,  batch.callbacks );\n                        dispatchingBatch = batch;\n                        can.batch.batchNum = batch.number;\n                        //console.log(\"dispatching\", can.batch.batchNum);\n                        var len;\n                    if (callStart) {\n                        can.batch.start();\n                    }\n                    for(i = 0, len = events.length; i < len; i++) {\n                        can.dispatch.apply(events[i][0],events[i][1]);\n                    }\n\n                    can.batch._onDispatchedEvents(batch.number);\n\n                    dispatchingBatch = null;\n                    can.batch.batchNum = undefined;\n\n                }\n                for(i = callbacks.length - 1; i >= 0 ; i--) {\n                    callbacks[i]();\n                }\n                dispatchingBatches = false;\n            }\n\n\n        }\n    },\n\n```\nupdate can/util/batch.js with this.\n. There is a better way of doing this, but not without rewriting all the tests. \nSent from my iPhone\n\nOn Mar 15, 2016, at 4:10 PM, Adam Barrett notifications@github.com wrote:\nAll the tests depend on a global can object being available.\nThis doesn't seem right, and, I feel, could lead to leaking stuff across tests because they are not fully isolated.\nImporting 'can' into the tests causes amd and global tests to fail, which I guess makes sense, but I feel like there is a better way to do it where the tests are isolated and not depending on a global can object, but we can still test the amd and global builds without re-writing the test files.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. We should absolutely rewrite the tests.  But not until after an initial release.\n. done in 3.0\n. done in 3.0\n. @reno1979 sounds like a fine feature.  Closing for an issue in can-stache.\n. @xojins Thanks for the suggestion.  Anyway you can make it in https://github.com/canjs/can-fixture?  This is going to be where the next version of can-fixture is maintained.\n\nAlso, can you include a bit more in terms of code that isn't working.  I assume you are talking about store.findAll.  \nThe next version of can-fixture will be making use of set-algebra.\n. Closing b/c no changes to can.fixture will be made in this repo.\n. @imjoshdean @ccummings please make a pull request with the JSBin's code as an HTML page in this folder:\nhttps://github.com/canjs/canjs/tree/master/view/stache\nhttps://github.com/canjs/canjs/blob/master/view/stache/visual_benchmark.html is an example of using steal to load CanJS.\nThis will save me some time getting setup to investigate.  Once that's created and I'm done with my morning meetings, I will look into it.\n. This isn't a bug because + is not a valid operator in a stache expression. \nSent from my iPhone\n\nOn Mar 20, 2016, at 4:56 AM, Mohamed Cherif Bouchelaghem notifications@github.com wrote:\nThis bin demonstrate the use-case, I think expressions like 1+2={{1+2}} should works but I saw even simple strings are not displayed I think this is can be a bug with stache expressions.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. Yeah, I was seeing this yesterday at a training. I had people switch to another version of npm and it worked. \n\nSent from my iPhone\n\nOn Mar 20, 2016, at 9:17 AM, pYr0x notifications@github.com wrote:\nUsing:\nnpm 3.7.3\nnode 5.9.0\nrelated npm/npm#11976\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. I'm not sure what you mean by \"paths should be changed\"?\n\nSent from my iPhone\n\nOn Mar 20, 2016, at 10:46 AM, Mohamed Cherif Bouchelaghem notifications@github.com wrote:\nWhy the importing paths are different? \nimport appTemplate from \"src/app.stache!\";\ncan-import from=\"testapp/components/welcome/\nI think paths should be changed\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. Never mind, you mean that pRy0x should change his imports. Yes, that is almost certainly the problem. \n\nSent from my iPhone\n\nOn Mar 20, 2016, at 10:46 AM, Mohamed Cherif Bouchelaghem notifications@github.com wrote:\nWhy the importing paths are different? \nimport appTemplate from \"src/app.stache!\";\ncan-import from=\"testapp/components/welcome/\nI think paths should be changed\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. @daffl I was thinking super should be core.  What do you think?\n. What do you mean by plugin?  If you mean should it be in its own modlet, then yes it should.  Its still a good practice to have things broken out.\n. Technically, I think this is trying to read the \"\" property from the map.  I know that:\n\nvar map = new can.Map();\nvar scope = new can.view.Scope(map);\nscope.attr(\"./\") == map; // false\nshould work.\nIs there a reason to use ./?\n. @dylanrtt what if someone wants to read the empty string property?  It's a very unlikely case, but {\"\":123} is valid.  Perhaps in 3.0, they could get it with ./[\"\"].  I'm just debating if this makes sense semantically, if ./ should represent the same thing as ./[\"\"] or ..\n. Issue moved to canjs/can-view-scope #54 via ZenHub\n. Shouldn't we avoid phantom and use FF instead?\nSent from my iPhone\n\nOn Mar 24, 2016, at 11:29 PM, Adam Barrett notifications@github.com wrote:\nClosed #2341.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. @RALifeCoach Thanks for sharing.  I'm not sure I understand the example quite yet.\n\nYour component is <player-row>.  But it doesn't seem like it is being inserted into an actual table is it? If it were, I would assume your example would look more like:\njs\nthis.playerRowMap = new global.playerRow.PlayerRowMap(data);\nvar template = can.stache('<tr><player-row id=\"player-row-' + this.pid + '\"></player-row></tr>');\nthis.container.append(template(this.playerRowMap));\nWhat is this.container?\nAlso, why is the code doing append itself?  In a modern, post-can.Component, application, one doesn't render and insert templates other than the initial template.  Instead, you'd have something like:\n{{#each players}}\n  <player-row {player}=\".\"></player-row>\n{{/each}}\nAlso, I noticed:\njs\nthis.highlightPicker = this.element.find(this.HIGHLIGHT_PICKER);\nthis.highlightPopup = this.element.find(this.HIGHLIGHT_POPUP);\nthis.expansionContainer = this.element.find(this.EXPANSION_CONTAINER);\nthis.articleButton = this.element.find(this.ARTICLES_BUTTON);\nthis.photoButton = this.element.find(this.PHOTOS_BUTTON);\nthis.videoButton = this.element.find(this.VIDEOS_BUTTON);\nThat's a lot of querying for each <player-row> which could be deferred until later.\nIs there anyway you can make your JSBin work?  Give it mock data that will insert player-row 156 times into the page?  I could take a stab at it, but it would take me a while to figure out what the mock data looks like.\n. @RALifeCoach if you know the shape of your data, you can probably do something like:\n``` js\nvar players = [];\nfor(var i = 1; i <= 156; i++){\n  players.push({\n    id: i,\n    name: \"Player\"+i,\n    // dummy versions of all other properties\n  })\n}\nplayers.forEach(function(player){\n  var template = can.stache('');\n  container.append(template(player));\n})\n```\n. @RALifeCoach I might be able to work on this over the weekend.  But I didn't get a chance to look at this today.\nIf you have a lot of properties that you don't need, then you might consider using LazyMap and LazyList.  They only convert properties as they are read.\nAlso, if you are supporting IE>9, you might look at https://github.com/canjs/can-define.  This is about 3 to 4x faster than can.Map.\n. > That opens the question, why does a large player object - where most of the properties are not used - take so much time? \nThis is because those properties are converted to being observable.  There's 135 properties and there's 156 items.  21060 is a lot of data to convert.  \nLazyMap and LazyList are able to avoid converting all of that and can-define is able to do it faster and you can specify what should be observable and what shouldn't.\n\nHaving to write a mapper each time I want to use a template doesn't make much sense.\n\nYou only need these techniques when the set of observable data is as large as you are dealing with.\n. @RALifeCoach can-define because in 3.0 everything is going to be module based.\nI'm closing this issue.  If you have performance problems in the future using can-define, please let us know. \n. @pmtarantino I'm not sure what's happening.  Are your templates being called before your routing rules are defined?\nFor example, something like:\n```\nvar frag = template({ ... })\ndocument.body.appendChild(frag)\ncan.route(\":page\")\ncan.route.ready()\n```\nIf this is the case, it's possible they don't know about the routing rules to write out the correct links.\n. @pmtarantino I'm closing this issue.  I'll re-open if you can give me a little more information.  Thanks!. While I like the syntax.  I think there are a lot of downsides to having multiple ways of doing things.  We had a long debate, everyone had their favorite binding syntax.  What we settled on wasn't mine (child{=\"parent\"), but I'm wary of revisiting.  Also, I'd want to make sure we maintain some level of consensus.  \nA starting place to experiment would be to expose getBindingInfo so it can be replaced.  That way you could easily write a plugin for your own rules by just providing an alternate regexp and rules for what it means like https://github.com/canjs/canjs/blob/master/view/bindings/bindings.js#L798\n. I fully support this, but it's not something the OS team is going to undertake at this time.  If someone wants to take it up, I'm happy to pair with them. Closing and adding \"needs a hero\" label.\n. fixed by removing the community page\n. can-define is the solution for this. Closing. \n. @rjgotten you have it!\nThe only thing I'd add to is:\n\nAnd there's a seal property which, when explicitly set to false, allows for 'expando' style maps with automatic just-in-time definition of a JS getter/setter for the incoming assignment, which makes DefineMap work like the old \"observe every property\" behavior in Map.\n\nThe observability only works if you use defineMap.set(\"prop\", newVal) to set an expando property.  If you add the property normally like defineMap.prop = newVal, this doesn't setup any sort of observable property. \nSo if you wanted to assign properties to a map where some were observable and others not, you could do it like:\n``` js\nvar MyMap = DefineMap.extend({seal: false},{\n  observableProp1: \"string\",\n  observableProp2: \"number\",\n  observableProp3: \"observable\"\n});\nvar myMap = new MyMap();\nObject.assign(myMap, {\n  observableProp1: \"hi\",\n  observableProp2: 5,\n  observableProp3: {something: \"else\"},\n  nonObservable1: \"nothing\",\n  nonObservable2: 4,\n  nonObservable3: \"u\"\n});\n```\nYes, this will only be available in 3.0.  You can find the list of breaking changes here: https://github.com/canjs/canjs/issues/2026#issuecomment-214504889 Though once we release can-jquery, I'm hoping that an upgrade is a pretty straightforward process.\nIf this is important for 2.3, it might be possible to make a \"global\" script that that could work. It's not priority for me until after 3.0 is out.  But I can help show what's needed.  The biggest change is right here: https://github.com/canjs/can-define/blob/master/can-define.js#L411\nThat needs to be can.__observe.\n. Is there something difficult with replacing the event system?  My hope is that IE9 would be pretty standards and no huge hurdles to work around.\n. Tom's mockups\n. @lastzero thanks for the workaround.  This method is being removed in 3.0 so closing.\n. That's not why. We add one. \nSent from my iPhone\n\nOn Apr 5, 2016, at 6:59 AM, Matthew Phillips notifications@github.com wrote:\nLooking at your example, I don't think native Promises have a value property, could this be why?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. A+ promises must be working in some fashion, otherwise, all the promises produced by can-connect, which are not native, but A+ (which is close enough) do work.\n. Also, we don't need to add anything to native promises, we only have to make sure can.isPromise works for them.  My guess is that StealJS's polyfill is making promise instanceof Promise fail.\n. This shows native promises working if can.isPromise is fixed: http://jsbin.com/xitezi/1/edit?html,js,output\n. @hntvip Thanks for asking questions.  We're always happy to help.  But if you don't mind, these types of questions are best on the forums: http://forums.donejs.com/c/canjs.  We like to keep github for bugs / features /etc.\n\nI'm closing this issue, but you probably need to call .attr with true like:\njs\n can.route.attr({route:\"list\"}, true)\nThis tells it to remove any properties on can.route not in the object of property/values.\n. There are no dumb questions. Keep asking!\n. Solve https://github.com/canjs/can-stache/issues/62 first and then come here.\n. Only in IE8?\n. Closing b/c we don't support IE8 anymore.\n. @Tarabyte sorry about the late response.  We've fixed a few memory leaks in 2.3, this is undoubtedly one of them.  \nAs tracking them all down, and making the individual changes will take a while, the easiest thing (and the best result) will be upgrading to 2.3.\n. 2.3 is backwards compatible (unless you're relying on broken batching behavior).  Upgrading shouldn't be a problem.\nIf you do run into 2.3 upgrade problems, please report them and we will help you move past them.\n. Closing for https://github.com/canjs/can-map-define/issues/4\n. @ilyavf To be clear, you're saying that you expected $value to be cross bound to your values in the list.  \nThis won't actually work as value in the DOM is actually a string that just prints out the first selected <option>'s value.  So if 1 and 2 are selected, select.value is \"1\".\nThis will be good to solve  in 3.0.  I'm not sure how to do it.  \njQuery's .val returns an array when used on <select multiple>.  It does it by looping through the options and getting the .selected ones around here: https://github.com/jquery/jquery/blob/e4fd41f8fa4190fbbb6cb98cf7ace64f6e00685d/src/attributes/val.js#L114\nit seems select.selectedOptions is an array of the selected options.  But I doubt you can set it.\nThis might simply be a use case for either special handing of $value or a special helper like the old can-value.\nWe could make can.attr handle arrays.\nMoving to: https://github.com/canjs/can-stache-bindings/issues/49\n. Closing for: https://github.com/canjs/can-stache-bindings/issues/49\n. That jsbin isn't using the 'values' property\nSent from my iPhone\n\nOn Apr 13, 2017, at 1:54 PM, Nitin Pasumarthy notifications@github.com wrote:\nHow is it fixed? I still see this in \"can\": \"^3.3.1\"\nCreated an example https://jsbin.com/medifub/edit?html,js,output1\n\u2014\nYou are receiving this because you modified the open/close state.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I misunderstood what this issue was. Re-opened . closed by https://github.com/canjs/can-util/pull/233. this is very confusing.  Solve in 3.0 first, and then back-port to 2.3.  https://github.com/canjs/can-stache-bindings/issues/55\n. Those things should be available here: https://github.com/canjs/can-stache-bindings/blob/master/can-stache-bindings.js#L308\n. Fix this first: https://github.com/canjs/canjs/issues/2316\n\nThen make sure this works in:\n- [x] - can-define/map\n- [x] - can-map-define\n. This should be solved by can-stache-converters.  We should still make sure POJOs work with can-stache-bindings.  Moving this issue there.. Issue moved to canjs/can-stache-bindings #161 via ZenHub\n. Probably configuring webpack to load the AMD distribution.\n. Yes. It's in dist/amd \nSent from my iPhone\n\nOn Apr 18, 2016, at 12:01 PM, Mohamed Cherif Bouchelaghem notifications@github.com wrote:\nDoes the AMD distribution available as npm package?\n\u2014\nYou are receiving this because you commented.\nReply to this email directly or view it on GitHub\n. So is this closed? It should be possible.\n. @BigAB does webpack follow a special configuration like Browserify's browser config that we specify here:\n\nhttps://github.com/canjs/canjs/blob/master/package.json#L201\n. I assume it will work by default with 3.0 if webpack supports typical CommonJS setups.\n@daffl we might need to change our imports to not use moduleName/ and instead write everything out explicit so it works in NodeJS / other setups.\n. closing as 3.0 will take care of this.\n. Thanks for reporting! This is mostly strategic.  Calling without () is deprecated.  It was the only thing possible with the old binding syntax: https://canjs.com/docs/can.view.bindings.can-EVENT.html\nWe supported the old no () form so migrations would be easier.\nStill worth explaining better.  Labeling as \"documentation\".\n. This is fixed in 3.0 as only call expressions should be used.\n. fixing this in can-util for 3.0.  Will likely back port to 2.3 after. \n. fixed in 3.0. https://github.com/canjs/can-util/blob/master/js/is-array-like/is-array-like.js#L4\n. If we bring back can-list-promise in 3.0, we should fix it there and possibly back-port to 2.3.\n. I'm going to close.  If this gets a few people adding +1s, we can make the can-list-promise plugin.  However, a workaround is to simply use promises in can-stache:\n{{#if promise.isResolved}}\n  {{#each promise.value}}\n  .... probably some crazy browser quirk.  Might not be needed in 3.0.  In 3.0, we can probably remove it and then make sure we test supported browsers.  cc @phillipskevin \n. @matthewp do you mean server side rendering?  I'm not sure what routing has to do w/ this?\n. Closing for: #2318\n. @rjgotten that seems great!  A few questions:\n- Do you mean can-tag not can-as?\n- Could you make the pull request against: https://github.com/canjs/can-stache ?  We aren't adding new features to 2.3 and 3.0 is the next release.\n. @rjgotten the patch releases for 2.3 will not contain changes to stache.js, only minor bug fixes.  \nWe're planning on making 3.0 highly compatible with 2.3 and have a \"compatibility\" mode for the jquery-specific changes.  Here's the current breaking changes: https://github.com/canjs/canjs/issues/2026#issuecomment-214504889 let me know if any of those seem troublesome to you.\n. Issue moved to canjs/can-component #95 via ZenHub\n. Notes on JSBin:\n- get one from server -> returns one item in .items.\n- get two from server -> returns two items in .items.\nGoing back and forth always shows just 1 item because everything is always merged.\n. I think the best way to do this would be to overwrite updated like this:\nhttp://jsbin.com/kididu/edit?html,output\n. Closing for: https://github.com/canjs/can-view-parser/issues/13\n. Thanks.  @daffl is taking a look at it.  Should be fixed shortly.\n. works for me in incognito now.\n. Should be fixed in #2390\n. Why is there no way to sort a list without setting up bindings?  What specifically enforces that?\n. Why couldn't it do:\nthis.attr('comparator', comparator);\nthis._sort();\n?\n. It's not a bug. Getters are not serialized by default. Only serialized properties end up in the url. \nSent from my iPhone\n\nOn May 24, 2016, at 8:20 AM, Chris Gomez notifications@github.com wrote:\nI noticed that a route property I was changing would update the DOM, but not the URL. The property had BOTH a set AND get method. When I commented the two define methods out the URL and the DOM both updated.\nI was able to recreate the example in this JSBin without can.route: http://jsbin.com/gakexi/edit?html,js,console\nI'm not sure if this is a \"bug\" or not, but I thought I'd report it anyway.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly or view it on GitHub\n. If that's the case, can you create a jsbin showing that happening and file it on: https://github.com/canjs/can-route\n. actually, this is probably fixed in 3.0 already.  It's broken now because getter properties don't fire \"change\" events.  But in 3.0, instead of binding on \"change\", a compute is used to wrap .serialize().\n. You need to use commas in between arguments. \n\nSent from my iPhone\n\nOn May 27, 2016, at 2:25 AM, isadovskiy notifications@github.com wrote:\nHello.\nOriginal helper's syntax allows to mix arguments and hashes:\n{{buz 1 a=2}}\nBut it does not work with the new call syntax:\n{{buz (1 a=2)}}\nAnd it's actually an issue since old helper syntax does not support sub-expressions. So it's just impossible to implement something like this:\n{{buz ( func1() a=func2() ) }}\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Also, stache sub expressions are called more like functions.  To call foo, you write foo( arg1, arg2, propA=valueA propB=valueB): https://canjs.com/docs/can.stache.expressions.html#section_Callexpression\n\nHere's a similar example to the one you made:\nhttp://justinbmeyer.jsbin.com/vorote/2/edit?html,js,output\n. Ah, ok.  I'll check it out again.\n. @isadovskiy yes, this was a deliberate decision.  Call expressions are mostly intended to work well with arbitrary functions that might exist on view models or any other API. It's very common to want to do call arbitrary functions like:\nsomeMethod(1234,{foo: \"bar\", zed: \"ted\"})\nCall Expressions are designed to make this possible:\n{{ someMethod(1234, foo=\"bar\" zed=\"ted\") }}\nThey allow multiple object arguments too:\nsomeMethod(1234,{foo: \"bar\"}, {zed: \"ted\"})\n{{ someMethod(1234, foo=\"bar\", zed=\"ted\") }}\nAnd in a controlled order:\nrouteCurrent({page: 'recipe'}, true)\n{{ routeCurrent(page='recipe', true) }}\nAs this was an entirely new syntax, we decided flexibility was more important than interop with existing helpers.  \nIf this is an issue, you might want to checkout how we manage this in routeCurrent: https://github.com/canjs/can-stache/blob/master/helpers/route.js#L24\nYou can sniff out the type of expression and make a helper work both ways.  It's ugly, but you can probably make a wrapper function out of it:\nregisterHelper(\"something\", makeWorkAsCallAndHelperExpression(function(){\n   // logic that works with CallExpressions\n}) );\nI'd even support adding something like this as a utility in 3.0 if people would like it.\n. Yeah, I've not thought about providing a way to make a helper faster to lookup.  I optimized call expressions away from looking in helpers because they tend to be calling things on the VM.  This is why they look at helpers last.  \nI'm going to have think about this some.  Do you have any ideas?\n. @isadovskiy maybe we could do something like:\n{{%helpers.theHelper(items)}}\n?\n. @isadovskiy I would write that like:\n{{ %helpers.foo( %helpers.bar( %helpers.buz(0, buz=1), bar=2), foo=3) }}\nYeah, but assuming you don't have a foo, bar or buz in your scope (or your scope isn't massively deep), this shouldn't really be a problem.\n. Issue moved to canjs/can-stache #182 via ZenHub\n. @taai thanks for the fix.  IMO, there's nothing more right about declarations instead of expressions.  https://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/  except for those cases when a debugging tool can't give an appropriate name to the function.\n. fixed in 3.0 https://github.com/canjs/can-stache/blob/master/helpers/core.js#L25\n. Yes.  no one uses freenode anymore.  We are all on: https://gitter.im/canjs/canjs\nClosing for a similar previous issue https://github.com/canjs/can-stache/issues/16\n. Yes, I think @pYr0x might be looking at it too.  \nAll features are going to be added in 3.0, so that can-stache repo is the place to make changes.\n. What does \"while looking at the browser on localhost\" mean?  Do you mean runtime errors get thrown?\nWhy wouldn't the define plugin be the appropriate place?  It would effectively be a validation on what the view model needs to be inited with?\ncan-component could reach into the view model pretty easily and do this.\n. @imjoshdean \n\ndefine's focal point is maps, which aren't necessarily the focal point of components. \n\nA big part of CanJS is that components aren't the focal point of an application, the easily unit testable view model is.  Components only exist to combine a view model, template and tag.\nThe proposal would make components the focal point, which goes against good engineering practices.  Furthermore it creates a lot of redundancy.  Consider having to define all your properties in your view model:\njs\nDefineMap.extend({\n  onClick: 'function',\n  name: 'string'\n})\nAnd then to repeat that in a component:\nComponent.extend({\n  tag: 'custom-button',\n  props: {\n    onClick: PropTypes.function.isRequired,\n    name: PropTypes.string\n  }\n});\nAlso, how is this testable?\nNow we could relatively easy add better validation primitives to the define plugin:\nMyVM = DefineMap.extend({\n  onClick: {\n    type: 'function',\n    validate: PropTypes.function.isRequired\n  },\n  name: {\n    validate: 'string'\n  }\n})\nAnd then still unit test it:\nnew MyVM({name: 123}) //-> throws warnings, errors, or has a .valid() method\nIn general, good validations systems are able to be as close to the source as possible, but scale upwards.\nIt makes the most sense from a technical standpoint, and from a best-practices standpoint to make strong validation a feature of Maps.  \n\nThe type of validation done on maps and define is not developer-centric.\n\nI don't think a validation on a map versus a component would matter that much, especially if everything else happens on the map.\n. Moving to https://github.com/canjs/can-define/issues/62.  @imjoshdean let me know if this works.  I think required is a good idea.  It just belongs in the view model.\n. There technically shouldn't be anything to look out for as 2.3 is backwards compliment. There should only be new feature.  We can link to the 2.3 release article. \nIf there are things to look out for, please let us know. \nSent from my iPhone\n\nOn May 27, 2016, at 10:41 PM, Chasen Le Hara notifications@github.com wrote:\nIt would be really helpful if this page in the 2.3 docs had info about things to look out for when upgrading to CanJS 2.3.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Yes. Please send us a test case. \n\nSent from my iPhone\n\nOn May 30, 2016, at 3:39 AM, Guido Smeets notifications@github.com wrote:\nI used a filter within a getter. When the source list got replaced for a new list, it spammed a length change event on my getter for each item in the list.\nI managed to work around this by attr the source list length in my getter and just use can.map on the source list.\nStill seems like this is a bug though. Don't have a simple repro case atm, let me know if this is something you wish to investigate.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @gsmeets any updates? Thanks!\n. @gsmeets please let us know if you have a test case.  Otherwise, I'm going to close.  Thanks!. @akagomez can you move this to https://github.com/canjs/can-map-define and close it here?\n. (I accidentally closed it)\n. Anyway you can make that example more simple?  Are components needed?  \n\nOn first glance I don't know what to look for.  I'm sure I could figure it out, but the easier it is for me to understand, the faster I tend to look at issues.\n. Without looking at the example much, my guess is that you're setting something and expecting a compute's value to be updated immediately. That doesn't happen anymore.  I think there's a related issue explaining why, but this is as close as I found: https://github.com/canjs/canjs/issues/2323\nIn short,  batches are \"breadth first\" instead of \"depth first\".  A change happens, all computes are updated, but any listeners aren't fired until after the entire batch completes.\n. Can you tell me what I'm looking for?  I click a button and then a whole bunch of input boxes show up.  What should or shouldn't I see?  Why are 5 input boxes needed?\n. Ah yeah.  This is what I thought was going on.   \nWhen this runs:\nthis.viewModel.attr('section', \"showGrandChild\");\na batch is created, say batch 6.  All of its listeners will fire, including a listener that inserts grand-child an triggers inserted on it.\nHowever, in inserted, which is still running in batch 6, some actions take place that will fire other events:\nthis.viewModel.attr('inputBoxes').push(true);\nThose events are queued for the next batch (7), and not dispatched immediately, so the DOM never updates.  \nYou can use can.batch.afterPreviousEvents to be called after any previous actions have completed:\nhttp://justinbmeyer.jsbin.com/citacohapo/edit?html,js,console,output\n. You can use %viewModel\n. Referenced here: https://canjs.com/docs/can.stache.key.html\n. Closing for: https://github.com/canjs/can-stache/issues/17\nYou could create a not helper like:\ncan.stache.registerConverter(\"not\",{\n  get: function(source){\n    return !source();   \n  },\n  set: function(newVal, source){\n    source(!newVal); \n  }\n});\n{$disabled}=\"not(selected)\"\n. @marshallswain why do we have to even track the caseMatters?  Could we just stop toLowerCase()-ing what we get?\n. is it?  does that work?  Closing b/c it should.  I'll reopen if not.\n. can/list itself depends on can/map.  So we can't fix it that way w/o creating a cycle.  Closing as this is resolved in 3.0.\n. I labeled it \"needs a hero\".  You'll see other closed features/bugs with this label that the core team isn't indenting to fix.  We'll accept a patch if someone provides it.\n. @arti1793 This is because you aren't calling save and haven't specified the id property.  Your objects must have an id for update to be called correctly.  \nDemonstrated here:\nhttp://jsbin.com/kididu/1/edit?html,output\n\n. Thanks @wongpratan.  @chasenlehara why the ready label when there's no test?\n. There is a slot proposal we can do this in. \nSent from my iPhone\n\nOn Jul 5, 2016, at 7:28 AM, Matthew Phillips notifications@github.com wrote:\nThanks @rjgotten, couple of comments:\n1) Light DOM should already have the template's scope when using leakScope: false. If not it's a bug.\n2) Using  inside of each is not supported, it doesn't work in web components and only works by mistake in CanJS.  is not a template, it's a way to insert light DOM in a place inside of the local DOM (aka the shadow DOM).  is actually be deprecated from web components and being replaced by something called slots, which I think we want to implement in can-component, so I don't think further changes to  are a good idea.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Moving into: https://github.com/canjs/can-component/issues/4\n. There currently isn't a way to do this.  We might be able to make something like {{! {{foo}} {{bar}} }} work.\n. closing for issue in can-view-parser\n. Using a timeout works: http://justinbmeyer.jsbin.com/jedice/1/edit?html,js,output\n. So does can.batch.after: http://justinbmeyer.jsbin.com/jedice/2/edit?html,js,output\n\nIt's because the value is changing twice w/i the same batch so the 2nd event is ignored.  You need to make sure it happens after the batch completes.\n. I'm not sure what you mean. Yes, can can fire off events. I don't know what you mean by setter to call. What properties are being passed? \nIt's certainly a bug, but it's because the same object is changing within a batch back to its original value. \n. I think this can be closed?  I'm not sure what the issue is. Seems like new binding syntaxes work with after.\nPlease re-open if I'm missing something.\n. Issue moved to canjs/can-stache #183 via ZenHub\n. It's not worth adding a branch in dispatch (which is canjs's most performance sensitive code). Perhaps a different version can be added to maps. \nSent from my iPhone\n\nOn Jul 21, 2016, at 8:09 AM, Guido Smeets notifications@github.com wrote:\nCouldn't dispatch on viewModels handle single objects as well? This has confused me a few times already. i.e. handle:\nthis.dispatch( \"foo\", fooData );\nas if it was:\nthis.dispatch( \"foo\", [ fooData ]);\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. please open in can-define if you'd like to see this in 3.0.  Thanks!\n. Use serialize:true. And use the serialize method. This is a duplicate issue. \n\nSent from my iPhone\n\nOn Jul 21, 2016, at 8:30 AM, Kyle Gifford notifications@github.com wrote:\nCurrently, can.Map.attr() only exports non-derived properties when it creates a raw object. We have a need to pass both derived and non-derived properties to a third-party library, but there is currently no interface for this.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. closing for issue in can-define.\n. The define plugin is pretty much the most useful thing ever and is standard for every/any modern CanJS app.   So don't worry about brining it in.\n\nRegarding why this is ... it's related to how JS works.\nLets start with:\njs\ncan.Component.extend({\n  viewModel: {\n    stars: new can.List([\n      {selected: false},\n      {selected: false},\n      {selected: false},\n      {selected: false},\n      {selected: false},\n    ])\n  }\n}\nThis is just sugar for:\n``` js\nViewModel =  can.Map.extend({\n    stars: new can.List([\n      {selected: false},\n      {selected: false},\n      {selected: false},\n      {selected: false},\n      {selected: false},\n    ])\n});\ncan.Component.extend({\n  viewModel: ViewModel\n});\n```\ncan.Map.extend is simply setting up the prototype of the ViewModel constructor.  It's almost something like this:\njs\nViewModel = function(){}\nViewModel.prototype.stars = new can.List([\n      {selected: false},\n      {selected: false},\n      {selected: false},\n      {selected: false},\n      {selected: false},\n    ])\nWith this last bit, hopefully you can see how the same stars can.List will be shared by every instance of ViewModel.  If this doesn't make sense, give this a watch:  http://blog.bitovi.com/training-series-prototypes/\nThis is just how prototypes work in JS.\nI suppose we could document this here: https://canjs.com/docs/can.Map.prototype.DEFAULT-ATTR.html\nIn 3.0, with DefineMap, this syntax is no longer available.  You have to use a value definition.  And it does warn of this http://canjs.github.io/canjs/doc/can-define.types.value.html:\n\nIf the default value should be an object of some type, it should be specified as the return value of a function (the above call signature) so that all instances of this map don't point to the same object. For example, if the property value above had not returned an empty array but instead just specified an array using the next call signature below, all instances of that map would point to the same array (because JavaScript passes objects by reference).\n. So I'm not sure my suggested will work.\n\nWhile {{#eq page 'view'}} is being bound before the myPage.get.  The reason myPage.get is updated first is because it is bound more directly to .page.   {{#eq page 'view'}} has a few more intermediate computes.  \nThe order of dispatching shown here:\n\nThis is because we do breadth first dispatching now.\nHowever, we might be able to get around that now that we have the ability for computes that are being read to \"make sure everything up to their depth\" has been updated before providing a value.\nThis might be able to solve the problem.  But I've got to go through some of the other use cases to make sure.\nAnother alternative might be zones.  We could use them to know the DOM's hierarchy and make sure primary depth is set on any compute a component is building.  (We might be able to do this w/o zones even).  \nI need to chew on this.\n. I'm not sure a depth first search will work either.\nThe problem is that when {{#eq}} helper starts to evaluate, it will read {{#eq}} other arg which will not provide a value until all lower depth computes have been updated, including myPage.get.\n\n. this is fixed in can-set.. closing for issue in can-route\n. yes.  Closing as it's gone in 3.0 and the new site will be up.\n. but it shouldn't be can.view.attr in can/can.  It should be can.viewCallbacks.attr or can.view.callbacks.attr.\n. I think this means that you used to be able to do:\nMap.extend({\n  define: {\n    name: \"Justin\"\n  }\n})\nw/ DefineMap, the following would think that Justin is a type:\nDefineMap.extend({\n  name: \"Justin\"\n}). He is probably talking about this:  \nMap.extend( { name: \"Justin\" })\nSent from my iPhone\n\nOn Mar 10, 2017, at 1:43 PM, Robert Lin notifications@github.com wrote:\nI tried doing this in a JSbin using canJS 2 and it doesn't work.\nMap.extend({\n  define: {\n    name: \"Justin\"\n  }\n})\nI get this error:\nTypeError: Cannot use 'in' operator to search for 'value' in Justin\n    at Object.mapHelpers.define (http://canjs.com/release/latest/can.jquery.js:8609:29)\n    at Function.setup (http://canjs.com/release/latest/can.jquery.js:2997:32)\n    at Function.extend (http://canjs.com/release/latest/can.jquery.js:2719:95)\n    at venaje.js:1:957\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. It is documented\n\nhttps://canjs.github.io/canjs/doc/can-stache.helpers.routeUrl.html\nAs its in a separate module, it's implied it needs to be imported\nSent from my iPhone\n\nOn Aug 26, 2016, at 9:35 PM, Julian notifications@github.com wrote:\nthe routeURL helper (here the old site: https://canjs.com/docs/can.stache.helpers.routeUrl.html) is not documented on the new canjs 3.0 documentation.\nit is also important, that you have to manually import can-stache/helpers/route to getting the routeURL helper\nimport 'can-stache/helpers/route'\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. closing for https://github.com/canjs/can-route/issues/21\n. this freezes things: http://jsbin.com/fodafo/edit?html,js,output\n. closed by: https://github.com/canjs/can-observation/issues/14\n. @pYr0x I think the styles are removed.  Anyone got the energy to create an example?\n. I really think there is a way to remove the rules\n\nSent from my iPhone\n\nOn Sep 3, 2016, at 11:04 AM, Matthew Phillips notifications@github.com wrote:\nThis is not a fixable issue. The same way this is not conditional in JavaScript:\nif(someCondition) {\n  import \"foo\";\n}\nstache templates are statically analyzed to determine what should be imported up front and what should be imported based on runtime conditions. This is how JavaScript ES modules works too.\nAn {{#if}} is just a helper and there is no special logic to handle it. You could have a custom helper in your template that did:\n{{#myHelper}}\n  \n{{/myHelper}}\nWhich we can't statically determine if this is a conditional type of helper or not. So we need some rule based on syntax to determine if something is intended to be static vs. dynamic. That syntax rule is currently self-closing vs. not self closing.\nWe could in the future switch to some different syntax rule. Maybe an attribute like dynamic. Suggestions welcome here.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @MarcGodard I think @matthewp explained this.  <can-import/> vs <can-import></can-import> is the same difference between import \"jquery\" and System.import(\"jquery\").  The difference in syntax helps us distinguish static vs dynamic imports.\n. You wouldn't want it to always work like System.import. Css and less should be part of the static dependencies. But it also should be possible to progressively load. \n\nSent from my iPhone\n\nOn Sep 5, 2016, at 3:14 PM, Marc Godard notifications@github.com wrote:\n@justinbmeyer I understand that, but it wouldn't be too hard to change it for css/less files to always work like System.import() This would save new people a lot of potential hassle and would be better in other ways as well. I am just going to close this, because otherwise you guys don't understand what I am saying or I am completely wrong.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @matthewp I'm confused why we can't make dynamic <can-import></can-import> of styles able to remove the stylesheet when the element is removed?\n\n<can-import>'s behavior, imo, should be relatively divorced from steal's behavior.  It's a layer that uses steal, but it's steal itself.  It can have it's own behaviors and abilities.\n. There's probably just some places that import module names like foo/bar/ when they should be foo/bar/bar.  We just need to fix them. \nSent from my iPhone\n\nOn Sep 4, 2016, at 6:27 AM, Julian notifications@github.com wrote:\n@blackmamba i think there is actual no workaround for that. i think you have to use steal.\nbut it is a good question to ask @matthewp or @justinbmeyer why canjs 3.0 is not usable with nodeJS. canjs 3.0 is written in commonJS and it is all modular. so why do we have to use steal for loading canjs in node. forget at this point the DOM problem. we can workaround with can-simple-dom\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @blackmamba this isn't priority right now, but it will land before 3.0.  If you can submit pull requests, that will be very helpful.\n\nA virtual dom will need to be included explicitly for stache to work (possibly not for it to be loaded).  For example, can-view-target imports some can-util/dom utilities: https://github.com/canjs/can-view-target/blob/master/can-view-target.js#L8\n. Issue moved to canjs/can-stache #184 via ZenHub\n. Properties are different from methods. You call methods like viewModel.method(). \nSent from my iPhone\n\nOn Sep 3, 2016, at 4:32 PM, edba notifications@github.com wrote:\nUsing the viewModels \"attr\" function to get a function that is assign as a property in the viewModel will return undefined.\nExample: http://jsbin.com/kayomi/15/edit?html,js,console\nI was expecting the function to be returned when using \"attr\" as it works for any other property on the viewModel.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @edba This should be fixed with can-reflect like:\n\ncanReflect.apply( item, canReflect.getKeyValue( item , \"method\"), [] );\nYou could also use can-observation/reader right now like:\nreader.read(this.viewModel, reader.reads(\"method\"), {}). I'm not sure there's a way currently.  Good catch!. Issue moved to canjs/can-stache #185 via ZenHub\n. Weird.  I thought we fixed this in 3.0 by making values sticky here: https://github.com/canjs/can-stache-bindings/issues/122 ... Moving to can-stache-bindings.. Issue moved to canjs/can-stache-bindings #162 via ZenHub\n. or we could just do what the old docs have done ... we have the docMap, with everything's titles.  We can have it just search w/ that.\n. We might be able to use lunr.js with the docMap.  The problem is that the docMap can be quite big.\n. @mickmcgrath13 Can you update this post with where you got?. Issue moved to canjs/can-stache #186 via ZenHub\n. Move to: https://github.com/canjs/canjs/issues/2491\n. - [ ] - can we remove contentType: 'application/x-www-form-urlencoded'\n. Issue moved to canjs/can-stache-bindings #163 via ZenHub\n. Probably don't want to run the compute\nSent from my iPhone\n\nOn Sep 20, 2016, at 6:53 AM, Garrett notifications@github.com wrote:\nFor #2318.\nAdd a compute for listening to object changes in the each helper.\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/canjs/canjs/pull/2504\nCommit Summary\nAdd a compute for listening to object changes in the each helper.\nFile Changes\nM view/stache/mustache_helpers.js (9)\nM view/stache/stache_test.js (13)\nPatch Links:\nhttps://github.com/canjs/canjs/pull/2504.patch\nhttps://github.com/canjs/canjs/pull/2504.diff\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I'll be online in about 20. I can help you out with it then. \n\nSent from my iPhone\n\nOn Sep 20, 2016, at 7:39 AM, Garrett notifications@github.com wrote:\nProbably don't want to run the compute\nYeah, this probably isn't the best way to go about it, but it seems to work. Not running it breaks other tests.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Issue moved to canjs/can-construct #36 via ZenHub\n. @airhadoken Thanks!  I don't think this is exactly legacy.  I'd say more \"ecosystem\".  Will this show up under \"ecosystem\"?\n. works in 3.0. . @daffl can this be closed? Or should it be re-openned to master?\n. Thanks for reporting.  I think this is a duplicate of another issue.  I thought setters were Observation.ignore-ed so whatever they read can't be watched by a compute.  But it seems like that's not the case.\n\nIn general, anything involved with setting state shouldn't be observable.  However, it's hard to differentiate a read that is part of setting state, and a read for deriving state.\nFor 3.0, we could make any constructor and setter Observation.ignore-ed by default. Also, we can make Observation.ignore public so it's easier to spell out these cases:\njs\nvar compute = can.compute(function() {\n  console.log('getting compute');\n  return Observation.ignore(function(){\n    return new PaginateVM();\n  })();\n});\nThoughts?\n. Observation.ignore is public and this is fixed in DefineMap.  Moving to can-map-define. Issue moved to canjs/can-map-define #32 via ZenHub\n. This is fixed with DefineMap: http://justinbmeyer.jsbin.com/conupel/1/edit?html,js,console which initializes values dynamically (it's much smarter ... value isn't called until the first time the property is read).\nBack porting this to Map might be tricky.  I think @akagomez gave it a try, but it appears to not work in all cases.  Although as a work around, you can define your properties in the order they should be instantiated: http://justinbmeyer.jsbin.com/ticevo/1/edit?js,console\nI'm going to close this and label it \"needs a hero\".  I'll help / pair with anyone who wants to fix it.  But I'm not going to pursue it at this time.\n. re-openned.   I'm going to label it P4.  It's still a bug ... we should fix it if we get time.\n. Issue moved to canjs/can-map-define #33 via ZenHub\n. This is mostly a question of how badly to we want to make people's migrations for a bit of code cleanup on our end.\nThe only way we should remove this is to make sure we give people very strong warnings in the next release of 2.3.  That way they can see where they are doing this, and take the correct steps to change it before upgrading to 3.0.\n. We didn't do this.  We would have to make this happen in can-stache-bindings 4.0. Issue moved to canjs/can-stache-bindings #164 via ZenHub\n. fixed in 3.0\n. He's upgrading to 2.3. \nA temporary work around would be to create the constructor like:\njs\nlong.path.name[\"switch\"] = Type.extend({ ... },{ ... })\n. Yeah, that should work. \n. @lewismoten Anyway you can create an example?  Moving to can-model.. Issue moved to canjs/can-model #18 via ZenHub\n. Issue moved to canjs/can-view-scope #55 via ZenHub\n. Looks like this works in 3.0: http://justinbmeyer.jsbin.com/lenomid/2/edit?html,js,output\n. - [x] can-stache-converters\n- [x] can-ejs\n- [x] can-vdom\n. And then there's can itself.  But lets wait on that.\n. @daffl looks really good.  I put in a few notes on things I found confusing in > blockquotes in this commit:\nhttps://github.com/canjs/canjs/commit/f23b272d486404e16ecd871537f49d63daff1ad9\nAnyway you can check them out, make any changes you feel necessary, and then remove the blockquote parts.\n. The PMO guide should probably be removed for now.\n. I hid pmo\n. @sarathnair thanks for the pull request.  @daffl I'm sorta afraid to merge this b/c I'm not sure what happens after 3.0 got merged into master.  I'll let you do the honors.\n. I think can-import is probably written out already escaped so things are escaped twice. We just need to change can-imports docs. \nSent from my iPhone\n\nOn Oct 28, 2016, at 5:41 PM, Garrett notifications@github.com wrote:\n@justinbmeyer I may need your help understanding escaping in bit-docs. I figure the fix should be made in bit-docs-generate-html/stmd.js, but any change I make there breaks everything...\nThe use of < in signature blocks also comes across escaped, but not >. So that is somewhat related.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. It should be moved over to can-connect.  It's probably just the path having too many ../\n. I think this already a can-define issue. Please try to create bugs in the right repo. \n\nSent from my iPhone\n\nOn Oct 27, 2016, at 1:35 AM, Brian Moschel notifications@github.com wrote:\nhttp://canjs.github.io/canjs/doc/can-define/map/map.html\nThe rest of the Core API top-level pages have a Use section. DefineMap is important enough it should have one too.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Closing for: https://github.com/canjs/can-define/issues/82\n. closing for issue in can-connect\n. cleared a bunch.\n.  The individual repos may publish this (some do), but it's  not canjs/canjs's job. \n\nBrowserify should work too. I think there's few people left on AMD alone. \nSent from my iPhone\n\nOn Oct 28, 2016, at 1:43 PM, Adam L Barrett notifications@github.com wrote:\nOur npm package for can should include a dist folder with the built gloabal/amd stuff?\nCurrently our release tags do have global https://github.com/canjs/canjs/tree/v3.0.0-pre.17\nI think it would be nice to have the amd and if possible a umd distribution file too. This would be good for anyone who uses npm for packages but not steal or webpack.\nThis would also make our stuff more available through the unpkg.com cdn which is good for demos and such.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Yes. All lowercase\n\nSent from my iPhone\n\nOn Oct 29, 2016, at 2:25 AM, Marshall Thompson notifications@github.com wrote:\nIn the docs sidebar, some of the modules have Initial caps and most others are all lowercase. Do we want all lowercase?\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I thought this is fixed in 3.0, but this is a duplicate of: https://github.com/canjs/can-stache-bindings/issues/162. http://canjs.com/doc/can-view-autorender.html. @phillipskevin is this closed?\n. @mickmcgrath13 I just tried this.  I did not see the error.  Does this always happen for you?  What is your browser version?\n. do sync for now.  Open an issue in bit-docs-generate-html to eventually handle promises.\n. We still plan to get an updated version in. . Yes. Maybe I like pain. . I don't think we need one for Withdrawal.  it would be the same test. It's a guide.  \n\nSame with the withdrawal info page ... no tests needed.\nThe guide gets across the point w/o needing these.\n. Well, I was thinking we might explain why they aren't there.  I could see people being confused.\n. Make sure to create a separate issue so I remember to update the JSBins with this change (has to be me as I have the account).\n. @phillipskevin For now, I would prioritize preventing errors/bugs over \"fuzzy use cases\".  This means, I wouldn't worry about making a can-observation-stack and handle this in can-observation.\nFor can-tags .... I have to think about that.  I'm wary of getting too deep into defining the behavior of a tag because for all intents and purposes, tags are really just stache mixins.\nI think can-tags needs to be part of a large discussion on how we could support:\n\nmultiple template engines\nmultiple binding syntaxes\nmultiple \"types\" of components (can.Component, can.Element)\n. Maybe it's me, but I find that font still pretty hard to read.\n. they look great!. what is this issue?. Thanks! We will accept them if you make them. \n\nSent from my iPhone\n\nOn Nov 25, 2016, at 6:47 AM, Per Ehnbom notifications@github.com wrote:\nHi, yes I've identified the problems. Im happy to submit pull requests to\nthe repos. It's the first time I do that for CanJS but I guess it shouldnt\nbe too hard.\n/Per\nOn Fri, Nov 25, 2016 at 1:36 PM, Matthew Phillips notifications@github.com\nwrote:\n\nCan you submit PRs to those repos? Looks like you already did the work to\nidentify the problems.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/canjs/canjs/issues/2780#issuecomment-262949350, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AIjm-62kNZh55jAZrgRUTKXCBhvTOVwJks5rBtZQgaJpZM4K8ScO\n.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n\n. Thanks for making these!  I've started publishing them.  So far only:\n- can-util 3.0.13\n- can-compute 3.0.4\n- can-simple-map 3.1.0\n- can-view-live 3.0.2\n- can-view-model 3.1.1\n- can-stache 3.0.10\n\nI will get to the rest you've already made pull requests for today.\n. Thanks!  Please let others know ( http://v3.canjs.com/doc/guides/contributing/evangelism.html ) and let us know if there's anything we can do to help you be successful on your project.  . I published those first 6 packages.  Please let me know if I need to publish any others immediately so you can get work done.  Otherwise, they will be published next week along with CanJS 3.2.. Yes, it can be removed\nSent from my iPhone\n\nOn Nov 29, 2016, at 8:06 AM, Matthew Phillips notifications@github.com wrote:\nSince can-connect uses a regular CommonJS structure now I don't think it needs the \"browser\" config any more. True @justinbmeyer @phillipskevin ?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Sounds good. Thanks!\n\nSent from my iPhone\n\nOn Dec 5, 2016, at 1:14 PM, Chasen Le Hara notifications@github.com wrote:\n@justinbmeyer, here\u2019s a rough agenda for what I\u2019ll go through with each person tomorrow:\nAsk some questions to establish their familiarity with JavaScript and CanJS (5 minutes)\nDirect them to the CanJS homepage, have them go through it and get their feedback (5\u201310 minutes)\nLet them browse around the site a bit based on what they\u2019re interested in (15\u201320 minutes)\nIf they haven\u2019t already, direct them to pages like Mission and Technical Highlights to get their feedback (15\u201320 minutes)\nBreak! (5\u201310 minutes)\nHelp them pick an experiment guide (e.g. the Chat or TodoMVC guides), have them go through it and collect their feedback (30\u201390 minutes)\nClosing thoughts: collect general feedback about the site, framework, etc. (10\u201315 minutes)\nPlease let me know if I\u2019ve left out something you\u2019d like me to cover.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. If someone wants to help see this through, we'll get a release out.. @phillipskevin any idea why this build failed?. They all work for me.  Can anyone else verify?  @joe-crick are you on a mac?  Which page are you specifically on?  http://v3.canjs.com/doc/guides/atm.html works for me.. Agreed ... but lets wait on this until Bitcentive proves that they are working together fine.  I'd probably have a section around 3rd party integrations ... Kefier would be another sub-point.. - @package ./package.json\n- @parent can-ecosystem\n- require(\"your-package\") in ecosystem.js\n- require(\"your-package/test\") in test.js\n- in canjs.md\n  - add highlight like:\n\n- **[can-fixture]** <small><%can-fixture.package.version%></small> Simulate AJAX requests\n    - `npm install can-fixture --save`\n    - <a class=\"github-button\" href=\"https://github.com/canjs/can-fixture\" data-count-href=\"/canjs/can-fixture/stargazers\" data-count-api=\"/repos/canjs/can-fixture#stargazers_count\">Star</a>\n  - \"can-fixture-socket\": \"<%can-fixture-socket.package.version%>\",. There's no \"hard requirement\" to use bit-docs in he source repo. \nSent from my iPhone\n\nOn Dec 23, 2016, at 12:29 PM, Kevin Phillips notifications@github.com wrote:\nThe first two bullets in @justinbmeyer's comment are about the source repo. I think those are the only real requirements. Are there other things you're finding?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. This is probably a bug with can-view-live.list.  In general, the computes passed to can-view-live have a primaryDepth.  But I think this is ignored by can-view-live.list.  \n\nI think that can-view-live.list should opt into the same \"update schedule\" that computes have.  This is something @phillipskevin and I talked about with a recent can-view-live.list change.. Closing for https://github.com/canjs/canjs/issues/2447. Can you open all issues like this in bit-docs-html-canjs?  It's easier to consolidate functionality issues that way. \nSent from my iPhone\n\nOn Dec 11, 2016, at 8:00 PM, Chasen Le Hara notifications@github.com wrote:\n@justinbmeyer and I talked about following a similar pattern to what\u2019s used by the DoneJS and MDN sites: a table of contents that sticks to the right as the user scrolls.\nI think this would be more visible to users and would also help with the content not being so wide on widescreen displays.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Yes, new users won't find this relevant.  I don't think this is a good enough reason to move it.  The guides page contains all sorts of guides.  . I think: http://canjs.com/doc/can-core.html does about as succinct job of doing this as possible.. Where would we move the API page?  Why would moving it make it less daunting?  . the idea behind all the libraries was to make it less monolithic :-(. It's structure based on the most critical choices people tend to make ... namely browser support being the first choice.  Then, it hits size which is a common comparison metric between frameworks.  The next two should be convincing to new users as they are core parts of CanJS's mission.  . This works for me in bitballs. You might have to set the ._listSet property on the list. I'll check it out Monday. \n\nSent from my iPhone\n\nOn Dec 11, 2016, at 8:41 AM, Per Ehnbom notifications@github.com wrote:\nI\u2019ve working on migrating an app from CanJS 2 to Canjs3. I would like to use DefineMap instead of can.Model, there\u2019s a lot of good features in the new DefineMap, but have come across a couple of problems in the work:\nI have a model which in turn has a list of other models as a property, e.g. a project contains a list of todo items.\nvar Project = can.DefineMap.extend({\n  items : {\n    Type : Item.List\n  }\n})\nWhen calling destroy on one of the todo items, it is not removed from the list. Automatic removal on destroy works fine if I instantiate a Item.List directly through can-connect, but not if it\u2019s part of the project model. The same problem applies when I instantiate an Item.List without using can-connect, but by using a constructor with json, e.g. new Item.List(json)\nIn can.Model, the removal of items relied on the change event bubbling up to the list, but there\u2019s another mechanism used in DefineMap. I do miss the change event bubbling up, it was handy to use when e.g. implementing live bound sorting or other types of live updates on lists.\nI have setup a jsbin which highlights the problem. 3 different lists are defined, and after a second, the first item in each list is destroyed. Only in one of the lists the item is removed from the list: http://jsbin.com/gagepa/edit?html,js,output\nFor a more comprehensive example, see https://github.com/perehnbom/tryout-canjs3\nI wonder if there\u2019s a simple way of achieving this. For now, this is a blocker for me in order to move to DefineMap from Model. The application I'm upgrading is https://www.agiloo.com, an app that relies heavily on live updates in models and model lists and fetches data both by ordinary ajax and by pushing out updates through socket.io.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. This JSBin shows the items in a list example working.  It does it by making sure that .__listSet is set on the list:\n\nitems : {\n      set: function(items){\n        if(items) {\n          items.set(\"__listSet\",{projectId: this.id})\n        }\n        return items;\n      },\n      Type : Item.List\n    }. The JSBin I shared isn't perfect.  The set {projectId: this.id} won't accurately represent your set because items don't have a projectId.  The following will explain ....\nIn 3.0, adding and removing items is done with the real-time behavior.  \nThe real-time behavior adds and removes instances to/from lists using the the params used to retrieve a list.  For example, if you load items like:\nItems.getList({projectId: 5});\nBy default, it's expected the server will respond back with item data like:\njs\n{\n  data: [{id: 55, name: \"something\", projectId: 5}]\n}\nThis is so the following will pass:\nalgebra.has({projectId: 5}, {id: 55, name: \"something\", projectId: 5}) //-> true\nRead more about this here: http://canjs.com/doc/can-set.html#SolvingCommonIssues\nLet me know if that's enough to get you started.. In the base connection docs. \nSent from my iPhone\n\nOn Dec 11, 2016, at 6:46 PM, Chasen Le Hara notifications@github.com wrote:\n@justinbmeyer, are there docs for __listSet (or this general issue) anywhere?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. it's optional if it's not being observed.  In most cases, it's optional.. @matthewp \nWe should make it be a function like items.defineListSet(set) or items.listSet(set) or something like that.\n\nMaking it a function wouldn't necessarily help.  It's double underscore because that's the default property name.  It can be whatever anyone wants.  \n@Bajix Please elaborate on what you mean in a new issue with much less code to parse through.  . I'm not sure about this. I'd rather teach them the short hand as they are extensively used elsewhere and encouraged. \nSent from my iPhone\n\nOn Dec 11, 2016, at 8:53 PM, Chasen Le Hara notifications@github.com wrote:\nAs users go through the guides for the first time, the shorthand syntax for some of our APIs doesn\u2019t make sense to them, so they\u2019re not able to understand the code as well as they could if the longer-form APIs were used.\nHere are some examples:\npage: \"string\" in the Chat Guide\u2019s Route between two pages section: it looks like string is the value of page, not that its the type definition\ntodos: Todo.List in the TodoMVC Guide\u2019s List Todos section: UX testing user thought they would\u2019ve had to use new Todo.List() to create a new list of todos\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. The UI doesn't work at all until we add things to it. The idea is that a designer hands over the complete HTML and CSS. We should just make that clearer. \n\nSent from my iPhone\n\nOn Dec 11, 2016, at 8:54 PM, Chasen Le Hara notifications@github.com wrote:\nDuring the UX testing sessions, this came up for both users in different ways:\nOne was confused why we didn\u2019t make the filters UI its own component, like we had the others\nA different user was confused at the very beginning why the filters UI didn\u2019t work\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. The only reasonable way I think we can do this is to have some sort of special comment that bit-docs picks up ...\n\njs\n/** @source-for can-component/beforeremove */\nvar nodeList = nodeLists.register([], function() {\n  domDispatch.call(el, \"beforeremove\", [], false);\n  if(teardownBindings) {\n    teardownBindings();\n  }\n}, componentTagData.parentNodeList || true, false);\nThis way we could move the source-for tags around as the code changes.  . I'd rather just have a copy to clipboard. Otherwise this will be annoying to maintain. \nSent from my iPhone\n\nOn Dec 11, 2016, at 8:56 PM, Chasen Le Hara notifications@github.com wrote:\nGiving users a JS Bin at the beginning or end of each section could help them if they:\nmess up their version and want to get a working version to continue going through the guide\ncontinue the guide later without saving their JS Bin\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @chasenlehara , it doesn't use 2015 syntax as far as I can tell.  It uses ES5 getters (supported in IE9 even).  Closing, will re-open if I'm mistaken.. please move this to bit-docs-html-canjs. I've been trying to limit accessibility to the helpers scope.  I'm not even sure call expressions should be allowed to access it.  \n\nWhat do you mean by:\n\nThis mostly comes into play when you (manually) backport the binding converter syntax to CanJS v2 and e.g. attempt to use it with local converters passed via the helpers property of a Component. . Those extra arrows are meaningful in state diagrams. \n\nSent from my iPhone\n\nOn Dec 12, 2016, at 5:33 PM, Chasen Le Hara notifications@github.com wrote:\nThis image in the ATM Guide needs to be replaced with something that:\nDoesn\u2019t have the red wiggly lines\n Is high-DPI\n Doesn\u2019t have extra arrows (see near unverified, Picking Account, and Withdraw Info)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Those are the entry points for substates.  This is a special hierarchical form of state diagram.  \n\nThe one on unverified means that substate starts at unverified.  \nFor the other ones, it's trying to show that a \"transaction\" starts at invalid ... though the \"ATM\" starts at picking account.  The hierarchy is flipped upside down a bit there.  However, I'm not sure that fixing it would make things easier to understand.\nThe reason things are odd ... is that picking an account and picking deposit or withdraw are mutually exclusive to a \"Transaction\" but represented as sequential for the \"ATM\".\n. Does it work in older releases?\nSent from my iPhone\n\nOn Dec 13, 2016, at 5:56 PM, Kevin Phillips notifications@github.com wrote:\nThis JSBin (which is shown here) is not working.\nHere is the error:\nUncaught TypeError: compareOrder is not a function\nrunner-3.40.2.min.js:1 error TypeError: compareOrder is not a function\n    at https://unpkg.com/can@3.2.2/dist/global/can.all.js:8049:28\n    at Array.sort (native)\n    at Object.subsetData (https://unpkg.com/can@3.2.2/dist/global/can.all.js:8048:31)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @arti1793 can you open this up here: https://github.com/canjs/can-stache-bindings . I still think we need to keep use the new can-* packages and can-map -> can-define in separate tasks. Perhaps:\n\n\nPre-migration preparation\nMinimal migration path\nModernized migration path\nLatest & greatest migration path \nAvoid future deprecations and removals. @chasenlehara if they aren't using justinbmeyer JSBins, will they work via https?  Does CanJS work via HTTPS?. @chasenlehara I think only a paid account can be embedded in https.  . Thanks for reporting. Is this a problem with 3.0? Can you move this issue to can-stache?\n\nSent from my iPhone\n\nOn Dec 21, 2016, at 3:28 PM, Liz Tom notifications@github.com wrote:\n{{@index 1}} offsets the index by 1 but `{{%index 1}} does not offset the index.\nExample:\nhttp://jsbin.com/takufujuge/edit?html,js,console,output\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Can you open this up under can-stream?. @matthewp the problem is that something like can-observation/reader needs to know about every possible type (Map, DefineMap, compute, etc), so it knows to call .attr, .get, or ().  A similar problem exists in can-route and a few other places in CanJS.\n\nThis proposal would allow each type to define how basic operations should be performed on it.  This should result in more maintainable and flexible code.  Different types, like an observable Set can be added without changing anything else.  We'll also have some useful methods like forEach to offer people who want to similar flexibility.  . @matthewp  can-observation/reader and can-route would benefit directly.  But in general, anything that has to interact with a Type would benefit.    A lot of code has been shifted to use can-observation/reader already.  But can-observation/reader is a terrible piece of code because it has to have implicit knowledge of every other type.  \nAlso, can-observation/reader is really designed for can-stache as it automatically \"calls\" functions (foo) if given something like foo.bar.  This would make a layer of functionality ignorant of an end goal like can-stache.\n. Another consideration ... What about types like Promise where we might want to read a .value, .isRejected, or .reason type virtual property uniformly across anything using get(obj, prop)\nTo address this, we could use some type converter to be used.\njs\nvar typeConverter = new Map();\ntypeConverter.set(Promise, ObservablePromise )\nAnother alternative is providing a \"get\", but not as a symbol:\n```\nvar typeGetter = new Map();\ntypeConverter.set(Promise, function(promise, prop){ ... } ) \ntypeConverter.set(Element, function(element, attribute){ ... } ) \n```\nIf there are things like element attributes or properties, these would allow automatic binding on a lower-level than can-stache-bindings like:\njs\nget( input, \"value\" )\n. Related: https://github.com/canjs/can-util/issues/103. Closing for: https://github.com/canjs/can-operate/issues/1. closing as this is part of #2957. @matthewp this is breaking because of node test/build.js and errors with the following:\ncanjs justin$ node test/build.js \nOPENING: can/test/test\nPotentially unhandled rejection [5] TypeError: Error loading \"socket.io-client@1.7.2#dist/socket.io\" at file:/Users/justin/dev/canjs/node_modules/socket.io-client/dist/socket.io.js\nError loading \"socket.io-client@1.7.2#dist/socket.io\" from \"can@3.3.1#test/test\" at file:/Users/justin/dev/canjs/test/test.js\nMultiple defines for anonymous module\n    at /Users/justin/dev/canjs/node_modules/system-parse-amd/system-parse-amd.js:354:12\n    at getDefs (/Users/justin/dev/canjs/node_modules/system-parse-amd/system-parse-amd.js:439:4)\n    at processSource (/Users/justin/dev/canjs/node_modules/system-parse-amd/system-parse-amd.js:318:3)\n    at Loader.loader.instantiate (/Users/justin/dev/canjs/node_modules/system-parse-amd/system-parse-amd.js:266:9)\n    at Loader.System.instantiate (/Users/justin/dev/canjs/node_modules/steal-tools/lib/trace.js:59:31)\nThe test/test.js module loads fine in development, including the socket.io-client@1.7.2#dist/socket.io module.  Can you think of a reason this would break in only the build?  Thanks!. > Ignore the following!!! it's because 'socket.io-client/dist/socket.io' is imported directly.\nConfusingly, in the client, the System.npm configuration points to \"./lib/index\":\n\nBut the only thing loaded in the client is socket.io-client/dist:\n\nIf I open up socket.io-client/package.json, I don't see where anything is pointing at dist.  . Going to close this for: #2957. It's at the bottom of http://canjs.com/doc/can-map-define.html\nHowever, we need a DefineMap version.. Source for the demo is here: https://github.com/canjs/canjs/blob/master/demos/can-map-define/make-model-year.html. This is fixed here: https://github.com/canjs/canjs/blob/master/package.json#L153. @rjgotten I think what you are saying is reasonable.  I'd accept a patch with this change and we can get out a new 2.3 release. (3.0 doesn't have %root anymore).. The following is an example of a bitballs template I updated: https://gist.github.com/justinbmeyer/cf19ed9789417f3c1f068707b45cc006\nMy concern with this is that ; might not be enough of a visual indicator that something is going on.\n. @matthewp JS looks like Java.  Java looks like C.  If we couldn't re-use existing syntax, we'd run out of ways for expressing things very quickly.  a.b is a great way of accessing things.  a() is a great way of \"running\" something.  { CODE } is a great way of indicating there's some block of code ( some languages do it with indention ).\n\nIn JavaScript for loops are for side effects and don't return as expression.\n\nThere are many use cases for for loops that don't involve side effects ... unless you are counting the iterator variable as a side effect.  \n\nAlso, it seems like this idea would require the language to constantly change as JavaScript itself changes, and that would be a difficult thing to keep up with.\n\nThis is what React had to do prior to babel.  They've shifted this to them.. > Why not a syntax that is JS instead of mostly JS?\nThis layer can still exist (as it does with react).  But it will be gross.  . @phillipskevin Creating bindings will involve making and passing computes around.  A two-way binding will need a special call.  . @phillipskevin it could still look like can-stache-bindings, but probably had different rules around expressions.  For example {prop}=\"method\" would need to be {prop}=\"method()\".. @phillipskevin ideally, data-bindings can operate somewhat independently from view-bindings.. To be clear about this proposal, it was only intended to spark a discussion.  Specifically, about what a react-like library with fewer magic tag delimiters might look like and how we might take the cutting edge a bit further.\n@matthewp you are right about the for loop, though this still could be JavaScript if the context of where the loop is (within a tag expression) is taken into account. \nI really have no great ideas on what the future of JS <=> DOM interplay should look like.  Perhaps there shouldn't even be JS <=> DOM interplay.  \nI'm going to close this issue as hopefully its spirit will live on.  Lets get crazy and start brainstorming wild ideas.  If you are reading someone else's idea, adopt is spirit and try to figure out how to make it better.\n. @matthewp as there are no semicolons, it \"knows\" No Keys and Keys have to be text.. @matthewp you would \\{ your curlies.  . I'm making the assumption that {} isn't super common in straight html.  Stache / dash / etc already make this assumption and expect you to escape it.  . @rjgotten I like it. Thanks for sharing.. .bind will call .delegate if passed three options.  \nIf you are starting to use CanJS, I'd encourage you to use 3.0.  It's faster, easier to use, better documented and more.\nAlso the delegate plugin was dropped in 3.0 because it's unnecessary in a fully MVVM programming model.  . easy fix is to not use superMap and instead use baseMap.  The right fix is to solve: https://github.com/canjs/can-connect/issues/129. I'm ok adding this in w/i a 2.3 release.  We'd violate semver, but not the way that really matters to people IMO.  \nReleasing a 2.4 is much more complex b/c we need to build a different site for it.  Doesn't seem worth it.  . @phillipskevin on second thought, maybe we release it as 2.4, but just don't publish docs for it?. sure.  It just always seems error prone.. Issue moved to canjs/can-component #77 via ZenHub\n. Awesome!  If you haven't already, can you have the docs link to caniuse and mention this won't have the same browser support that other modules have?. This also needs to update the ecosystem part and version numbers part of the homepage: https://github.com/canjs/canjs/blob/master/docs/can-canjs/canjs.md. Closed by mistake. If you install canjs, but you should install can.\nSent from my iPhone\n\nOn Feb 7, 2017, at 10:37 PM, Chasen Le Hara notifications@github.com wrote:\nIf you run npm install canjs --save in a 2.3 project, it\u2019ll just install the latest version of 2.3, not CanJS 3.\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/canjs/canjs/pull/3004\nCommit Summary\nVersion the install commands in the Migration guide\nFile Changes\nM docs/can-guides/commitment/migrating_to_3.0.md (4)\nPatch Links:\nhttps://github.com/canjs/canjs/pull/3004.patch\nhttps://github.com/canjs/canjs/pull/3004.diff\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @chasenlehara, @Sinjhin shared: https://developer.android.com/reference/android/app/Application.html\n\nNotice how it shows the inheritance chain and interfaces it implements:\n\nWe should have something similar.   We probably need mixins as well as interfaces a module might implement.. @Sinjhin It does say events is used as the prototype of a can-control: http://canjs.com/doc/can-component.prototype.events.html \nNot every method needs to be documented.  off() is more of an internal method, not expected for other people to call.  . Ecosystem is 99% of what people will be adding plugins to going forward. The people who will be adding to the other parts are likely only going to be the core team. Generally speaking, we will just be moving something incubated in ecosystem to core. \nSent from my iPhone\n\nOn Feb 16, 2017, at 11:19 PM, Juan Orozco notifications@github.com wrote:\n@Macrofig commented on this pull request.\nIn docs/can-guides/contribute/including-new-modules.md:\n\n@@ -0,0 +1,111 @@\n+@page guides/contributing/include-new-modules Including New Modules\nI tried not to mention \"ecosystem\" exclusively because it should be helpful for every list. As a compromise, though, I tried to use examples specific to \"ecosystem\".\n\n\u2014\nYou are receiving this because your review was requested.\nReply to this email directly, view it on GitHub, or mute the thread.\n. One other thing to add is TravisCI in the repo. . This is a good start and should be merged.  It could use some additional info about how to integrate into the build, but that can be done later.\n\nAlso, the ecosystem landing page should link to this.  . Issue moved to canjs/can-define #148 via ZenHub\n. @marshallswain regardless of how npm installs things ... steal should be able to handle it. \n@marshallswain where are things \"really\" installed?\ncc @matthewp . Have you thought about how lists will work (diffing)?\nSent from my iPhone\n\nOn Mar 2, 2017, at 5:13 AM, Julian notifications@github.com wrote:\nhello kevin,\ni find this syntax very strange.\nyou didnt got any code completion or syntax highlighting in your IDE.\nthis syntax is maybe good for short and simple HTML. but if you write complex HTML you really want code completion.\none good reason to use this syntax is: it is testable !\ngood job.. keep it up :)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. It would also be nice to see how event and two way bindings would look. \n\nI wonder if Proxy could make it look nicer. It could save at least two characters:\nh.li(\"content\")\nBtw, couldn't this be the compile target for other templates?\nSent from my iPhone\n\nOn Mar 2, 2017, at 5:13 AM, Julian notifications@github.com wrote:\nhello kevin,\ni find this syntax very strange.\nyou didnt got any code completion or syntax highlighting in your IDE.\nthis syntax is maybe good for short and simple HTML. but if you write complex HTML you really want code completion.\none good reason to use this syntax is: it is testable !\ngood job.. keep it up :)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Would this be able to use can-view-target? can-view-target helps a lot with performance.\n\nSent from my iPhone\n\nOn Mar 2, 2017, at 5:13 AM, Julian notifications@github.com wrote:\nhello kevin,\ni find this syntax very strange.\nyou didnt got any code completion or syntax highlighting in your IDE.\nthis syntax is maybe good for short and simple HTML. but if you write complex HTML you really want code completion.\none good reason to use this syntax is: it is testable !\ngood job.. keep it up :)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Because there is no \"definition\" of the template apart from the \"execution\" of the template, it might be harder to optimize. \n\nI wonder if the 'h' could be contextualized. That way, if you ran the same template twice, parts of it could be memoized similar to what can-view-target is doing. \nSent from my iPhone\n\nOn Mar 2, 2017, at 5:13 AM, Julian notifications@github.com wrote:\nhello kevin,\ni find this syntax very strange.\nyou didnt got any code completion or syntax highlighting in your IDE.\nthis syntax is maybe good for short and simple HTML. but if you write complex HTML you really want code completion.\none good reason to use this syntax is: it is testable !\ngood job.. keep it up :)\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @mickmcgrath13 can you clean up the lint errors?. related to weird memory leak. The propDefinition docs should not say Type accepts a constructor function or PropDefinition ... Type should say that and does: http://canjs.com/doc/can-define.types.TypeConstructor.html\n\nWe shouldn't \"duplicate\" docs.  PropDefinition should describe what it looks like, not everything within it looks like, those are documented by the different behaviors Type, Value, get, set, etc. I misunderstood what you were saying, yeah it's fine to implicate that Type can take more than a function.  However, we don't want to go down the road of describing all of each behavior's possible options.. I don't think setting up is what a person coming to canjs should do before the guides. The guides all use JSBin to avoid people having to setup anything. \nSetting up canjs correctly, with its many packages, shouldn't be a prerequisite for exploring it. \nSent from my iPhone\n\nOn Mar 15, 2017, at 9:23 PM, Chasen Le Hara notifications@github.com wrote:\nI think it\u2019d make more sense if the Recipes link was next to the other guides. Additionally, I think it\u2019d make more sense to put Setting Up CanJS before all the other guides.\nCurrent:\nSuggested:\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. can-jquery doesn't add it as $.viewModel?. This is arguably a bug. Can you create an issue in can-map?\n\nSent from my iPhone\n\nOn Mar 15, 2017, at 10:07 PM, Curtis Cummings notifications@github.com wrote:\nIn 2.3, creating a custom can.Map would also create a custom can.List whose static Map property was the custom Map. For example:\nconst MyMap = can.Map.extend({\n  myHelper() {\n  }\n});\n//MyMap.List can now be used elsewhere\nIn 3.0 this was removed.\nIf the removal is permanent, it should be added to the migration guide.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. This only worked with mustache templates as far as I know.  We should not have the migration guide cover everything from 2.0->3.0 in my opinion.  (or we should handle these things separately).  . The code was in component, then moved to can-stache-bindings\n\nStache did it by default. I think that's why it worked. \nSent from my iPhone\n\nOn Mar 20, 2017, at 5:41 AM, Curtis Cummings notifications@github.com wrote:\nThe code to handle this is in can.Component so it isn't specific to mustache (I don't think).\nI just migrated a project that used this with stache and it seemed to work there.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub, or mute the thread.\n. ```\n\n\n\n```\nThose should work.. Is that a bug?  I'm not sure why 3.0 should differ from 2.3.. The starter bin should include some example HTML.\nSent from my iPhone\n\nOn Mar 27, 2017, at 7:56 PM, Chasen Le Hara notifications@github.com wrote:\nChange the starter JS Bin to not include the plain HTML so they don\u2019t have to remove it at the beginning of the guide\nAdd a Result section at the end\nPin the JS Bins to specific versions instead of their latest versions\nMake the spacing consistent in the code examples\nMinor spelling & grammar fixes\nCloses #3121\nYou can view, comment on, or merge this pull request online at:\nhttps://github.com/canjs/canjs/pull/3132\nCommit Summary\nFinalize the Weather Report Guide\nFile Changes\nM docs/can-guides/commitment/recipes/weather-report/weather-report.md (177)\nPatch Links:\nhttps://github.com/canjs/canjs/pull/3132.patch\nhttps://github.com/canjs/canjs/pull/3132.diff\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Maybe the guide should use the starter HTML similar to the main TodoMVC guide.  Start by wrapping it w/ the <script> tags so it becomes the template.  Then people are mostly just decorating it with {{}}.. @matthewp I'm not sure how we are going to decide what's in CanJS 4.0.  For now, this is just a catch-all epic for issues that can not be done w/o breaking changes.. RequestInstances tracks which Ajax requests have been made. Have all Ajax requests in your app completed successfully? (On phone so haven't looked at jsbin)\n\nSent from my iPhone\n\nOn Apr 5, 2017, at 12:17 AM, Szabolcs Schmidt notifications@github.com wrote:\nHi!\nI think I've found a memory leak.\nJS Bin\nTo reproduce the leak:\nTake a heap snapshot\nClick on Insert\nClick on Remove\nTake a heap snapshot\nClick on Insert\nClick on Remove\nTake a heap snapshot\nNow view the list of objects created between the first and the second snapshot. You'll see that there are items which cannot be garbage collected:\nWhen I discovered the issue I was using Chrome 56.... I don't know the exact version because when I tried to check my Chrome version it started to update to 57.0.2987.133. I had no choice it upgraded to the latest stable version. The problem still exists with Chrome 57.0.2987.133.\nIn the JS Bin I use a custom build. Here are the versions for the modules I use in the custom build:\ncan-component: 3.0.7\ncan-route: 3.0.8\ncan-stache: 3.0.21\ncan-stache-bindings: 3.0.13\ncan-stache-converters: 3.0.7\ncan-compute: 3.0.7\ncan-event: 3.2.0\ncan-view-model: 3.1.3\ncan-connect/can/base-map/base-map: 1.3.8\ncan-define/map/map: 1.0.17\ncan-define/list/list: 1.0.17\ncan-set: 1.1.0\ncan-fixture: 1.0.13\ncan-map: 3.0.6\ncan-list: 3.0.3\ncan-map-backup: 3.0.3\ncan-map-define: 3.0.6\ncan-connect/can/model/model: 1.3.8\ncan-jquery: 3.0.6\nThanks!\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I haven't. I was on vacation all last week. I get back tomorrow. \n\nSent from my iPhone\n\nOn Apr 10, 2017, at 12:47 AM, Szabolcs Schmidt notifications@github.com wrote:\n@justinbmeyer Hi! Did you make some progress in resolving this issue?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. This is fixed in 3.0: https://github.com/canjs/can-view-scope/blob/master/can-view-scope.js#L137\n\nHere's a test for it: https://github.com/canjs/can-view-scope/pull/44/files#diff-bae52c459300e0f3f90d96564fe3d56fR213\nAnyway you can submit a pull request?  We should be able to get a release out pretty quickly after that.  (Otherwise, we'll do it after 3.6 gets out).  Thanks!. Logo \n. @Nithanaroy thanks for reporting.  Anyway you can simplify this example?  Thanks!. Also, is this the error you are talking about:\n\nThis seems different than what you are reporting.. Also, if I look at the JSBin, no other error is thrown.  Event as I click on the Validate Report button:\n\nIs it possible this error was fixed?. Btw:\nEvent.List = can.DefineList.extend({\n  \"Map\": Event\n});\nshould be:\nEvent.List = can.DefineList.extend({\n  \"#\": Event\n});. Also, using inserted in this way to get data for the view-model is an anti-pattern.  Use an async getter.\ninserted: function () {\n      const self = this;\n      console.log(\"getting\");\n      Report.get({id: \"1\"}).then(function (report) {\n        // console.log(\"Fetched report\", report);\n        self.viewModel.report = report;\n      }).catch(function (err) {\n        console.error(\"Error fetching report\", err)\n      });\n    }. The request bug can be seen in a simplified form here: https://jsbin.com/zuwayakode/edit?html,js,output\nI think this might be due to a problem with zones and fixture  cc @matthewp . It's not a problem with fixtures.  The problem is that fixtures and can-connect have slightly different expectations about urls. We should make:\njs\ncan.connect.baseMap({\n  \"Map\": Report,\n  \"List\": Report.List,\n  \"url\": \"/api/v1/report/{id}\",\n  \"name\": \"Report\"\n});\nwork in can-connect.  This shows it not working: https://jsbin.com/zuwayakode/edit?html,js,output\nBut change the url to:\njs\ncan.connect.baseMap({\n  \"Map\": Report,\n  \"List\": Report.List,\n  \"url\": \"/api/v1/report\",\n  \"name\": \"Report\"\n});\nEverything works even though the fixture looks like can.fixture(\"/api/v1/report/{id}\", reportStore);. Issue moved to canjs/can-connect #298 via ZenHub\n. yes, this is a duplicate, closing.. @kylegifford can you resolve conflicts and merge?  Looks good otherwise.. That doesn't sound right to me. It bitballs, the state of the session code is not ignored by zones\nSent from my iPhone\n\nOn May 3, 2017, at 4:31 PM, Marshall Thompson notifications@github.com wrote:\nWe had to wrap the Session.current handler in a Zone.ignore.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. What would the binding syntaxes look like?  . A few thoughts:\n\nDo we need the events folder?\nCan you explicitly document the typedef/apis?\nFor example, what exactly does makeCustom export?\nExports:\n\nfunction(eventName, addListener)\n\nparams\n\neventName\n\naddListener(this:target, ...arguments)->removeListener()\n\nthis - the target the event should be registered upon.\narguments - the arguments forwarded\nreturns removeListener() which cleans up \n\n\n\nreturns An object with the following methods / properties:\n- _addListener(target, handler)->removeListener()_\n\nWhat does makeCompat return?\nAn object with a addEventListener, removeEventListener?\nCurrently, can-util/dom/events is mutated in place.  \nDoes myEvent.override mutate its argument?\nIf it does, are there concerns with calling removeEvent out of order? (I don't think so, but don't want to think hard right now).\nAre there better names for override? mixin, addTo, etc.\nShould makeNative be memoized?\nShould we use a constructor for makeRegistry?\nWhy different storage solutions?\nI bet we don't need this, so we can simply make makeRegistry not take a solution and expand to another argument if needed.  \nShould we distinguish between DOM events and can-event?\ncan-dom-event-radiochange?\nDoes these custom events need to be identify-able?\nvia can-reflect so we can know to add them to a template's event registry?\nor do we make someone set this.\n. I think it needs preventDefault(). I'll do this once we can have videoDrag use a helper.. I would rather copy jsx's semantics, while keeping things observable. We just compile to function wrappers. \nSent from my iPhone\n\nOn May 12, 2017, at 2:56 PM, Christopher Baker notifications@github.com wrote:\nTLDR\nUse JSX because JSX is awesome. Also, no runtime ast parsing, so possibly more performant and smaller.\nDetails\nJSX code is transpiled to calls to a particular function, (defaults to React.createElement, but can be switched with an @jsx pragma on a per-file or per-function basis). This does mean that any inline jsx would need to require the viewJSX function and include the pragma. Standalone files (like *.stache) would just be the jsx itself, and the require, functions, and pragma could be added by the loader. That function is called with the tagName as the first paramater, the properties as the second (an object, or null if no properties), and any children as the following arguments.\nNote: within React, there are differences between JSX and HTML, mainly the use of className over class, but this is standard they adopted rather than an implicit requirement. No such limitation would exist in a jsx-based tempating system.\nEvents\nFor representing events, I would propose using onFoo syntax. \nBinding\nOne of the complications here regarding binding is that the runtime use is via function calls, and the values are grabbed, so the connection to the parent object is lost each time. This is fine for unbound values, but would interfere with binding. To solve that, I would propose an extra set of getters on CanDefine objects, which return computes or observables instead of the actual values, something like viewModel.$foo. While there would be a small performance hit here, I don't think it would be very significant.\nI would propose the use of $ or _ as a prefix or suffix in order to specify binding, though I'm not crazy about it and would be open to other suggestions.    (to parent, to child, two way)  (two way shortcut, for when a compute is provided but no $ are present on the key)\nExample\n/* @jsx viewJSX /\nlet renderer = makeRenderer((vm) => (\n  \n    { vm.things.map(thing => (\n        { thing }\n    )) }\n    \n\n));\nlet frag = renderer({ things: [ 1, 2, 3 ] );\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Yes. How is your control creating the component? Via a template? If so, you can either use to-parent bindings {^} or get the view model of the component with can-view-bindings\n\nSent from my iPhone\n\nOn May 16, 2017, at 4:50 AM, Paul Pirosca notifications@github.com wrote:\nHi,\nIs there any way to pass values from a component into a controller that instantiated that component? Lets say i have a can Control on an element and inside is a component that represents a dropdown and i want to pass it's value to the parent control in order to update the UI.\nIs that possible?\nThanks\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. > CanJS documentation\n\nShould probably be:\n[canjs CanJS documentation]. After all, you're just linking to the root page whose name is canjs.. > Array shorthand\nYou could always use relative paths or //.  Better yet, would be to make:\n[can-define.types.propDefinition#Array Array shorthand]\nwork.  This could be done here: https://github.com/bit-docs/bit-docs-generate-html/blob/master/build/make_default_helpers.js#L268 ... just make sure the regexps allow it, pull off the hash and add it back later.. it seems like this checks in the docMap.json. - the sidebar isn't dynamic width (it also is janky as the page is loading). Compare CanJS.com now, to the next bullet's image:\n\n\nthe search doesn't appear to be in the right spot\n\n\n\nthis can't be published without fixing the ability to show nested children:\n\n\nAre these structural changes in master?  If not, they should be reverted.  We shouldn't publish these structural changes accidentally.\n\nthis isn't a \"brutalism\" design.  Too many design elements are introduced:\nthe green background on hover\nthe dark green padding on the left of a hovered search\n\n\n\n\nIs the (unique/name) part necessary / informative?\n\n\nWhen you click a search result, I don't think the search content should disappear.  Should these search results be part of the history (maybe via hashchange)?\n\n\nOn hovering a search result\n\n\nTyping make model year seems to freeze the search. It's not able to find the make-model-year example on the can-map-define page.  It would be nice if it could.\n\n\nSearching component shows can-component last.\n. @matthewp there isn't yet.  I've talked about it a few place.  I'm about to organize this epic and link to all other issues. What is in and out of this issue is 100% up for discussion.\n\n\nBut in short, there's some VMs that could be written as mostly stream-based.  I'd like to explore that:\n```js\n@defineStream({\n  prop : \"setable-stream\"\n  other: function(){\n    this.prop.map(() => null);\n  }\n});\nclass WeatherVM {\n}\n```\n. @matthewp my experience with new users suggests the opposite.  They have a lot of difficulty understanding how {{foo}} gets is value.  The small apps they build don't have a lot of interacting state.  \nUntil we have the \"two queues\" system @phillipskevin and I talked about ... I'm  not sure how we can identify where mutations happened.  \nAlso, we sort of have a problem with \"derived\" vs \"linked\" values.  A compute derives its values from other state.  So does an event stream.  However, a component binding is a \"linked\" value.  There's an independent state value, but they are connected.  I wonder if reflect could help us here too. \n. Notes from bitovi devs meeting:\nCommon Problems to address\n\n[ ] Why is something not mutating? \nWhy isn't a compute or DOM node updating as a result of some change? Cases might include:\nA compute doesn't actually read the observable.\nThe returned result is the same, so no updates happen (sort of like sticky bindings).\n\n\nSolutions:\ncan-debug which can tell you for a compute or DOM node all source values from which it derives its value. \n\n\n[ ] What caused some mutation?\nCases:\nThe page just updated due to real-time.  How can you track the source down?\n\n\nSolutions:\nA guide showing how to break on a DOM mutation (currently in can-view-live) and trace back its origin.\nImplementing 2Queues so mutation tasks can be clearly identified.\n\n\n[ ] Binding to a \"leaked\" scope vs a binding\nCase: A user's magic tags are on a leaked property, not a binding.\nSolutions:\ncan-debug should be able to show people the source of the binding data.\n\n\n[ ] Creating loops that recurse\nCase: Users use setters that cause infinite loops \nSolutions:\nWarn people about using setters.  This might be overkill.\n2Queues might be able to track this better?  The same task could be created as a result of a previous task.  But how to identify \"sameness\"?\n\n\n[ ] Getting routes right\nCase: Routes can be difficult to setup and get right.\nSolutions:\nProvide a guide around .deparam and param: { ... } -> \"url\"\n\n\n[ ] The stack is hard to follow\nCase: The stack is hard to understand because of batching.\nSolutions:\nTurn off batching. This will cause unexpected problems.\n2Queues might not clean up the stack, but will be able to provide more information about what is happening when.\nProvide a \"source\" on event objects.\n\n\n[ ] Invalid stache syntax\nCases: need some cases.\n[ ] namespace collisions\nCase: When there's an error about a namespace collision, it's not very informative on what to do.\nSolution: Better message\n[ ] Memory leaks\nCase: forgetting to undo a binding\nSolutions:\nWarn people about using.on entirely. This sounds like overkill.\nUse zones to track bindings during component initialization.  Make sure they are undone on element removal. \n\n\n\nUseful Debugging Techniques and gudes\nThe following are debugging techniques we can look to teach people in a guide:\n\nUnderstanding scope - Teach people what Scope is and how you can look at it to see what's going on.\nDebugging and walking the stack - Teach people some useful places within CanJS that are worth inspecting.  \nBreak on change (using a setter)\nHow to setup routing rules correctly\nDev Env \n\nTell people how to get syntax highlighting for stache. show mutating VM. As we need convention for logging information for a wide variety of types.  I'm thinking canReflect.getName() might return the following:\n\n\nInstances of map-likes Person{}\n\nInstances of array-likes People[]\nInstances of value-likes Observation<>\n\nMethod Person{}.eat (This implies we decorated all methods with info on the constructor)\n\n\nIf we want to provide additional information, like a cid or current value, we can do that between {}, [], or <>\n\n\nFor example, say we have a can-connect-ed Person type where we know the unique id property.  We might have a instance of person log like:\njs\nPerson{22}\nOr say we DO have a CID, then we can use it on those types like:\nObservation<21>\nOr maybe an observation logs its value:\nObservation<\"Justin Meyer\">\nA list might have its length:\njs\nPeople[5]\nOther things we need to log:\n\nproperties\nexpressions \ndom nodes. Closing as solved in 4.0. I'll try to find someone to take a look at it tomorrow.  Thanks for being persistent! . can you use a compute here?  This bug has been around for a while and we aren't going to fix it.  Bubbling (which can.Map does) was very error prone.  Generally speaking, a compute can be created for what you need:\n\njs\nprop: {\n  get: function(){\n    this.attr(\"data.value\");\n    return {}\n  }\n}\nprop will fire everytime data or value changes.. Issue moved to canjs/can-map #45 via ZenHub\n. btw @chasenlehara  / @imaustink this site shouldn't have to be hosted from / to work.  I host from a parent folder of canjs and it isn't working.  I noticed the images in about are failing:\n\nWhen you click a search result it also doesn't work if you are hosting from a parent folder.. this is a great way to catch missing docs!. Bug.  @imaustink did you make any progress on this?  . I've removed the email part of this form.. @adrifolio could you make the button when disabled look more disabled?  Thanks!. \n. \n. @m-mujica / @matthewp it seems that process isn't provided anymore to the built files.  Can you take a look at this?. Yeah, we should do it like kefir and jQuery ... not include them in the build, while allowing the build to work without them (at least the modules that don't depend on them).\nI know for jQuery, we do this conditionally a few places. We test that the jQuery module actually provided a value. \nSent from my iPhone\n\nOn Jul 5, 2017, at 7:13 AM, Matthew Phillips notifications@github.com wrote:\nSo I think we need to either include react and all of its dependencies into the build or exclude it, and react-view-model and can-react-component. For now I'm not to exclude those.\n\u2014\nYou are receiving this because your review was requested.\nReply to this email directly, view it on GitHub, or mute the thread.\n. The following might be an alternate way of loading models data (inspired by @andrejewski ).  This assumes an emit is passed to the makeStream functions which allows them to dispatch events themselves.\n\n```js\nvar makeModelsStreamFunction = function(GET_MODELS){\n  return function(eventStream, emit){\n    return eventStream.scan(function(last, event){\n      if(event.type === \"set\" && event.property === \"makeId\") {\n        GET_MODELS( event.value, function(data){\n          emit({type: \"gotModels\", value: data})\n        })\n      }\n      if(event.type === \"gotModels\") {\n        return event.value;\n      }\n    },undefined)\n  }\n}\nvar getModels = function(makeId, callback){\n    ajax({url: \"/models\"}).then(callback);\n};\nMakeModelYearVM = Streamed.extend({\nmakeId: Streamed.getterSetter\nmodels: makeModelsStreamFunction(getModels)\n})\n```\nThis makes the logic of makeModelsStreamFunction pretty easy to test (although super-higher-order):\n```js\nQUnit.test(\"makeModelsStream\", function(){\n// TEST THAT IT CALLS GET_MODELS and EMITS THE NEXT EVENT\n  var GET_MODELS_SHIM = (function(makeId, callback){\n    QUnit.equal(makeId, 1, \"got the right makeId\");\n    callback(  [{id: 1, model: \"altima\"}] );\n  }\nvar makeModelsStream = makeModelsStreamFunction(GET_MODELS_SHIM)\n  var sourceStream = Kefir.sequentially([\n    {type: \"set\", property: \"makeId\", value: 1},\n  ])\n  var modelsStream = makeModelsStream( sourceStream, function(newEvent){\n    QUnit.deepEqual( newEvent, \n      {type: \"gotModels\", value: [{id: 1, model: \"altima\"}]}, \"event emitted correctly\" );\n  })\n  modelsStream.onValue();\n// TEST THAT GIVEN THE gotModels event, the value is right\nvar GET_MODELS_SHIM = EMIT_SHIM = function(){ throw \"should not be used\" }\nvar makeModelsStream = makeModelsStreamFunction(GET_MODELS_SHIM)\n  var sourceStream = Kefir.sequentially([\n   {type: \"gotModels\", value: [{id: 1, model: \"altima\"}] } \n  ])\n  var modelsStream = makeModelsStream( sourceStream, EMIT_SHIM);\n  modelsStream.onValue(function(models){\n    QUnit.deepEqual( models, [{id: 1, model: \"altima\"}] );\n  })\n})\n```. Computes sure make things nice\njs\nPerson = new DefineMap({\n  first: \"any\",\n  last: \"any\",\n  get fullName(){\n    return this.first + \" \" + this.last;\n  } \n})\n```js\nPerson = Streamed.extend({\nfirst: Streamed.getterSetter,\n  last: Streamed.getterSetter\nfullName: function(stream){\n    return stream.scan(( event, person ) {\n      if(event.type === \"set\" ) {\n        var clone = Object.assign({}, person);\n        return clone[event.property] =  event.value;\n      }\n      return person;\n    }, {first: \"\", last: \"\"}).map(function(){\n      return person.first + \" \" + person.last;\n    })\n  }\n});\n```. @matthewp no, both are only getters.. I sort of see this as layers:\n\n\nThere's the events being dispatched by setters and methods that are trying to change the state.\n\n\nTheres a collection of properties that are \"first order \"values.  These are typically the enumerable state values in a DefineMap.  first and last in Person.  These often have a 1-1 relationship with the events that cause state changes.  This is really the \"state\" of the object.\n\n\nThere's things like fullName and models.  These derive from \"first order\" value changes or values themselves.  . yes, that would work. @christopherjbaker looks like this still needs the integration test enabled.  I'm going to flip that switch in a moment.. One way to deal with the concerns that:\n\nexpand / collapse might be far from the area the user is viewing\nwe might hide groupings without core parts\n\nIs to add buttons to each purpose grouping:\n\nAnother alternative:\n\n. After today's DoneJS contributors meeting, we decided:\n\nthat we'd namespace our packages under @bitovi\ncreate a site like bitovi.com/packages.  These packages would be organized by functionality.\nwe will use generic names so we import like require(\"@bitovi/assign\").  \ncanjs.com will have can-define, can-stache (or jsx), can-element (or can-component) as its core, but these will be directly listed on its site.  It will have an ecosystem dropdown.\n. Yeah, I read about this.  The parallel to this would be doing it in stache.  Or even in observation.  The error would somehow need to be communicated to the component or maybe just a %error in a template.\n\nMoving this issue to can-stache.. Issue moved to canjs/can-stache #254 via ZenHub\n. Ideally ... we wouldn't need to dispatch an attributes event anymore.  Instead we'd have a MutationObserver polyfill that avoids DOM dispatching.  \ncc @andrejewski \nThis would be a 4.0 change likely. . @matthewp updated a little.  Let me know if it's not clear.  . The short-term fix is to make can-stache and can-stache-bindings smart about knowing what might have dynamic attributes, and avoid setting up attributes event binding if the element in question isn't listening to attributes changes.. I'd use a lint rule. We don't need to have hooks that consumers would hit. \nSent from my iPhone\n\nOn Aug 18, 2017, at 11:38 AM, Kevin Phillips notifications@github.com wrote:\nWe run into issues when we add a new can-* dependency in order to test something and that dependency depends on the current package.\nFor instance, adding can-stache to test something in can-view-scope when can-stache already depends on can-view-scope.\ncan-view-scope\n\u2514\u2500\u2500 can-stache\n    \u2514\u2500\u2500 can-view-scope\nWe should avoid this. It would be awesome if we had a lint rule or some kind of postinstall hook that would check for this and let people know not to do it.\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Like Ember, it would probably be good to have a teardown queue too.  This will be for temporarily bound things to unbind themselves.. @andrejewski pinged me about .log() and supporting filtering.  Some thoughts about that:\n\nSay someone had some code similar to what's above, but I've added a fullName2 compute and someone listening on \"notify\" on the map's fullName:\n```js\nvar map = new DefineMap({first: \"Justin\", last: \"Meyer\", fullName: \"\"}); //map:1\nvar fullName = compute(() => {  return map.first + map.last }); // compute:2\nvar fullName2 = compute(() => {  return map.first + map.last });  // extra compute:3\nfullName.on(\"change\", function(ev, newValue){\n  map.fullName = newValue;\n});\nfullName2.on(\"change\", function(){}); // listening to extra compute\nmap.on(\"fullName\", function(){\n  queues.logStack()\n});\ncanReflect.onKeyValue(map, \"fullName\", function(){}, \"notify\"); // Listen on notify\nqueues.log();\nmap.first = \"Ramiya\"\n```\nqueues.logStack() would show what tasks lead to the current (or last) task being executed:\nMUTATE map:1 dispatching 'fullName' event\nMUTATE compute:2 dispatching 'change' event\nDERIVE compute:2 updating value to 'Ramiya Meyer'\nNOTIFY map:1 dispatching 'first' event\nqueues.log would show everything running in the order of execution as it happened:\nNOTIFY map:1 dispatching 'first' event\nDERIVE compute:2 updating value to 'Ramiya Meyer'\nDERIVE compute:3 updating value to 'Ramiya Meyer'\nMUTATE compute:2 dispatching 'change' event\nNOTIFY map:1 dispatching 'fullName' event\nMUTATE compute:3 dispatching 'change' event\nMUTATE map:1 dispatching 'fullName' event\nI think supporting filtering of .log()`, limiting it to a particular object would be great.  Two thoughts about this:\n\nTasks are currently just an array with: [function, this, arguments].  We will have to support some metadata for printing \"nice\" names.  We'll want to include a subject for filtering.\nI think we'll want people to be able to stop on a particular task easily, and then call logStack to see what caused a particular task. . Other notes:\nqueues should maintain the last task to run.  This is how we can keep the relationship.  Anytime a task is queued, it can look up the last task and remember it as its parent.\nafter the last task of the mutate queue has run, queues should null the last task.  . Why did these get removed? . Here's a simplified version: https://jsbin.com/xojinezewu/edit?html,js,output. Why is ScopeKeyData never updated? Why was it previously?. - bike shed on name. Link to page? Is it using @iframe?. Http(s) issue?. I would like to see the events object change to avoid the  {} in \"{data} thing\" sorta stuff, especially since the element is the view model now.\n\nCould we have something like:\njs\nevents: {\n  connected: function(){\n    setInterval(() => {\n                this.time = new Date();\n            }, 1000);\n  },\n  disconnected: function(){},\n  \"li click\": function(){}\n}. Thanks, the dist isn't getting included for some reason.  @phillipskevin it might be good to have a code-mod go find any main thats that point to dist and just remove them.  I'll fix this in can-make-rest.. Issue moved to canjs/can-make-rest #12 via ZenHub\n. We should support \u201clate\u201d declarations of components. And possibly always auto mount .\nSent from my iPhone\n\nOn Nov 1, 2017, at 7:52 PM, Kevin Phillips notifications@github.com wrote:\nSome feedback from going through the guide at DoneJS Chicago:\nthe \u201cIn this guide you will learn\u201d section needs to be updated\nI had a newline before my  so the this.element.firstChild was a Text Node (should use querySelector).\nString.prototype.padStart isn't supported in IE\nhttps://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext/moveTo should be https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/moveTo\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. > Q: What to do if user types, but you want to set  value \"back\" to old key value, but key hasn't changed?\n\nThis, imo, is really only currently solved well by streams which can produce the same value over and over again.  I think this problem is worth an issue and investigation of its own.  \nOne imperative solution:\n<input on:input:value:bind=\"inputValue\">\njs\nVM = {\n  inputValue: \"string\",\n  value: \"string\",\n  reset: function(){\n   this.inputValue = this.value;\n  },\n  save: function(){\n    this.value = this.inputValue;\n  }\n}\nAnother example from @phillipskevin for illegal characters:\n```js\nvar VM = can.DefineMap.extend({\n  key: { type: 'string', value: '123' },\nupdateKey(val) {\n    if (/ val is illegal /) {\n      var oldVal = this.key;\n      this.key = '';\n      this.key = oldVal;\n    } else {\n      this.key = val;    \n    }\n  }\n});\nvar view = can.stache(<input on:input=\"updateKey(%element.value)\" value:from=\"key\"/>);\n```. How would we test getters that dynamically change their values (imagine lists were also dynamic below):\njs\n1Counter = CanReducer.extend({\n  items: function(){ return Observable.of([1,2],[1,1], [0,1] ) },\n  get count(){\n    var count = 0;\n    this.items.forEach((n){\n      count += (n ===1 ? 1 : 0)\n    })\n    return count;\n  }\n})\njs\n// This would only work if you weren't calling other `this.methods`\n// You'd have to provide every stateful object here:\n1Counter.count( {items: [0,1]}) //-> 1. A thought: how could we \"duplex\" streams.  Say we were setting one stream from another stream.  Is there something special we could do here to make following the streams easier? . I\u2019ve been think about that, but I\u2019m wary of lots of imports or globals. \nSent from my iPhone\n\nOn Dec 7, 2017, at 11:05 AM, Kevin Phillips notifications@github.com wrote:\nFirst of all, I love this idea.\nNow that that's out of the way, I have an idea on how to make the API more understandable.\nThe tldr; is to use more of a builder pattern to create each property instead of using definition objects.\nHere is a rough example of what this could look like:\nconst Counter = StreamBuilder({\n    add: source('incrementBy'), \n    subtract: source('decrementBy'),\n    count: value(0)\n            .map('incrementBy', (value) => ({ type: 'add', value: value }) )\n            .map('decrementBy', (value) => ({ type: 'subtract', value: value }) )\n            .reduce((lastState, event) => {\n                switch(event.type) {\n                case add: \n                    return lastState + event.value;\n                case subtract:\n                    return lastState - event.value;\n                }\n            })\n});\nI think this has a few benefits over using objects for each property definition.\nThe \"builder\" functions help users understand what they can do with each property. If you call value(0) it will give you back the right Type with the methods you can use next.\nIt allows helpful error messages like\nYou can't call value after calling map\nIt's easy to document. We can document the source, value, map, reduce methods and clearly define their return values. This is easier than trying to document each of the combinations of properties that could be used in a definition object. (these APIs aren't fully thought out - just an idea of what this could look like)\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. I think there\u2019s a underlying \u201cmake reducer\u201d that is passed a library and maybe configuration similar to can-define-stream\n\nSent from my iPhone\n\nOn Dec 7, 2017, at 12:15 PM, Matthew Phillips notifications@github.com wrote:\nHow do you use your own stream library in this way?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @phillipskevin What i liked about the Credit Card example was that helper transformations could be organized and leveraged:\n\njs\nType = Reducer.extend({\n  someHelper: function(){ ... }\n},\n{\n  someProperty: {\"someHelper\": [\"otherPropAsArgToSomeHelper\"]}\n}\nThe .map, .reduce, etc .. these would come from the underlying stream implementation and be unbounded.  I wouldn't document them other then to say you can use whatever is on the underlying stream implementation.  \nLet me know if this makes sense.  The syntax doesn't really matter to me.  What does matter is:\n\nUsing whatever transforms the underlying stream implementation supports easily.\nAllowing people to organize helpers, call to them easily when deriving property values, and having them accessible for later (Type.someHelper( ... )).\n\nAnother syntax idea was:\nReducer({\n  someHelper: function(a, b){ \n     return aStreamFromAandB\n  }\n},{\n  \"propA\": { ... },\n  \"propB\": { ... }\n  \"myProp someHelper\": [\"propA\",\"propB\"]\n})\nEssentially, a space would indicate to call the someHelper method with the values emitted from propA and propB.. > I like the approach that Recompose uses... basically it uses something similar to the ES Observable spec internally and lets you map to/from that to whatever you want to use.\nI'd prefer not to \"own\" a bunch of APIs.  . Can-event isn\u2019t part of 4.0. @phillipskevin is it possible to make {{default()}} still work?. DefineMap's value behavior should now be called default.. I have been thinking if we should call connected callback on both the component and the VM.  Sometimes I feel like it makes more sense on the component.. > Unlike previous versions of CanJS, in CanJS 4 there are a mixture of different package versions. This is because CanJS is now developed as separate independent packages.\nWas this not true for 3.0? can-define was 1.0 for can@3.0.\n\nUse can-queues instead of can-event\n\ncan-queues replaces most closely can-event/batch/batch.\nIf you were using can-event, then you likely want to use can-event-queue/map/map.  \nI actually think can-event-queue/map/map is the best thing to use at first.  It includes .start() and .stop() and other old can-event/batch/batch methods: \nhttps://github.com/canjs/can-event-queue/blob/master/map/map.js#L821\nThese warn, but fix those later ...\n\nImplicit scope walking  \n\nI think this section should tell people that upgrading to the latest 3.0 will warn them of where they are using implicit scope walking.. I don't know if many packages have demos that are actually shown in the docs.  The demos folder is the most important one here.. Here is where these images are used: https://canjs.github.io/next/doc/guides/technology-overview.html\nHere are the images and what needs to be done:\noverview.png\n\nThis is the only one that really needs to be SVG.\nobservables-dom.png\n\ncan-component.png\n\ncomponent-architecture-overview.png\n\nInstead of the checked in image, I'd like two versions of this.  The first one looks like this:\n\nThe second one removes a few components and looks like:\n\nobservable-routing.png\n. Yay. This does need more discussion.  I think it's really important folks do it now that canReflect.getName() and so much of our debugging tools are improved by these names.. @matthewp I wrote up some \"background\" on CanJS's builds.  Here's what I wrote, let me know what you think (cc @phillipskevin / @chasenlehara ):\nBackground Information\nCanJS has a variety of packages, modules, and files ready to meet the needs of\nany development environment. This section gives some background on these items.\n\nThe individual packages.\n\nCanJS is composed from over 80 individual packages.  For example [can-component Component]\n  is actually the can-component package, housed\n  in its own github repository. The modules within\n  these packages are written in ES5 JavaScript and CommonJS, so they can be imported by Webpack, Browserify,\n  StealJS, and a do not require transpiling.\nApps that need long-term flexibility should installing these packages directly. Direct installation\n  means you can upgrade a small part of CanJS when needed.\n\nThe can package.\n\nCanJS publishes to npm a\n  can package. It contains:\n\n\n./can.js - The main export, imports every CanJS sub project and exports it as\n    a ES named export. For example, can.js looks like this:\njs\nexport { default as Component } from \"can-component\";\nexport { default as restModel } from \"can-rest-model\";\n...\nMost module loaders with tree-shaking (ex: Webpack and StealJS) setups\nuse this module. Import\nnamed exports from the can package like this:\njs\nimport {Component, restModel} from \"can\";\n\n\n./dist/can.mjs - An ESM module with named exports of each [core] package bundled\n    together. This is useful for examples and prototyping in modern browsers that\n    support ES modules and for real-world apps that use just what's in core CanJS.\n    It's hosted statically on unpkg and can be\n    downloaded here.\nYou can import directly from the file as follows:\n```js\n\nimport { Component } from \"//unpkg.com/can/dist/can.mjs\";</p>\n<pre><code>Component.extend({\n    tag: \"my-app\",\n    view: `Hello {{name}}!`,\n    ViewModel: {\n        name: { default: \"world\" }\n    }\n});\n</code></pre>\n<p>\n```\n\n\n./dist/can.all.min.js - A minified version of ./dist/can.all.mjs.\n\n\n./dist/global/can.js - A JavaScript file that exports a can object with\n    core named exports on it. Use this if you want to create a demo or example that will\n    work in browsers that do not support ESM.\n\n\n./dist/can.all.mjs - An ESM module with named exports of every* package bundled\n    together. This is useful for examples and prototyping in modern browsers that\n    support ES modules. It's hosted statically on unpkg and can be\n    downloaded here.\nYou can import directly from the file as follows:\n```js\n\nimport { Component } from \"//unpkg.com/can/dist/can.all.mjs\";</p>\n<pre><code>Component.extend({\n    tag: \"my-app\",\n    view: `Hello {{name}}!`,\n    ViewModel: {\n        name: { default: \"world\" }\n    }\n});\n</code></pre>\n<p>\n```\nThis file is huge as it includes nearly every extension to\nCanJS. So use of this module in production, without tree-shaking, is\nnot advised!\n\n\n./dist/can.all.min.js - A minified version of ./dist/can.all.mjs.\n\n\n./dist/global/can.all.js - A JavaScript file that exports a can object with\n    every* named export. Use this if you want to create a demo or example that will\n    work in browsers that do not support ESM.\n\n\n=======\nBasically, do we want to create a all vs core build?  I sorta feel like some people will be put off by a 400k download.  I think we should make a paved path for the crowd that just needs \"core canjs\" for some basic widgets.  I'm even thinking about what would a can-component-only build be too.  \nAnyhoo .. let me know what you think. Thanks!. > I'm lukewarm about adding a minified build. Projects minify their own stuff. It would only be useful if you were using native modules in production.\nI think it might be useful for the million hobby and corporate intranet type projects that don't really care about performance / creating a build script. They just want to listen to when a form is submitted and make an ajax request in a slightly nicer way.  . \n. Eventually, we should improve the bindings graph in two ways:\n\nRemove internal observables.  Show only what the user created.\nOrganize by component hierarchy within the DOM.  Something like: \n. Call expressions work. They can be cumbersome. It\u2019s not just a typing affordance. It breaks down the view-ViewModel boundary. While it can be avoided with the events object in a component, it\u2019s awkward. \n\nI think these two examples are enough that the problem should be solved. These show up in many of our example apps/recipes. \nAnother alternative is supporting multiple expressions in stache so folks can do:\non:click=\u201cscope.event.preventDefault();sendData()\u201d\nSent from my iPhone\n\nOn Jan 25, 2018, at 10:12 PM, Chris Andrejewski notifications@github.com wrote:\nI vote for \"Implement through can-stache-bindings\". No need to overcomplicate a more broad API for problems with event bindings.\nI think we should wait for significant interest from the community, and have more concrete examples before going any further than that. From what I have seen Vue doesn't have many of these modifier things. As far as I'm concerned these typing affordances can be resolved through proper component composition.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Vue seems to have many of them:\nhttps://vuejs.org/v2/guide/events.html#Event-Modifiers\n\nAs far as interest, this is a proposal for the survey. We will see how it does.\nSent from my iPhone\n\nOn Jan 25, 2018, at 10:12 PM, Chris Andrejewski notifications@github.com wrote:\nI vote for \"Implement through can-stache-bindings\". No need to overcomplicate a more broad API for problems with event bindings.\nI think we should wait for significant interest from the community, and have more concrete examples before going any further than that. From what I have seen Vue doesn't have many of these modifier things. As far as I'm concerned these typing affordances can be resolved through proper component composition.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @phillipskevin .. that wouldn't fix the capture and likely once problems. Vuejs's modifiers:\n\n\n.stop\n.prevent\n.capture\n.self\n.once\n.enter\n.tab\n.delete (captures both \u201cDelete\u201d and \u201cBackspace\u201d keys)\n.esc\n.space\n.up\n.down\n.left\n.right\n.left\n.right\n.middle\n.ctrl\n.alt\n.shift\n.meta\n\nThis allows stuff like:\nfocus.capture.self.once.. Thanks.  Keep voting for it!  \nFor not, there's already a converter: https://canjs.com/doc/can-stache-converters.not.html\n<input el:disabled:from=\"not(enabled)\" />\nOne other thing I've been thinking about as we are preparing for the next DoneJS Meetup where we are building a swiping carousel is that this syntax really doesn't go far enough to support complex interactions.  \nA swipe event might have a lot of options that need to be configured like:\n\nthe duration of the swipe, \nthe distance it needs to cover, \nif it should start moving the element under it, etc\n\nVueJS-style event modifiers would not allow this.  For this, you really need to pass arguments.  \nA solution that works now\nCurrently, the solution would be to create \"inline helpers\" that allow something like:\njs\n<div {{swipe(time=200 distance=100 move=true,onSwipeCallThis) }}>\nThis can currently be done like:\njs\nstache.addHelper(\"swipe\", function(options, callback){\n  return function(el){\n    el.addEventListener(\"mousemove\", function(){\n      // test if a swipe happened \n      callback()\n    })\n  }\n})\nThis same \"inline\" the element syntax could probably be used to do a lot:\n```html\n bindings example \n\n another bindings example \n\n```\nBetter syntax options?\nThere's likely better syntax to support this.  We could make something like:\njs\n<div on:swipe(time=200 distance=100 move=true)=\"onSwipeCallThis\">\nor with https://github.com/canjs/can-stache/issues/505, make this work:\njs\n<div on:swipe({time:200, distance:100, move:true})=\"onSwipeCallThis\">\nReact\nReact folks wouldn't have a special event here. They would reach for a special <Swipe> element, something like:\njs\n<Swipe time={200} distance={100} move={true} callback={onSwipeCallThis}>\n  <div>...</div>\n</Swipe>\n@christopherjbaker / @BigAB maybe you can fill me in on how this would be done in react.  How does <swipe>, which doesn't exist, get the <div>, setup listeners, and handle tearing things down when <swipe> is removed?\nMy gut is that this is sorta annoying to build compared to your standard \"swipe\" event handler.\nThings to think about\nAnyhoo, all of this is to wonder aloud:\n\nShould we be solving this in a way that is less leaky?\nAs <div {{ swipe() }}> effectively solves this and a whole bunch of other problems, should we focus on this instead of creating new syntax?  Or should we focus on creating new APIs for this?\nWhat would a better on:swipe(...)=\"bar\" syntax look like?. Might be useful to link to these proposals:\n\n\n. --------------\n\nThis has shifted our focus to things that matter to users.\n\nTo:\nThis has shifted our focus to what matters most to users.\n\nChange:\n\nTake our survey here!\n\nTo:\nIf something matters to you, take our survey here!\n\n\nDivision was nearly impossible with roman numerals, but it's easy with decimal numbers that we use today\n\nShould link to: https://www.washingtoncitypaper.com/columns/straight-dope/article/20854121/how-did-anyone-do-math-in-roman-numerals. I\u2019m not sure what the issue is. What version of canjs are you using? What browser does this happen in? Only old versions of canjs templates. Is it canjs loading the template or something else (like steal)?. @soultrue Unfortunately, I don't know what the issue could be.  Can you recreate it in a small example app and share that with me?. I\u2019ll try to take a look over the weekend. As a temporary work around, you can put a <div> or some other element directly within your <can-template> tag like:\n<can-template name=\"stuff\">\n<div> .... </div>\n</can-template>. Here's a jsbin that shows the issue a bit more easily to understand (for me anyway): https://jsbin.com/nixiwib/1/edit?html,js,output. Issue moved to canjs/can-component #220 via ZenHub\n. You can drag images into github comments.  . The global build shouldn\u2019t warn if someone is using can. We can maybe NOT import this warning behavior in can-debug or turn it off. . Can you reduce this so we can recreate? or push it to a github repo we can check out?. I\u2019m not sure this can be made to work easily. We should probably warn folks if they have unclosed elements in a block. . \n. foo bar. Thanks!. You could add the same logic that steal-tools uses as a pre-build hook. Alternately, you could help us migrate some of these blocks over to a compatible format. . @matthewp A few questions:\n\nDoes it tree-shake out other packages?  So can-set isn't included?  What about modules in can-util that can-connect might use, but the others don't.\nDoes this imply every module (not just package) needs an es counterpart?\nThese are the requirements for Webpack I assume.  Do you know:\nAre these technical/mathmatical requirements, or is it just Webpack needs things a certain way right now.  Is webpack looking to make CJS modules work?\nWhat does sideEffects true do? What's it's purpose?. To clarify:\n\n\n\n\nNo, only the modules that are imported by can/es would need the wrapper es module.\n\nYou mean only modules DIRECTLY imported by can/es would need the wrapper ... right?  This surprises me, lets say that can-component uses can-util/foo, and it the only user of foo.  How is it able to tree-shake can-util/foo correctly if not an ES module?. > I don't understand your question, can-component is also not an ES module. Why are you surprised by can-util/foo but not can-component?\nYeah, it's surprising to me that it's able to tree shake those CJS modules too.. @matthewp why does #1 do that?  Are you talking about tree-shaking within the individual modules?  import {realTime} from \"can-connect\"? This is mostly just a problem for can-connect I think right?  Nothing else really \"needs\" tree-shaking within a module.\nI think we should start with #2.  It is probably easier to accomplish, makes adding new packages much easier, and over-all less to worry about.  Once ES has \"taken over\".  Speaking of which, where is node ES support?\n. @matthewp gotcha.  I'd still say most linters would pick up on that example. I still don't think it's worth the extra hassle.  I'd prefer to wait to update everything to ES than keep supporting two module syntaxes everywhere.  . @lighttree, great suggestion!  Anyway you can share some of the code for that behavior?. One thing I've been thinking about, is how to include the session information with the query ...\n\nespecially when the session impacts the query \n\n```\n/api/todos\n-> unauthorized \n/api/todos JWT\nA -> unauthorized \nB -> [ todos for that user ] SIMILAR TO /api/todos?filter[createdBy]=5\n   Todo.getList({})\n{name: \"should not be in your list\", createdBy: 6, assignedTo: 5} -> would get added to a list!!\n```\njs\nTodo.getList({})\n\nWhat should be passed with the query?\n  js\n  Todo.getList({token: XYZ, filter:{}})\ntoken is not going to be on your data response ....\nWhat could be read from some global state?\n   js\n   getListData(){\n     LOOKUP TOKEN \n     ADD TOKEN TO HEADERS\n     return requestPromise\n   }. ## how to handle the session\n\nCRUD session JWT & Cookies\nPass the session (JWT)\njs\nTodo.getList({})\n```\nbehavior = function(){\nobj = dataUrl(base);\nreturn Object.extend ( Object.create(base), obj )\n}\n// this.getData \n// base.getData\nvar connection = [base, dataUrl, constructor].reduce( (last, behavior) => behavior(last), {\n  Map: Session\n})\nObject.extend(connection, {\n  getData(){\n}\n})\nvar connection = base()\nconnection = dataUrl(connection);\nconnection = constructor(connection)\nconnection = Object.create(connection, {\n  getData(){ \n}\n})\n// session.js \nrestModel([dataUrl,{getData(){}}],{\n  Map: Session\n},{\n  getData(){\n},\n  destroyData(){\n},\n})\n```\n```js\nimport {Session}\nTodo.connection = connect([\n   Session.connection.addAsRequestHeader\n],{\n})\n```\n\n\n\nJWT & cookies \n\n\nSingleton sessions like Bitcentive\n\nSession.current - see if there is a current session. Observable.\nnew Session().save() - Create a new session.\nSession.current.destroy() - Logout from anywhere.\n\nSession.get()\nTodo.getList()\n1.  Wait for the session to be available\n2.  Add session info\n```js\n// wait for session to be established ... info before requesting stuff ...\nbeforeSend(xhr){\n  return Session.currentPromise.then(function(session){\n});\n},\nurl: \"/api/todos\"\n```\n\nCRUD Session\nSingleton stuff\nAdd session info on other requests\n\nBitballs\n```js\nSession = DefineMap.extend({\n});\nimport connectCanSession from \"can-connect/can/session/session\";\nconnect([restModelsBehaviors..., connectCanSession], {\n  Map: Session\n  // NO LIST IS OK ... \n  url: \"/api/session\",\n  // JWT\n  url: {\n    getData(){ ... },\n    createData() { ... }\n  }\n});\nSession.current // First time it's read ... undefined, but kicks off a Session.get()\nnew Session({ ... }).save() //-> creates\nSession.current.destroy() //-> delete, set Session.current to undefined\nSession.currentPromise //-> resolved or rejected with the Session.get()\nimport Session from \"./session\"\nPlayer = DefineMap.extend({ ... })\nrealtimeRestModel({\n  Map: Player,\n  url: {\n    resource: \"/api/players\",\n    beforeSend(xhr){\n       return Session.currentPromise.then(function(session){\n          xhr.setRequestHeader(\"AUTH\",session.token);\n       });\n    }\n  }\n});\n```\n\ncan-ajax work with a promise-based beforeSend - 3-4hrs (make beforeSend actually before send)\ndata-url beforeSend configuration ... document that - 3-4 hrs\ncan-connect/can/session/session .. document that - 2-3 days\nfix can-connect/can/map needing a List type\n\nwrite the guide :-). ## Behaviors overview \n\n\nhook vs MIXIE\n\n\ngetData from constructor's perspective ... is a plain hook .. calls it like this.getData()\n\n\ngetData from \"combineRequest\"  \"fall-through-cache\" ... getData \"MIXIE\".\n\n\nparseListData - hook \n\n\nGOAL: \n\nKnow the existing behaviors, how a behavior works, and how they can be composed together.\n\n.getList({})\n.save()\n1.  can/map - connection.save()\n2. can/map-.isSaving()MIXIE\n3.constructor/store- IN => Makes sure instance is in the store \n4.can-connect/constructor/constructorIN => _CID store, CALLS.createData... (OUT)\n5.data/callbacksMIXIE --- calls base\n6.real-time-> calls the base, but make sure promise doesn't resolve  until any prior saves resolved\n7.can-connect/data/parse/parse-> calls base\n8.data-urlmakes the request \n9.can-connect/data/parse/parse-> PARSES DATA\n10.data/callbacksCalls.createdData1.real-time-> adds stuff to stores ... CallscreatedInstance.\n         1.constructor/callbacks-once-> Makes sure that we are only seeing created once. Calls base\n         2. can-connect/can/map/map-> Dispatch\"created\"` events\n\n\ncallbacks-once\n\n\nbase\n\n\n. ## Debugging \n\n\n.log()\n\nSee proto-chain. Can you create another issue about having element on the viewModel?. This has been fixed, just not published. \n\nSent from my iPhone\n\nOn Mar 12, 2018, at 8:18 AM, Mark Stahl notifications@github.com wrote:\nReference URL:\nhttps://canjs.com/doc/can-define.types.value.html\nScreenshot:\n\u2014\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n. @christopherjbaker A few thoughts and questions on these points:\n\nIf you were to use those values without derived getters, your jsx might look like {this.props.props.name}\n\n\nHow could this happen?  I think you are talking about if a component passed itself.  My guess is you would probably see <div>{this.props.passedComponent.props.name}</div>.\n\n\nI do not think the original source of information is relevant, only that the information exists for the component.\n\n\nBoth react (having .props and .state) and vuejs think this is important.   VueJS:\njs\nVue.component('item', {\n  template: '#item-template',\n  props: {\n    model: Object\n  },\n  data: function () {\n    return {\n      open: false\n    }\n  },\n  computed: {\n    isFolder: function () {\n      return this.model.children &&\n        this.model.children.length\n    }\n  },\n  methods: {\n    toggle: function () {\n      if (this.isFolder) {\n        this.open = !this.open\n      }\n    },\n    changeType: function () {\n      if (!this.isFolder) {\n        Vue.set(this.model, 'children', [])\n        this.addChild()\n        this.open = true\n      }\n    },\n    addChild: function () {\n      this.model.children.push({\n        name: 'new stuff'\n      })\n    }\n  }\n})\nIt might not be relevant to the view.  But it's relevant to the programmer and the component.  It provides insight into where things are coming from.  I wish CanJS did this. Backbone also did this (vs can-control).\n\n\nNone of RVMs competitors, AFAIK, do this and I would like to make adoption as easy as possible (especially from redux, as it is the most popular option for state management besides \"nothing\", which has almost twice as many users as redux).\n\n\nIf \"nothing\" is the most popular option, we should be looking to pull people from \"nothing\", not from Redux. We can probably provide state management that still feels like native react.\nFor example, we could just make state the observable.  The following is the Clock example from https://reactjs.org/docs/state-and-lifecycle.html\n```js\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\ncomponentDidMount() {\n    this.timerID = setInterval(\n      () => this.tick(),\n      1000\n    );\n  }\ncomponentWillUnmount() {\n    clearInterval(this.timerID);\n  }\ntick() {\n    this.setState({\n      date: new Date()\n    });\n  }\nrender() {\n    return (\n      \nHello, world!\nIt is {this.state.date.toLocaleTimeString()}.\n\n    );\n  }\n}\nReactDOM.render(\n  ,\n  document.getElementById('root')\n);\n```\nI think we should simply make this work:\n```js\nclass Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\ncomponentDidMount() {\n    this.timerID = setInterval(\n      () => this.tick(),\n      1000\n    );\n  }\ncomponentWillUnmount() {\n    clearInterval(this.timerID);\n  }\ntick() {\n    this.state.date = new Date();\n  }\nrender() {\n    return (\n      \nHello, world!\nIt is {this.state.date.toLocaleTimeString()}.\n\n    );\n  }\n}\nReactDOM.render(\n  ,\n  document.getElementById('root')\n);\n```\nAll I did was make it so instead of:\njs\nthis.setState({\n   date: new Date()\n});\nfolks can write:\njs\nthis.state.date = new Date();\n=============\nAfter CanJS 3.0, I learned hard lessons about simplicity.  While technically more correct and flexible to write out everything separate:\n```js\nimport DefineMap from \"can-define/map/map\"\nimport stache from \"can-stache\";\nimport Component from \"can-component\";\nvar VM = DefineMap.extend({ ... })\nComponent.extend({\n  tag: \"my-tag\",\n  ViewModel: VM,\n  view: stache(...);\n})\n```\nIt wasn't as conceptually simple.  People are responding much better to the 4.0:\n```js\nimport Component from \"can-component\";\nComponent.extend({\n  tag: \"my-tag\",\n  ViewModel: { ... },\n  view: ...;\n})\n```\nIt feels integrated.  \nThe @connect pattern feels like it's over-prioritizing the \"supply state to an existing view\" problem. Instead, I think we should solve just one problem ... having to call .setState.  \n. @kylegifford IMO, we need to know the product so we can sell it the right way.  A marketing effort without knowing what the API even looks like seems wasteful.  Are we trying to peel off Redux folks, or the folks not using anything but react?  The architecture informs that.  . Thanks for the comments everyone!\nThou ... please try to keep future discussion specific. All +1s of the concept should be saved for the upcoming survey. \nBut please share specific proposals.  For example, APIs that solve stated problems, with ideas how to market the specific tool. Thanks!. You have to include the enter event manually:\nhttps://canjs.com/doc/can-event-dom-enter.html\nYou can actually just import this module:\nhttps://github.com/canjs/can-event-dom-enter/blob/master/add-global/add-global.js\nAnd it will add the event to the global registry. \nI think the compat package does this.\nI\u2019ll update the migration guide to show how to do this. . Keeping open until its part of the migration guide and the add-global module is documented.. You might be able to overwrite the encodeURIComponent method. Closing as this isn\u2019t an issue with CanJS. . A search for canjs ssr or donejs ssr doesn't lead people to anything useful. \nIf someone doesn't really \"know about donejs\" they might not know that it is the suggested way SSR should be setup.. Calling destroy like is happening here is not documented in old canjs, and therefore not supported in new releases. So can-connect/can/model is not breaking compatibility of documented features. . Also, the goal of can-connect/can/model is to provide a high level of compatibility, but not perfect compatibility. It\u2019s unlikely can-model will be supported forever. can-connect/can/model is an \u201ceasy\u201d way to support old Model code. . @r0m4n To be clear, I'm talking about calling destroy directly on the model like:\njs\nmyModel.destroy(1)\nThat is not supported.  Afaik, being able to call destroy like this is not documented. \nDefining/implementing a destroy method like:\njs\nRecipe = can.Model.extend({\n  destroy : function(id){\n    return $.post(\"/recipe/destroy/\"+id,{});\n  }\n},{})\n... is supported (or at least should be) by can-connect/can/model.  Are you having problems with defining the destroy method like as shown in the v2 docs? \n. btw, the following might work as a fallback:\njs\nmyModel.destroy(new myModel({id: 1}));\nGood luck with the upgrade.  Keep posting questions and we will do our best to assist.. @BigAB \n\nSo I am assuming a Maybe* type is basically a value of that type or null/undefined?\n\nYes\n\nWhat happens if it receives a null for on a non-Maybe type? Does it throw?\n\nIdeally yes, it will throw.  I'm not sure can-define is setup for this, but can-observe should work this way.\n\nI am really into the toQuery/toParams transforms, but I think you should take the returned value\n\nIt does, I wrote it wrong.  It's fixed now.   You can mutate these objects as a clone is passed to these functions.  But you need to return the value. \n\nDoes the following syntax already work in DefineMaps (the type shorthand)?\n\nNot yet\n\nIt may be worth playing with the first implementation a bit\n\nI think I know what you mean here, but I'm not sure.  I would rather not play with the implementation past getting all our example apps working again.  It's an improvement over can-set.  It's important to release, get feedback, and move on.  \nMore on defineComparison\nset.defineComparison is basically a shorthand for an operator registry.  Instead of === and < being the operators, we register union, intersection and difference.  \nIt's only stateful as this helper makes an entry in the comparison map.  I showed this above:\njs\nBasicQuery[can.setComparisons] = Map({\n    [type1]: Map({[type2]: {union, difference, intersection}})\n})\nIf you call set.defineComparison(Foo, Bar, {union, difference, intersection}), these functions get stored within a depth 2 tree keyed by the types being compared:\njs\nFoo[can.setComparisons].get(Foo).set(Bar, {union, difference, intersection})\nBar[can.setComparisons].get(Bar).set(Foo, {union, intersection})\nWhen set.union, etc is called, it looks up the types of the operands, and then looks in the types' setComparisons tree for how to perform the operator.\nThe union, difference, intersection methods should return  the result of performing a union, difference, intersection.\nThere are some special sets they can use:\n\nset.EMPTY\nset.UNIVERSAL\nset.UNDEFINABLE\nset.UNKNOWABLE\n\n. ## The difference between is member and subset\ncan-set conflated the difference between a member and set.  In set-theory there is a difference:\n\n\u2208 - member\n\u2286 - subset\n\nThis distinction matters as type properties don't always match query params 1 to 1.  For example, you might want to get all todos like:\njs\nTodo.getList({searchText: \"ice cream\"})\nA Todo doesn't have a searchText property.  So a set like {searchText: \"ice cream\"} needs to be able to say if a todo like {id: 4, searchText: \"make ice cream\"} is a member of the set.\nThere's a fundamental difference between a member of a set and comparing a set to another set. \n. @matthewp I was thinking instead:\njs\n// feathers-service.js\nmodule.exports = {\n  toQuery() { ... },\n  toParams(){ ... }\n}\njs\nnew Query(Todo, featherService);\nI like exporting this because it doesn't actually depend on can-query.  There are just functions. \n These methods could be useful in other places in other ways.  . @BigAB I'm not currently sure the best way to reuse the gte logic.  The following is a way that I know would work, but there's probably a lot we can do to make it easier:\n```\nDateSet = function(value){\n  this.type = firstProp(value) // type will be \"$gt\", etc\n  var value = value[this.type];\n  var number = new Date(value).getTime();\n  this.value = new comparisonsthis.type; // this is creating a new $gt(123123123123)\n}\nset. defineComparison(DateSet, DateSet,{\n  union: function(dateSet, dateSet) {\n    var result = set.union(this.value, this.value);\n    // convert result back to DateSet\n    var dateString = new Date(result.value).toString();\n    return new DateSet( {[result.type]: dateString});\n  },\n  ...\n})\n```\nBasically, I'm making a DateSet convert to a $GT() with a number, and then back to a DateSet.\nIdeally, what should happen is {$gt: \"2018-03-30T21:05:28.599Z\"} gets converted to:\njs\nnew GreaterThan( new DateSet(\"2018-03-30T21:05:28.599Z\") )\nAnd you just would have to define some extra operators (gt, eq, lt) on DateSet.  GreaterThan and similar comparators could call into the DateSet.\nOR ...\nDateSet could have a .valueOf() method (exactly like the JS one), that GreaterThan will use to get some comparable value from the date.. So I'm trying to make an easy-ish way to reuse the $gt, etc logic as @BigAB requested.  I'm primarily focused on getting the \"type\" right and the easy part later.\nThe valueOf idea works for set comparisons, but it does not work for isMember.  \nMy idea was someone could create a type that doesn't have any of the union, intersection, difference comparators, and only exposes a valueOf() method.  valueOf() is already used for the >, >=, <, etc operators (but not ==).  So if someone created a set type like:\njs\nclass DateStringSet {\n  constructor(dateString){\n    this.dateStr = dateStr;\n  }\n  valueOf(){\n    return new Date(this.dateStr).valueOf();\n  }\n}\nI'd make GreaterThan, In, etc all make sure to take the valueOf() before doing its comparisons.  \nThe problem is that the item in isMember doesn't go through this conversion to set types.  For example:\njs\nqueryLogic.isMember(\n  { filter: { date: {$gt: \"2000-01-01\"} } }, \n  {id: 0, name: \"do something\", date: \"2018-03-30T21:05:28.599Z\"})\nThe date in {id: 0, name: \"do something\", date: \"2018-03-30T21:05:28.599Z\"} is just passed to something like the following:\njs\nvar date2000 = new DateStringSet(\"2000-01-01\")\nnew GreaterThan( date2000 ).isMember( \"2018-03-30T21:05:28.599Z\" )\nWe want the GreaterThan logic in GreaterThan, but we somehow need it to ask it's SetType instance to convert the \"2018-03-30T21:05:28.599Z\" to a value that GreaterThan can do a >.\nOne way of doing it would be for isMember to promote the value to match:\njs\nGreaterThan = function(value){ this.value = value }\nGreaterThan.prototype.isMember = function(value){\n  return this.value.valueOf() > new this.value.constructor(value).valueOf();\n}\nOr it could check if the value provides some sort of conversion method itself:\njs\nGreaterThan = function(value){ this.value = value }\nGreaterThan.prototype.isMember = function(value){\n  return this.value.valueOf() > new this.value.toValue(value);\n}\nI'm not sure the best way of making this work ...\n. What should we name the new preconfigured \"model\" functions? I think there are two types of options:\nDon't use connect in the package name\n```js\nimport rest from \"can-rest\";\nimport realtimeRest from \"can-realtime-rest\";\nimport superRest from \"can-super-rest\";\nimport DefineMap from \"can-define/map/map\"\nimport {rest, realtimeRest, superRest, DefineMap} from \"can\";\nvar Todo = DefineMap.extend({\n        id: {type: \"number\", identity: true},\n        name: \"string\",\n        complete: \"boolean\",\n        due: \"date\"\n});\nrest({Map: Todo, url: \"/todos/{id}\"})\nrealtimeRest({Map: Todo, url: \"/todos/{id}\"})\nsuperRest({Map: Todo, url: \"/todos/{id}\"})\n```\nPros:\n- short\n- less confusing what is a behavior (like can-conect-data-rest and a \"model function\")\nUse connect in the package name\n```js\nimport rest from \"can-connect-rest\";\nimport realtimeRest from \"can-connect-realtime-rest\";\nimport superRest from \"can-connect-super-rest\";\nimport DefineMap from \"can-define/map/map\"\nimport {connectRest, connectRealtimeRest, connectSuperRest, DefineMap} from \"can\";\nvar Todo = DefineMap.extend({\n        id: {type: \"number\", identity: true},\n        name: \"string\",\n        complete: \"boolean\",\n        due: \"date\"\n});\nconnectRest({Map: Todo, url: \"/todos/{id}\"})\nconnectRealtimeRest({Map: Todo, url: \"/todos/{id}\"})\nconnectSuperRest({Map: Todo, url: \"/todos/{id}\"})\n```\nPros:\n\nusing connect everywhere at least lets you know you are in can-connect \"territory\"\n\nCons:\n\nlonger\nmight be difficult to tell behaviors from \"model functions\". Another option:\n\n```js\nimport modelRest from \"can-model-rest\";\nimport modelRealtimeRest from \"can-model-realtime-rest\";\nimport modelSuperRest from \"can-model-super-rest\";\nimport DefineMap from \"can-define/map/map\"\nimport {modelRest, modelRealtimeRest, modelSuperRest, DefineMap} from \"can\";\nvar Todo = DefineMap.extend({\n        id: {type: \"number\", identity: true},\n        name: \"string\",\n        complete: \"boolean\",\n        due: \"date\"\n});\nmodelRest({Map: Todo, url: \"/todos/{id}\"})\nmodelRealtimeRest({Map: Todo, url: \"/todos/{id}\"})\nmodelSuperRest({Map: Todo, url: \"/todos/{id}\"})\n```\nor \n```js\nimport restModel from \"can-rest-model\";\nimport realtimeRestModel from \"can-realtime-rest-model\";\nimport superRestModel from \"can-super-rest-model\";\nimport DefineMap from \"can-define/map/map\"\nimport {restModel, realtimeRestModel, superRestModel, DefineMap} from \"can\";\nvar Todo = DefineMap.extend({\n        id: {type: \"number\", identity: true},\n        name: \"string\",\n        complete: \"boolean\",\n        due: \"date\"\n});\nrestModel({Map: Todo, url: \"/todos/{id}\"})\nrealtimeRestModel({Map: Todo, url: \"/todos/{id}\"})\nsuperRestModel({Map: Todo, url: \"/todos/{id}\"})\n```. Another summary of this choice.  There are two dimensions:\n\nbundle vs import/export\nimport/export - can's main module will import sub packages and export them.\nbundle - can's main module contains code from other packages.\ncore vs core+ecosystem\ncan's main module exports only the core and infrastructure packages\ncan's main module exports core and the ecosystem pacakges\n\nBundle Core\n\nThis isn't an option.  How could people use can-connect without duplicating things like can-reflect?\n\nBundle Core+Ecosystem\n\nAll of the pros and cons from Option B above.\n\nOther considerations:\n\nWhat happens when we \"break\" an ecosystem package?\n\nImport/Export Core\n\nAll of the pros and cons from Option A above.\n\nOther Considerations:\n\nwe probably would have to leave canjs's API docs as module names like can-define/map/map instead of named exports like DefineMap.  This is because ecosystem bundles wouldn't be on the can export. You'd have to import their package.\nAlternatively, we could show named exports for core, and packages for everything else.\n\nImport/Export Core+Ecosystem\nDisadvantages\n\nWithout some form of client-side tree-shaking, this would take FOREVER to load.  This probably becomes unworkable.\n\n. CanJS 3.0 supports IE and will continue to. 3.0 has been out for a year and a half. \nOr plan for 4.0 is to support IE11 via polyfills. I think someone in the community has been working on this. I\u2019m on my phone so too lazy to find the issue. \nBut we didn\u2019t want it to seem like IE 11 is supported right now, so we removed it until we get all tests passing with the polyfills. \nEdge is supported in 4.0. \nSent from my iPhone\n\nOn Apr 17, 2018, at 7:54 AM, rjgotten notifications@github.com wrote:\nReally? Dropping official support for Internet Explorer outright?\nGreat...\nLooks like I won't be migrating past 2.x for the next years then.\n\u2014\nYou are receiving this because your review was requested.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Regarding the polyfill approach, we required the same thing for IE 6 and 7 for old versions of CanJS.  You had to include HTML5Shiv. We also require a Promise polyfill for canjs 3.0. \n\nPolyfills are a pretty common practice. Why are you hostile to them?\n. > If you're in full control of the site or app that is meant to run your CanJS-based logic, that's a solution.\nBut it's infeasible when you're not. \nI'd like to hear more about this situation.  To me, it seems like the solution is to use polyfills that feature detect the absence of the desired feature and only polyfill it when it is missing.  Would this approach work for you?\nAlternately, we could have everything in CanJS import these features like:\njs\nvar WeakMap = require(\"can-polyfill/weakmap\");\nWhich would look like this:\njs\n// can-polyfill/weakmap.js\nmodule.exports = WeakMap\nThen, folks using a module loader could map from can-polyfill/weakmap to an actual polyfill.  The benefit of this approach is that the global WeakMap wouldn't be \"polluted\".\n===========\nAnyhoo, all of the above is to say, is that we will try to work with people to find solutions to upgrading to 4.0.  Please detail more of your concerns in that issue: #4098.\n. @rjgotten I'm ok with removing a dependency on Object.assign because we already have canReflect.assignMap(). I'm not sure how that actually snuck in.  But WeakMap and WeakSet were one, if not THE, critical design choice that helped simplify CanJS and make a lot of features either possible, or manageable. \nI don't want to burden people with pulling in polyfills as CanJS's default behavior.  \nI'd like some additional clarity on the root problem:\n\nIs it the number of polyfill \"files\"? \nIs it the number of polyfilled \"APIs\"?\nIs it some mixture of both?\n\nI ask this because presumably you don't have to ask people to setup any polyfill \"files\". They can be built into your app file.\nIf it's the number of \"APIs\", then how many is too much?  \nWould the module-loader mapping technique work for you?\n. With most module loaders, you are able to map package names.  We could make it super easy.\nCreate a can-env/weakmap:\njs\n// can-polyfill/weakmap.js\nmodule.exports = WeakMap\nAnd then a can-polyfill/weakmap:\njs\n// can-polyfill/weakmap.js\nmodule.exports = function(){ ... } //weakmap polyfill\nThen folks could just map can-env/* to can-polyfill/*.  Or they could pick individual modules to map.  . CanJS 4.0 does minimize the cost of building CanJS applications with new features and performance improvements that are helped from things like MutationObservers and WeakMap. \nThe mission is about a balance of innovation and stability.  We think that it's the right time to start using these features (yay auto-mounted components and goodbye CID!), and we can still provide (what I consider) a good compatibility story (stability).  \nThe difference here is that we don't see polyfills as much as a burden.  CanJS has always required some polyfill for the oldest browsers it supports.  \n\nIt also increases risk and stability. Polyfills may be incompatible or worse: become incompatible over time. (Notably when CanJS suddenly starts using an API feature that is not properly supported by a polyfill.)\n\nAs we did previously, we will test CanJS against the legacy browsers with the recommended polyfills.  CanJS can't start using a new unsupported feature because it would break its automated tests.  Are you sure this is a valid concern?\n\nIn this thread, I suggested a solution that solves the \"3rd party widget\" use case: \nI say we set about doing this. @rjgotten when is your timeframe for upgrading?  Can you help us with this?  Thanks!\n. So these errors happen while CanJS is loading?  Can you give more details about how you set this up?  Do you have a repo we can clone?  Thanks!. Issue moved to canjs/can-stache #506 via ZenHub\n. \n\n\n\n\n\n\n\n\n\n. Didn't want polyfills because their app is displayed in Ads.  Don't want to mutate the env.\n. This is breaking in Edge 17.  I'm not able to launch it with browserstack.  But everything passes in Edge 16 so I'm going to merge.. @Kienz this is great!  Thanks!. Issue moved to canjs/can-reflect #111 via ZenHub\n. Thanks.  CanJS 4.0 removed that direct jQuery integration.  I think @chasenlehara created some compatability for 4.0.  We will update the page accordingly.  . - [ ] In many packages?. As part of this issue, we will need to make sure the build actually works.  I think we are currently testing the build.  We will need to test this fashion of build too.  \nShould we do this for both 4.X and 5.X?. I think we should have a \"webpack-test\" module that imports all the tests that are \"safe\" for webpack to run.  Then we should have webpack build those tests and run the built version.\nBy \"safe\", I mean tests that are not using steal-clone and similar special features.. We need webpack-stache to fully close it I think.. Will this turn on pushstate routing in all jsbins and such?\nMaybe in 5.0, we should make people call routePushstate() or something .... I think we should, but change can-route-pushstate() so you have to call it ... though this will effect done-ssr.. creating an issue. @matthewp when you register a converter, it will always call the converter with observables. . @matthewp (cc @phillipskevin ) I feel like we are now forced to implement the \"special\" imports.  I think there's github issues around this, but they would look like this:\n<can-import from=\"can-stache-route-helpers\" value:to=\"scope.helpers\"/>\n<can-import from=\"can-dom-events-enter\" value:to=\"scope.events\"/>\nIssue for the events registry: https://github.com/canjs/can-stache-bindings/issues/440\nAnd \"shifting statefulness to the developer\": https://www.bitovi.com/blog/coping-with-stateful-code\n\n\n.helpers, .events, .partials. UIs to investigate:\n\n\nhttp://output.jsbin.com/qujiyuy - a grid where there is a component in each cell.. js\nvar fragment = require('can-util/dom/fragment/fragment');\nvar makeArray = require('can-util/js/make-array/make-array');\nvar frag = require('can-util/dom/frag/frag');\n\n\njs\nvar fragment = require('can-fragment');\nvar makeArray = require(\"can-reflect\").toArray;\nvar frag = fragment;. Yes, we are planning on making it work in about 2 weeks. Any help you can give would be great. . Hey all, as we've begun working on this, we are closing this issue for the proposal.  Please add comments here: #4115. I think the advantage is the individual repos. This allows us to make a release to can-stache that works for canjs 4 and 5 users. Would lerna support this? If not, moving to it would undo the whole benefit of the 3.0 shift. . Converting to individual repos didn\u2019t hurt canjs on its own, but the changes we made in presentation of the framework because of that change did. . Here are the sizes of our dependencies in KB:\n\ndu -sk * | sort -n | tail -r\n\n81976   can\n3316    can-debug\n1132    validate.js\n860 can-connect\n856 can-util\n800 can-ndjson-stream\n780 kefir\n728 can-stache\n588 can-query-logic\n564 can-define\n412 can-simple-dom\n384 can-connect-feathers\n340 can-queues\n320 can-component\n312 can-observe\n272 can-stache-bindings\n268 can-fixture\n260 can-reflect\n256 feathers-authentication-popups\n232 simple-html-tokenizer\n232 can-validate-legacy\n220 can-route\n216 can-set-legacy\n212 feathers-errors\n208 can-symbol\n208 can-event-queue\n200 can-value\n188 can-bind\n184 can-key\n180 can-view-scope\n172 can-compute\n164 can-view-live\n152 can-globals\n148 can-map-define\n148 can-map\n144 can-diff\n132 can-view-parser\n124 can-stache-converters\n124 can-list\n124 can-key-tree\n124 can-control\n120 can-dom-events\n116 he\n112 can-ajax\n108 can-view-import\n108 can-kefir\n104 events\n104 debug\n104 can-simple-observable\n104 can-observation\n100 can-view-callbacks\n100 can-validate\n100 can-route-pushstate\n100 can-fixture-socket\n96  can-stream\n88  can-observation-recorder\n84  can-zone-storage\n84  can-view-nodelist\n84  can-view-autorender\n84  can-rest-model\n84  can-local-store\n84  can-construct\n84  can-connect-tag\n84  can-attribute-observable\n80  can-vdom\n80  can-super-model\n80  can-realtime-rest-model\n80  can-memory-store\n80  can-data-types\n80  can-cid\n76  jwt-decode\n76  can-reflect-dependencies\n76  can-define-stream-kefir\n76  can-define-stream\n72  steal-stache\n72  can-single-reference\n72  can-log\n72  can-fragment\n72  can-event-dom-enter\n72  can-dom-mutate\n72  can-child-nodes\n68  can-string-to-any\n68  can-stache-key\n68  can-param\n68  can-join-uris\n64  can-stache-ast\n64  can-simple-map\n64  can-parse-uri\n64  can-import-module\n64  can-deparam\n64  can-define-lazy-value\n60  can-stream-kefir\n60  can-stache-route-helpers\n60  can-reflect-promise\n60  can-dom-data\n60  can-define-validate-validatejs\n60  can-define-backup\n56  can-make-rest\n56  can-construct-super\n56  can-assign\n52  can-view-target\n52  can-validate-validatejs\n52  can-types\n52  can-string\n52  can-event-dom-radiochange\n48  can-view-model\n48  can-stache-helpers\n48  can-sort-object\n48  can-dom-data-state\n48  can-attribute-encoder\n44  steal-config-utils\n44  can-validate-interface\n40  symbol-observable\n32  can-namespace\n24  micro-location\n16  ms. @m-mujica should it be possible to decrease the size of can-debug?  . https://github.com/canjs/can-ndjson-stream/issues/35. We should probably take a look at anything we own > 250k.  It probably means it has a build still:\n\n[ ] 81976 can\n[ ] 3316  can-debug\n[ ] 1132  validate.js\n[ ] 860   can-connect\n[ ] 856   can-util\n[ ] 800   can-ndjson-stream\n[ ] 780   kefir\n[ ] 728   can-stache\n[ ] 588   can-query-logic\n[ ] 564   can-define\n[ ] 412   can-simple-dom\n[ ] 384   can-connect-feathers\n[ ] 340   can-queues\n[ ] 320   can-component\n[ ] 312   can-observe\n[ ] 272   can-stache-bindings\n[ ] 268   can-fixture\n[ ] 260   can-reflect\n\n. I wish we could ignore test files. In the case of can-component it was 124k of its 320k. ugg ... I just realized we can't ignore docs because they are used to build the site ...\nI wonder if canjs/canjs should eventually work differently ... install from github tags to build its site.. Yeah, we used to use submodules.  I'm not sure how I feel about going back to that.  Packages are more explicit.  . You can see that currentBinding is pushstate if you set a breakpoint in the line that breaks and walk up to start():\n\n. This is even easier to see if you import from \"can\" in the route-counter demo:\nhttp://localhost:8080/canjs/demos/technology-overview/route-counter.html. Along with this, I think we should have the component generators produce this.  For example:\n```js\nComponent.extend({\n    tag: \"component-name\",\n    view,\n    ViewModel: {\n      // EXTERNAL STATEFUL PROPERTIES\n      // These properties are passed from another component. Example:\n      // value: {type: \"number\"}\n  // INTERNAL STATEFUL PROPERTIES\n  // These properties are owned by this component.\n  message: {default: \"This is the component-name component\"},\n\n  // DERIVED PROPERTIES\n  // These properties combine other property values. Example:\n  // get valueAndMessage(){ return this.value + this.message; }\n\n  // METHODS\n  // Functions that can be called by the view. Example:\n  // incrementValue() { this.value++; }\n\n  // SIDE EFFECTS\n  // The following is a good place to perform changes to the DOM\n  // or do things that don't fit in to one of the areas above.\n  connectedCallback(element){\n\n  }\n}\n\n});\n```. Other things:\nHandle side effects\nSide effects are probably one of the hardest things to get right.  Much of this can be done in connectedCallback, but not all of it. It's nice to be able to easily mock up the side effects.  \nnew Bind() can be used to do things in a way that the dev-tools understands. \nMaybe we should teach people how to work with the dev-tools here?\nExamples:\n\nmaking an ajax request\nconnecting the paginate's .length to the .count returned from the server.\n\nonValue\nIt will probably be useful to add this to value({onValue}) as short-hand for listenTo().\nType Checking\nIt would be nice if https://github.com/canjs/can-define/issues/334 is complete.\n. - [x] debugger guide shows importing can-debug with require.  How can we do this with import? . It seems that with our existing guide, in production webpack, //steal-remove-x is still left:\n\n@cherifGsoul do you know anything about this?. @rjgotten Steal's support of //! likely goes back 8 years.  I'm not sure it was well established by then.. I think we should just copy the core.js and ecosystem.js to can.js and can.all.js, maybe insert a console.warn() at the top.  . Yeah, a little bit of work can make sure a bunch of demos keep working without surprises. . People should change their URLs, but they likely haven't.  CanJS 3.0, 4.0, 5.0 all can have basic examples that work for every version.. break on change?. I will. If it turns out to be a steal bug, I'll pass it off to you.. @knrt10 , that would be great.  You just have to create a PR with the changes to this file. . Force only needs to be rerun if you change bit-docs configuration. Installing other canjs packages is ok.\nSent from my iPhone\n\nOn Jul 20, 2018, at 8:03 AM, Mike Dane notifications@github.com wrote:\nYeah good point! Im definitely not 100% sure, although I was using this yesterday and was able to successfully run npm install ../can-compute && npm run document which is technically installing a new package. Either way I think we should put some sort of note here which better explains the correct usage. @justinbmeyer\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub, or mute the thread.\n. Thanks!. It will be merged (or we will have another release that includes the updated can-define).  Though I'm unsure how you are getting a breaking build.  Are you installing from github? Is that what (github:canjs/canjs#d596e62e6770885366c33a4351858f0080b195fb) represents?. Thanks!. It appears that TodoMVC isn't working: can-guides/experiment/todomvc/todomvc.html when you focus / blur.\n\nCC @m-mujica I think you worked on the initial can-attribute-observable.  Do you know what happened to focused?. Ah, it does exist. It's here: https://github.com/canjs/can-attribute-observable/blob/master/behaviors.js#L224\nIt still needs to be documented.  I'll look into why todomvc is failing.. Issue moved to canjs/can-attribute-observable #16 via ZenHub\n. \"{element} inserted\": function(){\n  // BIND ON SOMETHING\n  this._teardown = function(){\n    // UNBIND ON SOMETHING\n  }\n},\n\"{element} removed\": function(){\n  this._teardown && this._teardown()\n},. There's some considerations about implementation.  Specifically:\n\nI think we will need to statically see {{scope.walk}}  to ensure all scopes are created with walk: true\nI think we will need to remove recursion from Scope to make this work.  . ## Explanations for questions above\n\n\nCould I listen to the amp-resize event on a responsive iframe, for example?\n\nYes. That should work as long as it's dispatched as a custom event elem.dispatchEvent(event);\n\nDo can-stache-bindings for properties rely on DefineMap or observables, or will they work with POJO? Would be nice to have a note about the underlying mechanism here.\n\nYes, they rely on observables.  The observables need to support the canReflect.onKeyValue symbol:  https://canjs.com/doc/can-reflect/observe.onKeyValue.html\n\nIt's not always clear why some properties/methods are TitleCase and some are camelCase (type vs. Type in DefineMap seems like a particularly gruesome edge case). Would be good to have more clarity on that called out.\n\nWhen we expect a constructor function, we capitalize.  For example: Type: Animal.  The lower-case version is used to provide a function that returns the type.  For example: type: function(x){ return x+2; }.  Type and Default are shorthands:\njs\nType: Animal,\n// same as\ntype: function(v){ return v instanceof Animal? v : new Animal(v) }\n\nIs it policy not to refer to other frameworks? I think some of this might be made easier with comparisons to libraries that the reader might have used before, either in a larger section or when talking about specific concepts.\n\nImo, it would be odd in the API docs, but there's a comparison page that we've long wanted to work on.. >  Not technically the overview page, but when I click through to the docs for Definemap, the @can.name symbol convention is used but never explained\n@thomaswilburn Can you explain more about this?. So MDN uses @@ (Ex: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/@@iterator)... but I felt that was overkill and shortened to @.  I think there are some places still using @@.\nMaybe we could have the hover show the type:\n\nHave you noticed that hover?\nWere you aware of the @@ convention?  Maybe we should go back to @@.. Another without:\n{{#if(messagesPromise.isPending)}}\n  <div class=\"list-group-item list-group-item-info\">\n    <h4 class=\"list-group-item-heading\">Loading\u2026</h4>\n  </div>\n{{/if}}\n{{#if(messagesPromise.isRejected)}}\n  <div class=\"list-group-item list-group-item-danger\">\n    <h4 class=\"list-group3--item-heading\">Error</h4>\n    <p class=\"list-group-item-text\">{{messagesPromise.reason}}</p>\n  </div>\n{{/if}}\n{{#if(messagesPromise.isResolved)}}\n  {{#for( message of messagesPromise.value )}}\n    <div class=\"list-group-item\">\n      <h4 class=\"list-group3--item-heading\">{{message.name}}</h4>\n      <p class=\"list-group-item-text\">{{message.body}}</p>\n    </div>\n  {{else}}\n    <div class=\"list-group-item\">\n      <h4 class=\"list-group-item-heading\">No messages</h4>\n    </div>\n  {{/for}}\n{{/if}}\nAnd with:\n{{#if(this.messagesPromise.isPending)}}\n  <div class=\"list-group-item list-group-item-info\">\n    <h4 class=\"list-group-item-heading\">Loading\u2026</h4>\n  </div>\n{{/if}}\n{{#if(this.messagesPromise.isRejected)}}\n  <div class=\"list-group-item list-group-item-danger\">\n    <h4 class=\"list-group3--item-heading\">Error</h4>\n    <p class=\"list-group-item-text\">{{messagesPromise.reason}}</p>\n  </div>\n{{/if}}\n{{#if(this.messagesPromise.isResolved)}}\n  {{#for( message of this.messagesPromise.value )}}\n    <div class=\"list-group-item\">\n      <h4 class=\"list-group3--item-heading\">{{message.name}}</h4>\n      <p class=\"list-group-item-text\">{{message.body}}</p>\n    </div>\n  {{else}}\n    <div class=\"list-group-item\">\n      <h4 class=\"list-group-item-heading\">No messages</h4>\n    </div>\n  {{/for}}\n{{/if}}. I made scope.log() work.  We could basically do something similar in a custom devtools plugin.. @CleverOscar is there a PR for this stuff?. @CleverOscar Please clean up this issue.  Please CHECK anything that is complete like:\n\n[X] This is complete\n\nAnd uncheck anything that needs to be done.  For example:\n\ntodomvc-with-steal\n[x] - Reviewed\n[ ] - Can't proceed past first step.  (Please include why you can't proceed, also the name of the step).\n\nFinally, please include more information, images, etc of the bugs you find so I know what to look for.\n . One idea might be to have users do a recipe, read the tech overview, read the existing homepage (why) and see what they respond to.. @thomaswilburn \nInterpreting:\n\n. As used in Vue, they're convenient because they provide an easy way to package up a component with its styles and view template, and they also eliminate a bunch of the boilerplate. I personally like that they tend to work well with editors for syntax highlighting without adding special plugins the way that JSX or CSS-in-JS approaches normally do.\n\nAnd applying it to what I proposed:\n\n[x] package up a component with its styles and view template\n[x] eliminate a bunch of the boilerplate\n[ ] editors for syntax highlighting without adding special plugins the way that JSX or CSS-in-JS approaches normally do\n\nIt's really the 3rd point that is the difference.  And I think only the CSS/LESS highlighting would be lost in what I proposed (when compared to yours) because handlebars / mustache does not come for free in either case.\n=======\nAlso regarding:\n\nAssuming that it generates unsealed\n\nIf a component gets values upon instantiation, those properties do not need to be predefined.. Also, the existing .component files look like:\n```html\n\n\n    display: block;</p>\n<pre><code>p { font-weight: bold; }\n</code></pre>\n<p>\n\n\n\nName / Address / Phone\nOrder\nTotal\nAction\n\n\n\n\n    export default {\n      message: {\n        default: 'This is the pmo-order-history component'\n      }\n    };\n  \n\n```. Putting this all together ... is CSS highlighting working by default worth deviating from the look of a \"standard\" component?\nI think there's a lot of benefit of having these things look the same across all sorts of projects.\n. ## ReasonLog\n\nAnswer:\n\n. ## components and logStack\n\n. ## Notify\n\nanswer:\n\n. ## scope.log\n\n\n. ## Debug scope\n\n. ## logWhatChangesMe\n\n. For now, I'm going to use the global build for this example. . Another way of fixing this might be to simply assign the get function to something in the outer scope.  Sorta ugly, but would get the job done.  \njs\nvar get = function(){ ... }\ndebuggerHelper.lastGet = get;. I think this is closed now: https://github.com/canjs/can-stache/blob/master/helpers/-debugger.js#L57. @matthewp the possibilities are documented.   So I guess limitations would be everything else.\nI think what is going to confuse most people is that stuff like on:click=\"this.foo++\" won't work, only valid expression work.. Hopefully add CHECK to can-event-queue .. can-define, can-simple-map, can-map.\nCHECK is there a can-observation-recorder recording right now? That's not good.. This is a question for steal. Steal supports development bundles. . core.min does  not have the debugging infrastructure.  I'd use core.mjs.. Thanks for posting.  Adding the following so folks understand the historical reasons we kept these separate:\n\nWe want to encourage folks outside Bitovi to contribute.  We felt having everything in Bitovi might turn folks off.\nWe want people feel like they can use projects on their own.  You don't have to use CanJS if you want to use steal.  \n\nThere are two solutions I see:\n\nPut everything under DoneJS.  The problem here is that we don't want people using steal to feel like they have to use done-ssr, canjs, etc.\nPut everything under Bitovi. The problem here is that folks might not feel like they want to contribute as much.  Personally, I think putting everything under Bitovi is what we should do. Bitovi is cool (or at least should be perceived that way).  It is an open source company.  It's brand shouldn't really get in the way and help encourage people.. It should be possible to do this as DoneJS does this already.   You likely need to first setup can-simple-dom and then make sure can-globals gets all of can-simple-dom's outputs.\n\nSomething like:\n```js\nvar makeDocument = require('can-vdom/make-document/make-document');\nvar globals = require('can-globals');\nvar doc = makeDocument();\nglobals.setKeyValue(\"document\",doc);\nglobals.setKeyValue('MutationObserver', null);\nvar Component = require(\"can-component\");\n... DO STUFF ...\n```. I don't know how much people want to debug microscopically vs macroscopic\nMICRO: say someone clicks a button, and they want to break down everything that happens as a result of that bug click ... as values get passed from one component to another.  This is what can-queues.logStack() does.  But I think time-travel is VERY difficult on this level without something like a \"slow mode\" queue.\nMACRO: You click one button, then another button, then submit a form, then do something else.  We can do time travel for these things.. Thank you!. fixed. Issues with vdom diffing:\n\nthe vdom has cycles.  Not sure how to teach the vdom how to be diffed ... which codepen?  Can you provide a screenshot?. figured it  out, fixed. @manaswinidas if you'd like to pair on any of this, please reach out to us: core@donejs.com.  We can help get you started.  Thanks for offering to help!  Also, couldn't hurt to email us because we will send you some t-shirts and such :-). codepen and unpkg doesn't apply to this guide. @frank-dspeed please create another issue for that.  I think something like that can be created on-top of CanJS's symbols APIs, but it can't be the underlying primitive CanJS uses without too many breaking changes.. I believe there is already an issue for doing this for all canjs packages. Nothing blocking. No one assigned. The big thing is changing how canjs/canjs works. I\u2019ll write up more later. . We already designate \u201ccore\u201d and \u201cecosystem\u201d packages. What is this not providing?. Slack discussion: https://bitovi-community.slack.com/archives/CFC22NZ8A/p1549030449119900\n\nWhile we probably should make this work, I think that in the next major breaking change we should make:\nthis:from=\"x\"\n... actually make the ViewModel itself x.\nAnd the following:\nthis:assignFrom=\"x\"\nInitialize the viewModel with new ViewModel(x) and then do canReflect.assign() on any changes of x.\n. My assumption is that only one <can-crud> would typically be visible at one time.  Sometimes the <can-crud> would be presented next to a <can-list> of a different type.  For example, I've seen a tasks page with a list of users that could be drag-dropped onto a todo.\nObviously, drag/drop won't work with can-crud, but it's to scaffold up the app.. > Is there a concept within can-crud of a view being \"finished\"?\nThere could be a concept of being finished.  For example, if you were editing a record, we might not want to let the app close that unexpectedly.  But I don't know how important this would be for most use cases of can-crud.. Can you change this to not use fixture: function() ... this has been deprecated for a long time.  Instead, do:\ncan.fixture(\"POST /people/{id}\",function(){\n  return  {createdAt: \"now\"}\n})\nThanks!\n. A compute probably does not need to be created.  A function will do I bet.\n. could you use deepEqual here?\nhttp://api.qunitjs.com/deepEqual/\n. Does this force the color attribute value into an array?  But it works as a string value at first?  I'm not sure about that ..\n. It's possible to use attributes / converters without adding to the window.\n. Is a findOne necessary?  Could new be used instead?\n. Clearing .innerHTML prevents event handlers from being cleaned up.\n. I think this should test updating a can.Map's list property to null then to an array and then back to null.\n. Thanks a ton for the docs! I'm going to have to change some of this text b/c using can.Control.route isn't really \"recommended\".\n. @sykopomp can you identify the change in this section?\n. @sykopomp here too ... what changed?\n. Please put test html within #qunit-test-area.\n. For this to pass in all browsers, it needs to be:\ncan.scope( can.$(\"test-comp\") ).attr(\"attr1\",1)\n. It's likely possible to only define the Clone \"class\" on demand instead of every time a can.Observe \"class\" is defined.\nCould this check if this.constructor.Clone exists and create it.\n. What if clone does explicitly set \"awesomeness\"?  Does .merge overwrite changes to the \"source\" observe?\n. This is a less than ideal implementation.  We should not be setting temporary properties like this on a scope.  Why not set a stopLookup variable to true and change attr = attr.substr(2)?\n. This doesn't actually test bubbling.  2 scopes are needed to be created.  Not a Child extending from it's parent.\nAlso, there should be a test in mustache or stache verifying this.\n. Does this handle double // ? \n. Can't\n\ncan.Construct && cur.prototype instanceof can.Construct\n\nbe replaced with:\n\ncur.prototype instanceof can.Construct\n\ndoes instanceof undefined fail?\n. It's possible context could be null, \"\", etc.  We really should make sure that .fn is called without any arguments.\n. @retro can you add a test for that?  Make sure 0 could be the context.\njs\nregisterHelper(\"zero\", function(){\n   return options.fn(0);\n});\n{{#zero}}{{.}}{{/zero}}\n. The comment below describes what this is doing.  isHelper might be renamed looksLikeAHelper, but this is hitting the case where it didn't look like a helper and no value was found in the scope, then try to look for a helper. This code is fine.  Please ask a question about this code in the forums or in github instead of writing a comment like this.\n. To be more clear ... the rules are:\nIf the tag looks like a helper - `{{foo bar}}`\n  then try to get a helper right away\nif there's not a helper\n  try to get data\n  if there's no data (and it doesn't look like a helper, so we haven't tried looking for a helper)\n    try to get a helper\n. I think this is inefficient ... it should be using can.compute.truthy.  Checkout how #if works.\n. Why would you check if prop === define on every iteration of this loop?  Can you you just check if \"prop\" in this.prototype outside this loop.\nAlso, using .toString() isn't supported everywhere ... is this the best way of checking if the define plugin is loaded?\n. indexOf is not supported in IE8.  Use can.inArray.\n. Not sure this will ever be performance sensitive, but I've read that generating the function can be 3x faster in chrome.  IE:\njs\nreturn new Function(\"can.data( ... ).\"+name+\").apply(this, arguments)\");\n. It's not a performance benefit when creating the function, it speeds up when the function is called.  Every time you called element.method() ... calling .method() would be faster.\n. So your benchmark could be just a single function called many times.\n. I doubt there will be a performance hit in any other browsers.\n. Interesting.  I read that this technique improved dirtychecking 3x.  I saw about 2x improvements in can.stache.\n. It's very strange that going from [name] to .name would slow things down.  \nI don't think you can put .__component directly on the element in IE8 without risking a lot of memory leaks.  It will almost certainly create a cycle if __component has any references (including function closures) to the element.  Cycles leak in IE8 even if nothing references the cycle.\nI'm actually not sure if this is an IE8 problem or was fixed in IE7.  You might what to check.\nAn alternative would be to keep your own component instance map and avoid $.data altogether.\nBtw, can can.data be passed a raw element?  Avoiding the can.$ might save some time too.\n. I think steal adds a .js to \"\"\nSent from my iPhone\n\nOn Jun 19, 2014, at 4:01 PM, David Luecke notifications@github.com wrote:\nIn route/pushstate/pushstate_test.js:\n\nstop();\n            makeTestingIframe(function(info, done){\n-                   info.route.bindings.pushstate.root = \"/\";\n-                   info.route.bindings.pushstate.root = can.test.path(\"route/pushstate/testing.html\", true).replace(\"route/pushstate/testing.html\", \"\");\n  Isn't can.test.path(\"route/pushstate/testing.html\", true).replace(\"route/pushstate/testing.html\", \"\"); the same as can.test.path(\"\")?\n\n\u2014\nReply to this email directly or view it on GitHub.\n. Thanks for submitting this.  Please try to avoid using extraneous parts of CanJS. can.route is unnecessary for a can.Component test.\n. this should be \n\njs\nnew this.constructor()\n. instead of {String} this will return a {DocumentFragment}.\n. Typically we always have all params before the @return.\n. if you look at how the other helpers look in the sidebar of:\nhttp://canjs.com/docs/can.stache.html\nYou'll notice that {{#is expr1 expr2 expr3}} doesn't really fit in.  At least, I think expr3 should be removed: {{#is expr1 expr2}}.  We could start showing expanded arguments like {{#is expr...}}\n. Actually, is this a duplicate?  I think one of the two BLOCK params should be removed.\n. On pages like http://canjs.com/docs/can.stache.helpers.helper.html we use \"...\" to signal unlimited number of arguments.\nPlease change the signature to:\n{{#is expr...}}BLOCK{{/is}}\n. We don't unfortunately have a can.stache.expression that you can link to.  However, I can fill that in.  Can you change this to:\n@param {can.stache.expression} [expr...] An expression or key that references a value within the current or parent\n. I don't think can.compute necessarily always returns its current value when being set.  I would change this to:\nthis.options.value(el.value)\nvar newVal = this.options.value();\n. I think leakScope should have it's own page, similar to how all the other prototype properties do.\n. Perhaps you can just move this into it's own MD file.\n. Once a user supplies arguments, should the \"old defaults\" be added?  Should foodType, el2, ev2 be passed?\nI'm thinking of people checking arguments.length sorta thing.\n. I'm on PTO too and Monday I'm doing a new hire training.  So either @daffl or you maybe.\n. isComputed is a boolean.  So I think this should be compute.isComputed = true\n. @zkat or @daffl Can we remove this line for now, until #1300 is figured out. I'm pretty sure I'll want @scope to mean the actual can.view.Scope at that time.\n. arg, yes.  Can you or @brianmoschel remove it for me?\n. maybe I'm missing something, but what if someone passes a handler?  Not all events for that handler will be removed. \n. This won't work outside jQuery.  You probably want to use can.attr.set.\n. We always put the test number at the end of the test name in parenthesis.\n. no reason to add stuff to the DOM unless you have to.  There's no reason here.\n. This won't work with a property like \"foo.bar\".  Maybe add a test for that.  You can probably split by \".\" and use can.getObject to get the \"root\" object to set.\n. is this setTimeout necessary?  Also, it 50ms is a long time when there are 1000 tests.\n. Is there a case where this.options.destroy would not be a function?\n. We write types with capitals like {Object|String|Boolean}\n. Can you change this to ## Use.  This way, we are consistent with every other page.  Thanks!\n. This won't work in older browsers.\n. it doesn't.\n. Yes.\n. This is a great example.  It might be a bit too long for someone to easily digest.  Do you think all these cases are necessary?  This seems to be documenting can.Map and can.Lists events instead of how the \"events\" object works.\n. I should restate ... it's not so much about what people can handle (although I think that a 200 line example is a bit long to read)\n... it's about having the right docs in the right places, especially API docs, and being able to maintain docs.  Control and Component.prototype.events are just \"sugar\" ontop of can.Map.prototype.bind and can.List.prototype.bind.  Those .bind functions should be the place where comprehensive docs about what events are possible are documented.  This makes sense because if we make changes to .bind, we will likely document it there.\nThe Component.prototype.events should just be explaining how the sugar maps to the underlying .bind, with a few examples.\nThis example also shows a '{window} click' which is not viewModel related.\n. The above code seems like it's doing something wrong.  What is this trying to show?  I can't think of a good case to assign an id of one Model instance to another model instance.\n. What is replaced for?  I think you mean when a reference to a list is changed?\n. I'm not sure how this is working because it's not adding it to initialViewModelData._data\n. no changes should be made in this file.  This is our legacy test.\n. are there other attributes that should be set this way?  Should anything with : be set this way?\n. hard coded\n. use the version\n. I think this shouldn't be here.  We should be just using canjs.package.version everywhere.\n. why was this changed to all?\n. oh, it wasn't\n. Gross.  This lameness can't be our mission statement.. the real goal is to verify node is working by printing out its version.. The left was organized by importance.. I'm wary of using special quotes other than ' or \".  ' and \" are easier to type and, at least for me, provide equivalently readable punctuation.  I don't want to be inconsistent.  I've noticed these changes mistakenly in code blocks, which breaks the code.  . it shouldn't be can-stache/can-stache ... can-stache should be fine.. we should look into what it takes to make a stache plugin for them.. no outline?  Why?. You might want to redefine what this means here.  . My guess is that it's trying to provide its own.  Also, there's no description (which show up if you hover over a link to this page).  I'm not sure it's worth breaking this convention.  . was there another version of this?  Why would someone need to do this?. This should probably be Adding Ecosystem Packages as that will be by far the most common.  . You can do @@ I think to write out @. Also, might not be an object.  But it's ok.\nProbably should be <PACKAGE_NAME>. DefineMap.extend. should we make formatErrors a bit nicer so it handles our single use case:\nhtml\n{{formatErrors(this, \"card\"}}\nWhy is it testSet?  Presumably the value is already set as there is a two-way binding with card and not {^$value}=\"*cardValue\".. The v3. should probably be removed from here.  Also, these links should match what is in each collection:\n\n. These should link to what's in http://canjs.com/doc/can-legacy.html\nRemove can-mustache.. It's possible to have identifiers that are not strings, like can-fixture.  . we might want to return undefined instead of null.  As null is more likely to be a purposeful \"added\" value to the registry.  . I thought we were \"going to go with\" remove for now for performance reasons?. I think we should have _KEY as private, but document __KEY as NOT necessarily private (meaning if __KEY is documented, it's ok to use).  For example the __keys event can be bound to, but is named __keys to prevent collisions with other properties.  Symbols can eventually fix this, but it's how we avoid collisions currently. . the old slug creates ordering problems I'll check for broken links in canjs before I release. they shouldn't be in a real app. . const and let are for the weak minded.  I'm part of the hard-corevar uproar!. top?  cc @phillipskevin . I generally try to use define instead of create to more clearly distinguish between \"extending / define\" VS \"instantiate / create\".  . We should probably change these eventually to the \"standard\" component syntax, without everything broken out.. Thanks! I wonder if this affects the line numbers.. componentElement.viewModel works now. ",
    "moschel": "To push out to staging or production, log in and push build on the corresponding Jenkins project: http://ci.javascriptmvc.com:8080/\nStaging is setup to automatically push out to staging.donejs.com after every commit to canjs.\nThe build script is here: https://github.com/jupiterjs/canjs/blob/master/util/make.js, but 3/5 projects don't build because of envjs errors that I haven't figured out yet.  I made the names like the jquery names: donejs.com/can/util/can.jquery-git.js\nTests are running automatically for 3/5 projects, but not for all browsers yet.  Need to make a change to funcunit to support reporting errors for multiple browsers.\nI'll get all this finished this week.\n. Thanks, good call.  The other URL only works if you have admin access on the repo\n. we need this for loops too, so we can do...\n{{#Grid.rows}}\n \u00a0{{#Grid.cols}}\n \u00a0 \u00a0<div>{{columnData ../. .}}</div>\n \u00a0{{/Grid.cols}}\n{{/Grid.rows}}\n. +1 for this.  Without this support, here's what I have to do in a helper function to support a nested loop:\n```\nMustache.registerHelper('columnData', function(cols){\n    var res = [], col;\n    for(var i=0; i');\n        res.push(this[col.name + 'Prepared'] ? this[col.name + 'Prepared'] : this[col.name])\n        res.push('');\n    }\nreturn res.join(\"\");\n\n});\n```\n. yeah you were right, fixed this in https://github.com/bitovi/canjs/commit/b62f3492469b09b73143c495e6380fe1c14c0891\n. Tested this against latest locally and its no longer breaking.  Tomorrow we'll push out a new 1.1.4 release candidate at http://canjs.us/release/latest/can.jquery.js (this isn't currently actually pushing out every night automated) and this should confirm this issue is fixed.\n. Actually nevermind what I said above, forgot I had made a local change.  Actually these lines in observe.js cause this weird behavior:\nif ( self.__convert ) {\n  newVal = self.__convert(prop, newVal);\n}\n__convert is called twice per nested observe, once here and once a few lines down at self._set(prop, newVal).  I'm not sure why this was necessary.  \nhttps://github.com/bitovi/canjs/commit/f9896d928d7547b63d625eeae1badd22e3ab8068 introduced this line.\nCommenting these lines out fixes this issue and all other can tests still pass.  Will talk to @imjoshdean about this tomorrow and get a test in.\n. fixed by https://github.com/bitovi/canjs/commit/c0d15ec1edf7327a3ec53cc6787db98da823da2a\n. Caused by the same lines mentioned in my comment in #174.  Removing those lines fixes this issue as well.\nWill talk to Josh and get a test in for this tomorrow as well.\n. So it turns out there's no simple way to fix this without breaking a bunch of existing functionality.  The real issue is your original fiddle is depending on converters being called after attr, which merges the properties into the nested observe.  So your converter is called with the merged, nested observe.\nNow in latest CanJS, converters are called BEFORE saving the new properties, with the raw data and the oldVal.  Your code sees a raw object and instantiates the constructor, so it violates your assumption that you'll be passed an existing observe.  David's gist is a good workaround for this issue.\nThere may be a good way to solve this and not break all the existing functionality (which assumes convert will be called before .attr), but it would involve a rewrite of that section of _attrs.  We'll push this to 1.1.5 and revisit to see if there's a better way.\n. #266 actually does not close this issue.  The issue still remains because we're calling converters with the unmerged new data object (it used call converters with merged observe objects).  The workaround David posted still works, but this isn't fixed.\n. I like this request for a different reason, the fact that it makes helpers local vs global.  The fact that it follows handlebars semantics is icing on the cake and kills 2 birds with one stone.  I made the original API work as well (passing helpers in as the optional 3rd argument) for consistency with EJS.  I also added another test to prove that this removes the global helpers issue.\n. merged with master and added more tests in #260 \n. Why would you want that behavior at all from .attr?  You could accomplish this with splice.\nThe REAL real problem is a findOne is getting a big nested object that has arrays, then another call with the same property isn't replacing those arrays.  For example:\nMyModel.findOne(1) first response\njavascript\n{\n  arr: [\"a\", \"b\"]\n}\nMyModel.findOne(1) another response, after some data has changed\njavascript\n{\n  arr: [\"c\"]\n}\nAt this point, MyModel.store[1] contains:\njavascript\n{\n  arr: [\"c\", \"b\"]\n}\nThat's strange and not expected.  This is also what I was attempting to fix with #248 but thought this was a better, more downstream fix, so reverted it.  #248 doesn't actually cause a removal of the property, just replacing arrays like this.\nIf you don't think this is the right place for the fix, where should the fix go?\n. Right, but currently there's no easy way to actually accomplish not merging when doing a findOne or findAll request or even calling MyModel.model.   #248 was intended to let you do:\njavascript\nmodel: function(){\n  return this._super(this, attrs, true)\n}\nBut that's not all that clean either for what might be a common issue.  If you're saying we can't reverse default merging until 1.2, what's a good solution until then?\n. Also, this change doesn't break any tests, so if that's the current expectation, its not really documented anywhere, and I'm not sure anyone really knows or depends on that behavior.  \nI think it kinda does make sense to have different behavior for lists and objects in this case.  I'd expect a new list to replace the old one, but I'd expect properties of an object to merge into the old one.\n. yeah thats fine, sounds like a plan, thanks David\n. https://github.com/bitovi/canjs/commit/f9896d928d7547b63d625eeae1badd22e3ab8068  is where this went wrong.  After fixing the logic, the question is what to do about this case: \ncan.Model('NestedAttrTest.Task', {\n      attributes : {\n        owner : \"NestedAttrTest.User.model\"\n      }\n    }, {});\n    var michael = NestedAttrTest.User.model({ id : 17, name : 'Michael'});\n    var amy = NestedAttrTest.User.model({ id : 29, name : 'Amy'});\n    var task = NestedAttrTest.Task.model({\n      id : 1,\n      name : \"Do it!\",\n      owner : {id : 17}\n    });\n    task.attr({ owner : { id : 29, name : 'Amy'}});\nThe way its currently written, these owner attributes will be merged with what's currently in the owner observe.  This means the actual data in the model store is overwritten, including the id and name.\nIn this case we need to know about the fact that owner is a model instance and not overwrite.\n. The above commit gets all the issues Josh was trying to fix working, but avoids calling __convert too early.  I'm unsure if this is the right way to fix the above issue:\nif( canMakeObserve(curVal) && curVal instanceof can.Model && canMakeObserve(newVal) ) {\n  call _set\n}\nMy logic is if the curVal is a model and the new one looks like it should be data for this model, call _set to let the converter handle it.  I could probably come up with some situations where this wouldn't work, like when there is some very weird custom converter that isn't .model or .models on this instance and they want the data to be merged into the existing model.  Thoughts?\n. updated to not reference can.Model here: https://github.com/bitovi/canjs/commit/ae6b39c8dfe3af62e2e7d0e51ed7573032a0e698\n. https://github.com/bitovi/canjs/pull/266\n. @justinbmeyer I looked into this a bit and what you're saying: \n\nIt's my understanding now that converters are always called and if they are present whatever they return (observe or not) is what's set as the Observe's property.\n\nIs not the case.  We didn't implement that.  When you first set an attribute, it just calls _set, which turns it into an observe no matter what.\nI looked into if it would be easy to add this quickly.  The issue is if the attributes plugin is loaded, whether or not a certain property has a converter, this.__convert(prop, newVal) will return something.  We'd need to change that to return nothing if there's no attribute -> converter mapping present.\nNot sure if this will break other stuff.  I can dig a bit deeper if this is something we want to implement.\n. fixed now\n. Fixed.  Thanks for submitting.\n. Adding this as a plugin in builder.json so it will be in the download builder, but not part of core.\n. part of the fix for #289\n. This should also include map/setter and map/attributes.\nI added deprecation warnings to them in the map-define branch, but including here to remember to remove them in 2.2\n. will add this to the tests shortly\n. Added sort tests to the main tests.  @daffl are there any other steps I missed to add this plugin to the tests?\n. https://github.com/bitovi/canjs/commit/521576c8b582ea9eb3834fe1435db325cd1453cc is the commit that broke it\n. I agree that this is hard to understand and initially when reading the component implementation took a few readthroughs for me to pick up on.  There's 2 cases, passing a string in the attribute, and mapping a scope property from the parent scope.\nI agree with Josh in the sense that the @ syntax is what people would expect the normal case to be, not the exception.  And the case where we're passing data, we pass data everywhere else via {{ }}.\nStan proposed an alternate solution that removes the need for @, which is using a special attribute, like scope-myProp=\"selection\".  I still think I like Josh's first proposal better.\n. agree that its a breaking change, but would go well with the other breaking changes in 2.1.  Its something thats \"hard to explain\" and this proposal will simplify.  I think its worth it, even if its only in can.stash\n. I think it adds some consistency by requiring all usage of scope properties to be wrapped in {{}}.  \nFor example, what's the difference between class=\"{{foo}}\" and can-value=\"{{foo}}\" from a user's perspective.  They both bind a property of scope, but right now, they are written differently.  That difference is hard to explain/remember IMO\n. @justinbmeyer agree that changing the api for passing in scope to attributes would also require changing api for can-value and can-event.  Doesn't make sense to just change one without the other being consistent.\n. ok, but didn't you just say this would be 3.0 only?\n. or you mean if we do it stash-only, then its ok for 2.1?\n. I agree, so <myTag foo={bar}></myTag> is what we'll do.  I think Justin is working on this so assigning to him.\n. +1 looks like a good, clean API\nthere was overlap between setter and attributes, so this is clearer\n. As discussed in the hangout today, this will be added to can.List as well.\nAdding it here to make sure it doesn't get lost.\n. this has been merged into minor\n. @daffl does this cover the case where you have a big lazyList of objects, but you don't want those objects to be converted to lazyMaps (because nothing is listening to them)?\n. this is all in the docco branch, closing this\n. Isn't this the default behavior already?\nOn Sunday, April 6, 2014, Alexis Abril notifications@github.com wrote:\n\nCurrently keys: \"../\" and \".\" are allowed to look up a parent's scope or\ncurrent context, respectively. We don't have a key to specify looking up a\nproperty in the current scope.\n\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/issues/873\n.\n\n\nBrian Moschel[image: Bitovi]\nDevelopment | Training | Support\nBitovi.com http://www.bitovi.com/ | Twitter:\n@Bitovihttp://twitter.com/bitovi\n. merged and closed\n. @ekryski i was seeing the same problem last night with phantomjs timeouts unrelated to the branch i was working on, then it all passed in travis, so I think someone's going to have to dig and debug that soon\n. New docs should differentiate between how to do this in mustache vs stache too\n. related to https://github.com/bitovi/canjs/commit/3e04450607e81c085590c34fade36601f94843a3\n. This test will break with Uncaught RangeError: Maximum call stack size exceeded \n. We should merge this.  Any reason not to?\n. js\ncan.Model.extend('Book', {\n    findAll: 'GET /books',\n    model: function(attrs) {\n      attrs.title = Math.random();\n      return attrs;\n    }\n}, {\n});\nis the way to do this.  The fiddle works as expected, the second findAll finds the objects in the store and doesn't call setup/init again.  Closing because this isn't a bug\nWe do need better documentation around the model store, so I'll add another issue for that\n. If this idea gets traction, it might also be useful to create a non-live-binding iterator (a loop that doesn't bind on length) for the same reasons as above.  Something like:\njs\n{{#~each contacts}}{{~name}}{{/~each}}\n. After discussion in the weekly canjs meeting, closing this for now and making another issue to instead focus on benchmarking and improving performance in these critical paths.  There's a few areas we can definitely make major improvements before adding methods like this to the API.\n. I found this in another app.  After looking into it, the cause is because can.route is greedily matching slashes, and escaping the values.  For example, if you have a rule like can.route(\":page.html\") and a url like foo/bar.html, can.route.attr('page') will be \"foo/bar\" and that value will get escaped.\n. I'm going to see if we can prevent the pattern matcher from including slashes and not break any tests.  I'll make this a flag that defaults to on so people can turn it off if this breaks any existing expectations\n. doesn't this belong in the steal issues?\n. @daffl this is failing jshint:\n[L248:C17] W098: 'MapClass' is defined but never used.\n    var MapClass = can.Map.extend({\nIn this case, that's intended.  How can I ignore that for this test?\n. @daffl that test wouldn't work without a map definition\n@justinbmeyer lately we've been adding warnings for \"silent failure\" type things, like wrong property names in a mustache template. Most plugins don't fail silently, they define a function that gets called and user code throws an error without it, or something similar.  This fails silently.\nI added a better check, the problem was there is nothing special defined in the define plugin that could be inspected for feature detection code, so I changed the function stub.  Do you see any reason this could be bad?\n. did this off of minor, so closing it and opening another\n. I think there's something wrong with the build.  Its not failing locally in the same place, it just randomly timed out.  But it was also timing out when I ran it from master in another spot.\n. I don't think that failure is actually related to this commit.\n. It is another \"fails silently\" sort of issue, so maybe a warning would be useful too.\n. oops, that got escaped in my text, i meant render it like:\nhtml\n<list>{{name}}</list>\n. Its in mustache and stache actually\n. @justinbmeyer is this a bug? or expected?\n. Well, I agree with you for consistency, but its not implemented correctly for that to work since this logic is in Mustache.get and runs just when the template first renders, not on live binding property changes.\nBefore this change, it was throwing phantom warnings for any argument.  Fixing it to work for arguments seemed to take a little more time than I wanted to spend on it.\n. Also, we're not doing this at all for stache, just for mustache. Shouldn't we add the same warnings there for consistency?\n. justin doesn't want to merge this before number 3 is fixed from the list above\n. This is the same as #1041 but on master, not minor\n. fixed again, someone keeps reverting documentjs\n. @justinbmeyer do you mean \"I'm not saying it shouldn't\"?\nAlso, wouldn't that example initially set the value to an id, then later set it to the user object? That might cause some issues with the property taking on two different values\n. What is the downside of supporting this API?\n. number 1 works now, but the demo still doesn't work\n. @booc0mtaco could you have a look and try to fix it?\n. Hmm, is that a problem with other demos? Can you double check when fixing this?\n. I meant it should be called with a success handler (callback func) and error handler\n. related to #1182\n. Scratch that, the inverse tag isn't required, happens with any block tag too\n. I think I have seen this before, I'll take a look at this one.\nOn Thu, Jul 31, 2014 at 12:14 PM, Natallia notifications@github.com wrote:\n\nI am using Chrome and it the code is running within visualforce page. But\nthe page source is the sam e as\n<!DOCTYPE html>\n\n\ncan.route demo\n\n\n\n\n\n    $(function() {\n        var Routing = can.Control({\n            'route': function() {\n                console.log('route');\n            }\n        });\n        var routing = new Routing();\n        can.route.ready();\n    });\n\n\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bitovi/canjs/issues/1185#issuecomment-50789305.\n\n\nBrian Moschel[image: Bitovi]\nDevelopment | Training | Support\nBitovi.com http://www.bitovi.com/ | Twitter: @Bitovi\nhttp://twitter.com/bitovi\n. Tested with the following and it works fine, so this must have been fixed by something else since it was filed.\njs\nvar template = '<ul>{{#list}}<li class=\"report\"><span class=\"name\">{{name}}</span></li>{{/list}}</ul>';\nvar def = can.Deferred();\nvar list = new can.List(def);\nvar frag = can.stache(template)({\n    list: list\n});\nconsole.log(list);\nconsole.log(frag.childNodes[0].outerHTML);\ndef.resolve([{name: \"Brian\"}, {name: \"Ajax\"}])\nconsole.log(list);\nconsole.log(frag.childNodes[0].outerHTML)\n. @BigAB did you fix this directly in Master? We always fix stuff like that in a branch, add a test to prove its fixed, and only merge after someone has given it a +1.\n. Oh you did add a test :) But it went directly into master. Can you please close this if all tests are passing and the issue is fixed?\n. It appears that this works fine with latest master.\n. http://jsfiddle.net/c2242x20/1/\n. Closing because it doesn't seem like a bug. Let me know if you disagree.\n. Sorry, I should be more specific. Its not the helpers that need to be unbound. Its the event handlers associated with the helpers. In the example above, there will be a binding created like:\njs\ncan.route.bind('section', function(){ \n  // run isSection \n})\nThat live binding is never removed, because can.route never goes away.\n. Oh, so you had a can.Map that had an attribute called watch?\n. contact.attr('info') returns a can.Map\n. If you change your init method to the following, it works as expected:\njs\n    var template = $('#template').html()\n    var fragment = can.mustache(template)(options, {})\n    element.html(fragment)\n    console.log(element[0].innerHTML)\nRender will return a string representation of the template, but above returns a DOM fragment and renders it. Mustache is adding a placeholder for values that need to be live-bound to, which is replaced later by actual contents. I think calling .render will give the intermediate contents, not the replaced values.\nI'm not sure if that's actually expected or not. @daffl will have to weigh in on that part. But in your code sample, its more correct to do what is done above, not to call .render and insert a string into the element.\n. To be clear, I don't think this is a bug. It might be a case of needing better documentation around .render. @JustinLove maybe the render docs don't specify that this isn't the intended use?\n. @daffl can't we close this?\n. @daffl @julia-allyce is this not yet merged into the site because its waiting for the 2.2 release?\n. @julia-allyce next time if you say \"fixes bitovi/canjs.com#237\" or \"fixes #1672\" or whatever the issue number is, it will close the ticket automatically when the PR is merged into master.\n. Here's the breaking test:\n``` js\n        var MyMap = can.Map.extend({\n          define: {\n            fulfillmentType: {\n              get: function() {\n                return this.attr('ft');\n              },\n          set: function(newVal) {\n            this.attr('ft', newVal);\n            return newVal;\n          }\n        },\n\n        propA: {\n          get: function() {\n            return this.attr('fulfillmentType') == 'a';\n          }\n        },\n\n        propB: {\n          get: function() {\n            return this.attr('fulfillmentType') == 'b';\n          }\n        },\n\n        combined: {\n          get: function() {\n            return this.attr('propA') || this.attr('propB');\n          }\n        }\n      }\n    });\n\n    var map = new MyMap({ft: 'a'});\n\n    map.on('combined', function(){});\n    map.on('propA', function(){});\n    map.on('propB', function(){});\n\n    map.attr('fulfillmentType', 'b');\n    equal(map.attr('combined'), true);\n\n```\nThis seems very dependent on the order. If I change the order the properties are bound, it doesn't break. If I remove propA or propB altogether, it doesn't break.\n. Using git bisect was able to see that https://github.com/bitovi/canjs/commit/8826d1048d40021632494fffac16545d201487d6 is the commit where this problem was introduced\n. @alexisabril the new compute refactor stuff broke this. I could use your help or if @daffl or @justinbmeyer know this stuff, their help, figuring out why.\n. Here is the breaking test\n``` js\n    test('value and get', function(){\n        var MyMap = can.Map.extend({\n          define: {\n            list: {\n                Value: can.List\n            },\n            hasList: {\n                value: true,\n                get: function(){\n                  var list = this.attr('list');\n                  var length = list.attr('length');\n                  return length >= 1;\n                }\n            }\n          }\n        });\n    var map = new MyMap();\n    equal(map.attr('hasList'), false);\n\n});\n\n```\nAfter the breaking change, it seems to break because the getter for hasList is called when the map is created. \nBefore the breaking change, hasList would initialize using its value, and not call the getter until hasList was read in the next line.\n. This is the line that causes the premature call to the getter: https://github.com/bitovi/canjs/blob/master/compute/proto_compute.js#L335. Why is that needed?\n. putting a return on the this._set function here: https://github.com/bitovi/canjs/blob/master/compute/proto_compute.js#L466 will fix this test, but breaks another test in can/compute. Should _set be returning the value of lastSetValue.set(newVal)?\n. Is it expected that a can.Compute.async's function (the asyncComputer) should be called whenever there is a call to .get or .set? The docs make it seem like it should only be called for .get, but this test: https://github.com/bitovi/canjs/blob/master/compute/compute_test.js#L660 make it seem like it should be called for either. That is the only test that breaks when the above change is applied.\n. This is still failing but I'm not sure why, the travis logs don't say which tests failed\n. I feel like I've filed this and worked on it before. I don't remember what happened to it. I'll investigate.\n. The PR I was thinking of was https://github.com/bitovi/canjs/pull/1347\n. tests all passed locally, so maybe this is a fluke or a phantom only thing\n. @daffl what's holding this one up?\n. Added for route:\n\n. Added ATM example to the can.Map page and made it fit full column width:\n\n. @James0x57 is this script done? Can you point to where it is?\n. also fixes https://github.com/bitovi/canjs.com/issues/244\n. also fixes https://github.com/bitovi/canjs.com/issues/248\n. also fixes https://github.com/bitovi/canjs.com/issues/233\n. also fixes https://github.com/bitovi/canjs.com/issues/235\n. Test failure is unrelated, so merging\n. Same thing with this page: http://canjs.github.io/canjs/doc/can-connect/real-time/real-time.html\n. Same with this: http://canjs.github.io/canjs/doc/can-connect/fall-through-cache/fall-through-cache.html\nI think we can safely assume all can-connect demos are not working.\n. @BigAB Thanks, but I'm not ready yet for these images. This section is a WiP so it's premature to make the images. I think i'll make rough versions of them first myself before a designer works on these.\n. Please don't work on this yet\n. Please don't work on this yet.\n. Justin took over this page and I don't think he wants this image in there anymore, so i'll close it.\n. @justinbmeyer reopen if you still want this.\n. I like the tiled guides links, looks like something I want to click. Tom, please use use any other jsbin for the purpose of this design exercise, we'll replace it if we move forward with the option\n. looks good to me\n. looks good to me\n. Good docs, but might also want to mention the effect this has on arrays (causes them to be replaced instead of \"merged\").\nI can help with this.\n. @justinbmeyer ev no longer has stopImmediatePropagation because you changed ev to not be a jquery event object.  Should we convert ev into a jquery event before dispatching?  Or was this line no longer needed?\n. ",
    "amcdnl": "The following are completed with all tests passing on: /can/test/plugin_test.html\ncontruct/proxy,\ncontruct/super,\nobserve/attributes,\nobserve/delegate,\nobserve/setter,\nobserve/validations,\ncontrol/view,\ncontrol/route\n. Checked this out, seems like a legit issue.\nI created a failing test for it and pushed it ( https://github.com/jupiterjs/canjs/commit/d0cfc2de5cfa631d57621d09cece2c5b97877132 ) commented out for testing.\nI reviewed the lines @trickeyone was talking about and I can't determine what they are there for, @justinbmeyer @ralphholzmann  @moschel you guys have an idea?\n. @roissard Can you add a qunit test for this too?\n. @aloise Pretty sure this was fixed in this commit https://github.com/jupiterjs/canjs/commit/cded63e8ccbaf8336c1348b0462a56e85862634d\n. Does this happen in EJS too?\n. @whitecolor In your case you should just be able to do company.name and it should work.  Handlebars isn't a full implementation of Mustache so it doesn't support nesting contexts and context jumping like we do.\n@moschel Brians case is valid though because if your in a nested loop like that you need the ability to hop up the stack to the parent context.\n. Probably just needs tweaking to the regex.\n. +1 I think we should start this off as false too.\nIts a pretty common thing to need to do, shouldn't have to have the users doing it.\n. I'd like to vote this to go in 1.1.6 instead of 1.2\nWhile there is a work around for creating a variable in the local instance with EJS you would have to make a plugin helper to accomplish the same thing for Mustache making it very nasty to do this type of operation.\n. Thats fine ... The documentation eludes to that this is possible with this example in http://canjs.us/#why_canjs-flexibility.\n```\nvar person = new can.Observe({\n    name: { first: 'Justin', last: 'Meyer' },\n    hobbies: [ 'programming', 'party rocking' ]\n})\nperson.attr( 'name.first' ) //-> 'Justin'\nperson.attr( 'hobbies.0' ) //-> 'programming'\n```\n. @daffl Right on - makes sense ... although it makes it a pain to set nested properties but thats fine.\n. I like that ...\n. ",
    "ghost": "Looks the same way in Github. :) Looks like it's trying to interpret it as HTML.\n. Hi,\nIs there any solution to this problem? I have the latest version of canjs and the problem still seems to exist.\nHow should I change this code to make it work?\nmodel: function(attributes) {\n                   if (!attributes) {\n                        return;\n                    }\n                    if (typeof attributes.serialize === 'function') {\n                        attributes = attributes.serialize();\n                    }\n                    var id = attributes[this.id],\n                        model = (id || id === 0) && this.store[id] ?\n                            this.store[id].attr(attributes, this.removeAttr || false) : new this(attributes);\n                    if (can.Model._reqs) {\n                        this.store[attributes[this.id]] = model;\n                    }\n                    return model;\n                }\n. actually the problem is array attributes and the merging issue as ccummings said above. Normal attributes are updated correctly. Do you have any suggestion for that?\n. Yes, I have noticed afterwards that issue #257 is probably related. The workaround also worked for me, and then I can access the attributes using result.__get('key.1').\nA fix for this would be great.\nThank you\n. I'm not really sure, it is more related to view rather than a control.  I think the problem occurs when control element child nodes are removed multiple times. You can press the Reload button multiple times and see the result in the browser console - children array in __bindEvents will be growing.\n. Is there a reason that, by default, a single attr() on a Map, no matter the number of properties, would NOT fire just a single event?\n```\nmyMap.attr(param1: value1);\n// single change event\nmyMap.attr({\n  param1: value1\n});\n// single change event\nmyMap.attr({\n  param1: value1,\n  param2: value2,\n  param3: value3\n});\n// single change event\n```\nI feel like each should trigger a single event.  Possibly a toggle for that behavior?\nmyMap.attr({\n  param1: value1,\n  param2: value2,\n  param3: value3\n}, false);\n// multiple change events\n. Ok makes sense ... hmm ... a new method to do this, batchAttr()???\n. stache\nI seemed perhaps solve the issue.  Seems to work if I require 'can/view/stache'.  But, my 1st thought is that can/view would take care of that....\n. ",
    "WearyMonkey": "My current workaround, checking for recursion before triggering: c2a002a78214170ed27e1d2dad63fcbda6ba14c0\n. Likely related to issue #207 \n. By testing with the jsFiddles:\nFixed #207 and #208 but not #174 \n. ",
    "daffl": "I am closing this. The current structure makes a lot more sense when building the actual distributables and the problem in the forum seems to be solved, too.\n. Issue #59 is related to this as well.\n. Personally I really prefer deferreds. So would you pass a boolean to indicate that you want it executed asynchronously:\ncan.view('view.ejs', { feed : data }, true);\n?\n. Asynchronous can.view always returns a Deferred which resolves with the rendered document fragment:\ncan.view('view.ejs', data, function() {}).done(function(frag) { /* ... */ });\nUnfortunately at the moment the only way to force can.view to work asynchronously is to pass an empty callback as the third parameter.\nI think the question is to just get rid of any callbacks and just use Deferreds everywhere.\n. Can you try if running js can/util/make.js in the root directory still puts everything into can/dist with that change? If it does we can probably change it.\n. Ok, I think I fixed that issue with the build. Did you mean changing it to:\nsteal('can/util/object').then(function () {})\n. Fixed in #71\n. Will be addressed in #46\n. Currently points to the latest (11) and seems to be working.\n. Is this only for deferred.then? I think this is what's breaking the can/model: store ajax binding test, too.\n. I would like to close this issue. The suggested fix also works with the new tests and the updated sort plugin (which didn't really work as expected before anyway, see #170, #205 and #219). I recommend the fix as in the attached pull request without adding extra tests.\n. I think #114 should solve this issue\n. I hope. Let me know if it doesn't though (in case you are using CanJS master with Steal).\n. @daniel-franz If you are using these EJS helpers, it would be great if you could also add tests for them?\n. You say can.EJS.Helpers.prototype is not available otherwise? It should be defined in can/view/ejs/ejs.js and you can add helpers to it.\nIf you are not using any of these helpers I am actually debating if they can be removed from the repository. I am not aware of anybody using them at the moment and they are basically still a relic from the 1.5 and 2.x versions of JavaScriptMVC when it was a lot closer to Ruby on Rails.\n. The list extensions are still kind of proof-of conceptish. Glad that they work enough to be usable (still a bunch of todos like every, some etc.).\nReturning a new this.constructor() for the filtered list makes sense. Not sure how to solve the .map issue though. I think we can only safely use a plain Observe list. You might have to do any conversion in the event listeners.\n. @whitecolor I think that is what the issue is about.\nNow the problem is that Person.List currently, due to static inheritance, is exactly the same as can.Observe.List. It doesn't know about its parent Observe type. One option could be to add a default converter to each Observe construct and the ability to use that converter in Observe.List.\nIn the Person class the List static property would then point to an already subclassed list that uses the Person converter.\n. I was more thinking along the line of the object providing its own conversion and serialization methods so that you don't have to implement an additional wrapper:\n``` javascript\nreturn can.Construct({\n    convert : function() {\n},\nserialize : function() {\n\n}\n\n}, {});\nsteal('can/observe/attributes', 'items.js', function(Observe, Items){\n    return Observe({\n    attributes: {         \n        items: Items // Items is object not 'Items' string\n    }\n});\n```\nI think #106 is related to that as well (automatic conversion in Observe.List subclasses).\n. Hm, GitHub wasn't supposed to close the issue from a branch. \nAnyway, @whitecolor check out this branch. The attributes plugin lets you do things like this now:\n```\nvar Sword = can.Observe({\n    getPower : function() {\n        return this.attr('power') * 100;\n    }\n});\nvar Level = can.Observe({\n    getName : function() {\n        return 'Level: ' + this.attr('name');\n    }\n});\nvar Zelda = can.Observe({\n    attributes : {\n        sword : Sword,\n        levelsCompleted : Level.List\n    }\n},{});\nvar link = new Zelda({\n    sword : {\n        name : 'Wooden Sword',\n        power : 0.2\n    },\n    levelsCompleted : [\n        {id: 1, name: 'Aquamentus'},\n        {id: 2, name: 'Dodongo'}\n    ]\n});\n```\n. @hyusetiawan Unfortunately I can't reproduce it either. I created a JSFiddle with your code snippet at http://jsfiddle.net/LjU4A/1/ and it is working fine in IE 9 with version 1.0.7.\n. This problem still exists, first reported here for jQueryMX. Changing this line and quoting the source URL target seems to solve it:\nmyEval.call(out, 'this.fn = (function(_CONTEXT,_VIEW){' + out.out + '});\\r\\n//@ sourceURL=\"' + name + '.js\"');\nQuestion is if that still points to the correct URL? @justinbmeyer how would I test this best?\n. We wouldn't change the default behaviour. Since you can always implement your own create and update functionality, the question is, what Can should and could do to enable other datatypes.\n. This unfortunately doesn't seem to solve #267. Will investigate more in that issue but closing this PR.\n. After some haggling, I found out what the issue is. Basically, if there is an existing value already, the converter won't be called at all and instead it just sets the attributes of the existing value here. Additionally the list.attr() call won't convert the new raw data to into the correct type either.\nI think this could be elegantly fixed by implementing a solution for issue #107.\n. No it's in the issue_107 branch. Don't know why GitHub treated the commit messages as if they were on master. I also sent out an email about this last week asking for feedback. I was going to submit it as a pull request as well.\n. Oh I knew that it doesn't deal with the entire problem, but it was a better solution for now than having it broken.\nI created issue #117. Lets continue the discussion there. Copying jQuery.isPlainObject for any other library than jQuery or Zepto will probably be the way to go.\n. Ok, done. isPlainObject is being used now and supplied for the other supported libraries.\n. This is fixed in the current master and will be part of the next version. I will also try to get the build back up so that you can create your own version.\n. You are right. Seems like escaping does something weird here. Reopening.\n. Finally fixed it. It was name clash that replaced a regular expression with null in the actual build. Will merge and put into 1.1.4.\n. Maybe I can explain a little more:\nWe were discussing on IRC what would be a good way of allowing a fix for issue #122 but not breaking the old behaviour. Anthony suggested that plurarilising the event names might be a good way to go. So the example fiddle would work properly (firing for every change) when delegating on the changes event:\nobserveInstance.delegate('*', 'changes', function(ev, prop, oldVal, newVal){\n     $results.append('<p class=\"delegate\">DELEGATE got change: ' + prop + ' to ' + newVal + '</p>');\n});\n. Could we just do it similar to the AJAX method converters (where it converts { findAll : \"GET /todos\" } into a findAll method) and have the string be the data attribute:\ncan.Model({\n  models: 'recipes',\n  model: 'recipe'\n},{});\nWill assign a models function that uses the \"recipes\" as the data attribute.\n. @rajaravipati I'm not sure I understand your problem. This seems to be working:\n```\nvar Model = can.Model({});\nvar list = Model.models({\n    count : 1000,\n    data : [{ id : 1, name : 'first' }, { id : 2, name : 'second' }]\n});\nconsole.log(list.attr('count'));\nlist.bind('change', function() {\n    console.log(arguments);\n});\nlist.attr('count', 200);\n\u200b\n```\nFiddle\n. Ah got it! Problem is, that .models() will return a new model list every time you call it anyway. So what you were thinking of won't work.\nYou are right with the properties though. I think they should be added using .attr.\n. Nice. Thank you!\n. Awesome, thank you!\n. It should just be possible to apply the static setup again after you updated the prototype:\ncan.Control.setup.call(Tester)\nThis will remove all old actions and go through the current prototype again.\n. Cool. Closing this then if that works.\n. I totally should have added a test for the change I made there. Thanks!\n. Oh I forgot about NaN. Added that to the test as well.\nShouldn't can.esc(false) return \"false\"?\nIt currently returns an empty string for undefined, null and NaN.\n. Haven't forgotten about this. Put it on the roadmap for 1.2. It is not a major change to implement I think but I'd like to get actual bugs out first.\n. Thanks! Fixed it here. Really need to get everything linted.\n. Ok so version 1.1.1 comes with a whole bunch of AMD improvements:\n- Removed the reference to the global jQuery and used the module specific $ instead\n- Use mootools, yui, dojo and zepto so you can provide your own mappings (plus no version references)\n- No annoying mapping of can-library. Loads can/util.js by default which in turn loads can/util/jquery. Just map can/util.js to e.g. can/util/yui if you want to use one of the other libraries\n- Use the original Steal module return statements. So can/construct actually returns Construct so you can do define(['can/construct'], function(Construct) {});\nThanks for the feedback. Just open a new issue if you find any AMD related problems.\n. Thanks! Sorry I didn't get a chance to look into it yet. I remember that @dispatchrabbi, @imjoshdean and @ccummings added this special sequence for an IE bug. Could you guys have a quick look?\n. Yes, but the solution for EJS looked like this:\n<img <%= this.attr('image') ? \"src='\" + this.image + \"'\" : \"\" %> alt=\"An image\" />\nWhat I think should be the equivalent in Mustache doesn't work the same though:\n<img {{#image}}src=\"{{image}}\"{{/image}} alt=\"An image\" />\nShould we just add a special case for src attributes in the view renderer?\n. This was what this issue is about. @andykant combined several similar issues into this one.\n. Thanks! We really have to get full Linting in place.\n. Yes, this is because of the attributes plugin. When setting members, EmptyListTest.User.models will be called, which returns a new Observable list every time.\nI think we could change .models and the attributes plugin so that it removes all elements and adds the new ones if the current attribute is a can.Observe.List already. That should solve the problem right?\n. Ok, I pushed a fix. The attributes plugin now clears and updates an existing list, your test case is passing.\n. No, all good. Thank you!\n. Solved in #175.\n. @retro Published a n initial version of the generator. Could you follow up on this issue?\n. There are two CanJS generators available now so I don't think this issue needs to be kept open. Interested parties, feel free to contribute to:\n- generator-can\n- retro/generator-canjs\n. So what I read from that documentation is that the standard configuration will work (I got it working with Require and the AMD builds at least) but as soon as you add paths or mappings (like map can to js/can) it will not run any filename that ends with .js through the path/mappings right?\nThat should be easy to fix (the previous AMD builder removed the .js parts) as long as we have a way to map libraries (can/util.js -> can/util/jquery).\n. @saadtazi This won't work because mapping can/util to can/util/zepto will map any other module name like can/util/string to can/util/zepto/string which is not what we want.\nWe have a new AMD build ready that should solve the above issues. Hopefully it will be published with version 1.1.2 tomorrow.\n. I uploaded a 1.1.2 preview with the new builds. Maybe you can try it out and let me know if it solves the problem. Instead of can/util.js it now loads the can/util/library module which loads jQuery by default. Everything else is now using actual module ids (without the .js extension) as well.\nThis build is being used in the CanJS + RequireJS TodoMVC example and seems to work fine (but it doesn't need any mappings, either).\n. Yes. For e.g. Mootools you would do\nrequire.config({\n  map : {\n    '*' : {\n          \"can/util/library\" : \"can/util/mootools\"\n    }\n  },\n  paths: {    \n    \"mootools\" : \"path/to/mootools-amd.js\"\n  }\n});\n. We want to be able to use AMD + jQuery without having to map anything CanJS specific. can/util is not really used anymore. I will make sure that it just maps to to can/util/library as you suggested. If everything else works I will get 1.1.2 out later today.\n. 1.1.2 is out and it seems to solve all the AMD problems mentioned above. Closing.\n. Just to bump this up again, in current CanJS you should be able to compose the routes with any property like\ndestroy : \"DELETE /todos/{messageId}/{id}\"\nWith messageId being a property of your model. Is that what you need?\n. Then give it a try with the latest CanJS version. We can close the issue if this works right? If it doesn't please let us know and we'll fix it.\n. There is an upgrade path from JavaScriptMVC 3.2 to 3.3 which comes with CanJS. But if will require some changes if you want to do live-binding etc.\n. You are absolutely right. I could easily reproduce it in a test as well and will look into fixing it.\n. @imjoshdean That commit seems to be related to several bugs reported (namely #207 and #208). It would be great if we can figure out how this is supposed to work or fix it for 1.1.4.\n. Man this is a tough nut. I narrowed it down to __convert being called multiple times when the model is live bound. Still needs some more digigng though.\n. Closed via #266.\n. Thanks. This will also close #164. I'm wondering why this is necessary.\n. Seems to work fine. Anybody who is using Steal + 1.1.1 need to change their Mustache object reference but it solves the problem. Thanks again!\n. We should actually deprecate can.Control.view for 1.1.3. It doesn't work with anonymous Controls, is not very useful without Steal and stealing views with a renderer function should be the preferred way to load views with relative path names.\n. Closing this as can.Control.view is now deprecated and not included in any official builds anymore.\n. This sounds more like it should be a part of jQuery++. There already is a swipe and experimental tap event. \nBesides, any other gesture library that adds events to jQuery - like HammerJS - can be used in CanJS controls without problems:\n``` javascript\nvar Control = can.Control({\n    init : function() {\n       this.element.hammer({\n            // options...\n       })\n    },\ndoubletap : function(ev) {\n    console.log(ev);\n}\n\n});\nnew Control('#element');\n```\n. I think we can close this, Observable promises made it into 2.2.\n. That makes sense. I will mark it for 1.1.4.\n. When does this happen? If you could provide a breaking Fiddle it will probably be an easy fix.\n. I don't know, this:\n``` javascript\nvar todosDfd = Todo.findAll(),\n    userDfd = User.findOne( { id: 5 } ),\n    viewDfd = can.view('todos/todos.ejs', { \n        todos: todoDfd, \n        user: userDfd \n    }).then(function(frag, data){ \n        me.element.html(frag); \n        //myFunction(data.todo); \n    });\ncan.when (todosDfd, userDfd, viewDfd).then(function(todos, user, frag) {\n    // To stuff here\n});\n```\nis a pretty awkward contraption compared to\njavascript\ncan.view('todos/todos.ejs', { \n    todos: Todo.findAll(), \n    user: User.findOne( { id: 5 } ) \n}).then(function(frag, data){ \n    me.element.html(frag); \n    //myFunction(data.todo); \n});\nAnd all it takes to make that possible is to add the data as the second parameter when resolving the deferred.\n. Doesn't that defeat the purpose of being able to pass Deferreds when rendering a view? I do like the way Can handles Deferreds in an unobtrusive way and you don't have to worry about control flow (can.when, dfd.done, dfd.fail etc.) when there is no need to.\nAnd the only thing it took to allow accessing the resolved data was changing deferred.resolve(result); to deferred.resolve(result, data);.\nThe other changes were actually fixing an issue because can.view modified the original data:\n``` javascript\nvar viewData = {\n    todos : Todo.findAll()\n};\ncan.view('view.ejs', viewData).done(function(frag) {\n    viewData.todos // -> resolved data\n});\nviewData.todos // -> can.Deferred\n```\nI'm pretty sure that the original object shouldn't just change at some point in time (without even having a way of finding out when and how).\n. This is the test used for implementing the feature:\nhttps://github.com/bitovi/canjs/blob/master/view/view_test.js#L192\nIf you can provide a breaking test we can try and figure out why it isn't working.\n. True indeed. Unfortunately you can't just pipe deferreds that resolve with more than one argument.\nAnyway, can somebody please create a new issue for this (making the resolved data available when using can.view)?\n. The can.Model.models converter already does this: https://github.com/bitovi/canjs/blob/master/model/model.js#L734\nIf you would like it mentioned in the documentation you can submit a pull request with the updated documentation.\n. I think this one is a wrong branch, the correct pull request is #188 right?\n. I moved the description to the Third party extensions and plugins section. Thanks again for contributing!\n. The AMD build process is unfortunately not under CI. I also think it should only include official plugins (the ones listed on http://canjs.us/ and http://donejs.com/docs.html#!canjs) which I think it does (or did I miss something there?).\nWe would welcome any help to make more plugins official but they need to be fully tested, documented and added to the overview page before including them into any build.\n. You are right! Sorry, totally missed that one. If you could update your pull request (also add any others you might find) I will merge it. Version 1.1.3 is coming soon and I will include it.\n. Closed in #201\n. Thanks! Acessing can.$ is actually a good fix. Will be part of 1.1.3\n. This has been kicking for a while but I finally attached a pull request that allows to enforce the use of a certain view engine by passing an object with a url and engine property to can.view like this:\njs\ncan.view({\n  url: path,\n  engine: 'mustache'\n}, { message: 'Hi test' });\nIt doesn't break backwards compatibility and allows using a specific view engine for any URL.\n. It looks as if it is that special case when using a callback. When doing it synchronously it works as expected:\nhttp://jsfiddle.net/j9XSw/5/\nSo it is probably the fragment passed to the callback. We should probably get rid of callback and only use Deferreds but not for 1.1.x releases. Still investigating how to fix this best.\n. Thanks! This will be included in 1.1.3 which will be released shortly.\n. Sweet thanks!\n. That sort plugin needs some serious fixing up #170 and #88 are probably related as well and should be fixed all together.\n. Ok, there was indeed a bug with merging observes which got fixed in #221. I'm not sure if I understand this problem or the Fiddle right though.\nBasically we wanted converters to be a way to get around the automatic merging of Observables. But since you still get the old value passed you can use it in the converter. Here is the updated Fiddle which I think works the way you'd expect right?\n. That is true. I didn't know that this changed so much. Was that from 1.0 to 1.1? Basically the idea is that Observes will normally be merged and that converters are a way to prevent that if your converter returns a new Observe.\nDo your converters currently look as in the Fiddle example?\n. You are right, I did add passing the old value but not document it. Will do that, too.\nJust to make sure, it looks as if the original behaviour never really got tested right?\nOtherwise we would have had breaking tests. I will have a look at it again.\n. Closed with #266.\n. Also, instead of having to change all converters, you could probably just wrap them into a function that emulates the old behaviour:\n``` js\nvar _convert = function(converter) {\n    return function(data, oldVal) {\n        if(oldVal instanceof MyObserve) {\n            return converter.call(this, oldVal.attr(data));\n        }\n        return converter.call(this, data);\n    }\n}\nvar MyObserve = can.Observe({\n    attributes: {\n        nested: \"nested\"\n    },\n    convert: {\n        nested: _convert(function(data) {\n            return data instanceof MyObserve ? data : new MyObserve(data);\n        })\n    }\n},{\n```\nI made a demo Fiddle that shows that it works the expected way.\n. I think these are good suggestions and will mark it for 1.2. The problem is, that when changing the module return value all the code referencing that module (AMD or Steal) needs to be changed. We also need a way of documenting the module return values.\nAlso,  EJS and Mustache have to return then can Object because it is being used in pre-compiled scripts. I think we are going toward Mustache as the standard templating engine for 1.1. Mapping it like the CanJS library is a good idea.\n. For 1.2 I also want to remove the global can object if and AMD module loader is available (you can currently disable it with window.GLOBALCAN = false; but it hasn't really been tested yet.\n. I'd close this as a won't fix. We'll gladly help if you want to implement the wrapper yourself but looking at the adoption rates of the YUI and Mootools versions of CanJS I don't think it makes sense for us to implement another even less popular library (as good as it may be).\n. I think helpers have been added in aeb344870766a89608a3c680e4a1d04e2e4375d6. I do agree however, that it should use handlebars semantics. @moschel Input?\n. People! Talk to me :)\n. The Element.NativeEvents.hashchange = 2; one-liner still fixes it though right?\n. Yes I could confirm that. Looks like the route tests are not really testing routes with Mootools. We'll look into it.\n. Yes, I got it working that way in the mootools-routing-216 branch. Adding tests for it turned up that it doesn't work for Dojo and YUI either.\nOne problem is, that the _setup method is supposed to get called on document ready. Neither YUI, Dojo or Moootols seem to do that the same way as jQuery though.\n. Closed with #265\n. I tried looking at it but since you are the only one reporting that problem (update should always be defined) I don't think we can really do anything without a breaking example.\n. Closing this, I made a comment in #286. Unfortunately it is really hard to fix it as a bug without a small breaking test case but the comment handling fixes in the next release could be related and resolve your issue as well.\n. Cool thanks! It did come up more than once but every other time it was something in the code. It would be nice to find out what specifically could cause it though, even if it is just for providing a better error message.\n. Does that fix the other issue as well?\n. Thanks! I could confirm that it fixes #207 here but not #208. I'll try and wrap up that one and #174 in the attr-merge-207-208-174 branch.\n. Looks like there is by setting the defaultValue of the DOM element: Fiddle\n. Hm, the Control bindings for observes (what you show in the screenshot) have a different signature than if you bind directly using observe.bind, so the signature for can.route.bind is correct (I just tried it in a Fiddle).\nI have to admit that I'm often confused about the correct signature, too. Using things like event.target and event.currentTarget seems more straightforward to me than having to look up once again what exactly is being passed to the event handler.\n. Closing this. @juristr Please reopen if it doesn't answer your question or you think it needs further discussion.\n. Looks like a good fix to me. Could you provide a small test case that breaks in IE so that we can add it to our unit tests?\nOr, even better and which would get you in our list of heroes in no time, a pull request with the breaking test and the fix?\n. Allright I added the tests, pull request attached. Thanks again for reporting this!\n. I think this behaviour is according to the Mustache spec (Partials section) isn't it?\nI think the trick that Handlebars did was not to allow referencing anything up the stack unless you use backtracking paths. Support for backtracking has been filed in #163. I am not sure if Handlebars can backtrack up the stack in a partial though.\n. I think this behaviour is according to the Mustache spec (Partials section) isn't it?\nI think the trick that Handlebars did was not to allow referencing anything up the stack unless you use backtracking paths. Support for backtracking has been filed in #163. I am not sure if Handlebars can backtrack up the stack in a partial though.\n. Are you using the latest 1.1.3? I remember that a fix for something like this (can.view callback being piped in the Deferred) made it in there.\nIf you do, could you provide a Fiddle that demonstrates your issue? @@!!@@ is not the usual live-binding placeholder. I think it has something to do with binding tables.\n. Are you using the latest 1.1.3? I remember that a fix for something like this (can.view callback being piped in the Deferred) made it in there.\nIf you do, could you provide a Fiddle that demonstrates your issue? @@!!@@ is not the usual live-binding placeholder. I think it has something to do with binding tables.\n. Oh so that issue has been introduced after 1.1.3? Could you check if it has something to do with 0ddf3eae35d5c6f90f10da1e51af0f39b28ef64b?\nWe don't deploy an edge CanJS build at the moment, so pasting the breaking code here in the comments is fine.\n. Oh so that issue has been introduced after 1.1.3? Could you check if it has something to do with 0ddf3eae35d5c6f90f10da1e51af0f39b28ef64b?\nWe don't deploy an edge CanJS build at the moment, so pasting the breaking code here in the comments is fine.\n. Ok, I tried putting this into a test and either this issue is fixed in the latest master or I'm doing something wrong to reproduce it. Here is the tests code I am using which passes on the current master:\n``` javascript\nstop();\ncan.view.ejs('view_deferred', '<%= value %>');\nvar def = new can.Deferred();\nsetTimeout(function () {\n    def.resolve('Hello can');\n}, 1000);\n$('#qunit-test-area').append('')\ncan.view('view_deferred', {\n    value: def\n}, function (fragment) {\n    equal($('#out-cb').html(fragment).html(), 'Hello can', 'callback rendered content');\n}).then(function(fragment) {\n    equal($('#out-then').html(fragment).html(), 'Hello can', '.then rendered content');\n    start();\n});\n```\n. Ok, I tried putting this into a test and either this issue is fixed in the latest master or I'm doing something wrong to reproduce it. Here is the tests code I am using which passes on the current master:\n``` javascript\nstop();\ncan.view.ejs('view_deferred', '<%= value %>');\nvar def = new can.Deferred();\nsetTimeout(function () {\n    def.resolve('Hello can');\n}, 1000);\n$('#qunit-test-area').append('')\ncan.view('view_deferred', {\n    value: def\n}, function (fragment) {\n    equal($('#out-cb').html(fragment).html(), 'Hello can', 'callback rendered content');\n}).then(function(fragment) {\n    equal($('#out-then').html(fragment).html(), 'Hello can', '.then rendered content');\n    start();\n});\n``\n. As mentioned, I can't reproduce it on the current master (even with IE, what the!!@@!!placeholder is mainly used for). I will close this issue for now as I can't do much more without a breaking test. Feel free to reopen with a testcase like the one above that breaks on current master.\n. As mentioned, I can't reproduce it on the current master (even with IE, what the!!@@!!placeholder is mainly used for). I will close this issue for now as I can't do much more without a breaking test. Feel free to reopen with a testcase like the one above that breaks on current master.\n. This was done on purpose, initially to allow passing rendering functions allowing a view helper that can usecan.view` which is more powerful than Mustache partials.\nSince Handlebars works exactly the same way (functions passed to helpers won't be evaluated) and it isn't part of the official Mustache specification I would say this is the expected behaviour anyway.\n. This was done on purpose, initially to allow passing rendering functions allowing a view helper that can use can.view which is more powerful than Mustache partials.\nSince Handlebars works exactly the same way (functions passed to helpers won't be evaluated) and it isn't part of the official Mustache specification I would say this is the expected behaviour anyway.\n. Ah, I think I know where the inconsistency is. Handlebars doesn't evaluate functions at all when called with nested attributes.\nYour first example looks already different with Handlebars, see this Fiddle.\n. Ah, I think I know where the inconsistency is. Handlebars doesn't evaluate functions at all when called with nested attributes.\nYour first example looks already different with Handlebars, see this Fiddle.\n. Do you consider this something that needs to be fixed? In theory Handlebars templates are still compatible with can.Mustache in this case (just not the other way around).\n. Do you consider this something that needs to be fixed? In theory Handlebars templates are still compatible with can.Mustache in this case (just not the other way around).\n. I think we found a nice solution that still maintains Handlebars compatibility. We will continue passing functions to helpers but will make sure that they are always bound to their actual context. This should solve your issue and will also clear up a lot of confusion regarding the current context.\n. I think we found a nice solution that still maintains Handlebars compatibility. We will continue passing functions to helpers but will make sure that they are always bound to their actual context. This should solve your issue and will also clear up a lot of confusion regarding the current context.\n. Thanks. Fixed.\n. Thanks. Fixed.\n. Could you also post a quick example how the expected result should look like? If multiple tbody elements are valid the renderer might make a wrong assumption here.\n. Could you also post a quick example how the expected result should look like? If multiple tbody elements are valid the renderer might make a wrong assumption here.\n. Thanks for reporting this. I'm closing this as a duplicate of issue #157 though.\nThe issue comments contain a workaround, in your case:\n<img {{#userId}}src=\"//graph.facebook.com/{{.}}/picture?type=square\"{{/userId}}>\nThis also happens in EJS and we will look into fixing this very soon.\n. Thanks for reporting this. I'm closing this as a duplicate of issue #157 though.\nThe issue comments contain a workaround, in your case:\n<img {{#userId}}src=\"//graph.facebook.com/{{.}}/picture?type=square\"{{/userId}}>\nThis also happens in EJS and we will look into fixing this very soon.\n. Yes, CanJS currently doesn't work with jQuery 1.9. They've done some weird changes working with document fragments. We'll try and make it work with the 1.1.4 release.\n. Yes, CanJS currently doesn't work with jQuery 1.9. They've done some weird changes working with document fragments. We'll try and make it work with the 1.1.4 release.\n. Like I said in your forum post and demonstrated in this Fiddle, this is already implemented if you extend from MyItemClass.List.\nI will close this issue. Please reopen if this doesn't answer your question.\n. Like I said in your forum post and demonstrated in this Fiddle, this is already implemented if you extend from MyItemClass.List.\nI will close this issue. Please reopen if this doesn't answer your question.\n. I'll bump this to 1.1.5. Looks as if it needs some more investigation.\n. I'll bump this to 1.1.5. Looks as if it needs some more investigation.\n. Thanks @scorphus for investigating! I will bump this to 1.2 but as it looks right now we can only mention this in the documentation and leave as is right?\n. Thanks @scorphus for investigating! I will bump this to 1.2 but as it looks right now we can only mention this in the documentation and leave as is right?\n. This is the same issue as #153 right?\n. This is the same issue as #153 right?\n. Ok makes sense. Does the workaround mentioned there work for you for? We'll try our best making this fix a priority for Mustache in the 1.1.4 release.\n. Ok makes sense. Does the workaround mentioned there work for you for? We'll try our best making this fix a priority for Mustache in the 1.1.4 release.\n. Any news on this? Could you updated your branch and submit a new pull request targeted for the develop branch (1.2)?\n. Any news on this? Could you updated your branch and submit a new pull request targeted for the develop branch (1.2)?\n. Looks like a bug in .replace. Will mark it as a 1.1.4 fix.\n. Looks like a bug in .replace. Will mark it as a 1.1.4 fix.\n. Your Fiddle uses it in line 38. This is where I think the problem is.\n. Your Fiddle uses it in line 38. This is where I think the problem is.\n. Ok I see what you mean. Problem is, that this is how the model store works. If you explicitly set the attribute to null it does what you expect it to. I understand that this isn't always the expected behaviour and there is a flag in can.Observe.prototype.attr that allows to remove non-existent attributes. Overriding can.Model.model like this:\njavascript\ncan.Model.model = function( attributes ) {\n    if ( ! attributes ) {\n        return;\n    }\n    if ( attributes instanceof this ) {\n        attributes = attributes.serialize();\n    }\n    var id = attributes[ this.id ],\n        model = id && this.store[id] ? this.store[id].attr(attributes, true) : new this( attributes );\n    if(this._reqs){\n        this.store[attributes[this.id]] = model;\n    }\n    return model;\n}\nShould do the trick. Please give it a quick try for your problem. If that works I'd propose adding a static merge property to can.Model that allows to change the merging strategy.\n. Ok I see what you mean. Problem is, that this is how the model store works. If you explicitly set the attribute to null it does what you expect it to. I understand that this isn't always the expected behaviour and there is a flag in can.Observe.prototype.attr that allows to remove non-existent attributes. Overriding can.Model.model like this:\njavascript\ncan.Model.model = function( attributes ) {\n    if ( ! attributes ) {\n        return;\n    }\n    if ( attributes instanceof this ) {\n        attributes = attributes.serialize();\n    }\n    var id = attributes[ this.id ],\n        model = id && this.store[id] ? this.store[id].attr(attributes, true) : new this( attributes );\n    if(this._reqs){\n        this.store[attributes[this.id]] = model;\n    }\n    return model;\n}\nShould do the trick. Please give it a quick try for your problem. If that works I'd propose adding a static merge property to can.Model that allows to change the merging strategy.\n. The idea is: Models are uniquely identified by ID. So if you get model data with the same id Can assumes that it is the same model and will update the store. When your model data is live-bound (or listening to Observe changes any other way) somewhere (and models instances in the store always are, otherwise they will be removed from it) all your views and other listeners will be notified if the model is re-loaded from the server and attributes are updated. You also want all lists to remove a model if it is destroyed etc.\n. The idea is: Models are uniquely identified by ID. So if you get model data with the same id Can assumes that it is the same model and will update the store. When your model data is live-bound (or listening to Observe changes any other way) somewhere (and models instances in the store always are, otherwise they will be removed from it) all your views and other listeners will be notified if the model is re-loaded from the server and attributes are updated. You also want all lists to remove a model if it is destroyed etc.\n. This are actually two issues (part of which I think the http://jsfiddle.net/qYdwR/645/ Fiddle demonstrates):\nThe first one @moschel just addressed in #251: Nested arrays should never be merged. Otherwise you have weird things like this happening:\njavascript\nvar state = new can.Observe({\n  arr: [\"a\", \"b\"]\n});\nstate.attr({\n  arr: [\"c\"]\n});\n// state => {arr: [\"c\", \"b\"]}\nThe second one is, that can.Model.model doesn't offer an option to update the attributes of a model in the store with the removeAttr flag set to true. If your backend allows removing attributes this will cause problems like this:\n``` javascript\nvar MyModel = can.Model({}),\n    model = MyModel.model({\n        id: 0,\n        name: 'Test',\n        index: 1\n    });\n// After e.g. reloading\nmodel = MyModel.model({\n    id: 0,\n    name: 'Test'\n});\nmodel.attr('index') // -> still 1, but should be undefined\n```\nI think it would make sense to add a removeAttr flag or something to the static Model attributes in case the store attributes need to be merged with this.store[id].attr(attributes, true). The issue got addressed in #248 today but not with a can.Model property, just an additional parameter like can.Model.model(data, removeAttr).\n. This are actually two issues (part of which I think the http://jsfiddle.net/qYdwR/645/ Fiddle demonstrates):\nThe first one @moschel just addressed in #251: Nested arrays should never be merged. Otherwise you have weird things like this happening:\njavascript\nvar state = new can.Observe({\n  arr: [\"a\", \"b\"]\n});\nstate.attr({\n  arr: [\"c\"]\n});\n// state => {arr: [\"c\", \"b\"]}\nThe second one is, that can.Model.model doesn't offer an option to update the attributes of a model in the store with the removeAttr flag set to true. If your backend allows removing attributes this will cause problems like this:\n``` javascript\nvar MyModel = can.Model({}),\n    model = MyModel.model({\n        id: 0,\n        name: 'Test',\n        index: 1\n    });\n// After e.g. reloading\nmodel = MyModel.model({\n    id: 0,\n    name: 'Test'\n});\nmodel.attr('index') // -> still 1, but should be undefined\n```\nI think it would make sense to add a removeAttr flag or something to the static Model attributes in case the store attributes need to be merged with this.store[id].attr(attributes, true). The issue got addressed in #248 today but not with a can.Model property, just an additional parameter like can.Model.model(data, removeAttr).\n. Ok, as a non inversive fix for 1.1.4 I attached a pull request that adds a removeAttr flag which allows you to do something like:\njavascript\n  var Todo = can.Model({\n    findAll : 'GET /todos',\n    findOne : 'GET /todos/{id}',\n    create  : 'POST /todos',\n    update  : 'PUT /todos/{id}',\n    destroy : 'DELETE /todos/{id}',\n    removeAttr: true\n  }, {});\nWhich will cause any request and .model call on this Todo model to remove attributes that don't exist in the response instead of merging them.\n. Ok, as a non inversive fix for 1.1.4 I attached a pull request that adds a removeAttr flag which allows you to do something like:\njavascript\n  var Todo = can.Model({\n    findAll : 'GET /todos',\n    findOne : 'GET /todos/{id}',\n    create  : 'POST /todos',\n    update  : 'PUT /todos/{id}',\n    destroy : 'DELETE /todos/{id}',\n    removeAttr: true\n  }, {});\nWhich will cause any request and .model call on this Todo model to remove attributes that don't exist in the response instead of merging them.\n. Looks good, thank you. Could you add some tests for it or let me know if you would like me to add them?\n. Looks good, thank you. Could you add some tests for it or let me know if you would like me to add them?\n. You should be able to by following these steps:\n```\ngit clone https://github.com/bitovi/javascriptmvc.git\ncd javascriptmvc\ngit submodule update --init --recursive\nTo get everything up to date\ngit submodule foreach --recursive git pull origin master\n```\nThen edit the can/observe/attributes/attributes_test.js file (it is a QUnit test)\nwith your tests. To run the tests, visit the can/observe/attributes/qunit.html page in your browser.\nIf you want to use your own CanJS fork\n```\ncd can\ngit remote add fork git@github.com:JacopKane/canjs.git\nAnd later on\ngit push fork master\n```\nWhen you are done make also sure to open can/test/index.html which runs all CanJS tests with all\nlibraries and confirm that everything else is still passing. Hope that helps.\n. You should be able to by following these steps:\n```\ngit clone https://github.com/bitovi/javascriptmvc.git\ncd javascriptmvc\ngit submodule update --init --recursive\nTo get everything up to date\ngit submodule foreach --recursive git pull origin master\n```\nThen edit the can/observe/attributes/attributes_test.js file (it is a QUnit test)\nwith your tests. To run the tests, visit the can/observe/attributes/qunit.html page in your browser.\nIf you want to use your own CanJS fork\n```\ncd can\ngit remote add fork git@github.com:JacopKane/canjs.git\nAnd later on\ngit push fork master\n```\nWhen you are done make also sure to open can/test/index.html which runs all CanJS tests with all\nlibraries and confirm that everything else is still passing. Hope that helps.\n. I'll add the tests though. Just for future reference :)\n. I'll add the tests though. Just for future reference :)\n. Thanks again! Merged in and writing tests for it motivated me to actually add tests for the other default converters as well.\n. Thanks again! Merged in and writing tests for it motivated me to actually add tests for the other default converters as well.\n. Not every backend works this way though. In any schema-less database it is no problem to remove an attribute and you'll never know if it was there or not (and therefore can't really set it to null in response).\n. Not every backend works this way though. In any schema-less database it is no problem to remove an attribute and you'll never know if it was there or not (and therefore can't really set it to null in response).\n. Cool, thanks for the pull request. Hopefully we can make this plugin officially a part of 1.2. You definitely got it a step closer :)\n. @marshallswain: If you use it without any major problems, find a fix for the problem and would like to contribute documentation that would be greatly appreciated! Just create a pushstate.md in this folder with the docs.\n@talentedmrjones: Unfortunately there isn't any yet. The only way at the moment is referring to the demo.html for usage.\n. I'd agree with Brian here and I know that this caused confusion for others before as well.\nI just can't see a convincing enough case where you'd need to merge nested lists instead of replace them to make it the default. Merging would still be possible using a converter with the attributes plugin. Also, #208 might be related as well.\n. I think the problem can also be solved with the flag from pull request #245 (see this comment) and it is a smaller API change for the 1.1.4 release. Can we close this pull request and maybe go over this again for a later version?\n. Yes, I think a download branch with the built files would be a solution especially now that GitHub got rid of the download functionality anyway. The way you can currently get everything from Bower isn't very helpful anyway (because you can't even build without additional repositories).\n. The problem is that we can't just point to the main repository. We'd need some branch that includes all the build files (pretty much what's in the download). Is there a way to specifiy a branch for Bower?\n. There is a component.json in Can. But since Bower just copies the repository contents at the given version this will be pretty useless unless you are using Steal.\n. They are cheating. All the fancy stuff gets cloned from the components organization.\n. Ok, you can now\nbower install canjs\nWith the latest 1.1.4 version and you pretty much get the same content (different builds and AMD version) than in the download. Needs to update the repository and make updating it part of the deployment process.\n. For the 1.2 release we need to change the repository and make it part of the Grunt 0.4 build.\n. That's exactly what we should do. At the moment they just all come with the package (which doesn't matter too much if you aren't using them) but I'd really like to get all the plugins out of the main repository anyway.\n. Bower endpoint now fixed and correctly pointing to the new distributable repository so we can easily update it in the future.\n. Yep. And seeing the problem. Will fix for 1.1.5 which should be out around the middle/end of March.\n. Would this close #178 as well? Looks like it to me, but I am not sure.\n. Thanks. Marked for the next 1.1.5 release. I'm thinking one solution would be to not use dot separated accessors when you pass an object to .attr().\nThe problem would be that you couldn't do .attr('1.0') because it would try to get [1][0].\n. I think we'll have to bump this to 1.2 because any fix would entail a change it how it works. My suggestion:\n``` js\nvar ob = new can.Observe();\nob.attr('a.b', 'test');\nob.attr() // -> { a: { b: 'test' } }\nob.attr({\n    'a.b': 'test'\n});\nob.attr() // -> { 'a.b': 'test' }\nob.attr('a.b')\n// will look for 'a.b' first\n// and then for ob.attr('a').attr('b')\n```\nThat way it wouldn't break too much and still stay mostly backwards compatible. We still can't introduce it in a patch version though.\n. I'm assuming that helper should always have priority right?\n. I think it is the problem, that the route definition order for the can.Control.route plugin matters (which it shouldn't). This one works: http://jsfiddle.net/Daff/BaP5a/\n. :+1: - Finally fixed :) I guess we'll just close #208 then?\n. Deprecated with #266 merged.\n. :+1: Awesome that works for both cases! We can get 1.1.4 out today :)\nWe can close #264 now right?\n. Ah looks like it is because of the special handling for the length attribute (it doesn't bubble).\n@justinbmeyer What was the reason for that again?\n. Found it: This is exactly what the pull request #112 was about.\n. I think I'll just add tests to pull request #112 by @iamnoah and merge it in for 1.1.5 then.\n. Yeah, it shows where the error happens and it seems to work a lot better with the new scope. Closing this.\n. Does your pull request #272 solve this?\n. I would double check if this hasn't been fixed with #1187 yet which I merged yesterday.\n. Nervemind, that looks like it's something different.\n. Dist and Steal tests running, created #409\n. By default observe attributes are merged, also for arrays. We are thinking of changing the default for the next version but you can always pass true as the second argument for .attr like .attr(data, true) to prevent merging.\nSee the update Fiddle.\n. Got a chance to have a look at this and not seeing the problem:\n``` js\nvar MyObserve = can.Model({});\nvar testDate = (new Date()).toString();\nvar ob = new MyObserve({\n    created: testDate\n});\nequal(ob.attr('created'), testDate, 'Got expected attribute');\n```\nPasses as expected. Could you please create a Fiddle or example demonstrating your problem?\n. @adrianmaurer I really can't reproduce it. I will close this issue, but feel free to reopen with a breaking example.\n. Thank you. Fixed the name it will be available in the download builder for the next version. Hopefully we'll have the entire builder more reliable with things like that then, too.\n. No problem. Any pull request will be appreciated. If you are running into problems just ping us on GitHub or at #canjs in IRC.\n. Yes, I think it's a truthyness thing, too. Another question might be if empty strings should be truthy.\nShould {{#name}}Your name: {{.}}{{/name}} be evaluated if name is an empty string?\n. I like that idea!\nI'd still like to implement a test suite that specifically specs out what is expected from a wrapper. There are small differences between libraries that can break things in ways that are sometimes hard to debug (e.g. one thing I ran into is jQuery escape(null) returning an empty string where Mootools escape returns null).\nKeeping things working across libraries has two difficulties: New versions of the library (depends on the library though) and - of course - IE. We found that most of the library and browser compatibility issues came up with document fragment and DOM handling which is used for rendering EJS and Mustache.\nWould you be interested in collaborating extracting the wrappers into its own project?\n. There always needs to be one of the frameworks. We're hoping that a standalone version will be part of maybe CanJS 2.0. For a universal wrapper there should definitely be some kind of standalone implementations.\nHow do you think we should go about this? Use the CanJS library wrappers as a start?\n. Actually, I even think the branching function should be extensible. For example, for CanJS we need to check if the element is an observable list in which case the wrapper for .each needs to call .attr('length') in order to make things live-bindable.\nOverall, a great idea to standardize the library wrapeprs. I really like it. My questions to get started:\n- Should we create a universal.js repository on the Bitovi GitHub?\n- What is the best format to discuss the API? Options:\n  - GitHub issues\n  - GitHub wiki\n  - Google Document\n- Is it ok to use jQuery as a general reference point?\nAlso I agree that tests first would be the best approach.\n. Allright! Didn't forget about this. I created the Universal.js repository (we can decide later where it might live long-term - didn't want to create an organization just for one repository for now).\nLets take the discussion there :)\n. Looks good, thanks! Will merge it into 1.1.5.\n. Could you add tests or quickly create a Fiddle demonstrating the issue so that I can add them?\nThanks!\n. This also seems to be the problem mentioned in #218. I remember you found an issue in your code that triggered this error, but I wonder if we should merge this pull request anyway if we get a breaking test. It came up more than once already.\n. I'm reopening this to investigate more. This issue now came up more than once, I'm just still not sure why this is happening.\n. I tried again but could not find a small test case to reproduce. It seems this has something to do with #303 (or at least live-binding and comments) so it might already be fixed now.\n. @alexisabril Can we somehow have the builder run the normal build Grunt tasks but parameterized? That way it would include code formatting and strip out the multiline comments, too.\nTargeting for version 1.2 for now.\n. We're working on a new download builder that will include the header, clean up the code and also provide a minify option. Here is an example download how it will look: http://bitbuilder.herokuapp.com/can.custom.js?plugins=can/control&plugins=can/observe\n. Agreed. It originally was. Not sure why it got moved into can.Observe. Do the tests all still pass for you? Looks like the build is messed up but it doesn't seem to be because of your pull request.\n. :+1: \n. I have that functionality in the issue_107 branch. Here is the attributes plugin documentation. It also entails some other major observe changes though which is why it didn't get merged yet. I'd really like to see that in 1.2 though.\n. If you look at the roadmap you can see that it is planned for around the middle of May. We can't put something it into a patch version like 1.1.5 because it changes the API (even though it will probably be mostly backwards compatible).\n. I attached a pull request to this issue that will allow conversion like this (also for Maps/Observes):\n``` js\nvar Sword = can.Model.extend({\n  findAll: 'GET /swords'\n}, {\n  getPower: function() {\n    return this.attr('power') * 100;\n  }\n});\nvar Level = can.Model.extend({\n  findAll: 'GET /levels'\n}, {});\nvar Zelda = can.Model.extend({\n  attributes: {\n    sword: Sword,\n    levelsCompleted: Level\n  }\n},{});\nvar link = Zelda.model({\n  sword: {\n    name: 'Wooden Sword',\n    power: 0.2\n  },\n  levelsCompleted : [\n    {id: 1, name: 'Aquamentus'},\n    {id: 2, name: 'Dodongo'}\n  ]\n};\n```\nInstead of Item.List you can just pass Item and if the value is an array it will be automatically converted into a List (either using new Item.List or Item.models it Item is a model).\n. Sounds right. This plugin definitely needs some more love :(\nWould be great to be able to make it an official plugin.\n. Could it be that latest now (which is a 1.1.5-pre build) fixes the problem? At least I don't see an error but maybe I'm doing something wrong.\n. This is the same as issue #257. Maybe the workaround mentioned there works for you, too? A fix for this should definitely be part of 1.2\n. I found it way harder having to explain (and document) when to use can.route.ready and why it works in one case but doesn't in another. This comes up in IRC and Stackoverflow all the time and it just doesn't seem to work how many people (including myself) expect it to.\nPlus personally when I do things like:\n``` js\nvar Router = can.Control.extend({\n    ':type route': function() {\n        // do something\n    }\n});\nnew Router();\n```\nI always want my route to fire even when the page is refreshed and the router is initialized and for that there is no way around having to call can.route.ready (twice).\n. This was why I asked to submit the issue because only jQuery seems to support that (Moootols definitely doesn't) Which is why we think it makes sense to abstract global handlers in can.ajax (which is also a frequent question although easily resolve because most people are using jQuery).\n. Good point. I'll make a note for Universal.\n. Oh sweet! This is great! I will add a test and merge it in when it works.\n. One request: Would it be possible to disable the auto code formatting? It's kind of hard to tell what actually changed if the diff shows all the tabs and spaces that got modified. I'll run everything through a beautifier for 1.2 so that things will be more consistent.\n. Yes, sorry didn't have a chance to really look at this. Could you maybe also explain the reason for the string conversion a little more? I can see from the tests where this is going but am not sure why it would be necessary. Thanks!\n. Seems to be good now I think.\n. Looks like this works only really for jQuery. We should probably make this consistent for all libraries.\n. What if we make the Control itself an Observe?\n``` js\nvar MyControl = can.Control({\n    'li {activateEvent}': function() {\n}\n\n});\nvar control = new MyControl({\n    activateEvent: 'click'\n});\n// Sets the options and rebinds the evend handler\ncontrol.attr('activateEvent', 'mouseover');\n```\nI think that this could make templated event handlers a lot easier to understand.\n. Looks like the way can.Component currently works actually solves this problem. Hence closing.\n. :+1: - Looks good. Awesome job!\n. That's the curse of jQuery ;)\nWondering if this could somehow be combined with #193 (which makes a good point when requesting views without extensions)? \n. The build failed, I think in your new tests. Could you merge with latest master and re-run the full test suite (can/test/index.html) to verify? Thanks :)\n. You still need to call .attr('document', ...) at one point for it to create the setter method though. Personally I'd prefer a plugin that allows ES5 getter/setter so you can simply do observe.document = .... This won't work in IE < 9 however.\n. What I mean is that you can't simply do observe.setDocument() unless you tell the Observe at one point in time that there will be a document property (otherwise it can't create the setDocument method).\nAlso, did you have a look at the can.Observe.setter plugin yet?\n. Closing. I think until we have Object.observe available everywhere the way it is currently done works best.\n. I can confirm this, too.\n@thecountofzero Do you see this as well?\n. I'm moving this to 1.1.6 but https://github.com/bitovi/canjs/commit/f2ab4314c1fa23ff07cafdc989a6f932f98f761d might include a fix already. Not sure if this breaks other attributes serialization though.\n. We want to get it out in about a month. We can probably get the plugin out separately though. I made a can.observe.attributes.js Gist that includes the fix and it seems to work in the Fiddle\n. We'll get it working in less than a month :) If you want to try the fix and you are using Steal, just pull the latest CanJS repository and checkout the attributes-recursive-call-324 branch. If it works and it doesn't break anything else I can pull it into master right away.\n. Sweet. Does this work for you if I just merge it into master and you use that?\n. :+1: Thanks! That looks good. I think this can go into 1.1.5 for Sunday.\n. There is a forum discussion and you can try the implementation out in the canComponent branch.\n. Closing this as it has been merged into master yesterday. Release pending for next week.\n. It's basically just adding the if(key) statement right? If so, totally :+1: and good for 1.1.5.\n. Are AMD module ids relative to the current page or the current file?\n. I disagree especially since relative paths are common practise both in CommonJS and RequireJS. Module locations will still be immutable if you don't mess with the folder structure of the library (and I find the module name being the same as the folder name fairly intuitive).\nAs @rjgotten already pointed out, having to add that mapping is indeed unnecessary for RequireJS and with relative paths you could just do a clear and simple require('path/to/can'). You can always add a mapping if you get tired of typing things like path/to/can/view and path/to/can/control all the time but requiring a separate configuration to get it working at all is an avoidable barrier of entry.\nAdditionally path mappings are not part of most CommonJS module loaders (at least not in Node and Browserify/ComponentJS) so getting those to work will at best be annoying.\nI'm actually hoping to be able to make a CommonJS build because this would make generating AMD a lot easier as well because all you have to do is to wrap the generated CommonJS module into\njs\ndefine(function(require, module, exports) {\n});\n. A good example for relative module paths is jQuery which recently migrated to AMD (example: data.js). Also every NodeJS project (e.g. Express) does it.\nI still fail to see why using relative file names internally in CanJS (just like jQuery does it) would have any downsides. All your points were using and re-using the reference (require('can')), require('can/view') etc.) in a project which doesn't really have anything to do with how the library references its dependencies internally.\n. Just wondering, has this been fixed with the referenced pull requests?\n. The old model list .get and .remove allow you to get and remove a Model from the list by its id. We could add it to can.Observe.List to retrieve an observe by CID and override it for can.Model.List to do the same but by model id.\nWith the can/observe/elements and hopefully a stable version of can/observe/list (or whatever it will be named) we probably won't even need the can/model/list plugin anymore at all.\n. can.grep only works with jQuery. This is why the Travis CI build is failing in all other libraries. I'll have a look and see what would be the best way to split it up.\n. We were thinking of adding Lodash/Underscore methods to can.List in CanJS 3 and I think we did add other Array functionality already.\n. Does this work the same way as _.reduce?\nAnyway, I vote against making this part of CanJS for now as we should only include utility functions that we actually need for implementing any of the CanJS functionality (which isn't the case here).\nWe should however move the discussion into the Universal.js issues. I think it definitely has its place there and hopefully some time very soon CanJS will use it as the library independent wrapper (so download universal.js for your library and then just the standard CanJS build).\n. The can.makeArray fix? Yes I think that would definitely help.\nAs you saw, I started testing the wrappers but never really finished it and eventually broke it out into Universal.js.\n. I might be totally shooting the wrong way, but could we update the can.compute API to do something like this:\n``` js\nvar myObserve = new can.Observe({ myProp: 'test' });\n// compute for myProp:\nvar myObserveProp = can.compute(myObserve, 'myProp');\nvar myObject = { myProp: 'testing' };\n// cross bound compute for myProp\nvar myObjectProp = can.compute(myObject, 'changeEvent', 'myProp');\n// for the video\ncan.compute(el, 'timeupdate', 'currentTime');\nvar element = $('input');\n// Two way bound compute to an input element\nvar twoWayBound = can.compute(element[0], 'change', {\n    get: function() {\n        return element.val();\n    },\n    set: function(value) {\n        element.val(value);\n    }\n});\n``\n. This has been added in 1.1.5 because it wasn't possible to create attributes with dot separated keys before at all, see issues #257, #296 and the pull request #309. I think Justin is right, that when you are setting an object it should be what you actually want to set. This probably needs to be updated in the documentation.\n. If anybody thinks this need to be documented somehow please add it.\n. I can see that this might happen. If it is as easy as addingif(!this.element) return;` before https://github.com/bitovi/canjs/blob/master/control/control.js#L702 I don't see why it shouldn't be fixed.\n. I guess all we have to do to change this is turn it into\njs\neach(['bind', 'unbind', 'delegate', 'undelegate', 'attr', 'removeAttr'], function (name) {\n    can.route[name] = function () {\n        if(!can.isFunction(can.route.data[name])) {\n            return;\n        }\n        return can.route.data[name].apply(can.route.data, arguments)\n    }\n});\nUnfortunately we can't conditionally assign the function within the each loop because the delegate plugin might load after can.route has been loaded.\n. Closed via #373 \n. I think an update for that just got merged with #361 \n. Could #410 be related to this?\n. Closed via #1452\n. The problem is that the store update is based on the actual request counter (see here) which is not updated on a .model call and hence it creates a new Model every time.\n. That sounds good. This issue keeps coming (e.g. #218) up so fixing it would be very helpful.\n. Any idea why it didn't show the Travis CI build result at the merge button? Or did it?\n. Issue #366 is outlining the way this should work better now. Closing this as a duplicate.\n. True, that should not be converted. We'll fix it in the next release.\n. What actually would be really cool is if can.Observe realizes it is a Deferred, waits for it to complete and then sets the attribute with the result data. Not sure if that always applies though.\n. To clarify a little more: You will only have to npm install if you want to run command line tests or the build. To start developing and running the tests in the browser, just cloning the repository and opening test/index.html (ideally hosted on your local webserver) should be enough. You can try it out in the https://github.com/bitovi/canjs/tree/test branch. We want to merge it in hopefully this weekend.\n. Nice, thanks!\n. I haven't looked at it yet but would you mind sharing why you closed the issue?\n. I think I posted an example in your Stackoverflow question. It looks as exactly what happens. If you defer setting the hashchange it should fire as expected.\n. We probaby should have a general dev branch for the next minor/major version so that we can keep master at the patch level.\n. Could you verify this happening in all cases or just for cross domain requests as mentioned in #385? How did you implement findAll, update etc. in the cross domain case? Afaik, JSONP requests don't explicitly fail, you actually have to examine the response and fail the deferred yourself.\n. Allright, the findAll and findOne deferreds now reject when an exception gets thrown during .model or .models conversion and the default .models throws an error if it can't convert the data (i.e. the data is undefined).\n. This should be fixed with #384 as well.\n. I tried looking at this again but the demo page is gone. A minimal JSFiddle would indeed help. The above code is a little too big to easily narrow down the issue.\n. I'm going to close this. @wDevil could you please reopen with a working Fiddle if this is still an issue in 1.1.7?\n. It would be nice if at least our Deferred comply with the Promises/A+ spec.\nAs a side note, I also really like how RSVP.js does it by passing a function with resolve and reject callback to the constructor. No promise vs. deferred objects needed.\n. Good point. I created an issue in Universal.js and closing this one.\n. can.view signatures aren't right (e..g returns a renderer function when you only give it a template name).\n. Thanks for pointing that out. I updated the repository URL and the links should now work.\n. Where did that link come from? The CDN links from http://canjs.com/download.html should work.\n. Thanks! Actually loooks as if we forgot to include that in the build. I'll update it today.\n. Sorry it took so long. I updated the 1.1.6 release to include can/construct/proxy. If you used bower, run bower cache-clean to get the new tag (I know ideally that should've been a new release but a new release for one missing file seemed a little overkill).\n. I think the main issue that @jianlin was mentioning is that @EDGE didn't get replaced with the actual version in the release files (https://github.com/bitovi/canjs.com). I will update that as well as adding construct/proxy again. I also agree that we should have a clean Steal release in there as well.\n. Can you quickly merge latest master (which has CI fixed) into your feature branch and push to re-run the tests? Once they passed this is good to merge I think.\n. Sorry for sharing the private document. Here is the current list:\n- control\n  - /modifier/key\n    - Not enough documentation\n    - Only one test\n  - /view\n    - Deprecated\n- model\n  - /cached\n    - No docs\n    - Not working\n  - /list\n    - Contains lots of deprecated functionality\n    - see https://github.com/bitovi/canjs/issues/344, https://github.com/bitovi/canjs/pull/345\n  - /list/local\n    - Not working (uses $.Model)\n    - No docs\n  - /list/cookie\n    - Not working (uses $.Model)\n  - /local\n    - No docs\n    - No tests\n    - No nothing\n  - /service\n    - Not working (uses $.Model)\n    - No docs\n  - /store\n    - No docs\n- observe\n  - /elements\n    - No docs - deprecated \n  - /list\n    - No docs\n    - Not finished\n  - /sort\n    - Incomplete\n  - /transaction\n    - No docs\n    - Only basic tests\n      route\n  - /pushstate\n    - No docs\n    - Verify\n. This has been solved via #2337\n. Awesome thank you!\n. I think @schovi could chime in here because the #306 pull request feels very closely related to what you are suggesting (I think).\n. The placeholder {} should allow any model attribute. If it doesn't, could you make a quick Fiddle demonstrating what you are looking for?\n. I agree, it should allow all parameters.\n. Fixed with #492.\n. I indeed just tracked it down to the can.view.modifiers plugin. If you add it, everything works fine:\nhttp://jsfiddle.net/Daff/bYv8G/9/\n. So the reason why this works with the jQuery view modifier is that it overwrites .html, .append etc. and the logic does the conversion from an HTML string into a document fragment and then adds it. I recommend to use that plugin if that is the desired result (/cc @steeleprice - also let me know if that doesn't solve the problem). Closing this issue.\n. Thanks! You should be able to edit this guide in the Wiki (observes, routing). When we deploy the page again it should get updated. I'm also working on getting edit links on each page so that you can go there directly.\n. I'm still not sure how to solve this best. I wouldn't mind making it publicly editable (question is: how to do quality assurance before publishing it to the website?).\nWe were also thinking about simply moving the guides into the CanJS main repository where the API documentation is already coming from which can be edited using PRs.\n. After a discussion with @justinbmeyer I think we are just going to put the guides in the main repository so that they can be updated with a pull request.\n. Merged with #433\n. Should this also fix this issue reported in the forum? I think it does but could you maybe add a test for it?\n. I think that makes total sense. Lets get it into 1.1.7. Does this need a test?\n. Thanks for the update! I will check the fix and hopefully manage to write tests for all the issues. Lets hope it works for all cases :)\n. Can you try pulling from latest master and push again to re-run the tests? It should be fixed. Also, could you add tests for it? Thanks.\n. Those all seem to work in latest. @bmomberger-reciprocity could you verify at http://jsfiddle.net/Xp9K8/5/?\nI think the empty list ones are correct, too because {{#first_level}}{{#second_level}}Text: {{text}}{{/second_level}}{{/first_level}} and similar things will be empty for an empty list (second_level is undefined so the text block will never evaluate). All other cases are evaluating as expected.\n. Closing this for now for the 2.0.1 release. Please reopen if issues still persist in 2.0.1.\n. CanJS has been available on Bower for a while. You should be able to simply do bower install canjs and get the same content as in the zip file for every version.\n. We probably do need to add it more easily accessible in the docs but it definitely should show up in the public registry. Where did you look?\n. Attached PR that runs most test pages individually as well. Log output gets a little messy but not sure what to do about that. Also fixes most of the individual test pages since my IDE messed the paths up.\n. Thanks! These docs are definitely not up-to date. I will have a look at it today.\n. This was actually a bug which is fixed now with the attached pull request. Documentation has been updated as well.\n. That makes sense. Can you add a test and somehow reference the original issue (something like \"closes #444\" in the commit message should do it). Thanks.\n. :+1: - Woot!\n. Any news on this?\n. Added in the latest steal-build and bitovi-tools and will be part of the next release.\n. Closing this since the test already made it in (see https://github.com/bitovi/canjs/blob/master/map/attributes/attributes_test.js#L538).\n. Looks good to me. What was the case when this is happening? Should we add a test for it?\n. Ok. Merging this in since it doesn't seem to break any of the existing tests.\n. I think this is a precedence issue. The Mustache should look for Observe attributes first and look the property up directly only if it isn't found.\n/cc @justinbmeyer, @andykant \n. If you mean https://github.com/bitovi/canjs/blob/master/view/mustache/mustache.js#L1653, this is a common JS practise called early return. This avoids going through the whole loop because the function returns as soon as a matching helper has been found. I generally recommend using it. The easiest case looks like this:\n``` js\nfunction early(condition) {\n    if(condition) {\n        return 'true';\n    }\nreturn 'false';\n\n}\n``\n. Oh now I see what you mean! That looks pretty wrong ;)\n. Sorry, both versions are indeed a lot of code to review. If it is an actual bug in CanJS and not your code it should be possible to create a more refined breaking example.\n. Anything I'm missing here? Tests are failing and it can't be merged into master?\n. This is a JavaScript quirk becausetypeof new String('Bla') === 'object'andtypeof 'Bla' === 'string'. I'm not sure if we need to fix anything here...\n. The escaping behaviour should indeed be consistent. I will look into this and see what we can do. I concur with having helper be able to return HTML that doesn't need the triple braces.\n. I can confirm. @andykant Could you have a look at this?\n. I think we even might have enough bugs that are non-breaking to fix to get a 1.1.8 out next week if this is an easy fix. I can add a test.\n. Is this still something worth adding? If so it needs to be updated and merged with latest minor. Otherwise we should close the PR.\n. We can get that into 1.1.8 I do however still think that we never should callcan.route.readyautomatically for 1.2. There is so much confusion around when to use it and when not that it will be a lot easier to explain one way of doing things (if you want to start routing callcan.route.read(true)`).\n. Should this still go in or is this fixed? #470 is closed and 670cecb6e7de461ae047d86e7974ac9f03b1df62 adds a test but no fix.\n. There actually is an older issue #298 with a discussion and marked for 1.2 for this already.\n. Wouldn't this just be solvable by using the same stack?\n. I guess I can give it a shot, too if I have time.\n. Odd, now I'm not getting an error in the Fiddles. Could possibly be related with the fact that I forgot to update the release folder with 1.1.7 and only did it a week or two ago. Or am I missing something @thecountofzero?\n. I just tried that, too and it seems to work: http://jsfiddle.net/a2b3S/6/\nCould you maybe verify that it also destroys properly?\n. Is this fixed in 2.0.0-pre?\n. Closing this. Please reopen if it is still happening in the current release (2.0.2).\n. That was unfortunately unavoidable when switching to the new NodeJS build. The old build system had a weird exception for building the can.fixture distributables that I couldn't include.\nWhen adding //canjs.com/release/1.1.7/can.object.js it works: http://jsbin.com/IrOyimu/3/edit\nHope that helps and you don't mind if I close this.\n. The point of can.view is pretty much to create that renderer function. If you have the renderer already, why not just call\njs\nrecipesRenderer(Todo.findAll()).then(function(frag){\n     document.getElementById('recipes').appendChild(frag)\n });\nAlso how does your RequireJS plugin compile the views during optimization? We're still having trouble getting that to work because it expects a synchronous renderer and we were only able to do view compilation asynchronously.\n. You are right, this is definitely a bug that needs fixing. I created issue #486 for this.\n. As for the plugin, @alexisabril has been working on require-ejs and I think we did something similar to compile the views. So I guess we'd only need to somehow officially provide a non-DOM dependent wrapper. Would be great if you could share your work so we can figure out the best solution for this.\n. This is not uncommon, see jQuery, where $().attr('attribute') returns the attribute value and $().attr('attribute', value) sets the value and returns the jQuery element.\nThe return value for can.view() and how to use it is also documented pretty extensively. In the future we might revisit how this works (see #64) and generally make sure return values are consistent but I don't consider this an issue at the moment.\n. Ah, sorry just saw the conversation in #483. Reopening this issue so we can revisit this.\n. That is a good point and seeing as this doesn't work as I though it did, your suggested fix makes sense and would probably make less of an impact on the API. I was just thinking that renderer functions should work the same way as a can.view call. We will definitely get that into the next release.\n. Thanks for reporting. Fixed via #498 and will land in the next release.\n. I think this has been answered in the forum.\n. Awesome. So from what I understand, you are saying that the changes here were al that was necessary for you to provide synchronous view compilation? Have to try that out.\n. We'd definitely want to get this working with version 2.1 most likely in combination with can-compile. @isadovskiy's approach is a great starting point for that.\nView compilation should probably run in a separate VM so that there won't be a problem with conflicting mappings.\n. This looks good, thanks! I actually ran into this a little while ago, too. Looks like the build got stuck. I'll re-run it and it should pass.\n. I think I will bring it in, as it solves #428 as well. I think using the model attributes is the most common case. I would argue that you could just implement your own .destroy to make it possible to pass additional parameters.\n. This does seem to make sense but a lot of the tests are failing now.\n. Travis should be running against the head. I will merge it in locally and see what is happening. Would it be possible to scale the Fiddle down a bit so that I can turn it into an easy test to add for the issue that your change is fixing?\nThanks\n. I'm fixing this in another pull request. But has that event issue ever been dealt with? If our own stuff already breaks I am very opposed to changing this in a patch version.\n. Changing the event system only fixed a rather minor bug and to speed things up. It's hard to believe that nobody will use something like ev.stopImmediatePropagation(); in their own CanJS based projects which will break when upgrading a patch version.\n. I think I got that wrong anyway. Looks like we're still dispatching jQuery events in a control so it's just the can.Map event system right?\n. I can work on that. We should just remove all those checked in libraries and use Bower for different dependencies. That will get our Codeclimate up quite a bit, too.\n. I'm pretty positive NPM doesn't have packaged versions for jQuery, QUnit or Zepto (at least properly maintained). And since NPM expects a package.json and CommonJS modules you can't just pull the repositories in (which would be nice in our case). Bower seems like the best choice (although it seems to be missing packages for proper Mootools, YUI and Dojo versions).\n. This has been fixed with #531 and will be released with 2.0.1 tomorrow.\n. Making synchronous calls is not ideal and will block the browser. Using async: true is deprecated since jQuery 1.8. You should store the Deferred and wait for your call to resolve asynchronously:\n``` js\n//Control\nSampleViewControl = can.Control({\n    init: function () {\n        var self = this;\n    this.options.sampleView.data.then(function(data) {\n        // Do stuff here\n    });\n}\n\n});\n//View Construct\nSampleViewConstruct = can.Construct({sampleViewData: {},\n    init: function () {\n        this.data = $.sampleAjax('data/sample.json', {}, false, 'json', this.sampleView_success, this);\n    }\n});\n//instantiation\nvar sampleViewControl = new SampleViewControl(' ', {\n    sampleView: new SampleViewConstruct()\n});\n``\n. I don't think this is the same issue. In our case{{text}}is evaluated and then the value tried to run as a helper. Or istextalso a helper?\n. A string value in your view data should never be interpreted as a keyword for anything.\n. Test?\n. It is unfortunately not documented yet, but you can use thecan.Map.Listplugin from the official download which does add live boundmapandfilterfunctionality. It provides live bound\n- **filtered** lists: When a filtered attribute changes, the filtered list will be updated\n- **mapped** lists: When a item is removed/added to the original list, the mapped list will be updated\n. The plugin name is definitely not chosen very well. For 2.1 I want to finish the documentation and probably rename it.\n. This looks pretty good. I always felt there is some weirdness going on in our routing. E.g. withcan.route('test/:id')andcan.route('other/:id')what happens if I docan.route.attr('id', 1234)?\nI think it should actually becan.route.attr('test/:id', { id: 123 })`. This looks like a good step in the right direction.\n. Can we fix this one? I would like to get it into 2.0.3.\n. This has been fixed in 2.1.4 via #1338, something like\n``` js\nvar Person = can.Construct.extend({\n  get age() {\n    return 42;\n  },\nset name(value) {\n    this._name = value;\n  },\nget name() {\n    return this._name;\n  }\n});\n```\nIs now tested and working.\n. Defaults should only work with the attributes plugin anwyay. I'll look into why it isn't updating that properly.\n. We should document that ;)\n. Looks like this has been fixed via https://github.com/bitovi/canjs/commit/9c6a55a8a68a8b8e443b1b154e9609ee9688b078\n. Looks like the test is passing?\n. Nervemind, the map tests weren't included. Added them in #567.\n. Where is the inserted event being tested?\n. Fixed via #574\n. Closing this via #596. We can add a 2.1 issue to support can.route.root().\n. Fixed via #576\n. Just verified, this doesn't work in 2.0.0 either. Hopefully we can fix this for 2.0.4.\n. Are we still going to add this to 2.1? Explicitly passing the property like\nhtml\n<test_component notyetset=\"notyetset\"></test_component>\nGets the Fiddle to work in 2.0.5: http://jsfiddle.net/VRE8Z/5/\n. Sweet! Ran into that yesterday myself, thanks for the fix!\n. Wouldn't that just be an unused variable? Anyway, I started working on stricter JSHint rule verification that should catch anything like this. Lots to do though ;)\nThanks though, merging.\n. I thought the Fiddle illustrates the issue. As far as I can tell it doesn't really matter how the component gets the map (pre-initialized, as a plain object on the prototype or set as .attr in the inserted event)..\n. What's the verdict on this one?\n. I don't remember putting it in 2.1, 2.0.4 is fine I think as long as we have some tests.\n. I'm going to bump this to the next version. Removing more code than adding it is a good thing but we need to make sure that it doesn't break anything by adding more tests.\n. I think the only reason why the tests break is because array-like objects should be actual arrays. Did we ever add a test for #476?\n. This seems like a problem how renderer functions are inserted. If you call the renderer function returned by can.view.mustache(\"<dummy-tag></dummy-tag>\") right away with the scope it will only insert once.\n. Could that be the view modifiers plugin? Why is the renderer function in this.element.append(can.view.mustache(\"<dummy-tag></dummy-tag>\")); executed at all?\n. As @ccummings said\njs\n$('body').append(can.stache('<x-app/>'));\nNeeds to be\njs\n$('body').append(can.stache('<x-app/>')());\n// Or more readable\nvar renderer = can.stache('<x-app/>');\n$('body').append(renderer());\nThere is nothing we can do about this as that is just how jQuery works.\n. I can't find a reference for that use of trailing slashes in the HTTP spec. Do you have a link?\nAll that I can see is that a trailing slash should denote a folder on the webserver which doesn't really apply to pushstate. Escaping route/ to route%2F is a little weird but if you find this happened you could still just redirect to route.\n. Ah nice. I think can.remove should work for all libraries.\n. Awesome, thank you for catching that!\n. Could this be fixed via #604?\n. Almost missed this one. Thanks! I think this works until we add can.route.root() (probably in 2.1).\n. Merged into master. Recommending to remove node_modules and reinstall to get everything up to date.\n. Note: When fixing this we can also update https://github.com/bitovi/canjs/blob/master/component/component.js#L64\n. I submitted a fix for the issue. However I also had to change some of the other tests because they were assuming that normal text would be returned instead of a document fragment. For that reason I will bump this to 2.1. From experience we can generally say, that if the tests already assume things working a certain way, other users will do so as well.\n. Closing PR. Targetting for minor branch.\n. Why a new PR? #614 was up to date, too?\n. Yes, that looks right, although, because it is a somewhat standard call you could also use findAll: 'GET /api.php'. This should be described at length in the can.Model guide and the API documentation.\nThe best places to ask those questions is the forum or on IRC in #canjs. Closing this as an issue.\n. Closing and adding PR to #611\n. Closing and adding PR to #607\n. Hey @andykant can you merge this branch with latest master? Looks like one of the other PRs caused a conflict.\nAlso, there wasn't a test for this specific issue before. Looks like this case never got really tested before.\n. Looks like this has been solved in the forum discussion.\n. @andykant Can you merge this one with latest master, too? Thanks.\n. I think this should be fixed at least in 2.0.5 because we changed the check to return this.xyz; which shouldn't be stripped out by any minification engine.\n. Fixed via #874\n. Yes Travis and therefore grunt test are running tests on the standalone and AMD builds. You can run them in the browser by going to test/amd/index.html (which only works after running grunt build).\nYour test just needs to be conditional:\njs\nif(window.require) {\n  test('test baseUrl', function() {\n    require.config({ baseUrl: 'bla/ });\n    // Do tests here\n  });\n}\n. Does this mean this is a non-issue?\n. @justinbmeyer Can you sanity check this? Looks good to merge to me but I haven't worked with the pushstate implementation a lot.\n. What's the error message? And can we call it first and second instead of FooBar?\n. Fair enough. Thanks for updating. Merging into 2.0.5\n. I'm going to close this since it has been inactive for a while and nobody else was looking for similar functionality.\n. Test?\n. A pull request adding this would definitely be appreciated. It keeps coming up but nothing in this direction has been implemented yet.\nI'm thinking of simply adding a baseUrl static property that will be added to findAll etc. created with a string. The problem is that it will be useless if you implement it with your own function (well unless you read it manually but that might just be something that needs to be documented).\n. Closed via #657\n. Really, if you can escape the . then something like test.attr('my.item'); should only work for { my: { item: value } } and never for { 'my.item': value } (which should be test.attr('my\\.item');).\n. That's why I reopened. It's really inconsistent. And broken for falsy values.\n. This actually looks pretty good for 2.0.5 and doesn't seem to interfere with anything else.\n/cc @justinbmeyer, @thecountofzero\n. Cool, thank you! I think we can get this in 2.1 (there were some other AMD related changes that were suggested as well). It would be nice if we could also run the tests with GLOBALCAN disabled to see if anything fails.\n. We ran deAMDify on it once but there were some issues. Not sure if writing a CommonJS converter currently would be easy to do.\n. We can probably do it the same way the current AMDify does it and just output it into a commonjs folder in dist/. So a wrapper like:\njs\ndefine([\"can/util/library\", \"can/map\"], function (can, Map) {\n});\nWould just become:\njs\nvar can = require(\"can/util/library\");\nvar Map = require(\"can/map\");\nI think one of the problems we would run into though might be that Browserify doesn't support path mappings and that our paths aren't relative to the current file (which they totally should be, especially to also make #338 work). If we change that and register the canjs.com repository as an NPM module, I think it could work.\n. self.element.html('todos.ejs', new Todo.List({}) ) works only with the jQuery modifiers plugin and therefore indeed shouldn't be shown in the can.Control documentation. I bet this is a remainder from JMVC 3.2 where it was included by default.\n. Closed via #746\n. Closed via #1016 \n. What happens if you just use\njs\n$(element).html(can.view(\"comp/home/home.html\", {}));\nThis could have been introduced because of #647\n. So #718 adds documentation for this. If anybody thinks it is inadequate please reopen this issue.\n. Here is an updated example that works: http://jsfiddle.net/R5Vbw/2/\nThe reason is that if Mustache doesn't find it on the current object it walk up to the parent and tries to look it up there.\nThis is however an issue that we are hoping to solve in 2.1 (probably by prefixing with ./ if you want to prevent the scope lookup).\n. I couldn't find one that's why I left this one open.\n. Fixed via #874\n. Sounds good. I thought there might be a better way. This only affects test files that are using Steal anyway.\n. The key modifier plugin is still somewhat unofficial, I am not sure if it will make it as an official CanJS plugin. I think this is a good usecase for jQuery++ jQuery.event.key though. That way in an event handler you can check if(ev.keyName() === '\\r') {} and similar things.\n. It's been kind of flaky lately. Btw, is this a 2.0.6 or 2.1 feature?\n. I noticed this, too and this should probably be a JSHint exception. I wanted to write a test, do you have a quick example for what is failing?\n. Thanks! Fixed.\n. Actually it doesn't work for any directly nested block statement.\n. Isn't the Fiddle clear?\n. Looks like the dist build tests are failing. The restarted build failed at the same spot so it might be an actual issue to look into.\n. Build passed now. Pulling latest minor in should also fix a Steal loading race condition which might have been the cause for the builds stalling occasionally.\n. Closed via #868.\n. Had to add it in manually but we can close this PR.\n. If you pre-initialize the list with the size like new can.List(5) it works: http://jsfiddle.net/aVLUV/2/\n. We could add that, but he can.Map.setter documentation also already says:\n\nThe attr function looks for a setATTRNAME function to handle setting the ATTRNAME property.\n\nMaybe that can be more clear but that means that .attr('message', 'text') will be looking for a .setMessage method when using the plugin (hence the recursion in your example).\n. Can you try team.attr('players.0').attr({});?\n. I just verified that\njs\nteam.attr('players').push({});\nteam.attr('players.0').attr({});\nconsole.log(team.players[0] instanceof Player); // true\nWorks. So if you are modifying an existing attribute individually it should do what you expect.\nWe noticed some list.attr() inconsistencies though and will be looking into those.\n. Closed via #857\n. Awesome, thank you!\n. Migrated to canjs.com #182\n. Btw, this should be fixed now.\n. Makes sense. The easiest way would probably be to change it to:\nfunction (fn, time, context) {\n  var timeout;\n  return function () {\n    var args = arguments;\n    clearTimeout(timeout);\n    timeout = setTimeout(can.proxy(function () {\n      fn.apply(this, args);\n    }, context || this), time);\n  };\n}\n. That sounds like a fantastic plan :+1:\nWe just need to figure out how frequently to run those (nightly builds?) running all browsers with every build will make them take forever.\n. What operating system are you using?\n. From what I could find out so far, PhantomJS (which doesn't need to be installed btw, grunt-qunit uses the NPM package) runs a little slower on Windows.\nI got the tests to start by setting the timeout in https://github.com/bitovi/canjs/blob/master/Gruntfile.js#L218 higher (to e.g. 60000):\n\nBut now it sometimes hangs when running a different test. This might be solved when migrating from the Grunt QUnit task to Testee which I am planning to do (it didn't stall when I tried it at least).\nI will look into it some more but if it keeps stalling for you, too, to develop CanJS and write tests, the workaround would be just running grunt build and then run all the test files (test/index.html and maybe test/dist/jquery.html) in the browser and let Travis do the automated testing when making a pull request.\n. The forum is definitely the best place for discussions like this.\n. Can you link to the part of the documentation? From what I can see it says:\n\nAll event handlers bound with Control are unbound when the control is destroyed (or its element is removed).\n\n$().empty() does not remove the element however (controls inside the element will be destroyed though). You will have to .destroy() the control manually or override .empty() to destroy all controls attached to the element.\n. What browser? The Fiddle works without errors in Firefox and Chrome for me.\n. Ah got it. For me it says can not read property isComputed of undefined.\n. It looks like it doesn't run the change even when you give it something that is already a Map. If you serialize the Player first by changing\njs\nthis.options.team.attr('selectedPlayer', player);\nto\njs\nthis.options.team.attr('selectedPlayer', player.attr());\nit works.\n. For a basic support it would probably make sense to get and set the innerHTML on blur.\n. Closed via #821 \n. Wouldn't it work already by storing the different response functions and setting them back?\n``` js\nvar repsonseA = function(){ ... CODE A ... };\nvar responseB = function(){ ... CODE B ... };\ncan.fixture(\"services/thing\", responseA);\n// In a test\ncan.fixture(\"services/thing\", responseB);\n// run test\nTEST\n// restore old fixture\ncan.fixture(\"services/thing\", responseA);\n```\n. What's a good test to add for this?\n. It would break Mustache compatibility but since Stache is a new feature for 2.1 it would be ok. I personally like the syntax proposed by Josh because it removes a level of indirection while being more explicit.\nThe issue I'm still having with HTML based views is that templating logic needs to be thrown into the attributes (or special tags) somewhere. Angulars syntax is valid HTML but you have to do things that look like\njs\n<ul>\n  <li ng-repeat=\"todo in todos | filter:statusFilter track by $index\" ng-class=\"{completed: todo.completed, editing: todo == editedTodo}\">...</li>\n</ul>\nvs\njs\n{{#each displayList}}\n<ul>\n  <li class=\"todo{{#if complete}} completed{{/if}}{{#if editing}} editing{{/if}}\">...</li>\n</ul>\n{{/each}}\nin CanJS. I know we are all biased but the Angular example isn't understandable with \"just knowing HTML\" at all (which I assume should be the ideal solution for HTML based views).\n. It might be slightly harder to parse but why not call it like any other Handlebars helper?\nhtml\n<div can-click=\"{{removeFrom parent child}}\"></div>\n. This is fixed in the latest build. Getting 2.0.7 out now.\n. So if I got it right, returning a document fragment should be the expected behavior for can.view.preload which worked in 2.0.6 but the issue says that:\n\nIn 2.1, the rendering function returns a string, instead.\n\nWouldn't it be correct to return a document fragment?\n. Yep, I would like to merge it. @justinbmeyer any comments or concerns?\n. Closed via https://github.com/bitovi/canjs.com/issues/175\n. This has been fixed via #1454\n. No. @justinbmeyer is also implementing a better bubbling system so how this works might change a little soon anyway. I'm still not sure I fully understand the usecase. If nothing is listening, why have an observable list at all? Why not just implement an array-like construct that emits the events needed?\n. Closed via #868.\n. Closing as it is already included in #868\n. Now part of #868 (https://github.com/bitovi/canjs/pull/868/files#diff-725dbcbaabd381b25dda55cbf8d2f2deR1)\n. Part of #868 (https://github.com/bitovi/canjs/pull/868/files#diff-ccdc4ea4955883c8e65eac47a211c7f6R1).\n. Part of #868 (https://github.com/bitovi/canjs/pull/868/files#diff-ae63af94064db872a476d2a9387bad17L1)\n. This does not seem to be part of the Docco branch in #868.\n. Closed via #878\n. Part of #868 (https://github.com/bitovi/canjs/pull/868/files#diff-a4dd03963cc21be2b389b68ca71d6b91L1)\n. Closed via #868 (https://github.com/bitovi/canjs/pull/868/files#diff-532d6324975f398d1901af12e9086953R16).\n. Now part of #868 (https://github.com/bitovi/canjs/pull/868/files#diff-2f6cbfeb36062a73fce53f760ef4a1d4R1)\n. Walking up the scope is an important part of can.Component (and part of the Mustache spec I believe). Otherwise you couldn't do things like:\njs\n{{#each todos}}\n<li>{{description}} <a href=\"#\" can-click=\"deleteTodo\">X</a></li>\n{{/each}}\nWith deleteTodo being a method on your components scope. I wonder how hard it would be to add this.<some property> as an alias for ./ though...\n. Also closes #645 and #723\n. We should document that somewhere.\n. Just one question, could all those separate markdown files go into a single .md file? Or did that mess DocumentJS up?\n. Resubmitted as #1436\n. Closed via #1425\n. So to me tests are the only place where I think repeating yourself is ok. I find a global search & replace in this case easier than sifting through obscure test helpers.\n. I was thinking of just creating a \"Promises\" page (in the Pages section at http://canjs.com/docs/can.stache.html) that talks about how to use it.\n. Should be closed via #1140.\n. This should be in https://github.com/canjs/can-animate now right?\n. This fix has been merged via #1251. Thanks!\n. @justinbmeyer Is there a pull request for getting the stache perf branch into 2.1.2?\n. Closed through the commits in #1048\n. Maybe as a dev warning? Most DOM libraries don't error either when unbinding something that didn't have any events.\n. This is still a rather large example. Does this also fail when just creating a select field from a list of items and listening to that? What happens when listening to <select can-change=\"updateReason\"> instead of clicks on the option?\n. Closed via #1045\n. It seems that I can only reproduce this issue in jsFiddle. With an HTML page like this:\n``` html\n<!DOCTYPE html>\n\n\ncan.route demo\n\n\ncan.route\n\n\n\n\n    $(function() {\n        var Routing = can.Control({\n            'route': function() {\n                console.log('route', arguments)\n                // Matches every routing change, but gets passed no data.\n            }\n        });\n\n        can.route.bind('change', function(ev, attr, how, newVal, oldVal) {\n            console.log('manual bind', arguments)\n        });\n\n\n        var routing = new Routing();\n        can.route.ready();\n    });\n\n\n\n```\nI only see the event fired once, as expected.\n. Moving this to 2.2 for additional documentation. The fix already made it into 2.1.2 (or 2.1.3) and we are currently not documenting any of those can.route properties (like querySeparator or paramsMatcher).\n. This has been implemented in 2.2, closing this PR.\n. Can we change those code blocks to use indentation (like in #1036) as well?\n. Needs latest master merged in.\n. Maybe we can still change the flags from\njs\n@codestart\nvar Person = can.Map.extend({\n    fullName: function(){\n        return this.attr(\"first\") + \" \" + this.attr(\"last\")\n    }\n})\nvar me = new Person({first: \"Justin\", last: \"Meyer\"})\n@codeend\nTo tab or space indentation for this PR\njs\n    var Person = can.Map.extend({\n        fullName: function(){\n            return this.attr(\"first\") + \" \" + this.attr(\"last\")\n        }\n    })\n    var me = new Person({first: \"Justin\", last: \"Meyer\"})\n. @booc0mtaco I think we should use actual markdown and not clutter it with custom tags. @param directives are a convention from documenting code and not part of any Markdown specification.\nFor the future I'd also like DocumentJS to also parse the YAML frontmatter for markdown files instead of having to add things like the @page and @parent tokens.\n. Closed via #1055 \n. Why not take it out? The test should still do what it is supposed to without the var MapClass.\n. Closed via #1053\n. To bad it's a regression, we really should encourage hyphenated tag names.\n. This is fixed in version 2.1.4 via #1325 (Fiddle seems to be working now)\n. Are you sure those are related? #1063 is in Mustache and this appears only in Stache.\n. This bug already causes simple things like\nhtml\n<h2 class=\"{{#if shown}}foo{{/if}} test1 {{#shown}}muh{{/shown}}\"></h2>\n<h3 class=\"{{#if shown}}bar{{/if}} test2 {{#shown}}kuh{{/shown}}\"></h3>\n<h4 class=\"{{#if shown}}baz{{/if}} test3 {{#shown}}boom{{/shown}}\"></h4>\nTo fail, filling in the wrong subsections due to evaluator caching in https://github.com/bitovi/canjs/blob/master/view/stache/mustache_core.js#L419 (as pointed out in the Todo the line before).\nI recommend removing the caching - unless @justinbmeyer has another idea - since subsections are almost always different (except for the visual benchmark). It will slow the visual benchmark performance down from ~3.9ms to ~7.6ms.\n. Closing this one and open a new pul request with a new rebased and merged branch.\n. Nevermind, those changes apparently already made it in through the commits in #1048.\n. Closed via #1429\n. Just pass an object which will automatically be the options passed to findAll:\njs\nnew Foo.List({}); // Will do Foo.findAll()\n. Yes: http://canjs.com/docs/can.stache.helpers.index.html\n\n. I'd agree with @ccummings on this. There is a difference between \"We forgot to document it\" and \"It is an undocumented API\" and I'm pretty sure that for something as exposed as the event API the former is the case. What would be the problem with adding it back in?\n. I just realized that we actually can cache normal property lookups (that don't have the mode set). Fixes the test and keeps the spinning circle performance the same as before.\n. Wait, shouldn't that be\njs\nBar.findOne({ Id: 0 });\nanyway? I believe it should use the actual id property for the parameters (it does that when not using the resource property as well).\n. This changed from 2.0 to 2.1. Closing this issue as it can be fixed by setting it as a property instead of a value compute as discussed.\n. Ok. Reopening and putting it int 2.1.3.\n. Is this still an issue @justinbmeyer?\n. Looks like this is fixed in the current documentation (see link).\n. This is a big diff but it looks like when merging master into this branch that the changes are already in. Could you quickly verify those changes are in the current master already?\n. I thought so. Ok closing this one then, thanks!\n. You should be able to access the property using \\ before the .:\njs\nmap.attr(\"some-very'strange\\.name\") // can't access it, will throw\nHere is a Fiddle: http://jsfiddle.net/s7cq8/\nWe'll definitely have to add this to the documentation. I thought it was but I couldn't find it anywhere.\n. This has been added in 2.3 (but is already deprecated in favour of the routeCurrent and routeUrl helpers).\n. Thanks for all those fixes Josh!\n. Closed via #1135\n. I think we can move this discussion into https://github.com/canjs/can-validate\n. This will be fixed via #1454 in 2.2.\n. Closing this as a duplicate of #1287 which already made it into 2.1.4.\n. This seems to now be a duplicate of #1287. Closing.\n. Closed via #1453. Will merge into master shortly.\n. @ccummings Done. This is needed in several projects and a must if you want to use Bootstrap markup.\n. @matthewp is this relevant for latest minor? If so can you fix and resubmit?\n. This is fixed in latest minor.\n. I don't think so. If both are block level elements they will just be parsed in the order they're defined. But parsing <a><div></div></a> as <a></a><div></div> is most definitely wrong in HTML 5.\n. Closed via #1180\n. Can you maybe update the others, too?\n. Assuming that this is for manually retrieving and calling helpers it looks ok I'll just have to add tests for it.\n. Yes, merge the the remote branch in and make sure tests pass. Then we can merge this PR and then yours. Also, we probably want this for Stacheh as well?\n. Closing and resubmitting against minor.\n. This is similar to #1161 and #1134. The parser won't let you put block level elements within inline elements. We already changed this for links, I'm wondering if we should just turn that off completely since HTML5 seems to allow it in any case I tested.\n. I agree. This doesn't break any other libraries where passing event arguments isn't possible anyway and it fixes an actual issue. Will go into 2.2, thanks!\n. Maybe separate services might provide a better decoupling than mixins. It can potentially be hard to figure out what has been mixed in and effectively the Person model is still coupled to how it connects. I don't think it would make too much of a difference except for that you have a separate service object:\n``` js\nvar Person = can.Map.extend({ ... });\n// Hook up custom connector\nvar userService = can.connect({\n  findAll: function(params) {\n    return new Promise(); // ...\n  },\nfindOne: function(id) {\n    return new Promise(); // ...\n  }\n}, Person);\n// Hook up via REST API\nvar userService = can.connect(can.connect.rest('/users'), Person);\n// Hook up via Feathers\nvar userService = can.connect(can.connect.feathers('/users'), Person);\nuserService.findOne(10).then(function(person) {\n  console.log(person instanceof Person);\n});\nuserService.findAll().then(function(people) {\n  console.log('Found ' + people.length + ' users');\n});\nuserService.on('created', function(person) {\n  console.log('Someone created a new user', person);\n});\n``\n. The service would be coupled toPersonbut it would separate data accessing logic from thePerson` map (plus you can create a service without a Map to mix it into). With a mixin everything would still be smushed together in the end (as @matthewp pointed out this can make it hard to know what is actually happening). Also, as @Tarabyte mentioned this also makes things easier to mock and test.\nEven with services introduced as a new concept this can still be API backwards compatible because the service basically is the same thing as the mixin object. Simplified something like:\n```\ncan.extend(Person, userService);\nPerson.findAll();\n```\nWould then provide the same API as can.Model.\n. This is available in https://github.com/canjs/can-connect\n. Verified to be breaking on IE 11. Also with 2.1.2.\n. That fix makes sense. The weird thing is why this isn't happening in any other browsers (we are running the distributable and all plugins against Phantom at the least).\n. There is no 2.1 branch. Are you having issues upgrading to 2.2?\n. This still seems controversial. I'd be ok with changing it to node_modules/.bin/bower because that will definitely always be there.\n. Oh yes indeed, it has been removed from minor. Closing this PR then.\n. This also should be fixed in version 2.1.4 via #1325\n. This can be solved with the define plugin by setting { type: 'compute' }\n. Yeah, that's what I'm wondering, too. Still think this is a bug. this.attr(\"files.length\") is what I tried and it really should work.\n. This is in the works. We actually do have a Browserstack account. We'll use the new Testee which supports Browserstack out of the box as the test runner. One thing to figure out would be when to run the full test suite though. On pull requests we'd only want Phantom + maybe code coverage otherwise it would take forever.\nLeaving this issue open since I didn't make one.\n. Yeah. Maybe the full browser matrxi nightly once a day on master and minor if new PRs have been merged?\n. This should also be fixed via #1325.\n. In minor (and the 2.3 I'm just wrapping up) you can find it here: https://github.com/bitovi/canjs/blob/master/compute/proto_compute.js and as can.Compute.\n. The suggested fix makes sense. I am not sure what the desired behavior for multiselects is though.\n. This has been fixed via #1454\n. Can you push to this branch again to re-trigger a build? Looks like it worked fine for #1269.\n. I think we can close this one since we have the new sort plugin in 2.2.\n. We are purposely stopped doing this so that you can install CanJS via NPM without grabbing all the Bower dependencies.\n. Are you sure or is that a setting in your global .bowerrc?\n. It also looks like it is a regression. When I tested it, things worked in 2.1.3.\n. Did you check out master or a different branch?\n. Wondering when that happened. I don't think that problem occurs in the 2.1.3 build which was built the same way.\n. I just verified that with the new build system in 2.2 (which is now in master) dev code does get removed properly. 2.2 is about to land within the next two weeks.\n. This makes sense, we probably also want to add this in Stache (and have tests for it as well).\nI remember @imjoshdean working on a debug helper as well but I can't seem to find it anywhere?\n. There unfortunately seem to be a bunch of conflicts with some of the changes we recently made. Good catch with using _setupDefaults though. I submitted a separate PR (#1457) with using those (I'm kind of hesitant renaming it even if it is technically a \"private\" method).\n. This works fine for me in Firefox (32) without the setTimeout and fixes every other browser (where it is currently breaking).\n. Merging this since we won't need it with the new Steal which is going to be used by the next version.\n. Tests failed, JSHint.\n. Just one question, then we can merge it in.\n. Closes #1108. Looks good, :+1: from me.\n@justinbmeyer  any concerns about this?\n. This has been added via https://github.com/bitovi/canjs/commit/e5518b18b319c9487bb2998c4ad85b70522ed23d\n. This should be fixed with 2.1.4 for good.\n. #1336 has a fix which allows setting properties on the scope. The test referenced here needs to be slightly changed and now looks like this:\n``` js\ntest(\"Compute set prior to being read\", function(){\n  var scope = new can.view.Scope({\n    name: \"Matthew\"\n  });\nscope.attr(\"name\", \"Wilbur\");\nequal(scope.attr(\"name\"), \"Wilbur\", \"Value updated\");\n});\n```\nThis also works for computes and nested maps.\n. Closed via #1336\n. Can you rebase with minor and fix the test?\n. Will be renamed to viewModel via #1512.\n. That looks like minor with new Steal right?\n. Thank you! I think #1272 and #1246 are related. I will add some tests and verify that this closes it.\n. #1297 and this are two separate issues actually.\n. Stache does not use eval so the solution would be to switch to the Stache plugin (which we can't officially do until CanJS 3.0).\n. Could it be that you are still accidentally importing Mustache?\n. Yes, what I mean is implementing your own can.js wrapper that does not include Mustache (and then alias that to can/can.js):\njs\nsteal('can/util', 'can/control/route', 'can/model', \n    'can/view/stache', 'can/component', function(can) {\n    return can;\n});\nThat should then not include scanner.js.\n. That sounds like a separate issue and is probably easiest to debug with a a breaking app. I am not aware of that being a problem so it might just be a configuration issue.\n. Thanks! This has been merged into minor (2.2) via #1329.\n. Oh yes, it is indeed. It should probably use the default view engine but passing a renderer function should fix the problem.\n. Update test to use can.compute.read directly.\n. This has been merged into minor.\n. Still looking into ways to making it faster. They are taking quite a while but at least we can use it now.\n. It is for being able to run the tests on canjs.com. We should probably just add the bower_components to the repository.\n. This has been fixed. Test pages now look like https://github.com/bitovi/canjs/blob/master/component/test.html using steal-qunit. We just have to make sure that we add those to the GitHub pages otherwise the tests won't run online.\n. This seems to be fixed in minor.\n. Thanks! We can fix it but a pull request is also very welcome. You should be able to edit the page directly https://github.com/bitovi/canjs/blob/master/guides/recipes.md which will automatically submit a pull request.\n. This is failing and I'm getting the same error for #1350 with this error, too:\n\nNot Found: http://localhost:8081/test/builders/steal-tools/stache.js\n. I re-submitted this against master in #1495. Apparently I fail at rebasing to I'll just merge into master and then update minor with it.\n. This can be done in 2.3.0 with the new view bindings (http://canjs.com/2.3-pre/docs/can.view.bindings.html)\n. Here is another one: https://www.youtube.com/watch?v=ZO1BSnIFNRI with https://github.com/feathersjs/canjs-feathers\n. You could use a compute for the SockJS counter and pass it as mycounter to your component:\n\nhtml\n<script type=\"text/mustache\" id=\"app-template\">\n<sock-app mycount=\"{counter}\">\n    <h3 can-click=\"increment\">No way {{mycount}} {{name}}</h3>\n</sock-app>\n</script>\n``` js\n$(function() {\n  var CounterMap = can.Map.extend({\n      name: \"wish\",\n      mycount: 0,\n      increment: function(){\n          this.attr('mycount', this.attr('mycount') + 1);\n      }\n  });\nvar CounterComponent = can.Component.extend({\n      tag: 'sock-app',\n      scope: CounterMap\n  })\nvar counter = can.compute(0);\n  var SOCK = new SockJS(\"http://localhost:9090/sockjs/canjs\");\n  SOCK.onopen = function(){\n      console.log(\"working\");\n  }\nSOCK.onmessage = function(message){\n      counter(counter() + 1);\n  }\n$(\"#graph-app\").html(can.view('app-template', {\n    counter: counter\n  }));\n})\n``\n. This didn't turn out to be as effective as expected. On average waiting for several Travis VMs takes more time than running everything in series. Maybe different with a paid account.\n. No but this is not how you pass values to components. The documentation for{{key}}` says:\n\nInsert the value of the key into the output of the template.\n\nWhy they evaluate differently I don't know (isChecked might evaluate to the string true and pass that one to the component - @justinbmeyer might be able to shed some light on this) but it almost certainly does not do what it is supposed to (passing the value to the component). I think I already mentioned that the correct way to pass values to the component in Mustache is to use\n$('body').append(can.mustache('<my-comp value=\"done\" checked=\"done\" is-checked=\"done\"></my-comp>')(map));\nAnd in Stache\n$('body').append(can.mustache('<my-comp value=\"{done}\" checked=\"{done}\" is-checked=\"{done}\"></my-comp>')(map));\nSee Fiddle\n. Ok I think I understood this wrong then. If I take the component out and we get this Fiddle http://jsfiddle.net/xKc3H/585/, we currently get\n<div value=\"__!!__\" checked=\"__!!__\" is-checked=\"true\">Mee!</div>\nWhich indeed doesn't look right.\n. Looks good. Do we need to add a test for this though?\n. Looks like the history on this one is borked but this is included in #1440 via https://github.com/bitovi/canjs/commit/c820813e07c017a6c7de5b4d874a3a128e7e4d33 now anyway.\n. Yes. But @imjoshdean still needs to add documentation (#1449)\n. This looks like it makes sense and can go into 2.2. Is there a chance you can add some tests?\n. In what way?\n. Good point. I think what the docs were trying to say that if you'd do\njs\nvar newInfo = {'teeth' : 'shiny and clean'};\ncontact.attr('info').attr(newInfo);\nYou should get a merged object.\n. Is this fixed via #1486?\n. This is already in minor with the correct history.\n. Closed via #1400\n. This should be fixed now via #1486 (as mentioned in #1470)\n. We could alias it. I think I have some eqs somewhere, too.\n. Thanks! This looks good and will make it into 2.2 with two things:\n- Can you squash your commits (http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html)\n- Let's add the eq alias as well.\n. Sweet! Thanks a lot, this is a great feature!\n. No. Referenced issues will be closed automatically once in master.\n. We could make minor the default branch. I don't think that finding all the still open but referenced issues in merged PRs against minor is necessary though. I'd also rather have people watching an issue be notified if a new release has been made not just if the fix made it in a development branch.\n. This caused tons of issue with people forgetting to run it locally. I think we should be able to make it a peer and dev-dependency.\n. Nevermind, peerDependencies actually are being installed and @mjstahl is going to update this.\n. Would this be a 3.0 change? I know it's not tested anywhere but wouldn't this break all code that's listening to an add event under the - admittedly wrong - assumption that you only get a single value?\n. This is backwards compatible right? Can you rebase and double check why the tests are failing?\n. This needs to be submitted against the minor branch. You can change the target branch when creating the PR so we'll probably have to close this one and submit it again.\n. This is using PhantomJS as the test runner.\n. Oh yes, both is. We can close this.\n. No. Master is up to date and ready for 2.2. Ideally things go against master now but it doesn't really matter since I need to merge minor in again anyway.\n. Closed via #1460\n. Test?\n. :+1: once tests are in.\n. You probably need to pull in latest master.\n. I am not able to verify this. This test is passing:\n``` js\n    test(\"#1469 - resource definition - destroy\", 2, function() {\n        can.fixture(\"POST /foods\", function(res, respond) {\n            res.data.id = 42;\n            return respond(res.data);\n        });\n    can.fixture(\"DELETE /foods/42\", function() {\n        return [];\n    });\n\n    var FoodModel = can.Model.extend({\n        resource: \"/foods\"\n    }, {});\n\n    stop();\n\n    ok(typeof FoodModel.destroy === 'function');\n\n    var steak = new FoodModel({name: \"steak\"});\n    steak.save(function(food) {\n        equal(food.id, 42, 'Id set');\n        steak.destroy().then(function() {\n            start();\n        });\n    });\n});\n\n``\n. Did some more research and we might want to adddestroy` in https://github.com/bitovi/canjs/blob/master/model/model.js#L590 but I could not create a use case that would break otherwise.\n. This is great... but... docs?\n. Awesome, :+1: from me! I agree that the refactoring can be done in separately but can you maybe create a follow-up issue for it so that we don't loose track. Thanks!\n. Only tested for GET in https://github.com/bitovi/canjs/blob/master/util/fixture/fixture_test.js#L550\n. I put your example into a Fiddle and get a\n\nUncaught Parse Error: <input id=\"new-todo\"\n\nin the console. Is the issue you are observing reproducable in a Fiddle (fork from here)?\n. Closing this one since I can't reproduce. We can reopen if we find a breaking Fiddle.\n. I will try and add a test for this and then merge it.\n. Thank you!\n. The site won't be deployed until the release.\n. I also added the autorender module back into the builder.json but it won't run the tests (Phantom gets stuck on those for some convoluted reason and some random error somewhere in Underscore that I wasn't able to figure out yet).\n. In the test runner. Seems like the way the QUnit test are run in the iFrame it doesn't know what suite they belong to and thus gets stuck.\n. Looks like I found a way. Will merge once the tests pass.\n. This can be solved by setting the removeAttr static property to true which causes model merges to remove existing attributes.\nI agree this should be the default behaviour but unfortunately we can't change this until the next major release.\n. Closed via #1517\n. Closed via #1517\n. You probably need to update https://github.com/bitovi/canjs/blob/master/builder.json#L154 if you changed the location.\n. This is closed via #1520\n. As mentioned to @moschel, I am pretty sure that having a getter and a value is what is causing the issues. This causes the defaults to be set (in https://github.com/bitovi/canjs/blob/master/map/define/define.js#L30) and the getter to run during initialization.\nI can't think of a use case where you would have a value and a getter at the same time.\n. It looks like some tests (AMD, distributables) are failing legitimately. I am also not sure if this is the right fix. The order of keys in objects is not determined and not necessarily the same as it was defined. #1521 is a a regression so it must have been introduced somewhere else.\n. The reasons for the tests failing is that the attributes plugin does not play very well with define. I made the test conditional since we probably will remove the old attributes plugin - or at least take it out of this repository.\n. Can you change some of the tests so that both are covered? I really thought I caught this one but I guess I didn't.\n. This has been closed via #1528\n. I thought that would just mean you can't access the property directly like model.created. I would expect it to show up in a view if it is available via .attr: http://jsfiddle.net/uc1m3L4j/2/\nIs that just a precedence problem that (Mu)Stache is trying to run the function right away instead of looking it up via .attr first?\n. Thanks!\n. This seems to be fixed now (see http://canjs.com/docs/can.stache.helpers.sectionHelper.html)\n. I'm not sure if this is a bug. In your case station is a list with no elements (and therefore truthy). I usually check length like {{#unless stations.length}} {{/unless}}.\nThe Mustache spec however says that {{#stations}} implicitly iterates if stations is array like. So {{^stations}} does the opposite of that (if it is an empty array or falsy).\n. Unless isn't the opposite of {{#each}} it's the opposite of {{#if}}. As the documentation says:\n\nRender the block of text if the key's value is falsey.\n\nYour key is sections and sections is truthy. \n. This has been fixed via https://github.com/stealjs/steal-tools/pull/201\n. Both should be fixed in the release I'm working to get out (2.2.1)\n. And other matching elements (e.g. a <li> when you are in a <ul>)\n. Thanks for submitting all the PRs! Do you think you can consolidate them all into one? I assume it's because of GitHubs inline editing that they are all separate right?\n. Where? I was looking but couldn't find another PR. Oh also, if you rebase them (git rebase origin/patch-6) you'll avoid all those merge commits.\n. Is this fixed via #1592?\n. Should be fully fixed now with #1590\n. I thought @alexisabril worked on making validation errors observable at one point?\n. No, it should work just the same. I'll give it a try.\n. Fixed via #1590\n. This makes sense. Is there a way we can test it?\n. Sweet, thank you!\n. We are running the download builder core generated file through some basic tests (see http://bitbuilder.herokuapp.com/demo.html) which seems to work so it must be either Stache or autorender (although I did add autorender standalone tests in #1586).\n@matthewp Any idea why this would use window.require instead of our define shim?\n. http://bitbuilder.herokuapp.com/canjs is showing version 2.2.4. steal-tools is pointing to 0.7.1-pre.2. Is that too old?\n. I just updated to 0.8.0 so this should be fixed now. Although we do recommend using the actual AMD version when using and AMD loader like RequireJS. It makes things a lot easier.\n. Shouldn't R.js load it already it you require can/view/stache explicitly? Then can.import should just get that already loaded and optimized version.\n``` js\ndefine(function (require) {\n    var $ = require('jquery'),\n        can = require('can'),\n        stache = require('can/view/stache'),\n        foobar = require('app/module3');\nrequire('can/view/autorender');\n\n});\n``\n. I am going to close this one. Please reopen if there are still any issues.\n. That is odd since.replacejust runsthis.splice.apply(this, [0, this.length].concat(can.makeArray(newList || [])));(see https://github.com/bitovi/canjs/blob/master/list/list.js#L1096).\nIt seems to not detect the changes properly. If I doll.replace([\"aa\", \"something\"])it works as expected.\n. You should be able to change [can.view.ext](http://canjs.com/docs/can.view.ext.html) to.stache. Mustache is still be loaded because of a hard dependency on can.Component though. The reason why is discussed in #1326. We will change it for 3.0.\n. Would just becomecan.$(\"[can-autorender], [data-can-autorender]\")` right?\n. Closing this one for #1717\n. The result is indeed odd but I think the easiest solution for now is to pass the context you want to store in the data as the second argument:\nhtml\n<div id=\"test\" {{ data \"todo\" todo }}></div>\njs\n$('#test').data('todo') // -> todo\n. I would say docs for this and @marshallswain already started that in #1640.\n. I think this is the same issue that the #1634 pull request addresses.\n. Can we close this one?\n. Closed via #1631\n. I think @justinbmeyer added a deprecation message when you install canjs.\n. Added the NPM deprecation warning to the https://www.npmjs.com/package/canjs package.\n. Good point. I didn't remember the reason for our own proxy. We should probably leave it then although it would be interesting to see if there is a performance difference between Function.prototype.bind and your own wrapper.\n. Looks great, thanks! I'll put it in for 2.3. We might have to merge it into the minor branch then but that shouldn't be a problem.\n. I would probably add it to https://github.com/bitovi/canjs/blob/master/util/fixture/doc/store.md. You can also create a similar new page in that folder called resource.\n. Well I mean basically what you do with <div {{data 'person' person2}}> is $(div).data('person', person2) so it's simply just the value that you are setting. I find the word context potentially confusing here.\n. Not ready to merge yet, finalization incoming.\n. Nevermind, needs to be minor anyway.\n. @gomez Since you know the sort plugin best and if you agree with this PR, feel free to merge it in.\n. Minor\n. I just tried a merge and it turned out to be a huge pain so probably not until two weeks from now.\n. I was  indeed being complicated. Thanks!\n. Closed via #1655\n. Can you rebase this one, too? Probably just the Stache tests that need to be merged.\n. Oh also, tests can't be written in CommonJS format yet (but probably should eventually although I'd prefer ES6).\n. Following up on this, I'm wondering why this doesn't already reject since the default parseModels does throw an error at https://github.com/bitovi/canjs/blob/parse-models-issue/model/model.js#L261. Are you using your own parseModels?\n. This is probably still good to add but your parseModels should probably make sure that it is only returning and array and otherwise throw an error itself.\n. @akagomez What new issue? I'd argue that can.map.attributes and the define plugin shouldn't be used together (which is I think exactly what the deprecation warning says).\n. I removed the attribute tests from being included in #1704.\n. The tests are still failing (I'll have to look at it again) and @m-mujica reported this as a regression in 2.2 which doesn't make sense because this code hasn't really changed in about a year. I'd like to find out why this broke something that used to work before first.\n. This fails some backwards compatibility tests as well (see https://travis-ci.org/bitovi/canjs/jobs/62603307#L2571).\n. I created a better fix in #1803.\n. @James0x57 wrote a migration script for this. Before putting this warning in we should polish it, add documentation and link to it.\n. It would be great if you could add some quick documentation in the Readme so that we can link it in the deprecation warning.\n. I really thought I caught them all. Will merge once CI passes again.\n. Good call. Once I finished the other articles I will try and incorporate them into the guides but linking them for now makes sense.\n. I think this one is conflicting with #1661 I just merged. If you rebase with latest master I will merge this PR right away. Thanks!\n. Those files shouldn't really go into the AMD build but I'd like to figure out why they are so messed up. @matthewp any ideas?\njs\n'format steal';\ndefine(['can/view/ejs'], function (can) {\n    function translate(load) {\n        return 'define([\\'can/view/ejs/ejs\\'],function(can){' + 'return can.view.preloadStringRenderer(\\'' + load.metadata.pluginArgument + '\\',' + 'can.EJS(function(_CONTEXT,_VIEW) { ' + new can.EJS({\n            text: load.source,\n            name: load.name\n        }).template.out + ' })' + ')' + '})';\n    }\n    return { translate: translate };\n});\n translate: translate };\n});\nmports.intermediate) + ')' + '})';\n    }\n    return { translate: translate };\n});\n``\n. I don't think we introduced any breaking changes with VDom and it would be still good for 2.3 which we could do fairly soon.\n. Couldn't we use the can-import Deferred (which is available right away), pass that as the partial and and wait to render until it is resolved? \n``` js\n\n{{> orderItems}}\n``\n. Do you know if this is a regression in 2.2.x?\n. What are the related issues? #1231, #1676 and #1657 right?\n. Function are always implicitly called in Mustache (and Stache). As you have shown in your Fiddle this can be solved by wrapping it into another function. Since this is expected behaviour and part of the Mustache specification with a workaround available I don't think there is anything we can do to change this.\n. We should look into migrating more JSBins.\n. Finally! That was a beast ;)\n. Can we close this due to 2.3.0?\n. I'm going to close this. Partials should work correctly in latest.\n. @justinbmeyer this has indeed been added in #1540 but was never documented. I will add apromise.mdthat talks about how to use it.\n. Does it work if you serialize it explicitly?\n. That is true. Existing maps should be serialized and converted into a new one (if they are of different type) but they are currently not (much likenew Map(othermap)). Unfortunately we can't add this until 3.0 since it would break the current API. There is however a simple workaround of monkey patchingcan.List.prototype.push` if that is that is the behaviour your applications expects:\n``` js\nvar old = can.List.prototype.push;\ncan.List.prototype.push = function() {\n  var args = can.toArray(arguments);\n  var item = args[0];\nif(item instanceof can.Map && !(item.instanceof this.constructor.Map)) {\n    args[0] = item.serialize();\n  }\nreturn old.apply(this, args);\n}\n``\n. Am I understanding it right that what you want to do is use aModel.findAllbut receive an instance of a different list?\n. I will look into the issue but do you have an example for the define plugin not working on can.Model in 2.2.6? can.Model just extends can.Map and I remember using the define plugin with can.Model in that version.\n. Are you running themodel/test.htmlortest/jquery.htmltest page?model/model_test.jsdoes not include the define plugin so the tests would probably break when runningmodel/test.html.\n. It is indeed, thank you for pointing that out. I fixed the link.\n. It depends on what we are listening to:\n1. Deferreds are observable in templates but not on the control. You'd have to.then()them manually.\n2. The best way to listen to specific property changes is'{scope} foo': function(el, ev) {}`.\n. This is showing all the correct events right? I agree, it would make a good example, so if you would like to add it, http://canjs.com/docs/can.Component.prototype.events.html (by editing https://github.com/bitovi/canjs/blob/master/component/events.md) is probably the best spot. Can you submit a PR?\n. Yes, this is closed.\n. Just verified that this is fixed.\n. Also, how does the original template look like?\n. Should be closed now via 1401c401c49609f2d8d369d5950cdcaf139e6018\n. Here is a simpler test:\n``` js\ntest('compute change handler context is set to the function not can.Compute', function() {\n    var comp = can.compute(null);\ncomp.bind('change', function() {\n    equal(typeof this, 'function');\n});\n\ncomp('test');\n\n});\n```\nBasically the change handler context needs to be the can.compute function (which is what it used to be in 2.1) not the new can.Compute object.\n. Any idea why that files was gone?\n. :+1: But I'm wondering if this could be considered a breaking API change?\n. Shouldn't it be throw new Error(\"can.Map: Object does not exist\");? Anyway, if it doesn't we can even get it into the 2.2.7 patch release.\n. I think that makes sense. What's the breaking test case (maybe as a JSBin) that causes this issue?\n. Doesn't a helper just get used like\nhtml\n<div can-click=\"{{#canShowPopover}}togglePopover{{/canShowPopover}}\"></div>\nAlso your example does not have a closing {{/if}}.\n. I'll have a look next week. If this worked in 2.2 we should probably find out what changed.\n. Closed via #2066\n. Fixed by #1803\n. Awesome!\n. This is now in a separate module at https://github.com/canjs/can-interrupt\n. Closed in minor via #1840\n. I think it's a command line flag for npm publish\n. We will make sure that we do official pre-releases in the next minor/major version.\n. This has also been fixed in minor. The actual problem was that the default section didn't get re-evaluated.\n. The Stache engine is syntax compatible with Handlebars which means that you can use most Handlebars templates without any modifications. There are some small differences in helpers because stache helpers are live-bindable (whereas Handlebars doesn't have live-updating templates at all).\nWe don't have a specific list of the differences at the moment but you can find all the documentation at http://canjs.com/docs/can.stache.html and we can always help out migrating if you run into any issues.\n. Do we know why the tests are failing? It looks like the AMD build isn't working.\n. Closed via #1920\n. Closed via #1920\n. This looks good. Two things: Could you squash your commits and can we add test that breaks in Firefox for this?\n. Oh no. I can look into it if you can provide a breaking test for Firefox. Thinking more about it I am not sure if always checking for hasOwnProperty is the right solution yet so I'd like to double check it.\n. I'm closing this PR since we will extract it into a separate plugin as discussed.\n. Closed via #1893\n. This has been fixed in minor via #1885\n. Thank you. I don't know how I missed that. I will get a 2.2.8 out shortly.\n. Closed via ##1889\n. If and when this is wrapped up, could you re-submit it against minor since that is going to be the next release?\n. If this should go into 2.3 can you resolve the conflicts and add it to the 2.3.0 milestone?\n. This should probably go into master. It also is a regression in 2.2.6\n. Looks like something is breaking in the Mootools and YUI tests?\n. Sweet, thanks!\n. The issue is slated for 2.2.8. Can you resubmit against master?\n. Indeed. Thanks!\n. Why is the attribute capital READONLY? I would probably lowercase it. Looks good besides that.\n. can/view/href has already been deprecated so we can leave it as an external plugin dependency.\n. Instead of adding them all individually we should probably discuss adding Underscore/Lodash collection methods more.\n. This has been fixed via #1943\n. Shouldn't be the return null; be removed completely?\n. No this is indeed the correct fix. Thanks!\n. This has already been fixed in 2.2.8 via #1886. The correct solution would've been to merge 2.2.8/2.2.9 master into minor.\n. It looks like those tests are legitimately breaking. Probably in libraries other than jQuery.\n. I will try this later.\n. I merged #1964 first and now this one seems to have a conflict?\n.  No need to resubmit, just push to this branch once resolved (ideally rebased if possible). Thanks!\n. Can you resolve the conflicts that came up after merging in minor?\n. I did verify manually but could not add a test since Browsers don't support XHR requests on the file:// protocol.\n. Closed via #1967\n. Looks like this has been fixed via #1972\n. I think the change you mean has been made in https://github.com/canjs/can-connect/pull/35 (at least the only difference I can see in can/view/href in this commit is https://github.com/bitovi/canjs/pull/1972/files#diff-c41f9367c9bc3372297f1cf3fc7f217fR20),\n. Issue is now https://github.com/donejs/donejs/issues/81\n. This has been closed in #1990\n. Thanks Mark! CI failed because of JSHint though.\n. Sweet, thank you! Fixes should show up on the homepage in a couple of minutes.\n. Awesome, thank you!\n. Closed via #2021.\n. I don't think this is fixable. A select field like\nhtml\n  <select id=\"test\">\n    <option>One</option>\n  </select>\nWhen set like this:\njs\nvar element = document.getElementById('test');\nelement.value = '';\nWill always show an empty select in Chrome/Safari etc. and the first item in Firefox.\n. Just working on releasing a 2.3.1 which should fix this via #2021\n. I wonder why Mustache gets added to the window. I'll add a condition to only do this when GLOBALCAN is true.\n. I will add it to when people steal('can') or require('can'). I can't remove the plugin from the standalone build though since it would then break existing installations.\n. I was thinking about that, too but I think it should stay its own plugin (and you can't load it in can/map because they would depend on each other).\nWhen we put everything into their own modules it might live with can/map and be included by default (but also give the option to require them separately).\n. Closed via #2057\n. Yes, I think I'll have to merge in latest master. Working on it.\n. Closed via #2089\n. Since it is a documentation fix, I'll remove it from the milestone and we'll just merge it when it is ready.\n. Closed via #2094\n. I think #1692 is related to this as well.\n. Thank you! It looks like JSHint failed (you should see the same error if you run npm test). Also, I think if you are not using the define plugin you will still get the %root property serialized. It may need to be added to https://github.com/canjs/canjs/blob/master/map/map_helpers.js#L75 as well.\n. Yes, that looks great. Thank you!\nWhat issues did you have with the tests? Maybe there's something we can do to make it easier.\n. It looks like it is failing for non-jQuery libraries. You can run those by going to canjs/test/index.html or canjs/test/<name>.html.\n. Awesome. Looks good to me. Also verified that querySelectorAll is fine for IE8.\n. can.VERSION is being set in the files in dist/. I assume this is only a problem when using the NPM version with Steal?\n. Related #2092\n. The tests are legitimately breaking. For some reason this change causes a lot of other issues.\n. Awesome, thank you!\n. Can this be tested?\n. This seems like a lot of additions. Should that still live in our main repository?\n. I'm going to close this. Please reopen if it still persists.\n. Fixed via #2211\n. Bumping this to 2.3.13. We have been making at least weekly releases lately so this will still be fixed very soon.\n. Fixed via #2208\n. Argh, I don't know where all the whitespace diffs are coming from, .editorconfig is set up not to do that.\n. Is that bound to a select field?\n. Caused by #2224\n. This is fixed now. The reason why it was flaky was that the zip files were built when canjs/canjs master got updated but not after changing bitovi/canjs.com after a release. They now run every time.\n. Fix has been published on NPM as 2.3.15\n. They're literally the same except for an NPM bugfix. You are right though, it should probably show up in the changelog.\n. Sweet, thank you!\n. Thank you!\n. I don't think this is necessary. ^0.3.0-pre.0 should match every 0.3.x release (tested with http://semver.npmjs.com/)\n. I just tested npm update on my local CanJS. Before:\ncan-simple-dom@0.3.0-pre.3\nAfter:\ncan-simple-dom@0.3.0\nSo it seems to work.\n. We'll get the correct version range into the next release\n. That makes sense. One of those plugins probably called the method with null which seems to be valid in jQuery.\n. :boom:\n. This has been published as CanJS v3.0.0-pre.0 (you can get it via npm install can@furiosa).\n. :shipit: \n. I could reproduce this with those versions. I published a new 2.3.22 with it and the installation is now working.\n. Should it not be a plugin at all then?\n. Makes sense. I added it back in. All other plugins have been removed and now live in their own repository.\n. /cc @BigAB\n. This is fixed in v2.3.22\n. Thank you! It is fixed now.\n. Note: https://github.com/kenwheeler/cash might be a good replacement for the jQuery event system (full library might potentially even allow to migrate existing jQuery apps).\n. Good timing, I was just looking at it. Thanks for reporting!\n. The old site is now at https://v2.canjs.com running from the 2.3-legacy branch. \n. With #2538 merged, Greenkeeper has now been enabled.\n. Missing browsers will be reopened against master\n. Yes. Reopening in master with latest updates.\n. For the can-view-autorender tests: https://github.com/canjs/can-view-autorender/pull/21\n. Closed via #2628\n. All passing locally. We'll use Safari to test against Webkit.\n. All done now.\n. https://github.com/canjs/canjs/pull/2585\n. https://github.com/canjs/canjs/pull/2585\n. https://github.com/canjs/canjs/pull/2585\n. https://github.com/canjs/canjs/pull/2585\n. https://github.com/canjs/canjs/pull/2585\n. https://github.com/canjs/canjs/pull/2585\n. https://github.com/canjs/canjs/pull/2585\n. https://github.com/canjs/canjs/pull/2585\n. https://github.com/canjs/canjs/pull/2585\n. https://github.com/canjs/canjs/pull/2585\n. https://github.com/canjs/canjs/pull/2585\n. https://github.com/canjs/canjs/pull/2585\n. https://github.com/canjs/canjs/pull/2585\n. https://github.com/canjs/canjs/pull/2585\n. https://github.com/canjs/canjs/pull/2585\n. See https://github.com/canjs/canjs/pull/2585\n. https://github.com/canjs/canjs/pull/2585\n. Can you rebase with the latest master?\n. Thank you @sarathnair. Unfortunately I already updated https://github.com/canjs/canjs/blob/master/contributing.md with the new contribution guides. That repository is no longer used and the new process for generating the documentation is documented here. Closing this PR.\n. See #2605\n. See #2605\n. See #2605\n. See #2605\n. See #2605\n. See #2605\n. Definitely works locally, I just really hope Saucelabs plays nice.\n. Related: https://github.com/canjs/can-view-target/pull/19\n. #2672\n. Sorry those should still be there. I updated the release folder with latest. We probably want to keep them but for 1.x and 2.x release could refer to rawgithub.com (from https://github.com/bitovi/canjs.com).\n. #2687\n. #2687\n. I think it should do deep equality for everything then:\nif( (typeof value != ='undefined' && value !== null && value !== '')\n. This looks a little weird. Isn't this just doing\njs\nif(!this.host) {\n  this.host = window.location.host;\n}\nBesides that I'd merge this in because it makes sense. I was thinking about a good way for testing this but I don't think there is (even checking the window.location in an iframe wouldn't really tell us much).\n. This actually did break the tests.\n. Can you remove the tailing comma? I guess it's one of my pet peeves but it shows up as an error in Webstorm and any JS linter.\n. Should we make this if(ob === undefined || ob === null) to be more explicit?\n. Can we name this test.html? That's how the other plugins are doing it now, too.\n. So with changing the event system if anybody uses .stopImmediatePropagation or namespaced jQuery events we are breaking it in a patch version! I think the concerns someone already voiced over Twitter shouldn't be that easily dismissed.\n. The interesting thing is that it worked when just passing the instances but the stack overflow happens when it is on the window using the string notation (Game.model, Game.models).\n. Shoot, this should be textRenderer.apply(this, arguments);\n. Btw, now you can also use characters: Character (http://canjs.com/docs/can.Map.attributes.html#section_Associations). Using either way won't really test the issue however, because only the old way seems to cause a recursive error (most likely because it is being called differently).\n. Needs .stop() and .start() or .asyncTest for asynchronous tests.\n. Scratch that. Looks good.\n. I think the better place for this would be directly in https://github.com/bitovi/canjs/blob/master/control/control.js.\n. We might also want to make sure that something like\n``` js\nvar state = new can.Map({\n    \"key.with.dots\": 12,\n    key: { with: { something: 'else' } }\n});\nstate.removeAttr('key.with.something')\n```\nstill works. Besides that, great catch, thanks!\n. Could we maybe just do if( ('' + attr).indexOf('.') ) {?\n. Oh good point, I forgot about floating point numbers. I think this works then.\n. We might additionally have to check for contenteditable=\"false\" (as mentioned here).\n. Should we use the same check here as in can.Map (if (this[attr] && this[attr].isComputed && can.isFunction(this.constructor.prototype[attr])) {)?\n. Isn't can.test.path(\"route/pushstate/testing.html\", true).replace(\"route/pushstate/testing.html\", \"\"); the same as can.test.path(\"\")?\n. Even to something ending with /?\n. Why is this needed? I thought this is already initialized in can.Map which list extends.\n. Can't we just use the existing property set to fixture: false here?\n. No that doesn't work but I think supporting that would be nicer than adding an extra canfixture parameter.\n. I think both, the new and old Steal have a steal.config so it will always go in here. I'll probably merge this PR and then also add a test.\n. Use can.isObserve or instanceof can.Map\n. Needs .read\n. Add to .model and .models\n. Test with one more level of extension.\n. Make sure override with string also works.\n. Actually this needs to stay on parseModel(s) because .model and .models does not get initialized as a new function on every model anymore.\n. Why the name change? Also we might want to update the version and indent it.\n. Why is this commented out?\n. I'm not sure but wouldn't this leak? Do we need to unbind when the getter returns?\n. I think this needs to be window.jQuery\n. How is this supposed to work? For some reason it is only breaking for Mootools but can.proxy(true, internalCompute) doesn't seem right.\n. This needs to be can.trigger(el, ev) then tests should pass with the other libraries as well.\n. This probably has to be document.getElementById('qunit-fixture').innerHTML. I'll fix it.\n. <!-- AUTO GENERATED - DO NOT MODIFY --> ?\n. I guess I can fix that.\n. I would say yes. If we change the internal API we'll have to change the tests which is fine though.\n. Wouldn't it be faster to use substr and properties.lastIndexOf('.')?\n. Did we decide to leave !found in?\n. Should we changes this to an implicit cast like '' + elements.getAttr(el, attributeName)\n. !!!value.render?\n. I'm pretty sure this shouldn't use .then\n. Duh, it's right there don't know why I missed that. Fixed now, thanks!\n. I don't think this belongs here.\n. I'm not sure if this makes sense. function(val) now always returns undefined.\n. ",
    "robertheessels": "Still a bug remains:\nIf the server returns an item that has some fields that are removed (or an array filed is now empty, where it was not before) than the model function of model.js still return the old version of that field.\nin model.js line 789 it should be:\nvar model = this.store[attributes[this.id]] ? this.store[attributes[this.id]].attr(attributes,true) : new this( attributes );\nnot:\nvar model = this.store[attributes[this.id]] ? this.store[attributes[this.id]].attr(attributes) : new this( attributes );\n. Yes, I understand and agree.\nOverwriting the model method is fine for us, so there's no real hurry as far as we are concerned.\n. I'm not sure, but it could be that it works in 2.0.0 while it does not work in 2.0.3.\n. ",
    "thecountofzero": "Does it update the updated fields that come back from the server? Seems like it would/should. But by just looking at this (haven't had a chance to test), I can see how missing fields wouldn't be updated/removed.\nI agree on the suggested code change.\n. Submitted pull request for code change and corresponding test case\n. I am not actually running into this issue, but after checking, I was seeing what the original poster was talking about. If request a list of models and the second time you request those models, some attributes are gone, shouldn't they be removed from the store? \n. That make sense to me. As I mentioned, I am not running into this issue. I just saw that someone was and that he was \"right\", so I figured I'd try and pitch in and help without really thinking about the broader side effects. Although having an option do this as Justin mentioned, might be of value.\n. http://jsfiddle.net/thecountofzero/YnCTz/1/\n. Yes, I mean triggers the destroyed event and removes the removed div elements from the DOM. \nCalling .empty on a DOM element, in turn, removes all the child elements of that DOM element and triggers the destroyed event all of the removed elements. Doesn't the destroyed event then invoke the destroy function of any control that is attached to a DOM element that was removed?\nI agree that it is probably a live list of DOM elements that is returned by getElementsByTagName and passed to cleanData.\nthis.element.find('.collapser').remove();\nThe purpose of this is to allow the control to clean up after itself. The control created that DOM element. Let's say I wanted to have an action on the page that, for some reason, made it so that the content was no longer collapsible. To do this, I would call the destroy function of the collapsible control and it would clean up. I don't know that I actually want to do this, but I have been trying to make sure I have my controls clean up after themselves and incidentally stumbled upon this potential issue. \n. Well I guess it can be documented not to do that, but it seems like something that is possible to run into.\n. \u2192 ./js can/util/make.js\ncan/util/make/jquery.js >\n\ncan/util/exports.js\ncan/util/array/each.js\ncan/util/preamble.js\n  Ignoring can/util/jquery/jquery.1.7.1.js\ncan/util/jquery/jquery.js\ncan/observe/compute/compute.js\ncan/util/string/string.js\ncan/view/view.js\ncan/construct/construct.js\ncan/util/string/deparam/deparam.js\ncan/observe/observe.js\ncan/control/control.js\ncan/route/route.js\ncan/view/ejs/ejs.js\ncan/control/route/route.js\ncan/model/model.js\n  Ignoring steal/dev/dev.js\njs: uncaught JavaScript runtime exception: TypeError: Cannot read property \"scripts\" from undefined\n. I am using the latest version of jQuery CanJS (commit a7583f29260c127af8cb0dcd34fcb370d1b3a4d0)\n\njavascript\n\"li click\": function(el, ev) {\n    console.log($(ev.target).data('thing'));\n}\nThis logs \"undefined\"\nI am using Steal. Perhaps I am not steal'ing some file required for this to work?\nHow do I use Steal in a fiddle?\n. I apologize. This was my error. I was reading a view in using can.view into a variable named stuff. And then when I was appending that markup into the DOM I was doing:\njavascript\n$( \"content\" ).append( $(stuff).clone() );\nIt should have been:\njavascript\n$( \"content\" ).append( $(stuff).clone(true) );\nI was missing the true in clone. If you are wondering why I am doing this it is because I have a DOM element that can contain data (kinda like a panel) and that data can be swapped out with other data. The way I am doing this is in my init I am loading the chunks of data (different panel content) that can be loaded into the panel and when it's time to load that data into the panel I am calling this function:\n``` javascript\n_loadPanel: function(panel) {\n// Clear our the current panel and then load the new panel using a clone so when we use empty we don't\n// lose the panel markup\nthis.content.empty().append($(panel).clone(true));\n\n},\n```\nAnyway, my bad dudes. Closing this non-issue.\n. I am encountering the same issue. I have:\n``` javascript\nvar Thing = can.Model({\n    id: 'someField',\nfindAll: 'GET /things',\nupdate: 'PUT /things/{id}'\n\n}, {});\n```\nWhen I try and do a save on an instance, it tries to save to: /things/false\nIf I change the update definition as suggested above to:\njavascript\nupdate: 'PUT /things/{someField}'\nThis uses the correct URL. \nMy question is then, what is the purpose of the id field?\n. So it is for internal use. No problem. Just wanted to make sure I fully understood its purpose. \nThanks.\n. Already did. Attached it to the forum post but forgot to post it here.\nhttp://jsfiddle.net/thecountofzero/rEvpp/1/\n. I don't know. You think?\nThe problem here seems to be that on subsequent findAll() (and probably findOne) that converters are not being executed if specified by the attributes property.\nPerhaps you were talking about the other issue I posted where old items are not removed?\n. Seems to be working fine for me...\n. I had the wrong expected assertions count. I forgot I removed a change to the observe before committing the test and never decremented the expected assertions count.\nShould be good now.\n. When is 1.1.6 scheduled?\n. So it's the attributes plugin. If I want to test this with my app I should pull the latest from github and then grab this version of the attributes plugin? I definitely need to get this working in less than a month.\n. From my preliminary testing, this seems to fix my issue.\n. Sure. As long as it doesn't break other things.\n. Was this merged in?\n. I am still seeing this. Or perhaps a similar \"maximum call stack exceeded\" error with nested models.\nUncaught RangeError: Maximum call stack size exceeded\njQuery.extend.makeArray\ncan.Map.can.Observe.can.Construct.each\nserialize\nObserve._attrs\ncan.Map.can.Observe.can.Construct.attr\n(anonymous function)\ncan.each\ncan.Map.can.Observe.can.Construct.each\nserialize\ncan.Map.can.Observe.can.Construct._attrs\ncan.Map.can.Observe.can.Construct.attr\n(anonymous function)\ncan.each\ncan.Map.can.Observe.can.Construct.each\nserialize\ncan.Map.can.Observe.can.Construct._attrs\ncan.Map.can.Observe.can.Construct.attr\n(anonymous function)\ncan.each\ncan.Map.can.Observe.can.Construct.each\nserialize\nObserve._attrs\ncan.Map.can.Observe.can.Construct.attr\n(anonymous function)\ncan.each\ncan.Map.can.Observe.can.Construct.each\nserialize\ncan.Map.can.Observe.can.Construct._attrs\ncan.Map.can.Observe.can.Construct.attr\n(anonymous function)\ncan.each\n.\n.\n.\n. I am still trying to pinpoint exactly what I need to do to cause this to happen. I asked daffl today if this had been resolved and he said he thought so in the latest code so I pulled down v1.1.6 and clicked around my app and got the error. He told me to mention something here. \nNow I am looking at my code to see if I can give you guys some better details on how to repro. All I have so far is that it is related to nested models within each other. I realize this doesn't quite help, but I am trying to get you something better. \n. I should add that this is not when I destroy a model. I just realized that this issue is labeled \"when I destroy a model\".\nThis is actually happening when I just load additional or a new model into the UI when there are already others in the model store.\n. This doesn't appear to be fixed.\nHere are two fiddles the demonstrate the error:\nhttp://jsfiddle.net/thecountofzero/a2b3S/\nhttp://jsfiddle.net/thecountofzero/8KX4N/7/\nHere is the post on the forum:\nhttp://forum.javascriptmvc.com/#Topic/32525000001308005\n. This issue needs to be re-opened.\n. If you put a breakpoint on the console.dirs line and then step into, it brings you to \njavascript\nvar pipe = function(def, model, func) {\n    var d = new can.Deferred();\n    def.then(function() {\n        var args = can.makeArray(arguments);\n        try {\n            args[0] = model[func](args[0]);\n            d.resolveWith(d, args);\n        } catch (e) {\n            d.rejectWith(d, [e].concat(args));    // THIS LINE\n        }\n    }, function() {\n        d.rejectWith(this, arguments);\n    });\nIt appears the error is being caught in the try/catch\n. You are correct. It is not a problem with live binding as the page does update if you update the appropriate instance.\nI will create the breaking test for this tomorrow.\nThanks for the reply.\n. Was just about to submit a failing test, but it looks like someone beat me to it. \n. Test I see in model_test.js is for Issue #357 \nAre these issues related?\n. @justinbmeyer, hey dude, any time to look at this one?\n. Somehow we need to keep track of models of the same model type and ID while they are being processed in \"model\"\n. Whoops. Forgot \"var\". Bad me.\n. Not quite sure how that got in there. My git skills are no match for your dojo.\n. I'm not? In the fiddle I am fetching a game and it gets passed to the view. \nThen I change what the fixture points to to simulate data being changed and re-fetch it. I would expect the displayed value to change.\nAnd if I remove the attributes properties of each model and re-run, it works correctly.\nHow is this not a bug?\n. What do you mean, changing the id?\nOn Sat, Sep 21, 2013 at 9:08 PM, Justin Meyer notifications@github.comwrote:\n\nI don't think changing the id is supported.\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/pull/460#issuecomment-24873874\n.\n. @daffl, Which fiddle?\n\nWhen I use the following fiddle:\nhttp://jsfiddle.net/thecountofzero/a2b3S/\nAnd then enter v.destroy() in the console I get the \"RangeError: Maximum call stack size exceeded\"\n. Are you saying doing something like this in attributes.js ?\njavascript\ncan.Observe.prototype.serialize = can.Observe.List.prototype.serialize = function(attrName, stack) {\n. If I enter \"can.Observe.List.prototype.serialize = can.Observe.prototype.serialize\" in the console of the fiddle, it no longer throws the error.\n. Try typing \"v.attr()\" in the console. This will generate the maximum callstack error even with the above proposed fix\n. This issue has resurfaced in 2.0.3 (or earlier). \nHelp me Obi-bitovi...\n. This should be re-opened\n. See my comments on the forum. I reduced it a bit, but not much. Globals are needed for associations (attributes plugin) and the rest is the bare minimum to exhibit the issue.\n. It is?\nOn Nov 22, 2013 12:57 PM, \"David Luecke\" notifications@github.com wrote:\n\nLooks like the test is passing?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/pull/566#issuecomment-29094460\n.\n. So are you saying you that you cannot use can.Components within a can.Control?\n\nIf so, that would stink.\n. Nevermind. Thanks.\n. Here is the error message:\n```\nBuilding myapp/production.js\n last = index + $0.l\nength;\n }\n });\nParsing problem\nsteal/parse/tokens.js Bad number with 0.l.\n last = index + $0.length;\n }\n });\n names.push(attr.slice(la\n```\n. I think this might be broken only when the value you are trying to retrieve is falsey.\nhttp://jsfiddle.net/thecountofzero/tt7uL/\n. Using the \".\" works, but if the value of the attribute you are retrieving is a falsey value, it returns \"undefined\".\nIf the value of the attribute you are retrieving is not a falsey value, it returns the correct value.\nhttp://jsfiddle.net/thecountofzero/tt7uL/\n. Getting a falsey value fails with the \"\\\"\n. Please make sure that future versions of CanJS do not break apps that were built (or started) when EJS was the templating engine of choice.\n. I have stopped using EJS as well, but my app is large and it has a lot of EJS already and to go back and change it all would not be in the plans. I have no problem not using it going forward, but I want to be able to continue using the latest versions of CanJS despite having EJS as part of my app.\n. ",
    "ccummings": "Thanks for tracking this down guys and thanks for the quick fix.\n. I just nuked this pull request because it introduces some very destructive behavior that other users of the library may not expect. For example: If you do a findAll -> findOne -> findAll, the second findAll will remove all of the attributes you received in the findOne call. \nIn the case of array attributes, Observe will merge the existing and new array together, which is bad behavior so we are working on a more comprehensive fix to address that. Until that lands, you can overwrite the Model's model method to have the exact same code as the function in https://github.com/jupiterjs/canjs/blob/master/model/model.js#L782 but add the true parameter to the attr call.\n. All tests pass in all browsers.\n. This was added to fix Issue #40. If findOne and findAll returned different data, which is a common use case, the store would not update to reflect the new data.\nI had previously fixed the issue but my fix didn't remove attributes that weren't there anymore. \n. I just nuked this pull request for the reasons Justin listed above. If you do a findAll -> findOne -> findAll, the second findAll will remove all of the attributes you received in the findOne call. Just removing the attributes from the store is a little too destructive to force on everyone using the library.\n. Looks like you just want to change the link to a fiddle so why is there 4 months worth of commits in this pull request? I'm going to close this and ask that you pull the latest changes from master into your branch and resubmit your patch with only the code that needs to change.\n. Something went drastically wrong then. I've made the change myself: https://github.com/jupiterjs/canjs/commit/67b11b2022cbab4d63ce2e1b91c0b3b8e5b40b97\nThanks for the fix!\n. Going to need a little more information than that so that we can triage this bug.\n- Version of CanJS \n- Which CanJS library (jQuery, YUI, Mootools, Dojo or Zepto)\n- How you are trying to get the data back out\n- Browser(s) you see this in\nThe best way to file a bug is to submit a breaking test case or at the very least an example on jsfiddle where we can see the actual code causing the problem. Here is a fiddle I just created with identical code to yours that shows this feature working with the latest version of CanJS + jQuery.\n. This isn't a valid bug.\nYou are using live binding to display the inputs, so each time you push to the Observe.List, the whole list of inputs is re-rendered. This means whatever input had focus will lose focus because a new DOM node is rendered in its place.\nIf you want to restore focus after the re-render, you would have to add a focus event handler to your control and keep track of the index of the input that was last focused on and restore it after you push to the array. \nOf course there is also the issue of losing the values that you type into each input because the values are not being saved anywhere.\n. I wouldn't recommend using browser detection. I committed a fix here a few weeks a go.\n. Looks like this still happens if there is a DOM node wrapping the table. I'm going to take a look at this today.\nhttp://jsfiddle.net/FrRWz/\n. Fixed with 5bafca4a10835e67a015eadddf6466cbc25ca754\n. We do this here: https://github.com/bitovi/canjs/blob/master/view/render.js#L51 for . Looks like we just need to add  to this.\n. When the EJS scanner encounters a %> and the content in the EJS tags contains more { than }, It knows we are starting a new block. So EJS will wrap everything in the EJS tags in a can.view.txt call whose fifth parameter is a function to be executed that will output the correct HTML.\nWhen you have a variable declaration in the same EJS tag as the beginning of a block statement, the declaration gets put in the function that is passed to can.view.txt, meaning the var declaration is now inside an anonymous function and is \"lost\".\nTo make this work, the EJS scanner would have to check for the var keyword and output it on the line before can.view.txt. This is more complicated than it sounds and I haven't worked on the scanner code, so I'm hoping @justinbmeyer can chime in here.\n. double declaring...\nAll you have to do is declare the variable in a separate set of EJS tags. That way it will be outside of the function passed to can.view.txt\n<% var m = \"...\"; %>\n<% can.each(items, function(item){ %>\n...\n. The confusion/frustration from the automatic ready is likely related to #473 where ready is called once (before user has a chance to delay) and then again when jQuery's ready event is fired.\nBackbone and Ember both require an explicit call to start routing using Backbone.history.start() and Ember.Application.create(...) respectively.\nIn Ember's case it will start routing on DOMReady, but you can control that using deferReadiness and advanceReadiness. Angular does something similar except it seems much more tricky to delay route initialization.\nI'd be fine with automatic route.ready on DOMReady if we added a ready event to all libraries which gives the user a chance at delaying the route initialization.\n. +1\n. The pull #435 contains a .clone() for can.Observe. Good starting point for this.\n. Closing this since we won't be adding this feature to Control. Component will have this behavior through the use of the define plugin landing in 2.1. There will be a dev warning added as part of #704.\n. @daffl That's an interesting idea for sure. One that I think should be explored. \n@justinbmeyer How do you see Component and Control coexisting? Once we have Component, it seems like you would only need Control if you are working on DOM that is already rendered, right?\n. Let's take this example:\njs\n$('#myDiv').html(can.view('#tmpl', {}));\nAssume I messed up and my script tag actually has an id of template. So can.view looks for the script tag and doesn't find it, then makes an Ajax request to /tmpl.mustache with returns a 404. Now what's happened is the contents of my 404 page are now rendered into `$('#myDiv') when what we should have done is thrown an error.\n. An app isn't always in a working state...\nThrowing an error when the element isn't found, especially when we know that was the code's intent) tells you exactly what went wrong.\n. Wasn't sure what we wanted to do about the VERSION property when using CanJS from GitHub. The version will be @VERSION, which isn't very helpful, but we require some sort of unique symbol that can be replaced when the grunt build task runs.\nAlternatively, we could just update this property manually in the source, but I would prefer to automate as much as possible.\n. Changed the default value to @EDGE. This lets developers using the GitHub version know they are using the bleeding edge version of CanJS.\n. The most typical use case is an element getting destroyed and then having someone else call destroy() programmatically. Happens quite often in controls that manage other controls. This has also cropped up in test harnesses, where a sandbox is cleaned up after a test is run, but the test teardown also calls destroy on the instances it created.\n. When you encounter this error, it doesn't necessarily mean you've done something wrong. Take this fiddle for instance.\nIf you call destroy on the parent control, you would want it to destroy the child control instance as well. But if the parent control's element is removed from the DOM, this same logic will now throw an error.\nWe could console.warn that the instance was already destroyed, but I don't think a JavaScript error should be thrown in this case.\n. The binder is called is called right away and if something updates the value before hookups are run, update will be undefined. This typically happens when a value used in live binding is updated inside of a can.view call, which is a bad thing to do. \nA nicer fix is to assign a function to update at https://github.com/bitovi/canjs/blob/master/view/render.js#L261 that updates binding.value to newValue and console.warns that the developer might be shooting themselves in the foot.\nThis should make things work most of the time.\n. Looks like the incremental live lists update in #362 has fixed this issue.\n. To clarify, The request is to add a trigger method to can.compute and can.Observe.\nThese two classes have bind and unbind functions so it malkes sense to also have trigger.\n. Seems this issue is a bit more serious than I first thought. It's not just a duplicate event that is emitted, the compute you get from Observe.compute will have its value changed to the Observe If you bind to the change event. So in the example above adding this:\njs\nsetTimeout(function() {\n    console.log(name())\n}, 2000);\nWould log the Observe because the compute has been set to the Observe instance.\n. You are right, this was added as a fix to #316. I posed a similar question in that issue about what the GitHub version of CanJS should output as its VERSION. We were trying to avoid updating the version by hand, but you raise a good point. \nMost complex projects like ours always force you to use a built version of their library. For example, you'd never use the files in the src directory of jquery. You make your modifications, do a build and use the output of the build. But with CanJS, you do use the src files if you want to use steal.\nSo we either 1) accept that VERSION will be inaccurate or 2) update the VERSION by hand or 3) Make a built steal version of CanJS similar to how we have a version for AMD.\nI actually like 3 because there are lots of documentation, demo pages and tests in the GitHub source and a clean steal build might be nice. It makes working with CanJS similar to working with jQuery or any other relatively large library. You have source files, but the files you use in your application are the result of a build step.\n@daffl what do you think?\n. Everything on this list has been removed or has a deprecation warning. \nIn 2.2 we will remove everything that has a warning.\n. +1\nI think there is a need for a \"clean\" set of steal-able files. So everything you need to run CanJS with steal, but no demos, .md or test files.\n. The define plugin is replacing the attributes plugin so this PR is obsolete, hence closing. However, we might want to add wildcards to the define plugin.\n. I realized my first attempt at a fix was pretty ham fisted so I've changed it to have a lighter touch.\nIf you are using jQuery, it will fire a ready event so we don't need to also check the readyState of the DOM. This new fix allows a user to call can.route.ready as much as they want, but it will only be called once on page load.\n. +1\nAbsolutely agree that ready should have to be called explicitly. I'll create a new issue for that.\n. Fixture depends on can.object so you'll need to have that included before can.fixture. \n. This is fixed by #883. When 2.1 is released, you should change your template to:\n<li {{data \"item\"}}>\n    {{name}}\n    <ul>\n    {{#./children}} \n        {{>treeTemplate}}\n    {{/./children}}\n    </ul>\n</li>\nThe ./ keeps the lookup of children to the current scope instead of trying to walk up to parent scopes looking for the children property (and never finding it).\n. Fix is to strip out new lines so the second regex passes.\nWe could have changed the regex (.* to [^]*) to match across new lines, but this would pass a value with a new line to the special attribute setter which may not behave properly in some browsers.\n. #560 is fixed and an accompanying test was included in the fix. Closing\n. Firefox for OSX and Windows don't exhibit this behavior. Can you use the latest from minor and check again in your environment?\nI don't think this is the right fix because there is more logic in the overwritten methods compared to when you made this change. Also, as @justinbmeyer points out, this change means calls to pushState or replaceState (from another library for example) will not call can.route.setState so can.route will be out of synch with the window's history.\n. Still not a bug.\nIf you pass a function to append, jQuery will execute it and append the return value to the DOM docs.\nAs pointed out by daffl you should be passing the DocumentFragment to append, not the renderer function.\n. The can.mustache and can.ejs changes are going out with 2.1, but the context change will not.\n. This very issue is what #311 aims to solve. It's always felt a bit odd that defaults were not deep copied when a new instance was created. This would clear up that and allow mutable values to be specified in defaults and work as the use intended (not shared).\n. Final API decision was made to just add a warning if any mutable values are in defaults and re-evaluate this later after the define plugin lands (#819).\n. Wish I had read this issue a few hours ago before I fixed #679 to make the @ syntax work...\nSeems like all browsers now support the new syntax, so we'll make the change.\n. @colinexl Can you include your use case in this thread\n. I ran the tests on Android 2.2, 2.3, 4.0, 4.1 and 4.2 using Browserstack to verify the fix.\n. Thanks for the fix @janza. It will be going out in 2.1 so I had to create a new PR against minor instead of master.\n. Thanks for the fix!\nI incorporated it into #924 which just got merged into minor (2.1 branch)\n. Same issue as #887 which has a fix in PR #888.\nClosing this issue since all the activity for the fix is in the other issue.\n. This is covered by #192 which will add underscore/lodash helpers to can.List\n. Closing\naccording to @justinbmeyer \n\nThis can't be made to work and perform well. It's a chicken - egg problem. We can't have the element until mustache is processed.\n. thanks for the suggestion. I've moved this over to the canjs.com repo. \n. Merged into minor\nhttps://github.com/bitovi/canjs/commit/9aefb540ce80a8a5a8de4b03b9f96db8b4dfbfbe\nhttps://github.com/bitovi/canjs/commit/87011649f61f77cc0cb9e2187458ef1a16ef83c2\nhttps://github.com/bitovi/canjs/commit/a6017026c46243ee0dd4645d81a4deed0c14c8a2\n. Needs to go against master, closing\n. Issue is this line in stache.js\n\nIn your example, the indexOf check returns 0 which is falsey. This line should be:\njs\nif(\"'\\\"\\\\\".indexOf(character) !== -1) {\n. @portfolio-systems try to keep the discussion here on the issue at hand. It's tough to follow this thread when there a lot of text pertaining to unrelated things.\nThe canjs.com site is working along with the example in IE8. All I had to do was include HTML5Shiv version 3.7.0 or later.\nI updated your fiddle to include HTML5Shiv 3.7.0 and IE8 works. Here's the code and here is a link to the output of the fiddle you can visit with IE8 to test it out.\nThere's been a note about IE8 support added to the can.Component page\n. @whitecolor @justinbmeyer Is this fixed with #959 and #961?\n. Great! thanks for checking.\n. The shiv is mentioned in a few places. There is a note about it in one of the CanJS guides, but I think it's worth adding the same note to the can.Component page as well.\n. The link to the shiv you are using in your example was being served as text/plain which (I think) was causing your problems. I updated your example to use the latest version from cdnjs: http://jsbin.com/xojubo/1/ and it's working as expected.\nThanks for pointing out the error on CanJS.com. While our site was using the shiv, our example was not so you still got an error in IE8.\nI've added a note about IE8 support to the can.Component docs.\n. Fixed in master\n. Fixed in master\n. Fixed in master\n. Seems like a good idea to ignore registered special attributes, but that's an API breaking change so this would have to go in 3.0 right?\nAs for your other question... the handler for can.view.attris passed the element as the first parameter so you can retrieve any additional information from accessing the element's attributes. You also have access to the scope where you could have other data that changes the mixin behavior.\n. @dispatchrabbi Can you add a test for this fix\n. Fixed in master with https://github.com/bitovi/canjs/commit/033ef9e19e7510d2ac50f5d8188ccb2451db8d96\nWill go out in 2.1.1\n. I'll wrap this with the necessary tags to make it only work in dev mode.\n. @justinbmeyer good call, I've changed the helper to do the opposite of if, which is already doing things efficiently.\n. Fixed via https://github.com/bitovi/canjs.com/commit/71c87de95d689265579c312156da4014a7740e36\n. I noticed this in an app. Obviously, I can work around using target, but it is an API that is changing in 2.1.2.\nI noticed that none of the CanJS event objects are documented (probably a separate issue worth fixing) so yes, strictly speaking, target is not documented, but it is very common for an event to have type and target properties at the very least.\n. Just to see the effect, I made can.batch.trigger call can.trigger and saw a slow down of about 2% in the visual benchmark.\nWe don't necessarily have to make can.batch.trigger call can.trigger though. We could instead do something similar to what you did in model where you pass an object that has type and target instead of a string. In Map's case we would be calling can.batch.trigger, but it also accepts and event Object.\n. :thumbsup: +1\n. +1\nThis doesn't happen in stache.\nthe scanner does not ouput a call to can.view.pending unless the attribute has an =\nhttp://jsbin.com/varixuvawu/edit?html,js,output\n. The use case is highly reusable components that allow part of their templates to render a partial. Basically what shadow DOM's content-select would give us.\nA concrete example is an autocomplete component where the template that renders each result is passed in.\nWith 2.3.0 you still wouldn't be able to pass a renderer function to a Component without the can.compute.read fix. i.e I don't think this would work:\nhtml\n<can-import from=\"other.stache!\" #other=\"{value}\"/>\n<can-demo my-template=\"{other}\"></can-demo>\nEven if it was made to work without the can.compute.read fix, I'm using the CommonJS build with Browserify which is incompatible with can-import.\n. Example is in #2333\n. This can already by done using define\u2019s wildcard * to make everything type: '*' and then defining the Objects and Arrays as Observable by making them Type: can.Map or Type: can.List\nHere's a simple example: http://jsbin.com/zatodu/1/edit?html,js,output\n. I got it working after reading about some approaches someone else tried on SO\nI went with approach 3 which goes like this:\n1. In webpack configuration add the following to the resolve property:\nalias: {\n     'can$': 'can/dist/cjs/can.js',\n     'can': 'can/dist/cjs'\n   }\n2. Change @loader to raw! here and install the raw-loader dependency.\n3. Comment out this conditional\n. We could use Algolia.com which is what powers exponentJS, React as well as larger sites like HackerNews and ProductHunt.\nThere'd be some work on our side to make sure the docMaps we generate are indexed when we deploy the site.\nWe may be able to get a decent plan for free since this is for OS src.. This was added in 2013 here\n@justinbmeyer Ended a similar discussion with this\n\nIMO, an error is a different case than a ajax request fails to load. I'm not sure the try-catch was ever appropriate.. The code to handle this is in can.Component so it isn't specific to mustache (I don't think).\n\nI just migrated a project that used this with stache and it seemed to work there.. ",
    "neildcruz19": "Was this ever fixed for array attributes? I seem to be facing the same issue even in the latest version.\n. > The template uses the each helper to render the options of the select box, it turns out that these options are not rendered in the dom yet when the above code is trying to set the selected values. \nIs there a workaround to this? I'm having the same issue with the can-value not working for multi-selects the same way as it does for other input types.\n. Im seeing another issue with the can-value for select inputs in chrome maybe caused due to the element not being ready when the timeout occurs:\n// This may happen in some edgecases, esp. with selects that are not in DOM after the timeout has fired\nif (!this.element) {\n    return;\n}\n. ",
    "ecentinela": "Then, there is not any way to convert a timestring from the backend to a moment object using model convert/serialize?\n. This change will break something else?\nDid you plan to incorporate this for another release?\n. +1 for Bower compatibility\n. +1 for Bower compatibility\n. I don't know, but is really a problem. More and more libraries are being available from bower. CanJS should be too, to reach a bigger portion of developers.\n. I don't know, but is really a problem. More and more libraries are being available from bower. CanJS should be too, to reach a bigger portion of developers.\n. How is this being done by jquery team? \n. How is this being done by jquery team? \n. Thanks @daffl, it works perfectly!\n. Thanks @daffl, it works perfectly!\n. ",
    "jeffrose": "If you need guidance on adding optional AMD compatibility to code, check out https://github.com/umdjs/umd\n. I believe only jQuery and Dojo support it right now.\nYUI has it's own non-AMD loader.\nZepto seems unwilling to add AMD support at this time (https://github.com/madrobby/zepto/issues/342).\nMooTools seems to be in the middle of adding support (https://github.com/mootools/mootools-core/issues/2102).\nThat being the case, you could either not list those libraries as dependencies in your define() or make certain assumptions:\n- Developer is using RequireJS 2.0+ (or equivalent), which does not need loader plugins for non-AMD files\n- Developer has shimmed the non-AMD library in configuration (http://requirejs.org/docs/api.html#config-shim)\n- Developer used the name of the library in all lowercase as the module name\nThis would result in:\njavascript\ndefine( \"can\", [ \"zepto\" ], function () { return can; } );\ndefine( \"can\", [ \"mootools\" ], function () { return can; } );\ndefine( \"can\", [ \"yui\" ], function () { return can; } );\nThe only other choice would be to make it configurable in some way. That is, exclude the dependency unless the developer has set a value somewhere and use that value.\nDoing that would open it up to developers that are not using RequireJS 2.0+ as they could set the value to include loader plugins.\njavascript\n// Load Zepto using the WrapJS loader plugin in RequireJS < 2.0\ndefine.amd.Zepto = \"wrap!zepto\"\n...\nvar deps = [];\ndefine.amd.Zepto && deps.push( define.amd.Zepto );\ndefine( \"can\", deps, function () { return can; } );\nIn my example, I am bastardizing the define.amd (https://github.com/amdjs/amdjs-api/wiki/AMD#wiki-defineAmd) object a little. James Burke (@jrburke) might have a better suggestion.\nFor plugins, it should not matter as they only need to list \"can\" as a dependency.\n. Looking over my own reply, this may make more sense:\njavascript\n// Load Zepto using the WrapJS loader plugin in RequireJS < 2.0\ndefine.shim = define.shim || {};\ndefine.shim.Zepto = \"wrap!zepto\";\n...\nvar deps = [];\ndefine.shim && define.shim.Zepto && deps.push( define.shim.Zepto );\ndefine( \"can\", deps, function () { return can; } );\n. Thanks, James.\nThe reason for doing...\njavascript\ndefine( 'can', [], function () {});\n... instead of doing...\njavascript\ndefine([], function () {});\n... is that there is no single CanJS core. CanJS sits on top of various libraries, e.g. jQuery, MooTools, etc. If the module was anonymous, you would end up with a core module that has different names, .e.g. \"can.jquery\", \"can.mootools\", etc. unless you rename the core file you decide to use. For the sake of CanJS plugins, I would think there needs to be a single, core \"can\" module.\nI think hiding Zepto as jQuery is definitely the way to go.\n. Thanks, James.\nThe reason for doing...\njavascript\ndefine( 'can', [], function () {});\n... instead of doing...\njavascript\ndefine([], function () {});\n... is that there is no single CanJS core. CanJS sits on top of various libraries, e.g. jQuery, MooTools, etc. If the module was anonymous, you would end up with a core module that has different names, .e.g. \"can.jquery\", \"can.mootools\", etc. unless you rename the core file you decide to use. For the sake of CanJS plugins, I would think there needs to be a single, core \"can\" module.\nI think hiding Zepto as jQuery is definitely the way to go.\n. This issue has certainly grown bigger than I expected, though I am encouraged by the direction, i.e. being able require individual modules as well as CanJS as a whole. I understand this isn't a priority compared to other issues but I was wondering if there was a plan of attack? Is this something we would see in the next release?\n. This issue has certainly grown bigger than I expected, though I am encouraged by the direction, i.e. being able require individual modules as well as CanJS as a whole. I understand this isn't a priority compared to other issues but I was wondering if there was a plan of attack? Is this something we would see in the next release?\n. As part of this effort, it would be nice to see can/util/zepto/fill (and similar) broken up into separate files, like can/util/zepto/fill/promise, can/util/zepto/fill/ajax, etc. This would provide the flexibility of letting developers choose how to fill those gaps. For instance, using whenjs for promises.\n. As part of this effort, it would be nice to see can/util/zepto/fill (and similar) broken up into separate files, like can/util/zepto/fill/promise, can/util/zepto/fill/ajax, etc. This would provide the flexibility of letting developers choose how to fill those gaps. For instance, using whenjs for promises.\n. Yes, I was thinking you would create your own mapping in the RequireJS config to swap in the implementation you want to use for whatever can was expecting.\nAh, I see Deferred in can/util/deferred but I see the same code in can/util/zepto/fill (along with other code). I have to assume that can/util/zepto/fill must be built from multiple other files.\nI do agree that outside of something common like Promises and maybe some language polyfill (e.g. an implementation of Array.reduce), there's little that could be swapped.\nYup, I was just using can/util/zepto/fill as an example.\n. Yes, I was thinking you would create your own mapping in the RequireJS config to swap in the implementation you want to use for whatever can was expecting.\nAh, I see Deferred in can/util/deferred but I see the same code in can/util/zepto/fill (along with other code). I have to assume that can/util/zepto/fill must be built from multiple other files.\nI do agree that outside of something common like Promises and maybe some language polyfill (e.g. an implementation of Array.reduce), there's little that could be swapped.\nYup, I was just using can/util/zepto/fill as an example.\n. My current development stack does not include StealJS or EJS, so it would be nice if the solution wasn't tied to one of those but a feature of can.view\n. My current development stack does not include StealJS or EJS, so it would be nice if the solution wasn't tied to one of those but a feature of can.view\n. At the moment I am using jQueryMX with the intention of migrating to CanJS (and jQuery++) once #46 is resolved. Assuming AMD gets implemented throughout the CanJS, it seems likely that one could avoid loading EJS.\nI am not using EJS because at the time the development stack was chosen, jsrender met the requirements in terms of features and performance.\n. At the moment I am using jQueryMX with the intention of migrating to CanJS (and jQuery++) once #46 is resolved. Assuming AMD gets implemented throughout the CanJS, it seems likely that one could avoid loading EJS.\nI am not using EJS because at the time the development stack was chosen, jsrender met the requirements in terms of features and performance.\n. That's because console in IE8-9 is not a typical JavaScript object so it does not have the expected properties.\njavascript\ntypeof console.log.apply //--> \"undefined\"\nTry calling apply or call on the console method:\njavascript\nFunction.prototype.apply.call( console.log, console, [ ... ] );\nOr use bind:\njavascript\nvar log = Function.prototype.bind.call( console.log, console );\nlog.apply( console, [ ... ] );\n. That's because console in IE8-9 is not a typical JavaScript object so it does not have the expected properties.\njavascript\ntypeof console.log.apply //--> \"undefined\"\nTry calling apply or call on the console method:\njavascript\nFunction.prototype.apply.call( console.log, console, [ ... ] );\nOr use bind:\njavascript\nvar log = Function.prototype.bind.call( console.log, console );\nlog.apply( console, [ ... ] );\n. @rjgotten I haven't run into that personally (at least I don't think I have) but thanks for the tip! :-)\n. @rjgotten I haven't run into that personally (at least I don't think I have) but thanks for the tip! :-)\n. In general since you have the ability to set custom processors to handle other events, it stands to reason you may want to override the functionality of the default processor to introduce custom logic.\nIn my case I was looking to override to the value of this within the event callback, which has proven to be harder than expected.\n. @justinbmeyer Most of my experience with AMD involves RequireJS, so I can't speak for every AMD loader out there, but if all you want is Foo, you shouldn't have to require can and jquery too unless you want a handle to them.\njavascript\n// foo.js\ndefine( [ 'jquery', 'can' ], function( $, can ){\n    var Foo;\n    // Use $ and can to implement foo's functionality\n    return Foo;\n} );\nThen when you want to use Foo...\njavascript\nrequire( [ 'foo' ], function( Foo ){\n    // $ and can are loaded as dependencies in the background\n    // Use Foo\n} );\nI believe if you wanted to, you could actually do something like this...\njavascript\nrequire( [ 'require', 'foo' ], function( require, Foo ){\n    // Use Foo\n    // A need for $ has arisen...\n    var $ = require( 'jquery' );\n} );\n. @daffl From what I've seen all of the CanJS AMD modules, including Control and Model just return can. It's more typical for an AMD module to return a handle to the functionality it provides, e.g. can.Control, can.Model, etc. Since all of the functionality is added to a centralized namespace, I can see the argument for just returning can however it does lead to this scenario...\njavascript\nrequire( [ 'can/control', 'can/model', 'can/route', 'jquery' ], function( can, can_also, can_yet_again, $ ){\n...\n. I am looking in can.js.1.1.0.zip\\1.1.0\\amd\\can\\control.js and at the bottom of the file, it has return can; which seems in line with the define statement at the top which does...\njavascript\ndefine(['can/util', 'can/construct'], function (can) {\n. @rjgotten Cool plugin. Does it have an impact on how r.js bundles files? That is, does plugging libraries together lead to them being bundled by the optimizer?\n@justinbmeyer I certainly understand the laziness factor. If anything I think that speaks to the lack of IDE support. Listing off dependencies wouldn't be so bad if they could be autocompleted or even autogenerated by a quick code scan.\nIn general I've found the pros of being required to list off dependencies outweighs the cons. Your mileage may vary.\n. @rjgotten Cool plugin. Does it have an impact on how r.js bundles files? That is, does plugging libraries together lead to them being bundled by the optimizer?\n@justinbmeyer I certainly understand the laziness factor. If anything I think that speaks to the lack of IDE support. Listing off dependencies wouldn't be so bad if they could be autocompleted or even autogenerated by a quick code scan.\nIn general I've found the pros of being required to list off dependencies outweighs the cons. Your mileage may vary.\n. I hate to be \"that guy\" but when will 1.1.2 be released?\n. I hate to be \"that guy\" but when will 1.1.2 be released?\n. So you would only need a mapping if you wanted to use a library other than jQuery?\n. So you would only need a mapping if you wanted to use a library other than jQuery?\n. I ended up doing this...\njavascript\n\"paths\": {\n    \"can\": \"can-1.1.2-pre\",\n    \"can/util/library\": \"can-1.1.2-pre/util/jquery\"\n}\nMostly to cut out the library \"middleman.\" I was actually fine with being required to map a library (e.g. can-library in 1.1.0) but having a default file is fine too.\nI noticed that can/util has can/util/jquery as a dependency. I assume that should be can/util/library.\n. I ended up doing this...\njavascript\n\"paths\": {\n    \"can\": \"can-1.1.2-pre\",\n    \"can/util/library\": \"can-1.1.2-pre/util/jquery\"\n}\nMostly to cut out the library \"middleman.\" I was actually fine with being required to map a library (e.g. can-library in 1.1.0) but having a default file is fine too.\nI noticed that can/util has can/util/jquery as a dependency. I assume that should be can/util/library.\n. I would hope the two way binding is agnostic of the view engine.\n. I would hope the two way binding is agnostic of the view engine.\n. Sure\n. Sure\n. As much as I like underscore and lodash, take a look at amd-utils as well. It takes a different approach to organizing utility methods.\nhttp://millermedeiros.github.com/amd-utils/\n. As much as I like underscore and lodash, take a look at amd-utils as well. It takes a different approach to organizing utility methods.\nhttp://millermedeiros.github.com/amd-utils/\n. While it's not about consistency, I actually noticed another dependency-related issue. can/observe/compute does not list can/observe as a dependency but makes use of can.Observe.\n. While it's not about consistency, I actually noticed another dependency-related issue. can/observe/compute does not list can/observe as a dependency but makes use of can.Observe.\n. jQuery was kept in the global scope not for the sake of typing convenience, but for 3rd-party plugins that don't support AMD and expect it to be in window.\nhttp://bugs.jquery.com/ticket/10545\ncan does not necessarily have the same baggage.\n. jQuery was kept in the global scope not for the sake of typing convenience, but for 3rd-party plugins that don't support AMD and expect it to be in window.\nhttp://bugs.jquery.com/ticket/10545\ncan does not necessarily have the same baggage.\n. ",
    "jrburke": "@jeffrose by impression though is that only one can.* is used in a project at a time, so it is OK if they are anonymous. Also any module ID that is used for a named module should match the file name by default. But I'm still new to the expectations around the use of canjs.\n. @justinbmeyer there can be a top level can.js file that does all of those require calls and exports a module for those values:\njavascript\ndefine(function (require) {\n    return {\n        control: require('can/control'),\n        model: require('can/model'),\n        ejs: require('can/view/ejs'),\n        route: require('can/route')\n    };\n});\nSo if they want the whole thing, require 'can' instead of 'can/control'.\n. ",
    "saunders99999": "Hi, will this issue be resolved in the next release?\n. ",
    "patie": "+1\n. ",
    "guilambert": "+1\n. It does work with your workaround, thanks !\n. ",
    "jaxley": "+1, and Bump.  What is the status of AMD support now?\n. ",
    "rjgotten": "I would really like to know the status of this as well. Will AMD support make it for 1.1 ?\n. > Asynchronous can.view always returns a Deferred which resolves with the rendered document fragment:\nNo it doesn't. There's a not-so subtle bug with can.view(view, data, helpers, callback) which surfaces in cases where:\n1. view refers to a view that is not yet in the local cache,\n2. the data parameter is not a deferred object,\n3. a callback function is provided and\n4. you are using CanJS on top of jQuery\nThis will execute the following code path inside can.view.render around line 290:\n``` javascript\n// Return the deferred\nresponse = deferred;\n// And fire callback with the rendered result.\ndeferred.then(function( renderer ) {\n  callback(renderer(data, helpers))\n})\n[...]\nreturn response;\n```\nFor those who haven't spotted the problem that's about to snowball out of control: the resolved result of this deferred object will be the actual renderer function and not the HTML string rendered by this function.\nNow look at can.view itself:\njavascript\n// Get the result.\nvar result = $view.render(view, data, helpers, callback);\nif(can.isDeferred(result)){\n  return result.pipe(function(result){\n    return $view.frag(result);\n  })\n}\nInside the pipe method, result now wrongfully points to the renderer function, which will get pushed into $view.frag and eventually into jQuery.buildFragment. The latter expects a regular old HTML string and can't cope with the function. However, instead of throwing an exception it will fail silently and return an empty fragment instead. \nWhile this doesn't throw an exception when using jQuery on top of CanJS, depending on the underlying buildFragment implementation of the other selector libraries it may or may not throw for them. I haven't tested. I do know that the unit test suite for can.view as present in view_test.js doesn't cover this call scenario, which is probably why it has managed to persist for this long.\n. No problem. I had to dig in and solve this one for an issue in my own app anyway.\nI don't really understand what you mean by a multitude of requests and also needing to cache the renderer functions individually. Caching just the deferreds should be enough. When a deferred object is resolved the parameter values are cached internally, after all: any subsequent callbacks (done, fail, etc.) will always return these cached values. It shouldn't start up any new requests.\n(A race between downloading a template and requesting a template causing multiple downloads is exactly what moving the cache up-front sets out to solve.)\n. Aha. Now I see. No, my pull request didn't cover that particular scenario.\nFair note of warning; you may be susceptible to problems down the road in places where you assume Deferred will resolve synchronously. Plans to enforce Deferred always resolving asynchronously through an internal setTimeout call have already come up in one or more bug reports on the official bug tracker. Its a yay-vs-nay debate sofar, but there is some concensus on changing Deferreds to force asynchronous resolution as the default as long as either a local (method parameter, I assume) or global override toggle is provided to allow the old behavior for backwards compatibility.\n. > Talk about crazy generated code. You'd have to wrap every prop access in something that checks if a deferred and has a callback to run when resolved. I don't think that's actually possible.\nIt's really that hard to do? Just off the top of my head here:\nI assume there's some kind of central part of logic in EJS that performs an array push of some content coming from <%= %> tags. Right now you probably have a != null check and a toString call in place before pushing the item into the array for final assembly, or something similar.\nRight at that point you could place a check for can.isDeferred and, if that evaluates to true, instead of a simple item.toString you do:\njavascript\n__view.push(( function( index ) {\n  var item = item.pipe( function( result ) { __view[index] = result; });\n  __view.deferreds.push( item );\n  return item;\n})( __view.length ));\nThen at the very end, instead of the simple join:\njavascript\nreturn can.when( __view.deferreds ).then( function(){ return __view.join(\"\"); })\nThe only thing I can think of that would make this go lopsided is if a user creates a template with al done callback on a deferred object and from that callback directly adds content to the view, instead of returning it as a deferred result.\nIn that case the answer is simply to not do that!!\nThat kind of logic will lead to problems in (m)any view template engine(s), also including serverside ones; even the ironclad compiled and strongly-typed ones like ASP.NET MVC Razor. If your language supports closures, then in general you cannot prevent it from happening. It can even happen right now in EJS, if someone gets the bright idea to use setTimeout from within a view.\nThe only way to really prevent it is to write a JS lexer/parser combination that recognizes deferred objects and then generate a new __view 'string stream' for each deferred callback, processing it accordingly and integrating it into the main stream at the correct position. Indeed, that's where you'd get into mountains of code generation and transformation.\n. I'm not suggesting you magically resolve deferreds synchronously in that way. (That would be under-the-hood voodoo equivalent to C# 5's async and await keywords.)\nI'm only suggesting that you allow deferreds to be directly written to the array serving as the view's 'output stream' and that you postpone the final join on this array until all deferreds in it have been swapped out with their resolved values. This would immediately allow a view that renders partials like\n<% models.each( function( model ) { %>\n  <li><%= can.view.render( \"listitem.ejs\", model ) %></li>\n<% }); %>\nto work without requiring synchronous XHR. If you happen to have a whole model hierarchy composed entirely of deferreds (i.e. a lazy tree?), you simply split your rendering into partial views at each level of deferred. Effectively, each view will asynchronously require its child views to finish work before propagating the result up (which means each view itself returns an asynchronous result through a deferred object). The top level call  to can.view also returns a deferred object that eventually (when the entire tree of partial views is resolved) resolves to a document fragment containing the entire assembled view.\nThis completely does away with the synchronous pattern of returning a string from can.view and makes the behavior of your code much more predictable. It's simply always async and always returned as a deferred resolving to a document fragment, instead of the current situation where the synchronous or asynchronous return value depends on whether the model is or contains a direct child property that is a deferred object, and whether you provide a callback.\n. Just another heads up: the current intention is for Deferred to always resolve asynchronously starting with jQuery 1.9 and to move the synchronous XHR support into a legacy compatibility plugin.\nSee http://bugs.jquery.com/ticket/10467#comment:14\n. Regarding this fix:\nCalling a function with one argument that is an array is nowhere near the same as calling a function with an array of multiple arguments! Very nice for you that it happens to work out for this single instance of console.log, but as a general solution it is completely unfit.\nYou can (and should) work around the lack of call and apply on host object methods in IE by applying the method to Function.prototype.call. Using the additional layer of indirection, you can still use a variable number of arguments. E.g.\njavascript\nfunction log() {\n var args = [ console ].concat( [].slice.call( arguments ));\n Function.prototype.call.apply( console.log, args );\n}\n. A map operation is supposed to work as a projection, which means it should be able to produce lists of a different resulting type. The strongest type Observe.List.prototype.map can safely return is a vanilla can.Observe.List. Anything else is plain wrong.\n. You have to use\njavascript\nFunction.prototype.call.apply( console.log, [ console, ... ])\nor IE 8 might still freak out. While it has no problems with Function.prototype.call being used with host object methods, it seems to still have sporadic issues with Function.prototype.apply. It does, however, have no issue with applying Function.prototype.call to a method through Function.prototype.call.apply (since you are applying call and calling the host method, not applying the host method directly). In that way you can still bake in support for a variable number of arguments.\nHow's that for Internet Exporer being convoluted!\n. Explicitly specify the contentType option using an object literal notation for the CRUD API methods on can.Model. E.g.\njavascript\ncan.Model(\"my.Model\",\n  /** @static */\n  {\n    update: {\n      type : \"POST\"\n      contentType : \"application/json\"\n    }\n  },\n  /** @prototype */\n  {\n  }\n);\nHandle JSON encoding of the data by registering a jQuery.ajax prefilter to serialize the original data parameter as JSON for requests that have an applicable content-type ( i.e. \"application/json\", \"application/json+foo\", \"application/json; charset=utf-8\", etc. ) and an applicable http method (i.e. \"post\", \"put\" or \"delete\").\n``` javascript\n$.ajaxPrefilter(function(options, orig, xhr ) {\nif ( options.processData\n    && /^application\\/json((+|;).+)?$/i.test( options.contentType )\n    && /^(post|put|delete)$/i.test( options.type )\n  ) {     \n    options.data = JSON.stringify( orig.data );\n  }\n});\n```\nImho CanJS should probably bake something in to handle this for you. You can make a prefilter specific to only certain data types, so the default data type for the ajax maker functions in can.Model could set a \"can.Model\" data type to prevent pollution of other non-model requests. It's all perfectly capable of being encapsulated correctly.\nThe clincher is the support for JSON deserialization on the server side. It's very much a breaking change to alter the default behavior like this, so it should probably be a control switch somewhere (or just an officially sanctioned plugin...)\n. 0330191 doesn't quite deal with the whole problem.\nYou'll still run into problems with can.Construct derivatives, or anything else that is not a plain JS object or array for that matter, being crawled and turned into can.Observe instances, when that is most likely not what the user wanted.\nIssue #45 exposed this design flaw in can.Observe months ago and the same solution was proposed then: clone or use  jQuery.isPlainObject. Fixing this problem that way will resolve said issue as well.\n. >  I need to schedule some time with you to see what you are building and how you are using delegate.\nIt's not something I directly needed. I just noticed the potential problems with the delegate grammar when I started making other changes to the delegates plugin. Figured I might as well report them. Glad to see the issue resolved though, as it pulls the capabilities more in line with the attribute selector support in DOM query selectors. And if nothing else, it adds an additional layer of polish to the delegates feature. \n. Nice. I'm working on another pull request for can.Observe.delegate as well.\nIt contains some of the fixes you're presenting in this pull request, but not all.\nIt does however support more complex selector patterns with ** wildcards inbetween, such as foo.**.bar. This kind of selector comes in very handy when you have to listen for changes to a specific property on a recursive data structure. \nIt's really quite easy to assemble and cache an efficient regex to handle these kind of selector matches as well. Why the current matcher uses the custom hand-coded loop over split strings is beyond me...\n(Also; my pull request will fix event.currentTarget, from #123 as well. It appears to be trivial to fix.)\n. > Related discussion here: http://forum.javascriptmvc.com/#Topic/32525000001079097\nI really don't feel like signing up for Zoho just to make one comment in those forums, so I'm responding here:\nI'd favor something a little less generic and ambiguous than can.Observe.start or can.Observe.stop. Neither makes any kind of reference to what is being started or stopped. To make matters worse, the function name and semantics are also conflicting: stop starts capturing and start stops capturing. \nWhat about something like can.Observe.collate and can.Observe.dispatch? Those seem much more clear in intent and the name and semantics are in line with one another:\n- collate collates events into a single batch for later dispatching, and\n- dispatch dispatches a previously collated batch of events.\nAlternatively, you could use uncollate instead of dispatch to achieve a symmetrical API.\nOther than that; great! More direct control over batching changes is something that could solve some performance issues I've been having.\n. > Just wondering, what are you overriding the processor with?\nChiming in because I've run across the same problem.\nIn my case, I wanted to replace / extend the basic processor with one that would allow applying modifiers to events similar to AMD loader plugin syntax; i.e. \"modifier!event\". These would have allowed me to inject logic to throttle or debounce event responses in templated event bindings on controllers in a very clean fashion.\nHowever, as it turned out the basic processor is not the only internal-only construct involved; it depends on a whole lot of other internal-only constructs that made it completely impractical for me to write my modifier logic. I blew it off...\n. > now, I'm actually that lazy I don't want to add 'jquery' to get a handle on it. \nAs can.$ refers the original selector library:\n``` javascript\ndefine([ \"can\" ], function( can ) {\n  var $ = can.$;\n// Use $ (i.e. jQuery) here\n});\n```\nAlso, if you want to load a main library and don't feel manually requiring all manner of additional dependencies the whole time to make sure it has all its 'plugins' / 'extensions' / etc. applied, then I've got you covered with a little AMD loader plugin.\n. > That is, does plugging libraries together lead to them being bundled by the optimizer?\nIt bundles them in the correct order when used through the r.js optimizer, yes.\n. If you require a module through a URI that has a file extension attached, then said URI will be used untouched as the direct URL from which to retrieve the resource.\nThat means the URI:\n- will not be processed by the maps config,\n- will not be processed by the paths config,\n- will not be resolved against the current module URI, and\n- will not be resolved against the configuration base URL.\nBasically; all URL resolution built into your AMD loader will be skipped.\nAs a rule of thumb, you should never specify the file extension as part of the module URI, unless you are hard-linking to a very particular file location, which is most often when you are loading plain (non-AMD) JS or non-JS resources. (In case of the latter you'd almost exclusively be using a loader plugin for that particular family of non-JS resource as well.)\n. @daffl If you're worried about path remappings, then a not-so-easy but more bulletproof way out is to create a loader plugin that handles switching between the various selector libraries and to configure it using module config.\nGiven a simple loader plugin can/util/lib.js :\n``` javascript\ndefine([ \"module\" ], function( module ) {\n  var lib = \"./\" + ( module.config().lib || \"jquery\" );\nreturn {\n    load : function( name, require, load, config ) {\n      require([ lib ], load );\n    }\n  }\n});\n```\nand an application configuration:\njavascript\nrequire.config({\n  config : {\n    \"can/util/lib\" : { lib : \"zepto\" } // want zepto instead of jquery\n  }\n})\nYou could have can/util.js import a configured library through the plugin:\njavascript\ndefine([ \"./lib!\" ], function( lib ) {\n});\nThis is similar to how the RequireJS optimizer dynamically loads dependencies for either the NodeJS or RhinoJS environment. (I'd also recommend using module config to decide on whether to inject the window.can global or not, if you aren't doing so already.)\nAlso note the use of relative paths; if you have all the CanJS components use a relative path, then you can easily move the entire library around your project structure.\n. > How to deal with context?\nOne of the biggest powers of can.compute is that it performs computations in the scope of this if no context is supplied, which means it can easily be hooked up with can.Observe subclasses to provide computed model properties. You want to keep that level of statelessness intact.\nIf you need to bolt on stuff that looks like a resolve/reject, then take a page out of jQuery.Deferred's book and pass the created compute as the first parameter:\n``` javascript\ncan.compute( function( compute ) {\n  var a = this.attr( \"a\" ),\n    b = this.attr( \"b\" );\nif ( b === 0 ) {\n    compute.error( \"Divide by zero\" );\n  } else {\n    compute.solve( a / b );\n  }\n});\n```\nThis will break the current syntax, but imho it is the only way to do it that:\n1. makes sense syntactically,\n2. is easily extendable in the future (without leading to parameter bloat), and\n3. retains the current level of statelessness.\n. You're already storing the last computed value in computedData.value right? So; couldn't you store computedData.errors as well?\nCurrently when you execute a compute it will return the computedData.value if it is available and will execute getterSetter otherwise. You can extend computes with a new member method errors, which will mirror this behavior by returning the cached computedData.errors array, or running the compute's getterSetter if it's not yet available.\nI think if you add this on, you have something which facilitates all the use cases, while remaining clean and isolated.\n. Ah! I missed that bit, indeed. (Never could get used to the fact that computes are bidirectional; usually when you have them, they are read-only.)\nWell, you can make this new errors member method a get/set method, similar to the errors from the can.observe.validation plugin. When called as a set method, have it signal the compute pipeline in some way that it is not going to be setting an actual value, but is in a dry-run / test mode. Easiest way to accomplish this is through a global/static flag which, when set, would prevent any of the read bindings to computes from being triggered, would not update the compute's current bindings, etc.\n. > Is it even necessary to support this kind of functionality?\nIt isn't and it also shouldn't be created.\nYou don't want the overhead of observability attached to a general purpose flow control construct such as a Deferred object, which can be used in lots and lots of other parts of code than just the line of data that is fed to your view bindings.\nAs I commented in #1207, if you really want observable result values from a Deferred object, you should wrap a custom can.compute around the Deferred object beforehand while preparing your view model. I reached the same conclusion you did; there's no reason you couldn't accomplish this with an asynchronous setter on can.compute.async.\n. > I think this feature is a bad idea as well. This feature promotes using model / controller type functionalities (data retrieval) into your view. It just promotes bad architecture. \nHadn't even considered this part yet, but yes; that's true. It does tempt people to push the definition of responsibilities that should lie with controller or model into the view. From an application guidance standpoint, that's quite bad.\nAn explicit wrapping around a Deferred that you want to have observable atleast has better odds of being set-up in the correct location: as part of the definition of the (view)model. Let's please not have findAll calls complete with entire parameter sets hidden away in a view template...\n. > Optimally I would like to have a template like:\n\n{{#if foo.isPeding}}\n    ... show loader\n{{else}}\n    ... show foo\n{{/if}}\n\nAh, but that doesn't cover error states, now does it?\nIf you go down this road, then the generalized pattern you are looking for is essentially a tri-state switch for pending, resolved and rejected states. And that's something atleast jQuery.Deferred offers with the state() method returning one of \"pending\", \"resolved\" or \"rejected\".\nLet's go with the above idea from @Bajix that the define plugin's getter is given some special handling for promises:\n\nIn this scenario, if the getter returns a deferred, we'd wait until it resolves before updating the getterValue, which is what will be returned when calling attr. This gives us very desirable getters, and change events. We then would expose a promises attribute that has a hash map of all of the deferreds.\n\nUsing real asynchronous getting/setting and having an additional hashmap of all 'map attributes that are promises', is rather cumbersome. Rather than having the model attribute return null while in a pending state or the resolved value when not, why not have the getter detect a deferred and then always return an object literal composed of three computes:\njs\n{\n  state  : ... // Returns one of  \"pending\", \"resolved\" or \"rejected\".\n  value  : ... // Returns a resolved or rejected promise's first argument value.\n  values : ... // For multiple argument values on a promise. (Always returns an array.)\n}\nThis allows you to easily switch visibility of loader elements or classes using the state member separate from having to compare the whole value to null. This means you can also work with explicit null values returned from promises, which you otherwise could not. (Asynchronous work with no real result value can, infact, be a thing. I've needed it on multiple accounts.)\nYou could also incorporate support for things such as the progress callback handling on jQuery.Deferred into this, by having value set to a numerical value [0..1] or [0..100] while state is set to \"pending\".\nI see that can.stache doesn't have switch/case statements (yet?), but let's for sake of argument say it does (and let's simplify things by saying you cannot fall through cases that are not empty, making a break statement superfluous). A full example demonstrating how it all comes together would then be:\n{{#switch foo.state}}\n  {{case \"pending\"}}\n    <span class=\"busy\">Loading: {{foo.value}}% complete</span>\n  {{case \"rejected\"}}\n    <span class=\"error\">Unexpected error: {{foo.value}}</span>\n  {{case \"resolved\"}}\n    {{#if foo.value}}\n      <span class=\"success\">{{foo.value}}</span>\n    {{else}}\n      <span class=\"empty\">No result found</span>\n    {{/if}}\n{{/switch}}\n. @bmomberger-reciprocity Thanks for clueing me in on the switch helper being brewed there.\n@justinbmeyer Those special keys make it look kind of nice, I admit. But that ties the interpretation of deferreds as computes back into the view engine, which takes away the possibility of establishing entire chains of computes that have 'deferred computes' as part of them.\n@gsmeets Regarding the kludge you're currently using for the async fetched model; have a look at a more complete version of the idea I presented in #1207.\nMaybe this is just what you're looking for to smooth things over in the mean time. (Do note: I still wrote this off the top of my head. So I hope there aren't any bugs left in there.)\n. @justinbmeyer On:\n\nA promise's .then method would call can.__reading.\n\nI still think you won't want that. If you have all promises call into can.__reading then that means all promises, including any chain of then operations, and not just the last one in the chain. The average findOne already chains up a number of then operations, so even the most basic use case has a few superfluous function calls and checks installed.\nThis is part of what I meant when I mentioned before:\n\nYou don't want the overhead of observability attached to a general purpose flow control construct such as a Deferred object, which can be used in lots and lots of other parts of code than just the line of data that is fed to your view bindings.\n\n\nThe flipside of too many calls to can.__reading is too little, and that is an issue with this approach as well. Calling can.__reading will only work from your own can.Deferred implementation.\nBiggest immediate issue with that is that you'll no longer be able to directly access and forward the jQuery.Deferred implementation. You could wrap a few of its methods to add can.__reading, sure, but as part of the chaining of promises, jQuery creates new instances for Deferred objects under the hood as well and you'll need to add layer upon layer of wrapping to account for that.\nBut that's just jQuery... That does not yet cover promise-like results from every other library under the sun that returns its own flavor of 'thenables'.\nI maintain that a user-controlled wrapping point where observability is added is the best solution that strikes a balance between usability and performance.\n. :+1:\nThis would really help with a few of my use cases, where I have additional post-rendering logic that depends on values from the model.\n. > So the problem occurs only when you don't use the render method.\nAnd no wonder: can.view internally wraps the result value from can.view.render with a piped Deferred that only preserves the first parameter. It discards any others.\nSee: https://github.com/bitovi/canjs/blob/f120881f312ecd854de36a89a83e9b7de7ed8c33/view/view.js#L13-L40\n. > The problem in the source seems to be that you can't just pipe deferreds that resolve with more than one argument.\nYes you can. It just requires that you explicitly create a new Deferred instance and call resolveWith or rejectWith on this new instance before returning it as the result value.\njavascript\ndeferred.pipe(\n  function(){ return can.Deferred().resolveWith( this, can.makeArray( arguments )) },\n  function(){ return can.Deferred().rejectWith ( this, can.makeArray( arguments )) }\n)\nIt's a bit more verbose, but no more expensive than what the underlying library's pipe method would be doing under the hood when it gets back a value that is not already a promise...\n. > We'll try and make it work with the 1.1.4 release.\nNot sure how far along you are for a solution, but FYI; you should simply be using the new jQuery.parseHtml function to parse HTML strings into jQuery-wrapped DOM element collections.\nShould you really need document fragments instead of element collections, then you can use the following trick:\njavascript\nvar node = jQuery.parseHtml( html )[0];\nvar fragment = node && node.parentNode;\nreturn fragment;\njQuery has a unit test in place which guarantees that the parentNode of the elements in the collection returned by jQuery.parseHtml is a document fragment.\n. :+1:\nI've found myself hooking directly into the internals that propagate change events through the model tree to accomplish pre-processing and cancellation before. It wasn't pretty to have to handle it that way. Having official support for this would be great.\n. +1 if you can make it drop existing templated bindings and re-attach them to the newly set value.\n. They are relative to the current file.\nAs long as all the CanJS AMD files use relative IDs, the only thing you need to host CanJS on a particular URL is one simple map instruction, e.g. :\njavascript\nrequire.config({\n  map : {\n    \"*\" : {\n      \"can\" : \"lib/can/main\"\n    }\n  }\n});\n. First off, addressing the concern of @stevenvachon :\n\nWhat would be the mistake in requiring 'can' relatively? The possibility of it being loaded in twice?\n\nAMD loaders should internally normalize any relative IDs to absolute IDs and then register and load modules by said fully normalized IDs. RequireJS does this correctly and you don't get double loading.\nNext up, a rebuttal for what @justinbmeyer wrote:\n\nInstead, you always should require('jquery').\nThe same thing is true of can. Modules should never be relative in distributed projects.\n\nNo; that's a bad practice started by jQuery and a few other libraries that was cargo-culted into common accepted use for third party libraries. It has always been recommended to use anonymous modules and relative paths. Ask James Burke; the author of RequireJS, and I'm pretty sure you'll get a similar answer.\n\nYou should not be using map, you should be using path. It should only require one simple path instruction to change the lookup of \"can\" to wherever you want. Something like:\njs\nrequire.config({\n  paths: {\"can/\"  \"lib/can/\"}\n});\n\nThe paths configuration is meant for setting up a mapping at the physical file level.  Basically, you're lying to your application about where the CanJS files are located. It does NOT remap module IDs and does NOT factor into the normalization of module IDs.\nThis means that:\n1. it breaks the resolution of relative module IDs, and\n2. Should someone now request \"lib/can/\" in your application somewhere, it will be treated as a different module and you will infact be getting aforementioned double loading that you would not get with map configuration.\nAnd in closing to answer @stevenvachon again:\n\nI hadn't thought about parent paths; they kind of smell; though, not sure like what : )\n\nPray tell; how do parent paths smell more than hardcoded rooted paths requiring the mis-use of an explicit configuration flag that opens up the possibility of duplicate loading?\n. Going up four path levels is a very pessimistic case that should almost never occur. And if it does occur, then I'd argue the application or library where it occurs is not organized correctly.\n. Not 'very hard' at all: From the looks of things, the only required change to the can/observe/attributes plugin is that the default type converter act as a direct passthrough when its type parameter is null.\nThe above change would finish completely wiring up the plugin to ignore a null value for an attribute type in its converters and serializers, setting them to act as the default direct value passthrough. If can.extend indeed completely mirrors jQuery.extend, then only undefined values are skipped when merging object literals; null values should still be merged over any previously established values.\nProvided that the above holds, a very simple pattern allows you to reset the converter and serializer for an attribute by passing null as the attribute type during inheritance:\n``` javascript\nvar BaseObserve = can.Observe({\n  attributes : { \"value\" : \"boolean\" }\n})\nvar InheritedObserve = BaseObserve({\n  attributes : { \"value\" : null }\n});\nvar base = new BaseObserve({ \"value\" : \"false\" });\nconsole.log( typeof base.value ); // \"boolean\"\nvar inh = new InheritedObserve({ \"value\" : \"false\" });\nconsole.log( typeof inh.value ); // \"string\" instead of \"boolean\"\n```\nSure, you won't be able to get rid of the attribute entirely, but resetting its converter and serializer effectively does the same thing. All data members, also those not marked up explicitly as attributes, are still made observable by can.Observe and by default it will still serialize all those observable members back into a raw object.\nFrom a less pragmatic and more theoretical standpoint, some thoughts you may want to consider are:\n1. how messed up your application architecture has to be to require undefining part of a class for inheritance,\n2. if you should care to support that kind of crazy scenario and all the cans of worms* that come with it, and\n3. if, from an implementation guidance point of view, it would perhaps be wiser to steer your library consumers away from adopting that kind of design...\n*) sound polymorphism goes out the door, for one\n. This makes sense if you want to turn something that will have asynchronous value changes that are incompatible with can.Observe or can.compute into a computed property.\nFor instance, you could be wrapping the creation of a can.Deferred into a can.compute where you want the computed property to update when the deferred object resolves or rejects. Wrapping a deferred object into a computed property makes it work with live binding, which is awesome for partial view updates with spinners while content is still loading.\n. It would be used to force the computed property to update as if a dependent can.Observe would have fired off a change event.\nE.g.\n``` javascript\n(function(){\n  var defer, computed;\nreturn computed = can.compute( function() {\n    // First time running the compute, grab something that is a can.Deferred.\n    // E.g. a model instance.\n    defer = defer || SomeModel.findOne({ id : \"foo\" });\n// If the can.Deferred is still pending, register the compute to push out a\n// change event and notify depending computes when the can.Deferred\n// does eventually resolve or reject.\nif ( defer.state() == \"pending\" ) {\n  defer.always( function(){ computed.trigger(); });\n}\n\nreturn defer;\n\n});\n});\n```\n. :+1: but only if you expand the scope of the feature to include validation/acceptance based on functions, so that you can specify generic route constraints.\n. I can work on providing a reduced test case on Monday.\n[EDIT]\nI've already produced a working patch for this, so instead I'll try to reserve some time during the course of this week to set up a pull request with an additional unit test to cover this particular scenario's breakage.\n. > Any news on this?\nNone yet. Other work with higher priority interfering.\nI'm going to set aside some time in the evening to get this done, I think, because it's been dragging for too long.\n. @justinbmeyer \nIt's related to the old way the view template and Deferreds were being fetched; there used to be a private-by-closure pipe function present to chain resulting Deferreds together. The template's string -> fragment conversion (and thus the binding hookup) was (indirectly) called from that function.\nThe current trunk version of the view API was restructured and no longer contains this particular construct. I think the bug also no longer surfaces, but I'd have to check.\n. There's a problem with the above approach of introducing a wildcard mapping this way. Your builder plugins run on the same require context as the actual build output. This means that any changes to that context's configuration affect the build output. In this case the module to which can/util/library was originally pointing is changed, which can result in one of two related problems: \n1. If can/util/library has not yet been requested by the build process before this builder changes the mapping; can/util/library will be requested using the remapping. The original library file that should have been part of the build output will not be. Instead the builder plugin specific file will be. This will break the built code.\n2. If can/util/library has already been requested by the build process before this builder changes the mapping;\n   can/util/library will remain pointing to the already loaded dependency and will infact not load the builder plugin specific file for use by the builder. The builder ends up using the regular file that is part of the build output and is likely only meant to be used in a web browser. This will break the build process instead.\nTo work around both issues, you need to load CanJS through a new RequireJS context that is separate from the main build context. E.g.:\n``` javascript\ndefine([ / ... / ], function( / ... / ) {\n  var _require, can;\nrequire = require.config({\n    context : \"can-require-ejs\",\n    baseUrl : require.s.contexts..config.baseUrl\n    map: {\n      '*': {\n        'can/util/library': 'can/util/optimize'\n      }\n    }\n  });\ncan = _require( 'can/view/ejs' );  \nreturn {\n    load : / ... /\n  }\n});\n```\n. >  I just do not agree on point 2. As I understand, config.map option can actually be used for run-time dependencies changes. That's why config.map is used in plugin builder instead of config.path to configure 'can/util/library': 'can/util/optimize' mapping.\nA mapping redefinition will do nothing if the module in question has already been requested and loaded. The reason you're not hitting case 2 in the plugin builder is likely because the r.js optimizer undefines any dependencies of a plugin or builder first, which ensures that they are reloaded with full execution. (Because r.js normally doesn't execute all the factory functions for all modules, only for plugins and plugin builders. You know about that, right?)\n\nOriginal can/util/library gets into the compiled JS file and I do see any issues with.\n\nAgain; the only reason the proper can/util/library gets pushed into the compiled JS, is because it was processed before your plugin builder was first hit and the dependency could be remapped. This does not have to be the case for every build setup.\nWhat you are doing is inherently unsafe and should not be accepted as a solution.\n. > Or am I missing anything?\nIt doesn't seem to have an actual AMD loader plugin anywhere in the source, so there's no way to, e.g., do:\njs\ndefine([\n  \"can/component\",\n  \"stache!./my-template.stache\"\n], function( Component, template ) {\n  return Component.extend({\n    tag      : \"my-component\",\n    template : template\n  })\n});\nand to have that transparently work with both development builds and optimized production builds.\nMaybe it's generated as part of the dist build, but I have no way to verify that, as installing the required dev dependencies with NPM to make a build, leads to a 100% reproducible EBUSY rename error on Windows. (NPM screws up the rollback phase of the failed fsevents optional dependency, it seems.)\nThere are also other issues related to loading stache templates via AMD, such as the fact that <can-import> doesn't support AMD-based module lookups. Doing that properly, i.e. , including all the AMD idioms such as relative module ID lookups; proper honoring of package, map and path directives and support for plugin loaders is non-trivial.\n. > @matthewp\n\ncan-import should definitely work with Requirejs, we detect if running inside an AMD loader and call the dynamic loader: https://github.com/canjs/canjs/blob/master/util/can.js#L198-L200 This logic is tested with requirejs.\n\nSimply using the global require entrypoint on the window is not sufficient. Like I wrote:\n\nDoing that properly, i.e. , including all the AMD idioms such as relative module ID lookups (...) is non-trivial.\n\nYou need some intermediate logic to create a require that is local and relative to the generated module ID of the stache template that was loaded through the loader plugin.\nYou have to go through a two-step require-chain to get that working; first use a loader plugin engineered to retrieve a require that is rebased to the module ID passed to the loader plugin, then use that rebased require to resolve the import. I.e.\njs\nif (window.define && window.define.amd) {\n  if ( parentName ) {\n    window.require([\"can/util/amd/rebase!\" + parentName], function(require) {\n      require([moduleName], function (value) {\n        deferred.resolve(value);\n      });\n    });\n  } else {\n    window.require([moduleName], function (value) {\n      deferred.resolve(value);\n    });\n  }\n}\nwhere the rebase plugin is implemented as:\n``` js\ndefine([], function() {\n  var\n    rootRequire = require,\n    hasUndef    = \"undef\" in rootRequire;\nreturn {\n    load : function(name, require, load, config) {\n      // Temporary collision-free name at the same relative\n      // directory level as the reference name.\n      name += \"#require\";\n  define(name, [\"require\"], function(require) {\n    return require;\n  });\n\n  require([name], function(require) {\n    hasUndef && rootRequire.undef(name);\n    load(require);\n  }, function(err) { load.error(err); });\n}\n\n}\n});\n```\n\n@gsmeets\nThat community member would be me. ;)\n\nIt keeps surprising me that when either of us sits down to engineer something, we always tend to arrive at a similar solution. (One thing tho': you might want to refactor your builder to hook up the intermediate AST that the build process generated, instead of having the client reparse the template. Seems wasteful. ;-) )\n. > The AST was just slower than the text.\nThat's slightly crazy and somewhat interesting. There's no reason that should happen from a code complexity point of view. So it has to have something to do with compiler optimizations.\nI wonder if it has to do with https://github.com/canjs/canjs/blob/master/view/parser/parser.js#L21 and the fact that Function.prototype.apply is called with the array of args stored in the intermediate representation. Using apply is substantially slower than a call with a fixed number of arguments, which internally desugars to the exact same operation as a regular function call and thus can be far more optimized. (I'm not kidding; it's up to 8x slower! )\nCouple with the fact that you're calling with a dynamic context, which might be a de-optimization trigger for the callee and you might just be inadvertently creating a terribly inefficient piece of code that way.\nI wonder what would happen when a set of intermediate functions that explicitly expands the item's args array to direct calls with the correct number of arguments for each token type is used instead.\ni.e. \njs\nvar arities = [\n  function(handler, item, args) { return handler[item.tokenType]() },\n  function(handler, item, args) { return handler[item.tokenType](args[0]) },\n  function(handler, item, args) { return handler[item.tokenType](args[0],args[1]) },\n  function(handler, item, args) { return handler[item.tokenType](args[0],args[1],args[2]) }\n  // ...\n];\nfunction handleIntermediate(intermediate, handler){\n  for(var i = 0, len = intermediate.length; i < len; i++) {\n    var item = intermediate[i];\n    arities[item.args.length](handler, item, item.args);\n  }\n  return intermediate;\n}\nI might just have to try that out some time. :)\n. >  I'm not sure it's super useful outside maps\nIt's useful beyond can.Map to support things like lazy loading certain content in views. E.g. displaying a spinner until an image has finished downloading. If the code is there and has to be maintained anyway, then I'd definitely like it to be sanctioned and available officially in its 'raw' can.compute.async form for those particular one-off scenarios.\n. > How would you use async for a spinner image on its own?\nWrite a component that has a can.compute.async.\nInside said compute, create an img element, hook up its img.onload and img.onerror to call setValue with the img element, then set the img.src property to start downloading the image and finally return null synchronously to indicate the 'loading' state.\nListen to the compute for changes. When a change occurs, wipe the existing children of the component's containing element and either append the newly resolved element or, if the resolved element is null, set a background image spinner GIF (probably as a data-uri to ensure it is available synchronously).\nThe value for the img.src property can be sourced from an accessor function brought in as a constructor option. In that way the component can be tied generically to whatever concrete can.Map subtype you may want.\nSure, you can hack this today as well; but it involves a substantial amount  of book-keeping you have to perform manually. Having can.compute.async directly available would remove that overhead.\n. > I would not do it that way. I would probably do it like\nDepending on the order in which the templating system creates the img element, sets its src property and binds the load event, you may or may not run into a race condition where load is never triggered for images arriving from cache.\nAlso; you're somewhat conveniently discarding the error handling case, which requires also incorporating a timeout somewhere for IE, as it does not reliably fire events for timed out image requests...\nLoading images async reliably is not something you can solve trivially from simple template markup like that. ;)\n. > As all of that happens in the same \"turn\", it should not miss load.\nIt could in IE, which resolves images from cache and executes any bound load event handlers synchronously; without deferring to the next tick. But anyway; this is already veering off-topic, the example was only meant to illustrate that there are still use cases where having can.compute.async directly exposed for use may be a useful thing.\n. > Thanks for reporting, but it isn't a breaking change as our API never documented that functionality. \nGreat. I wonder how many people will end up being subtly bitten by it though? A little warning might've helped there.\nMaybe you should just stop cold with the partial inheritance/overriding of jQuery and have a clean can root, where only $ still references back to jQuery. Certainly will help to prevent this kind of thing from occuring in the future.\nAlso; you should probably update the bit of API documentation that still says it works \"similar to jQuery.proxy\". That might create some false expectations as well.\n. Not sure if that was meant as snark. This whole thing seems to be quite a dirty edit though:\nBoth util/mootools/mootools.js and util/yui/yui.js continue to offer support for partial function application through the library functions your can.proxy method continues to call.\nIn Mootools, this happens through a Function.prototype.bind polyfill built into that library that you are calling and in YUI's case its Y.bind doesn't even attempt to use Function.prototype.bind internally, it just runs their own implementation always.\nOn closer inspection, these seem to be doing more or less exactly what jQuery was doing, so if jQuery's proxy \"was slow\", why were these particular implementations not scratched and redone as well? Or if they are fast enough, why weren't their implementations taken instead and the partial application functionality retained across the board?\nSeems some overly rash decisions were made here.\n. You could create a rather simplistic persistent caching wrapper to place around computes on a per-scenario basis, right?\nOff the top of my head:\n``` javascript\ncan.compute.cached = function( compute ) {\n  var\n    handler,\n    cached,\n    obj;\nobj = {\n    get : function() { return cached; },\n    set : function( value ) {\n      cached = compute( value );\n      return cached;\n    },\n    on  : function( update ) {\n      handler = function( event, value ) {\n        cached = value;\n        update();\n      }\n      compute.bind( \"change\", handler ):\n    },\n    off : function( update ) {\n      compute.unbind( \"change\", handler );\n    }\n  };\ncached = compute();\n  return can.compute( cached, obj );\n};\n```\nThis would achieve persistent caching of some computes, without leaking memory for all of them.\n. > At the moment you cannot bind validations in a template easily. .errors need to be an observable object that can be transparently used in templates.\nWhen .errors runs validations it already uses .attr to retrieve the attribute values that need to be validated. The entire thing is already observable if you wrap a can.compute around it.\n. @justinbmeyer \nI'm seconding @gsmeets here:\nAllowing validation a hard link into the view tier is a pandora's box: people will abuse that and application code readability; discoverability and reusability will suffer for it. I've seen it occuring far, far too many times to have any faith left that people can use such a shortcut responsibly.\nYou're validating attribute values set on a can.Map, that in this case just so happens to be updated via cross-binding to an <input> element. The actual <input> element does not factor into the actual validation cycle anywhere. Keep it that way, please.\nAlso:\n\na simple email validation\n\nNice that you picked up exactly this example, because it allows me to request an additional validation feature.\nAn oversimplified e-mail validator spitting out a hard error and not allowing a user to set a perfectly valid e-mail address is pretty much the poster-child of bad form-entry UX. (You do know that, I hope.)\nThe consensus is that if you perform client-side regex-based e-mail validation, the result should at most be a suggestive warning and never a hard error.\nSo; how about adding 'error levels' to validation while we're at it? Explicitly marking hard errors and soft warnings would make it a bit easier to wire up such operations as deciding whether a model is 'error-free' and fit to be processed further, e.g., when a user is working in a form that can be 'posted'.\n. > For me a model is either valid or not at any given time. The fact that I might want to show a validation message as you type or when you hit submit is a view concern, so this I would like to see declared in the view somehow.\n'On blur' is the default behavior; a cross-binding based on, afaik, the change event. You can change that to 'as you type' by having the cross-binding be established based on the input event. This event is not supported by older IE browsers, but can be fairly accurately polyfilled using their proprietary propertychange event. Have it as an option for the cross-binding; in the view.\nThe 'on submit' flavor is trickier. You could do it as an option on the cross-binding, sure: it could be based on the submit event of the form element inside which the input element resides. However, you cannot guarantee that there will be a real form element present. (It's kind of a good practice for screenreaders though.)\nStill, a better way to implement it is to enable users to toggle on/off the behavior where validation is run whenever a model attribute is updated. When the application user tries to perform a 'submit' / 'confirm' / 'save' / etc. action, a manual validate() call could pump validation one time.\nHaving such a toggle interactive would also support a scenario where validation feedback is live, but doesn't show until the first time a user tries to perform a submit-like action. One would simply flip the toggle back on when the application user performs the action and live validation feedback jumps back into action (based on either 'on blur' or 'as you type', depending on how cross-bindings are configured).\n. > I think CanJS might want to consider including this workaround into the framework \n:+1: \nI'm currently using my own workaround for the cited <img src=\"...\"> case but had just about given up on SVG.\n. Isn't this something the new can.compute.async can be used for?\nOff the top of my head, you could define a can.compute.when as the following:\n``` javascript\ncan.compute.when = function( compute ) {\n  if ( !compute.isComputed ) { compute = can.compute( compute ); }\nreturn can.compute.async( null, function( oldValue, setValue ) {\n    setValue( null );\n    can\n      .when( compute())\n      .then( function( result ) { setValue( result ); });\n  });\n}\n```\nAnd then consume it as such:\njavascript\ncan.compute.when( function() { return Reports.findAll({}) })\nInfact; this is even a good deal more expressive, as the 'inner' compute returning the promise can itself recompute based on other conditions, e.g. , updates of filter parameters on a can.Map:\njavascript\ncan.compute.when( function() {\n  return Reports.findAll({\n    sort    : params.attr( \"sort\" ),\n    offset  : params.attr( \"offset\" )\n  });\n});\n. :-1:\nWhile dirty checking enables you to write directly against raw objects even for browsers that don't support Object.observe, it is a major, major resource hog.\nI'd encourage you to read the Change Detection document describing how change detection is going to be refactored in AngularJS 2.0 just to come to grips with the expense and the effort involved in trying to keep a handle on the performance.\n. @stevenvachon \nObject.prototype.watch is detrimental to performance as it clearly states in red warning atop the MDN page and was only ever implemented in Firefox.\nAs for Object.defineProperty: cite a better jsperf test, please. The one you are citing now is fundamentally flawed as it counts the construction time of the getter/setter as part of the test body rather than the test setup. With only a small 1000 item loop, it contributes far too much weight and skews the run time, essentially making all of its test results worthless.\n(I wonder how big a percentage of the web developer community just takes jsPerf tests at face value, rather than having a look for themselves if tests are correctly implemented to begin with.)\nAlso, the watch polyfill cited on MDN is essentially flawed in that it does not work when the property in question is already a getter/setter property. It clobbers the existing property without providing a proper inherited call chain into the original getter/setter pair.\n. > Here is the same jsperf with construction time excluded\nWith construction time excluded and purely checking usage, you find out that anything not running on Blink & the V8 JS engine is up to 270 times slower in using a getter/setter property than a normal setFoo() function. Whether a property is defined using the deprecated __defineGetter__ and __defineSetter__ way or is  defined using the standardized Object.defineProperty way makes no difference.\n. >  Browserify can't do progressive loads easily. So it's less than ideal for big/complex projects.\nGot to agree with @justinbmeyer on this.\nAMD's async nature allows you to easily implement progressive loading.\nDeferring loading of code until its really become necessary is not just a performance improvement either. Sometimes it's downright necessary. E.g. Google Maps API offers a limited amount of views, so you want to be really conservative with loading both it, and any code depending on it (for example; custom map overlay classes) until it has strictly become needed to display a map view.\nMoreover, AMD is much more open in its loader pipeline allowing you to 'plug in' custom loading schemes. You can use it to hook in i18n resource strings, CSS files, etc. or perform any manner of complex pre- or post-processing.\nE.g. you could have a plugin that loads a view template, compiles it to a function and then returns that function as the loaded result. That same plugin can detect whether it's running in 'build tool' mode and in that case can inline the compiled function as a module definition itself, foregoing the compilation step in the browser for production code.\nCommonJS and how it's translated into one big chunk for consumption by browsers just doesn't compare. Browsers may be ready for CommonJS, but CommonJS is not ready for browsers.\n. > The purported benefits of AMD are just not necessary for the majority of use cases. We build a large, complex app using CanJS and Steal, and we don't do any async code loading.\nYour one complex, large app does not constitute the 'majority of use cases'.\n\nWhat browserify gives you is the ability to use npm as your dependency management tool. \n\nThere's nothing that limits the use of NPM to just Browserify and there is no magic integration between Browserify and NPM. You still have to manually install your necessary modules before you use browserify to build a combined file.\nYou can use NPM as a dependency management tool with AMD as well, as long as the modules you are installing with NPM are written with the existence of AMD in mind and do not naively assume CommonJS is the only system under the sun.\n. @whitecolor \nIt never worked that way because splitting the key on periods and providing deep/recursive/nested access happens inside the call to can.Map.prototype.__get whereas the call to can.__reading is made by can.Map.prototype.attr itself, before entering that __get method.\nThe behavior of can.Map where both a shallow or a deep fetch are supported is non-orthogonal with the behavior where only shallow binds are applied when accessed in a can.compute. I'd surely classify that as a bug. (And it's a pretty long-lived one as well; been there since day one of computes...)\n. You can't really set up a prototype chain where a class inherits from Function.\nThis:\nvar c = new can.Compute(1)\nwould never work, if you wanted to be able to execute c directly to grab its current value, e.g. var val = c().\n. Out of curiosity:\nHow did you solve the use case where you have a pipeline of then calls, where any of those calls are susceptible to using computed properties?\nIn such a case the chain of promises could, at any point in the chain, need partial re-computation and re-evaluation. You'd then only want to recompute the chain moving forward from the point where a change occurs in a depending computed property, because in general it could be unsafe or extremely wasteful to recompute the entire chain. (In particular when the chain involves one or more XmlHttpRequests taking place.)\n. Ah! So it's the underlying cache retained while a binding is attached that does the magic here.\nNice!\n(And yes; can.compute does kick ass. Well; as of CanJS 2.x anyway. The 1.x version was a bit of a letdown with the hard dependency on the then can.Observe. ;-) )\n. @daffl\nhttps://github.com/bitovi/canjs/blob/398f2dfcfcd401f637f957b37ff3b4b5cf63b9ab/map/validations/validations.js#L155\nNote the self.attr( attr ) bit there? That's what makes a call to errors observable, provided errors itself is wrapped inside a can.compute. The old EJS view engine wraps assignment-type code nuggets into one automatically, which is why it works there if you use expressions such as <%= obj.errors() %> in your views.\nI presume the stache engine is different?\n. @daffl\nThe risk in using Function.prototype.bind 'if available', is that it may have been polyfilled. (E.g. Modernizr contains a polyfill for it, built into the library.)\nThe reason CanJS has its own proxy method instead of straight-up re-using jQuery is the fact that the argument checking and currying that is part of jQuery's proxy method was deemed too detrimental to performance, because CanJs heavily leans on proxy internally and calls it many times.\nA fully compliant polyfill for Function.prototype.bind would be just as stringent in its checks (if not even moreso) than jQuery's proxy method and would undoubtedly lead to comparable performance characteristics and thus the same performance problems...\n\nCurrently it always returns a wrapper function\n\nNitpick: technically, Function.prototype.bind also returns a wrapping function...\njs\nfunction foo() {};\nconsole.log(foo == foo.bind(this)); // false\n. > Instead if Function.prototype.bind is used, you will see your original source function.\nFyi: maybe that's the case with Chrome and its development tools, but in Firefox with Firebug you get back a different function with its source display set to [native code] and no link to the location where the original function is defined.\nIf debugging is the big reason that makes it worth the trade-off, perhaps you want to consider that it won't improve the experience for everyone. Only for those debugging via Chrome. (And the behavior may change there at some point as well. It's obviously not part of a standard.)\n. Interesting: while that is what the current code does, does it make sense for the current code to do that in the first place?\nIf you have a sequence of an add and a remove event where the new value of the remove event is undefined, then shouldn't the old value of the add event that logically happens after also be undefined?\n. > i have found this line\n\nhttps://github.com/bitovi/canjs/blob/master/model/model.js#L517\nbut i am not sure if this is the right way\n\nThat seems unrelated, as it is the prototype setup for individual map instances.\nHave a look at https://github.com/bitovi/canjs/blob/master/model/model.js#L397-L404 instead.\nThose lines are handling the carry-over of the Map member onto the model list if you are passing a custom list type as part of the static properties.\nI should add that those lines are totally unncessary and a really, really wrong workaround for a bug that originates back in the static can.Map.setup that is called by the static can.Model.setup as part of the class construction/declaration.\nAllow me to explain ...\n\nThe base can.Map.setup sets up a can.List subtype with a 'strongly typed' Map member: https://github.com/bitovi/canjs/blob/master/map/map.js#L80-L85\nHowever, it does so by directly extending Map.List a.k.a. can.Map.List a.k.a. can.List, where can.Model needs subclasses of its own dedicated can.Model.List for its auto-magical item removal etc. to work as expected.\nHence the few lines I cited back at the start of this post are used to patch over that. However, that entire piece of patch code can be kicked out by altering the static can.Map.setup to extend this.List instead of Map.List. The class setup will then naturally extend can.Map.List for subclasses of can.Map and naturally extend can.Model.List for subclasses of can.Model.\nAs a bonus, this will also fix inheriting custom list types onto subclassed can.Map and can.Model, which is currently completely broken. (Infact; I patched this internally on the older build of CanJS I'm using with a few projects.)\n. > you said, you patched this in your own fork. can you create a pull request?\nI patched this in an old 2.0.x build that underwent customization to use a sane relative module ID lookups when loaded via AMD / RequireJS. The technical stuf behind it is probably not really of interest to you, but let's just say that the default way CanJS is shipped for AMD is hostile to proper integration with other code and goes against best practices.\nIt's impossible to create a pull request against current versions based on that modified production export without resorting to headache inducing cherry-picking. I'd sooner set-up a fresh re-patch in the current HEAD revision and that's saying something, because the last time I tried to author a pull request based on the HEAD revision, it was a world of hurt as well.\nI ran into issues even getting my fork set up correctly with working sub-dependency repositories and had issues with the used toolchain that required installing additional dependencies completely outside of the normal Windows OS workflow.\nUntil that gets cleaned/fixed and the barrier-to-entry for creating a pull request gets lowered, I'm not submitting one again, sorry. I simply cannot justify the additional time spent to jump back down that hellhole.\nWhoever on the core development team wrote this feature in the first place should be able to follow along with the notes I wrote and patch this. I assume they actually have their system configured for this.\n. > If you have some ideas on how to this in a better way I'm happy to hear it.\nCreate some form of bindable errors metadata-collection on the model and bind to that in your component. Update that collection of error metadata as part of a validation process that flows down the tree of the model hierarchy.\nThat way you avoid having to look up hard attribute names containing the full descending paths through the model tree.\nAnd if you're going to construct your own errors metadata, you want just want to go for broke and also create warning states as well, which is a rather big hole in the current state of model validation for such scenarios as reporting on possibly invalid e-mail addresses or possibly weak password strength in tandem with actual errors.\n. > This will typecheck for StealJS/SystemJS, RequireJS, to get the module loader baseUrl,\nThe base URL of the module loader is not necessarily the base URL of a website.\nIt's common to root JS module loader at a subpath holding scripts: http://www.example.com/scripts/, especially when using far future expires headers coupled with a cache-busting version in the path: http://www.example.com/scripts/1.0.0/\nThe domain/authority part is not necessarily the base URL of a website either as you can host individual applications inside subdirectories. E.g. http://www.example.com/apps/myapp1 and http://www.example.com/apps/myapp2.\nApplication-relative URLs (the term used by Microsoft, which has been using a leading tilde for these type of URLs since the first version of ASP.NET) are best handled in user code, by having users describe how the base application url should be mapped.\nE.g. using RequireJS, the following does the job:\nhtml\n<head>\n  <script>\n  // First create a module mapping for the '~' symbol to\n  // a domain-relative, protocol-relative or absolute root\n  // url. (Don't make it path relative! That won't work!)\n  require.config({\n    map : { \"*\" : {\n      \"~\" : \"/application/.\"\n    }}\n  })\n  </script>\n</head>\njs\ndefine([ \"require\" ], function( require ) {\n  // Then use the `require.toUrl()` method.\n  // In this case, it will produce \"/application/content/images/example.jpg\"\n  var fullUri = require.toUrl( \"~/content/images/example.jpg\" );\n});\n. @justinbmeyer \nIt should absolutely be using the prototype.toString method of determining whether a value is an array. The instanceof Array method fails where array data is communicated across window boundaries. (One window's Array is not another window's Array.)\n. console.log and its siblings are host functions in IE9 and below, which means they don't inherit from Function and don't have call or apply members themselves. There's a little trick you can perform though:\njs\n_logger: function (type, arr) {\n    // test for support\n    if (( typeof console == \"object\" ) && console[ type ]) {\n        // applying the call method works around the fact that the console object\n        // in IE9 and below is a host object whose methods are not of type Function.\n        Function.prototype.call.apply( console[type], [ console ].concat( arr ));\n    }\n}\nThis should work in any browser and shaves off some bytes.\nI mentioned this waaaa---y back in 2012 actually: https://github.com/bitovi/canjs/issues/109#issuecomment-8933388\n. > What is the real cause of this behaviour?\nThis is expected behavior.\nYou're fetching a can.Model with the same identity (\"ID1\") twice. The second fetch will take the already existing instance and update it with the newly received properties and values.\nIf you don't want this behavior, make C a can.Map instead of a can.Model.\n. > But it is a common thing to have two different items (obtained from different endpoints), but with the same id\nThey're not different. In both cases the type of the member c is C.\n. Reproduced in EJS, actually. (Yeah, this bug has been present since forever...)\nNot sure if stache or mustache hit the same code paths in can.view.txt.\n. @justinbmeyer \nhttp://jsfiddle.net/07zks0q1/2/\nFails in both EJS and Mustache\n. @pYr0x \n\nunfortunately ejs is deprecated and this is a \"wont fix\"\n\nYour own documentation seems to disagree with that. http://canjs.com/docs/can.ejs.html clearly states that EJS \"will still be maintained up to 3.0 and potentially after.\" That implies bugfixes will still be made.\nDeprecation means you stop further development (of new features) and recommend people to switch over to a future-proof alternative, pending removal of the old system. It doesn't mean a free pass to ignore bugs that leave the old system in a broken state in lieu of the newest most shiny toy in the toybox.\n. If you're willing to accept pull requests for bug fixes, I'll look into setting one up as I've I've managed to patch this issue locally already. (Wasn't that hard once I figured out where to look.)\nIs it still a hassle to check out CanJS and all its dependencies via Git on Windows? I tried this once before in the v1.1 - v2.0 timeframe and it was really annoying having to deal with subrepositories back then.\n. @matthewp \nDone and done.\nWhile the removal of subrepositories greatly simplfied things, you're indirectly using several native modules as dependencies. Those were an absolute pain in the rear to build (node-gyp and Windows is hell) but I eventually managed to skirt that minefield. Oh well. ^_^\n. @matthewp \n\nThanks! Can you add a test?\n\nDone.\n. @matthewp \nLooks like PhantomJS and only PhantomJS is failing on part of the test I added.\nWhen I ran it in an actual browser, the test passed correctly.\n. @matthewp \n\nUse getElementsByTagName or can.$ instead here.\n\nStill fails, I'm afraid.\n. @justinbmeyer \n\nHow are you running it in an actual browser?\n\nOpening the html file by hand from a test server instance, pretty much following what @matthewp is writing as well.\n@daffl, thanks for pointing me at the non-jQuery libraries. I'll have a look tomorrow when I have access to my dev workstation that has everything set-up.\n. @matthewp\nFound it.\nThe problem is not in the patch code or in the unit test.\nThe unit test is exposing an underlying weakness in the internal can.buildFragment implementation that is used for libraries other than jQuery. That implementation currently fails to account for some of the table-related special cases that jQuery's version of the logic does account for, among which are free colgroup and col elements.\nI'll patch in support for those two, but you may want to open up an issue to have that looked at in depth, because I think several other cases like the caption element are also not covered.\n. @justinbmeyer \nWhy not keep your old buildFragment logic and feature-detect the existence of the jQuery.parseHTML( data [, context ] [, keepScripts ] ) method, which is part of the stable public API?\nThe parseHTML method does everything $.buildFragment did, but it flushes the contents of the document fragment that it internally uses with $.buildFragment into a plain array of DOM nodes and returns that to the caller. (Note: DOM nodes; not elements, so it still contains text nodes, comment nodes, etc. as well.)\nSince you were cloning the cached fragment into a fresh fragment anyway, all you need to do with that array of nodes handed to you by $.parseHTML, is to pour it into a new empty document fragment of your own creation.\n. @akagomez \nIsn't it using the direct Array.prototype.splice in that location exactly because it's necessary to avoid the change events that can.List.prototype.splice triggers?\n. @dylanrtt \n\nDuring setup, it sets the data (an empty object in this case) and that eventually leads to can.each which calls keys(). I don't know enough about the internals of the framework to know whether adding __notObserve somewhere in the chain would be the best solution as opposed to something else.\n\nThe problem is that the setup method calls into Map.prototype.attr with an object-based setter. This takes the code-path to Map.prototype._setAttrs, which uses the observable Map.prototype.each instead of the non-observable Map.prototype._each when iterating over its current values.\nI'd say this is a general bug with tripping an observer hook during the map.attr({ ... }) method signature that just so happens to also surface as part of the constructor.\n(Setters are never supposed to be observed, right? Just getters...)\n. @meconcomputer\nIn IE console is a host object and its methods are not true JS functions that descend from Function.\nTherefore console.log has neither a call nor an apply method and even attempting to access them leads to a runtime error.\nYou can get a cross-browser compatible implementation via a little trick where you 'apply call', e.g. ,\njs\n_logger : function( type, arr ) {\n  if (( \"console\" in window ) && ( type in console )) {\n    var call = Function.prototype.call;\n    call.apply( call, [ console[ type ], console ].concat( arr ));\n  }\n}\n. It does.\n. > @matthewp \n\nIs new Function really more performant that eval? I wonder why that is.\n\nBecause it constructs an isolated function in the global scope. You don't have the possibility of outer functions' closure scopes influencing the function or vice-versa. Normally, to perform a lot of code optimizations safely, a JS compiler needs to be able to do static code analysis to figure out how to cope well with closures. Straight-up eval makes that impossible, but the isolation of new Function means that type of analysis is not necessary for a great deal of optimizations to still be safely applicable by a compiler.\n\n@justinbmeyer \nI'd like to see the difference between this and how non-evaled code currently performs\n\nWhile I don't have a testcase at hand, testing by Modus Create at one point showed new Function can be 50x faster than eval. And iirc one of the Chrome dev people once held a presentation regarding the internals of V8 stating that it could make up to a 100x difference.\n. Sure. I guess it'll be easy enough to build a perf-test for this: just take an array of a few thousand elements to convert to can.Map instances and compare the construction time with and without the named constructor added via new Function, right?\nI'll try to set some time aside next Monday to concoct something and get you some numbers.\n. @justinbmeyer \nOk. This is going to take some more time. I actually have a perf test case that I can run via jsPerf, but an asinine security service of Cloudflare sitting atop of jsPerf keeps flagging the test and keeps refusing it.\n. @justinbmeyer \nhttps://jsbin.com/decuzunowe/edit?html,js,console\nThe results may surprise: the named extend using the Function constructor is actually faster than the unnamed extend in both Firefox and Chrome for me. o_O\nFirefox:\n\"NamedConstruct x 749,776 ops/sec \u00b10.72% (62 runs sampled)\"\n\"UnnamedConstruct x 682,506 ops/sec \u00b10.55% (64 runs sampled)\"\n\"Fastest is NamedConstruct\"\nChrome:\n\"NamedConstruct x 1,417,250 ops/sec \u00b11.88% (63 runs sampled)\"\n\"UnnamedConstruct x 1,337,433 ops/sec \u00b11.24% (63 runs sampled)\"\n\"Fastest is NamedConstruct\"\nHowever, on a few different systems, the results seem to oscillate. Sometimes Unnamed beats Named and sometimes Named beats Unnamed. I'd say that's a good indication of the fact that the performance impact of using new Function to generate the constructor is negligible.\nThat's also what I'd expect, as the only thing that cannot be optimized is the actual constructor itself and the constructor itself immediately proxies all its work to the pre-cooked init function which can be optimized like any regular old function.\n. Would be great if you can get that in before the 3.0 version.\nRight now the 2.3.x builds are a bad enough mess that I'm seriously contemplating to AMD-ify my own package based on the CJS builds.\n. Ofcourse. I'm asking for another build configuration next to the existing amd and amd-dev; amd-strict, for instance. Not for a replacement of what's already there.\n. @gsmeets \nThanks. That will help.\n. > <can-import> should normalize based off the moduleName of the current file. Normalizing of the baseURL is less than ideal in a package (npm) workflow. \nYes please. \nJust as long as you also implement it for AMD/RequireJS, where you're not yet handling relative module lookups with can.import (which is what <can-import> uses under the hood, ofcourse).\nIncidentally, incase you're still puzzling on how to get that to work: there's a little trick you can use whereby you define a dummy module that is meant to extract a local require reference for a sibling-module of the original parent. Then you use the 'required require' to load the actual module you want.\nIn simplified code:\n``` js\ncan.import = function( moduleName, parentName ) {\n  parentName += \"?can-import\";\nreturn can.Deferred( function( def ) {\n    window.define( parentName, [ \"require\" ], function( require ) {\n      return require;\n    });\n    window.require([ parentName ], function( require ) {\n      require([ moduleName ], def.resolve );\n    }, def.reject );\n  }).promise();\n}\n```\nWARNING: Under no circumstance should you attempt to directly concatenate module names and canonicalize them yourself. AMD/RequireJS module name canonicalization is a lot more complex than that and involves a lot of indirection with map and package configuration.\n(Ofcourse, the above still won't solve the problem with optimized builds and grouping dependencies and inlined templates though; which will require a separate loader plugin and builder plugin for stache...)\n. @ccummings \nI'm going to somewhat echo what @RALifeCoach already mentioned; there's a substantial cost involved just with walking through all the properties of an object literal and publishing their values on an instance of a Map subclass.\nThis is biting one of our apps very hard, with approx. 6 seconds of processing time spent purely in up-converting properties to observable Map members and attaching live-bindings whenever those properites are accessed in a view, even though they never, ever change in value.\nIt would help tremendously if there were an explicit way to opt into skipping observable conversion of properties that are not listed in a define block and then also having live-binding logic be aware of this, so that non-observable properties accessed through Map.attr are given a non-binding fast-path, as if you were reading the properties directly off of a plain object literal.\n. @justinbmeyer \nJust so I have this clear:\nDefineMap subclasses use the static constructor to wire up the defined properties as JS getter/setter that add observability. And then any instances you create and feed data, i.e. new DefineMap({ foo: 1, bar : 2 }), work by assigning all the values to the instance, which will only kick in observability if that particular property already exists as a JS getter/setter.\nAnd there's a seal property which, when explicitly set to false, allows for 'expando' style maps with automatic just-in-time definition of a JS getter/setter for the incoming assignment, which makes DefineMap work like the old \"observe every property\" behavior in Map.\nIs that correct?\nAnd is this usable with CanJS 2.3.x or will this require waiting for CanJS 3.x?\n. @justinbmeyer \nThanks for the clear explanation.\nI'll keep this on my radar.\n. That's actually not the only problem with isArrayLike. It also attempts to use an undefined variable arr instead of obj when checking for a function type.\n. Uhm yeah; It's can-tag and not can-as. Sorry about that. Part of my notes was typed up against an older version of my code. I switched to can-tag after I saw it mentioned in one of the other three issues I cited. (I corrected my notes for future readers.)\nI can set up a pull request with the can-stache repository for 3.0. I'll have some time to work on that next monday. \n\nRegarding the 2.3 releases: I am still expecting to use this feature for a project running on 2.3, so if I'm looking at the possibility of merging the feature into my own private 2.3 fork, what would the odds be that patch releases for the 2.3 line will still contain large changes to view/stache/stache.js ?\n. @justinbmeyer \nHmm.. nothing problematic there, I think. It'd be somewhat annoying to have to insert the jQuery-wrapped collections everywhere, but that's not something totally breaking.\nThanks.\n@matthewp \nWith some work, maybe. Not sure how compatible that particular feature is with what I wrote to instantiate components off of a can-tag attribute. I think can-import actually does a bit more delegation under the covers with a promise and async loading, right?\n(Btw. I've been wondering: what was the reason behind implementing can-import as a tag rather than a helper? Seems like the wrapping tag is not actually needed for anything.)\n. @matthewp \nYes. That's the one.\nIn older CanJS versions you could (accidentally) set an explicit context by passing a context member on the settings object. If you did not pass a context member, the context would be set to the settings object itself.\nIn Can 2.3.x you can no longer pass a context member that way and the context is set to the can.Compute instance.\n. @matthewp \nA heavily, heavily(!!) trivialized example would be:\njs\nvar\n  obj = { prop : \"foo\" },\n  computed = can.compute( undefined, {\n  get : function() { return this.prop; }\n  set : function(value) { this.prop=value; }\n  context : obj\n  }\n});\nAs for real-world applicability: I developed a two-way binding framework for use with EJS, far before CanJS offered native two-way binding in (mu)stache, which offered custom binders acting as a kind of micro-controller to handle, e.g. two-way binding to range sliders, date-pickers, or <select> elements with dynamic <option> and <optgroup> members.\nUnder the hood, these micro-controllers were really just assembled into computes with added instance members and methods, e.g.\n``` js\nfunction makeFormBinder( element, options, type ) {\n  var\n    mixin,\n    nodeName;\nelement = can.$( element );\nif ( type == null ) {\n    nodeName = ( element.prop( \"nodeName\" ) || \"\" ).toLowerCase();\n    switch ( nodeName ) {\n      case \"select\" : type = \"select\"; break;\n      case \"input\"  : type = element.attr( \"type\" ); break;\n      default       : type = \"\"; break;\n    }\n  }\nmixin = {\n    element : element,\n    on      : function( update ) {\n      can.bind.call( options.element, options.event, update )\n    },\n    off     : function( update ) {\n      can.unbind.call( options.element, options.event, update )\n    }\n  };\noptions = can.extend(\n    {},\n    formBinders[ \"default\" ],\n    formBinders[ type ],\n    options,\n    mixin\n  );\nif ( options.init ) {\n    options.init();\n  }\nreturn can.compute( options.get.call( options ), options );\n};\n```\n. > @matthewp\n\n1) Light DOM should already have the template's scope when using leakScope: false. If not it's a bug.\n\nYes, it does have the template scope stack.\nThis issue advocates adding a way for a component to explicitly push another scope onto this stack, so you can opt to publish only part of an internal scope stack for use by the light DOM, instead of having to rely on leakScope:true which leaks all the internal state.\n\n@justinbmeyer \nThere is a slot proposal we can do this in.\n\nRefresh my memory; is that the one for which I offered my <can-region /> implementation as a candidate? If so; I still have to build this particular work I've done for <content/> into my region implementation anyway. I could kill two birds with one stone in that case.\n. Should script tags in general even be processed when inserted as nodes that are part of a document fragment?\n(Afaik jQuery contains some kind of workaround for this, but it's not a given.)\n. > I think there's few people left on AMD alone.\nPersonally, as long as there's still  a way to export CanJS in AMD format via pre-made build scripts, I don't mind a pre-built dist folder not being present. In that case it just trims the fat to not have it in the packages directly and it's just a few additional npm installs and CLI build tools away.\nHowever, if you're suggesting AMD users should roll their own conversion from CJS -> AMD entirely, then I'm not so sure I'd be happy about that.\n. I'm using CanJS v3 binding converters backported to CanJS v2. (Had to backport them myself as this is a slightly older build which didn't have them in it as an undocumented feature yet.)\nThey work fine when you register them globally using can.stache.registerConverter({ get, set }), however they fail if you attempt to register them locally -- I refactored the factory portion of registerConverter into a can.stache.makeConverter({ get, set }) --, for instance because you have a converter that is highly tied to a certain can.Component. E.g.\njs\ncan.Component.extend({\n  tag       : \"my-component\",\n  template  : ... ,\n  viewModel : ... ,\n  helpers   : {\n    \"component-specific-binding-converter\": can.stache.makeConverter({\n      get : function () { ... },\n      set : function () { ... }\n    })\n  }\n})\nThis kind of thing should not be a function on the view model, imho. If you don't want Call-type expressions to access the helpers collection, maybe you should have a separate methods collection, or converters collection? Something else which is explicitly not part of the view model and which is kept internal to the component itself.\n\nNote however, that this is not just a problem with two-way bindng converters. It's already a problem when you need to combine  a number of boolean conditions together in a certain way and one-way bind the result to the disabled attribute on an input element, e.g. ,\nmustache\n<input {$disabled}=\"combine(first,second)\"  />\nAnd I can imagine that ends up frustrating plenty of people.. @phillipskevin \nI fail to see how that would make any difference whatsoever. \nThe code that creates the data binding discards the Options instance on the scope stack. It creates a new, completely empty instance and passes that into the expression resolving code. Whether Call or Helper expression; it will be resolved against that empty instance. So any helpers that were not registered globally would still not be found when switching to helper syntax.\nThis also blissfully ignores the fact that helper syntax is incapable of handling nested expressions. You need call syntax and braces for that.... Yes, you can. But that is only another variation of having to tailor your model to work around the problem.. > Well, in my personal opinion always enforcing and having the developer assume that the root model is a can.Map is fairly intuitive.\nExcept that's not the case. It's currently only the case for scopes created for a component. If you push a plain object into a stache template, %root will infact be just that plain object, as it's supposed to be.\nA big problem here is that even if I have a Map subtype that uses { type : \"*\" } to define an unobserved plain object; if that plain object at one point touches a bit of rendering with another nested component, the remainder of the object graph will still be converted to a Map and be assigned as the %root of that subcomponent's view model.\nIt's infectious that way.\nThe only way to avoid that from happening from 'user land' is to create a special helper which takes the current plain object scope and creates a new Map scope with all known keys of the plain object set to { type : \"*\" } and to instantiate the subcomponent within that scope only. And quite frankly; that's INSANE.\n\nBesides; if the original root scope is not a Map to begin with, then what is there to gain from converting the %root token to one?\nAdding observability? Well; no. If the underlying data is not observable to begin with, wrapping it in a Map will do squat to make it observable.\nConsistent API? No; because stache itself allows all kinds of scopes, from plain objects to Map instances to computes. And if you write a general purpose helper, you should be able to handle all that. (Note: this is why there's a shared resolve method used by some of the built-in helpers.)\n. @justinbmeyer \nI'll see what I can do to make that happen.\n. @gsmeets \nWhile in CanJS 3.x the %root attribute is no longer present directly on Component viewmodels, Scope.prototype.read still recognizes %root as a special token, just as it did in CanJS 2.x, and still short-circuits it to the Scope.prototype.getRoot method.\nUnless I'm missing something, that should still produce the same root object for you.\n. If you want to use a simple one-token-only template language, why not look at how something like Microsoft's Razor syntax does it?\nIt's forward-parsable by heading code nuggets off with an @ and then using the semantics of the language (C# or VB.NET in Microsoft's case) to determine where the expression closes and when the parser should return to HTML mode.\n(It has some other features to it that you'd probably like as well, such as placeholder declaration and filling using @section or the possibility to declare re-usable parametrized template snippits inline as @helper functions. Seriously worth looking at for inspiration.)\n. > @phillipskevin \n\nWhy not a syntax that is JS instead of mostly JS?\n\nI'm going to turn that right back on you:\nIf you're going to eventually generate HTML, why not have syntax that is close to HTML instead of something that abuses nested callback functions, object literals and template strings?\nDon't throw out the baby with the bathwater, please.\nThe reason intermixed JS-like constructs with HTML markup are such a desired feature is because they give you the best of both worlds: you get a good picture of what your output is going to look like, while you retain the privilege of having virtually all the fine-grained control you want, when you need it. And you can forego that complexity when you don't.\n. > @phillipskevin\n\nI'm not really sure what you mean\n\nYour proposal uses JS syntax to express HTML semantics, or to put it in other terms: you are using JS as a DSL for HTML generation.\n\n@matthewp \nI think you're mistaken here, this proposal isn't JavaScript, it's something that looks a bit like JavaScript\n\nWhich is why I wrote JS-like constructs that give you virtually all the fine-grained control you'd want. JSX just pushes that idea to its logical extreme by intermixing actual JS with HTML markup.\n. I'm going to suggest that for inspiration on inference of what is code vs what is text, you have, again, a look at what Microsoft did with their Razor templating syntax, because they solved that pretty well.\nE.g. here's what Razor adapted to JS would look like when applied to the template @justinbmeyer had in this thread's opening post:\n```html\n\n  @for( let classRoom of viewModel.classRooms ) {\n    let teacher = classRoom.teacher;\n<li class=\"@classRoom.type\">\n  <p>Name: @classRoom.name</p>\n  <p>Teacher: @teacher.name</p>\n  <p>@if( teacher.hasKeys( classRoom )) { <text>No keys</text> } else { <text>Keys</text> }</p>\n  <p>@helpers.prettyDate( classRoom.startTime )</p>\n</li>\n\n}\n\n``\nRazor starts in markup context, at which point any leading@` sign flips over to code context. Inside a code context, any opening tag for an element flips back to markup context. Language semantics are used to determine when a tag-like string is actually a tag and when not. Roughly speaking that rule is \"anywhere a statement can be started\". \nTo place output text directly inside a code block without using and outputting a wrapping element, you have two options:\n\nyou can use a leading @: mark, which switches the line to markup context and switches back to code context on the next line; or\nyou wrap the text in a special <text></text> element, which outputs only its content and which switches back to code context after the element's closing tag.\n(This is what the example listed above uses.). Did you also ever resolve the problem where said polyfill must write to the global scope by creating window.Promise vs. having a clean module import without polluting global scope?\n\nSomething like\njs\ndefine( \"can/promise\", [], function() { return window.Promise; })\ncould implement the existing behavior and still be overridden, i.e. , remapped to a different module, by users that cannot risk polluting global scope. (For example: vendors of third party widget embeds.)\n. My $0,02 :\n\nArguably more readable\n\nIt's arguably far less readable. Pug presents a near-complete elimination of context that users need. The loss of HTML-like structured markup means there is a far greater gap between the template and the actual rendered result. This hampers users that use the output HTML as their mental model for reasoning about their templates' structure. \n\nSimpler syntax\n\nShort \u2260 simple. Overly terse syntax introduces complications in the semantics underlying the syntax and invites ambiguity.\n\nLess typing\n\nUse an editor with autocompletion and solve that problem at the IDE level.\n. > 3) No closing tags\nSo no more missing or mismatched closing tags.\nNo closing tags, so no way to visually track relative indent level.\nThe example you've posted already shows this problem in action. As a reader skimming the template, you have to actively put in effort to visually correlate the indent position between the first and second .form-group, whereas this problem does not exist in the more HTML-like stache template. The explicit closing tags allow users to easily pop a given number of nesting levels off of the stack they mentally keep track of.\n. Wouldn't this just be a matter of offering the data helper in a separate plugin module, or am I missing something more fundamental here regarding why it was removed in the first place?\n. You may reset the observation stack, but that won't fix corrupted application model state.\nImho, the only thing you'll accomplish by offering this type of functionality is telling a new generation of software developers that it's ok to \"On Error Resume Next\".\n. If log() is implemented via the common way of binding a change event, and is little more than shorthand for\njs\nvm.on(\"fullName\", function(ev, newValue, oldValue){\n  console.log(\"viewModel.fullName\", newValue, \"from\",oldValue)\n})\nthen imho that's no good. This in itself creates side-effects, such as computes entering a bound state and -- if I am not mistaken -- pulling an initial value from their getter in some cases.\nIs care being taken to make log() free of this side-effect? E.g. via some kind of privileged binding code which does not run the logic that would cause whatever it is listening to to enter its bound state.. > Oh, would it not be?\nHaving a single worker per class is a bad idea because each individual worker involves memory overhead and contends for CPU resources in the scheduler. Ideally you never want to create more workers than there are physical cores.\nThere is also overhead involved in the actual creation of the workers. To avoid blocking in those situations, you could maybe investigate setting-up creation of workers from inside another worker functioning as a broker. Possibly that would also allow you to instrument partitioning of view models over a number of workers that coincides with the physical cores of a device.. My $ 0,02 as a framework consumer having some experience also with Vue: this sounds like an awesome feature to have.\nI would like to add: this syntax also seems like an extremely elegant syntax for some of the simpler binding converters that don't depend on outside parameters, like not. E.g.\nhtml\n<input el:disabled:from.not=\"enabled\" />\n. > VueJS-style event modifiers would not allow this.\nThey sort-of do, with pre-established possibilities. Vue is already using modifiers to capture only specific keypresses, e.g.\n```html\n\n````\n-- but indeed: that's not fully configurable. That's the challenge for CanJS to make it better: making it fully flexible yet continue to be generic and generically applicable.\nSomething that comes to mind is taking the Vue dot notation one step further by allowing CanJS to parametrize the individual modifiers. E.g.\nhtml\n<input on:keydown.key('esc').prevent=\"...\" />\nYou could even make some of the execution order-dependent to compose more complicated logic, in effect forming a pipeline that ends with the bound handler. E.g. in the above sample, the prevent modifier could run only when key('esc') already matches.\nThe hard problem is probably to come up with an exact syntax that works within the constraints of the DOM.\n\nI believe swipe-capability is not a good fit to be expressed with event modifiers, because swiping is a gesture that is composed of multiple events interacting on top of a piece of state, over time. It is neither isolated to a single event, nor represents a simple pipeline filter flow.\nI would implement swiping as an element-level helper, e.g.\nhtml\n<div {{ swipeable({ time : 200, distance : 100, move : true }) }}></div>\nor as a series of custom attribute handlers working together, e.g.\nhtml\n<div swipe-time=\"200\" swipe-distance=\"100\" swipe-move=\"true\"></div>\n(Personal preference for using a helper; less clutter in the DOM and less moving parts.). You can - sort of - already do this, right? Reparse the outerHTML of the element you're enhancing as a stache template and the basic functionality is there.\nArguably not very performant though. :-). Really? Dropping official support for Internet Explorer outright?\nRelying on -- i.e. requiring -- the global environment to be patch-polluted with polyfills to give it some quasi-official support?\nGreat...\nLooks like I won't be migrating past 2.x for the next years then.\n. > CanJS 3.0 supports IE and will continue to. 3.0 has been out for a year and a half. \n3.x doesn't add enough value over the private fork of 2.x that I have in use. I already back-ported some of the most-desired features we saw in 3.x like <can-slot> to said fork. 4.x did bring interesting improvements performance- and stability-wise (queue-based event dispatches, etc) and cleaned up a lot of mess with binding and scope handling in stache, leading to a lowered learning curve and eased maintenance. It would have been genuinely interesting.\n\nOr plan for 4.0 is to support IE11 via polyfills.\n\nIf you're in full control of the site or app that is meant to run your CanJS-based logic, that's a solution.\nBut it's infeasible when you're not. E.g. when you're active as a third-party being integrated on an existing site.\n. > Polyfills are a pretty common practice. Why are you hostile to them?\nBecause polyfills have to modify the global environment, which is a big no-no if you have to produce code that should be capable of running as a third-party, integrated into an existing website by others.\nHaving to polyfill Promise, or ask that integrators have it polyfilled, isn't that bad. Not very different from how back in the day lots of third-party integrations would warn you that they would load jQuery or could take advantage of a copy of jQuery already loaded.\nBut having to set up polyfills for a bevy of other things like Object.assign; WeakMap; WeakSet; etc. becomes too much for that to be managable.\nContrast with an implementation that imports everything as a module and falls through to the native implementation when available and otherwise falls back to a non-global polyfilled fallback.\nE.g. for Object.assign:\njs\nmodule.exports = ( \"assign\" in Object.prototype ) \n  ? function assign( object, props ) {\n    return Object.assign( object, props ); \n  } : function assign( object, props ) {\n    // FALLBACK IMPLEMENTATION\n  }\nOr indeed: provide 'shell' modules that can be swapped out for polyfills by module loaders. That's even better; because that gives people a choice. It then wouldn't bog down those which don't have to support IE at all. For instance; those people authoring Webview-wrapped apps like Cordova, Electron, etc.. > If it's the number of \"APIs\", then how many is too much?\nIn the role of a third-party, the problem is the cognitive burden you're placing on the potentially far less JavaScript-literate first-party. You either have to ask them to vet and include polyfills themselves, or you have to warn them that your code is going to be adding polyfills for feature X,Y,Z and that it may affect whatever they themselves have running in their first-party code.\nIn both cases, a hard sell that may scare them off.\n(And you really don't want to leave this undisclosed and then deal with the fallout where they integrate your third-party code and their first-party code suddenly breaks.)\n\nWould the module-loader mapping technique work for you?\n\nYes, very much so.\n. Would be better if there was a system in place where the dependencies that need polyfilling for IE would be actual -- you know; dependencies.\n...as in imports\n...which don't need to modify the global namespace for CanJS to pick them up\n...so that CanJS can also be used to create bundled third-party widgets meant to run on websites outside of your direct control\n...and so that everything works transparently, without developers needing to worry about the polyfill collection du jour.\nAs it stands, that is no longer possible in a post CanJS 4.x world.\nI'm very interested in how you believe these developments can possibly mesh with CanJS's official mission statement. That is:\n\nCanJS\u2019s mission is to minimize the cost of building and maintaining JavaScript applications by balancing innovation and stability, helping developers transcend a changing technology landscape.\n\nThis neither minimizes cost, nor maintains stability.\nIt completely breaks IE 11, which is the last available IE version on Windows 7 and 8 and continues to hold a decent chunk of marketshare. It places burden on developers to ensure they set up a polyfilled browser environment where CanJS can continue to work. It also increases risk and stability. Polyfills may be incompatible or worse: become incompatible over time. (Notably when CanJS suddenly starts using an API feature that is not properly supported by a polyfill.)\nIt may even be flat out impossible for developers to get away with polyfilling the global environment if they have code which has to run on a site in the context of a third-party, i.e. as some kind of widget others can integrate. (This is infact exactly the scenario I'm currently facing.)\n. @justinbmeyer \nMy employer's currently in the planning phase for a big new family of projects, one of which will need to integrate functionality as a third-party.\nI would have to consult some people over this and I can't give you an immediate answer, but the possibility of setting time aside to work on this and contribute to getting this into the framework may be there, if it means CanJS can help us get such third-party integration to work smoothly. After all: the assumption of a polyfilled global environment is something of a thorn in the side with most of the big MV* players for us on this and avoiding it altogether would be a big plus.\nI'll have to get back to you on this.\n. @justinbmeyer \nJust leaving a heads-up out of courtesy.\nThe responsible development team for the upcoming client projects I mentioned in my previous comment is going to settle on using Vue.js, believing it will be a better fit for their situation.\nThere's no longer an immediate need from my end for the change you suggested in the other thread. We will likely not run into problems with IE 11 support and polyfills in the short term.. @Lighttree \nThere's apparantly a bug in core-js 2.5.3 with IE 11 where a babel-shimmed for ... of loop always results in Incompatible receiver, map required! when iterating a Set or Map. Eventually that scenario was fixed in 2.5.4, but there are still other breaking cases.\nMight be something similar occuring here with CanJS. Have you tried pinning the version to 2.5.2 ?\nSee also: https://github.com/zloirock/core-js/issues/368. @chasenlehara\nOffering a potential alternative: I've been working on a company-internal webpack loader for stache, compatible with CanJS 4. Seems like feature-wise it's a bit more mature than the work @macku did with his loader sofar.\nOurs has support for extracting and processing nested {{> ./partial.stache}} partials into the webpack bundle as well as nested imports that use <can-import> -- the latter including support for pulling the imported value into a scope variable using <can-import value:to=\"scope.vars.(...)\" />. \n(As an aside: It's quite tricky to get this working with webpack's interpretation of require(), since it likes everything neatly defined upfront in a nice-and-static way. I had to have the loader resort to injecting a redefinition of the <can-import> tag, which avoids the can.import method on which the normal tag relies, since that's where a dynamic import strategy is used.)\nOurs also generates webpack-compatible source maps and handles them quite nicely: It creates a sub-folder for each foo.stache file, which holds a foo.js source file containing the generated code -- incase you ever need to set breakpoints -- and a foo.html file containing the original template -- for reference during debugging. (No setting breakpoints inside the template. As wicked cool as it would be to get that working, it is probably outside the realm of possibility right now.) \nThe .html extension may seem weird, but it's necessary for browser developer tools to not spaz out and report syntax errors, atleast until the source maps specs are updated to allow for content-type information and the tools start recognizing it.\nIf you're interested, we could probably donate the code. Would have to double-check with management, but since it's not exactly core business related material, it'll probably be fine.. @chasenlehara \nQuickly tossed together a repository that holds an export of our current code. Feel free to have a look.\nhttps://github.com/NetMatch/webpack-stache-loader. >  having the wrong main in package.json.\nFYI; the resolution taken to that issue runs counter towards common practice.\n\"main\" should point at dist/. Otherwise you are forcing all your consumers to set up their own transpilation, not just their own code but also selectively for certain of their modules installed in node_modules. Even if they didn't even need transpilation to begin with.\nMisunderstandings usually stem from people confusing dist/ with \"meant for browsers,\" which it is not.\nA correct \"works everywhere\" set-up is the following:\n\nHave  src/ contain non-transpiled ES6 code that can use features even not supported by Node.js\nTranspile src/ to dist/ with a target for Node.js\nTranspile src/ to browser/ with a target for browsers\nPoint main in package.json at the entry-point in dist/\nPoint browser in package.json at the entry-point in browser/\nAdd dist/ and browser/ to .gitignore\nAdd src/ to .npmignore\n\nMany bundlers including Webpack can pick their compile target, switching between e.g. node and web, and will respect the browser field from package.json while picking the entry point for the module.\nFinally, in the case of modern bundlers that understand ES6 modules and can perform tree-shaking, you'll want a build that transpiles everything down to ES5, except the ES6 import statements. You can put that in module/ and point the module property of package,json at it.\nUp-to-date bundlers like Rollup and Webpack should respect that property as well.\nA decent reference on the topic. > ```js\n\n// INTERNAL STATEFUL PROPERTIES\n// These are properties that are owned by this component.\n```\n\nI'd actually love if there were a way to make these truly internal.\nWould be nice if you could mark properties as private. Via a convention such as a leading underscore, or via a modifier: \"private\" or private: true setting on the define spec for the property. And then have it be impossible for the world outside a component to bind to those. Nice way to enforce encapsulation.\n . > @matthewp \n\nI don't think that's possible in JavaScript\n\nI know it's not possible to do 'true' private properties.\nThat's also not what I suggest; read closer.\nWhat I suggest is that there is some kind of way to mark certain properties on view model definitions as not being bindable from outside the component that would use the view model.\nFor instance, Vue.js does this by separating props and data. Both still end up as public members on the real component instances, but getting outside accesss to those instances and getting access to the private data members requires that you go outside the normal usage path. The only people doing that are people that know what they're doing and getting themselves into.\nSo it's kind of like putting a safety on a foot-gun for your 'normal' users.\n. > It seems silly that this comments aren't removed by default,\nNo it's not silly that the default is to keep those type of comments.\n//! and /*! is a common convention for marking comments that should not be removed by minification. E.g. because they contain licensing information.\nThe silly here is on the side of CanJS, using //! as build pragmas when that form of comment already had a widely adopted previously established meaning.. > registerPartial => ?\nYou shouldn't replace it by anything at all. In a proper module system, globally accessed and modified hardpoints like that are a bad, bad idea.\nYou should handle custom partials like you should handle custom helpers: import them at the top of consuming components and register them via the local partials collection of the component.\nA more streamlined solution involves working with a build system plugged with a loader to handle .stache. You can add logic to such a loader to make it recognize path-style partials, e.g. {{> ./template-relative/lookup-to/partial.stache }} and have it automatically wire those up as local partials.\nIt really isn't all that hard to do. I've done it before, but back then Bitovi opted to adopt a less-featureful Webpack loader as standard instead.\n. ",
    "fiestacabin": "I prefer the ability to pass a function; in my case the view result may or may not be a deferred, depending on whether I'm invoking it with deferred or resolved models. The callback functionality allows me to work with the view agnostic of this fact.\n. ",
    "rvl": "Ah ok... plugins.\nI have a resource which is a list of countries. It comes back from my server sorted by distance to a certain point. Sometimes I would like to present the list of countries in alphabetical order in a <select>.\n. Habit... from writing server side templates. If you want less doc then that's fine as well.\n. I don't want to be awesome I just want other users/victims not to have to make the same mistakes as I have.\nEJS templates are quite unforgiving. If you make a mistake all you get is an error on the line of the eval(), or worse, nothing at all. It's a pain in the arse actually. More docs could possibly help reduce mistakes.\nWhat you have put in these comments is quite useful information. When I get a moment I will reformulate the patch to include it.\n. At this point I am just trying to get my thing to work and don't have time to improve EJS debugability.\nIt would be great if browser debuggers were as useful as say gdb which understands generated sources.\nBut one possibility could be to have a template debug mode which runs the output of EJS through jslint's javascript parser and console.logs any parse errors found. jslint would need to be hacked to implement source line number mapping.\nAlso possible in debug mode could be to wrap <%= tags %> in a javascript try catch with the catch logging the exception and ejs line number of the tag. I'm not sure about the backtrace possibilities with this. Also I'm not sure what to do about <% tags %>, they will be more complicated if not impossible.\n. Or am I understanding how to use .attr()?\n. Yep OK, tomorrow.\nThe question I have, is is it OK to call attr() on the items of the can.Observe.List? Because in the test case I give it a plain array in the constructor. Does canjs wrap or add the attr function to each item in the list?\n. OK cheers. Changed it to use Observe.each().\n. ",
    "goldbuick": "Any word on when / how to fix this ?\n. ",
    "schovi": "+1\n. No, it is different problem.\n. Maybe similar to this one https://github.com/bitovi/canjs/issues/280\n. Closed this and opened https://github.com/bitovi/canjs/pull/306\n. Finally I had time to understand this a little bit more.\nSolutions like another function or extra param are pretty obvious, but API will be complicated. Now there is bind and delegate and sometimes i am confused :) And secod problem i see in using it inside a control \"{observer} one.two\" how to tell Can there what bind to use.\n. sweet :)\n. @daffl Reverted commit, hope it is fine now.\n. Had some issue with merging canjs master into this branch.\nIf this is problem, or there is lot of commits i can recreate it into only new one.\n. I noticed this as problem in my app, where i keep current state of page in hash params. Most of them are key - value where value is integer (id of something). \nI think this is pretty common usecase and it works fine until\n1) I use strict comparsion (for example in view)\nhtml\n<% something.each(function(smth) { %>\n    <div class=\"<% can.route.attr('something_id') === smth.id ? \"active\" : \"\" %>\" <%= (el) -> el.data('smth', smth) %>>\n        <%= smth.name %>\n    </div>\n<% }) %>\nThen in control\njavascript\n{\n    init: function() {},\n    \"div.click\": function(el, ev) {\n        can.route.attr('something_id', el.data('smth').id)\n    },\n    \"{can.route} something_id\": function(route, ev, what, somethingId) {\n        if(somethingId) {\n            $.ajax('something/' + somethingId)\n        }\n    }\n}\nSo this is usecase. When i have app in zero state and click on something div it sets something_id =  1 (integer) in can.route.\nIt trigger binding, div will be active and some ajax call is started.\nIt is perfect.\nBut what happend when i do refresh with something_id parameter sets.\nIt parses route and sets parameters into can.route. In this case something_id = \"1\" (string). It triggers and call ajax request, but div wont be active because I compare it with 1 (integer) via ===\nNow I can click on something div (with same id) and something_id = 1 (integer) is set on can.route. Div is mark as active and SECOND ajax call is called.\n. Good to hear guys .)\nWhere can i find the commit?\n. Having issue with set dotted key\nYour example \n``` javascript\nvar ob = new can.Observe();\nob.attr('a.b', 'test');\nob.attr() // -> { a: { b: 'test' } }\n```\nThrow me classic old error \"can.Observe: Object does not exist\"\nhttp://jsfiddle.net/schovi/zTF9s/\nRead works fine\n. :+1:\nAwesome idea. Still solving how effectively initialize some Controls.\n. :+1:\nAwesome idea. Still solving how effectively initialize some Controls.\n. Obsolete :)\n. Obsolete :)\n. Yes. It was quick to solve :)\nAnd ofc it solves leading ampersand can.deparam(\"&a=1\")\n. Yes. It was quick to solve :)\nAnd ofc it solves leading ampersand can.deparam(\"&a=1\")\n. With deepest debugging i found that one part of problem with removing is in can.getObject\n``` javascript\nvar o = {b:1}\ncan.getObject('a', o) // -> undefined\n// Which is correct because there is no 'a' property in there\n// -----------\n// With removing\ncan.getObject('a', o, false) // -> false \n// because it was not able to remove value. \n// It breaks meaning of returns which should be value of 'a' property and not result of removing operation\n```\nAnd multiple objects. With focus on objects except first, because with that it works fine\n``` javascript\nvar x = {a:1},\n    y = {b:2};\ncan.getObject('b', [x,y]) // -> 2\n// Removing\ncan.getObject('b', [x,y], false) // -> false\ny // -> {b:2}\n``\n. With deepest debugging i found that one part of problem with removing is incan.getObject`\n``` javascript\nvar o = {b:1}\ncan.getObject('a', o) // -> undefined\n// Which is correct because there is no 'a' property in there\n// -----------\n// With removing\ncan.getObject('a', o, false) // -> false \n// because it was not able to remove value. \n// It breaks meaning of returns which should be value of 'a' property and not result of removing operation\n```\nAnd multiple objects. With focus on objects except first, because with that it works fine\n``` javascript\nvar x = {a:1},\n    y = {b:2};\ncan.getObject('b', [x,y]) // -> 2\n// Removing\ncan.getObject('b', [x,y], false) // -> false\ny // -> {b:2}\n```\n. I tried to cover all cases of can.getObject with tests in https://github.com/schovi/canjs/commit/8350b8cbe3cdd0777f1d1a5648487a55a38c3c35\nFound problems with remove feature and remove or add with multiple roots\n``` javascript\nroot = {}\ncan.getObject('a', root, false) // -> undefined, BUT returns false\nroot1 = {}\nroot2 = {a:1}\ncan.getObject('a', [root1,root2], false) // -> 1 and root2 = {}, BUT returns false and root2 is same\nroot1 = {}\nroot2 = {a:1}\ncan.getObject('a', [root1,root2], true) // -> 1 and no change, BUT returns {} and root1 = {a:{}}\n```\nCan someone responsible confirm this? I tried to do some fixes but not sure if this is really expectable behaviour, or there is some reason for that.\n. I tried to cover all cases of can.getObject with tests in https://github.com/schovi/canjs/commit/8350b8cbe3cdd0777f1d1a5648487a55a38c3c35\nFound problems with remove feature and remove or add with multiple roots\n``` javascript\nroot = {}\ncan.getObject('a', root, false) // -> undefined, BUT returns false\nroot1 = {}\nroot2 = {a:1}\ncan.getObject('a', [root1,root2], false) // -> 1 and root2 = {}, BUT returns false and root2 is same\nroot1 = {}\nroot2 = {a:1}\ncan.getObject('a', [root1,root2], true) // -> 1 and no change, BUT returns {} and root1 = {a:{}}\n```\nCan someone responsible confirm this? I tried to do some fixes but not sure if this is really expectable behaviour, or there is some reason for that.\n. I rewrite can.getObject to pass tests above schovi@db6c24d\nTested it with 2 pull requests above together and tests and app works fine\nFix of noncontainer roots https://github.com/schovi/canjs/commit/21909b341643d85b731a13e10af9e073b53fdb1a\n. I rewrite can.getObject to pass tests above schovi@db6c24d\nTested it with 2 pull requests above together and tests and app works fine\nFix of noncontainer roots https://github.com/schovi/canjs/commit/21909b341643d85b731a13e10af9e073b53fdb1a\n. @daffl I tried to run tests and problem cases and all it looks fine now.\n. @daffl I tried to run tests and problem cases and all it looks fine now.\n. This partitionaly solve https://github.com/bitovi/canjs/issues/339\n. This partitionaly solve https://github.com/bitovi/canjs/issues/339\n. This also fix following. Last commit add test for this.\n``` javascript\nBEFORE\ncan.sub(\"a:{a}\",{}) // -> null\ncan.sub(\"a:{a}\",{}, true) // -> \"a:false\" // Which can break some logic\nAFTER\ncan.sub(\"a:{a}\",{}, true) // -> null\n```\n. This also fix following. Last commit add test for this.\n``` javascript\nBEFORE\ncan.sub(\"a:{a}\",{}) // -> null\ncan.sub(\"a:{a}\",{}, true) // -> \"a:false\" // Which can break some logic\nAFTER\ncan.sub(\"a:{a}\",{}, true) // -> null\n```\n. This can partitionaly fix and improve https://github.com/bitovi/canjs/issues/339\n. This can partitionaly fix and improve https://github.com/bitovi/canjs/issues/339\n. @justinbmeyer The idea came from my last project.\nFeature i need most is to keep result even there are missing values (\"a:{a}\" -> \"a:\"). Same as ejs or mustache work <span>{{a}}</span> will render <span></span> (if i skip fact that undefined or null will be there).\nAnd in one case i found very useful what I called meta-templates. In one place i prerender template with few values and then reuse this meta-template. I know that i can achieve same result with keeping object and extend it with new values, but this seem more straightforward for me. \nFirst time, when i tried to use can.sub and i get null as result it took me lot of time to do debug that and then i found it is \"feature\" and i ask myself \"Who the hell use this.\" :) Then i found it is primary for can.control templated bindings. So I tried to make API for this as easy as possible and understandable. Plus the code for this feature is not aggresive.\n. @justinbmeyer The idea came from my last project.\nFeature i need most is to keep result even there are missing values (\"a:{a}\" -> \"a:\"). Same as ejs or mustache work <span>{{a}}</span> will render <span></span> (if i skip fact that undefined or null will be there).\nAnd in one case i found very useful what I called meta-templates. In one place i prerender template with few values and then reuse this meta-template. I know that i can achieve same result with keeping object and extend it with new values, but this seem more straightforward for me. \nFirst time, when i tried to use can.sub and i get null as result it took me lot of time to do debug that and then i found it is \"feature\" and i ask myself \"Who the hell use this.\" :) Then i found it is primary for can.control templated bindings. So I tried to make API for this as easy as possible and understandable. Plus the code for this feature is not aggresive.\n. @justinbmeyer Any suggestions? \nI worked on it little more and found, that variant with strict = false is not that sexy as I thought. You can get same result with keeping object and extending it.\nBut otherwise still can imagine usecase, where first time i want to pass some params and i dont care if they are rendered or not. And later i will render that meta-template with rest params and strict = true\nWithout this feature do you think the strict mode is fine?\nOr it will be better to keep same api as now (without any options and when any value is missing then null is returned). And strict option can be changed with something like keepResult and it will ignore missing values.\njavascript\ncan.sub(\"a:{a}\", {}) // -> null\n// with keepResult\ncan.sub(\"a:{a}\", {}, false, true) // -> \"a:\"\n. @justinbmeyer Any suggestions? \nI worked on it little more and found, that variant with strict = false is not that sexy as I thought. You can get same result with keeping object and extending it.\nBut otherwise still can imagine usecase, where first time i want to pass some params and i dont care if they are rendered or not. And later i will render that meta-template with rest params and strict = true\nWithout this feature do you think the strict mode is fine?\nOr it will be better to keep same api as now (without any options and when any value is missing then null is returned). And strict option can be changed with something like keepResult and it will ignore missing values.\njavascript\ncan.sub(\"a:{a}\", {}) // -> null\n// with keepResult\ncan.sub(\"a:{a}\", {}, false, true) // -> \"a:\"\n. In my current project I made Control for two way bindings. It is little bit more complicated.\nIt supports can.Observe or can.compute\nhttps://gist.github.com/schovi/5374759\nIf you wish i have LiveChecked Control for supports checkbox and radio\n. In my current project I made Control for two way bindings. It is little bit more complicated.\nIt supports can.Observe or can.compute\nhttps://gist.github.com/schovi/5374759\nIf you wish i have LiveChecked Control for supports checkbox and radio\n. ",
    "farkashon": "I also encountered this problem. I have a controller that removes itself when an inner button is clicked. \nThis didn't happen in jQueryMX because the $.cleanData override used a for loop with '(elem = elems[i]) !== undefined', but CanJS uses a $.each loop which can try to trigger an event on an undefined element.\n. ",
    "rahulswamicse": "I am not able to use .then() function while stealing in canjs.\nMy Code:\nsteal('can',\n        './views/runreportInit.mustache',\n        'onlineclaims/common/resources.js',\n        'onlineclaims/common/properties.js',\n        'onlineclaims/models/service/runreport_service.js',\n        \"/templates/components/libraries/1.2/datatables/media/js/jquery.dataTables.js\",\n        \"/templates/components/libraries/1.2/datatables/media/css/jquery.dataTables.css\").then(\n        \"/templates/components/libraries/1.2/datatables/extras/ColVis/media/js/ColVis.js\",\n        \"/templates/components/libraries/1.2/datatables/extras/ColVis/media/css/ColVis.css\",\n        \"/templates/components/libraries/1.2/datatables/extras/TableTools/media/js/TableTools.js\",\n        \"/templates/components/libraries/1.2/datatables/extras/TableTools/media/css/TableTools.css\",\n        '/templates/components/libraries/1.2/plugins/1.0/overlay/jquery.overlay.js',\nfunction(can, initView, ResourceManager, Properties, runreportService, overlay){\n/**\nIts is giving me below error.\nError:\nTypeError: can is undefined\n    return can.Control(\n. ",
    "gpittau": "my first pull request... from \"edit file\"\nGabriel Pittau\n2012/7/24 Curtis Cummings <\nreply@reply.github.com\n\nLooks like you just want to change the link to a fiddle so why is there 4\nmonths worth of commits in this pull request? I'm going to close this and\nask that you pull the latest changes from master into your branch and\nresubmit your patch with only the code that needs to change.\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/jupiterjs/canjs/pull/66#issuecomment-7225056\n. thanks...\nGabriel Pittau\n\n2012/7/25 Curtis Cummings <\nreply@reply.github.com\n\nSomething went drastically wrong then. I've made the change myself:\nhttps://github.com/jupiterjs/canjs/commit/67b11b2022cbab4d63ce2e1b91c0b3b8e5b40b97\nThanks for the fix!\n\nReply to this email directly or view it on GitHub:\nhttps://github.com/jupiterjs/canjs/pull/66#issuecomment-7252040\n. \n",
    "trickeyone": "Pull Request sent!\n. Hi @ralphholzmann,\nI tried to make a jsfiddle to present a test case, but some of the needed model functionality isn't included in the built CanJS libs.\nhttp://jsfiddle.net/trickeyOne/ZBp45/\nI tried to describe what was throwing the error and where via some comments in the controller.\n. Hi @ralphholzmann,\nCould you suggest how I could provide a better test case? Since the functionality isn't included in the built version of CanJS, it's difficult to provide a full example.\nThanks.\n. The functionality that is missing is the Model.destroy method. In my method I'm just doing a this.options.model.Children.match('id', id) then looping through it to call the destroy on the child. Upon destroying, the sort plugin is being called again because there's been a change to the List. When it does this, it's trying to find an item with the specified index (attr) but it has been removed from the list and was the last item in the list. This is causing the item to be set to null. When this happens and sortedIndex is called with the item of null, sortedIndex is throwing an error because it's trying to do this: itemCompare = item.attr(this.comparator) at line 16.\nIf you can tell me how I can pull in the sort plugin and how to get the destroy method to show up on my fiddle, I can make a more apt example.\n. Ah, ok. So, I shouldn't use the latest releases (i.e. http://canjs.us/release/latest/can.jquery.js ) ?\n. Ok. I'm working an update of the fiddle. It's still not simple, but that's because of the inter-dependencies of the whole setup. i.e. Parent->child stuff.\n. Ok, if you take a look at the fiddle again, you'll see the error at work. Click the \"[x]\" next to the last item in the list and you'll see the error happen.\nhttp://jsfiddle.net/trickeyOne/ZBp45/\n. I can't make it simple as that because it's dependent on calling the Model.destroy method. So, the fixtures are needed to return a successful call. I've update the fiddle to just do a quick removal of a random item from the list, then the last item in the list. You'll see that it successfully removes the random item, but errors on the last item. I tried to put in some error catching, but it's not working since it's a deferred. You'll need to watch Firebug or some console in the browser to see the error that is thrown.\nWhy 20? I just picked the number at random. Only two items means there would only be 2 attempts. The updated one it a smaller run at it. I trimmed it down as much as I could but still produce the bug. There is some setup required, but only because of dependencies and data.\n. Sorry, I meant \"The updated fiddle is a smaller example\"\n. ",
    "hyusetiawan": "anyone?\n. because there is a mapping for id already, and changing that doesnt change the REST actions but it does change the attribute mapping. This is a discrepancy in behavior.\n. I realize that is the case, but I think this is still a valid usage of live binding. Is there a way to automatically keep track of the focus, the angularjs way? This feature will really help data driven way.\n. I doubt that it's keeping track of focus either, after rereading my sentence it does sound that way, my bad. I meant that it's intelligent enough to append/prepend/removal for a simple list so it doesn't rerender the whole list, but the method starts to break down in complex objects such as a table where the array is more than 1 dimension or complex objects.\nI will create such issue with a temporary solution to the problem.\n. I tried but for some reason I couldn't, I have to add after discussing with daffl, ejs doesnt break in general, only when the ejs is: http://pastebin.com/nuu1fw6h\nand this is the resulting code that is about to be eval: http://pastebin.com/NuEkSg2J\nhowever, when I remove //@ sourceUrl part, my code works just fine.\n. @daffl thank you for trying to figure it out, but I have moved on to another framework. If I recall correctly, the problem was caused by ejs using the @ symbol in the comments during eval, this will make IE9 think that it's a variable. There was a discussion about in the IRC but im not active in that channel anymore, so I guess I'll just close this :)\n. are there any updates on this effort? Or has the discussion moved somewhere else?\nWould love to know the progress on this and chip in a cent or two\n. first off, I would like say how impressive your typing/spelling has become since the last time we met @justinbmeyer , considering it's from an iPhone and thanks again for the Twix (To jog your memory, I was one of the engineers at MuDynamics).\nI have to disagree however with the comment \"Find/replace goes 90% of the way.\", at least for our specific case at the time (3.2 -> 3.3) notably the rendering and the way steal behaves. This however is not the main topic of the discussion. If I am understanding your reasoning correctly, it seems as the version changes, code that's written in the previous version of the framework becomes legacy code? That's what I got from \"To maintain legacy code, you have to create a bigger download than is necessary.\" This is expected in JMVC as you mentioned, but like @jaredstehler said, in CanJS has been smoother in the upgrades, but is this a short lived trend?\nI agree that continuous release cycle will definitely help, thought it forces the devs to constantly get updated but at least the breaking changes will get caught early.\n. That is a good point actually, the analogy with Backbone and AngularJS, I guess I am convinced. I am leading the effort to architect the UI for a giant telecom, obviously I am proposing CanJS, one of the issues that they brought up is LTS. That is why I am slightly worried, I guess with continual updates, it will make my case better in my effort to use CanJS as THE framework.\nThanks Justin!\n. ",
    "dispatchrabbi": "This issue's being tracked elsewhere; it should be resolved pretty soon.\n. It looks like this is working. I've added a test for it.\n. This apparently only happens for templates that are inline in script tags. I can get the error to happen on the page you gave, but here's another setup I have that works just fine.\nindirect3.ejs:\n<h2><%=name %></h2>\n<%if(this.children){ %>\n<ul>\n    <%== can.view.render(\"indirect4\", this.children) %>\n</ul>\n<%}%>\nindirect4.ejs:\n<% $.each(this, function(i,child) { %>\n    <li><%== can.view.render('indirect3',child) %></li>\n<% }) %>\nindirectEJS.html:\n``` html\n<!DOCTYPE html>\n\n\n\n\n\n\n\nsteal(\n    'can/view/ejs')\n.then(\n    'can/view/ejs/test/indirect3.ejs',\n    'can/view/ejs/test/indirect4.ejs',\n    function() {\n        var data = {\n            name: '1',\n            children: [\n                {\n                    name: 2,\n                    children: [{\n                        name: 3\n                    }, {\n                        name: 4\n                    }]\n                },\n                {\n                    name: 'abc'\n                }\n            ]\n        };\n\n        // this works just fine\n        can.view.cache = false;\n        data.name = 'can.view is not cached';\n        $('body').prepend(can.view('indirect3', data));\n\n        // as does this\n        can.view.cache = true;\n        data.name = 'can.view is cached';\n        $('body').append(can.view('indirect3', data));\n    }\n);\n\n\n\n```\n. After fixing an inadvertent issue caused by converting your $.each() to can.each() (the argument order is switched), your test works just fine:\nVerbatim out of dev tools, no clean-up done:\n``` html\n\n\n\n<h2>&lt;%=name %&gt;</h2>\n&lt;%if(this.children){ %&gt;\n<ul>\n    &lt;%== can.view.render(\"ind2\", this.children) %&gt;\n</ul>\n&lt;%}%&gt; \n    \n\n&lt;% can.each(this, function(child, i) { %&gt;\n    <li>&lt;%== can.view.render('ind1',child) %&gt;</li>\n&lt;% }) %&gt;\n    \n<script type=\"text/javascript\">\n    steal('can/view/ejs', function () {\n    var data = {\n        name: '1',\n        children: [\n            {\n                name: '2',\n                children: [{\n                    name: '3'\n                }, {\n                    name: '4'\n                }]\n            },\n            {\n                name: 'a',\n                children: [{\n                    name: 'b'\n                }]\n            }\n        ]\n    };\n\n    can.view.cache = false; //change this to true to cause the problem\n    data.name = 'can.view is not cached';\n    can.$('body').prepend(can.view('ind1', data));\n    can.view.cache = true;\n    data.name = 'can.view is cached';\n    can.$('body').append(can.view('ind1', data));\n});\n\nfunction render(templateName, templateData) {\n    //just a helper function to allow us to put breakpoints in the middle of a template render\n    var a = can.view.render(templateName, templateData);\n    return a || 'undefined';\n}\n</script>\n\n\n\ncan.view is not cached\n\n\n2\n\n\n3\n\n\n4\n\n\n</li>\n\n<li>\n\na\n\n\nb\n\n\n</li>\n\n\ncan.view is cached\n\n\n2\n\n\n3\n\n\n4\n\n\n</li>\n\n<li>\n\na\n\n\nb\n\n\n</li>\n\n\n</body><style type=\"text/css\"></style></html>\n\n```\n. All righty. I can't get this bug to happen consistently, even with pointers from https://github.com/bestiejs/lodash/issues/49. (The code that that says should throw an error in IE - Function('//@/a/a')() - doesn't throw an error in IE.) I'm gonna leave this aside for now.\nIf anyone can get a consistent test case for this, that'd be awesome.\n. You should be able to accomplish that just using:\njavascript\n\"{items} length\": function() {\n    this.element.find('.itemCount').html(...);\n}\nIf you can find a case where this kind of solution doesn't help you, rig up a test case and we'll take it from there.\n. Now you should be able to specify quoted values. For values with no spaces, though, you can still leave the quotes off. So your selectors can look like:\nfoo bar=a baz=\"b b\" qux=\"c c\"\nThis doesn't address all the issues above, but it's progress.\n. Can we get a minimal test case for this? Depending on what the actual bug is, this may or may not be the right way to go about fixing it. Thanks!\n. Here's what I think is happening here: compute keeps an eye out for when .attr() is called on an observable in its value function, but it's not recognizing when .each() is called (probably because .each() calls .attr() on different things each time). More later, hopefully after fixing.\n. This should be fixed with the newest version of steal.\n. I added a test for this, and the test is passing, so I'm going to close this issue as it doesn't seem to be an issue anymore.\n. We probably want the ability to do generic serializer/deserializer functions instead of just a property name map, for when your state is something like {search: 'bar', options: ['a', 'b', 'c']} and you want your route to look like #!q=bar&opts=abc.\nAs a note on serializer functions, can.param is not all that helpful here, because can.param({foo: [1, 2, 3]}) === 'foo[]=1&foo[]=2&foo[]=3', which I don't think is a great default.\n. @daffl I agree, but @justinbmeyer feels like that would be a breaking API change, so it should wait for 3.0. There is a workaround using the compares param.\n. Going to close this branch to open one that merges into the docco branch.\n. @daffl Fixed!\n. ",
    "daniel-franz": "updated fiddle: http://jsfiddle.net/WMC4S/2/\nTest and pull request will follow...\n. So, what will be the best way to update from JMVC 3.2.2 to 3.3 regarding EJS parsing problems? How do you migrate hundreds of EJS-files?\n. Now my EJS-files seem to be working. But I guess a hint in the docs, that EJS-files get parsed and not every kind of JS might be accepted, would be great.\n. I believe we actually use that file to guarantee $/can.EJS.Helpers.prototype is in place, when we add our own helpers.\nBut it always seems to be a good thing to write some tests, so I'll add some.\n. You're right. By the name and the declarations I assumed I should steal that file before I define my own helpers... In that case deleting seems to be the best option for everybody\n. ",
    "bassnode": "I assume you mean this one.  There's a syntax error in the can.yui.js which is currently linked. Change it to http://canjs.us/release/latest/can.yui.js and it works. \n. Erp - nope, guess you didn't mean that fiddle.  Well, that one's linked from the main site so you might want to :)\n. ",
    "iamnoah": "Awesome!\n. Fair enough. Is that documented somewhere?\n. Tested. Good thing too; jQuery 1.8 changed the semantics of then().\n. Right, I guess I was thinking that if you should never set it that way, then internally it should never be read that way.\n. Good point.\n. I added an optional second parameter to specify the list type. Most of the time an Observe.List should be fine, but sometimes you have to have a Model.List.\n. Well, it's tricky for map. The values could be heterogenous, so trying to infer the list type from the values could backfire if a new value maps differently or the list starts out empty.\n. > The old $.fn.models did something similar.\nI don't think that will work here since the list can self-update. We can't change the type of the list after we return it.\n. I really like observe list so I may spend some time on it soon. But for now ce004ee fixes my issue.\n. We use it for templated binding in our controls for one:\njavascript\n\"{model} items.length\": function() {\n   this.element.find('.itemCount').html(...);\n}\n. The test shows the problem I encountered. You're right that computes already work with other computes generally. Except, if the computes have bindings. Then the compute (percentage in the test) returns the cached value instead of calling the function, so no binding takes place within the calling compute (fraction).\nFor the same reason, I don't think you would get two events because the change event is only bound in this case.\n. Added comments and also fixed the compute(plainValue) case. They're essentially the same problem. If you're just returning a value, then there is no attribute access.\n. Sure it does. html always goes through modify and this:\nif ( hasHookups && args[0] && isHTML(args[0]) ) {\nSo html(string) will end up converting that HTML to a fragment if there are any pending hookups, which happens in practice (in our app) pretty often.\nWe have script tags in our legacy HTML that we load. We have a huge app, so we mix old style jQuery.load()s and JMVC frequently. The script tags setup the legacy dialogs, etc. and not having them execute is a problem.\n. Yes, sorry that wasn't clear that this is from the modify plugin. I think that changing the hasHookups bit to this would work:\nif ( hasHookups && args[0] && isHTML(args[0]) ) {\n        args[0] = can.view.frag(args[0]).childNodes\n    }\njQuery does seem to handle a node list consistently.\n. The fix makes it impossible to do updates on nested objects that have a converter to an Observe without clobbering the reference. You'll always get a new observe, which breaks all kinds of references in our app. e.g, we do this:\n```\nvar MyObserve = can.Observe({\n   attributes: {\n      nested: \"MyModel.model\"\n   }\n});\nvar myObseve = new MyObserve({\n   nested: {\n     id: 123,\n     name: \"foo\",\n     count: 1\n   }\n});\nmyObserve.attr({nested:{count:2}});\n```\nIf nested isn't bound yet or is not a Model, then we get a new instance (breaks references)  and lose any old keys (e.g., id and name). This is a reversal of the behavior we had before.\n. The worst part is that it is inconsistent. If I don't add a converter, the nested Observe is updated. But if I do, even if it's still an Observe and not a Model, the nested Observe is replaced.\n. That would work, although it means updating all our converters. That means we have a high upgrade risk now. I would think keeping the existing object would be the more common use case than replacing it every time. It was at least the original behavior.\nAlso, the oldVal parameter to a converter doesn't seem to be documented anywhere.\n. Converters were only called on the initial set before, so they all look something like this:\nfunction (data) {\n     return new MyObserve(data);\n  }\n. What about the existing functionality before this was implemented? We're on a release before f9896d9 and can't upgrade because this will destroy the bindings we've set up unless we go and modify dozens of converters. That's a huge risk to our application.\nBefore this was introduced converters were only called when setting the property the first time and ignored subsequently. f9896d9 basically turned converters into setters.\n. The Handlebars semantics are:\ntemplate(context, {helpers: helpers, partials: partials, data: data})\nSo this makes the can.Mustache renderers interchangeable with Handlebars functions, which makes migration easier.\n. Ideally this would return a promise (with abort() tacked on) instead of a Deferred, but that broke a lot of tests.\n. ",
    "szmeku": "temporary workaround\nin can.fixture.js line: 239\nreplace \nconsole.log.apply(console, Array.prototype.slice.call(arguments));\nwith \nif(!$.browser.msie) console.log.apply(console, Array.prototype.slice.call(arguments));\n. thx for help\n. ``` javascript\nCustomModel = can.Model.extend({ \n  attributes: {\n    variable: 'type'\n  },\n  serialize: {\n    type: function(val){\n      return val + ' some suffix';\n    }\n  }\n},{})\nc = new CustomModel({ variable: 'lkfjsal' });\nc.save();\n```\nthis doesn't save c with variable === 'lkfjsal some suffix'  when i'll include can.Model.Queue sources\n. thx\n. ",
    "aloise": "I'm sorry I don't now the exact commit. I believe they expanded the functionality for their internal needs. Unfortunately it's not even documented.\n. I see. Thank you !\n. ",
    "imjoshdean": "Issue sorted out indexOf is live bindable.\n. Passes in all browsers with a5354ef2aa4f69355fb14b334e74795e52e8cda7\n. Had to revert the pull due to breaking test \"store ajax binding\" and in general returning the appropriate models.\nPlease fix and submit a new pull request.\n. Can you provide a test case where this doesn't work?\n. We will heavily consider this during the next release, but for 1.1 it will stay as is.\n. Added hashchange and popstate to the native events, and it looks like that did indeed fix it on Can 1.0.7.\nThis will be resolved in 1.1.\n. :+1:\n. I'm in the same boat as daffl on this one. the updated fiddle is doing what I think you're expecting. Is there something we are missing?\n. Thanks much, I am also definitely seeing this. I am working on a solution at the moment and should have something in place shortly.\n. This is fixed with 6b3c8131f64291ffa9db76ff0df50fe1604c69a3.\nHappy coding!\n. Couldn't merge, but implemented your suggestion, worked like a charm. Closing up on this.\n. @schovi It's on our dev branch and will make it's way to the 1.2/2.0 release of CanJS.\nCommit is here: https://github.com/bitovi/canjs/commit/b363ee91b933c8d59dc809a19435ad51ebb005af\n. This should be working like you want it, looking into it now.\n. Reopening, not working on 2.0/dev branch.\n. I've been working on this and have been overall happy with what I have. After talking with @daffl, expect the 2.1 launch to have a lot of goodies related to this such as:\n- @index directive which outputs the index of item of an array/can.List\n- @key directive which outputs the name of properties on objects and attribute names on can.Maps\n- #each iterator now works on generic objects as well as can.Maps\n- #each will be live bound on can.Map attributes\n- @index will be live bound on can.List\nUnrelated but it will also have an implementation of {{log}} which will log the current context of where it appears in the template.\nYou can play with it in the indexKeyLogMustache branch.\n. @justinbmeyer Perhaps it's time we start a 2.1-dev branch?\n. So, in a surprise turn of events Christmas is coming early and this is going to be in 2.0.1. Here is an example of it in action: http://jsfiddle.net/7Kxtu/7/\nIf you're on master, pull away and enjoy.\n. As @codr mentioned, can.Observe's serialize takes precedence, because this is the root of how can.Observes work. That said, this is being investigated in #274.\nIn the mean time, @codr's solution works. And I am going to close so we have only one issue open for the same thing.\n. Honestly, I don't see the harm in aliasing can.on/off for can.bind/unbind. Looking at on(\"change\", ... vs on(\"somePropertyName\", ... they are both listening for emitted events, just different names.\n. Finished off the rest of the issues, next push of the site should have things fixed. Closing now.\n. Added documentation back in in 7691aabac8f1d8423281bbd4a4f9a172086f7af7\n. I removed \".render\" from the whole fiddle and everything is hunky dory.\nhttp://jsfiddle.net/imjoshdean/bYv8G/8/\nStill seems like there might be an issue with can.view.render, but the person can go about his business as usual.\n. I would expect that in all cases we would use the function and not the function's result if we are not at the \"end\" of the chain. This is how it works in Handlebars and Mustache proper. So using @justinbmeyer's example of \njs\nvar MyConstructor = can.Construct.extend({text: \"static text\"},{})\nMyConstructor.altConstructor = function(){\n  return MyConstructor;\n}\nvar data = {\n  Construct: MyConstructor\n}\nI would not expect the following to work at all, and it doesn't.:\nhtml\n{{Construct.altConstructor.text}}\nbut I would assume this should work, but it doesn't:\nhtml\n{{#Construct.altConstructor}}{{text}}{{/Construct.altConstructor}}\nWhile I'm not 100% sure on helpers, I would imagine it would make more sense to pass in the raw function rather than run the function through a can.compute. Thoughts on this?\n. Yup,\nHere's an example of what happens in Handlebars: http://jsfiddle.net/mE49M/195/\nHere's another example of what happens in Mustache: http://jsfiddle.net/rttBM/3/\nYou can see that, unless at the end of the \"chain\" neither of them actually call functions. This is evident by\nhtml\n{{interests.projects.length}}\nWhat gets rendered out isn't the length of what the array that the projects function would return, but rather the number of expected arguments.\nThis can also be seen by\nhtml\n{{interests.projects.otherProp}}\n{{interests.projects.otherFunc}}\nBoth of which skip over calling the projects function, and look for otherProp and otherFunc as properties on projects\njs\ndata.interests.projects.otherProp = \"prop bar\"\ndata.interests.projects.otherFunc = function() {\n    return \"func bar\";\n}\n. Dunno, maybe it should be presented to the rest of Bitovi and get their thoughts?\n. This fix should still go in, 670cecb6e7de461ae047d86e7974ac9f03b1df62 just adds a test, but @ablackthorn's code fixes the issue. Running/confirming tests with his code now.\n. This has been folded into the dev branch, fixed, and will be working in the 1.2/2.0 release.\n. Thanks! I remember seferred from a while back, but it slipped my mind. Good catches!\n. This worked for jQuery but stalled on the Destroy Deferred tests in can.model for Zepto, Mootools, Dojo, and YUI. Make sure to give them a test on latest master for each of the different libraries\n. I scratched my noodle on this one for a while. I see your point; however, I'm struggling to find the use case where something like this would happen. If you are doing a live bound template with both of these lists and you destroy one of the models in the list, then both of the lists will react as expected. This is because we bind on each list when rendering the template.\nCan you provide a potential real-world example where you might be running into this situation? One where you would only be listening on changes to one list, but would be expecting results from the other one without binding on it? In the mean time, I'm going to have to call this one \"won't fix\" because it is working as expected.\n. So...2.1 milestone?\nSent from my iPhone\n\nOn Oct 15, 2013, at 9:01 PM, Justin Meyer notifications@github.com wrote:\n@mihael has worked a bit on this. \nSent from my iPhone \n\nOn Oct 15, 2013, at 7:31 PM, Josh Dean notifications@github.com wrote: \nhttp://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/#toc-projection \nCurrently in can.Component, it seems that you can only use one tag in the component template, it seems like where components is going is to not only allow more than one content tag, but to specify what the content element projects. This is done via a select property on the content node. \nCurrently: \nDOM: \nBob \n\"hello\" Template: \n \nRendered: \nBob \nProposal: \nDOM: \n \nBob \nbob@bitovi.com \n \n\"hello\" Template: \nMy name is  \nEmail me at  \nRendered: \n \nMy name is Bob \nEmail me at bob@bitlvi.com \n \n\u2014 \nReply to this email directly or view it on GitHub.\n\u2014\nReply to this email directly or view it on GitHub.\n. What browsers are you having issue with when it comes to \n\n\nhtml\n<div class=\"foo {{#if state}}prefix-{{state}}{{/if}}\"></div>\n<div class=\"foo {{#if state}}prefix-{{.}}{{/if}}\"></div>\nBecause I am not seeing your !! issue with 2.0.0, proper. That said, maybe I'm not understanding Handlebars properly, but \njavascript\n{\n  state: \"foo\"\n}\nwith \nhtml\n<div class=\"foo {{#if state}}prefix-{{../state}}{{/if}}\"></div>\ndoesn't seem like it should work at all, because it would be an explicit reference to the parent scope, which is non-existent.\n. Do you still see the issue in this fiddle? http://jsfiddle.net/8qrKd/\n. The issue is that calling can.view.Scope.prototype.compute doesn't consistently return a compute. It will only return a compute if the requested attribute's parent is observable, otherwise it creates a can.compute and does nothing with it. I'm to assume this boils down to something as simple as \"this was probably a typo\" or \"this was an unintentional slip.\"\nI agree with @daffl, this makes sense. And merging against master it works just fine. My theory as to what cause the test to break was that the pull request came right before https://github.com/bitovi/canjs/commit/cfb6bd0d5476e487db64fb8518e859f73564f508 which fixed some breaking tests.\n. Yup, I see your error, ran your test with and without your fix, and it seems to be working. Merging.\n. This isn't a bug with scanner.js, this is the intended behavior at the browser and HTML spec level. See http://jsfiddle.net/vR4MF/1/ for example.\nIf you take a look at http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag bullet point six:\n\nThen, if the element is one of the void elements, or if the element is a foreign element, then there may be a single U+002F SOLIDUS character (/). This character has no effect on void elements, but on foreign elements it marks the start tag as self-closing.\n\nThose void elements include area, base, br, col, embed, hr, img, input, keygen, link, menuitem, meta, param, source, track, wbr and those foreign elements include elements from the MathML namespace and the SVG namespace.\nSo in this case the browser is rendering it as <my-comp>, and since there is no closing tag, the browser assumes you meant to wrap everything in a <my-comp> tag.\nSo you're going to want to do:\njavascript\ncan.view.mustache('<my-comp></my-comp><div class=\"outside\"></div>')()\n. I'll have to fix those up. Thanks for the heads up!\n. So I went through and made it so you can use <template>/<script>/<whatever-your-fancy> for templates.\nI also took this time to finally remove something that always bugged me with doing templates in CanJS, and removed the inherent need to specify the template type in your template tag.\nBeforehand you had to do something like:\nhtml\n<script id=\"mustache-template\" type=\"text/mustache\">\n  <h1>Hello {{name}}</h1>\n</script>\nNow you will be able to get away with something like\nhtml\n<template id=\"mustache-template\">\n  <h1>Hello {{name}}</h1>\n</template>\nThe only time where you will need to specify the type now is if you steal/require/include can.EJS in your project and want to still use an inline Mustache template.\n. The spec for attributes in HTML5 is that they have at least one character after the hyphen, is XML-compatible, and contains no uppercase ASCII letters. In addition, all attribute names get automatically ASCII-lower cased.\nI'm going to have to say this is a Won't Fix, in my opinion, because this is the intended behavior of the browser. Check out http://canjs.com/can/component/examples/paginate.html for an example of what we do with camelCase: (Ctrl + F + deferreddata).\n. The point is that the browser will automatically convert attributes to lower case for you.\nYou certainly COULD do \nhtml\n<grid deferred-data=\"websitesDeferred\"> ....</grid>\nand update the grid's can.Compontent internals to look like\njs\n...\n    \"{deferred-data} change\": \"update\",\n    update: function () {\n      var deferred = this.scope.attr('deferred-data'),\n...\nand it would work just fine.\n. That's fair. As someone just pointed out to me the HTML spec has hyphened elements converted to camel case on the JavaScript side.\nI'll reopen.\n. I approached this two ways: first I considered treating can.Map the same way as $.prototype.data so you could do something along the lines of:\njs\nvar x = new can.Map({'foo-bar': true})\nx.attr('foo-bar') // true\nx.attr('fooBar') // true\nx.attr('fooBar', false)\nx.attr('foo-bar') // false\nx.attr('foo-bar', true)\nwhich solved the problem pretty quickly; however @dispatchrabbi convinced me that this would probably do more harm than good. So I scrapped it, and chalked it up to \"it seemed like a good idea at the time.\"\nThe second way, which I am finishing testing, is a lot less intrusive and will only effect can.Component. It just auto camelCases all hyphenated attributes.\nExpect this, accompanied by a test for it, in 2.0.1.\n. Yeah, #512 is a good reason to have it there (plus just because it wasn't used by the framework doesn't mean someone wasn't using it).\nI'm going to add in a can.camelize back into can/util/string.js and as an added bonus you'll get the reverse action as well: can.hyphenate!\njs\ncan.hyphenate('fooBarBaz'); // => foo-bar-baz\n. Yup, makes sense. helpers is doesn't change pointers whereas you turn it into a new object.\nAdding a test based on your fiddle as well that reflects the change/issue.\n. I'd love to have another one of your 15-30 minute lunch sessions where you explain the performance gains we get from this.\n. Thanks for pointing that out. I'll find the correct fiddle and get that updated tout suite.\n. All fixed up. http://canjs.com/guides/RecipesControls.html\n. Looks good. Merging, thanks!\n. Man...this was a tricky one to track down. It turns out that when you wrap a compute in a can.Map, upon setting a value for that compute, it unintentionally changes that attribute's value to the result of the compute.\n. So after talking with @justinbmeyer we came to the conclusion that this is intended...ish. .attr(prop, val) is intended to set the value of a property, regardless of whether or not the value is a compute.\nWhat you want to do, using your fiddle as an example, is:\njs\nthis.options.testMap.attr('test')('after2');\nThis will get the compute on testMap, then you can call it with the value you want to change it to. This is where my previously stated \"ish\" comes into play. Currently if you do .attr(prop) on a compute, it will return the compute's value and not the compute itself. I'm cleaning up the fix to this and writing a test for it.\nThis should still be in 2.0.2 which should be landing later today.\n. Hey Fabian,\nI'm pretty sure we're on the same page. After this code I committed get's merged, your example will work in 2.0.2 just by changing\njs\nthis.options.testMap.attr('test', 'after2');\nto\njs\nthis.options.testMap.attr('test')('after2');\nThe issue with c2('after') not updating accordingly was fixed in 2.0.1 (Give http://jsfiddle.net/FLj7b/1/ a looksie, which uses 2.0.1). \n. I just pulled latest master and did the following test can.Control:\njs\nvar Test = can.Control.extend({}, {\n  init: function(el, ev) { },\n  '{document} mousemove': function(el, ev) {\n    console.log('triggered mousemove');\n  }\n})\nand things seem to be kosher. This was fixed in https://github.com/bitovi/canjs/commit/92e1822a3cdb5cb48dd91a888b20352cc7a2038f though. Can you pull latest master again and confirm?\n. EDIT: Upon further investigation and testing with Handlebars, this is about par for the course. For example if you go to http://tryhandlebarsjs.com/ and try the following data:\njs\n{ \"each\" : \"bar\" }\nwith the following template:\nhtml\n<h1>{{each}}</h1>\nit'll balk at you with the same type of error:\njs\n// TypeError: Cannot read property 'fn' of undefined\nThe real question is: For this type of situation do we maintain the status quo, or do we do something? If we do something, what is it that we do?\n. True, but in our case with is also a keyword.\n. Merge failed due to phantomjs timing out, but the CI test that failed was me removing two commented out lines of code. Merging.\n. +1\nIn hindsight this makes sense, I didn't think about this use case at the time.\n. @daffl Yes, just let me quick add a commit to the branch that removes the can.compute as @justinbmeyer suggested. A compute does not need to be created, as he suggested.\n. :+1:\nBy all accounts, I have always done can.view(template, options) and occasionally have done templateFunction(options). Also when I've done training, I also show the former more often. If this is how we normally go about things (without steal) then it should probably be the showing it in the examples, especially since it is the first way people learn how to use can.view.\nIt's a few more lines of code, but less confusing with can.view documentation as supplemental.\n. :+1:\nhttps://github.com/bitovi/canjs.com/issues/177\n. @daffl PR submitted.\n. \n. \nNo sweat. :)\n. Done and done @justinbmeyer \n. This'll be done with a flag called canfixture (canfixture? usefixture? disablefixture? fixture? @justinbmeyer I'm open to names) that works similar to can.fixture.on in the prefilter.\n. Also will need doc updates.\n. Gonna bump this but put a spin on it.\nI don't necessarily think that can-value and {($value)} should update on input, but I do think we should update our stuff to support can-input and ($input)\n. Happened to just run into a need for this. Giving it a :+1: \n. The situation I needed it for was a virtual getter property to check the validity of all the items in a list:\n``` javascript\nvar Items = can.List.extend({\n    Map: SomeItem\n}, {\n    define: {\n        areValid: {\n            type: 'boolean',\n            get: function() {\n                var areValid = true;\n            this.each(function(item) {\n                areValid = item.attr('someCondition');\n\n                return areValid;\n            });\n\n            return areValid;\n        }\n    }\n}\n\n});\nnew Items().attr('areValid'); // -> true | false\n```\nI can't imagine this would look any different on a can.List than it would on a can.Map honestly.\n. That particular one might be able to be a simple function, though I happen to want to value to be live bound, but couldn't that argument be made for any virtual getter property?\njavascript\nvar Person = can.Model.extend({\n    define: {\n        fullName: {\n            get: function () {\n                return this.attr(\"first\") + \" \" + this.attr(\"last\");\n            }\n        }\n    }\n});\nfullName could be a simple function as well.\n. So, I think we are both agreed - this is something that would be beneficial to add, yes?\n. Do you mean something such as this?\njavascript\nvar List = can.List.extend({ }, {\n    define: {\n        '0': {\n            // By default, the first item in every list should be the beginning\n            // of 2016 (for whatever reason).\n            value: function() {\n                return new Date('1/1/2016');\n            }\n        }\n    }\n});\n. That one is definitely trickier, unless we assume that everyone will only get items from an array with an iterator such as can.each or can.List.prototype.each or with .attr() e.g. list.attr(0). Because it breaks down otherwise.\nAt minimum, it would be nice if can/map/define worked on the expando properties and maybe afterwards we went back and looked at how it should work for list items.\n. @justinbmeyer Test added.\n. @Bajix The advantage it offers is a simpler and obvious syntax. We can already use type...if we extend a map. For lack of a better phrase...that's pretty poopy. I don't want to have to go through that trouble just to define an object within my map.\n. No need, I forgot to assign this to myself. @akagomez and I already worked on this, he is going to work on the doc updates.\n. @matthewp And I officially feel like an idiot.\n. @whitecolor It will affect all attributes - but it will have the same minimal footprint that define has already.\n. @whitecolor Your use case is the entire reason why I wrote the define default behavior to begin with. I'll have a fix in before end of weekend.\n. @whitecolor - Check the provided diff. I added your test with a minor tweak to the define tests. Thanks for catching this, because as I said...your use case was the whole purpose to me making this feature. I want to tie AppState to can.route, but I don't want EVERYTHING put in AppState to be serialized.\n. ...aside from the linting erros. :S\n. :+1:\n. @justinbmeyer @daffl - is there an ETA on something that would be considered \"good enough?\" I'd rather not have to fork CanJS to fix such a detrimental bug.\nAlso this fix only works with Stache - Mustache still has a problem, will that be fixed as well?\n. Incoming speculation, with links to lines in code:\nWhen we replace the <content/> tag with the subtemplate, we never set replacements  on the subtemplate nodeList when we register it. So when we remove the component from the DOM and unregister the subtemplate nodeList, since it doesn't have the replacements property, it doesn't get deleted from the nodeMap.\nAfter doing some work arounds to force the contents we replace <content /> with to be seen as a parent element and, therefore, have that replacements array - I was able to remove your memory leak, but I'm sure we'll talk more in the morning.\n. Seems like this should be tied in with #1626, and they're not separate concerns.\n. What's the benefit of a simple handler over a regular handler?\n. Oh, neat! So basically quick and dirty helpers that have zero liability of live binding?\n. It works in windows besides the primary window, meaning it'll allow inserted events to fire if you insert DOM into a different window.\n. @daffl wouldn't switching Stache to use VDom be a substantial change? I remember VDom being a 3.0 feature because of this.\n. While I like the concept, I'm not so sure it's the right solution to the problem you are expressing, which is unnecessarily repetitive events firing on batching. Let's use your example:\n``` js\nvar list = new can.List(); \ncan.batch.start();\nlist.push('a');\nlist.push('b'); \nlist.push('c');\ncan.batch.stop()\n```\nA length event will fire three times with the value being three. Do we REALLY want three events firing...or do we want one? I can't think of a case where I would want three events firing, especially if it is the same event (though I challenge someone to coming up with one, I'm sure it exists). \nI think coming up with a debounce/throttle addition to the batch API, while nice, fixes the symptom, not the problem.\n. @akagomez Sorry, what I meant was that the list's length property would be 3. Not what newVal would be equal to.\n. I guess the big thing for me is I have a certain expectation of can.batch that's not being met. Not to detract from your suggestion or implementation because I think it's definitely worthwhile for what we currently have, say with the following example:\n``` js\nvar map = new can.Map({\n    list: [1]\n});\ncan.batch.start();\nmap.attr('foo', 'bar');\nmap.attr('foo', 'baz');\nmap.attr('list').push(2);\nmap.removeAttr('list');\ncan.batch.end();\n```\nWhat I would personally expect to get fired are the following events in map:\n- change (attr: 'foo', how: 'set')\n- change (attr 'list', how: 'remove')\n- foo (newVal: 'foo', oldVal: 'bar')\n- list (newVal: undefined, oldVal: [1,2])\nBecause going from the start of batching to the stop of batching, that's really all that's (seemingly) important.\nWhat we currently get is the following:\n- change (attr: 'foo', how: 'add')\n- change (attr: 'foo', how: 'set')\n- change (attr: 'list.1' how: 'add')\n- change (attr: 'list', how: 'remove')\n- foo (newVal: 'bar' oldVal: undefined)\n- foo (newVal: 'baz' oldVal: 'bar')\n- list (newVal: undefined, oldVal [1,2])\n- I think I might've missed one or two\nThe answer might be \"yes, of course\" but - do we really need to fire all of those events when we are batching? Seems like many of them just aren't necessary.\n. :+1: Throwing strings don't provide things like stack traces and other Error goodies that are useful.\n. I...don't think so? How would it break the API?\n. @justinbmeyer I'm submitting one shortly, with more than just this throwing an error instead of a new string.\n. I feel like I should add that I saw this in a customer project that I am currently working on that desperately needs this fix, hence why I added the \"Priority\" label. I'm going to reapply it and assume it was removed because of the lack of understanding of that.\nAlso, thank you @ccummings.\n. lodash's isArrayLike will check if the value isn't null, whether or not the length property from the value is a proper length value, and isn't a function.\nPulling from their code's comments:\n\nA value is considered array-like if it's not a function and has a value.length that's an integer greater than or equal to 0 and less than or equal to Number.MAX_SAFE_INTEGER.\n\nisArrayLikeObject checks if it is like an object and is like an array by it's isArrayLike standards as mentioned above.\n. The core implementation is relatively simple and would mimic ReactJS pretty much 1 to 1\n``` js\nimport { default as Component, PropTypes } from 'can/component';\nComponent.extend({\n  tag: 'custom-button',\n  props: {\n    onClick: PropTypes.function.isRequired,\n    name: PropTypes.string\n  }\n});\n``\n. @justinbmeyer Updated my comment. Aconsole.warn` should be called in development mode.\nI disagree with the define plugin being the appropriate place for a few reasons.\n1.) It is a plugin, this is something that I feel should be baked in by default. The counter-argument has been made to me that define will become core soon but...\n2.) define's focal point is maps, which aren't necessarily the focal point of components. Properties we pass into a component are a focal point of components though.\n3.) The type of validation done on maps and define is not developer-centric. The purpose of PropTypes is very specifically developer-centric validation of component use.\n. I also feel like I should emphasize that I do not think this should be some component plugin, and should be built within Component core.\n. I don't think this is the right solution. While I understand that MDN says that you shouldn't use xlink:href and should just use href, I think the onus should be on the developer to do that in their code, not the framework.\nI think https://github.com/canjs/can-util/pull/98 is probably the right solution here.\n. Are you sure this works? It's an undocumented feature if that's the case.\n. ",
    "makebbekus": "@justinbmeyer I'm definitely open to other implementations (re: splice), but binding is precisely the issue we're having.\nLet's say we have a list of tasks that are bound to views with the following _cids:\nvar modelList = [\n{ _cid : 1, id : 'f', name : 'foo'},\n{ _cid : 2, id : 'b', name : 'bar'},\n{ _cid : 3, id : 'c', name : 'cat'}\n]\nIf the server comes back with this order : \nvar serverData = [\n{id : 'f', name : 'foo'},\n{id : 'c', name : 'cat'},\n{id : 'b', name : 'bar'},\n]\nThe current code leaves you with this:\n[\n{ _cid : 1, id : 'f', name : 'foo'},\n{ _cid : 2, id : 'c', name : 'cat'},\n{ _cid : 3, id : 'b', name : 'bar'}\n]\nBasically, the object with _cid 2 has now become the \"cat\" task.\nThis is a problem for us because if the user is looking at a view of a task (bound to the model with _cid 2), suddenly they are looking at a completely different object.\n. Awesome! Thanks, Josh.\n. ",
    "dimaf": "Well of course, there is no real reason for those spaces. But this is a valid HTML accepted by all browsers and in fact working with current  JSMVC release, so one or the other developer has used that in our code, probably even unintentionally.\n. exactly that will work..\nbut from what i see in validations.js line 62 \nhttps://github.com/jupiterjs/canjs/blob/master/observe/validations/validations.js#L62\njavascript\ncan.each([ can.Observe, can.Model ], function(clss){\nit does use can.Model hence needs to have dependency to model.js right?\nso I was wondering why you have not  included the dependency to Model and instead added this \njavascript\n// in some cases model might not be defined quite yet.\n    if(clss === undefined){\n        return;\n    }\n. ",
    "JeroGrav": "Here's a page that demonstrates the error for me \n``` html\n\n\n\n\n\n\n    <script id=\"1\" type=\"text/ejs\">\n            <h2><%=name %></h2>\n          <%if(this.children){ %>\n            <ul>\n            <%==render(\"2\", this.children) %>\n            </ul>\n            <%}%> \n    </script>\n    <script id=\"2\" type=\"text/ejs\">\n            <% $.each(this, function(i,child) { %>\n                <li><%== render('1',child) %></li>\n            <% }) %>    \n    </script>\n\n    <script type=\"text/javascript\">\n        $(function () {\n            var data = {\n                name: '1',\n                children: [\n                    {\n                        name: 2,\n                        children: [{\n                            name: 3\n                        }\n                        ]\n                    }\n                ]\n            };\n            can.view.cache = false; //change this to true to cause the problem\n            data.name = 'can.view is not cached';\n            $('body').prepend(can.view('1', data));\n            can.view.cache = true;\n            data.name = 'can.view is cached';\n            $('body').append(can.view('1', data));\n        });\n\n        function render(templateName, templateData) {\n            //just a helper function to allow us to put breakpoints in the middle of a template render\n            var a = can.view.render(templateName, templateData);\n            return a || 'undefined';\n        }\n    </script>\n</body>\n\n\n```\n. I have tried to repro that test of yours above. The only change I made is to not use steal.\nThe issue still appears for me. My output is (extra newlines pruned out)\nhtml\n<body>\n<h2>\n can.view is not cached\n</h2>\n<ul>\n <li>\n  <h2>\n   2\n  </h2>\n  <ul>\n   <li>\n    <h2>\n     3\n    </h2>\n   </li>\n   <li>\n    <h2>\n     4\n    </h2>\n   </li>\n  </ul>\n </li>\n <li>\n  <h2>\n   a\n  </h2>\n  <ul>\n   <li>\n    <h2>\n     b\n    </h2>\n   </li>\n  </ul>\n </li>\n</ul>\n<h2>\n can.view is cached\n</h2>\n<ul>\n <li></li>\n <li></li>\n</ul>\n    </body>\nSo as you can see, I still have the problem. I am using canJS 1.0.7 which is the latest release. Could you test it against that? If it fails for you but succeeds in the latest build then it seems you have indeed fixed it. Otherwise ...\n. ",
    "ravihamsa": "It's an expected behavior, Person.List hold instances of Person, hope we get a fix soon\n. I did download 1.1.3 version, this problem is still there. is this really resolved?\n. ",
    "whitecolor": "One more related question should item be converted to \"parent\" List type when it pushed there as raw object?\njavascript\nvar persons = new Person.List([])\npersons.push({name: Alex})\nShould elements in persons be Person instances? I think thy should.\n. why call just Items, in what case does it make sense?\nat list if Items is Construct/Observer or Observe.List/Model.List it does make sense to all new Items, no?\n. Yes, using function is good, but why not make it automatically.\n. Ok, it's just proposal. You know better. But for standard objects like Costruct/Observer/Model/List probably it could be done.\n. Yes they (107 and 106) relates. What I propose that if you wnat to get Observe.List named for example Blocks = Block.List (which assumed to be collection of elements of type Block), instead of code:\n\nattributes: {\n            items: function(items){\n                return new Blocks(items.map(function(item){\n                    return new Block(item)\n                }))\n            }\n        }\n\nIt would be much more elegant to write just like that:\n\nattributes: {\n            items: Blocks\n        }\n\n. I've tried latest master I still have @@!!@@ on the top of a table.\n. I think it should be put in docs, didn't see it there.\n. Is two way binding going to be supported in EJS?\n. Then, it seems that guys from bitovi talked about some plugin for two-way form binding.\n. It seems that there is no.\n. Sorry, duplicate.\nhttps://github.com/bitovi/canjs/issues/238\n. Maybe this could be done with some \"events\" API\njavascript\ncan.Model({\n   events: {\n      // handle change event of someAttr\n      'someAttr': function(ev, val){\n          this.save()\n      }\n   }\n})\nThat would implement bind and unbind correctly.\n. setter is perprocessor and change event is post processor, also there are events for can.List and events of changing nested attributes 'someAttr.nested'. So I propose to think about such API. Currently I just use this.bind(...) inside init function to make such stuff.\n. Is it supposed to work?\n. Does this work? In what version?\n. Do you mean Observe.List.protorype.replace? Why it is used while creating new model/list from new data arrived?\n. No, I've updated fiddle and removed replace, I just rerender view now with new list, it seems  that the problem in findAll.\nhttp://jsfiddle.net/qYdwR/645/\n. No, I've updated fiddle and removed replace, I just rerender view now with new list, it seems  that the problem in findAll.\nhttp://jsfiddle.net/qYdwR/645/\n. Yes, thank you, it seems that it does. I just doesn't understand what is the logic behind mixing behind model store that made it to look at previously loaded instance? Can you explain?\n. Yes, thank you, it seems that it does. I just doesn't understand what is the logic behind mixing behind model store that made it to look at previously loaded instance? Can you explain?\n. The idea is: Models are uniquely identified by ID. So if you get model data with the same id Can assumes that it is the same model and will update the store.\nOk that is very good point. I just don't undertand how nested lists where updated that caused the issue?\nMy particular case:\nI load from server a model, model contains nested list of items. Then I decide to synchronize model state with server, I load again the same model (with the same id). Between this two syncs new item was added on server to DB to the list. So I get new model with updated list that contains one new item. Items in the list say may have or have not field called 'finished', new item doesn't have it, but after loading can.Model adds this field (\"finished\") to new item and takes the value from first item of the list that where loaded previously. \nI hope I made my self clear. Can you explain it?\n. The idea is: Models are uniquely identified by ID. So if you get model data with the same id Can assumes that it is the same model and will update the store.\nOk that is very good point. I just don't undertand how nested lists where updated that caused the issue?\nMy particular case:\nI load from server a model, model contains nested list of items. Then I decide to synchronize model state with server, I load again the same model (with the same id). Between this two syncs new item was added on server to DB to the list. So I get new model with updated list that contains one new item. Items in the list say may have or have not field called 'finished', new item doesn't have it, but after loading can.Model adds this field (\"finished\") to new item and takes the value from first item of the list that where loaded previously. \nI hope I made my self clear. Can you explain it?\n. Yes, that is the point, as I've said new list was \"mixed\" with previously loaded, wrong verb -) it was actually merged with it.\n. Yes, that is the point, as I've said new list was \"mixed\" with previously loaded, wrong verb -) it was actually merged with it.\n. Have you looked at fiddle?\n. Have you looked at fiddle?\n. @justinbmeyer \nIn your example newVal will still be converted to observe. And I think It is ok for default behaviour because converter is for transforming (changing the structure or type of objects).\nI wanted to propose the Idea to extend attributes description notation to more robustly reflect the schema of observe/model and particularities of some attributes (I like this style as it is implemented in  mongoose.js ODM)\n\nattributes: {\n     special: {\n           convert: 'object', // tells what converter to use, the property also may be called \"type\"\n           default: {....}, //sets default value\n            observe: false, // tells not turn into observe,\n            serialize: false // test not to serialize attribute while sending to server\n     }\n}\n\nor that that maybe done by just including static property (but I like the first variant more =) )\n\n    notObserve: [..list of not observable attributes]\n\n. @justinbmeyer \nIn your example newVal will still be converted to observe. And I think It is ok for default behaviour because converter is for transforming (changing the structure or type of objects).\nI wanted to propose the Idea to extend attributes description notation to more robustly reflect the schema of observe/model and particularities of some attributes (I like this style as it is implemented in  mongoose.js ODM)\n\nattributes: {\n     special: {\n           convert: 'object', // tells what converter to use, the property also may be called \"type\"\n           default: {....}, //sets default value\n            observe: false, // tells not turn into observe,\n            serialize: false // test not to serialize attribute while sending to server\n     }\n}\n\nor that that maybe done by just including static property (but I like the first variant more =) )\n\n    notObserve: [..list of not observable attributes]\n\n. In what version when has it been changed?\nAnd if you don't mind I would draw your attention on other issue https://github.com/bitovi/canjs/issues/250\nabout ignoring attributes while serializing (sending to server).\n. In what version when has it been changed?\nAnd if you don't mind I would draw your attention on other issue https://github.com/bitovi/canjs/issues/250\nabout ignoring attributes while serializing (sending to server).\n. @justinbmeyer\nI've tried the method proposed with attributes and convert with latest can.js - it seems not to work.\n. @justinbmeyer\nI've tried the method proposed with attributes and convert with latest can.js - it seems not to work.\n. So, what do you think is it worth implementing in observable future?\n. So, what do you think is it worth implementing in observable future?\n. Think this maybe closed, define plugin does it.\n. Think this maybe closed, define plugin does it.\n. @Wizardum it works only with strings and window object namespace.\n. @Wizardum it works only with strings and window object namespace.\n. So, I believe we have to wait until that a little while )\n. So, I believe we have to wait until that a little while )\n. Well it definitly not something super functional, but to it allows to replace 'string based' calls like .attr('document', ...) on method calls like .setDocument(...). \nAnd this even saves at least 4 chars =)\n. Well it definitly not something super functional, but to it allows to replace 'string based' calls like .attr('document', ...) on method calls like .setDocument(...). \nAnd this even saves at least 4 chars =)\n. \"You still need to call .attr('document', ...) at one point for it to create the setter method though. \" not sure what problem you do mean. Yes you should, but you (actualy framework) do it one time.\nYes ES5 getters/setters woulbe great, the only problem that some times you want to have some auxiliary properties that are not observe attributes, but just observe's plain object's properties. So it wouldbe good to have a way to distinct between.\n. \"You still need to call .attr('document', ...) at one point for it to create the setter method though. \" not sure what problem you do mean. Yes you should, but you (actualy framework) do it one time.\nYes ES5 getters/setters woulbe great, the only problem that some times you want to have some auxiliary properties that are not observe attributes, but just observe's plain object's properties. So it wouldbe good to have a way to distinct between.\n. Yes I use setter plugin, and because of it I can not create setters like setDocument by myself.\n. Yes I use setter plugin, and because of it I can not create setters like setDocument by myself.\n. That is an old problem that happens sometimes \"unexpectedly\" is not resolved, and I always have to patch render.js each time I update.\n. That is an old problem that happens sometimes \"unexpectedly\" is not resolved, and I always have to patch render.js each time I update.\n. definitely + \n. definitely + \n. Wasn't it implemented yet?\n. Wasn't it implemented yet?\n. So what does that code mean in models.js? \n\n            // `destroy` does not need data.\n            if ( type == 'destroy' ) {\n                args.shift();\n            }\n            // `update` and `destroy` need the `id`.\n            if ( type !== 'create' ) {\n                args.unshift(getId(self));\n            }\n\nIn Ajax options generator function data contains only id, so any other params in {} are replaced with false.\n. So what does that code mean in models.js? \n\n            // `destroy` does not need data.\n            if ( type == 'destroy' ) {\n                args.shift();\n            }\n            // `update` and `destroy` need the `id`.\n            if ( type !== 'create' ) {\n                args.unshift(getId(self));\n            }\n\nIn Ajax options generator function data contains only id, so any other params in {} are replaced with false.\n. this code removes all data other than id\n\n        destroy : {\n            type : \"delete\",\n            data : function(id){\n                var args = {};\n                args.id = args[this.id] = id;\n                return args;\n            }\n        },\n\n. this code removes all data other than id\n\n        destroy : {\n            type : \"delete\",\n            data : function(id){\n                var args = {};\n                args.id = args[this.id] = id;\n                return args;\n            }\n        },\n\n. so, will you consider this a bug or feature to add? Besides I don't know how to create fiddle that will show the behaviour. It blocks all ajax requests. But look at the code I supplied it is obvious.\n. so, will you consider this a bug or feature to add? Besides I don't know how to create fiddle that will show the behaviour. It blocks all ajax requests. But look at the code I supplied it is obvious.\n. +1 that would be nice\n. Is it going to be in 2.1?\n. Is it going to be in 2.1?\n. This feature is really needed.\n. This feature is really needed.\n. Just intresting, any new on this?\n. Just intresting, any new on this?\n. I think it's no easy task to take on and complete for some one who is not in the loop. @matthewp is our oly chance.\n. I think it's no easy task to take on and complete for some one who is not in the loop. @matthewp is our oly chance.\n. > We could also punt on the feature and instead make it work with native shadow DOM or the shadow DOM polyfill.\nWhat is wrong with this approach?\n. > We could also punt on the feature and instead make it work with native shadow DOM or the shadow DOM polyfill.\nWhat is wrong with this approach?\n. Is it going to be in 2.3 or anytime soon?\n. Is it going to be in 2.3 or anytime soon?\n. Yes, thanks, I though maybe it would be convenient to build it in, it is not big itch for me too though.\n. Yes, thanks, I though maybe it would be convenient to build it in, it is not big itch for me too though.\n. Justin, your test passes only because parent and child components have the same name for the attribute\nHTML\n<my-toggler visible=\"visible\">\nif you replace \"visible\" attr in child for example with \"shown\", something like:\nHTML\n<my-toggler shown=\"visible\">\ntwo way binding won't work as it will try to change \"shown\" attribute in parent, not \"visible\".\nHere is fiddle\nhttp://jsfiddle.net/xKc3H/249/\n. Justin, your test passes only because parent and child components have the same name for the attribute\nHTML\n<my-toggler visible=\"visible\">\nif you replace \"visible\" attr in child for example with \"shown\", something like:\nHTML\n<my-toggler shown=\"visible\">\ntwo way binding won't work as it will try to change \"shown\" attribute in parent, not \"visible\".\nHere is fiddle\nhttp://jsfiddle.net/xKc3H/249/\n. End there is another problem with two way binding if you try to bind \"complex\" properties:\nHTML\n<my-toggler shown=\"visibility.visible\">\npropertyDataFromScope.parent for \"visibility.visible\" is not parent scope, but visibility map.\n. Yes I tried it in my project, I updated can.js yesterday from master. I had to change some code to fix this behaviour. Where there any fixes for this?\n. Would you confirm that this doesn't work? If yes, it is quite severe, issue should be opened and fixed for 2.0.1, I think.\n. Ok, sorry about that. But in can.Component docs http://canjs.com/docs/can.Component.html there are examples of templates like\nHTML\n<hello-world/>\n. Well I get your point, but I believe source code is enough for that.\nAs for production use, I think it is a good style to remove anything that accomplished its task in any system. It helps to keep things lean and clean.\n. Well maybe you are right, but I'll explain my point.\nAs for traditional attributes, yes they are not removed. But because they intended to \"work\" while whole element lifecycle and removing them will break things. \nThose (like class, style, hidden, width, etc) are actually state attributes, changing them will change things. As for custom data- attributes they intended to pass a static data and mostly be used while element lifecycle too.\nWhat is the role of attributes for components? As I understand it is to have a generic and common way of passing the data to the component for its initialization, without need of excessive javascirpt. What else? This attributes probably are not intended to be used in CSS or even JS lately, are they? \nI can hardly think how designers can benefit from them. I would even think that this information would be exessive for them, as it is out of their area of responsibility, and could only mess things up.\nThat is why I say they should be removed as wastes. Things should be kept working and clean.\n. Besides I'm talking of removing attributes that contain data attributes names not string data (as they really can be used).\nHTML\n<page-turn direction=\"back\" paginator=\"content.paginator\"></page-turn>\n\"direction\" attribute (that is passed to scope) can be lately used (in CSS for example) and it make sense to leave it alone, but \"paginator\" is exessive for user's (esp. designer's) eye and for browser engine either.\n. I understand your point =) You are the boss, I'm not trying to persuade you any more. But I will state some logical flaws in your arguments (from my point of view) , maybe it will help later.\nWhen I talk that they are exessive I'm not even tacking about browser's performance.\n\"class\" attribute (as \"id\", \"name\" etc) is used to identify elements either in JS code or in CSS. When you change element's class it will probably impact the presentation of the element at once, or this change will affect some JS logic later. If it is not it should not be there \"just to explain to designer/dev/user how things work\". (to me its like leave not minimized code with comments in production)\nIn terms of my last point, even with mutation support it doesn't make sense to keep them after a code caught up the event of attr change and hooked up new value to a scope. Then attr can be deleted again without any consequences. (actually I don't really understand the need of it. You can make now by some custom $.fn. function that would do that - only to get rid of some custom $.fn and use standard features)\n. \"Deleting it would remove that property from the scope.\"\nI'm not sure that it is a good idea... Maybe emptying should?\nbut perhaps I just don't get the deep meaning of all this stuff =) Now for me those attributes are just a part template development markup like mustaches {{.....}}.\nid too can impact the presentation if used in CSS and should be used in JS code.\n. Well, I considered some cases and think that you right mostly. It also will be very useful change attributes and change behavior and presentation of a component. So thanks for the explanation of the concept and roadmap.\n. Any comments on this? Maybe it should arrive in 2.0.1 if applicable.\n. Well I don't get your point.\nIn template you type deferredData as attribute name (which is not compliant with HTML5 scpec), while component's init it is converted to deferreddata for scope attribute name which is a bad name for JS attribute/property, camel cased deferredData is good.\nWhy not do\nHTML\n<grid deferred-data=\"websitesDeferred\"> ....</grid>\nand then while component init convert it to camel cased scope's attribute name deferredData?\n. Yes, I understand about attribute case in HTML. That was not the point of my original post. \nI'm talking about that in this case \"deferred-data\" and deferreddata are both bad names for scopes attribute. defferredData is good. And such cases are not rare when you have to provide complex attribute name (for scope)\nI think it is quite logical convention about the way of converting HTML attribute names to JS attribute names (and vice versa).\ndeferred-data (HTML) <--> deferredData (JS)\n. Great, interesting what HTML spec says about converting colon (:) in HTML attribute on JS side.\n. Maybe it could be used there https://github.com/bitovi/canjs/issues/512\n. +1\n. Well perhaps fiddle is incorrect, but there was another code in my version that I updated from master a couple of days before I found out this issue, and it didn't work:\njavascript\n    // there's a value, setup two-way binding ...\n    twoWayBindings[name] = propertyDataFromScope.parent\nand in current version it is:\njavascript\n    // setup two-way binding\n    twoWayBindings[name] = computeData\nOk. But some problems still remain.\n. this is broken in latest version:\nhttps://gist.github.com/whitecolor/7422552\nbecause I try to bind the nested property\njavascirpt\n<my-toggle shown=\"props.visible\">\n. What do you think about such case:\n``` javascript\n          can.Component({\n                tag: 'my-toggle',\n                template: 'Toggle',\n                scope: {\n                    shown: true,\n                    toggle: function(){\n                        this.attr('shown', !this.shown)\n                    }\n                }\n        })\n\n        can.Component({ \n            tag: 'my-parent',\n            // besides two way binding between visible and shown attributes, \n            // if there is no \"visible\" attribute defined in my-parent scope, it is set to initial \"shown\" value of my-toggle\n            template: '<my-toggle shown=\"visible\"></my-toggle>',\n            scope: {\n            }\n        })\n\n```\nmy-parent creates my-toggle and sets shown=\"visible\", but visible attribute is not presented in my-parent scope initially, and in my-toggle it has default value.\nSome times it could be useful if while init of my-toggle component, visible attribute of my-parent would be set to value of shown attribute of my-toggle.\n. Well \"each\" is a keyword should probably not be used as data attribute name.\nIn my case I don't use keyword as data attribute name.  {{text}} is not a helper. Error appears only if {text: 'with'}. Strange bug.\n. Justin, well, actually I hoped that compute would be be passed as a compute function not as value here is a modified test for this:\n``` javascript\ntest(\"component does not respect can.compute passed via attributes (#540)\", function(){\nvar data = {\n    compute: can.compute(30)\n}\n\ncan.Component.extend({\n    tag: \"my-component\",\n    template: \"<span>{{blocks}}</span>\",\n\n    scope: {\n        init: function(){\n            // currently this.blocks is just a value of 30\n            this.blocks(45)\n        }\n    }\n\n\n})\n\nvar template = can.view.mustache(\"<my-component blocks='compute'></my-component>\");\n\nvar frag  = template(data)\n\nequal(frag.childNodes[0].childNodes[0].innerHTML, \"45\")\n\n});\n```\n. Ok, that makes sense.\n. Don't you think that if component's attr is changed  this.attr('blocks', 45 ), then data.compute() value should be updated to? Not it is not, stays the same.\n. It seems that the problem is wrong and added test didn't pass because inserted event (for unknown reason) didn't fire.\nTwo way binding seems to be inconsistent in following case: when attribute value is changed again in change event handler two way bound attribute is not update. It happens because of use of scopePropertyUpdating in component.js.\nNot sure if it is bug (so don't make a pull request). The test for the case:\n``` javascript\ntest(\"component two way binding inconsistency issue with scopePropertyUpdating\", function(){\nvar data = new can.Map({prop: 1})\n\ncan.Component.extend({\n    tag: \"my-component\",\n    template: \"<span>{{prop}}</span>\",\n\n    events: {\n        '{scope} prop': function(scope){\n            if (scope.prop === 2){\n                console.log('set scope.prop to 0')\n                // after this scope.prop is 0, but two bound data.prop is still 2\n                scope.attr('prop', 0)\n            }\n        }\n    }\n})\n\nvar template = can.view.mustache(\"<my-component prop='prop'></my-component>\");\n\nvar frag  = template(data)\n\ndata.attr('prop', 2)\n\n//data prop.should be equal 0\nequal(data.prop, 0)\n\n});\n```\n. Think this needs to be closed too.\n. @daffl \nNo, I tried. I've updated my code in OP, if you try you should see the time difference (previous version was incorrect for the case and shown no difference). On my PC I have ~5 sec for version with teardownMap and ~0.1 sec for version without it. \nPerformance drop is significant when you have quite large array to be converted to can.List many times in a row.\nI noticed that because in my application I started to experience performance issues after update from master, debugged it and found out that it was due to https://github.com/bitovi/canjs/commit/e767fc64b87fbadd07ebd4650a779ae74137e3f8 commit.\n. So what does this mean? After https://github.com/bitovi/canjs/commit/e767fc64b87fbadd07ebd4650a779ae74137e3f8 performance became worse obviously. If what is the a way to improve it?\n. Where this can be useful?\n. word \"context\" is more often seen in real life and thus more common to be used as model's attribute name. \"scope\" is pretty netural and rare. In British words corpus (http://corpus.byu.edu/bnc/) \"scope\" has 3394 frequency score, \"map\" - 4026 and \"context\" - 8441.\n. Yes that is good, I don't know if it is needed to reserve new link method it could be accomplished via .attr(\"title\", title)  but maybe it is semantically more correct and safer to bring new method.\n\"links\" look desent.\n``` javascript\nlinks: {\n    // could just map scope's \"name\"  attribute to parent's componen't 'title' attribute, \n    // besides \"name\" could be compute or function defined in scope\n    '* title': 'name',\n// besides links could be used for back referencing to parent scopes\n\n// this would bring window-manager scope to \"windowManager\" scope property of current component   \n'windowManager': 'window-manager',\n\n  //would link window-manager \"prop\" to 'windowManagerProp' attribute\n 'windowManagerProp': 'window-manager prop'\n\n}\n```\n. \"links\" introduce and encourage tight coupling between components but as an option for a certain cases that is very good and quite safe to have such functionality. Not all components are designed to be absolutely independent and reusable.\n. 1) I think asterisk should mean in API any direct parent component\njavascript\nlinks: {\n    '* title': 'name',\n}\n2) and 3) is about back (reverse) referencing, if one wants to take attributes from parent scopes that is why component-tag name on the right (no need in some special characters like ^.\n2) Say one wants to access window-manager parent component's scope, maybe I could do\njavascript\nlinks: {\n    'windowManagerScope': 'window-manager',\n}\n3) Say one wants to access some parent component's property (from scope), maybe I could do \njavascript\nlinks: {\n    'windowManagerProp': 'window-manager prop',\n}\nOne could also use astersk to get direct parent\njavascript\nlinks: {\n    'parentProp': '* prop',\n}\n4) maybe allow local links between current component attributes and computes (not sure if that is needed)\njavascript\nlinks: {\n    'title': 'titleCompute', // will try to link title attr with titleCompute can.compute\n}\nit is an equivalent of\njavascript\nscope.link('title', scope.titleCompute)\n. first reaso was to have \"headless\" components (without wrapping tag), another reason multiple components on one element. I'm not sure if it really appropriate.\n. yes multiple components ont a big issue can.view.attr can be used, though component propose more robust API (scope, events) for creating comprehansive behaviour model. \nHeadless components would be intresting to have though.\n. I think this would be fine.\n. Yes\n. One more thing \"i\" modifier is exessive there. And look at this issue https://github.com/bitovi/canjs/pull/695 I had to add more in pattern to overcome it.\n. BTW I think there is a need in a parameter that will be able to prevent automatic removal of the model from store when all the bindings are removed (and let manual store management). \nHere is the case:\n1) I have some model that I loaded and present using some component, let say the component is the content of the tabs widget.\n2) Then I switch off the tab and the component is removed. All the bindings are moved from DOM. And model is removed from store. But I didn't I had a refences to the model instance and actually want to keep it memory for further actions - when the tab is switched back, component initiated again and renders the instance that I have in memory.\n3) Then during due to some actions model data is updated from from server and I have incorrect behaviour because I don't have model in store,\n. Bind empty handler? Isn't it artificial and looks odd? Is the scenario that I described so rare, why do you not considering it?\n. I would add some parameter to Model static.\njavascript\nkeepInStore: true\n. Ok, yes that doesn't relates to the issue stated in OP. The permanent store is bad because it provokes memory leaks if not properly managed manually. https://github.com/bitovi/canjs/issues/738\n. This reason of experienced problem is the following:\nNew data for Model {id:1, name: 'John', status: 'live'} arrived, new model was created as manually:\njavascript\nvar model = new Model(data) // new instance is placed in Model.store with id = 1\nThen again data for Model {id:1, name: 'John', status: 'dead'}, new model is created as manually again and new instance is placed to store (so previous was \"unexpectedly\" removed from store, though it was actually expected in terms of the code)\nThis can be avoided if new model is created using Model.model\njavascript\nvar model = Model.model(data) // new instance is place in Model.store with id = 1\nThe issue https://github.com/bitovi/canjs/issues/962 says that Model.model can be removed and new operator will check Model.store.\nSo, will \njavascript\nnew Model({id: 1, name: 'John'})\nalways return the same instance (taken from Model.store if it exits there) as Model.model does?\n. Thanks, wanted to make sure.\n. This maybe closes as well.\n. What is the reason behind the code checking can.Model._reqs when adding to store a newly created model?\nmodel.js:\njavascript\n// ## can.Model#setup\nsetup: function (attrs) {\n    // Try to add things as early as possible to the store (#457).\n    // This is the earliest possible moment, even before any properties are set.\n    var id = attrs && attrs[this.constructor.id];\n    if (can.Model._reqs && id != null) {\n        this.constructor.store[id] = this;\n    }\n...\nI have a situation where after first request to server model is not added to store because of this check. Is this expected?\n. Well I think this may be closed if you don't have plan to add this. To force persisting models in store I just bind empty handler to one of the attributes.\n. Well I think I've been misunderstood. I mean to set the scope of the component not to assign a current scope to component's scope attribute. \nWhat I meant that code\njavascript\n<media-file scope=\"mediaFile\"></media-file>\nwould merge mediaFile  (of parent scope) attributes with media-file scope.\n. Think this may be closed.\n. Are you going to add here plain object/array attributes support (that won't be converted to can.Map)?\n. Another feature that could be implemented in this plugin, is to allow out of the box setting deferred values to attributes\njavascript\n// so this would wait for findAll result and assign it to \"items\"\napp.attr('items', Item.findAll)\nfor this in define there could be defined some property \njavascirpt\ndefine: {\n    items: {\n        acceptDeferred: true, //or smth like that\n    }\n}\n. Yes, I understand I meant maybe to support setting deferreds out of the box. is the plugin ready for use/test?\n. It seems to be a wrong context inside serialize function (\"this\" is window object)\n. I think allowing to define a merging strategy (via map.define plugin) for particular attribute would fix this.\n. Yes I know that, but I would like to be able access element within helpers that return string. Besides it seems that can not bind attr change inside a helper that returns element function.\nThe case, say I have some component that has tabs, I want to have \"active\" class on it depending whether the tab selected (active) or not. Scope contains attribute \"activeTab\" that holds name of selected tab\nHTML\n<li tab=\"myFirstTab\" class=\"{{activeClass \"myFirstTab\"}}\">some text</li>\n<li tab=\"mySecondTab\" class=\"{{activeClass \"mySecondTab\"}}\">some text</li>\n``` javascript\nscope: {\n  activeTab: \"myFirstTab\"\n...\n}\nhelpers: {\n  // the helper returns class, but I have to also supply \n  // additional parameter \"tab\", \n  // which value I could get from the element attribute \"tab\"\n  activeClass: function(tab, options){\n    return this.attr('activeTab') == tab ? 'active' : ''\n  }\n}\n``\n. I'm using stache in latest 2.1, but it doesn't yet.\n. @justinbmeyer` tab elements as show in the code above are static, not dynamically build using can.List, so helper have no reference to the scope referring to a particular element. \"activeTab\" is scope attribute that contain active tab name,  and tab name is placed on the element via attribute \"tab\".\n. Will it be in stache?\n. I reopen it to add it to stache.\n. map.serialize('local') will serialize the \"local\" property currently with the attributes plugin. We couldn't support both attributes and define so this would have to wait until 3.0.\nWell but could this be supported now for apps where \"attributes plugin\" is not included?\nWhat about making it easy to make your own serializer methods? map.serializeToDB()? That might be something we can get in earlier.\nNow I use custom method which modifies serialized object (with standard serialize()) by adding and removing some properties. \nWhat do you mean by \"making it easy to make your own serializer methods\"?\n. But I think it is possible to handle let say define to know if attribute is loaded by placing some marker?\n. https://github.com/bitovi/canjs/pull/959\ntwo test, not sure if two pull request would be better.\n. It seems to work ok now.\n. Well right, but this could simplify change event handling for a particular attribute, without need of using bind.\n. Yes, probably.\n. huh, wrong pull.\n. Test for serialize wasn't passing for me, but now (after last update from repo) it does.\n. Are you going to remove can.Model's model and models functions?\nI use them to create new instance of model and insure that it checks model store before creating new instance.\n. @DVSoftware I'm talking about other thing. Before one had to redefine model or models to parse the structure, now one had to define parseModel(s) function.\nIn the code I see that model function uses parseModel to convert attributes to need structure and also it checks Model.store if instance exists there and merges new attributes with it, or create new instance if there is nothing in store. I don't understand the reason to remove this functions.\n. Ok, if new Model() will check Model.store, these functions are not needed.\n. Can you explain why remove\ncomputes directly on the prototype of a can.Map ?\nHere how I use computes currently\n``` javascript\nscope: {\n  items: can.compute(function(){\n        // some stuff\n        .....\n        return ....\n  })\n\n},\nevents: {\n      '{scope} items': function(){\n            // I would like to be able to handle items change here\n      }\n}\n```\nif just use function I have to create new attribute to bind its value (using define.get)\nwhat is so bad about such computes?\n. Could you elaborate my case using define plugin? So if I want to have some function and be able to handle it's change inside the code (like in my example).\n. ah yes, thanks)\n. Btw if you are going to\nremove direct properties on a can.Map\nare you going to include define plugin by default or get rid of define as plugin and make attribute definition API by default directly on prototype (without define property)?\n. Well maybe then ignoring attributes registered with can.view.attr would be right ting to do. \nOne more moment about can.view.attr attributes though, what if I want to supply properties to such \"mixin\" via additional attributes?\nHTML\n<my-component tooltip tooltip-placement=\"bottom\"><my-component>\nNot big issue, but still needs consideration.\n. I understand that I can get the information about the element inside attr callback, the question is what is the best pattern to supply additional information for such mixin attributes not to mess with component's attributes (if mixin attribute is on can.component element).\nBtw attribute callback desn't have access to parent scope, it is possible to provide it there (as third argument for attr callback for example)?\n. concat opeartion maybe added as well\n. good\n. I think such small things are not reasonable  to deliver in plugin as well. It can always be placed on prototype of those classes that need it.\nBut List.every https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every would be useful as well as List.some https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some.\n. What does {foo} mean? How to do i pass a parent scope's attribute name in one case and literal string in another?\n. I've implemented animation using custom components and CSS animations/transitions.\n. I suppose because I can not live bind some attr changes in such helper.\njavascirpt\nscope: {\n   tab: 'tab1'\n}\ntemplate:\nHTML\n<li tab=\"tab1\" class=\"{{activeTab}}\">Tab 1</li>\n<li tab=\"tab2\" class=\"{{activeTab}}\">Tab 2</li>\nI want activeTab helper to return 'active' on li[tab=tab1] if scope's attr tab is 'tab1'\nso suppose that helper options contain some reference to element, I would make a helper:\njavascript\nhelpers: {\n   activeTab: function(options){\n        return options.element.getAttribute('tab') == this.attr('tab') && 'active'\n   }\n}\nI don't know how to implement it with callback function.\nWithout reference to the element I have to provide additional parameter to helper\nHTML\n<li tab=\"tab1\" class=\"{{activeTab \"tab1\"}}\">Tab 1</li>\n<li tab=\"tab2\" class=\"{{activeTab \"tab2\"}}\">Tab 2</li>\njavascript\nhelpers: {\n   activeTab: function(tab){\n        return tab == this.attr('tab') && 'active'\n   }\n}\nsome times it is not very convenient, and it would be nice to have reference to element in helper options\n. again and again i'm facing the cases where this could be usefull\nI have a model in scope:\njavascript\nfragment: {\n start: 1,\n end: 10\n}\nFor example I've got two drag elements, they supposed to drag something, and change the attribute \"start\" or \"end\". So I have attribute \"drag\" on the element (which I use) in css and js code as well. An I have a couple of helpers which should return result depending on whether this is \"start\" or \"end\" drag. I have no scope contexts for them. \nHTML\n{{#fragment}}\n....\n<span title=\"{{dragText \"start\"}}\" class=\"{{activeDrag \"start\"}}\" drag=\"start\"></span>\n<span title=\"{{dragText \"end\"}}\" class=\"{{activeDrag \"end\"}}\" drag=\"end\"></span>\n...\n{{/fragment}}\nThe other option is to have more helpers:\nHTML\n<span title=\"{{dragStartText}}\" class=\"{{activeStartDrag}}\" drag=\"start\"></span>\n<span title=\"{{dragEndText}}\" class=\"{{activeEndDrag}}\" drag=\"end\"></span>\nBut it is exessive and unreasonable when you have more elements.\nIf it was possible to get element (and thus access the attributes of it) in the helper I could do just:\nHTML\n<span title=\"{{dragText}}\" class=\"{{activeDrag}}\" drag=\"start\"></span>\n<span title=\"{{dragText}}\" class=\"{{activeDrag}}\" drag=\"start\"></span>\n. I think it could be useful though I become to use direct inheritance less frequently in favor of extending needed part of the class.\n. This can be a useful standardized way to add a certain functionality to particular models that encourages modularity. For example I have some models\nCar\nHouse\nRefrigerator\nAnd I want to provide a pricing functionality: to each of this models this will add some price field, methods sale, exchange etc\nCurrently I use this approach quite often but have to write some exessive code to for init's hook up, mixin with define plugin etc\n. Ok, good, thanks.\n. I've updated the issue and narrowed down the problem scope. Probably this not a bug, but I can not get how I should handle the situation.\n. Ok I got that attr function in this case does a deep merge of for all observable attributes.\n. Is it going to be merged? Without it can-events does not work in production.\n. Is there any progress for this issue? BTW wy can.Model doesn't have default method like sync that would request server new data for partucular instance and merge it with existing data on the client?\n. I use this method, but I'm not sure that it will work correctly if model instance is not in store.\nfindOne only will merge incomming data with model with the same id that is in store.\n. can-router-route is tautological\n. Yes that would VERY useful, currently one have to change context of the element to pass particular data to event handler.\n. So should attr('value.nested') work the same way as attr('value').attr('nested')? At least it never worked this way.\n. It does not, and it is not supposed to. Currently you should extend define (and any other properties on prototype or static) manually (for example using can.extend).\n. Probably because of this:\njavascript\nvar b = new A();\n. This way, as I've said:\nhttp://jsfiddle.net/t7m77xvc/2/\n. It is in minor branch, is there build for this to use in fiddle?\n. Yes I've seen this bug too.\n. Will it be merge in minor?\n. Yes it is #minor on windows (not shure about steal, I just made npm install, bower install).\n. Is it possible to to try to switch to stache with can#minor?\nSuppose I have all my tempaltes of my compone defined as strings and if I do:\n``` javascirpt\nrequire('can/view/stache/')\n$('body').append(can.stache('')())\n```\nDo app suppose to use stache engine now? At least I tried and I still breaks on eval in can/view/scanner.\n. Do you have any comments?\n. > Could it be that you are still accidentally importing Mustache?\nWhat do you mean? can.js imports it:\ncan.js:\njavascirpt\nsteal('can/util', 'can/control/route', 'can/model', \n    'can/view/mustache', 'can/component', function(can) {\n    return can;\n});\nSo in built (bundle) file\njavascript\n/*can/view/mustache/mustache*/\ndefine(\"can/view/mustache/mustache\",...\nis present.\nIn my code I explicitly don't require and use it.\n. So event if to change there mustach for stache the result is the same. As I've said it breaks on eval in can/view/scanner.js\n. Ok, thanks, mustache also is used in can/componet but I I've managed to replace mustache with stache using confg's map and paths and overriding can.js wrapper.\nThe problem is that app is not seem to work properly. There are a problem with  tag in component template (it is not replaced with need contents). Can you comment on this issue?\nAre there also some known critical issues with stach that doesn't allow to use it in production currently?\n. I've created an issue. https://github.com/bitovi/canjs/issues/1324\n. Thanks, guys. \nThough the question: Do I need to replace can.view.mustache with can.stache in the code (for example in component.js )? (I do it using wrapper module for can:\njavascript\nsteal('can/util', 'can/control/route', 'can/model',\n    'can/view/mustache', 'can/component', function(can) {\n        can.view.mustache = can.view.stache\n        can.mustache = can.stache\n        return can;\n    });\nSome some config map and paths to replace loading mustache with `stache':\njavascript\nSystem.config({\n    map: {\n        'can/view/mustache': 'can/view/stache'\n    },\n    paths: {\n        'can/can': 'can.js', //modified can.js wrapper\n        'can/view/stache/mustache': 'bower_components/canjs/view/stache/stache.js'\n    }\n})\nIs this correct way of doing things? Or mustach should be in place?\n. > Oh yes, it is indeed. It should probably use the default view engine but passing a renderer function should fix the problem.\nIt seems that I've changed default engine (using modifications in previous post), but It didn't work.\n. @matthewp\nBut component.js requires can/view/mustache (and uses can.view.mustache), what if I don't need mustache to be included it at all?\n. ok, thanks!\n. @matthewp \nI coun't find the right place in the video, was it about setting xml NS attribute?\nCurrenlty I worked this around using this approach:\nhttp://jsfiddle.net/xKc3H/551/\n. Well I coun't figure how to apply this in my situation (that is in fiddle). I think to stay with my workaround corrently.\n. @root is more appropriate of course\n. If you need this, you could add element to scope:\njavascript\ninserted: function(){\n  this.scope.element = this.element\n}\n. This will be actually quite useful especially when https://github.com/bitovi/canjs/issues/1361 is in place.\n. http://canjs.com/docs/can.mustache.tags.escaped.html - is this deprecated?\n. > No but this is not how you pass values to components.\nI don't want to pass the data using {} and have two-way binding. The way i'm talking about setting attribute's value using some dynamic value from {{ }}, (canjs can observe string attributes changes in DOM and bind it to scope's attribute value) and it works ok, the problem only with this \"value\" and \"checked\" (and maybe some other) attribute names.\n. Is * going to afffect ALL the attributes or only that are in define object?\n. Is this supposed to work? In master?\n. http://jsfiddle.net/xKc3H/367/\n``` javascript\nvar Model = can.Model.extend({\ndefine: {\n    name: {\n        value: 'Alex'            \n    },\n    '*': {\n        serialize: false\n    }\n}\n\n})\nvar model = new Model({age: 10, name: 'John'})\nconsole.log(model.serialize())\n```\nWhy result is Object {name: \"John\"} ? I thought no props should be serialized, no? It is not very useful if * defines only not defnied attributes, I think it should aslo define each attribute properties.\n. > Oh, so you had a can.Map that had an attribute called watch?\nYes.\n. Is it possible to make it load multiple modules can.import(\"can-slider\", \"some-other\") ?\n. Well what is the use case for this:\n```\ncan.import(\"can-slider\").then(function(CanSlider){\n})\n```\ncan you give the code example?\n. Should pull go to master or minor?\n. > Or, we could possibly support && and || in expressions.\nThen, negation ! (for particular argument) as well would be useful.\n{{#if someParam && !anotherParam}}\nWill you think about it? Let know that you decide.\n. maybe {{#if fn attr}} shoud be interpried as if (fn(attr)){...?\n. @justinbmeyer have looked at the code carefully? it assumes that this helper can take more then two params, is it ok with your vision of it?\n. @justinbmeyer \nDo we need to add eq alias for this helper to this pull?\n. If I want to reinitialize the whole application. For example after hot (without page refresh) js modules reload.\n. +2 \nwhat about passing argumenta to can-events can-event=\"{todos.count 'completed'}\" ?\n. Wrong repo.\n.can.defineis fine, maybemap/define` plugin could use it internally to allow usage of its familiar API.\njavascript\ndefine:{\n   '*': {property: true} // would make all attributes directly accessed\n}\nThough no sure about *, maybe it should be set on every particualr property... though it is not very convinient.\n. @daffl \nAre you sure that removeAttr will not solve this problem? \nI think that in the example even with removeAttr map with _cid equal 2 still be a cat after update.\nThe problem is to keep correspondence between _cid (i.e. particular instance) and id (and other props).\nIn the example incoming data is mixing with the wrong existing objects (this object may even have diffrent types in the list, so object with diffrenct _cid are not interchangeble).\nWhat I would do is to allow custom merge scenarios for a particular attribute. Using define pluign\njavascript\ndefine: {\n   myList: {\n      merge: function(){\n         //this function would be used to set attribute value while merge\n      }\n   }\n}\n. Not sure about such API. '*': {merge: ..} mean that merge option is applied to all attributes (i.e list items in case of can.List), but we are talking about operation with the whole List (correct merge with new data set), not operation on each of its particular items.\n. Any Ideas about API for this?\n. I think this is not only problem with list\nThere is aslo a problem with such case (will explain again)\n```\nvar Person = can.Map({\nage: 0,\n\ndefine: {\n    name: {\n        type: function(val){\n            console.log('name type', val)\n            return val ? new can.Map({first: val.first.toUpperCase(), last: val.last.toUpperCase()}) : val\n        }\n    },\n\n}\n\n})\nvar person = new Person({name: {first: 'disney', last: 'walt'}, names:['disney']})\nconsole.log('name', person.serialize().name) // -> {first: 'DISNEY', last: 'WALT'}\n// while attr update, say I want name allways to be passed though type converter, not just merge\nperson.attr({\nage: 0,\nname: {\n    first: 'john',\n    last: 'galt'\n}\n\n})\n//var ser = person.serialize()\nconsole.log('name , person.serialize().name) // -> {first: 'jonh', last: 'galt'} and {first: 'JOHN', last: 'GALT'} needed\n```\nhttp://jsfiddle.net/xKc3H/367/\nThis is just simple example. So if we could avoid merging while such attr updates, for example using such API:\ndefine: {\n        name: {\n            type: function(val){\n                console.log('name type', val)\n                return val ? new can.Map({first: val.first.toUpperCase(), last: val.last.toUpperCase()}) : val\n            },\n            merge: 'type' // or custom function\n        }\nThis would allow to solve the issue with lists as well as any can.Map.\nI hope I was clear.\n. Yes it would be ok if it worked in views.\n. I would use create and update events instead created, updated\n. are the exiting tests passing? from my perspective there should be no problem as we just replace == -1 with < 0\n. @matthewp I've added this config to may package.json and got the error\nTypeError: Error loading \"package.json!npm\" at http://localhost:3000/package.json\nCannot read property 'system' of undefined {stack: (...), message: \"Error loading \"package.json!npm\" at http://localhot-\u2026e.json\u21b5Cannot read property 'system' of undefined\"}message: \"Error loading \"package.json!npm\" at http://localhost:3000/package.json\u21b5Cannot read property 'system' of undefined\"\n. can.view.mustache = can.stache\nhave to be done for all modules it is not convient.\nCurrenlty I have to use my fork for this https://github.com/whitecolor/canjs/blob/master/can.js. I just don't like that I need to fork just because of this.\n. @matthewp Why I can not not map it with new steal and package.json? (in old steal I jest mapeed, and fork was not needed)\n. @matthewp as I've mentioned I previously mapped can.js (main canjs file) and replaced it with new one https://github.com/whitecolor/canjs/blob/master/can.js, but I'm unable to do this with new steal.\n. It works but only with wrapper around can\n``` javascript\n// can override for using stache as default engine\nsteal('can/util', 'can/control/route', 'can/model',\n    'can/view/stache', 'can/component', function(can) {\n    can.mustache = can.view.mustache = can.stache\n\n    return can;\n});\n\n```\n. are you going to merge this? Btw are nest props like \"some.status\" by sort plugin?\n. this still doesn't work in lates minor and this too https://github.com/bitovi/canjs/issues/1800\n. @akagomez ok, hope to see this soon\n. @daffl will this work on minor?\n. @daffl have a look at this https://github.com/bitovi/canjs/issues/1800 too please, perchance related.\n. I mean static values not they are not set up as:\nmap.prop = 1 (vs attr set: map.attr('prop', 1), \nbut these properties are view only  values that come from server for example, they are not subjects for change in application - for example ISBN attribute for a book. But they are still are treated as map's attributes and change event handlers are bound to them in views.\n. ```\nvar Person = can.Map.extend({\ndefine: {\n     age: {\n       type: 'number'\n       value: 10\n     }\n     name: {\n        type: '*',\n        value: {\n           first: '',\n           last: ''\n        }\n }\n\n}\n})\n```\nin this example last and first props of name wont have bindings as name is plain object. but name it self and age still will have bindings. An I want this props to be out of live binding. But I a may want some other props be live binded so I have to use can.Map, not simple object or can.Construct for 'Person' class.\n. why this wont work?\n``` javascript\n     name: {\n        type: '*',\n        value: {\n           first: '',\n           last: ''\n        }\n }\n\n```\nname (by default, if not set) will be plain object {first: '', last:''}\n'*' can only prevent live bindings for \"nested\" properties like in this case {{name.first}}, but it can not prevent live binding of {{name}} property it self or {{age}} property that are directly on can.Map instance.\n. ok helper would work.\n. Why not include it in core? Could be useful.\n. Yes this works if we do:\njavascript\n                can.simpleExtend(helperOptions, {\n                    context: context,\n                    scope: scope,\n                    contexts: scope,\n                    hash: hash,\n                    nodeList: nodeList,\n                    exprData: exprData,\n                    helpers: options // added here\n                });\nAn then we can do:\njavascript\nreturn can.stache(template)(options.contexts, options.helpers)\nShould it be done this way? or add in mustache_core:\njavascript\noptions: options\n. well its structure is:\n__cache: ..\n__context: {\n   helpers: ..\n   tags: ...\n }\n_parent: ..\nIt is better look yourself.\n. @justinbmeyer have you seen that?\n. @matthewp any comment on that?\n. @justinbmeyer So what would be right code to add at https://github.com/bitovi/canjs/blob/master/view/stache/mustache_core.js#L306 for now?\n. should it go to master or minor?\n. Well currently one should think more about names conficts. ability to allow only specific attributes to be propagated would be valuable I think. Specific scopes for members (private, protected, public) have sense in many languages. I think here simplified version is needed.\n. @justinbmeyer Yes you are right with reference it is possible to implement my scenario. I will try I say if my proposal is still seem to be valuable. \nIn general, does preventing scope leaking tend to improve performance?\n. I think it is still valueable to allo only certain component's scope attrs (or methods) to be leaked outside. I have a general purpose components where for example only one property have to be available in child scope, but I have to have all props leaked and it may cause some conflicts.\n. @dylanrtt ok thanks) It seems new binding syntax is very flexible\n. Yes this could be useful in terms of making some generic components (for example animation, of other UI util features) that doesn't mess with markup, so you can more esealy remove or add them. Using  can.view.attr is not sufficient now, if to add subtemplate and options to attrData this could be more usefull in such cases. Helpers to can be used but they do not support parent helpers now https://github.com/bitovi/canjs/issues/1783.\n. > It's potentially a terrible performance killer.\nYou probably don't want to have 1000 list items on a page at a time anyway.\n. I think this is still must have, because wrapping component tags often spoil layout when 3-rd party css libries are used.\n. Why not valid? I find it useful often:\nHTML\n<div can-click=\"{{#if shown}}hide{{else}}show{{/if}}\"></div>\nor just helper action (that contains string name of calling method):\nHTML\n<div can-click=\"{{currentAction}}\"></div>\n. I think this may be related https://github.com/bitovi/canjs/issues/1770\n. @daffl is it difficult to fix in minor?\n. @daffl it just a mistype, doesn't work any way\n. Are you going to fix this soon?\n. @matthewp not sure where to look it.\n. \"{{#mobile}}touch{{else}}click{{/}}\" I use such often \nor such pattern: \ncan-click=\"{{clickMethod}}\" where  clickMethod: function(){this.attr('mobile') ? 'touch' : 'click'}\n. Will it be fixed soon? The only thing that holds to migrate one of our projects to 2.3beta.\n. @dylanrtt @matthewp @justinbmeyer\nI've checked on beta4 it doesn't work, error stack:\nPotentially unhandled rejection [14] TypeError: Cannot read property 'compile' of undefined\n    at can.extend.compile (.../node_modules/can/view/stache/text_section.js:29:32)\n    at Object.parser.attrEnd (.../node_modules/can/view/stache/stache.js:216:47)\n    at callAttrEnd (.../node_modules/can/view/parser/parser.js:285:11)\n    at Function.HTMLParser.parseAttrs (.../node_modules/can/view/parser/parser.js:348:7)\n    at parseStartTag (.../node_modules/can/view/parser/parser.js:112:15)\n    at String.replace (native)\n    at HTMLParser (.../node_modules/can/view/parser/parser.js:214:16)\n    at stache (.../node_modules/can/view/stache/stache.js:122:3)\n    at Object.can.view.register.fragRenderer (.../node_modules/can/view/stache/stache.js:349:11)\n    at Function.can.extend.register.can.(anonymous function).$view.(anonymous function).renderFunc [as renderer] (.../node_modules/can/view/view.js:404:25)\n. What about this?\n. > Did you try reverting? Does it work?\nWhat do you mean?\n. the same result with an error, is the test needed?\n. When is it going to be fixed? Holding from upgrade.\n. The problem not with this PR?\n. Yes formatting is not good, I aslo not sure how it is better to describe options structure. Do have any other remarks about API/code?\n. @imjoshdean \nhttps://github.com/bitovi/canjs/pull/1425\n. Probably I'm wrong! Don't know why it didn't work for me.\n. Thanks.\n. I experience I think a like problems with async define.get, I tried solution above, it doesn't seem to work.\n. @matthewp yes it is the same) coun't find it.\n. It seems the fix for now is to replace <span> with <a> that allows block elements inside.\n. Is it going to be fixed soon?\n. Seem to work now\n. @whdigger facepalm learn english http://babeleo.com\nkiddin`\n. @marshallswain well that works\njavascript\nvar map = new can.Map({color: 'green'})\n$('head').append(can.stache('{{{colorHelper}}}')(\n  map, {colorHelper: function(){return '<style>body{color: ' + map.attr('color') +'}</style>'}})\n)\nbut it is not very convinient\n. @justinbmeyer @marshallswain \nWhat do you think about making styleshits dynamic using stache templtes? it could allow intresting technics of styling components with dymics css properties (that would come from scope) or even mixins (made using helpers).\nWhat can be bad in such dynamic (live bound) styles?\n. Yes with yesterday master.\n. In this case:\nHTML\n<some-comp {{#unless allowSome}}disabled{{/unless}}></some-comp>\nif disabled attr is htmlbool in some-comp component, it even breaks with an erorr:\nnode_modules/can/view/stache/stache.js 301 Error: / is currently not supported within a tag.\n. Ok thanks, for now I just got rid of such cases in the code. But it would be nice if it would start to work again.\n. Well it worked in 2.2. And multipe content tags (using select attribute) still needed feature.\n. Well for now I'm not able to reproduce it on simple example, because it broke large app and have to figure out what part of it and what events cause this (it was always working fine in erlier versions).\nIn 2.3.5 I can not event test it because these issues:\nhttps://github.com/canjs/canjs/issues/2122\n. Well  a lot of events are intersecting that cause this: element custom trigged events and map's events within different components.\nThis fix seem to work https://github.com/canjs/canjs/commit/4bccc883c88842d6a2a2bf755e4864b40d70e5ab\n. Well again I didn't reproduce it on small example it is just describing the case in big app, and there components inserted in  do not get attributes passed.\n. this is related to https://github.com/canjs/canjs/issues/2122 and I think this as well https://github.com/canjs/canjs/issues/2092\n. No, why? year-selector here is a name of attribute of year-selector component. I want yearSelector to appear on parent scope and be equal to viewModel of <year-selector/>\n. Yes it is! Thanks.\n. @pYr0x that is ok, it was particular case I could guess that is should work this way.\nIf you don't mind couple of questions about <can-import>\n1)\n<can import from=\"helpers/stache-helpers\"/> says it imports helpers into the template, how this file should look like? Can I import something custom in to the scope?\nlet say some/my/map.js  module look like:\njavascript\nexport let someObject = {\n x: 1\n}\nHow to get someObject in to the scope? I would think aboult something like that:\nHTML\n<can import from=\"some/my/map\" my-some=\"someObject\"/>\nso it imports and places someObject in to mySome attribute on the scope.\n2) and question number two\n<can-import from=\"components/my-component\"/>\nDoes it work the same way as stating import 'components/my-component' inside the component JS code?\n. @matthewp \nDoes can-import works as async System.import always? Can it be used like analogy of import ... statement but in template?\n. @matthewp can-import seem to fail to resolve the relative module, right?\nand this:\nHTML\n<can-import from=\"./some\" {^value}=\"some\"/>\nseem to be not the same as:\njavascript\nimport some = './some'\ncan.Component({\n  ...\n  viewModel: {\n    some: some\n  }\n}\nbecause in second case some attribute has imported value while components init (and before template insertion), and in first case some attribute seem to be undefined while insertion. Am I correct?\n. Ah yes right then check the docs for errors (when type in iputs).\n. @justinbmeyer When are you planing to fix latest version? 2.3.4 has some bugs (i.e. lacks this https://github.com/canjs/canjs/pull/2123) and 2.3.5 has another bugs that don't allow to use it.\n. Applied ok of cource. Just strange warning.\n. I understand, but it is not the case I belive?\n. I would understand this warning (single curle bracket):\n<bmi-slider class=\"{result}\"/>\n. I diti it as in https://github.com/bitovi/canjs/blob/master/map/backup/doc/prototype.restore.md, if it is needed I can change there too for this commit.\n. ",
    "SteveEisner": "I just hit this error and came looking to see if it had been reported.  I see that it has but it's closed - I don't think it's actually fixed?\nThe reason you were having trouble reproducing the error might be that the bug case requires you to use both CanJS and another library that turns on conditional comments via /@cc_on!@/    I'm including CKEditor and that does it.  At that point your added lines \"//@ sourceURL=whatever.js\" are being interpreted by IE9 (and maybe other versions?)\nThe error I get is:\n  SCRIPT5007: Unable to get value of the property 'js': object is null or undefined \n  eval code (15), line 2 character 5\n(the eval code is a processed Mustache template)\nhttps://github.com/jupiterjs/jquerymx/issues/117#issuecomment-4211537  <- This is the comment that tipped me off.\n. @justinbmeyer Sure, my app is a bit complicated to extract stuff but I think it could work one of two ways -\n1) we can take this offline and I can let you debug into my actual app\n2) do you know of a jsfiddle or equivalent someone's built for demoing canjs bugs?  that'd let me focus on the bug and  not on trying to build out the environment properly\n. Thanks, Justin.  Here's a fiddle: http://jsfiddle.net/mReBY/2/\nThis works in Chrome, throws the exception in IE9.  Note the inclusion of ckeditor in the external resources - don't even need to invoke it, just include the script.\n(btw I've also \"worked around\" the problem in my own site by replacing scanner.js with a copy that doesn't add the //@ debugging info at https://github.com/bitovi/canjs/blob/master/view/scanner.js#L447 )\n. @justinbmeyer I've checked this against 1.1.6 and it looks like it's still broken.  Wanted to make sure you knew about it because the bug was already marked closed when I submitted the repro case, and never got re-opened.\n. Thanks -- if you'd like to try to track it down, I can open my full app to you & walk you through the repro (it can be easily traced in Chrome debugger / Firebug.)  I just haven't found a smaller subset/fiddle that repro's the problem...\n. Thanks - I'll look for it in the upcoming version.  If it is still a problem I'll work on a fiddle.\n(Overall I find canjs is really solid code so my guess is that I'm doing something wrong, and causing this to happen.  My code is in a mixed environment so I usually find that an error in canjs is happening because outside code did something like deleting a DOM node out from under it, etc.)\n. @justinbmeyer Sorry, I built a fiddle but I can't get it to repro.  http://jsfiddle.net/G34Vf/2/\nThis models what's going on in my class definition and instance use, but it doesn't break.\nSo instead I'm attaching a souce & stack example of the break from my production code.  I realize that a non-executing example may not be that helpful, but this might at least give you an idea?\nIn the topmost frame, I'm inside a can.compute and \"this\" is global/window.  In the bottom frame, I'm setting an attr of a can.Observe which has been rendered through a mustache template.\nI've confirmed that the same code runs just fine if I switch to 1.1.5 ... I don't think I'm doing anything out of the ordinary, but I have hit other boundary cases before with the same code [issue #218]\nSource\n``` js\n//=== template (person.mustache) ======\n{{#model}}\n  .....  {{name}} .....            <-- name is the can.compute\n{{/model}}\n//===  top frame (person.js) =====\nPerson = Model({\n  // No class methods\n},{\n  name: can.compute(function() {\n    var first = this.attr('first');        <-- line 7, where the error is in the stack below\n         Uncaught TypeError: Object [object global] has no method 'attr'  \n    var last = this.attr('last');\n    if (!first) return last;\n    if (!last) return first;\n    return first + ' ' + last;\n  })\n});\n//===  bottom frame (frame.js) =====\n  ...\n    setModel: function(model) {\n      this.attrs.attr({ model: model });   <--- attrs is the Observe instance that was rendered\n      return model;\n    }\n ....\n```\nStack\nOnly the top and bottom frames are user code, the rest are can JS modules, generated template code, or jquery.\nModel.name (person.js:7)  <-- in this frame, \"this\" is global\ncomputed (compute.js:213)\nMustache.resolve (mustache.js:724)\nMustache.get (mustache.js:688)\nfn.___v1ew.push.can.view.txt.can.Mustache.txt.fn.___v1ew.push.can.view.txt.can.Mustache.txt.context ((program):1)\ngetValueAndObserved (compute.js:36)\ngetValueAndBind (compute.js:98)\ncomputeBinder (compute.js:132)\ncan.extend.txt (render.js:204)\nfn.___v1ew.push.can.view.txt.can.Mustache.txt.fn ((program):1)\nMustache.txt (mustache.js:593)\nfn.___v1ew.push.can.view.txt.can.Mustache.txt.context ((program):1)\ngetValueAndObserved (compute.js:36)\ngetValueAndBind (compute.js:98)\ncomputeBinder (compute.js:132)\ncan.extend.txt (render.js:204)\nfn ((program):1)\nMustache.render (mustache.js:82)\n(anonymous function) (mustache.js:51)\ncan.Control.render (view.js:77)\nv.isFunction.s (jquery-1.8.3.min.js:2)\nv.event.dispatch (jquery-1.8.3.min.js:2)\no.handle.u (jquery-1.8.3.min.js:2)\nv.event.trigger (jquery-1.8.3.min.js:2)\n$.extend.trigger (jquery.js:14)\ncan.Observe.can.Construct.triggerBatch (observe.js:165)\ncan.Observe.can.Construct._changes (observe.js:212)\nv.isFunction.s (jquery-1.8.3.min.js:2)\nv.event.dispatch (jquery-1.8.3.min.js:2)\no.handle.u (jquery-1.8.3.min.js:2)\nv.event.trigger (jquery-1.8.3.min.js:2)\n$.extend.trigger (jquery.js:14)\n(anonymous function) (observe.js:153)\ncan.each (each.js:17)\ncan.Observe.can.Construct.stopBatch (observe.js:152)\ncan.Observe.can.Construct._attrs (observe.js:433)\ncan.Observe.can.Construct.attr (observe.js:235)\ndeclare.setModel (frame.js:33)\n. I went looking for other similar bugs and found #305 -- which happens to be exactly the same model I'm trying to create.  When I first made these models, I guess I thought that for a function to work in a mustache rendering, it had to be a can.compute (based on examples?)  But I've confirmed that my code works with 1.1.6 now if I simply remove the can.compute() and make the \"name\" method a simple function.\n. No need to write out a detailed description in a bug, but I'm curious if you have a link that explains why one shouldn't do it that way -- I got the pattern from a canjs team member's code at: https://forum.javascriptmvc.com/topic/can-compute-crazies\nIf I want to be able to observe the \"name\" attribute, how should I build the model instead?\n. Thanks!\nOn Tue, May 7, 2013 at 9:41 AM, Justin Meyer notifications@github.comwrote:\n\n305 https://github.com/bitovi/canjs/issues/305 shows how\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/issues/376#issuecomment-17554192\n.\n. \n",
    "JoshZA": "The reason for this encoding type is for better compatibility with CORS (A html5 alternative to JSONP). Changing it to 'application/json', will cause all CORS implementations to require preflights (which some people will not have implemented server side if they just use GET/POST), and as earlier stated, require changes in everyone's server side processing.\n. ",
    "steeleprice": "I have to make my own create and updates for everything since I am going against Asp.Net MVC WebAPI 4.\nthe biggest problem is that I also have to change the Controller on the WebAPI.\ncan.Map would indeed be a better way to achieve this without impacting the services we don't always have control over.  I had originally used Prefilter, but then I had problems with other services like Google Maps and TimeZoneDB since they didn't need it.\nWebAPI does support Form Encoding out of the box, but requires weird gymnastics in the controller where JSON Serialization is nearly automatic or at least configured through mapping a converter for JSON.Net for DTO to Concrete Type deserializing.\nI plan to create a set of tests in the near future to see the different ways a server-side controller in WebAPI can be configured and how Model should be configured for each.\n. I was just trying to do this yesterday and was confused why it wasn't working!\nYes, this is a much needed feature.\n. There is a great need for simplifying the instantiation and communication between Components in a standard way for current functionality.  I have spent lots and lots of time architecting and re-architecting how to do this properly with CanJS.\nConsider the following architecture:\nApp (with a component cache)\n- componentA\n  - subcomponent1 \n  - subcomponent2\n  - subcomponent3\n- componentB\n  - subcomponent2\nCurrently I have to do this in a less than spectacular way since a \"Component\" is essentially Construct+Control, one or more Models, one or more templates and a css file.   So this defines \"Component\", though it doesn't address instantiation of a component or Facade and Mediator.  For Mediation between Components almost everyone using CanJS correctly recommends using Observe for this but there is no real guidance on where to put them, are they injected into Component or just Observed?  We also need Facade for things like security and error management.\nApp has the responsibility to load Components as needed and for managing their current state (think of it as the smart component cache).  App is completely ignorant of what Components are doing but it does know which ones are loaded. Hopefully, most people know Components are not the same as Plugins, Components should be ignorant of the the App and implement a Facade Pattern instead, whereas Plugins are usually extending App and know about (at least some of ) its functionality.  Facade and Mediator are missing in CanJS, what's tying all these Components together?\nThis structure is what CanJS is currently lacking:  App->Mediators->Facade->Components->(low level abstractions)\nThe left four are completely roll-your-own with no clear guidance about how the framework is intended to be used for this.  All the low level abstractions are great and working well, adding these or offering clear guidance around how CanJS is best used in this structure will be terrific.\n. I'm looking at steal to see if it can do what I need for loading easier than RequireJS, but that really only deals with the dynamic loading part.  Perhaps I am missing the idea of can.Component.  I mean if you are going to make can.Component, isn't the idea of a \"Component\" a package of multiple parts that makes up a usable Widget? WebComponent is pretty specific and if that's what you want to support, call it that. Component is more abstract even though the draft says \"Both decorators and custom elements are called components\"  This is horribly misleading about what the functionality truly is.  Packaging is definitely part of the spec. in Part 8: \"Custom elements and decorators can be loaded from external files using the link tag\"  so does this mean can.Component would use steal to load any imports defined in the component?  We are talking about 5 pieces designed to be used together to design widgets.  This is a huge issue and saying, oh... we use steal is just covering one part of a much bigger issue.\n. I think I should move this discussion over to the https://forum.javascriptmvc.com/canjs since it's not really an issue other than defining what the functionality of can.Component really should be.  There are at least 5 people on the forums trying to solve the same thing (loading, communicating between and packaging what we are all calling components) in 5 different ways.\n. Thank you very much for this great explanation.  This is indeed exactly what I am trying to resolve in a better way right now with a single caveat, the large scale Application.  It's Applications with High Level (i.e. pages) components and several reusable components within.\nSrchr is a great example, but it has no concept of things like authorization or nested widgets which are prevalent in real-world line of business applications.\nApplication is the root, and functionality is loaded dynamically via routing or history.  The Engine of Application State is the issue at hand not just control state.  When I have my \"App\" at the root just refreshing the browser is going to cause all state to reload (which it should).  Which components are loaded as well as what state those components are in starts to become a very complex issue.  Using Srchr as a sample, some state gets pushed into localstorage (history) and we are mixing local state with remote state (the stuff we search for).  \nFor mobile we have a need potentially for offline use, the App (say wrapped in Cordova) is there and items are cached locally until there is a connection then pushed up to the server; this means we need both a local Model and a remote one for the Component unless we start hacking at the current Model structure to override what create/update does. \nThese are the difficult things I would really like to see get addressed in a more standard way for CanJS and I think Component can solve a lot of this if it has the concept of how to do it even if its a plugin.\n. Maybe in addition to can.Component we need can.Mediate that is an Observe used specifically for communicating between Components and can.Facade which handles swapping out Model storage for local vs remote usage patterns similar to how Fixture is used for testing.\n. +1 this is indeed a problem that needs quick attention.  The NuGet Package needs to be updated and I can't do it until we have proxy.js (I don't use a custom build for NuGet)\n. I have had this happen when using render too.\nI needed to pass the rendered string to a function and passing the results of render showed this anomaly.\nself.options.currWindow.setContent(can.view.render(marker.infoview, marker.geoentity));\npartial content looks like this:\n<p class=\"no-margin nowrap\">Starts at <span class=\"fatty\"><span data-view-id='18'>@@!!@@</span></span> and runs for <span class=\"em\"><span data-view-id='19'>@@!!@@</span></span></p>\nHowever, this works fine, but is far less desirable:\nvar r = can.view(marker.infoview, marker.geoentity);\n           self.options.currWindow.setContent(r.firstChild.outerHTML);\nSame content is correctly rendered:\n<p class=\"no-margin nowrap\">Starts at <span class=\"fatty\">4:00pm</span> and runs for <span class=\"em\">an hour</span></p>\n. This does work on fiddle and direct references, but I can't seem to get it to work in a Require module.\nhere is the module definition:\ndefine(['jquery', 'gmaps', 'can', 'can/view/modifiers'],\nfunction ($, gmaps, can) {\ndo I need to initialize modifiers in some way?\nthis should be automatic when it loads and I do see it loaded.\n. OK, it IS working...\nMy problem is that I'm not rendering to a DOM element. (and I can't easily without lots of rework)\nthis is rendering a view into a google maps InfoWindow.\nsame basic scenario as this: https://forum.javascriptmvc.com/#Topic/32525000001205025\nIs there a way to force the render without inserting it into a DOM element or is what I am doing the recommended way?  Otherwise, I have to render to a DOM element, then copy that DOM element into the eventual location.\nThis has other problems, seems more efficient and easier to track like this:\nvar r = can.view(marker.infoview, marker.geoentity);\nself.options.currWindow.setContent(r.firstChild.outerHTML);\nThis only has issues because of my particular scenario, but it would be nice to do something like this:\nself.options.currWindow.setContent(can.view.render(marker.infoview, marker.geoentity, {force: true} ));\nsince the intent would be more clear.\nThe problem I am seeing above is that I lose live binding and have to re-render instead of being able to have Observables take care of the re-rendering.\nI'm probably going to have to create a special control to do the InfoWindow (as well as the one I already have for the map) so I'll be looking at several alternatives today.\n. excellent workaround for this, I didn't think of using hook.\nThanks for the help!\n. No, it didn't, it works in a limited way on jsfiddle, but in real Apps, the helper is still failing (just differently).  I will put more time into this, but it's still essentially a problem with arrays not being passed properly. I wouldn't say the work-around would have closed the issue anyway, it's not an intuitive solution and certainly not something you would expect to be a problem in a helper.\n. Let me try that, but it seems to only be an issue in AMD.\nI created a fiddle using latest/can and it works as expected.\nI really need to create a fiddle template soon for AMD, but I can't do it today.\n. .mustache didn't work, it's still a fragment instead of a string as it is in 2.0.4.\ndaffl: that works, but is really strange, require.toUrl just changes the path to \"scripts/app/components/home/home.html\"\nif I pass anything but a string literal, it's failing, i.e.\nvar template = require.toUrl(\"comp/home/home.mustache\");\n                $(element).html(can.view(template, {}));\nwhich shows template is a string variable containing: \"scripts/app/components/home/home.mustache\"\nIt seems related to #647 but isn't a require base path problem, the problem is that anything but view(\"string literal\", {}) is not rendering.\nThis fails too:\nvar template = \"scripts/app/components/home/home.html\"\n                $(element).html(can.view(template, {}));\n. in line 652 of view.js, using the above syntax,\ntext is undefined and id is a fragment.\n. wait a minute...\nI'm inside a Component, but I think I see what is going on.\nThere is an async require for google maps in a sub component that is timing out.\n. no, even removing that isn't helping, but I do think this is Component related, most of the Components are loading when stepping through.\n. I'm working on a fiddle to emulate it.\nI have something close, but it's working, I will adjust it in a few minutes.\n. ok, so it appears that views don't work quite the same as they used to, but only inside of a component.  I am OK with this since all it required was directly calling mustache.\nthis worked in 2.0.4 inside of a component:\n$(element).html(can.view(require.toUrl(\"comp/home/home.html\"), {}));\nit doesn't in 2.0.5.\nbut this does and is better syntax anyway:\n$(element).html(can.view.mustache(require.toUrl(\"comp/home/home.html\"))({}));\nI still have this error being thrown with the following line though and I am trying to track down exactly what is causing it, this line did in fact render correctly in 2.0.4.\n$(\"body\").append(can.view.mustache(\"<app-location></app-location>\")({ session: attrs.session }));\nThis seems to be a tightening of what is accepted for rendering which is mostly a good thing.\ndebugging the root cause is quite painful.\n. this is definitely a combination problem of Require and setting Component templates.\nthe rendering inside the component is not the issue, but I will address that too.\nThe problem was how template: was being called.\nALL my components used: \ntemplate: can.view(require.toUrl(\"comp/home/home.html\")),\nwhich in 2.0.5 is \nA) no longer needed since it can use a require path directly\nand \nB) a breaking change, because if you used it in a previous version it's now trying to resolve the path twice.\ncorrect syntax for 2.0.5 is:\ntemplate: can.view(\"comp/home/home.html\"),\nas for rendering in the component, normally, yes, this is not done, <app-components> are inside the template.  In fact, right now <app> doesn't have a template and I am most likely going to change that shortly. I will have to play with that approach. This is all a conversion from a non-component architecture where everything was controls before.\nIf you have a single root <app> component, it may need to so some rendering for initial setup that is potentially outside the <app> tag\nI have to put login, logout and location finders in the body so they don't get clobbered when the hash changes and replaces content inside the <app> tag.\nThere is really no perfect way to do something like this, it's going to be a trade-off somewhere.\nif I created an index page something like this:\n<app />\n<app-login />\n<app-logout />\n<app-location />\nthen I have to reference app.scope.session from inside the other 3 components which now tightly couples them to an app component.\nif they are instantiated inside of <app>, they need to be placed in the DOM outside of the  tag since routing will replace things inside the  tag.\nIf I want <app> as a root component (as opposed to a control), I am not seeing a good way, except maybe using \n<div id=\"nav\">\n<app-nav-bar/>\n</div>\n<div id=\"content\" />\n<div id=\"otherstuff\">\ninside the  template.  \nThis is where Documentation of sample architectures for real-world apps is going to be enormously beneficial.\nWe are guessing at best-practices right now using \"Todos\" as a template when we need to think of things outside that, like security, session observes, communication pipelines between components without a facade or sandbox (pub/sub), etc.\n. No, this is a GOOD change and just needs to have some documentation to close this issue.\ncorrect syntax is:\ntemplate: can.view(\"comp/home/home.html\"),\ncomp is a requireJS path, not just the base.\nin my require setup it look like this:\nrequire.config({\n    baseUrl: 'scripts',\n    paths: {\n        app: 'app',\n        controllers: 'app/controllers',\n        comp: 'app/components',\n        can: 'lib/can',\n...\n. There is only one other odd thing I noticed in this issue, but its not really the same issue and would also be solved with documentation.\nself closing tags have unexpected behavior in most browsers.\nthey nest as children of the last element instead if siblings as they should.\nIts also inconsistent and I will need to open a new issue for it.\n. ",
    "beno": "Just got bit by this again: I can't believe I am googling my own post here. Am I really the only one bothered by this?\nAnyway, the problem is submitting an object with a nested array of objects:\n{foo: \"foo\", bars: [{bar: \"bar\"}]}\nSubmitting a JSON here would be trivial, but posting a encoded form turns this into\nq = jQuery.param({foo: \"foo\", bars: [{bar: \"bar\"}]})\n    #=> \"foo=foo&bars%5B0%5D%5Bbar%5D=bar\"\nwhich on a server turns into\n{\"foo\"=>\"foo\", \"bars\"=>{\"0\"=>{\"bar\"=>\"bar\"}}}\nSo now I am forced to create different code paths for submitting a urlencoded form or a JSON, which is not an acceptable option. Any help here?\n. I tripped over this issue when I decided to upgrade to edge the other day, and I solved it by going back to my can.jquery.js dated 25 june. So this problem has been introduced fairly recently and is evidently not covered by tests.\nAs far as I can tell, newly fetched 'child' models are not being converted to the appropriate class and do not get either custom instance methods (like used in can.compute) and also not Model methods (like isNew()).\nI will see if I can make a test that intercepts this later today.\n. Never mind the conditionals, it looks like mustache has been completely disabled in attributes? My navigation component is now broken (I use SLIM and the ~ is short for {{ }})\nnav\n ul.nav.clearfix\n   ~#actions\n     li\n       a href=\"#\" can-click=\"~.\" ~.\nTo avoid confusion, here's what this gets translated into:\n<nav>\n  <ul class=\"nav clearfix\">\n    {{#actions}}\n      <li><a can-click=\"{{.}}\" href=\"#\">{{.}}</a></li>\n    {{/actions}}\n  </ul>\n</nav>\nThis all works fine in 2.2.7, but fails in 2.3\nscopeData.value.apply is not a function\n. Not sure I follow. Are you saying the behavior of the attributes (like can-EVENT) has been changed to accommodate  #-prefixed attributes? And is this considered a feature or a bug? If feature, how would one create the logic in my example from 2.3 onward?\nTo be sure, the 'actions'-array in my code is a simple list of strings with each string having a corresponding function in the viewModel. So I am not doing any custom attributes or anything like that.\n. OK, thanks for the explanation, I get it now.\n\nUnfortunately, I don't think there's anything you can do within the context of your app to fix this without adding unnecessary complexity.\n\nSo there is no way to have any kind of dynamic custom attribute? That is quite the regression, don't think I have ever encountered something like this before. Besides, doesn't a 1-way vs 2-way binding only make sense in can-value attributes?\n. Ah, it was unclear to me whether it was considered a bug or not. I think I'd rather have a special way to enable the new behavior and leave the existing functionality as is. But flipping this around would be the next best thing I suppose.\nNot sure what you meant by your last remark. Can you elaborate? Thanks.\n. I made this test a while ago\nhttps://github.com/bitovi/canjs/pull/1863\n. ",
    "AnthonyMann": "+1\n. For non-wildcard selectors this makes sense, however for wildcard selectors it makes sense to receive all events that match the wildcard, not just the first.\nI think the fiddle provides an accurate description of this behaviour. Note that the fiddle is intentionally simplified, a stronger use case within that context would be:\njavascript\nobserveInstance.delegate('*.baz.*.boz', 'change', function(ev, prop, oldVal, newVal){ \n    //expect all events that match selector, only first is fired\n})\nFYI, commenting out the batchNum check https://github.com/jupiterjs/canjs/blob/master/observe/delegate/delegate.js#L69 allows the selector to be matched for all events.\nThis is obviously not a good solution, but demonstrates correct behaviour for wildcards\n. So i would like to fix this issue, but it seems to be in conflict with the following:\nThis test: https://github.com/jupiterjs/canjs/blob/master/observe/delegate/delegate_test.js#L168 is preventing the issue from being fixed. Why should compound sets only be notified of the first change in a set that matches either selector? Surely we should be firing all events that match either selector, even within a batch.\nI will happily create a pull request that changes compound sets and wildcards to match all events from a single batch.\n. Understood, but i don't think this is a strong enough argument to enforce this functionality ubiquitously. I can see how this makes sense for compound sets, but less so for wildcards. There are many use cases for delegates outside of the context of updating the DOM, and even when doing so, you still might need to know all object mutations (e.g animation etc).\nIn this case, i think extending the delegate API to provide this functionality optionally would be a good solution:\n``` javascript\n/\n @param {String} selector The attributes you want to listen for changes in.\n @param {String} event The event name.  One of (\"set\",\"add\",\"remove\",\"change\")\n @param {Boolean} [matchAll=false] Selector can optionally match all events in a batch change.\n @param {Function} handler(ev,newVal,oldVal,prop) The callback handler \n/\ndelegate :  function(selector, event, matchAll, handler){ ...\n```\nEDIT:\nActually, it looks like this approach would be unusable via can.Control. Templated methods are split by spaces with the final argument being the event type. 2 Args + callback max for use with can.Control.\n. > It does however support more complex selector patterns with ** wildcards inbetween, such as foo.**.bar. This kind of selector comes in very handy when you have to listen for changes to a specific property on a recursive data structure.\n:+1:\n\nefficient regex to handle these kind of selector matches\n\n:+1: \nLooking forward to seeing this!\n. @justinbmeyer sure! The docs give a brief overview of the pluralisation behaviour. Grab me on IRC when you are free and we can discuss the changes.\n. thanks @daffl,\nSo, changes would listen to every event, while change continues the old behaviour of matching a single event per batch.\nThese plurals are not new events or new event names internally, merely, if the event name ends with an s, the delegate gets flagged as matchAll and then we revert to the non pluralised event name for matching. It works with all event names, not just change. e.g: add or adds, update or updates etc\nI haven't dug into the can.transaction() changes thoroughly yet, but i can't see initially how this would cause an issue, perhaps you could elaborate on this?\nedit: unless you mean the terrible grammar of potential changeds :/\n. > We can probably change the current behavior. Now's a good time b/c we are releasing 1.1. I want to get it right.\n:+1: \n\nI'm wary of \"change\", \"changed\", \"changes\" as different event types. That's a lot to know.\n\nAgreed, also the similarity between them might initially be confusing. Good documentation will help.\n\nWe need to think about bind on change vs changes events. These should be similar.\n\nCouldn't agree more.\n\nAssuming we made \"change\" only once per batchNum change, What would obs.bind('change', func) even respond with?\n\nGood question, it seems pointless to return the attr, how, newVal and oldVal args as they are specific to a single event, not the batch which is the new locus. IMO, It still makes sense to pass the event to the callback, and the content of event still remains relevant.\nAs requested, I've put a quick gist together as a first draft of how this could work:\nhttps://gist.github.com/3987882\nAlternatively, a less destructive approach would be to prefix (rather than pluralise) the event names to add the batch change listen behaviour:\nSomething like: batch-change / change, batch-add / add etc, with batch-{event} listening to the single event per batch. This retains the existing functionality, while adding the one-time state change notification that is clearly desired.\nedit: this would also potentially sate anyone who would be annoyed with changeds\n. Related discussion here: http://forum.javascriptmvc.com/#Topic/32525000001079097\n. @justinbmeyer No problem, and i share your concern. Finding a consistent solution to this is clearly the way forward, glad this helped provoke the discussion.\n. :thumbsup:\n. ",
    "rajaravipati": "Hi Justin,\nI agree with you. But if a property can be accessed via .attr then it can be set too, which means people expect it to be able to use it in their EJS templates for live bindings.\nFor eg: If i manually did employee.attr('count', 500) it does fire the change event.\n. YEP. eg: The expando properties can be accessed either via employee.count or employee.attr('count')\n. @daffl You are right & thats what i said in my earlier comment :) \nThe change event does work if you call it manually like you did in your example - list.attr('count', 200)\nBut thats not the way the expando properties gets assigned in the source code. Please see line no 732 (res[prop] = val;) in https://github.com/jupiterjs/canjs/blob/master/model/model.js\nIt does NOT use the attr() method to set the data.\nI have created the following http://jsfiddle.net/vAv2t/ to play with. If you click the 'refresh data' button the data array does get updated but not the count property which is updated with a random number every time the findAll method is called. So the EJS template doesn't update due to the change event not firing for each expando property. Check the console.log messages. \n. ",
    "yusufsafak": "Thanks. But it is not working.It causes an error in defaults extend. We should add Tester class to arguments:\njavascript\ncan.Control.setup.call(Tester,Tester)\nThanks a lot.\n. Ok. Thanks\n. I checked it again and I found that can.view.lists function can't update key property of item in index function. It causes wrong fromIndex.\n. Thanks\n. +1\nThe same problem for me when I wanted try to convert Polymer selection component to can.Component last week.\nhttp://jsfiddle.net/yusufsafak/Bb47k/2/\n. I think @retro wants to say  http://jsbin.com/foruki/1/edit but it is not a good solution for me. \nI found a new solution. We need to pass a function that returns can.Map/object contains a setter function for x-chooser scope.  http://jsbin.com/foruki/3/edit\n. ",
    "cohuman": "Yeah, that makes sense to me.\nI was originally thinking the change would need to go in can.Model as it's really the model object that has an id; but then I saw that the constructor's id property is actually set in can.Observe so figured it would be fine to attack the problem there.\nAs long as you can make our test pass, we're happy! \nThanks,\nMichael\n. Awesome, thanks! This should fix our problem. We'll check it out.\n. Hey all, I'm pretty excited about this one! To get the incremental list benefits is it enough to just use each() in .ejs files?\nAnd of course, pull the latest version of can :)\n. oops. didn't mean to leave debugger in there :). In fact the whole model method definition can go away for this one. We were just making sure it was getting called.\n. ",
    "alexisabril": "Is this issue still valid? All referenced issues are closed.\n. Sebastian, we are actually working on a simplified version. If you take a peek at the \"test\" branch in CanJS, you'll be able to see where we're going(almost ready for primetime!).\nThe end result would be:\ngit clone github/path/canjs\nnpm install\ngrunt test\n. @raviviswanathan Could you add a new issue to the below repo and also add what HTML you're using? Thanks!\nhttps://github.com/bitovi/funcunit/issues?state=open\n. @whitecolor You could use a subtemplate instead of a new component:\n<my-track>\n  <!-- this would keep the context, but let you separate your markup -->\n  {{>media-file}}\n</my-track>\nAs an alternative, you could set the view model directly by using viewModel's function syntax:\nvar Child = can.Component.extend({\n  tag: 'sample-child',\n  template: can.stache('{{foo}}'),\n  viewModel: function(attrs, parentVM) {\n    return parentVM;\n  }\n});\nExample: http://jsbin.com/kayeza/edit?js,console,output\n. Just to clarify before this thread goes too far off topic, by \"deprecation\", I only state no new features will be added to EJS. EJS support will continue for many releases(years).\n. This is a limit on using splice.apply with an object(instance of can.List) as the context. Example breaking in Chrome 43.0.2357.132(Mac) without CanJS: http://jsbin.com/siqene/edit?js,console\nWith a simple array, there's a much higher threshold, so there may be a performance gain to be made here.\n. Closing as setters are deprecated in favor of the define plugin: http://canjs.com/docs/can.Map.prototype.define.set.html\n. @isadovskiy I agree this is a bit tricky from the developer's perspective. Think of it this way: templated event handlers are really just shorthand for binding to events.\nFor example:\n```\n'{game.team.player} change': function() {}\n// is equivalent to\ngame.team.player.bind('set', function() {});\n//The above line is pseudo code, only to stress a point\n```\nIn the pseudo line, if player is replaced with a new object, we also lose the binding. This is actually what is happening in your example. If you add a call to on(), you'll get the rebound player callback: http://jsfiddle.net/9yrm92f4/\nIn a view, this will work because we're actually setting up bindings on each section of your string: game, team and player. If any change, we'll re-evaluate the property/helper. For a control however, it's a more specific syntax. When is a property added, removed or set. Binding on each section in a control would be expensive.\nI'm not closing this issue immediately as it's possible we could re-evaluate this approach in the future.\n. I'm closing this bug as the sort plugin does indeed sort in place. There was some confusion on my part regarding how sorting is currently done within can.List instances.\n. The default behavior checks the current scope, then walks up the scope chain until the property is found. \"./\" forces a check at the current scope level, then stops prior to walking up.\n. Possibly still an issue as I'm able to reproduce this if the computed value is updated: http://jsfiddle.net/Gd38M/1/\nThis is with jQuery 1.11.0 and CanJS 2.1.1\nEdit: corrected fiddle.\n. Reviewed with @daffl. Re-opening and placing in 2.1.2 for further review.\n. Closing issue. The components in the fiddle are sharing the same template, so the infinite loop was human error.\n. Closing issue. This is actually passing. Test will naturally fail as this is logic contained within bindings, not within the view engine itself.\n. Very possible. I was looking that issue as well. I wrote another test as #if seems to work with other DOM elements, just seems to halt calling the helper in situations with a nested component. That being said, the logic to fix this very well maybe related.\n. This is actually an issue with custom helpers as well.\n. @shcarrico I just tested this fix with #1019. They appear to be separate issues. #1025 turned out to be specific to stache.\n. I think maybe the problem is that: .attr(PROP, Object) merges by default, but .attr(PROP, Map) sets.\nBoth calls will set: http://jsbin.com/gozadi/edit?js,console\n. @whitecolor Could you verify this is still an issue? That fiddle doesn't show an error currently, tested with v2.0.0, 2.1.0 & 2.2.9\n. @robregonm Yes, these do appear to be the same issue. This is true of all DOM attributes it seems as well, not just class. We've marked this for 2.1.2, so we'll have a fix asap.\n. Closed by https://github.com/bitovi/canjs/commit/c5b30740a24c7d47da2c314987aa91e64734754b\nNote: We don't actually document init in most places, although it's available on everything that inherits from can.Construct.\n. Clearing milestone as there is a discrepancy between resource and current signatures, however we need to document/outline existing functionality and discuss what we really should be supporting. I'm leaving this issue open for comment while I write a few docs.\n. Perhaps a better example than FighterPilot(since FighterPilot would most likely inherit from Person):\n```\nvar Item = can.Model.extend();\nItem.findAll({}, function(items) {\n    //can.List.Sort is a fictional plugin, that keeps\n    //a list's items sorted based on a comparator and\n    //produces the necessary events for live binding\n    items.mixin(can.List.Sort);\n//We may not want all Item.Lists to have/need this functionality,\n//so we can choose to do so on the instance.\n\n});\n```\nAlso, having mixin as a static method on constructs makes more sense:\nSensitiveDataModel.mixin\n//instead of\ncan.mixin\n. This was fixed in a prior merge in minor. Typo in the test, adding @matthewp's test to a PR.\n. @justinbmeyer Good call. I added an additional test and modified the condition to which we call ajaxMaker.\n. This also exists in stache due to: https://github.com/bitovi/canjs/blob/minor/view/stache/expression.js#L329\nAdding a test and leaving open while I verify if we should be checking for all falsey values, or just undefined.\n. @DesignByOnyx Yeah, merge in that test I wrote(or copy it) and we should be good.\n. Closing as we now have an alpha inspector with its own repository: https://github.com/canjs/can-devtools\n. Closing as this is fixed in stache: ref #1142 \n. Potentially related for components(using if to check an attribute on a parent item's scope): http://jsfiddle.net/b65UW/\n. Referencing PR #1184 \n. This was modified in CanJS 2.2.x to match the currently documented API. data & xhr are the only two arguments passed. Noting for review.\n. I can't speak for Angular, but it's my understanding they focus most of this at the presentation layer. For example, they have formatters and parsers as well as custom directives you can specify on an input element.\nThat being said, I am a fan of exposing types to allow for custom types to be created in addition to having formatters & parsers. This way if you want to display a custom format, you can keep the model pristine as well as if you want to immediately deserialize/serialize something at the model layer(converting an ISO date format to a Date object).\nWe probably should rename that variable, I believe @gsmeets was referring to: https://github.com/bitovi/canjs/blob/master/map/define/define.js#L123\n. @rjgotten Correct, there's an API change for can.Compute. You'll have to do:\nc.get();\nThat being said, we are staying backwards compatible with can.compute(), however internally it will now create a new can.Compute() instance. Then when you do:\nc(); //this will reference the internal new can.Compute and call get() respectively.\n. Noting current working branch for this feature: https://github.com/bitovi/canjs/tree/1255-compute/compute\n. Holding off on the PR until I can test within canjs.com.\n. Just noting this was not fixed via #1486\n. @pYr0x Sure is: http://canjs.com/docs/can.Map.backup.html\n. Referencing #1254 as that information should be included in this update.\n. Hey @pYr0x, that issue was in regards to reading values, this one is a recent bug due to setting values.\n. This was fixed with: https://github.com/bitovi/canjs/commit/016d0089596a4279e37c1f5833f91a0beca597ed in v2.2.6\n. Closed by b7c8769b26c4b56e866f5d5804c353693bd55ad3\n. This was fixed by commit b7c8769b26c4b56e866f5d5804c353693bd55ad3\n. @rjgotten I'm going to rephrase your thought a bit, but correct me if I'm wrong.\nA confusing note is that this example is listening to the \"change\" event, which has new and old values passed as arguments. However, \"remove\" only passes elements that have been removed in the event, in the place of the old values argument.\n```\nvar list = new can.List(['a']);\nlist.bind('change', function(o, ev, type, val, old) {\n  console.log(type, { new: val, old: old });\n});\nlist.replace(['b']);\n//console output\n//\"remove\" does not have any new elements added to this collection, as such is undefined\n//remove { new: undefined, old: ['a'] }\n//\"add\" does have new elements adding to this collection\n//add { new: ['b'], old: ['a'] }\n```\n. Hey @WooFerPPK, you need to pass the optional [deep] bool to isDirty as you're checking for nested changes: http://canjs.com/docs/can.Map.backup.prototype.isDirty.html\nAdding .isDirty(true) to your test makes it work as you would expect.\n. This is true with other list helper methods such as reverse()\n. Should can.isDeferred and can.isPromise be the same function in this case? Currently can.isDeferred looks for jQuery-esque deferred methods, which we use in a couple places: https://github.com/bitovi/canjs/blob/master/list/promise/promise.js#L15\n. Note, I retracted my prior PR when I realized the above. The current state of that branch has two separate functions: can.isDeferred and can.isPromise.\n. This is due to the fix provided for: https://github.com/bitovi/canjs/pull/1422\nSpecifically the re-binding on line: https://github.com/bitovi/canjs/blob/c3b340422e4b3584b44e9f6f9940331c6b1e6d94/component/component.js#L272\nUnsure what the impact would be of having a conditional rebind vs just rebinding.\n. Confirmed, this is fixed by #1803. PR: https://github.com/bitovi/canjs/pull/1809 added just for the test. Note: test passes in master, however it looks like there's some merging going on. Current PR is for minor.\n. Closing as this is fixed in master, #1809 is open to track progress of the test.\n. Re-labeling this as a bug. Unconfirmed, however the callback inside of can-import should throw an error if \"app-loading\" is not loaded yet.\n. Apologies for the confusion: https://github.com/bitovi/canjs/blob/minor/view/import/import.js#L33\n\"Should throw an error\" is only in reference to \"callback\" on that line, which is expected to be undefined in this scenario.\n. Just noting the reference issue #778 so we don't lose tracking of the comment below.\n\"It's under utils b/c that's where it's code is found. The same argument could be made for putting it under can.compute.  We should link to it from other pages, but it should stay in util.\nEventually, we should have an \"can.events\" that could house it.\"\n. Closing as a duplicate(this issue is referenced in #1189)\n. @boris-chernysh You'll need to change {id} to {basket_id} in your signature as well. This is actually a point of discussion as it's a bit confusing: http://jsbin.com/vewole/edit?html,js,console\n. This is due to the removal of delete this._init on: https://github.com/bitovi/canjs/commit/8b333ab#diff-532d6324975f398d1901af12e9086953L110\nNote: this._init has also been renamed to this._initializing.\nRe-adding that line fixes this issue, however breaks https://github.com/bitovi/canjs/blob/minor/list/sort/sort_test.js#L451\n. This is for issue #2006 \n. Note: this issue needs a test\n. @gsmeets Late response from me! This issue got buried a bit.\nThat's a valid point. The question becomes: Should define control what is backed up?\nFor custom serializers to become a problem in this regard, it would need to be a situation such as:\nconst item = Map.extend({\n    define: {\n        name: {\n            serialize() {\n                return 'foo';\n            }\n        }\n    }\n});\nIn this case, no matter what name is set to using attr(), serialize() will always return foo and isDirty() will be false. However, I'm having trouble thinking of other scenarios where this could cause an issue.\nJust some background info, the backup plugin was always meant to use serialize(), this was originally a typo.\n. Thinking about this a bit more, there could be more scenarios where this causes issues. I'll bring this up at the next OS meeting.\nFor instance, the restore value would be the serialized value, which may not be what you're looking for. That may also touch on a missing, corresponding type converter.\n. @justinbmeyer There's a commit on this issue already, however tests weren't running on Travis at the time of that issue. https://github.com/canjs/canjs/commit/b1015ae20f4bdc7ff586e99787207717d225a4ff\n. Do we consider this a conflicting API if .attr('foo', {}) does not do a merge?\nhttp://jsbin.com/redose/2/edit?html,js,output\n. Ah, that makes sense\n. @matthewp I believe we do have 2.3.x releases for critical bugs down the road(I realize this is non-critical).\n@justinbmeyer Any reason not to just leave this open for any future 2.3.x release, should it occur? It's an easy fix we can ship with a critical release.\n. ",
    "andykant": "This also occurs in EJS with the equivalent template:\njavascript\ntemplate = '<% can.each(todos, function(todo) { %><%= todo.attr(\"name\") %><% }) %>'\n. I'll look into why this is happening, but in the meantime, here's a workaround:\n<img {{#image}}src=\"{{.}}\"{{/image}} alt=\"An image\" />\n. This ended up not being an issue with images specifically. From what I've narrowed it down to, can/view/render fails to properly set up live binding for observe properties if it is being set to a node's attribute (in this case src) if the property doesn't exist when the template is originally rendered. This occurs with both Mustache and EJS, so I added tests for both in the live-bind-observe-attr-157 branch.\nThis works:\ndata = new can.Observe({\n        user: 'Tina Fey',\n        messages: 0,\n        image: 'some-value'\n    })\ndata.attr('image', 'http://farm8.staticflickr.com/7102/6999583228_99302b91ac_n.jpg');\nThis doesn't:\ndata = new can.Observe({\n        user: 'Tina Fey',\n        messages: 0\n    })\ndata.attr('image', 'http://farm8.staticflickr.com/7102/6999583228_99302b91ac_n.jpg');\n. I was hoping #153's fix would knock this one out too as they seemed very related. No such luck but hopefully the solution with that bug will help with this one.\n. What seems to be happening is that can.view.pending() doesn't update attributes when the attribute is being set in a nested block. The pending hookup for the nested block is created but not executed.\nThis works:\njavascript\n// <img src=\"<%== this.attr(\"image\") %>\" alt=\"An image\" />\nvar ___v1ew = [];\n___v1ew.push(\"<img src=\\\"\");\n___v1ew.push(can.view.txt(0, 'img', 'src', this, function() {\n    return this.attr(\"image\")\n}));\n___v1ew.push(\"\\\" alt=\\\"An image\\\" \", can.view.pending(), \"/>\");\n___v1ew.push(can.view.txt(1, 'undefined', 0, this, function() {\n    return this.attr(\"image\")\n}));;\nSo does this:\njavascript\n// <img src=\"<% { %><%== this.attr(\"image\") %><% } %>\" alt=\"An image\" />\nvar ___v1ew = [];\n___v1ew.push(\"<img src=\\\"\");\n___v1ew.push(can.view.txt(0, 'img', 'src', this, function() {\n    var ___v1ew = []; {\n        ___v1ew.push(can.view.txt(0, 'img', 'src', this, function() {\n            return this.attr(\"image\")\n        }));\n    };\n    return ___v1ew.join('')\n}));\n___v1ew.push(\"\\\" alt=\\\"An image\\\" \", can.view.pending(), \"/>\");;\nBut this doesn't:\njavascript\n// <img <% { %>src=\"<%== this.attr(\"image\") %>\"<% } %> alt=\"An image\" />\nvar ___v1ew = [];\n___v1ew.push(\"<img \");\n___v1ew.push(can.view.txt(0, 'img', 1, this, function() {\n    var ___v1ew = []; {\n        ___v1ew.push(\"src=\\\"\");\n        // The pending hookup this generates doesn't get created\n        // until after the can.view.pending() later on.\n        ___v1ew.push(can.view.txt(0, 'img', 'src', this, function() {\n            return this.attr(\"image\")\n        }));\n        ___v1ew.push(\"\\\"\");\n    };\n    return ___v1ew.join('')\n}));\n___v1ew.push(\" alt=\\\"An image\\\" \", can.view.pending(), \"/>\");\n___v1ew.push(can.view.txt(1, 'undefined', 0, this, function() {\n    return this.attr(\"image\")\n}));;\n. After some more research, we need a way to ensure that the can.view.txt calls are still initially executed (just not pushed into ___v1ew) regardless of potential surrounding logic. This might require significant changes to view/render and view/scanner.\n. Renamed the title of this issue to better describe it and prevent more duplicates.\n. Nothing currently for arbitrary sub-sections, right now all you can do is \"else\", but we could add a special case for Deferreds.\n{{#Todo.findAll}}\n  resolved\n{{else}}\n  pending/rejected\n{{/}}\nAs far as arbitrary sub-sections, maybe we could implement a mechanism that allows you to inject a custom scope for a given object type (in this case deferreds). Initially it could just be a hardcoded version for Deferreds.\n```\nTodo.findAll => new can.Map({\n  resolved: args,\n  rejected: args,\n  pending: false\n});\n{{#Todo.findAll}}\n  {{#resolved}}\n    resolved args\n  {{/}}\n  {{#rejected}}\n    resolved args\n  {{/}}\n  {{#pending}}\n    pending\n  {{/}}\n{{/}}\n```\n. The problem with this is with the context(s) that the with helper passes. I'm looking into a solution, but this might require the with helper to be implemented in a different way (maybe just treat it exactly as a Mustache section instead of implementing it as a helper).\nIn the meantime, you can use regular Mustache syntax as a workaround:\n{{#foo}}\n  {{#if loaded}}\n    {{#if ready}}\n      Ready!\n    {{else}}\n      Not Ready\n    {{/if}}\n  {{else}}\n    Loading...\n  {{/if}}\n{{/foo}}\n. This was fixed with the fix for #228. #228 ended up being a dupe of #215.\n. There is a lot that is specced in the Mustache spec definition files that isn't listed on their site: https://github.com/mustache/spec\nSections are specced to pass contexts, but partials aren't.\nRegardless, good idea so I added support. :)\n. Fixed.\nThanks a lot for your bug reports. Your descriptions and jsfiddles are very helpful.\n. This sounds like the same problem that is causing #157.\n. I have some uncommitted tests that I'll commit to a new branch for this issue.\n. I misread which issue this was, I already checked tests into the live-bind-observe-attr-157 branch. I added more comments in #157.\n. Closing as a duplicate of #157.\n. Recently ran into a similar issue while migrating a JMVC 3.1 codebase to latest. The workaround seems to be what Curtis mentioned (adding extra EJS tags to separate lines). It seems that EJS loses track of the number of brackets being opened and closed somewhere along the line.\nThis will generate a bad template:\njavascript\n<% if (true) { %>\n        <% if (true) { %>\n                hi\n        <% }\n } %>\nWhereas this is a good template:\njavascript\n<% if (true) { %>\n        <% if (true) { %>\n                hi\n        <% } %>\n<% } %>\n. Yeah, I think you're right.\n. I've fixed a chunk of this issue (my semi-related portions), but the original issue still fails.\n. I fixed the issue involving variables mentioned in the original issue description, except it only works if you're finishing your statements with semi-colons.\nSo these will work:\n``` javascript\n<%\n  var m = \"Mark\";\n  can.each(this, function( todo ) {\n%>\n  <%= todo.name %>\n<% }); %>\n<%== m %>\n<%\n  var m = \"Mark\"; can.each(this, function( todo ) {\n%>\n  <%= todo.name %>\n<% }); %>\n<%== m %>\n```\n\nbut these won't:\n``` javascript\n<%\n  var m = \"Mark\"\n  can.each(this, function( todo ) {\n%>\n  <%= todo.name %>\n<% }); %>\n<%== m %>\n<%\n  var m = \"Mark\" can.each(this, function( todo ) {\n%>\n  <%= todo.name %>\n<% }); %>\n<%== m %>\n```\n. I edited my last comment, but originally this solution also supported breaking up on new lines. The last two cases (statements broken by whitespace) are too difficult to fix in an automated way without adding a full JS parser.\n\nHopefully requiring a semi-colon is an acceptable tradeoff.\n. I merged these fixes over. I'm going to leave this issue open for now for discussion.\nI don't think there is a feasible way to fix this issue entirely without completely parsing the embedded JS code, due to how live binding wires up.\nWe should update the documentation to include some minor details regarding this quirk:\n- Avoid multi-purpose embedded JS in your EJS blocks\n- If you're defining variables, either define them in an isolated EJS block or use a semi-colon (which will have the same effect behind the scenes)\n. Lots of activity... I reverted the changed related to variables as the solution just caused issues that weren't reasonably resolvable.\nI would say we should just recommend that variables defined in templates are always defined in isolated blocks <% var m = \"Mark\" %> or are only used in the block they're defined in.\n. I've researched this a bit more and it seems borderline impossible to fix efficiently. In order for live binding to work, live binding uses the open EJS tag as a hint to inject a live-bound section.\nThe only possible solution seems to be to implement a JS parser to find the beginning of the final JS statement as a live-bound insertion point, but that requires a lot of code for limited benefit (although only at compile time).\nThe best solution seems to be to recommend that any long-lived variable, a variable that is accessed outside the active EJS block, should be defined in an isolated EJS tag.\njavascript\n<%\n  var bestTeam = teams[0];\n  can.each(teams, function(team) {\n%>\n  <div><%== team.name %></div>\n<% }) %>\n<div class='best'><%== bestTeam.name %>!</div>\nbecomes:\njavascript\n<% var bestTeam = teams[0]; %>\n<%\n  can.each(teams, function(team) {\n%>\n  <div><%== team.name %></div>\n<% }) %>\n<div class='best'><%== bestTeam.name %>!</div>\n. After discussing with fellow devs, we will be adding documentation for recommended usage/workaround but the bug itself won't be fixed since it would require fully parsing the JS.\n. Added documentation stating \"declared variables and control blocks should always be enclosed in dedicated tags\". Closed as won't fix.\n. This is fixed with the fixes for #153.\nUpdated fiddle with the fix copy+pasted: http://jsfiddle.net/B8kWR/8/\nI modified the test templates slightly because {^if text} isn't a valid helper call (should be {#unless text} or {^text}).\n. It looks like that does work now. That must have been something that changed between the version of Mustache in that fiddle and latest.\n. I have a solution for this, but unfortunately it breaks something else (#227). Although, I think #227 is only working because of this bug.\n. It originally worked similar to what I think you're suggesting. We switched to the array-based stack because it was exponentially faster (~5-10x faster for a simple template with one live binding).\n. Context stacks will no longer get duplicated when updating the stack.\nHelpers now get passed a copy of the stack in the options object (options.contexts) that can be passed to options.fn instead of this. This will allow the helper to still access references outside its original context (really only needed in weird cases with partials).\n. I merged portions of your pull request: The changes in Mustache.get and your test case with some minor tweaks to the template since it contained unsupported syntax ({{else}} within a base Mustache section).\nI skipped the Mustache.txt changes as they seemed to primarily be for supporting the {{else}} within a base Mustache section ({{#foo.bar}} instead of the {{#if foo.bar}} helper variant). {{else}} is part of the helper extensions to Mustache and should only be used with helpers.\nCurrently, any template that isn't using helper enhancements should maintain compatibility with other Mustache libraries that implement the official spec.\nI'm going to leave this pull request open for now in case anyone wants discuss this further.\n/cc @justinbmeyer @daffl @moschel \n. This is indeed similar to #153, but not fixed by its fix. This is a dupe of #157.\n. Added Mustache.resolve that'll resolve any variable the same way it would normally be interpolated and updated the default helpers to use this for evaluating truthyness.\n. Pretty sure I messed up the other branch...\n. It did show the build result after quite a while. I think Travis CI has been having some issues based on their status page, both today and last night it took a really long time before the build actually ran and showed up on GitHub.\n. Please review these changes before we merge this @justinbmeyer @ccummings @daffl \nDo you foresee any issues with these changes?\n. This commit should be included in the final build for JMVC 3.3.\n. This now fixes the issues that I was having (non-isolated blocks of code breaking), but still doesn't fix the original issue for #242 (losing variables).\n. Functions aren't part of the spec so there isn't an official \"it should be this way\". I'd recommend doing something similar to how we do helpers. Check for a matching path on the function object first, then if there wasn't one execute the function and apply the path on that.\nIt could get messy once you start having multiple functions in the chain though.\n. Just an update on this issue, I would lean towards:\nResolving paths with function objects\n- Initially treat the function as a plain object, checking the next lookup in the path\n- If the next lookup is found on the plain object, use it\n- Otherwise, execute the function and attempt a lookup on that object\nInterpolation\n- If the final object in the path is a function, always execute it and return the result\n  This should provide compatibility for the current interpolation method (where it will always execute the function and do lookups on the result, regardless of where it is in the path).\nHelpers\n- All final objects, including functions, should be passed as raw objects\n. That seems like a fair compromise.\n. @bmomberger-reciprocity I will definitely be fixing the consistency of the parameters.\n. I added the following fixes:\n- can.Construct functions are never executed in lookups\n- Anonymous functions that are not the final lookup are always executed\n- Helpers arguments/hash objects are now consistent\n  - Functions that are the \"final\" object are always passed as the original object and never executed\n  - The argument/positional parameter way things were handled were the proper way\nFor instance, the helper in your fiddle would need to be changed to:\ncan.Mustache.registerHelper(\"cat\", function(options) {\n    var clazz = options.hash ? options.hash.clazz : options;\n    // When using the anonymous function containing foostructor, it will need to be executed\n    return clazz.text || clazz().text;\n});\n. This seems to be an issue with the can.Observe attributes serialize method conflicting with can.Observe.List's serialize method. When attributes get serialized, they're checked against a stack of already serialized observes to prevent infinite loops, but can.Observe.List.prototype.serialize seems to bypass this.\n. Yeah, I think this could be easily fixed simply by having can/observe/attributes also override can.Observe.List.prototype.serialize in addition to can.Observe.prototype.serialize. I don't have time at the moment to take care of this but I'll fix it soon.\n. It's reproducible with this fiddle: http://jsfiddle.net/a2b3S/5/\n. Yeah, that should fix it, but like you mentioned, need to verify that it destroys properly as well as serializes lists properly.\n. This might be a candidate for 2.1.0. /cc @daffl \n. I included your changes and added a test in #700.\n. @daffl Updated\n. Sounds awesome, I think in the documentation we definitely need to highlight that there is no live binding with this and that you have to bind/unbind manually.\n. I've tested this a bit further, and this is an issue whenever the compute's value starts as undefined. It doesn't matter what type of new object you set it to (not can.Construct-specific)\n. In the meantime, here's a workaround... Initialize your empty can.compute with can.compute(null).\n. Looks like util/zepto overwrites Zepto's methods instead of extend them (specifically $.fn.empty, $.fn.remove, and $.fn.data --- other extended methods still call the originals). $.fn.data should be fine, as no plugins should really be extending it.\n. (Fixed with the pull request)\n. The current code passes the modified tests in the pull request without any changes.\nThe escaping really only applies to HTML tag escaping (it doesn't do ampersands). I'd disagree that attributes should always be ampersand escaped, I'd expect that your original content should be \"x&y\" in that case.\n. This is ready to merge pending some external changes involving test running.\n. Fixed with #671.\n. If there is a double read I think it's worthwhile for the consistency, although in my testing the amount of lookups in both cases was roughly the same.\nOptimally you wouldn't have data organized like this in cases where the performance was an issue.\n. Good catch, thanks!\n. What version of Android are you testing against?\nCan you provide more detail about the code around the can.route.ready() call?\nThe tests currently pass when I'm running it against Android 4.1 with jQuery 2.0.3.\n. This seems to specifically occur when using Zepto (not if you run the tests without a library).\n. I'm going to be adding a little tweak to your commit, then I'll merge it.\n. Closing this specific pull request, but I'm including your changes with an additional tweak in #686.\n. @stevenvachon Yeah, it was still randomly failing even at 1500ms (not often, but it happens). Difficult to replicate unfortunately, so I'm hoping this fixes it.\n. No worries, honest mistake. That method I used is a good general hack for those types of tests. Not pretty but it works. :)\n. This is ready to merge pending some external changes involving test running.\n. @stevenvachon If you click the Files Changed tab, it'll give you a diff that summarizes the entire pull request. (and then click View if you want to see the full file)\nAlso, the issue may or not be solved, we're doing cross browser and cross library testing and stuff keeps popping up. :)\n. The solution for this is pretty simple, use .bind/unbind if .delegate/undelegate aren't implemented.\n. It looks like Dojo/Zepto had additional failures because their libraries don't support using delegate without a selector.\n. This branch was started based on master and then merged with minor, I'll have to reorganize this a bit since minor hasn't had master merged in recently.\nI will most likely start this pull request over and cherry-pick my and @booc0mtaco's changes.\n. Closing until I fix this.\n. Implemented as part of #870.\n. Implemented as part of #870.\n. This ended up not really being related to #450, it has to do with how components handle scope, which is different than how mustache does it.\n. Rebased against latest minor so that this pull request can be merged.\n. I thought those weren't going to be deprecated until 3.0?\n. I can take care of this if there is a general consensus that we should include it in core.\n. I was thinking something similar to can/event/util.js. When we added can/event, I added a stub that just returned what that module used to return (but pointed to the object implemented at the new location). This way we don't force people to change their implementations until we fully deprecate the API.\nSomething like:\njavascript\n// can/construct/super/super.js\nsteal(\"can/util\", \"can/construct\", function(can, Construct) {\n  // The super plugin is now included in can/construct directly.\n  return can;\n});\n. I'll take a look at this, I believe there is also some vagueness in that some of this filter/sort support in Lists is via plugins when it isn't specified in the documentation as such.\n. I added documentation for the can/map/list plugin. Is does indeed change the function signature for List.filter, so I added that information to the documentation as well.\n. I'm not sure how we want to handle this, since we're trying to avoid API changes. Maybe just change the plugin's API, since the plugin wouldn't be considered a core API change.\n. Changed the milestone to 3.0 since it requires an API change.\n. Yeah, instanceof undefined fails.\n. ",
    "freejosh": "The issue can be reproduced again when trying to output a table for each element in the list, when the loop is preceded by any other element: http://jsfiddle.net/FrRWz/1/\nHowever I noticed that it works properly if the whole template is wrapped in an element: http://jsfiddle.net/FrRWz/2/\n. ",
    "saadtazi": "Oops, I just realized my pull request is from my master branch... I'm not sure if it will cause an issue... Let me know.\n. Oops, I just realized my pull request is from my master branch... I'm not sure if it will cause an issue... Let me know.\n. Even without mappings or paths (except a path for jquery), the only way to have it work is to have the can/ folder at the root level of the site. Using data-main attribute won't work, even if you have the can/ folder under the js folder:\n<script data-main=\"js/main.js\" type=\"text/javascript\" src=\"lib/require.js\"></script>\nI get the following error:\n\"NetworkError: 404 File not found - http://127.0.0.1:8000/can/util.js\"\n\"NetworkError: 404 File not found - http://127.0.0.1:8000/can/view/scanner.js\"\n\"NetworkError: 404 File not found - http://127.0.0.1:8000/can/view/render.js\"\nIt seems to work if I remove all the '.js' in the require() call, even with the data-main, which allows to organise js files.\n. Even without mappings or paths (except a path for jquery), the only way to have it work is to have the can/ folder at the root level of the site. Using data-main attribute won't work, even if you have the can/ folder under the js folder:\n<script data-main=\"js/main.js\" type=\"text/javascript\" src=\"lib/require.js\"></script>\nI get the following error:\n\"NetworkError: 404 File not found - http://127.0.0.1:8000/can/util.js\"\n\"NetworkError: 404 File not found - http://127.0.0.1:8000/can/view/scanner.js\"\n\"NetworkError: 404 File not found - http://127.0.0.1:8000/can/view/render.js\"\nIt seems to work if I remove all the '.js' in the require() call, even with the data-main, which allows to organise js files.\n. @rjgotten , I also think that the js files in amd/ should not specify the file extension as part of the module URI.\n@daffl : to map util to a specific libray, what about using:\nmap : {\n    '*' : {\n          \"can/util\" : \"can/util/zepto\" // no .js\n    }\nI have to admit that I didn't test it, I will try tomorrow if I have time... or this wend-end.\n. @rjgotten , I also think that the js files in amd/ should not specify the file extension as part of the module URI.\n@daffl : to map util to a specific libray, what about using:\nmap : {\n    '*' : {\n          \"can/util\" : \"can/util/zepto\" // no .js\n    }\nI have to admit that I didn't test it, I will try tomorrow if I have time... or this wend-end.\n. I narrowed down the build issue I have when observe/sort is included in the amd build: it is at line 128:\nvar index = +/^\\d+/.exec(attr)[0],\nHaving that line splitted in 2 lines solves the problem:\nvar re = /^\\d+/,\n    index = +re.exec(attr)[0],\nBut I think it might be because of a steal bug so I didn't update my pull request. Still trying to figure out what the steal code does... A bit lost I have to admit.\n. I narrowed down the build issue I have when observe/sort is included in the amd build: it is at line 128:\nvar index = +/^\\d+/.exec(attr)[0],\nHaving that line splitted in 2 lines solves the problem:\nvar re = /^\\d+/,\n    index = +re.exec(attr)[0],\nBut I think it might be because of a steal bug so I didn't update my pull request. Still trying to figure out what the steal code does... A bit lost I have to admit.\n. Hi,\nI know that 'can/control/route' (which is actually not a plugin but part of the core I think) was not included, that's why I went through all the js files...\nI think 'can/control/route' should definitively be added... I'll update the pull request to only contains 'can/control/route' and any missing official plugins (if any).\n. Hi,\nI know that 'can/control/route' (which is actually not a plugin but part of the core I think) was not included, that's why I went through all the js files...\nI think 'can/control/route' should definitively be added... I'll update the pull request to only contains 'can/control/route' and any missing official plugins (if any).\n. Sorry for the mess... recreating a new pull request\n. Sorry for the mess... recreating a new pull request\n. ",
    "jej2003": "In looking at Model.js am I wrong that this is just a change to lines 646 - 650 to do the following\njavascript\nreturn function( id, attrs, success, error ) {\n    return ajax( str || this._shortName+\"/{\"+this.id+\"}\", addId(this, attrs, id), success, error, fixture(this, \"Destroy\", \"-restDestroy\"), \"delete\")\n}\nand then removing lines 142 - 144?\nThis worked for my case, but I am not sure if there is something else that will break because of this change.\n. Yes, this is exactly what I would need\n. I unfortunately don't have the bandwidth to switch from JavaScriptMVC to CanJS (unless it's less complicated than I assume), If need be it's fine to mark this as fixed and I'll reopen the issue against CanJS when we move to it if it doesn't work.\n. Thanks daff, do you have a link to this?  If so I'll check it out.\n. ",
    "Wizardum": "I checked and it seems that mustache.js was the only one that was returning a different object.\nejs.js, jaml.js, micro.js and tmpl.js were all returning a can object.\nWhatever is receiving the template engine (I can't recall where I saw it) to compile the mustache templates, it expects an object as argument, and that object has a property called \"Mustache\", which is, in this case, the can object.\nRegarding the thing about modules, I'm not sure how I can help with that though. I'm still trying to get how modules and AMD stuff works.\n. Check this, scroll down to the Associations section.\nI think this does what you are asking for. :)\n. +1\nThat's a very useful feature.\n. ",
    "sporto": "How is this different from the can.List promise plug-in? \nIs it the fact that you could do Todo.findAll directly on the view? Personally I don't see this a good thing, as it mixes concerns and creates tighter coupling.\n. @justinbmeyer I think that making the API in the template consistent is very important. With the can.list promises plug-in you have already introduced syntax like:\n```\n{{#if todos.isPending}}\n    Loading\n{{/if}}\n{{#if todos.isResolved}}\n    ... show the todos\n{{/if}}\n```\nThis proposal seems inconsistent with that, which is not great.\nI often want components can either fetch their own model/models or receive a model/collection already in fetched. So, it would be really great to not even have to bother if something is a model/list or a promise, but still have the power of saying .isPending to show a loader.\n. @justinbmeyer\nI think I was looking at the wrong example, so if there is always a .isResolved etc, then it is all good.\nThe other consistency issue is {{#each todos.value}} vs {{#each todos}}, but you are addressing this in your last point.\n. Optimally I would like to have a template like:\n{{#if foo.isPeding}}\n    ... show loader\n{{else}}\n    ... show foo\n{{/if}}\nAnd not really care if what I give is a promise or a model. So my component could either do;\nvar foo = new can.Model({...});\nor\nvar foo = Foo.findOne({...});\nIn the first case the template would expect a isPending, isRejected, etc function in can model, maybe they could be there just so the view can easily accommodate this use case.\nIn the second case it would be something like the existing list plug-in.\n. @justinbmeyer I have been playing with this and I am not clear of the solution, would you mind explaining more?\nThe way I see it there are two issues:\n1. Can compute uses an incompatible API with can.observe: can observe you can do person.attr('name') but for compute you need person.fullName(), it would really nice to have only one API\n2. can compute cannot be observed.\n. +1 it will be very nice to bind directly to fullName, the solution shown above looks unnecessarily complex.\nAlso even if you do this it is not optimal because sometimes you just want to pass your observable object to other object, that other object shouldn't need to figure out what API is supposed to use to access or bind to a property, it should be totally transparent to that other object e.g. person.attr('firstName) or person.attr('fullName') should look exactly the same from the other object's perspective. So somehow aligning the APIs will be great.\n. I don't think I have explained the issue fully. When you try to use a compute as part of a can.Observer/Map you have to deal with incompatible APIs. Observer uses observe.attr('foo') while compute uses foo(). This is not a problem when using can views as those views are smart enough to figure out the differences. But when trying to integrate other libraries e.g. rivets.js this is an issue.\nLet me use Ember.js code to show my desired behaviour.\n```\nPerson = Ember.Object.extend({\n  full: function () {\n    return this.get('first') + ' ' + this.get('last');\n  }.property('first', 'last')\n});\nobserve = Person.create({\n  first: \"Sam\",\n  last: 'Sample'\n});\nconsole.log(observe.get('first')) //=> Sam\n console.log(observe.get('full')) //=> Sam Sample\n```\nAs you can see 'full' is a computed property, but there is uniform access here. You just do observe.get('xxx') to get what you want regardless if it is property or a compute.\nAs far as I have tried Can cannot do this (or can it? example?). I would be really nice to consider going towards this on the future.\nAlso the concept of uniform access could extend to observing computed properties e.g.\nobserve.bind('full', function (oldVal, newVal) {\n    ..do something  \n});\n. that was quick, very nice thanks.\n. I'm trying to use Can with webpack and having trouble with this, because it cannot resolve the dependencies, this is because of the use of the absolute path inside Can.\nWhat would be the downsides of instead of doing this:\ndefine([\"can/util/library\", \"can/control/route\", ...], function(can) {\n    return can;\n});\nDoing this?\ndefine([\"./can/util/library\", \"./can/control/route\", ...], function(can) {\n    return can;\n});\nSo Can itself looks for relative dependencies, and it doesn't force people to define a configuration. We can always define an alias for can if we want, but it should not be a requirement.\n. Probably, will have a go at testing later\n. Looking at this it doesn't seem related, I might be missing something.\nThe problem is that errors object is just a plain object returned by doing model.errors();\nWhat would be really good is to be able to do model.attr('errors') so it can be used in views, e.g. {{user.errors.name}}\n. In order to run the tests I had to:\n- clone canjs\n- rename canjs to can\n- put can into a subfolder\n- grab funcunit from github and put it there\n- grab steal from github and put it there\nThen it ran, this is in my opinion too much.\nWith NPM the workflow could be:\n- clone canjs\n- run npm install inside canjs folder\n  DONE!\nBut that would require steal and funcunit to be packaged as modules.\n. Right, I was looking at https://github.com/sporto/canjs/blob/master/contributing.md and didn't see those steps.\nStill simplifying it would be great.\nI think that a lot of JS devs are quite used to NPM these days, I don't see using NPM as a liability at all. I think is a plus.\n. That is fantastic, thanks.\n. Another example\nhttp://jsbin.com/unigav/2/\n. Also in EJS\nhttp://jsbin.com/unigav/3/\n. Just a note, it would be good to mention this dependency in the documentation. http://canjs.com/docs/can.fixture.html\n. My only concern is that when I see code like\n<my-component message=\"foo\" ></my-component>\nI cannot tell straight away what was the intention here, what it to pass the 'foo' string or to pass a foo object in the current context? I would be nice if this would be completely unambiguous.\nRe {message} vs {{message}}\nYes, that seems like they would do the same. So disregard that part.\nRe Backwards compatibility\nThis is very important, so maybe something for a future version or as you say some additional syntax that can be used on top if you think this is worth doing.\n. +1\n. Please consider putting a request for inclusion here http://kapeli.com/contact, this might do it if there are enough of us asking for it\n. Probably related https://github.com/bitovi/canjs/issues/965\nJust by going to http://canjs.com/ in IE8 you can see this error\n. Suggested solutions seems to be using https://github.com/bitovi/canjs/blob/minor/lib/html5shiv.js\nIs canjs.com including the shiv?\n. I retract myself, this doesn't work for us using the shiv, will try to give more details later on, but for now check the canjs.com page\n. Here is a bin that show the issue in IE8\nhttp://jsbin.com/raqaj/3/edit\n. ok\n. IMO helpers like {{link recipe.name page='recipe' id=recipe.id}} are not great, they make things more difficult, what if I want to add a title, aria-role, class, data or whatever, helpers need to account for a way of doing all these.\nI see custom attribute or custom elements as a better way, as you are free to modify the html tag as you see fit. \nCould you pass a json like object to the custom attr version? e.g.\n<a can-href=\"{page: recipes, id: recipe.id}\">{{recipe.name}}</a>\nHowever I'm confused about the possible syntax. Some common patterns I use:\n/#recipes\n/#recipes/1\n/#recipes/1/edit\n/#recipies/search?foo=bar\n/#users/1/recipes\nThe first two are clear, how would you express the others?\n. I think is worth looking at how the API is resolved in React-Routes https://github.com/rackt/react-router/blob/master/docs/api/components/Link.md\nSomething like:\n<can-link route-to=\"recipe\" route-params='{id: recipe.id}' route-query='{foo: bar}'>{recipe.name}</can-link>\nI find this very easy to understand. But they rely heavily on named routes for this which Can doesn't have atm. Anyway, something to consider.\n. No, I don't think that React-routes does two way route binding.\nThis is a convoluted example but worth using, how would you link to:\n/#user/1/comments/search?foo=bar\nIn React-Routes you would do:\n<Link to=\"user_comments_search\" params={{userId: user.id}} query={{foo: bar}}>Search</Link>\n. Related issue https://github.com/bitovi/canjs/issues/355\nI think that validations require more discussion. At the moment you cannot bind validations in a template easily. .errors need to be an observable object that can be transparently used in templates.\n. @rjgotten care to make a fiddle showing this?\n. I agree, validation should be only in the models, I don't really like the way Angular forces you declare the validation in the form, that is just their workaround because they don't have models. Some people argue that you might want different validations in different contexts, but I don't ever see that need in real apps.\n. Just to be clear on what is being proposed here, several people are keen to have a way to declare validation directly on the templates, but how would that interact with validation on the models? Would you have to duplicate the validation rules? \nI like having validation in my models as I can use that validation in several places. What is missing for me is a clean way to bind that validation to the views.\nRe state of validations\nFor me a model is either valid or not at any given time. The fact that I might want to show a validation message as you type or when you hit submit is a view concern, so this I would like to see declared in the view somehow.\n. @justinbmeyer the way I see it, it as about what someone expects without knowing too much about the implementation of a component. \nIf I see message='hello' I know I am passing a string hello. Then if I see message='true' I would expect to be passing the string 'true'. \nIf I see message='{true}' then I wouldn't expect this to be a string but something else. If that something else could be a property on the parent scope or a boolean is not totally clear, but at least I know is not a string.\nI don't want to go digging into the component implementation to know if message='true' is being converted into a boolean or is just a string. I think this is important to have conventions (expected behaviours) for long term maintainability of projects.\n. I tried that, a function that returns another function, but it doesn't work for me:\nhttp://jsbin.com/koxobamo/18/edit\n. This is not too different from passing an object with a function on it, and then just calling that function from the sub component: http://jsbin.com/hawunu/1/edit\nThis requires the sub component to know a lot about the given object, i.e. the name of the function to call.\nAll ugly workarounds for something that shouldn't be so complicated.\n. @justinbmeyer this method of assigning an attribute on the parent e.g. parentScope.attr(\"child\", childScope); seem to cover a lot of the cases. But I cannot say is elegant, the issues I have with this are:\n- Several children components could try to assign the same property e.g. child\n- the solution to this above would be to always use children, but then the component needs to assume that there is a children array on the parent\n- the parent component needs to know what the child component will set e.g. child or children\nI see tight coupling on this solution, personally I prefer not to go this way.\nFor me the way to avoid coupling is:\nWhen passing messages down: the parent component already knows the tag for a child component, so it could call a method on the DOM element or get the scope of the DOM element and call a method on it.\nWhen passing messages up, either using events or callbacks.\n. Re testing\nCould parent just be set automatically on the child scope?\nThen you would do:\n// child\nscope: {\n  doSomething: function(){\n    this.attr(\"parent\").doSomething();\n  }\n}\nSo in the test you could just do:\nvar childScope = new ChildScope();\nvar parentScope = new ParentScope();\nchildScope.attr(\"parent\", parentScope);\n. @justinbmeyer I think you are considering just the scope, I am thinking about the whole component, so the whole component has a template, the tag element is right there, is obvious. \nFor example in:\n```\ncan.Component.extend({\n     tag: \"my-element\",\n     scope: {\n },\n  template: \"<div>\"+\n     '<child-component />'\n    \"</div>\",\n\n})\n```\nI know I have access to child-component and can do things with it.\nOn the other hand the scope attribute is nowhere to be found on the parent component definition. It is in the child component definition. In order to know that a property child exists I will need to go digging in the child definition component.\nYou could say the same thing about methods in the child component, but this are the external API, so I think it is not the same.\nMaybe what is need is a way to tell the child component what property to set:\ncan.Component.extend({\n     tag: \"my-element\",\n     scope: {\n        doSomething: function () {\n            child1.foo();\n        }\n     },\n      template: \"<div>\"+\n         '<child-component ref='child1' />'\n        \"</div>\",\n })\nThen I will know that I can talk to the child component using child1\n. ",
    "Bajix": "Is it even necessary to support this kind of functionality? In almost all cases you could utilize asynchronous getters/setters to create belated change events, at which point this is a simple matter of using section helpers. It's perfectly valid as well to both return a placeholder value (false maybe?), and later call setValue on done to force the section helper to inverse while pending.\n. I briefly mentioned a concept on https://github.com/bitovi/canjs/issues/1080 in which we'd make getters and setters both able to use async getters and setters and pipe values. I think however we can accomplish all the functionality desired here by expanding on that concept, and by treating this in a similar fashion as validation by creating a promises object.\n```\n{\n  async: true,\n  get: function( setterResult, [optional cb] ) {\n    // setterResult is the returned value of set\n    // cb is optional, giving flexibility\nreturn Foo.findOne(setterResult);\n\n},\n  set: function( setterValue, [optional cb] ) {\n    // Called directly with the results of set\n  }\n}\n```\nIn this scenario, if the getter returns a deferred, we'd wait until it resolves before updating the getterValue, which is what will be returned when calling attr. This gives us very desirable getters, and change events. We then would expose a promises attribute that has a hash map of all of the deferreds.\nWe could access it in the template as {{#foo}} or as {{#promises.foo}}/{{#promises.foo.isPending}}/{{#promises.foo.isResolved}} etc.\nThoughts?\n. Well, so part of the goal of what I was proposing is to make it so that accessing a property using, for example, findOne, would always return either null, or the currently set instance. The point of this approach is so that after resolving, your values are always synchronously available, and aren't updated unto the next async setter resolves.\nThere are a lot of huge benefits to this sort of approach. For starters, your accessors are very lean, and can be readily used in other computes. You can also interact with the current value, and with the underlying promise independently, making it so that your views can opt to show the current value until the new value is loaded. By having access to the underly promises, you could construct composite when promises, potentially even by using computes observing the promises object. It really just lets us use whichever approach is applicable for the situation.\n. @justinbmeyer Rather than using switches, I usually add in helpers for ternary operators, and for matching values.\n<div class=\"{{state foo 'active' 'inactive'}}\"></div>\n{{#assert foo 'bar'}}\nFoo is bar!\n{{/assert}}\n{{#assert promises.bar.state 'pending'}}\nBar is pending!\n{{/assert}}\nThoughts?\n. I get that, but it's not very clear that this is the case. We'll chalk it out to a documentation issue\nSent from my iPhone\n\nOn May 16, 2014, at 7:06 AM, Justin Meyer notifications@github.com wrote:\nComputes can't always cache without creating a memory leak. \nSent from my iPhone \n\nOn May 16, 2014, at 2:09 AM, Bajix notifications@github.com wrote: \nA lot of times it's common to build out can.Map's before tying them into much. Unfortunately, when doing this, computes are not bound to anything, and thus fail to return cached values. This gets particularly problematic when returning objects, particularly deferreds. \nThere is no documentation that expresses when can.Compute will/will not cache values, and it's not obvious that you need to bind a change handler to them for them to work in that manner. \nComputes should always cache values, or otherwise the documentation needs to be updated to make this crystal clear. \n\u2014 \nReply to this email directly or view it on GitHub.\n\u2014\nReply to this email directly or view it on GitHub.\n. Set up a decent performance fiddle to gauge dom manipulation, hope it helps! \nhttp://jsfiddle.net/RtYxL/\n. Is this even needed? There's not really any case in which you don't readily have access to the super within your lexical scope.\n. This seems like a documentation issue. The clear approach when precedence is an issue is to define all routes, in order, using can.route, before instantiating any controls.\n. Makes sense. This should be explicitly documented at the very least.\n. I'm not sure what you mean here; Components defined after can.view already work. \n. Well, regardless of whether or not if I extend can.event into can.Map, there is a clear need to both be able to emit custom events, and be able to bind to those events using the dot event syntax.\n. While I agree that using the observable pattern is much better design pattern than using an event bus, the two can coincide. For example, it makes a lot of sense to emit events as a precursor to updating the state.\n. Ok. Let's say we have a youtube clip represented by a can.Model, and this clip has a playing attribute. It makes more sense to treat playing as an intrinsic state, that represents what's really happening. One might emit play, have the player bind to the event, play, and update the clip as playing once the clip is actually playing. If however we were updating playing, and observing that change, then the asynchronous, and erratic, updating of playing would cause an infinite change loop (youtube might emit something like buffering, playing, paused, buffering, playing before actually starting playback).\n\n\nIn this case, dispatching an event makes more sense, and you still reap all the benefits of having observable states.\n. Well, there are certainly other use cases, like if you initialized with seek at 0, then later restarted at 0 - using an observable here wouldn't create a change event. I've seen your examples, I just don't think that approach is the be all end all.\nIt doesn't sound like it makes sense to extend can.event into can.Map, however what about using can.Map's batch trigger for this purpose?\n. Whoops\nExample A:\nhttp://jsfiddle.net/uVkUy/\n. Well, design philosophy aside, it is a bug if the expectation is that the getter is passed the current value, and this isn't reflected after updating the current value.\n. That's only true if it's bound to. In this case, the getter is called twice; when initializing, and after setting.   The second call should be passed the newly set date object.\n. Hmm, I guess I don\u2019t follow here. If the function is bound to, and our results aren\u2019t deterministic, then there would never be a change event to trigger the getter and re-evaluate the cached value, and that part is a clear limitation. On the other hand, if a property isn\u2019t bound to, then there is no value caching, and the getter is called every time the property is accessed. In that specific use case, it makes sense to always pass the currentValue ( as set by the setter ) into the getter. Are there any limitations in that use case?\nOn Jun 12, 2014, at 4:03 PM, Justin Meyer notifications@github.com wrote:\n\nSure, but my point is this use case might be something we can't support. \nSent from my iPhone \n\nOn Jun 12, 2014, at 2:08 PM, Bajix notifications@github.com wrote: \nThat's only true if it's bound to. In this case, the getter is called twice; when initializing, and after setting. The second call should be passed the newly set date object. \n\u2014 \nReply to this email directly or view it on GitHub.\n\u2014\nReply to this email directly or view it on GitHub.\n. First of all async getters are not documented whatsoever, and from a design perspective, a getter should always return a value immediately or return a deferred if applicable. Arguably, an async setter would be better in any scenario in which you'd want an async getter, as the results would always be synchronously available, and the live nature can be accomplished externally. If keeping async getters in is at the cost of making synchronous getters sane, it really might not be worthwhile to support async getters. It is really not that bad to simply return a deferred.\n\n\nI made a new example that has source observables, a binder, and that can only be represented using a getter, to demonstrate this issue more succinctly.\nhttp://jsfiddle.net/vsqC9/\nIf it is in fact the case that this kind of functionality cannot be supported, then it's probably appropriate to change the call signature of getter to not be passed the currentValue. As it stands now, you can show this example to any dev and they will be beyond perplexed, and the documentation on these caveats is lacking, making for developers to feel like they're fighting the framework.\n. The make model year example doesn't demonstrate async getters, it just uses lists to abstract away deferred's and binds to length.\nIs it really necessary to make can.compute and mustache support deferreds? It seems perfectly reasonable to use a translator as you described; one \"would have to listen to the value change, wait until the deferred has resolved, and then update some other observable value\". At least in this scenario, when someone does access the getter at any point, it's able to return a value. With an async getter paradigm, that's not the case, and arguably using done/then etc is clearer there than needing to bind, and is more consistent when a variable is already resolved (done calls as expected, but change wouldn't fire if cached), and is more flexible when chaining is necessary.\nI'll see what I can do to create a test for this\n. I haven't seen that signature before, is that how async getters are suppose to be declared?\nWhat if there's just an async: true property that tests getter results to see if they're deferreds, and auto resolves them, such that all change events would return the resolved results, and all direct getters would return the underlying deferred. Can that be a possible best of both worlds without compromising the ability to implement the presented getter scenario?\n. Follow up example:\nimages: {\n  get: function( images ) {\n    return images || new Image.List({ product: this._id });\n  }\n}\nIn this example, we have a function to lazy sideload in images into a product. If the product was constructed with or otherwise had the images property set, it should use that, otherwise load in on demand.\nIdeally, the getter would always be passed the current results of the setter. Then, if a setter would be called, the getter piped the results.\n. Your comment language is a little bit ambiguous. To be clear:\nThe way I envision this, calling the setter would update a value representing the current private value. Every call of the getter would then be called passed the current private value as the first argument. The results of that would be set as the current public value. Subsequent calls to the getter would still be passed the current private value.\nThe \"type\" property would be applied to the value passed into the setter, before calling the setter.\nThe \"value\" property would be passed into the setter during initialization.\nThe \"Type\" property would use an instanceof check on the results of the getter, and call the constructor if applicable. If omitted, can.List or can.Map will be used as applicable.\n. We should consider removing type: \"\" as well, and instead use Type: \"\".\nIt is really strange that we're using Type for constructors, and yet can.List/can.Map aren't applied using Type, but rather implicitly with if type: \"*\" isn't explicitly set. This is very inconsistent.\nIt's very weird how it exists currently, as if you call a setter with an array, the setter function is called with a can.List.\n. Well, so converting into can.Map's and can.List's in general makes sense, it's just a matter of when and with what declaration that I'm concerned with.\nThe big red flag is that can.List and can.Map are constructors, and yet it's the \"type\" property that controls this behavior. It makes much more sense to use \"Type\" instead, and make it exclusively responsible for converting constructors. Ideally, type would only be used for primitives.\nThe other question is when should Type and type conversions should be applied. Applying \"Type\" before the setter is problematic and exceedingly confusing. I cannot count the number of times I've had other developers go down rabbit holes because the setter isn't passed an array when they set it, or when they do something like this, expecting their Foo.List to contain Foo instances: http://jsfiddle.net/oep8vjgL/1/\nObviously they could have used type: '*', but real scenarios aren't always this simple, and really, having a setter be passed anything other than the original value goes against the grain.\nThat said, I think the timing, when bound to, should be like this:\nattr setter called\ntype conversion applied if primitive\nsetter called with converted value, results set as private value\ngetter called with private value\nType conversion called with getter value, results set as public value\nemit changed if public value changed\n. @justinbmeyer This was resolved in 2.2.0 but wasn't included within the milestone\n. I've been using something like this to avoid the issue:\n```\nvar hash = can.route.deparam(window.location.hash.replace(/#!/, '')),\n  defaults = {},\n  define = can.route.data && can.route.data.define;\nif(define) {\n  for( var key in hash ) {\n    if(define.hasOwnProperty(key) && !define[key].serialize) {\n      defaults[key] = hash[key];\n      delete hash[key];\n    }\n  }\n}\nwindow.location.hash = '#!' + can.route.param(hash);\ncan.batch.start();\ncan.route.ready();\ncan.route.attr(defaults);\ncan.batch.stop();\n```\nThoughts on getting a serialize checker into core to run before ready?\n. Promises follow a strict specification, so it's not really an option to make deferreds themselves observable.\nOne really good approach IMO is to use deferreds with async getters/setters in define. It might make sense to add a define async/deferred/autoresolve flag that will make deferreds returned by the getter/setter use the respective async setValue. Even could make it true by default\n. In this example, I couldn't manually do it even if I wanted - the define prototype of the extending class is thrown out altogether, using can.extend etc to manually create the prototype define wouldn't get around that. Right now, you're more or less forced to either be very creative with your static init, or make a separate constructor that directly extends can.Map.\n. Updated:\nhttp://jsfiddle.net/t7m77xvc/1/\n. Bump. The issue isn't resolved by using can/map/delegate either\n. Updated test with other binding signatures\nhttp://jsfiddle.net/ej10m0sn/3/\n. Well, so why should this be limited to only components? Bubbling is definitely good functionality for can.Control, can.Map.delegate, and can.Map.bind.\nWhile I didn't create tests for it at this juncture, I've ran into this issue while using components as well.\n. Yea, I could see how this could create performance issues.\nThis might be an area in which propagation or delegate are the only viable options.\n. Can we do anything to make shallow events work? Really the use case that I'm looking for here is to be able to bubble events emitted by immediate children of a map.\n. Quick follow up\nSo part of the reason why I see this type of functionality being immensely powerful is to be able to make shallow event bindings on a specific subject. This has the advantage of not requiring a lot of lifecycle logic, to teardown and rebind, or needing computes in luei of vanilla get/set functionality simply to coerce event handlers.\nThis use case doesn't really fit very well with propagate, as propagate is bottom up whereas the bindings in this case would need to be top down. Of course, you could make what you're intended to observe extend can/event with propagate, and use change events to change the parent, however that's a considerable amount of glue and requires extended somewhat violates separation of concerns, as it would require changes to the bindee that should otherwise exist on the binder.\nA simple win here might simply be to exclusively use the shortest pathway when bubbling events, such that in a case where you could emit 'cats.0.cat.meow' or 'cat.meow', 'cat.meow' would always win out, and maybe even be more performant, if not at the very least more predictable.\nIt would be pretty sweet to be able to dispatch custom events from a can.Map in the same manor.\n```\nvar Map = can.Map.extend({}, {\n  define: {\n    cats: {\n      value: Array,\n      Type: Cat.List\n    },\n    cat: {\n      value: Object,\n      Type: Cat\n    }\n  }\n}), map = new Map();\nvar Ctrl = new can.Control.extend({\n  defaults: {\n    map: map\n  }\n}, {\n  '{map} cat.meow': function() {\n    console.log('YAY!');\n  }\n});\n```\n. By shallow event binding, I mean that the event would bubble specifically to the immediate parent.\nSo if I had a map foo with property bar that is a can.Map instance, and if bar dispatched an event, that event could be bound to like foo.bind('bar.{event}'), where {event} could be a property name, or the name of a dispatched event. In the previous example, cat could have a property meow that could trigger a change event or alternatively use can.batch.trigger/can.event.dispatch to dispatch a meow event with the same effect.\nI see what you mean about the regex approach and testing change - maybe simplified to /cat\\.meow$/?. Anyway, the problem with that approach though is that it would still pick up events emitted from objects that aren't your subject (in this case cat), and require instance checking. Even then though, that feels awfully spammy and doesn't let you split up bindings if you wanted to do this with multiple properties and have inheritance etc.\nFrom a performance perspective, I'm kind of curios how emitting something like cats.*.cat.meow compares to only emitting cat.meow. Is the latter not more performant?\n. > It currently does do this and continues to bubble up.\nIt does do this, and I am using this in the example I originally posted\nvar b = new Classroom({\n    valedictorian: valedictorian\n});\ncan.bind.call(b, 'valedictorian.GPA', increment);\nvaledictorian.attr('GPA', 3.95);\nThat absolutely works! My callback gets called just fine there. The problem is that if that same map I'm binding to has another property, say a can.List that has that same object, suddenly my binding that was working will no longer work.\nvar b = new Classroom({\n    students: students,\n    valedictorian: valedictorian\n});\ncan.bind.call(b, 'valedictorian.GPA', increment);\nvaledictorian.attr('GPA', 3.95);\nThis example is where the problem is. That binding that was working in the previous example no longer works. That is the issue I'm trying to address.\n\nBut this makes think I'm still not communicating how bubbling works. Bubbling up to all parents is not the problem. The problem that if someone changes the \"cat\" property, you want a \"cat.meow\" event.\n\nLet's say the cat property of map becomes a new instance of Cat, map would have a change event, and a cat event. This is a change event exclusively on map. It shouldn't have a cat.meow event. The properties of cat are irrelevant to this change event. If however the new cat has a meow event, because meow was changed, or dispatched, now that should bubble up to map and be observable while binding as map.bind('cat.meow'). \n. @justinbmeyer Thoughts on getting this into the eventual roadmap? This is a very scary issue as it creates a scenario in which your bindings can break unexpectedly, for non-intuitive reasons. \n. It appears this is slightly less broken on latest than 2.1.4. \n2.1.4\nhttp://jsfiddle.net/vt4L4ydu/\nLatest:\nhttp://jsfiddle.net/r0nmmfh8/\nThe 2.1.4 example wasn't actually resulting in the right thing, and was breaking computes, which had much wider ramifications. The latest branch doesn't seem to have this issue with computes, which is awesome.\nI think you mixed up issues, and were thinking of #1483 \nI can tackle this issue. Assign it my way\n. It's Thomas@bajix.com\nSent from my iPhone\n\nOn Sep 23, 2015, at 6:25 AM, Justin Meyer notifications@github.com wrote:\n@Bajix what's your email? I'm sending you something to the email I have on file, but it bounced. Can you email me at justin AT bitovi? Thanks!\n\u2014\nReply to this email directly or view it on GitHub.\n. This is actually pretty easy to implement: if define is present, make a constructor and make it Type.\n\nI can't help but wonder though, if this offers any advantage over just using Type. It actually makes things a little bit awkward, as you can't do instanceof tests, and it encourages insane nesting. \n. Fair enough. I can put together a PR for this if someone wants to assign it to me.\n. Sample use case:\nnotifications.replace(Notification.findAll());\nBecause of the way can.Model.stores work, the resulting array could likely in fact have a large intersect, and only a subset would be new\n. After discussing this with @justinbmeyer the issues are:\n- For this to be advantageous, the time complexity of the solution would need to be O(N), or linear. Initially, this appeared as having a time complexity of O(N LOG(N))\n- A key value store neglects that Document Node's can only be attached once to a document fragment. Cloning would potentially be necessary\n- If @index is being read, then cloning may not be viable.\n- List replacing uses splicing, which is represented in two events: a remove event, followed by an add event. The current bindings aren't well suited for this. A batchNum like mechanism could be potentially used. This could potentially be represented by a new splice event.\nThis relates to the work for #1454 to create a move event, which could be represented as a splice event, and whose functionality would also be accomplished via a document store based approach\n. This might also just be an issue with .attr\nModifying can.Model.model like below to loop through the passed attributes and use the key value syntax instead of the object syntax allows the more fine grain capabilities of the define plugin to take over\n```\nmodel: function( attributes, oldModel, xhr ) {\n  if (!attributes) {\n      return;\n  }\n  if (typeof attributes.serialize === 'function') {\n      attributes = attributes.serialize();\n  } else {\n      attributes = this.parseModel(attributes, xhr);\n  }\n  var id = attributes[this.id];\n  if ((id || id === 0) && this.store[id]) {\n      oldModel = this.store[id];\n  }\nif (oldModel && can.isFunction(oldModel.attr)) {\n    for (var key in attributes) {\n      oldModel.attr(key, attributes[key]);\n    }\n    return oldModel;\n  }\n  return new this(attributes);\n}\n```\n. Do you think you could supplement this with an example on how to load CanJS within NodeJS?\nThis isn't working for me, nor does loading it with StealJS. This issue doesn't appear resolved at the moment\n. I've had issues loading it with StealJS as well as when loading the CommonJS distributable. For what it's worth, I'm also having tests fail on projects that use CanJS, such as can-ssr.\nJust looking at how can-ssr loads, there's a lot of configuration going into loading with StealJS, so it would be good to have a tutorial for doing this regardless.\n. Is there any reason why the main entry point can't be a wrapper to load in CanJS into NodeJS?\n. Well, there are several use cases I envision here, mainly around doing server side plugins. For example, broccoli-can-stache would benefit from being able to use can's built in template parsing. can-ssr would benefit from being able to load can without all of the ceremony.\nThe problem, as it stands now, is that a lot of aspects of CanJS, and more specifically DoneJS, are built around a one stop solution for everything, and encompass a seriously large number of tools that would otherwise be independently valuable in their own right, and more palatable to include in a standalone fashion. This limits the ability for outside developers to build their own tools for new purposes in mind, or to incrementally shift over.\nFor example, StealJS on Node is a very recent thing, and there are a lot of projects that aren't going to abandon their existing build system or otherwise don't feel comfortable making the transition for one reason or another, but would appreciate being able to use optimized templates, or alternatively to use optimized AMD bundling with RequireJS. Say for example you have a Grunt/Broccoli build pipeline, and are using SASS as a CSS pre-processor; you're probably not going to want to use StealJS because it only supports LESS.\n. In this case, I was actually using SystemJS to load the CJS dist of CanJS.\nIt's not entirely clear how one would use SystemJS + the can/view/stache/system plugin otherwise, as it doesn't exist in the AMD dist, and SystemJS won't load the main Steal app.\nIn any case, developers should be able to simply do jspm install can, and run things out of the box w/ SystemJS, which is how I ran into this issue in the first place.\nHere's what my system config file looks like:\n```\nSystem.config({\n  baseURL: \"/assets\",\n  defaultJSExtensions: true,\n  transpiler: \"traceur\",\n  paths: {\n    \"github:\": \"packages/github/\",\n    \"npm:\": \"packages/npm/\"\n  },\npackages: {\n    \"jquerypp\": {\n      \"main\": \"dist/cjs.js\"\n    },\n    \"can\": {\n      \"main\": \"./dist/cjs/can\",\n      \"map\": {\n        \"./can\": \"./dist/cjs/can\",\n        \"./component/component\": \"./dist/cjs/component/component\",\n        \"./construct/construct\": \"./dist/cjs/construct/construct\",\n        \"./map/map\": \"./dist/cjs/map/map\",\n        \"./list/list\": \"./dist/cjs/list/list\",\n        \"./list/promise/promise\": \"./dist/cjs/list/promise/promise\",\n        \"./observe/observe\": \"./dist/cjs/observe/observe\",\n        \"./compute/compute\": \"./dist/cjs/compute/compute\",\n        \"./model/model\": \"./dist/cjs/model/model\",\n        \"./view/view\": \"./dist/cjs/view/view\",\n        \"./view/ejs/ejs\": \"./dist/cjs/view/ejs/ejs\",\n        \"./view/stache/stache\": \"./dist/cjs/view/stache/stache\",\n        \"./view/stache/mustache_core\": \"./dist/cjs/view/stache/mustache_core\",\n        \"./view/href/href\": \"./dist/cjs/view/href/href\",\n        \"./control/control\": \"./dist/cjs/control/control\",\n        \"./route/route\": \"./dist/cjs/route/route\",\n        \"./control/route/route\": \"./dist/cjs/control/route/route\",\n        \"./view/mustache/mustache\": \"./dist/cjs/view/mustache/mustache\",\n        \"./route/pushstate/pushstate\": \"./dist/cjs/route/pushstate/pushstate\",\n        \"./model/queue/queue\": \"./dist/cjs/model/queue/queue\",\n        \"./construct/super/super\": \"./dist/cjs/construct/super/super\",\n        \"./construct/proxy/proxy\": \"./dist/cjs/construct/proxy/proxy\",\n        \"./map/lazy/lazy\": \"./dist/cjs/map/lazy/lazy\",\n        \"./map/delegate/delegate\": \"./dist/cjs/map/delegate/delegate\",\n        \"./map/setter/setter\": \"./dist/cjs/map/setter/setter\",\n        \"./map/attributes/attributes\": \"./dist/cjs/map/attributes/attributes\",\n        \"./map/validations/validations\": \"./dist/cjs/map/validations/validations\",\n        \"./map/backup/backup\": \"./dist/cjs/map/backup/backup\",\n        \"./map/list/list\": \"./dist/cjs/map/list/list\",\n        \"./map/define/define\": \"./dist/cjs/map/define/define\",\n        \"./list/sort/sort\": \"./dist/cjs/list/sort/sort\",\n        \"./control/plugin/plugin\": \"./dist/cjs/control/plugin/plugin\",\n        \"./view/modifiers/modifiers\": \"./dist/cjs/view/modifiers/modifiers\",\n        \"./util/fixture/fixture\": \"./dist/cjs/util/fixture/fixture\",\n        \"./view/bindings/bindings\": \"./dist/cjs/view/bindings/bindings\",\n        \"./view/live/live\": \"./dist/cjs/view/live/live\",\n        \"./view/scope/scope\": \"./dist/cjs/view/scope/scope\",\n        \"./util/tests/tests\": \"./dist/cjs/util/tests/tests\",\n        \"./util/object/object\": \"./dist/cjs/util/object/object\",\n        \"./util/function/function\": \"./dist/cjs/util/function/function\",\n        \"./view/autorender/autorender\": \"./dist/cjs/view/autorender/autorender\",\n        \"./util/domless/domless\": \"./dist/cjs/util/domless/domless\",\n        \"./view/stache/system\": \"./dist/cjs/view/stache/system\",\n        \"./view/mustache/system\": \"./dist/cjs/view/mustache/system\",\n        \"./view/ejs/system\": \"./dist/cjs/view/ejs/system\",\n        \"./util/event\": \"./dist/cjs/util/event\",\n        \"./map/sort/sort\": \"./dist/cjs/map/sort/sort\",\n        \"./util/vdom/build_fragment/build_fragment\": \"./dist/cjs/util/vdom/build_fragment/build_fragment\",\n        \"./util/vdom/document/document\": \"./dist/cjs/util/vdom/document/document\",\n        \"./view/import/import\": \"./dist/cjs/view/import/import\"\n      }\n    }\n  },\nmap: {\n    \"can\": \"npm:can@2.3.17\",\n    \"cssuseragent\": \"npm:cssuseragent@2.1.31\",\n    \"dropzone\": \"github:enyo/dropzone@4.3.0\",\n    \"highcharts\": \"github:highcharts/highcharts@4.2.3\",\n    \"jquery\": \"npm:jquery@2.2.1\",\n    \"jquery-ui\": \"github:components/jqueryui@1.11.4\",\n    \"jquerypp\": \"npm:jquerypp@2.0.1\",\n    \"peteruithoven/systemjs-debugger\": \"github:peteruithoven/systemjs-debugger@0.0.3\",\n    \"process\": \"npm:process@0.11.2\",\n    \"systemjs-debugger\": \"github:peteruithoven/systemjs-debugger@0.0.3\",\n    \"traceur\": \"github:jmcriffey/bower-traceur@0.0.93\",\n    \"traceur-runtime\": \"github:jmcriffey/bower-traceur-runtime@0.0.93\",\n    \"validator\": \"npm:validator@5.0.0\",\n    \"github:components/jqueryui@1.11.4\": {\n      \"jquery\": \"npm:jquery@2.2.1\"\n    },\n    \"github:jspm/nodelibs-assert@0.1.0\": {\n      \"assert\": \"npm:assert@1.3.0\"\n    },\n    \"github:jspm/nodelibs-path@0.1.0\": {\n      \"path-browserify\": \"npm:path-browserify@0.0.0\"\n    },\n    \"github:jspm/nodelibs-process@0.1.2\": {\n      \"process\": \"npm:process@0.11.2\"\n    },\n    \"github:jspm/nodelibs-util@0.1.0\": {\n      \"util\": \"npm:util@0.10.3\"\n    },\n    \"npm:assert@1.3.0\": {\n      \"util\": \"npm:util@0.10.3\"\n    },\n    \"npm:can-simple-dom@0.3.0\": {\n      \"micro-location\": \"npm:micro-location@0.1.5\",\n      \"simple-html-tokenizer\": \"npm:simple-html-tokenizer@0.2.1\"\n    },\n    \"npm:can@2.3.17\": {\n      \"can-simple-dom\": \"npm:can-simple-dom@0.3.0\",\n      \"jquery\": \"npm:jquery@2.2.1\",\n      \"path\": \"github:jspm/nodelibs-path@0.1.0\",\n      \"process\": \"github:jspm/nodelibs-process@0.1.2\"\n    },\n    \"npm:inherits@2.0.1\": {\n      \"util\": \"github:jspm/nodelibs-util@0.1.0\"\n    },\n    \"npm:jquerypp@2.0.1\": {\n      \"jquery\": \"npm:jquery@2.2.1\",\n      \"path\": \"github:jspm/nodelibs-path@0.1.0\"\n    },\n    \"npm:path-browserify@0.0.0\": {\n      \"process\": \"github:jspm/nodelibs-process@0.1.2\"\n    },\n    \"npm:process@0.11.2\": {\n      \"assert\": \"github:jspm/nodelibs-assert@0.1.0\"\n    },\n    \"npm:util@0.10.3\": {\n      \"inherits\": \"npm:inherits@2.0.1\",\n      \"process\": \"github:jspm/nodelibs-process@0.1.2\"\n    }\n  }\n});\n```\n. JSPM plays really nice with broccoli, and automatically updates config. I don't want to give up broccoli js to use steak tools, and because of the design of SystemJS, I think it will be easier to build a broccoli plugin with than StealJS. JSPM just fits so nicely with Broccoli\nSent from my iPhone\n\nOn Feb 26, 2016, at 8:29 PM, Justin Meyer notifications@github.com wrote:\nAh, I guess I should say it only works with StealJS then. JSPM doesn't support a @loader which is necessary if you want to have multiple loader objects operating at once. You cant rely on the System being global.\nWhy are you using jspm instead of Steal? They are similar except that Steal will work out of the box with CanJS perfectly.\n\u2014\nReply to this email directly or view it on GitHub.\n. > I'm not sure we can identify those scenarios. What case is this happening? The only thing I can think of is with a component that is trying to export to a property on a plain JS object that happens to be a can.Map or a can.List.\n\nI think the default behavior of _setAttr to recycle can.Map's is what's problematic, as it has the potential to introduce side-effects. Setting nested objects results in merging nested maps rather than creating new ones, which quickly becomes problematic, as demonstrated here. \nRight now I'm using can.Model.parseModel to simply avoid the only major use case in which I've had this occur: CRUD callbacks w/ deeply nested properties. If setting the value of a can.Map property were to always utilize define/Type rather than merging though, we could combine that with better support for can.Model.model + define/Type/type, and that would make can.Model.store always work out of the box. That sort of simplification is what we need to make the library more accessible to new developers.\n\nI should point out that this merge ability is there for can-value in situations like this one: https://github.com/canjs/canjs/blob/master/view/bindings/bindings_test.js#L669\n\nThis is an excellent case for merging. I actually really do like merging whenever possible. It's only problematic when this behavior is unintentional and has the potential to inadvertently introduce side-effects.\nThe childToParent binding should probably just always be a vanilla compute. Merging props onto the existing map creates massive side-effecting, assuming we addressed serialization. For instance, imagine the potential ill-fated consequences of binding a model to the root viewModel: changing the value would affect other references of the previous model; something like a sub doc/ foreign doc could be inadvertently overridden.\n. > But that's not always the case as indicated in the above test.\nIn the case of multi-select, it would be safe to cross-bind the can.List itself, and then to replace members. The only way in which I see this going very wrong is if we didn't respect the can.List reference. I don't really see that occurring with multi-select, but conceivably elsewhere it would be problematic to have a childToParent binding replace the previous List's members rather than replace the list itself. It would also create an inconsistency in events: there wouldn't be a \"{viewModel} myList\" event, which suddenly means components would behave differently depending on how the value's are bound.\nThink about that for a second. \"{viewModel} myList\" would trigger w/ 2-way bindings, parent-child bindings, but not child-parent bindings. That's breaking behavior IMO.\n\nWhat would this look like?\n\n<find-one {^sidebar}=\"*sidebar\" {_id}=\"{*router.sidebar}\"></find-one>\n<find-one {^widget}=\"*widget\" {_id}=\"{*router.widget}\"></find-one>\n- Sidebar.widgets = [A, B]\n- Update widget A & save sidebar\n- Browse to widget B\n- Sidebar.widgets = [B, B]\n- Update widget B & save sidebar\nBrowsing to widget B inadvertently overrides A, which is referenced within in sidebar. Voila! Side effects with terrifying consequences that can easily be missed by the developer, QA as well as automated testing. Most likely, testing stops after successfully saving the sidebar.\nThere are a lot of ways this can go bad fast.\n. > can/view used for loading is really deprecated in favor of .  should normalize based off the moduleName of the current file. Normalizing of the baseURL is less than ideal in a package (npm) workflow.\nAlmost, but not quite: not normalizing the URL affects the ID lookup, which is necessary for both sub templates and for loading cached templates. The can/view/stache/system plugin should ideally pre-load templates and include sub-templates as dependencies, possibly bundled.\n\nWe are removing the jQuery/Mootools/YUI/Zepto compatibility layer from CanJS 3.0.\n\nStandardize on jQuery?\n\nIn the same vein, I've been considering removing  from CanJS 3.0 and having them be 2nd or 3rd party modules. can.view is very likely going to be removed as well.\n\ncan-import seems like a necessary evil, considering it's not viable to map component names to dependencies. That would also be difficult from a dependency tree perspective: the template translator would need account for can-import being externally required after the fact, which is unnecessarily painful.\n\ncan.view is very likely going to be removed as well.\n\nMakes sense. I was wondering when synchronous template loading was going to be deprecated. Pulling that bandaid out and forcing templates as a dependency simplifies a lot. \n. > (That won't solve the problem with optimized builds and grouping dependencies and inlined templates though. That bit requires a separate loader plugin...)\nI actually rolling w/ a custom can/view/stache/system plugin that does this. I'll try to get this integrated soon, but first need to sort out of all of areas in which SystemJS is semi-incompatible.\n\n should normalize based off the moduleName of the current file. Normalizing of the baseURL is less than ideal in a package (npm) workflow.\n\nI hadn't actually addressed the issue of normalization against a parentModule, which can't really be solved without abandoning can.view in favor of utilizing a module loader. We would need to use a normalized path that's relative to the baseURL for ID's, as well as use normalizeSync to expand the URL w/ path mapping. That gives us best of both worlds, as sub template lookup would grab from cache, and hit pre-loaded templates.\nAs a stop gap measure, we can include sub-templates as dependencies and pre-load them w/ ID's tokenized from the path mapped w/in System/Steal/RequireJS & relative to baseURL. At least that way we avoid needing can.view to do module loader things, which wouldn't be viable until 3.0\n{{>my-component/views/index.stache}}\nThis should result in:\nID: my-component_views_index_stache\nURL: http://www.example.com/assets/packages/my-project@0.0.1/dist/cjs/my-component/views/index.stache\n. I have noticed this as well, and I did appreciate using null as a placeholder back in the day. @justinbmeyer thoughts on letting null bypass type conversion?\nYou have a couple of options here. The type converter gives you more fine grain control, as you can pass in a function and do your Type conversion there. \nThe best solution for you at the moment is to use parseModels to clean up your data. This is a good place to do the respective can.Model.model calls as well, as otherwise nested data is merged, and it creates headaches. It's not adequate to manually hookup can.Model.model within the type setter, nor is can.Model.model compatible with Type.\n. You sir are a saint. That is all. \n:+1: \n. That was fast. \ud83d\udc4d \n. Any reason not to use items.__listSet = projectId: this.id};? The set is optional?. This should really have it's own API. It would be really powerful to be able to take the serialized state of a component's viewModel, and update the list set accordingly within a getter or a stream, such that the end behavior allows you to have a UI that's decorated with search filters / sorting that can handle more complex real-time filters. Here's an example of the behavior above using 2.3.x:\n```javascript\nvar template = require('./youtube-listing.stache!'),\n  connection = require('./channel').connection,\n  Channel = require('./channel').Channel,\n  config = require('config'),\n  can = require('can'),\n  Q = require('q');\nrequire('can/map/define/');\nrequire('can-derive/list/');\nrequire('can/list/sort/');\nvar key = config.youtube.key;\nfunction setOrRemove( val, setVal ) {\n  setVal(val || undefined);\n}\nvar ViewModel = can.Map.extend({}, {\n  define: {\n    channels: {\n      get: function() {\n        var filterParams = this.attr('filterParams'),\n          cache = this.attr('cache');\n    return cache.dFilter(function( channel ) {\n      var params = filterParams.attr();\n\n      if (channel.viewCount < params.minViews) {\n        return false;\n      }\n\n      if (channel.viewCount > params.maxViews) {\n        return false;\n      }\n\n      if (channel.subscriberCount < params.minSubscribers) {\n        return false;\n      }\n\n      if (channel.subscriberCount > params.maxSubscribers) {\n        return false;\n      }\n\n      if (channel.attr('dailyViewCount') < params.minDailyViews) {\n        return false;\n      }\n\n      if (channel.attr('dailyViewCount') > params.maxDailyViews) {\n        return false;\n      }\n\n      if (channel.attr('dailySubscriberCount') < params.minDailySubscribers) {\n        return false;\n      }\n\n      if (channel.attr('dailySubscriberCount') > params.maxDailySubscribers) {\n        return false;\n      }\n\n      return true;\n    });\n  }\n},\nfilterParams: {\n  value: Object,\n  get: function( map ) {\n    var params = {}\n\n    var keys = [\n      'minDailySubscribers',\n      'maxDailySubscribers',\n      'minSubscribers',\n      'maxSubscribers',\n      'minDailyViews',\n      'maxDailyViews',\n      'minViews',\n      'maxViews'\n    ];\n\n    while (keys.length) {\n      var key = keys.shift(),\n        val = this.attr(key);\n\n      if (val) {\n        params[key] = val;\n      }\n    }\n\n    map.attr(params, true);\n\n    return map;\n  }\n},\nqueryParams: {\n  serialize: false,\n  value: Object\n},\ncache: {\n  serialize: false,\n  value: Array,\n  Type: Channel.List\n},\ncategory: {\n  type: 'string',\n  set: setOrRemove\n},\nregionCode: {\n  value: 'US',\n  type: 'string',\n  set: setOrRemove\n},\nq: {\n  type: 'string',\n  set: setOrRemove\n},\nminSubscribers: {\n  serialize: false,\n  type: 'number',\n  set: setOrRemove\n},\nmaxSubscribers: {\n  serialize: false,\n  type: 'number',\n  set: setOrRemove\n},\nminViews: {\n  serialize: false,\n  type: 'number',\n  set: setOrRemove\n},\nmaxViews: {\n  serialize: false,\n  type: 'number',\n  set: setOrRemove\n},\nminDailySubscribers: {\n  serialize: false,\n  type: 'number',\n  set: setOrRemove\n},\nmaxDailySubscribers: {\n  serialize: false,\n  type: 'number',\n  set: setOrRemove\n},\nminDailyViews: {\n  serialize: false,\n  type: 'number',\n  set: setOrRemove\n},\nmaxDailyViews: {\n  serialize: false,\n  type: 'number',\n  set: setOrRemove\n},\nsortBy: {\n  type: 'string'\n}\n\n},\n  search: function( ev ) {\n    if (ev) {\n      ev.preventDefault();\n    }\nthis.queryParams.attr(this.serialize(), true);\n\n}\n});\ncan.Component.extend({\n  tag: 'youtube-listing',\n  template: template,\n  viewModel: ViewModel,\n  events: {\n    init: function() {\n      this.scope.attr('sortBy', 'dailyViewCount');\n    },\n    '{scope} sortBy': function( scope, ev, sortBy ) {\n      var list = new Channel.List(),\n        cache = scope.attr('cache');\n  list.attr('comparator', function( a, b ) {\n    var aVal = a.attr(sortBy),\n      bVal = b.attr(sortBy);\n\n    if (typeof aVal === 'string' && typeof bVal === 'string' &&\n        ''.localeCompare) {\n      return aVal.localeCompare(bVal);\n    }\n\n    return (aVal === bVal) ? 0 : (aVal < bVal) ? 1 : -1;\n  });\n\n  cache.forEach(function( channel ) {\n    list.push(channel);\n  });\n\n  scope.attr('cache', list);\n},\n'{queryParams} change': function( queryParams, ev ) {\n  var scope = this.scope,\n    cache = scope.cache;\n\n  cache.replace([]);\n\n  function populateChannels( channels ) {\n    return Q(can.ajax({\n      url: 'https://www.googleapis.com/youtube/v3/channels',\n      type: 'GET',\n      dateType: 'json',\n      data: {\n        key: key,\n        part: 'id, snippet, statistics',\n        id: channels.map(function( channel ) { return channel._id }).join(),\n        maxResults: 50\n      }\n    })).then(function( data ) {\n      return data.items.map(function( data ) {\n        return {\n          _id: data.id,\n          name: data.snippet.title,\n          description: data.snippet.description,\n          uri: 'https://www.youtube.com/channel/' + data.id,\n          viewCount: data.statistics.viewCount,\n          subscriberCount: data.statistics.subscriberCount,\n          publishedAt: data.snippet.publishedAt,\n          country: data.snippet.country || ''\n        };\n      });\n    });\n  };\n\n  function hydrateList( channels ) {\n    if (channels.length) {\n      return connection.createInstance(channels.pop()).then(function( channel ) {\n        connection.addInstanceReference(channel);\n\n        if (!~cache.indexOf(channel)) {\n          cache.push(channel);\n        }\n\n        return hydrateList(channels);\n      });\n    }\n  }\n\n  var queue = [];\n\n  function getListData( params ) {\n    return Q(can.ajax({\n      url: 'https://www.googleapis.com/youtube/v3/search',\n      type: 'GET',\n      dateType: 'json',\n      data: can.extend(params, {\n        key: key,\n        part: 'id',\n        type: 'channel',\n        maxResults: 50\n      })\n    })).then(function( data ) {\n\n      var channels = [];\n\n      for (var i = 0; i < data.items.length; i++) {\n        channels.push({\n          _id: data.items[i].id.channelId\n        });\n      }\n\n      queue.push(populateChannels(channels).then(hydrateList));\n\n      if (data.nextPageToken && data.items.length) {\n        return getListData(can.extend(params, { pageToken: data.nextPageToken }));\n      } else {\n        return Promise.all(queue);\n      }\n    });\n  }\n\n  getListData(queryParams.attr()).then(function() {\n    cache.forEach(function( channel ) {\n      connection.removeInstanceReference(channel);\n    });\n  });\n}\n\n}\n});\n```\n. Sure. ",
    "gsmeets": "I think this feature is a bad idea as well. This feature promotes using model / controller type functionalities (data retrieval) into your view. It just promotes bad architecture. \n\nYou can not easily accomplish a deferred's entire pending/resolved/rejected/value/reason state with the define plugin. \nI've tried it, it's very difficult.\n\nI agree with you there. I have a fairly complex control flow in one of my viewmodels with 6 deferreds with some interdependencies, and the code is pretty ugly and complex right now. Still looking for ways to reduce complexity. For the time being I've chosen to delay rendering until the deferreds are all resolved.\nThe proposed implementation doesn't seem like a proper solution though.\n. There are reasons why I've chosen for canjs instead of angular to base our company's new main product frontend architecture on. ;) I'm not opposing to having some way to be able to automatically update promises. As a matter of fact, I'm already doing something like that, but it's a bit annoying for single model instances. Lists are working nicely ofcourse, because add events are easy to handle out of the box.\nWhat I'm doing right now is basically this:\n``` js\nvar foo = new Foo();\nFoo.findOne({ id: 42 })\n    .done(function( model ) {\n        foo.attr( model.serialize());\n    });\ncan.view( VIEW, data, function ( fragment ) {\n  this.element.append( fragment );\n});\n```\nAn elegant way to handle this would be to add a counterpart to findOne that updates a given model with data from the server, i.e.: \njs\nvar foo = new Foo({id: 42});\nfoo.synch(); // synch would perform a findOne, and update foo with the data, instead of returning a new Foo instance.\n. > Consider what would happen if two instances of a model with the same id was desired?\n\n[..]\nThis is why promise support is the most elegant and simple (less APIs to add) way of handling this situation.\n\nOne of the confusing things about the define plugin is that this is exactly what happens if you were to add a Type and a setter function.\nIdeally what I want is to be able to pass an ID to my viewmodel, which in turn expands that into a full model by fetching it from the server. I'm currently refactoring a bit to make this possible. But the weird thing is I need to drop my explicit type definitions to get this to work. Otherwise the Type converter will have already converted my single id into a can.Map before I'm able to touch it in the setter function.\n. I think I can work around the issues I'm having with it. It's just that some things work in a bit of an unintuitive way. But maybe that's just my strongly typed past shining through. ;)\n. That community member would be me. ;)\nI have that stache amd plugin loader working in my private repo. The public repo is a bit outdated (https://github.com/Empirion/can-stache-amd) \nI've been murderously busy at work past 6 months, so I haven't even had the time to get that updated and documented. (So maybe you should reconsider my offer @rjgotten :P) If there's definite interest from someone then drop me a line. If not, updating that repository is still on my todo list somewhere in the next few weeks.\n. If this gets bumped to 2.1.4 I'm willing to participate. ;) This feature is also high on my wishlist. And I have it rather sooner than later.\n. Ofcourse, semver. ;) I'll see if I can make some headway this week on this feature. I don't see any active relevant branches by @matthewp regarding this matter? Is there anything I can branch off, or should I start from scratch?\n. I haven't had the time to look into it after matthewp pointed me to his branch. I've changed a few things around on my end to where I don't need this feature for now.\n. This is for me the most problematic behaviour when writing templates. Getting this fixed is important. I see it's been bumped a few times to future milestones. Can we get this fixed in 2.3? Do you need help with it?\n. I'll give it a go. I do run on 2.1.4 still though, so I'm hoping I don't have much patching to do.\n. ah, this might explain why I am having my last item rendered twice in a select list. \n. You could just make the serialize function depend on another property on the same map. I don't see how this has to be something that canjs has to support natively. \n. Hmm, seems like I'm running into some more of these issues. I'll add those to this pull request once I've fixed them..\n. I've added another can import for view/stache/stache.js. Now I got stache precompiled templates running on node. I've imported can/util/library.js for lack of a better candidate. Doesn't seem to matter that much, as long as there's some prototype to extend that will be picked up later by other components. \n. To clarify, for can/view/parser I just added a parameter name for the already imported can/view. For can/view/stache/stache I added can/util/library as a reference. Both imports are named can locally.\n(p.s. Travis reports failed builds. Is that due to my changes? Seems unlikely to me.)\n. foo.bar has a value (say 1), but the selected value in the dropdown is the first (0 in this case). When I use the manually written options the selected value is 1.\n. Ah, I seem to have located the cause of my issue. (Murphy at work again ofcourse right after debugging something for a few hrs ;)):\nfoo is actually part of a model that is fed into my view like this:\ncan.view( VIEW, me.model, function ( fragment ) {\n    me.element.append( fragment );\n});\nme.model is a can.Map holding two can.Model's which are fetched asynchronously:\nFoo\n    .findOne({ id: X })\n    .done( function ( foo ) { \n        me.model.attr( \"foo\", foo );\n    });\nI reckon I'm live-bound to a different instance of foo now, because I'm replacing it wholesale?\n. The problem indeed goes away when I set my bars and bar properties individually instead of adding the model as a whole. (In fact, I get away with explicitly setting foo.bars, and then foo itself. It's seems to be an ordering issue.)\nThe converters not being hit does seem to be a problem that could do with fixing though? Should I add a new issue for that?\n. Ah, I've found the root cause for the converter not being hit. can.Map.define is defined on the prototype, not on the static level, as can.Observe.attributes was.\nMaybe a clarification in the docs is in order? I'll close this one now.\n. can.view.mustache is actually used in f.x. can/component: \nhttps://github.com/bitovi/canjs/blob/master/component/component.js#L79\nI had to change this in my local build to run on stache instead of mustache.\n. What's the status on this feature? Is anyone working on it?\n. I still think validation is a model concern, not a view concern. That's something just about every framework out there does \"wrong\" as far as I'm concerned.\n. I've worked around this using components now in a non-livebound fashion. i.e. I trigger validation manually on change, and I force a validation of pre-set (and possibly invalid) data on submit again using a broadcast to all said components. From then on out the components (and the submit button that triggered it) remain in an invalid state until all errors are resolved.\nI'm wondering if folding all of that into full observable behaviour isn't going to increase the complexity all over. I'm quite happy with the terseness of my views at the moment.\n. That is indeed the solution. And thinking of the {{#}} helper now, it makes sense why it won't work. This is something that should probably end up in the documentation I reckon.\n. How was this fixed? I am running into the exact same issue after upgrading to 4.1.3, except that I'm using requirejs to preload my templates.\n. Use the define get methode instead of just properties on the prototype.\n. I don't think this is a bug. The normal\" prototype properties are there for simple observables, computed properties like the one you're building should be done with the define plugin.\n. You're stating that can now parses the templates correctly in the related stealjs issue. \nI'd love include those parsed templates in my amd build layers, as opposed to simply wrapping them in can.stache() calls. Is this now possible? I've been toying around with it a bit, but I haven't got it working yet. The rendering parts of can are fairly complex to get a full understanding of how they work.\n. Any news on the slower performance that this gives? We've discussed this once on gitter...\n. I ran some tests in the past, and intermediate compiled templates actually performed worse at runtime than on the fly compiliation of stache templates.\nThere's some other issue floating about where @rjgotten made some remarks about this as well.)\n. I was indeed referring to that variable. And converting dates and datetimes separately is precisely one of my use cases I want to handle. \n\nSo, I'm a bit wary of mixin behavior like this in general. Are you using some type of module system? \n\nI'm using AMD, and what you describe is precisely what I'm doing right now. But I think it's much more cleaner and clearer for our developers when the primitive-like types are all handled the same way. It's a bit quirky and cumbersome to have to import some extra file for something we already have infrastructure in place. One of the biggest downsides with canjs is that it tends to grow too many ways to solve the same issue, I'm trying to cut back on that everywhere I can. \nWriting this, I'm thinking adding something similar for serializers might also be a good idea. That way you can have predefined serializers in an analogous way.\n. Well, that would leave you still having to handle Date correctly in the least, unless you're thinking of leaving that as an exercise to the developer as well. I don't think it's incorrect to have some convenient way of registering reusable converters for those few primitive types. Most of the stuff is tucked neatly away in models anyway.\n. In the end I've decided to roll with justin's proposed solution, sort of. I'm bundling up the entire defines (generally, when I want type string, I want to have null converted to \"\", etc..).\nTo lessen the burden I'll alias the specific path to the defines in my requirejs config to something convenient.\nSo I wind up with this:\ndefines.js\n``` js\ndefine([\n], function () {\n    return {\n    \"string\" : {\n        type : \"string\",\n        set : function ( newValue ) {\n            if ( newValue === null ) {\n                return \"\";\n            }\n        }\n    }\n};\n\n});\n```\nsomemodel.js\n``` js\ndefine([\n    \"plug!can\",\n    \"defines\"\n], function ( can, defines ) {\n\"use strict\";\n\nreturn can.Model.extend(\n\n    /* @static */\n    {\n    },\n\n    /* @prototype */\n    {\n        define: {\n            id               : { type: \"number\" },\n            someProp : defines.string\n        }\n    }\n);\n\n});\n```\n. With regards to #646 I don't think \"link\" would be a good name. That's already used in the context anchor tags and link tags.\n. Do you have some example code somewhere? I'm new to FRP in javascript, so a few examples would help out.\n. How easy is it to generate relative paths in the AMD builds with the new steal tools? It doesn't have to be the default, but I'd much rather use relative paths in my application, I don't mind building it by hand if I have to.\n. For some reason I can't seem to get my r.js compiler to work nicely with code that uses paths. I'm not 100% sure what causes it, but making the canjs paths relative solved my issues when I set it up initially a while ago. \nOther than that it's also helpful when you're writing extensions on the framework and are doing path remappings from can's code to your own for stuff that just doesn't add to the framework.\nThere's an issue floating about here somewhere with some more background on why relative paths are a good idea. (edit, found it: https://github.com/bitovi/canjs/issues/338)\n. That's pretty dependent on your environment settings. I wouldn't shorten it on systems that need to be built and run across different platforms and whatnot.\n. > Yes, npm adds local executables to $PATH.\nOn windows, only if you actually choose it to do that.\n\nFrom what I know, it's an undocumented feature.\n\nAnd that's all the reason not to try this. I don't see a point in using an undocumented feature to shorten a line somewhere in a script that hardly anyone looks at but will bite a few people in the backside in the future.\n. Something that's bugging me that I want to fix:\n- proper support for stache templates. Main nuisance is the following being \"autocorrected\" to something that doesn't parse:\nhtml\n    <input {{#if foo}}disabled='disabled'{{/}} />\nStuff that I would like to add that would be nice to have:\n- can.Model scaffolding from web api controllers + accompanying models\n- intellisense for can.Components.\n. > I've done some testing, and it only happens when I use can.view(). \n\nIf I manually render a template with can.stache() everything runs as expected.\n\nI've been testing some more, and what I quoted here wasn't correct in the first place. I'm also getting this if I call stache directly.\nI'm trying to reduce it to a workable test case, but something's eluding me which makes it not reproducible outside my code. I'll be doing some more digging tonight, this might just be an issue on my end. :/\nCan you confirm that setting classes on the component's element is a valid use case? That it should be working under normal circumstances.\n. It might be an issue that's solved between 2.1.0 (which I'm running) and 2.1.2. Once I switch off my amd and load canjs 2.1.2 from your cdn synchronously the problem is gone. \nI'll first try upgrading canjs to 2.1.2 and see if that solves my problem. \n\nYes, upgrading solved it. \n. The master branch indeed. I suspect there is probably some grunt task defined that I could run?\nI've solved my immediate issue in another way now, but I'd like to be able to make proper builds myself for internal use. Especially if I run into the scenario where I need to patch some issue fast that might not find its way back immediately to the master branch.\n. apparently I double posted this.\n. I've also investigated this at some point. There's no \"inheritance\" implemented for components as far as I can tell. I'm not sure if this was done by design. It would be a nice feature though, I agree on that wholeheartedly.\n. dangit, now I'll have to refactor all my #eq's to #is's. ;)\n. Good job! And thanks for the alias. That saves me some work.\n. direction is the more commonly used term as far as I know.\nModels might have an order property, which can be sorted in ascending or descending direction.\n. This seems to leak even if I use a wrapping element:\n```\n\n\n\n\n    var template = can.stache( \"<p>{{test}}</p>\" );\n    var foo = false;\n\n    $( document ).click( function() {\n        if ( foo ) {\n            $( \"div\" ).remove();\n        } else {\n            var fragment = template({ test: \"test2\" });\n            $( \"div\" ).append( fragment );\n            foo = true;\n        }\n    });\n\n\n```\nUsing the 3 snapshot technique:\n- First snapshot after load. \n- Click the screen,\n- Snapshot\n- Click the screen\n- Snapshot\n- Select snapshot 3, instances that were created between 1 & 2.\n\nIf I change can.stache into can.mustache and repeat the procedure I don't get those dom nodes floating about.\n. There's one div in the page. After the first click it appends the template to the div, the next click the div is removed.  It's definitely appended to the page.\n. Yes, but I only click twice you know ;) I think I can probably dumb the example down more, hang on.\n. Yes, even this poses a problem:\n```\nvar template = can.stache( \"{{test}}\" );\nvar fragment = template({ test: \"test2\" });\n$( \"div\" )\n    .append( fragment )\n    .remove();\n```\n\n. On second viewing, scratch that though, that's actually jQuery causing it. So I do need the 3 snapshot method to be sure it's the executed code that causes the leak.\n\nOkay, the \"leak\" in my scenario here is caused by the reference to the template variable which was on the global scope.\nI still do think I have some mem leaks in my full project, but I guess I'll have to investigate that further myself.\n\nupdate: I've found the culprit, opening a new issue, as it's not related.\n. I've implemented an AMD loader plugin for my stache files, because I run with requirejs instead of stealjs. I've just updated the plugin to support to support the can-import tag. Partials are automatically resolved by canjs itself already when running without combining files into build layers.\nFor the generation of build layers I've added some code that adds imports and partials as dependencies of the stache file that requires them. For the imports I used can/view/intermediate_and_imports, for the partials I just parse the templates for the {{>}} tag. \nCan't you do the same in this case? Seems a lot of added syntax for something that doesn't do a whole lot.\n(Second question: are you interested in adding the AMD loader plugin to the canjs codebase? Otherwise I'll throw up my own github repo with it.)\n. There's a few things. My root elements are still controllers, because I don't think you can instantiate components from code. (If someone can prove me wrong here would be nice, still looking for a way to get rid of some semi-superfluous controllers).\nOther things that come to mind is when you render html server-side and you're just adding some behaviour over the existing dom nodes.\n. Those tests won't work. The dom nodes are detached, so they're not reachable from code. That means they're not available through the can.view.nodeLists. \nI've done some more testing, and it seems I'm getting 1 leaking document fragment per component that has a content tag. And all the contents in it leaks as well. \nDoesn't matter if I instantiate them once of a million times. Luckily that means the problem is less severe than I thought. :)\n. I have the same issue. I'm pulling some data from the server for some sort of logging timeline, and it generates 7K cid's (compared to 2.5K from the rest of the page) while it doesn't have to be live at all. Was wondering the same thing as whitecolor.\n. But at that point I still don't know I accessed foo.items\n. Validation. \nJust prior to submitting the form the entire root model is recursively validated. Individual components are bound to submodels. What I'm currently doing is re-evaluating every component individually as well, if I detected some error, but that's not that clean of a solution.\n. I have a component of the form:\n<text-editor binding=\"{someModel.prop}\" />\nThis component includes a label, a text input and an error message if the bound property is in an invalid state.\nRight now I check at a top level if some part of my model is in a state of error, if that's the case I message all the child components to re-evaluate if they're in an error state. At that point each component validates the bound property again against its local model. Effectively this is doing validation twice. That's why I was thinking along the lines I've posted in my initial post.\nIf you have some ideas on how to this in a better way I'm happy to hear it.\n. That won't work for my use case unfortunately. I have pretty highlevel components bound to some random part of the viewmodel. This allows me to have templates that non-programmers, heck even non-ux-designers can understand. That does put me in the position that the same binding is used for the validation.\nI'll just stick to what I've got now, validation isn't something that occurs a lot, so the extra perf hit is acceptable.\n. My guess is they deprecated that in Angular due to performance reasons.\nI really think this would be a bad idea if you want to do it just for the sake of stuff like looping over tables. There's not really a reason to instantiate a new scope for -every- item in a list. It's potentially a terrible performance killer.\nFor whitecolor's use case I'm wondering if a component actually is the correct choice to implement such behaviour. I would think more along the lines of helpers that instantiate an extra light-weight controller. \n. This seems to be doing some of the work that my can-stache-amd plugin does. Does this also work for amd based solutions?\n. That would be great. I just updated my build scenario to grab npm packages during build, instead of checking them into source control, so I'm tied to release packages at the moment. \n. I would like you to seriously consider officially supporting this, or support it in some other way. Repeatable templates is a very important feature.\n. This is extremely useful, it allows you to write components like drop-down menus that can be passed (required or optional) item templates.\n. I'll create a PR with a breaking test.\n. Sorry, been a bit busy. Right in the middle of crunch time. ;)\nThe problem is this:\nhttp://jsbin.com/fonipulufa/1/edit?js,console,output\nAt the bottom I pass in a custom compare function, but because of the specified comparator instead of getting the maps as parameters to my sort function, I'm getting the prices. \n. This could be a pretty big breaking change to be honest.\nI use serialize overwrites to ensure certain stuff doesn't get back to the server, doesn't mean I don't want the backup plugin to handle it though.\nIsn't this something you'd want to enable optionally?\n. I use a small grunt task that remaps the absolute canjs to the correct local absolute path, that's a workaround that works for me until 3.0. Drop me a line if you want it. ;)\n. Here are the relevant parts of my grunt config.\nBasically this pulls in canjs from the npm location into my local directory Scripts/lib, and then the text replace tasks just changes every path from \"can\" to \"lib/can\". It's dirty, but it works. I would've preferred just relative paths to begin with. ;)\n```\ngrunt.loadNpmTasks(\"grunt-contrib-copy\");\ngrunt.loadNpmTasks(\"grunt-text-replace\");\ngrunt.initConfig({\n    copy: {\n        can: {\n                expand: true,\n                cwd  : \"node_modules/can/dist/amd/\",\n                dest : \"Scripts/lib/\",\n                src  : [ \"\" ]\n            }\n    },\n    replace: {\n        can: {\n            src: \"Scripts/lib/can//*.js\",\n            overwrite: true,\n            replacements: [{\n                from: \"'can/\",\n                to: \"'lib/can/\"\n            }]\n        }\n    }\n});\ngrunt.registerTask( \"copypackages\", [ \"copy:can\", \"replace:can\" ]);\n```\n. Totally missed this one. Will have a look what this was about.\n. Did I miss that in the docs? Or is it undocumented?\n. Except that ^ already has semantics. ;) I think there's already an issue floating about where this was brought up...\n. @justinbmeyer is referring to #2278.\n. I don 't thinking that's supported. And that's a good thing. You shouldn't include scripts through the view, and you shouldn't write dynamically generated scripts.\n. I have it running with requirejs (can 2.X). Last time I tested precompilation though it was actually slower than parsing the string templates at runtime.\n. can't you circumnavigate the problem by passing in a can.Map with your unobserved data as a defined property on it?. Well, in my personal opinion always enforcing and having the developer assume that the root model is a can.Map is fairly intuitive. The whole idea of not having something observed on purpose is an advanced use case. But that's just my 2 cts.. @justinbmeyer what alternative do we have for %root in 3.0? . that's great for those of us that don't use can-route. :s. My root viewmodels are the viewmodels of dynamically inserted components. (It's an SPA with a tabbed interface). Since it's not a singleton viewmodel I don't think that'll work.. I think I'm better off passing in a custom marker myself for those cases. I'm already using a custom component to \"inherit\" from. I can fold in that functionality in there I think. \nIt's really quirky that you can't easily reference the component's viewmodel in whose stache template you're writing your code. Any property that you need to bind on it you need to initialize to null for it to be found during template binding. In most cases I circumnavigate this with binding stuff to submodels on my viewmodel, but you can't always do that, unless you create a bunch of extra models for no apparent reason.. yeah, I already found the line and have it hotfixed in my project. One thing I noticed that was a bit odd btw was that the event is part of those arguments. Didn't really expect that, as you can pass that in seperately if needed. (In fact, I would've expected the argument list to be flattened into whatever else you'd pass in, but I guess that can cause its own problems for people.). I've boiled it down to these lines:\nhttps://github.com/canjs/canjs/blob/2.3-legacy/component/component.js#L374-L380\nWould it be so simple as to change line 375 into this?\nif(typeof value === \"string\" || typeof value === \"number\") {. small update: I have some tests written to cover the change, but I ran into some issues with getting canjs working on windows. One I solved by upgrading zombie to the latest version. Now all that remains is that my production.css and production.js are missing when I try to run the test files in isolation. (I think I should probably be running the tests through zombie, not from local fs. Did I miss some docs about contributing that cover this? I'll try and get it up and running tonight.).\n",
    "bmomberger-reciprocity": "I actually agree with @gsmeets on this one.  In GGRC, we mostly abstract the use of deferred away from the view layer.  Even though we support a {{#defer}} helper that takes a deferred and renders when it resolves, it's rarely used. We prefer the more abstract {{#using}}, which syncs a stubbed object/list property of another object from the server, or {{#with_mapping}}, which refreshes a mapping (defined path through the object graph which yields a list) attached to an object.\nReally it seems to me that this is the problem that Bacon.js is at the ready to resolve.  All your deferred objects are really iterators on streams waiting for data.  Thus any deferred operation is really just a list iterator with a defined terminus.  The view layer should treat the deferred as an iterator. {{HasNext}} (or {{pending}}) is true until the deferred resolves, false after resolution. Errors on the deferred pass an error as the final iteration (there are likely no success case iterations that happen, in this scenario), which can be caught with a special section, e.g. {{onError}}.\nDid this make sense to anyone else?\n. For @rjgotten: https://github.com/reciprocity/ggrc-core/blob/1e2ce1150f84775ada6037181dab05cd9c0097c9/src/ggrc/assets/javascripts/mustache_helper.js#L2173\nAlso, just to :+1: everyone, these are all very good thoughts.  I feel like we may be trying to solve too large a vertical slice, though.  It should be broken down a bit, e.g.:\n- Composable observability with Deferred (computes observe promises, report state).\n- richer Define-based behavior using Deferred objects and their resolved/rejected values.\n- Pending state represented in (Mu)stache independently of truthy/falsy values, probably through a language extension (FTR I like {{~maybe_deferred}}...{{/maybe_deferred}} and {{#maybe_deferred}}...{{pending}}...{{/maybe_deferred}} to represent pending).\n. The spec doesn't seem to cover context nesting; it just says that a partial inherits the current context, but it also says the same for a section (which, in CanJS's Mustache, does inherit the stack).\n. Thanks.  That's helpful to know.\n. Citing the goal of Handlebars compatibility, I think it's just something that needs to be documented, perhaps with workaround examples (e.g. using subsections, or passing the path as string and using can.getObject with string parsing to find the function's parent object).  \nThe can.Mustache docs (donejs.com and canjs.us) have no mention of using functions in the Handlebars style; since I don't have prior expertise in Handlebars, I wasn't even aware that it was possible until my coworker showed me the issue.\n. Yes, if #234 is a duplicate of #157, then this one is as far as the placement of live bound elements.  I am not sure about the special character escaping/unescaping issues (part 7 of the fiddle plus \"non-observe\" parts 1 and 2).\n. With the 1.1.4-pre version of CanJS, the workaround of putting the full attribute name and value in the block no longer works.\nAlso note:  I made an update to the fiddle that references the release from canjs.us instead of using the sources from donejs.com.  http://jsfiddle.net/UHHvs/5/\n. That is indeed the issue I am seeing.  As far as I can tell, it's not a null-reference type of issue; it may be that we are causing CanJS to try to insert a text node in a parent while providing a positioning reference that is not a child of the parent.  I have not yet investigated it further than this.\n. With 1.1.4, using an {{#if}} block no longer throws errors, but also does not display text.  My comments in #241 seem to apply here as well.\nupdated fiddle for 1.1.4: http://jsfiddle.net/B8kWR/2/\n. https://github.com/wycats/handlebars.js/blob/master/spec/qunit_spec.js#L1019\n\"helpers take precedence over same-named context properties\"\n\"Scoped names [e.g. 'this.foo'] take precedence over helpers\"\n. Good call, then.\nIt seems to me that the obvious answer is to set the \"st4ck\" property on the array when you pass it to the partial.  A quick fiddling confirmed the basics work; i.e. if I pass a mustache ref and an array to can.view and set st4ck=true on the array, it's treated as a context stack.\nFor the benefit of helpers, it might be a good idea to pass the full context stack as well, and add something like can.view.isStack and can.view.makeStack to let helper writers work with the system without exposing the magic tokens.\n``` javascript\ncan.view.isStack = function(o) { return can.isArray(o) && !!o[STACK]; }\ncan.view.makeStack = function() { var a = can.makeArray(arguments); a[STACK] = true; return a }\n```\n. Note that for {{#with}} to be demonstrable, I also had to add a computed check in Mustache.get, since the context object might be a compute.  Anyway, tests are in for this change.\n. This is more in line with mustache.js's null_string and null_view specs.\n. It works if you make it a can.compute.\nhttp://jsfiddle.net/AUZmf/10/\nThis relates to the fix I made for #292.  I only considered computes and not other functions.  A non-compute function is treated as a static value when it's an argument to a helper, and function objects are truthy.\n. Calculation of aggregate heights/widths is my most common use case.  I'm doing a lot of dynamic positioning around jQuery-UI resizable, and I might for example need to be sure that the initial value of a div that gets sized alongside its parent is correct, meaning excluding the siblings' heights.\nvar recalculated_height = can.reduce(\n  $content.siblings()\n  , function(ht, sib) {\n    return ht - $(sib).height();\n }\n , $content.parent().height()\n);\n. More fun with can.reduce:\n``` javascript\n// as a string iterator\n[].map.call(\"foo\", function(a) { return a.charCodeAt(0); })\n\n\n[102, 111, 111]\ncan.map(\"foo\", function(a) { return a.charCodeAt(0); })\nTypeError: Cannot use 'in' operator to search for '2' in foo\ncan.reduce(\"foo\", function(b, a) { return b.concat(a.charCodeAt(0)); }, [])\n[102, 111, 111]\n```\n\n\n``` javascript\n// as any/all over an array\ncan.each([\"foo\", \"bar\", \"baz\"], function(a) { if(/b/.test(a)) return false; })\n\n\n[\"foo\", \"bar\", \"baz\"]  //Hmmm...\ncan.reduce([\"foo\", \"bar\", \"baz\"], function(b, a) { return b || /b/.test(a) }, false)\ntrue\n// also can be done with map/length/boolify\n!!can.map([\"foo\", \"bar\", \"baz\"], function(a) { if(/b/.test(a)) return true; }).length\ntrue\n```\n\n\n``` javascript\n// copy an object's own properties to a new object -- uses non-array-like object support I just added.\ncan.reduce(new can.Observe(), function(b, a, i, o) { o.hasOwnProperty(i) && (b[i] = a); return b; }, {})\n\n\nObject {data: Object, _cid: \".observe192\", jQuery19106896194147411734: Object}\n``\n. It's not quite the same as.reduce:memois not required andcontext` is not available; you would have to proxy your callback.\n\n\nSince the now-defunct can.reduce depends on can.each and can.makeArray, and u.each already exists, it should be fairly easy to port over if it's useful in Universal.js and u.makeArray also comes along for the ride.\n. Would it be useful to break out the Zepto and Dojo fixes to increase test coverage?\n. :+1: Closing.\n. As of the current version (2.0), incremental live lists work only with the #each directive, not with {{#property_name}} syntax.  Working example: http://jsfiddle.net/8LV4B/6/\n@justinbmeyer has expressed interest in making incremental list rendering also work with #property_name in future versions.\n. can.Map being so close to can.map is kind of stinky.  Then again, I don't like any alternative that I can think of (Dict, Set, Assoc, AList, Object, Props, Thing)\nI kind of like the reversion back to .extend -- though less terse, it's clearer what the code is doing.\nIs the only difference between can.observe and can.compute the fact that you're explicitly providing the setter in the latter case?\n. I still think there's value in it, especially since reciprocity/ggrc-core still has that use case for it.  I was interested in hearing whether anyone else would find it to be of value, though #311 shows that at very least the deep copy would be useful.  If we can come to a consensus on the line items @justinbmeyer raised, I'll put priority on fixing/tidying it up for release.\n. :+1: thanks for constructing the test.\n. It might be easier to go the other way and treat functions as objects first and then read their results.  However, for the sake of simplicity, can.computes should not be treated as functions.  The documentation should be exceedingly clear about this; i.e., \"A can.compute will always be Scope-read as its resolved value, never treated as a function object.\"\nIn this model, the length property on a function should be a special case that is never used.\nAdditionally, if I want to ensure that I'm using the resolved value of a function, I'd like to be able to leverage Function.prototype.call, i.e.\nvar obj = { \n  foo : function() {\n    return { bar : \"baz\" };\n  }\n}\nobj.foo.bar = \"quux\";\n....\n{{! with obj as the context }}\n{{foo.bar}} {{! -> \"quux\" }}\n{{foo.call.bar}} {{! -> \"baz\" }}\nCan we also be sure that they're treated the same when passed as positional parameters versus hash parameters (the original purpose of this ticket)?  Thanks. :)\n. Definitely there is a bug around returning functions from helpers here, but you can use can.view.hook() to enable two-way binding as you like.  Here's your updated fiddle (and I fixed your helper too -- the 'value' property and the form element's value were mixed up): http://jsfiddle.net/air_hadoken/w4rdH/17/\n. There isn't; that was supposed to be the \"foo\" helper.\n. the second \"should be\" line is calling \"baz\" instead, which is reading from a different var.  there should be only one call to \"foo\" after obs.quux is updated.\n. You're about the farthest thing from an idiot I can fathom.  It wasn't called the first time, and I could have made that clearer.  Here: http://jsfiddle.net/air_hadoken/V8VvF/4/\n. this seems to be specific to \"constructor\" because it's equal to its own prototype.constructor.  A workaround is to give every can.Map a \"class\" property on init() that resolves to the constructor.\n. Right, but it also goes the other way.  Listening on SharedTodo gets called when Todo is updated in the scenario I described.  If I also derived Todo into LocalTodo and fired an update on that, it would fire the listener on SharedTodo.\n. Of historical note: in 2.0.x the deep merge bypasses can.map.attributes if the following two conditions happen: (a) the property was previously set with .attr(key, val) and then later set with .attr(obj); and (b) if the converter function returns a plain array instead of a can.List.  This is fixed in the lastest version (2.1.2) but untested on 2.1.x as a whole.\nFiddles for reference:\nhttp://jsfiddle.net/NEKDk/  CanJS 2.0.7 shows bug (this fiddle has a shim around .attr due to another bug)\nhttp://jsfiddle.net/NEKDk/1/  CanJS latest shows no bug\nhttp://jsfiddle.net/NEKDk/2/  Shows workaround to ensure issue does not happen in 2.0.7\n. I was surprised when I first found out that you couldn't resolve to just a property of the current scope with \"this.<some property>\".  Something that lets you look at the current scope only is a useful feature to have when you are doing recursive/tree-based rendering of objects with similar properties.  We currently use a helper for this.\n. Certainly possible.  The way location.hash works is weird, though, since you get back a #-prepended string when you read it, but you're not supposed to prepend with # when setting it according to http://www.w3schools.com/jsref/prop_loc_hash.asp (though browsers seem to tolerate hash-prepending). If users set the root wrong, it could end up with unexpected effects, possibly an infinite loop of location setting.\n. Some can/control/route tests are failing on PhantomJS/MooTools.  The test passes for MooTools in Chrome.  I've been investigating but I have to put it on the back burner for a while and get some work done.\n. I implemented reduce() as a can.util, but it was determined to be unnecessary for the util library.  You can probably adapt the code for can.List.prototype.  https://github.com/bitovi/canjs/pull/346 is the relevant PR\n. It is possible, but it will generate a TypeError if someone attempts to do an instanceof check against the nonexistent Clone class if the check happens before the first cloning creates the class.\n. Yes.  The merge strategy is \"theirs\", i.e. the foreign Clone object being merged in has priority when the value for a particular key has been changed on both sides.\nTo do anything else would require dirty checking on the original Map, which I didn't think was appropriate, especially since one Map object can have multiple Clones.\n. ...unless the Clone was listening to changes on the original Map.  Then it could be responsible for all dirty checks (on itself and on its source) over its lifecycle.\n. ",
    "matthewp": "It will be good to have a way to know when a template is \"done\", after all promises have been resolved.\n. I'm thinking of the server rendering use-case, would want something more generic.\n. Is the goal to 1) provide some today-compatible version of web components, 2) build on top of web components 3) build something that is functionally similar (and if so, to what extent; is it only that this would be custom tag elements?)?\n. FWIW x-tags (Mozilla's polyfill) uses animationstart as an alternative to mutation events.\n. Should be able to use the old mutation events to get you to IE9. Below that it's probably not practical. I would think it's possible to overload document.createElement and htmlelement.prototype.innerhtml but no one else does that so there's probably a good reason.\nThe killer feature of web components is the ability to add a tag to your markup and have it just work. In my opinion sacrificing that in order to support older browsers would be a mistake. I'm not sure what the gain is over can.Control if you have to add them through JS.\nAnother really cool thing about web components is HTML imports which allow you to add components through the link tag. I think there is opportunity here for someone to become the NPM of web components by acting as a repository/CDN for components.\n. Why put the event functions on an events property?\n. I agree with the getter and setter for compute/observe. I think it's a bit easier to grock the concept of each this way. You observe a value, or compute its value. Makes sense to me.\n. To me on signifies that I'm working with an EventEmitter type of object, and that's not really what an Observe is. on(\"change\", ... makes sense but does on(\"somePropertyName\", ... ? Not sure.\n. Wrong project?\n. There is no AMD plugin in this repo, that is correct. There is a plugin a community member created but I'm having trouble finding it right now.\ncan-import should definitely work with Requirejs, we detect if running inside an AMD loader and call the dynamic loader: https://github.com/canjs/canjs/blob/master/util/can.js#L198-L200  This logic is tested with requirejs.\n. > You need some intermediate logic to create a require that is local and relative to the generated module ID of the stache template that was loaded through the loader plugin.\nThat's true, relative is currently not working with AMD modules. The Steal plugin includes the current module id (that is the id of the stache module once compiled to js), so the AMD plugin could do the same. We'd need some way to pass your own require instead of using window.require though. Very opening to collaborating with requirejs users to make sure our APIs support such a plugin.\n. Cool idea!\n. @gsmeets I've been working on it in a separate project. If you'd like to help out that would definitely be appreciated. Do you have skype or anything so we can discuss? Email me matthew@bitovi.com\n. I think I'm probably the last person who was working on this. I ran into a roadblock with the method I was using to trigger an update (MutationObservers) was too slow in older browsers. The way forward is either to A) Make this method fast; see shadow or B) Start from scratch with a new method.\nWe could also punt on the feature and instead make it work with native shadow DOM or the shadow DOM polyfill.\n. No, not in 2.3 at least.\n. getters/setters won't work with can.Construct.  Construct works by copying properties and you can't copy getters/setters in this way (you're just copying the value produced from the getter). The way to fix this is to use Object.getOwnPropertyDescriptor to get the descriptor object and then to assign it to the new object with Object.defineProperty. I'm not sure how involved it would be to make this change.\n. I've added a failing test in case anyone wants to give it a shot.\n. This is great!\n. @justinbmeyer added an explanation.\n. Hey @justinbmeyer I took a look at this bug a little bit and the item does call nodeLists.register, although I'm not sure what that actually achieves as far as node removal.  The first item gets removed through live.html's makeAndPut function. Should both items be removed at that time?\n. Excellent, I wasn't aware can.view.tag could be used directly like this. Using jQuery plugins as an example is great. I've been either using minimal can.Component wrappers or just using helpers to initialize them but can.view.tag is much more appropriate. Excellent documentation.\n. @stevenvachon You can use either #each children or #children for arrays.\nAs for the issue, personally I would rather fix this issue in JavaScript rather than adding the complexity of paths to mustache.\n. Talked this over off-issue, I wasn't aware that ../ already exists so I withdraw my objection. @savinger\n. What is the goal here, why do you want to have components as attributes rather than tags?\n. Headless components makes sense, I'm not understanding the reason behind multiple though... can.view.attr is great for mixins and #1376 has a way to make a higher-level plugin for those.\n. I like suggestion here, essentially a component with no tag and no template, allow that to be passed into can.view.attr.  What do you think?\n. My take on these issues:\nScope\nWould it be possible to have scope be part of the element's prototype as well? document.registerElement and Object.observe are not necessarily going to land at the same time and it would be nice to be able to use document.createElement('slider') even if the Object.observe sugar isn't available.\nContent\nI don't think <content/> should be run through Mustache at all. Anything outside of a script tag should be left alone. But I do think you should be able to set content with .html(). This is how it would work if using the shadow dom api, so I think we should stick to that (it \"feels\" right to me as well).\nMustache\nHere I would expect modifying scope properties would rerender the template. What would be the argument against doing this? I'm not sure about detaching, I would guess it would become <my-parent></my-parent>.\n. Wanted to lay out a couple of options for dealing with conditional attributes. Here's a simple example of when you might want them:\n``` javascript\nvar bananas = {\n  name: 'bananas',\n  price: 0.49,\n  onSale: true\n};\nvar apples = {\n  name: 'apples',\n  price: 1.79,\n  onSale: false\n};\nvar items = new can.List([bananas, apples]);\n```\nNow let's say you wanted to give a special class for the items on sale. Here's how you would do that in Mustache today, and a couple of options for doing it with pure html.\nMustache\n``` mustache\n\n  {{#each items}}\n...\n{{/each}}\n\n```\nOption 1\nXSLT already solved this problem, although it never caught on. The benefit of doing it this way is that the templating \"language\" could be implemented purely in Components, which would make it easily extensible. To solve the conditional attribute problem you might do:\n``` html\n\n\n\n\n  <can-attribute name=\"class\" value=\"sale\"></can-attribute>\n\n</can-if>\n\n\n\n\n```\nIn this example can-attribute is applied to the nearest parent element (excluding the can-* elements). This is fairly clean and flexible but is also verbose.\nOption 2\nAnother possibility is to have a special type of attribute that acts as the conditional. I propose using ? for truthy and ! for falsey. So you could write the same example more succinctly:\n``` html\n\n\n...\n\n\n```\nThe value of the truthy/falsey attributes is a colon-separated attribute name/value pair that will be added if on-sale? is true.\nDo either of these options sound enticing?\n. Problem is it generates 2 inverse functions. Not sure what the correct way to fix this is. Should this be \"corrected\" just before it's handed off to the helper?\njavascript\n            {inverse: function(scope, options) {\n                    var ___v1ew = [];\n                    ___v1ew.push(\n                    \"<div>Not showing</div>\");\n                    return ___v1ew.join(\"\");\n                }}, \n            {inverse: function(scope, options) {\n                    var ___v1ew = [];\n                    ___v1ew.push(\n                    \"<div>Is showing</div>\");\n                    return ___v1ew.join(\"\");\n                }}\n. Minor branch is failing for me on a fresh clone.\n. Oops, should have went to minor, closing.\n. @isadovskiy Here's the contributing guide.\n. Fork.\n. @daffl modify one of the inputs and the click away (blur).\n. The problem is here. .read is only returning a value, not the other properties.\n. Working with contenteditables can be complex. Should the value just be the element's text nodes?\n. What does type do? Does it reject values not of that type or does it attempt to coerce the value to the correct type?\n. Updated the PR with a new function that checks if an element is contenteditable. The rules are that an element is editable if either:\n1. contenteditable = \"true\"\n2. contenteditable = \"\"\n3. The element's parentNode is either (1) or (2) AND contenteditable != \"false\".\n. I like it, can we figure out a way to do this and #816 as one signature though?\n. What if it were one of the existing signatures, but we added a function to the compute that could be used in this way. For example:\n``` javascript\nvar todos = can.compute(new Todo.List()).later(function(oldVal, setVal) {\n});\n```\nThat way any existing signature could be used async. (later might not be the right name).\n. I like idea. How would these methods have access to the component's scope? If the answer is this.scope, then that means scope has to be on the element itself.\n. Instead of putting methods in the Component definition I think it should be within a separate methods object like x-tags does:\njavascript\ncan.Component.extend({\n  tag: 'shopping-list',\n  scope: ShoppingListScope,\n  methods: {\n    add: function() {\n       // this is an HTMLElement\n    }\n  }\n});\nOr potentially (if supporting ES5 getters/setters is an option) just properties (or props:\n``` javascript\ncan.Component.extend({\n  tag: 'shopping-list',\n  scope: ShoppingListScope,\n  properties: {\n    add: function() { ... },\nnumberOfApples: {\n   get: function(){\n     var list = this.scope.attr('list');\n     return list.filter(function(item) {\n       return item.name === 'apple';\n     }).length;\n   }\n}\n\n}\n});\n``\n. Instead of putting methods in the Component definition I think it should be within a separatemethods` object like x-tags does:\njavascript\ncan.Component.extend({\n  tag: 'shopping-list',\n  scope: ShoppingListScope,\n  methods: {\n    add: function() {\n       // this is an HTMLElement\n    }\n  }\n});\nOr potentially (if supporting ES5 getters/setters is an option) just properties (or props:\n``` javascript\ncan.Component.extend({\n  tag: 'shopping-list',\n  scope: ShoppingListScope,\n  properties: {\n    add: function() { ... },\nnumberOfApples: {\n   get: function(){\n     var list = this.scope.attr('list');\n     return list.filter(function(item) {\n       return item.name === 'apple';\n     }).length;\n   }\n}\n\n}\n});\n``\n. Think this is the same as #730 \n. Think this is the same as #730 \n. The commit where the undefined check was added is fdd650c6df977. I agree that we should be doing a== nullcheck here instead.\n. The commit where the undefined check was added is fdd650c6df977. I agree that we should be doing a== null` check here instead.\n. Are you aware that you can return a function that receives the element?\njavascript\ncan.Mustache.registerHelper(\"myClassHelper\",function(){\n  return function(el){\n    $(el).addClass(\"whatever\");\n  }\n});\nDoes that not satisfy your needs?\n. Are you aware that you can return a function that receives the element?\njavascript\ncan.Mustache.registerHelper(\"myClassHelper\",function(){\n  return function(el){\n    $(el).addClass(\"whatever\");\n  }\n});\nDoes that not satisfy your needs?\n. Can you add a test? Also, target can some times be a valid time to push state so this needs to check for the value being _blank as well.\n. Can you add a test? Also, target can some times be a valid time to push state so this needs to check for the value being _blank as well.\n. My use case was I needed to have 2 lists: 1 from the server and 1 that is a copy of the first's previous state (I need the ability to rewind).  After reading your comment I realized I could just .replace the first list with the second and its isResolved would still be true. So closing the issue as user error.\n. My use case was I needed to have 2 lists: 1 from the server and 1 that is a copy of the first's previous state (I need the ability to rewind).  After reading your comment I realized I could just .replace the first list with the second and its isResolved would still be true. So closing the issue as user error.\n. Will this trigger events when animations start/end? Or does jQuery take care of that?\n. Will this trigger events when animations start/end? Or does jQuery take care of that?\n. Would be the same as is currently done with can/observe\n. Would be the same as is currently done with can/observe\n. Yeah, I just mean that we need to stub it until 3.0 since otherwise it would be breaking an API expectation.\n. Yeah, I just mean that we need to stub it until 3.0 since otherwise it would be breaking an API expectation.\n. You must have psychic powers because we are working on just such a thing currently.  Can itself likely won't be able to be ES6 until 3.0 since it would break for anyone using old-Steal currently.\n. You must have psychic powers because we are working on just such a thing currently.  Can itself likely won't be able to be ES6 until 3.0 since it would break for anyone using old-Steal currently.\n. I'm not sure, we're focused on the next minor release, 2.2 for now. You should attend the Hangout we're doing today about the new Steal: https://plus.google.com/events/cibp5qahp97uqjvva0fbcsa5ap0\nIt uses Systemjs (and transpile) so you can use AMD, CommonJS, Steal, or ES6 syntax. So even if CanJS is not using ES6 syntax, you can use it in your own code, or mix and match different formats; this is what I'm planning on doing going forward.\n. I'm not sure, we're focused on the next minor release, 2.2 for now. You should attend the Hangout we're doing today about the new Steal: https://plus.google.com/events/cibp5qahp97uqjvva0fbcsa5ap0\nIt uses Systemjs (and transpile) so you can use AMD, CommonJS, Steal, or ES6 syntax. So even if CanJS is not using ES6 syntax, you can use it in your own code, or mix and match different formats; this is what I'm planning on doing going forward.\n. You could do that, yes. Steal has a pluginify option that compiles everything to AMD and includes a shim that's even smaller than Almond (but perhaps less featureful, I'm not that familiar with Almond). If you use some advanced functionality of Steal like bundles you'll need to include Steal in production though. These are all great questions for the Hangout, by the way :)\n. You could do that, yes. Steal has a pluginify option that compiles everything to AMD and includes a shim that's even smaller than Almond (but perhaps less featureful, I'm not that familiar with Almond). If you use some advanced functionality of Steal like bundles you'll need to include Steal in production though. These are all great questions for the Hangout, by the way :)\n. I recently needed this. Are you thinking of some type of mustache/stache syntax for this?  It can't be done as a helper. \n. I recently needed this. Are you thinking of some type of mustache/stache syntax for this?  It can't be done as a helper. \n. I don't believe that <module> can take module names. There was a time when it was supposed to but I believe they changed it. Now it's just a better <script> tag (not in the global scope, for example).\nI think we need some custom for this. <can-import> maybe.\nI think you have to consider how this will be parsed.  If you have a template like this:\n``` js\n\n\n\n```\nWe have to make sure we import all of the imports before the rest of the template is parsed. Stache calls its callbacks when it parses (I believe, correct me if I'm wrong) and therefore the custom attribute custom-attr won't be initialized.\n. I don't believe that <module> can take module names. There was a time when it was supposed to but I believe they changed it. Now it's just a better <script> tag (not in the global scope, for example).\nI think we need some custom for this. <can-import> maybe.\nI think you have to consider how this will be parsed.  If you have a template like this:\n``` js\n\n\n\n```\nWe have to make sure we import all of the imports before the rest of the template is parsed. Stache calls its callbacks when it parses (I believe, correct me if I'm wrong) and therefore the custom attribute custom-attr won't be initialized.\n. You're probably thinking of <link rel=\"imports\" href=\"path/to/something.html\">.  We could support rel=module ourselves though. That's unlikely to ever be added to the spec.\njs\n<link rel=\"module\" name=\"can/view/bindings\">\nI kind of like that. Or if you think that's a bad idea a can.view.attr instead <link can-rel=\"module\" name=\"can/view/bindings\">.\n. You're probably thinking of <link rel=\"imports\" href=\"path/to/something.html\">.  We could support rel=module ourselves though. That's unlikely to ever be added to the spec.\njs\n<link rel=\"module\" name=\"can/view/bindings\">\nI kind of like that. Or if you think that's a bad idea a can.view.attr instead <link can-rel=\"module\" name=\"can/view/bindings\">.\n. Thanks for the link. Perhaps we should just go with a helper for now then.  Although it does give me some pause to use something that looks like a helper but is parsed out of the template, I can't think of a better way.\n. The custom element spec specifies that custom elements must contain a hyphen, so I think we should enforce that on our end.\n. The custom element spec specifies that custom elements must contain a hyphen, so I think we should enforce that on our end.\n. Did we decide on a name for the property?\n. Did we decide on a name for the property?\n. That's true, probably no reason to do it this way. One of our existing apps this was working in 2.0.4.\n. That's true, probably no reason to do it this way. One of our existing apps this was working in 2.0.4.\n. Tested and this doesn't break on a can.Map.\n. Tested and this doesn't break on a can.Map.\n. So, this exports everything except tag, scope and template, right? What about events, helpers?\n. So, this exports everything except tag, scope and template, right? What about events, helpers?\n. Do the exported functions have access to the scope object in this implementation?\n. Do the exported functions have access to the scope object in this implementation?\n. I think can-href is the correct attribute name. If we wind up creating a can-route component it would be confusing to have a can-route attribute that is for something completely different.\n. I think can-href is the correct attribute name. If we wind up creating a can-route component it would be confusing to have a can-route attribute that is for something completely different.\n. Think you converted tabs to spaces.\n. Think you converted tabs to spaces.\n. Looks good to me :+1: \n. Looks good to me :+1: \n. So, is this because the SVG spec is strict about attribute values? if so I don't think this is really fixable. Perhaps it should be documented though.\n. So, is this because the SVG spec is strict about attribute values? if so I don't think this is really fixable. Perhaps it should be documented though.\n. I don't think this is worth trying to fix.  Instead we should add the ~ extension to Steal. I have it mostly working here: https://github.com/bitovi/steal/tree/tilde\nIn 3.0 we can deprecate this.\n. I don't think this is worth trying to fix.  Instead we should add the ~ extension to Steal. I have it mostly working here: https://github.com/bitovi/steal/tree/tilde\nIn 3.0 we can deprecate this.\n. I take it back, this shouldn't be hard to fix, getRenderer already returns a deferred.\n. I take it back, this shouldn't be hard to fix, getRenderer already returns a deferred.\n. This is fixed now.\n. This is fixed now.\n. Thanks for reporting!  This is a duplicate of #1134 so I'm closing.\n. Thanks for reporting!  This is a duplicate of #1134 so I'm closing.\n. We want this to work in Dojo and YUI though, right?\n. I feel like there was a reason why we left this off initially. Do you remember this @moschel ? I think you fixed a bug related to this a few months ago and it was undecided whether this should be dependent or not.\n. @justinbmeyer @moschel opinions on this one? I remember a discussion about whether this should be added or not, but can't remember the conclusion.\n. You can do new Person({id: 5}).save();, create isn't meant to be used in this way.\n. What is the API that a connector is implementing here? I want to write a custom connector that connects to indexeddb or some other storage backend that probably won't be in core.  How would I do that here?\nAlso, you can connect multiple backends it seems, so how does it determine which gets called?\n. I love the idea of defining routes in templates.  I think using attributes to set default values makes it clearer what is happening than by calling the JavaScript function. Also I think this will lead more people into defining their routes in a single place, rather than throughout the application.\n. Routes don't belong in can.app because they really don't have anything to do with it.  You can have an app without any routes at all. What defines an app is its state.  Routing is the thing most people find confusing when using CanJS, so we need to make some efforts to simplify it. In my opinion that means removing all of the extraneous APIs (like being able to listen to route changes in Controls) and push towards the \"correct\" way of using routes. So we need to figure out what will make it easier to understand.\n.  if it's called can.bacon we don't need the methods to be toCanMap and toCanList, the can is implicit, toMap and toList is sufficient. \n. ++ will be voting for this one\n. Yes, can follows semver. 2.2 is a minor release so it is api compatible.\n. I don't think this will fix stache though.  I submitted a previous PR that fixes stache: https://github.com/bitovi/canjs/pull/1204\n. Looks like this was enough to make stache work as well. We should find some way to test this though. At any point someone could use window in one of these files and it would break builds.\n. Adding a commonjs build would be a great contribution for anyone who wants to pick this up (seems like there are several browserify users who want this feature).  With the new build system it should be fairly easy to implement.  Take a look at how AMD is built here and here.  That's really all that is needed for commonjs (the format string would be \"cjs\").\nThe tricky part might be testing.  With the AMD build we test using RequireJS (see here).  For commonjs there would need to be an extra step of browserifying the commonjs modules and using that to test against. Not difficult just a little extra work.\nThink you can take this one on @zalad ?\n. You can use relative paths in your code while CanJS uses the full paths, they don't have to be the same.\n. Which template language are you using?\n. Not yet, stache is still a plugin, you must import it explicitly.\n. That's weird, how does this work? bower isn't part of the path, won't the shell complain? Are you saying that Node adds bin commands to the local path when installing?\n. I tend to agree that we shouldn't depend on an undocumented feature, particularly to fix something that's not broken at all. \n. can.computes for primitive values do not work on Maps. But then again, why do you need this? You can just set the value to false directly and update it with attr as with any other map property.\n. Should be this.attr(\"files\").attr('length')\n. Are you using the minor branch of CanJS?\n. It should be against minor. I think this function needs to return a can.Deferred though. IIRC old Steal's mapJoin is equivalent to the normalize in new Steal.\n. I might have been wrong about normalize. You do have to resubmit the PR though, GitHub doesn't let you change the base.\n. It doesn't couple Can to Steal. Non-Steal users can use Can without being aware that the plugins exist.  This is no different than a Node project containing Grunt tasks for Grunt users, which steal-tools, testee, and documentjs all have in their main repos.\nI'm all for increased modularity so long as we have a solution for those who want to grab everything from 1 download (whether that be JavaScriptMVC or something else).\n. So I think we're finally going to do this.  Example usage:\n``` handlebars\n{{#switch @env.NODE_ENV}}\n  {{#case \"production\"}}\n   \n  {{/case}}\n{{#case \"staging\"}}\n    \n  {{/case}}\n{{#default}}\n    \n  {{/default}}\n{{/switch}}\n```\n. Not sure, maybe it's turned off for forks?  Anyways, can you add a test?  And an explanation of what you changed and why would be great as well, seems like it's a big change.\n. Well we can't break compatibility until 3.0.  Are you suggesting a new API?\n. Ok, I can see you put quite a bit of effort into this.  I'll look over your changes and give you some feedback.\n. I lack the context to review this very well. What is the essential change? I'm not familiar with the old sort.  Could you make a case for this change? Specifically:\n1) What did the old sort do?\n2) What does your new sort do?\n3) Why is the new sort better than the old sort.\nAlso is there a reason to keep the old one around at all?\n. Why doesn't the old sort update the DOM? Is that intentional or just a bug?\n. My overall thoughts:\n- We can't and shouldn't put this new sort into core. Most new features start out as plugins, even stache is still a plugin, and are moved to core after they have been hardened.\n- I think having 2 sorts is too confusing. It would be better if we could combine these into 1.\nWhat I would suggest is scraping the old code (which sounds complicated) and add autosort into yours (with an option to disable it so it behaves like yours currently does) using the same API.  Put the code in the same place as the old autosort so this doesn't have to wait until 3.0.\nIf you can build a new sort that works as an autosort (with the same API, that's important) and optionally not... and is faster and actually works to update the DOM, that would be a big win and a great contribution.\n. Let's see what others think. @daffl @justinbmeyer opinions?\n. I don't think we should do this as we would have to do it for every plugin. \nFor this particular issue, the define plugin should become part of core.\n. Thanks for reporting!  There is already an issue for this, #1297, we'll track this there.\n. I previously reported this and included a test: https://github.com/bitovi/canjs/issues/1297\n. If you pass a string into template it will use can.mustache. If you want to use stache then pass in a can.stache renderer function: template: can.stache('Test component here with <content></content>')\n. You don't need to do any of that at all. Just do:\njs\ncan.Component({\n  tag: 'hello-world',\n  template: can.stache('hello world')\n});\n. js\nmap: {\n  \"can/view/mustache/mustache\": \"@empty\"\n}\n. Think we can close this one then.\n. Here's the Community Hangout where Justin explains why this currently isn't working and a possibly way to fix it.\n. Hm, I know there is a way to link to a time in a YouTube video but I can't figure it out. It starts about 24:30\n. This is wrong.\n. Added a breaking test.\n. Wrong branch.\n. :+1: finally!\n. You can have a default value in your template:\njs\n<content>\n  <div>Button</div>\n</content>\nwould default to showing a div with the word Button on it.\n. What will be the use-case for this?\n. isn't autorender added now?\n. This might need to be redirect to minor. @daffl is that right?\n. Looks like there is already code: https://github.com/bitovi/canjs/pull/1396/files#diff-95ad04d772620344cfa50f85ba7adb64R96\nI guess we just need a test to verify it is working?\n. Interesting, is there an existing demo page or something to test with? Otherwise I'll create one.\n. One issue is that we are importing can/view/stache/stache which for amd it should just be can/view/stache. This is only true of amd so I think we can just denormalize it in this one place.\n. I really don't like doing an amd check in autorender but can't think of a better way.\n. Just curious, why are you wanting to dismount a route?\n. Ah, cool then.\n. Pretty sure it's caused by this commit: https://github.com/bitovi/canjs/commit/18866d735149ed5c87e2227c346a258dfa72b64b\nBefore it would check if scope existed and if not create one, so that's why autorender is not working.  There's also another bug that was being masked before, here.  el.attributes is a NamedNodeMap whose children are Attrs, not strings. Will fix both.\n. @daffl I think this definitely needs to be in 2.2.\n. I think we went with define as the name because of dojo.  I don't think we can rename it but it should be deleting it itself.\n. @marshallswain best practice is not to use the global build :)  I think you might have a point though, deleting window.define might break things because it depends on define.modules, so we do need to cache modules somewhere.\n. Created https://github.com/stealjs/steal-tools/issues/200 to discuss fixing this issue.  I think we do need a global but maybe it can't be define.\n. There's one I missed.\n. Yep!\n. @daffl Yeah that doesn't have the fix to remove the define at the end of the script. We should update that to the latest 0.7.x version (0.7.4 I think).\n. This is something very far out as it would require producing code that can be stepped through.\n. With steal you can map mustache to stache:\njs\nmap: {\n  \"can/view/mustache/mustache\": \" can/view/stache/stache\"\n}\n. I just tried it and it works.  The issue is that can/component uses can.view.mustache. So you'll have to replace that with can.stache. Probably a better way is to map can/view/mustache/mustache to @empty and in then in your code set can.view.mustache = can.stache although you're on your own from here, I haven't tried this to confirm :)\n. Ideally can/view/mustache should return can.mustache, not can. If it did and can/component used that instead of can.view.mustache then a straight mapping would work.  I think we can't do that until 3.0 for backwards compatibility reasons.\n. You can map it. But Mapping it is not enough.  can/component expects a can.view.mustache and mapping doesn't fix that.\n. Can you post an issue in steal?  You should be able to do this, please provide an example of how you are trying to do your mapping.\n. Here's where to do it: https://github.com/bitovi/canjs/blob/master/view/autorender/autorender.js#L58\n. @rasjani are you sure you don't have a caching problem?  I just installed can@2.2.4 and did get a dist/cjs.  Maybe try npm cache clean?\n. @pYr0x we can't remove it as the default until 3.0.  This notice is just a warning that mustache won't have priority on bug fixes and eventually will be removed.\n. With simple helpers you get the values and not computes. If you've written code like this:\njs\nhelpers: {\n  addOne: function(val) {\n    val = val.isComputed ? val() : val;\n    return val + 1;\n  }\n}\nThen you'd probably like a simpleHelper.\n. This would be on the Component prototype. The idea is to have a component be represented as a different tag in scenarios where a custom tag isn't possible (like in place of a ).  There's another issue for allowing attrs to be Components: https://github.com/bitovi/canjs/issues/648#issuecomment-73942483  that I personally really like as well.\n. This is now done-autorender.\n. Yes, that is a Steal/SystemJS plugin, it should not be part of the AMD build.\n. Not really, best guess is that it's being misidentified as an AMD file because of the return 'define([..' part even though the format: steal should prevent that.  If you split up that string into return 'def' + 'ine([..' it might fix that issue.\n. @isadovskiy Are you using Steal?  If so then yes, you can use AMD or whatever syntax you want to use.  It doesn't matter what syntax CanJS itself uses, they all work together.\n. If you're using SystemJS directly then you'd want to use the AMD version. So to support that use-case we need to fix this bug.\n. @isadovskiy If you're using NPM you don't need any configuration at all.  If you're using Bower then I think probably the steal distribution would be the way to go.  In 3.0 the entire repo will be part of Bower as well so you could just use the base directory.  But I would highly recommend migrating to NPM if you can.\n. Why is it more powerful?\n. We're not going to switch Stache to use vdom.  We could possibly have a feature to do rendering in a web worker and that would use vdom, but in a normal browser window it will remain as it is.\n. So what happens when you put a can-as on a custom tag like?\nhtml\n<my-component can-as=\"other-component\"></my-component>\nI say this because <can-import> is implemented as a can.view.tag (for progressive loading).  If we switched to a more generic can-as that can be attached to any element what happens when the can-import callback is called, how does it know not to render its subtemplate?  Does it just check for the existence of a can-as?\n. We already have a solution for this (although not working with can-import at the moment):\nhtml\n<can-import from=\"./order-items.stache!\" [orderItems]=\"{value}\" />\nWe just need to document it as part of the can-import docs (and get it working).\nI'm not sure what to do with the as=\"viewModel\" static definitions.\n. We might need a new syntax for this because: \n``` mustache\n\n{{> orderItems}}\n```\nThe partial attempts to fetch orderItems.stache right away. We need to know to wait until orderItems is on the scope.  How about:\n{{< orderItems}}\nThis is more unixy as well. In this case we can bind to the scope and wait for orderItems.\n. No, in this case the partial renderer gets called before the [] attr callback.\n. Fixed by #1723\n. The new syntax will exist for everything, not just stache imports.  So you can reference the viewModel of any component, such as:\n``` handlebars\n\n#todos.length remaining todos\n```\nWe're just using the same syntax in this case for passing around templates, it's quite elegant IMO.\nI don't think we are going to be putting plugins into this repo any more, even the Steal ones will be removed, but we could create a new repo for you under the canjs org for a RequireJS plugin, that would be quite nice actually.\n. Let's open this back up to discussion.\n. I'm thinking the \"into variable\" use-case will be most common.  I almost think we should make it explicit if you want to place it on the parent context. What about:\nmustache\n<component [^parent-prop]=\"{child}\">\nWith the ^ meaning to add to the parent.  I don't like the {{#}} idea because it puts a tax on the most common need.\n. Here's how Angular 2 does bindings for comparison:\nDirect Bindings\nAll bindings use the [foo]=\"{bar}\" syntax like us, but the opposite direction.  This binds to an input's value:\nhtml\n<input type=\"text\" [value]=\"{{scope.value}}\">\nAnd this would also bind to a custom component's value:\nhtml\n<component [foo]=\"{{bar}}\">\nThis is interesting because the fact that they bind to an element's properties means you can do things like:\nhtml\n<div [inner-html]=\"{{scope.myHtml}}\"></div>\nReference Binding\nThis is a way to reference a component within the view. So you can do:\n``` html\n\n {{myInput.value}} \n```\n. (read the above comment first)\nI like having a different syntax for reference binding.  This could solve our issue of needing a \"local variable\" syntax.  So you could do:\n``` html\n\n{{child.state}}\n```\n#child is a promise, this will show \"pending\" and then \"resolved\" (or \"rejected\")\nI think you should also be able to do:\n``` html\n\n{{child}}\n```\nHere we are binding to the promise's value.\n. @justinbmeyer what was the use case for one-way binding?  And how would that work in practice? Wouldn't we have to make a copy?\n. > Child to Parent <my-comp [parent]=\"{childProp}\" />\nI think we should flip this around, it's weird that the direction is different between parent->child and child-> parent.  It's weird because the direction AND syntax are both different.  I think only the syntax should be different, I it makes it easier to understand.\nchild->parent\nhtml\n<my-comp [child]=\"{parentProp\"}>\ncorresponds to \nparent->child\nhtml\n<my-comp child=\"{parentProp\"}>\nI almost wish we didn't have to distinguish between the direction and could have only 1 two-way binding syntax. What if you could do:\nhtml\n<my-comp [id]=\"{parentId}\">\nYou currently can't do this with our binding syntax because id is reserved.\n. <my-comp [(child-prop)]=\"#ref\"/>\nWhy is the hash on the right side?\n. Does this fix the Chrome warning about using cloneNode with Attributes?  There are two possible ways to fix this:\n1. Create a new element and use innerHTML to set the attribute, just for the sake of getting it's Attribute node.  This is done here.\n2. Rename these special attributes (which stinks to special case) into something like one-way-parent-foo=\"bar\" and dom-two-way-value=\"foo\", these will be pretty long for some of the options.\n. :+1: sounds very useful.  Here you're always catching the event on the end but I wonder if some times you'd rather know at the beginning...\n. Progressive loading with <can-import>\n. I updated can-simple-dom so that we don't have to do simpleDOM[\"default\"] any more.  All steal tests are passing, most of the dist tests are passing, nothing is failing that was passing before.  I'm not comfortable pushing to a branch that's not passing so if I broke something it's not because i didn't test.\n. Green!\n. Do you mean 2.3-pre?  There is no 3.3.\n. Oh, you meant JavaScript MVC 3.3.  No, can-value (or any other can/view/bindings) is not part of JMVC 3.3.  You probably want to upgrade to CanJS 2.2.  That has everything you need.\n. It's probably caused by the change to the regexes to accommodate the new binding syntaxes.\n. Good question, with Component's you don't instantiate them, they are instantiated automatically as Stache runs your template.  So for that reason you can't pass functions into Components.  A lot of people have wanted a way to do this but we just haven't come up with the \"right\" solution yet. Here's an issue about it: https://github.com/bitovi/canjs/issues/1209\nAs far as your question about what is the difference... Controls are a bit lower level and are useful for when Components are not appropriate, for example if you need mixin-type behavior pairing a Control with a can.view.attr is a good way to go. Controls are also a better choice when you have performance critical parts of your app.\n. Why is this a 3.0.0 issue, would it be backwards incompatible?\n. There's an @index property you can use:\nhandlebars\n{{#each foo.items}}\n    <my-component property-index=\"{@index}\" some-property='{bar}' />\n{{/each}}\n. You can create a helper that passes in the string \"foo.items.0.bar\" if that's what you're going for.  What is the use-case that a component needs to know the parent's data structure?\n. @daffl can we go ahead and merge this?\n. Could probably be added here\n. Doesn't options contain more than just helpers?  If so I think options is what it should be called.\n. Pass it as both.\njs\noptions: options,\nhelpers: options\n. Found one more.\n. Fixed in https://github.com/bitovi/canjs/commit/3566ffa9a69cc1d4eba13f1d6f56d8c343eb78b5\n. Thanks.\n. I'm sorry but you broke the tests :)  Probably just need to re-run it.\n. Cool, thanks.\n. Probably not soon, PRs welcome though.\n. Hold on, first this is a legitimate bug as it is a regression, no one is saying this is a \"won't fix\".  It's probably a hard thing to fix though, would you be ok if it was \"opt in\" so that you enabled it some how? That's my first thought.\nIt's probably possible to do what you want to do by changing can-click to read . from the scope.  This can definitely be fixed.\n. @beno before we discuss the fix it would be really awesome to get a minimal breaking test.  If you could submit a PR with a breaking test here we can discuss a fix.\n. There's 2 things at play here; fixing can-EVENT probably pretty easy, but fixing it for all can.view.attrs would not be.\n. @justinbmeyer can't we just check for {{foo}} and then lookup foo in the scope? \n. Yes, please try with 2.3-beta and let us know.\n. Looks related to a change I made to can-simple-dom, I'll pull it down and see what is going on.\n. @whitecolor rebase with minor and the tests should all pass now.\n. Closed by #1815 \n. Great point. We can allow the user to set a variable, probably can.baseUrl which will be used as the first check to get the application base url for cases where the module loader baseUrl is not the same.\n. This is in minor.\n. In minor.\n. We can't really make loading canjs in Node intuitive unless we changed the folder structure.  Ideally it would be nice if you could do:\njs\nrequire(\"can/util/vdom/vdom\");\nvar can = require(\"can\");\nThis won't work though because the CommonJS can/util/vdom is located at dist/cjs/can/util/vdom/vdom and Node doesn't provide a way to remap module locations.\n. Looks like tests were failing because bower install failed; GitHub was probably down, so I restarted the tests.\n. You get the warning because cloneNode is being removed from Attributes.  Here's how I implemented in worker rendering without cloning and without using a try/catch.\n. This is fixed in minor.\n. No, Steal has a different plugin API than AMD.  In retrospect I wish we had made Steal fully AMD compliant and used the same plugin API.\n. Closing this in favor of using envs config.\n. How do you do this?\n. I'm not sure if a warning would be possible, you don't have to use can-tag (you could use a {{#isResolved}} helper instead) so I don't think we could know when to warn.  But we definitely need to document this so that it's known that can-import is asynchronous.\n. Why was this closed?  It's not fixed: https://github.com/bitovi/canjs/blob/minor/view/href/href.js\n. Oh, maybe because I said \"this is in minor\" you thought I meant it was fixed in minor, I meant that the problem is in minor.\n. @James0x57 yep, that's all that's needed.\n. @justinbmeyer Would this be fixed by the new binding syntax?\n. Opinions @justinbmeyer ?\n. I'd still like this behavior, but a separate project might be the way to go. In a refactoring scenario I think it's asking too much to completely change your template (and not use can.connect/tag) and refactor into the viewModel when a simple attribute could give you what you need. I understand that you probably wouldn't write it that way if you needed the todos in your viewModel from the start.\nLet me relook at the code and make sure it's not using any undocumented apis and I'll create a separate repo for this.\n. Closed by #1875 \n. Awesome, thank you.\n. I like either join or join-base because that is what they do.  join-base is more accurate.\n. @Alfredo-Delgado So this would be a helper that simply returns the baseUrl as a string, doesn't do any joining, and use normal stache to do whatever you want?  Not a bad idea... going to think about that some more.\n. Is the normal convention to kebab-case or camelCase helper names?\n. This is in minor.\n. @whitecolor Thanks, I think this is the same as #1189, no?\n. Thanks, I'm confused though, what about \"can.Control({})\" does ie8 have a problem with?\n. Hm, that's really weird, I just ran the can/control tests in IE8 and they all pass.  What is the typeof can.Control before that error happens?\n. > Not in this module directly.\nI'm not sure that this is it (because can does exist) but try importing can into this module.  You should really always import your dependencies and not depend on them having already loaded.  Maybe can is only partially loaded when this module is called.\n. Great, mind sending a pull request then?\n. Thanks, should keep a reference to Object.prototype.hasOwnProperty and use that.\n. Fixed by https://github.com/bitovi/canjs/pull/1974\n. Same for 'default'.\n. Ok, fixed now.\n. Need to test, but it looks like IE8 might also start loading the script before it is inserted into the dom.\n. ## Issues\nscripts with text\nThe following will throw in IE8:\njs\n var ss = document.createElement(\"script\");\n var tn = document.createTextNode(\"var foo;\");\n ss.appendChild(tn); // throws\nscripts with src\nIE8 will begin fetching/executing the script as soon as it is inserted into a fragment (not when inserted into the DOM like in most browsers).\njs\nvar frag = document.createDocumentFragment();\nvar ss = document.createElement(\"script\");\nss.setAttribute(\"src\", \"foo.js\"); // It will actually fetch and execute foo.js\nfrag.appendChild(ss);\n. Moved to https://github.com/donejs/autorender/issues/11\n. Thanks!\n. Thanks!\n. Not intentional, it's a bug.\n. Can you submit a test?\n. Can you open a donejs issue that simply points to this one and assign it to me.\n. @julia-allyce I tried to recreate the bug here https://github.com/bitovi/canjs/commit/bbb25cc76f3c0628f244968b6c90906137a1c9ce but am not seeing the same thing.\nAre you sure you have the latest donejs?  If you just did an npm install donejs -g you actually have an older version.  Since we are on a prerelease you have to do npm install donejs@0.5.0-pre.16 -g.\n. Fixed in https://github.com/canjs/canjs/commit/12f6e45e49a307df76d9dcbd04f28ca4897cd1cc\n. I did a git log search in steal-tools and I don't see there ever being a keepDevelopmentCode option, transform has always had removeDevelopmentCode.  I would think changing it to removeDevelopmentCode: false would work.\n. :)\n. > I'm not sure how much thought and discussion was put into making this change but I think this feature should still be on the table.\nA whole lot of both thought and discussion was put into it. And it is on the table for 3.0, not for 2.3, but 3.0 is next. That's why we released this now, because we know it's a big change and want to get feedback on how it works in practice and make adjustment if needed in 3.0.\nBut to answer some of your question, correct me if I'm wrong but it sounds like you want one-way binding behavior, you know that you have that now, right?  Previously it was always two-way. You can do {child}=\"parent\" to get 1 way binding which is what it sounds like you want.\n. > Register partials yourself or use a module loader.\nWill there be a new API for that?  Currently there's just can.view.preload (I think?) which is semi-private.\n. # Legacy stuff\n- [ ] - can-jquery: https://github.com/canjs/can-jquery/issues/1\n- [ ] - can-connect/can/model - put on namespace of can.Model not already there\n  - can-model always puts itself on ns.\n- [ ] - can/legacy includes can-map\n- [ ] - can-connect data-url to handle jQuery promises.\n- [x] - migration guide\n. Normally when two way binding we set initial values based on which has a value. In this case the parent doesn't have a value but the child does, so we are making an exception for selects and saying that their value doesn't matter?\n. More clearly, for selects we are ignoring their value and forcing parent->child initialization. Is this right?\n. I don't think it's possible to set a select's value as undefined so the parent compute is always going to be initialized as an empty string if we do this.\n. Scratch that, if we initialize this special case before bindings are set up the parent compute's value won't be updated. This sucks though.\n. This changes the behavior that was added for:\n- https://github.com/bitovi/canjs/issues/1679\n- https://github.com/bitovi/canjs/commit/c705aa6ca79571cf899fac95cb0b67f8d201d6a3\n. Yes, it is wrong.  I wonder if instead of explaining binding syntax there it should link to can.view.bindings instead.\n. I've been just using it like a normal helper:\nhref=\"{{routeUrl page='orders'}}\"\n. Yep, thank!\n. Looking into why this is failing.\n. @daffl this is the PR i need in 2.3.1\n. Shouldn't this be done in can/map itself?\n. https://github.com/bitovi/canjs/commit/4b3402cc11702220796ace332506f9e8ba1b15ea contains tests.\n. I don't think it's super important now that the {{> *other}} syntax is working which correctly applies the correct scope.\n. Actually we can probably just pass that in as tagData.\n. It can be yes.\n. @justinbmeyer I'd like you to review this PR, particularly the changes I made to component/component.js where I pass in a preventDataBindings flag into the tagData to fix the can-import can-tag problem. Maybe there's a more elegant way.\n. Yeah I supposed this is intentional: https://github.com/canjs/canjs/blob/master/view/bindings/bindings.js#L238\n. Yep.\n. That's right, ejs is still supported, this isn't a \"won't fix\".\nHowever bugs only get fixed if someone has time and energy to fix them. This is true of all features, new and old. Pull requests fixing this bug will of course be accepted.\nIt's also possible to sponsor a bug to ensure it gets fixed if you can't do it yourself, @justinbmeyer can speak more about how that can work in this case.\n. @rjgotten we don't use submodules any more, so it's much easier.  Just git clone and do an npm install.\n. I never run grunt test locally because it's too flaky. I test in browsers and then let Travis handle running it with Phantom.  I'd start by fixing the jshint problem from here: https://travis-ci.org/canjs/canjs/jobs/94478367#L617\nAlso, if not all 5 test suites are running that's likely an issue.  You can run an individual one, like mootools, by opening test/mootools.html\n. Thanks! Can you add a test?\n. @rjgotten Looks like it's failing in the dist tests. These are the tests that use the standalone build. You should be able to replicate in a browser by running grunt build and then opening up test/dist/mootools.html\n. Thanks for doing the digging!  We can get this in 2.3.6.\n. I think this should do it:\n<year-selector {^year-selector}=\".\" />\n. @whitecolor here's an example of doing that: https://github.com/canjs/canjs/blob/master/view/import/import_test.js#L65\n. @whitecolor If the tag is self closing it is like import ..., if it contains children (light dom) then it acts like System.import.\nstatic\n<can-import from=\"some/component\"/>\ndynamic\n<can-import from=\"some/component\">\n  {{#if isResolved}}\n  <some-component/>\n  {{/if}}\n</can-import>\n. It should be able to resolve the relative module if you are loading the template with Steal, otherwise I think it will not.\nThat's right, the two examples are not exactly the same, bindings you add to a can-import will be applied asynchronously.\n. Maybe... I can't remember where this problem originated. Probably you are right, it's only for the NPM Steal version.\n. Going to close, I have no plan on working on this.\n. For projects that operate on raw DOM elements (like legacy jQuery projects) that still would want the benefits of live-binding. Also, other frameworks that use observables are doing essentially this.\n. @DesignByOnyx All of the stache tests run both in the regular (real) DOM and using can/util/vdom.\n. Are you sure it's Steal and not jQuery? I know that there are currently issues with jQuery 2.2 that was released last week.\n. Looking at the code it seems some effort was made not to make can/map depend on can/list, why is that @justinbmeyer ?\nWith that being the case I guess the solution is to check if can.List exists and not assume it does. Which would mean your arrays are not observable, probably not what you actually want.\n. @justinbmeyer so why doesn't can/map depend on can/list?\nI don't think silently making arrays non-observable is the way to go. We should at least provide a warning (I think an assertion is more appropriate).\n. So it seems like maybe the reason it doesn't depend on can/list is to avoid a circular dependency. In that case I think an assertion is a good idea.\n. So you're expecting it to output something like <input type=\"text\" value=\"test\">?  I guess this is because can/view/bindings sets the value property and not the value attribute. But maybe it should when server-side rendered.  I think you probably want the placeholder attribute in this case though.\n. Thanks for reporting. This is being worked on in https://github.com/canjs/canjs/issues/2176 so will close this.\n. This is how I did it for web worker rendering: https://github.com/canjs/dom-patch/blob/master/src/setattribute.js#L22\n. Does jQuery even need to be a peerDependency any more? In DoneJS we installing with donejs init. In NPM3 peerDependencies aren't installed any more anyways, I'm thinking we can just move this to a dependency.\n. Aside from the warning, is the class name not applied?\n. The warning is for when people want to set the class property on the child component's viewModel.\n. What is not the case?\n. Thanks!\n. Is new Function really more performant that eval? I wonder why that is.\n. @daffl should this go into major?\n. Do we need/want to be publishing patch changelogs? If it's any amount of work to do I'm not sure it's worth it. \n. Yeah, the components must be registered when the template is parsed. You can work around this using a custom element and doing:\njs\n{{#show}}\n  <content/>\n{{/show}}\njs\n<only-show-if show=\"tag1\">\n  <custom-tag1></custom-tag1>\n</only-show-if>\nHowever... we already have  for exactly this purpose. It doesn't work with HeadJS though, are you married to using that library?  can-import works very nicely with stealjs\n. @pravin-d sounds like i was wrong, try with putting a hyphen in.\n. Doesn't this feature assume every issue is a bug?\n. Closing as this is for debugging at the moment.\n. Sorry, it doesn't.\n. It's necessary for people that do this.attr(\"%root\") in a ViewModel though. Before can-wait we were telling people to do:\njs\nvar promise = SomeModel.getList();\nthis.attr(\"%root\").waitFor(promise);\nreturn promise;\nDoes this break something for you?\n. This was the bug where you could not edit canjs code inside node_modules and have that code be reloaded. It's probably not an issue any more in 3.0, so closing this.\n. That only happens on fresh npm installs though, right? I think of someone did an npm update they wouldn't be upgraded.\n. I think this is the plan for 3.0, @justinbmeyer ?\n. We couldn't change the build structure in a non-breaking release.\n. @pYr0x there are two types of can-imports, perhaps this should be explained in the docs:\nstatic\nThese are imports that are direct dependencies of the template. For example:\njs\nimport from 'foo';\nIs equivalent to:\nhandlebars\n<can-import from=\"foo\"/>\ndynamic\nThese are conditional imports, things you only want to import in certain situations. These are equivalent:\njs\nSystem.import('foo').then(function(foo) { ... })\nto\nhandlebars\n<can-import from=\"foo\">\n  {{#if isResolved}}\n  <foo/>\n  {{/if}}\n</can-import>\nNote that when dynamically importing, the scope inside the can-import is a Promise, so you have to wait for it to be isResolved.\n. ## Documentation difficulties\nHere are some problems I've ran into when documenting 3.0 projects.\n- Unsure if we should use the can. namespace in examples (or docs in general). I have been removing it so far.\n- Linking to external projects. For example, in can-map there are links like [can-compute] which don't work in the readme but do work in the full-site.\n. Looking at your example, I don't think native Promises have a value property, could this be why?\n. This has been clarified. We've gone with a getter/setter approach to the document, and then always calling a getDocument() function when it needs to be used. See in can-util: https://github.com/canjs/can-util/blob/master/dom/document/document.js\n. To really \"support\" WebPack (or any other loader / bundler) you have to test against it. I don't think we should support WebPack or any other loader / bundler in that respect. The only things we should officially support is:\n- Node.js\n- Steal (we get this for free because canjs uses Steal in development)\n- Global (for fiddles)\nBy my count there's at least 6 somewhat popular loader / bundler options (WebPack, Browserify, Rollup, RequireJS, JSPM, Steal) and that number will likely increase when/if script type=module and the Loader spec ships.\nI think all loader integration should be handled by the community. If there are Rollup fans, they can run the canjs tests against rollup in their own project and provide patches for bugs.  We can even go as far as to make it part of the release process for community projects that are active enough to test in a timely fashion.\nLuckily converting to plain commonjs means that most loaders / bundlers will just work, but there's always the possibility of loader-specific bugs.  We did the \"support everything\" already with DOM libraries and I don't think we benefited much.  There's a huge maintenance burden to trying to support everything. And it affects how soon you can deprecate things; we are still supporting a dead project (YUI) because semver says we have to.\n. 3.0, which is in prerelease now.\n. Interesting, does lodash just test for a .length that's a Number?\n. I commented on the issue in can-interrupt.\n. What is bad about it?\n. Ok, will read it.\n. I responded to the original issue. Feel free to open an issue in https://github.com/canjs/can-route  if you think interrupting should be a core part of the router. Maybe it should be.\n. Still curious about this.\n. @tracer99 is experiencing this issue and is blocking him from using client-side routing, just to note.  Partially to myself so that I make the effort to fix it in 3.0.\n. can/view/import has a can-tag feature that lets you to define a Component (or can.view.tag) that controls the inner scope.  Maybe this new feature could replace the need for that.\n. lgtm\n. steal-stache will import can-view-import.\n. I think it would be a good start to add a required property in the define definition. type already covers type validations. I wouldn't want to attempt to do anything more validation related, and leave that to a plugin like can-validate if someone needs more.\n. Thanks!\n. Thanks, if you'd like to fix the bug you can do so in can-ejs.\n. This is gone in can-map: https://github.com/canjs/can-map/blob/master/can-map.js#L104  I'm not sure if there will be more 2.3.x releases or not.\n. can-list is now developed in its own repo. I've moved this issue there. Thanks for the suggestion, I like it!\n. Are you talking about this signature?  How were you able to pass the context?\n. Can you give a code example of what that looked like?\n. Ah, ok thanks, so it was a property on computeSettings. It's not documented but I think that's a fair thing to add.\n. Moved this to a can-compute issue, thanks!\n. I think that label is automatically added by waffle any time a PR is submitted.\n. Thanks @rjgotten, couple of comments:\n1) Light DOM should already have the template's scope when using leakScope: false. If not it's a bug.\n2) Using <content> inside of each is not supported, it doesn't work in web components and only works by mistake in CanJS.  <content> is not a template, it's a way to insert light DOM in a place inside of the local DOM (aka the shadow DOM).  <content> is actually be deprecated from web components and being replaced by something called slots, which I think we want to implement in can-component, so I don't think further changes to <content> are a good idea.\n. @justinbmeyer did you close this without comment on purpose? Going to assume not.\n. This is a valid new issue.  What is being talked about here is a sort of \"meta\" API that ignored enumerability. You might not want your derived properties to be serializable but need to access them anyways in special cases. I would suggest something like Map.getRawObject(map) (not a great name)  that ignores enumerability similar to how Object.getOwnPropertyNames ignores enumerability.\n. Can you add a test?\n. can/map/app doesn't have any use any more and should be removed. Use can/map here instead.  In 3.0 it will need to be types.DefaultMap.\n. Failing in Travis, is it working locally?\n. No, can/map/app should be removed actually. So there must be something wrong here. Which test is failing without it?\n. We can fix can/map/app in another issue, or not at all since can-view-autorender doesn't depend on it.\n. Are there cases other than _blank that you can think of? Otherwise maybe we can special case it.\n. We have a special case for javascript:// here, this is where I'd add special logic to prevent intercepting clicks for anchors with target values.\n. I haven't used it but I assume it's this: https://github.com/canjs/canjs/blob/master/model/queue/queue.js\n. This should be available in can/can as well, since it's brought in by can-component anyways.\n. viewCallbacks is a weird internal name though, it doesn't mean anything to users.  I wonder if the project should be named can-view :)\n. This was done in 8d900a5cdedbcbcad14c9bfb9074f1451dc855c8\n. This is specific to can-define/map/map.  I wonder if there should be a separate can-map-define -> can-define/map/map migration guide.\n. Here's some subissues:\n- https://github.com/canjs/canjs/issues/2457\n- https://github.com/canjs/canjs/issues/2461\n. Probably this sort of thing goes in the Contributing guide @justinbmeyer \n. This should be mentioned in can-route.map: http://canjs.github.io/canjs/doc/can-route.map.html\n. Yeah, you're right, will fix it in can-stache-bindings.\n. Will be fixed in the next canjs publish.\n. Self-closing is equivalent to the ES6 static imports like:\njs\nimport 'foo.js';\nIf you put that in a conditional it would still be loaded:\njs\nif(foo) {\n  import 'foo.js';\n}\n. Why? There are definitely situations where you want to progressively load css, to prevent loading more than you need for a particular view.\n. This is not a fixable issue. The same way this is not conditional in JavaScript:\njs\nif(someCondition) {\n  import \"foo\";\n}\nstache templates are statically analyzed to determine what should be imported up front and what should be imported based on runtime conditions.  This is how JavaScript ES modules works too.  \nAn {{#if}} is just a helper and there is no special logic to handle it. You could have a custom helper in your template that did:\nhandlebars\n{{#myHelper}}\n  <can-import from=\"something.css\"/>\n{{/myHelper}}\nWhich we can't statically determine if this is a conditional type of helper or not.  So we need some rule based on syntax to determine if something is intended to be static vs. dynamic. That syntax rule is currently self-closing vs. not self closing.  \nWe could in the future switch to some different syntax rule.  Maybe an attribute like dynamic.  Suggestions welcome here.  But we can't make all imports be runtime dynamically imported.\n. Let's keep this issue open a little longer, I don't want @MarcGodard to feel like his opinion is being ignored.  Hopefully we can explain why static analysis is needed to distinguish between static/dynamic imports.  I can't certainly understand the desire for conditionals in ifs.\nWe really just choose self-closing/non-self-closing because it was the best we could come up with at the time. Maybe there's a better way!\n. I see this as bit of an existential crisis for Steal. It's sort of like https://github.com/stealjs/steal-css/issues/16.\nLet me explain.  This issue has identified 2 problems with using can-import with CSS. Those are:\n- CSS is imported regardless of whether the <can-import> is inserted into the page or not. This goes against the expectation of HTML (which stache is not) that side-effects only happen once inserted into the DOM.\n- CSS is not removed when the <can-import> is removed from the page. It's understandable how you might want this behavior.\nThere's an existing API that gives you both of those things. It is:\nhandlebars\n{{#if condition}}\n  <link rel=\"stylesheet\" href=\"path/to/styles.css\">\n{{/if}}\nIf you use a <link> then you get exactly what is wanted. The CSS is not fetched until inserted into the page. Styles are removed when removed from the page.\nThere's just one big problem with using a <link> in a DoneJS application. Steal doesn't know about it. So it can't dedupe it and steal-tools can't create bundles for it. Steal only knows about a JavaScript main and its dependencies (or something that compiles to JavaScript). To work around this we make everything into a JavaScript module.  But by doing this we give up all of the features that <link> has, and that makes me sad. I don't want to reimplement all of link.\nThis is a problem I've been thinking a lot about recently. I see Steal as evolving towards revolving around pages and their dependencies, which includes JavaScript modules, CSS, images, and anything else that can be described in an HTML tag, including some day, custom elements.  A page's dependency graph looks like:\n\nFor CSS, for example, you could have a custom element like:\nhtml\n<steal-css href=\"path/to/styles.css\"></steal-css>\nThat solves all of the problems we encounter:\n1. It would only fetch styles when inserted into the page.\n2. It would remove its stylesheets when it is removed from the page.\n3. It could deduplicate import()s.\n4. It would produce bundles during the build.\n. @justinbmeyer \n\n@matthewp I'm confused why we can't make dynamic  of styles able to remove the stylesheet when the element is removed?\n\nWe might be able to, but I was answering the larger point about this issue which removing the stylesheet doesn't solve, and the problems that have prompted https://github.com/stealjs/steal-css/issues/16, and https://github.com/stealjs/steal-bundler and https://github.com/donejs/done-component, etc.\nTo your point though, I'm not sure how to do this without special casing CSS. \nRoughly speaking, any dynamic can-import translates into:\njs\nvar from = el.getAttribute('from');\nSystem.import(from);\nI'm not sure what removal is supposed to trigger? Let's say it did this:\njs\nSystem.delete(from);\nAnd somehow steal-css was able to know about this through a hook (that doesn't exist at the moment), you wouldn't want this anyways in the case of JavaScript imports which also happen within conditionals.\nSo, I don't think the use-case fits well into any existing Steal lifecycle hooks.\n\n<can-import>'s behavior, imo, should be relatively divorced from steal's behavior. It's a layer that uses steal, but it's steal itself. It can have it's own behaviors and abilities.\n\nI'm not sure what this is referencing, did something I said make you think that I want Steal to be aware of can-import?  If so that wasn't my intent.\nWhat I was saying is that can-import is not a great fit for CSS because of the reasons I outlined above, and how normal <link> solves both problems outlined here but isn't useable in this context because steal-tools can't trace page dependencies.\n. Search is hard to do for a statically generated site.  We might be able to leverage Google though. \n. Looks like this will be fixed in 3.0: https://github.com/canjs/can-observation/blob/master/can-observation.js#L17\n. I'll fix in 3.0 first.\n. @daffl @justinbmeyer is there a way to tag a PR to go in the next 2.3.x (if that even happens)?\n. Is it possible to only add the arguments when using Helper Expression or is that not known by the code that adds it?  I do agree that for Call Expressions you should be explicit.\n. Which version are you upgrading to? 3.0 doesn't support setting a global namespace object any more.\n. I'm taking care of this in a separate PR.\n. This does it: https://github.com/canjs/canjs/pull/2612\n. Nothing to see here.\n. @phillipskevin how do we get the saucelabs image updated?\n. 3.4 is out.. The websites are not single page CanJS apps so that couldn't be a can-component.. Overwriting globals has proven to be more of a headache than its worth in my opinion.. Can you submit PRs to those repos? Looks like you already did the work to identify the problems.. Since can-connect uses a regular CommonJS structure now I don't think it needs the \"browser\" config any more. True @justinbmeyer @phillipskevin ?. @perehnbom https://github.com/canjs/can-connect/issues/200. That would be great, thanks!. @perehnbom I did can-connect.. Oops, no I haven't I guess. Still fixing.. Ok, can-connect is fixed. I'm going to go through other projects and see if they have the same issue.. Everything should be working now @perehnbom   I'll close for now but if you have any other issues let me know.. The problem seems to be that a bunch of packages have a cssify transform listed even though they don't have anything to do with CSS. Going to post subissues as I find them:\n\nhttps://github.com/canjs/can-construct/issues/19\nhttps://github.com/canjs/can-observation/issues/31. Those are the only issues.. Fixed those two issues and it looks to be working fine now. Reopen if you see otherwise.. A convenient link: https://github.com/search?p=1&q=org%3Acanjs+cssify&type=Code. @chasenlehara this should be fixed now.. @chasenlehara can this be closed?. We should make it be a function like items.defineListSet(set) or items.listSet(set) or something like that. Setting a double underscore property is an uncommon API.. Here's the docs: http://canjs.com/doc/can-connect/base/base.listSetProp.html. Did this come up in the user testing or just your opinion?. I don't think it's the responsibility of our docs to teach JavaScript features. We should be free to use any features that are supported. Maybe link to an MDN page when using a feature that users are unfamiliar with.. It's a bug somewhere, not sure where. Looks good!. @phillipskevin If this gets merged will it go in the next release?. FWIW you can't do this in JavaScript either: anchor.onclick = fn;.. or fn1(); fn2(); if the right hand side of an event binding is a Function body.. Do you mean the steal-clone module?. Rather than not running these tests, would it be better to just not run the specific tests? For example, only one can-observation test uses steal-clone: https://github.com/canjs/can-observation/blob/master/can-observation_test.js#L385\n\ncc @phillipskevin . Can you describe the problem a bit more? I know we have talked about this several times but an overview of the problem area makes it easier to evaluate the proposal. . Would this be used by anything outside of can-view-scope?. Going to move this to canjs/can-list.. Issue moved to canjs/can-list #26 via ZenHub\n. @gsmeets can-route's .data property.. Then just export your root VM as a module and import it wherever you need it.. @rjgotten Good info!  Note that if you intend to use Scope.prototype.getRoot I would highly recommend filing an issue with https://github.com/canjs/can-view-scope/issues so that it becomes a public API and we don't remove it not knowing its being used.. I think it's a bad idea to make a language look like another language but have different semantic meaning. This is the same reason I think our <select multiple> implementation is the wrong way to go. If something looks like something else but behaves differently you can't use existing knowledge to understand what you're looking at; anything could have been changed.\nIn this example there's a for loop that looks a little bit like a JavaScript for loop except here there is something like an implicit yield happening. In JavaScript for loops are for side effects and don't return as expression.\nAlso, it seems like this idea would require the language to constantly change as JavaScript itself changes, and that would be a difficult thing to keep up with.. @rjgotten \n\nThe reason intermixed JS-like constructs with HTML markup are such a desired feature is because they give you the best of both worlds: you get a good picture of what your output is going to look like, while you retain the privilege of having virtually all the fine-grained control you want, when you need it. And you can forego that complexity when you don't.\n\nI think you're mistaken here, this proposal isn't JavaScript, it's something that looks a bit like JavaScript but behaves in different ways in some cases (see my comment on for loops above) and supports some subset of features of JavaScript that haven't all been defined yet.\nI agree with you about the advantages of something like JSX that is strictly a superset of JavaScript, but that's not what this proposal is.. I think we'll have to wait and see what this proposal introduces before we judge how much control is given. So far we have some imports, an export and a for loop (but not like a JavaScript for loop).. Good point, we should try to adopt the spirit of the proposal and improve upon it.  I think stuff like this is going to be difficult:\njs\nif( !teacher.hasKeys( classRoom ) ) { No keys } else { Keys }\nto differentiate between that as code and that as a string in the template. What if I wanted to write that as a string. Maybe use something like backticks?\nhtml\n`if( !teacher.hasKeys( classRoom ) ) { No keys } else { Keys }`. ^^ Essentially this means that code gets precedence over html or text which I think is probably the right choice, you want to make writing code easier and make the exceptions (like writing text that looks like code) the exception that needs special syntax.. @justinbmeyer I'm talking about if I want to write the entire expression as text in the template. I literally want to show the user the code. I think you would need some special syntax because by default it wants to evaluate the if()... as code.. I like it too, that's a good way to visually see where a code section starts.. Thanks!. Can this be closed? I think we settled on incrementally improving stache and eventually doing JSX.. It's in the docs: https://github.com/canjs/can-observe/blob/master/docs/can-observe.md#browser-support. I would think you just need the plugins config.. Not yet. That would be a reasonable add to https://github.com/canjs/can-util/tree/master/js. Could then provide a nice error message if there isn't a window.Promise.. Based on this info it sounds like there are 3 versions of debug and we are loading one of them incorrectly. Very likely a steal bug.\nWhat I would do as a next step is construct a test project when emulates what is happening here. Don't install the same modules, but instead create a fake directory structure like:\nnode_modules/\n  debug@2.6.1\n  package-a/\n    debug@2.2.0\n  package-b/\n    debug@2.3.3\nOr whatever the directory structure actual is. Then make it so that package-a requires debug and package-b requires debug... again whatever is happening in this example, do the same thing.\nIf you set it up the same way it is happening here, it should break. In which case there is a steal bug worth looking at.. I can probably look at it on Monday if not resolved before then.. I'll try out the branch.. I didn't fix it, just spot-checked it inside my node_modules. I will write a test + fix though.  Bug is here: https://github.com/stealjs/steal/issues/1075. This is fixed in steal 1.2.8. Yep, thanks.. I don't doubt you, but could you like to anything about name being deprecated? I wasn't aware of that.. Also, Babel can compile JSX to any hyperscript-compatible implementation. This is how all of the non-React vdom libraries use JSX. So you could use JSX and compile it to can-hyperscript.. Won't this be a 3.6 change? Are 3.6 changes being merged into master?. How are we deciding what is going to be in CanJS 4.0?. This replaces https://github.com/canjs/canjs/pull/2998. Most of the projects were created using the donejs plugin generator donejs add plugin foo, and that comes with jshint and these linting rules.  Some projects were created before the donejs plugin generator was around, so there is probably inconsistency there. . Yeah, I found that stuff interesting too. But keep in mind that adopting a observable-less templating system doesn't necessarily mean having to also adopt the opcode VM stuff.\nSo, I researched into how their validation system works. With Observables values are cached as part of the Type. So without observables you have to be careful not to over-get a value (getting a value is possibly expensive if it requires calling a function that might call other functions, etc).\nHow they achieve not over-getting a value is through a tagging system where each change to a property increments a global revision number. This is explained very well here.\nHow I'm thinking this can work is that the template retains the largest revision number of all of the tags it has. Let's say the largest revision number is 5.\nChanging a property will result in incrementing that property's tag:\njs\nobj.foo = 'bar';\n// Internally this increments obj.foo's tag to be 6\nThis also triggers (internally) the view layer to update somehow: view.update().\nThe view can walk through all of its properties and check the revision numbers:\n```js\nvar tag = getTagFor(\"obj.foo\");\nif(lastRevision < tag.revision) {\n  // Need to get its value as it's now out of date.\n  var newValue = obj.foo;\n}\n```\n\nThe downside here is that it's still (probably?) possible to get a value more than once per change. Let's say you have:\n\na is a getter\nb is a getter that calls to a\n\nIf both a and b are in the view, and a becomes stale then we might call out to a twice (to get its value and then to get b's value). So there isn't a guarantee that value is only gotten once per change.  This is the downside to not having caching in the data layer.. One neat thing about this method is that it doesn't get the value when it's not going to be needed. For example, consider this template:\nhandlebars\n{{#if isAdmin}}\n  <span>{{name}}</span>\n{{/if}}\nLet's consider the case when both isAdmin and name change values.  In CanJS currently it will update the value of both isAdmin and name even if isAdmin becomes falsey.\nUsing the approach described here, because we walk down the tree from the top, we stop when the condition is false.\nThis likely means you have to remember the previous revision number for each property in the view and compare against that (instead of having a single revision number stored for the entire view).. \ud83d\udc4d . This repo uses test-saucelabs, maybe use that as a guide.. I think we're going to need a more specific bug report.. Thanks!. I think distinguishing between can-event events and DOM events is a bit overkill. There have been no custom can-event events created yet.. @christopherjbaker Does your proposal differ from https://github.com/canjs/canjs/issues/3042? It appears to be the same to me.. \ud83d\udc4d . That solution sounds reasonable to me. I would check and see if the body gets updated when going from one page to another... if not putting it on a div might be a better way to go.. > ViewModels that only derive from streams.\nWhat is this? is there a subissue about this?. @phillipskevin @justinbmeyer given that you've decided to do a 4.0, is there any need to keep this issue open here?. I think the ability to step through state mutations is more useful than the former. You can pretty easily trace from a Node to its source template.. other options are rawgit if the files are checked into github or unpkg.com if they are published to npm.. Are you talking about what is loaded by test/index.html? That loads can.all.js, which is a global exported build. As far as I remember the global shim never had process, only the steal npm plugin (which does still have it). I'm not opposed to adding it to the global shim though.. I don't understand how this is supposed to work.  There are several libs being ignored in the build: https://github.com/canjs/canjs/blob/master/build.js#L6-L7 . but there are no corresponding script tags for those libs in the text HTML pages. So I don't understand how those libs are not throwing. . Digging into it more it looks like, in the example of can-stream-kefir, that kefir is excluded from the build and is not on the window, but because can-stream-kefir doesn't care in the module body if Kefir is undefined, it doesn't break. But it would break if someone attempted to use it (although I'm not quite sure how they would do so).. So I think we need to either include react and all of its dependencies into the build or exclude it, and react-view-model and can-react-component. For now I'm not to exclude those.. I like this a lot! Couple of initial thoughts:\n\nWould there need to be any Observations set up here? I think it would be really good if there were not (unless the user is using them, of course).\nIs there any assumption of this being synchronous? Would there be value in eliminating that assumption now to prevent the problems we experienced with making can-event events async?. The latter example implements a getter/setter, where the former is just a getter, right? Anyways, I see no reason why a Streamed interface couldn't contain similar types of sugar but it's premature to worry about that, imo.. @justinbmeyer are you arguing against this idea now? :-). I can't tell what this issue is about. Is it a bug report, a feature request? Could you update the issue with a little more description of what is wrong / what should be happening. Thanks.. lgtm \ud83d\udc4d . Are the doc links and github stars stuff added?. @imaustink I think you need to wrap the require() in the test in an if statement, checking for typeof Proxy === \"function\". Can this issue be closed?. @phillipskevin There's still a few issues open, is it ok to close this and assume those issues will be tackled elsewhere in the future?. Epic is here: https://github.com/canjs/can-element/issues/37. Interesting point.  If you wanted to only listen to what is being observed, I would think you would not observe the VM, but rather the thing that is doing the observing. For example, an element.. How do you use your own stream library in this way?. Oops, this belongs in can-element.. Can this be closed?. Basic guide does work:\n\n\n. Fixed in major.. Closes #3764. This is not ready to be merged.. can-stache/helpers/route is now can-stache-route-helpers.. can-view-scope doesn't do implicit scope walking, so change to use ../ and whatnot. Or use {{scope.find('foo')}}. Should we create can-dom-mutate-events-legacy or something that does the above?. The downside to that is it would be harder to remove the compat package if you depend on several of its internal behaviors.. I would favor not allowing importing can-3-4-compat and forcing people to import the individual things they need. Meaning you have to import can-3-4-compat/dom-mutation-events\n  . can.route.deparam(routeString) no longer includes a .route property when there is a matching route. Use !!route.rule(routeString) instead.\n\nJUSTIN NOTE: I'd use route.rule(...) !== undefined. can-view-model no longer uses domData to get an element's viewModel. Instead it uses the can.viewModel symbol.. Are there any uses cases for keeping can-event in a project @justinbmeyer @phillipskevin? I think everything it did is covered by can-queues.batch and can-event-queue, right?. @chasenlehara @phillipskevin @m-mujica @justinbmeyer Here is the first version of the migration guide: https://canjs.github.io/next/doc/migrate-4.html . You can leave feedback here and I'll update in a PR.. @justinbmeyer \nWas this not true for 3.0? can-define was 1.0 for can@3.0.\n\nNo, can-define was not part of CanJS 2.3, so it wasn't part of the migration guide.. I'll get it, thanks for the notes!. @phillipskevin what was the reason for .each being dropped? Was it that it conflicted with something else?. These are all added to https://canjs.github.io/next/doc/migrate-4.html. Which demos? @James0x57 and I did the recipes and TodoMVC and that sort of thing.. This is being punted.. - [x] Removing setting the constructor name since it is not used for anything.. I'm renaming this to \"Callback based routing\". The reducer part of this proposal is interesting, but I think the more important part is that a developer can react to a route change.  What if instead of passing an object that you reduce, you can just directly modify the route.data. I might switch the arguments in this approach. For example the above example could be written as:\n```js\nroute.register('/user/{id}', function(params){\n  route.data.assign({\n    id: params.id,\n    page: \"user\"\n  });\n});\nroute.register('/product/{id}', function(state, params){\n  route.data.assign({\n    id: params.id,\n    page: \"product\"\n  });\n}).\n```\nThis callback would be ran in a batch so the code shouldn't need to worry about having multiple set calls.. Might what to check if donejs needs this too on the APIs page. major is the branch.. Nice!. Can you submit this against the major branch? That's most likely where we'll make the change.. Yeah, rerun against the major branch. Sorry :( I should have specified this before.. There's a PR for this: https://github.com/canjs/canjs/pull/3840 . lgtm. ## Issues to add\n\nMigrate all of the example apps to 5.0\nMigration guide\nAdvanced setup guide (using packages)\n\nImmediately after\n\nAll docs use ES imports\nWebpack stache plugin. I think having a separate core build makes sense. However this does mean we need to have a core.js and an ecosystem.js like we used to have. Then the can.js would just re-export all of those things:\n\njs\nexport * from \"./core\";\nexport * from \"./ecosystem\";\nexport * from \"./legacy\";\nI'm lukewarm about adding a minified build. Projects minify their own stuff. It would only be useful if you were using native modules in production.. We can do it. I don't really buy that argument though, if they don't care about performance then why do they want a minified version.. It's out \ud83c\udf86. @justinbmeyer is this something we still want for 5.0? If so I'll need a refresher on what this is.. Couple of other nice-to-haves:\n\n[x] {{log}} to {{console.log(this)}} seems easy.\n\n[x] - DefineMap.extend({ prop: { value: 'foo' } }) to DefineMap.extend({ prop: { default: 'foo' } }). Seems a little hard, can't just assume that we can replace any instead of value:, would want to check when explicitly extending a definemap.. More feedback in https://github.com/canjs/canjs/issues/3781#issuecomment-360793619 and https://github.com/canjs/canjs/pull/3863. Thanks! I'll merge in the morning and expand on this a little.. I've cherry-picked your commit into https://github.com/canjs/canjs/pull/3860 and will be merged there. Thanks again!. @Sinjhin couple of notes on the gif:\n\n\nDo you think you could do it again without the install? I don't think that's necessary since we go over that in the guide and it makes the video longer. I think just typing the command and then running it and then doing a quick  git diff would be a good length of time.\n\nI notice there's some parser errors shown. Do you know what those are about? Any chance you could make those go away?\n. This was released.. There was a package that was missing can-types that I updated this morning. Could you have an old lockfile?. It was can-stache-bindings, fixed in 4.0.4. See if you have that version.. I think this is out-of-scope for canjs. DoneJS can have (and does have) opinions on how to style. But I also think DoneJS has to be pretty conservation about these kinds of things. These libraries are somewhat popular in React, but even create-react-app doesn't support them out of the box (i believe it supports css, sass, and css modules as options).\n\nYou should be able to use these libraries in a canjs app already; as you say they produce class names so you should be able to pass those into you template through the view model if you choose to go this way.. Thanks!. What change are you requesting be made?. You could wrap your conditionals with the comments :/. Import options:\njs\nimport {DefineMap, DefineList, superMap, set} from \"can\";\nvs.\n```js\nimport can from \"can\";\ncan.Component ...\n```. Tested this out and if you have a module like:\n```js\nimport { Component } from 'can/es';\nconsole.log(Component);\n```\nWhere can/es looks like:\n```js\nexport {\n    default as connect\n} from 'can-connect/all';\nexport {\n    default as DefineMap\n} from 'can-define/map/map';\nexport {\n    default as Component\n} from 'can-component/es';\n```\nIt will tree-shake out can-connect. Notice that the can-component module is can-component/es. It looks like this:\n```js\nimport Component from './can-component';\nexport default Component;\n```\nWe need to add these wrapper modules to all of the projects that we want to include in can/es. We also need to add \"sideEffects\": true to the package.json of these projects.. 1. It doesn't include can-set. Not sure about can-util types of things, as I don't know what can-connect uses that others do not.\n2. No, only the modules that are imported by can/es would need the wrapper es module.\n3. below\n  i. I don't know of a technical requirement at this time, I don't plan on making the wrapper a requirement but perhaps there is a good reason, will have to wait until I add it to steal-tools to know.\n  ii. It's an opt-in that a package can be tree-shaken, since import { foo } from 'pkg' could cause code to break if tree-shaken if importing causes needed side-effects.. I don't understand your question, can-component is also not an ES module. Why are you surprised by can-util/foo but not can-component?. I just tested and the wrapper modules do not need be in the separate packages. So if we wanted we could add (within canjs) a es/component.js that acts as the wrapper:\n```js\nimport Component from 'can-component';\nexport default Component;\n```\nOr shortened to:\njs\nexport * from 'can-component';. It doesn't actually tree-shake the CJS module, it tree shakes the ES wrapper.  Think about it like this, you have code:\napp.js\njs\nimport { Component } from 'can/es';\ncan/es.js\njs\nexport { default as Component } from 'can-component/es';\nexport { default as connect } from 'can-connect/es';\nWhen the tree-shaking occurs the latter gets treated as if it were:\njs\nexport { default as Component } from 'can-component/es';\nAt this point it doesn't need to understand the CJS modules of can-connect, it's like it was never even imported.. This is actually really good news because it means we don't have to rewrite everything into ES modules. The question becomes should we:\n\nCreate wrapper modules in each package, ie create a can-component/es that just reexports the CJS source.\nCreate the wrapper modules in canjs/canjs. This prevents needing to spread this feature into each package.\n\nArgument for (1) would be that it makes it easier for people that use the individual packages to still get benefits of tree-shaking.. @justinbmeyer No, I'm not talking about adding granular exports for packages. I'm just talking about enabling people to get the benefits of tree shaking even if they are not using can. For example, this module:\n```js\nimport Component from 'can-component';\nimport connect from 'can-connect';\nconsole.log(Component);\n```\nDoesn't use connect, but it will still be included because it is a CommonJS module. However if the code was:\n```js\nimport Component from 'can-component/es';\nimport connect from 'can-connect/es';\nconsole.log(Component);\n```\nThen connect would be removed. It's the same deal as this where the wrapper is needed to get tree-shaking.. What happened with this, decided not to do it?. lgtm. \ud83d\udc4d . This is in the migration guide now, add-global docs are here: https://canjs.com/doc/can-event-dom-enter/add-global/add-global.html. I never do this as it makes testing harder (have to create an element in tests). On the somewhat rare cases where you might want to, as you said, connectedCallback can allow you to add it. Are you wanting it on the viewmodels automatically?. On swapping parameters:\nThe example shows:\n```js\nconst Todo = DefineMap.extend({...});\nfunction toParams(query){\n  var where = query.filter;\n  delete query.filter;\n  query.where = where;\n  return query;\n}\nfunction toQuery(params){\n  var where = params.where;\n  delete params.where;\n  params.filter = where;\n  return params;\n}\nvar TodoQuery = new Query(Todo, toParams, toQuery);\n```\nIf the conversion functions were the 1st two arguments you could use .bind() to create your own Query type:\nmyquery.js\n```js\nfunction toParams(query){\n  var where = query.filter;\n  delete query.filter;\n  query.where = where;\n  return query;\n}\nfunction toQuery(params){\n  var where = params.where;\n  delete params.where;\n  params.filter = where;\n  return params;\n}\nconst MyQuery = Query.bind(null, toParams, toQuery);\nexport default MyQuery;\n```\ntodo.js\n```js\nimport Query from './my-query';\nconst Todo = DefineMap.extend({...});\n// conversion functions are bound to Query so no need to pass them.\nvar TodoQuery = new Query(Todo);\n``. @justinbmeyer The problem I was attempting to fix is having to provide that to every Query that gets made. Since it's the same (likely) for an entire application it would be nice to be able to bind it. It wouldn't be a problem if there was aFunction.prototype.rbindor something. I guess people can use [_.partialRight`](https://lodash.com/docs/4.17.5#partialRight).. This is in 5.0-pre, so closing this issue.. Don't forget https://github.com/canjs/canjs/pull/4085 as part of this.. # ES module options\nThe goal here is to make it possible to import parts of can from a single import statement, like so:\njs\nimport { Component } from 'can';\nThe question this issue is trying to resolve is:\n\nWhat should can consist of? Everything or just core?\n\nOption A: Retain separate can and can/all (and can/ecosystem) modules\nIf we make can only include core, then it's everything that people are most likely loading in their apps today anyways.\nAdvantages\n\nPrevents loading a bunch of stuff you are likely not using.\n\nDisadvantages\n\nImportant, but not core packages like can-connect would not be included, so you would need to do import { connect } from 'can/all'; to get it.\n\nFor example, if you wanted to import can-zone you would do:\n```js\nimport { Zone } from \"can/all\";\n// OR\nimport { Zone } from \"can/ecosystem\";\n```\nOption B: Bundle all of can together\nIf we were to create an ES module bundle that contains all of there's less concern about load times.\nAdvantages\n\nOnly 1 file to load for can prevents waterfalls.\n\nDisadvantages\n\nAdded complexity when developing can, should you be building all of the time?\ncan/all is quite large so the bundle itself could be quite large.\nstealjs/transpile doesn't currently support transpiling to ES modules, so this would have to be added first.. Update, we are attempting to go the import/export core+ecosystem route. For bundlers with tree shaking this doesn't present much of an issue. It does present an issue for steal. So to start I'm going to spend a little time trying to implement https://github.com/stealjs/steal/issues/1381. This is in major now.. @thomaswilburn Great work! If tests are passing I say just go ahead and start making pull requests in each repo.. Done by https://github.com/canjs/canjs/pull/4207. Fixed by https://github.com/canjs/canjs/pull/4207. I created a smoke test that has a basic app that's built with webpack. It's here: https://github.com/canjs/canjs/tree/major/test/builders/webpack\n\nIdeally we would run all of the canjs tests through webpack, but many of them depend on steal.. Currently there are probably no safe modules, given that all of the canjs tests use steal-qunit. Would first need to create a clone of that for webpack.. @rjgotten There's nothing that needs to be transpiled in canjs packages. The src/ contains plain CommonJS written in ES5.  The reason why our main is some times wrong is because the projects were created with donejs add plugin foo which sets the main to dist/cjs/foo.js, but we don't need to transpile to commonjs.. I mean that you would need to write a webpack plugin (which I don't know how to do) that makes it possible to include steal-qunit, since all of our tests use steal-qunit.\nI would probably wait on doing this. It would be quite a task. I would just focus on adding the if(process.env.NODE_ENV !== \"production) { stuff.  . @macku Would you mind transferring your project to the canjs org?. Yeah, just by using modules.. * [ ] - Use { filter: query } with getList().\n* [ ] - Change usage of scope.root to scope.vm.. This is done: https://canjs.github.io/next/doc/migrate-5.html. I guess it might... what other side-effectual modules are there that we don't want to be turned on by default?. I guess we shouldn't do this.. @justinbmeyer let's discuss in can-route-pushstate if you are proposing changing its API. I'm not sure what you mean by calling it... it returns an object currently.\nSo we should discuss if, for example, breaking it is worth it just for the sake of inclusion here.. Thanks! Why is ~ not needed now?. Fixed by https://github.com/canjs/canjs/pull/4205. Still up in the air what builds will be, what they will be called, etc.. @justinbmeyer have you came to a conclusion on this? Build is ready to go, just a matter of naming.. Fixed in #4224. can-debug is another: https://github.com/canjs/can-debug/issues/46. To register side-effectual helpers you would do:\n```js\nimport { stacheRouteHelpers, stache } from \"can-stache\";\nstache.addHelper(stacheRouteHelpers);\n```\nHowever, we have several examples that import these into the templates like so:\nhandlebars\n<can-import from=\"can-stache-route-helpers\" />\nSo the question is:\n\nShould can-stache-route-helpers be self-registering itself?\nIf not where would the registration happen?. I don't think this would work, \n\nhandlebars\n<can-import from=\"can-stache-route-helpers\" value:to=\"scope.helpers\"/>\nWould replace scope.helpers with export of can-stache-route-helpers. What if you import multiple helpers.. That's pretty user unfriendly imo.. To make addBindings work I'm going to add a Symbol.for(\"can.stacheBindings\") that can-stache will use. This is because can-stache-bindings already exports stuff. So the user can either do:\n```js\nimport { stache, stacheBindings } from \"can\";\n// Yuck!\nstache.addBindings(stacheBindings.bindings);\n```\nSo to make \n```js\nimport { stache, stacheBindings } from \"can\";\n// Yuck!\nstache.addBindings(stacheBindings);\n```\nWork I'm going to have can-stache check for a symbol.. https://github.com/canjs/can-reflect/pull/119 is the cause. Haven't figured out why yet.. Fixed in #4224. We're going to make can-stache-bindings be non-breaking.. Can you back up the call stack a little bit and figure out what is attempted to be set?. Any chance you go throw this in a glitch or jsbin or something? . My guess is that deps bundle probably isn't the cause, I bet the tree-shaking is not able to handle the multiple levels of re-exporting that I added.. Yeah, so it happens without the deps-bundle. Tree-shaking almost definition the problem here, still investigating.. Yeah, so currently everything from the 'can' module gets tree-shaken because we don't take into account re-exporting as \"using\" a module. \ud83d\ude04 \nSolution here is to recursively look up to parents until we find something that is importing, not exporting.. Turns out major was pinned to steal pre.1. When I updated it to latest the demos work now (with deps bundle being used).  https://github.com/canjs/canjs/pull/4226\nI went ahead and made a test case for the new structure that will be in place once #4224 is merged. So I'll have that in case something breaks there.. Fixed by #4226 . Notes from an earlier brainstorming session:\n```\n- run build \n- test FF test/index.html \n- test FF production.html \n\n\nMAJOR webpack smoke and tree-shaking \n\n\ntest development sauce labs \n\nglobal build test\n\n\n\nbuilds * browsers\ndevelopment \nsteal in prod \nglobal \nwebpack in prod \nmjs build\n\nLocal FF\nSauce Labs( integration test using steal to load all subproject tests in development)\nSauce Labs( todomvc and different DIST builds test)\nSauceLabs( production tests and production build )\n``. Avoid minifying in CI, it takes a while.. I guess https://github.com/canjs/canjs/issues/4233 won.. Fixed in #4232 . Concern here is that converting back to a single repo would take a long time. Converting to individual repos took *forever*, and probably had a negative impact on canjs 3's success.. Perfect use case for submodules!. Alternatively we could just not include can-route-pushstate in can/can. I'm happy to go with the constructor route described in that issue though.. This is fixed with can-route-pushstate@5. can-event-queue is kind of a special case like can-define, so need to do something similar there. I can do that one.. can-event-queue warning is fixed.. @rjgotten I don't think that's possible in JavaScript if you expect to internally be able to dothis.foo`. You could however do this yourself like so:\n\n```js\nconst PrivateStuff = DefineMap.extend({\n  priv: \"string\"\n});\nconst privates = new WeakMap();\nconst PublicStuff = DefineMap.extend({\n  init: function(){\n    privates.set(this, new PrivateStuff());\n  }\nprop: {\n    get: function() {\n      let privateStuff = privates.get(this);\n      return privateStuff.priv;\n    }\n  }\n});\nmodule.exports = PublicStuff;\n``. @rjgotten If you're not looking for actual private properties then the normal JavaScript conventions such as underscore property name should suffice, no?. Nice! \ud83d\udc4d . Why should we do that? If people are already changing the URL why can't they change it to core.js / ecosystem.js as well?. People *should* change their URLs though.https://unpkg.com/can/dist/global/can.jsnow redirects to a URL that is possibly not compatibility with their code. If we wanted to avoid breaking compatibility with that URL we should include a can 4 version of canjs indist/global/can.js.  But that would be a maintenance nightmare.. @phillipskevin does this interfere with the CI stuff?. Want me to look into this?. Good catch. We just need to do something like we do in https://github.com/canjs/canjs/blob/master/es/can-define.js to export from subdirectories.. That module isn't documented. I'm not sure if that's intentional or not. cc @phillipskevin @justinbmeyer . Are you sure that's true? When you install a new package you might need to run force again. cc @justinbmeyer who'd know for sure.. @mikedane this is yours?. Cool, let's merge when it passes \ud83d\udc4d . lgtm. Yes it did. I possibly caused this when I fixed a tree-shaking bug. Try with steal-tools 2.0.4. Or I can take a look tomorrow.. This is caused because can-simple-dom doesn't have a default export, but everything uses it like it does. This works with steal but doesn't transpile correctly. Going to fix in can-simple-dom.. This was fixed in can-simple-dom.. Yeah, that would be my guess.  We use rollup to create those modules. I think settingtreeshake: false[here](https://github.com/stealjs/steal-tools/blob/f4b9e4936a877f4030495cf636cfb6ce17252661/lib/bundle/concat_source_es.js#L23-L30) might prevent that.. Are the limitations documented? I assume that \"simple setters\" means that there are some.. @leoj3n It's not super friendly to comment on issues about how old the issue is or to ask why it hasn't been merged/resolved. If something hasn't been merged/resolved it's because the maintainers of the free piece of software were working on other things. . @frank-dspeed We pin the version numbers in canjs on purpose, so we always know the package is stable. If you want latest you can use the individual packages directly.. Could be a steal bug.. @MarcGodard There was indeed a steal bug related to tree-shaking and the build that I fixed yesterday. If you could try updating to the latest steal version this might be fixed now.. The bug was in steal, not canjs. Do you have steal2.1.7. I worked with Marc on this. This was fixed by a steal release.. Worker rendering didn't do diffing. It recorded dom mutations like incremental rendering does.. Why use can-simple-dom and not just create some real DOM nodes that are not inserted into the page?. Yay, passing!. Replaced by https://github.com/canjs/canjs/pull/4687. es/can-define is not meant to be used directly. Is that what you are trying to do?. What problems did you find with tree-shaking core.mjs?. Closing in favor of https://github.com/canjs/canjs/pull/4677. Replaced by https://github.com/canjs/canjs/pull/4686.. What do you mean when you say it doesn't work with tree shaking? What does work exactly?. Is there a concept within can-crud of a view being \"finished\"? On create/update it just returns to the previous screen (read / list) correct? I'm trying to figure out how much can-crud will play into application orchestration. I'm leaning towards believing that it only provides information (state) to the larger program but does not drive it.. Thanks @davidkpiano. I had researched a little and came [across this](http://blog.efftinge.de/2012/05/implementing-fowlers-state-machine-dsl.html) which inspired the above idea. I hadn't seen P though! I'll definitely learn more about it. One constraint I'm trying to operate in is that the DSL should be simple enough for non-programmers to use it, I'm not sure how achievable that is though.. That would have a different effect than his code. A number like1.2would then pass (which may be ok).\n. You're right. Valid values are\"\"or\"true\", will update.\n. Since this is a little more complex (By default an element is contenteditable if it's immediate parent has the attribute not set to false), should I put a helper function somewhere others can use? can/view/elements perhaps?\n. You should use can.addClass instead: http://canjs.com/docs/can.addClass.html\n. I was thinking that we are registered for both but was wrong, can is that other canjs.  I'll set it back.\n. oops, need to remove thiswindow.promise, was during testing.\n. I don't know, I did because it seemed like if a case is already found at this point there is no reason to evaluate the value here. We can still talk about it though.\n. I wouldn't use the<>as this is an attribute, not a tag.\n. There's another line that needs this.\n. This one: https://github.com/bitovi/canjs/blob/rename-as-1966/view/stache/intermediate_and_imports.js#L36\n. UsegetElementsByTagNameorcan.$instead here.\n. should this be can-compilify?\n. I don't think checking for catch/fail is right as this is not a required to be a Promise.  This is probably the way to do it: https://github.com/then/is-promise/blob/master/index.js\n. Not sure, wondering what scenario it is a function.  Should this work with jQuery's deferreds?  If so I'd make sure that it does (think it should)\n. Make this be!!objso it returnsfalsewhen providedundefined`. This function should always return a boolean.\n. This changes the behavior of isDeferred. If it's going to be deprecated it should have the same behavior until it is removed.\n. I don't get it, what does this do exactly?\n. Even though it is more correct to do it this way, I would just use System.import for simplicity.\n. I would just say Preparation. maybe if there becomes a can 4.0 and you still want the migrating to 3.0 guide to work.. I'll go with the former.. I think it's always good to add links though, don't you think? I think the wording could be changed to be more non-specific.  such as a DefineMap. ",
    "taai": "Just download the .zip file from http://canjs.us/ and use the can.jquery-all.js file! Then call this:\njavascript\nvar Create = can.Control({});\nI did copy that file contents and this script in this JSBin: http://jsbin.com/ekaxid/1/edit\nTo see the error click on \"Console\" to open the \"Console\" pane and then click on \"Run with JS\" to run it again and generate the error.\n. I'm glad to have your attention. Read the issue #2379 !\n. @justinbmeyer Alright... Do you accept that it is needed? Do you want me to implement this and make a pull request? Which branch should I use as a base for changes \u2013 \"master\"?\n. @pYr0x Please have a look at my pull request! I hope that's that simple and I'm not misunderstanding anything...\n. @pYr0x By the way, in the pull request it did the Travis CI test and it failed... But that's not because of my code. It fails randomly this test:\nhttps://github.com/canjs/can-stache/blob/master/test/stache-test.js#L2901\nIf you run tests again, it should pass the tests... I suspect it has something to do with setTimeout. Maybe the second setTimeout should be called from inside of the first setTimeout, because browsers doesn't guarantee the execution order of callbacks set with setTimeout? Proof:\n- https://nodejs.org/api/timers.html#timers_settimeout_callback_delay_arg\n- http://stackoverflow.com/questions/1776239/are-equal-timeouts-executed-in-order-in-javascript/1776684#1776684\n. ",
    "adrianmaurer": "I saw this being resolved in 1.1.3 but when I tried updating my code by removing the model callback, \"data\" is not returned and is undefined. I am wondering if the original suggestion is what was actually implemented or the above comment from @daffl would be the proper way? It is a nice suggestion since the code looks nicer as well without the model callback.\njavascript\n...\ncan.view('js/view/lineup.ejs', {\n    stories:  StoryModel.findAll( {section: section.name}, function (resp) {\n        console.log('resp', resp);\n        //the resp is a dependent for a story lookup. Update the sections observeable to fire the call for a lineup story\n        $APP.CURRENT_SECTIONS.attr(section.name, resp); \n    }),\n    lineup: section.name\n} ).then(function (frag, data) {\n    console.log('data', data); //<- undefined\n    $('#section'+k).append(frag);\n});\n...\n. So the problem occurs only when you don't use the render method.\nDoes not work.\njavascript\ncan.view('js/view/lineup.ejs', { ...\nDoes work.\njavascript\ncan.view.render('js/view/lineup.ejs', { ...\n. We made a fiddle to demonstrate this. Looks like the deferred is called with an ajax but not the model. \nhttp://jsfiddle.net/mattseburn/vTnDS/1/\nWe aren't doing any cross domain requests. It was actually a coincidence that we noticed this behaviour because a local apache proxies wasn't set up.  But it would be nice to know if a JSONP requests possible with can.Model to inspect the response?\n. We made a fiddle to demonstrate this. Looks like the deferred is called with an ajax but not the model.\nhttp://jsfiddle.net/mattseburn/vTnDS/1/\n. ",
    "basememara": "I can confirm there is a problem with this too and the data indeed comes back undefined. Stepping thru the code shows that the correct data values does get passed back to the callback function, but I think jQuery deferred functions take over and the data is no longer in scope by the time it gets back to you?\nThanks for the discussion on this. This addition does make code flow much more smoother.\n. I just saw the same thing: http://jsfiddle.net/basememara/j9XSw/6/\n. ",
    "stevenvachon": "I am interested in this feature. Has any work been done on it?  I am currently using randomized date tokens to differentiate between instances. I could use the undocumented _cid, but that poses an issue with future-proofing.\n. I am interested in this feature. Has any work been done on it?  I am currently using randomized date tokens to differentiate between instances. I could use the undocumented _cid, but that poses an issue with future-proofing.\n. A path to \"path/to/can\" is still a good idea for shortening the paths to CanJS in our project files. I suppose, however, that it might be nice to remove it as a requirement by using relative paths in CanJS' source.\n. A path to \"path/to/can\" is still a good idea for shortening the paths to CanJS in our project files. I suppose, however, that it might be nice to remove it as a requirement by using relative paths in CanJS' source.\n. What would be the mistake in requiring 'can' relatively? The possibility of it being loaded in twice?\n. Hmm, what if I wanted to share some code that had define(['can'],function(){})? Same problem, I'd gather. Isn't this why we have package managers?\n. I hadn't thought about parent paths; they kind of smell; though, not sure like what : )\n. > Pray tell; how do parent paths smell more than hardcoded rooted paths requiring the mis-use of an explicit configuration flag that opens up the possibility of duplicate loading?\njs\nrequire(\"../../../../folder/file\");\nPretty smelly. You'd have to consult a file browser to know where you are and where you're going.\n. > Pray tell; how do parent paths smell more than hardcoded rooted paths requiring the mis-use of an explicit configuration flag that opens up the possibility of duplicate loading?\njs\nrequire(\"../../../../folder/file\");\nPretty smelly. You'd have to consult a file browser to know where you are and where you're going.\n. Safari 6.0.5\nAnd the ../ one was just a test to help find the source of the issue.\n. Safari 6.0.5\nAnd the ../ one was just a test to help find the source of the issue.\n. Yes, sorry for the confusion. Long story short, ignore this bug report. Thank you for looking into this.\n. Yes, sorry for the confusion. Long story short, ignore this bug report. Thank you for looking into this.\n. Wow! Awesome promptness! Thank you :) I'm anxious for the new version\n. Wow! Awesome promptness! Thank you :) I'm anxious for the new version\n. Multiple <script> templates within a single external file would still have to be parsed as separate elements.\nDoesn't can.view.mustache() just convert a string to a fragment before running other procedures?\n. Multiple <script> templates within a single external file would still have to be parsed as separate elements.\nDoesn't can.view.mustache() just convert a string to a fragment before running other procedures?\n. Hmm, interesting. I'll have to think about going back to <script> then. Performance aside (ugh!), <template> is more self-documenting and is prettier.\n. Hmm, interesting. I'll have to think about going back to <script> then. Performance aside (ugh!), <template> is more self-documenting and is prettier.\n. If the file is external, how would a <template> get processed if it's imported as just text and its contents are converted to a function?\n. If the file is external, how would a <template> get processed if it's imported as just text and its contents are converted to a function?\n. can.view(\"file.html\") does an ajax call\n. can.view(\"file.html\") does an ajax call\n. I've been chatting with @daffl and he's explained to me how the compiling process works, which I've been neglecting. As a result, I've been going down the path of organizing and grouping template files manually for a production environment. I had thought that <template> or <script> tags were required even if such files only had one template within.\nGot lots of reading to do. Thank you\n. I've been chatting with @daffl and he's explained to me how the compiling process works, which I've been neglecting. As a result, I've been going down the path of organizing and grouping template files manually for a production environment. I had thought that <template> or <script> tags were required even if such files only had one template within.\nGot lots of reading to do. Thank you\n. Where in the docs? http://canjs.com/docs/can.route.pushstate.html\ncan.route.pushstate.root = \"/contacts/\"; causes an error because can.route.pushstate is undefined.\n. Where in the docs? http://canjs.com/docs/can.route.pushstate.html\ncan.route.pushstate.root = \"/contacts/\"; causes an error because can.route.pushstate is undefined.\n. Are you sure it's the docs that are incorrect? With how perfectly you have designed everything else in CanJS, I would think you would prefer can.route.pushstate over can.route.bindings.pushstate. But then again, you're a better programmer than I am.\n. Are you sure it's the docs that are incorrect? With how perfectly you have designed everything else in CanJS, I would think you would prefer can.route.pushstate over can.route.bindings.pushstate. But then again, you're a better programmer than I am.\n. can.route.root() looks nicer to me, and even though it being a function might deter from overall consistency in the API, it's still much less so than with bindings\nBy the way, how would we toggle between pushstate and hashchange if pushstate.root were to use the default \"/\"?\n. can.route.root() looks nicer to me, and even though it being a function might deter from overall consistency in the API, it's still much less so than with bindings\nBy the way, how would we toggle between pushstate and hashchange if pushstate.root were to use the default \"/\"?\n. say my app is at /app/ and I instantiate my main class containing a can.route.ready(), it immediately adds a history index. If I click and hold the browser's \"back\" button, it has two list items for my page (identical URLs) when there should only be one. If I remove the can.route.ready() line, there is only one such item.\n. say my app is at /app/ and I instantiate my main class containing a can.route.ready(), it immediately adds a history index. If I click and hold the browser's \"back\" button, it has two list items for my page (identical URLs) when there should only be one. If I remove the can.route.ready() line, there is only one such item.\n. yes\n. yes\n. I can't recreate it in jsFiddle, but it works on my local apache server.\nI also can't seem to pinpoint where the index is being added because history.length never changes and history.state is always null. However, the browser's \"back\" button list menu clearly shows the extra index. Commenting out the can.route.ready() line and loading in a new tab will not add this index.\n``` html\n<!DOCTYPE html>\n\n\n\ntest\n\n\n\n\n            can.Control.extend(\n            {\n                init: function(element, options)\n                {\n                    console.log(\"before can.route.ready()\")\n                    console.log( can.extend(window.history,{}) );\n                    console.log(\"------------------------\");</p>\n<pre><code>                can.route.bindings.pushstate.root = \"/\";\n                can.route(\":something\");\n                can.route.ready();\n\n                console.log(\"after can.route.ready()\")\n                console.log( can.extend(window.history,{}) );\n                console.log(\"------------------------\");\n            },\n\n\n            \":something route\": function(data)\n            {\n                console.log(\":something route\");\n                console.log( can.extend(window.history,{}) );\n                console.log(\"------------------------\");\n            },\n\n\n            \"route\": function(data)\n            {\n                console.log(\"route\");\n                console.log( can.extend(window.history,{}) );\n                console.log(\"------------------------\");\n            }\n        })();\n    &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;&lt;/body&gt;\n</code></pre>\n<p></html>\n```\n. I can't recreate it in jsFiddle, but it works on my local apache server.</p>\n<p>I also can't seem to pinpoint where the index is being added because <code>history.length</code> never changes and <code>history.state</code> is always <code>null</code>. However, the browser's \"back\" button list menu clearly shows the extra index. Commenting out the <code>can.route.ready()</code> line and loading in a new tab will not add this index.</p>\n<p>``` html\n&lt;!DOCTYPE html&gt;\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\"/>\n        <title>test</title>\n        <script src=\"http://code.jquery.com/jquery-git2.js\">\n\n\n",
    "mindscratch": "Thanks, and yes 188 was correct.\nOn Tue, Dec 4, 2012 at 4:47 PM, David Luecke notifications@github.comwrote:\n\nI moved the description to the Third party extensions and pluginshttp://canjs.us/#plugins-third_party_extensions_and_pluginssection. Thanks again for contributing!\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/pull/188#issuecomment-11017147.\n. \n",
    "jawshooah": "Voting link appears to be broken, so I'll just toss my +1 in here. Specifically for .some() and .every().\n. Weird, it's definitely there. Try it out yourself on the Stache example I linked to. \n. Ah, my bad. Still, should this be happening in EJS and Mustache? It feels like a bug.\n. Not ecstatic about that, as we have a pretty extensive set of EJS templates that would take a lot of work to migrate to Stache. But I recognize that it's not a trivial bug to fix.\n. For that matter, there's no mention at all of can.Map.List.prototype.map in the docs.\n. Might be better for it to just return the argument. Maybe add a .clone() method that's just a wrapper for new can.Map(map.attr())?\n. Gotcha, so I was right in thinking that Controls are more flexible in terms of behavior.\nThe equivalent of this.options for a Component would be this.viewModel, right? And any attributes set on the top-level element become members of that object?\n. @justinbmeyer The app I'm working on currently has a lot of Controls that interact with each other. How could one Component interact with (e.g. invoke a method of) another?\n. ",
    "foxdonut": "Looks like this is already fixed: https://github.com/bitovi/canjs/issues/204\n. ",
    "roelmonnens": "We have a very large website.\nThis website contains several different modules.\nWe also have a header with some little applications in it.\nThis header is loaded in every module.\nNow for the little apps we use canjs 1.0.5. For a new module we are currently canjs 1.1.5 (the AMD-version). \nThe problem that we are having right now is that if I'm loading the topnav in the new module then the global can is being overridden with two versions of canjs. \nNo I was hoping that if I updated these little apps to an AMD version I could contain the version of canjs within the scope of that script. But if this isn't the case like mentioned above I have to rewrite these little apps so they can work without canjs because for future modules we want to use future code of canjs. But there isn't always the time to update the topnav to the new version and certainly is no time to update all old canjs-modules.\nBecause of this, I think it's better to remove can from the global scope.\nedit:\nwindow.GLOBALCAN = false; \nSeems to be working!\n. Yes but I'm not destroying any items. I get the error after adding two elements.\n. @daffl : the path in the jsFiddle is http://canjs.us/release/latest/ so I think I'm using the latest version.\nIn the fiddle if you click on a li then the color changes, if you click twice (not once but twice) on new and then click again on a li to change the color then you'll get an javascript-error.\n\nThis is with Google Chrome.\n. thnx @scorphus That really helped!\nWe really need the if to show a different image when no items are available.\nI was always strugling with if, .attr('length') and live-binding. But you're example is really good!\nI think we can close this!\n. .match() could be removed as it is just a simplified .grep() method.\n. Yes. I'v noticed.\nCan't we create our own can.grep function in other libraries based on the jquery.grep?\n. ",
    "xjailbreaker": "i mean that it should be very nice if CanJS core will implement its support for jqMobi in that way how that was done for jQuery, Dojo etc (can.jquery.js, can.dojo.js...)\n. ",
    "tracer99": "Edit: No. Routing hashchange event firing is now completely broken in Mootools + CanJS.\n. So, \nIn CanJS 1.0.7, can.bind.call(window,'hashchange', setState); was on it's own line unconditionally called if a route was created in can.route.\nIn CanJS 1.1.3 it's wrapped in a _setup function.\nThis function is called by the ready function which according to the documentation, http://donejs.com/docs.html#!can.route.ready , is there for you to manually set when you want hash binding to occur. \nSo calling either the private _setup method or can.route.ready(true); makes routing work again.\nNote, issue #124 was not fixed in 1.1 and still requires \nElement.NativeEvents.hashchange = 2;\nto work\n. Conversation in Forums about this issue: https://forum.javascriptmvc.com/#Topic/32525000001090143\n. Mootools more is not a 3rd party library. It's the UI portion of Mootools (like Jquery UI is to Jquery). It's just not included in the core because it's huge if you want it all. \nAs for why it's happening, I spent a day on this and didn't get far in figuring out why it was happening. The symptom is that event binding was not being properly unbound.\n. Arghh. It appears I made it worse. At this point my git skills have been exhausted.\n. https://gitter.im/bitovi/canjs?at=55e870c9d231aa8e5918fdbd Matthew agrees that this may not be the best solution either.\nTo have this fail in FF, simply change any of the tests you have already by replacing the key name with \"watch\" and it will fail in modern FF.\n. This was lost in the original ticket.\nFF has an internal function called watch.\nSo if you want to have a map with a property watch, map.attr(\"watch\") will fail.\nI solved it by using hasOwnerProperty in the attr function in CanJS. However, @matthewp was concerned that this approach would not handle inherited properties. \n. What was the resolution?. ",
    "spautz": "That was quick! Just tested locally with a fresh build, and it works perfectly. Thank you.\n. ",
    "ms": "(Same team here)\nActually we can't reproduce it with 1.1.3, but we are currently using 689ef7325b6890e9d317d5af4185798bc0d92c94. I don't know how to create a fiddle that'll steal that properly without specifying every single can file as a resource. \n. It's definitely linked to 0ddf3ea.\nOn line 38, after the view.render deferred is resolved, the result is piped which resolves the hookups. But wrapCallback calls pipe on the result again after that, but by then there are no $view.hookups and therefore no !!@@!! get replaced.\nIf the deferred is resolved first, the callback will get incorrect data, and vice versa. Currently it seems that the deferred is resolved first (lines 377 and 380) so the callback gets incorrect results.\nA simple minimal example that should break (I haven't tested it but I will if you need me to) is at this fiddle: http://jsfiddle.net/ePc8T/ (it doesn't here because 1.1.3 is not broken). Here is the code:\n```\ncan.view.ejs('view_deferred', '<%= value %>');\nvar def = new can.Deferred();\nsetTimeout(function () {\n  def.resolve('Hello can');\n}, 1000);\ncan.view('view_deferred', {\n  value: def\n}, function (fragment) {\n  $('#out-cb').html(fragment); // Incorrect frag with !!@@!!\n}).then(function(fragment) {\n  $('#out-then').html(fragment);\n})\n```\n. Nothing, it's just cleanup. The behavior should be exactly the same (hence the lack of new tests).\n. ",
    "fjanon": "Same page, at the bottom after \"Demos\", broken link for \"TodoMVC\":\nhttp://addyosmani.github.com/todomvc/labs/architecture-examples/canjs/\n. Very last word, same page, broken link for \"Source Code\"\nhttps://github.com/jupiterjs/todomvc/tree/gh-pages/architecture-examples/canjs\n. Same page: \"recieves\" -> \"receives \"\n. ",
    "JacopKane": "Thank you, worked like charm.\n. Sure but i couldn't figure out how can i test it with steal yet, maybe yours will be faster?\n. Okay thank you, i'll try it now.\n. Your welcome, yours is cleaner =)\n. ",
    "scorphus": "Also, please compare that fiddle with this one: http://jsfiddle.net/scorphus/2PNyJ/5/\nMaybe http://jsfiddle.net/Daff/2PNyJ/3/ shows the result of how the scanner works? Just thinking out loud...\n. I've been dealing with this issue for a few days and, after trying to come up with a solution and thinking about it, I've come to the conclusion that it shouldn't be fixed.\nFailed attempts\nThe following is what I've tried, in brief. Please excuse me if these changes are too subtle, they are just to back my point of view.\nA) Split the block caller and what comes before it:\nFirst, I tried to split the block caller -- a can.each call, a for loop or an if or etc. -- and all the lines that come before it. Considering a correct and simple template:\n``` diff\ndiff --git a/view/scanner.js b/view/scanner.js\nindex ccdffec..0bf3324 100644\n--- a/view/scanner.js\n+++ b/view/scanner.js\n@@ -326,6 +326,14 @@ Scanner.prototype = {\n                        // We are ending a block.\n                        if (bracketCount == 1) {\n\n// Try and split the block caller and what comes before it (simple regex just for demo)\nvar pos = content.search(/[^;\\n{]+[\\s]*{/);\nif (pos >= 0) {\nvar before = content.substring(0, pos);\ncontent = content.substring(pos, content.length);\nbuff.push(before);\n}\n+\n                            // We are starting on.\n                            buff.push(insert_cmd, \"can.view.txt(0,'\"+getTag(tagName,tokens, i)+\"',\" + status() + \",this,function(){\", startTxt, content);\n\n```\nActivate your console log and check http://jsfiddle.net/scorphus/6qpQp/ to see the result for a simple and kinda-fixable-by-this-attempt template. Note that it's still not what one would expect.\nB) Extract variable declaration (not definition):\nThen I tried to extract every variable declaration and place it before the block; but just the declaration. Extracting definition would be crazy given all the possible options. See:\n``` diff\ndiff --git a/view/scanner.js b/view/scanner.js\nindex ccdffec..51687e0 100644\n--- a/view/scanner.js\n+++ b/view/scanner.js\n@@ -326,6 +326,16 @@ Scanner.prototype = {\n                        // We are ending a block.\n                        if (bracketCount == 1) {\n\n// Try and extract variable declaration (simple regex just for demo)\nvar matches = content.match(/var[\\s\\n]+[^=]+=/g);\nif (matches && matches.length > 0) {\nfor (var k = 0; (match = matches[k++]) !== undefined;) {\nvar vname = match.match(/var[\\s\\n]+([^=]+)=/)[1];\nbuff.push('var ' + vname + ';');\ncontent.replace(match, vname + '=');\n}\n}\n+\n                            // We are starting on.\n                            buff.push(insert_cmd, \"can.view.txt(0,'\"+getTag(tagName,tokens, i)+\"',\" + status() + \",this,function(){\", startTxt, content);\n\n```\nActivate your console log and check http://jsfiddle.net/scorphus/CvnSe/ to see the result for a simple and kinda-fixable-by-this-attempt template. Note that it's still not what one would expect.\nConclusion (read \"my humble opinion\")\nThe scanner works the way it works in order to be quick. There is no need to parse the template, we can leave it up to the browser. So this leaves no space to do things such as A and B correctly for all possible syntaxes. There would be necessary to implement a proper parser to correctly extract variable definition or whatever comes before the block caller. And that would turn things unnecessarily slower and more complicated.\nAs suggested by Curtis, it's better and still fast to simply use %><% to separate such things, and to state this in the documentation.\n. Commit a4de909 was a typo, I'm sorry.\n. The error TypeError: update is not a function @ http://canjs.us/release/latest/can.jquery.js:3350 in this case is caused by double rendering of the same Observe. Both <% if(items.attr('length') > 0) { %> and <% list(items, function(item) { %> trigger live-binding for items.length and so the <li> elements sequence gets twice rendered each time that length is changed.\nTo correctly use live-binding in this example you can, for example:\n- Remove the if statement\nIn this very example the if is unnecessary and can be eliminated:\nerb\n<script id=\"dummyEJS\" type=\"text/ejs\">\n    <%# if(items.attr('length') > 0) { %>\n        <% list(items, function(item) { %>\n            <li style=\"background-color:<%=item.attr('color');%>\" <%=(el)->el.data('item', item);%>><%=item.attr('name');%></li>\n        <% }); %>\n    <%# } %>\n</script>\n- Iterate over a copy of items\nBut if you really need the if, iterating over a copy will set up live-binding for each item and the color change will work:\nerb\n<script id=\"dummyEJS\" type=\"text/ejs\">\n    <% if(items.attr('length') > 0) { %>\n        <% list(can.makeArray(items), function(item) { %>\n            <li style=\"background-color:<%=item.attr('color');%>\" <%=(el)->el.data('item', item);%>><%=item.attr('name');%></li>\n        <% }); %>\n    <% } %>\n</script>\n. Awesome! Oh, let me try and add a test.\n. Thanks, @daffl! It's being pretty amazing understanding things and fixing these bugs =)\n. I've made use of valid HTML in test cases, pull request description and fiddles. Just to make it right.\n. I get ReferenceError: can is not defined if I run that in the console. So, I update the fiddle and there is the error message (in Firefox): too much recursion @ http://canjs.us/release/latest/can.jquery.js:30. Hope it helps with the bug_fix / cause_identification.\n. This issue is fixed in current master SHA: d33de3f8d26a59084ee140379c5465891b1d8106 and that example can be seen working in this fiddle.\n. Update: my bad, it's still an issue, but it looks like an issue with can.observe.attributes: http://jsfiddle.net/scorphus/KdVa5/3/ (includes can.observe.attributes.js)\n. One can see the issue here: http://jsfiddle.net/scorphus/a2b3S/2/ (I've just added a link and its click handler)\nI'm looking into this one.\n. ",
    "markalanevans": "For now, I have just been double declaring my variables in each block. As its the only way around it. @justinbmeyer  any thoughts?\n. @ccummings  thanks. I will give that a shot. \n. Fair enough. I don't mind doing it at all, but definitely add it to the docs, this can easily cause a developer hours of confusion.\nThanks Scorphus for diving into this.\n-Mark\n. ",
    "pmccartney": "Is this referring to  \"NOT_FOUND_ERR: DOM Exception 8\" ?  I was about to post a bug about this.  Here is what I have seen;  Given a model with attr 'name' and a proto function isLoggedIn(), handing it to the following mustache file, this will cause the exception.\n{{#isLoggedIn}}{{name}}{{/isLoggedIn}}\nCan.js : line 5872\nSame error in FF:  \"Not Found Error: Node was not found\"\n. This is actually a pretty major issue as you can't even do simple bound lists with mustache. Even #each doesn't work.\n{{#users}}{{name}}{{/users}}  or\n{{#each users}}{{name}}{{/each}}  fails\nWho decides when this should be labeled a bug?\n. Yes.  Sorry, it is.  At least for the cases I am running into.\n. Works great!  All the work that has been put into this is incredible.\n. ",
    "jbmillini": "Ignore this comment.  Apologies about the spam.  Testing our community page.\n. ",
    "airhadoken": "Eep.  I also used {{^if ...}} in the test for #292 (it passed, though).  Would you mind boyscouting that if you are working near it?\nhttps://github.com/bitovi/canjs/blob/master/view/mustache/test/mustache_test.js#L1342\nThanks.\n. I keep coming back to the idea that the stack should become a subclass of can.Observe which implements push and pop.  attr() as an accessor would return the first matching attribute by name.  Where it would make sense, other function calls (e.g. bind) would pass through to the current head of the stack.  Do you think this would be workable, @andykant ?\n. :+1:\n. The clone() function in #435 will work in the place of can.extend as long as you don't expect instances of the same classes -- the library creates a Clone subclass of each class to add the merge() operation. Just pass true as an argument to Observe.prototype.clone to effect a deep copy.\n. Definitely awesome, @justinbmeyer , and definitely worth checking out.  However, the other situation I was working on was a tab list that uses float:left.\n. It was happening in /reciprocity/ggrc-core until we applied the fix, but I am having trouble distilling the problem down into a simple fiddle.  I think it might be in part due to us overriding can.Model.model.\n. :+1: I've found this to be an annoyance when I just want to output <div data-view-id=\"###\"> and forget to triple-brace the Mustache token.\n. The behavior of Mustache with helpers is bizarre because I can do {{#some_helper}}{{/some_helper}} and return HTML (usually just a hook) that gets added to the DOM properly, but if I do {{some_helper}} instead it gets escaped.\nNote that I fully support escaping HTML by default when dealing with static properties or compute/function return values; I just feel like helpers should get the final say over whether they trust their output.\n. ",
    "marshallswain": "I know the documentation needs some work.  What else needs to be done?  It's working quite awesome for me in my projects, now, but I did have to prepend my routes in the controllers with a forward slash /.  I played around with removing the forward slash, but it messed up the URL in the address bar whenever they were more than one level deep.  I'll work on getting it to work without changing the controller routes.  \nAnything else you can think of?  \nHave a great day!\nMarshall Thompson\nCreative Ideal\nOn Wednesday, January 23, 2013 at 3:41 PM, David Luecke wrote:\n\nCool, thanks for the pull request. Hopefully we can make this plugin officially a part of 1.2. You definitely got it a step closer :)\n\u2014\nReply to this email directly or view it on GitHub (https://github.com/bitovi/canjs/pull/249#issuecomment-12626952).\n. Added lots more documentation for using pushstate.js with can.Control.route\n. Is it possible to listen to two routes in on one function, or in other words two route selectors in the same function name... something like the example routes, below.  \n\n```\n\"/routeone route, /routetwo route\": function(data){\n  // /routeone and /routetwo are both handled here.\n}\n\"/routeone, /routetwo route\": function(data){\n  // /routeone and /routetwo are both handled here.\n}\n```\nObviously these don't work or I wouldn't be asking.  Maybe the feature is there and I just don't understand the syntax?  I know this works for other event listeners to separate them by commas.  If it is the case, this fix isn't enough to handle multiple routes, but will at least handle the first.\nAlso, I've not tried testing this out with hash-change routing.  I HAVE tested push state routes with a custom build of can that includes all options in the download builder.  I also tried using only the below scripts and was able to find a \"fix\" in can.Control.route.\n<script src=\"/can/can.jquery.js\"></script>\n<script src=\"/can/can.route.pushstate.js\"></script>\n<script src=\"/can/can.map.delegate.js\"></script>\n. @justinbmeyer I didn't even realize I could take the slashes out until just now.  When pushstate.js first showed up on the forums I played with it and at the time it required the beginning slashes.  I had tried it without slashes, but it still wasn't working for me.  Now I realize that it was because of the folder structure headache that I \"discovered\" and put at the bottom of the documentation.\nI just tried the routes without the beginning slashes.  They work both with and without the change to can.Control.route.js.  With the edit I made, they work either with or without slashes.\nDefinitely need to include a check for the pushstate.root instead of /.\n. definitely. +1\n. That is awesome.  Thanks.\n. I've been treating it as though it were dead.  It felt like that writing was on the wall somewhere.  I even moved my older projects to Mustache.\n. I just noticed that it says \"undefined updated\".  I've been reading \"undefined update\" (without the d).  So this is probably referring to the updated event?\n. Here is a copy of my custom model that's producing the error:\nvar User = can.Model.extend({\n    id: '_id',\n    findOne : function(params){\n        return can.ajax({\n            url: '/api/users/me',\n            type: 'GET',\n            dataType: 'json',\n            data: params,\n            headers: {\n                Authorization: me.auth.token\n            }\n    });\n    },\n    update : function( id, attrs ){\n        return can.ajax({\n            url: '/api/users/me',\n            type: 'PUT',\n            dataType: 'json',\n            data: attrs,\n            headers: {\n                Authorization: me.auth.token\n            }\n    });\n    },\n}, {});\nAnything look obviously out of place?\n. Thanks. @justinbmeyer.  I know better.  I plead temporary insanity.\n. Found it.  Yep, I'll submit a PR to make that more clear for models without a shortName.\n. +1\nhttps://github.com/bitovi/canjs.com/issues/177\n. I took some screenshots of what you're talking about.  There's also a proposed fix here:\nhttps://github.com/bitovi/canjs.com/issues/175\nThe css fix is super easy.  Haven't gotten around to finding out where the docco documentation is kept in order to fix it.\n. You may have guessed that my vote is cast for fix number 2.\n. You\u2019re right that the docco for UTIL.JS is useless in its current state. \u00a0Rather than removing it, though, I think it needs more content.\n. Is this what's keeping my can.view.attrs from working in partials?  They work in the built production site, but not in development mode.\n. I am importing them with  and they work in the main template\nbut not in the partials.\nOn Sat, Jul 25, 2015 at 2:05 PM Justin Meyer notifications@github.com\nwrote:\n\nMake sure you import your modules that define your custom attrs.\nSent from my iPhone\n\nOn Jul 25, 2015, at 1:38 PM, Marshall Thompson notifications@github.com\nwrote:\nIs this what's keeping my can.view.attrs from working in partials? They\nwork in the built production site, but not in development mode.\n\u2014\nReply to this email directly or view it on GitHub.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bitovi/canjs/issues/1159#issuecomment-124882339.\n. Can-import is in the main template. I haven't tried re-importing in the\npartial, yet.\nOn Sat, Jul 25, 2015 at 10:48 PM Justin Meyer notifications@github.com\nwrote:\nYour partials are importing them?\nSent from my iPhone\n\nOn Jul 25, 2015, at 11:46 PM, Marshall Thompson \nnotifications@github.com wrote:\nI am importing them with  and they work in the main template\nbut not in the partials.\nOn Sat, Jul 25, 2015 at 2:05 PM Justin Meyer notifications@github.com\nwrote:\n\nMake sure you import your modules that define your custom attrs.\nSent from my iPhone\n\nOn Jul 25, 2015, at 1:38 PM, Marshall Thompson \nnotifications@github.com\nwrote:\nIs this what's keeping my can.view.attrs from working in partials?\nThey\nwork in the built production site, but not in development mode.\n\u2014\nReply to this email directly or view it on GitHub.\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bitovi/canjs/issues/1159#issuecomment-124882339.\n\u2014\nReply to this email directly or view it on GitHub.\n\n\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bitovi/canjs/issues/1159#issuecomment-124945721.\n. That worked.  Funny how I didn't try the simplest fix. \n. After looking at this some more, it's the second line that's throwing me off.   \nThis is not the same as calling setting a property with plain old attr and passing an object into a property that was already a can.Map, which will merge the new properties with the existing map.\n\nIf you have an existing map:\njs\nvar contact = new can.Map({\n    'info' : {'breath' : 'smells like roses'}\n});\nAnd you pass an object into the 'info' property on this already-existing can.Map:\njs\nvar newInfo = {'teeth' : 'shiny and clean'};\ncontact.attr('info', newInfo);\nThen the end result is that the 'info' attr has been completely replaced:\njs\ncontact.attr('info')\n{'teeth' : 'shiny and clean'}\nI think that it would be best to remove that line and leave everything else.  It seems the clarification in that line would only be needed if one is thinking of each of the attributes inside the define object as individual can.Maps instead of attributes of the parent can.Map.\n. Woah.  That's handy.  I wasn't aware of being able to do that.  Is that specifically documented anywhere?  How does that even work when contact.attr('info') returns a standard object?\n. Thanks, @moschel.  That's nice and straightforward.\n. If you can sneak it into master, that would be awesome.\n. Dash docs can already be downloaded in the \"User Contributed\" section of the \"Downloads\" pref pane in Dash for OS X:\n\n\n. You can also get the docs onto Dash for iOS by side loading through iTunes.\n. As far as I can tell, there's not really a direct way to get user contributed docsets onto iOS.  It seems you have to first install them into a Dash-compatible desktop app, then open that app's Library/Application Support folder to extract the docs and copy them over.  \nTo simplify it for you I've put the CanJS docsets on my Dropbox if you need them: https://www.dropbox.com/sh/msxwpxrudpnv95a/AADjwQRAJNaC19w08Va4TCisa?dl=0\nOn a Mac, can you drop each folder directly into the Apps / Dash file window for your iOS device in iTunes.  I'm not sure if this will work in Windows having the custom .docset file extension being placed on a folder.\n. The three folders in that dropbox link ARE the .docset files, but when they sync to Dropbox they show up as folders.  Try opening the Dropbox link and right-clicking one of the folders to download it.  I think you'll end up with a zip file., but see what you get when you extract it.\n. It doesn't look like Velocity lets you download the user-contributed docsets.  Is that what you are noticing?\nUpdate: Ok, I just installed Velocity in my Windows virtual machine and noticed that it doesn't offer support.\n. It looks like the .docset file extension is a type of installer that puts the .docset folder into place in the Docsets\\Dash folder.  I tried editing Velocity's DocsetLibrary.json file and moving the CanJS.docset folder into place manually, but it resulted in a hard crash when I opened Velocity.  Maybe send off an email to the Velocity developer and ask him how you could use those docsets I've posted above?\n. It's for sure not deleting itself.  The other CanJS plugins are dependent on it being in place.  If I move the delete script up above any of the plugins, they fail with varying errors.  If I move the delete script before loading can.fixture.js:\n``` html\n    \n\n\n\n\n\n\n<script>delete window.define;</script>\n\n<script src=\"/bower_components/canjs/can.fixture.js\"></script>\n\n```\nI get the following error\n\n. I don't understand why each plugin is dependent on it, when each contains the same /*[global-shim]*/ that creates the define.\n. Which is the better practice: loading scripts from a widely-used CDN or bundling them into a larger libs file, say jQuery and CanJS and MomentJS in one file?  My guess would be that bundling would be best for creating an independent app, like a PhoneGap project.  General web apps would probably benefit more from using the CDN, especially once HTTP2 is in place.  Am I off base with my thinking?\n. > I don't understand why each plugin is dependent on it, when each contains the same /[global-shim]/ that creates the define.\nOh. Probably because it's now missing what appears to be a module cache in define.modules.\n. Yeah. \u00a0I didn\u2019t really anticipate finding more to edit. \u00a0I can look at combining them on Thursday or Friday. \u00a0I\u2019m just scanning docs in my spare minutes. \u00a0:)\nHave a great day!\nMarshall Thompson\nOn Tue, Mar 31, 2015 at 11:20 AM, David Luecke notifications@github.com\nwrote:\n\nThanks for submitting all the PRs! Do you think you can consolidate them all into one? I assume it's because of GitHubs inline editing that they are all separate right?\nReply to this email directly or view it on GitHub:\nhttps://github.com/bitovi/canjs/pull/1567#issuecomment-88177187\n. @daffl I've merged those Github GUI edits here. \n. Oops I must've done something wrong. \u00a0There shouldn't be any merge commits. \u00a0I thought I had reset the branch, pulled the latest commits, and removed the edits to the components guide (since the guide rolled back) then put the files back in place that I had edited. \u00a0That should have been in patch-9, I believe. \u00a0I'll see what I did when I get back.\n\nHave a great day!\nMarshall Thompson\nOn Thu, Apr 2, 2015 at 12:15 PM, David Luecke notifications@github.com\nwrote:\n\nWhere? I was looking but couldn't find another PR. Oh also, if you rebase them (git rebase origin/patch-6) you'll avoid all those merge commits.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bitovi/canjs/pull/1570#issuecomment-88997247\n. This file is probably the AMD-equivalent version of this one: https://github.com/bitovi/canjs.com/blob/master/steal/can/view/stache/system.js, a plugin for loading CanJS templates.  \n\n@daffl I've not used the AMD version. Should this line say imports.intermediate instead of mports.intermediate?\n. The 2.2 blog article is a good start. \nhttp://blog.bitovi.com/canjs-2-2/\n. Can you post a jsbin or fiddle that demonstrates what's going on?\n. That's basically what it was doing before.  Not having the return there was breaking our app, but only in production mode.\nThere's probably a better fix for the overall issue, but this at least provides consistent behavior in dev and production until it's worked out. \n. I'm not sure how to edit old documentation pages.  @daffl Can you shed some light on this for me?  The page used to exist at guides/utils.md, but was removed with 2ec8deec5bc4dd47998f82b4bd22a6895d36c5eb.  Do we still generate docs from source somewhere?\n. I've noticed this before.  I used a helper with triple curly braces {{{layoutStyles}}} to generate a dynamic style.\n. @whitecolor I think it's a really good idea.  I'm not sure how often I would use it, other than with the occasional tricky layout.  I agree that using the helper syntax isn't very fun, but it doesn't look quite as ridiculous when you use it in a component.  :)\n. Looks like you beat me to it.  Thanks.\n. I was able to duplicate this with the following example code.  If you remove the get() from the page's definition, the url no longer updates, even though the route does.\nI'm getting an error (can.jquery.js:1710 Uncaught RangeError: Maximum call stack size exceeded) when using can.route.map(mapInstance), but not when I use can.route.map(MapConstructor), so I've split it out into two separate can.Maps.\n``` html\n<!doctype html>\n\n\nJS Bin\n\n\n\n\n\n\n\n\n\n  {{#app}}\n    <h1>Pushstate Links</h1>\n    <a href=\"/first\">/first</a><br/>\n    <a href=\"/second\">/second</a><br/></p>\n<pre><code>&lt;h1&gt;These links change route attributes&lt;/h1&gt;\n&lt;a href=\"javascript://\" ($click)=\"setPage('third')\"&gt;Third&lt;/a&gt;&lt;br/&gt;\n&lt;a href=\"javascript://\" ($click)=\"setPage('fourth')\"&gt;Fourth&lt;/a&gt;&lt;br/&gt;\n</code></pre>\n<p>{{/app}}\n\n\n  var AppState = can.Map({\n    define: {\n      '*': {\n        serialize: false\n      },\n      page: {\n        serialize: true,\n        set: function(val){\n          console.log(val);\n          return val;\n        },\n        get: function(lastSetVal){\n          return lastSetVal;\n        }\n      }\n    }\n  });\n\n  var other = new can.Map({\n    setPage: function(newPage){\n      can.route.attr('page', newPage);\n    }\n  });\n\n  $('body').append(can.view('#demo', {app:other}));\n\n  can.route.map(AppState);\n  can.route(':page');\n  can.route.ready();\n\n\n\n``\n. @justinbmeyer, why shouldn't $value behave the same as can-value?  I'm not asking because I want it to.  I just want to know.\n. Sounds cool.  Did you make docs so I can see how to use it?\n. I encountered this same thing last night.  I set a class with a dynamic value on a component, but I wasn't trying to pass it in, just use it.  It worked as expected, but the error message confused me, so I back-tracked through all of the code I had written to figure out where I had done what it says.  I finally assumed it was from doingclass=\"{{result}}\"` on a few components.\n. Not in the JSBin: http://jsbin.com/ruvako/edit?html,js,console,output\nIt's simply\n{{names}}\n. Or right away if you install from github. ;)\n. select boxes are resetting.  So far it's only an issue with text inputs.\n. Checkboxes work as expected (they clear on reset): http://jsbin.com/hobolo/6/edit?html,js,output\n. I feel like it really helps me to quickly catch up on what actually makes\nit into each release. As an early adopter, I have a better idea of what to\nexpect when I keep upgrading to the latest version. As a bug reporter it\nhelps me feel like I have a better idea of what to watch for, or where to\nlook first when I encounter a new problem. So, I really appreciate the\ndetailed change log. I do try to read every issue that hits the repository,\nbut having this info all in one timeline is really nice.\nOn Thu, Feb 11, 2016 at 6:04 AM Matthew Phillips notifications@github.com\nwrote:\n\nDo we really need to be publishing patch changelogs? If it's any amount of\nwork to do I'm not sure it's worth it.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/canjs/canjs/issues/2253#issuecomment-182854738.\n. I forgot to add the check for the promise resolution.\n\n<can-import from=\"money-tracker/components/money-page/\">\n  {{#if isPending}}\n    Loading\n  {{else}}\n    <money-page></money-page>\n  {{/if}}\n</can-import>\n. Great catch!  Thanks for taking the time to fix it.\n. See https://github.com/canjs/can-stache-bindings/issues/229. This same fix has already been merged into the v3.0 repo here: https://github.com/canjs/can-view-parser/pull/9\n. That makes sense to me. I don't know why we are lower casing in the first\nplace.\nOn Fri, Sep 2, 2016 at 2:17 PM Justin Meyer notifications@github.com\nwrote:\n\n@marshallswain https://github.com/marshallswain why do we have to even\ntrack the caseMatters? Could we just stop toLowerCase()-ing what we get?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/canjs/canjs/pull/2420#issuecomment-244477426, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AAH3WUxNSY-vhM84Iv6_l3Cpf7nApEywks5qmIRUgaJpZM4I3mmv\n.\n. In the example:\n\nerb\n{{#if xyz}}\n<can-import from=\"somfile.less!\"/>\n{{/if}}\nIf xyz is true and those styles load, then when xyz becomes false, would removing that style-sheet remove the styles from the DOM?  Is it even possible to remove styles?  I've never played with it, at least consciously.  :)\n. Thanks, @pYr0x.  This would be super beneficial if the stylesheet did get removed after xyz is set back to false, again.  But I think it will just be confusing if it's not possible to strip a stylesheet from the browser.  This would be better handled by loading all css and using classes to apply styles.\n. I think we can wire something up with lunr.js.  We would only have to do some pre-processing to create a full text search index as a static file it (lunr.js) could download.  I haven't looked at it for a while, but it definitely looked do-able.\n. > Do we really want screenshots of the app? Or would company logos suffice?\nCompany logos won't (likely) expire like apps do.\n. Docs are here: https://github.com/canjs/can-connect-feathers/tree/2.0/_docs. I would just shorten it to the file name, so it would say 'real-time' and those who want the full module name can click on it to view its docs. Closing for https://github.com/canjs/canjs/pull/2922.  The can-connect and can-define updates need to happen together.. I just ran the tests locally and they all passed.\n\nOh, it's on specific Sauce Labs environments.\n- Windows 10 Firefox 49: https://saucelabs.com/jobs/cc7370a631d84331be537532e014b08a\n- Windows 10, Google Chrome: https://saucelabs.com/jobs/dbe4ccdb0f914ccdaa4b4f125ce662ef\n- OS X 10.11 safari 10.0: https://saucelabs.com/jobs/fd4e9664e8e8463ebc9d0c2b013ba486\nI'm just playing catch up here on how our test CI works.. Yeah, I'm on the greenkeeper/can-connect-1.0.20 branch.  I wiped out node_modules and reinstalled then  did npm run build then http-server and opened /test/index.html in Chrome.  I tried twice for good measure, and the tests always pass.\n\n. It's weird to me because it looks like it's Stache tests involving Map and List that are failing with the can-connect update.  I would have expected the same tests to fail with the latest can-define release.  This seemingly unrelated commit is breaking a test that looks like this more-related commit would actually be affecting.  I can't really dig deeper because I can't get the tests to fail.. They failed in Safari.  That's both exciting and terrifying because Safari's debugger is not quite as good as Chrome's is with Steal-loaded code.. Uggh.  It was the cache in Chrome.  I just had to open my developer tools and rerun the tests.\n\u26c8\n\ud83d\udc12. > Maybe we shouldn't allow loading two versions of can-define?\nI noticed that the can-define version number in canjs is locked at 1.0.8.  The can-connect module has can-define@1.0.9 in its own node_modules folder.  When I updated canjs' dependency to can-define@1.0.9, the error went away, so maybe allowing only one version of can-define is the solution.\n\n. I'm going to update these tests so that they don't use relative imports: https://github.com/canjs/can-define/blob/master/test/test.js#L15. Updating the tests doesn't seem to fix the issue:\n\n. The tests should be using the can-types module, since the can-define is using it internally to create DefineMaps and DefineLists.  PR incoming.. Closing for https://github.com/canjs/canjs/pull/2922. @arti1793 any suggestions on what would this look like in practice?. Making functionality change based on the presence of ; required will not feel JS-like, but I like the idea of it being something simple like that.\nWhy not use ${ expression } from es6 strings?. I wiped out node_modules, pulled, npm installed and got a different result. The tests stop at the point shown in this screenshot.  Using node 6.5.0.  Same result with node 7.4.0 after reinstalling node modules.\n\n. Ah.  If I rerun the last test, then I get the same errors as @kylegifford:\n\n. I removed all dependencies from the canjs/canjs package.json except those needed to run the can-connect-feathers tests.  I tried installing with yarn and the problem went away.\nI think this might be an npm bug.  After npm installs dependencies, here's the npm ls debug output:\ncan@3.4.1 /Users/marshall/Sites/canjs\n\u251c\u2500\u252c feathers@2.0.3  \n\u2502 \u251c\u2500\u2500 debug@2.6.1 // Odd to me, considering the version it references compared to others.\n\u2502 \u2514\u2500\u252c express@4.14.1\n\u2502   \u251c\u2500\u2500 debug@2.2.0\n\u2502   \u251c\u2500\u252c finalhandler@0.5.1\n\u2502   \u2502 \u2514\u2500\u2500 debug@2.2.0\n\u2502   \u2514\u2500\u252c send@0.14.2\n\u2502     \u2514\u2500\u2500 debug@2.2.0\n\u251c\u2500\u252c feathers-socketio@1.4.2\n\u2502 \u2514\u2500\u252c socket.io@1.7.3\n\u2502   \u251c\u2500\u2500 debug@2.3.3\n\u2502   \u251c\u2500\u252c engine.io@1.8.3\n\u2502   \u2502 \u2514\u2500\u2500 debug@2.3.3\n\u2502   \u2514\u2500\u252c socket.io-adapter@0.5.0\n\u2502     \u2514\u2500\u2500 debug@2.3.3\n\u251c\u2500\u252c socket.io-client@1.7.3\n\u2502 \u251c\u2500\u2500 debug@2.3.3\n\u2502 \u251c\u2500\u252c engine.io-client@1.8.3\n\u2502 \u2502 \u2514\u2500\u2500 debug@2.3.3\n\u2502 \u2514\u2500\u252c socket.io-parser@2.3.1\n\u2502   \u2514\u2500\u2500 debug@2.2.0\n\u251c\u2500\u252c steal-tools@0.16.8\n\u2502 \u2514\u2500\u252c chokidar@1.6.1\n\u2502   \u2514\u2500\u252c fsevents@1.1.1\n\u2502     \u2514\u2500\u252c node-pre-gyp@0.6.33\n\u2502       \u2514\u2500\u252c tar-pack@3.3.0\n\u2502         \u2514\u2500\u2500 debug@2.2.0\n\u2514\u2500\u252c testee@0.3.1\n  \u251c\u2500\u252c miner@0.2.1\n  \u2502 \u2514\u2500\u252c localtunnel@1.8.2\n  \u2502   \u2514\u2500\u2500 debug@2.2.0\n  \u2514\u2500\u252c mocha@3.2.0\n    \u2514\u2500\u2500 debug@2.2.0\nThese are the packages from the error messages that Steal complains about.  I've listed the debug module version number referenced in each package.json.\nfeathers | debug@^2.1.1  // Lower than the others, but npm installed 2.6.1\nfeathers-authentication-client | debug@^2.2.0\nfeathers-authentication-popups | debug@^2.2.0\nfeathers-errors | debug@^2.2.0\nfeathers-hooks-common | debug@^2.2.0\nfeathers-rest | debug@^2.2.0\nfeathers-socket-commons | debug@^2.2.0\nfeathers-socketio | debug@^2.2.0\nsocket.io-client | debug@^2.3.3\nAfter Yarn installs dependencies, the problem goes away.  Here's the npm ls debug output.  Notice how most of the modules now have debug@2.6.1 installed, instead of just the feathers module.\ncan@3.4.1 /Users/marshall/Sites/canjs\n\u251c\u2500\u252c can-connect-feathers@3.5.1\n\u2502 \u251c\u2500\u252c feathers-authentication-popups@0.1.2\n\u2502 \u2502 \u2514\u2500\u2500 debug@2.6.1\n\u2502 \u2514\u2500\u252c feathers-errors@2.5.0\n\u2502   \u2514\u2500\u2500 debug@2.6.1\n\u251c\u2500\u252c feathers@2.0.3\n\u2502 \u251c\u2500\u2500 debug@2.6.1\n\u2502 \u2514\u2500\u252c express@4.14.1\n\u2502   \u251c\u2500\u2500 debug@2.2.0\n\u2502   \u251c\u2500\u252c finalhandler@0.5.1\n\u2502   \u2502 \u2514\u2500\u2500 debug@2.2.0\n\u2502   \u2514\u2500\u252c send@0.14.2\n\u2502     \u2514\u2500\u2500 debug@2.2.0\n\u251c\u2500\u252c feathers-authentication-client@0.1.8\n\u2502 \u2514\u2500\u2500 debug@2.6.1\n\u251c\u2500\u252c feathers-hooks@1.7.1\n\u2502 \u2514\u2500\u252c feathers-hooks-common@2.0.3\n\u2502   \u2514\u2500\u2500 debug@2.6.1\n\u251c\u2500\u252c feathers-rest@1.6.0\n\u2502 \u2514\u2500\u2500 debug@2.6.1\n\u251c\u2500\u252c feathers-socketio@1.4.2\n\u2502 \u251c\u2500\u2500 debug@2.6.1\n\u2502 \u2514\u2500\u252c feathers-socket-commons@2.4.0\n\u2502   \u2514\u2500\u2500 debug@2.6.1\n\u251c\u2500\u252c socket.io-client@1.7.3\n\u2502 \u251c\u2500\u2500 debug@2.3.3\n\u2502 \u2514\u2500\u252c socket.io-parser@2.3.1\n\u2502   \u2514\u2500\u2500 debug@2.2.0\n\u251c\u2500\u252c steal-tools@0.16.8\n\u2502 \u251c\u2500\u252c chokidar@1.6.1\n\u2502 \u2502 \u2514\u2500\u252c fsevents@1.1.1\n\u2502 \u2502   \u2514\u2500\u252c node-pre-gyp@0.6.33\n\u2502 \u2502     \u2514\u2500\u252c tar-pack@3.3.0\n\u2502 \u2502       \u2514\u2500\u2500 debug@2.2.0\n\u2502 \u2514\u2500\u252c transpile@0.9.7\n\u2502   \u2514\u2500\u252c babel-core@5.8.14\n\u2502     \u2514\u2500\u2500 debug@2.6.1\n\u2514\u2500\u252c testee@0.3.1\n  \u251c\u2500\u252c body-parser@1.16.1\n  \u2502 \u2514\u2500\u2500 debug@2.6.1\n  \u251c\u2500\u252c connect-injector@0.4.4\n  \u2502 \u2514\u2500\u2500 debug@2.6.1\n  \u251c\u2500\u2500 debug@2.6.1\n  \u251c\u2500\u252c launchpad@0.5.4\n  \u2502 \u251c\u2500\u252c browserstack@1.5.0\n  \u2502 \u2502 \u2514\u2500\u252c https-proxy-agent@1.0.0\n  \u2502 \u2502   \u2514\u2500\u2500 debug@2.6.1\n  \u2502 \u251c\u2500\u2500 debug@2.6.1\n  \u2502 \u2514\u2500\u252c restify@4.3.0\n  \u2502   \u2514\u2500\u252c spdy@3.4.4\n  \u2502     \u251c\u2500\u2500 debug@2.6.1\n  \u2502     \u2514\u2500\u252c spdy-transport@2.0.18\n  \u2502       \u2514\u2500\u2500 debug@2.6.1\n  \u251c\u2500\u252c miner@0.2.1\n  \u2502 \u2514\u2500\u252c localtunnel@1.8.2\n  \u2502   \u2514\u2500\u2500 debug@2.2.0\n  \u251c\u2500\u252c mocha@3.2.0\n  \u2502 \u2514\u2500\u2500 debug@2.2.0\n  \u2514\u2500\u252c testee-client@0.4.0\n    \u2514\u2500\u252c superagent@3.4.4\n      \u2514\u2500\u2500 debug@2.6.1. Steal can't find the debug@2.6.1 module.  It's not in loader.defined\n\nHere are the debug modules in loader.defined:\n\n. All tests pass when I install with yarn.. Hmm... debug@2.6.1 is installed in the node_modules root.  Steal should probably know it's there.. I've created a demo project that mimics the problem, but Steal handles it fine.  I was able to get the tests to all pass by removing \"npmAlgorithm\": \"flat\" from the canjs package.json.  I installed all packages with npm@3.10.3, so I'm not sure why that worked.. This problem went away this morning.  Several npm installs and it worked fine.  Now it's back.  I've created the steal-bug branch.  Just open /test/index.html to see the error, and no tests run.. @matthewp found & fixed this in Steal and will create a test for the fix.. Here's my two bits based on our experience with Feathers.  Switching to the EsLint AirBnB config left one annoyance in our faces.  Because it's configurable, we received \"let's tweak the config right here to be more convenient for me\" issues all too often.  We settled on semistandard, which is just like StandardJS, but includes semicolons.  It still lets you use semistandard --fix, like ESLint does, to quickly fix all of the whitespace errors in your project, which is a real time saver.\nNow, from personal experience, I tried no semicolons in a few of my project.  It took me a few weeks of post-semicolon mourning, but I'm now comfortable without them, and have moved on.  :). This is the real benefit we found in the Feathers repos:\n\n. Heh.  This is my work for this morning.  Please don't close.. We had to wrap the Session.current handler in a Zone.ignore.  Fixed in can-connect-feathers@3.5.2. There's definitely still a problem here.  The page renders correctly, now, but any event handlers on elements that are directly in index.stache don't get handled.  The magic tags still seem to be properly updating when data changes, but a button with ($click)=\"logout\" does nothing.  If I remove the binding to session from the markup, the ($click) handler works as expected.. In components, everything works as expected, as well.  It's so far only a problem directly in index.stache.. That does look better.  I updated the pull request to match.  Thanks.  \nHave a great day!\nMarshall Thompson\nCreative Ideal\nOn Wednesday, January 23, 2013 at 1:38 PM, David Luecke wrote:\n\nIn route/pushstate/pushstate.js:\n\n@@ -34,14 +34,17 @@ steal('can/util', 'can/route', function(can) { > _setup: function() { > // intercept routable links > can.$('body').on('click', 'a', function(e) { > - if(can.route.updateWith(this.pathname+this.search)) { > + // Fix for ie showing blank host, but blank host means current host. > + this.host == '' ? this.host = window.location.host : null;\nThis looks a little weird. Isn't this just doing\nif(!this.host) { this.host = window.location.host; }  \n\nBesides that I'd merge this in because it makes sense. I was thinking about a good way for testing this but I don't think there is (even checking the window.location in an iframe wouldn't really tell us anything).\n\u2014\nReply to this email directly or view it on GitHub (https://github.com/bitovi/canjs/pull/249/files#r2748417).\n. Looks to me like we need to remove the if(state) and add the missing & in the next line.  The state && is performing the same thing as the if(state).  Well, it would if it had both & signs.  With these changes, it will throw an error once state is truthy.\n. \n",
    "talentedmrjones": "@daffl Where can I find some documentation on this pushstate code? I'm trying to use it but not getting very far. Reverse engineering isn't in the budget on this one :)\n. I take that back. I'm sorry the hash symbol being URL encoded was from a change I made to the core of the plugin.\nLook here:https://github.com/bitovi/canjs/blob/master/route/pushstate/pushstate.js#L42\nYou will see this.pathname+this.search\nwindow.location.hash is not included at all. Therefore the pushstate code does not allow for links that contain hashes. I'd like to use pushstate but also need to support hashes so I can jump to specific places in the page based on window.location.hash.\nI've tried changing that line to this.pathname+this.hash+this.search but that ended up URL encoding the # and left window.location.hash empty.\n. ",
    "passy": "The bower component for 1.1.4 works great, we're already using it for TodoMVC. Do you have a plan on how to handle the optional plugins? It would if I could install canjs-mustache as a separate package for example.\n. ",
    "nanotronic": "I know, but its a little bit cumbersome...\nFar better would be RegEx-Routes.\n. Mainly I use can.Control.route. \nMhm. I have to think about it.\n. I have overwritten the route-plugin. It's a bit a hack. Basically a route docs/:section(/:subsection) register 2 routes:\ndocs/:section and\ndocs/:section/subsection\n. Finally the gist with the changed code: https://gist.github.com/nanotronic/5197453\n. +1\nI always use in init of my can.controls\nthis.options = new can.Observe(this.options);\n. ",
    "oytuntez": "I needed this kind of routes. This is not very handy but could work practically.\n\"docs:section/:sub1:/sub2/:sub3/:sub4:/sub5 route\"\nthen you create links like \n!docs/faq/null/null/null/null/null\n!docs/faq/installing/null/null/null/null\nOR alternatively, you could create a route like this:\n\"docs:section route\"\nand give links like\n!docs/faq,installing\n*** I havent tried this one. Maybe you could use something else than comma.\nThis way, you would have to process the :section variable on your own.\n. Can you share your code, to keep it archived here on search results? :)\n. ",
    "jeffreytgilbert": "Hello all,\nI'm actually fielding a use case where I have the following urls which I'd like to route to the browser history. There are 3 possible arguments for the page which would all be good save points for rerendering the page upon refresh or backing up through results. In addition, I also want to have these same options on a page with an id passed as well. With the suggested methods and the plugin nanotronic wrote, I haven't been able to get this url to work. Presumably, the plugin isn't happy with my syntax (will look into this now), however I can definitely add a + 1 for feature request on this. If partial url matching was supported, that might work, but to nano's point, passing around all those slashes and nulls doesn't make for nice route handling. My current solutions are either to manually map out all possible variations of these route parameters, or to fix / research this plugin and try to solve some of the voodoo magic it's doing. Neither are overly palatable options.\ncan.route( 'goto/:page(&view=:view)(&filter=:filter)(&sort=:sort)', {page:'home', view:'list', filter: 'default', sort: 'default'});\nExpected result: \n!goto/AboutUs -> fires change event\n!goto/Sites/102 -> fires nothing here\n!goto/Sites&filter=Published -> fires change event\nActual result:\n!goto/AboutUs -> fires nothing\n!goto/Sites/102 -> fires nothing\n!goto/Sites&filter=Published -> fires nothing\n. To follow up this post, it appears that the way the routing works is that you can specify your optional params ONLY in the object you pass in and parameters will be serialized/deserialized to match against the route without you having to specify them IN the route pattern itself. This goes against my assumptions on how this was perceived to function, but does actually work well. \nThis route should have been written as:\ncan.route( 'goto/:page', {page:'home', id:null, view:null, filter: null, sort: null});\nAnd as you can see, all the params are not specified in the pattern, but can.route does pick up the changes in the route. \n. Having found out how default parameters actually work, I'm not recommending any additions/changes. The gist code attached to nanotronics post didn't work as i had anticipated, but using can.route with defaults worked as intended. \nWith this code: \ncan.route( 'goto/:page(&view=:view)(&filter=:filter)(&sort=:sort)', {page:'home', view:'list', filter: 'default', sort: 'default'});\nI was trying to produce this effect: \ncan.route( 'goto/:page', {page:'home', id:null, view:null, filter: null, sort: null});\nI didn't realize you didn't have to specify the parameters in the defaults in the routing pattern (string) you define initially, which is what caused confusion. \n. params order doesnt matter. routes order should matter\n. I'm having issues with this. CanJS is rewriting a route and escaping characters in it before i can stop it from running and doing so. It's extremely confusing because I haven't even told CanJS about any routes. In fact, removing all routing declarations and just loading CanJS on a page will alter my routes. \nReasons it shouldn't be run by default:\n- No routing may even be loaded, so it's doing things it's not asked to be doing, which is contrary to expectations\n- Third party routing libraries will be interfered with, thereby breaking \"library-er\" conventions of CanJS\n- Deferring the route handling to a point where the asynchronous modules have a chance to load and respond in their own order just makes more sense\n- Adding a ready call at the end of a route declaration is sufficiently easy to understand for basic app builders\n. If I don't use the complicated routes with parameters, it doesn't happen, but then i also can't use those features. I'm using the AMD / RequireJS version, not the downloaded bundle. \n. BTW, this bug can be seen in the TODO MVC example as well as my application. Here's a url to showcase what is happening. \nhttp://addyosmani.github.com/todomvc/labs/dependency-examples/canjs_require/#!active/andthis&butthis=thisval\nWatch the / after active to see what's happening. It gets encoded, and if it were a route, it would no longer match the route definition. You can actually see this by adding a number of characters like so:\nhttp://addyosmani.github.com/todomvc/labs/dependency-examples/canjs_require/#!active;andthis=this&butthis=thisval\nThe semicolon will be encoded as well as the following = sign. \n. I've added another issue here per your request:\nhttps://github.com/bitovi/canjs/issues/330\n. You're absolutely right about that not being a route that the TODO MVC application is expecting. It wouldn't matter even if it were. CanJS shouldn't be manipulating those hashes. If it were actually expecting those routes, it wouldn't change the behavior of the page. The encoding would still happen and the routes would still break. \n. I'm currently using the routing for simple routes. Complex ones i'll have another pass at a few months down the road once i've finished everything mission critical on this project. \nOn Mar 21, 2013, at 3:08 PM, Justin Meyer notifications@github.com wrote:\n\nIf it were actually expecting those routes .... the encoding would still happen and the routes would still break.\nThat's not right. Check out the example in #330.\nI think the best solution for @jeffreytgilbert is simply not to load can.route if you aren't using it. Don't waste time loading code you aren't using.\nIf we should call force a call to can.route.ready() when someone has included the plugin (indicating desire of its features) is another matter ...\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "colinexl": "Here's a JSFiddle example: http://jsfiddle.net/7YvyV/\n. Thanks for the response. We implemented a really hacky fix for this on our local branch to get this to work, diff below:\ndiff --git a/observe/observe.js b/observe/observe.js\nindex 73629d7..03e07f3 100644\n--- a/observe/observe.js\n+++ b/observe/observe.js\n`` javascript\n@@ -604,13 +604,23 @@ steal('can/util','can/construct', function(can) {\n                //attr- Is a string of properties or an array  of property values.\n                //value- The raw value to set.\n                _set: function( attr, value ) {\n+                       // TODO: this is a hacky fix to undo what attrParts did\n+                       var nesting = attr.indexOf(\".\") > -1;\n+\n                        // Convertattr` to attr parts (if it isn't already).\n-                       var parts = attrParts(attr),\n+                       var parts = attrParts(attr);\n+\n+                       // TODO: this is a hacky fix to undo what attrParts did\n+                       if(nesting && this.attr(parts[0]) === undefined) {\n+                               parts = [parts.join('.')];\n+                       }\n+\n                                // The immediate prop we are setting.\n-                               prop = parts.shift(),\n+                       var     prop = parts.shift(),\n                                // The current value.\n                                current = this.__get(prop);\n+\n                        // If we have an object and remaining parts.\n                        if ( canMakeObserve(current) && parts.length ) {\n                                // That object should set it (this might need to call attr).\n```\nThis was meant as a quick fix in order to get our app to run but by new means is this a long term solution. Looking forward to a real fix in 1.1.5.\n-Colin Zhu\n. There are couple of work arounds:\n1. set the attr individually baz.attr('foo', foo); baz.attr('bar', bar);\n2. make foo and bar into can.Observe or can.Observe.List\n-Colin Zhu\n. Cool, thanks for taking care of this.\n. I know this issue has been closed, but after the changes in this commit, our compute no longer works the way it did.\nHere's a fiddle: http://jsfiddle.net/qYdwR/1180/\nBefore, we initialized an empty compute by using \ncan.compute()\nThen after some async operations are done, it'll update the compute by calling \ncan.compute(new ConstructOfSomeSort())\nThis would then cause the Mustache view to update itself due to live-binding. However, after this commit, the Mustache doesn't update itself anymore. I dug around briefly and it looks like the \"computed\" function in compute.js is no longer being called after the can compute update.\nI believe this issue is happening in the latest CanJS2 as well.\n. @andykant Your solution worked perfectly and thanks for getting down to the root cause.\n. Yep I think that will solve the issue.\n. Makes sense now. Might be helpful to update the doc with that distinction. Thanks!\n. ",
    "ekryski": "Hmm. Checked out my original work code at home and everything seems fine. I also took @daffl's example and tried it at home in different orders and it seems fine too. This might have been a false alarm. Not sure what is different on my work machine.\nI would consider this closed.\n. +1\n. @Alex-Krautmann I started looking into this. It looks like findOne when using can.fixture.store does return the item if you are requesting with a valid id. It returns undefined otherwise. See code.\nI would assume you are looking for a mock 404 to be returned if the resource isn't found? The only thing we will need to be conscious of, is still allowing a developer to create custom mock responses. For example, you might want to override the findOne call to return a 401 unauthorized.\nThoughts? @justinbmeyer @daffl @ccummings \n. There's a proposed kick at it. Let know what you think.\nI think we could actually have some nice default errors for the other methods as well (ie. UPDATE, DELETE).\n. @justinbmeyer Could probably do that I guess.\n. Yep you are right. I'll update that.\n. Closing this as it should be going to master. New PR is #927.\n. :thumbsup:\n. @daffl I totally agree. My thought was breaking the tests up into smaller ones that are testing one thing. That one I referenced above was doing a lot. Maybe look into http://api.qunitjs.com/module/ for  grouping similar tests together. ie. all test for can.fixture.store\n. Ha ha @justinbmeyer you are right. I made the same comment on the issue #803.\n. @neektza Sounds good. Ya, I just realized you guys probably want these PR's to be going to minor. Want me to change them?\n. @neektza Brought this in via 1d3c85bc8649bf460ae79727fb5c15b09655c4a3. Closing.\n. I rebased off of minor. Should be a much cleaner PR now. Just adding the log messages to stache.\n. ok @justinbmeyer that should be good to go now. Some of that stuff in mustache_core is pretty hairy. Definitely could use some :heart:.\n. Not sure what is going on here. I'm also failing locally on someone else's tests. Around can/view/mustach and can/map/lazy. Probably due to my rebasing off of minor.\n. Not sure what is going on here. I'm also failing locally on someone else's tests. Around can/view/mustach and can/map/lazy. Probably due to my rebasing off of minor.\n. Ya... I dunno what the deal is. It's randomly failing with Phantom. Usually its just timing out like on TravisCI. Seems to be bombing a little more consistently when it gets to qunit:individuals. Everything looks good in the browser. I'll need some help figuring this one out.\n. Ya... I dunno what the deal is. It's randomly failing with Phantom. Usually its just timing out like on TravisCI. Seems to be bombing a little more consistently when it gets to qunit:individuals. Everything looks good in the browser. I'll need some help figuring this one out.\n. @moschel k cool. Thanks for the merge @ccummings.\n. @moschel k cool. Thanks for the merge @ccummings.\n. Yep my bad. I should have just commented and not put an inline comment. I forgot to pull it out.\n. ",
    "James0x57": "Looks to be fixed.\nhttp://jsbin.com/remujuziho/edit?html,js,output\ntest( \"deep param bind doesn't fire twice on remove\", function () {\n  expect( 1 );\n  can.route.bind( \"prop.deep\", function () {\n    ok( true, \"only fired once because prop.deep changes\" );\n  });\n  can.route.attr( { prop: { deep: true } } );\n  // issue #269, remove would fire the change event for \"prop.deep\" AND \"prop\"\n  can.route.removeAttr( \"prop.deep\" );\n});\n. Thank you for submitting this fix, unfortunately we were unable to reproduce the issue in the latest version.\nWe tested it in the backup plugin and in util object with both shallow and nested properties.\nIf there is still an issue, we would be happy to accept a pull request with tests!\nThank you,\n//James\n. Sooo we need some discussion on this, via #1758 \nPoints of argument:\n1) The problem in #1758 says that if your can.List has a custom Map Type, pushing a new item which is already a map of some other type onto that list, you would expect the pushed item to be converted to the custom Map Type because the List's Map Type is set.\n2) The problem in this issue ( #1616 ) is that concat was serializing the items from each input list before creating the concatenated output List, which means:\nsourceList[ 0 ] !== ( sourceList.concat( [] ) )[ 0 ];\nwhich is wrong by typical definition of concatenation.\n-- The list created by concat uses the same constructor as the list on the left side of the argument\nGoals/Discussion:\n1) Be consistent. Which should we favor?:\n-- Any item in the List should be the same type as it's Map Type, so all List methods should type cast.\nOR\n-- List methods should behave like array methods ( without type casting the args ) so any type casting needs to be done manually.\n2) Should we give the option for either?\nsomeList.push( /* can push fn, type enforced / );\nsomeList.push.raw( / vanilla push fn, no type casting */ );\n3) Document this behavior for each method. ( even if we don't resolve the inconsistency? )\n. Hey Guys, here is the script:\nhttps://github.com/canjs/can-upgrade/blob/master/bin/mustache_to_stache.js\nThere is one TODO note in there I'd like to address when I have time, and I should probably remove the string prototype getters I did for colors and do them another way, but it all works as is.\n$ cd /root/of/your/project\n$ npm install can-upgrade\n$ node /node_modules/can-upgrade/bin/mustache_to_stache.js .\n. @julia-allyce should be fine to link to\n. This is all cleaned up and taken care of (and live):\nhttp://canjs.com/docs/can.route.html\nTalked with Ilya briefly to confirm he didn't intend to do anything else for this one.\nGood to go, closing! (Thanks Ilya!)\n. Oh! Sorry! It also it has the label \"fixed in branch\", which also might have been added by misread since I'm just noticing it wasn't added by you.\nIs the fix just adding can/route to the steal list? I can take care of it real quick\n. Closing for now:\nTravis CI is having issues and there's a point for discussion on this solution that I'll bring up in #1616 \n. Closing because all are done and pushed now.\nRemaining ones are hidden and listed in #3789 because they rely on Streams.. Windows 10 Chrome is failing in Travis:\n\nThey work on browserstack win 10 chrome:\n\nAnd they all pass on my windows 10 laptop in chrome latest too:\n\n. ",
    "shcarrico": "Additionally, tests on dependencies of core components (util/string, can.compute, etc) are not included in the main test runner.\n. @ccummings does the solution for #193 solve your issue? Could we throw a dev mode warning when lookup falls back to ajax?\n. This method has been significantly refactored. Please add this functionality against the newly refactored getObject method and include a test for it in string_test.js \n. Should we throw a dev mode warning for this, or try to code a workaround? \n. this pull request is made redundant by https://github.com/bitovi/incubator/tree/master/can/validator\n. would a dev mode warning be enough to catch this edge case?\n. I put these new dependencies in a branch we are running that has many other similar changes in it. I can't take this pull with all the whitespace modifications. Expect to see this in a new point release very shortly.\n. I'm all for this. Can we still update the documentation to explain what is happening pre 2.1 vs what will happen in 2.1? This behavior falls under an \"api change\" in a certain sense, as if you were expecting a static in the 'defaults' you may get a bug. Perhaps in the effort for #311 we also update the dev warning system to log an info that mutables are deep copied?\n. If the purpose of \"defaults\" on a control is indeed to specify the default configuration, then I do not agree that it is either appropriate or unsurprising that it shares these across all instances of said control. Additionally, the number of people I have encountered making this error leads me to believe it erroneous to assume the current behavior is expected. Not only does it lead to very hard to pin down behavior, it assumes a level of knowledge and a specific background that all users of our framework will not share.\nIf we are going to change the API, I would suggest we rename defaults to  options, deprecate existing properties named defaults with a warning, and provide a method to set instance defaults via a function ala Justin's suggestion. A new control might look like\njavascript\nvar Foo = can.Control.extend({\n  //these static options are shared across instances\n  options : {\n    viewstate : new can.Map()\n  }\n},{\n  ///object return from this method is merged into the options provided to the constructor\n  options : function(){\n    return {\n      computed : can.compute(2)\n    }\n  },\n  //at this point, options provided to the constructor have been merged with the defaults and any static options\n  init : function(el,options){\n  }\n})\nIn lieu of this, I strongly recommend we both throw a very visible info message about anything other than say, \"string\", \"number\", or \"boolean\" in the defaults object, and improve our docs to call out explicitly that defaults are shared. IE \"...shallowly merged... This means that mutable values for default properties (such as assigning a can.compute instance) will be shared across all instances of your control.\"\n. I just experienced two individuals separately making this same mistake.. Would it be appropriate to submit a pull to improve the documentation to call this out more loudly in the documentation places around \"static properties\" ? The dev warnings are so loud that we have suppressed them...\n. I am curious if this plugin is being included by default again.. My project is allowing this syntax without explicitly pulling the plugin (we just steal can/util/jquery)\n. is there an advantage to the ID being a number? can we force to set them as strings to start with so there isn't a type mismatch?\n. Can you suggest a place where we might emphasize or add this to the docs?\n. It is important we have very solid test coverage for EJS, especially if we are no longer focusing on it. We should do a thorough audit and make sure there aren't edge cases we aren't hitting with our current test suite. That way, even if it isn't in the limelight, we won't introduce breaking changes to the framework.\n. +1\n. how would this look when custom tags are placed directly in the page? ( not in a mustache template, script tag etc). Would it be confusing to see mustache syntax in your html?\n. I am also curious why we need to use @ in the existing API.. couldn't we just pull the string value if the lookup failed? \n. is it just me, or is this starting to look an awful lot like DHTML ? <a onclick=\"myFoo(bar,baz)>ugh</a> vs <a can-click=\"myFoo(bar,baz)>ugh</a>. Is this really where we are headed?\n. Sorry for the fire off comment. It just strikes me that if this was injected in a page inline, it would appear much the same as a DOM0 attribute. It is perception in some cases that drives adoption so if this is the final syntax we should be prepared to offer the explanation you have given in the least case. It still looks a bit like inline JS to someone who spent years convincing people to stop doing that and learn \"unobtrusive\"\n. Are we opposed to x-event-click=\"remove\" x-event-data=\"parent,child\" ? This looks more like valid attributes from my perspective. If this was inline it wouldn't look as scripty. I like idea of x- or data - . Barring that we could explore can-event-click ie explicit add event vs short but maybe less obvious syntax?  For scope could be x-scope-foo=\"bar\" where x could be x,data or can and still follow the pattern.\n. So to summarize, when passing a value to a component from the parent scope, should we use:\n1. <myTag foo=\"bar\"></myTag>\n2. <myTag foo={bar}></myTag>\n3. <myTag foo=\"{{bar}}\"></myTag>\nI like the single {} option (2), as it disambiguates this from a standard mustache. The single braces syntax is used in http://facebook.github.io/react/, and I think it reads very easily as \"pass a reference to this variable\" vs \"result of this variable is output into the tag here\" ala {{}}\nTo take this further, <myTag foo={bar} can-click={handler(baz,bat)} ></myTag> clears things up in my mind. The things in the {} are scope properties, not string literals. It is the similarity to a string literal that makes me object strongly to choice 1 above.\n. :+1: @matthewp re getter/setter. \n. > changes to child properties bubble out of parent properties.\nI am referring to changes to child properties of a map causing a 'change' event for each thing to come out of the parent, vs an atomic change for all child properties in one swoop.\nThe interface you suggest above is OK as well.. i was thinking we might want to support async atomic events, which my suggestion would do. If we rely on the global batch, this might cause some problems.\n. real world use case:\n``` javascript\nvar clientState = new can.Map({ dimensions : { 'location' : [], 'category' : [] }, measure : {} })\nvar saved = savedState.done(function(state){\n  //assume state is an object ie \n  //{dimensions : { location : [1001,1002], category : ['food']}, measure : { id : 2}}\n  clientState.attr(state);\n  //clientState will trigger 3 change events\n  //  \"dimensions.location.0\", \"add\"\n  // \"dimensions.category.0\", \"add\"\n  // \"measure.id\", \"add\"\n})\n```\nthe above clientState observable might be passed into a can.Control, component, etc.. where we had a templated handler such as\njavascript\n'{clientState.dimensions} change' : function(){ \n    //this might make a data request\n}\nthe goal of my interface is to allow one to modify the first snippet to do the following\n``` javascript\nclientState.attr().startBatch('restore');\nvar saved = savedState.done(function(state){\n  clientState.attr(state);\n  clientState.attr().stopBatch('restore');\n  // clientState would trigger one change event with an array of the above changes\n});\n```\nthis diverges from the initial comment in that it also needs to work for the map instance.. not just properties in the map.\nAnother example would be changing the location contents via something like can.List.prototype.replace. this fires 2 events, one for 'add' and one for 'remove'. in my above scenario, i would only want one to prevent dupe data requests. This isn't a batch per se, as there is only one thing happening, but i could prevent the dupe via the same interface, ie\njavascript\nclientState.attr('dimensions').attr('location').replace([1,2,3])\n//gives me \"dimensions.location.0\", \"remove\" as well as \"dimensions.location.0\", \"add\"\nvs \njavascript\nclientState.attr('dimensions').startBatch();\nclientState.attr('dimensions').attr('location').replace([1,2,3])\nclientState.attr('dimensions').stopBatch();\n//would give me one change event, \"dimensions\", \"change\" and a list of the changes.\nedited: typos\nedited again: example events for the first 2 snippets\n. Yes, I am referring to \"when you change multiple child observable's properties, numerous change events are dispatched on the parent\".\nre the name of the event, it's a good question.. If we do not overload or modify the existing 'change' event, i think we should go with something more different than \"changed\".. say \"batched\". This way if you had subscribed to both, you would not have something that looked like a typo in your list of handlers, ie\njavascript\n\"{foo} change\" : function(){}\n\"{foo} changed\" : function(){}\nvs\njavascript\n\"{foo} change\" : function(){}\n\"{foo} batched\" : function(){}\n. @thomblake are you referring to can.LazyMap / can.LazyList ? \nIn my super quick test, LazyMap has the same behavior, at least when replacing the values in a list if you are bound to the 'change' event.\njavascript\nvar l = new can.LazyMap()\nl.bind('change',function(){console.log(arguments)})\nl.attr({ foo : { bar : [1,2] } })\n//event emitted: [Object, \"foo\", \"add\", Constructor, undefined]\nl.attr('foo').attr('bar').replace([3,4])\n//2 events emitted :\n//  [Object, \"foo.bar.0\", \"remove\", undefined, Array[2]]\n//  [Object, \"foo.bar.0\", \"add\", Array[2], Array[2]]\nadditionally:\njavascript\nl.attr({foo : {bar : [5,6] }, baz : \"bat\" })\n//events emitted: \n// [Object, \"foo.bar.0\", \"set\", 5, 3]\n// [Object, \"foo.bar.1\", \"set\", 6, 4]\n// [Object, \"baz\", \"add\", \"bat\", undefined]\nand if you bind to foo \njavascript\nl.bind('foo',function(){console.log(arguments)})\nl.attr({foo : {bar : [7,8], buz : \"bob\" }, baz : \"bat\" })\n//events emitted:\n// [Object, \"foo.bar.0\", \"set\", 7, 5]\n// [Object, \"foo.bar.1\", \"set\", 8, 6]\n// [Object, \"foo.buz\", \"add\", \"bob\", undefined]\n. @daffl any problems merging this? can we put it into master and back port to minor / major ?\n. :+1: \n. maybe is related to #1019 ?\n. http://jsfiddle.net/shcarrico/bkE57/9/\nThe above fiddle works for merged properties, but it is pretty different than the docs.\nI think we need to improve this behavior. It is a valid thing to define a default value, then construct a map with said defaults, then set a value, and need to merge. If I had bound to the info property, for instance, i would always want to merge the value instead of replacing it, as otherwise my handlers will all have to be re-bound.\n. I am wary of putting something like a regex into a template.. templates are (hypothetically) a simple representation of underlying functionality, and there is nothing simple about a regex. Additionally, it is going to defeat syntax validation engines attempts to help people with regex syntax. \nSpecifically, having a validation called out ala can-validate=\"email\" is declarative, and provides context for the input field about what sort of validation it might need. Something like can-validate-pattern=\"\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}\\b\", at least to me, not only complicates the template with ugly regex, it encourages people to overload their templates with patterns that a template developer level person will not understand, and likely will copy/paste incorrectly from other implementations. \n. ``` javascript\nvar vm = can.Map.extend({});\nvar tpl = can.mustache(\"\")\nvar comp = can.Component.extend({ \n                tag : \"foo\", \n                viewModel : vm, \n                events : { \n                    \"inserted\" : function(){ \n                        console.log(\"through the component\", this.viewModel.serialize()) \n                    }\n                }\n                });\ncan.$(\"body\").append(tpl())\nvar i = new vm();\ni.serialize(); // returns Object {}\n```\nthe above console.log will produce through the component Object {%root: Object} when the component is inserted.\n. What I have done is to add a define block and set serialize to false for the %root property. This seems to work OK, although I didn't know what the purpose of %root was so was concerned about side effects.\nI am sharing a map instance between a \"root\" component and can.route via can.route.map. The idea being to have that set of properties be the base scope for the application, with the \"state\" living primarily in window.history\n. ",
    "nchervyakov": "Thanks for fix. \nI hope, the next time when I find a bug I will try to make a pull request myself, just need to learn the canjs internals more detailed. \n. ",
    "heff": "Yeah, I was thinking an exhaustive test suite would be important, especially considering developers building plugins or extensions on top of your library. You'd have to be as sure as possible operations would work exactly the same in any environment to avoid introducing a whole category of new bugs.\nDefinitely interested in collaborating.\n. I like the name universal.js, and the initial approach.\nI haven't had a chance to dig deeper into canjs, but it does it have it's own set of functions that it includes if none of the frameworks are available, or does there always need to be one of the frameworks? The reason I ask (in case it's not obvious) is we already have the specific lib functions video.js needs built independently, and I'd want to keep it so no framework is needed, but with the option of excluding those for size savings if there's already a framework. I'm not married to the lib functions we have, but I was thinking it'd be interesting to have a no-framework option where functions could be built using one of the component managers, npm/bower/component. Is that compatible with what you guys are thinking?\n. Probably some combination of that, and defining the specific functions we'd want to offer and work back from there. Start small and simple if possible. Hey, maybe we should write the tests first. :) Pulling pieces of canjs over as they're needed to pass tests.\nThe earlier examples could be a good starting point.\nu.each()\nu.bind()\nu.trim()\nA note on 'each', in Video.js I've broken up the array each and object each methods where it would look more like:\nu.arr.each();\nu.obj.each();\nPartially for performance optimization, and partially because it helps organize the base library functions for me. So you might also then have:\nu.obj.each();\nu.obj.merge();\nu.obj.extend();\nu.obj.copy();\nu.obj.isEmpty():\nu.str.trim();\nu.fn.bind();\nu.dom.append();\nu.evt.on();\nI could see that helping to simplify what the standalone implementation looks like, instead of trying to recreate convenience methods like jQuery.each that can handle anything you throw at it. Any thoughts on that?\nOn Feb 20, 2013, at 11:03 AM, David Luecke notifications@github.com wrote:\n\nThere always needs to be one of the frameworks. We're hoping that a standalone version will be part of maybe CanJS 2.0. For a universal wrapper there should definitely be some kind of standalone implementations.\nHow do you think we should go about this? Use the CanJS library wrappers as a start?\n\u2014\nReply to this email directly or view it on GitHub.\n. You're definitely right about that, and I would even say that's a standard. But I guess I'm not looking at this as a library with a clever API like jQuery etc, but as a library of very specific, very defined functions. The audience I would target with this project isn't the average website builder who uses jQuery all over a page and wants it to be easy, but other library builders like ourselves.\n\nI'm not sure what your needs are exactly, but my specific concerns are file size and performance. I don't need my each() to do everything, I need it to be small and fast. What if my project uses obj.each and not arr.each? The standalone version could be custom compiled to only include the functions you need (like Modernizr http://modernizr.com/download/), but not if functions are coupled together under a clever API. That's the problem jQuery is having right now as they're trying to modularize. Everything is tied together.\nI'm just really not interested in building another library like jQuery, and have different needs for this one. Still happy to hear other thoughts.\nOn Feb 20, 2013, at 2:19 PM, Justin Meyer notifications@github.com wrote:\n\nI think that goes against the trends in JS APIs. Most APIs are tending towards a few methods that do a lot.\n\u2014\nReply to this email directly or view it on GitHub.\n. Cool, that sounds good to me. And each might be a bad example because it is a pretty quick type check, but I hope what I'm saying about priorities makes sense to you guys.\n\nOn Feb 20, 2013, at 3:26 PM, Justin Meyer notifications@github.com wrote:\n\nGetting users is a huge concern for an open source library. I think even library builders are willing to trade 1/100th of a ms for a quick type detection and branch between two versions of each. Many libraries are built around jQuery.\nBut we can likely have our cake and eat it. We can have typed methods when necessary and still have u.each:\nu.each()\nu.obj.each()\nu.arr.each()\nWe could make an \"api\" module that would go through each type and move all those methods to u. If there was a conflict, it would setup a branching function based around the argument's type.\nI think jQuery's problem isn't that it's got a clever API, it's that it has always been \"built\" as a single file. If it started with AMD (or steal), it could have the same API but be quite modular.\n\u2014\nReply to this email directly or view it on GitHub.\n. It might be worth doing a github org. github.com/universaljs/universal.js\nbut I'm fine with whatever.\n\nWe could use pull requests on the readme and docs to discuss the API. (readme-first development)\nOn Feb 24, 2013, at 3:10 PM, David Luecke notifications@github.com wrote:\n\nActually, I even think the branching function should be extensible. For example, for CanJS we need to check if the element is an observable list in which case the wrapper for .each needs to call .attr('length') in order to make things live-bindable.\nOverall, a great idea to standardize the library wrapeprs. I really like it. My questions to get started:\nShould we create a universal.js repository on the Bitovi GitHub?\nWhat is the best format to discuss the API? Options:\nGitHub issues\nGitHub wiki\nGoogle Document\nIs it ok to use jQuery as a general reference point?\nAlso I agree that tests first would be a great approach.\n\u2014\nReply to this email directly or view it on GitHub.\n. Awesome.\n\nOn Mar 8, 2013, at 1:24 PM, David Luecke notifications@github.com wrote:\n\nAllright! Didn't forget about this. I created the Universal.js repository (we can decide later where it might live long-term - didn't want to create an organization just for one repository for now).\nLets take the discussion there :)\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "DVSoftware": "But it still catches them, unless i call stopPropagation(), which in my case breaks catching the outerclicks (i listen to clicks on body, to close modal windows etc), as it doesn't propagate further. I could change to \"javascript://\" but i kinda still think it's wrong to treat \"#\" as \"/\" route (at least with pushstate).\n. Well, the thing is, it does change even if preventDefault is called. At\nleast it's the case with pushstate, i'm not sure about hashchange as i\ndon't use it.\n18.02.2013. 00.26, \"Justin Meyer\" notifications@github.com \u0458\u0435 \u043d\u0430\u043f\u0438\u0441\u0430\u043e/\u043b\u0430:\n\nWhat do you mean catches them? The route will change unless preventDefault\nis called, not stopPropagation.\nIt's not wrong to respond to changing the hash to #. If the hash changes,\ncan.route should respond to it, whatever it is. Otherwise back button and\nbookmarking won't work as expected.\nOn Feb 17, 2013, at 1:18 PM, DVSoftware notifications@github.com wrote:\n\nBut it still catches them, unless i call stopPropagation(), which in my\ncase breaks catching the outerclicks (i listen to clicks on body, to close\nmodal windows etc), as it doesn't propagate further. I could change to\n\"javascript://\" but i kinda still think it's wrong to treat \"#\" as \"/\"\nroute (at least with pushstate).\n\u2014\nReply to this email directly or view it on GitHub.\n\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/pull/285#issuecomment-13700179.\n. This should do it, instead of checking for '#', i now changed it to check if default is prevented.\n. Travis build seems to be stalled for some reason, going to the link says it's actually passed... \n. This yields the same error i have, but i couldn't reproduce it in a fiddle. I did this to fix:\nhttps://github.com/bitovi/canjs/pull/286\n. Not sure why this test failed...\n. I see that tests for observe/sort are not included in the test suite, i tried adding them, but tests from there fail...\n. I don't think so, it applies to both can.Map and can.List\n. @Zemljoradnik it works like this: http://jsfiddle.net/s9fp54nu/1/\nIn order to use 2 way binding, you need to use Maps\n. They are being replaced by http://canjs.com/docs/can.Model.parseModel.html and http://canjs.com/docs/can.Model.parseModels.html\n. I fixed this issue here https://github.com/bitovi/canjs/pull/1009\nYes, i know eval is evil, but should be safe to use in this case. It's handy because it allows easier profiling with Chrome developer tools, as we can filter by class name. It would previously display \"Constructor\" for all classes.\n. @justinbmeyer unfortunately, not yet :(\n. @justinbmeyer What do you think about enabling it only in dev mode?\n. We have a really large code base, and after upgrading CanJS to latest, we started facing this bug, and we currently are not in a position to refactor all of the code to make this upgrade. I agree with daffl, most of the libraries don't error, they just unbind if events are set, and it makes sense. For example, i want to unbind all change listeners regardless there are any.\n. @moschel surround it with\n\n/* jshint ignore:start */\nyour code\n/* jshint ignore:end */\n. Use http://canjs.com/docs/can.mustache.helpers.each.html\nhttp://jsfiddle.net/83byM/1/\n. I also experienced this issue\n. We are also experiencing this issue\n. Sure, i'll add them in a few days\n18.02.2015. 21.31, \"David Luecke\" notifications@github.com \u0458\u0435 \u043d\u0430\u043f\u0438\u0441\u0430\u043e/\u043b\u0430:\n\nThis looks like it makes sense and can go into 2.2. Is there a chance you\ncan add some tests?\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bitovi/canjs/pull/1380#issuecomment-74941966.\n. I forgot to fork the fiddle, so it was original template\n\nhttp://jsfiddle.net/jnhaqL1e/\n. ",
    "schmod": "One other change (and a bit of an edge case at that)  -- observe.js has a bit of code in it that will prevent Observe.List.push() from triggering the add event if the List has a comparator property set, but the can.Observe.sort plugin hasn't been loaded for some reason.  \nMade some changes so that this situation now fails a little more gracefully.  Sortable lists will still behave like normal lists if the sort plugin hasn't been loaded, or somebody happens to have set a comparator property on an Observe.List for some other reason.\nAdmittedly, it would be nice if this code could be moved entirely into the sort plugin, although I'm not sure if there's any particularly elegant way to do that...\n. ",
    "nottoseethesun": "+1 on daffl's comment ( https://github.com/bitovi/canjs/issues/311#issuecomment-25035083 ).\n. +1 , as when an object is inadvertently shared, it often results in a very confusing bug (esp. to less-experienced js developers).  I suggest strongly emphasizing this issue in the documentation and also issuing an \"info\" console log message when an object is assigned to a default.  A \"warning\" might be appropriate, but could give the impression that the code is sub-par when (in the rare case) an object is shared on purpose.\n. ",
    "pYr0x": "@justinbmeyer does ccummings PR #918 not solve this issue?\n. Any idea when 2.0.1 will be Release? \n. no test, 2 year past, close this.\nfeel free to reopen if needed\n. my code is more complex... this example should  show you the probolem.\ni am surprised...\ni took the sample from the docs: http://canjs.com/docs/can.batch.html\nput it on fiddle and use my canjs file. the change callback is fired 2 times...\nhttp://jsfiddle.net/U2sTP/\nthat is not the behavior i expect. \n. my false... misunderstood the doc...!\n. these guys had the same problem... maybe they have solved it?\nlodash/lodash#49\n. @daffl is this a bug ? will it be fixed? or should i just use the workaround?\n@justinbmeyer feel free to write your comments https://forum.javascriptmvc.com/topic/how-should-i-write-a-star-rating-component\n. please update the docs with this notice...\n. the observable promises are not documentet yes\nhttps://github.com/bitovi/canjs/commit/c141dae08e2b517255c457b0e4df8b881374c5b0\n. i think we can close this.\nfeel free to reopen @whitecolor \n. @justinbmeyer can we create a cheat sheet about communication between components? This would help a lot. Where can we create such a cheat sheet?\n. this bug is still present in all  2.1.... can you pull danwoods fix into the 2.1.  branch?\n. i have an old project that is still in progress. there is no testing units for the site, so i cant update to a new major release until testing each part of the website. do canjs follow the Semantic Versioning Specification at all?\n. sorry... cant find this feature in repo\n. +1\n. Why do you don't want to set the variable in single brackets? \nhttp://canjs.com/docs/can.Component.html\nDeprecated 2.1\nTo pass data from the scope, you must wrap your attribute value with {}. In 3.0, can.mustache will use can.stache's method.\nThe other way is to pass the plain attribute name and use the @ notification like daffl posted \nUsing double brackets are not supported to pass attribute value \n. @alexisabril is there any documentation?\n. i think @marshallswain  is right... this is big difference between those two helper that should be documented.\n+1 for correct documentation\n. if #unless is the opposite of #each, #unless should not iterate through an array and so it is false (by my definition)\nas #(section) works like #each, #unless should work like ^(section)\n^(section) <=> #(section)\nunless <=> #each\nor am i wrong?\n. Alright !\nMisunderstood \n. thanks @marshallswain for this great overview.\ni am using velocity on windows.\non my windows machine, there is no folder for putting the content simply in.\nall docsets are stored in \nC:\\Users\\XXXXXX\\AppData\\Local\\Silverlake Software LLC\\Velocity\\Docsets\\Dash\nthe content is wrapped into a file called Resources.db\ndo you have a .docset file?\n. Is this issue releated to #762 ?\n. i think we can close this since the new binding syntax solve all the problems ;)\n. @justinbmeyer if you add requirejs you will get an extra request to can/view/stache/stache.js\nhttp://jsbin.com/mixofumige\n. @justinbmeyer why that's ok? What's the difference between the separate files and the concatenated file that can be downloaded via the download page\nwhy in the downloaded custom file stache define is:\ndefine('can/view/stache/stache', [\n    'can/util/util',\n    'can/view/parser/parser',\n    'can/view/target/target',\n    'can/view/stache/html_section',\n    'can/view/stache/text_section',\n    'can/view/stache/mustache_core',\n    'can/view/stache/mustache_helpers',\n    'can/view/stache/intermediate_and_imports',\n    'can/view/callbacks/callbacks',\n    'can/view/bindings/bindings'\n].......\nand in the amd version\ndefine('can/view/stache',[\n    'can/util/library',\n    'can/view/parser',\n    'can/view/target',\n    'can/view/html_section',\n    'can/view/text_section',\n    'can/view/mustache_core',\n    'can/view/mustache_helpers',\n    'can/view/intermediate_and_imports',\n    'can/view/callbacks',\n    'can/view/bindings'\n].........\n?\n. now i used the AMD version... but same problem here. i think i have found the problem.\nafter using r.js there should no extra request. but defining a module \n```\ndefine(function (require) {\n    var $ = require('jquery'),\n        can = require('can'),\n        foobar = require('app/module3');\nrequire('can/view/autorender');\n\n});\n```\nrequire('can/view/autorender'); still request the can/view/stache/stache\nthis is because my autorender-html-tag needs stache\n<script type=\"text/stache\" can-autorender id=\"main\" message=\"Hello World\">\n            <my-component>\n            {{message}}\n            </my-component>\n        </script>\nand stache is not the default template. if i switch to type=\"text/mustache\" the r.js optimization will work correctly and put all together in one file.\nso any idea how can i handle this problem?\n. +1\n. @chasenlehara: i like the new guide very much! good work ! i would like to have more info about can.Construct. difference about construct.init and construct.setup and the static can.Construct.setup. this is still  confusing me..\n. I agree, but if you marked mustache as deprecated you have to remove mustache as a hard coded dependency for can.component\n. i think we can close this.\nthere is a deprecated warning and a link to can-upgrade\n. I don't like the @ sign. It's confusing with the @index and @key and http://canjs.com/docs/can.Component.html#sig__TAG_ATTR_NAME_KEY_ATTR_VALUE__\nIn php a reference is created with &\n. i think you are right. it should return a compute.\nBut can you explain whats the difference between {{helper....}} and CallExpressions?\n. i like this current proposal\nwhats the difference between two way - viewModel and two way - reference ?\nif you bind a childProp to parentProp in the scope (two way - viewModel) thats the same as driver.plateName property to licensePlate (two way - reference)? \n. push ! no documentation of observable promises !\n. @akagomez i think events like remove and add have to trigger. there is no reasen why not. maybe you can make a pull request?\n. why would this break the current API? \nif we serialize the map and push them into the list, a new map will be created. i think we create to much overhead\nexample:\n- we define a Model \n- we make a aync call with findAll(). \n- we receipt a can.Model.List from parseModels http://canjs.com/docs/can.Model.parseModels.html\n- and now we have to serialize this created List.Map and create a new one... \n....there are too many creations of Maps\nhere an example that doesnt work ..  can.Model.List.Map has no effect\nhttp://jsbin.com/soyorayiku/2/edit\n. the main problem was, that in canjs 2.2.6 the define plugin was not working with can.Model.\nIn canjs 2.3 pre the define plugin is working also in can.Model as you can see here\nhttps://github.com/canjs/place-my-order/blob/master/app/models/order.js\nwith not working define plugin in can.Model i thought i can put a custom can.Map into can.Model.List.Map #1745 describt at http://canjs.com/docs/can.List.Map.html but this was not working too.\nthe third way was to create a new list and add the custom Map into it. after using findAll(), i wanted to push the received a map into this new list. But here the next problem comes up (this issue #1732). Map define does not work if pushing a existing Map into it (see the example below)\nafter the define plugin is working on can.Model (canjs 2.3 pre) this whole problem collapse.\nit would be nice if this issue will be solved. so we havent to serialize a map and then create a new one. i can also write a breaking test.\ni would be also nice if that issue #1745 will be solved, so we have the ability to use a different List.Map for findAll() but findOne() refrence to can.Model itself.\n. this test is breaking https://github.com/pYr0x/canjs/commit/33cb6f0412eaa5abc275ba2ae53e6c6a48c8a9d5 on my local machine at http://localhost:8000/model/test.html with the current master branch\n. @daffl @justinbmeyer  any news about this issue? \nmilestone was 2.3.0 ?\n. +1, useful!\n. @dylanrtt: {foo} is an compute and computes are observable. \ndaffls way (syntax) to listen at a compute is not clear. since we can listen at changes in can.List http://canjs.com/docs/can.List.html#section_Listeningtochanges and can.Control http://canjs.com/docs/can.Control.html#section_Listeningtoevents, i think we should have the same syntax for listen at the viewModel.\ni thought about:\n'{viewModel.foo} change': function(){}\n. so hello again ;)\ni would like to pick up this issue again.\ni have made a example where a component is listen to events on the viewModel.\nhttp://jsbin.com/lakefonulo/edit?js,console,output\nin this example you can see how to write event-listener for different properties in the viewModel.\n- can.List\n- normal key - value property\nthe event-listener work fine.\ncan we add this example in the component API description for viewModel? This would be nice.\nhttp://canjs.com/docs/can.Component.prototype.viewModel.html\n. @justinbmeyer I can't listen to add items to a can.List in the define plugin. The set-function would not trigger if I push a item. http://jsbin.com/cehawicivi/edit?js,console,output\nThe set-function is only trigger when create or replace the can.List\n. hi justin,\nwhats happening in my code example:\n1. disable auto-run js\n2. clear console output\n3. run js\n4. now the alert('memory leak'); will pop up and never end. and the counter \"j\" will increase.\nmaybe the title \"memory leak\" is not correct, there is an infinity loop which raise an error\ni hope \n. thanks @rjgotten for the explanation. but it seems that the whole extending part is a little bit too difficult for me.\nyou said, you patched this in your own fork. can you create a pull request?\n. Mustache will be deprecated .. Please use stache instead.\nhttp://jsbin.com/dakeziluho/edit?html,js,output\n. @justinbmeyer @dylanrtt i think we should document select binding better in the docs... @dylanrtt do you want to add some docs? you are the most familiar guy with that problem\n. @dylanrtt i run into the issue where a 1-way-binding with a dynamic select list not work.\nalso what have to document is the default select behavoir if no value exists in can.Map...\n. Do you mixing mustache and stache templates?\nIf you using stache all parent components and templates have to be a stache-template\nCan.Component using by default mustache...\n. @gmahomarf: it's not about the syntax. it's about you declaring the template\nthis example shows you the problem:\nhttp://jsbin.com/jusovafeva/edit?html,js,console,output\nreplace \"stacheTemplate\" with \"mustacheTemplate\" and you will notice that the helper in child-comp will call with the with the mustache-template, but not with the stache-template\n. do not understand the problem...\ni created a jsbin\nhttp://jsbin.com/xehapumixe/2/edit?html,js,console,output\n@dylanrtt  can you explain the problem at the example? And with the two-way-binding?\nbtw:\nthere is a different behaviour on firefox and chrome\n- in chrome the select-element is blank at the first time\n- in firefox the select-element shows the first option-element\n. created a new branch https://github.com/canjs/canjs/tree/2.2-legacy where david can linked the documentation\n. https://github.com/bitovi/canjs.com/pull/261\n@justinbmeyer please merge\n. can we merge this PR in version 2.3.4?\n. @uzlov can you please create a test and check the CI failure\nalso a documentation would be nice\n. we have can-fixture 0.3.0 and can-set\nclose this\n. should this be documented?\n. you tagged https://github.com/canjs/canjs/pull/2078 as \"Documentation\"\n. http://jsbin.com/zosewigafo/edit?js,console,output\n. i will merge that if no one have doubt\ncc @justinbmeyer \n. @Daniel-Hug @robert-sbin unfortunately i cant reproduce the problem.\nclone the repo and open the chapter 9, all things are working as expected\ncan.ajax make a asnyc call and response(data) is a asnyc setter\nplease reopen if needed\n. should i correct this? or would you like to change the content with hyperlinks to can.view.bindings\n. should {{@index}} not be replaced by {{%index}} ?\nhttp://canjs.com/docs/can.stache.key.html\n. @meconcomputer would you be nice to add a documentation part?\n. @justinbmeyer you can leave the compenent event., but we should add the simpleHelper documentation.\n. @roissard can you write a test into ? https://github.com/canjs/canjs/blob/master/event/event_test.js\n. @justinbmeyer no @deprecated annotation there.... \nso dont know what you mean...\n. @justinbmeyer can we merge that in?\n. @meconcomputer, rjgotten is right.\nyou have to create a new instance of C\ncan.Model('A',{\n    findOne: 'GET /a'\n},{\n    define: {\n        c: {\n            type: function(newValue){\n              return new C(newValue);\n            }\n        }\n    }\n});\nexample:\nhttp://jsbin.com/recewopiwi/edit?html,js,console\nfor type converting see also this good post at: http://forums.donejs.com/t/managing-complex-string-fields-with-can-map/64\n. mustache or stache?\n. unfortunately ejs is deprecated and this is a \"wont fix\"\nif you can reproduced this issue with can.stache let us know\n. @rjgotten didnt fail on stache\nhttp://jsbin.com/xunopoqexu/edit?html,js,output\n. @justinbmeyer we should be documented this behaivor better... \nthe only parts i found is:\nhttp://canjs.com/docs/can.stache.key.html\nand\nhttp://canjs.com/docs/can.view.bindings.toParent.html#section_ExportingFunctions\n. @justinbmeyer on the documentation http://canjs.com/docs/can.view.bindings.toParent.html#section_ExportingFunctions\n<my-panel {add-panel}=\"@*addPanel\" title=\"CanJS\">CanJS Content</my-panel>\nShouldn't the @ not be on both sides?\n. @justinbmeyer but you said\n\nI think the docs should continue to show @ on both sides. I think it's good guidance because they are needed for two way bindings.\n\nwe should write a documentation, which is uniform with all github issues and forum posts\n. @dylanrtt respect, nice work, you have found most of the bugs ;)\n. @whitecolor I tried my best to explain the binding, have a look http://canjs.com/docs/can.elementAndAttributes.html\n. Sorry can't follow you\n. dont know which behavior you expect?\nin the first dropdown \n<select class=\"country-list\" {^$value}=\"countryCode\" name=\"countryCode\" id=\"countryCode\">\nyou export the element value to countryCode with a one-way-binding.\nif you change this to:\n<select class=\"country-list\" {(^$value)}=\"countryCode\" name=\"countryCode\" id=\"countryCode\">\nall three dropdowns change simultaneously\n. i think canjs documentation is created with http://documentjs.com/\n. phillipskevin  and justinbmeyer talked about that in gitter \nhttps://gitter.im/canjs/canjs?at=56746e79b5777fb85ba4aa26\nmaybe it is the same problem as yours\n. close this @mjstahl has updated to steal 0.13\ngood job\n. @matthewp the error is related to mocha.\nhttps://travis-ci.org/canjs/canjs/jobs/101397873#L1603\nwhat does this have to do with jquery 2.2?\n@mjstahl do you have make some changes to the canjs core that fix the error on travis ci?\n. @mjstahl ok, maybe we can release this soon, to check if can-ssr will also pass the tests \n. the expected behavior is not to have <input type=\"text\" value=\"test\"> the {$value}=\"foo\" was only a test that was also not working.\nthe expected behavior was to have an input field with a reference binding to bar. that variable should be displayed before the input field. like the index.stache looks like.\n@justinbmeyer what to you mean with\n\nThe input should be blank with {($value)}=\"*bar\"\nhtml\n<input {($value)}=\"*bar\"/>\n\n@justinbmeyer what is if i want to have a 2-way-binding with foo ?? {($value)}=\"foo\" will also not working\n@matthewp this example works fine: http://jsbin.com/cofoqamecu/edit?html,js,output\ni want this behavior also with can-ssr\n. @daffl @matthewp @justinbmeyer can we now update all canjs / stealjs and donejs repos to jquery 2.2?\nfor example can-ssr https://github.com/canjs/can-ssr/blob/master/package.json#L42\n. :+1: \n. we should document that behavior for checkboxes and radiobuttons... still confusing for users\n. https://gitter.im/canjs/canjs?at=5705487bb12cb51618d29c3d\n. @justinbmeyer can we merge that? \ni think we should merge all acceptable doc PR so that we can start building can 3.0 docs\n. i think with the new binding syntax this can be deprecated in the future?\n. @gsmeets can you share your code with us? Would be create... :)\n. this is fixed in can 3.0 but we should except that for 2.3.25\n. i think this is a good update for legacy canjs 2.3\n. not for me...\ndont know exactly the problem...\n. @cherifGsoul unfortunately... no\n. @justinbmeyer what import should be changed?\n@cherifGsoul I changed the import also to import appTemplate from \"./app.stache!\"; and it doesn't t work too\n. ok got it.\nthx to @matthewp for that rectification.\ni will add this to the document\nalso be careful, the component need a hyphen for the dynamic loading see this issue here!\nhttps://github.com/canjs/canjs/issues/1541\n. close #2335\n. this PR dont make sense for me...\nthe contributor doesnt answer the notes... so i will close this\n. we need a test to except that PR. Also documentation is needed.\nalso there are some JSLint errors.\nthis feature maybe can released for the legacy canjs 2.3\npls let me know if you want to resolve the problems\n. so i will close this\n. @hntvip what about can.route.removeAttr('val')\n. @Tarabyte news about this issue?\n. can we close this?\n. @akagomez @daffl we should also make a PR against https://github.com/canjs/can-list-sort ?\n. thanks...\n. @taai if you have a working solution with also a test we will accept yours...\n. @taai can you try to wrap the second timeout in the first one? \n. @nlundquist what do you think. all aspects of importing modules are described?\n@daffl if this PR is merged can you update the website pls?\n. thx @phillipskevin for the review... i will merge this.\n. so we can set this for the legacy release of 2.3.X ?\n. please more info how your code look like. how do you call the update method and what does it contain?\nwhy do you use update() at all? you should be use save() https://canjs.com/docs/can.Model.prototype.save.html\n. thx @akagomez , but pls make also a PR against canjs/can-util (https://github.com/canjs/can-util/blob/0ff04106cfd5170727e6bc2f6c0041443e9f481d/dom/attr/attr.js)\nand pls dont forget this issue you fixed in can-list-sort to implement into canjs/can-list-sorthttps://github.com/canjs/can-list-sort/issues/3\n. closed by forum thread.\nhttp://forums.donejs.com/t/pass-variables-to-script-content-in-stache-files/356\n. Thank you. Looks good. But the test only covers that the namespace is set right, but is the image really shown?\nCan you also adapt Canjs 3.0?\n. you mean it should be\nif (!same(a[i], b[i], compare, a, b)) {\n. oh ok.. didn't see this page.\n. @marshallswain no the stylesheet will not removed.\n@MarcGodard dont see any benefits of your issue.\n. it is also a little bit tricky if more then one module rely on the same stylesheet. removing the stylesheet will causing a unstyled content\n. here a demo app.\nhttps://github.com/pYr0x/css-import\nsetting the variable to false will not remove the css import!\n. > There is still the problem of when the tag is self closing, it loads regardless of the {{#if}}\nyou read matthew's comment?\nhttps://github.com/canjs/canjs/issues/2469#issuecomment-244509497\nand pls read this too\nhttps://canjs.com/docs/can%7Cview%7Cstache%7Csystem.import.html#section_static_dynamicimport\n. thanks @matthewp  for you detailed answer. maybe a talk for the upcomming doneJS meetup.\n. @blackmamba if you are using canjs 3.0 here is a little code snippet\nNodeJS File:\n```\nvar stealconfig  = {\n    configMain: 'package.json!npm',\n    main: '@empty',\n    stealPath: __dirname+'/node_modules/steal/steal.js'\n};\nvar steal = require('steal');\nsteal.startup(stealconfig).then(function () {\n    steal.import('can-stache/src/intermediate_and_imports').then(function (module) {\n        var stache = module('HelloWorld');\n    console.log(stache.intermediate);\n});\n\n});\n```\nas you see, you need steal for loading all the canjs stuff. you need also\"can-stache\": \"^3.0.0-pre.15\" in your dependencies in your package.json\nyou will get an output of stache.intermediate\nyou can put this output in the normal stache() method and get a renderer back\nsee the example: https://jsbin.com/kazidezoya/edit?html,js,output\nnow you can create precompiled stache files, load them as json and put them into the stache()\n. @blackmamba i updated the jsbin. it pointed to the wrong url\nhttps://jsbin.com/ceqesenope/edit?html,js,output\n. @blackmamba i think there is actual no workaround for that. i think you have to use steal.\nbut it is a good question to ask @matthewp or @justinbmeyer why canjs 3.0 is not usable with nodeJS. canjs 3.0 is written in commonJS and it is all modular. so why do we have to use steal for loading canjs in node. forget at this point the DOM problem. we can workaround with can-simple-dom\n. @justinbmeyer it seems something wrong in many places.\n1. in package.json in can-view-live the main points to \"main\": \"dist/cjs/can-view-live\", but the  dist folder does not exists because https://github.com/canjs/can-view-live/blob/master/.npmignore\n2. there are many places where the module pointed to a steal-readable path \n```\nvar isEmptyObject = require(\"../../../js/is-empty-object/\");\nvar each = require(\"../../../js/each/\");\nvar makeArray = require(\"../../../js/make-array/make-array\");\nvar events = require(\"../events\");\nvar domData = require(\"../../data/\");\nvar getMutationObserver = require(\"../../mutation-observer/\");\nvar domDispatch = require(\"../../dispatch/\");\nvar mutationDocument = require(\"../../mutation-observer/document/\");\nvar getDocument = require(\"../../document/\");\n```\n. @edba whats wrong with using ?\ninit(){\n    this.viewModel.action()\n  }\n. it's very simple. change the jsfiddle to https://\ne.g. https://github.com/bitovi/canjs.com/blame/gh-pages/can/control/control.md#L380. hello kevin,\ni find this syntax very strange.\nyou didnt got any code completion or syntax highlighting in your IDE.\nthis syntax is maybe good for short and simple HTML. but if you write complex HTML you really want code completion.\none good reason to use this syntax is: it is testable !\ngood job.. keep it up :). Have you installed can-make-rest via npm?. why remote autoMount?. ok thanks.. so this should work now?\n```\ncan.Component.extend({\n  tag: \"example\",\n  template: 'foobar is: {{foobar}}',\n  viewModel: {},\n  events: {}\n});\nvar renderer = can.view('bar');\n$('body').append(renderer({\n  'name': 'hello'\n}));\n```\nwith \n<script id=\"bar\" type=\"text/stache\">\n  <example {foobar}=\"{{name}}\"></example>\n</script>\n. david meant https://github.com/canjs/canjs/issues/1740#issuecomment-149928218 this would be the best place.\nsince can.Controll isn't the future i think there would be a good place to show how you can listen to events thats fired in the viewModel.\nthis example indeet is long, but shows all possibilities. i think people can handle this\nmaybe we can add a reference to this documentation in can.List and can.Map (http://canjs.com/docs/can.Map.html#section_Listeningtochanges)\n. we have also http://canjs.com/docs/can.Control.html#section_Listeningtoevents for listening to events on a Control. \nthis docs sould not explain how the Component.prototype.events works, it is an example how the event object can used for.\nfeel free to move the example to other docs...\n. you create an instance, get the ID back from the server. the response is just a response, not the recipe model. \nto update the recipe model an ID have to set. if not, save() would create a new recipe.\nafter save() (line 202) the update event will call\nagain, its just an example of doing any possibility with the event object\n. yes, replaced is actual not a event.\nso you are right, replaced means reference changed\n. why remove the $ sign?\nhttp://canjs.com/docs/can.view.bindings.toChild.html\n```\n{$child-prop}=\"key\"\nImports key in the scope to childProp property or attribute on the element.\n```\nthis is wrong and would not work\nhttp://jsbin.com/sinamubuyu/edit?html,js,output\n. ok.. i rewrite to System.import. i can leave also a note that @loader would be recommended way ;)\n. ",
    "julia-allyce": "This PR hasn't been worked on in a long time. I am closing it. Please feel free to reopen or update it if we want to reconsider it.\n. Closing this PR as its been almost 2years since its last activity. Please update/reopen if this still needs to be addressed :)\n. @bmomberger-reciprocity @thomblake I am closing this issue its been over a year since its last activity. Please reopen or update if there is still interest in making this contribution. \n. @daffl @jlebrech I am closing this pr, because it hasn't been updated in over a year. Please reopen/update if you are interested in having this looked at again.\n. Hey @DVSoftware are you still interested in adding tests and making this contribution?\n. @mjstahl  can you resolve your merge conflicts? :smile: \n. @nickradford are you still going to make this change? :smile: \n. @James0x57 are we ok to link to can-upgrade yet? If not, I think we should merge this PR so there is at least a notice in for mustache.\n. @alexisabril would you still like to have this test merged or can we close this PR?\n. The PR for this issue was never merged. Is this still relevant? cc: @James0x57 \n. @tracer99 I am going to close this PR, and open an new issue for this. Would love to implement your contribution if you wanted to create a fresh PR with your fix and/or failing test.\n. @mjstahl there is a merge conflict here. Also, is this still relevant?\n. @mjstahl whats happening with this PR?\n. Hey @uzlov can you provide some context for this PR? Is there an issue that this relates to?\n. @matthewp I was not using donejs at all actually. Just steal and canjs.\nRepo for reference:\nhttps://github.com/julia-allyce/routing-example\n. It looks like I deleted the repo :/ I just removed a few several weeks ago, but I probably still have it on my machine...lemme see.\n. Pushed repo up and latest version of can seems to have resolved the issue @justinbmeyer \n. @alexisabril  can you resolve your merge conflicts?\n. @justinbmeyer  it looks like there are failing tests with can-simple-dom :(\n. Also just FYI, the original ticket/PR still exists along with all the code changes. It was only closed not deleted.\nYou can see the original pr here #1877 \n. ",
    "lihan": "I couldn't confirm that is actual a valid bug, so I decided to close it. \nI also have another thought that I should define the route before use it. I could use can.route.attr() to modify the route instead of change it by manually change window.location.hash.\nUpdate:\nI made another fiddle http://jsfiddle.net/jz4r5/5/, which uses the named hashtag, but why empty route get executed twice? \nUse can.route.attr({attr:val}, true) to over write existing hashtag.\nBut still have question on the original problem, why the route latest does not fire when browser has no Cache.\n. @daffl I figured this out that this is caused by onhashchange event fires asynchronously, and the way I kick off the application relies on the order of events. Enlighten me if I get the way wrong.\n. @daffl Thanks David.\n. @justinbmeyer I created a failing test for this issue. But the issue will not be resolved by simply change the order of internal control initialization code. I think this would only affect insert event. In my test case, it tested against the change event from viewModel.\nAnother finding is, if I remove the set function from the content property, this issue will go away.\n. ",
    "FelipeLahti": "Is it not better to have the test files in the test directory? Having the production code next to test code sounds strange for me... just my 2 cents\n. I would say it depends. If the culture of testing is not too strong in a way that you need to remember to write a test them you're right. However, in my opinion having all the tests in the same place would make more clear what are the features we're testing. \n. ",
    "azazel75": "it would be very helpful\n. i really don't know what the previous commenter means with \"- no can.view.pending() called after adding first tag\" but i've used a can.zepto.js compiled with sources containing my patch for bug #463 and it seems to work, check it out: http://jsfiddle.net/qc3XZ/9/\n. I have the same issue, but i can't understand what causes it\n. This issue is hitting meu almost everywhere i have two-way helpers on Observe.List instances, for example a list of  elements repeated for every Observe inside an Observe.List.\nFrom my investigation the problem emerges on view.render.js at line 130 ( https://github.com/bitovi/canjs/blob/master/view/render.js#L130 ) while the code is evaluating the compute for the helper function ( which if executed will return the two way binding function, not a static piece of html). \nAfter that line compute.hasDependencies >= 1  and in the end line 177 of the same file is executed, pushing an item in pendingHooks to execute live.attributes  with arguments el, compute and the two way helper function which is not what live.attributes expects,IMHO.\nCan someone more experienced than me have a look at the code please?\nThanks in advance\n. actually, i've found that if i return from an helper a string containing html code it gets escaped, but if i return a new String() object it doesn't\n. See http://jsfiddle.net/RZ8QH/1/ for a test of this strange behavior\n. ",
    "wDevil": "http://finanj.fromthecloud.ru/index_new.html - test instance of application. If you open in Firefox with firebug and refresh page(ctrl+f5) few times you can reproduce the problem\n. ",
    "codr": "You are right, the array is converted into an can.Observe.List here and here. It's own serialize takes precedence.\nOne solution is to build the can.Observe.List yourself and give it a serialize function.\nDemo: http://jsfiddle.net/rLDHc/5/\n. It looks like the wiki is not open for public editing. I've made these changes on my fork but apparently we can't make a pull request for a wiki.\nIs it possible to open the wiki for public editing?\n. How can this be fixed? Is opening the wiki for public editing an acceptable solution? \n. What about moving the guides to the canjs.com repo?\nIt does seems a little weird to have a wiki with a bunch of @ tags in it.\n. ",
    "rxaviers": "Yeap, that's awkward. Thanks for the workaround though.\nConsidering an Array could be part of a model (an attribute), it should behave just like any other datatypes.\n. :+1: cool\n. ",
    "klamping": "On the last example of the Constructor Functions page, the code (Line 3: 'this.') seems to be missing its end:\nvar PrivateTodo = can.Construct({\n    init: function(options) {\n        this.\n    }\n});\n. ",
    "pllee": "It looks great. Thanks.\n. ",
    "gpinto67": "proxy.js no longer here:\nhttps://github.com/bitovi/canjs.com/tree/master/amd/can/construct\n. Any news on this issue? It is preventing us to update to 1.1.6, as it breaks our builds...\nThanks.\n. THANKS! Our build is fixed, using 1.1.6.\n. ",
    "BigAB": "So, can/control/modifier/key was included in the npm release of 2.2.4 but not the bower release.\nBug? Or should we also remove it from npm release.\n. I did make a branch and a pull request https://github.com/bitovi/canjs/pull/1278\nThere is a test\nJustin merged it +1 and merged it.\nYes I will close this issue.\n. The Documentation says it should (and Mustache does) return a <span></span> as the default element\n. Looks like the original link was linked to localhost, I've edited it.\nhttp://canjs.com/docs/can.stache.helper.html#section_Returninganelementcallbackfunction\nSo I'll just add this as a documentation error then.\n. It does. But I don't think that invalidates the argument, specifically the can.fixture.rand( [ \"j\", \"m\", \"v\", \"c\"] , 2, 3); example\n. Why <content name=\"\"></content> and <*-template></*-template>?\nWhy not just use slot=\"\" and <slot name=\"\"></slot>?\n. I push the branch regression-1112-in-stache with this change to show the breaking test\n. OH, forgot to mention, this passes in browser but fails in PhantomJS (edited the description)\n. OK, edit number 2, it does fail in the browser too.\n. It seems to be, if the type is set to boolean then the consumer will use it that way, so I think null converting to false would be fine.\nIt seems to me like seting the property/attribute to null would be the \"right\" behaviour if you set an object value as null, so I, personally do not see a use case for the nullable property\n. Alright, that didn't work.\nBack to the drawing board.\n. Though I don't mind it.\nI find it a bit overly verbose, making a template file look think and bloated with text.\nI find it still suffers from a similar problem with confusion: \"Was it bind-in: or bind-out:?\", \"Was it on:event or on:(event)?\"\nI think exposing an api to allow plugin modifications to the templating language would be super awesome though.\n. Fair enough.\nI wouldn't use this syntax myself though. Maybe, if I had learned it first I would think differently.\n. It might be important, with the continuing popularity of webpack, to have it seamless work for webpack users alongside their other npm modules, without needing to add \"additional configuration\" just for CanJS \n. Still, removing steal specific stuff like moduleName/ is probably still a good idea\n. I updated the issue with the placeholder images and section text\nI know you didn't want THE WHOLE section text, but I wanted to make sure you had the context you needed to not be overly swayed by my diagrams and maybe suggest better ones.\n. I think that looks great to me. Thanks.\n. swoon, thank Adri, these are the bomb\n. \ud83d\udc4d LGTM\n. Well, I don't think this is going to get merged anymore.\n...also the examples are out of date.  maybe next time.. You see the date on this right?\nDoes this pull request bring you joy?\nIf you answer yes, you keep it open.\nIf you hesitate or say no, thank it for the service it has provided, then close it. . @phillipskevin I like this style, but to nitpick, is .map the right method name there? Are you mapping value in that instance?\nIs it like a '.match' or something, where it only does it if the source invocation matches the source key...?\nI guess what I am getting at is I don't understand what is going on with those .map calls.. > @christopherjbaker / @BigAB maybe you can fill me in on how this would be done in react. How does , which doesn't exist, get the , setup listeners, and handle tearing things down when  is removed?\nA quick googling of \"react swipe\" showed me at least 3 libs that did it this way:\nThe <Swipe /> component renders something like:\n````\n<div\n     onTouchStart={ this.handleOnTouchStart }\n     onTouchEnd={ this.handleOnTouchEnd }\n     onTouchMove={ this.handleOnTouchMove}\n    onTouchCancel={ this.handleOnTouchCancel}\n\n{ children }\n```\n...so the` component component takes props to configure the touch behaviour and the contents of swipe are wrapped in a div that has event handlers.\n\nThere might be other ways to do it too, but nothing jumps to mind.. I think the primary \"syntactical direction\" is somewhat still in flux at this moment (today at least).\n\n\nI want to push the connect() HoC way of doing things, but there is some concerns about performance implications.\n\n\nThere is some discussion about changing the way react-components are connected to the view-models, primarily involving discussion around separating the props received from the component from the view model (a few different ways are being discussed)\n\n\nI have an outlandish idea that is pretty much disliked by everyone, but I think may be the future:\n```\nconst VMComponent = createComponentFromViewModel( ViewModel );\n\n\nclass UserProfile extends Component {\n  render() {\n    return  {\n        \n\n\n{ vm.fullname }\n{ vm.score} \n\n\n    } />\n  }\n}\n```\nLong story short, I think that we should start pushing it, and give it a better name, and a homepage and some videos, but we need to decide which way we are going to be pushing people to use it: extend Component, the connect() HoC/Decorator, a VMComponent with a render prop, or just a component created from a function that takes a ViewModel class and a special render function... and any other ideas that are currently on the table.\nBut I don't think we have to wait for this decision either, we can pick a new name, create a website and start planning some stuff out about how we will promote it while we decide on a syntax for creating connected components.  ...but in the end a decision has to be made before we can really start pushing it.. ## My First thoughts on initially reading it\nSo I am assuming a Maybe* type is basically a value of that type or null/undefined?\nWhat happens if it receives a null for on a non-Maybe type? Does it throw?\n\nRE: This part...\njs\nvar TodoQuery = new Query(Todo, function toQuery(params){\n  var where = params.where;\n  delete params.where;\n  params.filter = where;\n}, function toParams(query){\n  var where = params.where;\n  delete params.where;\n  params.filter = where;\n})\nI am really into the toQuery/toParams transforms, but I think you should take the returned value, because I like the idea of not mutating objects that do not belong to me.\n\nI would like to know more about set.defineComparison, and the arguments it must receives, and what it does. It looks like it is stateful, as I assume the types are registered or something, but assuming the type is held in setType is help in the Model/Type definition I supposed that's alright.\n\nDoes the following syntax already work in DefineMaps (the type shorthand)?\nTodo = DefineMap.extend({\n  id: {\n    identity: true,\n    type: Number\n  },\n  complete: Boolean,\n  name: String,\n  status: makeEnum([\"assigned\",\"in-progress\",\"complete\"])\n})\n\nMy Favourite thing about this:\nfixture(\"/todos\",TodoQuery);\nMy Second Favourite thing:\nrealTimeRest({\n  url: \"/todos\",\n  Map: Todo,\n  query: TodoQuery\n});\n\nI've reached the end and I still don't know the distinction between isMember and subset.\n\nThis looks very promising. It is a problem with inherent complexity and therefore the solution will most likely be a little complex. It may be worth playing with the first implementation a bit, before releasing it, to see if there are areas we could simplify or combine, to make it easier for the end user.\nLooks cool. I am down.\n. @matthewp's Idea seems good, because most likely all your API's will require that change, so it will b easier to use across 1 app. ...actually, why not take it a step further and if only the first 2 params are provided, do the binding for them and return a function.. I would like to see an example of how you would write a service that had a Date type, and how the $gte, $lte, $gt, and $lt comparison operators would work, so that can-fixture would work, but the server (and can fixture) receive and respond with date strings like 2018-03-30T21:05:28.599Z. How about something like:\njs\nimport { connect, DefineMap } from \"can\";\nconst { rest, realtimeRest, superRest }  = connect;. So the real gain of this proposal would be a performance boost for initial parsing of the template, right? \nThat's why you would pre-compile?\nWould it be significant enough to warrant a pre-compile step?\nRight now the benefit of the .component files seems to be, to me at least, a convenience so you don't have to split anything out to separate files, which has become pretty redundant now with the fact that you can make \"single-file\" components just like normal ones:\n```js\nimport {Component, stache} from \"can\";\nComponent.extend({\n  view: <h1> some stache </h1>\n  css: h1: {color: \"red\"},\n  ViewModel: { ... }\n})\n``\n...and those \"single-file\" components don't need any special loaders to import as they are just.js` files.\nHonestly, I'd rather see work done on an editor extension/plugin to add stache syntax highlighting to the template literals (and .stache files btw), and the css property (or maybe styles to include less/sass) added to can component, more than making a step to pre-compile an already-working js file to load a little faster. \n...of course if the perf makes a huge noticeable difference it may be worth it, but I don't feel like I am having stache loading perf problems (maybe I am and just don't know it, I'd have to see the difference I guess)\nRE: An editor extension/plugin for adding stache syntax highlighting to template literals\nHere is maybe something we could for to start out: https://marketplace.visualstudio.com/items?itemName=webreflection.literally-html\n. ",
    "vdragsic": "+1\n(had to repeat same pattern few times for bithub, so having model collection would be useful)\n. Closing, created new PR #844 for docco branch.\n. @daffl I'll update it, thanks for the tip\n. ",
    "johndierks": "Hey all, this was originally my issue. The .render() call works fine when the environment is seeded with the full array of js files, but doesn't work when only canjs is included. I'm not sure which one breaks the render() call when removed.\n\n. ",
    "dorajistyle": "Yes. I can't edit the Wiki yet. And Github is not support Wiki pulling as well.\n. ",
    "norm-mp": "On this page: http://canjs.com/guides/EJS.html\nThis code:\ncan.view('todosAndUser', {\n    todos: Todo.findAll(),\n    user: User.findOne({id: 5})\n}).then(function(frag) {\n    document.getElementById('todos').appendChild(fragment);\n});\nShould be document.getElementById('todos').appendChild(frag);\n. ",
    "khoinguyen": "I also got the same problem, especially when use with AMD RequireJS, and optimised by r.js\n```\n$ r.js -o build.js \nTracing dependencies for: main\n/Project/www/scripts/main-built.js\n/Project/www/scripts/less.js\n/Project/www/scripts/sockjs-0.3.4.min.js\n/Project/www/scripts/jquery-1.8.2.min.js\n/Project/www/scripts/jquery.ba-hashchange-1.3.js\n/Project/www/scripts/vertxbus.js\n/Project/www/scripts/can/util/can.js\n/Project/www/scripts/can/util/array/each.js\n/Project/www/scripts/can/util/jquery.js\n/Project/www/scripts/can/util/library.js\n/Project/www/scripts/can/view.js\n/Project/www/scripts/can/util/string.js\n/Project/www/scripts/can/util/bind.js\n/Project/www/scripts/can/observe/compute.js <<< Note here, No can/observe was included\n/Project/www/scripts/can/view/elements.js\n/Project/www/scripts/can/view/scanner.js\n/Project/www/scripts/can/view/node_lists.js\n/Project/www/scripts/can/view/live.js\n/Project/www/scripts/can/view/render.js\n/Project/www/scripts/can/view/ejs.js\n/Project/www/scripts/can/construct.js\n/Project/www/scripts/can/control.js\n/Project/www/scripts/domReady.js\ndomReady!\n/Project/www/scripts/app/widget/ChatWidget.js\n/Project/www/scripts/app/main.js\n/Project/www/scripts/main.js\n```\nResult: Uncaught TypeError: Cannot read property '__reading' of undefined \nI fixed this issue in can/observe/compute.js:\njavascript\ndefine([\"can/util/library\", \"can/util/bind\"], function(can, bind) {\nchange to\njavascript\ndefine([\"can/util/library\", \"can/util/bind\", \"can/observe\"], function(can, bind) {\nOutput of r.js\n```\n$r.js -o build.js \nTracing dependencies for: main\n/Project/www/scripts/main-built.js\n/Project/www/scripts/less.js\n/Project/www/scripts/sockjs-0.3.4.min.js\n/Project/www/scripts/jquery-1.8.2.min.js\n/Project/www/scripts/jquery.ba-hashchange-1.3.js\n/Project/www/scripts/vertxbus.js\n/Project/www/scripts/can/util/can.js\n/Project/www/scripts/can/util/array/each.js\n/Project/www/scripts/can/util/jquery.js\n/Project/www/scripts/can/util/library.js\n/Project/www/scripts/can/view.js\n/Project/www/scripts/can/util/string.js\n/Project/www/scripts/can/util/bind.js\n/Project/www/scripts/can/construct.js\n/Project/www/scripts/can/observe.js <<< Note here, can/observe.js was included in the optimised file\n/Project/www/scripts/can/observe/compute.js\n/Project/www/scripts/can/view/elements.js\n/Project/www/scripts/can/view/scanner.js\n/Project/www/scripts/can/view/node_lists.js\n/Project/www/scripts/can/view/live.js\n/Project/www/scripts/can/view/render.js\n/Project/www/scripts/can/view/ejs.js\n/Project/www/scripts/can/control.js\n/Project/www/scripts/domReady.js\ndomReady!\n/Project/www/scripts/app/widget/ChatWidget.js\n/Project/www/scripts/app/main.js\n/Project/www/scripts/main.js\n```\n. ",
    "demyanrogozhin": "Sorry for bumping old issue, but I faced same error.\nAnd that's what I wound:\nFirst of all - generated template is wrong - no can.view.pending() called after adding first tag.\nI added work around: http://jsfiddle.net/qc3XZ/6/\nSecond  - for Observable data types (data.isListening is true) helper return value added on mustache stack, which result invalid HTML : \n< li function(el) { if //..and so on }  data-view-id='2'> observeList broken < /li > \"\nThird - compete-function can return function, but do not call OR even check value is not valid object.\nMy summary:\nUsing helper that return function for observable objects is bad idea.\n. ",
    "crispen-smith": "Awesome, thank you.  I hadn't seen it listed in the public registry or documented on the canjs home page.  I must have missed it.  Thanks again.\n. I think I can own the gap on the Bower side. I'd been searching through\nhttp://sindresorhus.com/bower-components/ for Can rather than Canjs, and\ndidn't go far enough in.\nOn Tue, Jul 2, 2013 at 12:50 AM, David Luecke notifications@github.comwrote:\n\nWe probably do need to add it more easily accessible in the docs but it\ndefinitely should show up in the public registry. Where did you look?\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/issues/442#issuecomment-20326313\n.\n. \n",
    "h16bit": "No, i dont\nThank for you answer, now im understand\n. ",
    "tilleps": "Turns out that the string parameter will need to be converted with can.underscore()\njavascript\n$('body').control('MyPlugin');  // returns undefined\n$('body').control( can.underscore('MyPlugin') ); // returns MyPlugin\n$('body').control('my_plugin'); // returns MyPlugin\nThis does not seem intuitive as initializing the plugin is done with the string defined in pluginName\njavascript\n$('body').MyPlugin();  // initializes\n$('body').my_plugin(); // Error: has no method 'my_plugin'\nNotes/examples of this behavior would be helpful on the documentation page\nhttp://canjs.com/docs/jQuery.fn.control.html\n. Another note, the fullName parameter can.Control() must also be provided in order for control() and controls() to match a control.  \nWould there be any issues assigning pluginName as fullName if fullName is not provided?\n``` javascript\n//\n// Instead of having to manually assign fullName and pluginName\n//\nvar MyPlugin = can.Control.extend('MyPlugin', {\n  pluginName: 'MyPlugin'\n}, {});\n//\n// Allow this instead\n//\nvar MyPlugin = can.Control.extend({\n  pluginName: 'MyPlugin'\n}, {});\nMyPlugin.fullName;  // return undefined (currently)\nMyPlugin.fullName;  // returns MyPlugin (proposed)\n```\n. ",
    "kiennguyen1101": "I've been recently using canjs and have encountered this problem. I'm using plupload plugin to handle file upload and canjs as my framework.\n``` javascript\nvar File = can.Map.extend({});\n//the List is  used for live-binding feature for can.Mustache. Just need to use function Map.attr()\nFile.List = can.List.extend({\n        Map: File\n        //some functions here to work with files\n});\nvar FileUpload = new File.List();\n```\nIn my controller:\n``` javascript\n var Controller = can.Control({\n        init: function (elements, options) {\n            console.log('Controller init!');\n            uploader = new plupload.Uploader({/ options /});\n        can.bind.call(uploader, \"Init\", function (params) {\n            $('#fileList').html(\"<div>Current runtime: \" + params.runtime + \"</div>\");\n        });\n\n        uploader.init();\n\n        can.bind.call(uploader, \"FilesAdded\", function (up, files) {\n\n            //to preserve functions of file's objects created by plupload\n            $.each(files, function (index, file) {\n                FileUpload.push(new can.Map(file));\n            });\n\n            var output = new can.Map({\n                files: FileUpload\n            });\n\n            $('#fileList').append(can.view('templates/fileUpload.mustache', output, {\n                formatSize: function (Object) {\n                    var file = Object.context;\n                    //this is fired twice!\n                    console.log(file.size);\n                    return plupload.formatSize(file.size);\n                }\n                //other helpers\n            }));\n        });\n    },\n    'route': function (data) {\n        // Matches every routing change, but gets passed no data.\n        console.log(data);\n    }\n});\n\ncan.route.ready(false);\nController = new Controller('body');\ncan.route.ready(true);\n```\n. > Can you shorten the example to more clearly illustrate the problem? <\nSure.\nSo I used a List to store my files:\n``` javascript\nvar File = can.Map.extend({});\n//the List is  used for live-binding feature for can.Mustache. Just need to use function Map.attr()\nFile.List = can.List.extend({\n        Map: File\n        //some functions here to work with files\n});\nFileUpload = new File.List();\n```\nNew elements are added to the list using push() function. Each 'file' is an object created by plugin plupload which has its own functions.\njavascript\nFileUpload.push(new can.Map(file));\nFinally, I use can.view and mustache to display my list. The helper function 'formatSize' will be fired twice.\n``` javascript\nvar output = new can.Map({\n                    files: FileUpload\n});\n$('#fileList').append(can.view('templates/fileUpload.mustache', output, {\n        formatSize: function (Object) {\n                   var file = Object.context;                     \n                        console.log(file.size);\n                        return plupload.formatSize(file.size);\n        }\n                    //other helpers\n}));\n```\n. Yes, the template was calling formatSize\n. ",
    "djdev": "So, when will it go to the FOR loop.\nAnd is it advisable to return NULL from a function.\nOn Fri, Aug 23, 2013 at 2:19 PM, David Luecke notifications@github.comwrote:\n\nIf you mean\nhttps://github.com/bitovi/canjs/blob/master/view/mustache/mustache.js#L1653,\nthis is a common JS practise called early return. This avoids going through\nthe whole loop because the function returns as soon as a matching helper\nhas been found. I generally recommend using it. The easiest case looks like\nthis:\nfunction early(condition) {\n    if(condition) {\n        return 'true';\n    }\nreturn 'false';}\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/issues/465#issuecomment-23181642\n.\n. \n",
    "nvcnvn": "Sorry, I fogot to markup a part of my question (updated).\nIf I add anything inside my row-data div then my template will break.\nDo you need my JSON data?\n. Sory for late reply:\nHere is my 90% code and data: https://gist.github.com/nvcnvn/fbe8f19ba2ea9bac127b\n. ",
    "jflemingsignifi": "What is happening here is that if the controller is created after the can.route with defaults, the controller route is blowing away the old route and replacing it with one with no defaults.\n. ",
    "jaredstehler": "If I read the original post correctly, the main issue is not that things are changing at the API level, but that the versioning scheme is misleading.  Perhaps if something more like Semantic Versioning (http://semver.org/) were used, such that breaking changes bumped the major number, that would make things clearer. \n. Yup, that makes sense. The minified size issue does present a problem for compatibility, and Jquery has notably introduced breaking changes in point releases as well. I will admit to similar confusion in the jmvc suite, but thus far canjs has been a much smoother ride.\n\u2014\nSent from Mailbox for iPhone\nOn Thu, Sep 19, 2013 at 10:01 AM, Justin Meyer notifications@github.com\nwrote:\n\nI've avoided semantic versioning because it doesn't easily distinguish between major breaking changes and minor. \nJMVC 3 was radically different from 2. Very few things would work in an upgrade.  While 3.1, 3.2, 3.3 had breaking changes, they were not breaking everything. \nThis is similar to jQuery's versioning that 1.0 -> 1.10 had breaking changes but 2.0 was very different. \nIf we followed semantic, this information would be lost. Kind of like how chrome versions have become meaningless. You can't easily label which version of chrome brought what feature. \nSent from my iPhone\nOn Sep 19, 2013, at 8:17 AM, Jared Stehler notifications@github.com wrote:\n\nIf I read the original post correctly, the main issue is not that things are changing at the API level, but that the versioning scheme is misleading. Perhaps if something more like Semantic Versioning (http://semver.org/) were used, such that breaking changes bumped the major number, that would make things clearer.\n\u2014\nReply to this email directly or view it on GitHub.\nReply to this email directly or view it on GitHub:\nhttps://github.com/bitovi/canjs/issues/482#issuecomment-24740659\n. \n\n",
    "isadovskiy": "I see. Thanks for the clarification.\n. Just wondering, why in this case works without can.view.frag() call?\nvar view2 = can.view.ejs(\"<p>Current Time <%= model.attr('now') %>\"); \nthis.element.append(view2({model: model})); // works fine\nShouldn't can.view.ejs(str) returns renderer, not fragment, to be consistent with can.view.ejs(id, str) call?\n. Sure. I'll create another ticket for this issue.\n. Thanks for your response! I did not figure out renderer function could accept deferred as an argument. Looks like documentation misses it (or I missed it in documentation ;)\nI'm not sure I understand your question about sync/async template loading... But in general I walked in the same way as discussed at http://forum.javascriptmvc.com/topic/package-compiled-ejs-templates-with-requirejs and faced the same issue: \"ReferenceError: window is not defined\". \nHowever I was able to work-around it. The I just needed to eliminate all calls contained \"window\" reference. The most of calls came from jquery, which is referenced from can/util/library. So I just override can/util/library module in build.js with my own module, contained functions, necessary for can/view and can/view/ejs. There are just few necessary functions: extend, isFunction and map. As a result I was able to get can/view and can/view/ejs routines work in optimizer run-time enviromnent and pre-compiled EJS template output to my destination JS file. I also added excludeShallow: ['can/util/library'] to my build.js to exclude my custom module stab from the build. i also fixed few \"window\" references in can/view and can/view/elements by adding \"typeof window !== 'undefined'\" (it does not break any existed logic there).\nAs a result I get single compiled JS file with pre-compiled templates inside. The only problem at the moment is \"can/util/library\" and \"can/util/jquery\" modules are excluded from the build at the moment and loaded in run-time. I'm working on solution for.\nProbably overall solution is not elegant (provide window-agnostic core library to optimizer run-time to let existed view/ejs code to do all heavy lifting). But at least it works for me. I can share results later, when come to the final approach.\n. David, are you sure your code snippet above actually works? I can not get it work and I also do not see how it could be supported from sources...\n. I should complete my researches early next week and will share results via github.\n. Here is plugin and example, which allows to pre-compile EJS templates with the same plugin, which is used for EJS templates run-time loading: https://github.com/isadovskiy/canjs-require-ejs. It's not perfect at the moment. I still did not find an elegant way to eliminate jquery dependency from EJS processing engine. I'm discussing some options with James Burke on requirejs github forum to find a workaround for.\nI also looked for a way to refactor canjs view-related modules to eliminate DOM dependencies from template processing. I found it's possible. However a lot of refactoring work is required. And I'm not familiar with canjs sources so good to take responsibility to make such changes. If you guys are interested in EJS templates pre-compilation, we can discuss my findings in a separate thread.\nI already introduced few small compatimility fixes into canjs sources, which are uploaded into https://github.com/isadovskiy/canjs-require-ejs. I made a separate commit with the changes to original code so you will be able to find the changes easily using change log.\n. Finally I get working example of the EJS template plugin with the pre-compilation support. Moving related discussion into separate topic: https://github.com/bitovi/canjs/issues/491\n. I'm actually not sure if it's possible or makes sense... can.view() does all Deferred-related magic currently (as well as wrapping renderer into can.view.frag() call for live binding). While renderer is just a function, which comes from can/view/ejs or can/view/mustache and renders template. So, as for me it makes sense to let can.view() to make its current job, which includes lazy model initialization. Just need to let can.view() accepts renderer function as a first argument (as proposed in https://github.com/bitovi/canjs/issues/484). It's an easy fix. And it also consistent. \n. In general yes.\nBut the main trick is here: https://github.com/isadovskiy/canjs-require-ejs/blob/master/src/plugin/ejs.builder.js\nrequire.config({\n    map: {\n        '*': {\n            'can/util/library': 'can/util/optimize'\n        }\n    }\n});\nIt replaces core library, which has DOM dependencies with my own, which provides few DOM-independent routines, required for EJS compilation. Since it's replaced in plugin builder, it affects just executions in optimizer environment.\nCurrently \"can/util/optimize\" is mapped to ejs.library in build.js:\npaths: {\n    'can/util/optimize': 'plugin/ejs.library'\n}\nBut in general can/util/optimize should be a part of the CanJS and named \"can/util/core\" or something similar. And should replace \"can/util/library\" with map config to run plugins in optimizer environment.\n. Thanks for your update, rjgotten. It makes sense. I just do not agree on point 2. As I understand, config.map option can actually be used for run-time dependencies changes. That's why config.map is used in plugin builder instead of config.path to configure 'can/util/library': 'can/util/optimize' mapping. At least code sample I shared works fine. All dependencies are resolved correctly. Original can/util/library gets into the compiled JS file and I do see any issues with.\nBut in general I do agree your approach is more safe.\n. > A mapping redefinition will do nothing if the module in question has already been requested and loaded.\nYou are completely incorrect about. Please double check the RequireJS documentation. Map config allows to re-define module in run-time, even if this module is already loaded by dependency manager. You can check the example: https://github.com/isadovskiy/requirejs-sample4. Run-time module re-mapping works not only in optimizer, but in browser environment as well.\n\nthe only reason the proper can/util/library gets pushed into the compiled JS, is because it was processed before your plugin builder was first hit and the dependency could be remapped. This does not have to be the case for every build setup.\n\nIn general you are correct. However I can not imagine the case, when plugin will be the FIRST dependency, loaded in your CanJS application. Every CanJS module depends on \"can/util/library\". Optimizer uses sync module loading method. It means the modules will be loaded in order they are requested. Since the entry point to your application is controller, most likely, 'can/control' and it's dependencies will be loaded first. However, I do agree, under some circumstance the provided approach is unsafe.\n\nWhat you are doing is inherently unsafe and should not be accepted as a solution.\n\nI do not pretend on the final solution, which completely closes the issue :) This is just an approach, which shows the direction, how the issue can be resolved. I spent several days trying to find any working solution. However I did not find it. So I spent additional several days to get the approach which works and even created worked example, which can be used as a start point to resolve the issue.\nIt's up to Bitovi guys if they will go this this, similar or completely different approach, if they want to resolve the discussed issue.\n. I updated plugins and example code. The latest results are here: https://github.com/isadovskiy/require-canjs-template\nChanges:\n1. Based on CaJS 2.0.5\n2. Support both for EJS and Mustache templates are added\n3. More clear example code.\n. Sure! No any objections from my side.\nOn Wed, Feb 11, 2015 at 9:36 PM, Justin Meyer notifications@github.com\nwrote:\n\n@isadovskiy https://github.com/isadovskiy I would like to get this into\nCanJS. Can I rename / cleanup the issue to make it clear that we would\nsupport plugins for building stache / mustache / ejs templates? Thanks.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bitovi/canjs/issues/491#issuecomment-73936945.\n. @justinbmeyer at the moment we are completely switched to StealJS. So we ar not so interested in AMD support. \n\nI also see https://github.com/canjs/steal-stache already supports AMD/RequireJS. Or am I missing anything?\n. Hello David.\nTried:\nteam.attr('players.0').attr({});\nconsole.log(team.players[0] instanceof Player); // false\nStill false...\n. Hello Justin.\nResult is absolutely the same - does not work... I created jsfiddle so you could test by yourself: http://jsfiddle.net/vuXau/\nIt's obviously CanJS issue...\n. Any update on the issue? Could someone at least point me to the place where to dig so I could fix it by myself.\n. Thanks for your feedback, David!\nLooks like the magic with the example above is to do push() first. Without initial push, subsequent team.attr('players.0').attr({}) does not work. See http://jsfiddle.net/vuXau/2/\nHowever at the moment it's fine to have \"push\" workaround for me. I can initialize my list with push and then update with attr('players.{index}').attr({}). Thanks again for your suggestion.\nKeeping the issue open to get more robust fix in the future versions.\n. Justin, I'm not sure if it's possible. Since looks like attributes plugin breaks the code above. Is there another way to cast Object to Player automatically, without using attributes plugin?\n. Closing the issue since can/map/define plugin resolves it.\n. I'm interesting in the answer too.\n. Any feedback on this issue?\n. For some reason tests does not work for me...\n```\nRunning \"qunit:steal\" (qunit) task\nTesting http://localhost:8000/test/jquery.html\nWarning: PhantomJS timed out, possibly due to a missing QUnit start() call. Use --force to continue.\nAborted due to warnings.\n```\nTests are lunched. I even can open test page in browser. But suddenly it interrupts by timeout...\n. Win7\n. I extended timeout to 60,000 ms. It gave time to pass http://localhost:8000/test/jquery.html test in browser:\nTests completed in 25489 milliseconds.\n1959 assertions of 1959 passed, 0 failed.\nBTW, as for development/contribution to CanJS - do you have any instructions (rules to create branches for fixes, pull requests and etc)?\n. I re-compiled the code with uncommented /, options/ param and run the tests in browser. Both test/jquery.html and test/dist/jquery.html worked out fine for me, without errors.\n. To submit a fix, should I create a branch in original canjs repository or in own forked repository?\n. Thanks for the clarification, Matthew. \n. Sorry for\n. Yes, already made a post there: https://forum.javascriptmvc.com/#Topic/32525000001604001\nHowever looks like such kind of logic is not available in CanJS right now... In this case, if there is no way to listen for view change, I will need to open feature request here..\n. My bad, sorry. Should read the documentation more carefully next time. Thanks for the quick response! Closing the ticket.\n. BTW, wouldn't safe to handle {{#list}} in the same way as {{#each list}} automatically to avoid such issues, made by mistake? Looks like an easy fix - check for {{#xxx}} operand type and launch {{#each xxx}} workflow for if it's an instance of can.List?\n. Thanks for the clarification. Completely makes sense now for me.\n. Yes. But in general it looks like a bug. Will it be fixed with future releases? Since extra wrapping/unwrapping to map costs some performance...\n. I will try.\n. BTW, another issue with the provided example is some helper arguments are passed into helper as computer functions. I should obtain the value from computer explicitly:\nplayer1 = can.isFunction(player1) ? player1() : player1;\nplayer2 = can.isFunction(player2) ? player2() : player2;\nIt looks like a bug for me since adds complicity and extra logic into my code. Is it bug or designed in this way?\n. Thanks for the explanation! Makes sense.\n. As for me initial example, _data field for player2 refers Map instance instead of plain Object: http://take.ms/nB277\n. Here is minimal example, displayed the issue: http://jsfiddle.net/ML8T2/12/\nAs you can see, \"raw\" data field type for selectedPlayer map object is can.Map, which is incorrect.\nIf you comment \"selectedPlayer: Player\" line in \"attributes\" configuration, it will turn to Object and work as expected.\nOriginally I noticed this issue in the application I'm working on now. It has the functionality, which is similar to the original example I posted (with player selection via UI). It throws JS error for me, when I clicked on the player name. Debugger said, error happened when Map tried to wrap some \"internal\" property (like \"_computedBindings\") into computer. I tried to create minimal example, but JS error did not happen there. Just comparison in helper function did not work (see original bug report). \nSo (accounting last example), something is wrong with attr() method in attributes plugin. It does not detect if value, passed inside attr() method is already Map instance and tries to wrap it again with Map.\n. Closing the issue since can/map/define plugin resolves it.\n. From Docs: concat makes a new List with the elements of the List followed by the elements of the parameters.\nSo it's already in place.\n. According to docs, {{else}} should work with any helper, which starts with # (http://canjs.com/docs/can.mustache.helpers.else.html), including user-defined helpers. And it works. Except for {{unless}}. \n. Ok, got another example which could give some glue for Bitovi team: http://jsfiddle.net/jd44f/7/\n. Yes, it will be work around for this issue. \nThis post were made as bug report for future releases. \n. Please check this example: http://jsfiddle.net/jd44f/7/. It's a bug...\nAs for define plugin, it's just an optional plugin, which can be omitted at all.\n. Here is an example without define plugin: http://jsfiddle.net/jd44f/8/\n. Yes, it worked with 2.0.5 and stopped working after upgrade to 2.1.2\n. Sure, it's not a problem to have such kind of wrapper. \nThe reason I created this topic is just to track it as a feature request and possible location of the future pull requests.\n. It's actually not just registerHelper question. If you take a look at Handlebars-Layouts library for example, you will see it obtains the reference to Handlebars object and uses it (it's API internally):\nvar Handlebars = require('handlebars');\nrequire('handlebars-layouts')(Handlebars);\nHandlebars-layouts uses Inside not just Handlebars.registerHelper method, but Handlebars.compile and etc.\nWell, it also uses undocumented Handlebars.partials. So probably handlebars-layouts is not the best example.\nBut thing like accepting Object as a single argument for registerHelper() would be useful in CanJS\n. Yes, I planned to create such kind of plugin. So will contribute it to CanJS once complete.\n. Probably makes sense to maintain \"define\" section as a class-level property (in the same manner as map.attributes were)? \n. Any update on this issue?\nOr there is a workaround, which allows to create MapA -> MapB -> can.Map inheritance chain and define properties both on MapA and MapB level?\n. Any update on this?\n. Thanks for your feedback, @justinbmeyer! If I get a chance, I'll try to implement this by myself and submit pull request.\n. Does it mean there is no way to load stache views and compile them with steal-tools using system plugin in AMD-style project?\n. @matthewp, do you mean we need to configure SystemJS to use \"steal\" version of the canjs (https://github.com/bitovi/canjs.com/tree/master/steal/can) within our AMD-style project?\n. We are going to use StealJS. So \"steal\" version of CanJS will work for us. But in general it would be great to have AMD version of the system plugin to be compatible with SystemJS as well. \nThe one thing I really like about the work you guys do in Bitovi is incredible flexibility for any dev workflow. So supporting SystemJS/AMD workflow would be really nice to have.\n. @matthewp, thanks for the tips!\n. I can try with 2.1.4\n. Looks like the issue existed at least since 2.1.4: http://jsfiddle.net/cs725u9e/3/\nSo it's not 2.2 regression issue.\n. @justinbmeyer, as I remember, you explained at some point, {{#list}} re-renders the whole list, while {{#each list}} re-renders just necessary elements. Isn't the case anymore?\n. Thanks for this update, @justinbmeyer. No immediate need to hack it.\n. Per documentation, unbind() is just an alias of removeEvent() (http://canjs.com/docs/can.event.unbind.html). Totally makes sense to keep everything consistent and to not add new methods but use existed one.\n. > Also, stache sub expressions are called more like functions\nYeah. But in this case they will be looked up in context/viewmodel first (per call expressions documentation). So using helper syntax allows to lookup them in helpers first, which is a micro performance optimization from my point of view. So if I would like to execute helper, I would like to invoke it as a helper to lookup it in helpers instantly.\n. I was able to get my example works for call syntax by adding commas. \nI also figured out, for call syntax I need to lookup hash values in options.hashKey, rather than options.hash.hashKey (like in helpers syntax). But I think it introduces another issue. Now my helper's code depends on the way I'm invoking it. So basically helper should be invoked using just \"call\" or just \"helper\" syntax all through the code. Else it just won't work since hash key will be looked up in the wrong place. It's an issue for big projects and library projects...\n. yes, totally makes sense. So looks like we will follow https://github.com/canjs/can-stache/blob/master/helpers/route.js#L24 approach. \n. But still wondering if it makes sense to have sub-expressions and hashes with old helpers syntax? Or helper lookup order could be worked around in some other way?\n. I think you can introduce some special symbol prefix before function in call expression, which will tell engine to lookup function among helpers first. This aligns with another similar concepts in the canjs.\n. @justinbmeyer yes, looks like good solution for me. However calling another helpers from sub-expression will make such statements a bit verbose\n{{%helpers.foo (%helpers.bar (%helpers.buz (0 buz=1) bar=2) foo=3) }}\n. yes, missed commas. But in general yes, should work. It lines up wi the similar syntax in https://canjs.com/docs/can.view.bindings.event.html#sig__VIEW_MODEL_EVENT___CALL_EXPRESSION_\n. ",
    "cl-ment": "I am not really happy with this fix.\nIMHO it would be valuable to change the model.destroy signature from: \ncan.Model(\"Person\",{\n        destroy : function(id, success, error){\n        ....\nto: \ncan.Model(\"Person\",{\n        destroy : function(id, attr, success, error){\n        ....\n. ",
    "simpleTechs": "Hey @schovi,\nin fact, I also was trying to do something like this. Maybe you could have a look at this, I just added some code of mine that I built for #549: http://jsbin.com/avUVepUp/3/edit?html,js,console,output\nThis is not perfect and I know it, but it seems people are looking for this kind of functionality in canjs?\n. Here's a JSFiddle to show the issue: http://jsfiddle.net/simpleFabian/TWHFs/2/\nComment out the first few lines of js to see the problem.\nAlso, livebinding will only work on properties that were present when binding was initialized - can this be circumvented somehow? (See in this example only \"Middle West\"'s checkbox will update correctly, as it has had the property selected before being bound.)\n. Well, yes, many tests are failing, but this is due to the fact I submitted the pull against current head, not against, say, tag 2.0.0. Just tried the latter locally and every single test is fine.\nShould I re-submit?\n(In fact, https://github.com/bitovi/canjs/commit/7d38e299d240c19d3bfb8a364de4b142661162d5 seems to have solved the test-failures)\n. Hey Josh,\nthanks for looking into this!\nI just want to make sure we're talking about the same issue:\nWhat I talk about is not line 16 in my fiddle, but rather line 11.\nSee, when calling c1('after') the mustache updates accordingly - but calling c2('after') does not.\nThe thing is, my compute is updated outside of the map, but bound to from inside. (Does this even make sense to you? :-))\nI'm not quite sure if that's the same thing you are into here, but that may totally be on me - is it?\nBest regards,\nFabian\n. @daffl Well, I think it should depend on where the user is at when the id changes. So if he was on \"test\" before, this should fire. I don't think my changes do account for this, though.\n@justinbmeyer The implicit definition is actually part of canjs since I have used it, and it allows you to \"just define the route\" without caring about registering it.\nRegarding your 2nd question: in fact, it is. Because the pattern that was matched was /:view/:id. The problem is, that if you define another route as /:whatever/:id, this route might be matched first and of course destroy the whole idea of it.\nAnother problem, I ran into:\nDue to the fact the controls must be initialized in order to receive route-events, this will totally mess up a project with existing controls. I didn't really think of this in the first place, but canjs now thinks every control is active, thus listens for all the events, adds the controls name to the element, and so on. So maybe this may serve as a starting point, but it should totally not be included in the source right now. I'm sorry for this!\n. Phew, let me look into my code and see if I can make it test out of it.\n. Hm, I'm not quite sure if the test is a good idea. It works, if you run it in the browser and with jQuery. It won't work with any other lib (due to the fact I needed jQuery's .remove in order to actually remove the DOM-node.)\nIf you have any idea how to do that without jQuery, please tell me. If I do it simply by using parent.removeChild() the node will be gone from DOM, but the binding will still have this.element; while using $('select').remove() does set this to null - thus, causing the issue.\n. Awesome, thanks for the hint :-) I was able to build a working async-test now and even find another issue which I fixed with the latest commit. All should be fine now.\n. ",
    "groue": "The correct (updated) link to the GRMustache documentation of template inheritance is https://github.com/groue/GRMustache/blob/master/Guides/template_inheritance.md\n. ",
    "kustaahuhtala": "With the latest canjs (2.0.4) the error message is actually \"Uncaught RangeError: Maximum call stack size exceeded \".\n. ",
    "karthilxg": "Oh I didn't know that 'can.fixture' is always async, thanks for letting me know.. I wanted to make a sync service call, till the service is ready I'm trying to mock the service call with fixture.. \n. My Construct Object has an init method which triggers the ajax call and the construct object is passed as an arg to the control, which expects the ajax response data on the control's init method. Please find the below code and share your thoughts..\n``` js\n//Control\nSampleViewControl = can.Control({\n                    init: function () {\n                        this.viewData = this.options.data.sampleData;\n                    }\n                });\n//View Construct\nSampleViewConstruct = can.Construct({sampleViewData: {},\ninit: function () {\n    $.sampleAsyncAjax('data/sample.json', {}, false, 'json', this.sampleView_success, this);\n},\n// ajax success method - method sampleView_success\nsampleView_success: function (response, self) {\n    self.sampleViewData = response;\n}\n});\n//instantiation\nvar sampleViewControl = new SampleViewControl(' ', {\n                    data: new SampleViewConstruct()\n                });\n```\n. ",
    "wulftone": "Ah yeah, what I meant was filter, anyway.  Thanks for pointing that out!  I wasn't sure what can.Map.List did, without that documentation.  I just included the file (and changed @map to @filter) and it worked!\nBut shouldn't it be can.List.Map instead of can.Map.List?  It seems to operate on List, not Map, which is a different data structure.\n. Sounds great, thanks again!  Closing.\n. ",
    "dabrosch": "My initial assumption appears to be wrong; it simply seems to be that in my example \"item.text\" does not end up referencing the getter/setting in the constructor, but instead refers to a non-existent property on the instance (until it is set on line 26). It still seems odd to me.\n. ",
    "ewongmindjet": "Thanks!\n. ",
    "Helidium": "By all means.\nFor further investigation:http://forums.mozillazine.org/viewtopic.php?f=9&t=2390879https://bugzilla.mozilla.org/show_bug.cgi?id=593910\nRegards,\nDate: Sun, 1 Dec 2013 10:59:43 -0800\nFrom: notifications@github.com\nTo: canjs@noreply.github.com\nCC: helidium@hotmail.com\nSubject: Re: [canjs] Update pushstate.js ( Fix for firefox push/replacestate override problem... (#584)\nThanks! We will need a test before it finds its way into core. \nSent from my iPhone\n\nOn Dec 1, 2013, at 2:28 PM, Helidium notifications@github.com wrote:\n...)\nHi I was using canjs with new pushstate functionality. All is working well in chrome / opera but not in firefox. The browser stopped listening to url changes all of the sudden after a couple of seconds of inactivity. The most bizzare situation which I am still not familiar with was when I changed any map property with attr the setState was called, otherwise not.\nAnyway I deleted the push/replacestate override and call the setState in the click handler.\nYou can merge this Pull Request by running\ngit pull https://github.com/Helidium/canjs patch-1\nOr view, comment on, or merge it at:\nhttps://github.com/bitovi/canjs/pull/584\nCommit Summary\nUpdate pushstate.js ( Fix for firefox push/replacestate override problem)\nFile Changes\nM route/pushstate/pushstate.js (16)\nPatch Links:\nhttps://github.com/bitovi/canjs/pull/584.patch\nhttps://github.com/bitovi/canjs/pull/584.diff\n\n\u2014\nReply to this email directly or view it on GitHub.                  \n. ",
    "cherifGsoul": "This bug still exist even with append function http://jsfiddle.net/cherif_b/emrGQ/\n. Ok thank you\n. Me like @matthewp I dont know the existance of this 2 features like this CanJS can be easily integrate 3rd party ui components.\nAwesome as always \n. I see it as a clean API for defining business logic services I like it\n. I think like this things will be more complicated, I like templated event handler in controls, but not the same notation in the viewModel\n. @justinbmeyer Yes I know this is not event handling here, just not fan of doing this declaratively\n. @daffl what about this line https://github.com/bitovi/canjs/blob/master/component/component.js#L79? the rendering will be can.stache or a check which engine is used \"legacy\" or \"stache\"!\n. @justinbmeyer is there specification (doc) for can.connect? What about can.Model after that? does MVVM better than MVC?\n. Im with @justinbmeyer validation in the view (if is in declarative manner) will be great flexibility IMO validation on client side should be different from the server (like Rails), maybe parsleyjs can be considerend as example too http://parsleyjs.org/ \n. @matthewp you mean I have to change theme to spaces?\n. @justinbmeyer I work on Win i dont know if it's the source of the problem!\n. Cool :)\n. the test fails in yui.html? an idea?\n. @matthewp could you tell me where is the error?\n. @justinbmeyer sorry I have been busy, thanks for the merge\n. This will be great, I can add: \n- Inspecting performance benchmarking\n- Inspecting dependencies\n. @justinbmeyer dependencies I mean if the module depends on onther module from CanJS for example can.Component depends on can.Map and can.Map depends on  can.map.define .\nFor benchmarkin I mean performance mesure, memory, time loaddin etc\n. even with radio buttons\n. Great, I need those tips, you rock.\n. Up vote, this will be great feature\n. Why the rough implementation creates script element for each component file? as long as can.Component instantiate itself I think all we need is the custom tag in the DOM and the components can be loaded at once (maybe minified)\n. Sorry for my limited english, what I mean is components files can be loaded all at once because there's no component instantiation if it's template is not present,  what is the goal of the progressive loading in this case?\n. Im talking about the import part because IMO components dont need progressive loading,  maybe im wrong because it treats components and other modules loading, I have a little idea that will be shared soon.\n. \"treats\" => do the loading action, what I mean, the admin component file can be loaded in this case even if it is not used yet, but its custom tag is not present in the DOM, like this component progressive loading is not very important IMO (just for component case).\n. this is a quick example for what I mean even if page component are present they are not instantiate if their templates are not rendred\nhttp://jsbin.com/yuyumu/2/edit \nthe gist https://gist.github.com/cherifGsoul/645db39ab8e8b24505d9 .\n. For 404 is the jsbin behavior when working with route, try it in full window http://jsbin.com/yuyumu/2#!  I undertand the need for progressive loading for modules but component.\n. @justinbmeyer I like this I wonder if can-route tag will be wrapper for the app or just hidden tag to handle can.route in declarative manner?\n. @matthewp IMO even this wont simplify the route, the main reason is not CanJS but other frameworks where application code has tight coupling to route (like backbone) the new developers may get this quickly but it will be hard for developer who change the framework/library\n. @justinbmeyer can you tell me if the  will be better if is based with can.view.tag or can.Component?\n. @justinbmeyer I already did a rough example for this in the jsbin above, if you have some time can you tell me what you think about it? I named it ui-manager\n. this could be implemented with helplers?\n. @justinbmeyer Can you give more details on this? \nI dont understand how to pass arguments?\nkey 1 key2 represent what? does the can-EVENT view/binding will be affected or remain the same and add this as a plugin?\n. you can stop routing after displaying the error page with can.route._teardown()\n. @jandjorgensen take a look at this issue https://github.com/bitovi/canjs/issues/1216 , sounds related, I think the best way for multi pages navigation is to have a page component that can be composed of several component, the page  reflects the high level application state or the global state (page) and page components can have local state, just a theory.\n. The problem is if the viewModel will be in the can.route.map the attribute can be displayed in the url for example: /#!some-path&role=button\n. @justinbmeyer here is a fiddle http://jsfiddle.net/cherif_b/88drbcxx/ that demonstrate the issue\nsorry if im late I was busy with work :)\n. @justinbmeyer sorry Im late it seems it is removed in 2.3 version so you can check it in 2.2 version http://canjs.com/2.2/guides/Utilities.html \n\n. @justinbmeyer it was a question posted in gitter maybe users need it for some reason but the correlation between serialize and keys might be true\n. a ncie one thank you for this :+1: \n. @daffl can you see why the build failed? I tried to correct the test but it dosent work in my computer the npm test pass like a charm\n. @justinbmeyer Can you tell me please why the build dosent work?\n. @justinbmeyer @daffl this can be merged\n. @pYr0x is it fixed?\n. @pYr0x what about if you use hypen in your custom tag? like ui-welcome\n. Why the importing paths are different? \nimport appTemplate from \"src/app.stache!\";\ncan-import from=\"testapp/components/welcome/\nI think paths should be changed\n. Nice to know thank you @matthewp \n. Yeah, I missed that \n. thank you @pYr0x :). @chasenlehara ok I take it. @chasenlehara PR was sent https://github.com/bitovi/canjs.com/pull/269. @bmomberger-bitovi yes that was the idea, I like Standard Base also, I just found https://github.com/stdlib-js/stdlib so this can clashes with std I want to say bedrock but it is taken too https://github.com/digitalbazaar/bedrock so maybe Javascript Standard Foundation (JSSF) and I found this https://github.com/JSFoundation close to that name.. this because of the trainling slash in the begining of the links in the markdown.. @phillipskevin the requested changes are commited thank you for checking :). It would be great if the guide will have how to handle models relations, example Post map has many Category maps (Category.List) than how to handle categoryIDs <=>Category.List?\nI'm assuming that Post and Category are models with can-connect:\n```js\nvar Category = DefineMap.extend({\n  id: 'any',\n  name :'string'\n});\nvar Post = DefineMap.extend({\n  id: 'any',\n  title: 'string',\n  categories: {\n    Tye: Category.List,\n    Value: Category.List\n  }\n});\nvar EditPostVM = DefineMap.extend({\n  post: {\n    Type: Post,\n    Value: Post\n  },\n  categoryIds: {\n    Type: DefineList\n  },\n  /*\n   * for categories list\n   /\n  categoriesPromise: {\n    value: function() {\n      return Category.getList({})\n    }\n  },\n  addRemoveCategoryId:function(ev) {\n     //...\n  },\n  savePromise: function() {\n    // ....\n  }\n});\n//stache\n...\n{{#if categoriesPromise.isResolved}}\n {{#each categoriesPromise.value}}\n    \n\n\n {{/each}}\n{{/if}}\n....\n```. Here is a list to track changes in modules for the first part of the issue, the checked means is approved and merged:\n\n[x] can-ajax\n[x] can-assign\n[x] can-attribute-encoder\n[x] can-attribute-observable\n[x] can-bind\n[x] can-component\n[x] can-compute\n[x] can-connect\n[x] can-connect-feathers\n[x] can-connect-tag\n[x] can-construct\n[x] can-construct-super\n[x] can-control\n[x] can-data-types\n[x] can-debug\n[x] can-define\n[x] can-define-backup\n[x] can-define-lazy-value\n[x] can-define-stream\n[x] can-define-stream-kefir\n[x] can-define-validate-validatejs\n[x] can-deparam\n[x] can-diff\n[x] can-dom-data\n[x] can-dom-data-state\n[x] can-dom-events\n[x] can-dom-mutate\n[x] can-event-dom-enter\n[x] can-event-dom-radiochange\n[x] can-event-queue\n[x] can-fixture\n[x] can-fixture-socket\n[x] can-globals\n[x] can-kefir\n[x] can-key\n[x] can-key-tree\n[x] can-list\n[x] can-local-store\n[x] can-log\n[x] can-make-map\n[x] can-map\n[x] can-map-define\n[x] can-memory-store\n[x] can-namespace\n[x] can-ndjson-stream\n[x] can-observation\n[x] can-observation-recorder\n[x] can-observe\n[x] can-param\n[x] can-parse-uri\n[x] can-query-logic\n[x] can-queues\n[x] can-realtime-rest-model\n[x] can-reflect\n[x] can-reflect-dependencies\n[x] can-reflect-promise\n[x] can-reflect-tests\n[x] can-rest-model\n[x] can-route\n[x] can-route-pushstate\n[x] can-set-legacy\n[x] can-simple-dom\n[x] can-simple-map\n[x] can-simple-observable\n[x] can-stache\n[x] can-stache-bindings\n[x] can-stache-converters\n[x] can-stache-key\n[x] can-stache-route-helpers\n[x] can-stream\n[x] can-stream-kefir\n[x] can-string\n[x] can-string-to-any\n[x] can-super-model\n[x] can-symbol\n[x] can-test-helpers\n[x] can-util\n[x] can-validate\n[x] can-validate-interface\n[x] can-validate-legacy\n[x] can-validate-validatejs\n[x] can-vdom\n[x] can-view-autorender\n[x] can-view-callbacks\n[x] can-view-live\n[x] can-view-model\n[x] can-view-nodelist\n[x] can-view-parser\n[x] can-view-scope\n[x] can-view-target. @chasenlehara all listed modules were fixed I think we can close this!. @chasenlehara Allegorie group website uses CanJS for the social wall too.\nIt is in the homepage and in the Social wall page. ## Packages need to be fixed:\n\nInfrastructure\n\n\n[x] can-bind: Object.assign error\n\n\n[x] can-control\n\n\n[x]  can-dom-events: new Event() Object doesn't support this action\n\n\n[x] can-event-queue/map: Error on dispatching events \n\n\n[x] can-queues: log tests fail\n\n\n[x] can-reflect-dependencies: test fails, Unable to get property 'whatChangedMe' of null\n\n\n[x] can-view-live\n\n\n[x] can-view-parser PR\n\n\n[x] can-view-scope: Object.assign error\n\n\n[x] can-stache-converters: \u2714\ufe0f Object.assign error, \u2714\ufe0f Invalid argument from can-dom-mutate\n\n\n[x] can-attribute-observable: Object.assign (Kevin)\n\n\n[x] can-dom-mutate: \u2714\ufe0fArray.from, \u2714\ufe0fExpected \":\" SyntaxError,  \u2714\ufe0fObject doesn't support contains, \u2714\ufe0fObject doesn't support this action, \u2714\ufe0f Invalid argument here(Kevin)\n\n\n[x] can-dom-data-state: Object doesn't support contains (Kevin). ## Packages need to be fixed:\n\n\nCore:\n\n\n[x] can-component (Cherif,Kevin) PR, window.item issue\n\n\n[x] ~~can-define~~\n\n\n[x] can-route (Cherif) PR\n\n\n[x] ~~can-route-pushstate~~\n\n\n[x] can-stache \u2714\ufe0fArray.prototype.includes, \u2714\ufe0fBracket test failure (Symbols) (Kevin)\n\n\n[x] can-stache-bindings (Kevin)\n\n\n[x] can-query-logic\n\n\n[x] can-value\n\n\n[x] can-connect (Cherif)  PR\n\n\n[x] ~~can-stache-route-helpers~~\n. ## Packages need to be fixed:\n\n\nEcosystem:\n\n[x] can-define-backup (Kevin)\n\n[x] can-view-autorender all tests are passing but can-dom-mutate throws an error Object doesn't support this action in line . I started working on can-stache for this and made a branch https://github.com/canjs/can-stache/tree/fix-debug-webpack-style it needs webpacks test suite!. @chasenlehara when you said I propose that we add tests to the main CanJS test suite that load all the modules with webpack you mean loading test modules?. Should we write tests that check that warning and debug messages ar e not displayed in the production builds?. @matthewp can you please tell me what do you mean by \"clone\"? write the same tests for webpack?. @matthewp thank you, that's what I'm doing now, I just want to have some ideas on how tests could be written.. @phillipskevin this what should be closed for fixning dev mode!. The checked items are fixed and merged:\n\n\n[x] can-compute@4.0.3 (PR sent and in review)\n\n[x] can-make-rest@0.1.3\n[x] can-connect-feathers@5.0.0-pre.3\n[x] can-construct-super@3.1.4\n[x] can-define via can-simple-observable\n[x] can-define-validate-validatejs@1.0.1\n[x] can-fixture-socket@2.0.0-pre.1\n[x] can-list@4.0.2\n[x] can-map@4.0.1\n[x] can-map-define@4.0.0\n[x] can-reflect-promise@2.0.1\n[x] can-route@4.1.2\n[x] can-route-pushstate@4.0.5\n[x] can-simple-observable@2.0.4\n[x] can-stache-converters@4.0.2\n[x] can-stream-kefir@1.0.1\n[x] can-test-helpers@1.1.2\n[x] can-validate-legacy@1.2.0\n[x] can-view-nodelist@4.2.0\n[x] react-view-model@1.0.0\n[x] steal-stache@4.1.2 via can-view-import@4.0.2 . @justinbmeyer react-view-model is now ylem and dosen't have any dependency to can-util, do we have to fix old versions?. @justinbmeyer I just saw the comment I should make sure that module has been released!. @leoj3n I don't have rights to merge it! the merging is blocked for me.. fixed by #4532 . The can-fixture-socket error is in not in canjs is in feathers-hooks in this line. \n\nhttps://developer.yahoo.com/weather/. @chasenlehara do we have credentials?. What link should be changed? stealjs.com by stealjs repo?\n\n. I guess this repo https://github.com/canjs/stealjs-example should be mentioned . Can you help me to figure out what should be used instead of the deprecated stuff? \nHelper Expression => ?\nscope.vars => #let\n{{#each(expression)}} => #for\n{{#is(expressions)}} => ?\n{{#unless(expression)}} => #if?\n{{#with(expression)}} => let\nregisterPartial => ?\nLegacy Scope Behavior => ?\n{{>key}} => ?. Where this should be fixed in the documentation? cc @chasenlehara . @chasenlehara can this be merged/released?. @chasenlehara can you please merge/release it? I don't have permission to do it.. yes. You changed it?. thank you :). Done!. Done!. Done!. Done!. Done!. Done!. Done!. Done!. Done!. Done!. Done!. Done!. Done!. Done!. Done!. Done!. Done!. Done!. I updated, yeah I did it but it seems missed this step.. Done!. Done!. Done!. Fixed!. ",
    "Tushki87": "emallapi = can.Model.extend({\n  findAll : function(params){\n    return $.ajax({\n      url: '/api.php',\n      type: 'get',\n      dataType: 'json'})\n  }\n},{})\nis this right ???\n. ",
    "onyxrev": "Maybe a naive fix?  I haven't been in this part of the code before but this definitely works.\n. Okay - will do.\n. It works on addition and subtraction of properties.  Added __keys and test.\n. Uglify seems to work okay on its own.  I toggled just about every setting in the uglifier gem to no avail.  I also dug into the minified code a bit - it looks right.\n. Looks like it's working now!\n. ",
    "tamzinblake": "Those numbers are within the same order of magnitude - not a very convincing argument.\n. At BrightRoll, we've been considering ejs deprecated and have been phasing it out.\n. It seems to me that models are behaving correctly here. SharedTodo isa\nTodo, so listening for Todo should also listen for SharedTodo.\nOn Mar 3, 2014 11:36 PM, \"Brad (Bradley) Momberger\" \nnotifications@github.com wrote:\n\nI've been perpetually annoyed at defining something like the following\nevery time I listen on a Model class event:\n\"{TodoTask} updated\" : function(model, ev, instance) {\n  if(instance instanceof TodoTask) {\n // ... actually get to work\n }}\nThis is because of a peculiarity of how can.Construct creates and\npropagates static properties. The __bindEvents repository for event\nbindings on objects gets passed along if it gets defined before the\nsubclass is created.\nThat is to say, if I create can.Model(\"Todo\", { init : function() {\nthis.bind(\"created\", ...); } }, {}) and then extend Todo into SharedTodo,\nboth classes share the same created/updated/destroyed event bindings. All\nsubclasses of Todo will share these event bindings and you have to pick\napart which type you actually want to listen on, on each event firing.\nThis pull request is intended to resolve this problem elegantly. Now event\nbindings can propagate up a class hierarchy instead of spanning the entire\ntree.\nYou can merge this Pull Request by running\ngit pull https://github.com/bmomberger-reciprocity/canjs map-event-tree\nOr view, comment on, or merge it at:\nhttps://github.com/bitovi/canjs/pull/761\nCommit Summary\n- Made events bubble for can.Model classes instead of always\n  triggering created/updated/destroyed on every class\n- Removing legacy hasOwnProperty\n- Avoiding error if __bindEvents is not defined\nFile Changes\n- M model/model.jshttps://github.com/bitovi/canjs/pull/761/files#diff-0(4)\n- M model/model_test.jshttps://github.com/bitovi/canjs/pull/761/files#diff-1(36)\n- M util/event.jshttps://github.com/bitovi/canjs/pull/761/files#diff-2(17)\nPatch Links:\n- https://github.com/bitovi/canjs/pull/761.patch\n- https://github.com/bitovi/canjs/pull/761.diff\n\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/pull/761\n.\n. Awesome. Though modifying the behavior of deferreds might be problematic if\nyou ever switch over to a+ promises.\nOn Mar 13, 2014 8:45 PM, \"Justin Meyer\" notifications@github.com wrote:\nThere is another issue related to this. I'm away otherwise I would look it\nup.\nI'm not sure that the compute should take on the value of the resolved\ndeferred. That will be a bit strange having a deferred then suddenly a\nvalue. Also, what happens on error and such?\nInstead, we might simply make deferreds call can.__reading and be \"bind\nable\". That way you could do something like:\n{{#eq deffered.state() \"resolved\"}}\n{{deffered.value.name}}\n{{/eq}}\nSent from my iPhone\n\nOn Mar 13, 2014, at 9:10 PM, Thom Blake notifications@github.com\nwrote:\nYou can pass a deferred into a can.List, which allows you to render a\ntemplate using that List and then the template will update when the\ndeferred is resolved. The same functionality should be available for\ncomputes. (Raised by Colin Zhu and @moschel at canjs Silicon Valley meetup)\n\nReply to this email directly or view it on GitHub.\n\n\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/issues/786#issuecomment-37614383\n.\n. Probably any fix here should be considered breaking because if anyone is using it at all then they're using it against the API (backwards).\n. Yep, that was the problem - the controller was bound to the element being\nemptied.  Might be worth adding a note to the docs there.\nhttp://canjs.com/docs/can.Control.prototype.destroy.html\n\nOn Tue, Mar 18, 2014 at 10:37 AM, Justin Meyer notifications@github.comwrote:\n\n.empty() will destroy controls within the element being destroyed. It\nwill not destroy controls on the element being emptied.\n\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/issues/798#issuecomment-37963341\n.\n. This problem might be solved by those more lightweight lists that are coming out soon.\n. Yeah, this is more intuitive for folks who live in JS, which I would assume is the target audience.\n. The purported benefits of AMD are just not necessary for the majority of use cases.  We build a large, complex app using CanJS and Steal, and we don't do any async code loading.\n\nWhat browserify gives you is the ability to use npm as your dependency management tool.  Benefits there like avoiding dependency hell are much more valuable to me than async code loading or the overly complex build pipelines described above.\n. Yes, this is documented and well-known.  It applies to things under 'scripts' in package.json and also anything run by npm run-script\n. What does this fix?\n. ",
    "AdamTourkow": "By \"it\", I mean: \"Index: 0 Parent: | Item 0\"\nThat one doesn't delete, and then all the indexes above it decrement.\nNot to mention, it worked when I just applied that one patch as can be seen in http://jsfiddle.net/subsonic/6v6nz/\n. ",
    "savinger": "@matthewp Is there some straightforward way to fix this in javascript beyond renaming attributes? I have handlebars templates that I'm trying to transition to mustache right now that render something inherently recursive. So this abstract object can have one or more similar objects within it, so they all share the same attributes, but each does not necessarily have all. All that to say renaming isn't really an option.\nJust hoping that may motivate the issue a bit.\n. Updated. Check the rendered elements and you'll see that the <button> is outside of the <span>, contrary to the markup. http://jsfiddle.net/xLH4K/2/\n. Why would they rely on canjs to output markup different than what they declared?\n. Nope. Maybe this fiddle is more clear: http://jsfiddle.net/fjaq8h66/1/\n. ",
    "danbee": "Both of those make sense. Thanks!\n. ",
    "Djemo": "OK. It seems to be because I've used, can.view.render() to get HTML and then set it on container with $c.html(). If I use can.append It works.\n. ",
    "booc0mtaco": "I believe this is in the same vein as #657 , no?\n. @daffl Looks like 2.0.7 was tagged before this merge. Would it be possible to get 06c7bd2 into that tag, as it also fixes an example in can.Control.on? (specifically, the TaskStriker Example code)\nRelated, would merging this branch into 2.0.7 also make my docco and other changes appear when viewing docs for CanJS v2.0? Right now, they only appear in CanJS v2.1-pre\n@justinbmeyer These are my docco/documentation changes, FYI.\n. Docs now available via the \"User Contributed\" Section, under the Downloads tab, in Dash preferences. \n. nr. 2 for me also. This will prevent the need to re-visit this in case the list grows again, or someone has a different size monitor (or likes their docco window to be short and stout), etc. A more fluid layout this way.\n. Forgot to ask yesterday... What's wrong with @code{start | end}? Is it a change we want for convention's sake, or do those tags lead to problems elsewhere?\nRelated, looks like the example above uses spaces. Do we prefer spaces over tabs, vice versa, or does that not matter?\n. I will have a look at this one\n. looks like it can't find steal at http://canjs.com/can/map/lib/steal/steal.js. Apparently, it should be looking for it at http://canjs.com/can/lib/steal/steal.js\n. did some spot-checking, and the other demos seem to be fine. I'm guessing it might have been missed when examples were moved into doc/ subdirectories? I'll do  a few more checks, then submit a PR for the changes.\n. Agree with @shcarrico . The worst scenario is when someone mis-copies a template regex like this, and introduces subtle, incorrect behavior.\nThere are also the form field types in HTML5. Could we use those http://diveintohtml5.info/forms.html#type-email? The new field types would affect the protocol validations mentioned above, and are well-defined, so they could be baked in. Using these types could have several benefits:\n- preferring type=\"email\" instead of something like can-validate-format=\"email\" would provide enough information to select the right type of default validator\n- type=\"email\" would trigger the appropriate input keyboard on mobile devices (e.g., include the .com button on the keyboard)\n- would allow for any type of user-specified overrides in addition to a default email validation if necessary.\nOther types of validation could rely on the other standard input field attributes and would be written to \"just work\" when the validation engine is enabled.\n. Reference: http://javascriptmvc.com/docs/DocumentJS.tags.typedef.html\n. RE #1122\n. The formatting here is off because the @option values for can.compute(initialValue[, settings]) aren't being parsed properly for some reason. The text above should be nested blow the signature, explaining how to use settings.\n@justinbmeyer any idea why @option isn't working properly in compute.md? From what I could gather in the documentJS docs, it is being used properly.\n. lines 57-71 are causing the issues:\nhttps://github.com/bitovi/canjs/blame/master/compute/compute.md#L57-71\nThe text on each line beginning with @option never renders, and the other chunks of text appear throughout the page in the wrong locations.\n. @justinbmeyer @daffl Seems that travis failed on ... some issue with PhantomJS? In any case, this should be good to go now. Let me know if further changes are needed.\n. RE #1110 \n. After reading http://javascriptmvc.com/docs/DocumentJS.tags.typedef.html, I am still unsure of what the TYPE section of a typedef means. Also, the links to TYPE and type expression result in 404. \n. will add some clarity on what newVal and oldVal are in this file.\n. ",
    "RpprRoger": "Precisely @thecountofzero , there appears to be a check for \".\" and then to return that element if it is found. But the check is only if it's truthy, this is very odd behaviour, shouldn't it be one or the other? @justinbmeyer\nhttps://github.com/bitovi/canjs/blob/master/map/map.js#L648\nhttps://github.com/bitovi/canjs/blob/master/map/map.js#L650\nThe Attr functionality currently works like this\n``` js\nvar result, test = new can.Model({\n    'my.enable': false,\n    'my.item': true,\n    'my.count': 0,\n    'my.newCount': 1\n});\nresult = test.attr('my.enable'); // result === undefined\nresult = test.attr('my.item'); // result === true\nresult = test.attr('my.count'); // result === undefined\nresult = test.attr('my.newCount'); // result === 1\n```\nThat doesn't feel right to me. \n. Out of interest, isn't it true that in javascript\njs\n\"\\.there's a dot\\.\" === \".there's a dot.\"\nSo at the point we do the check the backslash is irrelevant? https://github.com/bitovi/canjs/blob/master/map/map.js#L648..\nUnless I'm missing something when we check the index of \".\"\n. ",
    "raviviswanathan": "Yes.. I am raising is issue from funcunit.com community..\nOn Jan 15, 2014 11:34 PM, \"Justin Meyer\" notifications@github.com wrote:\n\nAre you sure this is a problem with CanJS? This seems to be a problem with\nfuncunit. cc @alexisabril https://github.com/alexisabril\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/issues/670#issuecomment-32441781\n.\n. HI Alexis,\n\nI have added a new issue, to the repo you have sent.\n-Ravi\nOn Thu, Jan 16, 2014 at 10:09 AM, Alexis Abril notifications@github.comwrote:\n\n@raviviswanathan https://github.com/raviviswanathan Could you add a new\nissue to the below repo and also add what HTML you're using? Thanks!\nhttps://github.com/bitovi/funcunit/issues?state=open\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/issues/670#issuecomment-32476533\n.\n. PLease Help\n. \n",
    "Psykoral": "Also noticing it on: /canjs/amd/can/util/hashchange.js\nLine 10 not defined: define(function() {\nLine 23 called: can.trigger(window, 'hashchange');\n. definitely open to more eyes on that to check and see if that's right, but it seems to work for me. Thanks!\n. No output has been received in the last 10 minutes, this potentially indicates a stalled build or something wrong with the build itself. The build has been terminated\nnot sure it actually had an error as much as it just timed out. Can't seem to figure out how to make it try another build. \n. Yeah just noticed that too. I'm just leaving work, going to head home and run these tests again and track it down. \n. OK, got it. Looks like hashchange() was actually specifically built to use globals, so I'll pass on that one for the time being. The greater fix was for elements and setting the scope for the 'can' name space. Please review this when you get a chance and let me know if you have any concerns. \n. Ah. Is there an ETA on 2.1 yet? I was hoping to get this fixed soon because \"we\" have an application that's depending on this fix. If I need to I can change our configs to bower it in from my Fork. But if there's any chance at just a small patch for this, it would help \"us\" greatly :c)\n. Yeah, sorry about all that. The biggest (actual) change was in view/elements.js where\n-steal(function(){ ... should be...\n +steal(\"can/view\", function( can ) {\nThanks for the quick turnaround!\n. Edit: looks like it was fixed in 2.0.5. Thanks guys!\n. Fixing that last build error, give me a few\n. It looks like can.isPlainObject is defined in https://github.com/bitovi/canjs/blob/master/util/object/isplain/isplain.js#L29 and so the new local scoped can doesn't know what it is. It looks like it's actually only an issue for the tests themselves. Let me try something...\n. :+1:  :100: \nhttps://travis-ci.org/bitovi/canjs/builds/87148427\n. My pleasure!\n. In this case, 'list' was referenced but never used. 'can' was not referenced but used.\n. ",
    "cklanac": "Fix as of version 2.1.0. Added is isArrayLike() check.\n. @stevenvachon Thanks for submitting the issues. This issue is caused by the {{#if breaks.length}} helper interacting with the batched update and {{#each breaks}} helper. We've a fix to the next release. \nIn the meantime, you can workaround the issue by removing the .length from the if helper -  simply {{#if breaks}}... {{/if}}, or change {{#each breaks}} helper to simply {{#breaks}}{{.}}{{/breaks}}. \nhttp://canjs.com/docs/can.stache.Sections.html#section_Iteration\nhttp://jsfiddle.net/cklanac/wfm6k20r/\n. Fixed in previous release. If you check the original fiddle http://jsfiddle.net/VVQ8k/1/ and open console, you'll see that the child nodes have an element attribute set to \"li\" element \n. Sorry, I pushed before committing the changes. I'll commit and restest and push again\n. This is just a breaking test to go along with the Issue... no a fix\n. Gotcha'...\u00a0Currently the model is stored twice, once with the old ID and again with the new ID. I'll make sure the test properly tests for either an update or a delete of the old model.\u00a0\n```\n\n```\nFrom: Justin Meyer notifications@github.com\nSent: Friday, February 20, 2015 7:31 PM\nSubject: Re: [canjs] Models should be removed from store when id changes. (#1463)\nTo: bitovi/canjs canjs@noreply.github.com\nCc: Chris Klanac cklanac@bitovi.com\nTo be clear ... the model should still be in the store, only referenced by a new id.   \n\u2014\nReply to this email directly or view it on GitHub.\n. ",
    "inderps": "Hey,\nI tried it on android 4.0.3 (Ice Cream Sandwich) and it didnt work. \nIt works fine for jelly bean (4.1).\n. ",
    "jbguerraz": "Yep, why not; document.documentElement is document.childNodes[1]. As I said, I'm not sure it has some interest to check in the full HTML fragment (document.documentElement / document.childNodes[1]) as the HTML Head may reference quite lot of nodes (even more when we use an AMD loader like Require). But if some people may have interest to use can.inserted in order to check if an element is in the Head, then why not :)\n. \"This seems to specifically occur when using Zepto (not if you run the tests without a library).\"\nAs far as Weinre tell me, there is no document.contains even without any library => It's not related to Zepto, but to Android browser which provide contains only on HTMLElement (document is an HTMLDocument object and not an HTMLElement one, that's why it fails).\nAlso, you added a condition in order to continue to use contains on document; that's not right, if you want to check on the full document, then use document.documentElement, if you prefer to check only on body, then use document.body : then there is no need to add a condition as both works over all browsers.\n. ",
    "zkat": "This change is included in #701. I moved it to that pull request because I wrote a test to verify the change. Thanks for the patch!\n. This change is included in #701. I moved it to that pull request because I wrote a test to verify the change. Thanks for the patch!\n. https://www.npmjs.org/package/destealify WIP\n. https://www.npmjs.org/package/destealify WIP\n. destealify was working \"well enough\" for me, so I'm closing this. Please file any other issues in that repo.\n. destealify was working \"well enough\" for me, so I'm closing this. Please file any other issues in that repo.\n. Simply cloning can cause its own share of issues. For example, what does this code do?:\njs\ndefaults: {\n  foo: new Thing() // does some kind of initialization for each instance -- I think can.compute works like this, even.\n}\nand even if you're willing to ignore cases like this, what do you do about these two cases?:\njs\ndefaults: {\n  foo: {\n    state: clientState // There must be one clientState to rule them all. Please never copy this.\n  }\n}\n// and...\ndefaults: {\n  foo: {\n    bar: {} // Please don't share this instance, it needs to be unique for everything\n  }\n}\nI don't believe there is a single good-enough DWIM solution that works for all these cases. An alternative would be to force values in the defaults object to be either immutable data (strings, numbers, booleans), or be provided as a function that will be executed on every instantiation to create the default value in a predictable, unsurprising way:\njs\ndefaults: {\n  foo: \"hey\",\n  bar: 1,\n  baz: true,\n  quux: function() { return new Thing(); } // this is safe\n}\nOf course, it kinda sucks to have to type out functions every time you want a mutable default. You could provide both interfaces (objects get auto-deep-cloned or auto-shallow-cloned, and function get executed), but that doesn't fix the original bug, which has to do with the principle of least surprise more than anything else, since the framework is already perfectly capable of working around this \"bug\" through the init method.\nThe tl;dr is that I think the only appropriate, unsurprising thing to do is to just yell at users when they put mutable objects in defaults when they're in dev mode, and document this issue in our documentation.\n. Simply cloning can cause its own share of issues. For example, what does this code do?:\njs\ndefaults: {\n  foo: new Thing() // does some kind of initialization for each instance -- I think can.compute works like this, even.\n}\nand even if you're willing to ignore cases like this, what do you do about these two cases?:\njs\ndefaults: {\n  foo: {\n    state: clientState // There must be one clientState to rule them all. Please never copy this.\n  }\n}\n// and...\ndefaults: {\n  foo: {\n    bar: {} // Please don't share this instance, it needs to be unique for everything\n  }\n}\nI don't believe there is a single good-enough DWIM solution that works for all these cases. An alternative would be to force values in the defaults object to be either immutable data (strings, numbers, booleans), or be provided as a function that will be executed on every instantiation to create the default value in a predictable, unsurprising way:\njs\ndefaults: {\n  foo: \"hey\",\n  bar: 1,\n  baz: true,\n  quux: function() { return new Thing(); } // this is safe\n}\nOf course, it kinda sucks to have to type out functions every time you want a mutable default. You could provide both interfaces (objects get auto-deep-cloned or auto-shallow-cloned, and function get executed), but that doesn't fix the original bug, which has to do with the principle of least surprise more than anything else, since the framework is already perfectly capable of working around this \"bug\" through the init method.\nThe tl;dr is that I think the only appropriate, unsurprising thing to do is to just yell at users when they put mutable objects in defaults when they're in dev mode, and document this issue in our documentation.\n. Bump. I'm not sure why phantomjs died on this. Fluke? Is there a way to just rerun the tests, or do I need to force a push?\n. Bump. I'm not sure why phantomjs died on this. Fluke? Is there a way to just rerun the tests, or do I need to force a push?\n. It extends the API as coded but is backwards-compatible. I would argue this behavior should have already been expected, which would make it a bug and thus a 2.0.6 fix, but it's really a backwards-compatible API extension, which would land it in 2.1.\nI don't see any actual documentation for can.scope, and $().scope() is only casually mentioned because it happens to be used by http://canjs.com/docs/can.Component.html, so it was never technically a defined part of our API.\n. It extends the API as coded but is backwards-compatible. I would argue this behavior should have already been expected, which would make it a bug and thus a 2.0.6 fix, but it's really a backwards-compatible API extension, which would land it in 2.1.\nI don't see any actual documentation for can.scope, and $().scope() is only casually mentioned because it happens to be used by http://canjs.com/docs/can.Component.html, so it was never technically a defined part of our API.\n. I added it to my own project because I made the mistake of trying to do el.scope(\"foo\", 1) several times. When something bites me enough times, I figure it's time to fix it, but obviously I am not all users, and it's fine if this isn't welcome. I probably won't bother documenting it if it's not, and we can just close the issue, though I like the way the interface works in my own code and will probably keep that.\n. I added it to my own project because I made the mistake of trying to do el.scope(\"foo\", 1) several times. When something bites me enough times, I figure it's time to fix it, but obviously I am not all users, and it's fine if this isn't welcome. I probably won't bother documenting it if it's not, and we can just close the issue, though I like the way the interface works in my own code and will probably keep that.\n. Overwriting jquery's .attr() has much more serious implications with how can.Component work with attributes as an interface, so I'd rather not touch that because there's too many ways it could go -- if you're going to override .attr(), you would also probably want to get rid of $#scope() altogether, as well, since it would be redundant -- your element would become the actual data interface.\nOne example of a serious implication is how we interpret non-strings being assigned to these values, which I think has several legitimate answers, specially because of how these could interact with can.view templates and how they pass stuff in. I also think there's value in having an internal-data-storage interface that isn't affected by an HTML element's attributes. Having that would be a generalization of the currently-hardcoded id/class/etc exception hack we do for component data binding.\nLong story short, I'd rather have something like this in the short term than have this be blocked by a different part of the API design that can be tackled separately from this particular one. Yes, $#scope already works like can.Map#attr, but overriding something that is designed for DOM manipulation is a much bigger change, and I wouldn't consider it to be in the scope of the relatively small, quality-of-life improvement this patch is trying to do, and I don't consider it worth blocking because of that, unless you intend to completely remove this function until we do The Right Thing\u2122, whatever that ends up being, about attributes.\n. Overwriting jquery's .attr() has much more serious implications with how can.Component work with attributes as an interface, so I'd rather not touch that because there's too many ways it could go -- if you're going to override .attr(), you would also probably want to get rid of $#scope() altogether, as well, since it would be redundant -- your element would become the actual data interface.\nOne example of a serious implication is how we interpret non-strings being assigned to these values, which I think has several legitimate answers, specially because of how these could interact with can.view templates and how they pass stuff in. I also think there's value in having an internal-data-storage interface that isn't affected by an HTML element's attributes. Having that would be a generalization of the currently-hardcoded id/class/etc exception hack we do for component data binding.\nLong story short, I'd rather have something like this in the short term than have this be blocked by a different part of the API design that can be tackled separately from this particular one. Yes, $#scope already works like can.Map#attr, but overriding something that is designed for DOM manipulation is a much bigger change, and I wouldn't consider it to be in the scope of the relatively small, quality-of-life improvement this patch is trying to do, and I don't consider it worth blocking because of that, unless you intend to completely remove this function until we do The Right Thing\u2122, whatever that ends up being, about attributes.\n. Are we interested in this, or should we close it?\n. Are we interested in this, or should we close it?\n. Added docs and rebased onto the latest master\n. Added docs and rebased onto the latest master\n. @daffl all done\n. @daffl all done\n. +1 for including this in can.stache. I think it'll feel better in practice, but it's great to have an opportunity to try it out without worrying about backwards compat.\nI may have misunderstood what you said about html-only views, but -- I think the issue of wtf the context/viewscope is is orthogonal to this change. If we want custom elements to work standalone, we'll have to figure out an API for injecting scope data into the html page. Consider that, in Polymer, this {{foo}}-based insertion is only available for <template>, and its value depends entirely on where the template is used. You don't use {{}} for property values outside of this tag. At the toplevel, you do any context/scope population in whatever toplevel <my-app> wrapper you have, iiuc.\ntl;dl: the issue of what attr=\"{{foo}}\" means in the toplevel is orthogonal to this feature, unless I misunderstand web components.\n. +1 for including this in can.stache. I think it'll feel better in practice, but it's great to have an opportunity to try it out without worrying about backwards compat.\nI may have misunderstood what you said about html-only views, but -- I think the issue of wtf the context/viewscope is is orthogonal to this change. If we want custom elements to work standalone, we'll have to figure out an API for injecting scope data into the html page. Consider that, in Polymer, this {{foo}}-based insertion is only available for <template>, and its value depends entirely on where the template is used. You don't use {{}} for property values outside of this tag. At the toplevel, you do any context/scope population in whatever toplevel <my-app> wrapper you have, iiuc.\ntl;dl: the issue of what attr=\"{{foo}}\" means in the toplevel is orthogonal to this feature, unless I misunderstand web components.\n. Note that unquoted attributes are perfectly valid html5, so foo={bar} and foo=\"{bar}\" are equivalent to the browser.\n. Note that unquoted attributes are perfectly valid html5, so foo={bar} and foo=\"{bar}\" are equivalent to the browser.\n. Does that mean that returning strings from this is the actual expected behavior? What should similar tools use instead when precompiling templates?\n. Does that mean that returning strings from this is the actual expected behavior? What should similar tools use instead when precompiling templates?\n. shall we close this?\n. shall we close this?\n. I prefer @matthewp's approach. I do not believe we should automatically expose every single option/property on the can.Component (that means we should not expose scope by default. The component's API should be controllable by the component author, which means: A. They should be allowed to name their properties with any name they want without worrying about conflicts with Component options, B. They should not be forced to expose internal details of the Component (such as scope or template.\nThere's also the issue with the message={{foo}} example. I think we're starting to go down the path where it would make sense to find a way to unify properties/define with scope (or specifically, get rid of scope as its own thing), but that's a more radical change for the API. I don't know why scope should exist as a separate thing from these properties and methods, though, beyond questions about the API -- considering, since we're making this be the HTMLElement itself, that we should now need to make .attr() available directly on the element to be able to do what we're used to doing. It would greatly simplify the API, though, and collapse three of the options into a single one: define, scope, and helpers would all become the same thing. events can stay separate, but would no longer be a repository for regular methods.\n. I prefer @matthewp's approach. I do not believe we should automatically expose every single option/property on the can.Component (that means we should not expose scope by default. The component's API should be controllable by the component author, which means: A. They should be allowed to name their properties with any name they want without worrying about conflicts with Component options, B. They should not be forced to expose internal details of the Component (such as scope or template.\nThere's also the issue with the message={{foo}} example. I think we're starting to go down the path where it would make sense to find a way to unify properties/define with scope (or specifically, get rid of scope as its own thing), but that's a more radical change for the API. I don't know why scope should exist as a separate thing from these properties and methods, though, beyond questions about the API -- considering, since we're making this be the HTMLElement itself, that we should now need to make .attr() available directly on the element to be able to do what we're used to doing. It would greatly simplify the API, though, and collapse three of the options into a single one: define, scope, and helpers would all become the same thing. events can stay separate, but would no longer be a repository for regular methods.\n. ``` js\ncan.Component.extend({\n    tag: 'shopping-list',\n    events: {\n        \".add-apple click\": function() {\n            this.list.add(this.makeApple());\n        }\n    },\n    properties: {\n        list: [],\n        add: function(item) {\n            this.list.push(item);\n        },\n        numberOfApples: {\n            get: function(){\n                return this.list.reduce(function(acc, item) {\n                    return acc + Number(item.name === 'apple');\n                }, 0);\n            }\n        },\n        makeApple: function() {\n            return {name:\"apple\"};\n        }\n    }\n});\n\nvar list = document.querySelector(\"shopping-list\");\nlist.add({name:\"apple\"});\nlist.numberOfApples === 1; // true\nlist.list.attr(); // [{name:\"apple\"}]\nlist.attr(\"list\", []);\nlist.numberOfApples === 0; // true\n```\nbut really I kinda like what x-tags does, too. Probably better than this approach. I think the way to describe it is that scope wouldn't be the viewmodel anymore. The component/element itself is the viewmodel. Or something.\n. ``` js\ncan.Component.extend({\n    tag: 'shopping-list',\n    events: {\n        \".add-apple click\": function() {\n            this.list.add(this.makeApple());\n        }\n    },\n    properties: {\n        list: [],\n        add: function(item) {\n            this.list.push(item);\n        },\n        numberOfApples: {\n            get: function(){\n                return this.list.reduce(function(acc, item) {\n                    return acc + Number(item.name === 'apple');\n                }, 0);\n            }\n        },\n        makeApple: function() {\n            return {name:\"apple\"};\n        }\n    }\n});\n\nvar list = document.querySelector(\"shopping-list\");\nlist.add({name:\"apple\"});\nlist.numberOfApples === 1; // true\nlist.list.attr(); // [{name:\"apple\"}]\nlist.attr(\"list\", []);\nlist.numberOfApples === 0; // true\n```\nbut really I kinda like what x-tags does, too. Probably better than this approach. I think the way to describe it is that scope wouldn't be the viewmodel anymore. The component/element itself is the viewmodel. Or something.\n. What's wrong with mapping properties to attributes? All this really does is reduce friction between things you would already be doing.\nFor added control in an API like this, you could, say, add a \"publish\" option property that accepts an array of strings, that decides which HTMLElement attributes will be automatically mapped to the underlying can.Map that would've previously been called the scope.\nSo, in a way, all of the above are already \"independent\" in the sense that they're just a mirror. I don't see a reason to have so much ceremony around accessing this data when in the end the external user API goes through HTMLElement attributes.\n. What's wrong with mapping properties to attributes? All this really does is reduce friction between things you would already be doing.\nFor added control in an API like this, you could, say, add a \"publish\" option property that accepts an array of strings, that decides which HTMLElement attributes will be automatically mapped to the underlying can.Map that would've previously been called the scope.\nSo, in a way, all of the above are already \"independent\" in the sense that they're just a mirror. I don't see a reason to have so much ceremony around accessing this data when in the end the external user API goes through HTMLElement attributes.\n. I'm thinking of just writing a Can plugin that lets you return event streams from anything that can do can.bind, and then have can.view accept those event streams to do its rendering. Not sure about adding can.Control magic syntax for declaratively creating event streams, since many of them are just combinations on existing ones. May want to just let that be an imperative definition on init/insterted. Feel free to ping me if this sounds interesting or you have your own ideas/requirements.\n. I'm thinking of just writing a Can plugin that lets you return event streams from anything that can do can.bind, and then have can.view accept those event streams to do its rendering. Not sure about adding can.Control magic syntax for declaratively creating event streams, since many of them are just combinations on existing ones. May want to just let that be an imperative definition on init/insterted. Feel free to ping me if this sounds interesting or you have your own ideas/requirements.\n. https://github.com/sykopomp/can.bacon Here's a WIP that'll hopefully help ideas coagulate.\n. https://github.com/sykopomp/can.bacon Here's a WIP that'll hopefully help ideas coagulate.\n. I added docs to the library and published it as a plugin on BitHub: http://bithub.com/event/40502\nThat should cover us from now. Closing this issue.\n. I added docs to the library and published it as a plugin on BitHub: http://bithub.com/event/40502\nThat should cover us from now. Closing this issue.\n. Bump. These changes would be pretty nice to have.\n. Bump. These changes would be pretty nice to have.\n. I implemented this in a branch for stache files. This should be a static thing, so I just used an imaginary helper (paired with an identically-named helper that just crashes because meh dynamic dependencies):\n``` js\n// can/view/stache/system.js\n    function scanDependencies(string) {\n        var re = /\\s{{@import\\s+\"'['\"]\\s}}\\s*/g,\n            deps = [],\n            str = string.replace(re, function(match, module) {\n                if (module) {\n                    deps.push(module.trim());\n                    return \"\";\n                } else {\n                    return match;\n                }\n            });\n        return {deps: deps, source: str}; \n    }\nfunction translate(load) {\n    var depsScanned = scanDependencies(load.source);\n    var deps = [\"can/view/stache/stache\"].concat(depsScanned.deps);\n    return \"define(\"+JSON.stringify(deps)+\",function(stache){\" +\n        \"return stache(\\\"\" + esc(depsScanned.source) + \"\\\")\" +\n        \"})\";\n}\n\n```\nWe can switch that regex to handle other forms of import, but I like @import, and I'd rather just have something rather than spend a ton of time worrying about ideal syntax. can-link seems fine, but idk about having a component-looking thing implementing this. I like forcing imports to be static.\n. Bah, humbug. I'll add <link rel=\"import\" href=\"module\"> support, too, but that one's a little trickier.\n. Pushed a PR for this at #1369 \n. I think making it optional is reasonable, but I think defaulting to lexical behavior is much better for writing nice, modular code and surprising users less in the long run, assuming they are used to lexical semantics for variables (like JavaScript's defaults). Consider how confusing dynamic bindings such as this end up being, in practice for users. There is, of course, a place for stuff like that but I think it's important to make the general case \"safe\", and encourage users to use component features more when exposing stuff like in your example. \n. I think making it optional is reasonable, but I think defaulting to lexical behavior is much better for writing nice, modular code and surprising users less in the long run, assuming they are used to lexical semantics for variables (like JavaScript's defaults). Consider how confusing dynamic bindings such as this end up being, in practice for users. There is, of course, a place for stuff like that but I think it's important to make the general case \"safe\", and encourage users to use component features more when exposing stuff like in your example. \n. leaking {{bindings}} is much more prone to surprises, and it's unfriendly to designers who just want to use a component without having to know its internals. With the current behavior, designers now have to know about the internal details of the viewmodel in order to not accidentally capture values in it.\n. leaking {{bindings}} is much more prone to surprises, and it's unfriendly to designers who just want to use a component without having to know its internals. With the current behavior, designers now have to know about the internal details of the viewmodel in order to not accidentally capture values in it.\n. The PR is using dynamicContentBindings as a flag to toggle between lexical and dynamic binding. Anyone have better ideas?\n. The PR is using dynamicContentBindings as a flag to toggle between lexical and dynamic binding. Anyone have better ideas?\n. @matthewp https://github.com/sykopomp/canjs/commit/02aee4bc734dd9be62aec868191a426b48f6ddde#diff-044464ba2f6d4f8b084348672f9ea8adR195\n. @matthewp https://github.com/sykopomp/canjs/commit/02aee4bc734dd9be62aec868191a426b48f6ddde#diff-044464ba2f6d4f8b084348672f9ea8adR195\n. TODO: write docs\n. TODO: write docs\n. docs added\n. docs added\n. poke\n. poke\n. I ran into a bug in our application that this would fix. Any chance we could get it in soonish? I'll have to end up maintaining a separate branch with these patches in it otherwise.\n. I ran into a bug in our application that this would fix. Any chance we could get it in soonish? I'll have to end up maintaining a separate branch with these patches in it otherwise.\n. For #881 (hopefully github links them now)\n. For #881 (hopefully github links them now)\n. Oh I forgot about those. :) But they're already covered because functions are the only ones that get exported. scope is the only one that needs a special case because you can provide a function form for it.\nI'll just make it export any function that isn't one of the options in http://canjs.com/docs/can.Component.extend.html \n. Oh I forgot about those. :) But they're already covered because functions are the only ones that get exported. scope is the only one that needs a special case because you can provide a function form for it.\nI'll just make it export any function that isn't one of the options in http://canjs.com/docs/can.Component.extend.html \n. This shouldn't prevent us from handling get/set properties in the future. That would be an API addition, and there's nothing here that stops that -- we just don't support non-function exports right now.\n. This shouldn't prevent us from handling get/set properties in the future. That would be an API addition, and there's nothing here that stops that -- we just don't support non-function exports right now.\n. @matthewp yup. scope is exported directly on the element, so you can do this.scope. See https://github.com/bitovi/canjs/pull/1092/files#diff-044464ba2f6d4f8b084348672f9ea8adR1269\n. @matthewp yup. scope is exported directly on the element, so you can do this.scope. See https://github.com/bitovi/canjs/pull/1092/files#diff-044464ba2f6d4f8b084348672f9ea8adR1269\n. added docs\n. added docs\n. poke\n. poke\n. The more used I get to scope, the less I care about this feature. I don't really think this adds any value to speak of, unless we start focusing on components that work in non-Can environments, and even then, I think changing data and triggering events can get us 95% of the way there. So meh.\n. The more used I get to scope, the less I care about this feature. I don't really think this adds any value to speak of, unless we start focusing on components that work in non-Can environments, and even then, I think changing data and triggering events can get us 95% of the way there. So meh.\n. @daffl Hey David, can I just close this? Please?\n. +1\n. i think this should become the default behavior for helpers. As described, this feature would still force users to check for computes when you define helpers right in a can.stache() call, or in the helpers object of can.Component.\n. tests actually pass now. cough\n. poke\n. documented deferred api\n. TODO: try removing underscores\n. Done.\n. http://handlebarsjs.com/builtin_helpers.html Mentions a helper called lookup. I think in order to really be able to use something like that, we'd need nested helper support. The following then would do the trick nicely while still making [] available for escapes (see #1344) and fitting in more with how handlebars does things. I don't know if there's an issue for that yet, and searching failed me, but see:\nhtml\n{{#each (lookup things key)}}\n...\n{{/each}}\nEither way, probably good for us to include the lookup helper by default since it's default in handlebars.\n. Yeah. I know I can .attr() it, but the error can be really confusing, and this seems to have been a relatively recent change -- I ran into it while upgrading an app running on 2.0\n. I like this API a lot, specially can.watch. My minor comment on that is that calling it can.observe might make it feel more like the standard Object.observe, but I don't think it matters that much.\nI also think it's good to have can.view automatically dirty check -- and I would argue that's one of the more important parts of all this, since so much of our object observation is for the sake of template rendering.\nAs far as template rendering goes, it might be nice to have an event hook into rendering completion. CanJS is currently synchronous, and folks might still expect that. Perhaps telling users to call performMicrotaskCheckpoint themselves will work, but that leaves us SOL for browsers that support observation natively.\nFinally, observe-js supports several kinds of object observation. How are we handling those different kinds? Some of them are fairly interesting (such as the path observers).\n. I've been using a <can-router> and <can-router-route> pair of components pretty successfully at a client application, it's been working like a charm :). Also got some great ideas from @imjoshdean for what sorts of extra options for page management they might need. \nFrom the sandbox page:\nhtml\n    <header>header</header>\n    <can-router map=\"{.}\">\n        <can-router-route href=\"\">\n            Hello, world{{punctuation}}\n        </can-router-route>\n        <can-router-route href=\":name\">\n            Hello, {{name}}{{punctuation}}\n        </can-router-route>\n    </can-router>\n    <footer>footer</footer>\n. @whitecolor Think of can-router- as a prefix for components that are meant to be children of can-route. It's a pattern I've used in a few other places to namespace elements and specify what parent they belong to -- so I don't consider it a tautology :)\nI also think the visual distinction between can-router and can-route is too small so meh.\n. To clarify a bit, this would essentially entail taking the current can.bacon and turning it into a generic API that can have arbitrary FRP libraries (including, in the future, our own?) plugged into it. For now, it would be a matter of including can.eventstream and can.bacon together.\n. I've released can.eventstream, and am currently working on spitting out a new version of can.bacon that uses it as a dependency.\n. Just released a new version of can.bacon that implements the generic can.eventstream interface.\n. Aaaand I just cooked up can.rx for good measure. I know there's already someone who wanted to use RxJS specifically, so maybe this'll come in handy to them, as rough as it is.\n. There's some basic examples here: https://github.com/sykopomp/can.bacon/blob/master/dist/sandbox.js\nI'm also planning on writing some more helpful guides that actually explain what's going on and give people an introduction to programming with FRP.\nFor now, you can also check out the various Bacon guides that give a fairly good overview of what it's like using it.\n. Change you suggested is in, @matthewp :)\n. Just started pushing can.dataview as a nice utility that makes use of can.bacon.\nNew versions of can.eventstream/bacon/rx have been released, too.\n. \ud83d\udc4b\n. I still favor viewModel because it emphasizes its role. context, scope and options are all overloaded terminology in CanJS. Even model would be nicer, although that might conflict with the idea of can.Model somewhat (since they default to being Maps), and I think map is overloaded enough as-is, in comp sci talk :\\\ntl;dr: I favor viewModel and model, in that order -- the latter conveniently lets you avoid casing annoyances. :)\n. This would conflict with #1157, I think.\n. +1\n. @daffl added tests, docs.\n@justinbmeyer added and documented @element and @event.\n. @daffl I've made all the changes, but the amd tests specifically are failing and I don't understand why. Can you take a look? The regular tests pass just fine. :\\\n. Looking around on http://handlebarsjs.com/reference.html, I saw that handlebars uses @root for something very similar to this that I think would fit this role just fine.\n. @whitecolor indeed, but I'd rather not have to remember to do that every time, and it would be even better if I did not actually have access to the element from the scope, to maintain the separation of concerns (since you should rarely, if ever, do actual DOM work inside your scope -- triggering an event is not necessarily DOM work)\n. See #1386 \n. @daffl done\n. woo! +1!\ncan-autoload gets my vote over can-render.\nDo you want me to just grab autoload.js as-is and make a pull request of it? As far as the src= feature goes, I think that should be a separate issue+PR. I'm assuming what you meant by that is that you want to be able to do:\nhtml\n<script src=my/template/thing.stache type=text/stache></script>\nWould be nice if we could omit the type in cases like this, but the browser won't cooperate with us on this one. :)\nFinally: I'm not sure what patching is needed about the DOMContentLoaded thing. I'm not familiar with Moo and YUI. I assume Zepto has the same fudged load event jQuery does.\n. I was working on this feature elsewhere, but I guess it's all yours now. See #1369. Nicer to use a parser anyway, I guess, and I like the explicit import tags and steal-based partial loading that PR supports. Would be nice to pull in that particular feature into here. Besides that, I guess may as well blow away that PR. The code was written based on the discussion at #1037.\nI don't like automagic import any more than I would like magically trying to import can.Models based on their usage in JavaScript code: I think it's better to make it easy for people to specify modules to load, with explicit dependencies. But I don't really care about fighting about that. Can I just have a flag so I can disable that feature in my own projects?\n. @daffl this is up to date and clear.\n. All attributes are escaped here. status() is a string when the value is inside an attribute.\n. This works with the other change so that we don't bother checking for attribute status (except for special attributes, which are special)\n. Unless your benchmark involves defining thousands of individually-named components with hundreds of exported functions each, I'm not sure this would ever be a problem, so I'm not sure it's worth the price of using this optimization.\n. What about benchmarking other browsers that might have performance hits for functions created with new Function?\n. Benchmarked on Chrome: no noticeable difference.\nI get 480-510ms from calling the current version 100k times, and 480-505ms from calling the new Function version the same way.\n. Slight correction, I was still using the [name] form for access, and tried it again with the dot operator: The new Function version using the dot operator is now between 490ms-540ms, which is very slightly slower.\nIt's probably still slower because, unlike the functions that something like lodash will compile, this one is actually fairly tiny, simple, and still involves multiple dynamic lookups.\nThe real speedup comes when I remove that and put ___component directly on the htmlelement:\nfunction makeComponentMethod(name) {\n        return function() {\n            return this.___component[name].apply(this, arguments);\n        };\n    }\ncompletes the benchmark in 70-85ms. There is no noticeable difference between this one and the same version using new Function. Assuming this works at all on IE8 (I haven't tried, but I assume it does?), would you like me to use this version instead? :)\n. I like this change a lot actually. Specifically, it means we don't need to do anything special for something like {@root.attr name=foo email=bar} to work, whereas if we continue passing in the extra arguments when explicit arguments are present, we would end up calling the equivalent of viewmodel.attr(valuesHash, true) and replace everything, which is not very friendly :(\nShall I make this change? (or can someone else? I'm on PTO today)\n. ",
    "NoICE": "This helped me discover something unusual. If you do this in canjs 2.2.5:\njs\nsteal('can/model', 'can/map/attributes', function() {\ncan.Model.extend('HiThere',\n// @Static\n{\n  attributes: {},\n  findAll: function() {\n    // doesn't matter\n  }\n},\n// @Prototype\n{}\n)\n})\nIt will throw this error and the model is empty, without definitions. Incomplete. Dead.\nBut I'm giving it the name, static props and prototype props.\nThe cause of this is the stealing of can/map/attributes, which breaks it completely and causes it to break. It is deprecated, but it's removed from docs but not from canjs package, so I didn't even knew it was deprecated :-DThis helped me discover something unusual. If you do this in canjs 2.2.5:\njs\nsteal('can/model', 'can/map/attributes', function() {\ncan.Model.extend('HiThere',\n// @Static\n{\n  attributes: {},\n  findAll: function() {\n    // doesn't matter\n  }\n},\n// @Prototype\n{}\n)\n})\nIt will throw this error and the model is empty, without definitions. Incomplete. Dead.\nBut I'm giving it the name, static props and prototype props.\nThe cause of this is the stealing of can/map/attributes, which breaks it completely and causes it to break. It is deprecated, but it's removed from docs but not from canjs package, so I didn't even knew it was deprecated :-D\n. ",
    "honzatrtik": "I see, but the documentation does not explicitly forbid this kind of use\nand since can.List inherits from can.Map, it can be confusing.. It seems i\nshould check source code :)\nAnyway thank you for the answer and for this great library!\nOn Thursday, May 1, 2014, Justin Meyer notifications@github.com wrote:\n\nHmmm, you are setting an expando property on a list:\nitems.attr('spliced', true);\n\u2014\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/issues/744#issuecomment-41913188\n.\n. \n",
    "leoj3n": "Ah...... So this's how to build the docs.\n. Thanks for this; much needed.\n. So, add two new menu items? Like:\n\nBitovi.com\nBlog\nDesign\nDevelopment\nTraining\nOpen Source\n\nLooks like http://donejs.com/ links to the 404 as well.\nHaven't looked into whether or not that would be a separate change or not, but I think it will as I assume this is coming from the respective bit-docs themes.. Looks like it comes from here:\nhttps://github.com/canjs/bit-docs-html-canjs/blob/master/templates/header-right.mustache#L8\nPerhaps we can make it a reusable component, to standardize the menu items (and logo size) across websites (DoneJS/CanJS/etc).. Here is some research I found pertinent, and my opinions included:\nhttps://github.com/canjs/canjs/issues/3089. Semi-related:\nhttps://github.com/jstransformers/jstransformer\nhttps://www.npmjs.com/browse/keyword/jstransformer\nAlso, would be cool if we had an online educational REPL like this:\nhttp://www.earl-grey.io/repl.html\nSorry if this isn't the right place to post this for discussion (please direct me otherwise if needed).. https://facebook.github.io/jsx/#why-not-template-literals. Verifying that, indeed, the markdown is correct and working:\n\n. Another part I feel is a bit confusing for a beginner is the way this mentions \"if/else branching\" but doesn't really show that in it's entirety:\nhttps://github.com/canjs/canjs/pull/3326/files#diff-e82e0aad7bb0050545316a9e3d28f4dfR280\n. Sorry @imaustink and @chasenlehara, I thought this issue was something with bit-docs search but now I think this might be due to some discrepancy of how the files are packaged by npm publish.\nUsing bit-docs/bit-docs or file://... to cloned master works fine to build the CanJS docs, but trying to use 0.0.8-0 from npm fails as above while 0.7.0 continues to work fine.\nHere is the file diff between 0.7.0 and 0.0.8-0 when both are downloaded as .zip from npm:\n```\nOn branch master\nChanges not staged for commit:\n  (use \"git add/rm ...\" to update what will be committed)\n  (use \"git checkout -- ...\" to discard changes in working directory)\nmodified:   .gitignore\nmodified:   .travis.yml\ndeleted:    docs/api/generate/cmd.md\ndeleted:    docs/documentjs.md\nmodified:   lib/generate/generate.js\ndeleted:    lib/generate/generator.md\nmodified:   lib/process/file.js\nmodified:   lib/process/process.js\nmodified:   lib/process/process_test.js\nmodified:   license.md\nmodified:   package.json\nmodified:   readme.md\nmodified:   test.js\n\nUntracked files:\n  (use \"git add ...\" to include in what will be committed)\ndocs/api/cmd.md\ndocs/api/types/\ndocs/bit-docs.md\ntest/foo.js/\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n``. Seems to be an issue with usingnpm publish` from a git submodule repo directory.\nFull issue here: https://github.com/npm/npm/issues/18629\nThis happened because bit-docs-website currently uses submodules, and I used npm publish from the bit-docs submodule repo directory. Obviously breaking for this reason was unexpected.. \nThink this looks better / less confusing.. Correct. Is this PR really 21 days old.... @cherifGsoul I see... Well if anyone with merge power is listening please merge this and https://github.com/canjs/canjs/pull/4545 \ud83d\ude05 . @matthewp Well, to be fair, this PR has been sitting around for an excessively long time without being merged, and I think it's an important error with a guide aimed at beginners. I was just pointing that out. Hopefully we can still be friends. It's just counter-intuitive that these kinds of chores sit around for so long with the whole renewed effort to build a community around the FOSS is all. Thanks for merging.. @chasenlehara Fixed the indenting.. It should actually be pointing out the drop argument, I think. This is based on the fact that the drag event was already covered before this point. On line 386 of the markdown file, there is a very similar sentence:\n\nNotice that drag is the 2nd argument to the event.  You can listen to\n drag events in [can-stache] and pass the drag argument to a function like:\n\nUnfortunately, I cannot link to a specifice line of a markdown file on GitHub.. \u2705 Change made.. \u2705 Change made.. \u2705 Change made to \"has been\".. \u2705 Change made.. well, they ARE authored in <script> tags for this example which is why I found this sentence confusing \u2014 perhaps you could add a short blurb to qualify that a real app would organize templates into files.. Is it most likely to be a DefineMap? I don't think there's any harm in pointing out what it's most likely going to be. If so, instead of such as a DefineMap, it could read typically a DefineMap. Otherwise should probably say an Object or just not change this sentence.. ",
    "janza": "Alright, updated the test in pull request.\n. ",
    "dfyx": "Wouldn't it be better to have both checks? In the future we could encounter objects that have an apply method that does something completely different.\n. ",
    "RuslanGetmansky": "Also has bumped into this bug here:\nhttps://github.com/canjs/canjs/blob/master/util/object/object.js#L160\nshould be:\njavascript\nfor (var prop in subset)\nI doubt anyone is using it because it doesn't work if a subset contains less properties than a set.\n. @justinbmeyer Probably the concept of can.Object.subset is correct. I don't mind. Then the actual bug is how it's used in can.Object.subsets. Because it doesn't work as explained in the doc. For example:\njavascript\ncan.Object.subsets({id: 1}, [\n    {id: 1, name: 'name1'},\n    {id: 2, name: 'name2'}\n])\ngives nothing because can.Object.subset({id: 1}, {id: 1, name: 'name1'}) === false in current implementation.\n. ",
    "Zemljoradnik": "I have the same issue, it's not limited to can-value=\".\". \nFor example: http://jsfiddle.net/s9fp54nu/ and http://jsfiddle.net/5geohr7w/\nIs there a workaround, or is can-value to be avoided?\n. @DVSoftware Thanks, I get it now.\n. ",
    "markfeimer": "Could you please post some example code?\n. That case requires the script to already know responseA externally from the can.fixture, whereas the enhancement would allow the script to pull the old can.fixture as necessary.\n. ",
    "alexkrautmann": "Finally got some time to look at it.  You can find a pretty self explanatory repo here:\nhttps://github.com/Alex-Krautmann/fixture-store-example\n. Hi daffl-\nIt might be important to note that all of these unexpected issues happen when findAll is defined in the parent models.  This can be seen in the fiddle, but I didn't call it out in the original issue post.\n. ",
    "mjstahl": "From my limited testing the setter is not getting called when removeAttr is\ncalled.\nThe event is being thrown, but no setter is being called.\nOn Mar 23, 2014 3:08 PM, \"Justin Meyer\" notifications@github.com wrote:\n\nI'd like to add the ability to hook into removing an attribute like one\ncan hook into setAttr.\n@mjstahl https://github.com/mjstahl Did you figure out if this was\nalready happening?\nWe can either make .removeAttr call the setATTR with undefined, or have\nanother .removeATTR method like:\nsetContentId: funciton(newVal){\n  return newVal\n},\nremoveContentId: function(){\n}\nWe probably want a way to prevent removing a property. I suggest returning\nany value will prevent removal.\nThoughts?\n\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/issues/819\n.\n. I like the removeATTR functionality.\n\nI would also propose that we pass in the value that the attribute was at\nthe time of removal.\nIt should be noted that I do not have a use case for accepting the value of\nthe removed attribute as an argument.\nOn Mar 23, 2014 3:08 PM, \"Justin Meyer\" notifications@github.com wrote:\n\nI'd like to add the ability to hook into removing an attribute like one\ncan hook into setAttr.\n@mjstahl https://github.com/mjstahl Did you figure out if this was\nalready happening?\nWe can either make .removeAttr call the setATTR with undefined, or have\nanother .removeATTR method like:\nsetContentId: funciton(newVal){\n  return newVal\n},\nremoveContentId: function(){\n}\nWe probably want a way to prevent removing a property. I suggest returning\nany value will prevent removal.\nThoughts?\n\nReply to this email directly or view it on GitHubhttps://github.com/bitovi/canjs/issues/819\n.\n. Most likely will not be displayed on the main docco page therefore not a priority. Issue can be reopened or recreated when the need arises to document this part of can/util.\n. Thinking about it more, it might make sense to do both.  Removing N files doesn't guarantee that this problem wouldn't happen again when I view it on my Chromebook.\n\nBut shrinking the displayed file list and tweaking the CSS would help future proof the documentation.\n. This was supposed to be branched from minor.  The branch is currently breaking the tests.  So the branch is being deleting and one created from minor to be merged in to the docco branch.\n. # Value, Object, and Array APIs\nWe should be able to use dirty checking relatively transparently with current CanJS APIs. The watch API will return an appropriate CanJS Observable (e.g. for use in a template, can.Control, or can.Component).\n``` javascript\nvar foo = {bar: 'hi', baz: 'bye'};\n// returns a can.compute that dirty checks the bar\n// property of foo and includes normal compute\n// bindings\nvar dirtyBar = can.compute.watch(foo, 'bar');\n// returns a can.Map that dirty checks the entire foo object\n// and fires all change events available with a can.Map\nvar dirtyFoo = can.Map.watch(foo);\nvar fooArray = [0, 2, 3, 4]\n// returns a can.compute that dirty checks the first\n// item in the array\ncan.compute.watch(fooArray, '0');\n// returns a can.List that dirty checks the entire fooArray\n// and fires all change events available with a can.List\ncan.List.watch(fooArray)\n```\nSecondary API\njavascript\ncan.watch(value [, property_string]) // where value is a primitive, array, or object\ncan.watch is an convienence function allows the programmer to call can.watch on their desired value without having to decide which datastructure to use.  It is a wrapper that ultimately ends up calling one of the Primary APIs.  \nThe pseudo-code for can.watch is as follows:\njavascript\ncan.watch = function(value, property) {\n  if (alreadyObservable(value)) {\n    return observable;\n  }\n  if (property) {\n    return can.compute.watch(value, property);\n  }\n  if (can.isArray(value)) {\n    return can.List.watch(observable);\n  }\n  if (can.isObject(value)) {\n    return can.Map.watch(observable);\n  }\n  return can.compute.watch(value);\n}\nTemplate\nTemplate can automatically convert a primitive object into a can.watched item.  We are unsure if this is a good idea. _INPUT NEEDED_\nFor example:\nhtml\n<script id='template' type='text/mustache'>\n    <h1>Welcome {{user}}</h1>\n    <p>You have {{messages}} messages.</p>\n</script>\n``` javascript\nvar data = {\n    user: 'Tina Fey',\n    messages: 0 \n};\nvar template = can.view('#template', data);\ndocument.body.appendChild(template);\n```\nIn the above example data is now an (dirty) observable, automatically converted via can.watch.  Any changes to data will be reflected in the template.\nChallenges\nMany browsers do not have support for Object.observe. Thankfully Polymer\u2019s observe-js provides us a means to \u201cdirty-check\u201d an object manually by calling performMicrotaskCheckpoint.  The challenge is in the fact that we have to manage our own interval checking.  One obvious question is how often we should call performMicrotaskCheckpoint.\nPerformance\nSince performMicrotaskCheckpoint will need to be polled regularly, there are a few performance considerations. For one, we likely need to shim requestAnimationFrame to avoid CPU usage with an inactive app.\nSecond, can.__reading may be able to pause the polling procedure and then call it at the end of can.__reading. This may not be necessary if can.__reading ends up calling performMicrotaskCheckpoint anyway (the polling debounces itself).\n. jquery is now in both peerDependencies and devDependencies.  \nIt was originally thought that only having it in peerDependencies would be enough, but for versions of npm (such as 1.4.28 -- what we test with in Travis CI) peerDependencies do not get installed when doing an \"npm install\" at the root level of the project.\n. These were all correct in master branch so they must have gotten fixed along the way.\n. @justinbmeyer Pull request has been committed - https://github.com/bitovi/canjs/compare/1611-data-can-autorender\n. @julia-allyce ^^ done.\n. Based on https://docs.npmjs.com/misc/semver#prerelease-tags we would do something like 2.3.0-alpha.11\nThough it seems like we are doing it correctly.  Based on the comments at: \nhttps://github.com/npm/node-semver/blob/master/semver.js#L62\nhttps://github.com/npm/node-semver/blob/master/semver.js#L75 \nour releases should be considered pre-release.\n. isBindableElement should support anything that has addEventListener\nhttps://github.com/bitovi/canjs/blob/master/util/jquery/jquery.js#L2\n. @justinbmeyer I need to come back to this... for some reason, no matter what I do I can't get the tests to run on the CI.  They all run in the browser and on the command line just fine, but not in the CI.\n. I have no idea what is happening.  Everything I change makes no difference to the tests passing.\n. @julia-allyce ^^ done.\n. Well I added a simple implementation and some tests.  If we decided to go a different route, that is completely fine. Just happen to need in a project so I made an implementation since we had to use lodash instead.\n. @daffl Yeah I saw that this morning. I just haven't had time to fix it. I'll get it fixed some time today.\n. @akagomez This seems to actually be a bug in can.each.\nhttps://github.com/canjs/canjs/blob/master/list/list.js#L769 (forEach on can.List)\nhttp://jsbin.com/vuvusowosa/edit?html,js,console (updated with can.each use case)\n. fixed merge conflicts.\n. @justinbmeyer AllI did was resolve the merge conflicts with package.json and bower.json\n. @pYr0x If all goes well with #2175 tests this will be updated.\n. @pYr0x I am running through the tests right now. I have reason to believe that the error messages on Travis are misleading. We will soon see.\n2175 Updates jQuery to not depend on 1.12 or 2.2.0. Hopefully this fixes the problems we are seeing.  We will release that change (and some bugfixes with partials) for 2.3.9.  @justinbmeyer is working a compatibility change for jquery 2.2.0 and 1.12.0.\n. @pYr0x I think we can close this. #2175 is working just fine, and has all of the updates in it.\n. One JSBin needs to be changed to ensure consistency with routing in a template:\nhttp://jsbin.com/surokag/edit?html,js,output\n<a href=\"{{routeUrl page='restaurants'}}\">\nshould be changed to:\n<a href=\"{{ routeUrl(page='restaurants') }}\">\nAnd\n<a href=\"{{routeUrl page='home'}}\">\nshould be changed to:\n<a href=\"{{ routeUrl(page='home') }}\">\n. Completely my mistake. I took it down because the server graphs for CPU, memory, and bandwidth were completely flatlined. So I assumed it wasn't being used anywhere anymore. Wrong assumption on my part.\nIf we decide to not go with Tom's suggestion, we can recreate the feeds on bithub.com.\n. Seaside's concept of Halo's was in an inspiration for me working on the done-inspect code, and is a high level goal.\nhttp://seaside.st/about/examples/halos. It doesn't. I asked if were should handle stripping multiple forward slashes and you said no.  If that has changed, no biggie. I will tweak the regex.\n. Yeah, I just went back and looked at the MDN docs.. and saw IE 9. sigh\n. should this be changed to \nhtml\n<input type=\"checkbox\" ($change)=\"order.items.toggle(.)\" ...\n. ",
    "initialize": "Also, it would be nice if it would trigger a 'reset' event after sorting has been done when pushing objects to the array.\n. ",
    "neektza": "Is this still a valid issue? If it is, I'd like to take a shot at it.\nAFAIU the can.List.prototype.sort is actually this thing right here right?\ncan.List.proto gets extended with it right here.\n. I'll working on this ATM\n. I'll add support for other methods (update and destroy) and merge this into minor once tests are passing.\n. @justinbmeyer I'll add tests for 'update' and 'destroy', similar to what was done for 'findOne'. Once they're passing I'll merge this into minor.\n. ",
    "juanmaia": "+1\n. ",
    "portfolio-systems": "Justin\nI have been using IE8 with 2.0.4  no problems until can.Components additions.\nStandards mode, normal html5shiv etc etc\nI have some form with bleeding edge tech. In my assessment of various frameworks before starting with canjs I experimented with Meteor. An extremely interesting product but not a good fit for various reasons.\nHowever, I had analogous problems, total failure to render etc. Vendors were adamant that tests etc passed (this was Firefox) but turned out they were making assumptions about internal FF settings ... When identified it took a few minutes to fix the code.\nIt's a bloody minefield, but whatever your tests are telling you, this is as simple an example as you could imagine, and in the real world it's failing.\nIt would take one of your guys about one minute to run my HTML page in your devel environment against IE8 and then we can go from there.\nIt is perfectly possible that I am making some kind of error but if so I can't see it. AFAICS the code IS correct according to you docs which means, if I'm correct, that we have a good old fashioned bug.\nRegards\nRon\n\nOn 3 May 2014, at 19:00, Justin Meyer notifications@github.com wrote:\nAlso, make sure that IE8 is in standards mode. CanJS does not support quirksmode.\n\u2014\nReply to this email directly or view it on GitHub.\n. Justin\n\nI have been using IE8 with 2.0.4  no problems until can.Components additions.\nStandards mode, normal html5shiv etc etc\nI have some form with bleeding edge tech. In my assessment of various frameworks before starting with canjs I experimented with Meteor. An extremely interesting product but not a good fit for various reasons.\nHowever, I had analogous problems, total failure to render etc. Vendors were adamant that tests etc passed (this was Firefox) but turned out they were making assumptions about internal FF settings ... When identified it took a few minutes to fix the code.\nIt's a bloody minefield, but whatever your tests are telling you, this is as simple an example as you could imagine, and in the real world it's failing.\nIt would take one of your guys about one minute to run my HTML page in your devel environment against IE8 and then we can go from there.\nIt is perfectly possible that I am making some kind of error but if so I can't see it. AFAICS the code IS correct according to you docs which means, if I'm correct, that we have a good old fashioned bug.\nRegards\nRon\n\nOn 3 May 2014, at 19:00, Justin Meyer notifications@github.com wrote:\nAlso, make sure that IE8 is in standards mode. CanJS does not support quirksmode.\n\u2014\nReply to this email directly or view it on GitHub.\n. Justin\n\nI have created a fiddle : http://jsfiddle.net/4H5dF/\nI have included the external link to the html5shiv that you suggested, but I do not see how any of this will be of use.\nJsFiddle as a site will not run in IE8, at least not for me. It's totally broken\nRon\n+++\nOn 4 May 2014, at 01:49, Justin Meyer notifications@github.com wrote:\n\nI understand it won't take much time (it will take longer than a minute to get a IE8 VM started), but there are other issues that have fiddles waiting. If this is urgent to you, it won't take much more than a minute to create a fiddle.\n\u2014\nReply to this email directly or view it on GitHub.\n. Justin\n\nI have created a fiddle : http://jsfiddle.net/4H5dF/\nI have included the external link to the html5shiv that you suggested, but I do not see how any of this will be of use.\nJsFiddle as a site will not run in IE8, at least not for me. It's totally broken\nRon\n+++\nOn 4 May 2014, at 01:49, Justin Meyer notifications@github.com wrote:\n\nI understand it won't take much time (it will take longer than a minute to get a IE8 VM started), but there are other issues that have fiddles waiting. If this is urgent to you, it won't take much more than a minute to create a fiddle.\n\u2014\nReply to this email directly or view it on GitHub.\n. Justin\n\nMany thanks for your continuing attention to this problem.\n1. I did add the shiv but I forked after adding it and the external resources section then seems to revert to the original. Sorry, didn't realise this - this is my first jsfiddle use ...\n2. Seems to me there is some other issue in play here. I cannot even render the jsfiddle in IE8, there is a js failure as per here : (even their home page fails)\n3. I am not aware of anything unusual in my setup which is :\nMacbook Pro / Mavericks / Parallels / WinXP (to mimic major client legacy system...) everything patched up to date AFAIK\n1. This is my IE8 version\nTools confirms it is in IE8 Standards for both Document and Browser\n1. After further research it seems that IE8 is UNSUPPORTED by jsfiddle, there is mention of a jsfiddle.net/draft feature but that doesn't work for me.\nsee https://github.com/jsfiddle/jsfiddle-issues/issues/311, these are the sorts of errors I get and the last comment is explicit. Not supported.\n1. There's a shed load of stuff on the web about jsfiddle not working in IE8\nAny suggestions would be very welcome, i'm getting to be out of ideas\nRon\n. Justin\nMany thanks for your continuing attention to this problem.\n1. I did add the shiv but I forked after adding it and the external resources section then seems to revert to the original. Sorry, didn't realise this - this is my first jsfiddle use ...\n2. Seems to me there is some other issue in play here. I cannot even render the jsfiddle in IE8, there is a js failure as per here : (even their home page fails)\n3. I am not aware of anything unusual in my setup which is :\nMacbook Pro / Mavericks / Parallels / WinXP (to mimic major client legacy system...) everything patched up to date AFAIK\n1. This is my IE8 version\nTools confirms it is in IE8 Standards for both Document and Browser\n1. After further research it seems that IE8 is UNSUPPORTED by jsfiddle, there is mention of a jsfiddle.net/draft feature but that doesn't work for me.\nsee https://github.com/jsfiddle/jsfiddle-issues/issues/311, these are the sorts of errors I get and the last comment is explicit. Not supported.\n1. There's a shed load of stuff on the web about jsfiddle not working in IE8\nAny suggestions would be very welcome, i'm getting to be out of ideas\nRon\n. Justin\nMy VM setup.\nI downloaded and installed the Parallels / Win7 / IE8 VM from Modern.ie (I also have the 9 to 11 equivalents)\nThis is the canonical setup, blessed by Microsoft for testing websites with older IE\nWithout changing a single thing I am unable to run jsfiddle.net without JS errors and needless to say my original problem remains.\nI don't understand how you are able to run an IE8 VM against jsfiddle AT ALL ! Especially since they explicitly state that IE8 is not supported.\nWhat is your VM setup ?\nWhat is your Secret Sauce ??\nEnquiring mind would like to know ???\nRon\n. Justin\nMy VM setup.\nI downloaded and installed the Parallels / Win7 / IE8 VM from Modern.ie (I also have the 9 to 11 equivalents)\nThis is the canonical setup, blessed by Microsoft for testing websites with older IE\nWithout changing a single thing I am unable to run jsfiddle.net without JS errors and needless to say my original problem remains.\nI don't understand how you are able to run an IE8 VM against jsfiddle AT ALL ! Especially since they explicitly state that IE8 is not supported.\nWhat is your VM setup ?\nWhat is your Secret Sauce ??\nEnquiring mind would like to know ???\nRon\n. Sebastian / Justin\nHi ! \nVerified that your website has this same problem.\nThanks for this ! I'm not sure that Justin and the team entirely believe my problems but this helps a lot (:-)\nFYI the canjs.com website also has some problems in the latest FireFox (29).\nThe login input fields behave strangely.\nIt is as though there is some background process triggering every second or two which has the effect of resetting the input focus to the start of the login username field.\nThe end result is that you are typing away trying to login and all your characters appear but most of them in completely the wrong place ... It is impossible to login unless you type your characters externally and copy paste them\nI don't see this behaviour all the time but mostly I do, and I haven't seen it at all in Chrome\nRegards\nRon Yuen\n+++\nOn 6 May 2014, at 06:07, Sebastian Porto notifications@github.com wrote:\n\nProbably related #965\nJust by going to http://canjs.com/ in IE8 you can see this error\n\u2014\nReply to this email directly or view it on GitHub.\n. Sebastian / Justin\n\nHi ! \nVerified that your website has this same problem.\nThanks for this ! I'm not sure that Justin and the team entirely believe my problems but this helps a lot (:-)\nFYI the canjs.com website also has some problems in the latest FireFox (29).\nThe login input fields behave strangely.\nIt is as though there is some background process triggering every second or two which has the effect of resetting the input focus to the start of the login username field.\nThe end result is that you are typing away trying to login and all your characters appear but most of them in completely the wrong place ... It is impossible to login unless you type your characters externally and copy paste them\nI don't see this behaviour all the time but mostly I do, and I haven't seen it at all in Chrome\nRegards\nRon Yuen\n+++\nOn 6 May 2014, at 06:07, Sebastian Porto notifications@github.com wrote:\n\nProbably related #965\nJust by going to http://canjs.com/ in IE8 you can see this error\n\u2014\nReply to this email directly or view it on GitHub.\n. Justin\n\nI'm referring to your forums and the login for same, sorry not to be more specific\nhttps://forum.javascriptmvc.com/canjs\nAs I write this email I find that Firefox has autoupdated itself to v30 and I no longer appear able to reproduce the problem, which is a relief it was a PAIN. Could well have been a specific FF bug, certainly FF28 was known buggy in several areas. When I tried to licence a copy of Codekit (Less compiler etc) using FF28 it failed and they ended up putting a notice on their website that you couldn't use FF28 ...\nAlternatively it could have been a NoScript artefact as that auto-updates very frequently. Not that I'm paranoid about security you understand. It's just that the Bastards are Out to Get Me.\nI'll keep an eye on it and let you know if it recurs.\nWhile on the website and nit picking, sorry, it's the perfectionist in me, I suspect that the login form and the 'sign in using' images are not rendering quite as intended.\n lack a right border and the sign-in images are all trimmed at the bottom.\nI'd hate for you to get sued by the BigG for bringing their logo into disrepute (:-)\nIt's the same in Chrome and Safari but the amount of image trimmed is fractionally less.\nSmells like an overflow: hidden; in a fixed size container or something akin. Zoom in improves things, zoom out makes them worse. More work for the WebMaster, no peace for the wicked ...\nRegarding the canjs.com website in IE8 I rather think that Sebastian's post proves my point.\nWhatever your tests are telling you, it don't work properly in IE8. I hope that when you nail it turns out to be an easy bug to squash and not one of those 'Jesus our strategy is down the toilet' moments.\nKeep up the good work.\nCheers\nRon\n+++\nOn 6 May 2014, at 12:14, Justin Meyer notifications@github.com wrote:\n\nIn my earlier comment, I said that it was not working when served from github, but worked locally:\nThere might be a problem with how github pages is serving scripts.\nI'm not sure why that is.\nThe login input fields behave strangely.\nWhat login input fields?\n\u2014\nReply to this email directly or view it on GitHub.\n. Justin\n\nI'm referring to your forums and the login for same, sorry not to be more specific\nhttps://forum.javascriptmvc.com/canjs\nAs I write this email I find that Firefox has autoupdated itself to v30 and I no longer appear able to reproduce the problem, which is a relief it was a PAIN. Could well have been a specific FF bug, certainly FF28 was known buggy in several areas. When I tried to licence a copy of Codekit (Less compiler etc) using FF28 it failed and they ended up putting a notice on their website that you couldn't use FF28 ...\nAlternatively it could have been a NoScript artefact as that auto-updates very frequently. Not that I'm paranoid about security you understand. It's just that the Bastards are Out to Get Me.\nI'll keep an eye on it and let you know if it recurs.\nWhile on the website and nit picking, sorry, it's the perfectionist in me, I suspect that the login form and the 'sign in using' images are not rendering quite as intended.\n lack a right border and the sign-in images are all trimmed at the bottom.\nI'd hate for you to get sued by the BigG for bringing their logo into disrepute (:-)\nIt's the same in Chrome and Safari but the amount of image trimmed is fractionally less.\nSmells like an overflow: hidden; in a fixed size container or something akin. Zoom in improves things, zoom out makes them worse. More work for the WebMaster, no peace for the wicked ...\nRegarding the canjs.com website in IE8 I rather think that Sebastian's post proves my point.\nWhatever your tests are telling you, it don't work properly in IE8. I hope that when you nail it turns out to be an easy bug to squash and not one of those 'Jesus our strategy is down the toilet' moments.\nKeep up the good work.\nCheers\nRon\n+++\nOn 6 May 2014, at 12:14, Justin Meyer notifications@github.com wrote:\n\nIn my earlier comment, I said that it was not working when served from github, but worked locally:\nThere might be a problem with how github pages is serving scripts.\nI'm not sure why that is.\nThe login input fields behave strangely.\nWhat login input fields?\n\u2014\nReply to this email directly or view it on GitHub.\n. Curtis\n\nYou are a gentleman and a scholar.\nThank you.\n1. Confirmed that the canjs.com website now works with IE8\n2. Confirmed that my test works with IE8 PROVIDED THAT :\na/  jquery 1.9.1 or greater, it WILL NOT WORK with 1.8.3\nb/ html shiv is 3.7.0\nThat's all it took.\nMay I suggest that your website should always link to the currently blessed version of html5shiv for those of us that need to cater for legacy IE, and also note any explicit jquery version dependencies.\nCan 2.0.4 / 2.0.7 and 2.1.0 all work in this configuration AFAICS\nNow I have to go check everything with this new jquery as I believe that 1.9 + changes quite a bit ... or was it 1.10 ... Heigh Ho.\nStill, If I wanted an easy life I'd have been a bleeding Rocket Scientist.\nI have not the slightest doubt that I will be in need of your services again at some future date, in the meantime you are accumulating credits. I usually pay in beer but alternatives can be negotiated.\nRegards\nRon\n+++\nOn 6 May 2014, at 22:27, Curtis Cummings notifications@github.com wrote:\n\nClosed #952.\n\u2014\nReply to this email directly or view it on GitHub.\n. Curtis\n\nYou are a gentleman and a scholar.\nThank you.\n1. Confirmed that the canjs.com website now works with IE8\n2. Confirmed that my test works with IE8 PROVIDED THAT :\na/  jquery 1.9.1 or greater, it WILL NOT WORK with 1.8.3\nb/ html shiv is 3.7.0\nThat's all it took.\nMay I suggest that your website should always link to the currently blessed version of html5shiv for those of us that need to cater for legacy IE, and also note any explicit jquery version dependencies.\nCan 2.0.4 / 2.0.7 and 2.1.0 all work in this configuration AFAICS\nNow I have to go check everything with this new jquery as I believe that 1.9 + changes quite a bit ... or was it 1.10 ... Heigh Ho.\nStill, If I wanted an easy life I'd have been a bleeding Rocket Scientist.\nI have not the slightest doubt that I will be in need of your services again at some future date, in the meantime you are accumulating credits. I usually pay in beer but alternatives can be negotiated.\nRegards\nRon\n+++\nOn 6 May 2014, at 22:27, Curtis Cummings notifications@github.com wrote:\n\nClosed #952.\n\u2014\nReply to this email directly or view it on GitHub.\n. \n",
    "andrew-sygyda": "This is not a bug, becouse helper {{else}} use only with helper {{#if}}.\n. This is not a bug, becouse helper {{else}} use only with helper {{#if}}.\n. According to source code: \n'unless': function (expr, options) {\n    if (!Mustache.resolve(expr)) {\n        return options.fn(options.contexts || this);\n    }\n}\nDoes not have \"options.inverse\" branch. So thats why {{else}} not working.\n. According to source code: \n'unless': function (expr, options) {\n    if (!Mustache.resolve(expr)) {\n        return options.fn(options.contexts || this);\n    }\n}\nDoes not have \"options.inverse\" branch. So thats why {{else}} not working.\n. ",
    "cjloong": "yes.\n. ",
    "ramblinjan": "Suggestion from @moschel: animate on page navigation in SPA's\n. Related question on Stack Overflow -- should be updated when issue is closed\n. Neither tag is optional in the current html5 spec for anchors.  It doesn't appear to be classified this way in the current version of the parser as it is, so I don't think we're losing any behavior.\nOne place this might be a problem, however, is nesting one anchor inside another anchor, but this is a rule based on the content model, which the parser doesn't enforce anyway.\n. Related question on Stack Overflow\n. Duplicate of #1254 \n. @asavoy Mistyped the issue number. Thanks for pointing it out!\n. Seems to work correctly these days--no longer sure what this issue was actually about anyway.\n. Fixed in branch in #2302 except in amd with dojo--will bug someone later for help with that\n. @RALifeCoach did this get resolved in https://github.com/canjs/can-map-lazy/issues/1?\n. :+1: on some of the anecdotes. It wasn't obvious when the syntax was first settled on, but after some \"user testing\" I think an alternative is worth considering.\n. @BigAB verbose is arguably ok if it's memorable, and verbosity often begets readability.\n{()} syntax may be more concise, but there are two problems with that: it's arguably harder to parse visually at a glance and your brain is going through two steps when converting it to meaning:\nSymbols => Words, Words => What's Happening. \nIt's kind of like using Spanish for an English-speaking audience for the sake of clarifying gender. It may add additional meaning with fewer words, but mentally dealing with the incongruity probably requires use of the reflective system (slow and draining) of thinking instead of the automatic system (fast and unconscious).\nEven if \"Was it bind-in or bind-out?\" is easily confused, you must retain less information to remember it. In=Down, Out=Up. For the current syntax, {}=Down, ()=\"Up\" for events, {^}=Up.\n. ",
    "Lionhunter3k": "Here is the fiddle with the select can-change=\"updateReason\" :\nhttp://jsfiddle.net/dXLGP/1/\nIt doesn't work as intended, it adds up all the option names into one field (in all browsers). I am not sure what you mean by \"Does this also fail when just creating a select field from a list of items and listening to that?\". To a list of predefined items or a dynamic list of items?\nThe first fiddle is the simplest way I could reproduce the issue, the original code was somewhat... larger.\n. http://jsfiddle.net/5N6eW/2/\nI have used a can.Map now, and it still doesn't work.\n. ",
    "Alfredo-Delgado": "@Lionhunter3k, can-click is behaving just as DOM click events behave in Chrome. They are not fired on an option tag when its parent select has a size of 1.\nIn this fiddle, I added a plain ol' select so you can see how it behaves. I also updated your can-click=\"UseReason\" on the option tags to a single can-change=\"UseReason\" on the select tag. You'll see that your code now works in Firefox, Safari, and Chrome.\n. \n. :+1:\n. Will submit as part of a larger request.\n. Why not {{baseUrl}}\"img/foo.png\"?\n. - https://github.com/bitovi/canjs/blame/minor/guides/getting-started-tutorial/tutorial.md#L114 & https://github.com/bitovi/canjs/blame/minor/guides/getting-started-tutorial/setup.md#L16 looking into status of having zip file creation automated cf.\n- https://github.com/bitovi/canjs/blame/minor/guides/getting-started-tutorial/setup.md#L99 unable to reproduce\n- https://github.com/bitovi/canjs/blame/minor/guides/getting-started-tutorial/stache-templates.md#L149 should link to #context\n. Working on this, I'm not sure that the case where a key in a parent scope is undefined should be our concern. \ne.g. current behavior (consistent across browsers)\nvar map = new can.Map({ });\nequal(frag.firstChild.selectedIndex, 0, 'undefined <- {($first value)}: selectedIndex = 0');\nWhat isn't consistent is what happens when the key's value doesn't match one of the select's options:\nmap.attr('key', 'does not match one of the options');\nequal(frag.firstChild.selectedIndex, -1, 'selectedIndex = -1');\nThis passes in Chrome, but fails in Firefox (selectedIndex === 0).\nThis branch addresses this much. I added the fix in attr.set because it seems like a universal problem. Like @matthewp mentioned above, this new behavior conflicts with the change done at https://github.com/bitovi/canjs/commit/c705aa6ca79571cf899fac95cb0b67f8d201d6a3\n. - I added tests for {toString: function(){ return \"something\"}} and they pass.\n- The criterium for using setAttribute was updated to only apply to SVGElement instances.\n. s/their/there\n. Thinking of IE8, this won't work. I'll update to if(el.namespaceURI === 'http://www.w3.org/2000/svg') like modernizr.\n. Also: http://jsperf.com/instanceof-vs-namespaceuri\n. ",
    "sociocast-leroy": "I think this had something to do with the location of my .ready() and manually setting .attr('route').... I've restructured the can.route stuff twice since then and I'm not getting that any more\n. ",
    "Natallia-Bahlai": "I have this issue reproduced both locally (like it is written in daffl's code) and on http://jsfiddle.net/qYdwR/1553/.\nWith the code below default empty route event is fired twice:\n$(function() {\n        var Routing = can.Control({\n            'route': function() {\n                console.log('route');\n            }\n        });\n        var routing = new Routing();\n        can.route.ready();\n    });\n. I am using Chrome and it the code is running within visualforce page. But the page source is the same as below:\n```\n<!DOCTYPE html>\n\n\ncan.route demo\n\n\n\n\n\n    $(function() {\n        var Routing = can.Control({\n            'route': function() {\n                console.log('route');\n            }\n        });\n        var routing = new Routing();\n        can.route.ready();\n    });\n\n\n\n```\n. ",
    "andrejewski": "Closing as retro \ud83d\udc74 . The problem was in the can-util project and has been fixed in the v3.3.6 release of that project.. This needs some with merge rights to merge, which I currently do not have.. Do we need the events folder?\nNo, this is a bike shed.\nCan you explicitly document the typedef/apis?\n\nmakeCustom()\nparameters\ndefaultEventName: string default name of the event\naddEventListener: function\nthis: EventTarget the target to register the event on\neventName: string the name of the event to register on\nhandler: function the handler to call when the event is triggered\nbubble: boolean optional whether the event should bubble\nuseCapture: boolean optional whether the event should capture\n\n\n\nreturns an object containing:\n\naddGlobally(): disposalFn\nreturns the removeGlobally() disposal function\n\n\naddListener(el: HTMLElement, handler: function[, bubble: boolean][, useCapture: boolean]): disposalFn\nparameters\nel: EventTarget the target to register the event on\nhandler: function the handler to call when the event is triggered\nbubble: boolean optional whether the event should bubble\nuseCapture: boolean optional whether the event should capture\nreturns the removeListener() disposal function\n\n\n\n\n\nmakeNative()\n\nparameters\neventName: string default name of the event\n\n\n\nreturns an object containing:\n\naddGlobally(): disposalFn\nreturns the removeGlobally() disposal function\n\n\naddListener(el: HTMLElement, handler: function[, bubble: boolean][, useCapture: boolean]): disposalFn\nparameters\nel: EventTarget the target to register the event on\nhandler: function the handler to call when the event is triggered\nbubble: boolean optional whether the event should bubble\nuseCapture: boolean optional whether the event should capture\nreturns the removeListener() disposal function\n\n\n\n\n\nmakeCompat()\n\nparameters\ndomEvent CustomEvent|NativeEvent the event created via makeCustom or makeNative to use in the returned override method\n\n\n\nreturns an object containing:\n\noverride(domEvents: object): disposalFn\nreturns the removeOverride() disposal function\n\n\n\nmakeRegistry()\n\nparameters\nnone, below we agreed to not allow custom storage solutions for now\n\n\nreturns an object containing:\naddEvent([eventName: string,] event: CustomEvent)\nparameters\neventName: string optional custom name for custom event, otherwise makeCustom's defaultEventName is registered\nevent: CustomEvent event created via makeCustom()\n\n\nreturns the removeEvent() disposal function\nhasEvent(eventName: string)\nparameters\neventName: string name for custom event\n\n\nreturns whether the event is registered with the registry\naddEventListener: function\nparameters\nthis: EventTarget the target to register the event on\neventName: string the name of the event to register on\nhandler: function the handler to call when the event is triggered\nbubble: boolean optional whether the event should bubble\nuseCapture: boolean optional whether the event should capture\n\n\nreturns the removeEventListener() disposal function\n\n\n\nWhat does makeCompat return?\nSee previous snippets.\nDoes myEvent.override mutate its argument?\nYes, override was chosen to reflect how the implementation works. Removal out of order is accounted for, see can-event-radiochange for how it will be handled. There could also be a development mode warning for mis-ordered removals.\nAre there better names for override? mixin, addTo, etc.\nThe word override sounds bad, which is what I want to convey about using the old API. Also the implementation matches the name.\nShould makeNative be memoized?\nThere is no reason why it could not be.\nShould we use a constructor for makeRegistry?\nNo, I don't want to encourage mucking around with it. Under the hood sure, but not as a part of the interface. Heck, let's freeze these puppies.\nWhy different storage solutions?\n\nexpand to another argument if needed.\n\nAs in add the storage argument in the future? If so, yes that's fine.\nShould we distinguish between DOM events and can-event?\nAbsolutely. The can-event-radiochange package can be renamed.\nDoes these custom events need to be identify-able?\nI don't know what this means. If you mean to say should be create a can-symbol symbol to identify and differentiate event types in something like can-import statements, we can. The interfaces are minimally defined so we can make these changes in the future as well.\n. Appended: Consistent APIs across projects\n\nConform registry types with can-view-callbacks\nConforming interfaces with can-event\n\nThere could be some overlap amongst event, attribute, and tag registry systems. can-dom-events may also should align with can-event. Below are my thoughts on these.\nConform registry types with can-view-callbacks\nLooking at can-view-callbacks there definitely some things we can do to make things more consistent, especially when aligning design goals. There are a few things to align:\n\nuse the subscribe-disposal pattern for add/remove\nrename tag() and attr() to addTagEffect() and addAttributeEffect()\n\nThere is not much else to align, multiple registries don't make sense in the current implementation of can-view-callbacks. The only way multiple registries makes sense to be is a component-level registry which child nodes fire up to in the render tree. To accomplish that, we'd need\n\nTagEffectRegistry/.add() and AttributeEffectRegistry/.add()\nor, EffectRegistry/(.addTag/.addAttribute), making can-view-callbacks the global effect registry\nand a dispatch(el) method for all callback registries\n\nThe wildcard style regex filter used in callbacks.attr() is not something that can be brought to can-dom-events because we cannot listen on all events ahead of time because of the way DOM events work.\nAside: In the tag and attr calls, the string equality and regex filter are doing the same thing: filtering DOM nodes. So in can-view-callbacks we can \"lift\" those to accept a predicate function and specialize when a string or regex is passed instead.\nConforming interfaces with can-event\nThis depends on how congruent we'd like to get. Maximally, the addEventListener() and dispatch() (rename to dispatchEvent) are the only two methods needed. Using the subscribe-disposal pattern the remove methods are eliminated. There are also a number of aliases for doing that same thing that can be removed. I don't know how un/delegate are used so I'd drop those. The listenTo/stopListening methods don't make sense in the age of bind and with arrow functions even less, so drop. \nThat leaves the shorthand one, which is much easier to de-sugar with the disposal function, so much easier that I'd remove it. Here's an before/after for one:\njs\ncanEvents.one.call(obj, 'foo', function () {\n  // do something once\n})\njs\nvar removeListener = canEvents.addEventListener.call(obj, 'foo', function () {\n  removeListener()\n  // do something once\n})\nAlso, currently can-event maps calls to can-util/domEvents if the object is an EventTarget, which I don't think is a good decision because if miscalled, DOM events could propagate unexpected events which don't have to be proper Event objects into the DOM event system. Better to isolate the two use cases so one is not coupled to the other.\nThe result of these changes is that can-dom-events and the can-events mixin both use the disposal-pattern and expose only two methods addEventListener() and dispatchEvent().\n\nNote: nothing here changes the can-dom-events API, but clarifies how we can better rework the ecosystem to align with its usage.. can-dom-events went 1.0.0 yesterday, closing.. Superseded by https://github.com/canjs/canjs/pull/3434. Definitely headed in the right direction. I think having each property have full access to all events is going to get confusing and for not much benefit. I think the value of this reducer pattern is encapsulating behavior. Coupling a single piece of data (a property) to potentially many behaviors is easy to get wrong. I'd prefer the model to be defined by the events, not the individual properties.\n```js\nvar MyThing = RajMap(function update (model, message, emit) {\n  switch(message.type) {\n    case 'add': return {...model, count: count + message.value}\n    default: return model\n  }\n});\nvar myThing = MyThing({count: 0})\n// using Proxies or a DefineMap-like thing describing the model we can get:\nmyThing.count // => 0\nmyThing.emit('add', 2)\nmyThing.count // => 2\n```\nIf anyone wants something to look at that has my conceptual seal of approval, check out https://github.com/andrejewski/raj.. The badge, like https://github.com/donejs/developer-relations/issues/12, needs to be discussed before anyone spends too much time on it.. Alternative suggestion: no prefix or suffix, put it all in the Bitovi org until they get big enough like Done and Steal.\nElaborating:\nWhat happens when there are naming conflicts?\nWe rename to a more specific name (not prefixed/suffixed for branding purposes, actually useful stratification) or not publish; assign is taken but our assign is no better than object-assign. We have pretty bad NIH syndrome. Naming conflicts will probably makes us reflect on what actually needs to be developed by us to deliver value to our users.\nNested elaboration for https://github.com/canjs/canjs/issues/3426#issuecomment-315134601\nIf there isn't a good solution we make one, that doesn't change. As far as package alignment, I think that trying to provide everything once with no overlap is not a worthwhile concern. Bundle size does not matter to me as developer. Concerns worth prioritizing are delivering value, runtime performance, and correctness. With jQuery, integrators have very limited options to isolate their dependencies. With such a large surface area / API contract, relying on jQuery would definitely suck, but that's an extreme. A historical extreme.\nWhat does \"big enough\" mean? Individuals are big enough, the collection is big enough?\nBig enough means that for each project there is an ecosystem of tooling around a concrete goal. Steal is big enough for an org and has a clear mission in module loading and bundling. Whereas can-ndjson-steam, can-dom-events, and can-view-model have no relationship and thus should not be grouped together.\nHow do these get documented?\nWe can have bitovi.com/os/<project-name>/<doc-page> or os.bitovi.com serve these purposes, note with this centralization would make a lot of sense to have bitovi.com/os/steal direct to the Steal homepage and same with Done.\nWhy \"brand later\" instead of immediately?\nFirst, too much branding causes indirection. In order to find out about Bitovi, you have to go through Can/Done/Steal. If our goal is to better funnel new clients to Bitovi, we should not put obstacles in front of people for no reason. When something gets big enough, as defined above, we can know for certain it is worth our efforts to brand (cuz that work is not free) and that it serves a direct user need. Not all projects will be winners, why brand their tombstones?\nWe generally try to keep our OS out of Bitovi org because its for client projects and it keeps access rights a bit easier for non-bitovi's to contribute.\nMake a new org for client projects, with all the heightened security they demand (cough 2FA). Bitovi is a public facing company due to our open-source and when/if projects get big enough then outside contributors can become members of those orgs.\nLate Edit: What I am thinking, in terms of marketing is something like this on the footer of every README. It goes a lot further for SEO and brand awareness than can- could ever hope.\n. Closing as this is just a Landscaper test.. The warning no longer exists in @phillipskevin's JSBin updated to use can@4.0.0-pre.10: http://jsbin.com/jowixuxeye/edit?html,js,output\nInspecting the last Can _traceData the only modules using domDispatch and can-util/domEvents which expose the warning code path are test files. So CanJs internally will not produce this warning any more in 4.0.. @matthewp I would prefer a can-3-4-compat package that does more than add two events if there is anything else we could restore.. We could have can-3-4-compat/dom-mutation-events be a module that is imported by can-3-4-compat/index and what not, allowing people more granularity without scattering legacy behavior across entire packages.. I vote for \"Implement through can-stache-bindings\". No need to overcomplicate a more broad API for problems with event bindings.\nI think we should wait for significant interest from the community, and have more concrete examples before going any further than that. From what I have seen Vue doesn't have many of these modifier things. As far as I'm concerned these typing affordances can be resolved through proper component composition.. Performance is a concern for event handler registration, not for registration of custom events. I think the disposal pattern is still good to use for registries in general, it's just that with event handlers so critical to everything and needing to be back-compat anyway I think that part is something we can punt on.. No objection to that. No objection to that, some registries can enforce strings if it makes sense to the use. We'll just change this to identifier: RegistryKey to be most generic.. Like you said this is a temporary convention, I think it would be more better to keep this convention and add a note saying for saying \"Documented __{name}s are safe to use as they are used until symbols are fully supported.\". ",
    "robregonm": "Mustache.\nThe problem appears when you change the value of any of the variables.\n. After switching to Stache this problem got fixed (Now, moving some views to Stache).\n. I think this issue could be related to #1063 \n. Yes, the server is returning the id.\nI'll try queue plugin...\nThis \"error\" happened to me because I accidentally clicked a button twice (which executed todo.save()) and since the first request wasn't finished yet, then the model was created twice. So, the easy way to reproduce was the code I showed above.\nSo my question is: is this an expected behavior?\nThanks again.\n. It seems that it is being caused for another \"bug\" (mine or canjs).\nI'll add details in another issue. Closing this.\n. ",
    "znajem": "What's your timezone? I'm in Kuwait UTC+3.\n-------- Original message --------\nFrom: Justin Meyer notifications@github.com \nDate:18/06/2014  00:46  (GMT+03:00) \nTo: bitovi/canjs canjs@noreply.github.com \nCc: \"Ziad H. Najem\" znajem@computer.org \nSubject: Re: [canjs] Bug in view.mustache Passing Partials in Options (#1068) \n@znajem Thanks! If you have some time tomorrow, can you ping me on skype so I can get this fix in? My screen name is justinbmeyer.\n\u2014\nReply to this email directly or view it on GitHub.\n. ",
    "bmomberger-bitovi": "I made a mixin engine for can-model in my last major project.\nhttps://github.com/google/ggrc-core/blob/develop/src/ggrc/assets/javascripts/models/mixins.js\nAmong our business cases for adding mixins:\n- Complex validations like making a server round trip to check unique titles.\n- Encapsulating a set of attributes (pre-can-define) that were common across a group of objects, when that group didn't neatly fit within the class hierarchy.\n- Having an extension engine meant that behaviors for some items had to be late bound: e.g. if you had workflows, then your objects had workflow state and that had to be managed: https://github.com/google/ggrc-core/blob/develop/src/ggrc_workflows/assets/javascripts/apps/workflows.js#L678\nAlmost none of the cases that we had for mixins dealt with adding to the public interface of objects; they were almost all around dealing with existing functions and properties, and I think that's important to note here.  It seems to me that there are two separate problems:\n- can-connect example: An object has an existing interface from its superclasses, but needs to have behavior injected into this interface; maybe you can't use a class hierarchy because your super/sub relationship is configured at runtime, or you already have a class structure but the new behavior has to be replicated at multiple points (so your other option is copypasta).\n- building a person that's a fighter pilot and a mammal: having one object recognized in multiple well-defined contexts that aren't related, so making properties and methods available to satisfy every required interface. A static class hierarchy is impossible because no single inheritance structure matches your needs.\nThey could be solved with the same approach but may end up needing two different approaches.\nApplying mixin behaviors to class instances, individually, doesn't strike me as a good idea in general, but adding interfaces to individual objects makes sense. It would also be a pretty cool thing to have var person = Object.fromInterfaces(Mammal, FighterPilot);\n. Working on these issues now for can-map-define and can-define, but with my thoughts I posted in https://github.com/canjs/can-map-define/issues/8 there still may be some cases in which default behaviors aren't desired.\nThese are the breakdown of type cases after fixing:\n- '*' and 'compute' are essentially non-events; these just store and return what is passed in.\n- 'number', 'string', and 'date' were already functioning as intended here.  null and undefined retain their values.\n- 'htmlbool' has to be an exception because it's really the presence/absence of a string value that determines true and false.  In other words, null should be false here.\n- 'boolean' is less clear.  I think it should be consistent with the other basic types above but it's currently not: nulls become false.\n- Type constructors are the heart of the issue as reported here, since they should be nullable by default and weren't nullable at all; you would have to .removeAttr() on their respective properties.  This I am fixing.\nSo the real judgment calls here are twofold:\n1. Should we null out regular booleans if null is passed in?\n2. Should we allow the user to override these behaviors with the addition of a nullable property?\n. can-define/map doesn't throw an error after the fix for #2316, but can-map-define still does.\n. It's referenced as a plugin by can-construct in the docs.  I'm terming this target \"legacy\" not because can-construct-super is legacy but because its support is being backported to the legacy canjs monolith.\n. You're both right.  But that just means that you need to link the docs or a quickstart for can-define shorthand from the guide, right before you start using it.. A hover target popover for the line item in the DefineMap def would be awesome.. WRT the comment above, the PR branch didn't have a reference to can-event-dom-radiochange, which was required to make the radio linking work correctly. Now that it's merged into master it seems to be working fine.. Not a good commit.  Closing, will try again.. Working on it; this needs the latest can-stache-bindings to make tests pass.  If I update that, then can-ejs and can-legacy-view-helpers need to be updated, and right now I'm stuck on can-legacy-view-helpers because testee is breaking.. I've wrestled with this same error at times in the past, and also wrote some code mitigating it happening more often (by making another mutation fire and waiting for it), and I think a lot of it comes down to mutation events not having a fixed time or ordering when they fire.  Browser engines are free to batch these events and dispatch them as they see fit.  There's no guarantee that a mutation event will happen within a time box.  For the most part, outliers don't happen, but it seems like we cross some threshold at some point where the browser has to do an allocation or a buffer reset or something, and then we get one mutation batched up way out of order.\nFor now, use whatever tricks you can to make the test pass.  The code itself is tight; it's only an issue because the test battery has to try DOM and vdom in succession.  If we can fix things with a delay, do it.  But I'd also extensively document what you're doing there, so if and when we have the issue again, we won't have to rely on our short memories to inform us of what's going on.. @adrifolio's idea looks very nice, but please remember colorblind users.  Perhaps icon bullets and an outline style for inactive?. Cherif said in https://github.com/canjs/canjs/issues/3426#issuecomment-315143438\n\nWhat about javascriptstd (standard library for javascript)\n\nI like the idea of promoting it as a standard, but I'd use -sb (for JS Standard Base) or -sp for (JS Starting Point) instead.  Some brief research says that the two letter forms of this aren't used for anything in the JS world, and at very least JSSB only name clashes with a bank.. I've been evaluating different cyclic dependency options to run in canjs/canjs to catch things during build.\nThe fastest one seems to be with nocycle: https://www.npmjs.com/package/nocycle .  Use this node script during the build to check for a cycle in our scripts in can.all (we can also make our own printer that would warn appropriately):\njavascript\nrequire(\"nocycle\").detect();\nvar GLOBAL = require(\"can-global\");\nvar global = GLOBAL();\nrequire(\"can-vdom\");\nglobal.HTMLElement = global.Node;\nglobal.XMLHttpRequest = global.XMLHttpRequest || function() {};\nglobal.$ = global.jQuery = require(\"jquery\");\nrequire(\"./all\");\nAnother option that's completely settable from the CLI is madge: https://www.npmjs.com/package/madge .  This is slower than nocycle but could be done with just a bash script instead of setting up a custom server-side can instance:\nbash\nfind node_modules/can-* -name \"*.js\" | grep -Ev \"node_modules.*node_modules|dist\" | xargs madge --include-npm --circular\nMost other items in my research required webpack, and were ignored as a result.  Another package, circular-require, didn't catch the cyclical dependency in can-zone, so I can't trust it to find anything else.\nThe scripts above could be easily adapted to run against individual packages if we want.  nocycle, in particular, requires a script file to find its dirname (it can't be run successfully with node -e).. I think I've found them all.. Yep, I had pushed it but not created a PR.  Will close this once patch releases are done for every lib.. Closing in favor of #3519 . Other than can-connect, this has been implemented across the board.  Closing.. Tests on IE are failing.  Will investigate.. Tests fixed.  Intermittent Sauce Labs failures seem to have cleared up to (chrome failures based on window objects not being found by FuncUnit).  This is ready to review.. If I understand lerna correctly, they exist as one GitHub repo, but are published to NPM individually.  As an example, with Stackstorm, you can see a module in https://github.com/Stackstorm/st2web 's modules folder, like st2-login.  It contains its own package.json that declares its name as @stackstorm/module-login.  If you search NPM, you find @stackstorm/module-login and it links back to the st2web Github repo.\nSo for users wanting to make incremental upgrades, nothing changes.  It comes down to how we want to organize our projects. I suspect that we're hurt a bit by canjs's issue tracking being split across the 100+ repos.  However, I recognize that trading that for every issue ever being put into one repo is a problem of its own.  So we'd have to evaluate whether it would make it easier to get a clear view of outstanding issues and project needs, or harder.\nThat said, I want to avoid ever again making temporary version publications to pass so that I can update packages with mutual devDependencies/dependencies cycles. Nobody should ever have to do that, but it's almost mandatory when we make big, sweeping changes to the codebase (e.g. reflection).  If we have a monorepo, we don't have to do the weird manual steps to mutually upgrade packages.. > There's also https://github.com/lerna/lerna . Something to consider.\nRelated: https://github.com/canjs/canjs/issues/4235. Good question raised by @matthewp:  \nHow will connectedCallback work in the transparent component proposal?\nSome ideas:\n Pass null\n pass a fragment of all child nodes. \n Pass the first element child\n Pass the parent element\n Apply the array of all element children\n Pass the can-view-nodelist\n* Create the node then immediately remove it from the DOM after connectedCallback is run, and promote its children to the parent.\nI don't think there's an optimal answer in this case, but someone probably already knows the least-bad solution. ",
    "patrickvogt": "On http://canjs.com/guides/Observables.html: In the first three example codes the map is called \"pagination\". Beginning with example four the map is called \"paginate\" e.g. for binding/registering to events. Perhaps the name of the map should be consistent within the whole page such that there won't be any mistakes when copy & paste the example codes from the page step-by-step\n. on http://canjs.com/guides/Observables.html: Section \"Composite Computes\" - Example - Line 23 \"fullName();\" instead of \"fullname();\"\n. on http://canjs.com/guides/Observables.html: Section \"Converted Computes\" - Example - Line 13 and 16 \"progressPercentage()\" and \"progressPercentage(75)\" instead of \"percentage();\" and \"percentage(75);\"\n. on http://canjs.com/guides/EJS.html: Section Magic tags, First Example, Code Line 1 - I think the Condition is wrong. Shouldn't it say \"if(todos.attr('length') <= 0)\". I think at the moment the logic is inverted\n. ",
    "chasenlehara": "Closing this because we have new guides: http://canjs.com/doc/guides.html. +1, we ran into an issue caused by this bug in Sam\u2019s.\n. @justinbmeyer I have some other open source stuff I want to work on, so if someone takes those before I get a chance, they can use my PR: https://github.com/canjs/canjs/pull/2222\n. You can see these changes here: http://chasenlehara.github.io/guide/Tutorial.html\n. Closing in favor of https://github.com/bitovi/canjs/pull/1741\n. Here are the changes that need to be considered (the rest are related to the example code): https://github.com/bitovi/canjs/pull/1738/files#diff-4640f378a7ad79111092c63b9064e704\nYou can see these changes here: http://chasenlehara.github.io/guide/Setup.html\n. Closing in favor of https://github.com/bitovi/canjs/pull/1741\n. Two new pages:\n- Application Design: http://chasenlehara.github.io/guide/ApplicationDesign.html\n- Constructors: http://chasenlehara.github.io/guide/Constructors.html\n. Two new pages:\n- Application Design: http://chasenlehara.github.io/guide/ApplicationDesign.html\n- Constructors: http://chasenlehara.github.io/guide/Constructors.html\n. Closing in favor of https://github.com/bitovi/canjs/pull/1741\n. Closing in favor of https://github.com/bitovi/canjs/pull/1741\n. I took a bunch of screenshots and have integrated most of them into the guides, but here are a few leftover that I hadn\u2019t used yet:\n\n\n\n. I took a bunch of screenshots and have integrated most of them into the guides, but here are a few leftover that I hadn\u2019t used yet:\n\n\n\n. Added the page in this commit: https://github.com/bitovi/canjs/commit/d8aed495332561167f4c9628701b0b41db62a8e8\nA preview can be seen here: http://canjs.com/2.3-pre/guides/Observables.html\n. Added the page in this commit: https://github.com/bitovi/canjs/commit/d8aed495332561167f4c9628701b0b41db62a8e8\nA preview can be seen here: http://canjs.com/2.3-pre/guides/Observables.html\n. Current link: https://canjs.com/doc/roadmap.html\nThis can be updated after https://github.com/bitovi/extracurriculars/issues/87 is published.. Current link: https://canjs.com/doc/roadmap.html\nThis can be updated after https://github.com/bitovi/extracurriculars/issues/87 is published.. We\u2019ve had this on the CanJS 3 site for a while: https://canjs.com/doc/guides/api.html. We\u2019ve had this on the CanJS 3 site for a while: https://canjs.com/doc/guides/api.html. @marshallswain, yes, just added docs: https://github.com/canjs/canjs/pull/2222/files?short_path=ea73bd9#diff-ea73bd9b162a471eb881dae973216353\n. @marshallswain, yes, just added docs: https://github.com/canjs/canjs/pull/2222/files?short_path=ea73bd9#diff-ea73bd9b162a471eb881dae973216353\n. Hey @mickmcgrath13, it doesn\u2019t work out of the box with the super plugin, but I started working on making _super available and it looks like I\u2019ll be able to do it. I\u2019ll continue working on it and update my PR.\n. Hey @mickmcgrath13, it doesn\u2019t work out of the box with the super plugin, but I started working on making _super available and it looks like I\u2019ll be able to do it. I\u2019ll continue working on it and update my PR.\n. @justinbmeyer I have some other open source stuff I want to work on, so someone can take these issues if I don\u2019t get to them first: https://github.com/canjs/can-map-define/issues/2 & https://github.com/canjs/can-define/issues/18\n. @justinbmeyer I have some other open source stuff I want to work on, so someone can take these issues if I don\u2019t get to them first: https://github.com/canjs/can-map-define/issues/2 & https://github.com/canjs/can-define/issues/18\n. Closing this because it won\u2019t be merged into a release.. Closing this because it won\u2019t be merged into a release.. Yeah, unfortunately the most simple case works, but it fails when a component is involved.\n. Yeah, unfortunately the most simple case works, but it fails when a component is involved.\n. @matthewp I\u2019d like to echo @marshallswain\u2019s comment. If I\u2019m experiencing a bug and I can narrow it down between two versions, looking through the changelog can give some indication of what might\u2019ve caused the bug.\n. @matthewp I\u2019d like to echo @marshallswain\u2019s comment. If I\u2019m experiencing a bug and I can narrow it down between two versions, looking through the changelog can give some indication of what might\u2019ve caused the bug.\n. I think it\u2019s assuming that at least 50% of the issues created are the same type and would benefit from having a template available. Looking at the issues list, I think a majority of them would find a template that asks for a description, steps to reproduce, expected results, actual results, links, and version info useful. If you start filing a new issue that doesn\u2019t make sense with the default template, it\u2019s pretty easy to delete everything and start from scratch.\n. I think it\u2019s assuming that at least 50% of the issues created are the same type and would benefit from having a template available. Looking at the issues list, I think a majority of them would find a template that asks for a description, steps to reproduce, expected results, actual results, links, and version info useful. If you start filing a new issue that doesn\u2019t make sense with the default template, it\u2019s pretty easy to delete everything and start from scratch.\n. Closing in favor of https://github.com/donejs/developer-relations/issues/15. Closing in favor of https://github.com/donejs/developer-relations/issues/15. Thanks guys. Based on what I found, I think I could fix this by just moving that line of code. I\u2019ll write a test for %root first, make sure this fix breaks it, then see if I can move that line of code to satisfy both tests.\n@matthewp, yes, this commit is what first started breaking my test case for #2250. I determined that when %root was being set up, it was not correctly initializing my scope variable.\n. Thanks guys. Based on what I found, I think I could fix this by just moving that line of code. I\u2019ll write a test for %root first, make sure this fix breaks it, then see if I can move that line of code to satisfy both tests.\n@matthewp, yes, this commit is what first started breaking my test case for #2250. I determined that when %root was being set up, it was not correctly initializing my scope variable.\n. @justinbmeyer & @matthewp, here\u2019s what I\u2019ve done:\n- Add a (really simple) test for %rootin can.Component\n- Revert my previous changes\n- Fix the original bug by allowing the component\u2019s attributes to be bound first before %root\n. @justinbmeyer & @matthewp, here\u2019s what I\u2019ve done:\n- Add a (really simple) test for %rootin can.Component\n- Revert my previous changes\n- Fix the original bug by allowing the component\u2019s attributes to be bound first before %root\n. The cause of this issue is a little tough to explain, but here\u2019s my best shot:\n- can.Map helpfully keeps track of objects that it\u2019s converted, so if you pass it an object twice, it\u2019ll return the same can.Map instance\n- When %root is a plain object, it gets converted to a can.Map\nIn #2250, %root has a collection that is converted into a can.List because %root is converted first. Then, when collection is defined on the component, can.Map (unhelpfully in this case) returns the can.List it had already created instead of converting the object to the special Collection type.\nThis PR \u201cfixes\u201d (it\u2019s kind of a hack) the issue by setting up %root after the other properties are converted, so it references the converted values instead of creating its own.\n@justinbmeyer and I talked about this and he might be able to add more clarification to this rough description.\n. The cause of this issue is a little tough to explain, but here\u2019s my best shot:\n- can.Map helpfully keeps track of objects that it\u2019s converted, so if you pass it an object twice, it\u2019ll return the same can.Map instance\n- When %root is a plain object, it gets converted to a can.Map\nIn #2250, %root has a collection that is converted into a can.List because %root is converted first. Then, when collection is defined on the component, can.Map (unhelpfully in this case) returns the can.List it had already created instead of converting the object to the special Collection type.\nThis PR \u201cfixes\u201d (it\u2019s kind of a hack) the issue by setting up %root after the other properties are converted, so it references the converted values instead of creating its own.\n@justinbmeyer and I talked about this and he might be able to add more clarification to this rough description.\n. @Hamelina This sounds like a different problem; would you mind opening a new issue with more info? What version of CanJS? Are you importing can-stache/helpers/route or can-stache-route-helpers somewhere in your app or template?. @Hamelina This sounds like a different problem; would you mind opening a new issue with more info? What version of CanJS? Are you importing can-stache/helpers/route or can-stache-route-helpers somewhere in your app or template?. There were some things that we had to change in our code to upgrade to 2.3, but I think most/all of them were bugs in our code that just happened to work in 2.2, like calling this.prop() instead of this.attr('prop'). I\u2019ll write those things up as soon as I get a chance.\n. There were some things that we had to change in our code to upgrade to 2.3, but I think most/all of them were bugs in our code that just happened to work in 2.2, like calling this.prop() instead of this.attr('prop'). I\u2019ll write those things up as soon as I get a chance.\n. Looks like @justinbmeyer wrote this: https://v3.canjs.com/doc/guides/contributing/documentation.html\nI\u2019ll review that page and close this issue as soon as I can.\n. Looks like @justinbmeyer wrote this: https://v3.canjs.com/doc/guides/contributing/documentation.html\nI\u2019ll review that page and close this issue as soon as I can.\n. Closing this issue in favor of https://github.com/canjs/bit-docs-html-canjs/issues/123 so we don\u2019t have discussions about this in multiple places. \ud83d\ude42. Closing this issue in favor of https://github.com/canjs/bit-docs-html-canjs/issues/123 so we don\u2019t have discussions about this in multiple places. \ud83d\ude42. I don\u2019t think the above flow is effective for new users. Here is some feedback I received during the usability sessions:\n\nThe Guides page is entirely too lengthy and not focused on what should be the next step: a getting started guide.\nThe Mission page seems more geared towards our clients, not other developers.\nThere isn\u2019t a compelling reason to care about the project\u2019s mission until the technology is explained; similarly, the sales pitch is unexpected when the tech hasn\u2019t been explained.\nThe Technical Highlights page doesn\u2019t \u201chighlight\u201d the tech; it\u2019s way too much information early on.\n\nOverall, the site isn\u2019t conducive to new users because it prioritizes things that aren\u2019t important to them until they\u2019ve learned more about the framework.\nI think we can make this better by prioritizing these things, starting from the home page:\n- A quick summary of what CanJS is (a frontend JS framework)\n- A brief overview of its best features/concepts (components, model, observables, etc.)\n- A getting started guide\nHere are the steps we can take to do that:\n- Remove the collections from the home page\n- Provide a higher-level overview of all the core APIs\n- De-emphasize things like the mission and contribution guides\nI am still working through my thoughts on this, so please understand that the above are my first ideas that still need to be refined. Input is welcome!. I don\u2019t think the above flow is effective for new users. Here is some feedback I received during the usability sessions:\n\nThe Guides page is entirely too lengthy and not focused on what should be the next step: a getting started guide.\nThe Mission page seems more geared towards our clients, not other developers.\nThere isn\u2019t a compelling reason to care about the project\u2019s mission until the technology is explained; similarly, the sales pitch is unexpected when the tech hasn\u2019t been explained.\nThe Technical Highlights page doesn\u2019t \u201chighlight\u201d the tech; it\u2019s way too much information early on.\n\nOverall, the site isn\u2019t conducive to new users because it prioritizes things that aren\u2019t important to them until they\u2019ve learned more about the framework.\nI think we can make this better by prioritizing these things, starting from the home page:\n- A quick summary of what CanJS is (a frontend JS framework)\n- A brief overview of its best features/concepts (components, model, observables, etc.)\n- A getting started guide\nHere are the steps we can take to do that:\n- Remove the collections from the home page\n- Provide a higher-level overview of all the core APIs\n- De-emphasize things like the mission and contribution guides\nI am still working through my thoughts on this, so please understand that the above are my first ideas that still need to be refined. Input is welcome!. Step 1 for someone picking this up should be reviewing/merging https://github.com/canjs/canjs/pull/2711. Step 1 for someone picking this up should be reviewing/merging https://github.com/canjs/canjs/pull/2711. I\u2019m merging this as-is because we\u2019re not linking to the comparison page from anywhere and this can help the next person who works on that page.. I\u2019m merging this as-is because we\u2019re not linking to the comparison page from anywhere and this can help the next person who works on that page.. https://github.com/canjs/canjs/pull/3160. https://github.com/canjs/canjs/pull/3160. A reusable component would be nice, but not a priority for now. @leoj3n, would you mind submitting a PR to fix the CanJS, DocumentCSS, and DoneJS sites please? [I think all the other ones are ok.]. A reusable component would be nice, but not a priority for now. @leoj3n, would you mind submitting a PR to fix the CanJS, DocumentCSS, and DoneJS sites please? [I think all the other ones are ok.]. Issue moved to canjs/bit-docs-html-canjs #203 via ZenHub\n. Issue moved to canjs/bit-docs-html-canjs #203 via ZenHub\n. @justinbmeyer, when you get a chance, would you mind adding more detail to this issue please?\n. @justinbmeyer, when you get a chance, would you mind adding more detail to this issue please?\n. @justinbmeyer, I\u2019m done with my first draft of the Models section. I plan on going through it tomorrow to clean it up. Please feel free to provide feedback at your earliest convenience or after I\u2019ve made a second draft.. @justinbmeyer, I\u2019m done with my first draft of the Models section. I plan on going through it tomorrow to clean it up. Please feel free to provide feedback at your earliest convenience or after I\u2019ve made a second draft.. @justinbmeyer, here\u2019s a rough agenda for what I\u2019ll go through with each person tomorrow:\n\nAsk some questions to establish their familiarity with JavaScript and CanJS (5 minutes)\nDirect them to the CanJS homepage, have them go through it and get their feedback (5\u201310 minutes)\nLet them browse around the site a bit based on what they\u2019re interested in (15\u201320 minutes)\nIf they haven\u2019t already, direct them to pages like Mission and Technical Highlights to get their feedback (15\u201320 minutes)\nBreak! (5\u201310 minutes)\nHelp them pick an experiment guide (e.g. the Chat or TodoMVC guides), have them go through it and collect their feedback (30\u201390 minutes)\nClosing thoughts: collect general feedback about the site, framework, etc. (10\u201315 minutes)\n\nPlease let me know if I\u2019ve left out something you\u2019d like me to cover, or if you have any advice!. @justinbmeyer, here\u2019s a rough agenda for what I\u2019ll go through with each person tomorrow:\n\nAsk some questions to establish their familiarity with JavaScript and CanJS (5 minutes)\nDirect them to the CanJS homepage, have them go through it and get their feedback (5\u201310 minutes)\nLet them browse around the site a bit based on what they\u2019re interested in (15\u201320 minutes)\nIf they haven\u2019t already, direct them to pages like Mission and Technical Highlights to get their feedback (15\u201320 minutes)\nBreak! (5\u201310 minutes)\nHelp them pick an experiment guide (e.g. the Chat or TodoMVC guides), have them go through it and collect their feedback (30\u201390 minutes)\nClosing thoughts: collect general feedback about the site, framework, etc. (10\u201315 minutes)\n\nPlease let me know if I\u2019ve left out something you\u2019d like me to cover, or if you have any advice!. Reopening because can-stache has the same issue: https://github.com/canjs/can-stache/blob/master/package.json#L31. Thanks @matthewp, I will test the new releases either today or tomorrow. Closing for now.. I still have a few things I\u2019d like to do:\n- [ ] Verify the Browserify code works after this issue is fixed\n- [ ] Add instructions for using Webpack\n- [ ] Add a note about whether you can use Yarn. Slack discussion where this was asked: https://bitovi.slack.com/archives/team-open-source/p1480526674014683. Closing in favor of https://github.com/canjs/bit-docs-html-canjs/issues/211. The JS Bins are broken when you\u2019re on https because their URL is http.. Closing in favor of https://github.com/canjs/canjs/issues/4170 (and because can-stache-loader exists).. I wrote a first draft today: https://docs.google.com/a/jupiterjs.com/document/d/1UQ42o5jMKT-dbT0XwWO081pZwkKOssyAkErdNE_-IHQ/edit?usp=sharing. Published: https://www.bitovi.com/blog/how-to-upgrade-a-donejs-plugin-to-canjs-3. Added CanJS 3 Codemods as a blocker because it\u2019ll be easier to show the entire process in the blog post if codemods can be used.. @justinbmeyer and I talked about following a similar pattern to what\u2019s used by the DoneJS and MDN sites: a table of contents that sticks to the right as the user scrolls.\nI think this would be more visible to users and would also help with the content not being so wide on widescreen displays.. Issue moved to canjs/bit-docs-html-canjs #202 via ZenHub\n. \ud83d\udc4d Sorry about that.\nLooks like ZenHub has a \u201cMove Issue\u201d feature in the right sidebar that makes this pretty easy.. No, we\u2019re going to keep it.. The information architecture screenshot in this comment renames the group and this page\u2019s title\u2026 but I\u2019m really conflicted about it. I think the most useful place for this information would be in the API Docs hierarchy, but there\u2019s no good place to put it unless we just put it on the API Docs page.. This could be related to https://github.com/canjs/canjs/issues/2902 if include the main parts of a CanJS app on the home page.. Related feedback from @gKreator: https://gitter.im/canjs/canjs?at=58958b7b46101c1209871de1. Yeah, maybe abbreviating the module name (StealJS style) is a bad idea. If this replacement is just in sentences, not the API examples, do you think it\u2019d still be confusing to non-Steal users?\nHere\u2019s the kind of thing I want to fix:\n\nThis is because can-connect/can/super-map/super-map adds the can-connect/real-time/real-time behavior. The can-connect/real-time/real-time behavior automatically inserts newly created messages into lists that they belong within.\n\nBoth uses of can-connect/real-time/real-time could be replaced with \u201creal-time\u201d, like so:\n\nThis is because can-connect/can/super-map/super-map adds the real-time behavior. The real-time behavior automatically inserts newly created messages into lists that they belong within.\n\ncan-connect/can/super-map/super-map is still a mouthful, which is why I thought can-connect/can/super-map/ might be better:\n\nThis is because can-connect/can/super-map/ adds the real-time behavior. The real-time behavior automatically inserts newly created messages into lists that they belong within.\n\nThoughts on that?. Here\u2019s another sentence that could benefit from using Steal-style abbreviations:\n\ncan-define/map/map and can-define/list/list allow you to create observable maps and lists with well defined properties.\n\nThis would be easier to read as:\n\ncan-define/map/ and can-define/list/ allow you to create observable maps and lists with well-defined properties.. I have a different issue open for either moving or removing the current API Guide page.\n\nThis issue is related to the Collections section on the home page. It can be overwhelming for new users to see so many APIs listed on the home page because it makes CanJS look monolithic and complicated. The framework isn\u2019t as approachable with so many modules, especially because of all the jargon.\nI think it would be appropriate to list all of the modules on a main API page, which would make it easier to find what you\u2019re looking for when you\u2019re familiar with the terms.. Which it is! Conceptually, it\u2019s not so monolithic either: there are a few basic concepts (components, observables, etc.) that are easy for new users to grasp. I think emphasizing those basic concepts first will make it easier for new users to get started.. Yeah, exactly. The goal is to guide people where we want them to go next.. Two thoughts on that:\n1. We could remove the count but leave the button (that was actually my original intent when I filed this issue).\n2. If we move that section off the homepage, I think the star count is not as big of a deal.. @justinbmeyer, are there docs for __listSet (or this general issue) anywhere?\nIt seems like we might want to make __listSet a \u201cpublic\u201d API if it\u2019s needed for some functionality.. Added the design label because we could show the content on that page in a more compelling way.. It should be semi-evident on the public-facing sites; for internal stuff, if it\u2019s a project we worked on, then @brianmoschel or someone else will know.. I added the design label because I think we can do a better job of showcasing those sites\u2026 sorry, I should probably start creating separate issues with just the design work. \ud83d\ude15 . Closing this because I think the only things I thought were ES2015 were the object getters, which were defined in ES5.1: http://www.ecma-international.org/ecma-262/5.1/#sec-11.1.5. This came up during the UX testing (with one user). I don\u2019t think it\u2019s a priority or something we should necessarily add, although I see its usefulness. I created this issue so we could track interest if it comes up again.. Created two issues related to this:\n- Add videos to the ATM Guide: https://github.com/canjs/canjs/issues/2900\n- Make a better state diagram for the ATM Guide: https://github.com/canjs/canjs/issues/2901. Hi @frank-dspeed, a few comments:\n1. Each page has a \u201csource\u201d link that takes you to where you can see & edit the docs. I have an issue open for changing the link\u2019s text to something more identifiable: https://github.com/canjs/bit-docs-html-canjs/issues/201\n2. It looks like those links aren\u2019t working correctly for can-define/list/list, so I\u2019ve filed an issue for that: https://github.com/canjs/canjs/issues/2898\n3. That example uses the new ES2015 syntax, so it\u2019s not wrong, but I\u2019ve opened an issue for only using ES5 in our docs to avoid confusion: https://github.com/canjs/canjs/issues/2884. Today I learned that those getters were included in ES5.1: http://www.ecma-international.org/ecma-262/5.1/#sec-11.1.5. Issue moved to canjs/bit-docs-html-canjs #204 via ZenHub\n. Ok, I\u2019ve removed that from the description.\nI understand what the first \u201centry point\u201d one means, but what do the ones near unverified, Picking Account, and Withdraw Info mean?. Thanks @blazepollard! If you want to, you can submit a PR that updates the image in this folder: https://github.com/canjs/canjs/tree/master/docs/can-guides/experiment/atm/1-pages-template\nIf someone needs to make changes in the future, where can they find the original file you worked on?. Thanks @blazepollard!\n@jamiemccue, could you please add Blaze\u2019s Axure file to wherever you\u2019re organizing the rest of the design resources?. The URLs that still have http in them are just links. I already fixed the embeds to be protocol relative.. They stopped making that a paid feature a year and a half ago: https://jsbin.com/blog/ssl-for-all. The URLs just need to be changed to be protocol relative; this would be an easy contribution if someone wants to take it.. @phillipskevin, I know this isn\u2019t the same as what you asked, but I merged master into this branch and am still seeing the same test failures.. \u2026and just realized I should\u2019ve changed the base. Restarting the builds\u2026. Actually, on second thought, would this go into the next minor release? Should I update minor to match current master and then change the base of this PR to that?. Two things I see that are broken:\n\n[ ] Demo tab doesn\u2019t show the total number of pages\n[ ] HTML tab just shows <div id=\"out\"></div>\n\n\n. I think the stache markup should be shown. According to the @demo docs, you can add id=\"demo-html\" to the script element to show it.. @justinbmeyer Was this closed on purpose?. The core team is quickly closing in on the DoneJS 1.0 release. Since that\u2019s still our current focus this month, I\u2019ve updated the RFP\u2019s description to note that we are not requiring submissions by March 10. We will most likely set another date as we get closer to when we\u2019ll start discussing this topic.. > If you install canjs, but you should install can.\nYes, sorry I mistyped my original description. It\u2019s updated now.. Related: https://github.com/donejs/donejs/issues/792. Yeah, good idea. If we can define mixins well, we can do something similar to how Apple handles protocols:\nhttps://developer.apple.com/reference/uikit/uicollectionviewtransitionlayout#relationships\n\n. Update the release folder is part of the docs for publishing a 2.3 release, so I\u2019m going to close this issue.. Thanks @Macrofig! I\u2019ve merged this and created another issue for us to follow up with: https://github.com/canjs/canjs/issues/3055. Heh, I missed the memo that name was deprecated too.\nHere\u2019s our code that doesn\u2019t support name: https://github.com/canjs/bit-docs-html-canjs/blob/d1352069818e053453a5f082fad68e08f79f3ad6/static/canjs.js#L98. This document will need to be updated to not use name: https://github.com/donejs/donejs/pull/829/files#diff-54741d26fa44ca37b832eee981ddc15b. @ilyavf, I\u2019m not sure what that issue you referenced has anything to do with this one. This issue is related to editing the docs for a module and that other one is for seeing the actual source code for the module. Could you clarify please?. Closing this PR because I\u2019m going to open another one that doesn\u2019t have Marshall\u2019s commits.. Remember that when the major version is 0, ^ will only include new patch versions, not minor.\nI think Travis is failing because we need to set the FIrefox version; I\u2019ve opened a PR for that: https://github.com/canjs/canjs/pull/3074. @Rlin415 If you get a chance, could you please merge master into your branch and push? Hopefully that\u2019ll fix the CI issue.. @Rlin415 It looks like a commit from https://github.com/canjs/canjs/pull/3097 was missed when this branch was updated. I don\u2019t think it\u2019ll cause any issues but it might be good to update it again.. @Rlin415 There\u2019s a merge conflict that need to be fixed.. What you\u2019re suggesting sounds right to me: the PropDefinition docs should say that Type accepts a constructor function or a PropDefinition.. The issue might actually be in https://github.com/canjs/bit-docs-html-canjs. Recipes is now a direct descendant of Guides:\n\n. Issue moved to canjs/can-map #34 via ZenHub\n. CanJS 3.6 was released a couple days ago: https://github.com/canjs/canjs/releases/tag/v3.6.0. Hey @frank-dspeed, thanks for the feedback. I don\u2019t disagree that this would be helpful, I\u2019m just curious why you would find this useful. \ud83d\ude42. I still need to run through the guide and add a link to it from the main recipes page.. I would make it name: https://github.com/canjs/can-util/blob/3bd0e682e3e2d8edd340bb084a838a320ee67257/dom/data/data.js#L5. Hi @morrme! Yes, please feel free to submit a PR for it. I think all that needs to changed is the beforeremove example in this file: https://github.com/canjs/canjs/blob/24c957194c034b778fdc45eaee042196b4b523dc/docs/can-guides/commitment/migrating_to_3.0.md. Yup, I think it should change from \"beforeremove\" to \"{element} beforeremove\". Dupe of https://github.com/canjs/bit-docs-html-canjs/issues/204. I\u2019ve updated the guide with instructions for how to start with the prototype HTML and modify it to create the app, \u00e0 la the TodoMVC guide.. Yes, sorry about that, revert PR: https://github.com/canjs/canjs/pull/3141. @Macrofig, this would be a great topic for conversation during the next contributors meeting.\nThere\u2019s also an issue for it here: https://github.com/donejs/developer-relations/issues/22\nI totally agree with the goals you outlined. I am also on the \u201cdon\u2019t care what the rules are, just want things to be consistent\u201d bandwagon.. Another example of how to do it: https://github.com/canjs/can-util/pull/267/files. Looks great, thank you @morrme!. I think this is the same as https://github.com/canjs/can-define/issues/153. I think this is fixed in the latest version of can-define and the fix will be included in the next version of CanJS.. Thanks for filing this issue @dtomack! This seems like a pretty straightforward bug. Would you be able to submit a PR for it? Otherwise the team will probably take a look sometime next week.. Thanks @dtomack! You can branch off 2.3-legacy and submit a PR; we\u2019re happy to make a release once it\u2019s merged in.. Nothing else; I don\u2019t want to take the risk of publishing a bad release at the end of the day, so I\u2019m going to publish 2.3.31 in the morning. Thanks for your contributions!. @dtomack CanJS 2.3.31 has been released with this fix. We\u2019ll get out a new release of can-list with this fix soon too. Thanks for your help!. @matthewp I think the tests should also be added; not sure what else might be missing from the instructions on Making a New Package.. @ypanyukov Sorry about that, all of those release folders are there now.. Yeah, I saw that and manually checked to see if the code is correct for the version. It looks like just the numbers are wrong in the comments. I would have \u201cfixed\u201d it but then it would\u2019ve been different from the actual release, so I left the files alone.. This has been published: https://canjs.com/doc/guides/upgrade/using-codemods.html. \ud83d\ude0d the before/after screenshots\nI don\u2019t think docMap.json is supposed to be committed. I would reset your branch back to your first commit, remove the file, add it to .gitignore, amend your commit, then force-push the branch to update this PR. I\u2019m happy to pair if any of this is confusing or intimidating.. I forgot to assign this issue to you: https://github.com/canjs/canjs/issues/2868\nI would make that change too since you added them to the API page. \ud83d\ude0a. https://github.com/canjs/canjs/pull/3254. I\u2019m not sure what the syntax should be for linking to the root of the site. I would just change that link to be https.\nI don\u2019t think we need to immediately deploy a new version of the site to fix this issue (because they work on http and we\u2019re not forwarding to https right now), so I think it\u2019s ok to wait until bit-docs-html-canjs is fixed.. The commits from this branch were merged but the search feature isn\u2019t yet active; I will open a new PR to enable search sometime in the future.. Hey @tomgreever! To be clear, I\u2019m not advocating for any change in the process[1], I just want to make it easier for:\n\ndesigners to get up to speed with the project\ndevelopers to reference the design mockups/prototypes\n\nI\u2019m afraid stuff gets lost in GitHub issues and it\u2019s sometimes hard to answer questions like \u201cis this a bug or how the design is supposed to look?\u201d\nHopefully that makes it a little more clear why I think it\u2019s worth us organizing what we have and what we make going forward.\n[1] Yet\u2026 I hope we get to the point of having live style guides for our sites.. cc @mjstahl who has been working on https://github.com/donejs/done-inspect. Thanks @imaustink! I\u2019m going to make some edits to the new page (hopefully tomorrow) and then we might rope @jamiemccue into helping with the design. \ud83d\ude0a. I made some updates:\n\nAdded some more links to community resources\nAdded icons for the external links\nLinked to DoneJS.com\u2019s Upcoming Events section\nAdded links to parts of the contribution guide\nReworded the Consultancies section\n\nStill left to do:\n\n[x] Clean up the styling of the external resources (and those images should be added to the theme)\n[ ] Get some feedback from Brian & Justin about the wording of the Consultancies section\n\n@imaustink, would you mind tackling the remaining items after the remaining search issues are closed please?. @justinbmeyer, here\u2019s an updated screenshot of the page after Brian\u2019s feedback. Brian and I agree that it could use some design love to make it feel more human, but for now, I think it\u2019s still worth merging as-is.\n\n. This is close but not quite right. The sitemap in this comment makes it a little bit more clear that the goal is to show all the recipes in the nav without having to click on Recipes. It should come out to something like this:\n\n. Sorry for the delay on this; it\u2019s been released in 2.3.32!. CI is failing because of conflicting can-types versions. can-connect and can-view-import both require steal-stache, which has been updated for can-reflect, so its dependencies require can-types@1.1, which conflicts with the can-types version of the other dependencies in this repo.\nSo, a couple questions:\n1) Is it necessary for can-connect and can-view-import to depend on steal-stache? Could it instead be a dev-dependency?\n2) Is it ok to merge this PR as-is with the build failing because the changes in the PR aren\u2019t causing the failure?\nI believe this is the same issue @bgando ran into with her PR https://github.com/canjs/canjs/pull/3370. Closing in favor of https://github.com/canjs/canjs/pull/3450. Closing this in favor of https://github.com/canjs/canjs/pull/3370. Thanks Jamie! I will merge this as part of my work on https://github.com/canjs/canjs/issues/3300. This is finished and has been deployed to https://canjs.com. Related: https://github.com/canjs/can-connect/issues/347 https://github.com/canjs/can-stache/issues/282. https://canjs.com/doc/guides/debugging.html. @phillipskevin I think this is good to go now. Of course the ultimate test will be merging this to master and checking the log to see that it used the right Sauce Labs account.. @bgando I made some improvements; the diff isn\u2019t useful, but I tried to list everything in my commit message: https://github.com/canjs/canjs/pull/3432/commits/ab9f4233d3723dbc94bf4edfe71f4854f65abe13. Thank you @andrejewski and @dpeixoto; we are working to resolve this today.\nClosing this in favor of https://github.com/donejs/developer-relations/issues/56. @phillipskevin Thanks for the quick approval \ud83d\ude1d. I\u2019m closing this because we\u2019re not going to move forward with this idea right now. We discussed it in the 2017-07-28 contributors meeting.. Thanks for the feedback @frank-dspeed! I\u2019m going to close this in favor of https://github.com/canjs/can-connect/issues/347, https://github.com/canjs/can-stache/issues/282, and https://github.com/canjs/canjs/issues/3416.. Final as discussed with Justin:\n\n. For this and https://github.com/donejs/donejs/issues/1001, I\u2019d like to understand how this is valuable. How do different types of pages show up now, e.g. our home page, a guide page, etc.?. Thanks to @MikoBrandini for fixing this in https://github.com/canjs/canjs/pull/3506. @bgando Thanks, should be all good to go now!. @bmomberger-bitovi It looks like this one still needs to be updated: https://github.com/canjs/can-simple-map/blob/master/package.json#L45-L51\nI would close this once you\u2019ve merged & released all the PRs you created.. @imaustink There\u2019s more to adding an ecosystem package than just editing the package.json; please read through everything in our Making a New Package docs.. Awesome, thank you for catching this and opening a PR @MikoBrandini!. Closing in favor of https://github.com/canjs/bit-docs-html-canjs/issues/339#issuecomment-329228111. @imaustink Thanks! That\u2019s what I get for changing the text last minute\u2026. \nJustin\u2019s proposal description grouped most but not all of the packages into these groups:\n\nObservables\nViews\nData Modeling\nDOM Utilities\nRouting\nTyped Data\nPolyfills\nJS Utilities\n\nI\u2019ve put the rest of our packages (as of minor a few days ago) into these groups. You can also see the list below in a spreadsheet.\n\nAll Packages Grouped by Purpose\n\n1. Observables\n    - Core\n        - can-define\n        - can-define/list/list\n        - can-define/map/map\n    - Infrastructure\n        - can-compute\n        - can-event\n        - can-event/async/async\n        - can-event/batch/batch\n        - can-event/lifecycle/lifecycle\n        - can-observation\n        - can-simple-map\n        - can-simple-observable\n        - can-stream\n        - can-stream-kefir\n    - Ecosystem\n        - can-define-stream\n        - can-define-stream-kefir\n        - can-kefir\n        - can-observe\n    - Legacy\n        - can-list\n        - can-map\n        - can-map-backup\n        - can-map-define\n2. Data Modeling\n    - Core\n        - can-connect\n        - can-set\n    - Ecosystem\n        - can-connect-cloneable\n        - can-connect-feathers\n        - can-connect-ndjson\n        - can-connect-signalr\n        - can-fixture\n        - can-fixture-socket\n        - can-ndjson-stream\n3. Views\n    - Core\n        - can-component\n        - can-stache\n        - can-stache-bindings\n    - Infrastructure\n        - can-stache-converters\n        - can-view-callbacks\n        - can-view-live\n        - can-view-model\n        - can-view-nodelist\n        - can-view-parser\n        - can-view-scope\n        - can-view-target\n    - Ecosystem\n        - can-element\n        - can-react-component\n        - can-view-autorender\n        - can-view-import\n        - react-view-model\n        - react-view-model/component\n        - steal-stache\n    - Legacy\n        - can-ejs\n        - can-view-href\n4. Routing\n    - Core\n        - can-route\n        - can-route-pushstate\n        - can-stache/helpers/route\n    - Infrastructure\n        - can-deparam\n        - can-param\n5. JS Utilities\n    - Infrastructure\n        - can-ajax\n        - can-assign\n        - can-globals\n        - can-make-map\n        - can-parse-uri\n        - can-test-helpers\n        - can-util\n    - Ecosystem\n        - can-zone\n        - can-zone-storage\n6. DOM Utilities\n    - Infrastructure\n        - can-attribute-encoder\n        - can-control\n        - can-dom-events\n        - can-event-dom-enter\n        - can-event-dom-radiochange\n    - Ecosystem\n        - can-jquery\n7. Data Validation\n    - Infrastructure\n        - can-validate-interface\n    - Ecosystem\n        - can-define-validate-validatejs\n        - can-validate\n        - can-validate-validatejs\n    - Legacy\n        - can-validate-legacy\n8. Typed Data\n    - Infrastructure\n        - can-cid\n        - can-construct\n        - can-namespace\n        - can-reflect\n        - can-reflect-promise\n        - can-types\n    - Ecosystem\n        - can-construct-super\n9. Polyfills\n    - Infrastructure\n        - can-symbol\n    - Ecosystem\n        - can-vdom\n\n. \nOut of curiosity, I got the number of page views for each package shown in the sidebar to determine what is most frequently viewed on the site. The numbers include all of the pages under each package, but is adjusted so nothing is double-counted (i.e. can-stache does not include can-stache-bindings in its total).\n\nHere are the packages that received at least 1000 page views this year\n\n1. can-connect: 15,980\n2. can-stache: 11,924\n3. can-component: 7,148\n4. can-define/map/map: 4,263\n5. can-define/list/list: 3,737\n4. can-stache-bindings: 3,620\n5. can-util: 3,575\n6. can-define: 3,541\n7. can-set: 3,029\n8. can-event: 2,671\n9. can-route: 2,157\n10. can-compute: 1,980\n11. can-fixture: 1,406\n12. can-control: 1,388\n13. can-stache-converters: 1,277\n\n\nMost of the packages in this list are in Core, with some notable exceptions:\n\ncan-control\ncan-event\ncan-fixture\ncan-stache-converters\ncan-util\n\nIn the new sidebar, I think it\u2019s important to make these visible by default so they\u2019re more easily accessible.. \nKeeping the above in mind, here\u2019s what we could show by default if we include the Core packages and the exceptions I noted above.\n\nCore packages + exceptions noted above\n\n1. Observables\n    - can-define\n    - can-define/list/list\n    - can-define/map/map\n    - can-event\n2. Data Modeling\n    - can-connect\n    - can-fixture\n    - can-set\n3. Views\n    - can-component\n    - can-stache\n    - can-stache-bindings\n    - can-stache-converters\n4. Routing\n    - can-route\n    - can-route-pushstate\n    - can-stache/helpers/route\n5. JS Utilities\n    - can-util\n6. DOM Utilities\n    - can-control\n\n\nI think this is decent. All of Observables, Data Modeling, and Views would be above the fold for the majority of our users (based on looking at screen resolutions in Google Analytics).. \nNote that in the above list, there isn\u2019t anything shown from Data Validation, Typed Data, or Polyfills, and there are only a couple utilities shown.\nI think what we would actually want to do is show most of the packages in those categories; I think it matters less to hide them since they\u2019re further down in the navigation.\nIn some ways, I think this could even strengthen CanJS\u2019s brand as a collection of useful libraries, because a lot of utilities would be shown and they would be on the same hierarchical level as everything else.\n\nHere\u2019s what the nav could look like by default if we included more of the utility packages\n\n1. Observables\n    - can-define\n    - can-define/list/list\n    - can-define/map/map\n    - can-event\n2. Data Modeling\n    - can-connect\n    - can-fixture\n    - can-set\n3. Views\n    - can-component\n    - can-stache\n    - can-stache-bindings\n    - can-stache-converters\n4. Routing\n    - can-route\n    - can-route-pushstate\n    - can-stache/helpers/route\n5. JS Utilities\n    - can-ajax\n    - can-assign\n    - can-globals\n    - can-make-map\n    - can-parse-uri\n    - can-test-helpers\n    - can-util\n    - can-zone\n    - can-zone-storage\n6. DOM Utilities\n    - can-attribute-encoder\n    - can-control\n    - can-dom-events\n    - can-event-dom-enter\n    - can-event-dom-radiochange\n    - can-jquery\n7. Data Validation\n    - can-define-validate-validatejs\n    - can-validate\n    - can-validate-interface\n    - can-validate-validatejs\n8. Typed Data\n    - can-cid\n    - can-construct\n    - can-construct-super\n    - can-namespace\n    - can-reflect\n    - can-reflect-promise\n    - can-types\n9. Polyfills\n    - can-symbol\n    - can-vdom\n\n. \nWhat about all the other packages?\n\nObservables still has Infrastructure, Ecosystem, and Legacy packages\nData Modeling has more Ecosystem packages\nViews has more Infrastructure, Ecosystem, and Legacy packages\nRouting has more Infrastructure packages\nData Validation has one Legacy package\n\n\nHere\u2019s all the packages with the Infrastructure/Ecosystem/Legacy ones included too\n\n1. Observables\n    - can-define\n    - can-define/list/list\n    - can-define/map/map\n    - can-event\n    - Infrastructure\n        - can-compute\n        - can-event/async/async\n        - can-event/batch/batch\n        - can-event/lifecycle/lifecycle\n        - can-observation\n        - can-simple-map\n        - can-simple-observable\n        - can-stream\n        - can-stream-kefir\n    - Ecosystem\n        - can-define-stream\n        - can-define-stream-kefir\n        - can-kefir\n        - can-observe\n    - Legacy\n        - can-list\n        - can-map\n        - can-map-backup\n        - can-map-define\n2. Data Modeling\n    - can-connect\n    - can-fixture\n    - can-set\n    - Ecosystem\n        - can-connect-cloneable\n        - can-connect-feathers\n        - can-connect-ndjson\n        - can-connect-signalr\n        - can-fixture-socket\n        - can-ndjson-stream\n3. Views\n    - can-component\n    - can-stache\n    - can-stache-bindings\n    - can-stache-converters\n    - Infrastructure\n        - can-view-callbacks\n        - can-view-live\n        - can-view-model\n        - can-view-nodelist\n        - can-view-parser\n        - can-view-scope\n        - can-view-target\n    - Ecosystem\n        - can-element\n        - can-react-component\n        - can-view-autorender\n        - can-view-import\n        - react-view-model\n        - react-view-model/component\n        - steal-stache\n    - Legacy\n        - can-ejs\n        - can-view-href\n4. Routing\n    - can-route\n    - can-route-pushstate\n    - can-stache/helpers/route\n    - Infrastructure\n        - can-deparam\n        - can-param\n5. JS Utilities\n    - can-ajax\n    - can-assign\n    - can-globals\n    - can-make-map\n    - can-parse-uri\n    - can-test-helpers\n    - can-util\n    - can-zone\n    - can-zone-storage\n6. DOM Utilities\n    - can-attribute-encoder\n    - can-control\n    - can-dom-events\n    - can-event-dom-enter\n    - can-event-dom-radiochange\n    - can-jquery\n7. Data Validation\n    - can-define-validate-validatejs\n    - can-validate\n    - can-validate-interface\n    - can-validate-validatejs\n    - Legacy\n        - can-validate-legacy\n8. Typed Data\n    - can-cid\n    - can-construct\n    - can-construct-super\n    - can-namespace\n    - can-reflect\n    - can-reflect-promise\n    - can-types\n9. Polyfills\n    - can-symbol\n    - can-vdom\n\n\nI think we have a few different options\u2026. \nAs proposed by Justin, we could have buttons that show/hide entire collections across all the groupings, similar to this screenshot (from here):\n\nHe noted that \u201c[h]aving the collection toggle at the top might be annoying because you wont be able to see what's there,\u201d which I agree with; there\u2019s less of a connection between what the user clicks and what will be updated in the nav. Those buttons would be hidden when scrolling through the list as well, unless we created some sort of sticky header for them.. \nWe could add the collection names under each grouping so they only appear if there\u2019s more to see (from here):\n\n. Here\u2019s another take on the above idea, with show/hide buttons for non-Core collections under each group:\nCollapsed:\n\nExpanded:\n\nDo we even need to give a title to the Core group? It takes valuable vertical space away, so I think it\u2019d be ok not to include it.. Another idea: move the Infrastructure items out from under the main groupings and into their own top-level sections.\nThis would leave us with Ecosystem and Legacy under each section. We could show and hide them via More/Less buttons.\n\nStructure if we moved Infrastructure packages into their own sections and grouped Ecosystem & Legacy under a \u201cMore\u201d button\n\n1. Observables\n    - can-define\n    - can-define/list/list\n    - can-define/map/map\n    - can-event\n    - More\u2026\n        - can-define-stream\n        - can-define-stream-kefir\n        - can-kefir\n        - can-observe\n        - Legacy\n            - can-list\n            - can-map\n            - can-map-backup\n            - can-map-define\n2. Data Modeling\n    - can-connect\n    - can-fixture\n    - can-set\n    - More\u2026\n        - can-connect-cloneable\n        - can-connect-feathers\n        - can-connect-ndjson\n        - can-connect-signalr\n        - can-fixture-socket\n        - can-ndjson-stream\n3. Views\n    - can-component\n    - can-stache\n    - can-stache-bindings\n    - can-stache-converters\n    - More\u2026\n        - can-element\n        - can-react-component\n        - can-view-autorender\n        - can-view-import\n        - react-view-model\n        - react-view-model/component\n        - steal-stache\n        - Legacy\n            - can-ejs\n            - can-view-href\n4. Routing\n    - can-route\n    - can-route-pushstate\n    - can-stache/helpers/route\n    - More\u2026\n        - can-deparam\n        - can-param\n5. JS Utilities\n    - can-ajax\n    - can-assign\n    - can-globals\n    - can-make-map\n    - can-parse-uri\n    - can-test-helpers\n    - can-util\n    - can-zone\n    - can-zone-storage\n6. DOM Utilities\n    - can-attribute-encoder\n    - can-control\n    - can-dom-events\n    - can-event-dom-enter\n    - can-event-dom-radiochange\n    - can-jquery\n7. Data Validation\n    - can-define-validate-validatejs\n    - can-validate\n    - can-validate-interface\n    - can-validate-validatejs\n    - More\u2026\n        - Legacy\n            - can-validate-legacy\n8. __Observables Infrastructure (or some other name)__\n    - can-compute\n    - can-event/async/async\n    - can-event/batch/batch\n    - can-event/lifecycle/lifecycle\n    - can-observation\n    - can-simple-map\n    - can-simple-observable\n    - can-stream\n    - can-stream-kefir\n9. __Views Infrastructure (or some other name)__\n    - can-view-callbacks\n    - can-view-live\n    - can-view-model\n    - can-view-nodelist\n    - can-view-parser\n    - can-view-scope\n    - can-view-target\n10. Typed Data\n    - can-cid\n    - can-construct\n    - can-construct-super\n    - can-namespace\n    - can-reflect\n    - can-reflect-promise\n    - can-types\n9. Polyfills\n    - can-symbol\n    - can-vdom\n\n. I think we could even integrate the Legacy packages with the others and just make sure each one has a deprecation warning on their main pages. If we did that, we wouldn\u2019t have to indent the additional packages differently; we could just have Show More and Show Less buttons to control what\u2019s displayed:\nCollapsed:\n\nExpanded:\n\nAlternatively, we could add \u2611 Show Legacy checkbox at the top or bottom of the API Docs section to show/hide those packages. Ember does this in their docs.\n\nHierarchy with Ecosystem and Legacy collections on the same level\n\n1. Observables\n    - can-define\n    - can-define/list/list\n    - can-define/map/map\n    - can-event\n    - More\u2026\n        - can-define-stream\n        - can-define-stream-kefir\n        - can-kefir\n        - can-list\n        - can-map\n        - can-map-backup\n        - can-map-define\n        - can-observe\n2. Data Modeling\n    - can-connect\n    - can-fixture\n    - can-set\n    - More\u2026\n        - can-connect-cloneable\n        - can-connect-feathers\n        - can-connect-ndjson\n        - can-connect-signalr\n        - can-fixture-socket\n        - can-ndjson-stream\n3. Views\n    - can-component\n    - can-stache\n    - can-stache-bindings\n    - can-stache-converters\n    - More\u2026\n        - can-ejs\n        - can-element\n        - can-react-component\n        - can-view-autorender\n        - can-view-href\n        - can-view-import\n        - react-view-model\n        - react-view-model/component\n        - steal-stache\n4. Routing\n    - can-route\n    - can-route-pushstate\n    - can-stache/helpers/route\n    - More\u2026\n        - can-deparam\n        - can-param\n5. JS Utilities\n    - can-ajax\n    - can-assign\n    - can-globals\n    - can-make-map\n    - can-parse-uri\n    - can-test-helpers\n    - can-util\n    - can-zone\n    - can-zone-storage\n6. DOM Utilities\n    - can-attribute-encoder\n    - can-control\n    - can-dom-events\n    - can-event-dom-enter\n    - can-event-dom-radiochange\n    - can-jquery\n7. Data Validation\n    - can-define-validate-validatejs\n    - can-validate\n    - can-validate-interface\n    - can-validate-validatejs\n    - More\u2026\n        - can-validate-legacy\n8. __Observables Infrastructure (or some other name)__\n    - can-compute\n    - can-event/async/async\n    - can-event/batch/batch\n    - can-event/lifecycle/lifecycle\n    - can-observation\n    - can-simple-map\n    - can-simple-observable\n    - can-stream\n    - can-stream-kefir\n9. __Views Infrastructure (or some other name)__\n    - can-view-callbacks\n    - can-view-live\n    - can-view-model\n    - can-view-nodelist\n    - can-view-parser\n    - can-view-scope\n    - can-view-target\n10. Typed Data\n    - can-cid\n    - can-construct\n    - can-construct-super\n    - can-namespace\n    - can-reflect\n    - can-reflect-promise\n    - can-types\n9. Polyfills\n    - can-symbol\n    - can-vdom\n\n. Again, these are just some ideas to get the conversation started.\nI personally most like the third to last idea (because it\u2019s clear about what you\u2019re showing/hiding) and the last idea (because it has the most simple hierarchy).. Yeah, I think breaking the Infrastructure packages into their own groupings might be more confusing, because you\u2019d look for them when expanding the section, not be able to find them, then need to scroll down to find their own grouping.. After talking with Justin, I\u2019m going to more forward with the design in this comment (show more/less buttons).\nSome other notes:\n\nNot going to make any non-Core packages visible by default.\nNot going to move the Infrastructure items out from under the main groupings.\nI\u2019ll work with a designer on some ideas for showing the collections in the sidebar, but for now I\u2019ll proceed with not showing those. We\u2019ll at least want to mark all the Legacy packages as deprecated.\nWe will collapse some groupings by default (e.g. Data Validation)\n\nAll the packages will have new parents, e.g. @parent can-observables for can-define, and a new @collection tag will be added; these changes can be made as late as possible as to not disrupt any releases. @adrifolio explored a bunch of ideas in these prototypes:\n\n\nhttp://share.bitovi.com/HC0GTL/#g=1&p=collapsible_panels_-_alpha_order&c=1 (click on More under Data Modeling)\n\nhttp://share.bitovi.com/HC0GTL/#g=1&p=collapsible_panels_-_no_alpha_order&c=1\nhttp://share.bitovi.com/HC0GTL/#g=1&p=collapsible_panels_-_collapsible_panels&c=1 (click on the indicator next to JS Utilities)\nhttp://share.bitovi.com/HC0GTL/#g=1&p=collapsible_panels_-_no_alpha_order&c=1 (collections under Routing)\n\nThis is what we settled on as the \u201cfinal\u201d design:\n\n\ud83d\ude4f Thank you to Adri and Tom for working with me on this. \ud83d\ude4f. This is complete, thanks @imaustink for releasing everything!. Implementation is finished and deployed for testing here: https://bit-docs.github.io/canjs/. I wrote a rough draft of the content but we decided not to make the groups clickable.\nHere\u2019s the commit for posterity: https://github.com/bit-docs/canjs/commit/6cb8fe017426bb277ca15c6ae50e127d5a231632. This is kinda related to https://github.com/canjs/canjs/issues/3310. I believe all of these are fixed now.. @justinbmeyer How should can-bind determine whether it should one-way bind the child/parent or two-way bind? Should can-bind look for symbols on the child/parent observables, or should the binding be initialized with something like shouldUpdateChild/shouldUpdateParent as options?. Some notes from talking with Justin:\n\n\nOne-way vs. two-way will be determined by looking at if the observables have getValue/setValue symbols\n\n\npriority will be a shortcut for this same logic: https://github.com/canjs/can-stache-bindings/blob/942ed411052e5dae7dd8092408fa6a2f404bd24f/can-stache-bindings.js#L943-L949\n\n\nsticky: \"toChild\" is similar to syncChild in this logic (child changes parent, check the parent after it\u2019s been set to see if it\u2019s changed): https://github.com/canjs/can-stache-bindings/blob/942ed411052e5dae7dd8092408fa6a2f404bd24f/can-stache-bindings.js#L659-L662\n\n\nThere shouldn\u2019t be a big difference between how a child or parent is updated; the two functions are different in can-stache-bindings, but maybe no reason why they couldn\u2019t be one function with different options?\n\n\ncycles\u2026 right now the semaphore is pretty basic in can-stache-bindings; maybe the update counts should be tracked separately for child & parent?\n\n\nThe childToParent and parentToChild options are to be used in place of canReflect.setValue calls\n\n\nDoes can-bind need to take some sort of name argument so it can name the updater functions?\n\n\nqueue: should be required, throw an error if not supplied. FYI tests are currently failing in major because of a change in can-stache-key 1.0.0-pre.13 that\u2019s breaking can-stache-bindings major; @phillipskevin is going to investigate.. Everything checked off is now in major; can-route and can-route-pushstate are in the package.json but their tests aren\u2019t being run because of https://github.com/canjs/canjs/issues/3760. It looks like the tests were added to the 4.x suite but not for 3; not sure how much we care about making sure the tests are running there too.. can-define uses can.keys as the event name for when keys are dispatched instead of __keys. - can-route-pushstate should now allow the browser to open a new tab/window when the user is holding down a modifier key (e.g. control, command, etc.)\n\n\nChanging a component element\u2019s attribute will not update the viewmodel property; see can-component\u2019s ViewModel \u201cUsing attribute values\u201d docs for more details.\n\n\nThe default ViewModel type has changed; if you were relying on it being a specific type, it\u2019s changed.\n\n\nNo need for @ when importing or exporting functions in stache.\n\n\nroute.param no longer accepts route as a property on the object passed to it [this was an undocumented API]. There are also demos in all the individual packages that need to be checked, and everything in this folder: https://github.com/canjs/canjs/tree/master/demos. This was completed with these PRs:\n\n\nhttps://github.com/canjs/canjs/pull/3799\n\nhttps://github.com/canjs/canjs/pull/3800\nhttps://github.com/canjs/canjs/pull/3803\nhttps://github.com/canjs/canjs/pull/3804\nhttps://github.com/canjs/canjs/pull/3805\nhttps://github.com/canjs/canjs/pull/3806\nhttps://github.com/canjs/canjs/pull/3807\nhttps://github.com/canjs/canjs/pull/3811\n\nhttps://github.com/canjs/canjs/pull/3812. I believe everything\u2019s updated now.. Based on our conversation during the contributors meeting, I\u2019m going to update this to explicitly use scope.root to avoid ../ in our demos.. This is a dupe of https://github.com/canjs/canjs/issues/3008. I think route/route_test.js should point to can-route/test/test. +1 on letting people edit the address bar, this came up during the usability study. A couple more things:\n\n\nWhen editing todos in the demo under Routing and the root component, the changes don\u2019t actually get saved when you come back to the todo you edited\n\nThe Observables and the service layer section isn\u2019t written. I think this is addressed with @justinbmeyer\u2019s recent changes to the home page. \ud83d\ude0a. This has not been finished.. Awesome work and thank you @roemhildtg! \ud83d\ude4c. Re-opening this because we also would like to update the individual can-* packages; hopefully the codemod from https://github.com/canjs/canjs/pull/3840 can be used again.. This has not been finished.. We\u2019ve done this as of CanJS 5.. I don\u2019t think we have any codemods for the recent stache syntax deprecations, e.g. prop=\"{prop}\" => prop:bind=\"prop\" or functions being called automatically.. This has been done in master.. What was your process for making all the const/let changes? Is this something we could easily do across the other packages too?. This was fixed in https://github.com/stealjs/stealjs/commit/bb861ac27321041f5dff3e461955f3b22d9e24bd by @matthewp, thanks!. +1 on option 1, I think we will still encourage expert users to use the individual packages.\n\nUnrelated question: I can across this blog post recently, and it explains how import { times } from 'lodash' is worse than import times from 'lodash/times' when bundling Lodash with webpack.\nIt sounds like we won\u2019t have that issue, so my question is, do we avoid that by exporting the modules like this from can/es?\njs\nexport {\n    default as connect\n} from 'can-connect/all';. A couple of things I\u2019ve seen in APIs that we should probably address:\n\n\nAn endpoint that returns different data types, e.g. one API call that returns { data: { projects: [ ... ], todos: [ ... ] } } (how to make this call, how to manage caching, how to model the data, etc.)\n\n\nThe opposite of 1, where there are different endpoints for slightly different types of data (e.g. /api/completed and /api/incomplete endpoints that return todos that have slightly different properties); how should you get all todos, how to manage caching, how to model data, etc.. This has been released! There were a few packages involved in making this happen, so let\u2019s go through them:\n\n\nFirst is can-value 1.0. can-value makes it possible to create new observables that are bound to a specific key in another observable. The example below shows can-value.bind() being used to get an observable that can get and set outer.inner.key:\n```js\nimport DefineMap from \"can-define/map/map\";\nimport value from \"can-value\";\nconst outer = new DefineMap({\n  inner: {\n    key: \"hello\"\n  }\n});\nconst keyObservable = value.bind(outer, \"inner.key\");\n```\nNow if we read keyObservable.value, we get the value at outer.inner.key:\njs\nkeyObservable.value; // is \"hello\"\nWe can also set keyObservable.value to change the value at outer.inner.key:\njs\nkeyObservable.value = \"aloha\";\n// Now outer.inner.key === \"aloha\". Next, let\u2019s talk about can-component 4.2, which makes it possible to instantiate component instances with new without rendering the instances in a template. This is useful when you:\n\nhave complex logic for switching between different components (e.g. routing)\nwant to create components without adding them to the page (e.g. testing)\n\nThe following defines a MyGreeting component and creates a my-greeting element by calling new on the component\u2019s constructor function:\n``js\nconst HelloWorld = Component.extend({\n    tag: \"hello-world\",\n    view:\n\nworld\n{{#each(items)}} {{this}} {{/each}}\n    `,\n    ViewModel: {\n        items: {}\n    }\n});\n// Create a new instance of our component\nconst componentInstance = new HelloWorld({\n// values with which to initialize the component\u2019s view model\nviewModel: {\n    items: [\"eat\"]\n},\n\n// can-stache template to replace any <content> elements in the component\u2019s view\ncontent: \"<em>{{message}}</em>\",\n\n// <can-template> strings rendered by can-stache with the scope\ntemplates: {\n    greetingTemplate: \"{{greeting}}\"\n},\n\n// scope with which to render the <content> and templates\nscope: {\n    greeting: \"Hello\",\n    message: \"friend\"\n}\n\n});\nmyGreetingInstance.element; // is like Hello friend  eat \nmyGreetingInstance.viewModel; // is HelloWorld.ViewModel{items: [\"eat\"]}\n```\nChanging the component\u2019s view model will cause its element and any bindings to be updated:\n```js\nmyGreetingInstance.viewModel.items.push(\"sleep\");\nmyGreetingInstance.element; // is like Hello friend  eat sleep \n``. Now let\u2019s tie those new features ofcan-componentandcan-value` together.\nThe viewModel option accepts values from can-value, which means you can one-way or two-way bind values from another view model to the component\u2019s view model. For example:\n```js\nimport Component from \"can-component\";\nimport DefineMap from \"can-define/map/map\";\nimport value from \"can-value\";\nconst appVM = new DefineMap({\n  association: \"friend\"\n});\nconst MyGreeting = Component.extend({\n  tag: \"my-greeting\",\n  view: \"{{greeting}} {{subject}}\",\n  ViewModel: {\n    greeting: \"string\",\n    subject: \"string\"\n  }\n});\nconst myGreetingInstance = new MyGreeting({\n  viewModel: {\n    greeting: \"Hello\",\n    subject: value.bind(appVM, \"association\")\n  }\n});\nmyGreetingInstance.element; // is Hello friend\nmyGreetingInstance.viewModel; // is MyGreeting.ViewModel{subject: \"friend\"}\n```\nThe way the component is instantiated above is similar to this example below, assuming it\u2019s rendered by can-stache with appVM as the current scope:\nhtml\n<my-greeting greeting:raw=\"Hello\" subject:bind=\"association\"></my-greeting>\ncan-value\u2019s bind, from, and to methods can be used to can recreate two-way, one-way parent-to-child, and one-way child-to-parent bindings, respectively.\n```js\nconst appVM = new DefineMap({\n  family: {\n    first: \"Milo\",\n    last: \"Flanders\"\n  }\n});\nconst NameComponent = Component.extend({\n  tag: \"name-component\",\n  view: \"{{fullName}}\",\n  ViewModel: {\n    givenName: \"string\",\n    familyName: \"string\",\n    get fullName() {\n      return this.givenName + \" \" + this.familyName;\n    }\n  }\n});\nconst componentInstance = new NameComponent({\n  viewModel: {\n    givenName: value.from(appVM, \"family.first\"),\n    familyName: value.bind(appVM, \"family.last\"),\n    fullName: value.to(appVM, \"family.full\"),\n  }\n});\n```\nThe way the component is instantiated above is similar to this example below, assuming it\u2019s rendered by can-stache with appVM as the current scope:\n```html\n<my-greeting\n  givenName:from=\"family.first\"\n  familyName:bind=\"family.last\"\n  fullName:to=\"family.full\"\n\n\n```\n\nThis will result in an appVM with the following data:\njs\n{\n  family: {\n    first: \"Milo\",\n    full: \"Milo Flanders\",\n    last: \"Flanders\"\n  }\n}\nChanging the component\u2019s view model will cause its element and any bindings to be updated:\n```js\ncomponentInstance.viewModel.familyName = \"Smith\";\ncomponentInstance.element; // is Milo Smith\nappVM.family.last; // is \"Smith\"\n```\nIf you voted for this proposal and the above doesn\u2019t excite you, let me know how I can explain this better because it should BLOW YOUR MIND.. For the icing on this cake, I\u2019d like to show you what\u2019s new in can-stache 4.9. This release makes it possible to render component instances in a template with the \u201cunescaped\u201d (triple-curly) tags:\n```js\nimport Component from \"can-component\";\nimport stache from \"can-stache\";\nconst MyGreeting = Component.extend({\n  tag: \"my-greeting\",\n  view: \"Hello {{subject}}\",\n  ViewModel: {\n    subject: \"string\"\n  }\n});\nconst myGreetingInstance = new MyGreeting({\n  viewModel: {\n    subject: \"friend\"\n  }\n});\nconst template = stache(\"{{{componentInstance}}}\");\nconst fragment = template({\n  componentInstance: myGreetingInstance\n});\nfragment; //-> Hello friend\n```\nmyGreetingInstance is just a variable in an example above, but this means you can return a component instance from a property in your view model and have that rendered in your template!. Creating new component instances in your view model and rendering them with can-stache means it\u2019s possible to do something like what was described in the original proposal:\nhttps://gist.github.com/chasenlehara/3e20479e3cf0fa53510e00bd7062c535#file-route-example-js-L34\nHurrah! \ud83c\udf89\nOf course, there are more details to be shown in the upcoming routing and testing guides, but hopefully this gives you enough info to start using these new features in your application today. \ud83c\udfc1. All of this has been released in can@4.3.0.. @phillipskevin We use can.data in the playlist editor, so we either need to fix this in 4.0 or I can show how to use can.domDataState in the guide instead.. I think same issue is fine.\nFor 4.0, I don\u2019t think the same solution will work because some of the module versions will conflict, so I\u2019m going to change can-util to namespace each module independently, then import what\u2019s needed into the main can build.. can-migrate issue: https://github.com/canjs/can-migrate/issues/98. Something that was brought up on the forums: https://forums.donejs.com/t/more-canjs-documentation-remarks/893\nIn the description or first paragraph of a module\u2019s docs, we should link to higher-level info about how that module fits in with the rest of the CanJS ecosystem. For example, the can-define/map/ docs should link to the Key-Value Observables section of the Technology Overview page.. I\u2019m closing this issue because we\u2019ve essentially done this. We use CodePen for the examples on canjs.com now and our guides are being updated to show import statements.\nI\u2019ve filed issues for the guides that still need to be updated: https://github.com/canjs/canjs/issues?utf8=\u2713&q=is%3Aissue+is%3Aopen+%22update+*+guide+for+CanJS+5%22+. Ting.com uses CanJS, and their About page will eventually use this DoneJS plugin from Tucows: https://github.com/tucows/donejs-carousel-plugin. People frequently search for can js, which also returns lackluster sitelinks (all but the migration link are for v2):\n. Hi @r0m4n, I know that you\u2019re using the can-connect/can/model/ module in the JSFiddle; in your actual project, are you using that or can-model?\nI wouldn\u2019t expect the can-model package to have this issue, but it does look like one of the differences between it and can-connect/can/model/ is that the latter requires an instance be passed to it.. Thanks for the review @phillipskevin, I think this is good to go now.. I think this can be closed now. \ud83d\ude0a https://canjs.com/doc/guides/setup.html#IE11Support. I think this can be closed now. \ud83d\ude0a https://canjs.com/doc/guides/setup.html#IE11Support. This isn\u2019t something we have to address as part of tackling this proposal, but where we\u2019re already updating code\u2026 @code-read brings up a good point that more distinctive variable & property names can make it easier to understand code examples: https://forums.donejs.com/t/generic-property-names-confuse-the-beginner/908. Hi @zhanghengxin, CanJS 2 supports IE8+ and CanJS 3 supports IE9+ (with a Promise polyfill).\nYou can find the CanJS 2 docs here: https://v2.canjs.com/. We should make sure everything\u2019s assigned to can-namespace; I know can-assign isn\u2019t, and there might be others.. Yes, that section & JS Bin needs to be updated to use the new can-dom-events addJQueryEvents() helper.. What I had in mind was making sure require(\"can-component\") or import \"can-component\" worked correctly with webpack. This would help us avoid simple mistakes like steal-specific syntax or having the wrong main in package.json.\nI\u2019m not exactly sure what a test for this should look like\u2026 maybe it would require building a bundle with webpack? Maybe this is already covered by the tests @matthewp added for https://github.com/canjs/canjs/issues/4200 or https://github.com/canjs/canjs/issues/4133?. @matthewp I reached out to him over email. \ud83d\ude0a. Merging this despite one of the builds failing due to a timeout issue. One of the builds fully passed (with tests running in all the Sauce Labs browsers), so I don\u2019t think there\u2019s an issue with the code.. I would run all the PNGs through something like https://imageoptim.com/mac\nThat usually shaves anywhere from 25% to 50% off the image size. \ud83d\ude03. Has everything been released?. Thanks @CODE-REaD!. Can the initialization that currently happens when can-route-pushstate is included wait to be done until start() is called? https://github.com/canjs/can-route-pushstate/blob/c5e7a47bcf400ecaf90f372ac2ff6751c1a58094/can-route-pushstate.js#L309\nOr at least maybe this logic can wait? https://github.com/canjs/can-route-pushstate/blob/c5e7a47bcf400ecaf90f372ac2ff6751c1a58094/can-route-pushstate.js#L322. @frank-dspeed I\u2019m going to close this issue because I don\u2019t think the core team will do anything with it right now; we\u2019ll continue to invest in making steal better, e.g. the improvements we\u2019ve made with native module loading.\nI love your enthusiasm for building new tools\u2014please publish! I think this is an interesting approach, just not one that the core team is going to be working on.. can-view-import works with webpack as well, so it\u2019s not specific to steal. I don\u2019t think it needs to be renamed.. @MarcGodard Would you mind running npm ls steal in your project and pasting the results here please?. I left a comment on another issue about getting started on this: https://github.com/canjs/canjs/issues/4623#issuecomment-450207645. Thanks @manaswinidas!\nWe\u2019ve already upgraded some of the other recipes, so you can use those for reference:\n\nhttps://canjs.com/doc/guides/recipes/modals.html\nhttps://canjs.com/doc/guides/recipes/search-list-details.html\nhttps://canjs.com/doc/guides/recipes/signup-simple.html\nhttps://canjs.com/doc/guides/recipes/text-editor.html\nhttps://canjs.com/doc/guides/recipes/tinder-carousel.html\nhttps://canjs.com/doc/guides/recipes/video-player.html\n\nSome of my PRs for upgrading the other recipes can be used for reference:\n\nhttps://github.com/canjs/canjs/pull/4293\nhttps://github.com/canjs/canjs/pull/4605\nhttps://github.com/canjs/canjs/pull/4392\n\nThis is a big task, so don\u2019t be afraid to ask questions here or message us on Gitter: https://gitter.im/canjs/canjs \ud83d\ude0a. I left a comment on another issue about getting started on this: https://github.com/canjs/canjs/issues/4623#issuecomment-450207645. That notice says:\n\nImportant EOL Notice: As of Thursday, Jan. 3, 2019, the weather.yahooapis.com and query.yahooapis.com for Yahoo Weather API will be retired. \nTo continue using our free Yahoo Weather APIs, use https://weather-ydn-yql.media.yahoo.com/forecastrss. Contact yahoo-weather-ydn-api@oath.com for credentials to onboard to this free Yahoo Weather API service.\n\nI emailed them to see if we can get free credentials.. I never received a response from them.. Thanks for filing this issue @Lighttree. \ud83d\ude0a\nThis is a little bit related to Add a best practices guide.. Yes, it should be similar to what\u2019s in the webpack section:\n\n. Reason bindings for CanJS would be cool.\nSince this issue doesn\u2019t mention a problem or an enhancement that the core team would take on, I\u2019m going to close this issue.\nIf you do pursue this project, please let us know!. I\u2019m not 100% sure what you\u2019re proposing here. We\u2019d happily accept a PR with additional instructions for using CanJS with Rollup. If there\u2019s something wrong with our current ES builds, please let us know.\nPlease feel free to reopen this issue if I\u2019m missing something that\u2019s actionable for the core team.. I\u2019m sorry @frank-dspeed, I did not understand that this was something that you were working on.. @frank-dspeed Could you please outline what this PR accomplishes?. I don\u2019t think we\u2019ll start using a different GitHub organization for different types of projects. One reason why: I don\u2019t think it\u2019s a valuable way of organizing projects because that would only account for our repos, not third-party components.\nWe have a proposal open for creating a dedicated resource, but it hasn\u2019t gained much traction in surveys, so it\u2019s unlikely we\u2018ll work on it anytime soon: https://github.com/donejs/donejs/issues/682\nSomeone else is obviously welcome to start their own list. \ud83d\ude0a. I\u2019m closing this now that 5.22.0 is published and everything looks ok.. This was for ZenHub, but GitHub\u2019s project feature should work fine.\nClosing in favor of https://github.com/orgs/canjs/projects/1. Closing for https://github.com/canjs/canjs/pull/4752. \u201cLets\u201d => \u201cLet\u2019s\u201d. This is listed twice.. \u201cof all of of the\u201d => \u201cof all the\u201d. \u201cthe that\u201d \u2026?. I\u2019ve filed an issue: https://github.com/canjs/canjs/issues/2846. Hey @justinbmeyer, a few comments on using the correct punctuation marks:\n- It\u2019s pretty easy to type the correct marks (although I don\u2019t expect anyone else to care enough to change their habits).\n- The correct marks are easier to read and can help make text more understandable.\n- I\u2019ve definitely seen issues with software automatically changing \u201cdumb\u201d quotes to \u201csmart\u201d quotes (ugh presentation software), so I wouldn\u2019t really recommend automated replacement. Using the correct marks can actually fix some issues though, like in this PR:\n\n\nAgain, I\u2019m not really expecting anyone else to care, but as I go through the docs, I\u2019m going to clean up our spelling, grammar, typography, etc. It doesn\u2019t take much time to get the little details right. \ud83d\ude0a. I\u2019ll add the description. I thought the outline looked out of place because it\u2019s summarized in the text below.. Yeah, this is not required right now, but I think we should typically version our install commands so new and old guides install the correct version.. \u201csource repo\u201d isn\u2019t defined before this section, so I would either define it in the intro (e.g. \u2018In this guide, we\u2019ll use the term \u201csource repo\u201d to refer to the repository of the package that you want to add to the ecosystem collection\u2019) or make it more clear here (e.g. \u2026\u2018folder in your package\u2019s repository and\u2019\u2026).. I\u2019m a little confused about this because the instructions above say you should create a docs folder but this puts it in the root.. You can make this consistent with the other list items by replacing : The project with : is the project. Maybe \u201cAdding Packages to CanJS.com\u201d? I\u2019m weary of putting \u201cecosystem\u201d in the name because it applies to all of the collections.. \u201cthan\u201d => \u201cthen\u201d. \u201ctest main file\u201d => \u201cmain test file\u201d? Here and in the sentence below.. \u201cif source\u201d => \u201cif the source\u201d. This wording is a little hard to parse: \u201cto test the documentation and test process locally\u201d\nSuggestion: \u201cto build the documentation and run the tests locally\u201d\nAlso, consider \u201cin\u201d instead of \u201cagainst\u201d.. This change is wrong; \u201cwebpack\u201d is correct.. It seems odd that this is a list but there\u2019s only one list item. I would include this sentence with the paragraph above to make it flow more naturally.\nAlso, it\u2019d be nice to mention which browsers this applies to (I know at least IE9, not sure which versions of others).. Should this be String.prototype.trim.call(el.val())?. Also, I wonder if any protections for null or undefined need to be added\u2026 String.prototype.trim.call will throw if it\u2019s given either of those values.. I think the arguments are ev, drop, drag so drag is the third argument. Am I reading the code incorrectly?. This is correct, and we could probably make it better by saying \u201c\u2026dragged so you can know which video is being dropped when a drop happens.\u201d. The comma seems unnecessary.. is should be used or has been. I think the optimism of the original text is more encouraging. Maybe Congrats! You now have your very own YouTube Playlist Editor.. This is shown when you hover over an item in the navigation, so I would add a little bit more text here about what\u2019s in this section.. It\u2019d be nice to have this inline CSS taken out and put in the style sheet.. Just FYI you didn\u2019t remove the inline styles. If you added them to the theme, then they\u2019ll be redundant, otherwise we can merge this as-is.. This will need to be flipped back to true. ^0.6.0 now. I think this should be 4. Right now I\u2019m seeing some weird behavior when switching between pages:\n\n. I think we\u2019ll want to keep all of the design stuff for each project in one folder, so I don\u2019t think we need a separate Project Design Resources folder.. Why was this changed?. Why was this changed?. I\u2019d leave the slug alone so we don\u2019t break old links to this page.. Out of curiosity, why was this added?. This will need to be changed back.. I would like to better understand what changed that required this to be included.\n[FYI, as of npm 5, any install will --save by default.]. I could not reproduce the siteConfig.finder is not a function issue so I removed it.. Filed an issue to actually document the transforms: https://github.com/canjs/can-migrate-codemods/issues/20. It seems odd to me that users install can-migrate-codemods but the actual CLI command is can-migrate; seems like we\u2019d want to rename the repo and npm package. This is pretty easy to do but I didn\u2019t want to act unilaterally on a kinda big thing, so let me know what you think.\ncc @justinbmeyer. @bgando As we talked about in standup, please update these docs to reference can-migrate instead of can-migrate-codemods.\nI created an issue for updating the CLI\u2019s repo (I already renamed it \ud83d\ude0a): https://github.com/canjs/can-migrate/issues/21. I made the username variables public so I could log them (the access keys are still encrypted).\nYou can see in the job log that it used the correct user: https://api.travis-ci.org/jobs/274416622/log.txt?deansi=true. I wonder if we could get away with installing bower globally if the command was something like ./node_modules/.bin/bower install\nTheoretically, same thing with grunt-cli since it\u2019s listed in devDependencies. Same, I don\u2019t really care, the only advantage I see is that both of those would be tied to what\u2019s in the package.json instead of the latest version of those packages.. Switching from requiring can-stache-converters to just can-stache-bindings was the only change here.. Yeah, which is why it was working, but I couldn\u2019t see a reason why converters needed to be required\u2026. I think it works but generates warnings if selected is undefined, so I thought this would be a better way of writing the same thing.. Switching to base-map because the can-fixture delay wasn\u2019t perceivable; I think because the data was being fetched from local-storage before the fixture would resolve.. I don\u2019t think leakScope: true was necessary here.. As far as I can tell, the docs say that return values are ignored if a setter has two arguments, so I don\u2019t think this ever worked.. Avoiding can-stache\u2019s \u201cunable to find key\u201d\u00a0warning. Also avoiding can-stache\u2019s \u201cunable to find key\u201d\u00a0warning by making this value not undefined.. I don\u2019t know if it\u2019s a bug or not, but scope.index can\u2019t be used because it\u2019ll be the last value after going through the entire list.. I\u2019m not sure how leakScope is supposed to work in 4.0, but it was really buggy in this demo.. This demo is used in can-component\u2019s ViewModel docs to show how you can change a component\u2019s element attributes to update the view model, but I don\u2019t think this is supported in 4.0, so the demo now shows using can-view-model to get the component\u2019s view model and set a property.. This should still be included.. The mixture of import and var stand out; any reason not to use const and let in this document?. Great that we\u2019ll be able to take these out. :D. This indentation is incorrect.. New lines like this are significant in our guides because of the line highlighting we use to show what was added.. I think this should be an import statement, but babel wasn\u2019t loading for me when I tested the site locally, so I didn\u2019t want to mess with it.. That was sloppy on my part, I\u2019ve restored how this guide was before.. This demo uses innerHTML instead of having a count property on a view-model and rendering it with {{count}}. That stuck out to me and I wonder if it\u2019ll be jarring to other people too.. I don\u2019t think anyone would be confused if those strings weren\u2019t wrapped in quotation marks, but for the sake of being consistent with can-reflect-promise, I\u2019ve reverted back to what you had.. Yeah, that makes sense. I\u2019ve updated the example to use {{count}}; it\u2019s about the same amount of code and I think it makes it more consistent with the other examples.. Using $.trigger for dispatching special events through jQuery doesn\u2019t work, I think unless we register them with can-dom-events. I thought it\u2019d be fine to show can-dom-events, but please let me know if there\u2019s a different way we want to teach this.. +1 on removing this; not sure if @justinbmeyer intentionally left those in because they\u2019re useful for other people going through the guide.. Yeah good catch, I\u2019ll update these.. IE11 doesn\u2019t support arrow functions; I can be persuaded that the code in our guides doesn\u2019t have to support IE11, but it\u2019d take longer for me to update the code and make sure the highlighting is correct, so I\u2019m not going to make this change now.. Maybe, I\u2019ll re-indent everything so it\u2019s consistent.. It looks like this particular line was fine but I did fix other indentation issues.. For the sake of time (not updating the highlighting for all the examples), I\u2019ve changed these to console.info(\"Search results:\", response.result.items). Maybe we should say IE 11 with polyfills? Related issue: https://github.com/canjs/canjs/issues/4098. It\u2019s not included in the build or site right now, so I\u2019m going to remove it and see if it can be added back in with https://github.com/canjs/canjs/issues/4142. Yup, as mentioned in the description, we\u2019ll need to update the demos with top/vm when 4.3 is released: https://github.com/canjs/canjs/issues/4157. Are these image paths right? Could they be ../images/devtools/?. You don\u2019t need to change this, but in the future I would make links to a different section on the page just plain Markdown links, e.g. [Setup Debugging](#SetupDebugging). Did you try using class=\"bit-docs-screenshot\" on these? Not sure if they\u2019d make the images look better or not. \ud83d\ude03. Where possible, I\u2019d link to methods in our docs, e.g. the [can-queues.logStack] method of [can-queues]. And for this particular section, it might be good to embed or link to https://www.youtube.com/watch?v=L0hR5ic_FvE&t=1s. I personally would, just because I find it nicer to have links everywhere and it makes it easier for people to start reading a particular section without having to go through all the sections. \u00af_(\u30c4)_/\u00af. Constructor functions are usually capitalized, which is why I changed it from selectVM to SelectViewModel.\nAlso, we don\u2019t show this everywhere, but if you provide a string as the first argument to .extend(), it\u2019ll have a nicer name in the debugger. https://canjs.com/doc/can-define/map/map.extend.html. Thanks @CODE-REaD! I\u2019ll make sure the highlighting looks ok with this change.. Finished CodePen: https://codepen.io/chasenlehara/pen/pZOpRE. Starting CodePen: https://codepen.io/chasenlehara/pen/djqJMj. I removed this section because you don\u2019t have access to can or viewModel from CodePen\u2019s console. Other than explicitly assigning window.viewModel = viewModel in the module, it\u2019d be nice to have another way of verifying this step.. Updated to show that, thanks @justinbmeyer!. \ud83d\udc4d All the code files should be indented with tabs now.. The VM can be a can-map, or can-observe, or\u2026\nWas there something confusing about not mentioning the type here?. This needs less indentation.. Same here.. One more spot :). I made a small edit to say \u201ctypically.\u201d\u00a0Thanks!. I think we should still use CodePen to embed the starter and finished code examples, like we do in this guide: https://canjs.com/doc/guides/recipes/signup-simple.html. \u201ccodepen\u201d -> \u201cCodePen\u201d everywhere. This should match the \u201cSTART THIS TUTORIAL BY CLICKING\u201d text shown in this guide: http://localhost:8080/doc/guides/recipes/signup-simple.html. I think these will need to be changed to import { Component } from \"//unpkg.com/can@5/core.mjs\";. I would change this and {{entities rootEntity}} to the call syntax ({{entities(rootEntity}}).. Anything with can. needs to be updated.. Let\u2019s change this to show #for. coonectedCallback -> connectedCallback. Let\u2019s use template literals to contain strings with quotes:\njs\nview: `<canvas this:to=\"canvasElement\" id=\"analog\" width=\"255\" height=\"255\"></canvas>`,\nThere\u2019s a few places where this\u2018ll need to be changed.. Indentation. I think this should be @highlight 3-5,31-58,only. This code assumes there\u2019s a canvas variable, but there isn\u2019t. I think we should probably use this.canvas everywhere.. I think the highlighting is off here.. Indentation. The finished CodePen doesn\u2019t have this. I think it\u2019s probably better to include this and not use CodePen\u2019s JS settings (so that it\u2019s clearer how it works), but either way, we should be consistent.. This starter CodePen has the form in the HTML tab. I think we should probably remove it and start it fresh with just the Stripe script.. I think these need to be:\njs\nimport { Component } from \"//unpkg.com/can@5/core.mjs\";. I\u2019d ident this.. The placeholder attribute is missing an end quote (here and other places).\nI caught this because the syntax highlighting was off in the rendered page.. I think this one also needs to highlight the VM props that are added.. We should probably move this into an html file, include the script that the starter bin has, and then only highlight the first line.. The indentation in these lines seems off.. Also, I don\u2019t think this section works. I think the reader should be able to have the root folder rendered, but rootEntity is never used in the template and there\u2019s no this.children.. I don\u2019t think the code works after this section because rootEntity isn\u2019t used where.. Indentation. This doesn\u2019t look right. Did you run through the guide to make sure all the steps were right / worked?. Changing the HTML is still required to get started.\nI\u2019d run through the guide again to make sure all the steps can be followed to achieve the right results.. codepen -> CodePen. Indentation. This should be Object.assign(this.canvas, {\nGoing through the guide from the starter CodePen and copying the highlighted code in each step should reveal any issues like this.. I\u2019ve not finished the sections starting here.. ",
    "asavoy": "If the result is converted to a String (i.e. the result is \"0\" - zero in a string), then zero will be rendered.\n. @justinbmeyer I've got the remove/add events working and covered by a test. But would like your help on the last failing test on pushing to a sorted list: {{#each}} renders the pushed item twice at the end of the list, instead of once in the sorted position. I can't figure out a way to resolve this without rewriting rewriting the push function completely, and changing the order of events triggered there.\n. @justinbmeyer I did get a little bit closer with the assumption that push() and unshift() should insert items into their sorted position. \nAt this point it appears to work, except for one part: that sortedList.push(item) isn't telling {{#each}} to move the new item into the sorted position. For that it looks like view.live.list() needs to support the 'move' event. I haven't been able to figure out how that should work, so would like to get your opinion on whether that is workable, or perhaps an overhaul is really necessary. Certainly were a few bugs in there :(\n. I tried that first, it required rewriting more of the sort module and broke more tests. It looked like it was closer to the original intent of the plugin to push the item onto the end, and then move it into the sorted position. Or so I had interpreted the _changes() function :) \n\nOn 28 Jun 2014, at 3:19 am, Justin Meyer notifications@github.com wrote:\nWhy would list need to support the 'move' event? Shouldn't an add event for the newly added item be enough?\n\u2014\nReply to this email directly or view it on GitHub.\n. I managed to get sort working with the 'add' event, instead of going down the 'move' event approach - much easier.\n\nI had to change 2 tests, but I'm pretty sure they were incorrect in the first place, please see the commit messages. This is the reason the build fails: the compatibility test run is still executing these incorrect tests. \n. Would like to get an opinion from someone on the CanJS team about the breaking \"compatibility\" test cases - I'm pretty sure they were incorrect in the first place.\nI think a sort plugin is important for anything beyond simple listing of data. For example, select lists, tables and data grids need to be able to control the ordering of list members.\n. I discovered AngularJS had the same issue so inspired by that solution (late-binding attributes),  I tried a similar workaround with can.view.attr(), see this fixed fiddle. This means one can write <circle late:cx=\"{{radius}}\" ...> without raising the attribute error.\nI didn't have to do much more than copy the attribute value, since I guess can.view.attr is initialised late enough. It appears to maintain data binding, and gets cleaned up if the element is removed. \nI think CanJS might want to consider including this workaround into the framework as AngularJS has done. It fixes binding to SVG attributes, but also other problematic attributes such as <img src=\"...\"> (which would otherwise try a request to __!!__).\n. @justinbmeyer Can't tell, stache raises a Parse Error on SVG content. I'll create an issue for it.\n. @justinbmeyer Yep, single char attributes cause the parser error. Can only think of SVG elements that need it, and perhaps custom components.\n. +1 - I believe I'm running into this.\n. The failures were due to different handling in Dojo and YUI when triggering events with extra parameters. I scoped the test to jQuery only.\n. I'm not Dojo expert but when I looked into it, it appears that Dojo handles extra args, by merging the Event object with the extra event args. So can.trigger('special', ['one', 'two']) will provide args in Dojo as event[0] == 'one' and so on - whereas jQuery doesn't do this, it provides it as extra arguments to the event handler. So the test can't cover both cases, but it certainly works in jQuery.\nFor YUI, when I checked that, it appears that extra arguments to trigger cause it to not bubble, so the event won't trigger the event handler.\nI guess the ultimate question is, in the case of differing framework implementations underlying CanJS' wrapper functions (in this case can.trigger()), which path should CanJS follow:\na) shim them all to behave like jQuery, or some other standard\nb) let the arguments be interpreted and processed the way the underlying framework chooses to? \nIt feels like, e.g. with can.$ that CanJS chooses b), and that's why the test only covers jQuery.\n. Closing; I see the change has already been made on master.\n. Regarding 3.2.3 - can-event and extra args, I have a PR on fixing that: https://github.com/bitovi/canjs/pull/1199\n. @matthewp Thanks for pointing that out, I had it in my mind that this was valid usage since I found some old code that has since broke, but it's not described as such in the docs.\n. @matthewp Yes, though the patch is against master.\n. Poke... I rebased this branch to latest master.\n. @matthewp \nI rebased onto minor, but GitHub won't let me change the target branch for this PR to minor, and so the commits on minor are showing up here.\nI'm not understanding your can.Deferred comment. And steal.normalize(name, loader) seems to do something quite different to steal.joinURIs(base, href), so I'm not sure I understand that either?\n. Moved to #1329\n. @jandjorgensen The issue referenced doesn't seem related? I, for one, think the SO answer is a very useful explanation, and would like to see it in the docs.\n. And wouldn't this be moving to a less complete solution because you wouldn't be able to escape [?\n. +1 \nIs this the same as #1357?\n. More recently, there is https://www.youtube.com/watch?v=2FtLRDX3yIc&list=PLV271uUAM_m44eJzV4c8ENbtZ2vORpQTl&index=5 and the corresponding code in https://github.com/alexisabril/frontporchio .\n. Might be similar to #1151 and #1142 .\n. @justinbmeyer I thought CanJS uses SemVer? Or in 2.2 will it always use Stache, even for Mustache templates?\n. @justinbmeyer While I reported the error here, I should have described the use case along with it.\nI've written a view model for a can.Component's scope, with an async getter and a getter dependent on it. I'm using this.attr('myAsyncProperty'); to not just get the value, but also to setup the binding. Everything works when the component is rendered to the DOM, but I'd like to also write DOM-less unit tests for the view model and that is where this error comes up.\nHere's a similar example http://jsbin.com/cunane/8/edit?js,console where the async getter is resolved asynchronously (I agree resolving synchronously isn't useful, so disregard that).\nI agree that the async getter should return undefined, at least until it gets resolved.\nIn response to your proposals:\nA. Since discovering async getters, my team and I have agreed that it's really useful for simplifying code where AJAX requests are involved. Docs for it would have helped us find this earlier.\nB. I've had a crack at fixing this already, by eagerly binding an empty handler for any async getters, which I think is what you're describing here. I don't have a lot of confidence with Map/define/compute under the hood, so I'll need someone to review it. I'll push it up soon.\nC. I don't think there should be a warning because I feel that one should be able to have getters dependent on async getters as done in http://jsbin.com/cunane/8/edit?js,console\n. +1 This looks awesome\n. +1 I'd like this.\n. +1 I've run into this as well\n. This would be the stache equivalent to this mustache issue: https://github.com/bitovi/canjs/issues/1109\n. ",
    "DesignByOnyx": "Hey @alexisabril - I have fixed Stache already (haven't pushed yet) and know where to fix this one. Do you want me to go ahead and do it?\n. readonly attribute maps to readOnly property - could be a start...\n. There is a truthy check here: https://github.com/bitovi/canjs/blob/master/view/stache/mustache_core.js#L535\nWe need to make sure this wouldn't be a breaking change as some authors might return 0 with the intent of give me an empty string.\n. If you set the selectedIndex to -1 it will clear out the element, even in Firefox:\nhttp://jsfiddle.net/3xyxpcqo/\nIt seems that all browsers report the value as the first option in the list by default, and then an empty string when the selected index is set to -1.\n. This is needed first: https://github.com/canjs/canjs/pull/2063\n. The same should probably also be applied to STYLE tags. Please advise.\n. @justinbmeyer - I think the parser handles that properly already. I haven't tested it, but this comment in the tokenizer makes me think that it has been accounted for.\nThe reason this bug surfaced for me is because the react integration I am building uses a <script> tag, and internally react is using innerHTML to set the contents for the tag. This was not a problem until the contents contained some JSON data that contained a string like this: \"Foo<Bar\". Adding spaces around the < fixed it, but unfortunately this is a trademarked name used by our client and the spaces cannot be there.\n. @daffl - this fixes an issue on our current project and it would be greatly appreciated to get this in. Please let me know if there are any hangups.\n. There are no tests running for vdom at the moment - so I didn't write one. I can verify that this works on a client project. If you were to set up the testing structure for vdom, I would write a test to cover this. I just don't have the time or authority to set it up and determine whether these tests should run in a worker or not and all the discussion therein.\n. Interesting. then can you suggest where I might be able to test this? The test would look something like this:\njs\ntest(\"Script contents are not parsed in vdom\", function () {\n    var script = document.createElement(\"script\");\n    var code = \"var markup = '<Foo';\";\n    try {\n        script.innerHTML = code;\n        assert.equal(script.innerHTML, code, \"Script content set correctly.\");\n    } catch () {\n        assert.ok(false, \"Failed to set script contents\");\n    }\n});\n. That's a longer conversation. All I am trying to fix the the fact that special treatment was already being given to the anchor element - and that treatment was broken. If we really want to replicate html then we stop auto-closing tags altogether - but that's likely to break implementations.\nI am needing this on a current project and have tested this change on that project (in addition to the unit tests written in this PR)\n. I'll do my best to keep this short. Most of my concerns are API related.\n\nSeparation of props and state (VM) is a deal-breaker IMO. How it is solved doesn't matter to me, but the lack of separation has caused us problems. Reach out to me on Slack for real world examples.\n@justinbmeyer gave examples earlier which can be boiled down to \"RVM provides observable state - so forget about setState, forceUpdate, and shouldComponentUpdate\". This was my vision for can-react and something I fully support (and the easiest to promote).\nI personally like the class extend syntax. I think we can @connect our cake and extend it too without much maintenance or marketing overhead. I also think render props (re: VMComonent) are too advanced and cutting edge to be marketed effectively at this point. (for the record, I think render props are really awesome and solve the \"expanding API\" problem in an amazing way).\n. \n",
    "BigZolo": "I wasn't aware of this 'all stache' requirement. Checking my code and convert all mustache to stache.\n. It was a user error, I have embedded components and tried to use the helper in the wrong context.\nSorry about the false alarm.\n. ",
    "dylanrtt": "I have already been using * with define in lists.\nExample:\n``` js\nvar List = can.List.extend({\n  define: {\n    '*': {\n      type: 'number'\n    }\n  }\n});\nvar list = new List(['5', '3', '7']);\nconsole.log(list.attr());\n// [5, 3, 7]\n```\nhttp://jsbin.com/cepejemoci/edit?html,js,console\nWas this not supposed to work or could there be binding issues?\n. I have been thinking a lot lately about how a higher level API for attributes might work and what I have ultimately come up with is practically a copy of can.Component with a few tweaks:\nhttps://gist.github.com/dylanrtt/42f56d374080cad61c16#file-demo-html\nI basically copied a bunch of code from can.Component, removed the parts about attaching a child scope/template and added a little bit of configuration to determine which attributes get mapped in.\nI had several design goals in mind:\n- Easily map additional helper/option attributes to a fully featured can.Map (prototype, define, etc.) which also increases testability\n- Fully featured can.Control (templated event handlers)\n- Listen to attribute changes without having to monkey with a single 'attributes' event where you check which attribute changed\n- Easily listen to and change scope properties without worrying about memory leaks or passing computes to a separate can.Control definition\n- Define which attributes are mapped to avoid standard standard HTML attributes like 'type' and 'class'\nMany attributes will not need all that functionality, but for the ones that do, it's nice to have a better API. There is currently a lot of copy pasta going on in my example so if you guys agree with this type of design, some substantial refactoring may have to take place to make the can.Component code more reusable.\n. I would probably be fine with disallowing computes on maps. Computes have been manually applied to models a lot in the app I work on (some were done before the define plugin), and they recently started showing up as minor problems during the upgrade to stache, and then as very serious problems in the upgrade to can 2.2.1; it took several full days to understand and fix the problems with computes being manually applied to maps.\nIn almost all cases where computes went wrong in my app, I would say the usage was inappropriate. I was usually able to work around the issue by just rethinking the problem and coming to a more appropriate solution. For example, in one case, a \"display\" compute was being set on every model in a list, and the compute was depending on the other values in the list. Since it was really performing view logic, and thus did not belong in define, I simply changed it to a local stache helper and fixed the problem.\nThe only usage I can think of where we needed to apply computes in an unorthodox way had to due with a model list because we can't currently use define on lists. Maybe we could get #1127 expedited sooner...\n. Either option sounds fine, but at this point I don't really see this as much of an issue anymore. I was able to work around it fairly easily and I just figured you guys should be aware of it since it seemed like a regression. Up to you how you want to deal with it, whether that be a fix or just documentation.\n. Oh, I didn't realize that was supported. I could have sworn I tested this before and that it did not work... but it seems to be working fine now.\nYou should add that to the docs so people know it's available.\nEdit: The only possible issue I can see is that if you do {{ data \"todo\" todo.prop }}, the data will actually store a compute instead of the value of todo.prop.\n. @justinbmeyer I am not sure that removing the parent takes care of the bindings. For example, in the following jsbin, the template is rendered into a div, which is then added to the container. If I understand you correctly, emptying the container (which removes the div) should remove the bindings, but that doesn't appear to be happening.\nhttp://jsbin.com/liwezuwoke/1/edit?js,console,output\nBy the way, it turns out the leak issue I am having actually has to do with the #each helper and it seems to have been fixed in 2.2.3.\n. Looks like this is unfixable. In summary, the problem is the lack of a wrapping element around the bindings. The fix is to add a wrapping element when using can.stache().\n. I can't accept \"won't fix\" as an answer for this anymore. This keeps coming up as a problem I need to workaround whereas angular 1.x provides this by simply throwing & on the directive definition (which is gross I know). We could probably do something like this:\n``` html\n// passing function to component\n\n// passing function to can-EVENT\n\n```\nHere's a simplification of a recent use case I encountered where I could not find a suitable workaround.\nmy-component.js:\njs\ncan.Component.extend({\n  tag: 'my-component',\n  template: // my-component.stache\n  viewModel: {\n    myMethod() {}\n  }\n});\nmy-component.stache:\n``` html\n stuff \n component somewhere in the middle \n\n more stuff \n```\nmy-dialog.js:\njs\ncan.Component.extend({\n  tag: 'my-dialog',\n  template: // my-dialog.stache\n  viewModel: {\n    // close dialog only if form validates\n    closeDialog(validator, myMethod) {\n      if (validator.validate()) {\n        myMethod();\n      }\n    }\n  }\nmy-dialog.stache\n``` html\n\n\n\n\n\n\n\n```\nThere is no way for me to pass myMethod to that function. If my-component's view model was exposed as a #reference then I could pass that in but that can't be done when all of this resides within my-component.stache.\nAngular 1.x lets you use the controllerAs property of a directive which namespaces the controller. This affects the component's template so I could probably pass myComponent to the click handler if I wanted to, but we don't have a way to reference the current template's context like that except for in can-EVENT which doesn't work here since the click event is too deep.\nHere are some alternatives I did not want to do.\nBad Alternative 1: I could pass @element to closeDialog and have it trigger an event which is hooked up to myMethod on the element via can-EVENT. I don't like the idea of triggering DOM events in the view model.\nBad Alternative 2: Adapting option 1 to not trigger in the view model, create a new view model property and change it just for this purpose. Add an event handler in the component that triggers the event... more convoluted.\nBad Alternative 3: Create another object on the my-component view model that exposes the method... it shouldn't come to this.\njs\ndefine: {\n  api: {\n    get() {\n      return { myMethod: this.proxy(this.myMethod) }\n    }\nSimilar to method 3, the more traditional way would be to have my-dialog expect an object on which would be the method it should call. If it were just a dialog, that would make sense but my example above is a simplification; the actual scenario I have makes that seem inappropriate... perhaps because it needs to be partially redesigned but this all would have been so much easier if I could just pass a function reference in stache.\n. > Someone needs to fill out the following matrix:\nI believe it's currently like this:\n- R = Reference\n- R() = Executes the reference to get the value\n- (R) = Wraps the reference in a compute\n|  | computes | functions | properties |\n| --- | --- | --- | --- |\n| helpers | R | R | (R) |\n| components | R() | R() | R |\n| methods | R() | R() | R |\nI think primitives are always passed as values so I did not include them.\n* would allow passing properties/objects directly to helpers and & would allow passing functions/computes to components/methods; any other variation would give the current behavior.\n| * | computes | functions | properties |\n| --- | --- | --- | --- |\n| helpers | R() | R() | R |\n| components | R() | R() | R |\n| methods | R() | R() | R |\n| & | computes | functions | properties |\n| --- | --- | --- | --- |\n| helpers | R | R | (R) |\n| components | R | R | (R) |\n| methods | R | R | (R) |\nI'm not sure how I feel about wrapping properties in computes when passing them to components/methods but it was the logical thing to do here. Edit: I found a case where this would actually be pretty useful.\n. It looks like we're both wrong. It executes it.\nhttp://jsbin.com/teyukumozo/edit?html,js,console\n. Interesting. I was originally thinking of (R) as adding an additional layer of a function where executing it would return the original reference. In this case, you just get a different function (R()) which returns the value of executing the original reference.\nI would say that is fine for & to pass along except that in order to know the function is observable, it has to be executed which I don't think is acceptable.\n. > What use case?\nI was thinking it would be nice to pass a compute to a function so it could and then write back to the property without the function knowing anything about it. It could also set up bindings or something.\nIf I understand your chart correctly and the (!R) means it runs the function and then creates a compute for it (if applicable), as I described earlier, that means the function is run initially. For my use cases, that completely defeats the purpose of passing a function to a method or component (not sure I have use case for a helper) because I want the execution to be on my terms.\nI was thinking of something like this:\nhtml\n<input type=\"button\" value=\"Submit\" can-click=\"{doSubmit &validator.validate &dialog.closeDialog\">\nIn that example, validator and dialog are in the references scope and can't be directly accessed by the view model. The idea is to close the dialog only if the validation returns true. Running closeDialog initially would obviously be undesirable.\nI can currently achieve the functionality I just described by passing the validator and dialog instead of their functions, but that requires the doSubmit function to have knowledge of their APIs which is more complicated than it has to be; it might be an unreasonable expectation if doSubmit is part of another module entirely.\nI would like to apply basically the same concept with components where I could pass a callback that the component will execute whenever it does some specific thing. You can currently do this by passing an object to the component with a method that it will know to call, but I find that to be cumbersome for simple components that have few options.\nUsing can-EVENT doesn't always make sense because you don't typically trigger events from the view model (creating an extra property for triggering an event is dumb), so being able to listen to view model events in stache (#1841) might alleviate the problem.\nMy goal with passing functions to components/functions is to simplify the interaction between modules. I'm not sure what value computifying them provides. If that's a real need, perhaps it should do that for functions by default once the * and & modifiers are available (the way I want them), except that would be backwards incompatible.\n. There would still be an inconsistency between passing a computable function and a non-computable one with *; sometimes you would have the function and other times you would have return value, which is currently the case for passing functions to helpers.\nI was thinking that using * with a helper would pass the value like a simple helper so you don't have to deal with the compute, and the binding would be hooked up behind the scenes.\n. I agree with @pYr0x here. The & seems totally reasonable and even angular uses it.\n. I think the curly braces in templated event handlers should always surround an observable so the {foo} change syntax doesn't really make sense since foo is not an observable so how can you listen to a change event on it? You would think you could use this:\njs\n' foo': function(){\n  console.log('foo changed');\n},\nbut I think that is hardcoded to only work with the control's element.\nPersonally, I think the convenience of allowing the view-model to be the first point of lookup is unnecessary and only serves to confuse people. The standard syntax which @daffl pointed out is clear and should be the only way of listening to the scope in my opinion.\n. Ah, I overlooked that foo is a compute.\nIn that case, it seems reasonable to expect your latest example to work, but it seems to only work on Maps and Lists, not computes. :(\nI suppose it could be considered a bug but when would this actually be necessary? Your example seems a bit unlikely because you placed a compute instance on the prototype whereas using define seems to be the more appropriate choice. Using define, the foo property takes on a slightly different form so I think the typical '{viewModel} foo' does make sense (and works).\nThe only way that makes sense at the moment for you to have a raw compute on the component's viewModel is if you passed it in from another scope but stache would automatically run it which you probably don't want, etc... nowadays computes are rarely necessary to make manually, and needing to listen to them like this is even more unlikely.\nAlso, I just realized the _action method is basically rewritten in the component control so most of what I said in my previous comment doesn't apply.\n. Fixed in 2.3.9\n. You can only pass one extra argument to trigger() and the rest are dropped. The jQuery docs recommend passing an array.\n. #1827 fixed the case where the options change and the selected option remains in the list, but if the selected option is removed and added back to the list, the displayed option stays out of sync.\nHere is the original JSBin updated to use 2.3.1:\nhttp://jsbin.com/hajupezufa/edit?html,js,output\n. I don't think this is fixed. My previous comment is still true using master.\n. Yeah, that should work.\nhttp://jsbin.com/hopukovala/1/edit?html,js,output\nWhen the selected value is not in the list of options and then enters that list, the selected value should change but does not.\nThis happens a lot in my current project where picker data loads async and there are default values either present initially or loaded async as well. My current workaround is to render a dummy select if the list is not loaded, but it would be cool if I didn't have to do that.\n. Your suggested 2-way binding behavior might be the best option, but what should happen during initialization if the bound value is not present in the options?\nFor the use cases I described, it would preferably not change the bound value, but showing no selection (selectedIndex = -1) would also mean a \"Loading...\" option placeholder would not show either, so maybe a dummy select element is the way to go after all.\nWhat would happen if multiple change events caused the list from which the options are derived to change multiple times very quickly? Might that cause the selected value to change to \"\" unexpectedly or would batching likely prevent that?\n. Hmm, I guess there are still some cases where the 2-way binding behavior isn't working as expected.\nhttp://jsbin.com/nojikisobe/edit?html,js,console,output\nIf the parent/scope has a value that is not present in the options initially, the <select> element displays no selected value, which is correct. However, if an option matching the parent/scope value is added...\n1) The <select> element should display that option as selected - it does not\n2) The parent/scope value is being set to the element's value\n. @pYr0x Since the bugs were fixed, I think the behavior is pretty intuitive now. What more about select binding do you think needs to be documented?\n. I like the function call method filter(type) better than the way handlebars does it.\n. This works now, with helpers and functions. I think it was added via #1832.\nWorking example with 2.3.1:\nhttp://jsbin.com/dakesokuva/edit?html,js,output\n. Alright, I've updated my code to get around this. While testing the upgrade again, I found that the following also no longer works:\n``` html\n\nPerson\nCar\n\n\n```\nIn this case, I get the string \"{{ model }}\" instead of the value of model. I would have to strip the curly braces and bind to the outer scope to get changes like can-value does... is that how all custom attributes should be implemented? I could just as easily avoid that by having a separate attribute for the model as described below but I don't think I should have to.\nA point of inconsistency that bothers me is that I can have helper attributes rendered with stache but not the main custom attribute itself. For example, this is how I might use a datepicker:\n``` html\n\n\n\n```\nThe dp-min-date and dp-max-date attributes update automatically due to stache so the 'attributes' event observes the updates and can pass them to jQuery datepicker easily, but it's not always clear just by looking at a template which attributes can be rendered with stache and which cannot because that is determined by whether they are registered with can.view.attr.\n. > We support a [] operator\nSeems reasonable.\n\nAre you sure? That seems like a bug if you do. auto-complete won't be set to \"Person\" or \"Car\"?\n\nIf auto-complete is registered with can.view.attr then I get the raw stache code by reading the attribute.\nhttp://jsbin.com/qarafoqugu/edit?html,js,console,output\n\nActually, a problem with all of this:\n\nI don't think it's necessary to support more complex expressions like [{{#contact}}contact.{{/contact}}name]. For the simpler variants, I think simply coding the attribute callback to process the string is enough. Most of the use cases others presented in regards to this problem would be fixed by updating can-value and can-EVENT to read the string from {{key}} and then bind to that in the scope.\nMore complicated examples like below could be handled in the view model.\nhtml\n<div can-click=\"{{#if shown}}hide{{else}}show{{/if}}\"></div>\n. > I have a general purpose components where for example only one property have to be available in child scope, but I have to have all props leaked and it may cause some conflicts.\n@whitecolor I can certainly relate to this but using the reference scope with leakScope: false is working great for me so far. It's actually become pretty central to how I write components. Consider this example:\nhtml\n<my-dialog {^.}=\"*dialogApi\">\n  <!-- stuff -->\n  <input type=\"button\" value=\"Close\" ($click)=\"*dialogApi@close()\">\n</my-dialog>\nor even this:\nhtml\n<my-dialog {^@close}=\"*closeDialog\">\n  <!-- stuff -->\n  <input type=\"button\" value=\"Close\" ($click)=\"*closeDialog()\">\n</my-dialog>\nI understand you are waiting to upgrade until another issue is fixed but I would definitely give this a try when you do because it allows you to have 0 leakage which I think is even better than selective leakage. It also adds clarity to where your methods/properties are coming from which can get confusing when nesting leaky components.\nIs there a use case where the references scope would not solve your problem?\n. Interesting... I wasn't aware it had been deprecated.\nSome quick googling has revealed this stack overflow question about why it was removed, which links to a discussion about this github commit. People seem to be looking for alternatives. It even sounds like they might not be removing it.\nOne way to solve the original problem would be to allow mixing in a component as an attribute. I believe angular allowed that in 1.x but I haven't looked much at 2.0.\n. @beno This only applies to custom attributes defined with can.view.attr which I've brought up in basically a duplicate issue here.\nWhat basically happens now is the can.view.attr callback just receives a string before processing. This is necessary to make the new references bindings work because the #-prefixed attributes need to see the raw string to determine whether to hook up a 1-way or 2-way binding. This probably would have been avoided if the references bindings were part of can.Component instead of a custom attribute pattern.\nThe probable resolution would be to modify existing custom attribute definitions (particularly can-EVENT) to do the processing internally.\n. The behavior of registering a custom attribute callback with can.view.attr was changed so the #-prefixed attributes which are registered with can.view.attr (/#[\\w\\.\\-_]+/ pattern) can get the raw string instead of a processed one. This was a necessary feature to make it work and now people are seeing the backwards-incompatible side effect. \nI was referring to what could be done to resolve it within the framework. Since can-EVENT is registered with can.view.attr, that's why this is a problem, and the function defined for can-EVENT could be updated to process the string.\nJustin also threw out the idea of making a special syntax for enforcing that the mustache code is processed before the attribute callback receives it, but I'm not sure I like that.\nUnfortunately, I don't think there's anything you can do within the context of your app to fix this without adding unnecessary complexity.\n. @whitecolor The new binding syntax should allow this. I haven't tried it yet but you might be able to upgrade now.\n<input type=\"button\" ($click)=\"{{#if shown}}hide{{else}}show{{/if}}\">\nI believe can-click will also work since processing should be turned back on for custom attributes now that the references scope bindings have different syntax.\n. This kinda makes me nervous... I don't think placing can-value on an element should cause it to update the view model upon insertion. Two-way binding already gets hate for the confusing side effects it can cause developers, and this would add an additional layer of complexity.\nSome components like bit-panel update the parent view model of bit-tabs when inserted but that is an example of two components specifically designed to work together, whereas can-value is generic so it's probably better to avoid this behavior.\nThe top-down approach still works so the only advantage this provides is that you don't have to define a default in the view model which I don't think is a good trade-off.\n. I can see how that would be confusing but if the property is undefined, the <select> should probably not display the first option as being selected. As far as I can tell, that's how it worked before so you might have accidentally changed it recently when fixing live binding with dynamic select menus (#1762).\nHere it is in 2.2.6 with no displayed selected value:\nhttp://jsbin.com/mogocoteje/edit?html,js,output\nIf the blank option is not desirable then the developer should define a default and problem solved.\nEdit: You must be using Firefox because the blank option doesn't show there. It might be worth it to enforce a blank selected option in all browsers (http://jsfiddle.net/R9auG/ works in FF too). This could also be confusing to developers using Firefox primarily because adding can-value would change how <select> works on the initial render, but it might be ultimately less confusing than the other alternatives.\nI agree that we should preserve the 2 way-ness, but for the initial render, it should be the element reflecting the data, not the other way around.\n. I found the issue. It's happening because no template is defined for the component. If I put template:can.stache('<content/>') on the component definition it fixes it.\nLacking a template also affects lexical scoping and renders leakScope:false useless whereas it should probably still prevent the light DOM from reading from the component's viewmodel. Even before #reference values, you could still have a component with no template that used a view model that wasn't used by the light DOM.\n. Seems to be fixed in minor.\n. I was mistaken. This is still an issue and I just didn't update the syntax in the jsbin correctly to test it.\nOuter Scope: {{*bar}}\n<my-component {^foo}=\"*bar\">\n  Light DOM: {{*bar}}\n</my-component>\nhttp://jsbin.com/zegotuwope/edit?html,js,output\nIt's also an issue in examples like this (bar changing does not update foo):\n<foo-bar {(foo)}=\"*shared\">\n  <fiz-biz {(bar)}=\"*shared\"></fiz-biz>\n</foo-bar>\nStill workaroundable by adding a template, even template: can.stache('<content/>').\n. Ah, it is fixed in 2.3.1. I usually just test in jsbin with minor and assumed that would be up to date. Next time I'll use a specific version.\nI'll upgrade now. Thanks!\n. I'm not sure how related it is. I did manage to reproduce it with just a can.Map like the other issue so it's also not the fault of the router.\nhttp://jsbin.com/tapileheda/edit?html,js,console,output\nThe difference here is that only one property is changing which I think rules out the other issue as the cause.\n. This appears to now be fixed in minor as a result of the bindings rewrite.\n. Ugh. I was hoping it was just a router bug and not such a deep problem. Here's a new jsbin that uses a can.Map instead of the router (no change as you explained).\nhttp://jsbin.com/kaxebezapi/edit?html,js,console,output\nTo workaround it, I basically did what you suggested and made a virtual property that is computed from both.\n. It's not using can.route. Just maps and components.\n. I don't think I can remove the component.\nI haven't upgraded to the new pre versions yet because I've been really busy. It seems odd that doing page-name=\"{{page}}\" would be unsupported or have side effects. If so, I would have to go back and update older code.\nThe jsbin uses minor but this happens in much older versions as far as I can tell. I just did some testing and it happens in 2.2.6 but not 2.2.5.\nI will try upgrading to the latest pre once I update a few hundred reference scope bindings (I love this feature).\n. I recognize the value in using the new syntax for 1-way bindings (especially being able to pass non-strings), but I wouldn't expect those cons to cause this issue. I haven't had any other problems with this syntax before besides having to wait a frame for components to see the change. In this case, the change is never occurring.\n. Well the new syntax does work without this issue, so I'll just be converting to the new syntax anywhere I encounter this problem. Thanks for the help!\n. Yes, that's correct. Sorry for not clarifying.\nI worded it that way because you can't/won't use #each if the teardown is broken and I wasn't sure if it was an intentional feature.\n. @justinbmeyer I think this behavior makes perfect sense for the references scope, but updating the parent viewmodel is a different subject and increases complexity of an app, which is perhaps part of why you were originally against {^child}=\"parent\" bindings.\nSorry if I'm not very forgiving of breaking changes, but I have used CanJS for a little over a year now and I can't even count the number of times I have had to deal with them, let alone the dozens of hours I have spent debugging them, all on 2.X.\nMany times the developer whose code I was updating just \"did it wrong\" due to lack of proper documentation or functionality needed. Sometimes you guys just decided to change something you didn't like, which was possible because you conveniently never documented it. Other times, issues have arisen by doing it exactly the way you demonstrate, such as nesting #eq statements which turns out to be problematic due to the fundamental flaw of child bindings receiving updates first.\nMany of the times I have upgraded were for mandatory bug fixes or for features I felt handicapped without. Nearly every time, I had to deal with breaking changes or I would discover new bugs, requiring me to yet again upgrade and have to deal with more of the same, trading one set of bugs for another. I don't recall ever feeling a sense of stability with this framework, and as much as I really hate saying this publicly (edit it out if you want), I'm not sure I can honestly recommend to anyone that they start a new project using CanJS.\nDon't get me wrong, though. I do like many of the framework's features and the general direction things are headed. I appreciate all the hard work you guys do to improve the framework and add features like references scope, passing functions, and better binding syntax, all of which I am using already and love.\n. Dang, I was hoping this was already fixed in 2.3.1 but it looks like it's going to be in 2.3.2.\nI ran into an issue today because the old syntaxes were using the new binding behavior...\n<my-comp a=\"{foo}\" b=\"{foo.bar}\"></my-comp>\nmy-comp.b was defined as defaulting to the value of my-comp.a, and foo.bar was undefined. This resulted in the initial value of my-comp.b (equal to my-comp.a and foo) getting assigned to foo.bar, meaning foo === foo.bar, which was very unexpected. I only found it because foo.save() failed due to a stack overflow from circular references.\nhttp://jsbin.com/wewobizonu/edit?html,js,console,output\nI think this is a good example of why these binding rules can be bad, especially for backwards compatibility. The obvious solution in this instance is to simply change it to a one-way binding (if applicable) or make sure foo.bar is defined initially, but no change should be necessary if you do not change the binding syntax so I am glad you guys decided to revert the binding rules (edit: for the old syntax). I think it was the right choice.\n. > I don't think foo === foo.bar is unexpected as long as you know that undefined parent values will be set to their child value.\nExcept my code pre-existed that rule and running npm install can@2.3.0 did not impart that knowledge :stuck_out_tongue: (might be a bug with npm). To be clear, I'm saying it's good that the old syntax will continue to work the old way to prevent unexpected things like this for people upgrading.\n. Ah, thanks for the explanation. Looks like there's no bug here.\n. I thought on this some more. When a child updates the references scope, what is the point in setting that value back on the same child that caused the update if the references scope can't possibly have changed the value because it can't have setters?\nIn general, I think it is important to prevent unnecessary updates as much as possible because I have run into valid situations where unexpected updates have instigated complex logic.\n. I have kind of come around on this topic. In general, while it still feels wrong to me, updating the parent scope during initialization probably can't be very harmful. I initially discovered it was happening because a late loaded binding was changing a property (from undefined to empty string) to which another component was listening. I easily got around it by just setting a default empty string.\nI hesitate to add another syntax as if we don't already have enough. If I am the only one complaining about how the new bindings work, you can probably put this on the back burner.\nAs for the syntax options, I don't really have an opinion and I will probably not even use this feature.\n. I gave this a try on master and the foo function is running 3 times, or just twice if {{*bar()}} is removed. The whole point is that it shouldn't be running at all with @.\nhttp://jsbin.com/pezologeyi/edit?html,js,console,output\nI also tried using the function on the viewmodel instance instead of the prototype method and that doesn't work (never runs). I know it's not mentioned in title of this issue but I think that should work too if it's not too much trouble.\n. @justinbmeyer Sure, adding more complicated tests isn't fun and is probably the least efficient way to improve test coverage. I just thought I would throw that out there as an idea because I have had too many problems like this in the past and something needs to change.\nIt's been at the point for a while where I expect there to be nasty regressions in core features like this every time I upgrade, because frankly, this seems to always happen. Having a stable framework is absolutely key to building any complex app.\n. It's true that pushing it out the new version to a bunch of projects does reveal regressions quickly. I remember hearing about Angular having a system where they automatically upgrade hundreds of apps  internally at Google and run all of their tests with the new framework code in order to find bugs before release.\nI don't know if you guys are doing anything like that already but if you could adopt something like it, it might turn out to be worthwhile. For example, all Bitovians currently on projects could upgrade and test at various pre-release stages.\n. I just tested this out and it fixes the use case I provided in the first post, and the ordering issue you demonstrated with computes, but it seems to happen again when I add more depth to the 'computes'.\n``` js\nvar Map = can.Map.extend({\n    define: {\n        root: {\n            value: 'a',\n            set: function(val){ return val; }\n        },\n        child: {\n            get: function() {\n                return this.attr('root');\n            }\n        },\n        grandChild: {\n            get: function() {\n                return this.attr('child');\n            }\n        },\n        combine: {\n            get: function() {\n                return this.attr('root') + this.attr('grandChild');\n            }\n        }\n    }\n});\nvar map = new Map();\nmap.bind('combine', function(ev, newVal, oldVal) {\n    console.log('newVal=' + newVal);\n});\nmap.attr('root', 'b');\n```\nThe problem still goes away when the setter is removed from root and I'm not sure how that plays a role (because it creates a compute?). I could not reproduce this problem with just computes like you did earlier.\nUpon further review, I think you and I might be talking about different problems. It seems you think the problem is that change fires twice in 2.3.2 and once in 2.2.9, but what I initially described seeing was 2 changes in 2.2.9, which while sounding like something I would normally complain about, was not yet my concern... that also no longer seems to be happening in my 2.2.9 example so I am now confused...\nAm I correct in understanding that the goal is to minimize change events while infinitely nesting compute dependencies?\n. Closing as duplicate of #1692.\n. Looks like a 2.3.3 regression. It works in 2.3.2:\nhttp://jsbin.com/rilinopufi/edit?html,js,output\n. No rush for me. I'll just stay in 2.3.2 for now. I saw you fixed some of my other issues on master but there's just too many 2.3.3 problems right now for me to upgrade yet.\n. Are you suggesting that <foo-bar {@child}=\"@parent\"></foo-bar> should be the correct syntax for 1-way binding a function parent-to-child? I think you did something similar for child-to-parent...\n. Fine by me. Whatever makes things easier.\nMaybe.\n. @justinbmeyer Are you still planning to do #2065 eventually or just leave it with double @ as the norm?\n. The @ modifier makes sense when reading values, not writing them. Adding @ to the destination has no meaning. With {^@method}=\"@parent\", you are not assigning to @parent, but to parent.\nI suppose a 2-way binding like {(@method)}=\"@parent\" is actually a bit tricky since it's setting @parent to method and @method to parent.\n. Interesting. I suppose that would depend on what the current behavior is, which I originally thought (I could be wrong) is that it always assigns directly to the property. That is, the hypothetical @ destination syntax would keep the current behavior.\nIf I'm right so far, omitting @ would allow you to instead call a function/compute on the destination with the assigned value, but that behavior can already be achieved by defining the component that way, so having the syntax flexibility would allow the component to be used multiple ways.\nThen you may have to consider a scenario where the developer wants different read/write functionality when using @ on both sides in a 2-way binding.\nMy initial thought is that we should keep it a read modifier and call it a day.\n. This popped up as an issue in places where an asynchronous virtual property's value is passed to a component where undefined is never expected, but perhaps it is the right behavior. I'll update my setters regardless of what you decide.\n. @pYr0x The issue being demonstrated is that changes to viewModel properties during events.init() or events.inserted() do not update <select> elements using the new 2.3 binding rules. The 2nd and 3rd select menus should show \"INDIA\" initially, not \"USA\". It works in his 1st example because it's using stache bindings to determine the selected element.\nHere's a slightly simplified example:\nhttp://jsbin.com/fizuniyoju/edit?html,js,output\nThe bug affects can-value as well because it shares code with the new bindings.\nIt doesn't seem to be a problem with other form controls. There are a few open issues about select element live binding already; they sure could use some love.\n. > A scenario without a batch: if the visibility property has a setter then stache does not update the template:\nI think that's because the presence of a setter adds a batch, so batching may still be related.\n. I think a more precise description would be that virtual properties are not included in the output of can.Map.keys(map). If the map has real properties, those will still be in the array.\n. My use case for this was creating a mixin for bit-tabs that binds the active tab to the route's tabId.\n``` js\nfunction bindTabsToRoute(tabsVM) {\n    let oldMakeActive = tabsVM.makeActive,\n        panels = tabsVM.attr('panels'),\n        routeChangeHandler = function(ev, newVal, oldVal) {\n            panels.each(panel => {\n                if (panel.attr('tabId') === newVal) {\n                    tabsVM.makeActive(panel);\n                }\n            });\n        };\n// override makeActive() to also update the route\ntabsVM.makeActive = (panelVM) => {\n    can.route.attr('tabId', panelVM.attr('tabId'));\n    oldMakeActive.call(tabsVM, panelVM);\n};\n\n// bind to route\ncan.route.bind('tabId', routeChangeHandler);\n\n// return teardown function\nreturn () => can.route.unbind('tabId', routeChangeHandler);\n\n}\ncan.view.attr('bit-tabs-route', function(el, attrData) {\n    let teardown = bindTabsToRoute(can.viewModel(el));\n    can.one.call(el, 'removed', teardown);\n});\n``\n. This came about because I am using a helper to create child reference scopes in#each` blocks, but I also want scope reads in those blocks to fall through to the parent reference scope.\njs\ncan.stache.registerHelper('ref', function(options) {\n    return options.fn( new can.view.Scope.Refs() );\n});\n``` html\n\n{{#each list}}\n    {{#ref}}\n        \n        {{foo}}\n        {{bar}}\n    {{/ref}}\n{{/each}}\n. html\n\n\n\n```\nThe context passed is the viewmodel of <parent-comp> even though it is leakScope:false. It should be the scope above <parent-comp>.\nhttp://jsbin.com/sihogovema/edit?html,js,console\n. The pattern is a template-less logic component that wraps around a simple ui component. When the ui component's state changes, the logic component performs an action.\nhtml\n<dropdown-listener-navigation {(selected)}=\"*selectedCommand\">\n  <dropdown-ui {items}=\"actionList\" {(selected)}=\"*selectedCommand\"></dropdown-ui>\n</dropdown-listener-navigation>\nIn this case, <dropdown-listener-navigation> is very specific. It has knowledge of the possible selections and a function for each one, so I could swap it out for a different component if I wanted a different implementation. This is the pattern that my coworker introduced for dropdowns and it has worked well so far.\nI could always add template: can.stache('<content />') as a workaround, but there are a few other ways of implementing a dropdown that came to mind just now:\ncustom attributes:\nhtml\n<!-- dropdown-listener-navigation would listen to the viewmodel -->\n<dropdown-ui dropdown-listener-navigation {items}=\"actionList\"></dropdown-ui>\ndirect module access:\nhtml\n<can-import from=\"helpers/dropdowns/navigation\" {^value@process}=\"*processDropdown\" />\n<dropdown-ui {items}=\"actionList\" (selected)=\"*processDropdown(%viewModel.selected)\"></dropdown-ui>\n. Ah, so if I set with can.route.attr() instead of directly on appVM, the problem is avoided. Good to know.\nThe 2nd bug is that if I use can.route.attr(obj) with no 2nd argument, it does not stringify the object's properties because it incorrectly thinks it's a read. Reversing the order of the first two if statements should probably do the trick.\n. I think the overriden .__type method (and can.route.attr()) should ignore properties with serialize:false because there is no reason to stringify them, right? I ran into an issue with this fix where a boolean that the appVM handles internally was being stringified to \"false\" which changed the result of truthy checks.\n. I recently tried something like this:\n``` js\ncan.view.attr('my-attr', function(el, attrData) {\n  var div = $('');\n$(el).after(div);\ncan.one.call(el, 'removed', function() {\n    div.remove();\n  });\n});\n```\nIs that not safe? If it is, then what kind of DOM modification are you doing that requires nodeLists? Mostly just curious because I use custom attrs a lot.\n. Yeah, this doesn't happen with just a compute, so it's a can.Map init issue.\nI can do this as a workaround:\njs\nvar c = can.compute(function() {\n  var map;\n  can.__notObserve(function() {\n    map = new can.Map();\n  })();\n  return map;\n});\nTracing was pretty easy. During setup, it sets the data (an empty object in this case) and that eventually leads to can.each which calls keys(). I don't know enough about the internals of the framework to know whether adding __notObserve somewhere in the chain would be the best solution as opposed to something else.\n. Here is a simpler example:\nhttp://jsbin.com/qayicihipa/edit?html,js,console,output\nIt doesn't seem to happen when you bind directly to the map before the stache binding.\nThe same behavior occurs if you try to read the property before binding it.\n. This was caused by #2219.\nThe can.compute 'map' reader (compute/read.js#L155) previously would return the context with map.attr('') but that now looks for a property keyed with an empty string.\nI also think that this should return the map rather than the object (always thought that was a bug).\n. > What is that? I'm not sure what you mean.\nI mean ../, not map.attr('').\n. Can we remove the can.route.attr() override now that the backing map handles the coercion? I don't think it's necessary, and it's currently not checking if the properties are serializable. \n. Yes, I am talking about {prop: undefined} properties.\n. What if {($value)} bound to the result of the subexpression? You could simply return a compute in the helper like this:\njs\ncan.stache.registerHelper('convertNumber', function(source) {\n  return can.compute('', {\n    get() {\n      return source()+'';\n    },\n    set(val) {\n      source(val === '' ? null : +val);\n    }\n  });\n});\nWhen I try to do this now, the compute function string is shown in the text box which doesn't seem useful.\n. @justinbmeyer If you don't intend on radix changing, that doesn't seem like an issue. However, if you do, what would be the intended functionality? Should it re-run the setter?\n. In order for radix to be a compute, I assume it would also be passed as ~radix which seems like an unusual use case. If it was passed without ~, then when radix changes, I suppose the outer compute would recompute the inner, which should then be re-bound and re-set... Seems like complicated behavior for a binding.\n. I don't recall exactly where this came from. Perhaps someone reported it in Gitter. Some people may prefer ./ over . for clarity or readability.\n. I think this is related to (or a duplicate of) #2318.\n. You might be thinking of #2220 which also has to do with instantiating maps in computes.\nI think wrapping value() and set() functions in Observation.ignore or something similar is a good idea.\nA public Observation.ignore would be nice to have. I have avoided using can.__notObserve in the past because it is private.\n. I think the last part should be !!this.define[prop].serialize since the define block should not be a map.\n. I think you want can.Map.extend() here.\n. ",
    "jondubois": "@justinbmeyer - Maybe something along the lines of can.route.attr(key, value[, options]) - The options object could hold property names (I.e.. a 'history' property in this case) to let you customize how can.route should handle the attribute change.\nFor example:\n// Overwrite the previous history entry\ncan.route.attr('contentId', id, {history: 'replace' })\n// Do not add this route to history at all\ncan.route.attr('contentId', id, {history: 'ignore' })\nI realize that this somewhat violates the simplicity (and consistency) of the attr() method so maybe it's not ideal. But then again, functionality-wise, can.route's attr() method does more than that of can.Map, so maybe having an extra argument is justified?\nThe other alternative I can think of is to add a can.route.navigate(attrName, value, history)\nmethod where the history argument is either 'replace' or 'ignore'... This is not perfect either semantically.\n. Actually yes, something like that should work well.\nThere should probably also be an equivalent ignoreHistoryOff() method. I think history should be enabled by default though - Most routes do need the history.\nAlternatively, the history-tracking status of each route could be a config option passed to can.route(). I think generally, the history behavior won't change at runtime anyway. Both techniques are equivalent for my particular use case.\n. @justinbmeyer Note sure, I haven't tried with stache yet.\n@Tarabyte On my machine, the script I provided only leaks when you click on the 'Start test (with leak)' button.\nIn the slightly modified version you provided in JSFiddle, both leak. The first one leaks almost 3MB and the second one only leaks slightly over 1MB - So one is leaking more than the other... Could this inconsistency be related to fiddler itself?\nWhen checking for memory leaks, I tend to check in complete isolation in a fresh tab - I'm not sure how jsfiddle interacts with all this code - It might skew results... I also noticed that jsfiddle runs the code in an iframe which can affect things too - For example, you will find that deleting the iframe cleans up all memory leaks (because iframe memory is sandboxed).\n. @justinbmeyer I will try to reproduce it using a simple Observe instead of the Model + Fixture combination - It might still leak. \nUltimately, something appears to be holding on to references of the data. When I was debugging a while ago, I think I saw something about a _cache property somewhere in 'can' and I remember thinking that this could be the cause... Does that ring a bell?\n. @justinbmeyer Thanks for looking into this. We will try to migrate our templates to stache.\n. @justinbmeyer Thanks. I did spend a couple of hours on this last week but it's really difficult to find memory leaks in unfamiliar code :p\n. ",
    "w3dot0": "@justinbmeyer fully agree - debugging computes can be quite tricky and being able to see their dependency chain would be very useful. \nLet's say I'm creating a view with a list of checkboxes that use can-value. Each item should be checked if its value is contained in a can.Map's selectedIds array field (and unchecked if it's not present).\nI could write a compute that \"gets\" each checkbox's value from the array using selectedIds.indexOf(value) > -1 and \"sets\" the value in the array using selectedIds.push(value) and selectedIds.splice(...). Looks pretty harmless at first sight, but it's not going to scale well: Since all the computes listen for changes to the same \"selectedIds\" field, each time a checkbox is selected ALL computes will reevaluate (and each checkbox will update). Not a good idea...\nHow could the inspector help you realize that this is a performance bottleneck? Maybe the \"compute dependencies\" view could show how many times a compute instance updated itself in total (so you could see that they all recompute themselves at the same rate) or a log view could shows which computes have updated most recently. Clicking on one of the log entries could then show the dependent values and ideally link to the compute's source code itself.\n. @justinbmeyer fully agree - debugging computes can be quite tricky and being able to see their dependency chain would be very useful. \nLet's say I'm creating a view with a list of checkboxes that use can-value. Each item should be checked if its value is contained in a can.Map's selectedIds array field (and unchecked if it's not present).\nI could write a compute that \"gets\" each checkbox's value from the array using selectedIds.indexOf(value) > -1 and \"sets\" the value in the array using selectedIds.push(value) and selectedIds.splice(...). Looks pretty harmless at first sight, but it's not going to scale well: Since all the computes listen for changes to the same \"selectedIds\" field, each time a checkbox is selected ALL computes will reevaluate (and each checkbox will update). Not a good idea...\nHow could the inspector help you realize that this is a performance bottleneck? Maybe the \"compute dependencies\" view could show how many times a compute instance updated itself in total (so you could see that they all recompute themselves at the same rate) or a log view could shows which computes have updated most recently. Clicking on one of the log entries could then show the dependent values and ideally link to the compute's source code itself.\n. cc @ms \n. cc @ms \n. +1\n. +1\n. ",
    "akagomez": "One down: http://jsperf.com/tabs-timing-test/13\n. I'm looking into the issues on http://jsfiddle.net/JMWf4/47/ now. \nTo simplify things a skoch I separated the CanJS parts into a separate Fiddle: http://jsfiddle.net/tazpq6z9/4/. \nTo get that working I had to update the jQuery dependency from 1.7.1 to 1.11.0 and replace can.view.mustache.js with can.ejs.js. For fun I also added a Stache example which meant I had to load can.stache.js too.\nThe next thing to do is to get each of the other examples working also. \n. @daffl Can we fix this in 2.3? It's a very common \"gotcha\" for new CanJS devs. Related: https://github.com/bitovi/canjs/issues/1775\n/cc @DesignByOnyx \n. Can we limit that behavior to the few tags that might take advantage of it? Or possibly make that feature configurable? \nThe way I see it, if we're going to aggravate one of the two types of users, I'd rather it be the experienced CanJS developer that decided to update and read the release notes.\n. This looks fixed in latest. \n. This is still a problem in latest. Possibly related to: https://github.com/canjs/canjs/issues/2229\n. While mucking with this I learned that parseModels shouldn't be called directly. My bad. \nThis is still an issue though as shown in my test, which doesn't call parseModels directly. \nI also learned that you can work around this issue by defining parseModels in init. \nThe problem then becomes that parseModels is called twice. The same is true for parseModel. See issue #1253. \nThe second time parseModels is called it's passed a can.List instance. My workaround for this was to check the instance type of the argument passed to parseModels. \nHere's a demo of how I hacked my way around both issues: http://jsfiddle.net/qYdwR/2194/\n. Here's a demo of how I worked around the issue: http://jsfiddle.net/qYdwR/2193/\n. If you're into computer science data structures, you may be interested in the work going on here: https://github.com/canjs/can-binarytree\nAs far as sorting goes, the sort plugin specifically uses selection sort to avoid unnecessary swaps in the DOM. \n. I was a little annoyed at how sloppily I was testing this feature, so I cleaned that up a bit. \nAlso, made it so that functions passed to can.Map.prototype.attr get converted to can.compute's in the context of the can.Map. \n@daffl Documentation added. It's a bit more wordy than the other types in the type list, but I think it works (for now).  \n@justinbmeyer I can't see any way around it due to bind and unbind's dependence on _computedBindings. \nHowever, unless I'm missing something we can replace _computedBindings in can.Map.prototype.setup, can.Map.prototype.__get, and can.Map.prototype.___set with  val.isComputed. Then, account for the fact that the initial _computedBindings.propertyName object may not be defined yet in bind and unbind. They seem to be the only methods that depend on the binding count.  \nAll of that said, I think that should be handled in a separate PR since it works as it stands. \n. #1486 does this better by giving converters the ability to mixin set and get functions and reworks can.compute so that the get value can be derived from the result of set.\n. Thanks for reporting this.\nFortunately this issue has already been resolved in #1400. \n. From the looks of it, this is now possible too:\n```\ncan.define.powerOfTwo = {\n  set: function(newValue){\n    return +newValue;\n  },\n  get: function(lastSetValue){\n    return Math.pow( lastSetValue, 2)\n  }\n}\nMyMap = can.Map.extend({\n  define: {\n    num: {\n      type: 'powerOfTwo'\n    }\n  }\n})\nvar myMap = new MyMap();\nmyMap.attr(\"num\",\"4\");\nmyMap.attr(\"num\") //-> 16\n```\n. Is it possible that there was some sort of copy/paste error? because I can't see how that Fiddle relates to the issue you're logging. \n. I see. \nLooking into this a bit further, regardless of what effect calling .off has on the this.__bindEvents[event] array after calling can.removeEvent, the this._bindings count is decremented. \ncan.removeEvent.apply(this, arguments);  // Has no effect on `this.__bindEvents[event]`\n        if (this._bindings === null) {\n            this._bindings = 0;\n        } else {\n            this._bindings--; // Decrements despite not removing an event\n        }\nhttps://github.com/bitovi/canjs/blob/32f1f6633266918185ade66ac1c72029ffdbd456/util/bind/bind.js#L31-L36\nHere's a failing test to accompany the issue: https://github.com/bitovi/canjs/commit/c9eddc3b268b89fa97edc96d7d3a21e023822d6b\n. From what I can tell, the \"JOHN GALT\" example demonstrates that a define type converter is not called when setting multiple properties with .attr(object): \nhttp://jsbin.com/jetibe/edit?html,js,console\nHow this relates to the original example I haven't been able to determine yet. \n. I'll create a test for this in the AM. \n. I have a fix ready. I just need to create a test to go along with it. \n. Here's a Fiddle I put together a little while back demonstrating the issue: http://jsfiddle.net/akagomez/tksdbxvp/\n. I suppose this issue is irrelevant now due to the new binding syntaxes @daffl?\n. @justinbmeyer I'd love it if you could take a look and let me know if there's a better way to accomplish this. \n. After looking at this again I've decided that the current compute._triggerWhileUnchanged approach will not work since it persists once set. \nI think the solution is to pass the event object to updater and updateOnChange, then add some logic to updateOnChange that looks for eventObject.ignoreSameValues === false, or something like that. \n. Thinking about it a bit more, this approach... \n// The value didn't stick, so trigger a change on the\n// abstract compute (the compute all of these radio inputs) are\n// bound to so that every radio input can determine whether\n// or not it should be \"checked\".\nvar abstractCompute = this.options.abstractValue.computeInstance;\ncan.batch.trigger(abstractCompute, {\n    type: 'change',\n    triggerOnSameValue: true\n});\n...cascades down to all child events. A better idea might be to configure the specific child computes that will trigger change events despite same values. I think I'll look into this. Sounds like the ideal solution. \n. Okay, I think I have a much better solution in place for the type=\"radio\" part of this PR. \n- Each \"radio\" compute is bound to the abstractValue (as was already the case, only now it has a name)\n- Each \"radio\" compute is configured to trigger change events regardless of whether the value has changed or not (by way of value.computeInstance._triggerOnSameValue)\n- If the Checked control attempts to set a \"radio\" compute's value and fails (meaning the abstractValue's setter rejected/changed our newVal), the Checked control manually triggers a change event on the abstractValue\n- The manually triggered change event will propagate down to the \"radio\" computes, thereby causing each <input type=\"radio\"> to re-evaluate whether or not it is \"checked\" based on the abstractValue's value. \nAs far as I'm concerned this PR is ready for merge, pending review. Please excuse me for the trail of breadcrumbs I left getting to this point. \n. Thanks for reporting. \nThis is fixed in 2.2. See #1253. \n. @justinbmeyer The test you provided passes: https://github.com/bitovi/canjs/commit/1917e59c4894b54112295062b11c26d07bafbfce\nIf I remember correctly, this._bindEvents is organized like this:\n{ \n  firstName: [\n    {\n      name: 'firstName', \n      handler: fn1\n    }\n  ], \n  lastName: [\n    {\n      name: 'lastName',\n      handler: fn2\n    },\n    {\n      name: 'lastName',\n      handler: fn3\n    }\n  ]\n}\nLet's assume map.off('lastName', fn3); is called. \nBy getting the length of this._bindEvents.lastName before and after can.removeEvent we know how many event handler were removed for that eventName, and handler/validate method combo. \nUnless I'm wrong in assuming that this._bindings is meant to cache the number of eventName/handler pairs there are in this._bindEvents, I can't see how this PR introduces a bug. \n. Still wrong on the Mustache docs: http://canjs.com/docs/can.mustache.helpers.sectionHelper.html\n. The reason this isn't working is because of additional text nodes in the template (whitespace, new lines, etc).\nThis will work with those removed.. http://jsbin.com/fomequfosa/1/edit?html,js,output\nThat said, this issue exposes others at the DOM manipulation layer of the Sort plugin. \n@daffl and I will be taking a look later today. \n. @justinbmeyer How do you want to go about the next steps?\n. When I spoke with @justinbmeyer yesterday evening, he suggested these were not likely the solution to the core issue. For now, it's likely a good enough fix until Justin has the time to investigate further. \n. @daffl Thanks. \n@m-mujica and I discussed a few ideas a while back: https://gist.github.com/akagomez/c7d7111e4490e9dd49eb\nThis one fits right in with the rest besides for the name of the property. If we can change it to attr instead of property I'll be happy to merge it. \n. I just realized that direction should also be renamed to order.\n. @kylegifford setVal is meant for async setting. I don't think that truly addresses the issue. \n. Darn. I probably could had reused that test and just changed mustache to stache. \n. @whitecolor The PR hasn't been merged yet. \n. @daffl I only meant to link the issue that @kylegifford referenced in his comment. \n. @rjgotten That seems logical to me also. \n@justinbmeyer @daffl Is there a specific reason why oldVal isn't undefined in can.list.prototype.splice when the add event is fired? \nif (howMany > 0) {\n    // tears down bubbling\n    bubble.removeMany(this, removed);\n    this._triggerChange(\"\" + index, \"remove\", undefined, removed);\n}\nif (args.length > 2) {\n    // make added items bubble to this list\n    for (i = 0, len = added.length; i < len; i++) {\n        bubble.set(this, i, added[i]);\n    }\n    this._triggerChange(\"\" + index, \"add\", added, removed);\n}\nhttps://github.com/bitovi/canjs/blob/master/list/list.js#L340\n. For reference, there's a bit of documentation in the original PR: https://github.com/bitovi/canjs/pull/1486.\n. Questioning whether \"debounce\" was a good name for a utility like this I decided to look up the definition.\n\nGlossary Term: Debounce \nElectrical contacts in mechanical pushbutton switches often make and break contact several times when the button is first pushed. A debouncing circuit removes the resulting ripple signal, and provides a clean transition at its output.\nhttp://www.maximintegrated.com/en/glossary/definitions.mvp/term/Debounce/gpk/82\n\nSounds pretty suitable. \n. @matthewp In my implementation we're not catching the event on the end. We're calling the function on the first of the batched events. But knowing that this is a batched event, we can read directly from this instead of relying on newVal.\n. @imjoshdean \n\nA length event will fire three times with the value being three. \n\nThat's not true. We'll get three events. Their newVal will be 1, 2, and then 3. \n. @justinbmeyer Just to be clear, are you suggesting that we implement ONLY the closure variety as a part of 2.4.0? Or BOTH, despite the fact that the prototype variety is less useful than it would had been in the past?\n. It turns out most of the issues I listed here where invalid. I had gotten fooled by landing on a dead page in a late night stupor: http://canjs.com/docs/can.List.prototype.sort.html\n@daffl What's the best way to deal with that? Does DocumentJS have a way to redirect from one page to another?\n. Status: \n- [x] The out of date documentation page has been removed (404: http://canjs.com/docs/can.List.prototype.sort.html)\n- [x] This example lacks a comparator definition: \nvar cart = new can.List([\n    { title: 'Juice', price: 3.05 }\n    { title: 'Butter', price: 3.50 },\n    { title: 'Bread', price: 4.00 }\n  ]);\n  cart.bind(\"length\", function(){});\n  cart.push({title: 'Apple', 3.25});\n  cart; // -> [Juice, Apple, Butter, Bread]\n- [x] There is no documentation for how to accomplish descending string comparators (to which the current answer is, use a function)\n. Yup. That's shown in the demo too. \n. I asked in the \"How can.Map works\" Hangout why a remove event isn't triggered. Here's a link: https://youtu.be/MPZeaDY5mTk?t=33m11s\n@justinbmeyer mentioned that we intentionally don't fire add or remove events on can.Map's because there hasn't been a reason to. He also mentioned that you can bind to __keys, but you won't get the key that was removed. \n. Interesting. map.attr('key', undefined) === map.removeAttr('key'). Check out this demo: http://jsbin.com/pabeco/2/edit?js,console\n. So here's what I've learned...\n1) A can.Map's will exclude a \"key\" if the \"value\" is undefined. That wasn't expected. Compare:\n```\nvar m = new can.Map({ a: 1, b: undefined });\nconsole.log(m.attr()); //-> Object {a: 1}\nvar o = { a: 1, b: undefined }\nconsole.log(o); //-> Object {a: 1, b: undefined}\n```\n2) Binding to change is the only way to know if a \"key\" is added or removed from a map. No matter if it was removed for it's \"value\" being set to undefined or  removeAttr being called. \n. Here's a demo of this being an issue with native DOM manipulation too: http://jsbin.com/tupodanihu/1/edit?html,js,output\n. Other instances I found: \n./map/define/define_test.js:546:                        throw '\"foo\"\\'s value method should not be called.';\n./map/lazy/lazy.js:196:             throw \"can.LazyMap: object does not exist\";\n./map/map.js:495:                       throw \"can.Map: Object does not exist\";\n./util/fixture/fixture.js:108:                  throw \"fixtures.js Error \" + error + \" \" + message;\n./view/parser/parser.js:236:                throw \"Parse Error: \" + html;\n./view/view.js:46:          throw \"can.view: No template or empty template:\" + url;\n. The PR: #1811\n. Correction: Calling .unbind() without any arguments does nothing. You need to at the very least pass a type (.unbind([type])). Still, doing so when no bindings are defined causes and error and the PR referenced here addresses that issue. \n. I can't imagine we'd want to throw that error for the case I outlined. \nWhat others exist? Can you think of some off hand?\n. Maybe there's a better alternative to my use case then. How I can I safely remove all bindings from a compute, regardless of whether it is or isn't bound to already?\n. You're right. I assumed that calling .unbind() without any arguments would remove all of the bindings. After getting this error I then assumed that if there were bindings to be removed, they would be. \nI could swear I've confirmed this before. But now I'm not sure. I probably got this mixed up with how can.Map can unbind all handlers bound to a property: http://jsbin.com/yomimiyuce/edit?js,console,output\n. One slight clarification. Calling .unbind() without any arguments does in fact not remove any bindings. \nYou can remove all of the bindings of a particular type by calling .unbind([type]). \nThat said, doing so will still throw an error if there are no bindings at the time .unbind() is called on the compute. This PR addresses that specific issue. \nAlso, test added. \n. Rebased. Tests passing. Good to merge. \n. The confusion may be due to the fact that I opened the issue for the case .unbind(). That was in error. Calling .unbind() without an event \"type\" does nothing. See here: https://github.com/bitovi/canjs/blob/master/event/event.js#L199\nI attributed that error to calling .unbind() without a type. In reality it was present even if a \"type\" was defined: \nvar c = can.compute(32);\nc.unbind('change'); //-> \"TypeError: Cannot read property 'undefined' of undefined\n                 at can.unbindAndTeardown [as unbind]\nThis PR prevents an error from being thrown if .unbind(\"type\") is called and there are no bindings, which is consistent with most \"remove\" api's that I'm familiar with (e.g. el.removeClass('class'), map.removeAttr('attr'), etc)\nMaking .unbind() remove all event handlers of all types was not the intention of this PR. \n. +1\n. I'm curious how this PR addresses the issue and it's not clicking for me. Would you mind helping me understand?\n. I am not. I'm sure that's the issue. Thanks for the clarification. \n. Okay, that part was unrealistic I'll admit. But the click=\".list-item {increment}\" bit is doable, yeah?\n. No, this is new to me.\nChris\nOn Monday, September 14, 2015, Justin Meyer notifications@github.com\nwrote:\n\n@akagomez https://github.com/akagomez Did you add this functionality\nalready? I felt like we talked about it.\n\u2014\nReply to this email directly or view it on GitHub\nhttps://github.com/bitovi/canjs/issues/1870#issuecomment-140260111.\n. I made .unbind() not error: https://github.com/bitovi/canjs/pull/1780#issuecomment-121241086\n. It's important to note that the sort plugin will still use selection sort for complete re-sorts since it results in fewer swaps. \n. The 3rd objective \"Collect batched adds ...\" can't actually be done. Even if batched, multiple calls to .push() won't get a batchNum (Duh!). The best way to benefit from batched inserts is to store all of your \"push's\" into an array and pass that array to push all at once, like: list.push.apply(list, queuedInserts). \n. From what I can tell, the newVal starts referring to the compute's method here: https://github.com/bitovi/canjs/blob/master/view/scope/compute_data.js#L102\n. A bit more context... \n\nIt appears the issue was introduced here: https://github.com/bitovi/canjs/commit/23de6705dd7c97c5608ddb8904541e601a62dd9d \nWhile addressing an almost identical issue here: https://github.com/bitovi/canjs/issues/1617\n. Benchmarks before (~40s per test): \nAdding 20k items via .push([list]) x 0.02 ops/sec \u00b10.95% (5 runs sampled) \nAdding 20k items via .splice(0, 0, [list]) x 0.02 ops/sec \u00b11.91% (5 runs sampled)\nAdding 20k items via .each([list]) + .push([item]) x 0.04 ops/sec \u00b10.72% (5 runs sampled) \nCurrent (<1.5s per test): \nAdding 20k items via .push([list]) x 4.89 ops/sec \u00b12.12% (17 runs sampled) \nAdding 20k items via .splice(0, 0, [list]) x 5.18 ops/sec \u00b11.62% (17 runs sampled)\nAdding 20k items via .each([list]) + .push([item]) x 0.63 ops/sec \u00b12.18% (6 runs sampled) \n. For speed, If multiple items are added in one call to .push() or .splice(), the native .sort() is called with the user's provided comparator. Then, each subsequent _getInsertIndex is masked to the remainder of the list. For instance:\nlist = ['a','c','e','g','i']\nlist.push('b','d','f');\n    //-> _getInsertIndex('b'); // Search indexes 0,1,2,3,4; Returns: 1\n    //-> _getInsertIndex('d', 1); // Search indexes 1,2,3,4,5; Returns: 3\n    //-> _getInsertIndex('f', 3); // Search indexes 3,4,5,6; Returns: 5\nWithout this tactic the time to insert 20k items at once goes up by ~400ms.\nThe reason I mention this is that unfortunately I just learned that the native .sort() method's implementation can yield unreliable results. See here and here.\nThis means that a bad native sort result can throw off the sort plugins much more reliable result because of the masking. It's a \"will probably never happen\" edge case, but still. \nThe best compromise that I can think of is to keep track of the types as they're inserted. If the type changes while doing the inserts, re-sort the entire list (which will result in unnecessary swaps if something went wrong, but it will be corrected), then continue to insert items without the masking. \nOr maybe I just shouldn't rely on the native sort implementation. \n. Decided to remove the pre-sorting optimization. It was causing problems for even a simple case in PhantomJS tests. Lesson learned. DO NOT rely on native .sort() implementations. I should make note of this in the sort plugin docs. \n. Re-submitting against minor. \n. Looking into it. \n. I was trying to be clever by doing can.$('#id').find('.class'), but .find() seems to be specific to jQuery. \nShould be good now. \n. Maybe. Didn't work for me though. \n. Darn. @imjoshdean and I thought we covered that base here: \nvar template = can.stache(\n    '<list-toggler-1></list-toggler-1>\\n' +\n    '<list-toggler-2></list-toggler-2>\\n' +\n    '<list-toggler-3></list-toggler-3>\\n');\nvar frag = template();\n$(document.body).append(frag);\nI didn't realize stache/mustache could work together. \nOkay. So. I've updated the tests to use stache explicitly. As a result 2 of the 3 test turned out to be false alarms. Then I tried a few more test cases, and found another. Test #_1 is a doozy. Test #_2 may not even be a leak. \n\n(I updated the branch and the JSBin)\n. From the can.Component.prototype.template documentation: \n\nUse\nThe template specified by the template property works similar to the W3C Shadow DOM proposal. It represents the contents of a custom element, while being able to reposition the user provided source elements with the <content> tag.\nThere are three things to understand about a can.Component's template:\n- It is inserted into the component's tag.\n- It is rendered with access to the component instance's viewModel.\n- <content> tags within the template act as insertion points for the source elements.\n\nAdditionally it says: \n\nUse the <content> element to place the source content in the component's element within the component's template.\n\nSource: http://canjs.com/docs/can.Component.prototype.template.html\nWhile the documentation doesn't explicitly state that a <content> tag can reside within an {{#each}} block, I can't see how it could have been interpreted that it wasn't. Especially since it uses the terminology \"insertion points\". \n. @justinbmeyer How would <user-template> differ from <content>?\n. I'm struggling to understand also. Some pseudo code would probably go a long way here. \n. Upon revisiting this issue, I'm starting to think the issue is that passing a comparator to the .sort() method directly isn't overriding the predefined comparator on the can.List. \nI'll put a test together to see if that's the case. \n. If I had to guess, I'd say that's the issue: http://jsbin.com/gicuji/embed?js,console\nIn the previous version of the sort plugin, did the comparator passed to .sort(newComparator) override the configured .attr('comparator', oldComparator)?\nI'm not sure why we even handle this case at all. It's not documented. \nAnyway, here's what I think we should do: \n- Move the contents of sort to _sort\n- When .attr('comparator', value) is set, call _sort\n- Redirect .sort(value) calls to .attr('comparator', value) thus updating the comparator and re-sorting the collection\nAfterwards any inserts will be made based on the last comparator set, which in the JSBin above would be the string passed to .sort()\nDoes that cover it @gsmeets?\n. Thanks for the clarification @gsmeets. I'll take a look at this as soon as I can. \n. This was speculated to be closed in #2257, but @gsmeets added more context after it was written. \nThis is still an open issue. \n. @justinbmeyer Can you confirm I got this right? I double and triple checked but it's one of those \"too good to be true\" situations. \n. It looks like the call stack error has to do with the number of arguments passed to .apply(). and how many times that number of arguments is passed as a result of a single call. \nIn this example you can see that 41590 arguments isn't too much for a single .apply(), or even when .apply() results in a another .apply() call. But if .apply() is called 3 times in the same stack, the max call stack error is thrown:\nhttp://jsbin.com/gumehe/edit?js,console,output\n. So, the sort plugin calls can.List.prototype.push with .apply() and can.List.prototype.push calls Array.prototype.push with .apply(). That's how we're hitting the \"Max call stack size\" limit. \n. The only way to solve this issue is to limit the number of times apply is called with huge arrays in the stack. \nSplitting up the arguments list and progressively passing them to push is less performant. \nReimplementing can.List.prototype.push in the sort plugin is unmaintainable.\nThe only solution I can come up with is to only redefine the push method on a can.List instance once a comparator is set, which will only happen after initialization of the list. Unless it's defined on the constructor's prototype. In that scenario it can likely be done in setup or init. \nHowever, since this issue has only come up in benchmarks and JSBin demos I'm going to put it on the back burner for now. \n. I don't suspect so. Triggering \"change\" events is fine. Binding to them should be avoided. \nThe sort plugin triggers \"add\" events in the same way can.List.prototype.splice does: \nhttps://github.com/canjs/canjs/blob/master/list/sort/sort.js#L382\nhttps://github.com/canjs/canjs/blob/master/list/list.js#L334\n. Simplified example: http://jsbin.com/lurunep/edit?html,js,output\n. https://github.com/canjs/canjs/blob/master/list/sort/sort.js#L236\nI suppose that's not entirely true. You can sort a list without setting up bindings if you don't provide a comparator. \n. Closed via #2399. \n. In my case serialize was set to true. \n. I've done some work on default value generators, but I can't remember why we store the resulting default values on the constructor: https://github.com/canjs/canjs/blob/a3b566ceb93dc60e4f1e909f9a27123b4ff55771/map/map.js#L192\n. Closing because this issue won't be addressed in 2.3. Look for the fix in ^3.0.\n. Previously related issue: https://github.com/canjs/canjs/issues/1874\nThe reason the current test doesn't expose this issue: https://github.com/canjs/canjs/commit/9d44086b50882c6e7c815b0781f83bc44037a5cf#diff-4400cee85d2d4c68912da22739d81521R89\n. FYI. This branch was tested in a working app and appeared not to introduce any issues. \n. Looks good to my eyes. Thanks @imjoshdean!\n. I'll have to get back to you on this. I can't quite remember right now. \n. Here's what I can tell you: \n- The _computedBindings object was being populated after the defaults where processed\n- Committing properties to .attr() while processing defaults meant _computedBindings needed to be defined earlier on, so it was moved to setup\n- can.List and can.LazyMap define their own setup method \n- From what I can tell can.List and can.LazyMap do not call can.Map's setup method\n- Since _computedBindings is no longer defined in _setupComputes, anything that extends can.Map with its own setup method is now responsible for defining the _computedBindings object\n- Instead of defining _computedBindings in all of the setup methods it may have made more sense to simply call _setupComputes before _setupDefaults\n- Calling _setupComputes before _setupDefaults didn't seem like an option at the time because _setupComputes appeared to be dependent on the defaults:\njs\n  var defaultValues = this._setupDefaults(obj);\n  this._setupComputes(defaultValues);\n- In reality _setupComputes isn't actually using any of the arguments passed to it  \nI think I've talked myself into moving _computedBindings back into _setupComputes, removing the _computedBindings definitions in can.List.setup and can.LazyMap.setup, not passing defaults to _setupComputes, and changing the order that _setupDefaults and _setupComputes are being called. \nTheoretically that should all work just the same. \nStandby for a new commit. \n. Scratch all of this: \n\nI think I've talked myself into moving _computedBindings back into _setupComputes, removing the _computedBindings definitions in can.List.setup and can.LazyMap.setup, not passing defaults to _setupComputes, and changing the order that _setupDefaults and _setupComputes are being called.\nTheoretically that should all work just the same.\n\nThat won't work at all. What we want is for _computedBindings to be defined early on before we call _setupDefaults and then to run _setupComputes after all of the defaults have been processed/defined in _setupDefaults. \nUnfortunately this means _computedBindings needs to be defined in anything that extends can.Map and provides its own setup method. \nSorry for the confusion. \n. In my playing with this branch I noticed that isComputed was no longer a boolean and was uber confused. Glad that's cleared up. \n. There's probably a cleaner way to write this. I didn't spend much time on it. \n. @justinbmeyer Am I right to assume that this is a reasonable default? It seemed correct based on how I understand can.batch.batchNum to work. I wondered if it should be added to the other event objects created here and here also. \n. @daffl Is it okay that I'm testing the internal API of the sort plugin this way?\n. My previous batch handling was a joke, which inspired the can.batch.debounce discussion here: https://github.com/bitovi/canjs/issues/1708\n. TODO: Add test; ~~Create issue~~;\n. Justin agreed this is fine here, but not so in the other two places. \n. I always thought the start() should be called once the async bit had ended, and before the test. Is there a particular reason you did it this way, or does it not really matter?\n. ",
    "tdorie": "Aah, sorry I missed that. That's the fix, thanks!\n. ",
    "m-mujica": "@daffl I wrote a test for this https://github.com/bitovi/canjs/tree/test-1178, not sure how do you want to proceed, should I merge this PR in my branch? \n. It seems that this issue was not totally fixed. In this branch I've created a new failing test with more complex computes. \n\n. yes @daffl I have a custom parseModels, you can see it in the test I created https://github.com/bitovi/canjs/pull/1663/files#diff-f5751f58f80284ca23c4942749b780feR1450. \n. @matthewp done!\n. @matthewp @justinbmeyer I like the 'regular helper' version better, I changed the deprecation notice to read like:\n'Use the routeUrl helper instead like href={{routeUrl prop=value}}'\nIs that better? \n. @matthewp assertion as in steal.dev.assert? throw an exception if can.List is not available?\nIf that's the case it feels odd to me, if the default behaviour we want is to make arrays properties observable we should just make sure can.List is available in can.Map and instead provide an option to prevent those arrays to be observables (which I think you can do using the define plugin already).\nIf we don't think it's an issue to change the default behaviour (before 2.3.9 you'd get observables from arrays by default) I guess warning is ok.\n. Fixed in 2.3.16 (I just tried it out and worked as expected).\n. I'll have to check but most of the observables in the initial list already have the log function. Will take a look at the missing ones and update this. . Justin did this, so I think we should close. . Added tests and fixed demo code indentation // @chasenlehara \n\n\n\n. Closed by https://github.com/canjs/canjs/pull/3816 . can-validate demo is broken b/c it depends on can-stache-converters, once that package is updated and added to canjs we need to make sure can-validate demos work as expected.. can-stache-converters is up to date now and demos are working as expected:\n\nI'm going to merge once the build finishes.. you forgot to remove this (I think?)\n. yeah, I'll do that right away.\n. ",
    "cedricalfonsi": "Hi @asavoy,\nThanks for this contribution I'm roaming around trying to figure out why I'm not able to render templates that have already been preloaded.\nI can fix my can version with the code I found in your commit.\nBut why this commit hasn't been applied to other branches ?\nMaybe there is another solution to solve that issue ?\n. ",
    "Tarabyte": "@daffl The idea with \"services\" is really cool. Actually it can be an implementation of Repository Pattern. Which allows to hide storage and transport level details from the model itself.\nQuite usefull for advanced scenarios like unit-testing or switching between online and offline application mode.\n. I've set up a fiddle. Not sure it is confirming the issue. http://jsfiddle.net/tarabyte/8g0qv4xj/\nWell, the memory consumption is growing both cases. But not as if it was leaking something having model instances in closure.\n. > It should probably not be used to create application wide types.\nSuppose I have lots of different models having different properties I need to convert using the same logic. For example createdAt, modifiedAt, beginTime, endTime etc that should be converted using say momentjs. What is wrong with defining an application wise moment type?\n. Ping\n. @justinbmeyer Thanks. I'll try to upgrade to the latest 2.3.x\n. Fixed in 2.3.\n. ",
    "danwoods": "This can be fixed by adding elements = elements || can.view.elements; in can.stache.js around line 14 (after the opening of __m11(). Just one option...\n. ",
    "zalad": "nope, i can not afford that.\nif i could i would not troll about :)\ni'm still a parasite, though strongly inclined to become useful for open source i'm using.\nin the light of fast CommonJS adoption by browsers i were thinking it's not a big deal for initiated gurus to do a cjs package\n. steal-tools looks promising.\nwill give it a try, though i'm totally pleased with webpack at the moment and no lot of steal-tools docs/examples over there.\nalso hoping steal-tools will give me less nuts than jspm :)\n. :+1: \nthanks,\neagerly waiting :)\n. ",
    "no-glue": "I am just trying to detect created event in the component. It is not triggered at the moment.\n. When model is created there should be message \"new\" in the console. There isn't at the moment.\n. ",
    "minsooshin": "@justinbmeyer, I already have my routes handling with:\njavascript\n'route': function(data) {\n    if (data.widget) return;\n    this.handle_route(data);\n  },\n  ':widget route': function(data) {\n    if (data.sub) return;\n    this.handle_route(data);\n  },\n  ':widget/:sub route': function( data ) {\n    if (data.id) return;\n    this.handle_route(data);\n  },\n  ':widget/:sub/:id route': function(data) {\n    this.handle_route(data);\n  }\nIt doesn't work.\n. ",
    "reno1979": "Hi daffl, didn't expect you to answer but glad you did! \nI expected that can-value would behave consistent regarding preselected values.  It would be a big bummer if it doesn't do so on multi-selects :(\nbuilding a custom two-way binding helper like can-value doesn't make any sense. By the way using stache I can't read values outside the each loop (not supported). \n. The fiddle has been minimized even more \n. Hello Justin, \nI posted this a while back, to be honest I'm a bit unsure. \nToo long ago :/\n. Ok same here, thank you for the milestone fix :) \n. @justinbmeyer Ok I understand. Glad to see it added to the new milestone, thank you.\n. ",
    "rkojedzinszky": "+1\n. ",
    "Macrofig": "I thought the solution was to not do this at all and, instead, have the check for jQuery abstracted from can.component. Or are you saying to use can.$.fn in the mean time?\n. Whew. Freaked out for a sec. Nope, it still works like you said: https://github.com/bitovi/canjs/blob/master/view/parser/parser.js#L97\nTo your point, though, if I were to hand write HTML like\nhtml\n<li>First\n<li>Second\nthe browser would attempt to self close them on it's own (sometimes?). But even if it doesn't, I kinda feel like Stache should just render what I give it, as broken as my template could be.\nIf the plan for Stache is to continue with auto-closing tags then it will need to process more than just inline vs block. There should be checks for all the content categories and their exceptions. That just sounds like a lot of maintenance to me, though. I mean, it would be cool but a lot of work.\nThe other option is for Stache to render what I give it and let the browser handle the broken parts.\n. You want to use can-validate now. It has the ability work with any validation library (with a provided shim), and the errors object is now an observable. \nThat said, it also uses the errors property on the map instance. I created an issue to make can-validate's can.Map plugin work with any property you desire.\nAlthough, the errors object is a can.Map which means you can manipulate it if you wish. I'm trying to make a JSbin to demonstrate this.\n. Ok, check this out: http://jsbin.com/difibeq/edit?html,js,console,output\nSo you can manipulate the errors object when you instantiate your map but you have to remember that the validation library expects a certain structure. In this case, I'm using validate.js. ValidateJS returns a map of arrays when validating multiple properties.\nQuick explanation why: Each item in the map is mapped to a property. Because each property can have multiple validation rules, there can be multiple errors. These errors are represented by the array.\nSo, you can push your own data into the errors object if you need to, just make sure you stick with the structure of your chosen library.\nOne last note, can-validate will clear the errors object if it finds that the validation rules it is aware of have all passed.\nThis brings me to a question, @pYr0x, why do you need to manually edit the errors object?\n. Docs were up at some point here: canjs.github.io/can-validate/\nI was trying to fix the demos and it looks like I broke the whole thing. I'll fix it today. https://github.com/canjs/can-validate/issues/8\n. @justinbmeyer Is it not possible for Can to fire off any events after batch is completed? Is it a problem of knowing which setter to call? \nI guess I'm not exactly sure why I need to add code that checks for the batch. Passing properties around like this should be consistent regardless of the nesting, no?\n. > Passing properties around like this\nI was referring to my jsbin example... of passing properties up/down a deeply nested set of components.\n\nIt's certainly a bug\n\nOk, that's what I was trying to figure out. I wasn't sure if you were saying this is correct behavior or not. Thanks!\n. Regarding my secondary issue...\n\nFurthermore, in using the workaround, I found out that my sub-component cannot be the one to define an object; it must be defined by the top most component. \n\nI did a bit more poking around on this and it seems to be unrelated so I'll create a separate issue, if needed.. \n. Yea, using after works but I have two concerns.\nFirst, the mental model for how this works is deceiving. I understand that there are multiple updates going on, even though the trigger for these updates is a single action. I feel like this is a confusing API.  (That said, I need to do test this out with latest 3.0 stuff to see if it is still an issue)\nSecond, is this behavior documented somewhere and maybe I just missed it? \n\nWhen a change triggers just one compute to update, we won't need to use after. But because we have nested computes, we need to use after.\n. Probably because it is a duplicate of #2433 Github was acting up when I created the first one.\n. I think that's probably the most common one. Looking at the MDN page for it, there's the frame specific values for target and there's also the download property that might be an issue as more people use it. https://developer.mozilla.org/en/docs/Web/HTML/Element/a\n. @justinbmeyer's comment explains what needs to happen in the CanJS repo.\n\nI think it would be helpful to describe the process of using bit-docs in the source repository as well.\nI'm assuming the docs should be added here?. There were a few tiny things to make notes of, but other than that, the above steps were fine.\n Here's a rough draft of what I noted down:\nhttps://gist.github.com/Macrofig/32b4070858b4dd1bee97a40b86f212bc. One other consideration I just thought of was adding linting to the build for each project. Either way, the first step is to discuss in the community if there is a packaged config we should use (like AirBnb's) or if we should just make our own; what changes we should make for our projects; etc.\n@chasenlehara Perhaps something we can discuss at the DoneJS contributors meeting?. Just want to reference Joel's work here for easy reference: https://github.com/donejs/developer-relations/issues/22. It looks like, if Unpkg is preferred instead, then only jQuery++ and Funcunit packages need work.. @matthewp Same goes for Rawgit (some libraries need work in order for them to work via the service). Although, I think Unpkg is easier to use.. I tried not to mention \"ecosystem\" exclusively because it should be helpful for every list.  As a compromise, though, I tried to use examples specific to \"ecosystem\".. D'oh. I knew there was a better name than \"module name\". Thanks!. Ohhhh... I can't believe I missed that!. Actually, it says...\n\nCreate a markdown file in the docs folder of source repo\n\nBut I was afraid that wouldn't be clear so I'm glad you stumbled there, though. I'll fix it.. ",
    "quirkles": "Ok, that makes sense, thanks for the quick and informative reply, I wasn't aware of that plugi, iill check it out, thanks. \n. ",
    "haluzator1": "Just have same problem.\n. ",
    "wishabhilash": "Thanks @daffl and @asavoy for the videos. Immense help. Appreciated!!! :)\n. Hi, I again have to reopen this issue. \nTemplate:\n<script type=\"text/mustache\" id=\"app-template\">\n<sock-app>\n    <h3 can-click=\"increment\">No way {{mycount}} {{name}}</h3>\n</sock-app>\n</script>\nComponent:\n```\nvar CounterMap = can.Map.extend({\n    name: \"wish\",\n    mycount: 0,\n    increment: function(){\n        this.attr('mycount', this.attr('mycount') + 1);\n    }\n});\nvar CounterComponent = can.Component.extend({\n    tag: 'sock-app',\n    scope: CounterMap\n})\n$(\"#graph-app\").html(can.view('app-template', {}));\n```\nSockJS (think of it as socket.io):\n```\n$(function(){\n    var SOCK = new SockJS(\"http://localhost:9090/sockjs/canjs\");\n    SOCK.onopen = function(){\n        console.log(\"working\");\n    }\nSOCK.onheartbeat = function(){\n    SOCK.send('o');\n}\n\nSOCK.onclose = function(){\n\n}\n\nSOCK.onmessage = function(message){\n    console.log(message);\n    **// I want to increment the component every time a message is received.**\n}\n\n})\n```\nI want to increment the number in the component every time a message is received. How can I do that???\n. Please ignore this. And my apologies for missunderstanding.\n. Thanks man... I will try using LazyMap and check for performance change. If required will definitely heed for stackoverflow and put a link here.\nEDIT:\nThis might sound silly but it seems I do not know how to use the can.LazyMap plugin. I mean how should I add it. My project is in requirejs. Thanks.\nRight now I have added it in define of my concerned app as \"can/map/lazy\". It throws TypeError in \"nested_reference.js\"\n. ",
    "andreichuk": "one more question: i did not notice any event that fires only once when multiple properties of can.Map are updated. why is that?  it would be convenient to have such an event. now i have to check batchNums :-1: \n. ",
    "JustinLove": "Huh.  I added render while debugging other stuff and didn't expect the behavior to be different.  At this point I've done too much with the component based system, but if it gets too painful I'll try switching to controls again.\n. Another way to do arrows, although I'm still not sold on arrows\nchild-prop{=\"}parentProp\"\nchild-prop{=\"parentProp\"\nchild-prop=\"}parentProp\"\n. I've feel like I've got a solved on paper type solution to half the problem; limited by my rather recent approach to the problem. It has a quality of cohesion I've felt lacking elsewhere, likely biased by inventing it. No doubt some people will dislike this as much as I dislike the other options. ;^)\nPrinciples\nplain old html looks like plain old html\nprop=... should be an dom property and ...=\"foo\" should be a plain string\ncode looks like code\nIt would be nice if it was similar to {{}}, but doing that without colliding with the existing {} has proved daunting\nProposal: An attribute or value prefixed with . is read as a property reference into the implied context.  The implied context on the left is viewModel, and on the right the template context.\nSpecial contexts can be used before the dot: $ for the the dom element, and * for the reference scope.\nClearly identify values being subscribed to\nProposal: : is an object reference \"doubled-down\" to a binding. ! is a variant for events.\nClearly identify values that can be changed externally\nProposal (not happy with part yet): I've tried to extend the expanded syntax, e.g. ~complete($element.checked), with an \"implied value from other side\" using _; However I feel like the postfix (_) is a bit verbose, and perhaps semantically unnecessary.\n| Type | Example |\n| --- | --- |\n| 0 way - viewModel | .child-prop=\"foo\" |\n| one way - viewModel - parent to child | .child-prop(_)=\":parentProp\" |\n| one way - viewModel - child to parent | :child-prop=\".parentProp(_)\" |\n| two way - viewModel | :child-prop(_)=\":parentProp(_)\" |\n| event - viewModel | !child-event=\".parentMethod()\" |\n| event - DOM | $!click=\".parentMethod()\" |\n| one way - DOM - parent to element | $.el-prop(_)=\":parentProp\" |\n| two way - DOM | $:el-prop(_)=\":parentProp(_)\" |\n| one way - reference - child to reference | :child-prop=\"*.ref(_)\" |\n| two way - reference | :child-prop(_)=\"*:ref(_)\" |\n| two way - reference shorthand | *:ref |\n. ",
    "RunsFor": "Hey there! Great job!\nAre there any plans to make 2.1.5 release in the nearest future with this pull request included?\nWe are using this framework in our daily work and really like it! Thanks.\n. ",
    "fychinesepjj": "@justinbmeyer \nI have post my question on stack overflow, the link is http://stackoverflow.com/questions/27938986/canjs-component-tempate-dom-live-binding\nThanks for your reply!\n. I have solved the problem, but not the best, Maybe someone  have a better way.\n- I changed my template, add a new component called <messageitem>\n- <messageitem> will load another template \u2014\u2014 message.mustache\n- Every <messageitem> will trigger inserted event when inserted into <messagelist>\nThe new component:\n``` javascript\ncan.Component.extend({\n  tag: \"messageitem\",\n  template:can.view('/static/web/tpl/mobile/message.mustache'),\n  events: {\n    inserted: function(el, ev){\n     // Can-click can not satisfy my needs,\n     // because i call the third-party module to bind click event\n    // this module will be called repeatedly, not the best way\n      reloadModules(['accordion']); \n    }\n  }\n});\n// To load message_list.mustache\ncan.view(\"/static/web/tpl/mobile/message_list.mustache\",{}, function(content){\n  $(\"#message-list\").html(content)\n});\n```\nStatic html:\nhtml\n<body>\n<div id=\"message-list\">\n....\n</div>\n</body>\nmessage_list.mustache:\nhtml\n<app>\n   <messagelist deferredData='messagesDeferred'>\n   {{#messages}}\n  <messageitem></messageitem>\n  {{/messages}}\n   </messagelist>\n   <next-prev paginate='paginate'></next-prev>\n   <page-count page='paginate.page' count='paginate.pageCount'></page-count>\n</app>\nmessage.mustache:\nhtml\n<dl class=\"am-accordion-item\" >\n...\n</dl>\nThanks.\n. ",
    "Rendez": "@justinbmeyer it would be great to see that plugin. I find it easier to insert components within this event, as in components which act as layout composers (building subviews). I can better test my components when the views are split into separate files.\nThanks!\n. ",
    "Aldredcz": "Not sure, the define 'hack' is the case i want achieve.\nThe case with Components: \nImagine, you have a Component used by many types of parent Components (lets call it Widget). This Component accepts 3 parameters and modifies them. Since you can't pass computes directly into Component, you probably pass can.Map like:\njavascript\ncan.Map({\n    param1: value,\n    param2: value,\n    param3: value\n});\nOne Widget has all these parameters in one object, so you can just pass it as it is. \njavascript\nvar stuff = new can.Map({\n    // many params here including our 3\n    param1: value,\n    param2: value,\n    param3: value\n    // and many many more\n})\nBut another Widget using the same Component could have these parameters spread over many different objects.\nIn this situation, this would be really good solution:\njavascript\nvar params = new can.Map({\n    param1: obj1.compute('param1'),\n    param2: obj2.compute('param2'),\n    param3: obj3.compute('notEvenNamedParam3')\n});\nAnd any change made would also be propagated to the original obj1/obj2/obj3 can.Map.\nAbout syntax, one more idea, what about extending can.compute prototype with a method, which would produce same compute, but when passing to can.Map, it would have described functionality?\njavascript\nvar params = new can.Map({\n    param1: obj1.compute('param1').methodName() // e.g. insertable?\n});\n. ",
    "web-mech": ":+1: \n. :+1: \n. ",
    "marknadig": ":+1: http://jsfiddle.net/digger69/t1b20j2b/4/\n. ",
    "rasjani": "Also example in http://canjs.com/docs/can.mustache.tags.escaped.html under Looking up values in parent contexts doesn't have the closing '/' for chapters helper.\n. janimikkonen@RASJani ~/src/mixradio/web/tvapp (upgrade)$ npm install canjs\ncanjs@2.2.0-alpha.9 node_modules/canjs\njanimikkonen@RASJani ~/src/mixradio/web/tvapp (upgrade)$\nLatest canjs does not warn about deprecation.\nALSO do note that canjs@2.2.0-alpha.9 does contain  dist/cjs  but can@2.2.4 doesn't so switching to can package will break builds for those who use webpack/browserify etc .. \n. Yeah, it was caching issue.. \n. ",
    "tomgreever": "Ok, I've got the HTML / CSS designs ready and will add to the repo soon. Some notes...\nCommon Header\nContains a nav with hover and active states:\n\nCommon Breadcrumb\nTo show the nested routing:\n\nHomepage Hero\nJust the content for a static homepage. \n\nRestaurant List\nWith possibility of showing \"Open\" or \"Closed\" depending on the time of day. \n\nRestaurant Header\nBoth the restaurant page and the order form should share this header: \n\nRestaurant Page\nJust a static page. We don't really need this page (as far as UX goes), but it helps to have the form one level deeper for the routing part of the demo. Get more ipsum dummy copy here http://www.lipsum.com/feed/html\n\nRestaurant Order Form\nWith tabs for lunch and dinner. Select the correct tab depending on time of day. Dynamically update the total $$ as the user checks the boxes. Error states require a class=\"has-error\" on the parent element.\n\nOrder History\nJust a simple table with Delete\n\nLoading State\nThis is just <div class=\"loading\"></div>\n\n. To add to the design: \n- Status / notification indicator to the main menu for Orders\n- 3 states for order: Delivered, New, In Progress plus a control for changing the state\n  - Filter / sort based on the columns?\n. @BigAB can you post a screenshot of what the placeholders look like? \n. @moschel - just noting that @karlshaver is available now when you get to this. Just tag/assign him \n. Same here. @moschel not sure why this was closed. @BigAB included it in a long list of issues that needed a designer, so let me and @karlshaver know if you still need help.\n. Curious why this one was closed? @karlshaver is available to work on it, if needed.\n. Same here. @moschel not sure why this was closed. @BigAB included it in a long list of issues that needed a designer, so let me and @karlshaver know if you still need help.\n. @brianmoschel when you get to this again, let me know because I think we might want to have Eric (who drew the turtle) to do a custom illustration for this too.\n. Here's one suggestion including the tiled buttons for the guides. \nDo we really want screenshots of the app? Or would company logos suffice? \nhttp://share.bitovi.com/TJOOEZ/#g=1&p=v3_home\n\n. @justinbmeyer or @brianmoschel can I get the hello world jsbin code example to include in this?\n. Ok, I added a screenshot of a JSBin and moved things around. I'm uncertain if this is the look we're going for here, so any feedback from @justinbmeyer is welcome. I've not included company logos yet. Trying to avoid over designing it, so as a result everything is just kinda on the page. I'm not sure what to do next.\nhttp://share.bitovi.com/TJOOEZ/#g=1&p=v3_home\n\n. @brianmoschel what do you think about something like this? This adds a border and dropshadow, which makes them look nicer. And for the ones that include a url, we can fake a browser address bar. This won't change the markdown other than wrapping the section in a parent div. Other than that it's just CSS, so it should still be simple to update.\n\n. oh and it scales nicely. \n\n. This should be closed by #2757 - I'm not seeing the changes on GH pages yet, but closing anyway and trusting it's gtg since the PR was merged. @brianmoschel @justinbmeyer here is the first one. If this is good to go, I'll finish the rest!\n\n. \n. \n. \n. @justinbmeyer @chasenlehara Here are a few other options that still appeal to the informal/handwritten style. \nPlease let me know what you think today. If the font is the only thing left, I'll probably pick one and submit a PR today if I don't hear back. We can always update it afterwards, but I want to get this in before the weekend.\nOriginal\n\nDifferent Options\n\n\n. My recommendation is the first one. \n\n. @brianmoschel or @justinbmeyer can you review this and https://github.com/canjs/bit-docs-html-canjs/pull/194 and let me know when it's all merged and visible? I don't have a good way of checking my changes from bit-docs in this repo, so I'm just :fingers_crossed: that it's all good.\n. I've asked Eric Merced to draw some stuff for this to make it better. \n. @justinbmeyer would you mind providing feedback on these? I can submit a PR real-quick like if you think they are gtg\n\n\n\n. Hey @chasenlehara I'm not aware of any resources we could provide that would solve for this. You mentioned prototypes. We don't have a master prototype for CanJS. (Maybe we should? But what would it include?) Usually, we prototype one thing per issue and then those get closed with the ticket. What tools did you have in mind? And is this for a Bitovi designer? Or any designer, including someone outside Bitovi who wants to contribute?\nUsually, the best thing to help someone get up-to-speed on a project like this is a style guide showing all the UI elements, the CSS and HTML needed. You know, the whole DocCSS thing.\nOutside of that, I can't think of anything else a designer would need to start contributing . But maybe I'm not understanding the need. . ",
    "nickradford": "Sounds great @daffl. Do you have any guidance around documentation so I can add some for this feature?\n. @marshallswain I agree, but I'm coming from an Angular background where that syntax is familiar. I'm totally open to the idea, but syntaxes are sometimes hard to agree upon. \n. @akagomez I can change property to attr later today.\n. ",
    "Gomez": "ping @akagomez as i am an other gomez :)\n. ",
    "kylegifford": "Looks like this is an issue with set not saving correctly. If I modify set to the following in the demo, it works:\nset: function (newVal, setVal) {\n    console.log('set:', newVal);\n    setVal(newVal);\n    return newVal; \n}\n. @daffl @justinbmeyer I'm a bit stuck on this, could use your input. The contents of the {{#if}} are returned on https://github.com/bitovi/canjs/blob/master/view/stache/mustache_core.js#L114, but for this case, it is something like \"can-click=\"foo\" \". I believe what needs to happen is instead of just returning this as a string, it should compile and hydrate the contents of the result. Something like:\nvar result = rendererWithScope(newScope, newOptions || parentOptions, parentNodeList || nodeList);\nif(result) {\n    // result.compile().hydrate()\n}\nDoes this seem like the right place to put this code? If so, what method can be used to compile and/or hydrate the result? Also, is there anything that needs to be done to remove the binding once \"can-click=\"foo\" \" is removed from the DOM? Thanks!\n. Rebased, should be ready to merge now.\n. It looks like this behavior was fixed in #2277. In my specific case, I had a reference to an object as part of two properties being set with can.route.attr. Because one of them did not have serialize: false set, the object was errantly stringified. Setting serialize: false on the second property fixes this issue after upgrading to v2.3.17. This issue can likely be closed.\n. \n. I'd like to echo my support for @brianmoschel's proposal, and push for a marketing effort for RVM in parallel to prioritizing an architecture direction.\nIn working with current and future Bitovi clients, \"using React\" is almost guaranteed to come up in conversation. What business people (and even some higher level technical managers) don't fully understand is that React is best when it's handling views/components, and that the state management framework is generally agnostic from that. They just want to \"use React\" (for any number of reasons), and RVM gives us a chance to push the benefits of CanJS/DoneJS while still \"using React\".\nAlong with a rebranding, website, docs, explainer videos, I think it would be worth a \"publicity tour\": promoting this through in-person meetups in the React community, espousing the benefits of CanJS coupled with React (longevity, solid tooling within DoneJS, more personal OS support, etc).\nI'd also like @bgando, @mickmcgrath13, and @DesignByOnyx's opinions on how RVM has fared in production with CanJS to date, and any recommended changes.. ",
    "patrickclancy": "+1 would love this feature\n. ",
    "Luanre": "No, I'm setting up unit-test environment to test my components' scope methods.\nI used browserify before and yes, canjs could be included using:\njavascript\nvar can = require('can');\nBut for plugins you still need to write:\njavascript\nrequire('can/dist/cjs/object/object');\n. ",
    "nlundquist": "this isn't needed considering can-import can be used to amend a viewModel during rendering. In this example we import the module 'src/demo-data' as 'data'.\n<can-import from=\"src/demo-data\" {^value}='data'/>\n{{#each data.default}}\n     {{message}\n{{/each}}\n. I did look into this and it doesn't appear to be IE specific. I made some fiddles that demonstrated consistent types returned by CanJS attr and DOM getAttribute on IE & Chrome in several cases. \nHowever attr.get has a case where instead of the attribute value being written and retrieved on the element using 'getAttribute' / 'setAttribute' it's actually written as an object property on the element object itself, i.e.  'el[prop] = val;'. In that case it would be easily conceivable that an number type might be stored and retrieved rather than a string as might be expected when getting an element attribute. I'm trying to determine when this case is used and reverse engineer from that a reasonable test case that reproduces an error like the one reported.\n. I've looked at this a bit closer and I'm still stumped on how an issue like this could be happening. Do you know what attribute was being accessed when this occurred? \nThe case that I mentioned, where element object property modification is used instead of setAttribute, is only for very specific attributes, those that the browser has some special handling for already, for example: \n- class\n- value\n- src\n- style\n- innertext\n- textcontext\nWith the exception of value, you wouldn't expect those attributes to ever be an integer, perhaps a string representation of one. All other attributes are set/get by the standard DOM methods which by all accounts appear to work consistently between browsers.\nI did some testing with 'element.value' modification across browsers and it worked consistently, implicitly converting numeral values to strings, e.g\n<input type=\"text\" />\nvar input = document.querySelector('input');\ninput.value = 5;\nconsole.log(input.value); // \"5\"\nI just can't think up a test case using one of the special cased attributes mentioned above resulting in can.attr.get returning an integer. Any ideas? \nIt could still be that getAttribute itself still returns number types in some edge case, but we haven't found any indication of that.\n. Yeah I've just had that case come to mind and confirmed the error. Like I mention above, the 'value' attribute has special handling that causes it to be written to the element object 'value' property rather than be written like an attribute. This is fine when the element is an input tag. 'inputtag.value = 5;' implicitly converts any non-string type being set to a string, however this is not true for non-input elements and attr.set / attr.get doesn't expect that.\nSo modifying my example above to reproduce the issue:\n<div class=\"test\"></div>\nvar div = document.querySelector('div.test');\ndiv.value = 5;\nconsole.log(div.value); // 5\n// or\ncan.attr.set(div, 'value', 5);\nconsole.log(can.attr.get(div,'value')); // 5\nI'll be making a modification so the special case for 'value' attribute modification is only used for appropriate form elements.\n. I've done a short review and the elements with 'native' value attributes are:\nbutton, option, input, li, meter, progress, param\nMy results for which elements do implicit type conversions and which link the values between 'element.value' & 'element.getAttribute(\"value\")' are shown in this JSBin: http://jsbin.com/hehuqenoya/1/edit?html,js,console\nThe results themselves are rather surprising. In Safari, button, option, input and param all do implicit string conversion, and all elements but input link the value of the element property to the attribute. This behaviour is consistent with Chrome and IE 11. Only exception is that in IE the value property of the progress element isn't linked to the attribute, but I don't think that's a case worth making special effort for.\nI think a reasonable fix, maintaining current behaviour as much as possible, would be to only access 'element.value' for the elements that do implicit type conversions, preventing this case where a number type is returned unexpectedly. However, I'm wondering what the impact would be of removing the special case for 'value' all together, and just using the typical setAttribute/getAttribute behaviour. In my brief testing it accomplishes the same thing, and additionally, though setting 'input.value' doesn't in turn update the value returned by 'input.getAttribute', 'input.setAttribute' does update the value of 'input.value' keeping the state of the element more consistent. Eg: http://jsbin.com/ripinorezu/edit?html,js,console,output\nI'll try removing the special case for value tomorrow and see if it has any obvious impact on our test suite.\nIf anyone has background or insight regarding the purpose of that value attribute special case, if its intended for say backwards compatibility, cross browser compatibility or performance reasons, please join in this thread.\n. I've answered my own question regarding 'input.value' vs 'input.setAttribute(\"value\", ...)'. It's a quirk of the DOM specs that I was unfamiliar with. For text input types, the HTMLInputElement 'value' property is the current value of the component, while the 'value' attribute is mapped to the defaultValue property. The defaultValue property, when changed, updates the value property, but of course not vice versa. \nSee http://zvon.org/xxl/DOM2reference/Output/HTML/attribute_value_HTMLInputElement.html for an excerpt from the DOM 2 spec regarding this.\nSo due to that distinciton my revision will continue to special case setting the value attribute for input elements so we correctly alter the value property instead of the defaultValue via the attribute. For all other elements value will be treated like a normal attribute. \n. That couldn't be the only change however? The core issue is that an integer type is returned unexpectedly from attr.get, which should always return a string. If that were the only change an integer type could still be set / returned on, for example, an li element reproducing the issue at hand. If I'm understanding you correctly. This JSBin demos the issue I'm thinking of http://jsbin.com/sacipomewa/1/edit?html,js,console\n. Why do you prefer the property over the attribute in the absence of the defaultValue issue unique to input elements?\n. To summarize some discussions we've been having internally, the issue is that live.js requires a string value for attributes, so it can do manipulations as expected. However, we've concluded that non-string  return values are a valid case, so to resolve the issue at hand we'll cast the value to a string when required.\nIt took some thought to determine why returning a type other than a string from can.attr is correct.  The key is, rather than simply accessing attributes, can.attr is designed to get / set state for components which requires, at times, manipulating component properties, which may be any type.\nConsidering that, we'll be simplifying this behaviour, increasing it's documentation and renaming can.attr & elements.getAttr to something that more accurately reflects the behaviour.\n. I think I see what you mean. In later versions of the docs that page doesn't exist and there is no way to navigate to the documentation of the members of the prototype like then, always, etc. even though the docs are generated for them, like http://canjs.com/2.3-pre/docs/can.Deferred.prototype.always.html. I'll be investigating this.\n. Closing to resubmit in #1907.\n. This has been resolved as part of the fixes for #2198 and #2203, included in Can 2.3.11. @ilyavf could you confirm your original case is now working?\n. Yes, but only with further changes. The new override to __type only coerces the values to strings. In can.route.attr keys are being string coerced, this would have to be added to a different backing map override.\nIt would also be a slight change from the existing route.attr behaviour, if it checked serializable.\n. My last commit does this. Removes the .__type override & route.attr behaviour. Moves all string coercion to a .attr override. Resolved an issue I had when originally trying to do this in an .attr override.\n. I think we should add the same properties to native promises. Or at least document that this support is only for deferreds.\n. awesome thanks for looking into this\n. assigning to @daffl for review\n. I'm going to be making additional changes to this behaviour, the string conversion shouldn't be run for properties that have a can.map.define serialize implementation that will be perform a string conversion of its own\n. closes #3429 . I'd love if as part of this effort we modify bit-docs / documentjs to warn about broken links (and add a strict mode flag that would return a failed exit code if broken links were found). Fair enough. Looking at the diffferences to what you linked, you think I should just remove the isFunction(catch || fail)? Or should I also check if the argument is an object or function?\n. Yeah this works with jQuery deferreds.\n. Totally right.\n. this is already listed in the bit-docs dependencies so this wouldn't need to be here. should probably change this to a published version number before merging. not sure this is needed since it's part of the bit-docs dependencies. ",
    "kkkdb": "None yet\n. ",
    "gazlu": "There is I just pulled it. I tried also downloading zip ball from http://www.javascriptmvc.com/dist/javascriptmvc-3.3.zip butno luck.\n. ohhh you mean canjs version, got it\n. ok, thanks.\n. ",
    "notdang": "It used to be a form, and I simplified it down to a span with an input, and got the same result as in the fiddle. When being used in development mode (template being loaded via an async call), the live binding works. But for production, I am using can-compile to precompile/preload the templates and it doesn't work. \nI couldn't find a solution to this, so I switched to stache and got it working in both development and production mode. \nI think I can lose the issue, since I got it working with stache and mustache will be deprecated. \n. ",
    "rmannibucau": "Well I'm not yet familiar enough to be able to import a http js in these tools but here a starting point:\n```\n\n\n\n\n\n\n\n\n    <select can-value=\"model.flag\">\n        <option>Select something...</option>\n        <option value='true'>True</option>\n        <option value='false'>False</option>\n    </select>\n    <button can-click=\"{ doLog model }\">Log</button>\n\n\nvar Model = can.Map.extend({\n    define : {\n        flag : { type: 'boolean', set: function (val) {\n            return val === true ||\u00a0val === 'true';\n        }}\n    }\n}, {});\nvar model = new Model({ flag: true });\n$(\"#out\").html(can.view(\"flag-view\", new can.Map({model:model, doLog: function (m) {\nconsole.log(m.serialize());\n}})));\n\n\n\n```\nSo you have a basic select with a simple model having a single field \"flag\" which should stay a boolean. In this snippet I used define (which is ignored so maybe I did something wrong) but using old syntax (convert/attributes) leads to the same.\nMy goal is to keep flag type to boolean (this way the sent json is always valid for the server).\nTo test it click on \"Log\" before changing any value, you get a correct json then change it to false or true and you'll get a string instead of a boolean.\nHope it helps\n. ",
    "kostix": "Tried including the latest html5shiv before loading jquery.js and can.jquery.js -- it made no difference.\n. OK, here's a jsbin which works in modern FF and Chrome, and fails in IE8 with the error I have reported (actually, it first fails on something coming from jsbin but it's easy to click that error away when in the developer mode).\n. ",
    "lukewhyte": "It appears we lost it in this commit: https://github.com/bitovi/canjs/commit/37111e1c6990c8a4fc244f1da65d6ac502a85876 \nPrior to this it was stored in route/docs/ dir, which I believe was removed in the same commit.\n. @justinbmeyer: thanks!\n. ",
    "mickmcgrath13": "What are some use cases for using a Control over a Component (You mentioned that we should be using components 90% of the time;  What is the other 10% for)?\n. Of course, if you're rendering html server-side, there might be a better way to approach the situation anyway ;)\n. That helps a lot, thanks!\n. ..using either $element or @element instead of %element does work.  So is this just a documentation change?\n. Can you use super?\njavascript\n   var ChildMap = ParentMap.extend({\n      define: {\n        inheritedProp: {\n          get: function() {\n            return this._super.apply(this,arguments) + 1;\n          }\n        }\n      }\n    });\n. Under Create Todos -> \"Update the html tab to:\",\nIt says\n\nUpdates the todo\u2019s name with the \u2019s value using {^to-parent}\n\nbut the code is using {($value)}.\nShould we:\n1) change the code to use {^to-parent}\nOR\n2) change the description to say {(two-way)}?\n. The field doesn't clear properly unless we use two-way;  So, that answers that. :)\n. Closing - We won't do videos until after the release\n. In response to:\ncan we remove contentType: 'application/x-www-form-urlencoded'\nIn the JSBin, it works whether it's there or not.\nFurther, with the contentType set to application/x-www-form-urlencoded, the Content-Type response header is application/json, but there doesn't seem to be a request header set.\nRequest with contentType: 'application/x-www-for-urlencode'\n\nRequest without contentType\n\n. Without contentType: 'application/x-www-for-urlencode', the creation of messages results in an error:\nOPTIONS - http://chat.donejs.com/api/messages\nResponse Headers:\nHTTP/1.1 200 OK\nServer: Cowboy\nConnection: keep-alive\nX-Powered-By: Express\nAccess-Control-Allow-Origin: *\nAccess-Control-Allow-Headers: X-Requested-With\nAccess-Control-Allow-Methods: DELETE, GET, HEAD, POST, PUT, OPTIONS, TRACE\nAllow: GET,POST,PATCH,PUT,DELETE,HEAD\nContent-Type: text/html; charset=utf-8\nContent-Length: 30\nEtag: W/\"1e-CVFZ0nFHwOziYlbMcCG31A\"\nVary: Accept-Encoding\nDate: Mon, 07 Nov 2016 17:49:58 GMT\nVia: 1.1 vegur\nRequest Headers:\nOPTIONS /api/messages HTTP/1.1\nHost: chat.donejs.com\nConnection: keep-alive\nPragma: no-cache\nCache-Control: no-cache\nAccess-Control-Request-Method: POST\nOrigin: http://null.jsbin.com\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36\nAccess-Control-Request-Headers: content-type\nAccept: */*\nReferer: http://null.jsbin.com/runner\nAccept-Encoding: gzip, deflate, sdch\nAccept-Language: en-US,en;q=0.8,pt-BR;q=0.6,pt;q=0.4\ncurl\ncurl 'http://chat.donejs.com/api/messages' -X OPTIONS -H 'Pragma: no-cache' -H 'Access-Control-Request-Method: POST' -H 'Origin: http://null.jsbin.com' -H 'Accept-Encoding: gzip, deflate, sdch' -H 'Accept-Language: en-US,en;q=0.8,pt-BR;q=0.6,pt;q=0.4' -H 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36' -H 'Accept: */*' -H 'Cache-Control: no-cache' -H 'Referer: http://null.jsbin.com/runner' -H 'Connection: keep-alive' -H 'Access-Control-Request-Headers: content-type' --compressed\nResponse (200 OK - empty but caused error):\nXMLHttpRequest cannot load http://chat.donejs.com/api/messages. Request header field Content-Type is not allowed by Access-Control-Allow-Headers in preflight response.\n\n. Closing - We won't do videos until after the release\n. Issue to handle the Withdrawal tests: canjs/canjs/issues/2712\n. So, it turns out that Google code prettify actually works in batches so as to not block the browser for too long.  Unfortunately, the length of time for a batch to be allowed to run seems hardcoded into the code at 250 ms, and the same is true for the time to wait.\nSee here and here.\nI can think of a couple ways to resolve this\nOption 1 - Turn off batching\nSolution\nThere is an option on the window that can be set to disable the async/batch feature:\n/**\n * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\n * UI events.\n * If set to {@code false}, {@code prettyPrint()} is synchronous.\n */\nwindow['PR_SHOULD_USE_CONTINUATION'] = true;\nNotes\nI think this would be sufficient, but it would potentially slow down the page for bigger jobs.\nOption 2 - Use prettyPrint's done callback\nSolution\nThe prettyPrint method takes a couple of parameters, the first of which is a function to be executed when the prettifying is complete.  (See here).\nWhere we call the prettyPrint method, we could provide a return value of a Deferred which is resolved within prettyPrint's done callback:\n```\n    require('./prettify-engine');\n    require('./prettify.less');\n    var $ = require('jquery');\n    module.exports = function () {\n        var doneDeferred = $.Deferred();\n        var codes = document.getElementsByTagName('code');\n        for (var i = 0; i < codes.length; i++) {\n            var code = codes[i];\n            if (code.parentNode.nodeName.toUpperCase() === 'PRE') {\n                code.className = code.className + ' prettyprint';\n            }\n        }\n        prettyPrint(function(){\n            doneDeferred.resolve();\n        });\n    return doneDeferred;\n};\n\n```\nThen where we loop over the packages, we look for a deferred (has .then) and wait for that to resolve before proceeding.\n```\n                function processPackages(packageIndex, callback){\n                    var i = packageIndex || 0,\n                        packageNames = Object.keys(window.PACKAGES),\n                        packageName, packageResult;\n                if(i === packageNames.length){\n                    if(typeof callback === 'function'){\n                        callback();\n                    }\n                    return;\n                }\n\n                packageName = packageNames[i];\n                if (typeof window.PACKAGES[packageName] === 'function') {\n                    packageResult = window.PACKAGES[packageName]();\n                    if(packageResult && packageResult.then){\n                        packageResult.then(function(){\n                            processPackages(i+1, callback);\n                        });\n                    }else{\n                        processPackages(i+1, callback);\n                    }\n                }else{\n                    processPackages(i+1, callback);\n                }\n            };\n\n            // go through every package and re-init\n            processPackages(0, function(){\n                init();\n                setDocTitle();\n            });\n\n```\nNotes.\nThis solution would allow non-docs related scripts to do their thing.\n. @justinbmeyer, should it be bit-docs-generate-html or bit-docs-html-canjs ?  \nThe code I have above was in bit-docs-html-canjs.\n. I've updated the description and first comment accordingly.  I'll knock that out tomorrow\n. Will do\n. Here's an example using can.viewModel: http://jsbin.com/heruzil/1/edit?html,js,output\nHere's an example using stache's binding syntax: http://jsbin.com/mosatad/1/edit?html,js,output\nAn important thing to note is that the defaults property of a can.Control's static props must be a plain object.  If it is a can.Map instance, it will be converted into a plain object anyway.  In the second example I gave, the map instance was moved to a property on defaults called componentScope following the pattern described here.. Are you referring to this line?\njs\n    var componentVm = can.viewModel(this.element.getElementsByTagName(\"demo-component\")[0]),\nIf so, can.viewModel just takes an element, so you can get your component in whatever way is appropriate for your project.  For example, you can use jQuery and a classname:\njs\nvar someSpecificComponentElement = $(this.element).find(\".some-specific-component-classname\")[0],\n      componentVm = can.viewModel(someSpecificComponentElement);\nPlease let me know if this isn't what you mean.\nI will say, though, that it might be a better approach to use the second example as it is more state-based and requires less manual interaction with the DOM.. Sure!\nAssuming you've got a can.Map defined in your control's options like:\njs\nvar DemoControl = can.Control.extend({\n  defaults: {\n    componentScope: new can.Map({\n      dropdown: \"some-value-for-the-dropdown\"\n    });\n  }\n}, {\n/* ... */\n}\n..and your Stache template is child-to-parent (or two-way) binding that property like:\n<your-component {^dropdown-property}=\"dropdown\" />\n..then you can listen to the dropdown property change in your control like this:\njs\n  \"{componentScope} dropdown\": function(componentScope, event, newVal, oldVal){\n    console.log(\"componentScope's dropdown property changed\", arguments);\n  }\n(you can think of \"{componentScope} dropdown\" in this case as similar to this.options.componentScop.attr(\"dropdown\").bind(\"change\", function(){})\nIf you're wanting to 'listen' for when an item is added to or removed from a list, you can do that like this:\njs\n  \"{componentScope.controlAr} add\": function(vm, newVal, oldVal){\n    console.log(\"something added to the controlAr property\", arguments);\n  }\nHere is an example: http://jsbin.com/natowod/1/edit?html,js,output. NP!. Is this issue resolved, then?. The property you want to listen to would need to either be a compute or nested within a can.Map like this.. NOTE: If this is wrapped up prior to the search feature getting launched, the bit-docs-html-canjs version will need to be pinned to 0.4.15 because 0.5.0 has a build error.\nThose urls are hard-coded as http in the .md file: https://github.com/canjs/canjs/blob/master/docs/can-guides/commitment/recipes/file-navigator-simple.md#what-you-need-to-know\nAll links that point to canjs.com:\n...should be changed from this format:\n[can-stache](http://canjs.com/doc/can-stache.html)\nto this format:\n[can-stache]. it's not clear to me how to convert this\n[CanJS documentation](http://canjs.com/)\ninto a non protocol-specified version.. Also not sure about this one:\n[Array shorthand](http://canjs.com/doc/can-define.types.propDefinition.html#Array)\n(the #Array part)\nalso\n[ViewModels](http://canjs.com/doc/guides/technical.html#MaintainableMVVM). Here's a branch: https://github.com/canjs/canjs/tree/3259-hardcoded-http-links\nstill need to change our outgoing links to https, too\n funcunit.com\n stealjs.com\n bitovi.com\n etc. Hash syntax support for bit-docs links\n Issue\n PR\nOnly pushState to same protocol\n Issue\n PR\nThis issue (https links not working)\n Issue\n PR. Some issues found so far:\n [x] The href attributes in the search results aren't being generated properly\n [x] When going from one page to another (pushState?), the search disappears. The href disappearance was due to improper scoping during the es6 -> es5 conversion (changed something to self that should have stayed this).\n\u2013 I have a fix for this in bit-docs-html-canjs\nThe search was disappearing because the init is run every time we \"change pages\" (pushState) - which re-initializes the search.  When the search is initialized, it makes an ajax request to window.pathPrefix + '/searchMapHash.json'.\n..the problem is that the window.pathPrefix exists within a script tag on the newly ajax-retrieved page, but the value isn't making it onto the window (not being executed?) prior to the search being initialized.\nWhile we should fix that (somehow?), it did highlight an opportunity which is: if we do not find the searchMapHash but we do have one in localStorage, we can just use that and continue as normal.\n\u2013 I have a fix for this in bit-docs-html-canjs. Maybe a fix could be instead of doing this:\n<script type=\"text/javascript\">\n  window.pathPrefix = '{{pathToDest}}';\n</script>\n...we use a data attribute on a div:\n<div data-path-prefix=\"{{pathToDest}}\" />\n..or on the body\n<body data-path-prefix=\"{{pathToDest}}\">\n...\n</body>. Previous two issues have solutions\nNow, there's:\n [x] Responsive search. Issues mentioned above:\n [x] broken links\n* [x] responsive search. https://github.com/canjs/bit-docs-html-canjs/pull/251. ..so, now there's another issue... :/\nWith the latest update, #250 - mentioned in the last comment (bit-docs-html-canjs v0.5.4), the doc/ isn't at the beginning of the search results as it should be (seems to work in bit-docs-html-canjs...). TLDR:  I agree that we should push for Marketing, Dev, and publicity efforts.  The order of it probably needs some debate, but, as Kyle mentioned, it's almost certain to come up in conversations with clients/possible clients, and I want to be confident in our ability to swoop in and save the day.\nRe: Brian's next steps\nI agree that we should have a standalone page for it (probably the new name, too).  As Kyle mentioned (and as I've experienced), there's not really an understanding from clients and their devs that React itself isn't a full web application solution, and that fact should probably be highlighted clearly on the site.\nI think we can have some of\n\nContent around why it's better to have powerful viewmodels when building a react application and comparing that to flux/redux data flow - articles and videos\n\n...but, to Justin's point, it seems like we'd need to know what the API looks like to compare it to anything or create articles/videos about it.  A standalone homepage could probably be vague enough to not care too much (at first), I think:\n\nLook!  RVM!  State Management for React!  Use it! It's great!\n\n..but it definitely wouldn't have a lot of substance.\nTechnically, I don't have too many opinions beyond the idea that whatever direction it takes should be easy and appealing to adopt for existing React users.  I personally don't really care what it looks like because I tend to work with whatever's available, but a lot of people do/will have opinions about it's used.  I think that if our goal is adoption (what else would it be?), we should approach this with the mindset of 'how would a solid React developer expect this to work?'.\nI'm not entirely sure what that means because I haven't actually been in the code too much, but I've heard, for example, about the non-distinction between props and state in the current implementation being a problem (not how a React dev would expect it to be).  I also remember working with can-react, and we had to do some odd things to make that work.\n(apologies for any lack of logical cohesion in this post - I didn't have the time to reread as well as I had hoped). ",
    "gregfleury": "I was away on project work. nlundquist is entirely correct -- we found the same situation. I will provide follow up source shortly.\n. We initially had this mustache template:\n<ul class=\"dropdown-menu dropdown-menu-left js-contextAction-dropdown\" role=\"menu\">\n            <li class=\"dropdown-header\">Actions</li>\n            {{#contextActions}}\n            <li role=\"presentation\" value=\"{{Index}}\"><a role=\"menuitem\" tabindex=\"-1\" href=\"#\">{{Name}}</a></li>\n            {{/contextActions}}\n        </ul>\nAll we did was change the li elements value={{Index}} to action-index={{Index}} to fix the problem.\nSo you cannot use \"value\" implicitly on an element -- which in itself is not a bug, but an API toolkit usability quirk with CanJS. Internally, something is happening with the Value param that is causing this error that I repeated earlier.\n. ",
    "canac": "Yes, that makes sense, thank you for clarifying. I hadn't thought about the possibility of memory leaks with this feature. You might consider tweaking the documentation to prevent other people from becoming confused about this feature like I was.\n. ",
    "opolyo01": "Yes, it will break this way too.\n. Yes, your tests passing because you don't pre-render a component into the DOM.  If instead of creating a fragment, you would do this It wouldn't call helper\n// var frag = can.stache('<call-helper></call-helper>')();\n  // console.log(frag.firstChild.firstChild.nodeValue);\n  $(\"#out\").html(can.view(\"appMustache\", {}));\nWhere template is loaded from the .html file\n<script id=\"appMustache\" type=\"text/mustache\">\n  <call-helper></call-helper>\n</script>\nOn the side note I realized that I cannot steal('can' on its own to get access to can/stache, I also need to load a stache file.  Not sure if it has anything to do with an issue.\n. I render can.component from the html page, rather then create a fragment inside of the same file.  Could be steal related issue?\n. ",
    "gmahomarf": "Has there been any progress on this issue? I'm having a similar issue, but I'm using RequireJS instead of Steal. If I register the helpers with can.stache.registerHelper, everything works fine. If I add them to the helpers property of a new Component, they don't work.\nThis is (roughly) the code I'm using:\n.js\ncan.Component.extend({\n        tag: 'some-tag',\n        template: can.view('path/to/view.stache'),\n        helpers: {\n            helpMe: function(arg1, options) {\n                return arg1 === 'help' ? options.fn() : options.inverse();\n            },\n        },\n        simpleHelpers: {\n            simplyHelpMe: function(arg1) {\n                return 'help';\n            },\n        },\n....\n});\nEverything else in the view renders properly.\nI debugged my code, and the helpers never even get called (they get called when they're registered globally).\nEDIT: using v.2.3.1\n. @pYr0x I'm using stache only, but what does that have to do with anything? \nFrom docs (link):\n\nDifferences from can.mustache\ncan.stache is largely compatable with can.mustache. There are three main differences:\n- Passes values in the scope to can.Component with {key}.\n- section renderers return documentFragments.\n- Element callbacks like {{(el) -> CODE}} are no longer supported.\n\nI'm not passing values to any child components, I'm not using Element callbacks, and I assume section rendering works fine, because the section rendered by the helper I'm using displays something (always defaults to falsey, so it's not working entirely as expected, but it's rendering nonetheless). I don't see how that would affect my code\n. @justinbmeyer alright. I'll see if I can create a test case to reproduce the issue. \n. @justinbmeyer  I'm still working on getting you a test case that matches my current setup (maybe I screwed something up), but I think @pYr0x may be on to something there. After looking at his jsbin code, I decided to test something in my code. All my templates are in .stache files and I set them to each Component's template with can.view(url). I renamed one of them to .mustache, and the Component's helpers started working. Changed back to .stache, broken.\n. @justinbmeyer all my test cases pass, so I can't reproduce my issue outside my own code. I've got to get this project out, so for now I've worked around it by using require's text plugin to load the templates as text and then set each Component's template to can.stache(requiredTemplate). As soon as I'm done with this project, I'll work on creating a test that fails the same way my code is failing. Thanks\n. I'll try it, thanks. I was using a call expression as detailed in the routeUrl helper docs. They should be updated.\n. @justinbmeyer just to be clear, you're suggesting I do the following?:\n.html\n<a href=\"{{routeUrl({page: 'home'}, true)}}\"> Link</a>\n. @justinbmeyer  I ran several tests this morning. Each example has the stache template where routeUrl was used. Below that are values of the arguments sent to the routeUrl helper (see code) and the resulting value for the href attribute.\nTo avoid cluttering the issue comments, I created a gist with the results: https://gist.github.com/gmahomarf/92d97265694f0c1a77ec\nI hope this helps\n. Any news on this?\n. @justinbmeyer For now, I've got my code working as I need it, so this is no longer urgent for me. Ping me whenever you have time to take a look at this, and I'd love to help fix it. Thanks!\n. ",
    "pilou": "Well yes and no :)\nSorry for my bad english...\nI would say yes because the feature is written there, and I am willing to use any good code made by the open source community. But,\nI say no because, can-connect seems like (dont be mad at me, I had just a couple of minutes on the github site, and at the downloaded source):\n- the build is failing - and I need this for production in two weeks\n- not well documented, if I learn it from reading the codes I have to teach my colleagues, rather sending just a link to the doc page\n- looks like Its not adding fetures to can.Model, but creates another implementation, that sould be learned, and not all the features in can.js are in can-connect. Also I cant see how to implement on top of can.js. But maybe its only in my head because I cant see the big picture without proper documentation.\n- I would like better a plugin implementation with less dependency\nIm sorry if my statements are incorrect, but I'm not familiar yet with can-connect, and it seems like I wont without a documentation like can.js has.\n. Maybe the biggest problem, is that on the github page (https://github.com/canjs/can-connect), there is no link to the documentation site.\nThe downloaded, and extracted github zip has an error: index.html redirecting to /doc/, to a non-existing dir.\nNow I can see http://connect.canjs.com/doc/can-connect|can|model.html so I'm (starting to) understand what does it do, you can imagine reading this page https://github.com/canjs/can-connect with the lack of knowledge.\nThe less features perception was beacuse of that. Because I couldnt navigate to the \"subdocumentation\" like the /can-connect|can|model.html page.\nI see that in can.js 3.0 the can.Model will be deprecated (seeing it here http://connect.canjs.com/doc/can-connect|can|model.html), and I feel really bad about that, because we started implementing an application migrating from JMVC with ejs, 3-4 weeks ago. On the can.js http://canjs.com/docs/can.Model.html page there was no sign of deprecation, so our brand new code will be deprecated, and we didnt know about that.\nDo I guess right that can.js will deprecate the Model, and let can-connect handle it, so can-connect will do the CRUD commications with the server and everything connected with that feature, and can.js will be an application framework without saving any data?\nI could not find the behavior that I mentioned in my original question, could you point me to it?\nOr its not imlemented but can be done with connect.behavior(\"my-behavior ...\"\n. I could go to subdocumentation because I wasnt aware of the http://connect.canjs.com/ its not mentioned anywhere (not even on the github page https://github.com/canjs/can-connect) :)\nSo I could only see only the github page, what is basically the can-connect index page (http://connect.canjs.com/doc/index.html) without proper formatting.\nI've seen the migration guide, and yes ist pretty straight forward.\nThe migration wont be a problem.\nMy problem is the lack of info on can.js that can.Model will be deprecated and I should use can-connect instead.\nSo my work hours migrating could go directly to implementing can-connect instead and getting more familiar to it.\nCan you verify that can.Model will be deprecated and can-connect will be the \"official\" server saving thingy for can.js?\nThe isSaving function is perfectly good for me. More than good. I will save a lots of lines of code in my controls/components :)\nYou should consider also imlplementing a isCreating, and a isUpdating function so if sbdy needs exactly know \"how\" its being saved.\nSo in a Todo app you could write 'Creating todo', or 'Updating todo' instead the boring :) 'Saving...' with small effort.\n. Combining isNew and isSaving, is good enough. I think there is no need for the shortHand functions.\nThe example you written should be on http://connect.canjs.com/doc/can.Map.prototype.isSaving.html page.\nI will release our app with can.Model extending, but after the release I will start experimenting with can-connect, replace our Models with can-connect/can/model or can-connect/can/super-map I dont know yet.\n. So, can you think about this plz?\n. ",
    "ilyavf": "Looks like this is happening for canjs 2.2.2, and for 2.2.6 it does not.\n. It does not matter, its case insensitive (we lower case it anyway).\n. Closes #1872 and #1874.\n. @daffl If return null gets removed then calling scopeData.value.apply will cause an exception since scopeData.value is undefined.\n. Fixed with this PR\n. The test is still breaking in 2.3.10. \nI am not sure if its similar to #2186, because in this case a primitive property of vm is updated correctly (see the 1st jsbin), and only can.Map (can.List) property of vm is not. And this only happens inside a batch.\n. The test requires a component being inserted into DOM to fire the inserted event. I was not able to come up with a test without this requirement.\n. A scenario without a batch: if the visibility property has a setter then stache does not update the template:\nhttp://jsbin.com/fekava/edit?js,output\n``` javascript\nvar vm = can.Map.extend({\n    define: {\n        isVisible: {\n            value: false,\n            set: function(val){ return val; } //<<< without a setter it works fine.\n        }\n    },\n};\nvar myComponent = {\n    define: {\n        myMap: {\n            value: {test: 'old-value'}        // primitive values are OK.\n        },\n        myProp: {value: 'old'}\n    },\n    events: {\n        inserted: function(){\n            this.viewModel.attr('myMap.test', 'new-value');\n            this.viewModel.attr('myProp', 'new');\n        }\n    }\n};\nvm.attr('isVisible', true);\n{{#if isVisible}}\n    \n        {{myMap.test}}             {{! old-value will not be rerendered with new-value }}\n    \n{{/if}}\n```\n. +1\n. hm... maybe its as simple as this:\n<input type=\"checkbox\" ($checked)=\"isChecked\" ($indeterminate)=\"isPartlyChecked\" />\n. This PR also fixes #2319 Fix autorender template tag attributes.\n. @matthewp I removed can/map/app usage, so its back to pre-39c08a state:\n// This will create a new scope (if it does not exist) and attach it to `el` with data:\nvar scope = can.viewModel(el);\nTests are there.\n. @matthewp Locally I am getting stuck on amd tests (4159 - on the same test as Travis)\nRunning \"testee:steal\" (testee) task\n....... \n22850 passing (4m)\nRunning \"testee:amd\" (testee) task\n... 4159 dots ... and stuck\nChecking the pre-existing commit for tests now...\n. @matthewp: Woohoo, the CI is passing. So, I had to import can/map/app from inside autorender.js. Do you have an idea why?\n. Reference: https://github.com/canjs/canjs/issues/2892. ",
    "joe-crick": "Added test to show that the plugin works with can.route: https://github.com/canjs/can-interrupt/commit/dbc68580f29de6f8cb5064195b2f9360abaf8fc4\n. OK. I'll resolve, and resubmit.\n. I am on a Mac. Magic must have happened, because I see the JSBins working now.. ",
    "boris-chernysh": "I already tried it, but it does not work :) \nBecause values of url in request params in method sub changing to null, but when lines commented out, sub works well and return correct url.\n. I already tried it, but it does not work :) \nBecause values of url in request params in method sub changing to null, but when lines commented out, sub works well and return correct url.\n. http://jsbin.com/resowi/edit?html,js,console\n. http://jsbin.com/resowi/edit?html,js,console\n. ",
    "smoothlikejazz": "No problem, thanks for your reply Matt, \nSo we have a lot of controllers created via var x= can.Control({...},{...});  and testing in IE8 when these lines are hit, IE is throwing an error stating \"Object doesn't support this action\",and browser halts and the controller is not created; but then when updating our code base with using can.Control.extend({...},{...});  which is our current workaround will work in IE8.\n. Not in this module directly.\n. setting debug point right before, can.Control statement.\ntype of can.Control returns \"function\",\nI am testing in IE 11 Browser, running Developer tools set to IE8. wondering if this is causing different behavior\n. Thanks for your help, ill try that, and also try upgrading our current version of can.\n. We have updated our source code to use the new syntax. yet in our situation, we have customers using the old syntax for UI customisation and just want to make sure that our customer wouldn't have any issues.\nafter digging into the issue more, the console.log.apply is causing the error, stemmed from https://github.com/bitovi/canjs/blob/master/construct/construct.js#L496\nin the snippet below in IE8 console.log.apply is throwing error \"Object doesn't support this action\"\n_logger: function (type, arr) {\n            if (console.log.apply) {\n                console[type].apply(console, arr);\n            } else {\n                console[type](arr);\n            }\n        }\n. I have replaced the above code in can/util/can.js with the below code snippet and it is working now\n_logger: function (type, arr) {\n            // test for console support\n            if (typeof console == \"object\") {\n                // test for console.log.apply support in IE8\n                if (typeof console.log == \"object\") {\n                    console[type](arr);\n                } else {\n                    if(console.log.apply){\n                        console[type].apply(console, arr);\n                    } else {\n                        console[type](arr);\n                    }\n                }\n            }\n        }\n. ",
    "scaryzet": "Thank you. I'll try that. My mistake I didn't read about viewModel in the docs: http://canjs.com/docs/can.Component.prototype.viewModel.html Pretty powerful, I like that.\n. ",
    "uzlov": "we will have functionality more the same with models (in my case - I use id for caching)\n. ",
    "whdigger": "For translate I need to fork the project, checkout v2.3.0-pre.13, and translate folder guides, and later send pull request\nTell me how to generate the html page via documentjs ./node_modules/.bin/documentjs  which must be the generation of project files?\n. @whitecolor I feel you want to help me?\n. ",
    "fantanamihai": "Thank you for a quick response :thumbsup:\n. Thank you Justin for your comments (and label) that underlines best what this issue is about.\n\nWhy would someone use both this.on and an action to listen to the same event.\n\nThat is a confusion rising from documentation, because there is no clear statement to differentiate between this.on bindings and actions.\nJust to conclude, please include in the documentation your statements, accompanied by example. It will be clear for everyone what are some of the foundations Can has (especially for beginners):\nBindings:\n\nActions are rebound\nbindings with this.on are not rebound.\n\nAn action is anything that:\n\nhas a special character\nin $.event.special\na DOM event like \"click\", \"keypress\", etc\n. Yeah sure, I'll try to do that if everyone is ok with this. Thanks anyway for the invite\n.    Thank you guys for your comments.\n   Nice coincidence @tarabyte https://github.com/canjs/canjs/issues/2085#issuecomment-156443443: the 'moment' type was the problem which made me rise this issue :smiley:\n   On the other hand, @justinbmeyer you showed how simple and clear (at least for me) the issue of using common custom types on define can be solved. And this is the way I will do it.\n   However, Can is a framework implemented to work in the restrict-less javascript environment. I think Can gives you the choices. For me, the choice of not using can.define should be left on the programmer shoulders. I would documented it with warnings. \n. Yes, I understand that. But it is a common thing to have two different items (obtained from different endpoints), but with the same id, isn't it?\n. For example two tables, cats, dogs, having references to a common genre table. By chance, when getting a cat and a dog having the same genre male id, but backend processing adds different attributes to male genre.\nThis is the situation the above example is used.\n. @pYr0x great resource donejs forum. My bad, I didn't searched enough.\n@rjgotten thank you for your replies.\nJust to be clearer on the subject. I thought that store had an issue using 2 endpoints, returning an object (with the same id), which was then passed to a the model method of can.Model. Each endpoint processed data differently so even if the 2 endpoints used the same model, I was getting erroneous results.\n@pYr0x I didn't want to use define { Type: C }, because I had a custom C.model, so it was necessary to pass through this method\nIn the end I used @rjgotten observations, and for one of the enpoints, I used another model for c attribute, extended from C model.\n. @justinbmeyer Great to have a feedback.\n  I always consider stability and flawless functionality in normal conditions (documentation based) as major attributes for a good framework. I chose CanJS because I sense it tends towards this.\n  The way I see it there are two paths:\nmodifiers will still be considered an asset for the framework\nin the near future, modifiers will be out of the framework\n  If is still of interest, I am willing to fix it, but I need assistance, as I don't fully understand CanJS internals.\n. Agree. But doesn't this mean that _logger should be \"officially\" patched on master also?\n. \n",
    "dhs3000": "Thanks, I will look take a look at, sounds interesting.\n. ",
    "robert-sbin": "Yes, find same error. Found that in Chrome you get always \"Choose a City\" during in Firefox you get \"Loading ...\". \nI think Browsers don't wont to load Files with ajax-calls like \"can.ajax\". \nSo I changed my fixtures.js to:\n``` javascript\n  can.fixture('GET /api/cities', function(request, response) {\n  var citiesbystate = [\n    {\n      \"name\": \"Green Bay\",\n      \"state\": \"WI\"\n    },\n    {\n      \"name\": \"Milwaukee\",\n      \"state\": \"WI\"\n    },\n    {\n      \"name\": \"Chicago\",\n      \"state\": \"IL\"\n    },\n    {\n      \"name\": \"Peoria\",\n      \"state\": \"IL\"\n    },\n    {\n      \"name\": \"Detroit\",\n      \"state\": \"MI\"\n    },\n    {\n      \"name\": \"Ann Arbor\",\n      \"state\": \"MI\"\n    }\n  ];\nvar cities = [];\n  citiesbystate.forEach(function (city){\n    if (city.state === request.data.state) {\n      cities.push(city);\n    }\n  });\n  response({\"data\": cities});\n});\n```\n. Yes, it works if you open the index.html over a http-server. When you open the index.html over the file-open dialog of the browser, it doesn't.\n. ",
    "espretto": "great! could you do the same for canjs/amd/can/view/mustache.js > window.Mustache?\n. I'm currently upgrading from 2.1.1 to 2.3.1. the global Mustache still leaks.\n. ",
    "prashantsharmain": "@justinbmeyer Sure, how about Thursday (12/17) ? We could set it up at the same time we have the contributor's meeting.\nIf I manage to find a fix before that, I'll share an update.\n. @justinbmeyer I added the following test to component_test.js:\n```\n    test(\"%root property should not be serialized inside prototype of can.Component constructor (#2080)\", function () {\n        var viewModel = can.Map.extend({});\n    var comp = can.Component.extend({\n        tag: \"foo\",\n        viewModel: viewModel,\n        events: {\n            \"inserted\": function () {\n                ok(!this.viewModel.serialize()['%root'], \"serialized viewModel contains '%root' property\");\n            }\n        }\n    });\n\n    var template = can.mustache(\"<foo/>\");\n\n    can.append(this.$fixture, template());\n});\n\n```\nI then added the following to \\canjs\\map\\define\\define.js (lines 358-359) to make this test pass:\ndelete serialized['%root'];\nreturn serialized;\nThe test passes with this fix, but I also get the following failure:\nTests completed in 333942 milliseconds.\n374 assertions of 375 passed, 1 failed.\ncan/component vdom: %root property should not be serialized inside prototype of can.Component constructor (#2080) (1, 0, 1)Rerun37806 ms\nDied on test #1     at makeTest (http://localhost:8000/component/component_test.js:1534:3)\n    at http://localhost:8000/component/component_test.js:1559:3\n    at stealInstantiateResult.execute (http://localhost:8000/node_modules/steal/steal.js:5806:32)\n    at linkDynamicModule (http://localhost:8000/node_modules/steal/steal.js:3547:32)\n    at link (http://localhost:8000/node_modules/steal/steal.js:3407:11)\n    at Object.execute (http://localhost:8000/node_modules/steal/steal.js:3726:11)\n    at doDynamicExecute (http://localhost:8000/node_modules/steal/steal.js:1949:25)\n    at link (http://localhost:8000/node_modules/steal/steal.js:1997:24): Cannot set property previousSibling of # which has only a getter\nSource: \nTypeError: Cannot set property previousSibling of # which has only a getter\n    at insertFragment (http://localhost:8000/node_modules/can-simple-dom/lib/simple-dom/document/node.js!eval:28:32)\n    at DocumentFragment.Node.appendChild (http://localhost:8000/node_modules/can-simple-dom/lib/simple-dom/document/node.js!eval:82:11)\n    at Function.jQuery.extend.buildFragment (http://localhost:8000/node_modules/jquery/dist/jquery.js:5672:23)\n    at jQuery.fn.extend.domManip (http://localhost:8000/node_modules/jquery/dist/jquery.js:5939:22)\n    at $.fn.domManip (http://localhost:8000/util/jquery/jquery.js:165:23)\n    at jQuery.fn.extend.append (http://localhost:8000/node_modules/jquery/dist/jquery.js:5758:15)\n    at Object.can.(anonymous function) as append\n    at Object. (http://localhost:8000/component/component_test.js:1551:8)\n    at Object.Test.run (http://localhost:8000/node_modules/steal-qunit/qunit.js:1303:18)\n    at http://localhost:8000/node_modules/steal-qunit/qunit.js:1463:10\nI'm not sure why can/componet dom test passed, but can/compoment vdom test fails. Any clues? Does it have anything to do with the following call:\ncan.append(this.$fixture, template());\n. @justinbmeyer It does work with can.stache. Is this fix acceptable? Please note that the example that @shcarrico had shared uses can.mustache.\n. @daff @justinbmeyer I have fixed the jshint error, but I'm having problems running grunt test on my machine:\nc:\\projects\\canjs>grunt test\nLoading \"changelog.js\" tasks...ERROR\n\n\nError: Cannot find module 'oauth-sign'\nLoading \"docco.js\" tasks...ERROR\nError: Cannot find module 'docco'\nLoading \"build.js\" tasks...ERROR\nError: Cannot find module 'winston'\nLoading \"export.js\" tasks...ERROR\nError: Cannot find module 'jsonfile'\nLoading \"live-reload.js\" tasks...ERROR\nError: Cannot find module 'chokidar'\nCannot find module 'brace-expansion'\nError: Cannot find module 'brace-expansion'\n    at Function.Module._resolveFilename (module.js:338:15)\n    at Function.Module._load (module.js:280:25)\n    at Module.require (module.js:364:17)\n    at require (module.js:380:17)\n    at Object. (c:\\projects\\canjs\\node_modules\\fileset\\node_modules\\minimatch\\minimatch.js:10:14)\n    at Module._compile (module.js:456:26)\n    at Object.Module._extensions..js (module.js:474:10)\n    at Module.load (module.js:356:32)\n    at Function.Module._load (module.js:312:12)\n    at Module.require (module.js:364:17)\nLoading \"testee.js\" tasks...ERROR\nError: Could not register command from file check-coverage.js\nWarning: Task \"testee\" not found. Use --force to continue.\n\n\nAborted due to warnings.\nWhen I try running tests in browser by pointing to http://localhost:8000/test/, all the tests pass. My observations:\n- I see 5 iframes, but only 3 test suites are executed: CanJS jQuery tests, CanJS jQuery (2.x) tests, CanJS YUI tests. The other 2 iframes stay blank.\n- I don't see the jshint error here at all. I see all test cases passing in the 3 iframes.\nAm I missing something here?\n. @daffl Is this good to be merged now? Sorry it took me a long time to get the tests running on my machine.\n. The build failure looks unrelated to the fix I made. I'm going to close the PR and then open it again. I expect this would trigger the Travis CI build again.\n. This is already fixed in 2.3.10. I'm going to close this.\n. @justinbmeyer Could you confirm if I'm looking at the right set of files where the fix should be made:\nFor mustache:\n- canjs/view/mustache/system.js\n- canjs/view/mustache/doc/mustache.md\nFor EJS:\n- canjs/view/ejs/system.js\n- canjs/view/ejs/doc/ejs.md\nAlso, which branch should the fix be pushed to? I remember you saying earlier that these changes shouldn't be pushed to the master branch.\n. @justinbmeyer can we pair up on this? I'm getting 8 test failures in stache_test.js when I incorporate the fix for #2309. Following is one such failed test case. (I'll continue to investigate in the meantime)\ncan/view/stache dom: Helpers can be passed . or this for the active context (2, 0, 2) Rerun\nExpected:   \"Justin is attending Reception\"\nResult: \"Justin is attending \"\nDiff:    \"Justin  is  attending Reception\" \" \nSource: \n    at Object. (http://localhost:8000/view/stache/stache_test.js:2346:4)\n    at Object.Test.run (http://localhost:8000/node_modules/steal-qunit/qunit.js:1303:18)\n    at http://localhost:8000/node_modules/steal-qunit/qunit.js:1463:10\n    at process (http://localhost:8000/node_modules/steal-qunit/qunit.js:1016:24)\n    at http://localhost:8000/node_modules/steal-qunit/qunit.js:186:5\n. ",
    "roissard": "I have written the test in 2.3.1 and can see the bug occurs. In the master branch the same test passes, so I will close the bug.\n. ",
    "roger-ng-helloworld": "Hi Justin,\nI'm using version 2.1.2 and I mean instances of classes. I seriously hope the instances of classes wouldn't cost that much because I'm not looking forward to merging some of the classes. Also, I'm using a lot of can.Map and can.List instances, would that be the reason why it's almost grinding to a halt on mobile?\nRog\n. ",
    "phillipskevin": "I don't know either. I updated that code to use a helper, but wanted to check in case this was intended to work.\n. I think the confusion is just that the docs point you to use {($value)} in place of can-value: http://canjs.com/docs/can.view.bindings.can-value.html.\n. Yep, and if there's a way to do radio buttons with the new binding syntax, we should add that too. When we discussed this before, @justinbmeyer, we decided the best way was to just use can-value for radio buttons.\n. @justinbmeyer, here is a simplified example: http://jsbin.com/dizuxanide/edit?html,js,output.\nIf you point me to the right place, I can attempt to put in a test.\n. @justinbmeyer the fix for https://github.com/canjs/canjs/pull/2189 doesn't resolve my issue. I should have time to submit a test for this tomorrow.\n. @justinbmeyer the test is on this branch: https://github.com/canjs/canjs/tree/if-partial-if-2186.\n. @justinbmeyer I've only seen it being used to load templates that are being used as partials. I'm not sure why it was done that way.\nThis question on gitter led me to look up the docs again to see if can.view.preload would help. That's when I had trouble finding the docs. Also, once reading them I really wasn't sure if it was applicable in the situation.\n. This was fixed already by https://github.com/canjs/canjs/commit/8a8a9bce9265f825d35eedb6a32d0546c81f2d4d.. This PR is no longer needed as https://github.com/canjs/canjs/issues/2317 was closed.. I closed https://github.com/canjs/canjs/pull/2438 since it was pointing to the master branch which now has the 3.0 code. @colin-tucows if you submit a new pull request to the 2.3-legacy branch we can get that fix into a 2.3 release.\n. \ud83d\udc4d I think this really helps clarify the uses.\n. @colin-tucows This was fixed in 3.0 to use el.setAttributeNS(...) for any attribute containing a :. Can you take a look at the fix here and apply the same solution? Also, the pull request will need to be made to the 2.3-legacy branch since master now has the 3.0 code.\n. In the isActive case, we know it is a helper and mustache-core only adds those arguments for Helpers. For the makeActive case we don't know whether it is a Helper expression, but we know it's not a Call expression.\n. Going to open  a new PR when this is working.\n. can-jquery is testing the canjs dependencies that it impacts, so it will not be tested here. can-vdom and can-zone are both using mocha for tests, so they won't be added now either.\n. This was done in a separate PR.\n. will open a new PR now that gruntfile is not being used.\n. iOS safari builds do not have the correct build ID to correlate with travis - reopening to add.\n. The built version of the tests now runs when you do npm test, which is run before publishing new versions to npm. Not going to add the built version of tests to CI for now as we think prior to publish is good enough and don't want to make CI take twice as long.\n. blocked by:\n- [x] https://github.com/canjs/canjs/issues/2681\n- [x] https://github.com/canjs/can-fixture/issues/79\n. https://github.com/canjs/canjs/pull/2685\n. https://github.com/canjs/canjs/pull/2685\n. https://github.com/canjs/canjs/pull/2685\n. https://github.com/canjs/canjs/pull/2685.\n. https://github.com/canjs/canjs/pull/2685.\n. This was caused by a websocket error when using Testee. Switching to a different http server resolves this issue in these browsers.\n. https://github.com/canjs/canjs/pull/2685\n. Yes, this is closed.\n. Looks like this was reverted, which is why IE 11 isn't showing up in the sauce labs badge.\n. Re-added by https://github.com/canjs/canjs/commit/8ab0b8e35ccf305188d510a98f8dffe86ea09ee1. Badge should be updated shortly.\n. All credit goes to @daffl.\n. Issues fixed in 3.0.10.\n. There are still a bunch of issues in this epic that are not complete, so I'm going to re-open this and rename it 3.5.0. I don't know if this is the best way to do it, but it's what we've been doing. If someone has a better approach for handling the \"next minor release\" epic let me know.. I see there's already an Epic for 3.5, so I'm going to re-close this. We'll just need to move these over:\n\n. Will handle all package updates in a new PR.\n. Will handle all package updates in a new PR.\n. Will handle all package updates in a new PR.\n. Will handle all package updates in a new PR.\n. Will handle all package updates in a new PR.\n. Will handle all package updates in a new PR.\n. This is done already.\n. Will handle updates in a new PR.\n. Will handle updates in a new PR.\n. Will handle updates in a new PR.\n. This was just test flakiness. Now that the CI process has been cleaned up all is good. Semver already covers this version, so closing this.\n. Force pushing this branch seems to have confused git. Will reopen.\n. Handled in https://github.com/canjs/canjs/pull/2736.\n. Looks like demos are broken again (or still?).\n. Will wait for 1.0.7.\n. https://github.com/canjs/canjs/pull/2744\n. CI failed because of the XHR Shim test which will be fixed by https://github.com/canjs/canjs/pull/2744. \n. can-view-callbacks adds the list of custom tags as can.view.callbacks._tags. I am planning to move this to a new can-tags repo and throw whenever namespace.tags is already set when can-tags is loaded.\nAlso, should can-observation throw whenever namespace.Observation is defined twice? Or should I create another repo for it's global state can-observation-stack? Is it possible that anything other than can-observation would want to add to the observationStack?\n@justinbmeyer what do you think?. For now I will just have can-view-callbacks handle the case where it is loaded twice. We can make a decision about separating out the tags state into its own repo once that larger discussion happens.. \ud83d\udc4d once tests pass.\n. This is covered by https://github.com/canjs/canjs/pull/2756 because it needs to be done along with can-view-scope 3.1.0.\n. https://github.com/zeit/release is another option. This is needed to create new releases.. This is caused by can-fixture's xhr.js overwriting XMLHttpRequest. I attempted to fix this by using getters/setters to make sure the properties of our mock XHR match that of the real XHR (code can be found here), but this did not solve the problem.\nThere must still be something that our XHR is not doing correctly, but I don't have an idea what it is.\nI've also determined that this only happens in the production tests because in dev mode socket.io loads before we overwrite XMLHttpRequest. If I delay xhr.js from loading then the issue goes away in production mode also.\nA workaround for this issue is to try to make xhr.js load after socket.io, even in the built version of the tests. To do this, perhaps can-fixture can be separated into its own bundle or socket.io can be set as a dependency of can-fixture/xhr.. Keeping open until released.. Closed by https://github.com/canjs/canjs/pull/2805.. closing for https://github.com/canjs/canjs/pull/2797.. Closing for https://github.com/canjs/canjs/pull/2797.. Closing for https://github.com/canjs/canjs/pull/2797.. Accidentally closed.. Some issues in different browsers. Will wait for next version.. Closing for https://github.com/canjs/canjs/pull/2805.. Closing for https://github.com/canjs/canjs/pull/2805.. Closing for https://github.com/canjs/canjs/pull/2805.. Closing for https://github.com/canjs/canjs/pull/2805.. The first two bullets in @justinbmeyer's comment are about the source repo. I think those are the only real requirements. Are there other things you're finding?. I think in lots of cases it would be better to abbreviate using the most common variable name for the module.\nFor example, in the docs below, the link to can-connect/constructor/constructor could just say constructor since that is what we use whenever writing var constructor = require(\"can-connect/constructor/constructor\");.\n\nIn most cases, we have a common variable naming convention like this that we can use (like DefineMap for can-define/map/map). @rjgotten Is there any reason it has to be a Call expression instead of a Helper expression?\nhtml\n<input {$disabled}=\"combine first second\" />. After clearing localStorage this works fine.\nHere is what it had before in case someone thinks this is an issue:\njson\n{\n  \"todoCache-sets\": \"[{\\\"sort\\\":\\\"name\\\"}]\",\n  \"todoCache/instance/5\": \"{\\\"name\\\":\\\"mow lawn\\\",\\\"complete\\\":false,\\\"id\\\":5}\",\n  \"todoCache/instance/6\": \"{\\\"name\\\":\\\"dishes\\\",\\\"complete\\\":true,\\\"id\\\":6}\",\n  \"todoCache/instance/7\": \"{\\\"name\\\":\\\"learn canjs\\\",\\\"complete\\\":false,\\\"id\\\":7}\",\n  \"todoCache/set/{\\\"sort\\\":\\\"name\\\"}\": \"[6,7,5]\"\n}. After clearing localStorage this works fine.\nHere is what it had before in case someone thinks this is an issue:\njson\n{\n  \"todoCache-sets\": \"[{\\\"sort\\\":\\\"name\\\"}]\",\n  \"todoCache/instance/5\": \"{\\\"name\\\":\\\"mow lawn\\\",\\\"complete\\\":false,\\\"id\\\":5}\",\n  \"todoCache/instance/6\": \"{\\\"name\\\":\\\"dishes\\\",\\\"complete\\\":true,\\\"id\\\":6}\",\n  \"todoCache/instance/7\": \"{\\\"name\\\":\\\"learn canjs\\\",\\\"complete\\\":false,\\\"id\\\":7}\",\n  \"todoCache/set/{\\\"sort\\\":\\\"name\\\"}\": \"[6,7,5]\"\n}. Yes, it can get in to 3.3.0.. Yes, it can get in to 3.3.0.. Some of the can-define tests are failing now that can-connect is pulling in can-define 1.0.9. I'm not sure what the correct way to fix this is. Maybe we shouldn't allow loading two versions of can-define?\ncc @marshallswain @justinbmeyer . Some of the can-define tests are failing now that can-connect is pulling in can-define 1.0.9. I'm not sure what the correct way to fix this is. Maybe we shouldn't allow loading two versions of can-define?\ncc @marshallswain @justinbmeyer . 5 tests are failing in all of the Sauce Labs setups:\n\nIt passed for you on greenkeeper/can-connect-1.0.20? I get the same 5 failures locally.. 5 tests are failing in all of the Sauce Labs setups:\n\nIt passed for you on greenkeeper/can-connect-1.0.20? I get the same 5 failures locally.. Yeah, sorry I should have explained. My question is... if a user has \"can-define\": \"1.0.8\" and \"can-connect\": \"1.0.20\" as dependencies in their project, is it going to break? If so, maybe we need to enforce only having one version of can-define with can-namespace.. Yeah, sorry I should have explained. My question is... if a user has \"can-define\": \"1.0.8\" and \"can-connect\": \"1.0.20\" as dependencies in their project, is it going to break? If so, maybe we need to enforce only having one version of can-define with can-namespace.. \ud83d\udc4d . \ud83d\udc4d . I think this is the discussion that prompted this issue: https://gitter.im/canjs/canjs?at=5858f4e80730ce6937e981e0. I think this is the discussion that prompted this issue: https://gitter.im/canjs/canjs?at=5858f4e80730ce6937e981e0. I think something like ($click)=\"fn1(), fn2()\" is what @arti1793 is looking for.. I think something like ($click)=\"fn1(), fn2()\" is what @arti1793 is looking for.. No, it is just importing steal-clone that causes errors. This is the issue https://github.com/stealjs/steal/issues/952.. No, it is just importing steal-clone that causes errors. This is the issue https://github.com/stealjs/steal/issues/952.. @frank-dspeed I think you need to use quotes to use a version range like npm install can@\">=3.3\".. @frank-dspeed I think you need to use quotes to use a version range like npm install can@\">=3.3\".. Are there any errors in the Firefox console?. Are there any errors in the Firefox console?. I was able to get this working locally by making these changes:\n\n\nRoll back can-component to 3.0.3. The tests for 3.0.4 and above are failing on the latest firefox. See https://github.com/canjs/can-component/issues/75.\n\n\nremove the todomvc Funcunit test\n\n\nI'm not sure what changed to cause this to break, but it is throwing this error now:\nTypeError: Error loading \"can@3.3.0#test/test\" at http://localhost:3996/dist/test/test.js\n$(...).unload is not a function\nStack trace:\n@http://localhost:3996/dist/bundles/can/test/test.js:74506:5\nc/l.execute@http://localhost:3996/dist/node_modules/steal/steal.production.js:9:12843\nI'll investigate this after fixing the can-component issue.\n. I was able to get this working locally by making these changes:\n\n\nRoll back can-component to 3.0.3. The tests for 3.0.4 and above are failing on the latest firefox. See https://github.com/canjs/can-component/issues/75.\n\n\nremove the todomvc Funcunit test\n\n\nI'm not sure what changed to cause this to break, but it is throwing this error now:\nTypeError: Error loading \"can@3.3.0#test/test\" at http://localhost:3996/dist/test/test.js\n$(...).unload is not a function\nStack trace:\n@http://localhost:3996/dist/bundles/can/test/test.js:74506:5\nc/l.execute@http://localhost:3996/dist/node_modules/steal/steal.production.js:9:12843\nI'll investigate this after fixing the can-component issue.\n. JSFiddles are working again\n\n. JSFiddles are working again\n\n. Closing this until https://github.com/canjs/can-define/issues/133 is fixed.. Closing this until https://github.com/canjs/can-define/issues/133 is fixed.. @chasenlehara looks like this is only failing after the merge. Did you try merging 2793-add-can-model-as-legacy into 3-4 and then running the tests locally?. @chasenlehara looks like this is only failing after the merge. Did you try merging 2793-add-can-model-as-legacy into 3-4 and then running the tests locally?. master is fine for minor or patch releases.. master is fine for minor or patch releases.. These are broken because some npm dependencies are missing:\n\nI think these need to be added back to https://github.com/canjs/canjs/blob/2.3-legacy/package.json#L25-L56.. These are broken because some npm dependencies are missing:\n\nI think these need to be added back to https://github.com/canjs/canjs/blob/2.3-legacy/package.json#L25-L56.. This should be fixed now. Please let us know if you still see any issues. Thanks for pointing out the issue @abalmus.. This should be fixed now. Please let us know if you still see any issues. Thanks for pointing out the issue @abalmus.. Why not a syntax that is JS instead of mostly JS? Something like elm-lang/html or cyclejs/dom where you call functions directly, passing an object with attributes for the element and an array of child elements.\n```\nimport { ul, li, p, text } from \"can-html\";\nimport helpers from \"my-helpers\";\nimport studentView from \"student-view\";\nexport default (viewModel) => \n    ul({}, viewModel.classRooms.map((classroom) => \n        li({\n            class: classRoom.type\n        }, [\n            p({}, [ text(Name: ${classRoom.name}) ]),\n            p({}, [ text(Teacher: ${classRoom.teach.name}) ])\n            p({}, [ text(!teacher.hasKeys( classRoom ) ? 'No keys' : 'Keys') ])\n        ])\n    ));\n```\nI understand this is less \"designer-friendly\", but making a syntax that is more like JS probably isn't targeting that audience.. Why not a syntax that is JS instead of mostly JS? Something like elm-lang/html or cyclejs/dom where you call functions directly, passing an object with attributes for the element and an array of child elements.\n```\nimport { ul, li, p, text } from \"can-html\";\nimport helpers from \"my-helpers\";\nimport studentView from \"student-view\";\nexport default (viewModel) => \n    ul({}, viewModel.classRooms.map((classroom) => \n        li({\n            class: classRoom.type\n        }, [\n            p({}, [ text(Name: ${classRoom.name}) ]),\n            p({}, [ text(Teacher: ${classRoom.teach.name}) ])\n            p({}, [ text(!teacher.hasKeys( classRoom ) ? 'No keys' : 'Keys') ])\n        ])\n    ));\n```\nI understand this is less \"designer-friendly\", but making a syntax that is more like JS probably isn't targeting that audience.. > But it will be gross.\nCan you explain what you mean?. > But it will be gross.\nCan you explain what you mean?. Yeah, there's not really a pretty solution to two-way binding that isn't extremely verbose.\nHow would two-way binding work in the semijs proposal?. Yeah, there's not really a pretty solution to two-way binding that isn't extremely verbose.\nHow would two-way binding work in the semijs proposal?. Ok, so using another component inside of a view function like this would look a lot like it does now:\nexport default (viewModel) => {\n<ul>\n   for(let classRoom of viewModel.classRooms) {\n     <class-room\n       {type}=\"classRoom.type\"\n       {(name)}=\"classRoom.name\"\n       {teacher}=\"teacher.name\">\n    </class-room>\n   }\n</ul>\n};\nI was thinking you were expecting to be able to call the studentView function directly, which would have the same sorts of problems with two-way binding that an \"all-JS\" solution would have I would think.. Ok, so using another component inside of a view function like this would look a lot like it does now:\nexport default (viewModel) => {\n<ul>\n   for(let classRoom of viewModel.classRooms) {\n     <class-room\n       {type}=\"classRoom.type\"\n       {(name)}=\"classRoom.name\"\n       {teacher}=\"teacher.name\">\n    </class-room>\n   }\n</ul>\n};\nI was thinking you were expecting to be able to call the studentView function directly, which would have the same sorts of problems with two-way binding that an \"all-JS\" solution would have I would think.. > something that abuses nested callback functions, object literals and template strings\n@rjgotten I'm not really sure what you mean. My \"all-JS\" proposal is really just calling functions that take an object and an array.\nI understand the benefit of having something that looks like HTML but has some features of JS, but I think there is also value in something that has all of the features of JS but might not look as much like HTML.. > something that abuses nested callback functions, object literals and template strings\n@rjgotten I'm not really sure what you mean. My \"all-JS\" proposal is really just calling functions that take an object and an array.\nI understand the benefit of having something that looks like HTML but has some features of JS, but I think there is also value in something that has all of the features of JS but might not look as much like HTML.. @Macrofig It looks like it doesn't like \"\"can-define-validate-validatejs\": \"0.0.0\"'. Can you take a look?. @Macrofig It looks like it doesn't like\"\"can-define-validate-validatejs\": \"0.0.0\"'. Can you take a look?. Since 3.5.0 is out, moved issues to 3.5.1 or 3.6.. Since 3.5.0 is out, moved issues to 3.5.1 or 3.6.. @gsmeets sorry, I originally said we would get this in, but since this would require a 2.4 release, maybe @justinbmeyer should weigh in.. @gsmeets sorry, I originally said we would get this in, but since this would require a 2.4 release, maybe @justinbmeyer should weigh in.. @gsmeets since I deleted my original response, here is where this was added in 3.0: https://github.com/canjs/can-stache-bindings/blob/master/can-stache-bindings.js#L291.\nYou should just need to add that here: https://github.com/canjs/canjs/blob/2.3-legacy/view/bindings/bindings.js#L264-L279 and copy this test over https://github.com/canjs/can-stache-bindings/blob/master/test/bindings-test.js#L2416-L2429.. @gsmeets since I deleted my original response, here is where this was added in 3.0: https://github.com/canjs/can-stache-bindings/blob/master/can-stache-bindings.js#L291.\nYou should just need to add that here: https://github.com/canjs/canjs/blob/2.3-legacy/view/bindings/bindings.js#L264-L279 and copy this test over https://github.com/canjs/can-stache-bindings/blob/master/test/bindings-test.js#L2416-L2429.. Why not just publish 2.4 docs to v2.canjs.com?. Why not just publish 2.4 docs to v2.canjs.com?. Ok, we can decide when the time comes. I'm fine either way.. Ok, we can decide when the time comes. I'm fine either way.. Here's what still needs to be done before publishing 3.9.0:\n\n\ncan-reflect: https://github.com/canjs/canjs/pull/3362\nThe tests are currently timing out in CI. Locally they get stuck on can-util/dom/events/inserted - no MutationObserver: basic disabled insertion.\n\n\nreact-view-model: https://github.com/canjs/canjs/pull/3319\nSame issue as can-reflect.\n\n\nsteal 1.0: https://github.com/canjs/canjs/pull/3306\nTests also failed. Probably the same thing.\n\n\ncan-slot\n\n\nRelease Notes\nI created releases for all of the can-* repos, but they don't have any information.\n\n\ncan-reflect release notes:\nhttps://github.com/canjs/can-component/releases/tag/v3.1.0\nhttps://github.com/canjs/can-compute/releases/tag/v3.2.0\nhttps://github.com/canjs/can-connect/releases/tag/v1.5.0\nhttps://github.com/canjs/can-connect-cloneable/releases/tag/v0.2.0\nhttps://github.com/canjs/can-connect-feathers/releases/tag/v3.6.0\nhttps://github.com/canjs/can-connect-signalr/releases/tag/v0.2.0\nhttps://github.com/canjs/can-construct/releases/tag/v3.2.0\nhttps://github.com/canjs/can-construct-super/releases/tag/v3.1.0\nhttps://github.com/canjs/can-control/releases/tag/v3.1.0\nhttps://github.com/canjs/can-define/releases/tag/v1.2.0\nhttps://github.com/canjs/can-define-stream/releases/tag/v0.2.0\nhttps://github.com/canjs/can-define-stream-kefir/releases/tag/v0.1.0\nhttps://github.com/canjs/can-define-validate-validatejs/releases/tag/v0.1.0\nhttps://github.com/canjs/can-ejs/releases/tag/v3.1.0\nhttps://github.com/canjs/can-event/releases/tag/v3.5.0\nhttps://github.com/canjs/can-event-radiochange/releases/tag/v0.2.0\nhttps://github.com/canjs/can-fixture/releases/tag/v1.1.0\nhttps://github.com/canjs/can-fixture-socket/releases/tag/v0.7.0\nhttps://github.com/canjs/can-jquery/releases/tag/v3.1.0\nhttps://github.com/canjs/can-legacy-view-helpers/releases/tag/v0.6.0\nhttps://github.com/canjs/can-list/releases/tag/v3.1.0\nhttps://github.com/canjs/can-make-rest/releases/tag/v0.1.0\nhttps://github.com/canjs/can-map/releases/tag/v3.2.0\nhttps://github.com/canjs/can-map-backup/releases/tag/v3.1.0\nhttps://github.com/canjs/can-map-define/releases/tag/v3.1.0\nhttps://github.com/canjs/can-observation/releases/tag/v3.2.0\nhttps://github.com/canjs/can-reflect/releases/tag/v1.0.0\nhttps://github.com/canjs/can-route/releases/tag/v3.1.0\nhttps://github.com/canjs/can-route-pushstate/releases/tag/v3.1.0\nhttps://github.com/canjs/can-set/releases/tag/v1.3.0\nhttps://github.com/canjs/can-simple-map/releases/tag/v3.2.0\nhttps://github.com/canjs/can-stache/releases/tag/v3.1.0\nhttps://github.com/canjs/can-stache-bindings/releases/tag/v3.2.0\nhttps://github.com/canjs/can-stache-converters/releases/tag/v3.2.0\nhttps://github.com/canjs/can-stream/releases/tag/v0.3.0\nhttps://github.com/canjs/can-stream-kefir/releases/tag/v0.3.0\nhttps://github.com/canjs/can-symbol/releases/tag/v1.0.0\nhttps://github.com/canjs/can-types/releases/tag/v1.1.0\nhttps://github.com/canjs/can-util/releases/tag/v3.9.0\nhttps://github.com/canjs/can-validate/releases/tag/v1.1.0\nhttps://github.com/canjs/can-validate-legacy/releases/tag/v1.1.0\nhttps://github.com/canjs/can-validate-validatejs/releases/tag/v0.1.0\nhttps://github.com/canjs/can-vdom/releases/tag/v3.1.0\nhttps://github.com/canjs/can-view-autorender/releases/tag/v3.1.0\nhttps://github.com/canjs/can-view-callbacks/releases/tag/v3.1.0\nhttps://github.com/canjs/can-view-href/releases/tag/v3.1.0\nhttps://github.com/canjs/can-view-import/releases/tag/v3.1.0\nhttps://github.com/canjs/can-view-live/releases/tag/v3.1.0\nhttps://github.com/canjs/can-view-model/releases/tag/v3.3.0\nhttps://github.com/canjs/can-view-nodelist/releases/tag/v3.1.0\nhttps://github.com/canjs/can-view-parser/releases/tag/v3.4.0\nhttps://github.com/canjs/can-view-scope/releases/tag/v3.2.0\nhttps://github.com/canjs/can-view-target/releases/tag/v3.1.0\nhttps://github.com/canjs/steal-stache/releases/tag/3.1.0\nother releases included in can-reflect branch:\nhttps://github.com/canjs/can-define-validate-validatejs/releases/tag/v0.1.1\nhttps://github.com/canjs/can-connect/releases/tag/v1.5.1\nhttps://github.com/canjs/can-make-rest/releases/tag/v0.1.1\nhttps://github.com/canjs/can-connect/releases/tag/v1.5.2. Here's what still needs to be done before publishing 3.9.0:\n\n\ncan-reflect: https://github.com/canjs/canjs/pull/3362\nThe tests are currently timing out in CI. Locally they get stuck on can-util/dom/events/inserted - no MutationObserver: basic disabled insertion.\n\n\nreact-view-model: https://github.com/canjs/canjs/pull/3319\nSame issue as can-reflect.\n\n\nsteal 1.0: https://github.com/canjs/canjs/pull/3306\nTests also failed. Probably the same thing.\n\n\ncan-slot\n\n\nRelease Notes\nI created releases for all of the can-* repos, but they don't have any information.\n\n\ncan-reflect release notes:\nhttps://github.com/canjs/can-component/releases/tag/v3.1.0\nhttps://github.com/canjs/can-compute/releases/tag/v3.2.0\nhttps://github.com/canjs/can-connect/releases/tag/v1.5.0\nhttps://github.com/canjs/can-connect-cloneable/releases/tag/v0.2.0\nhttps://github.com/canjs/can-connect-feathers/releases/tag/v3.6.0\nhttps://github.com/canjs/can-connect-signalr/releases/tag/v0.2.0\nhttps://github.com/canjs/can-construct/releases/tag/v3.2.0\nhttps://github.com/canjs/can-construct-super/releases/tag/v3.1.0\nhttps://github.com/canjs/can-control/releases/tag/v3.1.0\nhttps://github.com/canjs/can-define/releases/tag/v1.2.0\nhttps://github.com/canjs/can-define-stream/releases/tag/v0.2.0\nhttps://github.com/canjs/can-define-stream-kefir/releases/tag/v0.1.0\nhttps://github.com/canjs/can-define-validate-validatejs/releases/tag/v0.1.0\nhttps://github.com/canjs/can-ejs/releases/tag/v3.1.0\nhttps://github.com/canjs/can-event/releases/tag/v3.5.0\nhttps://github.com/canjs/can-event-radiochange/releases/tag/v0.2.0\nhttps://github.com/canjs/can-fixture/releases/tag/v1.1.0\nhttps://github.com/canjs/can-fixture-socket/releases/tag/v0.7.0\nhttps://github.com/canjs/can-jquery/releases/tag/v3.1.0\nhttps://github.com/canjs/can-legacy-view-helpers/releases/tag/v0.6.0\nhttps://github.com/canjs/can-list/releases/tag/v3.1.0\nhttps://github.com/canjs/can-make-rest/releases/tag/v0.1.0\nhttps://github.com/canjs/can-map/releases/tag/v3.2.0\nhttps://github.com/canjs/can-map-backup/releases/tag/v3.1.0\nhttps://github.com/canjs/can-map-define/releases/tag/v3.1.0\nhttps://github.com/canjs/can-observation/releases/tag/v3.2.0\nhttps://github.com/canjs/can-reflect/releases/tag/v1.0.0\nhttps://github.com/canjs/can-route/releases/tag/v3.1.0\nhttps://github.com/canjs/can-route-pushstate/releases/tag/v3.1.0\nhttps://github.com/canjs/can-set/releases/tag/v1.3.0\nhttps://github.com/canjs/can-simple-map/releases/tag/v3.2.0\nhttps://github.com/canjs/can-stache/releases/tag/v3.1.0\nhttps://github.com/canjs/can-stache-bindings/releases/tag/v3.2.0\nhttps://github.com/canjs/can-stache-converters/releases/tag/v3.2.0\nhttps://github.com/canjs/can-stream/releases/tag/v0.3.0\nhttps://github.com/canjs/can-stream-kefir/releases/tag/v0.3.0\nhttps://github.com/canjs/can-symbol/releases/tag/v1.0.0\nhttps://github.com/canjs/can-types/releases/tag/v1.1.0\nhttps://github.com/canjs/can-util/releases/tag/v3.9.0\nhttps://github.com/canjs/can-validate/releases/tag/v1.1.0\nhttps://github.com/canjs/can-validate-legacy/releases/tag/v1.1.0\nhttps://github.com/canjs/can-validate-validatejs/releases/tag/v0.1.0\nhttps://github.com/canjs/can-vdom/releases/tag/v3.1.0\nhttps://github.com/canjs/can-view-autorender/releases/tag/v3.1.0\nhttps://github.com/canjs/can-view-callbacks/releases/tag/v3.1.0\nhttps://github.com/canjs/can-view-href/releases/tag/v3.1.0\nhttps://github.com/canjs/can-view-import/releases/tag/v3.1.0\nhttps://github.com/canjs/can-view-live/releases/tag/v3.1.0\nhttps://github.com/canjs/can-view-model/releases/tag/v3.3.0\nhttps://github.com/canjs/can-view-nodelist/releases/tag/v3.1.0\nhttps://github.com/canjs/can-view-parser/releases/tag/v3.4.0\nhttps://github.com/canjs/can-view-scope/releases/tag/v3.2.0\nhttps://github.com/canjs/can-view-target/releases/tag/v3.1.0\nhttps://github.com/canjs/steal-stache/releases/tag/3.1.0\nother releases included in can-reflect branch:\nhttps://github.com/canjs/can-define-validate-validatejs/releases/tag/v0.1.1\nhttps://github.com/canjs/can-connect/releases/tag/v1.5.1\nhttps://github.com/canjs/can-make-rest/releases/tag/v0.1.1\nhttps://github.com/canjs/can-connect/releases/tag/v1.5.2. @bmomberger-bitovi I know this was from a while ago, but does this behavior look right to you?\n\n. @pYr0x you get the same code completion and syntax highlighting you get with any other JavaScript. I don't really use code completion with html, so maybe I'm totally wrong, but isn't it mainly helpful for adding closing tags?\nThere is https://github.com/ohanhi/hyperscript-helpers that gives you helper functions like div(..., span(..., etc that you might like better. It should work out of the box with can-hyperscript.. @justinbmeyer I'll try to address each of your questions.\nRe: lists... I thought about it, but not a lot. Right now it is just using live.html(), so it will rerender the entire list if you splice an item from the middle or things like that.\nRe: events and two-way binding... you can see some examples of how it works in the tests. There isn't really two-way binding.\nThis could absolutely be a compile target for other forms of templates, though like you said it might be a little harder to optimize.\nI originally was using can-view-target, but I decided to just wrap hyperscript in this initial version because it was quicker to get working.. I've taken a stab at handling lists by overwriting .map on any properties used in a hyperscript function. That way can-view-live.list will be used if you do something like this:\nh('div', { },\n  data.planets.map(planet =>\n    h('p', {}, [ () => `Hello, ${planet}!` ])\n  )\n)\nThere are other ways that people could use lists that we would want to handle, but this might be the most common way and shows how it could be done.. Closing in favor of https://github.com/canjs/canjs/issues/3569.. \ud83d\udc4d . can-jquery does create $.fn.viewModel.. This already exists: https://github.com/canjs/canjs/issues/2990.. I'm not sure. This doesn't seem like a documented API. can.List and can-list only show new List([array]) and new List(deferred). I'll look into the 2.3 code to see how this was working.. Moved this to can-util/js/make-array/make-array.. 3.5.1 has been released: https://github.com/canjs/canjs/releases/tag/v3.5.1.. When I presented this guide at DoneJS Chicago, a few people were confused about the starter JSBin having all of the HTML. Especially since the solution to the first problem is just a div containing WEATHER WIDGET.. https://github.com/canjs/can-stream-kefir/issues/24 is trying to make it easier to integrate other stream libraries, so we do not need to support only one option.. @sszabolcs This issue is fixed in can-util v3.3.7. Thanks again for reporting it!. @sszabolcs if you don't use jquery for adding/removing the element, then your memory leak goes away. I'll take a look at why jquery causes a problem.. @sszabolcs can-jquery@3.0.7 is released with fixes for these memory leaks when using jQuery. Please let us know if you're still seeing issues after upgrading to this version.. I've opened https://github.com/canjs/can-jquery/issues/72 for that. Should be able to fix it today.. @sszabolcs can-view-live@3.0.7 is out with another fix.. @sszabolcs I definitely appreciate the work you're doing to find these and help make CanJS better. I'll look into this issue today.. @sszabolcs sorry, this got delayed while we were working to get CanJS 3.6.0 out. I will look into this today.. @sszabolcs are you still seeing this issue? I can't reproduce it with your code and the latest can-* versions.. Yeah, I can reproduce with your can.custom.js, but not with these individual imports:\n\n. @sszabolcs I opened https://github.com/canjs/can-stache-bindings/issues/210 for this. We can discuss any further findings there.. Yehuda kind of explained the use of opcodes in another post: https://thefeedbackloop.xyz/designing-and-implementing-glimmer-like-a-programming-language/. \nI think the basic idea is that they can do incremental rendering by splitting up the work in to multiple opcodes. Then they can yield back to the browser between opcodes to prevent jank. . @morrme I was planning to work on this today. Were you planning to work on it?. Sorry @morrme, the canjs builds are blocked because of the saucelabs configuration we're using for Appium is no longer available, so this became higher priority. I look forward to your future contributions.\n. @obaidott you should point this to minor.. closing for https://github.com/canjs/canjs/pull/3187.. If you rebase this with master it should skip the tests since this is just docs changes. @Sinjhin is looking into the test failure.. I merged master in to get John's fix for the tests: https://github.com/canjs/canjs/pull/3234.. The tests for can-connect-cloneable are breaking so I'm going to revert this merge and open a new PR against a minor branch.. Ok, not going to revert and instead we're just going to do a quick 3.7.0.. @christopherjbaker You can take a look at can-hyperscript if you're interested, but it is using a lot of the same internals as can-stache (can-view-live being the big one).\nOne of the biggest performance pieces is how it handles rendering lists. I got this to work by overwriting the .map function to use can-view-live.list, which isn't a perfect solution but does provide similar performance to can-stache. It's hard to give a full comparison of performance between can-stache and something like can-hyperscript in the state it is in, but there aren't any glaring reasons why we wouldn't be able to optimize rendering performance of can-hyperscript.\nOne caveat, though, is that we wouldn't be able to support streaming using something like can-hyperscript.. Issue moved to canjs/can-define-validate-validatejs #16 via ZenHub\n. I would be fine closing this.. Expose viewModel on component element in development - https://github.com/canjs/can-debug/issues/8. @UselessPickles I know I commented on your PR already, but I want to make sure I fully understand the issue, is there a reason you're using can.batch.after?. I think you might be able to fix it by changing the wrapping in the editor:\n\nHowever, it might be a good idea to set up the repo locally anyway. It would be great if you could add a test for this case. It would basically be the same as the example you gave in the issue, but with an assertion (ok(true, ...)) in place of the alert.. We're using tabs. You can set up EditorConfig (http://editorconfig.org/) in your editor to make sure your spacing is correct.\nInstead of using the grunt task to run the tests, you can just load one of the test pages in a browser (test/jquery.html for instance).. This is published in can@2.3.34.. Issue moved to canjs/can-stache #207 via ZenHub\n. FYI, jquery++ was only stored on gh-pages as a temporary workaround while we got SSL set up for jquerypp.com (since https is needed for JSBin).. There have been a few other repos with failing tests with can-util updates, so running this as a sanity check.. Good catch on the steal-css and steal.prod.js.\nThat test is failing because those tests are switching between the normal dom and vdom. So it's dispatching that event, then the dom is switching, then the event handler is being called. I think a simple thing we should try is adding a stop()/start() to that test.. I've started experimenting with this kind of Object-Oriented Reactive Programming\u2122\ufe0f. In my prototype, all the properties of your map are streams. You can pass a function as the value of a property to derive a stream from other properties (which are streams). Anything that isn't a function is emit as the value of the property (stream). If properties are set, the new value will be emitted. Functions are passed a setStream so they can use any emitted values to derive their value.\nMaybe easier to understand with an example:\n```js\nconst Person = ReactiveMap({\n  first: 'Tracy',\n  last: 'Phillips',\n  fullName(setStream, { combineLatest }) {\n    return combineLatest(this.first, this.last, (first, last) => {\n      return first + ' ' + last;\n    })\n    .merge(setStream);\n  }\n});\nconst person = new Person({\n  first: 'Kevin'\n});\nperson.fullName.subscribe((fullName) => {\n  // 'Kevin Phillips',\n  // 'Clancy Wiggum',\n  // 'Kevin McCallister'\n});\nperson.fullName = 'Clancy Wiggum';\nperson.last = 'McCallister';\n```. 3.9.1 is out.. Here goes nothing.. Looks good: https://travis-ci.org/canjs/canjs#L1609. Nice job.. I think this is a duplicate of https://github.com/canjs/canjs/issues/2737.. So we'll need to get https://github.com/canjs/canjs/pull/3423 in before we close this issue out. It looks like that PR doesn't have the same failures as the rest of these, but some tests are still failing. @Sinjhin do you want to look into that?\nYou may just also need https://github.com/canjs/canjs/pull/3422. The fix in can-view-scope went along with https://github.com/canjs/can-observation/releases/tag/v3.3.2.. this is fixed in minor.. Here is an example JSBin reproducing the issue: http://jsbin.com/joteciriqo/edit?html,js,output.\nIn this case, the warning is produced because of the removed event that gets dispatched when the {{#if}} is toggled.\nI don't think we can avoid dispatching these events because we use them to teardown the bindings for the live attributes.. Nice job researching this @bmomberger-bitovi. I added https://github.com/canjs/canjs/issues/3544 to implement it.. This codemod can be used to make the changes: https://gist.githubusercontent.com/phillipskevin/75a3626b00dd32709b13132706cb7f30/raw/36b0a4f55cc611e79670549ed9a24b9bc8670a42/remove-pre-release-deps.js.. I closed this since all the PRs have been merged.. Ok, then can you point this to the minor branch instead? We can try to get a 3.12.0 out tomorrow or early next week.. This is a problem because steal-css is a devDependency? So is the correct solution just to use a <link> for these css files: https://github.com/canjs/canjs/blob/a181a6a6b294e9e8d29a5aaa3f761f6cb3c4481f/demos/can-view-callbacks/fade_in_when.html#L20.. @justinbmeyer The issue is that synchronous getters are now set up as Observations. So, when the value is set, Observation.prototype.update is called here, but the ScopeKeyData that depends on this Observation is never updated. I put in a potential fix for this here: https://github.com/canjs/can-define/pull/261.\nLet me know if you think there is a better way to fix this.. I'm not sure why ScopeKeyData is never updated - it seems that the boundGet function needs to observe computeObj.valueTrap.lastSetValue, but it is not observable.\nIt was working previously because getters were always set up as computes (although there was no ScopeKeyData at that time). . canjs 3.10.2 is out and resolves this issue.. Let's go with can-simple-observable.. This has been published: https://www.npmjs.com/package/can-simple-observable.. Yeah, let's close it.. Do we want to maintain this reademe? Or just update it to a link to the docs? cc @chasenlehara . This is complete.. I like the option with the simple More... button for CanJS Users.\nHowever, I think this makes it more difficult for CanJS Authors to find API docs, since they're most often looking at infrastructure docs I think. Maybe that doesn't matter?. It will probably be implemented similarly... something like\n```js\nlog: function(key) {\n  canReflect.onKeyValue(this, key, function() {\n    console.log( ... );    \n  });\n}\n```\nThis is a function to make things easier to debug; it's not intended to be used in application code.\nWhat issue do you foresee with this, @rjgotten?. @m-mujica if all of the initial ones are complete we can close this and add separate issues to add them to the other observables.. Here is the outline for the first draft of the guide that I am working on now:\n## Form Elements\n\n### <input type=\"text\">\n* binding to events\n  - on:change\n  - list of standard events that can be bound to\n* binding to attributes\n  - value:to\n  - value:from\n  - value=\u201c{{foo}}\u201d\n  - list of standard attributes that can be bound to\n* binding to events and attributes\n  - value:bind\n  - on:input:value:to\n\n\n### <input type=\"checkbox\">\n* checked:from\n* {{#if checked}}checked{{/if}}\n* checked:bind=\u201cboolean-to-inList(key, list)\u201d\n* checked:bind=\u201ceither-or(\u2026)\u201d\n\n\n### <input type=\"radio\">\n* can-event-dom-radiochange\n* checked:bind=\u201cequal(key, value)\u201d\n\n\n### <input type=\"number\">\n* type: \"number\"\n\n\n### <input type=\"submit\">\n* can-event-dom-enter\n\n\n### <input type=\"file\">\n\n\n### <select>\n\n\n### <select multiple>\n* value:bind\n\n\n### <textarea>\n\n\n## Fancy bindings\n\n### Non-standard attributes\n* focused\n* disabled\n\n\n### Non-standard events\n* Reasoning\n  - Keep DOM-related functionality out of your ViewModel (ev.type === 13, etc)\n* enter\n  - can-event-dom-enter\n* radiochange\n  - can-event-dom-radiochange\n\n\n### events up, data down\n* on:change=\u201cscope.set(\u201ckey\u201d, scope.element.value)\u201d value:from=\u201ckey\u201d\n\n\n### Resetting <input> value back\n* explain that two-way binding normally sets <input> value back when a \u201cchange\u201d event occurs on the ViewModel property\n* if a setter or resolver does not change the value (because it is illegal), there is no change event\n* with :bind, can-stache-bindings will handle this for you\n\n## Validation\n* can-define-validate-validatejs\n\nA few things that I haven't added to the outline yet (so I don't forget about them):\n can-connect-cloneable\n creating new data\n* updating data. I'm leaving out the can-event-dom-radiochange for now as I don't see a use-case for using this directly (not through can-stache-bindings and the checked attribute).. I think can-define-backup and can-connect-cloneable have slightly different goals, but they are related. I don't think one is replacing the other.. Remaining changes:\n- [x] Revamp overview section so that it gives people a better understanding of what they're getting into (take a look at Tech Overview guide)\n- [x] Make Custom Attributes and Custom Events more obvious\n- [x] Add a \"working with related data\" example\n  - make, model, year example with can-ajax\n  - how to load data\n  - how to use promises in forms\n  - the string-to-any utility\n  - link to issue on \"creating new data\" / \"updating data\"\n- [X] Remove use of <label> where they prevent you from clicking outside <input> to produce \"change\" events\n- [X] Remove use of scope.set(...) in \"data down, actions up\" section\n- [X] Expand \"data down, actions up\" section to show an example with multiple components\n- [X] Use Components in all the examples\n- [X] explain when on:click will be called when hitting the Enter key inside an <input> in a form\n. First of all, I love this idea.\nNow that that's out of the way, I have an idea on how to make the API more understandable.\nThe tldr; is to use more of a builder pattern to create each property instead of using definition objects.\nHere is a rough example of what this could look like:\njs\nconst Counter = StreamBuilder({\n    add: source('incrementBy'), \n    subtract: source('decrementBy'),\n    count: value(0)\n            .map('incrementBy', (value) => ({ type: 'add', value: value }) )\n            .map('decrementBy', (value) => ({ type: 'subtract', value: value }) )\n            .reduce((lastState, event) => {\n                switch(event.type) {\n                case add: \n                    return lastState + event.value;\n                case subtract:\n                    return lastState - event.value;\n                }\n            })\n});\nI think this has a few benefits over using objects for each property definition.\n\nThe \"builder\" functions help users understand what they can do with each property. If you call value(0) it will give you back the right Type with the methods you can use next.\nIt allows helpful error messages like \nYou can't call value after calling map\n\n\nIt's easy to document. We can document the source, value, map, reduce methods and clearly define their return values. This is easier than trying to document each of the combinations of properties that could be used in a definition object. (these APIs aren't fully thought out - just an idea of what this could look like). > How do you use your own stream library in this way?\n\nI like the approach that Recompose uses... basically it uses something similar to the ES Observable spec internally and lets you map to/from that to whatever you want to use. So if you want to use Kefir you would do something like:\njs\nconst StreamBuilder = builderFromConfig({\n  fromESObservable: Kefir.fromESObservable,\n  toESObservable: stream => stream.toESObservable()\n});\n(shout out to @BigAB for showing me this originally)\n\nis .map the right method name there?\n\nMaybe not? The idea is to map the incrementBy event on the event bus to a more descriptive event that you can use in your reducer. This way you could take source events that might look very different and normalize them. But you're right, it might not make a lot of sense.\nMainly, I just like the idea of saying \"it's map/reduce for observables\".. > I'd prefer not to \"own\" a bunch of APIs.\nI'm not sure what you mean. What APIs would we own?. The .each method has been removed from can-define/map/map, can-define/list/list, can-map, and can-list.\nYou should use .forEach or canReflect.each instead.. stache's log helper is now console.log (the other console methods are available also). It will not be passed the current context by default. You should use console.log(this) if you want that.. These will no longer automatically call bar as a function:\n{{bar}}\n{{#bar}}\n  ...\n{{else}}\n  ...\n{{/bar}}\nYou need to now call them manually:\n{{bar()}}\n{{#bar()}}\n  ...\n{{else}}\n  ...\n{{/bar}}\nAlso, functions in bindings are not automatically called... so you need to call them if you're doing\non:click=\"foo\" or on:click=\"foo.bar.baz()\".. inserted and removed events on components should be moved to connectedCallback and disconnectedCallbacks on the component's ViewModel.\nOr you should run this to make inserted and removed work:\n```\nimport domEvents from \"can-dom-events\";\nimport domMutateDomEvents from \"can-dom-mutate/dom-events\";\ndomEvents.addEvent(domMutateDomEvents.inserted);\ndomEvents.addEvent(domMutateDomEvents.removed);\n``. Thedefault` helper can no longer be called as function.. Some comments from reviewing the guide:\n\n\nWe might want to mention that not all ecosystem packages have been updated to 4.0. Especially if using the can package, it might not be super easy to tell if everything you're using has a 4.0 version. Maybe we have people check the site for the packages they're using. Or we could give a list of what has not been updated.\n\n\nIn the inserted/removed event section, this sentence reads a little strange:\n\n\n\nMost if what was done in the inserted event can be replaced in places like value.\n\n\nThe connectedCallback is only on the ViewModel (pretty sure).\n\nComponent.extend({\n    connectedCallback: function(){\nshould be\nComponent.extend({\n    ViewModel: {\n        connectedCallback: function(){\n        }\n    }\n\nI think this is a typo:\n\n\nIn can-define 1.0, you would default a default value for a property. @matthewp there are a few things missing from the migration guide:\n\n\n.each is removed from our Map and List types and you need to use .forEach (https://github.com/canjs/canjs/issues/3781#issuecomment-351097925)\nfunctions are not automatically called by stache without () (https://github.com/canjs/canjs/issues/3781#issuecomment-351837669)\n\nDo you want me to add these? Or do you want to take care of it?. stache lookups will now check the context before checking helpers, so {{#each(list)}} would have called list.each instead of the each helper.. About https://github.com/canjs/canjs/issues/3781#issuecomment-357727911 - I'm going to try to get {{#default()}} working today so we don't have to explain/codemod this.. I'm just going to merge this and update the /next site once the tests pass, but if you have any comments @chasenlehara or @justinbmeyer I'll address them in a follow-up PR.. oh, right. no tests \ud83d\ude04 .. @justinbmeyer this is passing now.. can-view-callbacks is now auto-autoMounting, so you get this for free without the autoMount: true. You can see the changes here: https://github.com/canjs/can-view-callbacks/pull/77.. I think all the ones that didn't work were either:\n\ncomma-separating the vars\n\njs\nvar baseMap = require(\"can-connect/can/base-map/base-map\"),\n    DefineMap = require(\"can-define/map/map\"),\n    DefineList = require(\"can-define/list/list\"),\n    set = require(\"can-set\");\n\nimporting for side-effects\n\njs\nvar can = require('can');\nrequire('can/model/model');\nJust wanted to point it out in case the codemod could be updated to handle these cases.. Great job! I'll fix up the conflicts and merge.. This is done on https://canjs.github.io/next/ thanks to @roemhildtg. Awesome work \ud83c\udf89 \ud83c\udf89 \ud83c\udf89 .. I've deployed this to https://canjs.github.io/next/doc/guides/recipes/canvas-clock.html if anyone else wants to review or try it out.. Another idea, @andrejewski came up with is to add an item to the right-click context menu to \"Inspect nearest ViewModel\". It looks like this should be possible: https://superuser.com/a/184806.. https://chrome.google.com/webstore/detail/canjs-devtools/hhdfadlgplkpapjfehnjhcebebgmibcb is available. Going to close this. Issues for that are in https://github.com/canjs/devtools/issues.. More Detailed Outline:\n1. Testing ViewModels\n  a. Basic setup\n  b. Overriding getters - using lastSet to \"override\" the return value of a getter to test properties derived from it\n  c. Async properties\n2. Testing Componens\n  a. Basic setup\n  b. ViewModel - show using `Component.ViewModel` then link to (1).\n  c. Events - using bindings -> just call the functions. Using `listenTo` in a `value` or `connectedCallback` -> dispatch events.\n  d. connectedCallback - example of third-party integration and how to manually call `connectedCallback` or actually insert in the page.\n3. Testing Routing\n  a. Basic setup\n  b. Data - `route.data` -> show creating `routeData` property and how to use `RouteMock` to verify URL changes without changing the real URL.\n  c. Component - `componentToShow` pattern and how to test it independently.\n  d. Component viewModel -> `componentToShowViewModelData` (but something shorted) and testing `value.from`/`value.bind`/etc properties using Reflect.\n4. Testing Models\n  a. Basic setup - create a fixture, test that `getList`,etc return correct data.\n  b. Generating test data - using `fixture.store` and `queryLogic`.\n  c. Testing `QueryLogic` - using `filterMembers` to test schema. Using `isMember` to test custom `toQuery`/`toParams`\n5. Integration Testing\n  a. When should you do it?\n  b. Basic setup. I really think this is the way to go:\n\nsupporting multiple expressions in stache\n\nI don't think people should have to learn new syntax to do this.. Remaining packages to publish:\nCore:\n- [x] can-component\n- [x] can-connect (kevin)\n- [x] can-route\n- [x] can-route-pushstate\nInfrastructure:\n- [x] can-control\n- [x] can-validate-interface\nEcosystem:\n- [ ] can-connect-feathers (kevin)\n- [x] can-debug\n- [x] can-define-stream (matthew)\n- [x] can-define-stream-kefir (matthew)\n- [x] can-define-validate-validatejs (kevin)\n- [x] can-fixture (kevin)\n- [x] can-kefir (justin)\n- [x] can-observe\n- [x] can-stream (matthew)\n- [x] can-stream-kefir (matthew)\n- [x] can-view-autorender (kevin)\n- [x] react-view-model (kevin)\n- [x] steal-stache (matthew)\n- [x] can-view-import (matthew)\nLegacy:\n- [x] can-list\n- [x] can-map. I still think this might be confusing for people. I think we should just say\n\nFunctions should be called using parentheses\n\nThen show what this means and give the explanation of why we did this (like you are).\nThen once this is clear, say something like\n\nThere is one exception -- the Helper Expression syntax, which is allowed when your function is called with at least one argument. This is for legacy purposes, so you don't have to change all of the places you're doing {{#each list}} in your app.. My main point is, functions should be called with (). There's one situation where they don't have to be.. This is fixed. Thanks for pointing it out.. Yes, you can do it. But I'd like to make it easier \ud83d\ude04.. Previously, can-util/can-util was getting pulled in by can-construct-super: \n\n\nI specifically fixed this in can-construct-super@v3.1.4 to be compatible with 4.0.\nI think we should add an import for can-util/can-util in the 3.0 can/can.js.\nIn 4.0, I think we should change can-util so each of the modules we want people to use add themselves to can-namespace instead of having one big catch-all.\nSo I don't forget how I figured this out later, I ran a build:\n./node_modules/.bin/steal-tools build --main can/all\nand then created an html page like:\nhtml\n<!doctype html>\n<script src=\"./dist/steal.production.js\">\n        window.can = require(\"can\");\n        window.steal = require(\"@loader\");\n</script>\nI then looked at window.steal._traceData.parentMap to get the image at the top.. @chasenlehara do we want to close this since it is fixed in 3.13.1 or should we address 4.0 also?. Yeah, I understand we need to fix it. Just wasn't sure if you wanted to use the same issue.. Thanks @cherifGsoul!. This is the JSBin we're using in Gitter: https://jsbin.com/safigic/18/edit?html,js,output. Going to close this. Please re-open if there is anything that we could do to make this more obvious.. You just mean that the calculation is reversed? It should be\nconst wallLengthInMeters = compute( function( lengthInM ) {\n    if ( arguments.length ) {\n        wall.length = lengthInM * 3.28084;\n    } else {\n        return wall.length / 3.28084;\n    }\n} );\nYou can click the \"Edit on GitHub\" button at the top of the page to update the example if you'd like:\n\n. This is done. Nice work. What a cool guide!. This is fixed in 2.3.35 and 2.3.34 has been deprecated. Thanks for pointing this out.. For the bugs, definitely feel free to submit a PR.\nFor the others, excited to discuss your ideas!. @cherifGsoul @chasenlehara can this be closed?. @justinbmeyer is this closed now?\nThis link:\n\n...now links to https://canjs.com/doc/guides/technology-overview.html#Key_ValueObservables.. We could either make the setter handle this, but that would probably end up being confusing. Maybe we need to make this work:\nhtml\n<can-import from=\"can-stache-route-helpers\" value:assignTo=\"scope.helpers\"/>\nas discussed in https://github.com/canjs/can-stache-bindings/issues/104#issuecomment-337778746 (and I think other issues).. Does this work already?\nhtml\n<can-import from=\"can-stache-route-helpers\" value.routeUrl:to=\"scope.helpers.routeUrl\"/>. Oops... I did not mean to merge this. I'll make the changes you requested in another PR. Thanks @chasenlehara.. just going to do this on major since CI takes forever.. We might want to do #4295 also.. @justinbmeyer \n\ndebugger guide shows importing can-debug with require. How can we do this with import?\n\nIs this asking about the webpack setup? \nYou can do \n```\nimport { debug } from \"can\";\nif (process.env.NODE_ENV !== \"production\") {\n  debug();\n}\n```\n...and the import will be removed by tree-shaking in production.. Going to go with this for now. It takes the CI time down to about 33 minutes. I'll put in a follow-up PR once I hear back from Travis Support about only adding the sauce_connect addon for the one env that needs it.. For people that aren't changing the URL (like https://unpkg.com/can/dist/global/can.js).. Here are the docs for the string-to-any converter: https://canjs.com/doc/can-stache-converters.string-to-any.html. No, the test script isn't used in CI anymore at all.. How can we integrate logWhatChangesMe?. break on change is part of https://github.com/canjs/devtools/issues/6.. can-define is 2.5.4 now in CanJS 5.3.0. \ud83c\udf89 . One thing that would need to be figured out is how to handle Sessions. One way to do this is to let the router also create virtual properties based on other ViewModel properties. This way the \"{page}\" property used to decide the active route could be set based on the user's Session:\njs\nrouter(routes, {\n    get page(lastSet) {\n        if (!this.isLoggedIn) {\n            return \"login\";\n        }\n        return lastSet;\n    }\n})\nNot sure I love this.. This could also make it so that a new component is not created if taskId changes for a route like this:\ntasks: {\n            \"{taskId}\": {\n                Component: () => import(\"./pages/tasks\"),\n                data: {\n                    logout: \"logout\",\n                    id: \"{taskId}\"\n                }\n            }\n        },\nSince the Tasks component will be internally using something like viewModel: { id: value.from(this.routeData, \"taskId\") }, a new Component does not need to be created for this case.. I haven't decided which one I like better, but one thing I'm thinking about is... what will people do if they're not sure what key to use to get the data they want to display?\nWith the this approach you could {{ console.log(this) }} or {{ debugger }} and then get(\"this\").\nWith the \"naked\" approach... I don't know what people would think to do.\nIt would be nice if we could make Scopes inspectable in devtools like normal JS Scopes, but I'm not sure how we would do that.. Yeah, I used {{ scope.log() }} earlier today and it does help. But that doesn't make it very easy to figure out what key to use in the template.. Yeah, looks like it's missing the removeDevelopmentCode: false that core and ecosystem have:\nhttps://github.com/canjs/canjs/blob/c242be8502b4a6bdbb620c74c914fef22660af2e/build.js#L102-L106. This was fixed in https://github.com/canjs/canjs/commit/74ad7875a4a278bbc22a68d36a5f81cd4c06dfd2.. One messaging idea (that I think I've pushed in the past) is \"consistent productivity\"\n- easy to get started and be productive right away\n- devtools and error messaging keep you productive when you run into issues\n- advanced features like realtime, fall-through caching, and streams keep you productive when you need to handle complex tasks. Issue moved to canjs/devtools #29 via ZenHub\n. @justinbmeyer's original description:\nThis issue are thoughts around how to introduce virtual DOM diffing to CanJS as a solution to the performance problems related to https://forums.donejs.com/t/why-is-my-color-choosers-frame-rate-with-vue-so-much-higher-than-with-canjs/986/5.\nI'd like to introduce it incrementally, so that folks could get some basic diffing without having to make it work completely in CanJS.\nAs we know SimpleDOM can already be used by can-stache.  I think @matthewp as part of making workerthread rendering has made some form of diff and patching.  (@matthewp where is this done?).  If there isn't good diff and patching, it's likely can-diff/deep can help.\nWe could change can-view-live so that if it gets observables that produce DOM that is not of the same \"document\", we can diff the DOM result and then apply the patch:\n```js\nvar makeSimpleDOM = require(\"can-vdom/make-document/\");\nimport {fragment} from \"can\";\nvar DOCUMENT = makeSimpleDOM();\nvar html = value.with( fragment(\"\", DOCUMENT) );\nviewLive.html(el, html );\nhtml.value = fragment(\"\", DOCUMENT)\n```\nThe next problem is how can we switch to creating SimpleDOM instead of using the normal document. Obviously, there's globals, but that feels weird.  \nCurrently, the templates get compiled in the section builders:\nhttps://github.com/canjs/can-stache/blob/4af7b26e64be2623dda88dcfce9b24d6291184fd/src/html_section.js#L127\njs\nthis.compiled = target(this.targetData, getDocument());\nWe could make compiling targets delayed.  Perhaps target's hydrate() could take arguments specifying the type of document.\nThis information could also be passed down by stache helpers somehow. Currently, it's expected that scope, nodeList gets passed.  Could the document be made part of nodeList.\nWe could make a {{# diff( item of items ) }}.. Here are the two tests that are failing:\n\n. Here is what is failing in the latest run:\n\n. closed by https://github.com/canjs/canjs/pull/4615.. Maybe this should say \nPlease notice that when dynamically importing modules in a stache file, the scope inside <can-import> is a Promise, so you have to wait ~~for~~ until it is resolved.\n. The recommended way to progressively load~~ing~~ modules with StealJS is to use the @loader module provided by steal.\n. Probably should be\ntemplate's data\n. Since this is a constructor, it probably should be capitalized like CanMap.. addEventListener doesn't take the element as the first parameter, so this needs to be can.event.addEventListener.call(el, 'click', function() {});.. can-view-model can take a string as the first parameter, it just isn't reflected in the docs. See https://github.com/canjs/can-view-model/blob/master/can-view-model.js#L9 and https://github.com/canjs/can-view-model/issues/19.. @Macrofig any chance you can update this example? Or at least confirm that it could be done the way @justinbmeyer is proposing?. we should publish these first.. yeah, we could do that with grunt-cli also if we care enough. I don't really care what I have installed globally on node 0.12 since I only ever use it for releasing legacy can 2.3. What do you think?. I'm just going to leave it this way for now. There are several grunt commands and I don't think it's worth taking the time to update it.. This should be the test file. Also.. the one above this is wrong, should import the tests for can-attribtue-encoder if you want to fix that up also.. This should be a devDependency.. I would use toggle(this).. Same thing here... let's show this instead of ... why is this one using helper syntax?. I don't think this will work (in 4.0)... isSelected() won't be passed an options argument. You should just pass the item in like isSelected(this). did {{^selected.length}} not work?. FYI can-stache-converters requires can-stache-bindings, but this is fine since no converters are being used.. Ok, we've got an issue open to fix that. Thanks.. You mean it's always set to items.length - 1?. If so, that's a bug.. I think this is fine, but it should work the other way also: https://jsbin.com/gikewuyewi/1/edit?html,js,output.. Can you put in a newline here?. Another newline \ud83d\ude04 .. You can't have exports inside of if statements with es6. We'll have to figure out another way to do this.. Same as above. Can't have export inside of a block.. Another newline \ud83d\ude04 .. Another newline \ud83d\ude04 .. Another newline \ud83d\ude04 .. This import should be moved to the top so the function can be called correctly here. Like it's done up above in 15-setter-toggle/index.js (and some other examples probably).. Same thing - need to fix how this import is called.. Need a newline here and to name the import and call it correctly.. This one needs a newline and should be something like\n```\nimport defineStreamKefir from 'can-define-stream-kefir';\ncan.defineStreamKefir = defineStreamKefir;\n.\nimport can from 'can/all';\nimport defineStreamKefir from 'can-define-stream-kefir';\nimport Kefir from 'kefir';\ncan.defineStreamKefir = defineStreamKefir;\n. same can.defineStreamKefir approach.. newline here.. newline \ud83d\ude04 .. newline \ud83d\ude04 .. newline \ud83d\ude04 .. newline \ud83d\ude04 .. newline \ud83d\ude04 .. newline \ud83d\ude04 .. newline \ud83d\ude04 .. newline \ud83d\ude04 .. newline \ud83d\ude04 .. newline \ud83d\ude04 .. newline \ud83d\ude04 .. newlines \ud83d\ude04 .. newline \ud83d\ude04 .. newline \ud83d\ude04 .. newline \ud83d\ude04 .. Let's not change this file just yet. We don't have plans to change can-* source files to ES6 modules right now..\n//!steal-remove-start\nimport can from 'can-debug';\nwindow.can = can;\n. same thing.\nimport can from 'can-debug';\nwindow.can = can;\n``. newlines \ud83d\ude38 .. newlines \ud83d\ude38 .. These imports need to be moved to the top and named.. newline.. Remove everything afteror a value?` and say something like\n\nIt's impossible to tell when reading this that foo might be a function that will be called.\n\nand then\n\nThe only exception is built-in helpers or Helper Expressions (when called with >=1 argument)\n\nAnd explain that this is so you don't have to change {{#each items}} in a ton of places, which would make it hard to upgrade.. double check how this looks when rendered.. can you pin the version?. packagae.json -> package.json. The transform actually handles both since it might run before the register transform, but this is fine.. @chasenlehara took care of it.. I did it this way to use as little stache as possible, so that the event binding was the only thing being introduced. You're right, that might make it more confusing. I'm open to suggestions.. Since these are strings, maybe it should be:\n\n\"pending\", \"resolved\", or \"rejected\". should this be\nThe names that can be imported from this module...\n\nor \n\nThe names that are exported by this module.... I don't know if we care, but putting this comment before the doctype will put IE in quirks mode.. is stache(...) required with webpack?. same question as webpack.. do we want to remove these ./s now?. can we use arrow functions and remove this?. I know this isn't new, but do we need this console.log?. is this indented weird?. It looks like this is indented wrong, but I'm not positive.. I think can-fixture-socket should still be compatible with 4.0. Its dependencies are the same as canjs/canjs#master.. Yes, scope.root is deprecated. This should use scope.vm (scope.top would also work, but scope.vm is better).. I see there's another issue. So this can be merged.. This is linked above in the Debugwhatcausedaobservableeventorupdatetohappen_ section. You think we should link to it again?. The images dont get copied from docs to doc, which is where the generated html is output. I think these are right. This is how other guides do paths for images.. It centers them \ud83d\ude04.. I did create a bitovi account on codepen if you want to use that.. There's some weird spacing here.. looks good.. \n",
    "organic-scholar": "Thanks for quick response its working. but do you add support for follwing syntax.\nhandlebars\n{{ greet name=(uppercase username) }}\nafter all it is valid syntax.\n. Please check this \n(http://jsbin.com/bopateq/1/edit?html,js,console,output)\ni tried the above syntax its not working\n. But right now we can't mix helper expression with call expression.\n. here is another example failing, this one with unnamed params.\nhttp://jsbin.com/niseji/edit?html,js,console,output\n. but i think this behaviour is inconsistent beacuse we called the expression its is not  instead it is passed as compute.\n. ",
    "amitbikram": "@justinbmeyer It looks like this issue is not limited to EJS. I found the same issue with Mustache also. Below is the link for that.\nhttp://jsfiddle.net/S3kVm/15/\n. @justinbmeyer It works great with stache but I am working on a project which uses EJS and changing the the templating engine at this point of time does not look feasible. I have a fix ready for this and make a pull request.\n. @justinbmeyer I have have a pull request for this. When would would it be available if the fix looks good?\n. ",
    "pravin-d": "@matthewp \nHad a quick read about stealjs and related docs. Would need some time to understand it properly.\n I'm a little confused about your example. Before setting show='tag1' I need to still check if the component is registered or not right ?\n. @matthewp \nHad a quick read about stealjs and related docs. Would need some time to understand it properly.\n I'm a little confused about your example. Before setting show='tag1' I need to still check if the component is registered or not right ?\n. ",
    "lastzero": "It was caused by some jquery plugin - probably select2. We came across this while refactoring existing code...\n. Not select2, but some datetime picker in conjunction with moment.js.\n. Yeah, I think arguments was [null]\n. The bug seems to date back to 2014 (f761946449ab8e19ae1073649d51f408759b2d97):\n// if the template has a fragRenderer already, just return that.\nif(info.fragRenderer) {\n    return info.fragRenderer(null, id);\n} else {\n    return makeRenderer(info.renderer(null, id));\n}\nSince fragRenderer doesn't offer a render() function for text rendering, a DocumentFragment is always returned:\nrenderTo: function (format, renderer, data, helpers, nodelist) {\n    return result = (format === 'string' && renderer.render ? renderer.render : renderer)(data, helpers, nodelist);\n},\nAs a workaround, it's possible to convert a DocumentFragment back to text like this:\nif(text instanceof DocumentFragment) {\n   text = new XMLSerializer().serializeToString(text);\n}\n. ",
    "garrettreed": "solved in 3.0. \nImplementing the same fix resolves the problem, but breaks other tests. I'll continue to work on it.\n. can-map-define is fixed in https://github.com/canjs/can-map-define/pull/12\ncan-define/map is fixed in https://github.com/canjs/can-define/pull/73\n2.3 is fixed in #2509\n. > Probably don't want to run the compute\nYeah, this probably isn't the best way to go about it, but it seems to work. Not running it breaks other tests.\n. @justinbmeyer this is ready to be merged and #2318 can be closed.\n. @justinbmeyer I may need your help understanding escaping in bit-docs. I figure the fix should be made in bit-docs-generate-html/stmd.js, but any change I make there breaks everything...\nThe use of < in signature blocks also comes across escaped, but not >. So that is somewhat related.\n\n. ~~Still stumped. Changing out the &lt;can-import&gt; for <can-import> in steal-stache docs doesn't make a difference here. There is a line in the makeLinks helper of bit-docs-generate-html that escapes the link text. I figured that was the root of the second escape, but removing that didn't make a difference either.~~ It ended up working. Must have had it cached. \n. The steal-stache change will need to be published before this issue can be closed.\n. @justinbmeyer do you have an idea of what's going on here? Should this be filed under can-connect?\n. Issue moved to canjs/can-connect #169 via ZenHub\n. ",
    "RALifeCoach": "@justinbmeyer, Thanks for your comments.\nYou are right, the component is being inserted into a table of divs, not an HTML table. As for\nthis.highlightPicker = this.element.find(this.HIGHLIGHT_PICKER);\nthis.highlightPopup = this.element.find(this.HIGHLIGHT_POPUP);\netc.\nI use those frequently in the events following. However, the performance issue is present whether the assigns are in the component init or not.\nGetting the JSBin to work will take a fair bit of time. Let me see what I can do. It will probably only be for a few rows.\n. The JSBin is running and taking the about 3 seconds. The reload is much faster than in my code. Let's fix the load and see if that improves the reload. I investigated further and the reload is reloading a much larger player object so that explains some of the time difference.\n. Here is the new JSBin. http://jsbin.com/wanima/1/edit?html,js,console,output\n. If I strip down the player object to just the fields that I need, then I get better timings. The load is still over 3 seconds, but the reload is .5 seconds. That still feels a touch long, but much improved. That opens the question, why does a large player object - where most of the properties are not used - take so much time? Having to write a mapper each time I want to use a template doesn't make much sense.\n. I know I am being impatient, but has there been any progress?\n. Thank-you @justinbmeyer for your suggestions. I have changed Map to LazyMap and I now get an exception thrown both in my code and in the JSBin. Please have a look and let me know what I have missed. (In the mean time I will see if what I have missed is to define all the properties I might be using.) I have created defines for the properties and the problem persists. I will make the same updates to the JSBin.\n. Any insights?\n. I have done further analysis. It is a third level property that causes the exception. The viewModel top level properties are options, player, etc. Player has a property player_bio. player_bio has properties country, first_name, etc. When I reference, in the stache file, player.player_bio.country, I get a problem when updating the player map.attr('player', player);. If I remap the player and flatten it to player.player_bio_country, then the exception no longer happens.\n. @justinbmeyer I had a look at can-define. The readme references can.compute and therefore there is no can-define documentation. As well, this code is not available through the custom download builder. Question: why is this code can-define instead of can.define?\n. @jandjorgensen Yes.\n. @ccummings Passing in a large object with many unused properties still creates a large performance issue. I still feel this is a valid request and have created a PR to address the issue.\n. I didn't think this PR was going ahead. If it is, I would need to do some\nclean up of the code.\nOn Tue, Jul 12, 2016 at 2:15 PM, Julian notifications@github.com wrote:\n\nwe need a test to except that PR. Also documentation is needed.\nalso there are some JSLint errors.\nthis feature maybe can released for the legacy canjs 2.3\npls let me know if you want to resolve the problems\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/canjs/canjs/pull/2357#issuecomment-232132668, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe/ADrayA2wTEIG7fxMf4zENUBMHgEkyiWPks5qU9nTgaJpZM4H-uWD\n.\n\n\nChristopher Oliphant\n+1 647 972 4549\n. ",
    "Hamelina": "Hi there, \nI have quite the same issue here : I am trying to use routeUrl like this : href=\"{{routeUrl page='chat'}}  on a button. But the problem is that I get the following warning : ChatAppView:8: Unable to find helper \"routeUrl\". \n. ",
    "hntvip": "thank you @pYr0x . i done with your suggestion\n. when i on url : \"#!update/add\" , i want go to new url  \"#!list\", but when i call : can.route.attr({route:\"list\"}) . It changed page of url, but the url did not change ?. what can i do now?\n. @justinbmeyer  thank you so much, sorry when i ask some dumb question ! :((\n. ",
    "Nithanaroy": "How is it fixed? I still see this in \"can\": \"^3.3.1\"\nCreated an example https://jsbin.com/medifub/edit?html,js,output1. Thanks Justin. I tried with $values as explained at https://canjs.com/doc/can-util/dom/attr/attr.special.values.html, but still don't see the selected value updating selection variable. I want to use the select box with single selection with optgroups. Am I missing something?\nUpdated JSBin with $values, https://jsbin.com/medifub/edit?html,js,output. ",
    "lewismoten": "The real problem is JavaScript itself has never allowed you to use return outside of a function. This is a bug in Node that they haven't fixed (https://github.com/nodejs/node-v0.x-archive/issues/6254). So although CanJS is targeting only Node/Steal/Global, it seems to be missing the problem - CanJS is not JavaScript compliant in some areas and taking advantage of a bug!\nThe ECMAScript 1st edition (ECMA-262) specification states:\n\nAn ECMAScript program is considered syntactically incorrect and may not be executed at all if it contains a return statement that is not within the Block of a FunctionDeclaration.\n\n(page 55) http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%201st%20edition,%20June%201997.pdf\nThis is why our programs are explicitly having problems with the CanJS files.\nSome programs I have seen that don't like this:\n1. ESLint will just give you a parsing error: 'return' outside of function\n2. Acorn (used by Webpack / babel) - Module parse failed: ...node_modules\\can\\dist\\cjs\\map\\define\\define.js 'return' outside of function (248:4) You may need an appropriate loader to handle this file type.\n3. UglifyJS - has a flag (--bare-returns) to allow this code for anyone supporting Node. It is setup to throw an error by default.\n4. Visual Studio will have JS1018 - https://msdn.microsoft.com/en-us/library/e7c1ycsk(v=vs.90).aspx\nIs there an ETA when or if this will be addressed?\n. Correct @matthewp - I am upgrading to can 2.3. I'm uncertain what I am upgrading from. The package.json and changelog.md says its version 1.1.7, the can.js file says 2.1.1\n@justinbmeyer  The temporary workaround - is \"Type\" supposed to be \"can\" or \"can.Control\" in this case? I don't think \"path\" and \"name\" exist just yet in this namespace either. I could be wrong.\n. @justinbmeyer - it looks like the work-around fixed the issue. Thanks!\n. I spoke a bit too soon. I had other resources failing first with the load order. I'm getting: \n\nimport.js:26 Uncaught ReferenceError: Type is not defined\n\nAnd the line looks like:\njavascript\nsomething.here[\"import\"] = Type.extend({\n. Maybe this?\njavascirpt\nsomething.here = something.here || {};\nsomething.here[\"import\"] = can.Control.extend({\n. ",
    "Krakabek": "Same problem\nDo you have any plans about what version this bug will be fixed in?\n. Same problem\nDo you have any plans about what version this bug will be fixed in?\n. ",
    "cleong-tc": "hi @justinbmeyer, i work with the op (@justthismorning).\ni investigated the issue farther and found that the svg-element has dimensions (70px by 70px), but the (child) use-element does not have dimensions (0px by 0px) (vs ting.com).\nwhen i inspect (with chrome) the use-element (in 'Properties' sidebar), the 'use' | 'href: SVGAnimatedString' is missing the svg-uri for baseVal & animVal (vs ting.com & initial-server-render).\ni believe can.stache is not calling the namespace-specific set-attribute function (i.e. el.setAttributeNS())...\nvar svgUri = '../..//static/images/icons.svg#ting';\nuseEl.setAttributeNS('http://www.w3.org/1999/xlink', 'href', svgUri);\nwhat is the best way to set el.setAttributeNS() in can.stache?\n. @pYr0x : checking the svg-element and/or use-element clientWidth/Height were not sufficient checks, so i will have to investigate further on confirm the use-element was able to retrieve the svg-image/file.\ni am busy for the next few months with a launch. i will try to get back to this when i can.\n. ",
    "abalmus": "@matthewp please review this issue. We have problems with JSPM during bundling process. This is very simple fix.\nMultipleErrors: can@2.3.23/dist/cjs/map/define/define.js:15:5: Illegal return statement\n. ",
    "chrischrischris": "There are additional errors with the documentation, will get all of the fixes in one pull request.\n. ",
    "chikkalingaiah": "I need 3 components hierarchy to simulate the behavior, I have simplified the example a bit.\nQuestion I have is on this piece of code:\n'{viewModel} someObject': function() {\n        this.viewModel.attr('section', \"showGrandChild\");\n      }\nIn above code I am listening to change in \"someObject\" and updating \"section\" with new value \"showGrandChild\" which injects grand-child component on DOM.\n{{#is section \"showGrandChild\"}}\n      \n    {{/is}}\nIn \"inserted\" event of \"grand-child\" I am updating \"inputBoxes\" array attribute and trying to see whether it reflects on DOM immediately in next line, but it does not reflect on DOM.\nBut if I do same thing in next event loop of \"someObject\" change by using 0milli-second setTimeout, grand-child DOM is updated immediately:\n'{viewModel} someObject': function() {\n        setTimeout(()=>{this.viewModel.attr('section', \"showGrandChild\")},0);\n      }\n. Case 1:\n$('.input-boxes').length is 0 in \"inserted\" event  of grand-child, when \n'{viewModel} someObject': function() {\nthis.viewModel.attr('section', \"showGrandChild\");\n}\nCase 2:\n But if I insert grand-child in next event-loop using setTimeout $('.input-boxes').length is 6. \n'{viewModel} someObject': function() {\nsetTimeout(()=>{this.viewModel.attr('section', \"showGrandChild\")},0);\n}\nI am trying understand batch impacting this scenario,  in Case 1 since I am inserting \"grand-child\" in the same event loop as \"someObject\" change is it holding off observable updates on \"grand-child\" DOM in \"inserted\" event?\n2.3.7 version reflects the change immediately on DOM in \"inserted\" event. \n. Thanks for the reply, but why do I see event being queued up only in this scenario, if I trigger showGrandChild from child directly the observable changes are reflected immediately . Basically my question is when to expect events to be queued up vs when not.\nPlease see example: http://jsbin.com/jececi/edit?html,js,console,output\nHere \"Show Grand Child 3 level hierarchy\" button trigger does not reflect the observable changes immediately but \"Show Grand Child 2 level hierarchy\" does immediately.\n. ",
    "arti1793": "Basket = can.Model.extend({update:'PUT serveraddress/basket'})\nBasket.update({\"products_with_options_list\":[{\"products_with_options_id\":9809,\"quantity\":5}]},successCallback})\n It wraps arguments in 'id' or in some cases in 'undefined' like on a screenshot.\nsave() is making put to url from location.pathname and spooiling arguments too, that's why i didn't use it. save() can be fixed the same way that update()\n. @phillipskevin you're absolutely right. Opened issue there https://github.com/canjs/can-stache-bindings/issues/115. ",
    "foundling": "Thanks, that clarifies things. \ud83c\udf66\n. ",
    "ArGGu": "@pYr0x yes.\n. ",
    "bitwhiz": "@matthewp I'm a little confused about this. To me it seems like can-define/map/map still offers the same functionality for value as can-map/define did. Maybe I'm looking at the wrong places? These are the 2 resources that I've looked at:\n- http://canjs.com/doc/can-define.types.propDefinition.html\n- https://v2.canjs.com/docs/can.Map.prototype.define.value.html. I tried doing this in a JSbin using canJS 2 and it doesn't work.\njs\nMap.extend({\n  define: {\n    name: \"Justin\"\n  }\n})\nI get this error: \njs\nTypeError: Cannot use 'in' operator to search for 'value' in Justin\n    at Object.mapHelpers.define (http://canjs.com/release/latest/can.jquery.js:8609:29)\n    at Function.setup (http://canjs.com/release/latest/can.jquery.js:2997:32)\n    at Function.extend (http://canjs.com/release/latest/can.jquery.js:2719:95)\n    at venaje.js:1:957. Sure! Here is one: https://www.w3schools.com/tags/att_a_name.asp. It's also stated here as well: https://www.w3.org/TR/html5/obsolete.html. This is the same as canjs/bit-docs-html-canjs#204. Hmm, I guess you're right. The user could always read the documentation on Function.prototype.bind if they didn't already know how to use it.. @ccummings can you make sure this is correct?. Looks like it was the same situation with addEvent from 2.3. Changes have been made.. I think this is pretty much the same as before then, so I've removed it.. ",
    "MarcGodard": "I know that. What I am saying is that you should treat self closing css/less can-imports like they are not self-closing.\n. https://github.com/MarcGodard/donejs-appframework\nThis is where it would be needed. Switching between iOS and Android in development.\nI am trying to incorporate Framework7 with doneJS... so far very unsuccessfully.\n. @matthewp That is what I want, to progressively load CSS but using a self-closing tag.\n. @justinbmeyer It wouldn't be hard to make it an example in my repo. https://github.com/MarcGodard/donejs-appframework\nI need to call it a night, will look into it more tomorrow. Also, if anyone wants to help with this project, I could use the help. I really like doneJS and it would be so sweet to take the Framework7 stuff and incorporated it (too bad it's javascript isn't great like its css--I was looking into changing that)\n. It would be cool if it did remove it.\n. There is still the problem of when the tag is self closing, it loads regardless of the {{#if}}\n. You say this doesn't work: (and I agree)\n{{#if xyz}}\n<can-import from=\"somfile.less!\"/>\n{{/if}}\nbut then why does this work:\n{{#if xyz}}\n<can-import from=\"somfile.less!\"></can-import>\n{{/if}}\nAll I am saying is that for css and less files you shouldn't need the extra tag to close the import for the if to work. That is all. Its not like content goes there. Also not saying ALL imports, just css/less ones. Would have saved me some debugging time that is all.\nThe unloading of CSS file was mentioned by someone else (@marshallswain I think), and I just mentioned a use for it. Which I still think is a good idea.\n. @justinbmeyer I understand that, but it wouldn't be too hard to change it for css/less files to always work like System.import() This would save new people a lot of potential hassle and would be better in other ways as well. I am just going to close this, because otherwise you guys don't understand what I am saying or I am completely wrong.\n. Thanks @justinbmeyer \nJust so people have the import option too. This worked.\n```\nimport definition from 'can-event-dom-enter'\nimport domEvents from 'can-dom-events'\nexport default domEvents.addEvent(definition);\n```. Still have the error using can@5.16.3\nOPENING: base-site@0.0.0#components/modal-settings.component!done-component@2.2.0#component\n(node:43810) UnhandledPromiseRejectionWarning: Error: 'QueryLogic' is not exported by can@5.16.3#can\n    at error (/Users/marcgodard/GitHub/base-site/node_modules/steal-rollup/dist/rollup.js:199:15)\n    at Module.error (/Users/marcgodard/GitHub/base-site/node_modules/steal-rollup/dist/rollup.js:16918:9)\n    at handleMissingExport (/Users/marcgodard/GitHub/base-site/node_modules/steal-rollup/dist/rollup.js:17233:21)\n    at /Users/marcgodard/GitHub/base-site/node_modules/steal-rollup/dist/rollup.js:19976:56\n    at Array.reduce (<anonymous>)\n    at Graph.handleMissingExport (/Users/marcgodard/GitHub/base-site/node_modules/steal-rollup/dist/rollup.js:19975:27)\n    at Module.traceVariable (/Users/marcgodard/GitHub/base-site/node_modules/steal-rollup/dist/rollup.js:17007:28)\n    at ModuleScope.findVariable (/Users/marcgodard/GitHub/base-site/node_modules/steal-rollup/dist/rollup.js:13445:29)\n    at Identifier.bind (/Users/marcgodard/GitHub/base-site/node_modules/steal-rollup/dist/rollup.js:14129:40)\n    at NewExpression.NodeBase.bind (/Users/marcgodard/GitHub/base-site/node_modules/steal-rollup/dist/rollup.js:13490:23)\n. Yes, I updated all libs\n\"steal\": \"^2.1.7\",.\n",
    "blackmamba": "If I go the Steal route:\n```\nvar steal = require('steal');\nvar can = require('can/dist/steal/can/can');\n```\nthen I get:\n```\nTypeError: Cannot read property 'then' of undefined\n    at steal (/User/project/node_modules/steal/main.js:224:25)\n```\nWithout explicitly adding Steal, I get Steal not found.\n. can-simple-dom route\nvar simpleDOM = require('can-simple-dom');\nvar document = new simpleDOM.Document();\nvar can = require('can/dist/cjs/can');\nReferenceError: document is not defined\n    at /User/projectname/node_modules/can/dist/cjs/util/fragment.js:60:56\nno luck so far!\n. Thanks @pYr0x for your response.\nLet me start with sharing what I have done since last night, with a hope that it may help others.\nWhile troubleshooting the above, I stumbled upon Donejs - and tried the above mentioned 'Steal route'. I also stumbled upon the modular implementations of the packages in CanJS 3.0.0. I must add that, looking at the modular implementations got me really excited. And I decided to try to accomplish the above using the 'can-stache 3.0.0-pre.18' module. Hoping that it should be as easy as the following lines of code:\n```\nvar stache = require('can-stache');\nvar template = require('./path/to/template');\nvar renderer = stache(template); \n```\nBut, unfortunately I couldn't even get pass the require('can-stache') line. It fails with an error of some modules not found. Basically, say for example sake, inside can-stache.js, it requires a module in the following way:\nvar assign = require('can-util/js/assign');\nTypically that means that inside 'assign' directory, there will be an index file, but here it contains an assign.js. And the require cannot interpret that, and its failing. I fixed many modules by pre-pending it with the module name after the directory name, hoping that its just one or two modules, but seems like there are a lot. I thought may be this is because I'm on Node 5.x, so I upgraded to Node 6.x incase this new feature is introduced, but no luck so far. \neg: of the error I'm running into\n```\nfs: re-evaluating native module sources is not supported. If you are using the graceful-fs module, please update it to a more recent version.\nmodule.js:457\n    throw err;\n    ^\nError: Cannot find module 'can-event/lifecycle/'\n    at Function.Module._resolveFilename (module.js:455:15)\n    at Function.Module._load (module.js:403:25)\n    at Module.require (module.js:483:17)\n    at require (internal/module.js:20:19)\n    at Object. (/user/project/node_modules/can-compute/proto-compute.js:37:22)\n```\nNow coming to using Steal, as per your example. I am already using require to load dependencies i n my node build. And I am skeptical adding, one more dependency management just to pre-compile. Hopefully there is a workaround. The jsbin example is good, but the browser environment was never a problem. Its the node where I'm facing this. May be I'm missing something, as to how can-stache is supposed to be built. Will appreciate if someone can point out. If not then may be as the last resort I may have to consider Steal.\nThanks!\n. @pYr0x Exactly.\nJust running a require('can-stache') should help uncover a lot of this. I fixed a few on my end, but it's spread across many repositories. I'll try to open a PR.\nThankfully I haven't seen any of the 'window' or 'document' undefined messages in can 3.0 yet, so most probably I may not need a Virtual DOM to be included explicitly.\nAny ETA on this ?\nThanks!\n. Totally understand. I'll try my best to contribute at my earliest leisure. \nGotcha. I'll add it when required, once I'm past the above errors.\nCheers!\n. ",
    "edba": "Calling methods like viewModel.method() works fine until you start passing methods from parent to child or the other way around.\nSince viewModel.method() will always execute the currents components method without taking into account what has been bound to it.\nSo the only reliable way to execute either the bound method or the components method is like:\nif(typeof this.viewModel.attr('method') === 'function'){\n  this.viewModel.attr('method')();\n} else {\n  this.viewModel.method();\n}\nHere is a working example: http://jsbin.com/kayomi/19/edit?html,js,console\nThis becomes a bit cumbersome and it's not immediate obvious since functions are treated differently than any other property on the viewModel.\nI guess one way around this could be to use the define plugin to return a function as the initial value.\nWhat are your thoughts on this?\n. ",
    "frank-dspeed": "@justinbmeyer i would prefer if we invest in a little server for 10 dollar month and let it crawl and index the sites and implament that\nbut i could also think of something like a /search folder that stores the index splitted ? as we can use for example r in /search/r. @justinbmeyer i would prefer if we invest in a little server for 10 dollar month and let it crawl and index the sites and implament that\nbut i could also think of something like a /search folder that stores the index splitted ? as we can use for example r in /search/r. The Real Importent things are Mixed Tutorials thats all whats realy missing to make it easyer for new people i think i trained the last days over 50 people to code Can3 and i got the most fast success via showing them how to port existing projects and code to CanJS Code because near any Javascript Coder starts with Jquery for example so its for him Realy easy once you told him look this is a jQuery app and then tell him how he can shorten that code with CanJS\nWe Could also add some kind of Matrix Tabels that show a Migration Path for other Frameworks so they can work with the knowleg they have. We Need to Catch them where they are at present and Add Value to existing Projects and Stuff.\n@justinbmeyer You did a awsom job with splitting it up it made me jump into this and love it more as any other framework it took me 1 week till i got first results and i am Coding longer then 28 years :) but as i got it working i speeded up my Overall Development Time 5x.\nSplitting it up in Modules was right and it is not Monolithic its one of the Most Modular Frameworks on The Whole Market with so many abilitys to code adapters and transformations. It Could get Maybe a whole Superset like TypeScript is. . The Real Importent things are Mixed Tutorials thats all whats realy missing to make it easyer for new people i think i trained the last days over 50 people to code Can3 and i got the most fast success via showing them how to port existing projects and code to CanJS Code because near any Javascript Coder starts with Jquery for example so its for him Realy easy once you told him look this is a jQuery app and then tell him how he can shorten that code with CanJS\nWe Could also add some kind of Matrix Tabels that show a Migration Path for other Frameworks so they can work with the knowleg they have. We Need to Catch them where they are at present and Add Value to existing Projects and Stuff.\n@justinbmeyer You did a awsom job with splitting it up it made me jump into this and love it more as any other framework it took me 1 week till i got first results and i am Coding longer then 28 years :) but as i got it working i speeded up my Overall Development Time 5x.\nSplitting it up in Modules was right and it is not Monolithic its one of the Most Modular Frameworks on The Whole Market with so many abilitys to code adapters and transformations. It Could get Maybe a whole Superset like TypeScript is. . i think you should let it this way and we create some kind of wiki lexicon that simply has more details about this defined sentences like \"Service modeling\" gets a extra page or block where we explain what is service modling. i think you should let it this way and we create some kind of wiki lexicon that simply has more details about this defined sentences like \"Service modeling\" gets a extra page or block where we explain what is service modling. cant we use the modules also in the guid also without steal its only needed to load them in the right order the guids arn't that complext that this could lead to fails.. cant we use the modules also in the guid also without steal its only needed to load them in the right order the guids arn't that complext that this could lead to fails.. Lets Close in Favor of: https://github.com/canjs/can-stream/issues/14. Lets Close in Favor of: https://github.com/canjs/can-stream/issues/14. @phillipskevin lol good point :D thanks. @phillipskevin lol good point :D thanks. @matthewp i think this can be closed so right?. @matthewp i think this can be closed so right?. @chasenlehara because i often want to point to code parts when people have questions and i can find the repos more fast when i browse the docs and then show the related parts in the repos original code. @chasenlehara because i often want to point to code parts when people have questions and i can find the repos more fast when i browse the docs and then show the related parts in the repos original code. @chasenlehara closing this as this is done feel free to reopen. we should add #3145. we should add #3145. @chasenlehara i am for adding npm module debug to all can libs like define on all places and then we can debug all stuff well i did that for can define direktspeed/can-define-debug@f390eb0\nit helped me a lot https://www.npmjs.com/package/debug\ni use it also backend side for all projects i did forks of every can package but don't published them and can this way debug them all\na commun method that i use then is i add to the init of my app that if env DEBUG exists in the node start line then i add directly in the init the settings to the localstorage in browser\nbecause you need to filter out very verbose things like babel :) they all are using that module and if you do something like DEBUG=* you get with steal and babel a lot of fun :)\nso DEBUG=,-babe is most importent if you debug whole projects if you debug only a single component turn on debug for babel is also cool. @chasenlehara i am for adding npm module debug to all can libs like define on all places and then we can debug all stuff well i did that for can define direktspeed/can-define-debug@f390eb0\nit helped me a lot https://www.npmjs.com/package/debug\ni use it also backend side for all projects i did forks of every can package but don't published them and can this way debug them all\na commun method that i use then is i add to the init of my app that if env DEBUG exists in the node start line then i add directly in the init the settings to the localstorage in browser\nbecause you need to filter out very verbose things like babel :) they all are using that module and if you do something like DEBUG=* you get with steal and babel a lot of fun :)\nso DEBUG=,-babe is most importent if you debug whole projects if you debug only a single component turn on debug for babel is also cool. @andrejewski if you got time maybe prepare a canjs documentation badge? http://svgshare.com/i/2Bm.svg. @andrejewski if you got time maybe prepare a canjs documentation badge? http://svgshare.com/i/2Bm.svg. i think maybe that should get even more splitted up by its tool type for example if its a class or decorator or cjs script something like that \nwasn't canjs about all this little utils?`maybe brand it something like:\n- bitovi-framework bf-xxxx\n- bitovi-helpers bh-xxxx\n- bitovi-decorators bd-xxxx\nThis is the best of my suggestions\nnaming them can-utils-* as i think moving out to a other organization is not needed as canjs is designed to work as single modules as also combined as whole framework if something don't works as a single module then this should get renamed to can-shared-* maybe\n. i think maybe that should get even more splitted up by its tool type for example if its a class or decorator or cjs script something like that \nwasn't canjs about all this little utils?`maybe brand it something like:\n- bitovi-framework bf-xxxx\n- bitovi-helpers bh-xxxx\n- bitovi-decorators bd-xxxx\nThis is the best of my suggestions\nnaming them can-utils-* as i think moving out to a other organization is not needed as canjs is designed to work as single modules as also combined as whole framework if something don't works as a single module then this should get renamed to can-shared-* maybe\n. @andrejewski maybe watch also into this i found out you already did some upgrades to repos like testee to do automated releasing via travis this will apply the same thing also to all repos we should work together on this as your familar with the main concept. @andrejewski maybe watch also into this i found out you already did some upgrades to repos like testee to do automated releasing via travis this will apply the same thing also to all repos we should work together on this as your familar with the main concept. also good issue to add: canjs/can-route#98\nyou should be able to put a breakpoint in that define-helpers file and trace the stack back up to what you're calling. also good issue to add: canjs/can-route#98\nyou should be able to put a breakpoint in that define-helpers file and trace the stack back up to what you're calling. only way i could figure out is:\n-npm hook pre install script in package.json\nthat links to a js file that get called and finds out if deps already exist in upper folders.\nand then look if version is statisfied if not it would be a good idea to cycle because the version depends then not really on the other because of the version.\nscripts: {\n preinstall: \"node ./not_cycle_dependencys\"\n}\nthe script would execute this to edit package.json:\nnpm install --save ../can-view-scope. only way i could figure out is:\n-npm hook pre install script in package.json\nthat links to a js file that get called and finds out if deps already exist in upper folders.\nand then look if version is statisfied if not it would be a good idea to cycle because the version depends then not really on the other because of the version.\nscripts: {\n preinstall: \"node ./not_cycle_dependencys\"\n}\nthe script would execute this to edit package.json:\nnpm install --save ../can-view-scope. this is related to #3428 . renovate the main project that backs semantic release and also greenkeeper\nhttps://gitter.im/renovate-app/Lobby\nhttps://renovatebot.com/docs/\nwe can get it all integrated together\nno need to merge greenkeeper stuff renovate can cover that automatic and also do the changelog and other release quality stuff\nhttps://github.com/renovateapp/renovate/blob/master/docs/self-hosting.md\nwe could also integrate code mods what you do with landscaper at present\nvia defined rules in a self hosted renovate process\ncc @bmomberger-bitovi @justinbmeyer @phillipskevin \nbut as i worked with semantic release and renovate i got the result that semantic release is a set of scripts that need to get bundled for each case into a own semantic release fork. @phillipskevin can-connect-cloneable isn't that replacing can-define-map-backup ? stuff?. @justinbmeyer what do you think about this Streaming viewModel\nIts only a little experiment you could also simply let can-define away and rerender stache or even better would be to add the ability to stache to directly observe streams.\n```javascript\nconst Nils = require('../../')\nconst defineMap = require('can-define/map/map')\nconst Component = require('can-component')\nconst view = require('index.stache')\nconst app = new Nils()\nconst viewModel = defineMap.extend({sealed: false},{})\n// Init ViewModel\n// could be also a defineMap->Stream\napp.stream.of({\n  inputX: '',\n  inputY: ''\n})\n// Observe DOM Elements\n// return { update, assign }\n.combineArray((observed)=>observed,[\n  app.fromInput(document.querySelector('input.x'))\n  .map((val)=>{\n  return { inputX: val }\n  }),\n  app.fromInput(document.querySelector('input.y'))\n  .map((val)=>{\n    return { inputY: val }\n  })\n])\n// Returns the ViewModelUpdating State aka can-x-connect :)\n// This can also be a complet Can Component\n// its only for demo\n.loop(function applyVM(lastSetVal, setVal){\n  //=> lastSetVal looks like { inputY: val, inputX: val }\n  let seed = lastSetVal.viewModel.updateDeep(setVal)\n  return return { seed, value: seed };\n},Component.extend({\n  tag: 'kasse-login',\n  ViewModel,\n  view\n}))\n// Acticvate the Stream All gets executed as sideEffect\n.map((comp)=>comp.render())\n.drain()\n```\nthe idea behind this is we simply bring in a component and update it based on the stream values if we would have a map lile { prop1: val1, prop2: val2 } we would deepMerge the object in the loop to get a single map with the most current values to render . I think the current module way is great we could simply write tutorials about how to compile a custom canjs can version or how to use can global namespace stuff to get a can object. \nThat means we change near nothing but make clear how the can. gets build. Then we Also introduce can.all as the general way to use canjs and in donejs we introduce the modules.  and reference there how they could get a global can. from the modules\nthen stealjs tree shaking can strip down the main canjs build to only the used functions in production builds.\nConsideration\nIt saves no learning effort if we bundle to can.* as every new user still needs then to learn defineMap defineList connect set-algebra and stache. there is near no extra effort to learn that this are diffrent packages it makes no diff if i need to remember the function name or the package name which i assign a name on import.\n. i think a new can.all plus can.Component alone in tutorials is a nice reduction from using stache and defineMap for basic examples . @justinbmeyer can we simply use callexpressions again? if we do {{fadeAnimatedLi(this, 300)}} we should get the element already as far as i remember then in our fadeIn function we can care for the disconnect function to fadeOut.. I copy the Answer from https://github.com/canjs/can-stache/issues/611 =>\n@justinbmeyer https://codepen.io/frank-dspeed/pen/KGemLG\nexample that shows what i mean it is also related to canjs/canjs#4517\nit can be also applyed here to render animated sections via callexpressions\n. @phillipskevin can-define-backup looks missing that needs also release \ncan-connect-feathers   4.0.0-pre.2   4.0.0-pre.2   3.7.1  applications\ncan-define-backup      1.0.0-pre.1   1.0.0-pre.1   0.0.1  applications\n. @phillipskevin also this is wrong and blocking https://github.com/canjs/can-util/pull/409\nits all well with that update the travis got fails without that update canjs 4 don't works. Adding can-types fixes the issue npm install --save can-types\ni am Running CanJS4 latest maybe its needed by can-define or can-component and missing in package.json. @matthewp ok your right thanks for info . @christopherjbaker we have that already as our components are style isolated that means you can generate the style for your component how ever you like the modlet structure of canjs lines that out pritty well as also can-element can-component look into that if your interrested in styled components.. @justinbmeyer little question where did you store the screen shoot the url looks like github i am interrested in your method.. can be closed got solved via change of code style is not relevant any more. I think this should get avoided !!!\ncomponent.mjs\njs\nlet myComponent = Component.extend\nexport myComponent as Component\nindex.mjs\njs\nvar data = {}\nimport('./component.mjs').then(({Component})=>new Component(data))\nthis is total ok and needs no addition i think. i think the way to go is let the people code custom routers and gives them a example because the init tasks of every component are really diffrent. my opinion this.* is the only real way to go as this is guess able and so more easy to understand for beginners that simply understand javascript. I have a lot of problems with stuff that should make life more easy because i need to understand what they did befor i can use it so it doubles the effort at the end.. @bmomberger-bitovi when i understand right the solution that i apply to this is i simply don't never ever use can-import :D as we can deprecate that via the ESM Loader so the right way is to return the element in the viewModel of your Component. @bmomberger-bitovi see the canjs routing guide as a example for what i mean by return the element inside the viewmodel. but i think maybe the most best way is really still the programatic way to return the content of the component instance in place via a custom function on the viewmodel. \nExamples\nhttps://canjs.com/doc/can-stache/expressions/call.html\nReturn stache (Good Easy way!!!!)\nas you can return stache via a function in the view Model do this\n``js\nComponent.extend({\n    tag: \"my-table\",\n    view:\n\nA perfectly normal table row\n  {{myTableRowGroup(foo=\"A supplied table content\")}}\n\n`,\nViewModel: {\n    get myTableRowGroup(data) {\n\n// can be also from file\n                    return stache(<tr><td>A custom table row</td></tr>\n                          <tr><td>{{foo}}</td></tr>)(data)\n            }\n        }\n    }\n});\nResults in:html\n\n\nA perfectly normal table row\nA custom table row\nA supplied table content\n\n\n```\nas you can see in this example you would also not need the my-table component as you could have a my-table.stache that you can call with data that you can directly return stache with data inside any viewModel via callexpression\nReturn a other Component (To Complex!)\nnot finished\n``js\nComponent.extend({\n    tag: \"my-table\",\n    view:\n\n\nA perfectly normal table row\n  {{myTableRowGroup({ foo: 'A supplied table content' })}}\n\n`,\nViewModel: {\n    myTableRowGroup: {\n        default() {\n\n        }\n    }\n}\n\n});\n```. @bmomberger-bitovi if the return stache example don't fits in your concept ping me here and i will show a working example of your proposal via return of a complet component instance and if you wish also demonstrate cross live binding\nbut that would be hugh example so i want to do it on request only i think the return stache() method is exactly what you call return transperent . @bmomberger-bitovi\nThe Answer of https://github.com/canjs/can-stache/issues/611 can solve this watch this example.\n https://codepen.io/frank-dspeed/pen/KGemLG. @bmomberger-bitovi\nThe Answer of https://github.com/canjs/can-stache/issues/611 can solve this watch this example.\n https://codepen.io/frank-dspeed/pen/KGemLG. @kcoleman731 https://stealjs.com/docs/StealJS.development-bundles.html\nRead that and close this issue if you feel that it is solved.\n@justinbmeyer we should follow stackoverflow best practice with answering issues and also label such questions as documentation or help so we can filter closed issu information for places where we need to supply better documentations\n- https://stackoverflow.com/help/how-to-answer\n. @kcoleman731 https://stealjs.com/docs/StealJS.development-bundles.html\nRead that and close this issue if you feel that it is solved.\n@justinbmeyer we should follow stackoverflow best practice with answering issues and also label such questions as documentation or help so we can filter closed issu information for places where we need to supply better documentations\n- https://stackoverflow.com/help/how-to-answer\n. @kcoleman731 you can also use for development the can/core.min package it is precompiled and has much smaler loadtimes :dancer: . @kcoleman731 you can also use for development the can/core.min package it is precompiled and has much smaler loadtimes :dancer: . @Lighttree please visit\n- #4533 \n- #4527 . @Lighttree please visit\n- #4533 \n- #4527 . @Lighttree i think it is as this is the first working example running in node and the browser packaged by rollup js nativ esm bundler and running ans nativ esm module. @Lighttree this is exactly what you need to do to package a canjs app for production without steal loader.. @justinbmeyer i applyed your changes but the problem is still the code inside can-stache \nassign(HTMLSection.prototype,{\n    inverse: function(){\n        this.inverseData = [];\n        this.data = \"inverseData\";\n    },\n    // Adds a DOM node.\n    push: function(data){\n        this.add(data);\n        this.targetStack.push(data);\n    },\n    pop: function(){\n        return this.targetStack.pop();\n    },\n    add: function(data){\n        if(typeof data === \"string\"){\n            data = decodeHTML(data);\n        }\n        if(this.targetStack.length) {\n            last(this.targetStack).children.push(data);\n        } else {\n            this[this.data].push(data);\n        }\n    },\ndecodeHTML don't exists and is not a browser method or anything . @justinbmeyer i applyed your changes but the problem is still the code inside can-stache \nassign(HTMLSection.prototype,{\n    inverse: function(){\n        this.inverseData = [];\n        this.data = \"inverseData\";\n    },\n    // Adds a DOM node.\n    push: function(data){\n        this.add(data);\n        this.targetStack.push(data);\n    },\n    pop: function(){\n        return this.targetStack.pop();\n    },\n    add: function(data){\n        if(typeof data === \"string\"){\n            data = decodeHTML(data);\n        }\n        if(this.targetStack.length) {\n            last(this.targetStack).children.push(data);\n        } else {\n            this[this.data].push(data);\n        }\n    },\ndecodeHTML don't exists and is not a browser method or anything . @justinbmeyer i got it working but i needed to modify 2 files inside can-stache will do pull request. @justinbmeyer i got it working but i needed to modify 2 files inside can-stache will do pull request. node --experimental-modules can-esm-load-node.mjs\n```js\n/ global global /\nlet myApp = import('./index');\nglobal.location = { href: ''};\nPromise.all([\n    import('can-vdom/make-document/make-document').then(m=>global.document=m.default()),\n    import('xmlhttprequest').then(x=>global.XMLHttpRequest = x.default.XMLHttpRequest)\n// We need to Import the App Dynamic as else we can't be sure that our Globals are set right\n]).then(()=>myApp.then(myApp=>new myApp.default()));\n```\nindex.mjs\n``js\nexport default import('can/core.min'))\n  .then(({ Component, route, stacheRouteHelpers })=>{\n    return Component.extend({\n      mixins: [stacheRouteHelpers], //=> Prevents Treeshaking of Mixins when async imported\n      tag: 'my-app',\n      view:CanApp Demo-\n            {{#if pageComponentPromise.isPending}}\n                Loading ...\n            {{/if}}\n            {{#if pageComponentPromise.isResolved}}\n                {{pageComponentPromise.value}}\n                {{# eq(routeData.page, \"hello-world\")}}\n                    Goodbye\n                {{ else }}\n                    Hello\n                {{/ eq}}\n            {{/if}}`,\n      ViewModel: {\n        routeData: {\n          default() {\n            route.register('{page}',{page: 'hello-world'});\n            route.start();\n            return route.data;\n          }\n        },\n        get pageComponentPromise(){\n          let name = this.routeData.page;\n      //return import('./'+name+'.js')\n      //console.log(import.meta).url;\n      return import('./components/'+name+'.js')\n        .then(module => new module.default())\n        .then(element=>element);\n    }\n  }\n});\n\n})\n. node --experimental-modules can-esm-load-node.mjsjs\n/ global global /\nlet myApp = import('./index');\nglobal.location = { href: ''};\nPromise.all([\n    import('can-vdom/make-document/make-document').then(m=>global.document=m.default()),\n    import('xmlhttprequest').then(x=>global.XMLHttpRequest = x.default.XMLHttpRequest)\n// We need to Import the App Dynamic as else we can't be sure that our Globals are set right\n]).then(()=>myApp.then(myApp=>new myApp.default()));\n```\nindex.mjs\n``js\nexport default import('can/core.min'))\n  .then(({ Component, route, stacheRouteHelpers })=>{\n    return Component.extend({\n      mixins: [stacheRouteHelpers], //=> Prevents Treeshaking of Mixins when async imported\n      tag: 'my-app',\n      view:CanApp Demo-\n            {{#if pageComponentPromise.isPending}}\n                Loading ...\n            {{/if}}\n            {{#if pageComponentPromise.isResolved}}\n                {{pageComponentPromise.value}}\n                {{# eq(routeData.page, \"hello-world\")}}\n                    Goodbye\n                {{ else }}\n                    Hello\n                {{/ eq}}\n            {{/if}}`,\n      ViewModel: {\n        routeData: {\n          default() {\n            route.register('{page}',{page: 'hello-world'});\n            route.start();\n            return route.data;\n          }\n        },\n        get pageComponentPromise(){\n          let name = this.routeData.page;\n      //return import('./'+name+'.js')\n      //console.log(import.meta).url;\n      return import('./components/'+name+'.js')\n        .then(module => new module.default())\n        .then(element=>element);\n    }\n  }\n});\n\n})\n. @justinbmeyer i found out that the problem was not can-stache its can-globals and the coding style of it that don't works out well when used asyncjs\nimport me from 'can-globals'\nimport other from 'other'\n```\ndont gets executed in order they run parallel and because of the prototype additions all over some functions are missing in some state.\nissu #4533 - is related to this as this is the base for it \nhttps://github.com/canjs/can-globals - has some open PR's that need discussion or merge so that all works more smoth. @justinbmeyer i found out that the problem was not can-stache its can-globals and the coding style of it that don't works out well when used async\njs\nimport me from 'can-globals'\nimport other from 'other'\ndont gets executed in order they run parallel and because of the prototype additions all over some functions are missing in some state.\nissu #4533 - is related to this as this is the base for it \nhttps://github.com/canjs/can-globals - has some open PR's that need discussion or merge so that all works more smoth. the owner of #4524 should look into this to have a example complet application using only CanJs with nativ ESM Methods.. the owner of #4524 should look into this to have a example complet application using only CanJs with nativ ESM Methods.. @Lighttree yes exact that is working but it needed a bit more research and tweaks for setting up the globals right. @justinbmeyer maybe something as simple as logging can-queue? and preserve state in a browser storage solution ? or as simple as offer a external endpoint to post the log to via api? Observation of can-queue . @justinbmeyer maybe something as simple as logging can-queue? and preserve state in a browser storage solution ? or as simple as offer a external endpoint to post the log to via api? Observation of can-queue . issu: #4524 is related because this enables exactly what @lighttree  requested decouple DoneJS CanJS aka decouple Steal CanJS boundary. issu: #4524 is related because this enables exactly what @lighttree  requested decouple DoneJS CanJS aka decouple Steal CanJS boundary. @Lighttree canjs can be build with any tool sure but rollup is a good nativ example it is the only nativ example at present without additional loader needed . @Lighttree the loader posted here is only for backward compat this will run nativ in script type module tags the loader only switches between that and systemjs or steal . @Lighttree yes thats exact what it is CanJS ESM Flavor + a other bundler then steal configured to produce the same or better result as steal them self. And the best it it falls back to nativ work even none bundled. @Lighttree this is loadable test able and use able directly without bundler or steal!. @Lighttree it also shows loading the modlet structure! like donejs does with nativ methods so again without steal but also using dynamic progressiv imports\n. @leoj3n i think the missing information is there but in the can-route documentation it self and that is linked in the guide do you think we should Make that link more visible?. @chasenlehara should look in here and choose if that algins in @leoj3n would you offer a PR?\n. maybe call it steal-stache-import ?. maybe call it steal-stache-import ?. here a starting point from me you can change it to use can@5 \nhttps://codepen.io/frank-dspeed/pen/xyvpKO. here a starting point from me you can change it to use can@5 \nhttps://codepen.io/frank-dspeed/pen/xyvpKO. @justinbmeyer can we make please this interface? with subscribe and unsubscribe?\nhttps://github.com/tc39/proposal-observable\n. @justinbmeyer can we make please this interface? with subscribe and unsubscribe?\nhttps://github.com/tc39/proposal-observable\n. @matthewp not really i was trying to play around with some converter tools and found out that it makes bad results \ni wanted to slim canjs a bit as it got tons of doubled functions and exports and all that and i get always a 1.3 megabyte unminifyed version of core.mjs this was much to big compared to any other lib \ni am trying to get a canjs that really only loads what is used and found out on my research that core.mjs is not as treeshake compatible as expected \nthe only good way i found is making it even more modular or replace a lot of stuff with dynamic imports\nbut at all i come to the final result i should forget about the original codebase complet and use only the canjs concepts and refactor it complet by hand \n\n1.3M    src/ is my bundle result\n\nimport DefineMap from 'can-define/map/map'\nimport Component from 'can-component'\nconsole.log(DefineMap,Component)\n. @matthewp not really i was trying to play around with some converter tools and found out that it makes bad results \ni wanted to slim canjs a bit as it got tons of doubled functions and exports and all that and i get always a 1.3 megabyte unminifyed version of core.mjs this was much to big compared to any other lib \ni am trying to get a canjs that really only loads what is used and found out on my research that core.mjs is not as treeshake compatible as expected \nthe only good way i found is making it even more modular or replace a lot of stuff with dynamic imports\nbut at all i come to the final result i should forget about the original codebase complet and use only the canjs concepts and refactor it complet by hand \n\n1.3M    src/ is my bundle result\n\nimport DefineMap from 'can-define/map/map'\nimport Component from 'can-component'\nconsole.log(DefineMap,Component)\n. @matthewp it simply gets not treeshaked it got complet  importet and i don't know why exactly we are debuging that but i think its { } from Syntax that makes the fail we plan to deprecate that all over\nwe know react and all are using it but it makes to much trouble but i think we can close this as your right this should not get used directly \ni think i will jump a bit into hyperHTML with Neverland ( A succesor over your haunted Package)\nhttps://github.com/WebReflection/neverland\n. @matthewp it simply gets not treeshaked it got complet  importet and i don't know why exactly we are debuging that but i think its { } from Syntax that makes the fail we plan to deprecate that all over\nwe know react and all are using it but it makes to much trouble but i think we can close this as your right this should not get used directly \ni think i will jump a bit into hyperHTML with Neverland ( A succesor over your haunted Package)\nhttps://github.com/WebReflection/neverland\n. @chasenlehara PR means Pullrequest i am preparing it at present. @chasenlehara PR means Pullrequest i am preparing it at present. @justinbmeyer is something blocking? is some one assigned to that already?. @justinbmeyer is something blocking? is some one assigned to that already?. @chasenlehara this issue is for my self so i know that i need to make this Pullrequest once i am ready but its a lot of work to get it in shape with the current Guide as its already really long. \nAnd the error with the current ES builds is that they are simply to big something don't works right with treeshaking. Maybe it has something to do with sideEffects of some packages. \n\nhttps://github.com/stealify/canjs/tree/setup-rollup-guide\ntracks the progress of this at present. @chasenlehara this issue is for my self so i know that i need to make this Pullrequest once i am ready but its a lot of work to get it in shape with the current Guide as its already really long. \n\nAnd the error with the current ES builds is that they are simply to big something don't works right with treeshaking. Maybe it has something to do with sideEffects of some packages. \n\nhttps://github.com/stealify/canjs/tree/setup-rollup-guide\ntracks the progress of this at present. @chasenlehara and some extra comment sorry i think its bad to close a PR only because of the reason the Core Team don't needs to investigate at present. As such a PR also Informs the Other OpenSource Team Members about Work In Progress so that they can combine efforts.\n\nMaybe CanJS Should find a new Way to Handle such things so it can evolve more fast.. @chasenlehara and some extra comment sorry i think its bad to close a PR only because of the reason the Core Team don't needs to investigate at present. As such a PR also Informs the Other OpenSource Team Members about Work In Progress so that they can combine efforts.\nMaybe CanJS Should find a new Way to Handle such things so it can evolve more fast.. @matthewp i am talking about nativ builds via the current node ESM Fork https://github.com/nodejs/ecmascript-modules + rollup it includes always much extra functions that never get used or called. i am maintaining a canes Fork of CanJS that is trying to get ESM Compatible as far as possible but there are a lot of blocking issues.. @justinbmeyer its not providing packages that are build with canjs like\n- can-crud \n- can-router \n- mock-url\nthey are Components using can-component as the core \nso this don't provides Components created with CanJS lets say smaller Components to build something bigger.\nbut i was mainly talking about a extra github.com/Organisation like github.com/canjs-components to split out Stuff that is not directly a Part of the CanJS Framework it self Infrastructure and Ecosystem are forming the CanJS Framework.\nhope that made sense.. @chasenlehara your right i agree we are in 2019 we have tools to identify the canjs packages by code and fork them into different organizations good point. . ",
    "christopherjbaker": "I wrote a quick script that pre-builds a lunr index by crawling the generated doc folder for all html files. There are currently 1006 documents and creates an output file at 2.8mb (1.8mb if we don't index <code> blocks) which compresses to 459kb (or 291kb) when gzip is available. There would also need to be a map that holds info about each document (url, title, short description) (though the presence of this would be able to reduce the size of the index, as I used teh URL as the index IDs). The API is pretty straight forward if we wanted to go this route. Updates here would be part of the bit-docs command and would just deploy as before.\nAlgolia's free account allows 10,000 records, so we would easily fit there. For this option, we would have to re-index and upload to algolia on deploy, so making it reusable outside canjs.com would be a bit more complicated (I don't know how extensible bit-docs is).. Bit of an extra feature, but could apply to any proposal. It might be worth trying to modularize the actual dom rendering component, in order that it can be swapped out for other renderers (native ios, native android, threejs/webgl, pdf, etc). I would think they could all use the same (or nearly the same) diffing (perhaps it might have some options set by the renderer?), and some sort of common API that they hook into (method calls, event system, etc).. added a (meta) proposal at #3248. added JSX proposal at #3252. fixed in #3381. I think this should be fixed in #3381. can this be closed now, @justinbmeyer?. Unfortunately, jshint only checks things that can contribute to errors or potential problems (== vs ===, assignments where statements are expected, etc). It says nothing about code style consistencies (tabs vs spaces, inline whitespace, single vs double quotes, semicolons, etc). (note: some of these were previously is jshint, or still are but are deprecated. Their official stance is to limit to \"code correctness\".)\nAs far as semistandard, its just a specific set of eslint rules. I would be inclined to use a ruleset that most closely matches what people are already doing. Standardize the existing rules, rather than imposing new rules. Justin mentioned that the jQuery Style was used primarily, and I found their rules to match to the current code quite well (only real inconsistencies are indents and if/for spacing, both of which are fixed with --fix). Using --fix solved nearly every issue, leaving 5-10 per project. In general (only a few exceptions), I could care less what the rules are, only that they are consistent. Once the rules are established, it shouldn't require much more discussion.. When cleaning up markdown sample code, I applied this eslint config, which is a duplicate of jquery's official config using tabs and with no-console.\nI would like to re-open this discussion. While I understand the reasons for not fixing everything right off (mainly that it interferes with blame), it could be added to all projects but not run as part of tests yet (or run in a way that won't make them fail). Sections that are being modified anyway could be fixed as part of the commit without interfering with blame.. @matthewp I confess I had not seen that that proposal. I looked at comments on #2995 but didn't realize it was an epic and that there were other attached proposals. In structure, it is not different.\nI had seen hypertext before, though did not consider using it to handle can rendering. Would we be able to get performance comparable to can-stache without direct control? Or were you just proposing to using their structure (ala can-stach vs mustache)?. When running locally, I get an error of Uncaught TypeError: Failed to execute 'dispatchEvent' on 'EventTarget': parameter 1 is not of type 'Event'. (the exact test that fails varies) in both dev and production (had to add steal-css and change the steal.prod.js path in production.html to get it to build and run in production). I narrowed that error down to being called on a <p> created in a test, and if I disable the test that creates it by switching it to QUnit.skip, everything passes fine. I cannot see why this would cause that error, and why it would happen so much later. Also, if that error is caught and ignored, all tests pass too.. Adding start/stop to that test did not make a difference, but a new empty test with a short delay did. With that change, this passes all tests locally.. fixed in #3381. Current test failures are fixed in canjs/can-stache-converters#34. fixed in #3381. fixed in #3381. Closing. Accidental release.. The following PRs have been opened:\n https://github.com/canjs/can-define-list/pull/2\n https://github.com/canjs/can-connect/pull/408\n https://github.com/canjs/can-set/pull/85\n https://github.com/canjs/can-vdom/pull/44\n https://github.com/canjs/can-validate/pull/71\n https://github.com/canjs/can-observe/pull/46\n https://github.com/canjs/can-fixture/pull/146\n https://github.com/canjs/can-zone/pull/163\n https://github.com/canjs/can-define/pull/317\n https://github.com/canjs/can-view-href/pull/47\n https://github.com/canjs/can-util/pull/415\n https://github.com/canjs/can-compute/pull/128\n https://github.com/canjs/can-component/pull/222\n https://github.com/canjs/can-construct/pull/54\n https://github.com/canjs/can-route/pull/155\n https://github.com/canjs/can-event/pull/76\n https://github.com/canjs/can-stache-bindings/pull/430\n https://github.com/canjs/can-view-callbacks/pull/82\n https://github.com/canjs/can-view-import/pull/100\n https://github.com/canjs/can-view-nodelist/pull/44\n https://github.com/canjs/can-view-parser/pull/89\n https://github.com/canjs/can-view-scope/pull/150\n https://github.com/canjs/can-view-target/pull/61\n https://github.com/canjs/can-observation/pull/126\n https://github.com/canjs/can-stache/pull/465\n https://github.com/canjs/can-view-model/pull/63\n https://github.com/canjs/can-route-pushstate/pull/87\n https://github.com/canjs/can-connect-feathers/pull/105\n https://github.com/canjs/can-simple-map/pull/60\n https://github.com/canjs/can-stream-kefir/pull/64\n https://github.com/canjs/can-stache-converters/pull/80\n https://github.com/canjs/can-define-stream/pull/60\n https://github.com/canjs/can-fixture-socket/pull/61\n https://github.com/canjs/can-define-backup/pull/7\n https://github.com/canjs/can-validate-validatejs/pull/21\n https://github.com/canjs/can-connect-signalr/pull/37\n https://github.com/canjs/can-zone-storage/pull/14\n https://github.com/canjs/can-define-stream-kefir/pull/28\n https://github.com/canjs/can-define-validate-validatejs/pull/48\n https://github.com/canjs/can-parse/pull/7\n https://github.com/canjs/can-element/pull/49\n https://github.com/canjs/can-connect-cloneable/pull/19\n https://github.com/canjs/can-ndjson-stream/pull/30\n https://github.com/canjs/can-connect-ndjson/pull/14\n https://github.com/canjs/can-symbol/pull/25\n https://github.com/canjs/can-reflect/pull/101\n https://github.com/canjs/can-migrate/pull/69\n https://github.com/canjs/can-param/pull/9\n https://github.com/canjs/can-stream/pull/13\n https://github.com/canjs/can-global/pull/2\n https://github.com/canjs/can-is-browser-window/pull/1\n https://github.com/canjs/can-globals/pull/40\n https://github.com/canjs/can-stache-animate/pull/47\n https://github.com/canjs/can-validate-interface/pull/12\n https://github.com/canjs/can-make-rest/pull/17\n https://github.com/canjs/can-dom-mutate/pull/29\n https://github.com/canjs/can-stache-key/pull/27\n https://github.com/canjs/can-debug/pull/39\n https://github.com/canjs/can-attribute-encoder/pull/16\n https://github.com/canjs/can-kefir/pull/15\n https://github.com/canjs/can-test-helpers/pull/11\n https://github.com/canjs/can-queues/pull/14\n https://github.com/canjs/can-jsx/pull/7\n https://github.com/canjs/can-compute-memoize/pull/10\n https://github.com/canjs/can-key-tree/pull/10\n https://github.com/canjs/can-simple-observable/pull/19\n https://github.com/canjs/can-define-lazy-value/pull/4\n https://github.com/canjs/can-event-queue/pull/16\n https://github.com/canjs/can-observation-recorder/pull/6\n https://github.com/canjs/can-stache-route-helpers/pull/4\n https://github.com/canjs/can-reflect-dependencies/pull/14\n https://github.com/canjs/can-reflect-tests/pull/7\n https://github.com/canjs/can-stache-helpers/pull/3\n https://github.com/canjs/can-define-map/pull/1. @chasenlehara Since I am running the code samples in the rest of the projects through lebab anyway, I can have that mod also switch to imports.. This has been settled on #3846. I have the code to do this on my codemod, but due to the objection by @justinbmeyer, I did not include it when running. Does this need more discussion?. If you think it is out of scope, I can't argue. While it seems to be becoming popular, including being used on one of our projects, I can't provide much statistics to this point (though now I'm curious and checked npm and github. styled-components has about 13% as many downloads in the last month vs react-dom, and about 15% the github stars).\nFor accuracy, however, I do want to add that CRA does not support SASS, LESS, or CSS modules, it only supports raw CSS (their offered solution is to build your sass using an external tool and include its output in your html manually). It was this limitation (CRA forbids any kind of customization) that lead me to styled components initially, which are usable in a CRA app, as it is just pure React (styles are injected into the head at runtime).\nWhile it could probably be mixed into the VMs with relative ease (especially with decorators on can-observe), I liked how a deeper integration could create a complete separation between the view's structure and style.. Unfortunately, it was very manual. You cannot always use const, though in our case you can most of the time.. If we had eslint set up, that has an automatic ability to do this, but we aren't set up to do that at the moment (and I don't think it could handle js blocks in markdown).. This now has the same treatment as https://github.com/canjs/can-define/pull/317 and similar, though also applied to the guide code itself. The debug names remain, to be revisited with #3848. Current Issues:\n [x] Shadow under code blocks\n [x] Alternating line colors drift\n [x] Highlight standalone code\n [x] Horizontal scrolling?\n [x] Some newlines being removed? (/doc/guides/todomvc.html)\n [x] Color template strings with html as HTML\n* [x] Highlight doesn't look good\n  * [x] add line-highlight plugin\n  * [x] integrate line-highlight plugin with bit-docs-html-highlight-line\n  * [x] create collapse plugin\n    * [x] collapse line-numbers\n    * [x] collapse line-highlight\n  * [x] integrate collapse plugin with bit-docs-html-highlight-line. Though I think much of this was said by @BigAB, I think it is worth repeating in my own words. TLDR at bottom.\nI think we should absolutely do the first 3 of your bullet points under \"next steps\" (see below for notes on the 4th bullet point). There are some changes that still need to be made, but I don't think any of these prevent moving forward, they just need to be settled before we \"release\" it.\nDocs\nI think the RVM page should have basic docs self-located. Function signatures, example uses, etc. Those can link to equivalent pages in the canjs docs, which tend to be much more technical, which is perfect. I think directly them straight there would lose some (if for no other reason than they can get lost in the sea of canjs).\nI think there should be 1 doc page for can-observe with basic usage + decorators, linking back to canjs for more details/examples/building decorators. can-observe is so vital to rvm that new users will be required to read a bit about it to do anything beyond the demos, and my same argument above applies.\nIn addition to \"we are better than X because\" (with whatever level of tact is decided), there should also be \"switch to RVM from X like this\" (perhaps \"upgrate to RVM from X\" instead?).\nSignatures\n\nThe current stable RVM uses extending syntax. I think this method should be abandoned, though it can certainly be preserved in a deprecated state for a while (this is what the current client is using).\nThere is an @connect branch that provides a Higher-Order Component interface, generally through a decorator (though a function call works just as well). I think this should be the default as presented in docs/etc.\nAdam has proposed a provider (VMComponent) interface that is very similar to the new way that react handles context (example can be found here, scrolling down to the first gray code box). I think this is a good idea, though I think the structure should be reconciled with react context (as this is an established react pattern), but I don't think it would change much. This method provides distinct features over the @connect syntax, making it very clear when to use one over the other. This would be the advanced form.\n\nMy reasoning for rejecting extend in favor or HOC or providers is to make the react component itself as plain-react as possible, with no special knowledge. That way the VM can be connected to to any existing component (even 3rd party components) with 0 changes, and people using other state management systems like redux won't have to change their components at all, only create VMs that mimic their previous state files and change their xxHandler calls to vm calls (IE: instead of <div onClick={() => this.clickHandler()) />, where clickHandler dispatches an action, you do <div onClick={this.props.clickHandler} />, whereclickHandler` on the vm just does' whatever it needs to do).\nCh-ch-ch-ch-Changes (Turn and face the strange...)\nFor the @connect syntax, there is a performance problem that needs to be resolved. Basically, the viewmodel instance is shallow-cloned (and all methods are bound) when it is passed into the react app. I am quite sure I can resolve this without much effort. While this needs to be fixed, it will not change the usage at all. The docs for this need to be finished.\n@justinbmeyer proposed passing the props to the viewmodel in such a way that the input props and any derived props and state were separate (react has a distinction between this.props and this.state). While I see the logic, I do not think this is a good idea. I do think that it is a good idea to point out how this (and other \"don't merge props with vm\" styles) can be accomplished (last point below) in an \"advanced techniques\" section.\n1. If you were to use those values without derived getters, your jsx might look like <div>{this.props.props.name}</div>\n1. I do not think the original source of information is relevant, only that the information exists for the component.\n1. None of RVMs competitors, AFAIK, do this and I would like to make adoption as easy as possible (especially from redux, as it is the most popular option for state management besides \"nothing\", which has almost twice as many users as redux).\n1. It is rather easy to do this yourself in the can-observe constructors if you prefer it. I found in my own apps that I often override the default \"merge all props into the VM\" with custom locations anyway.\nTLDR\n\nNew name\nStandalone site with basic docs on RVM and a single page of can-observe.\nUse @connect as default. have provider interface (mimicking reacts new context interface) for advanced usage. Abandon extend.\nFix performance issue in @connect and finish docs.\nBuild out provider/consumer components with docs.\nMore docs, including advanced usage and comparison/upgrade vs competitors (redux, and maybe mobx).. Might be worth running this codemod against all the markdown files in this repo. It looks like it didn't get run against canjs/canjs when i ran it against everything else.. \n",
    "adrifolio": "@BigAB thanks for all of the detail! I can grab this one. Can you assign it to me? I was going to do it myself, but that option doesn't look enabled to me.\n. @BigAB @tomgreever here's a mockup of the first diagram:\n\nLet me know if you think this direction works. Thanks!\n. Hey @BigAB,\nAs discussed, I've included the \"Action Creations\" in the first graphic:\n\nI've also I worked on the second graphic. For this I thought a horizontal layout was easier to read. Also note that I removed \"Video Chat\" from the action creators, as it looked pretty cluttered. Let me know your thoughts. Thanks!\n\n. Cool @BigAB!\nA have a small update for the 2nd graphic (moved the text on the right to be over the arrow, vs at the end):\n\nAnd the other two graphics:\n3.\n\n4.\n\nLet me know if this looks good to you or if you have any updates. Once these are all squared I will open a PR to add them to the docs. Thanks!\n. @justinbmeyer I cloned the bin here: http://jsbin.com/bahinof/edit?html,css,output\n\nNotes:\n- I moved the error message to the top. \n- I'm pending to add the styles for the field when there is an error\nLet me know your thoughts!. Added error styles:\n\n. @justinbmeyer check this out:\n\n. Here's another idea:\n1.) Show the entire name of each toggle\n\n2.) Show colored squares next to each package according to group they belong to. In the example below, ecosystem and legacy have not been selected.\n\nNote that the color for each group would needs more consideration, I just picked some random colors to show this concept.\n. @justinbmeyer check this bin with the styles: https://jsbin.com/ficiga/25/edit?html,css,js,output\nI'm having issues with JSBin. Is taking forever to load now and it won't show me CSS changes :(\nIn any case, the forms are done, but I wasn't able to load them to grab screenshots.\nA couple of notes:\n- I removed he <p> tags that were around the input fields\n- I added a class to the paragraph with the welcome message. ",
    "roemhildtg": "I had a chance to test the script here: https://gist.github.com/sszabolcs/3455514b8b7f418160966ed8fd169b8c and it works well for outputting an amd build of canjs. . This was related to can connect and a custom behavior. Fixed now. . https://regex101.com/r/iZdrAM/2. I changed the branch to major, is that what you meant? Or should I re-run the landscaper against the major branch?. No worries! Its super easy now that there's a landscaper gist. . Updated. Its weird that some files worked and others didn't. Line ending style perhaps?. This also happens with {{#with()}}. Probably all branching logic:\nhttps://jsbin.com/sitepaxazu/edit?html,js,output. The value that's getting set is the can.getKeyValue symbol. Its calling the assignSymbols and iterating through.\nThis is what it looks like:\n\n. Sure - http://jsbin.com/pubiqoc/1/edit?html,js,output\nIt basically happens in any polyfilled canjs application in IE11 I think.. There's also https://github.com/lerna/lerna . Something to consider. . You need to add something like this to your production webpack config:\noptimization: {\n        minimizer: [\n            new UglifyJSPlugin({\n                uglifyOptions: {\n                    output: {\n                        comments: false,\n                    },\n                },\n            })],\n    },\nIt seems silly that this comments aren't removed by default, and the option to do so is nested 6 objects deep but that's what I've found frustrating in webpack. . ",
    "jimaek": "The new backend is live. It pulls files directly from npm and github https://github.com/jsdelivr/jsdelivr#usage\nExample https://cdn.jsdelivr.net/npm/jquery@3.1.1\nExample directory listing https://cdn.jsdelivr.net/npm/jquery@3.1.1/. ",
    "0joshuaolson1": "For testing accessibility, plenty of tools are a good starting point to fix that.\nThey would, however, miss more manual/design QA problems like the website's approach to feedback. (\"This unlabelled logo looked like a contrast toggle, so I accidentally visited another website; also there's no direct link to an issue tracker.\")\nThis seems like a PR issue to me, since I personally judge libraries/frameworks by the areas they remember like accessibility features/components/links/education.. ",
    "andreaalmeida": "Updated homepage design:\n- Re-organized side navigation pages (mockup included)\n- Added border around turtle hare images so that they look more like one image, instead of two separate ones\n- Moved NPM Package, Github Star, and GitHub edit links/buttons in-line with page title\n- Styled Edit page in Github link to look like a button\n- Removed collections and packages sections (now live on API docs page)\n- Added logos of companies that use CanJS\n- Increased font-weight of \"on this page\" to make it more noticeable \n\n\n. Mockup of API Docs page - moved Collections and package sections from homepage\n\n. ",
    "bgando": "When canjs has a release, pull the latest release notes from the updated can-* packages and aggregate them into the latest canjs release notes.. I am still experiencing these errors after the tests run, but I do not believe it is related to can-connect-ndjson or can-ndjson-stream.\n\nJustin OK'd these errors\n. Error loading the dependencies for the demos:\n\n. hardcoded right now to generate 3.10.0 and 3.10.1 notes. ",
    "perehnbom": "Hi, yes I've identified the problems. Im happy to submit pull requests to\nthe repos. It's the first time I do that for CanJS but I guess it shouldnt\nbe too hard.\n/Per\nOn Fri, Nov 25, 2016 at 1:36 PM, Matthew Phillips notifications@github.com\nwrote:\n\nCan you submit PRs to those repos? Looks like you already did the work to\nidentify the problems.\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/canjs/canjs/issues/2780#issuecomment-262949350, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/AIjm-62kNZh55jAZrgRUTKXCBhvTOVwJks5rBtZQgaJpZM4K8ScO\n.\n. The changes made in can-compute, can-util, can-stache, can-view-model, can-view-live and can-simple-map are sufficient to run the basics: can-control, can-define and can-stache. I have however looked over all can modules and have found similar problems in the following:\n\ncan-ejs\ncan-fixture-socket\ncan-legacy-view-helpers\ncan-map-backup\ncan-map-define\ncan-stache-converters\ncan-stache-bindings\ncan-view-href\ncan-view-import\nI will go over and make similar pull requests for these modules as well. I should be thanking you, CanJS is in my opinion the best framework out there if you're looking to build an advanced SPA. And I've been working with quite a few frameworks.. These changes should be sufficient for all canjs modules to work with webpack. I encountered another problem when using can-fixture. Both webpack 1 and 2 gives an error when requiring can-fixture, and the problem is because of the code snippet require.resolve in fixture.js:\nif(typeof window !== \"undefined\" && !require.resolve) {\n    window.fixture = fixture;\n}\nI\u2019m not quite sure why this is a problem in webpack but I\u2019ll post a PR all the same that eliminates the problem. I'll let you decide whether to accept it or not.. Another problem encountered in webpack 2 but that works in webpack 1 is the following in can-connect/data/url/url.js:\nvar getIdProps = require(\"../../helpers/get-id-props\");\nThat is strange since similar requires in e.g. can-util works fine:\nvar assign = require(\"../../js/assign/assign\");\nvar namespace = require(\"../../namespace\");\nvar parseURI = require('../../js/parse-uri/parse-uri');\nAnd the require of get-id-props works fine when using\nvar getIdProps = require(\u201dcan-connect/helpers/get-id-props\");\nIt looks like it has something to do with the name starting with get- but I would consider that being a bug in webpack 2, not CanJS, and maybe that should be filed as a webpack bug.. After looking more closely into the problems described about can-connect I found the following: \nIn can-connect/package.json there's a property \"browser\" which sets up module paths. The paths are defined so modules point to the dist folder e.g \"./helpers/get-index-by-id\": \"./dist/cjs/helpers/get-index-by-id\". I dont see similar use of \"browser\" in other canjs modules.\nWebpack 2 seems to use the \"browser\" property in order to resolve module paths, and since the path is to the dist folder and not the source, the build fails. \nI'm not quite sure why this configuration in can-connect is there in the first place, but by either removing the \"browser\" property, or set the paths point to the source instead of the dist, the problem is solved.\nUpdate: the \"browser\" paths are set as part of the build.js job. Thanks, I can setup a PR for can-connect if you want me to.. thanks @matthewp , I hadnt had the time to go over it yet. I've upgraded to canjs 3.2.0 + can-connect 1.0.14. Everything I've covered in my test application now works with both webpack 1 and 2.. canjs 3.2.0 uses can-connect 1.0.12 so that would need an upgrade in the next release. . Thanks @justinbmeyer . Thanks, this solved the issue for me. In my real case scenario, each item does actually have a projectId. However, the json format is \nitems : [{\n   id : 1,\n   projectId: 1\n}]\nand not \nitems : {\n   data : [{\n      id : 1,\n      projectId : 1\n   }]\n}\nChanging to the 2nd format solved the problem without using\nitems.set(\"__listSet\",{projectId: this.id}). I consider this solved, closing the issue. . ",
    "imaustink": "@chasenlehara with all the structure changes coming to the site I feel like it would be safe to remove this page entirely. Do you concur?. Okay, what do you think about renaming it to \"API Introduction\"? I am not sure where we would move it that is more relevant than the \"guides\" sections. Any thoughts?. I opened a PR that matches the mockup. Maybe we should have a quick discussion about other options first though?. @justinbmeyer Switching to baseMap doesn't fix the demo: https://github.com/canjs/canjs/compare/2980-fix-peginate-demo?expand=1\n@chasenlehara looks like other demos on that page are showing that same HTML. What would you expect to be there? Seems like that's the only markup that isn't made in stache land.. I've added a proposal here: #3197. Fixed demos\nAdded AppState example\nUpdated route slug syntax in docs. I was just gonna make a separate PR but I don't really see a point so I just updated this one to include https://github.com/canjs/canjs/issues/2868 :). @chasenlehara I removed the inline styles and made a PR to move them to the less files https://github.com/canjs/bit-docs-html-canjs/pull/267. I created a PR to update the styles and move the images:\n\nJust need @justinbmeyer and @brianmoschel to take a look at this section:\n\n. Updated the PR :). Fixed \ud83d\ude03 \n\n. @justinbmeyer I've updated the PR. It should allow hosting it 'relatively' and fix the images on the about page. I also have PR in to fix the signature parameters.. Yes sir, I have a PR in https://github.com/canjs/bit-docs-html-canjs/pull/325. I will add you as a reviewer.. @matthewp they are now. The build won't pass without upgrading those deps. Mostly upgrading just removed can-util/log and can-util/dev but I think there was a least 1 other fix as well.. I'm not sure they ever existed. They didn't exist at the time that those docs were created: https://github.com/canjs/canjs/tree/9d85275910051693d7952ed876a4ecf56e8cde2a. More issues found:\n- X button in search bar not visible on mobile [can\u2019t reproduce]. @phillipskevin You're correct, I missed that and thought it was a typo. I've updated the PR to add a new demo for selected-to-index.. Okay, I've updated the description. Let me know if you don't like the new one. I can try to come up with alternatives.. Done and updated the original commit \ud83d\ude03 . Oh, shoot! I thought you were referring to the inline <style> tag I was using before. I will update the PR again.. Strange... I installed that when I was trying to debug using this with the local copies of the plugins, but I didn't use the save flag so I'm not sure how this got added.. Actually, this is needed. Otherwise and error is thrown: \n```\n/Users/austin/bitovi/canjs/node_modules/bit-docs/lib/configure/node_modules/q/q.js:155\n                throw e;\n                ^\nTypeError: siteConfig.finder is not a function\n    at generateOne (/Users/austin/bitovi/canjs/node_modules/bit-docs/lib/generate/generate.js:49:36)\n    at generateAndWatch (/Users/austin/bitovi/canjs/node_modules/bit-docs/lib/generate/generate.js:82:10)\n    at /Users/austin/bitovi/canjs/node_modules/bit-docs/main.js:6:10\n    at _fulfilled (/Users/austin/bitovi/canjs/node_modules/bit-docs/lib/configure/node_modules/q/q.js:854:54)\n    at self.promiseDispatch.done (/Users/austin/bitovi/canjs/node_modules/bit-docs/lib/configure/node_modules/q/q.js:883:30)\n    at Promise.promise.promiseDispatch (/Users/austin/bitovi/canjs/node_modules/bit-docs/lib/configure/node_modules/q/q.js:816:13)\n    at /Users/austin/bitovi/canjs/node_modules/bit-docs/lib/configure/node_modules/q/q.js:624:44\n    at runSingle (/Users/austin/bitovi/canjs/node_modules/bit-docs/lib/configure/node_modules/q/q.js:137:13)\n    at flush (/Users/austin/bitovi/canjs/node_modules/bit-docs/lib/configure/node_modules/q/q.js:125:13)\n    at _combinedTickCallback (internal/process/next_tick.js:67:7)\n```. ",
    "gKreator": "This is perfect. I suggest a beginers guide page is made.. Maybe use a title tooltip on the module name to display the textual description. Or vice versa. \nThe shorthand module name is as far as I know a StealJs thing. Therefore it can be confusing to people using other module loaders. I would be careful in this and state this clearly. I would see there being a toggle button to switch between the views.. Yes, I agree. Using the common variable name is allot smoother. I would just have the real name as a tool tip at least.. I agree. I think the docs are fairly light at the moment since they just launched.. I thought a similar thing with the low count, but how will you get the count higher if you don't display the buttons prominently? . Sounds good :). ",
    "jamiemccue": "@chasenlehara What about linking to the next page in the navigation? \nExample: Mission would link to Technical Highlights. @chasenlehara How can we find out how they are using CanJS? Is that a matter of tracking down the devs and asking?. Removed CanJS from the title. I vote we close this issue with the acknowledgment that going forward we create a centralized folder/repo (style guide) for the team to grab design resources from. The URL to access would be in the Github readme for the projects. This would make it easy for a Bitovi designer unfamiliar with the project to start contributing. (Like myself recently). Create design.md file in the contribute docs (https://github.com/canjs/canjs/pull/3367/commits/85003282aef3bf1db2f64ca7eeccec683643c62e):\nhttps://github.com/canjs/canjs/tree/master/docs/can-guides/contribute\nOrganize project resources into shared folder on google drive:\nhttps://drive.google.com/drive/folders/0B9uYesPecByGcnRpbFV4bUFQWGM?usp=sharing\nhttps://github.com/canjs/canjs/pull/3367/commits/85003282aef3bf1db2f64ca7eeccec683643c62e. @chasenlehara Can you review this page for content, layout, anything missing?\nhttps://github.com/canjs/canjs/commit/9dce62482f7bf82b24f7dbb93780576e7efac8f7. ",
    "blazepollard": "Here is the newly updated graphic:\n\n. I've added the new image to this PR: \nhttps://github.com/canjs/canjs/pull/3203\nI did the diagram in Axure, I've attached the PDF file here:\nflowchart_for_canjs.pdf\nWhere would be a good location for this Axure file? \n. ",
    "greenkeeper[bot]": "Version 1.0.10 just got published.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\n9d2cb33 Update dist for release\naf3a1f5 Update can-define tests to use types.DefineMap (#124)\n79cac1b Make JsHint ignore the ./dist directory (#122)\n\nSee the full diff.\n\n. ## Version 1.0.21 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits .\n\ndf36f43 Update dist for release\nca173fb Merge pull request #227 from canjs/realtime-destroyed-instance-calls-destroyed-instance\n9df7653 Remove commented line.\ncef5d9e Make sure destroyInstance calls destroyedInstance\n\nSee the full diff.\n\n. ## Version 1.0.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.0.8 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.0.9 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits .\n\n34e26dd Update dist for release\n7e374ff Merge pull request #234 from canjs/map-merge-fixes\ndcc8b58 removing hydrate via type test\na581248 you SHOULD use Ref instead of Ref.type\nd42e68d fixing problems with merging\n\nSee the full diff.\n\n. ## Version 1.0.13 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\ne98cd2f Update dist for release\n3134aa6 Merge pull request #135 from canjs/seal-test-in-dev\n707314a don't run Object.seal test in production mode\n\nSee the full diff.\n\n. ## Version 1.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.0.11 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.2.0-pre.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.2.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.2.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.2.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.2.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.2.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.2.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.2.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\n7d150d4 1.2.7\n6170809 Merge pull request #1067 from stealjs/move-loader-deps\nc7de081 Move steal-es6-module-loader to package dependencies\n\nSee the full diff.\n\n. ## Version 0.6.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\nf79c183 0.6.4\n101575d Merge pull request #107 from canjs/number-timeouts\n1e7e611 Store timeout ids correctly when they are a number\n\nSee the full diff.\n\n. ## Version 3.0.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits .\n\n6cb99c3 Update dist for release\n\nSee the full diff.\n\n. ## Version 3.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits .\n\na376018 Update dist for release\n0f00152 Merge pull request #56 from canjs/session-auth\nb557ef2 added test for isAuthenticated; upgraded to latest can-fixture-socket\n03b64ea set isAuthenticated flag for session\n\nSee the full diff.\n\n. ## Version 3.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits .\n\n07e4bc5 Update dist for release\n712ea7a Merge pull request #57 from canjs/revert-session-tokendata\n29c2671 upgraded can-fixture-socket\n6bc7d6d Revert \"Return stored token data in initial session.\"\n17dfa7e Revert \"set isAuthenticated flag for session\"\n06e6b1e Revert \"added test for isAuthenticated; upgraded to latest can-fixture-socket\"\n\nSee the full diff.\n\n. ## Version 3.5.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits .\n\nd0d886c Update dist for release\n22e34cb Merge pull request #59 from canjs/bugfix-infinite-loop\n8a41bac updating the test\n938df76 call session.get() only if session.current is undefined (not null)\nb7ed163 Update dist for release\nfdbb6da Merge pull request #58 from canjs/session-states\nfba2343 session states: null for non-auth\n\nSee the full diff.\n\n. ## Version 3.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\nd081f86 Update dist for release\n4faa655 Merge pull request #32 from canjs/steal-upgrade\na1ddb1f Upgrade steal\n\nSee the full diff.\n\n. ## Version 1.3.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits .\n\nd2bf418 Update dist for release\n930fd22 Merge pull request #248 from canjs/can-ref/hydrate-value\nbcf610e can/ref check if value is an instance; removed sinon\n2d98445 fixed can/ref to hydrate value if it has not been defined\n8742fcc Merge pull request #241 from canjs/docs/240/weak-ref-remove-reference\n13ecd26 fixed wrong method name is docs for weak-reference-map Use section #240\n\nSee the full diff.\n\n. ## Version 1.3.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits .\n\n64f3623 Update dist for release\n0b061f8 Merge pull request #245 from canjs/issue/244/max-call-stack-when-no-id\nb02f033 skip undefined key for weak-reference-map\nc966ad2 added failing tests for #244\n\nSee the full diff.\n\n. ## Version 1.3.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits .\n\n3b7d50b Update dist for release\n3e786df Merge pull request #253 from canjs/callback-once-method\n284895d simplified test - removed DefineMap\n459f27d simplified test\n9cbc70b callback-once: save last data with method name suffix to distunguish method calls\n\nSee the full diff.\n\n. ## Version 1.3.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\n5821aa8 Update dist for release\nb6d5a98 Merge pull request #256 from canjs/algebra-id-supermap\n962f881 using idProp from set algebra in supermap\n\nSee the full diff.\n\n. ## Version 1.3.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits .\n\n0c6bb52 Update dist for release\n3ca542e Merge pull request #257 from canjs/smart-merge-id-prop\nc366ade smart-merge: read id usign connection.id\n05b3eab smart-merge: retrieve id correctly in idFromType from algebra\ne8a762e smart-merge: added a failing test for a custom id\n\nSee the full diff.\n\n. ## Version 1.3.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\n484074c Update dist for release\ncc1b9c7 Merge pull request #258 from canjs/smart-merge-id-bug\n826196c smart-merge: use connection.id as method not just function\n\nSee the full diff.\n\n. ## Version 3.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\na821972 Update dist for release\nc3a716c Merge pull request #32 from canjs/loc\n3caadd9 Use can-util/dom/location/location\n\nSee the full diff.\n\n. ## Version 1.2.9 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.2.10 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.2.11 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.0.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits .\n\n9e6f811 1.0.4\n998230d Add preversion script to run tests before publish\n\nSee the full diff.\n\n. ## Version 0.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 0.3.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 0.3.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 8 commits0.\n\n7bee023 0.3.2\nff54566 Catch getJWT promise errors (#46)\n2399ff3 chore(package): update semistandard to version 11.0.0 (#43)\nf9b728b chore(package): update feathers-hooks to version 2.0.0 (#42)\nf9b5921 Update dependencies to enable Greenkeeper \ud83c\udf34 (#40)\n5e657aa Merge pull request #36 from hubgit/patch-1\n4bf77be Note that auth must be configured after rest/socket clients\n0a74315 Updating changelog\n\nfalse\nSee the full diff\n\n. ## Version 1.3.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.3.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.4.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits .\n\n6871bc3 1.4.1\nb077621 Merge pull request #1147 from stealjs/fetch-babel\na469a3e Prevent unwanted global package name loading\n9ca23bc Merge pull request #1142 from stealjs/contextual-plugin-loader\nd613bc2 Use pluginLoader in contextual extension\n\nSee the full diff.\n\n. ## Version 1.4.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 37 commits .\n\n97be2e7 1.4.2\ne9a9444 Merge pull request #1164 from stealjs/lr-error\nc42cb6a Log an error when unable to connect to ws server\nc6e7629 Merge pull request #1161 from stealjs/cjs-detection\ne939257 Improve CJS module format detection\n05227f5 Merge pull request #1160 from stealjs/remove-babel-core\n35533bb Replace babel-core with babel-standalone (patch)\n336f6a0 Remove old deprecated babel files (patch)\n71ef85c Merge pull request #1159 from stealjs/opt\n4b07e48 Ext plugin: make sure to pass normalized name\n8848364 Don't run linting in Node 0.12\n3be05a8 Prevent mutating params\n2e20c32 Merge pull request #1149 from stealjs/greenkeeper/grunt-contrib-uglify-2.3.0\n2204e49 Merge pull request #1151 from stealjs/greenkeeper/https-browserify-1.0.0\n41d48d9 Add updated steal production file (patch)\n\nThere are 37 commits in total. See the full diff.\n\n. ## Version 1.4.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 17 commits .\n\nc5d165a 1.4.6\n494337c Merge pull request #1174 from stealjs/stuff\n53aa03c Update progressive loading guide with weather widget\n6be0936 1.4.5\naf8be69 Merge pull request #1162 from stealjs/update-contributing\n02acb7c Multiple updates to the Contributing guide\n3ae9f6a Merge pull request #1173 from stealjs/lr-dispose\nb2bb33c Add a path to the local live-reload\nfe5c3a7 Use Firefox 52 in saucelabs\n69724c9 Call dispose callback when disposing a module\nad1159b 1.4.4\ncb104c2 Remove undefined reference\n345ec98 Merge branch 'master' of github.com:stealjs/steal\n7a021ee 1.4.3\n04593df Remove noisey error message\n\nThere are 17 commits in total. See the full diff.\n\n. ## Version 1.5.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n1.5.0\nThis is a minor release of steal that adds the new homeAlias option and a new build of steal.js that excludes the promises polyfill.\nFeatures\nhomeAlias\nSteal 1.0 added the tilde operator that allows you to reference your project's root/home folder using the ~ scheme like so:\n \nThe ~ character was chosen because it correlates nicely to the concept of home directories in the filesystem. However since some ecosystems have this same idea but use another character (for example, in the Vue community using @/ is common) the homeAlias config option was added so that you can change what character is used to indicate the home folder.\n{\n  \"steal\": {\n    \"homeAlias\": \"@\"\n  }\n}\n \nThe ~ scheme is the default homeAlias, so no configuration is needed to use that.\nsteal-sans-promises\nNow that it is 2017 more and more browsers support Promise native. For many projects there is no need to use a polyfill.\nIn Steal 2.0 it is likely that no polyfill will be included (or might be included optionally), but in the meantime the steal-sans-promises.js and steal-sans-promises.production.js scripts have been added to steal.\nUse them in exactly the same manner that you use steal.js today:\n \nNote that when building with steal-tools the steal.production.js script is copied into your dest folder. This is the normal version of steal which does include the Promise polyfill. There is an open issue to provide a way to use steal-sans-promises.production.js instead (and ditto for using bundleSteal).  In the meantime you can use steal-sans-promises from node_modules like so:\n \nIssues\n\n#1178 Add homeAlias option\n#1179 A new build without Promise shim\n\n\n\nCommits\nThe new version differs by 11 commits0.\n\n0988858 1.5.0\n80f92eb Merge pull request #1179 from stealjs/1108-build-without-promise-shim\n7309897 Exclude the loader build from eslinting\na2c63b9 Make steal-sans-promises work in Production\ncfac392 Merge pull request #1178 from stealjs/home-alias\neb2da30 Document the homeAlias option.\ne99bd1e Add homeAlias test\n4e70321 Add homeAlias option\nb3a5a75 Merge pull request #1175 from stealjs/greenkeeper/os-browserify-0.3.0\nc642f49 fix(package): update os-browserify to version 0.3.0\nfb9fb58 Fixes #1108. Adds tasks to build without promise shim\n\nfalse\nSee the full diff\n\n. ## Version 1.5.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits0.\n\n933bd12 1.5.1\nba6c847 Merge pull request #1181 from stealjs/attr-name\nc6233bc Use attr.name to get an attribute's name\n\nfalse\nSee the full diff\n\n. ## Version 1.5.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits0.\n\n2764ffa v1.5.2\nbb1f22b Merge pull request #1190 from stealjs/1188-prog-loading\n90ee8d6 minor fixes for progressive loading, fixes #1188\n57e2ede Merge pull request #1184 from stealjs/copy-versions-to-local\n1772e27 Copy versions to local loader\n\nfalse\nSee the full diff\n\n. ## Version 1.5.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n1.5.3\nThis is a bug fix release, which fixes an issue when using live-reload with steal-clone. Also includes some minor documentation improvements to the Babel docs and progressive loading guide.\nIssues\n\n#1213 live-reload extension is not cloneable\n\n\n\nCommits\nThe new version differs by  commits.\nSee the full diff\n\n. ## Version 1.5.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n1.5.4\nThis is a bug-fix release that fixes usage in IE9.\nIssues\n\n#1216 \"mod.default\" causes a syntax error in IE9\n\n\n\nCommits\nThe new version differs by 3 commits.\n\n1371002 1.5.4\n92ed7e4 Merge pull request #1217 from stealjs/def\n4643388 .default -> [\"default\"]\n\nSee the full diff\n\n. ## Version 1.5.5-pre.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\neada8bc include build files and make pre-release\n65abac0 fixes #1221 and adds tests for it\n5ef2d0d shows problem doesn't require dynamic imports\n245739b demonstrates error with #1221\n115a8f0 Merge pull request #1215 from stealjs/greenkeeper/testee-0.5.1\na48415c chore(package): update testee to version 0.5.1\n\nSee the full diff\n\n. ## Version 1.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n1.3.0\nThis release adds support for Babel plugins and presets. You can learn more about it in the Steal 1.4.0 release notes.\n\n. ## Version 1.3.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 22 commits .\n\n3d0e42a 1.3.1\n10963d7 Merge pull request #659 from stealjs/export-docs\n84e30c1 Improve steal-tools.export docs\nf574ce0 Merge pull request #658 from stealjs/move-multimain-tests\n5bc83b4 Move multi main tests into its own file\n217d37f Merge pull request #657 from stealjs/utf8\nb9aaaa8 steal-tools build writes out UTF-8 correctly\n577201a Merge pull request #629 from stealjs/greenkeeper/mock-fs-4.2.0\n8aee6d4 Merge pull request #656 from stealjs/greenkeeper/ws-2.2.3\n0315659 chore(package): update ws to version 2.2.3\n2bfca6b Merge pull request #655 from stealjs/greenkeeper/uglify-js-2.8.22\n03a1092 Merge pull request #654 from stealjs/greenkeeper/steal-css-1.2.3\nd7616b3 Merge pull request #653 from stealjs/greenkeeper/testee-0.4.0\n6b32e95 chore(package): update steal-css to version 1.2.3\n2048888 chore(package): update testee to version 0.4.0\n\nThere are 22 commits in total. See the full diff.\n\n. ## Version 1.3.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 20 commits0.\n\n1fab7dc 1.3.2\na60ca38 Merge pull request #681 from stealjs/base-url\n7082112 Merge pull request #679 from stealjs/missing-dest\n37e2cf8 Fix broken baseURL link\n372a172 Merge pull request #678 from stealjs/missing-main\n0303888 Better build error message when \"main\" is missing\n2740311 Merge pull request #673 from stealjs/clean-css\n6ab3e21 Better export error message when dest is missing\n6f208e5 Merge pull request #675 from stealjs/greenkeeper/browserify-14.3.0\ncd6b599 Merge pull request #674 from stealjs/greenkeeper/fs-extra-2.1.2\n049246e chore(package): update browserify to version 14.3.0\n206c838 Disable clean-css import inlining\neb29d62 steal-tools should not swallow clean-css errors\n80fc8cd Merge pull request #671 from stealjs/max-stack\ne489d79 Fix infinite recursion with circular dependencies\n\nThere are 20 commits in total.\nSee the full diff\n\n. ## Version 1.3.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits0.\n\n5782d89 1.3.3\nc8bddcb Merge pull request #682 from stealjs/fix-node-4\ncd2dbe9 Use zombie@4 in Node 4\n83c6b40 Array::includes is not supported in Node 4\n\nfalse\nSee the full diff\n\n. ## Version 1.3.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 30 commits.\n\n0b7a0b9 1.3.4\nd1ddfed Merge pull request #709 from stealjs/ignore-uglify\n0dad54e Merge pull request #713 from stealjs/export-stuff\n96f1248 Adds buildResult as resolved value for stealTools.export\na556a9a Set greenkeeper to ignore uglify-js\n9e6a405 Merge pull request #704 from stealjs/pump\na94d072 Merge pull request #705 from stealjs/bundle-docs\ndc1d31f Fix steal-tools bundle docs\nd39524d Simplify steal-tools bundle with pump library\nfea3bd9 Merge pull request #703 from stealjs/pump\nb0697e0 Use pump library in steal-tools build code\nd461624 Merge pull request #685 from stealjs/conditional-with-extensions\n7edd2c3 Use steal-conditional@0.3.4\nb7e1702 Merge pull request #694 from stealjs/greenkeeper/yargs-8.0.1\n060d751 Merge pull request #697 from stealjs/pYr0x-patch-1\n\nThere are 30 commits in total.\nSee the full diff\n\n. ## Version 1.3.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n3524032 1.3.5\n09c7b01 Move pump to the npm dependencies object\n\nSee the full diff\n\n. ## Version 1.3.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 25 commits.\n\n1b01f1d 1.3.6\n6616335 Merge pull request #756 from stealjs/eng\n7202d09 Update engines field in package.json\nc2df0b1 Merge pull request #750 from stealjs/docs/uglify-options\n0b17eca documented uglifyOptions with an example\n95e4699 Merge pull request #739 from stealjs/condition-eval\nc2fb57e Update steal-conditional version\n325e3ac Test conditional using browser specific code\n910fdcb Merge pull request #738 from stealjs/recycle-tests\n04a44d8 Run recycle tests in Node V8\n808fdd6 Merge pull request #737 from stealjs/greenkeeper/mock-fs-4.4.1\n68c010d Merge pull request #736 from stealjs/issue/727-extra-space\nbcff2a3 enabled clean_test\na561b88 Allow extra space before steal-remove-start and -end tags to support standard linting. #727\nfec0b64 chore(package): update mock-fs to version 4.4.1\n\nThere are 25 commits in total.\nSee the full diff\n\n. ## Version 1.3.8 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nSwitch to QUnit.async syntax to harden test in IE\n#268 (comment)\n\n\nCommits\nThe new version differs by 2 commits .\n\n2bfa179 Update dist for release\n4cf3191 Switch to QUnit.async syntax to harden test in IE (#268)\n\nSee the full diff.\n\n. ## Version 3.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\n681cfcc Update dist for release\n9f50df0 Merge pull request #66 from canjs/steal-016\nbaa22a9 updating namespace test to work with Steal 0.16 or Steal 1.0\n\nSee the full diff.\n\n. ## Version 3.0.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\n5c58be8 Update dist for release\n2b78cdf Merge pull request #29 from canjs/links-to-deprecated\n90f3974 Remove link markup for deprecated plugins\n\nSee the full diff.\n\n. ## Version 3.0.9 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits0.\n\nd696a35 Update dist for release\n30a1887 Update dist for release\n05a5de3 Merge pull request #34 from canjs/22-remove-jquery-dep\nca699f5 remove jquery dependency\n\nfalse\nSee the full diff\n\n. ## Version 3.1.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits (ahead by 3, behind by 8).\n\n893a4bb Update dist for release\n07ada29 Merge pull request #78 from canjs/update-can-event\nbbb2e93 Update can-event dep to match that used by other can libraries\n\nSee the full diff.\n\n. ## Version 3.1.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 14 commits0.\n\nb5d27fc Update dist for release\na34dccc Merge pull request #83 from canjs/is-promise-like\ne47ea58 allowing can-observation to read promise-like values\na57937b running async and reader tests\n44a73e4 Merge pull request #81 from canjs/greenkeeper/initial\n40d5eca docs(readme): add Greenkeeper badge\nee868b4 chore(package): update dependencies\naafeb34 Merge pull request #79 from canjs/revert-73-70-report-promise-errors\na51d73a Revert \"#70 report promise errors\"\n53a555f Merge pull request #73 from canjs/70-report-promise-errors\n46a0afc update reader promise errors output and tests to use latest can-util/dev.error\n0d46208 adjust promise error handling\n49e1b4c refactor promise rejection reader test to use window.onerror instead of overwriting setTimeout\n156c6de #70: Catch and report promise rejections\n\nfalse\nSee the full diff\n\n. ## Version 3.1.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n90bba4f Update dist for release\neefb171 Merge pull request #80 from canjs/70-report-promise-errors\nd6cba7a restore\n\nSee the full diff\n\n. ## Version 3.1.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nMakes reads handle numbers\n#87\n\n\nCommits\nThe new version differs by  commits.\nSee the full diff\n\n. ## Version 3.1.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nprimitive properties can be read\nIn stache, {{number.toFixed(2)}} should now work.\nFrom #89\n\n\nCommits\nThe new version differs by 3 commits.\n\n6b68965 Update dist for release\nbec50d1 Merge pull request #89 from canjs/88-read-primitives\nbc669da fixes #88\n\nSee the full diff\n\n. ## Version 3.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n09f3ab3 Update dist for release\n1861530 fixing postversion script\n929587d Observe \"reflected\" interfaces (not ready yet) (#72)\n\nSee the full diff\n\n. ## Version 3.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\nb20ca8a Update dist for release\n266ce0d Merge pull request #94 from canjs/updateDeep\n54646c6 batch version\n4112f8a if batchNum is undefined, try to update no matter what\n97a016f removing reader\nffe785a immediately dispatch event handlers\n\nSee the full diff\n\n. ## Version 3.3.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits .\n\n7a29aa7 Update dist for release\n450983f Merge pull request #220 from canjs/fix-infinite-disable-mutations\nb061ba2 Update feature detection to account for browsers that do not fire synthetic events on disabled elements\ncd6d40a Adding feature detection\n504e2c4 limit disabled dispatching fix to inserted and removed events\n\nSee the full diff.\n\n. ## Version 3.3.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\n4c55ab3 Update dist for release\n1a2b9a0 Merge pull request #222 from canjs/doc\nbb22bbf Conditional run fixSyntheticEventsOnDisabled logic\n\nSee the full diff.\n\n. ## Version 3.3.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 11 commits .\n\n29db08a Update dist for release\n6a0ca67 fix  to consider  s (#233)\n2a6dfe2 Merge pull request #229 from canjs/195-can-deparam\n1fef592 Use the new can-deparam module\n805bd08 Merge pull request #226 from canjs/195-can-param\n93e5378 Merge pull request #228 from canjs/delete-example-fix\nc604f8d Fixing delete docs example\n19c867f Add deprecation notice for js/types/types\n76119a0 Add deprecation warning for js/cid/cid\ne06905b Add a deprecation notice for js/param/param\n2240ce2 Use the new can-param module\n\nSee the full diff.\n\n. ## Version 3.3.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.3.7\nmakeMutationEvent correctly handles adding multiple listeners\n\n\nCommits\nThe new version differs by 3 commits .\n\n000f4b6 Update dist for release\nb2bfce8 Merge pull request #237 from canjs/two-remove-event-listeners\n027aac3 Counting the number of event handlers for each element/event combo\n\nSee the full diff.\n\n. ## Version 3.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits0.\n\n1963d83 Update dist for release\n8c23c6e Add radiochange event (#241)\n0d646ce Add LICENSE (#244)\n7019c99 Use strict (#238); fixes #230\n\nfalse\nSee the full diff\n\n. ## Version 3.4.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits0.\n\n1b89f9f Update dist for release\n8a146bb Remove \"use strict\" from assign (#248)\n\nfalse\nSee the full diff\n\n. ## Version 3.5.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits0.\n\n72b031d Update dist for release\n9dd60bc Merge pull request #243 from canjs/73-error\nfe1a59a add .error to dev\n\nfalse\nSee the full diff\n\n. ## Version 3.5.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n3.5.1\nThis is a small bug fix release that mostly affects server side rendering issues.\nIssues\n\n252 Check if an element is contained within the documentElement\n227 Added document.baseURI check for can-util/js/base-url\n\n\n\nCommits\nThe new version differs by 10 commits0.\n\nced47ca Update dist for release\nec300f8 Merge pull request #252 from canjs/mutate\n716bb7b Check if an element is contained within the documentElement\n5a2e5ce Merge pull request #227 from canjs/223-base-url-doesnot-check-document.baseURI\na4e5325 use can-util/dom/document/document instead of global.document - adding forgotten base-url.js\n1936a76 use can-util/dom/document/document instead of global.document\nd203d04 Merge branch 'master' of https://github.com/canjs/can-util into 223-base-url-doesnot-check-document.baseURI\n318518b Merge pull request #232 from canjs/greenkeeper/testee-0.4.0\n0b78522 chore(package): update testee to version 0.4.0\n7f2651f Added document.baseURI check for can-util/js/base-url\n\nfalse\nSee the full diff\n\n. ## Version 3.6.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 15 commits0.\n\nfe010d9 Update dist for release\n0a12a60 Merge pull request #253 from canjs/derive-enter-leave\n3820d40 IE9 initMouseEvent requires view & relatedTarget\n9f283f9 Deprecate and externalize radiochange (#255)\n1ae9762 Do not document soon-to-be-removed event (#254)\nbd74be1 Use singleReference to keep wrapped handler reference. Create new event with correct type to pass to handler. Renamed file. Fixed whitespace.\ndb4430a Adding delegated enter/leave events derived from over/move events.\neebbfa0 Merge pull request #242 from canjs/5-enter-event\n6383cf5 firefox testing\n7d347d5 tests whether KeyboardEvents are properly handled\n159f587 reference qunit relationally and remove console logs\n79117e9 adds back in commented out version of single-reference that uses WeakMap (prev from can-compute/single-reference)\neace1b2 simplifies single-reference test\n1c4c808 changes testee back to firefox\nbdf88eb overwrites /can-util/dom/events addEventListener and removeEventListener to add ability to watch for \"enter\" events.  uses /can-util/js/single-reference to store and retrieve enter evt handler on given evt handler\n\nfalse\nSee the full diff\n\n. ## Version 3.0.9 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\n4fb9787 Update dist for release\ncfd0e10 Merge pull request #58 from canjs/clean-dom-data\n7f764d3 prevent errors when domData is deleted before control is destroyed\n\nSee the full diff.\n\n. ## Version 3.0.10 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 12 commits .\n\na69f9e6 Update dist for release\nb33f331 Merge pull request #63 from canjs/named-control-selector\n4fb4378 Make control add class to converted element\n14abbf4 Merge pull request #59 from canjs/bind-beforeremove\n294f201 Update test\n602211b Merge pull request #60 from canjs/54-control-without-element\n21dce2a Add test for beforeremove\n103ccc2 Removed dev warning and added better error\n14a6440 Throws an error instead of a return\nb57e4a1 Fixed failing test case\na838844 Removed creating a div and instead shows a dev error and then returns\n38fad40 Add beforeremove to the set of common events\n\nSee the full diff.\n\n. ## Version 3.0.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.0.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nOnly allow one batch module to be loaded at once.\n#43\n\n\nCommits\nThe new version differs by 3 commits .\n\n327392c Update dist for release\n398a86d Merge pull request #43 from canjs/only-one-batch\n7543ff0 warns if two batches are loaded\n\nSee the full diff.\n\n. ## Version 3.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits .\n\n2391226 Update dist for release\n3ac021b Update dist for release\ndf07300 Merge pull request #45 from canjs/nest-lifecycle-binding-count\n4446fde Push _bindings count into __bindEvents object (now called _lifecycleBindings for clarity)\n\nSee the full diff.\n\n. ## Version 3.3.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nDispatch warnings\n#29\n\n\nCommits\nThe new version differs by 5 commits0.\n\nc47fe0d Update dist for release\n447e846 Merge pull request #49 from canjs/29-dispatch-arguments\nba49d2b dispatch checks arguments length and type (fixes #29)\n339dcb2 Merge pull request #47 from canjs/35-cleanup\n4c3fad4 clean up batch + getHandler; fixes #35\n\nfalse\nSee the full diff\n\n. ## Version 3.3.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits0.\n\n0bb5d38 Update dist for release\ndb8ed36 Merge pull request #53 from canjs/skip-dev-test\na946e7c removing dev warning test in production\n\nfalse\nSee the full diff\n\n. ## Version 3.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits0.\n\n67a2bac Update dist for release\n86ff0ed Merge pull request #51 from canjs/add-delegate-mouseenter\n4c0461f Update to enable delegated enter/leave events\n\nfalse\nSee the full diff\n\n. ## Version 3.0.8 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.0.9 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits .\n\n284f534 Update dist for release\n1041aba Merge pull request #76 from canjs/set-immediate-unbind\n69b19cf Merge pull request #71 from canjs/greenkeeper/generator-donejs-1.0.4\n638e0c2 Merge pull request #75 from canjs/172-at-args-no-execute\n654e672 Merge pull request #74 from canjs/greenkeeper/testee-0.4.0\n255b447 Replace 10ms setTimeout with setImmediate for unbinding temporary computes\n6fa6975 truthy should not automatically run functions (canjs/can-stache#172)\naafd10d chore(package): update testee to version 0.4.0\n9d44d6e chore(package): update generator-donejs to version 1.0.4\n\nSee the full diff.\n\n. ## Version 3.0.10 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\n0a056de Update dist for release\n2d568c1 Merge pull request #77 from canjs/use-set-immediate-polyfill\nbdbaddc import setImmediate polyfill from can-util\n\nSee the full diff.\n\n. ## Version 3.0.11 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n432b4db Update dist for release\n20337f3 Merge pull request #85 from canjs/inp\nfae3cea Properly handle setting element computes\n\nSee the full diff\n\n. ## Version 3.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\na8ecbe2 Update dist for release\na9278b4 changing postversion script back\nd0d529f implements much of the reflected API for can-compute (not ready) (#69)\n\nSee the full diff\n\n. ## Version 3.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nf88f65a Update dist for release\n05d3c2d Merge pull request #86 from canjs/updateDeep\n111b742 getting compute to work with can-stache-key\n\nSee the full diff\n\n. ## Version 3.0.22 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\neff2cba Update dist for release\n16a15e4 Merge pull request #190 from canjs/update-test-can-event\n7972acc update can-event and modify tests to match\n\nSee the full diff.\n\n. ## Version 3.0.23 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.0.23\n#172\n\n\nCommits\nThe new version differs by 13 commits0.\n\necf29b6 Update dist for release\n1a95bc2 Merge pull request #178 from canjs/172-at-args-no-execute\n80730c7 update can-compute depedency\n06ac889 remove extraneous check/test\n490f425 Merge remote-tracking branch 'origin/master' into 172-at-args-no-execute\ne325ae4 only run computes, not all functions. (closes #172)\ne300722 Merge pull request #192 from eben-roux/patch-1\n0c3bad4 - fixed \"or\" placement\n595e907 returns function for\n532a2ee fix test for\nfa986f3 new test for @arg function calls\n62b8101 fix @arg test for travis-ci\n10c58ad @arg's return a function validating existence (#172)\n\nfalse\nSee the full diff\n\n. ## Version 3.0.24 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.0.24\n#171\n\n\nCommits\nThe new version differs by 7 commits0.\n\nb0df12f Update dist for release\n91e0246 Merge pull request #171 from canjs/1476-warn-missmatch\ndecc589 Merge remote-tracking branch 'origin/master' into 1476-warn-missmatch\nf8c7980 Merge remote-tracking branch 'origin/master' into 1476-warn-missmatch\n7ebfa15 refactor missmatch warning tests\n0847079 refactor element stack, move closingTag logic to expression object (canjs/can-stache#13)\n7785b9e partial fix for canjs/can-stach#13: provide warnings for missmatched start/end tags\n\nfalse\nSee the full diff\n\n. ## Version 1.0.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\nee077d4 1.0.7\nb9f93be Merge pull request #60 from canjs/no-parse\n46f1b99 Remove TextNode encoding\n\nSee the full diff.\n\n. ## Version 1.0.8 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.0.8\n#62\n\n\nCommits\nThe new version differs by 7 commits0.\n\ndaf606e 1.0.8\nd623fdf Merge pull request #62 from canjs/61-ie9\n380ed64 Merge pull request #63 from canjs/fix-45\n73a0664 Updated Node to version 6 for Travis\ne8159ca Added can-simple-dom.md for #45\n912dafa fix enumerable/configurable tests for ie9/10 (fixes #61)\naf6eec7 Correctly serialize  blocks (#30)\n\nfalse\nSee the full diff\n\n. ## Version 1.3.11 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits0.\n\nbf5bb20 Update dist for release\n1271e42 Merge pull request #283 from canjs/281-deep-merge\n1203477 update tests to reflect changes in #163 (fixes #281)\ne38d823 Merge pull request #277 from canjs/194-doc-issue\nea738ff fixes ./can/ref/ref.Map.Ref.prototype props and functions to display signature text within p not code block\n\nfalse\nSee the full diff\n\n. ## Version 0.4.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits ahead by 6, behind by 1.\n\nb8cf1f0 0.4.1\n94f9cab 0.4.0\n0fad897 Allow reporting of client console logging (#116)\n138fa7f Merge pull request #108 from bitovi/107-document-es6-coverage\n6a35fbc add es6 note and coverage example\n7f3357d Merge pull request #105 from bitovi/babel-plugin-istanbul\n\nfalse\nSee the full diff\n\n. ## Version 0.5.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits0.\n\n40e50aa 0.5.0\n3c4581c Merge pull request #123 from stevenvachon/master\n58f3b9c Add CLI support for *.js config files\n\nfalse\nSee the full diff\n\n. ## Version 3.0.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.0.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.0.10 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\n00b4018 Update dist for release\nb489154 Merge pull request #71 from canjs/use-can-param\nf2593e7 fix to use can-param directly\n\nSee the full diff.\n\n. ## Version 2.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits0.\n\n29dec05 2.0.1\n2c9f8ac Test for #154 and #155 (#156)\nd2e59ee Fixed issue with __hooks being overwritten when reusing service (#155)\n1f55195 chore(package): update semistandard to version 11.0.0 (#152)\n7b450f5 Updating changelog\n\nfalse\nSee the full diff\n\n. ## Version 0.2.1-0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 0.2.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits .\n\na0f4258 Update dist for release\n08f720e Update dist for release\n1113f02 Updated can-stream to 0.2.1. Updated docs\n\nSee the full diff.\n\n. ## Version 0.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits .\n\na320db1 0.1.0\n28b5cb8 Updated can-stream. Updated docs\n55a4fc6 0.1.0-pre.2\nfcd201c makes it so it weaves into only one map\n\nSee the full diff.\n\n. ## Version 3.0.8 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits0.\n\na672cde Update dist for release\n9da8797 Merge pull request #46 from canjs/skip-dev-tests\n64f393c skipping dev warnings test in production\n\nfalse\nSee the full diff\n\n. ## Version 1.0.19 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits0.\n\n12f8f41 Update dist for release\n03bb87a Merge pull request #183 from canjs/greenkeeper/can-util-3.5.1\n321eabb chore(package): update can-util to version 3.5.1\n\nfalse\nSee the full diff\n\n. ## Version 1.0.20 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits0.\n\nb64ced8 Update dist for release\n50c0610 Merge pull request #184 from canjs/fix-definemap-value-init\nb9e18da Get values before setting them in setup, to avoid setting a property with a replaceWith getter; fixes #182\n\nfalse\nSee the full diff\n\n. ## Version 1.0.21 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits0.\n\n106dc91 Update dist for release\n8995dd3 Merge pull request #186 from canjs/fast-init-set\ne08011e fixes #182\n\nfalse\nSee the full diff\n\n. ## Version 1.0.22 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits0.\n\ne41f198 Update dist for release\nda2b104 Merge pull request #188 from canjs/config\n57c5a9b Defined properties should be configurable\n\nfalse\nSee the full diff\n\n. ## Version 1.0.23 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits0.\n\nb0cccc1 Update dist for release\nd49856b Merge pull request #192 from canjs/fix-throws-test\n1efb826 Updating list-test.js to not use QUnit.throws that does not work consistently in every browser\n\nfalse\nSee the full diff\n\n. ## Version 1.0.24 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits0.\n\n6c70983 Update dist for release\n8defbad Merge pull request #193 from canjs/new-list-test-fix\n44d0842 making list-test less restrictive\n\nfalse\nSee the full diff\n\n. ## Version 3.6.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 10 commits0.\n\nc738ca1 Update dist for release\nead0c36 Merge pull request #266 from canjs/265-usage-require-documentation\n095fcdf Merge branch 'master' into 265-usage-require-documentation\na75565e Merge pull request #267 from canjs/update-saucelabs-test\n73fff20 Use the test page url, not the one for Sauce Labs\n49d0e03 Update tests for saucelabs; iOS needs Safari 1.6.3, use test-saucelabs package\n06eb57d Fixes #265. Adds usage docs and require statements to some functions\n086e2f9 Merge pull request #264 from canjs/focused-on-insert\nfea3f05 Use dom-mutate in inserted event test for IE9/10\ncf48c5d Make focused attribute wait for inserted if element is detached\n\nfalse\nSee the full diff\n\n. ## Version 3.7.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits0.\n\n146f8bb Update dist for release\n5c3769d Merge pull request #269 from canjs/268-dev-stringify\n17c5fac Fix self-reference deprecation warnings (#270)\n1e723d4 Adds an implementation of stringify that outputs properties with a value of undefined. Resolves #268\n\nfalse\nSee the full diff\n\n. ## Version 3.5.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits0.\n\n964ca4f Update dist for release\n786d4e0 Use algebra idProp when available. (#71)\n\nfalse\nSee the full diff\n\n. ## Version 3.5.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits0.\n\n6b53101 Update dist for release\n2a0e07e Simpler idProp check\n\nfalse\nSee the full diff\n\n. ## Version 3.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n7182715 Update dist for release\naf8e93b Merge pull request #49 from canjs/updateDeep\ndf42bfa working with can-stache-key\nac91a39 pre\nde976ce all tests pass with updateDeep\n\nSee the full diff\n\n. ## Version 2.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 2.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.3.0-pre.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.0.26 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nMakes brackets work with literals\n#207\nMakes these work:\n{{ test['foo'][0] }}\n\n{{ test['foo'].zed }}\n\n{{ test['foo'].zed['bar'] }}\n\n\n\nCommits\nThe new version differs by 4 commits.\n\n12bc8c6 Update dist for release\n53d8687 Merge pull request #211 from canjs/207-brackets-with-literal\n53b02df uncomments tests\n28cb741 makes brackets able to work with literals\n\nSee the full diff\n\n. ## Version 3.0.27 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nDiff plain arrays in computes\nFrom #216\nAllows a compute with an array to use diffing similar to the following example:\nvar which = compute(false);\nvar a = {}, b = {}, c = {};\n\nvar list = compute(function(){\n  return which() ? [a,c]: [a,b,c]\n});\n\nstache(\"{{#each list}}...\");\n\n\nCommits\nThe new version differs by 5 commits.\n\nbf369f2 Update dist for release\nc89e057 Merge pull request #216 from canjs/215-diff-arrays-in-computes\n329355b fixes #215\nb330aff Merge pull request #210 from canjs/24-helpers-overwrite-fix\n5b14524 disable helper warning test in production\n\nSee the full diff\n\n. ## Version 3.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\ne78b04b Update dist for release\n992a181 fixing postversion script\n331fb55 Do Not Merge - can-reflect (#219)\n660764a Merge pull request #220 from canjs/greenkeeper/can-util-3.8.5\nbfda249 chore(package): update can-util to version 3.8.5\n\nSee the full diff\n\n. ## Version 3.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n62d548b Update dist for release\n4df8850 Merge pull request #228 from canjs/updateDeep\nc2a0760 updates deps\n\nSee the full diff\n\n. ## Version 3.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n927aa9d Update dist for release\n7dff156 Merge pull request #53 from canjs/52-encode-forward-slashes\nab5b859 #52 - encode forward slashes\n\nSee the full diff\n\n. ## Version 3.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n234d932 Update dist for release\n4889ee2 fixing postversion script\na5f67ba Do Not Merge - can-reflect (#55)\n\nSee the full diff\n\n. ## Version 1.0.14 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nMix of Fix\nAdds a warning when adding a store with METHOD doesn't make sense (#30), we Make sure ids are going to be unique (#102), and we Use can-deparam (#109) internally.\n\n\nCommits\nThe new version differs by  commits.\nSee the full diff\n\n. ## Version 3.8.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits.\n\nf419bcf Update dist for release\nc486d7a Merge pull request #277 from canjs/update-radiochange\n4899b81 updating can-event-radiochange to the latest\nab45302 Merge pull request #262 from canjs/greenkeeper/initial\n444c9d0 Merge branch 'master' into greenkeeper/initial\n0bb0012 docs(readme): add Greenkeeper badge\n7e0621c chore(package): update dependencies\n\nSee the full diff\n\n. ## Version 3.8.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n063b83b Update dist for release\n5e930f0 Merge pull request #278 from canjs/keyboard-event-type\n5fa977b Making test for KeyboardEvent work with jQuery\n\nSee the full diff\n\n. ## Version 3.8.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n776fb21 Update dist for release\n4e59637 Merge pull request #279 from canjs/revert-keyboard-event-type\n966eefb Revert \"Merge pull request #278 from canjs/keyboard-event-type\"\n\nSee the full diff\n\n. ## Version 3.8.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n1644c4c Update dist for release\nbdf8920 Merge pull request #286 from canjs/ajx\nf0972c1 Properly handle serializing data in dom/ajax\n586d66d Merge pull request #280 from canjs/193-inner-diff\n1739af2 fixes #193\n\nSee the full diff\n\n. ## Version 3.9.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nd16c7de Update dist for release\n9c1d867 fixing postversion script\nf381873 Do Not Merge - can-reflect (#287)\n\nSee the full diff\n\n. ## Version 3.9.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n3a7d214 Update dist for release\n75cd90f Merge pull request #291 from canjs/unused-deps\n4c35866 Replace events with can-event-dom-* packages (#281)\n0df8151 Remove unused deps\n\nSee the full diff\n\n. ## Version 3.9.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n271070d Update dist for release\n246a17b Merge pull request #293 from canjs/no-define\n69f5492 removing can-define as a dep\n\nSee the full diff\n\n. ## Version 3.9.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\nd00eb3c Update dist for release\n5c76f0f Merge pull request #295 from canjs/294-disabled-events\n56a085e make requires relative\n101e293 add/test warning when dispatching on disabled elements (fixes #294)\n\nSee the full diff\n\n. ## Version 3.9.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n1d9a914 Update dist for release\n31a45d1 Merge pull request #299 from canjs/294-disabled-events-fix\n52fce14 ignore disabled element warning at feature detection\n\nSee the full diff\n\n. ## Version 1.4.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nSupport item urls\nFixes #298 by making data-url support urls like url: \"/v1/places/todos/{id}\"\n\n\nCommits\nThe new version differs by 14 commits.\n\n908f781 Update dist for release\n2f87c93 hard-coding validate\n6b6c865 Merge pull request #300 from canjs/298-resource-consistency\n604d82f Merge branch 'master' into 298-resource-consistency\nd54a056 Merge branch 'master' into 298-resource-consistency\n6b55595 fixes #298 by using can-make-rest\n317f968 Merge pull request #299 from canjs/fix-validation-errors\na777279 Fix validation errors\naba3384 Fix jquery global usage tests\n25353df Merge pull request #293 from canjs/no-jquery-dep\n25a71ee Merge pull request #297 from canjs/296-created-instances-in-store\ncf99c4c added docs and fixed tests\nb606152 fixes #296 by allowing instances to be kept in a newInstanceStore\na7b8492 Remove jQuery as a dep (leave as devDependency for tests)\n\nSee the full diff\n\n. ## Version 1.4.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n493b4dc Update dist for release\nc74a567 Merge pull request #307 from canjs/ajx\ne0f9763 data/url: Always provide contentType\n2c7ed38 Merge pull request #302 from canjs/list-in-docs\nf0389bc Fix the appearance of a list in the docs\n\nSee the full diff\n\n. ## Version 1.5.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 19 commits.\n\n8e49f84 Update dist for release\n1f8381f Merge pull request #306 from canjs/can-reflect\n3e8d354 bumping pre version\n56247bd updating to correct version of can-view-callbacks\nc105ad0 Update dist for release\nfd407f3 bumping can-util version\nde90782 Merge remote-tracking branch 'origin/master' into can-reflect\n97580e2 Update dist for release\na4ed89c removing usage of depreacted types.isPromise\n4463f6f v1.5.0-pre.4\n2f6e6ee updating to pre-releases\naf69d45 v1.5.0-pre.3\nb33a182 using can-types / can-util pre-releases\nabda261 Update dist for release\nc30ea39 Merge remote-tracking branch 'origin/master' into can-reflect\n\nThere are 19 commits in total.\nSee the full diff\n\n. ## Version 1.5.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n5338c09 Update dist for release\n09c5518 Merge pull request #309 from canjs/remove-pre-releases\nc2b13e9 removing pre-releases from dependencies\n1685c2b fixing postversion script\n\nSee the full diff\n\n. ## Version 1.5.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n1cdd9f8 Update dist for release\nc6ea697 Merge pull request #313 from canjs/make-rest-0.1.1\n1cbc447 bumping version of can-make-rest\n\nSee the full diff\n\n. ## Version 1.5.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n0edf7b8 Update dist for release\nae5f385 Merge pull request #322 from canjs/updateDeep\n77b9cc3 uses new can-reflect to not update typed data\n\nSee the full diff\n\n. ## Version 1.0.10 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n1.0.10\nThis is a patch release that fixes an issue with replaceChild (and other DOM operations) would cause external-facing calls to other DOM operation APIs. This facilities with dynamically patching these APIs.\nIssues\n\n#67 Node operations should make internal calls\n\n\n\nCommits\nThe new version differs by 3 commits.\n\n9e8a7f1 1.0.10\n386b702 Merge pull request #68 from canjs/internal\n18f4fa2 Change DOM operations to internal calls\n\nSee the full diff\n\n. ## Version 0.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n8cb4012 0.2.0\nccb27c8 Do Not Merge - can-reflect (#38)\n\nSee the full diff\n\n. ## Version 0.0.11 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n6abe2e7 0.0.11\nd8256d3 Merge pull request #1 from canjs/greenkeeper/update-all\n8857e39 fixing bad merge conflict resolution\ndae5f8c Merge branch 'master' into greenkeeper/update-all\n2358047 chore(package): update dependencies\n\nSee the full diff\n\n. ## Version 0.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n04b444d 0.1.0\nb5a79df Do Not Merge - can-reflect (#6)\n\nSee the full diff\n\n. ## Version 3.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.2.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 0.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits ahead by 3, behind by 4.\n\ncbf4d9a Update dist for release\n05bc1e9 fixing postversion script\n9ad4d89 Do Not Merge - can-reflect (#40)\n\nSee the full diff\n\n. ## Version 0.6.9 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits.\n\nd252aab Update dist for release\n\nSee the full diff\n\n. ## Version 0.6.10 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n1fb029d Update dist for release\n3ee7f49 Merge pull request #121 from canjs/readystate\nc5f8b32 Use Node 7 in CI\n3392d66 XHR Cache: Call onreadystatechange\n\nSee the full diff\n\n. ## Version 3.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n98021a2 Update dist for release\n14ba070 Update dist for release\n78d2a3e fixing postversion script\ne7ccb1f Do Not Merge - can-reflect (#35)\n\nSee the full diff\n\n. ## Version 1.2.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n34d51dd Update dist for release\n44044e6 Merge pull request #217 from canjs/ef\n10f4bd6 Replace duck-typing hasMethod with can-reflect\n838ad10 Add a breaking test for #216\n\nSee the full diff\n\n. ## Version 1.2.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nskipping Object.seal test in production env\n#219\n\n\nCommits\nThe new version differs by 2 commits.\n\n2c82941 Update dist for release\n147a388 skipping Object.seal test in production (#219)\n\nSee the full diff\n\n. ## Version 0.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n7301cb0 Update dist for release\n8478e48 Merge pull request #24 from canjs/no-pre-releases\nfa2655a removing pre-releases from dependencies\n\nSee the full diff\n\n. ## Version 1.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 8 commits.\n\nd39227f Update dist for release\n08dd1a6 Merge pull request #226 from canjs/updateDeep\n062f753 adding tests for isPlainObject\n7c25d13 calls splice correctly\nccaee51 upgrading versions\nbd11bde updating package\n43776f2 jshint passes\n0fa4ef3 all tests passing again\n\nSee the full diff\n\n. ## Version 1.3.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n260c99c Update dist for release\nd1c17bc Merge pull request #229 from canjs/extensible-check\n78defeb fix extensible error message check for new safari\n\nSee the full diff\n\n. ## Version 1.3.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n4d53fdd Update dist for release\n8357ee3 Merge pull request #230 from canjs/cachedGetSet\n6bc8b53 pointing at new version\n66886b0 exposes get/set key value methods\n\nSee the full diff\n\n. ## Version 3.2.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits.\n\n65c64fa Update dist for release\nbf02732 Merge branch 'master' of github.com:canjs/can-component\n0879d9f increasing timeout length even more\nfe60bb6 Merge pull request #122 from canjs/greenkeeper/can-util-3.9.5\n2b30d39 chore(package): update can-util to version 3.9.5\na0c92cb Merge pull request #121 from canjs/greenkeeper/can-compute-3.3.1\n3f5de24 chore(package): update can-compute to version 3.3.1\nbcc493b Merge pull request #120 from canjs/greenkeeper/can-map-3.3.1\n8578297 chore(package): update can-map to version 3.3.1\n\nSee the full diff\n\n. ## Version 1.2.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n95a07b6 1.2.2\nf68b6ce fixes Object.keys problem with IE 11\n945f89e doc re-org\n\nSee the full diff\n\n. ## Version 3.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\nb616a81 Update dist for release\n19a4f6e rolling back version\n59b32ac Merge branch 'master' of github.com:canjs/can-component\n4ea7269 Update dist for release\n39457ce Merge pull request #124 from canjs/greenkeeper/can-observation-3.3.1\n099c809 chore(package): update can-observation to version 3.3.1\n\nSee the full diff\n\n. ## Version 1.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.6.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n5932569 Update dist for release\n6f27c0b Merge pull request #58 from canjs/fix-batch-bug\nef3c553 fix issue with debounce removing all batchEnd events\n\nSee the full diff\n\n. ## Version 3.3.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 12 commits.\n\n38ad18a Update dist for release\n1f5c77d Merge pull request #247 from canjs/139-attribute-warning\nd6c42f5 Added steal remove\ncdb63bf Check attr names and give warning if no callback\n26ad9c4 Merge pull request #245 from canjs/fix-at-operator-link\n6cc11e0 Update at operator link\n61b3870 Merge pull request #243 from canjs/remove-options-comment\n68152c9 Remove options scope comment to fix bit-docs bug\n6dbc591 Merge pull request #241 from canjs/greenkeeper/can-view-scope-3.3.1\n9325454 chore(package): update can-view-scope to version 3.3.1\n70d395a Merge pull request #240 from canjs/greenkeeper/can-event-3.6.0\n579a207 chore(package): update can-event to version 3.6.0\n\nSee the full diff\n\n. ## Version 3.3.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n1e769f2 Update dist for release\nb9b36e2 Merge pull request #231 from canjs/plain-js-obj-subtemplate\nacefc00 Merge branch 'master' into plain-js-obj-subtemplate\n12af3f8 it works ready to merge\nd6d51bd Plain JS object scope works with subtemplate (#208)\n\nSee the full diff\n\n. ## Version 3.3.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\nad8713b Update dist for release\n9222e66 Merge pull request #249 from canjs/can-jquery-test-fix\n8f9c83c Fixed can-jquery test using steal-clone\n1357acf Adding missing license.\n\nSee the full diff\n\n. ## Version 3.3.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nUpdating can-stache-key\n#263\n\n\nCommits\nThe new version differs by 10 commits.\n\n6f30036 Update dist for release\ndbced68 Merge pull request #263 from canjs/landscaper/bump-can-stache-key\nee5edc3 Update to latest can-stache-key\n31abc21 Merge pull request #255 from canjs/180-definelist-index-reference\n4a74289 Breaking tests for instances of {{defineList[n]}} and {{dataList.n}} not updating on data changes. Bug #180\nb54ed61 Merge pull request #251 from canjs/185-is-section\nd08e91f Consolidate helper fn and inverse logic\n52bbaf7 Add helperOptionArg.isSection + tests\n146b7d3 Cleanup some quirks\nfbfa32c Fix a link in the %special docs\n\nSee the full diff\n\n. ## Version 3.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n1176ee9 Update dist for release\n1761aaf Updating can-view-parser (#257)\n\nSee the full diff\n\n. ## Version 3.5.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nAdded debugger helper\n\n{{debugger}} helper\ndoc updates for the @ operator\n\n\n\nCommits\nThe new version differs by 7 commits.\n\naea9273 Update dist for release\n65718e7 Merge pull request #246 from canjs/bad-at-docs\n34e4d4c Merge pull request #261 from canjs/debugger-helper\n65fab2b Add debugger helper doc\nec04e42 Add debugger helper\n76b5949 updated per Kevin's feedback\n9ca5a47 Update at operator doc with useful info from Brad\n\nSee the full diff\n\n. ## Version 3.5.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nFixing issue with debugger helper in production\n#266\n\n\nCommits\nThe new version differs by 5 commits.\n\nbe93489 Update dist for release\n997baa7 Merge pull request #266 from canjs/bugfix/remove-evaluateArgs\n36eeffd debugger helper: fixed __testing\nec2b172 use noop for resolveValue in debugger helper\nf52a4b5 fixing #265: use noop for evaluateArgs in debugger helper\n\nSee the full diff\n\n. ## Version 3.5.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\nee23e17 Update dist for release\nc109fa6 Merge pull request #196 from canjs/greenkeeper/initial\n1e002ed docs(readme): add Greenkeeper badge\n59e93ea chore(package): update dependencies\nf945832 Merge pull request #271 from canjs/greenkeeper/can-stache-key-0.1.0\n978c6da fix(package): update can-stache-key to version 0.1.0\n\nSee the full diff\n\n. ## Version 3.6.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n6075de7 Update dist for release\nb1d31ec Merge pull request #197 from canjs/namedPartials\n2390e7e Closes #3 - add inline/recursive named partials functionality. Tests and documentation too.\n\nSee the full diff\n\n. ## Version 3.6.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nWarning when using on:, :to, :from, :bind and not importing can-stache-bindings\n#273\n\n\nCommits\nThe new version differs by 6 commits.\n\na1543bb Update dist for release\n87f7489 Merge pull request #277 from canjs/warn_when_using_new_binding_syntax_wihtout_stache_binding\n94d610a warn users when using colon binding syntaxe without importing can-stache-bindings\n9ada6bc Merge pull request #269 from canjs/dev-rel-12-update-generated-readmes\ne2d203d Merge branch 'master' into dev-rel-12-update-generated-readmes\n651a4fa Remove generated API docs from the README\n\nSee the full diff\n\n. ## Version 3.6.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nDoc update: warnings on recursive named partials\n#275\n\n\nCommits\nThe new version differs by 4 commits.\n\nafd7966 Update dist for release\na0a2463 Merge pull request #276 from canjs/nprecursiondocs\nc3ad484 Break up the code examples in the named partials docs\ndcb92a9 Closes #275 - document the pitfal of recursive partials combined with the default expression behavior of looking up the context chain.\n\nSee the full diff\n\n. ## Version 3.3.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 8 commits.\n\n0021b7b Update dist for release\n81eec01 Merge pull request #78 from canjs/55-reference-scope-throw\n1daa987 Added scope get, set, and add to test\n576ad9a Switch test to using scope only without stache\n037e2fa Add reference scope when calling getRefs is none exists\n69f9931 Merge pull request #77 from canjs/greenkeeper/can-define-1.3.3\n42fa16d chore(package): update can-define to version 1.3.3\ne5935d5 Adding missing license.\n\nSee the full diff\n\n. ## Version 2.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits ahead by 6, behind by 1.\n\nac66822 2.0.3\n3762607 [typings] add service and id to hook context object (#169)\nadf84ff Update README to point at new documentation location (#167)\n5341fe4 Updating changelog\ne31b4a6 2.0.2\n320e482 Add prepare script (#164)\n\nSee the full diff\n\n. ## Version 2.0.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits ahead by 4, behind by 1.\n\n27deae1 2.0.4\nae895dc Updating changelog\nb04dc50 2.0.3\nafc39a3 make Service generic type default to any (#168)\n\nSee the full diff\n\n. ## Version 2.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n5530494 2.1.2\n041aede Add a warning when trying to use hooks with v3 (#175)\ndb9a345 Updating changelog\n\nSee the full diff\n\n. ## Version 1.5.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\ne4d7fa6 Update dist for release\n282ee46 Merge pull request #334 from canjs/doc-updates-stage-2\n8539a14 fix IE compatibility, don't use startsWith\n\nSee the full diff\n\n. ## Version 0.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nRemoved console.log statement\n#17\n\n\nCommits\nThe new version differs by 3 commits.\n\n1c41658 0.1.2\n73b4bfd Merge pull request #17 from canjs/remove-console-logs\nad826f6 Removing console.log\n\nSee the full diff\n\n. ## Version 3.9.8 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nDeprecated is-string and is-array\nThis release deprecates js/is-string/is-string and js/is-array/is-array. These functions mapped directly to their respective typeof str === 'string' and Array.isArray(arr) checks. Please replace your usages accordingly; these functions will remain until v4.0.\n\n\nCommits\nThe new version differs by 4 commits.\n\n9fd2865 Update dist for release\n2683337 Merge pull request #303 from canjs/225-deprecate-is\nf090d82 Remove all self-usages\na3d91bc Deprecate is-array and is-string\n\nSee the full diff\n\n. ## Version 1.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 10 commits.\n\n91d2555 Update dist for release\n011e1e9 Merge pull request #242 from canjs/change-version-back\ncb25d0d changing version back to last successful release\n9f2aa15 Update dist for release\n667bd79 Update dist for release\nb8c9212 Update dist for release\nd899e84 Merge pull request #241 from canjs/239-observe-definelist-index\naaef85b Dispatch event when an indexed list value changes. Resolves #239\n94a5290 Merge pull request #238 from canjs/can-reflect-onvalue\nb6e8a6b Added a DefineList test using canReflect.onValue() to observe element value changes.\n\nSee the full diff\n\n. ## Version 1.2.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nAdded checks for Map/Set in unsupported browsers\nMap/Set are not supported in IE 11 for serialization.\nIE 9/10 do not support Map/Set and even using if(Map) {} will cause an error.\nSwitched to using typeof Map !== 'undefined'\nIn addition in IE 11 Map/Set do not properly have toString defined and will return [object Object] rather than [object Set] or [object Map] so we make sure not to test in those cases.\n\n\nCommits\nThe new version differs by 4 commits.\n\neecf65a 1.2.6\nf9d710f Merge pull request #39 from canjs/ie-map-set-support\n6fcffb9 Minor doc enhancement\nbe0c038 Added helpers to see is map/set are implemented and properly supported\n\nSee the full diff\n\n. ## Version 3.3.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nffee798 Update dist for release\n380e25f Merge pull request #142 from canjs/greenkeeper/can-stache-key-0.1.0\n803b82e fix(package): update can-stache-key to version 0.1.0\n\nSee the full diff\n\n. ## Version 3.3.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nremoved can-* pre-releases\n#144\n\n\nCommits\nThe new version differs by 3 commits.\n\na71a9b7 Update dist for release\n412f493 Merge pull request #144 from canjs/landscaper/remove-pre-releases\n503a7a8 Remove canjs pre-releases\n\nSee the full diff\n\n. ## Version 3.3.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nUse typeof to check for console\nUsing if(console) {...} will silently fail in IE 9. Replaced it with if(typeof console !== 'undefined') {...}.\n\n\nCommits\nThe new version differs by 5 commits.\n\n22a7f5c Update dist for release\nc796643 Merge pull request #102 from canjs/no-console\n7305319 Used typeof to check for console for IE9\na545623 Merge pull request #101 from canjs/greenkeeper/can-stache-key-0.1.0\n2b87962 fix(package): update can-stache-key to version 0.1.0\n\nSee the full diff\n\n. ## Version 3.1.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.2.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 10 commits.\n\n6cd0871 Update dist for release\n455914b Merge pull request #66 from canjs/greenkeeper/initial\nb8b150f Merge branch 'master' into greenkeeper/initial\n4b17195 Merge pull request #52 from canjs/greenkeeper/done-serve-1.0.0\n4a5954f Merge branch 'master' into greenkeeper/done-serve-1.0.0\n178a760 Merge pull request #89 from canjs/greenkeeper/can-stache-key-0.1.0\n9735412 fix(package): update can-stache-key to version 0.1.0\n9297c63 docs(readme): add Greenkeeper badge\n18fc3c8 chore(package): update dependencies\ne9bb4e2 chore(package): update done-serve to version 1.0.0\n\nSee the full diff\n\n. ## Version 3.3.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nf9aa18b Update dist for release\nc9a8108 Merge pull request #64 from canjs/greenkeeper/can-stache-key-0.1.0\nf307e2d fix(package): update can-stache-key to version 0.1.0\n\nSee the full diff\n\n. ## Version 3.3.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nde5a662 Update dist for release\nba20261 Merge pull request #86 from canjs/greenkeeper/can-stache-key-0.1.0\n8c92819 fix(package): update can-stache-key to version 0.1.0\n\nSee the full diff\n\n. ## Version 3.3.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n6bc5772 Update dist for release\n69b6238 Merge pull request #90 from canjs/this-as-context\n83f1776 Removed circular dependencies and rewrote the test\ne756458 Fixes the issue with this not supported a context\n\nSee the full diff\n\n. ## Version 3.7.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits.\n\n22fd1e0 Update dist for release\n\nSee the full diff\n\n. ## Version 3.7.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\ncan-event/batch/batch logs a warning on missing stop\n#66\n\n\nCommits\nThe new version differs by 4 commits.\n\nfcc00b9 Update dist for release\n8374bbc Merge pull request #66 from canjs/missing_stop_warning_timout\n75431fe make all tests pass\n0df6235 can-event/batch/batch logs a wraning timeout on missing stop\n\nSee the full diff\n\n. ## Version 3.3.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nseparating observability from proactive cacheability\n#109\n\n\nCommits\nThe new version differs by 3 commits.\n\ndde9ae8 Update dist for release\n41b1e37 Merge pull request #109 from canjs/is-proactively-cacheable\nb9320b4 adding flag to separate observability from proactive cacheability\n\nSee the full diff\n\n. ## Version 3.3.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n19ff28c Update dist for release\nec67fad Merge pull request #110 from canjs/revert-proactive-caching\n0a563cd Revert \"Merge pull request #109 from canjs/is-proactively-cacheable\"\nc57297e Merge pull request #106 from canjs/dev-rel-12-update-generated-readmes\nb34d7ac Remove generated API docs from the README\n\nSee the full diff\n\n. ## Version 1.5.8 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits ahead by 4, behind by 1.\n\n3efc2d3 Update dist for release\n2444fb4 Merge pull request #346 from canjs/use-can-reflect\n61ed240 replace types.isPromise to canReflect.isPromise\n85144f0 Update dist for release\n\nSee the full diff\n\n. ## Version 1.4.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\nc2279f7 Update dist for release\n3bb34ec Merge pull request #244 from canjs/149-on-key-value\ncfc6024 making canReflect.onKeyValue not bind on the internal Observation for computed props\n4c02116 calling define adds a CID\n81aaec8 Observe on the object property\n\nSee the full diff\n\n. ## Version 1.4.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\ncae36ab Update dist for release\n322c834 Merge pull request #255 from canjs/rollback-for-tests\n6a9e147 Rolling back changes to fix failing can-connect tests\nfd01bcf Merge pull request #248 from canjs/dev-rel-12-update-generated-readmes\n5ff1c9a Remove generated API docs from the README\n\nSee the full diff\n\n. ## Version 3.10.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nf057fab Update dist for release\n3ab9c80 Merge pull request #235 from canjs/fix-234\n4295512 Update dist for release\n\nSee the full diff\n\n. ## Version 3.10.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits.\n\n2a4df38 Update dist for release\n\nSee the full diff\n\n. ## Version 3.10.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nFix dom/attr test to not run on server\n#336\n\n\nCommits\nThe new version differs by 7 commits.\n\n34f4583 Update dist for release\nb613f81 Merge pull request #337 from canjs/bg-can-ajax\n6fc94b3 Revert \"fix(package): update can-ajax to version 3.11.0\"\n1412e79 Merge pull request #336 from canjs/bg-skipped-tests-320\ncf42f0a Merge pull request #334 from canjs/greenkeeper/can-ajax-3.11.0\na270d88 Skip one test on server\nce35a55 fix(package): update can-ajax to version 3.11.0\n\nSee the full diff\n\n. ## Version 3.10.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by  commits.\nSee the full diff\n\n. ## Version 3.10.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits.\n\n4b975b2 Update dist for release\n\nSee the full diff\n\n. ## Version 3.10.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n0431f75 Update dist for release\nd48a16d Merge pull request #339 from canjs/update-can-globals\ne38bce9 Upgrade can-globals to 0.1.0\n\nSee the full diff\n\n. ## Version 3.2.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n5868280 Update dist for release\ncd17e97 Merge pull request #109 from canjs/bg-route-key-warning-99\n1dc04ef Improve test with expected error message\nad3b6ae Update can-stache-key and add doctype\ne826c0b Remove warning when routes have a trailing slash #99\n\nSee the full diff\n\n. ## Version 3.2.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n02aaefb Update dist for release\n824e7f4 Merge pull request #56 from canjs/unregister-then-modify\nefe83fe extracting Observation queueing code to separate module\n41b0c06 running add,set,remove,move in the Observation update queue\n7dbf450 adding failing test for #55\n\nSee the full diff\n\n. ## Version 3.1.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.10.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n669f976 Update dist for release\n6b930b1 Merge pull request #345 from canjs/mme\n1c10363 Prevent keeping count of DocumentFragments in mutation events\n6ac439c Merge pull request #344 from canjs/341-fix-explorer-spelling\n25d0d68 Fix spelling of Internet Explorer in docs (#341)\n\nSee the full diff\n\n. ## Version 3.10.8 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n198bc79 Update dist for release\nec24c9a Merge pull request #346 from canjs/del\nd9a1d92 Prevent removeDelegateListener from throwing\n\nSee the full diff\n\n. ## Version 3.7.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits.\n\n0f63317 Update dist for release\n\nSee the full diff\n\n. ## Version 3.7.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n8005a64 Update dist for release\n3531231 Merge pull request #285 from canjs/173-bracketdots\n81073f9 Closes #173 - Add several bracket tests and fix 2 way binding\n\nSee the full diff\n\n. ## Version 3.7.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nDoc updates for new can-stache-bindings syntax\n#306\n\n\nCommits\nThe new version differs by 3 commits.\n\n234758a Update dist for release\nb2030e6 Merge pull request #306 from canjs/bg-doc-fix\n7d118db Update to new binding syntax\n\nSee the full diff\n\n. ## Version 3.7.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 10 commits.\n\n59844f3 Update dist for release\ncbdd6d8 Merge pull request #309 from canjs/support-dynamic-import-tag\nd7e0915 Add support for can-dynamic-import tag and static can-import when tag is not self-closing but does not have content\nfc0f292 Merge pull request #299 from canjs/274-with-keys\n4fa0c19 renaming underscore prefixed names in example for clarity\nafef862 Doc updates for hash expression support in #with helper\n34767d1 Fix #with helper so it always renders fn block\nf05b709 Add support for hash keys in with expression (#274)\nd85d8cd Merge branch 'master' into 274-with-keys\n2faab01 Added test for with and multiple keys\n\nSee the full diff\n\n. ## Version 3.8.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n3eb013b Update dist for release\nb2de39a Merge pull request #307 from canjs/302-improve-warning-tests\n936c6c0 Use full module for can-test-helpers instead of individual lib\ndec9202 Refactored dev warning tests to use can-test-helpers\n\nSee the full diff\n\n. ## Version 3.9.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 8 commits.\n\n675fa5c Update dist for release\nc8fd06a not creating lockfile\n2a8fc87 Merge pull request #320 from canjs/300-each-hash-expressions\n5d0c479 Warning message now better explains how to use hash expression when using as signature.\n508523b Merge pull request #319 from canjs/landscaper/define-cycles-github\n8854894 Add handling for iterable objects\n09239da Update each helper to use hash expressions\n04a6b9f landscaper: Add a cycle detection script to test process\n\nSee the full diff\n\n. ## Version 3.7.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nRevert 3.7.2\nThis patch release reverts the change from can-event 3.7.2, which caused apps rendered with done-ssr from waiting correctly. A more appropriate fix for the issue that 3.7.2 sought to fix will be done in 3.7.4.\n\n\nCommits\nThe new version differs by 2 commits.\n\n0ca9554 Update dist for release\nc14e3d8 Revert \"Prevent running warning setTimeout when not needed\"\n\nSee the full diff\n\n. ## Version 3.7.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n53a8ece Update dist for release\nc8322e2 Merge pull request #69 from canjs/sl-warn\nb9fc588 Prevent running missing batch.stop() warning code within a Zone\n\nSee the full diff\n\n. ## Version 0.2.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits ahead by 4, behind by 1.\n\n56ae7ee 0.2.1\ndc19e5d Update version number\n8e58fa5 jshint\n0b15b83 can read the emitter property\n\nSee the full diff\n\n. ## Version 1.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nsize, assign[Deep], update[Deep]\nThis documents size, assign, update, assignDeep and updateDeep.\n\n\nCommits\nThe new version differs by 2 commits.\n\na5e5e23 Merge pull request #44 from canjs/assign-update\n2b69d6e assign and update docs\n\nSee the full diff\n\n. ## Version 1.4.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n2bebd53 1.4.1\n41ef747 Merge pull request #45 from jeroencornelissen/master\n3e657eb typeof returns string\n\nSee the full diff\n\n. ## Version 1.4.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nisObservableLike defaults to returning false\nPrior to this release:\ncanReflect.isObservableLike([]) //undefined\ncanReflect.isObservableLike({}) //undefined\ncanReflect.isObservableLike(null) //false\nExpected/fixed behavior:\ncanReflect.isObservableLike([]) //false\ncanReflect.isObservableLike({}) //false\ncanReflect.isObservableLike(null) //false\nThis release also adds new NPM scripts to package.json, include release management and cycle detection.\n\n\nCommits\nThe new version differs by 6 commits.\n\n5ec1bd7 Update dist for release\n0616a10 Add version and release scripts to package.json\nd97ce63 Merge pull request #56 from canjs/fix-observerableLike-bg\n13aff8f Merge pull request #57 from canjs/landscaper/define-cycles-github\n0d4147a Fixed observableLike to default to returning false\na0cb02f landscaper: Add a cycle detection script to test process\n\nSee the full diff\n\n. ## Version 1.4.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nPass through onEvent arguments\nIf passing multiple arguments to onEvent(arg1,arg2, etc), all arguments will be forwarded to the underlying symbol's function.\n\n\nCommits\nThe new version differs by 6 commits.\n\n62e3118 Merge pull request #58 from canjs/queue\n5482e15 merging\nc716a5c bumping version\n8126087 passes many arguments\nf6894d0 Fix tests where QUnit.ok logged a boolean\n7752608 allows phase argument on events\n\nSee the full diff\n\n. ## Version 1.4.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\na3177b5 Update dist for release\nb92fb25 running build in preversion\n0c3d66c Merge pull request #59 from canjs/cleanup-modified-map\n8fcab4b correctly cleaning up symbols added to Map.prototype\n\nSee the full diff\n\n. ## Version 0.5.9 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits.\n\n4d90373 Update dist for release\n83336d8 Merge pull request #86 from canjs/ie10\n940b8c3 remove polyfill\n7590aad add polyfills for ie < 11\nd562766 Autobind ViewModel methods (#83)\n13350b1 Merge pull request #82 from canjs/landscaper/define-cycles-github\n65b366b landscaper: Add a cycle detection script to test process\n\nSee the full diff\n\n. ## Version 1.5.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n12e9480 Update dist for release\n340c51d Merge pull request #273 from canjs/define-lazy-value\n388c76b using can-define-lazy-value\n31c19a5 Merge pull request #272 from canjs/landscaper/define-cycles-github\nabbf940 landscaper: Add a cycle detection script to test process\n\nSee the full diff\n\n. ## Version 3.2.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits.\n\ne3d32b1 Update dist for release\n1dcde87 Merge pull request #34 from canjs/remove-cyclic-dep\n09cf4c6 Update can-view-parser to prevent can-util cyclic dep\n914e6d6 Update dist for release\n0ded58e Merge pull request #33 from canjs/landscaper/define-cycles-github\ne02cab0 Move can-util to a devDependency to avoid cyclic deps\ndab8100 landscaper: Add a cycle detection script to test process\n\nSee the full diff\n\n. ## Version 3.3.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nf709e0b Update dist for release\nfa23e39 Merge pull request #95 from canjs/298-unwritable\nc430668 handle undefined parents on set\n\nSee the full diff\n\n. ## Version 3.3.8 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\nf82c0c0 Update dist for release\n61ab403 fix undefined property test\n\nSee the full diff\n\n. ## Version 0.1.9 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n8bac8a8 Update dist for release\neaf7132 Merge pull request #14 from canjs/ie10\n586cb25 remove polyfill\ne583766 add polyfill for ie < 11\n\nSee the full diff\n\n. ## Version 3.3.9 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\neace52e Update dist for release\nf3fe5c6 Merge pull request #113 from canjs/landscaper/update-parent\n02a7254 Change this package\u2019s collection to infrastructure\n82c30ba Update docs with new @parent & @collection\n\nSee the full diff\n\n. ## Version 3.10.13 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nUpdate docs with new @parent & @collection\n\nRemoving setAttributeNode #321\nRevert \"Removing setAttributeNode\" #365\nUpdate docs with new @parent & @collection #369\n\nv3.10.12...v3.10.13\n\n\nCommits\nThe new version differs by 11 commits.\n\n502b325 Update dist for release\n973b171 Merge pull request #369 from canjs/landscaper/update-parent\nf0d9a4e Update docs with new @parent & @collection\na848955 Merge pull request #365 from canjs/revert-321-encoded-set-attribute\nfe4f82d Revert \"Removing setAttributeNode\"\n85c3b05 Merge pull request #321 from canjs/encoded-set-attribute\n70919f5 Merge branch 'master' into encoded-set-attribute\nd3e58c8 Update dist for release\ncf2384f Merge remote-tracking branch 'origin/master' into encoded-set-attribute\n9c04adb Update dist for release\n933ef5e Removing special handling of attributes\n\nSee the full diff\n\n. ## Version 3.2.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 0.3.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n172d760 Update dist for release\nfae98f5 Merge pull request #54 from canjs/landscaper/update-parent\n53c223f Update docs with new @parent & @collection\n\nSee the full diff\n\n. ## Version 3.6.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nUpdate docs with new @parent & @collection\n\nUpdate docs with new @parent & @collection #76\n\nv3.6.2...v3.6.3\n\n\nCommits\nThe new version differs by 3 commits.\n\n5326c5e Update dist for release\n7a99d20 Merge pull request #76 from canjs/landscaper/update-parent\n4c7eb6c Update docs with new @parent & @collection\n\nSee the full diff\n\n. ## Version 3.11.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nDeprecating `*foo` and `{{>*self}}` and documenting `scope`\ncan-view-scope@3.4.0 added a new scope keyword to access the templateContext and deprecated *foo and {{>*self}}. This release officially deprecates these in the docs and adds documentation for the scope keyword.\n\n\nCommits\nThe new version differs by 5 commits.\n\nfa287b0 Update dist for release\nde8a247 Merge pull request #346 from canjs/add-scope-deprecate-self\ndeb7446 deprecating *variable and *self and documenting scope (templateContext)\n8ca5ff5 Merge pull request #340 from canjs/45-filename\n30bc347 accept filename for intermediate_and_imports (fixes canjs/steal-stache#45)\n\nSee the full diff\n\n. ## Version 3.11.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n5f7a7b2 Update dist for release\n8c6ad7e warn less often (#330)\n\nSee the full diff\n\n. ## Version 3.12.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 23 commits.\n\n63a0d05 Update dist for release\na4cdb9f Merge pull request #352 from canjs/special-template-context\n705f229 deprecating %index/@index in favor of scope.index when using #items\nb259553 Merge pull request #303 from canjs/migrate-to-can-globals\neb6a287 Merge remote-tracking branch 'origin/master' into special-template-context\ne35c883 Landscaper: Remove deprecated can-util methods and replace with can-globals\n0826043 Merge pull request #350 from canjs/325-make-each-work-with-plain-objects\n9b574b8 Separate handling of plain object and arrays\nd8b32d7 Combine object and array each handling\n43614c8 Merge pull request #351 from canjs/landscaper/update-parent\nee63cab Update docs with new @parent & @collection\n50ace69 Fixed issue breaking hash expressions with plain objects\n318422a cleaning up warning filename/linenumber\nf39c4df small doc fix\n1d9653a Move remaining %special values to scope in the docs and deprecated %special\n\nThere are 23 commits in total.\nSee the full diff\n\n. ## Version 3.13.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nAdding scope.root\nThis adds a {[scope.root}} that you can use to access the data passed to a stache renderer function. This allows you to avoid scope walking with recursive partials:\nconst data = new DefineMap({\n    name: \"Earthworm Jim\",\n    child: {\n        name: \"Grey Worm\",\n        child: {\n            name: \"MyDoom\"\n        }\n    },\n    exclaim: '!!!'\n});\n\nconst view = stache(\"AppTemplate\", `\n    {{<personAndChildren}}\n        <span>{{name}} {{scope.root.exclaim}}</span>\n        {{#./child}}\n            <div>\n                {{>personAndChildren this}}\n            </div>\n        {{/./child}}\n    {{/personAndChildren}}\n\n    {{>personAndChildren this}}\n`);\n\n#353\n\n\nCommits\nThe new version differs by 5 commits.\n\n52f45ef Update dist for release\n19dfb0d Merge pull request #353 from canjs/scope-root\nd5154dc adding root scope to scope.root keyword\ncc4cdae alphabetizing scope keys\n8d1f818 removing filename metadata since it is set in {{scope.filename}} now\n\nSee the full diff\n\n. ## Version 3.13.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nb7cad0a Update dist for release\n7fe91c1 Merge pull request #355 from canjs/3660-docs\n5b23836 Fix the Sections docs\n\nSee the full diff\n\n. ## Version 3.13.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nMaking scope.index work with plain arrays\n#357\n\n\nCommits\nThe new version differs by 3 commits.\n\ned1c616 Update dist for release\n61ffc70 Merge pull request #357 from canjs/index-with-arrays\n5c30cca correctly setting scope.index and deprecating %index/@index with arays\n\nSee the full diff\n\n. ## Version 1.7.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits.\n\n71cd54c Update dist for release\n4f5c945 Merge pull request #71 from canjs/IE9-test-fix\nb2637dd Changed to still add name when no name exists\ndadbd6d Modified check to look for configurable and writable\nb82f47c Added check to make sure reflection name is not already defined\nde867e6 Added feature detect for writing function name props\ndbe21d3 Used object define for setting aliases\n\nSee the full diff\n\n. ## Version 1.7.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nRelease to re-include test folder\nThis was due to an npm bug\n\n\nCommits\nThe new version differs by 1 commits.\n\n2bb2704 Update dist for release\n\nSee the full diff\n\n. ## Version 1.7.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits.\n\n6a25186 Update dist for release\n11dbac9 Merge pull request #74 from canjs/3660-docs\nffd5c90 Hide aliases\n242f8f1 Add @parent to isPromise docs\n3516edd Add @parent to alias functions\n7ac6afe Merge pull request #69 from canjs/imaustink-patch-1\naaa58e1 Merge pull request #72 from canjs/landscaper/update-parent\n5a3f88c Update docs with new @parent & @collection\na3b9c73 Add Green Keeper badge\n\nSee the full diff\n\n. ## Version 3.3.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits.\n\n5933d6c Update dist for release\na832152 Merge pull request #148 from canjs/migrate-to-can-globals\n9bb0146 Landscaper: Remove deprecated can-util methods and replace with can-globals\nfd13dc0 Merge pull request #149 from canjs/bg-doc-fix\n477dd1e Use camelCase on instead of hyphens\n9856655 Merge pull request #161 from canjs/landscaper/update-parent\n7cae2a4 Remove old/broken docs\n748e4da Update docs with new @parent & @collection\nf2c9269 Update can-component docs with new binding syntax\n\nSee the full diff\n\n. ## Version 3.2.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nUpdated docs in preparation for new sidebar\n\nUpdate docs with new @parent & @collection #66\nFix broken code docs #64\nHide docs that can\u2019t show up in the navigation #67\n\nv3.2.4...v3.2.5\n\n\nCommits\nThe new version differs by 9 commits.\n\n76b4d91 Update dist for release\n9072545 Merge pull request #67 from canjs/3660-docs\n529e380 Hide docs that can\u2019t show up in the navigation\n943324a Undo accidental commit to master\ncf0b22d Hide docs that can\u2019t show up in the navigation\n7c48767 Merge pull request #64 from canjs/chasenlehara-patch-1\ne89f079 Merge pull request #66 from canjs/landscaper/update-parent\nfa27b12 Update docs with new @parent & @collection\n0e8e53c Fix broken code docs\n\nSee the full diff\n\n. ## Version 3.5.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\ne36e87d Update dist for release\n584f76c Merge pull request #109 from canjs/special-template-context\nbb13344 fixing jshint\n45c9400 making %special variables non-observable if read from templateContext\n\nSee the full diff\n\n. ## Version 3.5.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n51ddbe9 Update dist for release\n94afa58 Merge pull request #110 from canjs/add-line-number-observable-blacklist\n3a28619 Added lineNumber to observable blacklist\n\nSee the full diff\n\n. ## Version 3.5.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\n2baf9e7 Update dist for release\n3f8e020 Merge pull request #108 from canjs/add-line-numbers-to-warnings\n4ce8747 Read filename and lineNumber from nonObservableVars\n93eacce Merge pull request #112 from canjs/landscaper/update-parent\n47d5619 Update docs with new @parent & @collection\n2e40bc8 Update dist for release\n\nSee the full diff\n\n. ## Version 3.5.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nHide & remove old docs\n\nHide & remove old docs #114\n\nv3.5.2...v3.5.3\n\n\nCommits\nThe new version differs by 2 commits.\n\n683d14c Update dist for release\n1497e12 Hide & remove old docs (#114)\n\nSee the full diff\n\n. ## Version 0.6.14 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nFixed a bug, updated a dependency, and updated the docs\n\nMake sure wrapped event handler is created only once #146\nUpdate mocha to the latest version \ud83d\ude80 #142\nUpdate docs with new @parent & @collection #147\n\nv0.6.13...v0.6.14\n\n\nCommits\nThe new version differs by 9 commits.\n\n012cb5b Update dist for release\n7fa2dd5 Merge pull request #147 from canjs/landscaper/update-parent\n8b00e8c Merge pull request #142 from canjs/greenkeeper/mocha-4.0.0\nc89d0d0 Merge branch 'master' into greenkeeper/mocha-4.0.0\nb7aeb8a Add doctype to test.html\n14817f1 Update docs with new @parent & @collection\nbfcebf7 Merge pull request #146 from canjs/el\nf0a440e Make sure wrapped event handler is created only once\nf76d156 chore(package): update mocha to version 4.0.0\n\nSee the full diff\n\n. ## Version 3.2.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nUpdate docs with new @parent & @collection\n\nUpdate docs with new @parent & @collection #67\n\nv3.2.2...v3.2.3\n\n\nCommits\nThe new version differs by 3 commits.\n\n9230f37 Update dist for release\ne8ea61a Merge pull request #67 from canjs/landscaper/update-parent\n751ba8b Update docs with new @parent & @collection\n\nSee the full diff\n\n. ## Version 3.10.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.10.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.11.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 2.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n2.1.0\nMatching Socket.IO 2.1.0 release notes\nFeatures\n\nadd a 'binary' flag (#1194)\n\n// by default, the object is recursively scanned to check whether it contains some binary data\n// in the following example, the check is skipped in order to improve performance\nsocket.binary(false).emit('plain-object', object);\nMilestone: 2.1.0\nDiff: 2.0.4...2.1.0\n\n\nCommits\nThe new version differs by 8 commits.\n\n3eb047f [chore] Release 2.1.0\nafb952d [docs] Add a note about reconnecting after a server-side disconnection\n74893d5 [feat] Add a 'binary' flag (#1194)\n9701611 [chore] Bump engine.io-client to version 3.2.0 (#1192)\n3d8f24e [test] Update travis configuration\ne27f38b [chore] Restore unminified distribution files (#1191)\nbb743c4 [docs] Document connected and disconnected socket properties (#1155)\nf31837f [chore] Bump debug to version 3.1.0\n\nSee the full diff\n\n. ## Version 2.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 12.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv12.0.1\n\n12.0.1 (2017-10-25)\nBug Fixes\n\nadapt for mime@2 (fb0ad88)\n\n\n\nCommits\nThe new version differs by 2 commits.\n\nfb0ad88 fix: adapt for mime@2\nc961627 chore(package): update @octokit/fixtures to version 3.0.0\n\nSee the full diff\n\n. ## Version 12.0.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv12.0.4\n\n12.0.4 (2017-11-22)\nBug Fixes\n\npackage: update follow-redirects to version 1.2.6 (1667120)\n\n\n\nCommits\nThe new version differs by 2 commits.\n\n1667120 fix(package): update follow-redirects to version 1.2.6\n309e66e docs(README): fixlink to promise example (#651)\n\nSee the full diff\n\n. ## Version 12.0.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv12.0.5\n\n12.0.5 (2017-11-22)\nBug Fixes\n\ndon\u2019t pass filePath as query parameter (3c2e465)\n\n\n\nCommits\nThe new version differs by 2 commits.\n\n3c2e465 fix: don\u2019t pass filePath as query parameter\n11fed85 test(scenario): release assets\n\nSee the full diff\n\n. ## Version 12.0.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv12.0.6\n\n12.0.6 (2017-11-26)\nBug Fixes\n\ncalculate content-length correctly for raw markdown request (4f819ad)\n\n\n\nCommits\nThe new version differs by 3 commits.\n\n4f819ad fix: calculate content-length correctly for raw markdown request\n46049aa test: markdown\n86db8c3 scenario: rename repository\n\nSee the full diff\n\n. ## Version 12.0.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv12.0.7\n\n12.0.7 (2017-11-28)\nBug Fixes\n\nwhitelist X-GitHub-SSO header in response (#663) (1e07daf)\n\n\n\nCommits\nThe new version differs by 3 commits.\n\n1e07daf fix: whitelist X-GitHub-SSO header in response (#663)\nd5a3261 chore(package): @octokit/fixtures^5.4.0\n081d5a0 test(scenario): search issues\n\nSee the full diff\n\n. ## Version 12.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv12.1.0\n\n12.1.0 (2017-11-29)\nFeatures\n\nadd child team list route (#664) (14f18c2)\n\n\n\nCommits\nThe new version differs by 1 commits.\n\n14f18c2 feat: add child team list route (#664)\n\nSee the full diff\n\n. ## Version 13.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv13.0.1\n\n13.0.1 (2017-12-02)\nBug Fixes\n\nrespect NO_PROXY environment variable (#667) (9c68105)\n\n\n\nCommits\nThe new version differs by 73 commits.\n\n9c68105 fix: respect NO_PROXY environment variable (#667)\n3c4ab02 breaking: remove .get{Scope name}Api() methods\n1956da2 test: remove test for .get{Scope name}Api() methods\n31ba34a docs(CONTRIBUTING): add note about how type definitions and API docs are generated and published automatically\n762a7e3 docs(README): remove dev notes section\n5e5d2b2 chore: remove followRedirects option from type definitions\nabb2be4 chore(package): publish to npm with @next dist tag\n51eeb0d fix: no headers are sent if there are no headers\n20da873 test: no \"link\" header is sent if there are no pages\n7f3528a chore(package): deploy docs after publish\n49d21dd chore(package): build:docs script\n2e98859 chore(script): generate API docs\n21b234b docs(README): add heads up comment to keep README example and type definition templates in sync\n21c50a8 chore(gitignore): doc/apidoc.js\ncd70273 chore: lowercase scripts file names\n\nThere are 73 commits in total.\nSee the full diff\n\n. ## Version 13.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv13.1.0\n\n13.1.0 (2017-12-31)\nFeatures\n\nerror on 304s (#673) (a0c65a2)\n\n\n\nCommits\nThe new version differs by 10 commits.\n\na0c65a2 feat: error on 304s (#673)\n8940925 chore: remove obsolete comment\n85b1810 chore(stale): initial configuration\n85255a1 fix: uploadAsset with file: fs.createReadStream()\nda35582 test: uploadAsset with file: fs.createReadStream()\nd1afb97 chore(package): is-stream\n87adbdd chore(package): update description\n430c0bc docs(README): update summary\nf5de18d docs(README): CLI debug instructions (#671)\n1d7cdb9 Fix typos\n\nSee the full diff\n\n. ## Version 14.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv14.0.0\n\n14.0.0 (2018-01-17)\nBreaking changes\nThe package has been renamed from github to @octokit/rest.\nTo upgrade\n\nnpm install @octokit/rest\nnpm uninstall github\nreplace require('github') with require('@octokit/rest')\n\nThat\u2019s it, there are no functional changes in the public APIs compared to github@13.\nDebug logs\nDEBUG=node-github* is now DEBUG=octokit*.\nIn case you enabled debug logs, make sure to adapt the DEBUG environment variable accordingly.\n\n\nCommits\nThe new version differs by 1 commits.\n\nfa09dd8 deprecated: 'github' has been renamed to '@octokit/rest' (https://git.io/vNB11)\n\nSee the full diff\n\n. ## Version 1.5.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nRelease to re-include test folder\nThis was due to an npm bug\n\n\nCommits\nThe new version differs by 1 commits.\n\n65d55a4 Update dist for release\n\nSee the full diff\n\n. ## Version 1.5.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nUpdate docs with new @parent & @collection\n\nUpdate docs with new @parent & @collection #284\n\nv1.5.3...v1.5.4\n\n\nCommits\nThe new version differs by 3 commits.\n\nef99482 Update dist for release\n3185844 Merge pull request #284 from canjs/landscaper/update-parent\nf69a9dc Update docs with new @parent & @collection\n\nSee the full diff\n\n. ## Version 1.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\ndfbdc93 Update dist for release\n1c388ef Merge pull request #28 from canjs/landscaper/update-parent\n0ec25f3 Update docs with new @parent & @collection\n\nSee the full diff\n\n. ## Version 3.2.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nUpdate docs with new @parent & @collection\n\nUpdate docs with new @parent & @collection #51\n\nv3.2.2...v3.2.3\n\n\nCommits\nThe new version differs by 3 commits.\n\n0c6ff92 Update dist for release\n2ca66bf Merge pull request #51 from canjs/landscaper/update-parent\n56cfd02 Update docs with new @parent & @collection\n\nSee the full diff\n\n. ## Version 2.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 14 commits.\n\n2632d57 2.0.0\na70ca7a fixes log dep\n6f4992b Merge pull request #18 from canjs/major\n1e62525 Merge branch 'master' into major\n1d0b94e removing build\n42382aa Merge pull request #21 from canjs/error-test\nfe124ea moving test from can-stache-key\n58573c5 not creating package-lock.json\nebafd81 2.0.0-pre.5\n4e19b1d Merge pull request #20 from canjs/merge-master-to-major\n6cce6b5 Merge branch 'master' into merge-master-to-major\n737b510 Update dist for release\nb492a1b Merge pull request #19 from canjs/landscaper/update-parent\n9758d42 Update docs with new @parent & @collection\n\nSee the full diff\n\n. ## Version 2.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits.\n\nf6006fc 2.0.1\n\nSee the full diff\n\n. ## Version 1.0.0-pre.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 0.2.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nMake onKeyValue dispatch the resolved value when function is provided\n\nonKeyValue should dispatch the resolved value #30\n\nv0.2.4...v0.2.5\n\n\nCommits\nThe new version differs by 5 commits.\n\nae0f9f1 Update dist for release\n582b0bb Merge pull request #30 from canjs/29-events-should-dispatch-resloved-value\nbdba718 onKeyValue should not dispatch default value if set to undefined\nb3d752b onKeyValue should return default value if new value is undefined\n786a041 onKeyValue should dispatch the resolved value\n\nSee the full diff\n\n. ## Version 0.2.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nFixed a couple small bugs\n\nFix reset method to reset all keys to default value #32\nDon't call value function twice when observing #34\n\nv0.2.5...v0.2.6\n\n\nCommits\nThe new version differs by 5 commits.\n\n7c5cccc Update dist for release\nf0f2c5c Merge pull request #34 from canjs/33-dont-call-value-function-twice\n7371ae7 Don't call value function twice when observing\nc59fadd Merge pull request #32 from canjs/31-reset-should-default-keys\n5c20124 Fix reset method to reset all keys to default value\n\nSee the full diff\n\n. ## Version 1.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits ahead by 2, behind by 1.\n\n4132335 1.0.3\n0898b2e Update version number\n\nSee the full diff\n\n. ## Version 1.3.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\ne73bb39 1.3.3\n39f533f Merge pull request #82 from canjs/remove-class\nced7663 Element.removeAttribute updates className\n\nSee the full diff\n\n. ## Version 1.3.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n90b2678 1.3.4\n8a23ed7 Merge pull request #83 from canjs/update-class\n6d7f4b5 Element.setAttribute updates existing className\n\nSee the full diff\n\n. ## Version 1.0.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.0.7\nChange the can-globals semver range to <2.0.0 #34\n\n\nCommits\nThe new version differs by 5 commits.\n\n17ef02e 1.0.7\n0104cb9 Add release docs\n7aeeecd Merge pull request #34 from canjs/greenkeeper/can-globals-0.3.0\n9081d5d Update package.json\n9f1d1e4 fix(package): update can-globals to version 0.3.0\n\nSee the full diff\n\n. ## Version 1.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\ncd932c2 1.1.0\n8bb644f Merge pull request #37 from canjs/magneto\nda6ee66 Add delegate listener support\n\nSee the full diff\n\n. ## Version 1.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n6df719a Merge pull request #40 from canjs/deps-updates\nd221e29 updates deps to latest\n\nSee the full diff\n\n. ## Version 4.0.0-pre.33 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 87 commits ahead by 87, behind by 3.\n\n407f33b 4.0.0-pre.33\nf79d7a3 Merge pull request #132 from canjs/remove-deprecated\nbf241e0 Update to can-reflect-dependencies\n3c0841a 4.0.0-pre.32\n399c058 updating tests to handle functions that are not called automatically\nfa08547 4.0.0-pre.31\nb4133f1 Merge pull request #131 from canjs/move-scope-root\n9a6c68c moving scope.root into can-view-scope\n1ffe2fa 4.0.0-pre.30\n4b7ddb4 Merge pull request #130 from canjs/set-context-data\nf1ccb0d Implement getDataForScopeSet\n2ae0ecc 4.0.0-pre.29\n96a0b57 Don\u2019t test mutated dependencies in production\nbe68cdd 4.0.0-pre.28\n0414014 Merge pull request #127 from canjs/read-from-no-parent\n\nThere are 87 commits in total.\nSee the full diff\n\n. ## Version 3.5.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits ahead by 7, behind by 87.\n\nc212b17 Update dist for release\n1268366 upgrading to latest can-log 1.0\na9faf9b Merge pull request #140 from canjs/docs-cleanup\na56e1fb Add language tags to the code examples\n191a995 Update dist for release\n47ce5e7 Merge pull request #121 from canjs/120-fix-reading-function-from-star\n19da47d Fix issue reading function from templateContext using *\n\nSee the full diff\n\n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 145 commits.\n\neff2019 4.0.1\n102d7e4 4.0.0\n6fc203a Merge pull request #97 from canjs/major\nca42738 fixing merge artifacts\na83ed38 merged with major\nd4cdf2e pointing at major releases\n4d563f2 4.0.0-pre.49\na9be6d6 Fix some merge mistakes\n209f969 4.0.0-pre.48\n5e98432 Merge branch 'scope-find-docs' into major\n7185944 Merge branch 'master' into major\n42e07ee fixing link to can-observation-recorder.add\n7f8e287 documenting scope.find and removing implicit scope walking from docs\n4f03c2f making Scope.prototype.find accept readOptions\n08884c0 removing docs for Options & Refs which have been removed\n\nThere are 145 commits in total.\nSee the full diff\n\n. ## Version 3.13.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 8 commits.\n\neef09b6 Update dist for release\n9c69a70 Merge pull request #373 from canjs/372-set-line-number-on-scope-at-end\n2aa5bf7 Set lineNumber on close and attrEnd and add tests for it all\na080448 Set lineNumber on the scope before passing it to viewCallbacks.tagHandler\na39e4b3 Merge pull request #362 from canjs/fix-erroneous-closing-tag-with-bracket\nd510fb0 Make the new tests devOnly\n7a288ec Close bracket notation with the root, and don't warn when missing closing tag for warning\n6215f46 Fixed a bug causing erroneous warnings when expression uses brackets\n\nSee the full diff\n\n. ## Version 3.14.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\n2252d8e Update dist for release\n868cadb Merge pull request #367 from canjs/add-live-helper\n32fcc44 Merge remote-tracking branch 'origin/master' into add-live-helper\n822424f deprecating registerSimpleHelper in favor of addHelper\nb47da8a Making #each(list) use can-view-live.list\n4a90bde simplifying cases in \"each\" helper\n\nSee the full diff\n\n. ## Version 3.14.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nb63a143 Update dist for release\n6b1638b Merge pull request #385 from canjs/comma\nec31610 Move dev-only argument into a variable to fix IE\n\nSee the full diff\n\n. ## Version 3.14.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\nb356f16 Update dist for release\n9eadca2 Merge pull request #387 from canjs/call-helper-arg-warning\n48164d4 adding a warning for automatically called functions that are passed as arguments to helpers\nefd8f3f Fix variable declaration\neb59c71 adding lineNumber to scope walking warning\n9e0f2dd adding lineNumber to automatic function calling warning\n\nSee the full diff\n\n. ## Version 3.14.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits.\n\n750e8dd Update dist for release\n1f116e0 Merge pull request #392 from canjs/greenkeeper/can-globals-0.3.0\n4e69180 Update package.json\n203612b fix(package): update can-globals to version 0.3.0\n4d99191 Update routeUrl.md\nd5a1502 Merge pull request #388 from frank-dspeed/patch-3\nc56263d Update sectionRenderer.md\n\nSee the full diff\n\n. ## Version 3.14.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n3f82e60 Update dist for release\n6d24d5c Merge pull request #399 from canjs/fix-test\neda9d65 Fix test causing can-jquery to break\n\nSee the full diff\n\n. ## Version 3.14.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 14 commits.\n\n1ee4640 Update dist for release\n05a0b56 Merge pull request #404 from eben-roux/patch-2\n4489117 Fix registerSimpleHelper warning\nf1e291c Merge pull request #403 from canjs/replace-attr\n3fe83eb - registerSimplePartial to registerSimpleHelper\nd89173d Use canReflect.getKeyValue() instead of .attr()\naba0281 Merge pull request #398 from canjs/change-eq-to-is\n6563ea6 Merge pull request #397 from canjs/fixup-routeCurrent-docs\n3a0139c Merge pull request #396 from canjs/remove-extraneous-it\nf74323a Merge pull request #395 from canjs/remove-redundant-looks\n8fa95e5 Change instances of \"eq\" to \"is\" in is.md\naabd2e2 Fixup docs in routeCurrent.md\n3798d96 Remove extraneous \"it\" in routeUrl.md\nf0e1835 Remove redundant \"looks\" in context.md\n\nSee the full diff\n\n. ## Version 3.14.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 8 commits.\n\n4846cc9 Update dist for release\n2c82698 Merge pull request #417 from canjs/line-number-object\n9f727ab moving lineNumber onto the HTML section state object\ne2d5845 fixing case where lineNumber was set to state object\nbb58769 Merge pull request #412 from canjs/clean-up-docs\na5317d5 Clean up the docs\n8397741 Merge pull request #407 from canjs/chasenlehara-patch-1\n43c82ee Fix %special deprecation warning\n\nSee the full diff\n\n. ## Version 3.14.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.14.7\nSupport can-template with no content #421\n\n\nCommits\nThe new version differs by 3 commits.\n\n865e3aa Update dist for release\n76d048d Merge pull request #421 from canjs/418-empty-can-template\ndd089e3 Support can-template with no content\n\nSee the full diff\n\n. ## Version 3.14.8 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nfa20acd Update dist for release\ne8bdd7c Merge pull request #424 from canjs/each-deprecation-docs\n20bcc10 fixing deprecation warning for as in {{#each}}\n\nSee the full diff\n\n. ## Version 3.14.9 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n7021dca Update dist for release\nc8e593c Merge pull request #430 from canjs/update-deps-util-parser\na9f0903 Update the dependencies for can-view-parser and can-util\n\nSee the full diff\n\n. ## Version 3.14.11 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n803cd9d Update dist for release\nfac50d0 Update dist for release\n078a83b upgrading to 1.0 can-log\n\nSee the full diff\n\n. ## Version 4.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 161 commits ahead by 161, behind by 6.\n\nac0a983 4.0.0\n496be17 adding addConverter\nca0be91 4.0.0-pre.54\n0ada1eb Merge pull request #436 from canjs/default-helper-function\nbf39af9 making the default helper work when called as a function (again)\n2dc507b 4.0.0-pre.53\n198a109 removing docs for things removed in 4.0\n1bace9b 4.0.0-pre.52\n3f084ef using canReflect.hasKey for Unable to find key... warning check\n066c447 4.0.0-pre.51\n7bb3dd6 Merge pull request #428 from canjs/defined-undefined-warning\n58f502a not warning on keys that are defined but are undefined\n6cd9cf2 4.0.0-pre.50\n259ea1d fixing docs showing default helper as a function\ndbac45c 4.0.0-pre.49\n\nThere are 161 commits in total.\nSee the full diff\n\n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 10 commits.\n\nebed2e4 4.0.1\n4b9095d Merge pull request #455 from canjs/major\na6eb93e fixing json\n8f1c739 merging with master\n803cd9d Update dist for release\nfac50d0 Update dist for release\n078a83b upgrading to 1.0 can-log\n7021dca Update dist for release\nc8e593c Merge pull request #430 from canjs/update-deps-util-parser\na9f0903 Update the dependencies for can-view-parser and can-util\n\nSee the full diff\n\n. ## Version 4.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n99ab700 4.0.2\n62e9dff use can-dom-mutate instead of can-util\n\nSee the full diff\n\n. ## Version 3.11.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.11.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.11.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.11.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.11.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.11.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.11.8 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.11.9 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.11.10 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.0.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.0.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.10.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n10f6693 1.10.0\n9f3234d Merge pull request #81 from canjs/changes-methods\n6f0a883  Base implementation of new symbols\n\nSee the full diff\n\n. ## Version 1.10.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\nfebad70 1.10.1\nd02dc14 Merge pull request #83 from canjs/hide\nacecd5d Fix getWhatIChange symbol reference\n467f7b3 Hide getWhatIChange and getChangesDependencyRecord\n\nSee the full diff\n\n. ## Version 1.10.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n456321c 1.10.2\n1d054b8 Merge pull request #86 from canjs/not-throw\n6c268e7 Prevent getChangesDependecyRecord to throw\n\nSee the full diff\n\n. ## Version 1.11.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n7616326 Update dist for release\n9c67e35 Merge pull request #88 from canjs/get-name-docs\n733c96d Improve canReflect.getName docs\n\nSee the full diff\n\n. ## Version 1.11.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nFixes bug with updating deep lists\n#73\n\n\nCommits\nThe new version differs by 2 commits.\n\n69696f1 Update dist for release\n5366895 fixes #73, splices off the right number of values\n\nSee the full diff\n\n. ## Version 1.12.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n041fc16 1.12.0\n192635c Merge pull request #90 from canjs/greenkeeper/test-saucelabs-0.0.3\n254fcd8 Merge pull request #91 from canjs/instance-patches\necc2412 Add onInstancePatches and offInstancePatches\na6548ee chore(package): update test-saucelabs to version 0.0.3\n\nSee the full diff\n\n. ## Version 1.13.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\ncanReflect.hasKey\n#95\n\n\nCommits\nThe new version differs by 3 commits.\n\nd8660af Update dist for release\ne150ae8 Merge pull request #95 from canjs/has-key\nad7f234 adding hasKey\n\nSee the full diff\n\n. ## Version 1.13.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n4f71241 Update dist for release\nc8a7197 Merge pull request #97 from canjs/recur\nc57da5c Handle cycles in serialize()\n\nSee the full diff\n\n. ## Version 1.2.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits ahead by 2, behind by 1.\n\neb818b0 1.2.1\nddfef65 Update version number\n\nSee the full diff\n\n. ## Version 1.2.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.2.2\nFixes an issue in which Array, FormData, and data types were converted to plain objects #133 (thanks @roemhildtg!)\n\n\nCommits\nThe new version differs by 6 commits ahead by 6, behind by 1.\n\n024a2cb 1.2.2\ndce9276 Update version number\nb9d634d Merge pull request #141 from canjs/133-array-data\n0e5416a Accept arrays as the request data\n005a892 Merge pull request #134 from roemhildtg/master\nbb8eac6 check for form data types before processing data #133\n\nSee the full diff\n\n. ## Version 1.1.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.1.4\nChange the can-globals semver range to <2.0.0 #21\n\n\nCommits\nThe new version differs by 5 commits ahead by 5, behind by 1.\n\n9449844 1.1.4\n694006c Update version number\n636d29d Merge pull request #21 from canjs/greenkeeper/can-globals-0.3.0\n6310be4 Update package.json\n9fbc0c8 fix(package): update can-globals to version 0.3.0\n\nSee the full diff\n\n. ## Version 1.5.13 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.5.13\nUpdate deps to use latest can-set #385\nDiff: v1.5.12...v1.5.13\n\n\nCommits\nThe new version differs by 4 commits.\n\n1cb3997 Update dist for release\n90dec8c Merge pull request #385 from canjs/use-latest-can-set\n2a300f0 Update deps to use latest can-set\nb9dd379 Add !test/ to .npmignore\n\nSee the full diff\n\n. ## Version 2.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 47 commits.\n\n1d8423b 2.0.0\n7ac01d6 Replace can-event-queue/map/legacy/legacy with can-event-queue/map/map\ne42b604 Merge branch 'master' into major\nb2d5751 2.0.0-pre.14\n8a7e5cc Merge pull request #384 from canjs/fix-list-prop\n9225e13 Fix bug where properties in a getList response weren\u2019t being returned\n7f20c05 2.0.0-pre.13\n4da72a5 updating nodelist dep\ndc8fa88 2.0.0-pre.12\n6d3b0f7 Update prerelease semver ranges\na1f013e 2.0.0-pre.11\n8278b9d moving can-observe to dev deps\na523d85 2.0.0-pre.10\na484882 Update prerelease semver ranges\nab29e24 Merge branch 'master' into major\n\nThere are 47 commits in total.\nSee the full diff\n\n. ## Version 1.5.14 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.5.15 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n4568bb8 Update dist for release\nbe00a9f not creating package-lock.json\ncf5a3d9 Merge pull request #362 from canjs/102-batch-model-events\nf908670 Batch model events\n\nSee the full diff\n\n. ## Version 1.5.16 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nc648d0b Update dist for release\n1f9e059 Merge pull request #389 from canjs/update-can-set\nd232829 Update can-set and add test for set difference in paging\n\nSee the full diff\n\n. ## Version 1.5.17 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n2bbbab0 Update dist for release\n79d9902 Merge pull request #390 from canjs/url-param-encode\nae04615 [data/url] encode URL parameters\n\nSee the full diff\n\n. ## Version 0.6.17 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n5028693 0.6.17\n5e4f769 Merge pull request #159 from canjs/handlers\n712e734 Wrap event handlers set with on[event] = fn syntax\n\nSee the full diff\n\n. ## Version 3.8.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nf8371e8 Update dist for release\n3390f18 Merge pull request #82 from canjs/deprecate-magic-start\n3f3aa9a deprecating magicStart\n\nSee the full diff\n\n. ## Version 3.8.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nSupport closing bracket character (>) in attribute values\nPrior to this release, a fragment like <button data-value=\"3 > 2\"></button> would end the parsing of the start tag inside the attribute value when it encountered a character that looked like the end of the tag.\nWith this release, the above parses correctly, with 3 > 2 being parsed as the value of the data-value attribute and the tag ending after the attribute value ends.\n\n\nCommits\nThe new version differs by 3 commits.\n\nd769d3c Update dist for release\n4a8feb8 Merge pull request #84 from canjs/closing-bracket-in-attr-value\n1a50b6c Support closing bracket character (>) in attribute values\n\nSee the full diff\n\n. ## Version 0.1.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits ahead by 4, behind by 1.\n\nd46dc68 0.1.3\nc517752 Update version number\n274b2bc Merge pull request #16 from canjs/fix-automatic-function-call-warning\n0867f49 not warning when functions are not called due to proxyMethods=false\n\nSee the full diff\n\n. ## Version 3.1.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nc50b468 Update dist for release\ncef6346 Merge pull request #72 from canjs/imaustink-patch-1\n5177411 Really add note for caveat when using elements other than script tags\n\nSee the full diff\n\n. ## Version 1.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits ahead by 4, behind by 1.\n\n6930a72 1.1.1\nbbf1063 Update version number\nc68e534 Merge pull request #6 from canjs/revert-multiple-sources\nc952bb2 Revert \"adding support for passing multiple source objects\"\n\nSee the full diff\n\n. ## Version 3.10.18 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.10.18\n\nUpdate some docs with the new bindings syntax #388\nChange the can-globals semver range to <2.0.0 #393\n\n\n\nCommits\nThe new version differs by 7 commits.\n\n49cf550 Update dist for release\ne5517b7 Merge pull request #393 from canjs/greenkeeper/can-globals-0.3.0\n8dc16f7 Update package.json\n5dd2095 fix(package): update can-globals to version 0.3.0\n3c6db0e Merge pull request #388 from canjs/372-use-new-binding-syntax\nc34fe37 Update attr-special.focused.md\n3a836a7 Use new bindings syntax\n\nSee the full diff\n\n. ## Version 3.10.19 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n3.10.19\nFixes an issue where can-util/js/import/import would always call Promise.resolve() in optimized builds (instead of calling steal.import).\n\n\nCommits\nThe new version differs by 7 commits.\n\n3c4c6dd 3.10.19\n10d032b Merge pull request #400 from canjs/slim-support\nd5ec94a Merge pull request #398 from canjs/diff-array\n18114d4 Add support for slim loader\n6bd6bbc Merge pull request #394 from canjs/greenkeeper/test-saucelabs-0.0.3\nbbc5a7b Document diff-array utility\n68b34bd chore(package): update test-saucelabs to version 0.0.3\n\nSee the full diff\n\n. ## Version 3.11.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nAdd string.replaceWith()\nThis minor release adds can-util/js/string/string.replaceWith, see PR #402.\n\n\nCommits\nThe new version differs by 3 commits.\n\n0687e3e Update dist for release\n9f9f6eb Merge pull request #402 from canjs/replace-with\n044e7de Add string.replaceWith\n\nSee the full diff\n\n. ## Version 0.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n5b18d4a 0.4.0\nb4e29bf Merge pull request #37 from canjs/is-web-worker\n843901d removing build\n3ccf558 adds isWebWorker\n\nSee the full diff\n\n. ## Version 0.4.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nc5903f8 0.4.1\n9d5abdf Merge pull request #39 from canjs/ce\n756f8e4 Add can-globals/custom-elements/\n\nSee the full diff\n\n. ## Version 2.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\n60cbd82 2.0.0\n499ae8e Merge pull request #18 from canjs/magneto\ne0ad6fd Drop can-util and can-dom-data-state\n38647b8 Merge pull request #14 from canjs/cleanup-deps\n05899d5 Merge branch 'master' into cleanup-deps\nf0fd624 cleanup dependencies\n\nSee the full diff\n\n. ## Version 3.2.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n6b2cf89 Update dist for release\nbb98739 Merge pull request #84 from canjs/83-import-promise-warning\n8b678ca Make the importPromise a notContext scope\na7b84b9 Merge pull request #80 from canjs/fix-docs\n9f5bfc7 Update value:to docs to use scope.vars\n\nSee the full diff\n\n. ## Version 3.3.8 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.3.8\nDocs updates: #178 #182 #179 #187\n\n\nCommits\nThe new version differs by 10 commits.\n\n849f905 Update dist for release\nf594f6f Merge pull request #187 from canjs/demo-docs-updates\nde36070 Update docs to match the demos\nb6bc4c9 Merge pull request #182 from canjs/docs-fixes\n0128402 Update docs to use the new binding syntax\n3a5c992 Merge pull request #179 from canjs/update-bindings\n3d829c5 Use the new binding syntax in docs & tests\n620fbdc Merge pull request #178 from canjs/remove-extraneous-to\ne841002 Remove another extraneous \"to\" in component.md\nb4af02a Remove extraneous \"to\" in component.md\n\nSee the full diff\n\n. ## Version 3.3.9 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n5c98337 Update dist for release\n1fe1a6f Merge pull request #189 from canjs/self-closing-can-slot\n963f350 Fix issue with can-slot not working with  components\n\nSee the full diff\n\n. ## Version 3.2.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n040e3e1 Update dist for release\n68db8c5 Merge pull request #74 from canjs/testpaths\n4efae56 For canjs/canjs#3760 - fix test paths so they also work as part of canjs's tests\n\nSee the full diff\n\n. ## Version 3.2.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nbecc848 Update dist for release\n5bf6db7 Merge pull request #76 from canjs/75-target-hash\ncbe3401 Don\u2019t preventDefault() when clicking a link that just changes the hash\n\nSee the full diff\n\n. ## Version 3.2.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.3.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.3.2\nMake the tests more reliable: #134\n\n\nCommits\nThe new version differs by 3 commits.\n\nf9ec573 Update dist for release\n742e568 Merge pull request #134 from canjs/fix-tests\n6e57979 Make __url event test more reliable\n\nSee the full diff\n\n. ## Version 4.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 49 commits.\n\nf5f9f49 4.0.0\n0e6b2a3 Merge pull request #139 from canjs/removing-some-util\n5786710 removing some of can-util\n384adf1 4.0.0-pre.16\n3a4926a Merge pull request #138 from canjs/137-rule\nfadc0e8 for #137 adds a bunch of docs too\n25a0400 4.0.0-pre.15\nf4c324e Merge pull request #136 from canjs/sticky-route-fix\na4ba2d1 makes the route not add history with #!\n587cca5 fixes sticky routes, adds parameter to .param\n74944aa 4.0.0-pre.14\n9db2edb Merge branch 'master' into major\n3c916d1 4.0.0-pre.13\naa7ad6e Merge master to major\n747e6be 4.0.0-pre.12\n\nThere are 49 commits in total.\nSee the full diff\n\n. ## Version 4.0.1-0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.5.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n7d7fed9 Update dist for release\n73d5390 Merge pull request #82 from canjs/difference-with-id\nf609603 Fix some inaccuracies in the can-set algebra docs\nd2c8e33 Fix linting errors\nf584384 Fix ID and sort issues with can-set\n\nSee the full diff\n\n. ## Version 1.5.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nRemove duplicate items in Algebra.prototype.getUnion()\nGiven an algebra:\nset.props.id(\"id\")\nand these two sets:\n{ type: 'a' }\n{ area: 'x' }\nAnd these two lists related to the respective sets:\n[{ id: 1, type: 'a' area: 'x' }, { id: 2, type: 'a', area: 'y' }]\n[{ id: 1, type: 'a' area: 'x' }, { id: 3, type: 'b', area: 'x' }]\nPreviously, the result of getUnion() would return a simple concatenation of these two lists:\n[{ id: 1, type: 'a' area: 'x' }, { id: 2, type: 'a', area: 'y' }, { id: 1, type: 'a' area: 'x' }, { id: 3, type: 'b', area: 'x' }]\nThis is suboptimal in cases like in can-connect's cache-requests behavior, where the union of several sets may be used to build a query response for yet a different set.  Each item should be represented at most once when creating the union.  With this release, items in both aItems and bItems are removed from the bItems before concatenating into a union result.  The example above becomes:\n[{ id: 1, type: 'a' area: 'x' }, { id: 2, type: 'a', area: 'y' }, { id: 3, type: 'b', area: 'x' }]\n\nNote: this doesn't remove all duplicates, just removes duplicates from bItems that are already in aItems -- if aItems already has a duplicate, or bItems has a duplicate not in aItems, it will be preserved.\n\n\n\nCommits\nThe new version differs by 7 commits.\n\n933863a Update dist for release\n768e76b Merge pull request #84 from canjs/83-getunion-unique\n718ed13 Remove dependency on CIDSet; use native Set or indexOf based on availability\n3d9c64f Use can-assign instead of assign from can-util; use CIDSet instead of Array.indexOf\n61a31bd Use can-assign instead of can-util/js/assign/\n74fa7e5 placate jshint\n1522184 fix getUnion returning duplicate items from both sets (#83)\n\nSee the full diff\n\n. ## Version 1.1.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n27153dc Update dist for release\n0dbcdff Merge pull request #68 from canjs/bug\n8b5f4ac formatErrors should handle undefined arguments\n\nSee the full diff\n\n. ## Version 2.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv2.0.1\nFix the tests to run in the main CanJS test suite #16\n\n\nCommits\nThe new version differs by 4 commits.\n\n0a3c892 2.0.1\n3c13e1f Add a postversion script to push git tags\n45cde71 Merge pull request #16 from canjs/fix-tests\n88e88e3 Fix the tests to run in the main CanJS test suite\n\nSee the full diff\n\n. ## Version 3.11.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits.\n\n0021254 Update dist for release\n\nSee the full diff\n\n. ## Version 1.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 44 commits ahead by 44, behind by 1.\n\nc09c754 1.0.0\n19a381a Merge pull request #26 from canjs/major\ne1e7a6e Merge branch 'master' into major\n077b703 pointing at the right versions\neb1357d 1.0.0-pre.17\nf4e200d Merge pull request #19 from canjs/good-test\n3e50ff8 Fix QUnit.ok usages\nc728562 1.0.0-pre.16\na484584 Use can-event-queue/map/map instead of can-event-queue/map/legacy/legacy\nc766eb1 1.0.0-pre.15\n0558121 use OR directly\nca84fd1 1.0.0-pre.14\n8bd8c5c removing incorrect warning for @\n7a27d14 1.0.0-pre.13\n855bdd3 giving warnings for @, callMethodsOnObservables, and removing automatic function calling\n\nThere are 44 commits in total.\nSee the full diff\n\n. ## Version 2.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 110 commits.\n\n868b4b1 2.0.0\n12590cf Merge pull request #275 from canjs/major\n6e7310c merging with master\n7b0c988 updating for release\n46f0e32 2.0.0-pre.34\n172496e removing test for _cid\n3e45e41 removing CID and naming get and set functions\n91b3dec Merge branch 'major' of github.com:canjs/can-define into major\nb25f5fe pass prop\nec8837a changing references to value to default\n119586f 2.0.0-pre.33\n23086df making hasKey return booleans\nd2c4c39 2.0.0-pre.32\n49ba987 linting\n7579ff8 fixing problem with {value:'string'} being ignored\n\nThere are 110 commits in total.\nSee the full diff\n\n. ## Version 2.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n32e4e2b 2.0.1\nf114345 Merge pull request #316 from canjs/edge-issue\n889f8ac making getters name writable to fix Edge issue\n\nSee the full diff\n\n. ## Version 1.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\nd5ca26b 1.0.0\n0d91342 preparing for 1.0\n\nSee the full diff\n\n. ## Version 4.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 8 commits.\n\n50a8dbf 4.0.0\n908f432 Merge pull request #88 from canjs/major\n55be118 merging with master\n3280918 prepping for 4.0.0\n8f3ba34 changing version script to point to major\n1981683 Update dist for release\n98de659 Merge pull request #83 from canjs/remove-magic\n9c0e84d removing magicMatch / magicStart options\n\nSee the full diff\n\n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits.\n\ne1c9f8c 4.0.1\n\nSee the full diff\n\n. ## Version 4.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 36 commits.\n\n71ac03d 4.0.0\ndc5dcb6 Merge pull request #73 from canjs/major\n4c97606 Fix lint issues\nc28a95d Update deps and skip failing test\n6ee650a Update the dom-data-state dep\n275d522 Merge branch 'master' into major\n6c87441 4.0.0-pre.10\n74f81df Merge pull request #88 from canjs/nl\n1866a11 Fix linting\n8095684 Properly pass parentNodeList to subtemplate\n907cf50 4.0.0-pre.9\nc41f18c Merge branch 'magneto' into major\n8a5ed28 Update package.json\nba4a3f4 4.0.0-pre.8\nfefabec Merge branch 'master' into major\n\nThere are 36 commits in total.\nSee the full diff\n\n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nf356e12 4.0.1\nb3d989d Merge pull request #99 from canjs/data\ncbee782 Use can-dom-data-state 1.0.0\n\nSee the full diff\n\n. ## Version 4.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 76 commits.\n\n79b4d7d 4.0.0\nb97b817 Merge pull request #216 from canjs/major\ne04cb97 pointing most packages at latest\n5a444e3 Merge branch 'master' into major\ncb05c74 4.0.0-pre.28\n9eea30c using document.body.contains to determine whether to call vM.connectedCallback\ncecb360 4.0.0-pre.27\n5e9fe53 removing autoMount since automatic mounting is done in can-view-callbacks\necdadc0 4.0.0-pre.26\n106d918 Merge pull request #192 from canjs/default-views-models\n442dfd7 ViewModel:{} defaults to DefineMap\nfde08d3 making stache the default view engine\n9c03168 4.0.0-pre.25\ne448a31 Merge branch 'magneto' into major\n357c4d4 Improve a test by making it fail instead of run indefinitely\n\nThere are 76 commits in total.\nSee the full diff\n\n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nf2edad6 4.0.1\ncad9a12 Merge pull request #218 from canjs/dom-data-state\n60ae1f3 Move can-dom-data-state to dependencies\n\nSee the full diff\n\n. ## Version 1.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 11 commits.\n\nfaa8d5e Update dist for release\n82bfe26 Merge pull request #47 from canjs/major\nb7e7cbf not creating package-lock\n6b8945a updating to canjs@4.0 dependencies\n86396d5 Merge branch 'master' into major\n0088b2f Update dist for release\n0f6860b Change postversion script to check out the last branch\nf2eec72 Merge branch 'master' into major\n5c11235 1.0.0-pre.0\n9998e59 Merge pull request #40 from canjs/update-dependencies\n1a07bad Update dependencies\n\nSee the full diff\n\n. ## Version 4.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 8 commits.\n\n84ac5ef Update dist for release\n55c113d Merge pull request #72 from canjs/major\nba55587 Merge pull request #75 from canjs/no-tilde\n52c3833 removing the need for ~\n1bb2c64 Merge branch 'master' into major\na5c4d7f 4.0.0-pre.0\na700221 Merge pull request #67 from canjs/can4\n225cb64 Upgrade to can 4.0\n\nSee the full diff\n\n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits.\n\nd9e1b88 Update dist for release\n\nSee the full diff\n\n. ## Version 4.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 54 commits.\n\nb19fba7 4.0.0\n87402fa Merge pull request #65 from canjs/major\n548edb0 getting ready for 4.0.0\n1966131 Merge branch 'master' into major\n57a005d 4.0.0-pre.17\n378bb54 correcting the arguments passed to tagHandlers by MutationObserver / CustomElements\n21020bc 4.0.0-pre.16\na89a757 Merge pull request #80 from canjs/automount-false\na02681b Disconnect the mutationobserver when automount is disabled\n0775491 Only automount if the can-automount flag is not set to false\ne25deb1 4.0.0-pre.15\n9dd0163 When resetting the globals, pass a function\n13d2593 Merge pull request #79 from canjs/MO\n4946a1e Set back the MO/ce after its test\nff784a5 Prevent MutationObserver code from throwing in env without MO\n\nThere are 54 commits in total.\nSee the full diff\n\n. ## Version 2.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n42a2b69 2.0.1\na5db2b9 makes resolve return passed value\n5fe4d4c Merge pull request #5 from canjs/major\n\nSee the full diff\n\n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n8711529 4.0.1\nd08b781 Merge branch 'major'\n236f2ae version\na7c6e74 Merge pull request #41 from canjs/major\n\nSee the full diff\n\n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n7018762 4.0.1\nf9bb326 Merge pull request #92 from canjs/no-dom-attr\nf8ea69f not using can-util/dom/attr/attr\n\nSee the full diff\n\n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\n9fe8ff8 4.0.1\n405b06a Merge pull request #108 from canjs/no-can-util-dom\n5c8fdb4 Removing use of can-util/dom\n6e2b37b not creating package-lock\n78903f0 removing done-serve\n5d36dfc updating to canjs@4.0 final versions\n\nSee the full diff\n\n. ## Version 4.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n5d7e7b3 4.0.1\nba9f6ee Merge pull request #86 from canjs/no-can-util-dom\nac50df9 removing usage of can-util/dom\n\nSee the full diff\n\n. ## Version 2.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits ahead by 3, behind by 1.\n\nb78e598 2.0.1\nd293d5f Update version number\nd62b501 removing -pre from can-connect dependency\n\nSee the full diff\n\n. ## Version 2.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits ahead by 3, behind by 1.\n\n0464b74 2.0.2\ndc6f920 Merge pull request #144 from canjs/empty-data\n643fc92 Set request data to an empty object\n\nSee the full diff\n\n. ## Version 1.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nf2878dc 1.0.1\n25123c5 Merge pull request #14 from canjs/fix-global\n902c8e7 Only extend Kefir prototype when Kefir is bundled\n\nSee the full diff\n\n. ## Version 4.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n881b391 4.0.3\ne3f8def Merge pull request #97 from canjs/live-attr-value\n62b26d4 fixing live.attr for properties like value\n\nSee the full diff\n\n. ## Version 4.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n5b4856c 4.1.0\necc0d1f Merge pull request #464 from canjs/expose-directlyNested\nd961a7a adds directlyNested info to tagData to fix bug with can-slot\n\nSee the full diff\n\n. ## Version 4.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nbcb5b78 4.1.1\nb20c5e9 Merge pull request #468 from canjs/setattr\nf12663b Use can-dom-mutate/node to set attributes\n\nSee the full diff\n\n. ## Version 4.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n8d0d793 4.1.2\n506aa30 Cleanup markdown sample code (#465)\n\nSee the full diff\n\n. ## Version 4.1.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n{{#default()}} no longer changes the context\n#476\n\n\nCommits\nThe new version differs by 5 commits.\n\n6a5e51c 4.1.3\n9d18fc5 Merge pull request #476 from canjs/default-helper-context\n5398cd2 {{#default()}} no longer changes the context\n8034163 Merge pull request #471 from canjs/lookup-in-attributes\nbf71cf6 updating test to use Helper Expression\n\nSee the full diff\n\n. ## Version 4.1.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nFixing magic tags within attributes\nThis fixes two issues related to attributes with magic tags like\n \n#470\n#477\n\n\nCommits\nThe new version differs by 4 commits.\n\ndbe2965 4.1.4\nf9823f5 Merge pull request #478 from canjs/no-live-attr-warning\n698c345 removing warning for magic tags within attributes\ndab39bd fixing magic tags within attributes\n\nSee the full diff\n\n. ## Version 4.1.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n9445ff9 4.1.5\ndb9543e Merge pull request #480 from canjs/negative-literals\n1a7730b Negative numbers should be parsed as literals\n\nSee the full diff\n\n. ## Version 4.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nb1b092d 4.2.0\n09f3998 Merge pull request #479 from canjs/iai\n00e5317 Use can-stache-ast and deprecate intermediate_and_imports\n\nSee the full diff\n\n. ## Version 4.2.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\nc84cfab 4.2.1\n481a2d4 Merge pull request #482 from canjs/each-hash-warn\n4e5e170 Merge pull request #481 from canjs/lint\n183ad72 Cache type check and check argument position instead of type\n3670c37 Hash expressions used in each helper should not warn\n8fc7c6d Fix lint setup and existing lint issues\n\nSee the full diff\n\n. ## Version 4.2.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n5c5ea49 4.2.2\nfa69282 Merge pull request #485 from canjs/484-debugger-get\n02578e1 restore debugger get function (fixes #484)\n\nSee the full diff\n\n. ## Version 2.0.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n12ed905 2.0.4\n8b9bd4f 2.0.3\n9289fe9 Cleanup markdown sample code (#408)\n\nSee the full diff\n\n. ## Version 4.0.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n311a68b 4.0.4\nff87c5e 4.0.3\n54e0b9c Cleanup markdown sample code (#222)\n\nSee the full diff\n\n. ## Version 4.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\nf868eff 4.1.1\n4be79ab Cleanup markdown sample code (#155)\n\nSee the full diff\n\n. ## Version 2.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n65e7803 2.0.3\n286f177 Cleanup markdown sample code (#317)\n\nSee the full diff\n\n. ## Version 1.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n6c03c79 1.0.3\na282cb0 Merge pull request #17 from canjs/15-initial-uppercase\n13c67d6 adjust camelCase detection to also find leading capitals (fixes #15)\n\nSee the full diff\n\n. ## Version 1.0.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n35d98c9 1.0.4\nc41a892 do not encode non-binding attrs (fixes canjs/can-attribute-encoder#19)\n\nSee the full diff\n\n. ## Version 2.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\ne152e1b Update dist for release\nff9423d add computedPropertyDefinitions (#40)\n\nSee the full diff\n\n. ## Version 4.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\ndbe88dc 4.0.3\n08174f6 Merge pull request #90 from canjs/delegate\nf2fc4e0 Use domEvents.removeDelegateListener to remove anchor listener\n\nSee the full diff\n\n. ## Version 4.0.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\neb95fdc 4.0.4\n83d9d5d Merge pull request #92 from canjs/current-rule\nee617ae Call ObservationRecorder.add when observable is read\n\nSee the full diff\n\n. ## Version 3.11.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.11.4\nFix setting undefined as the value for a textarea #416\n\n\nCommits\nThe new version differs by 3 commits.\n\n22dda20 Update dist for release\ne69f7f1 Merge pull request #416 from canjs/undefined-textarea\n09a32c1 Fix setting undefined as the value for a textarea\n\nSee the full diff\n\n. ## Version 3.11.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n074bacd 3.11.5\nd32a792 Merge pull request #417 from canjs/xitstrategies\n8fa88c3 Add condition and test for null object in get\n\nSee the full diff\n\n. ## Version 1.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n18c5f7b 1.1.0\nbe32c00 Merge pull request #56 from stealjs/metadata\n0f572d2 Update travis versions\n4116a08 Add conditionDependencies metadata to load objects\n\nSee the full diff\n\n. ## Version 1.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n678d1c3 1.1.1\n20496c1 Revert \"Add conditionDependencies metadata to load objects\"\n\nSee the full diff\n\n. ## Version 1.1.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n1.1.3\nSupport Edge 14\nEdge 14 has no support for Element.prototype.matches but it implements the same functionality as Element.prototype.msMatchesSelector.\n\n\nCommits\nThe new version differs by 3 commits.\n\n7f25ffe 1.1.3\nb75d558 Merge pull request #45 from canjs/edge-14\n174746d Support Edge 14\n\nSee the full diff\n\n. ## Version 4.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 2.0.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n0d0e2e7 2.0.4\n14b0d93 naming resolver functions\n\nSee the full diff\n\n. ## Version 4.2.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nFixes context passed to {{#default}} helper\n#496\n\n\nCommits\nThe new version differs by 3 commits.\n\neaa3dbe 4.2.4\n7c12fc6 Merge pull request #496 from canjs/default-context\n90f95bf fixing context passed to {{#default}}\n\nSee the full diff\n\n. ## Version 4.2.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nFixing calling debugger as a Lookup Expression\nThis works again: {{debugger}}.\n#497\n\n\nCommits\nThe new version differs by 3 commits.\n\nf47cdfa 4.2.5\nb088524 Merge pull request #497 from canjs/debugger-helper-expression\nd0a9b2e Fixing calling debugger as a Lookup Expression\n\nSee the full diff\n\n. ## Version 4.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.3.0\nAdded the {{domData}} helper to replace {{data}} #500\nThe {{data}} helper is now deprecated in favor of {{domData}}, which uses can-dom-data to set data in a memory-safe way with WeakMaps.\nFor more info, check out the docs.\n\n\nCommits\nThe new version differs by 3 commits.\n\n57fab72 4.3.0\n33c9ebb Merge pull request #500 from canjs/domData-helper\n832f121 Deprecate the {{data}} helper in favor of {{domData}}\n\nSee the full diff\n\n. ## Version 1.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.2.0\n\nAdds helper for listening to jQuery events #48\nImproves docs #47\n\n\n\nCommits\nThe new version differs by 6 commits.\n\na461bef 1.2.0\n58160ee Add helpers group to the docs\n4adc772 Merge pull request #48 from canjs/add-jquery-events\n0c4efdb Merge pull request #47 from canjs/docs\n79e08f0 Add helper for listening to jQuery events\ne6d8322 improved docs #46\n\nSee the full diff\n\n. ## Version 4.0.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\npassing a filename to stache() for inline views\nFilenames are now passed to stache() when using inline views like:\nvar MyComponent = Component.extend({\n  tag: \"my-filename-component\",\n  ViewModel: {},\n  view: \"<div></p>\"\n});\nThis way, useful error messages are given. For example, the view above gives:\nMyFilenameComponentView:1: unexpected closing tag </p> expected </div>\n\n#229\n\n\nCommits\nThe new version differs by 3 commits.\n\n5372ac4 4.0.6\n568347d Merge pull request #229 from canjs/inline-view-name\ne3a595c passing a filename to stache() for inline views\n\nSee the full diff\n\n. ## Version 4.0.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nskipping stache filename test in production\n#231\n\n\nCommits\nThe new version differs by 3 commits.\n\n17f09ff 4.0.7\n7afcf97 Merge pull request #231 from canjs/dev-only-test\nd60d1d3 skipping stache filename test in production\n\nSee the full diff\n\n. ## Version 4.0.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nMake the name for .read consistent with the name for .dispatch\n#155\n\n\nCommits\nThe new version differs by 3 commits.\n\n9064688 4.0.4\n050c3ef Merge pull request #155 from canjs/names\n9e9d8c0 cleaning up ScopeKeyData.read's name\n\nSee the full diff\n\n. ## Version 4.0.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n7ea7f46 4.0.5\n630350b name computes\n\nSee the full diff\n\n. ## Version 4.0.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\nc56760f 4.0.6\ndf391c9 Merge pull request #157 from canjs/slow-path-graph\n965f40e fixing dependency graph for nested properties\na6cb995 always showing \"slow-path\" dependency graph instead of adjusting for \"fast-path\"\n\nSee the full diff\n\n. ## Version 4.0.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n5cac7f8 4.0.5\nd10a043 Merge pull request #100 from canjs/update-attribute-observable\naaadeca updating to latest can-attribute-observable\n\nSee the full diff\n\n. ## Version 4.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.1.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 0.2.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.14.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n9ab25b4 Update dist for release\nca8f87f correct link\nc750536 actually adding identity reflections\n\nSee the full diff\n\n. ## Version 1.14.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n2458a6e Update dist for release\n1edefba get the context right\n\nSee the full diff\n\n. ## Version 1.14.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n1d0bce4 Update dist for release\n3273eb3 making arrays clonable\n\nSee the full diff\n\n. ## Version 1.14.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\nd07936f Update dist for release\n0f29518 handle no symbol prop\n\nSee the full diff\n\n. ## Version 1.15.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n.size() works with strings\nd3469d0\n\n\nCommits\nThe new version differs by 2 commits.\n\n0eadc90 Update dist for release\nd3469d0 testing shape, making it work with strings\n\nSee the full diff\n\n. ## Version 1.15.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\nccf9180 Update dist for release\n84eda48 adding convert, but not documenting, so don't use it\n\nSee the full diff\n\n. ## Version 2.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nUpdated deprecation warning for DefineMap.prototype.set\n#328\n\n\nCommits\nThe new version differs by 3 commits.\n\n632fef7 2.1.2\nb687090 Merge pull request #328 from canjs/set-deprecation-update\nc0f32a1 Updating deprecation warning for .set to be more clear\n\nSee the full diff\n\n. ## Version 2.2.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits.\n\nc47d305 2.2.2\n6174a35 making sure serialize works\n750499b 2.2.1\ncbc8d46 better check for define type\n14aefd2 2.2.0\nb317ac1 Merge pull request #329 from canjs/maybe-types\n109cfc6 schema doesn't have enumerable\nf7745b7 linting\n3199df1 maybe types works\n\nSee the full diff\n\n. ## Version 2.2.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nfixes incorrect warning message\nd8738dd for #331\n\n\nCommits\nThe new version differs by 4 commits.\n\n57aa55f 2.2.4\nd8738dd removing the incorrect error message for #331\ne2de5ae 2.2.3\naad3115 converting all maybe types to functions for #330\n\nSee the full diff\n\n. ## Version 2.2.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nidentity\nAdds the identity property definition:\nimport {DefineMap, Reflect} from \"can\";\n\nconst Todo = DefineMap.extend(\"Todo\",{\n    id: {type: \"number\", identity: true},\n    name: \"string\",\n    complete: \"boolean\"\n});\n\nvar todo = new Todo({id: 6, name: \"mow lawn\"});\n\nReflect.getIdentity(todo) //-> 6\n\n\nCommits\nThe new version differs by 2 commits.\n\n29d6a6e 2.2.5\ne593164 documenting identity\n\nSee the full diff\n\n. ## Version 2.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nBye can-util, hello can-data-types\nThis removes can-util by using can-diff and some other packages.  It also uses can-data-type's MaybeString, MaybeNumber, etc types.\n\n\nCommits\nThe new version differs by 3 commits.\n\nf616a1b 2.3.0\nbdcd735 Merge pull request #335 from canjs/no-can-util\n805aaf2 removing can-util and using can-data-types\n\nSee the full diff\n\n. ## Version 2.3.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\ncde2472 2.3.1\na5090b0 making sure to use a version of can-reflect that supports what can-define needs for #336\n\nSee the full diff\n\n. ## Version 1.16.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n94cad22 Update dist for release\n0558efc docs for can-convert\n\nSee the full diff\n\n. ## Version 1.16.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n339f556 Update dist for release\n7215075 fixing docs\n\nSee the full diff\n\n. ## Version 4.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n1850cda 4.0.2\nf8715e6 properly dispatches patches\n\nSee the full diff\n\n. ## Version 0.6.20 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n0.6.20\nThis is a bug fix release, making it possible to run can-zone inside of a web worker.\n\n\nCommits\nThe new version differs by 8 commits.\n\n6fbb8cf 0.6.20\n2a57676 Merge pull request #169 from canjs/fix-worker-error\n8d784fe Run tests in a web worker\n6e76169 Remove extraneous semicolon\n7c7786a Tab indentation redux\n60c8f7d Tab indentation\n9c3d80a Refactor fixes based on review\n0507a64 Allow can-zone to run in Worker contexts\n\nSee the full diff\n\n. ## Version 1.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits ahead by 3, behind by 1.\n\n59518fd 1.1.1\n9dfed31 Update version number\neb2c091 adding dev dep\n\nSee the full diff\n\n. ## Version 1.0.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.3.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nFixes problem with functions not being treated truthfully\nFixes #510\n\n\nCommits\nThe new version differs by 4 commits.\n\n1444720 4.3.3\nace957c Merge pull request #511 from canjs/510-function-expr\n4c44090 fixes #510\n9f62a8a adds a test for #510\n\nSee the full diff\n\n. ## Version 4.3.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nAdded filename and lineNumber to \"Unable to find\" warnings\n#513\n\n\nCommits\nThe new version differs by 3 commits.\n\ne0a7d6e 4.3.4\nc72e9a0 Merge pull request #513 from canjs/filename-warning\n780f240 adding filename and lineNumber to \"Unable to find\" warnings\n\nSee the full diff\n\n. ## Version 4.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n62aaf5f 4.4.0\n3d4c3d0 Merge pull request #518 from canjs/lookup-warnings\nb1f34cf documenting scope.vm and scope.top\nbd543e1 using can-view-scope.hasKey for \"Unable to find key\" warnings\n40588dc adding suggestions to \"Unable to find key\" warnings\n\nSee the full diff\n\n. ## Version 4.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n099abc7 Update dist for release\n75c4c1e Merge pull request #66 from canjs/has-key-for-functions\nb27747a making hasKey work for functions\n\nSee the full diff\n\n. ## Version 1.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nccd5117 1.1.1\nb4dc2b1 Call addParent so that an observable can know about its parent\n2615df7 Adds ObservationRecorder.create\n\nSee the full diff\n\n. ## Version 4.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nd63ce45 4.1.1\n16d8a3b Merge pull request #162 from canjs/get-paths-booleans\n9a70b5c preventing in operator errors if scope._context is not an object\n\nSee the full diff\n\n. ## Version 4.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n13ee346 4.2.0\n3e1c9b5 Merge pull request #163 from canjs/has-key\n452e89c implementing can.hasKey Symbol on Scope.prototpye\n\nSee the full diff\n\n. ## Version 4.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.2.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.2.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.2.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.2.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.2.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.2.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 18 commits.\n\nb04a732 4.1.0\n4782999 Merge pull request #104 from canjs/landscaper/4217-use-strict\nf80ba05 Merge pull request #100 from canjs/greenkeeper/testee-0.8.0\nc5e7a47 Merge pull request #103 from canjs/fix-webpack-debug-style\n18fd6d0 Adds use strict. Fixes canjs/canjs#4217\ne688e9f fix can-symbol use after review\n5781982 fix dev code for webpack compatibility\n3b1f75b chore(package): update testee to version 0.8.0\nff72311 Merge pull request #99 from canjs/merge-3.x-legacy\nccd6281 Merge branch '3.x-legacy' into master\n566c18a Update dist for release\n2112a6c Revert \"3.2.3\"\ne05c4d8 Merge pull request #98 from canjs/chasenlehara-patch-1\n1d0e664 Use postpublish script in package.json\n439ab45 Update package.json for 3.x-legacy\n\nThere are 18 commits in total.\nSee the full diff\n\n. ## Version 4.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 18 commits.\n\nb04a732 4.1.0\n4782999 Merge pull request #104 from canjs/landscaper/4217-use-strict\nf80ba05 Merge pull request #100 from canjs/greenkeeper/testee-0.8.0\nc5e7a47 Merge pull request #103 from canjs/fix-webpack-debug-style\n18fd6d0 Adds use strict. Fixes canjs/canjs#4217\ne688e9f fix can-symbol use after review\n5781982 fix dev code for webpack compatibility\n3b1f75b chore(package): update testee to version 0.8.0\nff72311 Merge pull request #99 from canjs/merge-3.x-legacy\nccd6281 Merge branch '3.x-legacy' into master\n566c18a Update dist for release\n2112a6c Revert \"3.2.3\"\ne05c4d8 Merge pull request #98 from canjs/chasenlehara-patch-1\n1d0e664 Use postpublish script in package.json\n439ab45 Update package.json for 3.x-legacy\n\nThere are 18 commits in total.\nSee the full diff\n\n. ## Version 4.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n07b9ca5 4.1.1\nfff6e1c fixing docs\n\nSee the full diff\n\n. ## Version 4.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n07b9ca5 4.1.1\nfff6e1c fixing docs\n\nSee the full diff\n\n. ## Version 5.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n5.0.0\nThis is a major, breaking change for can-route-pushstate. This creates a new API to use can-route-pushstate, by exporting a constructor function that can be set on the can-route.\nimport route from \"can-route\";\nimport RoutePushstate from \"can-route-pushstate\";\n\nroute.urlData = new RoutePushstate();\nroute.register(\"{page}\");\n\n\nCommits\nThe new version differs by 11 commits.\n\n6f8192f 5.0.0\nda578de Merge pull request #108 from canjs/major\nfe97225 Merge branch 'master' into major\n3c296d9 Merge pull request #107 from canjs/docs-codeblock\n3af4388 Move the documented API usage into @type\nd8f311b 5.0.0-pre.0\n1d11d9b Merge pull request #106 from canjs/new-api\n36a9b89 Conform to the new API\n6e95b16 Document the new API\n861dec2 All tests are passing\ne20e30b Current status\n\nSee the full diff\n\n. ## Version 5.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n5.0.0\nThis is a major, breaking change for can-route-pushstate. This creates a new API to use can-route-pushstate, by exporting a constructor function that can be set on the can-route.\nimport route from \"can-route\";\nimport RoutePushstate from \"can-route-pushstate\";\n\nroute.urlData = new RoutePushstate();\nroute.register(\"{page}\");\n\n\nCommits\nThe new version differs by 11 commits.\n\n6f8192f 5.0.0\nda578de Merge pull request #108 from canjs/major\nfe97225 Merge branch 'master' into major\n3c296d9 Merge pull request #107 from canjs/docs-codeblock\n3af4388 Move the documented API usage into @type\nd8f311b 5.0.0-pre.0\n1d11d9b Merge pull request #106 from canjs/new-api\n36a9b89 Conform to the new API\n6e95b16 Document the new API\n861dec2 All tests are passing\ne20e30b Current status\n\nSee the full diff\n\n. ## Version 4.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\ne1e25ff 4.1.1\n2d22daf accepting non breaking changes of deps\n\nSee the full diff\n\n. ## Version 4.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\ne1e25ff 4.1.1\n2d22daf accepting non breaking changes of deps\n\nSee the full diff\n\n. ## Version 4.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n53711d2 4.1.2\nf3206e3 publish test folder\n\nSee the full diff\n\n. ## Version 4.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n53711d2 4.1.2\nf3206e3 publish test folder\n\nSee the full diff\n\n. ## Version 0.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 0.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.4.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\na96ef0c Update dist for release\nadc7f2d removing can-util in deps\n\nSee the full diff\n\n. ## Version 3.4.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\na96ef0c Update dist for release\nadc7f2d removing can-util in deps\n\nSee the full diff\n\n. ## Version 3.4.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits.\n\n7fd3b9f Update dist for release\n\nSee the full diff\n\n. ## Version 3.4.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits.\n\n7fd3b9f Update dist for release\n\nSee the full diff\n\n. ## Version 4.3.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\naef1a03 4.3.1\n40e70b3 using set instead of CIDSet\n\nSee the full diff\n\n. ## Version 4.3.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\naef1a03 4.3.1\n40e70b3 using set instead of CIDSet\n\nSee the full diff\n\n. ## Version 1.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nfix merge conflict\nI fixed some unmerged previous commits.\n\n\nCommits\nThe new version differs by 4 commits.\n\nd8363ba 1.1.1\nbc7190c merged\nb6fdf0f 1.0.1\ncdd090d Cleanup markdown sample code (#40)\n\nSee the full diff\n\n. ## Version 1.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nfix merge conflict\nI fixed some unmerged previous commits.\n\n\nCommits\nThe new version differs by 4 commits.\n\nd8363ba 1.1.1\nbc7190c merged\nb6fdf0f 1.0.1\ncdd090d Cleanup markdown sample code (#40)\n\nSee the full diff\n\n. ## Version 4.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits.\n\n00d412f 4.1.1\n\nSee the full diff\n\n. ## Version 4.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits.\n\n00d412f 4.1.1\n\nSee the full diff\n\n. ## Version 3.4.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n0bcff00 Update dist for release\n987c4d3 Merge pull request #56 from canjs/chasenlehara-patch-1\n03e1ab7 Fix can-string dependency to <2.0.0\n\nSee the full diff\n\n. ## Version 3.4.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n0bcff00 Update dist for release\n987c4d3 Merge pull request #56 from canjs/chasenlehara-patch-1\n03e1ab7 Fix can-string dependency to <2.0.0\n\nSee the full diff\n\n. ## Version 3.5.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits.\n\nb13392f Update dist for release\nb028254 Merge pull request #58 from canjs/landscaper/4217-use-strict\ne976267 Merge pull request #55 from canjs/greenkeeper/testee-0.8.0\nfd694ac Adds use strict. Fixes canjs/canjs#4217\n5b6e903 Merge pull request #57 from canjs/fix-webpack-debug-style\n32388f7 fix dev code for webpack compatibility\nac74152 chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 3.5.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits.\n\nb13392f Update dist for release\nb028254 Merge pull request #58 from canjs/landscaper/4217-use-strict\ne976267 Merge pull request #55 from canjs/greenkeeper/testee-0.8.0\nfd694ac Adds use strict. Fixes canjs/canjs#4217\n5b6e903 Merge pull request #57 from canjs/fix-webpack-debug-style\n32388f7 fix dev code for webpack compatibility\nac74152 chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 4.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 18 commits.\n\ne792b1b 4.2.0\n0d68de1 fixing package.json\nd659a33 removes can-util, closes #175\na6f6352 Merge pull request #177 from canjs/minor\ne9e6abd improved docs\n527e3bd 4.2.0-pre.1\nc476d27 some basic docs\n05dad2f some docs\n39ae463 supports .dataUrl\nb5faeb4 Merge pull request #171 from canjs/greenkeeper/testee-0.8.0\n0f5e757 Merge pull request #166 from canjs/162-can-bind\n7b4f007 Use can-bind internally\ne7b12a7 Merge pull request #173 from canjs/fix-webpack-debug-style\n70d7fcd fix arguements for queues between dev and production\nf1b6f06 change indent_size in .editorconfig\n\nThere are 18 commits in total.\nSee the full diff\n\n. ## Version 4.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 18 commits.\n\ne792b1b 4.2.0\n0d68de1 fixing package.json\nd659a33 removes can-util, closes #175\na6f6352 Merge pull request #177 from canjs/minor\ne9e6abd improved docs\n527e3bd 4.2.0-pre.1\nc476d27 some basic docs\n05dad2f some docs\n39ae463 supports .dataUrl\nb5faeb4 Merge pull request #171 from canjs/greenkeeper/testee-0.8.0\n0f5e757 Merge pull request #166 from canjs/162-can-bind\n7b4f007 Use can-bind internally\ne7b12a7 Merge pull request #173 from canjs/fix-webpack-debug-style\n70d7fcd fix arguements for queues between dev and production\nf1b6f06 change indent_size in .editorconfig\n\nThere are 18 commits in total.\nSee the full diff\n\n. ## Version 4.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.3.0\nAdd \"use strict\" #174\n\n\nCommits\nThe new version differs by 6 commits.\n\n3a09239 4.3.0\n4f8260b Merge pull request #174 from canjs/landscaper/4217-use-strict\n11e9413 Merge branch 'master' into landscaper/4217-use-strict\nbbba59a Merge pull request #156 from canjs/greenkeeper/done-serve-2.0.0\na336f25 Adds use strict. Fixes canjs/canjs#4217\n5489931 chore(package): update done-serve to version 2.0.0\n\nSee the full diff\n\n. ## Version 4.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.3.0\nAdd \"use strict\" #174\n\n\nCommits\nThe new version differs by 6 commits.\n\n3a09239 4.3.0\n4f8260b Merge pull request #174 from canjs/landscaper/4217-use-strict\n11e9413 Merge branch 'master' into landscaper/4217-use-strict\nbbba59a Merge pull request #156 from canjs/greenkeeper/done-serve-2.0.0\na336f25 Adds use strict. Fixes canjs/canjs#4217\n5489931 chore(package): update done-serve to version 2.0.0\n\nSee the full diff\n\n. ## Version 4.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.1.0\n\nAdd compatibility with how webpack builds for production #101\nAdd \"use strict\" #100\n\n\n\nCommits\nThe new version differs by 12 commits.\n\n9c254c3 4.1.0\nb1a0524 Merge pull request #100 from canjs/landscaper/4217-use-strict\n683a3e9 Merge pull request #102 from canjs/can-util-removal\nc364b7e add deps to package.json\nf29a064 Merge pull request #98 from canjs/greenkeeper/testee-0.8.0\n87de322 remove can-util from package.json\n9e6adc9 fix can-reflect use\n14fec0d get rid of can-util\n86d34a0 Merge pull request #101 from canjs/fix-webpack-debug-style\nf441961 fix dev code for webpack compatibility\n3de0d54 Adds use strict. Fixes canjs/canjs#4217\n2303ec8 chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 4.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.1.0\n\nAdd compatibility with how webpack builds for production #101\nAdd \"use strict\" #100\n\n\n\nCommits\nThe new version differs by 12 commits.\n\n9c254c3 4.1.0\nb1a0524 Merge pull request #100 from canjs/landscaper/4217-use-strict\n683a3e9 Merge pull request #102 from canjs/can-util-removal\nc364b7e add deps to package.json\nf29a064 Merge pull request #98 from canjs/greenkeeper/testee-0.8.0\n87de322 remove can-util from package.json\n9e6adc9 fix can-reflect use\n14fec0d get rid of can-util\n86d34a0 Merge pull request #101 from canjs/fix-webpack-debug-style\nf441961 fix dev code for webpack compatibility\n3de0d54 Adds use strict. Fixes canjs/canjs#4217\n2303ec8 chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 4.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nc1dca96 4.1.1\nf9152e7 Merge pull request #104 from canjs/can-util\n27b6ae4 Remove remaining uses of can-util\n\nSee the full diff\n\n. ## Version 4.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nc1dca96 4.1.1\nf9152e7 Merge pull request #104 from canjs/can-util\n27b6ae4 Remove remaining uses of can-util\n\nSee the full diff\n\n. ## Version 2.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\n5d4fcab Update dist for release\n5693ff2 Merge pull request #56 from canjs/symbols-descriptors\ncfb406c Ensure that all symbols have a corresponding descriptor\n7556c08 Breaking test for getOwnPropertyDescriptor\n746f809 Merge pull request #55 from canjs/get-val\nbf2a4a3 Pass makeObserve into observed constructors\n\nSee the full diff\n\n. ## Version 2.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\n5d4fcab Update dist for release\n5693ff2 Merge pull request #56 from canjs/symbols-descriptors\ncfb406c Ensure that all symbols have a corresponding descriptor\n7556c08 Breaking test for getOwnPropertyDescriptor\n746f809 Merge pull request #55 from canjs/get-val\nbf2a4a3 Pass makeObserve into observed constructors\n\nSee the full diff\n\n. ## Version 2.1.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n1bdae97 Update dist for release\n40e959b Update dist for release\ne62720b Merge pull request #59 from canjs/decorator-name\na557f13 Use defineProperty to set the decorator wrapper's name\n\nSee the full diff\n\n. ## Version 2.1.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n1bdae97 Update dist for release\n40e959b Update dist for release\ne62720b Merge pull request #59 from canjs/decorator-name\na557f13 Use defineProperty to set the decorator wrapper's name\n\nSee the full diff\n\n. ## Version 2.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits.\n\n5cbc6e8 Update dist for release\n642fac6 Merge pull request #47 from canjs/greenkeeper/can-reflect-tests-0.2.1\n67934f6 Update package.json\n1e0e311 resolve security vulnerabilities (fixes #64) (#65)\nf365a01 Merge pull request #61 from canjs/landscaper/4217-use-strict\n270472b Adds use strict. Fixes canjs/canjs#4217\n7f3bcc2 Merge pull request #60 from canjs/fix-webpack-debug-style\n0368dc3 fix dev code for webpack compatibility\n4bd9174 chore(package): update can-reflect-tests to version 0.2.1\n\nSee the full diff\n\n. ## Version 2.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits.\n\n5cbc6e8 Update dist for release\n642fac6 Merge pull request #47 from canjs/greenkeeper/can-reflect-tests-0.2.1\n67934f6 Update package.json\n1e0e311 resolve security vulnerabilities (fixes #64) (#65)\nf365a01 Merge pull request #61 from canjs/landscaper/4217-use-strict\n270472b Adds use strict. Fixes canjs/canjs#4217\n7f3bcc2 Merge pull request #60 from canjs/fix-webpack-debug-style\n0368dc3 fix dev code for webpack compatibility\n4bd9174 chore(package): update can-reflect-tests to version 0.2.1\n\nSee the full diff\n\n. ## Version 1.16.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits.\n\n8bdfbe1 Update dist for release\n2f69d04 Merge pull request #117 from canjs/116-haskey-primitives\naa89ed5 fixes IE9 and 10\n5d463c2 fixes IE11's lack of Object.getPrototypeOf working on primitives\n4754791 Fixes issue with hasKey not working on primitives\n56ae882 fixing undefined check\n221c5f4 Merge pull request #114 from Aosanders/master\n9ebeadf added undefined and null support fixes #105\nca389b5 splice fix training fixes #112\n\nSee the full diff\n\n. ## Version 1.16.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 9 commits.\n\n8bdfbe1 Update dist for release\n2f69d04 Merge pull request #117 from canjs/116-haskey-primitives\naa89ed5 fixes IE9 and 10\n5d463c2 fixes IE11's lack of Object.getPrototypeOf working on primitives\n4754791 Fixes issue with hasKey not working on primitives\n56ae882 fixing undefined check\n221c5f4 Merge pull request #114 from Aosanders/master\n9ebeadf added undefined and null support fixes #105\nca389b5 splice fix training fixes #112\n\nSee the full diff\n\n. ## Version 1.16.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nSerialize objects to primitives works\nCloses #63\n\n\nCommits\nThe new version differs by 6 commits.\n\n822679d Update dist for release\n979a61d Merge pull request #119 from canjs/63-primitive-serialize\n4e9b950 adding some IE labels\ndbd9889 should work in IE9\n9211dfc fixing for FF\n781f628 fixes #63, handles primitive return types\n\nSee the full diff\n\n. ## Version 1.16.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nSerialize objects to primitives works\nCloses #63\n\n\nCommits\nThe new version differs by 6 commits.\n\n822679d Update dist for release\n979a61d Merge pull request #119 from canjs/63-primitive-serialize\n4e9b950 adding some IE labels\ndbd9889 should work in IE9\n9211dfc fixing for FF\n781f628 fixes #63, handles primitive return types\n\nSee the full diff\n\n. ## Version 1.16.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nb192c45 Update dist for release\nbed13c0 Merge pull request #120 from canjs/bah-globals\n3ffa310 Reset global state when throwing b/c of circular refs\n\nSee the full diff\n\n. ## Version 1.16.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nb192c45 Update dist for release\nbed13c0 Merge pull request #120 from canjs/bah-globals\n3ffa310 Reset global state when throwing b/c of circular refs\n\nSee the full diff\n\n. ## Version 1.16.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nProperly fast-path size for arrays and strings\n#121\n\n\nCommits\nThe new version differs by 2 commits.\n\nce3a8a0 Update dist for release\nac267ba improving .size() performance\n\nSee the full diff\n\n. ## Version 1.16.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nProperly fast-path size for arrays and strings\n#121\n\n\nCommits\nThe new version differs by 2 commits.\n\nce3a8a0 Update dist for release\nac267ba improving .size() performance\n\nSee the full diff\n\n. ## Version 1.17.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.17.0\n\nMake getSchema return undefined when passed undefined #126\nAdd compatibility with how webpack builds for production #122\nAdd \"use strict\" #124\n\n\n\nCommits\nThe new version differs by 13 commits.\n\n9c2b895 Update dist for release\nf1b05c5 Merge pull request #124 from canjs/landscaper/4217-use-strict\n3b53fcd Adds use strict. Fixes canjs/canjs#4217\na80f264 Merge pull request #129 from canjs/saucelabs-host\n141fcbf changing host for test-saucelabs script\n4a55c71 Merge pull request #126 from canjs/undefined-schema\nddc86de Make getSchema return undefined when passed undefined\nb91b7cc Merge pull request #115 from canjs/greenkeeper/testee-0.8.0\n8e7544c Merge pull request #94 from canjs/greenkeeper/http-server-0.11.0\nce0aeae Merge pull request #122 from canjs/fix-webpack-debug-style\nd307fa9 fix debug/dev code for webpack\n62300a1 chore(package): update testee to version 0.8.0\n8735a01 chore(package): update http-server to version 0.11.0\n\nSee the full diff\n\n. ## Version 1.17.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.17.0\n\nMake getSchema return undefined when passed undefined #126\nAdd compatibility with how webpack builds for production #122\nAdd \"use strict\" #124\n\n\n\nCommits\nThe new version differs by 13 commits.\n\n9c2b895 Update dist for release\nf1b05c5 Merge pull request #124 from canjs/landscaper/4217-use-strict\n3b53fcd Adds use strict. Fixes canjs/canjs#4217\na80f264 Merge pull request #129 from canjs/saucelabs-host\n141fcbf changing host for test-saucelabs script\n4a55c71 Merge pull request #126 from canjs/undefined-schema\nddc86de Make getSchema return undefined when passed undefined\nb91b7cc Merge pull request #115 from canjs/greenkeeper/testee-0.8.0\n8e7544c Merge pull request #94 from canjs/greenkeeper/http-server-0.11.0\nce0aeae Merge pull request #122 from canjs/fix-webpack-debug-style\nd307fa9 fix debug/dev code for webpack\n62300a1 chore(package): update testee to version 0.8.0\n8735a01 chore(package): update http-server to version 0.11.0\n\nSee the full diff\n\n. ## Version 4.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.2.0\nAdd \"use strict\" #116\n\n\nCommits\nThe new version differs by 6 commits ahead by 6, behind by 1.\n\n421fc71 4.2.0\nb213d34 Update dist for release\nb5f92e1 Merge pull request #116 from canjs/landscaper/4217-use-strict\nd560474 Merge pull request #115 from canjs/greenkeeper/testee-0.8.0\n16ba3db Adds use strict. Fixes canjs/canjs#4217\n044be2a chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 4.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.2.0\nAdd \"use strict\" #116\n\n\nCommits\nThe new version differs by 6 commits ahead by 6, behind by 1.\n\n421fc71 4.2.0\nb213d34 Update dist for release\nb5f92e1 Merge pull request #116 from canjs/landscaper/4217-use-strict\nd560474 Merge pull request #115 from canjs/greenkeeper/testee-0.8.0\n16ba3db Adds use strict. Fixes canjs/canjs#4217\n044be2a chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 5.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n5.0.0\nThis is a major release, for compatibility with can-connect 3.0.\n\n\nCommits\nThe new version differs by 10 commits ahead by 10, behind by 1.\n\n07fc416 5.0.0\n725813d Merge pull request #120 from canjs/major\n0f943a8 Merge branch 'master' into major\ne4600d2 5.0.0-pre.3\ne82709c removing warnings about calling .add\ne78e898 5.0.0-pre.2\nc3ea0df adding test files\n3d65772 removing build from publishing\n03df7fe Update dist for release\na0ac7ca making a prerelease\n\nSee the full diff\n\n. ## Version 5.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n5.0.0\nThis is a major release, for compatibility with can-connect 3.0.\n\n\nCommits\nThe new version differs by 10 commits ahead by 10, behind by 1.\n\n07fc416 5.0.0\n725813d Merge pull request #120 from canjs/major\n0f943a8 Merge branch 'master' into major\ne4600d2 5.0.0-pre.3\ne82709c removing warnings about calling .add\ne78e898 5.0.0-pre.2\nc3ea0df adding test files\n3d65772 removing build from publishing\n03df7fe Update dist for release\na0ac7ca making a prerelease\n\nSee the full diff\n\n. ## Version 2.3.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits.\n\n2e1b747 2.3.3\n3f0bd81 Merge branch 'master' of github.com:canjs/can-define\n874e1c3 2.3.2\n0eb9e59 removing lingering debugger\n2b745b5 linting\n2f6ecad verify resolve does not leak reads\n0cce134 some minor cleanup\n\nSee the full diff\n\n. ## Version 2.3.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits.\n\n2e1b747 2.3.3\n3f0bd81 Merge branch 'master' of github.com:canjs/can-define\n874e1c3 2.3.2\n0eb9e59 removing lingering debugger\n2b745b5 linting\n2f6ecad verify resolve does not leak reads\n0cce134 some minor cleanup\n\nSee the full diff\n\n. ## Version 2.3.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nf0fb13f 2.3.4\ne90f457 Merge pull request #342 from canjs/new\n938d415 Normalize val: Type, val: { Type: Type } and val: { type: Type }\n\nSee the full diff\n\n. ## Version 2.3.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\nf0fb13f 2.3.4\ne90f457 Merge pull request #342 from canjs/new\n938d415 Normalize val: Type, val: { Type: Type } and val: { type: Type }\n\nSee the full diff\n\n. ## Version 2.3.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n00a21b6 2.3.5\ndcf33ff Merge pull request #343 from canjs/ownkeys\nde47a81 Make canReflect.getOwnKeys work on basic maps\n\nSee the full diff\n\n. ## Version 2.3.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n00a21b6 2.3.5\ndcf33ff Merge pull request #343 from canjs/ownkeys\nde47a81 Make canReflect.getOwnKeys work on basic maps\n\nSee the full diff\n\n. ## Version 2.3.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\nd49acd0 2.3.6\n81aabc5 Merge pull request #348 from canjs/rm-props\n7c7677d Remove documentation on deprecated set() calls\nf1733ec Merge pull request #344 from canjs/320-docfixes-caneventqueue\ne53052d Fix can-event-queue links\n\nSee the full diff\n\n. ## Version 2.3.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n849617f 2.3.7\n852de76 Revert \"Remove documentation on deprecated set() calls\"\n\nSee the full diff\n\n. ## Version 2.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv2.4.0\n\nAdd compatibility with how webpack builds for production #346\nAdd \"use strict\" #347\n\n\n\nCommits\nThe new version differs by 15 commits.\n\nf32e5a4 2.4.0\n63b8c76 Merge pull request #339 from canjs/greenkeeper/serve-7.0.0\n2365f3d Update package.json\ncc4ea96 Merge pull request #347 from canjs/landscaper/4217-use-strict\n0d6ce7d Merge pull request #346 from canjs/fix-webpack-debug-style\n7e915f2 Merge pull request #341 from canjs/greenkeeper/testee-0.8.0\nfb3f447 add log function to helpers\ne3de92b remove comments\nf7d689d share log between list/map\nb7d34bf share log between list/map\n70bb786 fix the identation\n174f9c0 Adds use strict. Fixes canjs/canjs#4217\nec222e3 fix dev code for webpack compatibility\n11bec1e chore(package): update testee to version 0.8.0\n998dd7f chore(package): update serve to version 7.0.0\n\nSee the full diff\n\n. ## Version 1.2.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits ahead by 4, behind by 1.\n\naf3c052 1.2.1\ndde5e12 Update version number\n6e7dec1 Merge pull request #37 from canjs/formdata\n634c174 Check for FormData support\n\nSee the full diff\n\n. ## Version 2.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv2.0.0\nFeatures:\n\nparse rejected response #32\nimplement beforeSend #34\n\n\n\nCommits\nThe new version differs by 15 commits ahead by 15, behind by 1.\n\na24294b update npmignore\n320725f Update version number\n4933df3 using https for CORS\ncdcccbf Merge pull request #38 from canjs/major\n6f0f53b cleanup package.json\n124970b cleanup package.json\nadb5a43 prepare version 2\nc599796 Merge branch 'json-response' into major\n63461d6 Merge branch 'beforsend' into major\ne1838ce context of beforesend is the option object self\nf8d938f add description\n44315e4 close #32\n554c6f6 #close #34\n6f0376d parse if responseheader or a datatype is set\n49bda6c Update can-ajax.js\n\nSee the full diff\n\n. ## Version 2.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n2f37383 2.0.1\nc2d3ec3 Update version number\n69b3695 Don't ignore the tests from npm; needed for canjs/canjs\n\nSee the full diff\n\n. ## Version 2.0.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n2.0.2\nRemoves a few items from .npmignore that are needed for the canjs/canjs tests.\n\n\nCommits\nThe new version differs by 3 commits ahead by 3, behind by 1.\n\n6d608b1 2.0.2\nc0330a5 Update version number\n5bd5f9b More stuff that's needed for canjs/canjs tests\n\nSee the full diff\n\n. ## Version 4.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nread returns parentHasKey data\nvar VM = DefineMap.extend({\n  foo: \"string\"\n});\nvar vm = new VM();\nvar scope = new Scope(vm);\nscope.read(\"foo\").parentHasKey; // -> true\n\nThis also makes it so that getPathsForKey will return back paths where the key returns a function.\n\n\nCommits\nThe new version differs by 3 commits.\n\nfb9622f 4.4.0\na070fff Merge pull request #169 from canjs/get-paths-updates\n63c7dec fixing getPathsForKey to work with functions and making read return parentHasKey data\n\nSee the full diff\n\n. ## Version 4.4.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nrefactoring Scope.prototype.hasKey to avoid using getPathsForKey\n#173\n\n\nCommits\nThe new version differs by 7 commits.\n\n2e1d4c8 4.4.2\na9204f9 Merge pull request #173 from canjs/has-key-refactor\n6b6ac0b refactoring Scope.prototype.hasKey to avoid using getPathsForKey\n0eed04e Revert \"unremoving scope.getPathsforKey in production\"\nef5fc3c 4.4.1\n7a0c0e3 Merge pull request #172 from canjs/paths-for-key-prod\n59aaf05 unremoving scope.getPathsforKey in production\n\nSee the full diff\n\n. ## Version 4.4.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n536fc67 4.4.3\n6406976 Merge pull request #174 from canjs/test\n7da6a33 Run tests in production mode\n\nSee the full diff\n\n. ## Version 4.5.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 10 commits.\n\n41560c2 4.5.0\nf5cbdef Merge pull request #179 from canjs/can-observation-value\n0acd544 Merge pull request #178 from canjs/landscaper/4217-use-strict\n11d3cdd Check for can-observation._value instead of .value\n69303ce Merge pull request #168 from canjs/greenkeeper/testee-0.8.0\nac5d7d5 Adds use strict. Fixes canjs/canjs#4217\ne1b7e3d Merge pull request #177 from canjs/fix-webpack-debug-style\n288fb3e fix can-symbol after review\n5fa06e7 fix dev code for webpack compatibility\ne8b53be chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 4.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\ne53e0ee 4.1.2\ndb17d3c Merge pull request #90 from canjs/no-object-setprototypeof\n68c1adf avoiding use of Object.setPrototypeOf\n\nSee the full diff\n\n. ## Version 4.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\n09ba22f 4.2.0\n158868b Merge pull request #96 from canjs/attrs\nbcf51ce Linting\nd28a8cb Implement callbacks.attrs\ndaf867a Merge pull request #91 from canjs/fix-webpack-debug-style\nae7aab1 fix dev code for webpack compatibility\n\nSee the full diff\n\n. ## Version 4.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.3.0\nAdd \"use strict\" #94\n\n\nCommits\nThe new version differs by 7 commits.\n\n712326d 4.3.0\n9534cb9 Merge pull request #94 from canjs/landscaper/4217-use-strict\n910d028 Adds use strict. Fixes canjs/canjs#4217\n078474d Don\u2019t use a prerelease version of can-view-scope\naa60720 Remove done-serve\nc8c1a57 Merge pull request #89 from canjs/greenkeeper/testee-0.8.0\n1ec5ee0 chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 4.5.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nfixing \"Unable to find key\" warnings for nested properties and functions\n#535\n\n\nCommits\nThe new version differs by 3 commits.\n\ne7fdd1d 4.5.2\n68e0c1a Merge pull request #535 from canjs/missing-key-fixes\n2c22a96 fixing \"Unable to find key\" warnings for nested properties and functions\n\nSee the full diff\n\n. ## Version 4.5.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nfixing \"Unable to find key\" warnings to not give suggestions if the key was found\n{{abc.def}} will no longer suggest abc if abc was found but does not have a def key.\n#537\n\n\nCommits\nThe new version differs by 3 commits.\n\n89a49e8 4.5.3\nf0f69b9 Merge pull request #537 from canjs/dont-suggest-same-key\nef142ec not giving same key that was used in missing key warning for nested properties\n\nSee the full diff\n\n. ## Version 4.5.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.5.4\nFix can-string dependency to <2.0.0 #541\n\n\nCommits\nThe new version differs by 3 commits.\n\n1c0861b 4.5.4\n8d38da0 Merge pull request #541 from canjs/chasenlehara-patch-1\n99082a3 Fix can-string dependency to <2.0.0\n\nSee the full diff\n\n. ## Version 4.5.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits.\n\n04e1621 4.5.5\naeb3709 Merge pull request #499 from canjs/test-for-sort-each-498\ne93d43b jshinting\n1365f00 fixes #542 by using improve can-view-live\n1b6a6e6 provide nicer names for is helper\nfd51238 forgot test\n831fe5e a test the proves #498 works after can-define changes\n\nSee the full diff\n\n. ## Version 4.5.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n0892a75 4.5.6\nfa27339 fixes a bug where a value that changed from undefined to defined, and then changed values wasn't being updated in the page\n\nSee the full diff\n\n. ## Version 4.5.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n10e9cbc 4.5.7\n992a598 linting\n4fc63d2 no longer always warns when reading a key from the result of a method call\n\nSee the full diff\n\n. ## Version 4.5.8 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nPreserve the correct filename after rendering partials\n#547\n\n\nCommits\nThe new version differs by 3 commits.\n\n56b0ce2 4.5.8\n63c6201 Merge pull request #547 from canjs/544-preserve-scope-filename\n5578800 Preserve the correct filename for reporting even after loading a partial with a different filename (#544)\n\nSee the full diff\n\n. ## Version 4.5.9 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\ncache call expression scopeKeyData arguments for faster performance\n#550\n\n\nCommits\nThe new version differs by 3 commits.\n\n1d8cbbe 4.5.9\nbd336fc Merge pull request #550 from canjs/549-perf\nd2c7870 cache call expression arguments\n\nSee the full diff\n\n. ## Version 4.5.10 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\ndcadd26 4.5.10\n3182889 avoid setting the context unless actually necessary\n\nSee the full diff\n\n. ## Version 4.6.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 10 commits.\n\nd119a2f 4.6.0\n6b82699 Merge pull request #555 from canjs/addhelper\nb282ac2 Add the Map global\nabacc01 Add addBindings\n384b1e4 Merge pull request #554 from canjs/addhelper\n309441e Allow addHelper to be passed an object\na4d7b70 Merge pull request #551 from canjs/fix-debug-webpack-style\ndeb4d08 fix maxdepth error\n8ce0358 dev condition wrap\n9518db4 fix dev code for webpack compatibility\n\nSee the full diff\n\n. ## Version 4.7.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n7da43d4 4.7.0\n95158cc Merge pull request #558 from canjs/add-bindings-symbol\nd8c6b96 Allow WeakMap to be used as a global\n8a54a25 Make addBindings prefer a symbol.\n\nSee the full diff\n\n. ## Version 4.7.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n7406abd 4.7.1\n86b85f7 Merge pull request #561 from canjs/attrs\nd146a5c Update the test to use the callbackMap symbol\n9263853 Make addBindings an alias for viewCallbacks.attrs\n\nSee the full diff\n\n. ## Version 4.8.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 6 commits.\n\nb39cf8c 4.8.0\nf6c0b2b Merge pull request #563 from canjs/mult-converter\ne00e899 Remove use of can-stache-bindings\n42b06c9 Merge pull request #532 from canjs/greenkeeper/testee-0.8.0\n410ce77 Allow multiple converters to be registered with addConverter\n407f50e chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 4.9.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 21 commits.\n\n5a2be42 4.9.0\ne9f2c64 Merge pull request #564 from canjs/minor\n7bdc638 Update package.json\nbe53cb0 Merge pull request #560 from canjs/landscaper/4217-use-strict\n60315c2 Merge branch 'master' into landscaper/4217-use-strict\n07d22ba Merge branch 'master' into minor\n6df187c Adds use strict. Fixes canjs/canjs#4217\nf2521b0 Merge pull request #546 from canjs/502-docs\nd516b1b 4.8.0-pre.1\nbcee582 Fix the examples for rendering component instances in templates\n40951e3 Merge branch 'master' into minor\n9f155bb Add docs for rendering component instances in templates\nce9f155 Merge branch 'master' into minor\n7b8f639 4.6.0-pre.2\nc786af0 Merge branch 'master' into minor\n\nThere are 21 commits in total.\nSee the full diff\n\n. ## Version 2.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 26 commits.\n\n4fd5b79 2.1.0\n079941f Merge pull request #31 from canjs/minor\n07bcc65 Don\u2019t load can-reflect-dependencies in production\nfdd00ca Merge branch 'master' into minor\n44544ea Merge pull request #30 from canjs/can-util-removal\ne015c3e Merge pull request #28 from canjs/landscaper/4217-use-strict\n29a6da8 get rid of can-util dep\n1d4b32f Merge pull request #29 from canjs/webpack\nd911a90 Wrap debug code in process.env checks in the key module\n7ab0800 Merge branch 'master' into minor\ne58bffc Adds use strict. Fixes canjs/canjs#4217\nea86484 Merge pull request #27 from canjs/fix-webpack-debug-style\n10be334 fix can-symbol use after review\n3171225 fix dev code for webpack compatibility\n266f508 Merge branch 'master' into minor\n\nThere are 26 commits in total.\nSee the full diff\n\n. ## Version 2.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv2.1.1\nFix an issue when building for production 2e85df4\n\n\nCommits\nThe new version differs by 2 commits.\n\nc2475bf 2.1.1\n2e85df4 Fix an issue when building for production\n\nSee the full diff\n\n. ## Version 2.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv2.2.0\nAdd a value property getter & setter to the key module/observable #32\n\n\nCommits\nThe new version differs by 4 commits.\n\n2a1e16d 2.2.0\ncf91ec2 Merge pull request #32 from canjs/key-value\n73916d0 Require can-observation@^4.1.0\na5c7729 Add a value property getter & setter to the key module/observable\n\nSee the full diff\n\n. ## Version 0.8.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n614a3b2 0.8.1\n5e98771 Merge pull request #173 from bitovi/dev/172-security\nce09a68 update deps to resolve security vulnerabilities (fixes #172)\n\nSee the full diff\n\n. ## Version 1.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.1.0\nAdd \"use strict\" #6\n\n\nCommits\nThe new version differs by 5 commits.\n\n0737f8a 1.1.0\n34b737b Merge pull request #8 from canjs/fix\n8f11b96 Fix tests\n87cfac8 Merge pull request #6 from canjs/landscaper/4217-use-strict\n39b4e99 Adds use strict. Fixes canjs/canjs#4217\n\nSee the full diff\n\n. ## Version 1.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\n.read() now returns foundLastParent property\nReading foo.bar.baz will now return foundLastParent: true if foo.bar was found.\n#32\n\n\nCommits\nThe new version differs by 3 commits.\n\nbc6196d 1.3.0\n8b9c291 Merge pull request #32 from canjs/found-last-parent\n8040133 adding foundLastParent to reads\n\nSee the full diff\n\n. ## Version 1.3.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n807da50 1.3.1\nff92e66 Merge pull request #34 from canjs/33-fix-objHasKeyAtIndex\n05cbf9c specifying the right can-reflect\n89fc863 fix objHasKeyAtIndex handling non-objects\n\nSee the full diff\n\n. ## Version 1.3.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nWriting object performance improvement\n#36\n\n\nCommits\nThe new version differs by 2 commits.\n\n0b8d390 1.3.2\n7458bfc improves performance for #36\n\nSee the full diff\n\n. ## Version 1.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.4.0\n\nAdd compatibility with how webpack builds for production #37\nAdd \"use strict\" #38\n\n\n\nCommits\nThe new version differs by 7 commits.\n\na539dcf 1.4.0\n30f5059 Merge pull request #38 from canjs/landscaper/4217-use-strict\n517be78 Merge pull request #29 from canjs/greenkeeper/testee-0.8.0\nf7da573 Adds use strict. Fixes canjs/canjs#4217\n3a645d8 Merge pull request #37 from canjs/fix-webpack-debug-style\n013b52f fix dev code for webpack compatibility\nf4bbeee chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 4.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.2.0\nAdd \"use strict\" #53\n\n\nCommits\nThe new version differs by 7 commits.\n\n8aa306c Update dist for release\n996e1d1 Merge pull request #45 from canjs/greenkeeper/done-serve-2.0.0\n6a0b663 Merge pull request #53 from canjs/landscaper/4217-use-strict\nf9036c6 Merge pull request #49 from canjs/greenkeeper/testee-0.8.0\na7708f2 Adds use strict. Fixes canjs/canjs#4217\n0166a50 chore(package): update testee to version 0.8.0\ne678acd chore(package): update done-serve to version 2.0.0\n\nSee the full diff\n\n. ## Version 4.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n4be24b9 4.1.2\ne863ad2 use latest nodelist\nae231cb Merge pull request #253 from canjs/greenkeeper/testee-0.8.0\n25516b0 chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 4.1.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 12 commits.\n\n14d62bd 4.1.3\n49932df Merge pull request #272 from canjs/reg\n3ad3c72 Upgrade to use stache.addBindings\n12c065d Merge pull request #268 from canjs/view-model-docs-updates\nb6eb223 Minor improvement to the ViewModel docs\n6eae577 Clean up the view and ViewModel signatures\n16efa4d Merge pull request #261 from canjs/259-docs\n4d35a15 Merge pull request #260 from canjs/fix-webpack-debug-style\ne6d2516 Update docs to show 4.x syntax\nab1c32d Merge pull request #223 from canjs/greenkeeper/done-serve-2.0.0\nbf7a175 fix debug/dev code for webpack\n3fcb74b chore(package): update done-serve to version 2.0.0\n\nSee the full diff\n\n. ## Version 4.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 40 commits.\n\ndebb0e0 4.2.0\nbe0e769 Merge pull request #274 from canjs/minor\ned78a14 Use can-stache@^4.9.0\n9ace588 Merge branch 'master' into minor\n3bec10f Merge pull request #269 from canjs/landscaper/4217-use-strict\n912b401 Merge branch 'master' into minor\nf30dc37 Merge pull request #271 from canjs/fix-connected-callback-bug\naa2af19 Fix bug where connectedCallback gets called twice for new Components({ ... })\n35e64db Merge pull request #267 from canjs/262-init-with-templates\n7a3f422 Use can-reflect.eachKey instead of a for in loop\nef38153 Adds use strict. Fixes canjs/canjs#4217\nd7adafa Allow components to be instantiated with slot templates\nb60dbf6 Merge pull request #265 from canjs/262-init-slot-templates\n3911538 Add a test for using can-bind in connectedCallback\n58e3260 Update based on Justin\u2019s feedback\n\nThere are 40 commits in total.\nSee the full diff\n\n. ## Version 4.2.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\na502d71 4.2.1\na7e4cf5 publishing without the docs folder for canjs#4238\n\nSee the full diff\n\n. ## Version 4.2.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n3d69b8c 4.2.2\necd29dd publishing with docs once again\n\nSee the full diff\n\n. ## Version 4.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n51515f4 4.2.0\ncbad1bf able to pass an already unregistered old nodes to improve performance slightly\n\nSee the full diff\n\n. ## Version 4.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits.\n\n517bfa9 4.3.0\n0995d22 Merge pull request #47 from canjs/can-util-removal\n89c48ea get rid of can-util\n4ec76fe Merge pull request #46 from canjs/landscaper/4217-use-strict\n2ba40c7 Merge pull request #45 from canjs/greenkeeper/testee-0.8.0\nc5cacda Adds use strict. Fixes canjs/canjs#4217\n92151db chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 4.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n7319dce 4.1.2\n05667a6 Merge branch 'master' of github.com:canjs/can-view-live\nc17e899 Merge pull request #107 from canjs/greenkeeper/testee-0.8.0\n717603c chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 4.1.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\nc73f103 4.1.3\n19a11d0 if a element callback function messes with the nodeList, do not then update the nodelist again\n\nSee the full diff\n\n. ## Version 4.1.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nOnly add changesDeps in development\n#111\nfor faster performance\n\n\nCommits\nThe new version differs by 4 commits.\n\n63b7bd1 4.1.4\n60eb48c 4.1.4-0\ndce1d92 Merge pull request #111 from canjs/110-dev-only\n0cd65f8 for #110, only assign getChagnesDepsRecord in dev\n\nSee the full diff\n\n. ## Version 4.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 13 commits.\n\n20b575c 4.2.0\n938167f Merge pull request #115 from canjs/minor\nf9368f1 Merge branch 'master' into minor\n2d8abd4 Merge pull request #114 from canjs/landscaper/4217-use-strict\n0719634 Adds use strict. Fixes canjs/canjs#4217\ne3d40c2 Merge pull request #112 from canjs/fix-webpack-debug-style\nfcf9275 fix dev code for webpack compatibility\ne626e24 4.2.0-pre.1\n9c33a58 Merge branch 'master' into minor\n356119c 4.1.0-pre.1\nf966fd1 Bump version for minor prerelease\ne206139 Merge pull request #104 from canjs/can-view-insert\n0724455 Add support for can.viewInsert\n\nSee the full diff\n\n. ## Version 1.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.2.0\nAdd \"use strict\" #11\n\n\nCommits\nThe new version differs by 3 commits.\n\nb695f04 1.2.0\n4ee31fd Merge pull request #11 from canjs/landscaper/4217-use-strict\n0612aba Adds use strict. Fixes canjs/canjs#4217\n\nSee the full diff\n\n. ## Version 2.0.6 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nRefs are serializable \nCommit: 255bfb6\nSolves: #360\nBy using latest can-reflect: https://github.com/canjs/can-reflect/releases/tag/v1.16.5\n\n\nCommits\nThe new version differs by 3 commits.\n\n2a2f050 2.0.6\n5dbb338 gets all tests to pass\n255bfb6 uses latest can-reflect to correctly serialize refs into id strings\n\nSee the full diff\n\n. ## Version 2.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv2.1.0\n\nAdd compatibility with how webpack builds for production #425\nAdd \"use strict\" #426\n\n\n\nCommits\nThe new version differs by 9 commits.\n\n5ce38f7 2.1.0\ne01fe88 Merge pull request #426 from canjs/landscaper/4217-use-strict\n8d8cda2 added Object.defineProperty to connect.js:73, fixed this context in localstorage-cache.js:405\n8322c57 Merge pull request #419 from canjs/greenkeeper/testee-0.8.0\nc6939d3 Adds use strict. Fixes canjs/canjs#4217\n17b6865 Merge pull request #425 from canjs/fix-webpack-debug-style\n49d62c7 fix args wrapping for debug/dev mode\na00c4cf fix dev code for webpack compatibility\nd4eef9c chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 3.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 62 commits.\n\n46b4eae 3.0.1\ncc85c0b 3.0.0\n134e55f Merge pull request #431 from canjs/ql\ne4cff3d Use 1.0.0 of query-logic\n9f0c07f Merge pull request #413 from canjs/major\n60a0543 Merge branch 'master' into major\n9ebf537 Merge pull request #430 from canjs/m-m\n9eaaecd Correctly export from localstoragecache\n92a84e4 Merging master->major\n528440b 3.0.0-pre.16\n9cc4eb9 Merge pull request #429 from canjs/ajax\na35a01f Upgrade the can-ajax version\n54568dd 3.0.0-pre.15\n0930824 mistakenly published 3.0, fixing\n5342040 3.0.0\n\nThere are 62 commits in total.\nSee the full diff\n\n. ## Version 1.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\npassing specific can modules required by devtools to register function\nThis ensures that CanJS Devtools has all of the methods it needs from CanJS modules -- Symbol, Reflect, queues, getGraph, formatGraph, mergeDeep.\n\n\nCommits\nThe new version differs by 4 commits ahead by 4, behind by 1.\n\n85ea015 1.2.0\na4ff993 Update version number\na1f6b08 Merge pull request #47 from canjs/add-merge-deep\nf2d67d2 passing specific can modules required by devtools to register function\n\nSee the full diff\n\n. ## Version 1.2.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nmaking sure __CANJS_DEVTOOLS__.register is called\n#49\n\n\nCommits\nThe new version differs by 4 commits ahead by 4, behind by 1.\n\nd01e2df 1.2.1\n8201a6d Update version number\n82bb858 Merge pull request #49 from canjs/better-devtools-registration\n1546840 making sure CANJS_DEVTOOLS.register is called\n\nSee the full diff\n\n. ## Version 1.2.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nmaking sure to actually set __CANJS_DEVTOOLS__ global\n#50\n\n\nCommits\nThe new version differs by 4 commits ahead by 4, behind by 1.\n\n6f5d438 1.2.2\n78a3bf2 Update version number\naf9a923 Merge pull request #50 from canjs/fix-late-registration\n62f0d62 making sure to actually set CANJS_DEVTOOLS global\n\nSee the full diff\n\n. ## Version 1.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.3.0\n\nAdd \"use strict\" #51\n\n\n\nCommits\nThe new version differs by 4 commits ahead by 4, behind by 1.\n\n4af488b 1.3.0\ncf6b6ac Update version number\nb9c9b66 Merge pull request #51 from canjs/landscaper/4217-use-strict\nb6deded Adds use strict. Fixes canjs/canjs#4217\n\nSee the full diff\n\n. ## Version 1.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.2.0\nAdd \"use strict\" #12\n\n\nCommits\nThe new version differs by 4 commits ahead by 4, behind by 1.\n\n1f43a39 1.2.0\n656cfd5 Update version number\nba43900 Merge pull request #12 from canjs/landscaper/4217-use-strict\n7fdbe46 Adds use strict. Fixes canjs/canjs#4217\n\nSee the full diff\n\n. ## Version 1.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.1.0\n\nAdd compatibility with how webpack builds for production #18\nAdd \"use strict\" #19\n\n\n\nCommits\nThe new version differs by 7 commits ahead by 7, behind by 1.\n\nf052488 1.1.0\n3e8732a Update version number\n2f45001 Merge pull request #19 from canjs/landscaper/4217-use-strict\nfd336cd Update .jshintrc\n05e8919 Adds use strict. Fixes canjs/canjs#4217\nba208eb Merge pull request #18 from canjs/fix-webpack-debug-style\nf072639 fix dev code for webpack compatibility\n\nSee the full diff\n\n. ## Version 1.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 0.6.22 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\na3fc03a 0.6.22\nd2a23dc Merge pull request #179 from canjs/wp\ne72a931 Fix webpack require warning\n\nSee the full diff\n\n. ## Version 5.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n00726d7 Merge branch 'master' of github.com:canjs/can-view-autorender\nb1f1117 5.0.0\n4a88486 Merge pull request #82 from canjs/greenkeeper/testee-0.8.0\n3d55802 chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 5.0.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\nd88fda5 Update dist for release\nfa88545 Use can-component 4.x\n\nSee the full diff\n\n. ## Version 0.0.11 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 3.12.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv3.12.0\n\nAdd compatibility with how webpack builds for production #431\nAdd \"use strict\" #430\n\n\n\nCommits\nThe new version differs by 8 commits.\n\nde76770 Update dist for release\nd16b60a Merge pull request #430 from canjs/landscaper/4217-use-strict\n451021a making sure test folder does not get npmignored\nb9fe910 Merge pull request #426 from canjs/greenkeeper/testee-0.8.0\nec7da85 Merge pull request #431 from canjs/fix-webpack-debug-style\nc30b591 fix dev code for webpack compatibility\n97686c7 Adds use strict. Fixes canjs/canjs#4217\n8eb4e80 chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 4.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.2.0\n\nAdd \"use strict\" #86\nRemove uses of can-util #89\n\n\n\nCommits\nThe new version differs by 7 commits.\n\n059edd7 Update dist for release\n84330ce Merge pull request #89 from canjs/can-util-removal\nb2c7082 Merge pull request #86 from canjs/landscaper/4217-use-strict\nb79da69 get rid of can-util\nb975083 Merge pull request #83 from canjs/greenkeeper/testee-0.8.0\nf8ca610 Adds use strict. Fixes canjs/canjs#4217\nec118b2 chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 1.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.3.0\nAdd \"use strict\" #45\n\n\nCommits\nThe new version differs by 9 commits.\n\n7c3b963 Update dist for release\nf59f8bc Merge pull request #45 from canjs/landscaper/4217-use-strict\ned92860 Merge pull request #43 from canjs/greenkeeper/testee-0.8.0\nf15ef8f Update validate.js\n71accc2 Update can-validate-test.js\nc0ea2d6 Create .jshintrc\nf328011 Merge branch 'master' into landscaper/4217-use-strict\n0e12cab Adds use strict. Fixes canjs/canjs#4217\n61f2caf chore(package): update testee to version 0.8.0\n\nSee the full diff\n\n. ## Version 1.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n533c13b Update dist for release\nf415fdd Merge pull request #50 from canjs/can-util-removal\n1943856 get rid of can-util\n\nSee the full diff\n\n. ## Version 1.1.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\naee4f1e 1.1.2\nc76957e publishing docs\n\nSee the full diff\n\n. ## Version 3.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 30 commits ahead by 30, behind by 1.\n\nc7e7c26 3.0.0\nc23e5eb Merge pull request #147 from canjs/major\n8bae66a Merge branch 'master' into major\n567f6fe 3.0.0-pre.11\ndb3c340 log fixture information more nicely\n010a660 3.0.0-pre.10\n499b73e respond with all data in create\n3d1ed11 3.0.0-pre.9\n7a466f1 store works\ncca8f28 3.0.0-pre.8\n1dc5f09 include test folder\n5130eaf 3.0.0-pre.7\n1352513 schemas can be passed directly\nd779e28 3.0.0-pre.6\nbeaa760 moving to core\n\nThere are 30 commits in total.\nSee the full diff\n\n. ## Version 2.0.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.2.0\nRemove uses of can-util #71\n\n\nCommits\nThe new version differs by 4 commits.\n\nfb52502 Update dist for release\nfd4b72f Merge pull request #71 from canjs/can-util-removal\n8c6bb6d fix can-namespace for build.js\nf2de6a5 get rid of can-util\n\nSee the full diff\n\n. ## Version 0.0.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n43d2604 0.0.5\n83313c9 Merge pull request #10 from bitovi/clear-timeouts\n49fcfca clearing timeoutIds\na926456 adding platform name to all log messages\n\nSee the full diff\n\n. ## Version 1.4.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv1.4.0\n-Add \"use strict\" #9\n\n\nCommits\nThe new version differs by 4 commits.\n\nf2959d7 1.4.0\nde1057e Merge branch 'master' of https://github.com/canjs/can-diff\nfa160a9 Merge pull request #9 from canjs/landscaper/4217-use-strict\n78bdbf4 Adds use strict. Fixes canjs/canjs#4217\n\nSee the full diff\n\n. ## Version 4.3.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nv4.3.2\nThis reverts a buggy bug-fix in https://github.com/canjs/can-view-nodelist/releases/tag/v4.3.1\n\n\nCommits\nThe new version differs by 2 commits.\n\n8174d88 4.3.2\n6f85a3a Revert \"Unregister newDeepChildren\"\n\nSee the full diff\n\n. After pinning to 3.0.8 your tests are passing again. Downgrade this dependency \ud83d\udccc.. - The devDependency webpack-cli was updated from 3.1.0 to 3.1.1.\nYour tests are passing again with this update. Explicitly upgrade to this version \ud83d\ude80\n\nRelease Notes for Webpack-cli v.3.1.1\nWebpack CLI version 3.1.1 comes with minor fixes to infrastructure, fixing bugs, synchronization with webpack and updating the build system.\nFor a full overview of changes done, you can view it here\nMonorepo packages has also been updated as patches and can be safely updated.\n\n\nCommits\nThe new version differs by 36 commits.\n\ne3119b6 v0.1.1\na0afc35 chore: v.3.1.1\n0ffede1 fix(schema): resolve references in schema (#605)\n6be0478 chore(fix): fix clean all script\n91cc499 chore(tests): added first ts test for info package (#584)\n1a8099c Merge pull request #604 from sendilkumarn/fix-tslint-issues\ne425642 chore(lint): remove or replace console.log with console.error\ndb5f570 chore(lint): turn off console log warning\ncf0bf4a chore(lint): fix tslint warnings\n1e0fa65 chore(ci): fix commitlint (#592)\nb8d544b feat(types): types for packages (#578)\n936e7c1 chore(ci): Add a status badge for the azure pipelines CI build (#601)\nd892b4d chore(deps): resync package-lock, upgrade major version\n2910645 docs(contribution): fix the setup workflow #591 (#597)\n2588394 chore(ci): add commitlint when trying to commit (#595)\n\nThere are 36 commits in total.\nSee the full diff\n\n. - The devDependency webpack-cli was updated from 3.1.1 to 3.1.2.\nYour tests are passing again with this update. Explicitly upgrade to this version \ud83d\ude80\n\nRelease Notes for webpack-CLI version 3.1.2\nVersion 3.1.2 fixes minor bugs, readme fixes and various of small regressions.\nYou can safely update to webpack 3.1.2 from 3.1.0.\nFor a full view of changes done, you can browse those here.\n\n\nCommits\nThe new version differs by 53 commits.\n\n795ac48 v0.1.2\n8225339 chore: v.3.1.2>\nfb6945b Merge pull request #618 from webpack/fix/watch-info\n99f5a69 Merge pull request #616 from rishabh3112/patch-4\n4cba51d Merge pull request #615 from rishabh3112/patch-3\nd4e1614 fix: replace test regex\nf3a225a docs(readme): update webpack-cli to webpack CLI\n9aed0dc fix(tapable): fix hook options\ndc4ded9 docs(init): update headers\n747aef9 docs(readme): change addons to scaffolds\nf8187f1 docs(readme): update links\n2ccf9a9 docs(init): update init documentation\n3844671 docs(readme): update README.md (#614)\nda05c2f docs(readme): update Readme based on feedback\n93ebcc2 chore(docs): update readme\n\nThere are 53 commits in total.\nSee the full diff\n\n. - The devDependency webpack-cli was updated from 3.1.2 to 3.2.0.\nYour tests are passing again with this update. Explicitly upgrade to this version \ud83d\ude80\n\nCommits\nThe new version differs by 177 commits.\n\n6253a73 chore: v.3.2.0\n0c3be76 chore: make tests pass\n0b6bab3 chore: better defaults\n78436ff chore: add-on -> scaffold\n3281372 chore: simplify clean-all script\nb0f4a0f chore: addon -> scaffold\n82c9ea8 chore: update lockfiles\na3fe013 Merge pull request #716 from EvsChen/dist-scaffold\nf9bb82d Merge pull request #693 from lakatostamas/feature/find-config-recursively\n3ec2e9d chore: resolve conflict\n83602d4 chore: update package lock and scripts\nd82b016 Merge pull request #720 from rishabh3112/patch-7\n4d9c847 Merge pull request #723 from eavichay/patch-1\n4b2a127 docs: improve the docs (#722)\n9ad8c1d See #721\n\nThere are 177 commits in total.\nSee the full diff\n\n. - The devDependency webpack-cli was updated from 3.2.1 to 3.2.2.\nYour tests are passing again with this update. Explicitly upgrade to this version \ud83d\ude80\n\nCommits\nThe new version differs by 275 commits.\n\nf81762c chore: v.3.2.2\nbed0c80 Merge pull request #744 from webpack/fix/737-and-739\nc95ea35 chore: :D\n11a3c15 chore: :)\naf46c7e chore: :)\n4e67e7f chore: :)\nab4c3a2 chore: :)\n099e43d chore: :)\n18a6f53 chore: :)\nca46c8b chore: :)\n053195a chore: remove ci opt\nb21d2ce chore: remove ci opt\n1d84d27 chore: remove ci opt\ncc11736 chore: remove ci opt\n861d543 chore: remove ci opt\n\nThere are 250 commits in total.\nSee the full diff\n\n. - The devDependency webpack-cli was updated from 3.2.2 to 3.2.3.\nYour tests are passing again with this update. Explicitly upgrade to this version \ud83d\ude80\n\nCommits\nThe new version differs by 276 commits.\n\n16c9c8d chore: v.3.2.3\nf81762c chore: v.3.2.2\nbed0c80 Merge pull request #744 from webpack/fix/737-and-739\nc95ea35 chore: :D\n11a3c15 chore: :)\naf46c7e chore: :)\n4e67e7f chore: :)\nab4c3a2 chore: :)\n099e43d chore: :)\n18a6f53 chore: :)\nca46c8b chore: :)\n053195a chore: remove ci opt\nb21d2ce chore: remove ci opt\n1d84d27 chore: remove ci opt\ncc11736 chore: remove ci opt\n\nThere are 250 commits in total.\nSee the full diff\n\n. - The devDependency webpack-cli was updated from 3.2.3 to 3.3.0.\nYour tests are passing again with this update. Explicitly upgrade to this version \ud83d\ude80\n\nCommits\nThe new version differs by 308 commits.\n\n8955506 chore: v.3.3.0\n398e39a Merge pull request #773 from misterdev/misterdev-format-scaffold\na14908e chore: revise typo\nd19c1f7 docs(scaffolding): lowercase Webpack\nb94b0de docs(scaffolding): fix typos\n6b79072 docs(scaffolding): improve grammar\n65bf27f docs: add lerna badge in README (#786)\n98818a1 docs(scaffolding): fix typo\n0f657d0 docs(scaffolding): improve description & formatting\n6aec4c3 Merge pull request #742 from rishabh3112/fix/init\ne2c9dd7 Merge pull request #768 from misterdev/docs/contributing-formatting\n6fee805 Merge pull request #785 from webpack/fix/ci\na8b46bf chore(deps): @std/esm -> esm\n54a3ac4 fix(tests): remove snapshot for static compilation\n3af0948 fix(tests): remove snapshot for static compilation\n\nThere are 250 commits in total.\nSee the full diff\n\n. ## Version 1.1.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nExpose set methods and reduce some examples better\nCommit: 7547e48\nimport {QueryLogic} from \"can-query-logic\";\nvar gt1 = new QueryLogic.GreaterThan(1);\nvar lte1 = new QueryLogic.LessThanEqual(1);\n\nQueryLogic.intersection(gt1, lte1) //-> QueryLogic.EMPTY\n\n\nCommits\nThe new version differs by 2 commits.\n\n7931b4d 1.1.0\n7547e48 exposes set methods and tests and fixes various dead-code-elimination patterns\n\nSee the full diff\n\n. ## Version 4.3.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.3.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n6e8745b 4.3.3\n4e98f4c Merge pull request #193 from canjs/when-ready\n85686ba Allowing a callback when start() finishes to make tests more consistent\n\nSee the full diff\n\n. ## Version 4.3.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nImproving consistency of more tests\n#194\n\n\nCommits\nThe new version differs by 3 commits.\n\ncdeb144 4.3.4\n4710f2d Merge pull request #194 from canjs/more-start-complete\n50288a2 adding _onStartComplete to more flaky tests\n\nSee the full diff\n\n. ## Version 4.3.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n61f1aa6 Update dist for release\n2e486ac Merge pull request #82 from canjs/keys-no-define\n292316a fixing getOwnEnumerableKeys when there is no define object\n\nSee the full diff\n\n. ## Version 4.3.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\ne0fdd00 Update dist for release\n32bd127 Merge pull request #84 from canjs/reflect-tests\n5cf5722 adding can-reflect-tests and fixing issue with non-enumerable properties\n\nSee the full diff\n\n. ## Version 4.3.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\ne2ed171 Update dist for release\n4377d4a Merge pull request #86 from canjs/null-keys\n108e93e using Object.keys to get keys for _data\n\nSee the full diff\n\n. ## Version 1.1.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 1.17.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n33945b8 Update dist for release\n4bd5444 Merge pull request #140 from canjs/is-even-test\nbbc2bb2 using a function expression for isEven to fix strict mode\n\nSee the full diff\n\n. ## Version 1.17.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nFixes documentation on update and updateDeep\nThis fixes the documentation and code examples for update and updateDeep.\nBugs\n\n#141 The update docs are showing examples using assign\n\n\n\nCommits\nThe new version differs by 3 commits.\n\n8bebe49 Update dist for release\n8538587 Merge pull request #142 from canjs/assign-docs\n6e45a37 Fixes the update/updateDeep docs\n\nSee the full diff\n\n. ## Version 4.10.5 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nFixes arguments passed to helpers and adds `addConverter` docs \nPR #582\n\n\nCommits\nThe new version differs by 3 commits.\n\ne9191fd 4.10.5\n796234e Merge pull request #582 from canjs/556-docs\n8ecda23 fixes #581 and adds addConverter docs for #556\n\nSee the full diff\n\n. ## Version 4.4.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n. ## Version 4.3.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\ncddc888 4.3.0\n9ed2c54 Merge pull request #117 from canjs/leg-attr\nbc84aeb Makes _legacyAttrBehavior work for serialize()\n\nSee the full diff\n\n. ## Version 4.3.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nMakes deep assigns and updates work with _legacyAttrBehavior\nWhen using _legacyAttrBehavior: true to enable the legacy attr\nbehavior you still want to interop with other map types. For this to\nwork:\nmap.attr({\n  prop: new DefineMap()\n})\nThis works with both assign and update forms of attr().\n\n\nCommits\nThe new version differs by 3 commits.\n\n5da9b98 4.3.1\n72a2fac Merge pull request #121 from canjs/map-attrs2\n8674382 Makes deep assigns and updates work with _legacyAttrBehavior\n\nSee the full diff\n\n. ## Version 4.3.3 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nHandles props with undefined values \nMakes sure that any props on the map are still added when their value is undefined, whether during construction or set later. PR#122\n\n\nCommits\nThe new version differs by 3 commits.\n\na78d735 4.3.3\n6d829b8 4.3.2\n1094c44 84 dropping keys (#122)\n\nSee the full diff\n\n. ## Version 1.2.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nAdding to can-namespace\n#39\n\n\nCommits\nThe new version differs by 3 commits.\n\naec23de 1.2.0\n9684f6c Merge pull request #39 from canjs/can-namespace\n7759391 adding to can-namespace\n\nSee the full diff\n\n. ## Version 4.2.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n49edd88 Update dist for release\need27db making sure test folder is not gitignored\n\nSee the full diff\n\n. ## Version 4.3.7 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n9b46b81 4.3.7\n4e41bba waiting a min before failing\n\nSee the full diff\n\n. ## Version 4.3.8 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by  commits.\nSee the full diff\n\n. ## Version 5.0.4 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n751d213 5.0.4\n5b30d40 cleaning up the tests, trying to make one more timing tollerant\n\nSee the full diff\n\n. ## Version 1.4.1 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n53bf272 1.4.1\n37fab1e Add test/ to the npm folder\n\nSee the full diff\n\n. ## Version 1.4.2 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\nd0460d4 1.4.2\n9e6c249 Make tests pass in Edge\n\nSee the full diff\n\n. ## Version 2.5.11 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n28bd4a0 2.5.11\n95f4739 Updating can-define/map documentation (#382)\n\nSee the full diff\n\n. ## Version 2.5.12 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes\nRedeploying updated documentation\nThe last release didn't have the most up-to-date documentation, redeployed.\n\n\nCommits\nThe new version differs by 3 commits ahead by 3, behind by 1.\n\nf72de00 2.5.12\n5d76bd4 2.5.11\n9d0f619 Improvements to Can-Define Documentation (#387)\n\nSee the full diff\n\n. ## Version 2.6.0 just got published. \nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n0be24e9 2.6.0\nbb8f29f Merge pull request #388 from canjs/late-defined\ncc8d8ad Make serialized DefineMaps observable with late-defined properties\n\nSee the full diff\n\n. - The dependency can-stache was updated from 4.11.0 to 4.11.2.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 5 commits.\n\n17597ee 4.11.2\na1f15cf works within string-only\n690cbe5 Merge pull request #594 from canjs/593-let-in-for\nd5806c5 lints\n01f2b8c fixes #593\n\nSee the full diff\n\n. - The dependency can-stache was updated from 4.11.0 to 4.11.3.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for for(of) gets scope.index and for(items) works\nbba5f68\n{{# for(items) }}\n  {{scope.index}}\n{{/ for}}\n\nThe above works.\n\n\nCommits\nThe new version differs by 2 commits.\n\n8629fe7 4.11.3\nbba5f68 for(of) gets scope.index and for(items) works\n\nSee the full diff\n\n. - The dependency can-view-live was updated from 4.2.1 to 4.2.4.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for Avoid setTimeout in tests. (Edge was breaking)\nCommit: ce97c19\n\n\nCommits\nThe new version differs by 2 commits.\n\n318d715 4.2.4\nce97c19 avoids problems with slow mutations by using afterMutation from can-stache-bindings tests\n\nSee the full diff\n\n. - The dependency can-stache-bindings was updated from 4.4.2 to 4.5.0.\nUpdate to this version instead \ud83d\ude80. - The dependency can-simple-observable was updated from 2.3.0 to 2.4.0.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for Adds the ability to take default value\nPR: #36\n\n\nCommits\nThe new version differs by 1 commits.\n\n7e576f0 2.4.0\n\nSee the full diff\n\n. - The devDependency steal-tools was updated from 2.0.4 to 2.0.7.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for 2.0.7\nThis fixes a bug related to modlet folders and the bundle configuration for progressively loaded bundles. Now the following works:\n\"bundle\": [\n  \"pages/**/\"\n]\nWhich will find modules like:\n\npages/home/home\npages/cart/cart\n\nBut will not pick up\n\npages/cart/cart-test\n\n\n\nCommits\nThe new version differs by 4 commits.\n\nf8ecfd4 2.0.7\ne298a5c Merge pull request #1090 from stealjs/bundle-wildcard\nfa1ad6f Restructure the bundle false test\n444cb85 Make bundle globs work with the modlet pattern\n\nSee the full diff\n\n. - The devDependency steal-tools was updated from 2.0.4 to 2.0.8.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for 2.0.8\nThis patch releases fixing a bug caused when tree shaking CommonJS modules from 2 different ES modules.\n\n\nCommits\nThe new version differs by 9 commits.\n\n492651f 2.0.8\nbad9a20 Merge pull request #1095 from stealjs/ts\n4a139ab Determine used exports for CJS modules\n53f9b45 Merge pull request #1076 from stealjs/greenkeeper/babel-minify-0.5.0\n5b6155f Merge pull request #1091 from stealjs/greenkeeper/through2-3.0.0\n26eff78 Merge pull request #1092 from stealjs/bu\n397107e Add more advanced bundle wildcard tests\nc1e26d5 fix(package): update through2 to version 3.0.0\n2144f33 fix(package): update babel-minify to version 0.5.0\n\nSee the full diff\n\n. - The devDependency steal-tools was updated from 2.0.4 to 2.0.9.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for 2.0.9\nThis is a patch release of steal-tools, fixing a regression caused in the last tree shaking fix.\n\n\nCommits\nThe new version differs by 3 commits.\n\n3d64f6a 2.0.9\n14634e5 Merge pull request #1097 from stealjs/guard-importspecifiers\n9442dc3 Account for modules without importNames\n\nSee the full diff\n\n. - The devDependency steal-tools was updated from 2.0.4 to 2.0.10.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n91bc952 2.0.10\nbb157bf Merge pull request #1098 from stealjs/rollup\n7ef645e Upgrade rollup version\n\nSee the full diff\n\n. - The devDependency steal-tools was updated from 2.0.4 to 2.0.11.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n22cadf6 2.0.11\ncc5b5b3 Merge pull request #1099 from stealjs/ts-side\n946cfb2 Add the dependencies to git for treeshaking\ndda6e08 Make sure all side-effectual deps remain in tree\n\nSee the full diff\n\n. - The dependency can-event-queue was updated from 1.1.1 to 1.1.3.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits ahead by 4, behind by 1.\n\n45a7ced 1.1.3\n26dd60a Update version number\nab06c04 Merge pull request #21 from canjs/ie-compat\n068a072 fix tests for iE11\n\nSee the full diff\n\n. - The dependency can-control was updated from 4.2.0 to 4.4.0.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\na935d4c 4.4.0\n58ee8ca fixes #128, provides can-dom-data-state access to controls\n\nSee the full diff\n\n. - The dependency can-stache was updated from 4.14.0 to 4.15.1.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for call expressions re-evaluate\nIf foo changes in this.foo.doSomething(), the expression re-evaluates.\n\n\nCommits\nThe new version differs by 3 commits.\n\n00ac620 4.15.1\nd98a650 lints\nb9bfba3 tests and fixes #616\n\nSee the full diff\n\n. - The dependency can-view-scope was updated from 4.9.1 to 4.11.0.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n5a3587d 4.11.0\n870ea2b fixes canjs/can-stache#616 by making thisArg observable\n\nSee the full diff\n\n. - The dependency can-fixture was updated from 3.0.2 to 3.0.4.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n36c079f 3.0.4\n50140f7 Merge pull request #159 from canjs/fix-test\nea8da29 Import steal-clone dynamically in the test\n\nSee the full diff\n\n. - The dependency can-query-logic was updated from 1.1.3 to 1.1.5.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n39b3def 1.1.5\n20906f8 more linting\n3c17183 linting\n55be658 fixes #24, makes null and undefined sort to the start of a list\n\nSee the full diff\n\n. - The dependency can-value was updated from 1.0.2 to 1.1.0.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits ahead by 3, behind by 1.\n\n154bec7 1.1.0\nb762823 Update version number\n84be576 add the ability to create settable observables via returnedBy\n\nSee the full diff\n\n. - The dependency can-queues was updated from 1.1.4 to 1.2.1.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n2f88377 1.2.1\n72dfb04 Merge pull request #23 from canjs/skip-production-tests\nef3e052 skipping tests for dev-only code in production\n\nSee the full diff\n\n. - The dependency can-bind was updated from 1.0.1 to 1.1.1.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n2896c2f 1.1.1\n39b197a speeding up tests by not logging groups\n\nSee the full diff\n\n. - The dependency can-stache-bindings was updated from 4.5.1 to 4.6.1.\nUpdate to this version instead \ud83d\ude80. - The dependency can-stache-bindings was updated from 4.5.1 to 4.6.2.\nUpdate to this version instead \ud83d\ude80. - The dependency can-stache-bindings was updated from 4.5.1 to 4.6.3.\nUpdate to this version instead \ud83d\ude80. - The dependency can-stache-bindings was updated from 4.5.1 to 4.6.4.\nUpdate to this version instead \ud83d\ude80. - The dependency can-dom-mutate was updated from 1.3.0 to 1.3.2.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for IE11 Support\n#46\n\n\nCommits\nThe new version differs by 5 commits.\n\n96d11f1 1.3.2\n916014b Merge pull request #46 from canjs/fix-ie\n64dc422 not using DocumentFragment constructor that is not supported in IE11\n22eb84f fixing document.contains for IE11 (copied from canjs/can-view-live#127)\n47932e3 fixing export for IE11\n\nSee the full diff\n\n. - The dependency can-dom-mutate was updated from 1.3.0 to 1.3.3.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for fixing issues with document.createTreeWalker in IE11\n#47\n\n\nCommits\nThe new version differs by 3 commits.\n\n9d1473f 1.3.3\n855c1de Merge pull request #47 from canjs/ie11-create-tree-walker\ne952f01 fixing issues with document.createTreeWalker in IE11\n\nSee the full diff\n\n. - The dependency can-dom-mutate was updated from 1.3.0 to 1.3.4.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for handling Set constructor being removed before a tree mutation is handled in IE11\n#48\n\n\nCommits\nThe new version differs by 3 commits.\n\n3398ac8 1.3.4\n6ab5146 Merge pull request #48 from canjs/typeof-set-unknown\nff40278 handling Set constructor being removed before a tree mutation is handled\n\nSee the full diff\n\n. - The dependency can-dom-mutate was updated from 1.3.0 to 1.3.5.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for Another fix for IE11\n#49\n\n\nCommits\nThe new version differs by 3 commits.\n\nd72d54a 1.3.5\na32913a Merge pull request #49 from canjs/typeof-set-take-2\n5094ee6 changing typeof Set to fix IE11 issue\n\nSee the full diff\n\n. - The devDependency steal-conditional was updated from 0.4.0 to 1.1.3.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n2a58d14 1.1.3\n7c31394 Merge pull request #66 from stealjs/use-loader\nab0edbd Use @loader\n\nSee the full diff\n\n. - The dependency can-dom-data-state was updated from 1.0.2 to 1.0.4.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n0f6b196 1.0.4\n48a2325 Merge pull request #25 from canjs/docel\n47bc26b Use document.contains where available\n\nSee the full diff\n\n. - The dependency can-dom-data-state was updated from 1.0.2 to 1.0.5.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n869641a 1.0.5\n7477521 Merge pull request #30 from canjs/remove-document-element\nbe44ca2 fixing node deletion when documentElement is removed\n\nSee the full diff\n\n. - The dependency can-component was updated from 4.4.4 to 4.4.6.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n114af80 4.4.6\n7351017 Merge pull request #311 from canjs/rename-tests\nce7f490 renaming tests to match naming convention of other packages\n\nSee the full diff\n\n. - The dependency can-component was updated from 4.4.4 to 4.4.7.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for Removing can-observe from test that doesn't need it (for IE 11 support)\n#312\n\n\nCommits\nThe new version differs by 4 commits.\n\nd7903f6 4.4.7\nf04ea0b Merge pull request #312 from canjs/remove-observe\n16f7e70 enabling and fixing jshint in tests\ne8588b1 removing can-observe from test that doesn't use it\n\nSee the full diff\n\n. - The dependency can-component was updated from 4.4.4 to 4.4.8.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n5d901df 4.4.8\n5d6f5e5 Merge pull request #314 from canjs/window-item-ie11\n2e8f3a9 changing key in test to something that doesn't conflict with IE11\n\nSee the full diff\n\n. - The dependency can-component was updated from 4.4.4 to 4.4.9.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n4404b22 4.4.9\nf96f45a Merge pull request #315 from canjs/remove-document-element\n30765fe fixing teardown when documentElement is removed\n\nSee the full diff\n\n. - The dependency can-stache was updated from 4.15.3 to 4.15.5.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n79cc158 4.15.5\nd24b723 Merge pull request #623 from canjs/ie11-tests\n2a14982 fixing tests using Symbols for IE11\n\nSee the full diff\n\n. - The dependency can-route was updated from 4.4.3 to 4.4.5.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 7 commits.\n\nbe0b020 4.4.5\ne43e84b Merge pull request #212 from canjs/ie11-compat\n8e217ed changing test file setup to match new pattern\nb03f8e8 fixing typeof check\n2fa953c separate observe tests\nc70ae1b fix routing values conflicts between tests with timeout for ie11\n271a1a9 fix test for IE11\n\nSee the full diff\n\n. - The dependency can-stache was updated from 4.15.4 to 4.15.7.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for SVG rendering\n#604 \n\n\nCommits\nThe new version differs by 5 commits.\n\n098d6e9 4.15.7\ne15d0f9 Merge pull request #604 from canjs/584fix-svg-rendering\n37c2f9d fix svg rendering test\n2f9a1a2 fix handle attributes namespaces\nff50bc8 handle xmlns namespace attribute for svg\n\nSee the full diff\n\n. - The dependency can-stache was updated from 4.15.4 to 4.15.8.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for filenames work in text sections\nIn a text section like: <div class='{{aValue}}'></div>, the filenames were not working.\n#628\n\n\nCommits\nThe new version differs by 4 commits.\n\n8325854 4.15.8\n8a660d7 makes sure filename works in text sections\n97a5187 Merge branch 'master' of github.com:canjs/can-stache\n7b656fb more documentation improvements\n\nSee the full diff\n\n. - The dependency can-connect was updated from 3.0.2 to 3.0.4.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 10 commits ahead by 10, behind by 1.\n\n0b684e0 3.0.4\nb5651cc bump version\nba386ee Merge pull request #443 from canjs/ie11-compat\n73dcffc organise tests file to fit the standard\nba623d1 fix tests files\ne18550b renaming test modules to follow the standard for proxy\n6171007 rename to follow the standard for Proxy tests\nf4d6120 rename test modules to follow the standard\n3d48ea7 remove weakset from devDeps\n12a3985 separate can-observe tests and make sure it uses the fixed version of can-memory-store\n\nSee the full diff\n\n. - The dependency can-connect was updated from 3.0.2 to 3.0.5.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\na9464cd 3.0.5\n2d49bb5 Merge pull request #444 from canjs/test-without-proxy\ne5077b1 adding test-without-proxy.js for IE11\n\nSee the full diff\n\n. - The dependency can-stache-route-helpers was updated from 1.1.1 to 1.1.3.\nUpdate to this version instead \ud83d\ude80. - The dependency can-debug was updated from 2.0.1 to 2.0.3.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for using can-assign instead of Object.assign (for IE11)\n#61\n\n\nCommits\nThe new version differs by 4 commits ahead by 4, behind by 1.\n\n3940592 2.0.3\n1170ab9 Update version number\nfa35717 Merge pull request #61 from canjs/can-assign\nbbca129 using can-assign instead of Object.assign (for IE11)\n\nSee the full diff\n\n. - The dependency can-debug was updated from 2.0.1 to 2.0.4.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits ahead by 4, behind by 1.\n\n2bb7078 2.0.4\nb72af44 Update version number\n61cd76c Merge pull request #63 from canjs/new-set-iterable\n94210c8 not creating new Set with an iterator (for IE11)\n\nSee the full diff\n\n. - The dependency can-bind was updated from 1.1.1 to 1.3.0.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for Added onEmit / offEmit to listenAndUpdate methods for emitted values\n#15\n\n\nCommits\nThe new version differs by 2 commits.\n\nc249193 1.3.0\nb4ef897 Added onEmit / offEmit to listenAndUpdate methods for emitted values (#15)\n\nSee the full diff\n\n. - The dependency can-view-scope was updated from 4.11.1 to 4.12.1.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for initialValue should not emit ObservationRecords\nIssue: #198\n \n\n\nCommits\nThe new version differs by 6 commits.\n\n80a1fa3 4.12.1\n7d2e6eb linting\n742532a Merge branch 'master' of github.com:canjs/can-view-scope\nd67c9cb fixes #198\n2942dac Merge pull request #180 from canjs/greenkeeper/steal-2.0.0\n2c8acb9 chore(package): update steal to version 2.0.0\n\nSee the full diff\n\n. - The dependency can-view-scope was updated from 4.11.1 to 4.13.0.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\nc6abb74 4.13.0\n8c1c300 allows scope.args as a special key, replacing scope.arguments\n\nSee the full diff\n\n. - The dependency can-stache was updated from 4.15.9 to 4.15.12.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n945d700 4.15.12\nb2aea5e Issue with ordering of for/let/converters causing tests to fail (#643)\n\nSee the full diff\n\n. - The dependency can-define was updated from 2.7.1 to 2.7.3.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\n93b0a5c 2.7.3\n1d5efeb fixes #412\n\nSee the full diff\n\n. - The dependency can-define was updated from 2.7.1 to 2.7.4.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 2 commits.\n\nfbe6b04 2.7.4\nab0a677 make sure to copy all symbols over for IE11\n\nSee the full diff\n\n. - The dependency can-stache-bindings was updated from 4.6.4 to 4.7.0.\nUpdate to this version instead \ud83d\ude80. - The dependency can-stache-bindings was updated from 4.6.4 to 4.7.1.\nUpdate to this version instead \ud83d\ude80. - The dependency can-diff was updated from 1.4.2 to 1.4.4.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 1 commits.\n\n7999f7e 1.4.4\n\nSee the full diff\n\n. - The dependency can-define was updated from 2.7.4 to 2.7.6.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 8 commits.\n\nf82cca1 2.7.6\n60fba22 Merge pull request #399 from canjs/277-includes\nbbb730c fix typo in the docs\na2b30b8 fix typo in the docs\nca4a053 add docs\ncd6b147 change the IIFE includes definition position in the code\ndf08810 Use Array.prototype.includes and warn IE11 users to add a polyfill\ne5e0465 Fixes #277. Adds 'includes' method to DefineList\n\nSee the full diff\n\n. - The dependency can-simple-dom was updated from 1.4.2 to 1.6.1.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n3477915 1.6.1\n09367dc Merge pull request #90 from canjs/reflect-href\n98d9a56 Reflect anchor's href property\n\nSee the full diff\n\n. - The dependency can-ajax was updated from 2.1.1 to 2.2.1.\nUpdate to this version instead \ud83d\ude80. - The dependency can-stache was updated from 4.15.12 to 4.15.14.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\n09ea6a2 4.15.14\n94b4913 removing debugging stuff\n1cc85ab Merge pull request #651 from canjs/650-bracket-fix\n55a1af3 fixes #650\n\nSee the full diff\n\n. - The dependency can-stache was updated from 4.15.12 to 4.16.0.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 4 commits.\n\nccda6da 4.16.0\na0ef9a4 Merge pull request #648 from canjs/portals\n6e03b1e Add clarifications to the portal docs\n02d08f0 Portals\n\nSee the full diff\n\n. - The dependency can-stache was updated from 4.16.0 to 4.17.1.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for Call partials stored in LetContext \nFixes #649, call partials stored in LetContext as call Expressions now is supported:\n{{< foo }} This is foo {{/ foo }}\n{{ let bar = scope.templateContext.partials.foo }}\n<p>{{ bar() }}</p>\n\n\n\nCommits\nThe new version differs by 3 commits.\n\n37af65f 4.17.1\n7e13620 Merge pull request #653 from canjs/649-partials-let-expressions\nf8a7887 LetContext as Call Expressions\n\nSee the full diff\n\n. - The dependency can-view-callbacks was updated from 4.3.3 to 4.3.5.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 3 commits.\n\n151ffb9 4.3.5\nacdf2ec Merge pull request #110 from canjs/cleanup-tags\n3453521 cleaning up tags before each test\n\nSee the full diff\n\n. - The dependency can-view-callbacks was updated from 4.3.3 to 4.3.6.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for using unique tag names to prevent conflicts with other tests\n#111\n\n\nCommits\nThe new version differs by 3 commits.\n\n3780724 4.3.6\n0450c6b Merge pull request #111 from canjs/fix-tag-duplication\nb877ab9 using unique tag names to prevent conflicts with other tests\n\nSee the full diff\n\n. - The dependency can-stache was updated from 4.17.5 to 4.17.7.\nUpdate to this version instead \ud83d\ude80 \n\nRelease Notes for fixing a typo in stache docs\n#664\n\n\nCommits\nThe new version differs by 3 commits.\n\n7953cd6 4.17.7\n29262ca Merge pull request #664 from canjs/fix-typo\nb759966 fixing a typo in stache docs\n\nSee the full diff\n\n. - The dependency can-stache was updated from 4.17.8 to 4.17.10.\nUpdate to this version instead \ud83d\ude80 \n\nCommits\nThe new version differs by 8 commits.\n\ne7154f9 4.17.10\nc742407 Merge pull request #642 from canjs/493-warn-when-partial-not-found\n7b533eb fix the warning message\nfad40db fix code structure\nfca7b5f change where should be fixed\n01c3746 fix jshint by removing unsed var\n6c2d39a simplifie the test\n6ada83e warn when partial is missing\n\nSee the full diff\n\n. - The dependency can-stache-bindings was updated from 4.8.0 to 4.10.0.\nUpdate to this version instead \ud83d\ude80. - The dependency can-attribute-observable was updated from 1.2.1 to 1.2.4.\nUpdate to this version instead \ud83d\ude80. ",
    "liztom": "I found this with Can 2.3. Should I still move it to can-stache?. ",
    "nmasilva": "Hi Justin, \nIs the make-model-year migrated to the canjs 3 ?\nThanks,\nNuno Silva. Can't find the complete example source with the stache files and etc\nI've added a post on the forum:\nhttp://forums.donejs.com/t/canjs-3-change-select-box-data-source/604. ",
    "Sinjhin": "@justinbmeyer Another example that came up for me today and seems to be totally undocumented.\nThe events prop of a component apparently is a can-control and has an off() that is nowhere in the docs?. This is fixed with #3439 . This is actually fixed with can-view-scope version 3.3.1.\nReferenced PR is going away.. Tests are passing in master now.. Main tests that were added:\n- [x] require('can-connect-ndjson/test/can-connect-ndjson-test');\n- [x] require('can-ndjson-stream/can-ndjson-stream-test');\n- [x] require('can-connect-ndjson/test/can-connect-ndjson-test'); (Not there anymore?)\n- [x] require('can-ndjson-stream/can-ndjson-stream-test'); (Was added twice)\n- [x] require('can-reflect/can-reflect-test');\n- [x] require('can-symbol/can-symbol-test');\n- [X] System.import('can-connect/test/test');\nEcosystems Added:\n- [x] require(\"can-connect-ndjson\");\n- [x] require(\"can-ndjson-stream\");. Updates since 3.9.1\n- [x] \"can-attribute-encoder\": \"^0.3.0\" <- New package\n- [x] \"can-component\": \"3.3.3\"\n- [x] \"can-compute\": \"3.3.3\" <- Console fixed and works in IE 9\n- [x] \"can-connect\": \"1.5.7\" <- Console fixed and works in IE 9\n- [x] \"can-control\": \"3.2.2\"\n- [x] \"can-define\": \"1.4.2\" <- Fixed and now works in IE9\n- [x] \"can-ejs\": \"3.1.4\"\n- [x] \"can-event\": \"3.7.0\" <- Console fixed and works in IE 9\n- [x] \"can-map\": \"3.3.3\"\n- [x] \"can-observation\": \"3.3.4\" <- Console fixed and works in IE 9\n- [x] \"can-stache\": \"3.6.0\"\n- [x] \"can-stache-bindings\": \"3.7.0\" <- Fixed and now works with IE9\n- [x] \"can-stache-key\": \"0.1.0\" <- New package\n- [x] \"can-util\": \"3.9.9\" <- Updated to work with IE 10\n- [x] \"can-vdom\": \"3.2.0\" <- New package\n- [x] \"can-view-autorender\": \"3.1.1\"\n- [x] \"can-view-parser\": \"3.5.0\"\n- [x] \"can-view-scope\": \"3.3.5\"\n- [x] \"funcunit\": \"^3.4.2\"\n- [x] \"qunitjs\": \"^2.4.0\" <- New package. Closes https://github.com/canjs/canjs/issues/3657. This is closed and CanJS 3.12.0 is released. These are all closed with versions 2.0.0 - 2.0.4 of can-migrate\nA new issue has been created for lack of implicit scope walking https://github.com/canjs/can-migrate/issues/72. Here is a gif to use for showing can-migrate:\n\n. ",
    "morrme": "@chasenlehara Can I help with this?. @chasenlehara Thanks! Should the quotes around \"beforeremove\" remain? . @phillipskevin I am new to your codebase. What would need to be done to resolve this? Would references to the prior script need to be changed to a script in the repo you linked? . @chasenlehara thanks!. @phillipskevin  Yes, I'd been working on it offline and was stuck on something until @chasenlehara shared that other example. Sorry for the delay! I see you've taken care of it.. @phillipskevin totally understand. i definitely hope to be able to contribute again soon! i'm newish to github and it's really cool to support a local company here!. ",
    "sszabolcs": "Yes, all Ajax requests end with status 200. In the example - JS Bin - the request is handled with a fixture and it ends with success, too.. Here I include another version of this code, where I'm using can.Model. The problem looks alike. Maybe it can help hunting down the root cause: JS Bin\nAnd here is a screenshot for the leak with this version of code: . @justinbmeyer Hi! Did you make some progress in resolving this issue?. Ok, thanks for the info.. @phillipskevin Thanks a lot! I'll test it!. @phillipskevin I've tested the fix. I don't know how but it seems to me that the leak is still there.\nHere I have a test code:\nplaycode.io\nThis time I used playcode.io because there is possible to include multiple in-the-place-edited js files and so I can have a custom CanJS build included and edited very easily and quickly. The custom CanJS build is an up-to-date CanJS 3.5.1 build. I've updated all the can* packages to the latest stable version so I have no outdated npm can package, but the leak is still there:\n\nCould you please check it? Thanks!. @phillipskevin Ok, thanks!. @phillipskevin Thank you for your work! The leak has gone in the playcode example.\nWhen I merged the updated CanJS libs in to our app I sadly realized that there is another leak...\nI've successfully narrowed down the cause of the problem.\nHere is an example: playcode.io\nIf I remove the following snippet from the app.html in the 11th row:\n{{#if data}}data-filter=\"{{data}}\"{{/if}}\nthe leak disappears.\nDo you have any idea what's wrong with this?\nThanks!. @phillipskevin Thank you! The fix is correct this leak has disappeared.\nI know you hate me but I've found another one... :cry:\nHere I made an example for you. Reproduction steps are the same as in the earlier samples. Click on \"Create new foo\" then on \"Cancel\" and create snapshots:\n\n. @phillipskevin Did you have time to work on this? Thanks!. @phillipskevin I'm still seeing it. I did the following steps:\n1. installed a new can@3.8.1 package\n2. built a custom CanJS js file based on this legacy.js:\nvar can = require('can-util/namespace');\n    require('can-component');\n    require('can-route');\n    require('can-stache');\n    require('can-stache-bindings');\n    require('can-stache-converters');\n    require('can-compute');\n    require('can-event');\n    require('can-view-model');\n    require('can-connect/can/map/map');\n    require('can-define/map/map');\n    require('can-define/list/list');\n    require('can-fixture');\n    require('can-map');\n    require('can-list');\n    require('can-map-backup');\n    require('can-map-define');\n    require('can-connect/can/model/model');\n    require('can-jquery');\n    can.view.attr = can.view.callbacks.attr;\n    can.view.tag = can.view.callbacks.tag;\n    module.exports = can;\n3. created a 2nd version of the sample code with the freshly built can.custom.js\n4. took a heap snapshot\n5. clicked 'Create new foo', then 'Cancel'\n6. took a heap snapshot\n7. clicked 'Create new foo', then 'Cancel'\n8. took a heap snapshot\n9. analyzed 'Objects allocated between Snapshot 1 and Snapshot 2'\n10. found for example three HTMLOptionElement which were not garbage collected:\n\nWhat do you think?. And here is a JSBin with the same code in case playcode.io would do anything nasty.. @phillipskevin I think we are a little bit closer: I've created a new version of the sample where the only modification in JS is that I use can.DefineMap for the FooEditorComponentVM instead of can.Map and there is NO LEAK! So the problem is somewhere in can.Map.. ",
    "GeneralMeow": "should i get rid of my fix for #3117 ? doesn't seem to be passing the tests. Thank you so much for the feedback. I will incorporate it and get the PR updated!. should i add .call on all the other String.prototype.trim functions as well?. ",
    "dtomack": "@chasenlehara Thanks for the feedback.  I've created a PR for the main branch of code.  What do I need to do to address this for 2.3? We currently are using the 2.3 code.  Thanks.. @chasenlehara Thanks!  I've gone ahead and created a PR for 2.3-legacy.  What else do I need to do to shepherd this along? (Other than, obviously, correcting anything I get feedback about).\nThank you.. ",
    "jbsulli": "I'm new to donejs but saw this and wanted to throw my thoughts out there as a Pug.js lover (hope you guys don't mind):\nWhat Pug brings to the table for me:\n1) Uses JavaScript expressions for binding\nBinding syntax will be more familiar to JavaScript devs.\n2) Consistency when it comes to formatting and indentation\nQuickly jump into other people's templates without beautifying.\n3) No closing tags\nSo no more missing or mismatched closing tags.\n4) All the important bits are emphasized\nIds, classes, conditionals, etc are easy to pick out and digest with a quick glance.\n5) Comments!!! So easy!\nMarkup taken from the donejs in-depth guide:\n```handlebars\n\n\nRestaurants\n\n\nState\n\n        {{#if states.isPending}}\n          Loading...\n        {{else}}\n          {{^if state}}\n          Choose a state\n          {{/if}}\n          {{#each states.value}}\n          {{name}}\n          {{/each}}\n        {{/if}}\n      \n\n\nCity\n\n        {{#if cities.isPending}}\n          Loading...\n        {{else}}\n          {{^if city}}\n          Choose a city\n          {{/if}}\n          {{#each cities.value}}\n          {{name}}\n          {{/each}}\n        {{/if}}\n      \n\n\n\n  ...\n```\n\nWould look something like this in Pug:\n```jade\n//- \n  What is going on here? \n  Let me tell you using this multi-line comment!\n  Note: the dash means this comment is removed when rendered otherwise you get an HTML comment\ncan-import can-stache/helpers/route\n\n.restaurants\n  h2.page-header Restaurants\n\n  //- state and city selection\n  form.form\n    //- state select\n    .form-group\n      label State\n      //- wait for states to be loaded\n      select(value=state disabled=states.isPending)\n        if states.isPending\n          option(value=\"\") Loading...\n        else\n          if !state\n            option(value=\"\") Choose a state\n          //- I may be misreading what is going on in donejs here...\n          each name, short in states\n            option(value=short)= name\n\n    //- city select\n    .form-group\n      label City\n      //- wait for a state to be selected\n      select(value=city disabled=!state)\n        if cities.isPending\n          option(value=\"\") Loading...\n        else\n          if !city\n            option(value=\"\") Choose a city\n          //- I may be misreading what is going on in donejs here...\n          each name in cities\n            option(value=name) name\n```\n\nI can agree with @rjgotten that there is a learning curve and source doesn't look like output but it is my understanding that this would be an alternative to stache and not a replacement?\n\n**Closing thoughts:** It looks popular according to [js.libhunt.com](https://js.libhunt.com/categories/13-templating-engines) and [slant.co](https://www.slant.co/topics/51/~best-javascript-templating-engines) and some positive things to say from [colorlib](https://colorlib.com/wp/top-templating-engines-for-javascript/)..",
    "ypanyukov": "http://v2.canjs.com/release/2.3.30/can.jquery.js\nhttp://v2.canjs.com/release/2.3.31/can.jquery.js\nFor last 2 url does not match library.\nhttp://v2.canjs.com/release/2.3.30/can.jquery.js - 2.3.29\nhttp://v2.canjs.com/release/2.3.31/can.jquery.js - 2.3.30\nPlease double check!. ok. ",
    "paul321": "Yes my control is creating the component via template, so we have a control like this one \n```\ndefine([\n    'can'\n], function(can) {\n    return can.Control.extend({\n        defaults: new can.Map({\n        })\n    }, {\n        init: function() {\n        },\n    'button click':function(el, ev) {\n        //need to access the component scope here\n    }\n});\n\n});\n```\nand we need to access the component values in the button click function. Maybe you can give us some hints?\nI was trying with {^} but no success maybe we did something wrong\nThanks. In the first example, we might have more components with the same tag in the same file which might be the problem, we are using mustache files to load the templates we do not use templates defined within a script tag. I don't really understand the following lines\n```\nvar componentRenderer = can.stache.from(\"demo-control-template\");\nthis.element.appendChild(\n      componentRenderer(this.options.componentScope)\n);\n```\nCan we use the component like this?\n```\n  \n\n<button>Click Me</button>\n\n\n```. Ok i've got it working in our app, thank you we use the second example because it's better.\nAnother question if i have an attribute in this.options called dropdown can i have a method in the controller so we can observe if a property is changed or updated by a component?\n'{dropdown} change': function() {\n}. Thanks a lot Mick for the help \ud83d\udc4d . if i have this case:\nvar DemoControl = can.Control.extend({\n  defaults: {\n    componentValue: 1;\n  }\n}, {\n/* ... */\n}\nCan i listen to changes on componentValue in my control without doing the following?\nthis.options.on('componentValue', function(ev, newVal, oldVal) {\n  console.log('something changed');\n});\ni wold prefer something like \n'{componentValue} change': function() {...}. Yes, but i don't want to create another can.Map in the options, i'll use this.options.on(....\nI'm closing this one. ",
    "UselessPickles": "@phillipskevin If you look at the implementation of can.batch.after and can.batch.stop, it's pretty clear that there is intent to support registering callbacks on a batch that is currently the dispatchingBatch. I looked at some older versions of the code (can't remember what versions now) and found that this is a regression. Older code used to do var callbacks = batch.callbacks inside the while loop, then execute the callbacks for that batch at the end of the while loop (but still inside). Whenever the code was changed to gather up callbacks from ALL batches and execute all callbacks AFTER the while loop, that's when this bug was introduced.\nExplaining why I'm using can.batch.after probably won't improve the understanding of this specific problem, but it may reveal another problem that should be separately reported. Here goes...\nBasically, I ran into a situation where I update a Map's attribute within the change handler of another attribute, then immediately call a method that ends up reading the value of the attribute I just changed. The read value of that changed attribute returns a stale value. The only way to read the correct value is to delay the read until after the batch is finished.\nI created a fiddle to demonstrate it (easier to understand than trying to explain in written word). Open the browser's debug console to view the logged results. Read the comments for more explanation, including 2 separate changes (simply commenting out some lines)  that can be made to trigger the behavior to become correct. \nhttp://jsfiddle.net/n491v2xq/1/\nIt is over-simplified compared to what I am actually doing, so there are actually good reasons for what I'm doing that aren't apparent in the example.\n. I separately reported the issue that lead me to discover this can.batch.after issue: #3292. I confirmed that can v3 does NOT have this same bug.. I'm sure it's obvious, but I'm new to github and contributing to this project. I clearly am not doing something right because my simple \"move a line and add a comment\" change is failing automated tests. Looks like it's probably a discrepancy in what character(s) is used for the newline character. \nI made the change directly on github with the web-based file editor. Thought I could get away with a simple change like this without setting up a local environment, etc. \nIf someone else could get this corrected and moved through, or give me some clear guidance on what I need to do, I'd really appreciate it. This bug is currently a critical roadblock to a project that is already running behind schedule for me.. I tried running unit tests locally via \"grunt test\", but got this error:\nRunning \"testee:steal\" (testee) task\n  Fatal error: spawn D:\\DevProjects\\github\\canjs\\node_modules.bin\\phantomjs ENOENT\nAny ideas what I did wrong? This is on a windows 10 machine. I installed git, NodeJS, grunt-cli, cloned my canjs repo, checked out my \"patch-1\" branch, ran \"npm install\" and \"bower install\" in my repo directory. Am I missing a step?\nFor now I pushed my changes to see if my new unit test passes.. Also, looks like I still have some whitespace issues, probably caused by an inconsistency between using space characters or tab characters for indentation. What's the standard for this project?. Now that the tests have passed, is there any way to confirm that my new unit test actually executed? I can't find anything in the logs.. @phillipskevin All indents converted from spaces to tabs. As far as I can tell, my new unit test should be executing and is passing, but I still am not sure where to look for some sort of log that confirms that the new test in batch_test.js file specifically was executed/passed.. Is this ever going to be merged? If not, I'd like to close it to clean up my list of pending PRs.. In my case, this approach works just fine for me:\nviewModel.attr(\"data\").bind(\"value\", function() {\n        console.log(\"attr(\\'data\\').value changed\");\n    });\nDoes this problem exist also in v3?. I confirmed that this bug also exists in can v3. ",
    "ndemianc": "Cool \ud83d\udc4d . ",
    "benedyktdryl": "@chasenlehara any chance to approve and merge this one? It will allow us to use CanJS properly with modern bundlers, also it's a bug. \nThanks for your time!. Thank you!. ",
    "mikemitchel": "Proposal: wrx wrxjs.com\nSpringboarding off @matthewp & @justinbmeyer  works idea:\nwrx == works (insert road sign logo here) or WR\ud83d\udee0 ?\nSimilar branding to DoneJS and CanJS - it just Works! \nbut has the nice 3 letter extension, with an X, but the x is not just for show (ie. worx) but takes the place of 2 letters to get us down to that 3 letter extension ideal - code efficiency !\nassign-wrx\najax-wrx\nfire-wrx (what DOES this do ?!?!)\n. @justinbmeyer here's the link to the page https://github.com/canjs/canjs/blob/master/contributing.md\nIt's not using @iFrame , just the  tags\n<iframe width=\"662\" height=\"372\" src=\"https://www.youtube.com/embed/PRuueWqnpIw\" frameborder=\"0\" allowfullscreen></iframe>\nis the proper syntax @iFrame(urlToVideo). Feedback on the first section from a non-OS person:\n- [ ] Clicking a link from Overview to explore a topic further, and then coming back you lose your place, as it scrolls back to the top. Would be cool to have it keep your scroll position as you're working through the overview.\n- [ ] the overview flow image lists the View items - can-stache, can-component, can-stache-bindings, but the text explains them - can-stache, can-stache-bindings, can-component. I think this stuck out to me because line 214 of the overview.md file says The final core view library is can-component. next to zoomed in image that shows it second. . I voted for this mostly for this reason\n```\nCanJS has a lot of powerful tools around data modeling - real-time, caching, \"instance awareness\".\nBut these tools are underutilized for probably two reasons:\nLack of awareness of how they work, and what they do.\n. I like the `helper` approach (`{{# diff( item of items ) }}`) especially for nested iterations, as the syntax is so familiar.\n{{# diff( item of items ) }}\n  \n   {{# diff( detail of item.details ) }}\n       \n      {{# diff( nuance of detail.nuances ) }}\n          \n```. ",
    "lgh5018": "yes!\nubuntu@ubuntu-xenial:/vagrant/ttt/cc$ ll\ntotal 15\ndrwxrwxrwx 1 ubuntu ubuntu 4096 Sep 24 00:34 ./\ndrwxrwxrwx 1 ubuntu ubuntu 4096 Sep 23 16:11 ../\n-rwxrwxrwx 1 ubuntu ubuntu   42 Sep 23 16:27 a.js\n-rwxrwxrwx 1 ubuntu ubuntu    0 Sep 23 16:15 bundle.js\n-rwxrwxrwx 1 ubuntu ubuntu  236 Sep 23 09:34 index.html\n-rwxrwxrwx 1 ubuntu ubuntu   39 Sep 23 16:51 main.js\n-rwxrwxrwx 1 ubuntu ubuntu   31 Sep 23 14:22 main.stache\ndrwxrwxrwx 1 ubuntu ubuntu 4096 Sep 23 16:33 node_modules/\n-rwxrwxrwx 1 ubuntu ubuntu   58 Sep 23 16:33 package.json\nubuntu@ubuntu-xenial:/vagrant/ttt/cc$ cat package.json\n{\n  \"dependencies\": {\n    \"can-make-rest\": \"^0.1.1\"\n  }\n}\nubuntu@ubuntu-xenial:/vagrant/ttt/cc$ cat a.js\nvar makeRest = require('can-make-rest');\nubuntu@ubuntu-xenial:/vagrant/ttt/cc$. yes!\n===================================\nubuntu@ubuntu-xenial:/vagrant/ttt/cc$ ll\ntotal 15\ndrwxrwxrwx 1 ubuntu ubuntu 4096 Sep 24 00:34 ./\ndrwxrwxrwx 1 ubuntu ubuntu 4096 Sep 23 16:11 ../\n-rwxrwxrwx 1 ubuntu ubuntu   42 Sep 23 16:27 a.js\n-rwxrwxrwx 1 ubuntu ubuntu    0 Sep 23 16:15 bundle.js\n-rwxrwxrwx 1 ubuntu ubuntu  236 Sep 23 09:34 index.html\n-rwxrwxrwx 1 ubuntu ubuntu   39 Sep 23 16:51 main.js\n-rwxrwxrwx 1 ubuntu ubuntu   31 Sep 23 14:22 main.stache\ndrwxrwxrwx 1 ubuntu ubuntu 4096 Sep 23 16:33 node_modules/\n-rwxrwxrwx 1 ubuntu ubuntu   58 Sep 23 16:33 package.json\nubuntu@ubuntu-xenial:/vagrant/ttt/cc$ cat package.json\n{\n  \"dependencies\": {\n    \"can-make-rest\": \"^0.1.1\"\n  }\n}\nubuntu@ubuntu-xenial:/vagrant/ttt/cc$ cat a.js\nvar makeRest = require('can-make-rest');\nubuntu@ubuntu-xenial:/vagrant/ttt/cc$. ",
    "haestflod": "Tested in Webstorm 2017.3.4\ncan-stache version 4.2.0\ncan-define version 2.0.3\nTest code:\n```\nimport DefineMap from 'can-define/map/map';\nimport stache from 'can-stache';\nimport rawTemplate from 'raw-loader!./main.stache';\nvar data = new DefineMap({message: \"Hello World!!\"});\nvar template = stache(rawTemplate);\ndocument.body.appendChild(template(data));\n```\nResult\nNo intellisense if I do stache(\nstache. yielded 4 suggestions: async, from, registerPartial, safeString \nThere is intellisense for DefineMap \n\n. ",
    "soultrue": "We are using canjs 1.3 version. We can\u2019t update it to latest version due to\nsome reason. User reported basically in chrome browser. We are using Akamai\nto load the resources. We are using Steeljs for loading.\nI check some articles and some users suggested that if we add some random\nstring after the requested file path, will always get uncached file. Is\nthat true?if yes, how can we do the same for mustache file load while using\nsteeljs as dependency loader. As per my understanding, it is something\nrelated to cache as after removing the browser cache, it\u2019s again started\nworking.\nSorry, I cannot share the code and screen as it is Client site.\nOn Sun, Feb 4, 2018 at 11:07 AM Justin Meyer notifications@github.com\nwrote:\n\nI\u2019m not sure what the issue is. What version of canjs are you using? What\nbrowser does this happen in? Only old versions of canjs old templates. Is\nit canjs loading the template or something else (like steal)?\n\u2014\nYou are receiving this because you authored the thread.\nReply to this email directly, view it on GitHub\nhttps://github.com/canjs/canjs/issues/3920#issuecomment-362922407, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/Ae8C6TBivsv_nJLdOuUblJT2ia4HPXR5ks5tRePbgaJpZM4R4oJW\n.\n. It's Ok. I am attaching herewith my steal.js file. Could you please help me\nto add a code in stealjs(old vesion 3.3) so that it dynamically add some\nstring after the file path of all mustache file while loading?\n\nfor example:\npath/folder/test.mustache\nChange To:\npath/folder/test.mustache?timesamp\nOn Sun, Feb 4, 2018 at 3:04 PM, Justin Meyer notifications@github.com\nwrote:\n\n@soultrue https://github.com/soultrue Unfortunately, I don't know what\nthe issue could be. Can you recreate it in a small example app and share\nthat with me?\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\nhttps://github.com/canjs/canjs/issues/3920#issuecomment-362939507, or mute\nthe thread\nhttps://github.com/notifications/unsubscribe-auth/Ae8C6bUZxbb8vBJFqdHGpdsdO7ZoD5f_ks5tRhtggaJpZM4R4oJW\n.\n\n\n// steal is a resource loader for JavaScript.  It is broken into the following parts:\n//\n// - Helpers - basic utility methods used internally\n// - AOP - aspect oriented code helpers\n// - Deferred - a minimal deferred implementation\n// - Uri - methods for dealing with urls\n// - Api - steal's API\n// - Module - an object that represents a resource that is loaded and run and has dependencies.\n// - Type - a type systems used to load and run different types of resources\n// - Packages -  used to define packages\n// - Extensions - makes steal pre-load a type based on an extension (ex: .coffee)\n// - Mapping - configures steal to load resources in a different location\n// - Startup - startup code\n// - jQuery - code to make jQuery's readWait work\n// - Error Handling - detect scripts failing to load\n// - Has option - used to specify that one resources contains multiple other resources\n// - Window Load - API for knowing when the window has loaded and all scripts have loaded\n// - Interactive - Code for IE\n// - Options -\n(function( undefined ) {\nvar requestFactory = function() {\n    return h.win.ActiveXObject ? new ActiveXObject(\"Microsoft.XMLHTTP\") : new XMLHttpRequest();\n};\n\n// ## Helpers ##\n// The following are a list of helper methods used internally to steal\nvar h = {\n\n// check that we have a document,\n        win : (function(){ return this }).call(null),\n        // a jQuery-like $.each\n        each: function( o, cb ) {\n            var i, len;\n        // weak array detection, but we only use this internally so don't\n        // pass it weird stuff\n        if ( typeof o.length == 'number' ) {\n            for ( i = 0, len = o.length; i < len; i++ ) {\n                cb.call(o[i], i, o[i], o)\n            }\n        } else {\n            for ( i in o ) {\n                if(o.hasOwnProperty(i)){\n                    cb.call(o[i], i, o[i], o)\n                }\n\n            }\n        }\n        return o;\n    },\n    // adds the item to the array only if it doesn't currently exist\n    uniquePush: function(arr, item){\n        if( h.inArray(arr, item) === -1 ){\n            return arr.push(item)\n        }\n    },\n    // if o is a string\n    isString: function( o ) {\n        return typeof o == \"string\";\n    },\n    // if o is a function\n    isFn: function( o ) {\n        return typeof o == \"function\";\n    },\n    // dummy function\n    noop: function() {},\n    endsInSlashRegex: /\\/$/,\n    // creates an element\n    createElement: function( nodeName ) {\n        return h.doc.createElement(nodeName)\n    },\n    // creates a script tag\n    scriptTag: function() {\n        var start = h.createElement(\"script\");\n        start.type = \"text/javascript\";\n        return start;\n    },\n    // minify-able verstion of getElementsByTagName\n    getElementsByTagName: function( tag ) {\n        return h.doc.getElementsByTagName(tag);\n    },\n    // A function that returns the head element\n    // creates and caches the lookup for faster\n    // performance.\n    head: function() {\n        var hd = h.getElementsByTagName(\"head\")[0];\n        if (!hd ) {\n            hd = h.createElement(\"head\");\n            h.docEl.insertBefore(hd, h.docEl.firstChild);\n        }\n        // replace head so it runs fast next time.\n        h.head = function() {\n            return hd;\n        }\n        return hd;\n    },\n    // extends one object with another\n    extend: function( d, s ) {\n        // only extend if we have something to extend\n        s && h.each(s, function( k ) {\n            if(s.hasOwnProperty(k)){\n                d[k] = s[k];\n            }\n        });\n        return d;\n    },\n    // makes an array of things, or a mapping of things\n    map: function( args, cb ) {\n        var arr = [];\n        h.each(args, function( i, str ) {\n            arr.push(cb ? (h.isString(cb) ? str[cb] : cb.call(str, str)) : str)\n        });\n        return arr;\n    },\n    // ## AOP ##\n    // Aspect oriented programming helper methods are used to\n    // weave in functionality into steal's API.\n    // calls `before` before `f` is called.\n    //     steal.complete = before(steal.complete, f)\n    // `changeArgs=true` makes before return the same args\n    before: function(f, before, changeArgs) {\n        return changeArgs ?\n            function before_changeArgs() {\n                return f.apply(this, before.apply(this, arguments));\n            } : function before_args() {\n            before.apply(this, arguments);\n            return f.apply(this, arguments);\n        }\n    },\n    // returns a function that calls `after`\n    // after `f`\n    after: function(f, after, changeRet) {\n        return changeRet ?\n            function after_CRet() {\n                return after.apply(this, [f.apply(this, arguments)].concat(h.map(arguments)));\n            } : function after_Ret() {\n            var ret = f.apply(this, arguments);\n            after.apply(this, arguments);\n            return ret;\n        }\n    },\n    /**\n     * Performs an XHR request\n     * @param {Object} options\n     * @param {Function} success\n     * @param {Function} error\n     */\n    request: function( options, success, error ) {\n        var request = new requestFactory(),\n            contentType = (options.contentType || \"application/x-www-form-urlencoded; charset=utf-8\"),\n            clean = function() {\n                request = check = clean = null;\n            },\n            check = function() {\n                var status;\n                if ( request && request.readyState === 4 ) {\n                    status = request.status;\n                    if ( status === 500 || status === 404 || status === 2 || request.status < 0 || (!status && request.responseText === \"\") ) {\n                        error && error(request.status);\n                    } else {\n                        success(request.responseText);\n                    }\n                    clean();\n                }\n            };\n        request.open(\"GET\", options.src + '', !(options.async === false));\n        request.setRequestHeader(\"Content-type\", contentType);\n        if ( request.overrideMimeType ) {\n            request.overrideMimeType(contentType);\n        }\n\n        request.onreadystatechange = check;\n        try {\n            request.send(null);\n        }\n        catch (e) {\n            if ( clean ) {\n                console.error(e);\n                error && error();\n                clean();\n            }\n        }\n    },\n    matchesId : function( loc, id ) {\n        if ( loc === \"*\" ) {\n            return true;\n        } else if ( id.indexOf(loc) === 0 ) {\n            return true;\n        }\n    },\n    // are we in production\n    stealCheck : /steal\\.(production\\.)?js.*/,\n    // get script that loaded steal\n    getStealScriptSrc : function() {\n        if (!h.doc ) {\n            return;\n        }\n        var scripts = h.getElementsByTagName(\"script\"),\n            script;\n\n        // find the steal script and setup initial paths.\n        h.each(scripts, function( i, s ) {\n            if ( h.stealCheck.test(s.src) ) {\n                script = s;\n            }\n        });\n        return script;\n    },\n    inArray : function( arr, val ){\n        for(var i = 0; i < arr.length; i++){\n            if(arr[i] === val){\n                return i;\n            }\n        }\n        return -1;\n    },\n    addEvent : function( elem, type, fn ) {\n        if ( elem.addEventListener ) {\n            elem.addEventListener(type, fn, false);\n        } else if ( elem.attachEvent ) {\n            elem.attachEvent(\"on\" + type, fn);\n        } else {\n            fn();\n        }\n    },\n    useIEShim : false\n}\n\nh.doc   = h.win.document;\nh.docEl = h.doc && h.doc.documentElement;\n\nh.support = {\n    // does onerror work in script tags?\n    error: h.doc && (function() {\n        var script = h.scriptTag();\n        script.onerror = h.noop;\n        return h.isFn(script.onerror) || \"onerror\" in script;\n    })(),\n    // If scripts support interactive ready state.\n    // This is tested later.\n    interactive: false,\n    // use attachEvent for event listening (IE)\n    attachEvent: h.doc && h.scriptTag().attachEvent\n}\n\n// steal's deferred library. It is used through steal\n\n// to support jQuery like API for file loading.\nvar Deferred = function( func ) {\n    if (!(this instanceof Deferred)) return new Deferred();\n    // arrays for `done` and `fail` callbacks\n    this.doneFuncs = [];\n    this.failFuncs = [];\n\n    this.resultArgs = null;\n    this.status = \"\";\n\n    // check for option function: call it with this as context and as first\n    // parameter, as specified in jQuery api\n    func && func.call(this, this);\n}\n\nDeferred.when = function() {\n    var args = h.map(arguments);\n    if ( args.length < 2 ) {\n        var obj = args[0];\n        if ( obj && (h.isFn(obj.isResolved) && h.isFn(obj.isRejected)) ) {\n            return obj;\n        } else {\n            return Deferred().resolve(obj);\n        }\n    } else {\n\n        var df = Deferred(),\n            done = 0,\n        // resolve params: params of each resolve, we need to track down\n        // them to be able to pass them in the correct order if the master\n        // needs to be resolved\n            rp = [];\n\n        h.each(args, function( j, arg ) {\n            arg.done(function() {\n                rp[j] = (arguments.length < 2) ? arguments[0] : arguments;\n                if (++done == args.length ) {\n                    df.resolve.apply(df, rp);\n                }\n            }).fail(function() {\n                df.reject(arguments);\n            });\n        });\n\n        return df;\n\n    }\n}\n\n// call resolve functions\n    var resolveFunc = function( type, status ) {\n            return function( context ) {\n                var args = this.resultArgs = (arguments.length > 1) ? arguments[1] : [];\n                return this.exec(context, this[type], args, status);\n            }\n        },\n    doneFunc = function( type, status ) {\n        return function() {\n            var self = this;\n            h.each(arguments, function( i, v, args ) {\n                if (!v ) return;\n                if ( v.constructor === Array ) {\n                    args.callee.apply(self, v)\n                } else {\n                    // immediately call the function if the deferred has been resolved\n                    if ( self.status === status ) v.apply(this, self.resultArgs || []);\n\n                    self[type].push(v);\n                }\n            });\n            return this;\n        }\n    };\n\nh.extend(Deferred.prototype, {\n    resolveWith: resolveFunc(\"doneFuncs\", \"rs\"),\n    rejectWith: resolveFunc(\"failFuncs\", \"rj\"),\n    done: doneFunc(\"doneFuncs\", \"rs\"),\n    fail: doneFunc(\"failFuncs\", \"rj\"),\n    always: function() {\n        var args = h.map(arguments);\n        if ( args.length && args[0] ) this.done(args[0]).fail(args[0]);\n\n        return this;\n    },\n    then: function() {\n        var args = h.map(arguments);\n        // fail function(s)\n        if ( args.length > 1 && args[1] ) this.fail(args[1]);\n\n        // done function(s)\n        if ( args.length && args[0] ) this.done(args[0]);\n\n        return this;\n    },\n    isResolved: function() {\n        return this.status === \"rs\";\n    },\n    isRejected: function() {\n        return this.status === \"rj\";\n    },\n    reject: function() {\n        return this.rejectWith(this, arguments);\n    },\n    resolve: function() {\n        return this.resolveWith(this, arguments);\n    },\n    exec: function( context, dst, args, st ) {\n        if ( this.status !== \"\" ) return this;\n\n        this.status = st;\n\n        h.each(dst, function( i, d ) {\n            d.apply(context, args);\n        });\n\n        return this;\n    }\n});\n\n// ## HELPER METHODS FOR DEFERREDS\n// Used to call a method on an object or resolve a\n// deferred on it when a group of deferreds is resolved.\n//\n//     whenEach(resources,\"complete\",resource,\"execute\")\n    var whenEach = function( arr, func, obj, func2 ) {\n    var deferreds = h.map(arr, func)\n    return Deferred.when.apply(Deferred, deferreds).then(function() {\n        if ( h.isFn(obj[func2]) ) {\n            obj[func2]()\n        } else {\n            obj[func2].resolve();\n        }\n\n    });\n};\n\n// ## URI ##\n/**\n * @class steal.URI\n * @parent steal\n *\n * A URL / URI helper for getting information from a URL.\n *\n *     var uri = URI( \"http://stealjs.com/index.html\" )\n *     uri.path //-> \"/index.html\"\n */\n\nvar URI = function( url ) {\n    if ( this.constructor !== URI ) {\n        return new URI(url);\n    }\n    h.extend(this, URI.parse(\"\" + url));\n};\n\n// the current url (relative to root, which is relative from page)\n// normalize joins from this\n//\n    h.extend(URI, {\n        // parses a URI into it's basic parts\n        parse: function( string ) {\n            /\n             * @prototype\n             */\n            var uriParts = string.split(\"?\"),\n                uri = uriParts.shift(),\n                queryParts = uriParts.join(\"\").split(\"#\"),\n                protoParts = uri.split(\"://\"),\n                parts = {\n                    /\n                     * @property query\n                     \n                     * The query part of the url. Everything after the ?, but before\n                     * the #.\n                     \n                     *     var uri = URI(\"/foo?bar#zed\")\n                     *     uri.query //-> bar\n                     \n/\n                    query: queryParts.shift(),\n                    /\n                     * @property fragment\n                     \n                     *     var uri = URI(\"/foo?bar#zed\")\n                     *     uri.query //-> zed\n                     \n                     */\n                    fragment: queryParts.join(\"#\")\n                },\n                pathParts;\n        if ( protoParts[1] ) {\n            /**\n             * @property protocol\n             */\n            parts.protocol = protoParts.shift();\n            pathParts = protoParts[0].split(\"/\");\n            /**\n             * @property host\n             */\n            parts.host = pathParts.shift();\n            /**\n             * @property path\n             */\n            parts.path = \"/\" + pathParts.join(\"/\");\n        } else {\n            parts.path = protoParts[0];\n        }\n        return parts;\n    }\n});\n/**\n * @static\n */\n\n//\n    /\n     * @property page\n     * The location of the page as a URI.\n     \n     *     st.URI.page.protocol //-> \"http\"\n     /\n    URI.page = URI(h.win.location && location.href);\n    /\n     * @property cur\n     \n     * The current working directory / path.  Anything\n     * loaded relative will be loaded relative to this.\n     /\n    URI.cur = URI();\n/**\n * @prototype\n */\nh.extend(URI.prototype, {\n    /**\n     * @function\n     * @signature `dir()`\n     * Returns everything before the last `/` as a URI.\n     *\n     * @return {steal.URI}\n     */\n    dir: function() {\n        var parts = this.path.split(\"/\");\n        parts.pop();\n        return URI(this.domain() + parts.join(\"/\"))\n    },\n    /**\n     * @function\n     * @signature `filename()`\n     * Returns everything after the last `/` as a String.\n     *\n     * @return {String}\n     */\n    filename: function() {\n        return this.path.split(\"/\").pop();\n    },\n    /**\n     * @function\n     *\n     * @signature `ext()`\n     * returns everything after the last `.`.\n     *\n     * @return {String}\n     */\n    ext: function() {\n        var filename = this.filename();\n        return (filename.indexOf(\".\") > -1) ? filename.split(\".\").pop() : \"\";\n    },\n    /**\n     * @function\n     *\n     * @signature `domain()`\n     * Returns the protocol and host of the domain.\n     *\n     * return {String}\n     */\n    domain: function() {\n        return this.protocol ? this.protocol + \"://\" + this.host : \"\";\n    },\n    /**\n     * @function\n     *\n     * @signature `isCrossDomain([referenceUri])`\n     * Returns if a URI is cross domain.\n     *\n     *     var abc = URI(\"http://abc.com\")\n     *     abc.isCrossDomain() // -> true\n     *     abc.isCrossDomain( \"http://abc.com/foo\" ) //-> false\n     *\n     * @param {steal.URI} [referenceUri] An optional uri to use\n     * as the reference to return if the uri is cross domain from.\n     */\n    isCrossDomain: function( referenceUri ) {\n        referenceUri = URI(referenceUri || h.win.location.href);\n        var domain = this.domain(),\n            uriDomain = referenceUri.domain()\n        return (domain && uriDomain && domain != uriDomain) || this.protocol === \"file\" || (domain && !uriDomain);\n    },\n    /**\n     * @function\n     *\n     * @signature `isRelativeToDomain()`\n     * Returns if the uri begins with `/`.\n     *\n     * @return {Boolean}\n     */\n    isRelativeToDomain: function() {\n        return !this.path.indexOf(\"/\");\n    },\n    /**\n     * @function\n     *\n     * @signature `hash()`\n     * Returns the URI's [steal.URI::fragment fragment] with\n     * `\"#\"` preceeding it.\n     *\n     * return {String}\n     */\n    hash: function() {\n        return this.fragment ? \"#\" + this.fragment : \"\"\n    },\n    /**\n     * @function\n     *\n     * @signature `search()`\n     * Returns the URI's [steal.URI::query query] with\n     * `\"?\"` preceeding it.\n     *\n     * @return {String}\n     */\n    search: function() {\n        return this.query ? \"?\" + this.query : \"\"\n    },\n    // like join, but returns a string\n    add: function( uri ) {\n        return this.join(uri) + '';\n    },\n    /**\n     * @function\n     * @signature `join(rightUri)`\n     * Joins two uris together and return\n     * the result as a new URI.\n     *\n     *     var left = URI(\"/a/starting/place\")\n     *     var res = left.join(\"../../better/location\")\n     *     res //-> URI(\"a/better/location\")\n     *\n     */\n    join: function( uri, min ) {\n        uri = URI(uri);\n        if ( uri.isCrossDomain(this) ) {\n            return uri;\n        }\n        if ( uri.isRelativeToDomain() ) {\n            return URI(this.domain() + uri)\n        }\n        // at this point we either\n        // - have the same domain\n        // - this has a domain but uri does not\n        // - both don't have domains\n        var left = this.path ? this.path.split(\"/\") : [],\n            right = uri.path.split(\"/\"),\n            part = right[0];\n        //if we are joining from a folder like cookbook/, remove the last empty part\n        if ( this.path.match(/\\/$/) ) {\n            left.pop();\n        }\n        while ( part == \"..\" && left.length && left[left.length-1] !== \"..\") {\n            // if we've emptied out, folders, just break\n            // leaving any additional ../s\n            if (!left.pop() ) {\n                break;\n            }\n            right.shift();\n\n            part = right[0];\n        }\n        return h.extend(URI(this.domain() + left.concat(right).join(\"/\")), {\n            query: uri.query\n        });\n    },\n    /**\n     * @function\n     * For a given path, a given working directory, and file location, update the\n     * path so it points to a location relative to steal's root.\n     *\n     * We want everything relative to steal's root so the same app can work in\n     * multiple pages.\n     *\n     *     ./files/a.js = steals a.js\n     *     ./files/a = a/a.js\n     *     files/a = //files/a/a.js\n     *     files/a.js = loads //files/a.js\n     */\n    normalize: function( cur ) {\n        cur = cur ? cur.dir() : URI.cur.dir();\n        var path = this.path,\n            res = URI(path);\n        //if path is rooted from steal's root (DEPRECATED)\n        if (!path.indexOf(\"//\") ) {\n            res = URI(path.substr(2));\n        } else if (!path.indexOf(\"./\") ) { // should be relative\n            res = cur.join(path.substr(2));\n        }\n        // only if we start with ./ or have a /foo should we join from cur\n        else if ( this.isRelative() ) {\n            res = cur.join(this.domain() + path)\n        }\n        res.query = this.query;\n        return res;\n    },\n    /**\n     * @function\n     * @signature `isRelative()`\n     * Returns if the path starts with `.` or `/`.\n     *\n     * @return {Boolean}\n     */\n    isRelative: function() {\n        return /^[\\.|\\/]/.test(this.path)\n    },\n    // a min path from 2 urls that share the same domain\n    /**\n     * @function\n     * @signature `pathTo(relativeURI)`\n     * Returns a relative\n     * path from `uri` to `relativeURI`\n     *\n     *     steal.URI(\"app/controls/recipe.js\")\n     *        .pathTo(\"app/models/recipe.js\")\n     *     // -> ../../models/recipe.js\n     *\n     *     steal.URI(\"foo/bar\")\n     *        .pathTo(\"foo/bar/zed\")\n     *     //-> zed\n     *\n     * @return {steal.URI}\n     */\n    pathTo: function( uri ) {\n        uri = URI(uri);\n        var uriParts = uri.path.split(\"/\"),\n            thisParts = this.path.split(\"/\"),\n            result = [];\n        while ( uriParts.length && thisParts.length && uriParts[0] == thisParts[0] ) {\n            uriParts.shift();\n            thisParts.shift();\n        }\n        h.each(thisParts, function() {\n            result.push(\"../\")\n        })\n        return URI(result.join(\"\") + uriParts.join(\"/\"));\n    },\n    mapJoin: function( url ) {\n        return this.join(URI(url).insertMapping());\n    },\n    // helper to go from jquery to jquery/jquery.js\n    addJS: function() {\n        var ext = this.ext();\n        if ( !ext ) {\n            // if first character of path is a . or /, just load this file\n            if (!this.isRelative() ) {\n                this.path += \"/\" + this.filename();\n            }\n            this.path += \".js\"\n        }\n        return this;\n    }\n});\n\n// This can't be added to the prototype using extend because\n// then for some reason IE < 9 won't recognize it.\n    URI.prototype.toString = function() {\n        return this.domain() + this.path + this.search() + this.hash();\n    };\n//  =============================== MAPPING ===============================\n// TODO: this can likely be removed\n    URI.prototype.insertMapping = function() {\n        // go through mappings\n        var orig = \"\" + this,\n            key, value;\n        for ( key in steal.mappings ) {\n            value = steal.mappings[key]\n            if ( value.test.test(orig) ) {\n                return orig.replace(key, value.path);\n            }\n        }\n        return URI(orig);\n    };\n// --- END URI\n/*\n * @hide\n * `new ConfigManager(config)` creates configuration profile for the steal context.\n * It keeps all config parameters in the instance which allows steal to clone it's\n * context.\n *\n * config.stealConfig is tipically set up in __stealconfig.js__.  The available options are:\n *\n *  - map - map an id to another id\n *  - paths - maps an id to a file\n *  - root - the path to the \"root\" folder\n *  - env - `\"development\"` or `\"production\"`\n *  - types - processor rules for various types\n *  - ext - behavior rules for extensions\n *  - urlArgs - extra queryString arguments\n *  - startId - the file to load\n *\n * ## map\n *\n * Maps an id to another id with a certain scope of other ids. This can be\n * used to use different modules within the same id or map ids to another id.\n * Example:\n *\n *     st.config({\n *       map: {\n *         \"*\": {\n *           \"jquery/jquery.js\": \"jquery\"\n *         },\n *         \"compontent1\":{\n *           \"underscore\" : \"underscore1.2\"\n *         },\n *         \"component2\":{\n *           \"underscore\" : \"underscore1.1\"\n *         }\n *       }\n *     })\n *\n * ## paths\n *\n * Maps an id or matching ids to a url. Each mapping is specified\n * by an id or part of the id to match and what that\n * part should be replaced with.\n *\n *     st.config({\n *       paths: {\n *         // maps everything in a jquery folder like: `jquery/controller`\n *         // to http://cdn.com/jquery/controller/controller.com\n *         \"jquery/\" : \"http://cdn.com/jquery/\"\n *\n *         // if path does not end with /, it matches only that id\n *         \"jquery\" : \"https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js\"\n *       }\n *     })\n *\n * ## root\n * ## env\n *\n * If production, does not load \"ignored\" scripts and loads production script.  If development gives more warnings / errors.\n *\n * ## types\n *\n * The types option can specify how a type is loaded.\n *\n * ## ext\n *\n * The ext option specifies the default behavior if file is loaded with the\n * specified extension. For a given extension, a file that configures the type can be given or\n * an existing type. For example, for ejs:\n *\n *     st.config({ext: {\"ejs\": \"can/view/ejs/ejs.js\"}})\n *\n * This tells steal to make sure `can/view/ejs/ejs.js` is executed before any file with\n * \".ejs\" is executed.\n *\n *\n */\n\n\n\nvar ConfigManager = function(options){\n    this.stealConfig = {};\n    this.callbacks = [];\n    this.attr(ConfigManager.defaults);\n    this.attr(options)\n}\nh.extend(ConfigManager.prototype, {\n    // get or set config.stealConfig attributes\n    attr: function( config, value ) {\n        if(!config){ // called as a getter, so just return\n            return this.stealConfig;\n        }\n        if(typeof config === \"string\"){ // getter / setter\n            if(arguments.length === 1){\n                return this.stealConfig && this.stealConfig[config];\n            } else {\n                var temp = {};\n                temp[config] = value;\n                config = temp;\n            }\n        }\n        this.stealConfig = this.stealConfig || {};\n        for(var prop in config){\n            var value = config[prop];\n            // if it's a special function\n            this[prop] ?\n                // run it\n                this[prop](value) :\n                // otherwise set or extend\n                (typeof value == \"object\" && this.stealConfig[prop] ?\n                    // extend\n                    h.extend( this.stealConfig[prop], value) :\n                    // set\n                    this.stealConfig[prop] = value);\n\n        }\n\n        for(var i = 0; i < this.callbacks.length; i++){\n            this.callbacks[i](this.stealConfig)\n        }\n\n        return this;\n    },\n\n    // add callbacks which are called after config is changed\n    on: function(cb){\n        this.callbacks.push(cb)\n    },\n\n    // get the current start file\n    /**\n     * @function steal.config.startId\n     * @parent steal.config\n     *\n     * @signature `steal.config(\"startId\", startModuleId )`\n     *\n     * Configures the first file that steal loads. This is important\n     * for builds.\n     *\n     *\n     */\n    startId: function(startFile){\n        // make sure startFile and production look right\n        this.stealConfig.startId = \"\" + URI(startFile).addJS()\n        if (!this.stealConfig.productionId ) {\n            this.stealConfig.productionId = URI(this.stealConfig.startId).dir() + \"/production.js\";\n        }\n    },\n\n    /**\n     * @function steal.config.root\n     * @parent steal.config\n     *\n     * @signature `steal.config.root(\"root\", \"http://foo.com/app/files/\")`\n     *\n     * Read or define the path relative URI's should be referenced from.\n     *\n     *     window.location //-> \"http://foo.com/site/index.html\"\n     *     st.URI.root(\"http://foo.com/app/files/\")\n     *     st.root.toString() //-> \"../../app/files/\"\n     */\n    root: function( relativeURI ) {\n        if ( relativeURI !== undefined ) {\n            var root = URI(relativeURI);\n\n            // the current folder-location of the page http://foo.com/bar/card\n            var cleaned = URI.page,\n            // the absolute location or root\n                loc = cleaned.join(relativeURI);\n\n            // cur now points to the 'root' location, but from the page\n            URI.cur = loc.pathTo(cleaned)\n            this.stealConfig.root = root;\n            return this;\n        }\n        this.stealConfig.root =  root || URI(\"\");\n    },\n    //var stealConfig = configs[configContext];\n    cloneContext: function(){\n        return new ConfigManager( h.extend( {}, this.stealConfig ) );\n    }\n})\n\n// ConfigManager's defaults\n    ConfigManager.defaults = {\n        types: {},\n        /\n         * @property steal.config.ext\n         * @parent steal.config\n         \n         * @signature steal.config(\"ext\", extensionConfig)\n         * Configures processing behavior of moduleId extensions. For example:\n         \n         *     steal.config(\"ext\",{\n     *       js: \"js\",\n     *       css: \"css\",\n     *       less: \"steal/less/less.js\",\n     *       mustache: \"can/view/mustache/mustache.js\"\n     *     })\n         \n         * @body\n         * extensionConfig maps a filename extension to\n         * be processed by a [steal.config.types type]\n         * (like js: \"js\") or to a dependency moduleId that\n         * defines that type (like less: \"steal/less/less.js\").\n         \n         */\n        ext: {},\n        /\n         * @property steal.config.env\n         * @parent steal.config\n         \n         * @signature steal.config(\"env\", environment )\n         * Configures steal's environment to either:\n         \n         *  - 'development' - loads all modules seperately\n         *  - 'production' - load modules in minified production scripts and styles.\n         \n         * @body\n         * ## Setting Env\n         \n         * Typically, changing the environment is done by changing\n         * steal/steal.js to steal/steal.production.js like:\n         \n         *     \n         *     \n\n         * It can also be set in the queryparams like:\n         \n         *     \n         *     \n\n         * Or set before steal is loaded like:\n         \n         *     \n         *     steal = {env: \"production\"}\n         *     \n         *     \n         *     \n\n         * Of course, it can also be set in stealconfig.js, but you\n         * probably shouldn't.\n         \n\n/\n        env: \"development\",\n        /\n         * @property steal.config.loadProduction\n         * @parent steal.config\n         \n         * @signature steal.config(\"loadProduction\",loadProduction)\n         * Tells steal to load [steal.config.productionId productionId] when\n         * [steal.config.env env] is \"production\". It's true\n         * by default.\n         \n         * steal.config(\"loadProduction\",false) is used when steal is\n         * bundled with the production script.\n         \n/\n        loadProduction: true,\n        logLevel: 0,\n        root: \"\",\n        /\n         * @property steal.config.amd\n         * @parent steal.config\n         \n         * @signature steal.config(\"amd\",true)\n         * Turns on steal's AMD support. This needs\n         * to be configured before steal loads like:\n         \n         *     \n         *     steal = {amd: true}\n         *     \n         *     \n         *     \n\n         * This lets you use define([id], [deps...], definition) and\n         * require([deps], definition).\n         /\n        amd: false\n        /\n         * @property steal.config.map\n         * @parent steal.config\n         \n         * @signature steal.config( \"map\", mapConfig )\n         * Maps moduleIds to other moduleIds when stolen\n         * in a particular location.\n         \n         * The following maps jquery/jquery.js to\n         * jquery-1.8.3.js in filemanager and\n         * jquery/jquery.js to jquery-1.4.2.js in\n         * taskmanager:\n         \n         *     steal.config({\n     *       maps: {\n     *         filemanager: {\n     *           \"jquery/jquery.js\": \"jquery-1.8.3.js\"\n     *         },\n     *         taskmanager: {\n     *           \"jquery/jquery.js\": \"jquery-1.4.2.js\"\n     *         }\n     *       }\n     *     });\n         \n         * In filemanager/filemanager.js:\n         \n         *     steal('jquery')\n         \n         * ... will load jquery-1.8.3.js. To configure the location of\n         * jquery-1.8.3.js, use [steal.config.paths].\n         \n         * To map ids within any location, use \"\":\n         \n         *     steal.config({\n     *       maps: {\n     *         \"\": {\n     *           \"jquery/jquery.js\": \"jquery-1.8.3.js\"\n     *         }\n     *       }\n     *     });\n         \n         * ## mapConfig\n         \n         * mapConfig is a map of a \"require-er\" moduleId\n         * to a mapping of ids like:\n         \n         *     {\n     *        \"require-er\" : {requiredId: moduleId}\n     *     }\n         \n         * where:\n         \n         *   - require-er is a moduleId or folderId where the requiredId\n         *     is stolen.\n         *   - requiredId is the id returned by [steal.id].\n         *   - moduleId is the moduleId that will be retrieved.\n         /\n        //\n        /\n         * @property steal.config.paths\n         * @parent steal.config\n         \n         * @signature steal.config( \"paths\", pathConfig )\n         * Maps moduleIds to paths.  This is used to\n         * override [steal.idToUri]. Often, this can be used to\n         * specify loading from a CDN like:\n         \n         *     steal.config({\n     *       paths: {\n     *         \"jquery\" : \"http://cdn.google.com/jquery\"\n     *       }\n     *     });\n         \n         * To keep loading jQuery in production from the CDN, use\n         * [steal.config.shim] and set the \"exclude\" option.\n         /\n        //\n        /\n         * @property steal.config.productionId\n         * @parent steal.config\n         \n         * @signature steal.config(\"productionId\", productionid )\n         * Configures the id to load the production package. It defaults\n         * to replacing [steal.config.startId]\n         * with \"production.js\". For example,\n         * myapp/myapp.js becomes myapp/production.js.\n         \n         * The best way to configure productionId is\n         * with a steal object before steal.js is loaded:\n         \n         *     \n         *     steal = {productionId: \"myapp/myapp.production.js\"}\n         *     \n         *     \n         *     \n\n         * If you change productionId, make sure you change\n         * your build script.\n         */\n        //\n        /\n         * @property steal.config.completed\n         * @parent steal.config\n         \n         * @signature steal.config(\"completed\", completedIds)\n         * Marks the modules represented by completedIds as\n         * completed (already loaded and run).\n         \n         * The following can be used to indicate that\n         * production.css has already been loaded and run:\n         \n         *     \n         *     \n         *     steal = {completed: [\"myapp/production.css\"]}\n         *     \n         *     \n         *     \n\n/\n        // code in core.js w/i config.on callback\n    };\n// ### TYPES ##\n/**\n * @function steal.config.types\n * @parent steal.config\n *\n * `steal.config(\"types\",types)` registers alternative types. The\n * `types` object is a mapping of a `type path` to\n * a `type converter`. For example, the following creates a \"coffee\" type\n * that converts a [CoffeeScript](http://jashkenas.github.com/coffee-script/)\n * file to JavaScript:\n *\n *     steal.config(\"types\",{\n\n\n\"coffee js\": function(options, success, error){\noptions.text = CoffeeScript.compile(options.text);\nsuccess();\n}\n});\n     *\nThe type path is a list of the type to a buildType (either \"js\" or \"css\"). For example,\n\"coffee js\" means the converter converts from CoffeeScript text to\nJavaScript text.\n *\nThe type converter, converter(options, success, error), takes a [steal.Module.options Module options] updates it's text property\nto contain the text of the buildType and calls success. For example:\n *\nsteal.config(\"types\", {\n\n\n\"less css\": function(options, success, error){\nnew (less.Parser)({\noptimization: less.optimization,\npaths: []\n}).parse(options.text, function (e, root) {\noptions.text = root.toCSS();\nsuccess();\n});\n}\n});\n     *\nA type path can specify intermediate types. For example,\n *\nsteal.config(\"types\", {\n\n\n\"view js\": function(options, sucesss, error){\nreturn \"steal('can/view/\" +options.type)+\"',\"+\n\"function(){ return \"+options.text+\n\"})\"\n},\n\"ejs view js\": function(options, success, error){\nreturn new EJS(options.text).fn\n}\n});\n     *\n\nCreate your own type\n *\nHere's an example converting files of type .foo to JavaScript.  Foo is a\nfake language that saves global variables.  A .foo file might\nlook like this:\n *\nREQUIRED FOO\n *\nTo define this type, you'd call steal.config like:\n *\nsteal.config(\"types\",{\n\n\n\"foo js\": function(options, success, error){\nvar parts = options.text.split(\" \")\noptions.text = parts[0]+\"='\"+parts[1]+\"'\";\nsuccess();\n}\n});\n     *\nThe \"foo js\" method is called with the text of .foo files as options.text.\nThe method parses the text, and sets the resulting JavaScript\n\nas options.text.\n \n/\nConfigManager.prototype.types = function(types){\n    var configTypes = this.stealConfig.types || (this.stealConfig.types = {});\n    h.each(types, function( type, cb ) {\n        var typs = type.split(\" \");\n        configTypes[typs.shift()] = {\n            require: cb,\n            convert: typs\n        };\n    });\n};\nConfigManager.prototype.require = function( options, success, error) {\n    // add the src option\n    // but it is not added to functions\n    if(options.idToUri){\n        var old = options.src;\n        options.src = this.addSuffix( options.idToUri(options.id) );\n    }\n// get the type\nvar type = this.attr().types[options.type],\n    converters;\n// if this has converters, make it get the text first, then pass it to the type\nif ( type.convert.length ) {\n    converters = type.convert.slice(0);\n    converters.unshift(\"text\", options.type)\n} else {\n    converters = [options.type]\n}\nrequire(options, converters, success, error, this)\n    }\n    ConfigManager.prototype.addSuffix = function( str ) {\nvar suffix = this.attr('suffix')\nif ( suffix ) {\n    str = (str + '').indexOf('?') > -1 ? str + \"&\" + suffix : str + \"?\" + suffix;\n}\nreturn str;\n    }\n\n\n\n\n// Require function. It will be called recursevly until all\n// converters are ran. After that success callback is ran.\n// For instance if we're loading the .less file it will first\n// run the text converter, then less converter and finally\n// the fn converter.\n    function require(options, converters, success, error, config) {\n        var t = converters[0]\n        var type = config.attr('types')[converters.shift()];\n    type.require(options, function require_continue_check() {\n        // if we have more types to convert\n        if ( converters.length ) {\n            require(options, converters, success, error, config)\n        } else { // otherwise this is the final\n            success.apply(this, arguments);\n        }\n    }, error, config)\n};\n\n// =============================== TYPES ===============================\n// a clean up script that prevents memory leaks and removes the\n// script\n    var cleanUp = function( elem ) {\n            elem.onreadystatechange = elem.onload = elem.onerror = null;\n        setTimeout(function() {\n            h.head().removeChild(elem);\n        }, 1);\n    },\n// the last inserted script, needed for IE\n    lastInserted,\n// if the state is done\n    stateCheck = /^loade|c|u/;\n\n\nvar cssCount = 0,\n    createSheet = h.doc && h.doc.createStyleSheet,\n    lastSheet, lastSheetOptions;\n\n// Apply all the basic types\n    ConfigManager.defaults.types = {\n        \"js\": function( options, success, error ) {\n            // create a script tag\n            var script = h.scriptTag(),\n                callback = function() {\n                    if (!script.readyState || stateCheck.test(script.readyState) ) {\n                        cleanUp(script);\n                        success();\n                    }\n                }, errorTimeout;\n            // if we have text, just set and insert text\n            if ( options.text ) {\n                // insert\n                script.text = options.text;\n        } else {\n            var src = options.src; //st.idToUri( options.id );\n            // If we're in IE older than IE9 we need to use\n            // onreadystatechange to determine when javascript file\n            // is loaded. Unfortunately this makes it impossible to\n            // call teh error callback, because it will return\n            // loaded or completed for the script even if it\n            // encountered the 404 error\n            if(h.useIEShim){\n                script.onreadystatechange = function(){\n                    if (stateCheck.test(script.readyState)) {\n                        success();\n                    }\n                }\n            } else {\n                script.onload = callback;\n                // error handling doesn't work on firefox on the filesystem\n                if ( h.support.error && error && src.protocol !== \"file\" ) {\n                    script.onerror = error;\n                }\n            }\n\n            // listen to loaded\n            // IE will change the src property to a full domain.\n            // For example, if you set it to 'foo.js', when grabbing src it will be \"http://localhost/foo.js\".\n            // We set the id property so later references to this script will have the same path.\n            script.src = script.id = \"\" + src;\n            //script.src = options.src = addSuffix(options.src);\n            //script.async = false;\n            script.onSuccess = success;\n        }\n\n        // insert the script\n        lastInserted = script;\n        h.head().insertBefore(script, h.head().firstChild);\n\n        // if text, just call success right away, and clean up\n        if ( options.text ) {\n            callback();\n        }\n    },\n    \"fn\": function( options, success ) {\n        var ret;\n        if (!options.skipCallbacks ) {\n            ret = options.fn();\n        }\n        success(ret);\n    },\n    // request text\n    \"text\": function( options, success, error ) {\n        h.request(options, function( text ) {\n            options.text = text;\n            success(text);\n        }, error)\n    },\n    // loads css files and works around IE's 31 sheet limit\n    \"css\": function( options, success, error ) {\n        if ( options.text ) { // less\n            var css = h.createElement(\"style\");\n            css.type = \"text/css\";\n            if ( css.styleSheet ) { // IE\n                css.styleSheet.cssText = options.text;\n            } else {\n                (function( node ) {\n                    if ( css.childNodes.length ) {\n                        if ( css.firstChild.nodeValue !== node.nodeValue ) {\n                            css.replaceChild(node, css.firstChild);\n                        }\n                    } else {\n                        css.appendChild(node);\n                    }\n                })(h.doc.createTextNode(options.text));\n            }\n            h.head().appendChild(css);\n        } else {\n            if ( createSheet ) {\n                // IE has a 31 sheet and 31 import per sheet limit\n                if (!cssCount++ ) {\n                    lastSheet = h.doc.createStyleSheet(options.src);\n                    lastSheetOptions = options;\n                } else {\n                    var relative = \"\" + URI(URI(lastSheetOptions.src).dir()).pathTo(options.src);\n                    lastSheet.addImport(relative);\n                    if ( cssCount == 30 ) {\n                        cssCount = 0;\n                    }\n                }\n                success();\n                return;\n            }\n\n            options = options || {};\n            var link = h.createElement(\"link\");\n            link.rel = options.rel || \"stylesheet\";\n            link.href = options.src;\n            link.type = \"text/css\";\n            h.head().appendChild(link);\n        }\n\n        success();\n    }\n};\n\n\nvar moduleManager = function(steal, stealModules, interactives, config){\n    /**\n     * @class steal.Module\n     * @hide\n     */\n    // ============ MODULE ================\n    // a map of modules by moduleID\n    var modules = {},\n        id = 0;\n    // this is for methods on a 'steal instance'.  A file can be in one of a few states:\n    // created - the steal instance is created, but we haven't started loading it yet\n    //           this happens when thens are used\n    // loading - (loading=true) By calling load, this will tell steal to load a file\n    // loaded - (isLoaded=true) The file has been run, but its dependency files have been completed\n    // complete - all of this files dependencies have loaded and completed.\n\n    // A Module is almost anything. It is different from a module\n    // as it doesn't represent some unit of functionality, rather\n    // it represents a unit that can have other units \"within\" it\n    // as dependencies.  A module can:\n    //\n    // - load - load the module to the client so it is available, but don't run it yet\n    // - run - run the code for the module\n    // - executed - the code has been run for the module, but all\n    //   dependencies for that module might not have finished\n    // - completed - all modules within the module have completed\n    //\n    // __options__\n    // `options` can be a string, function, or object.\n    //\n    // __properties__\n    //\n    // - options - has a number of properties\n    //    - src - a URI to this module that can be loaded from the current page\n    //    - rootSrc - a URI to this module relative to the current root URI.\n    //    - type - the type of module: \"fn\", \"js\", \"css\", etc\n    //    - needs - other modules that must be loaded prior to this module\n    //    - fn - a callback function to run when executed\n    // - unique - false if this module should be loaded each time\n    // - waits - this module should wait until all prior scripts have completed before running\n    // - loaded - a deferred indicating if this module has been loaded to the client\n    // - run - a deferred indicating if the the code for this module run\n    // - completed - a deferred indicating if all of this modules dependencies have\n    //   completed\n    // - dependencies - an array of dependencies\n    //\n    // exporter\n\n    var Module = function( options ) {\n        // an array for dependencies, this is the steal calls this module makes\n        this.dependencies = [];\n\n        // an array of implicit dependencies this steal needs\n        this.needsDependencies = [];\n\n        // id for debugging\n        this.id = (++id);\n        // the original options\n        this.orig = options;\n        // the parent steal's id\n        this.curId = steal.cur && steal.cur.options.id;\n\n        this.setOptions(options);\n        // create the deferreds used to manage state\n        /**\n         * @property steal.Module.states\n         * @parent steal.Module\n         * @hide\n         *\n         * There are 4 states a Module can be\n         * within:\n         *\n         *  - created - the Module instance is created, but no further action has been\n         *    taken on it.\n         *  - __loaded__ - the module's source has been loaded, but not run.\n         *  - __run__ - the module's source has been run, but it's dependencies\n         *    have not been loaded, and its value has not been determined.\n         *  - __completed__ - the module's dependencies have been loaded and value determined.\n         *\n         * Each module has the following deferreds to retain the state:\n         *\n         *  - module.loaded\n         *  - module.run\n         *  - module.completed\n         */\n        this.loaded = Deferred();\n        this.run = Deferred(); // TODO - this should be ran or executed\n        this.completed = Deferred();\n    };\n\n    Module.pending = [];\n    // `Module.make` is used to either create\n    // a new module, or return an existing\n    // module that matches the options.\n    Module.make = function( options ) {\n        // create the temporary reasource\n        var module = new Module(options),\n        // use `rootSrc` as the definitive ID\n            id = module.options.id;\n\n        // assuming this module should not be created again.\n        if ( module.unique && id ) {\n\n            // Check if we already have a module for this rootSrc\n            // Also check with a .js ending because we defer 'type'\n            // determination until later\n            if (!modules[id] && !modules[id + \".js\"] ) {\n                // If we haven't loaded, cache the module\n                modules[id] = module;\n            } else {\n\n                // Otherwise get the cached module\n                var existingModule = modules[id];\n                // If options were passed, copy new properties over.\n                // Don't copy src, etc because those have already\n                // been changed to be the right values;\n                if (!h.isString(options) ) {\n                    // extend everything other than id\n                    for(var prop in options){\n                        if(prop !== \"id\") {\n                            existingModule.options[prop] = options[prop];\n                        }\n                    }\n                }\n                return existingModule;\n            }\n        }\n\n        return module;\n    };\n\n    // updates the paths of things ...\n    // use stealModules b/c they are more fuzzy\n    // a module's id stays the same, but a path might change\n    //\n\n    h.extend(Module.prototype, {\n        /**\n         * @property steal.Module.options\n         * @parent steal.Module\n         * @hide\n         */\n        setOptions: function( options ) {\n            var prevOptions = this.options;\n            // if we have no options, we are the global Module that\n            // contains all other modules.\n            if (!options ) { //global init cur ...\n                this.options = {};\n                this.waits = false;\n            }\n            //handle callback functions\n            else if ( h.isFn(options) ) {\n                var uri = URI.cur,\n                    self = this,\n                    cur = steal.cur;\n                this.options = {\n                    fn: function() {\n\n                        // Set the URI if there are steals\n                        // within the callback.\n                        URI.cur = uri;\n\n                        // we should get the current \"module\"\n                        // check it's listed dependencies and see\n                        // if they have a value\n                        var args = [],\n                            found = false,\n                            dep, value;\n                        // iterate backwards through dependencies\n                        for ( var i = cur.dependencies.length; i >= 0; i-- ) {\n                            dep = cur.dependencies[i];\n\n                            if ( found ) {\n                                if ( dep === null  ) {\n                                    //  //alert(\"YES\")\n                                    break;\n                                }\n                                // We need to access the stored stealModules in this order\n                                // - calculated id\n                                // - original name\n                                // - dependency return value otherwise\n                                value = stealModules[dep.options.id] || stealModules[dep.orig] || dep.value;\n                                args.unshift(value);\n\n                                // what does this do?\n\n                            }\n\n                            if ( dep === self ) {\n                                found = true;\n                            }\n                        }\n\n\n\n                        var ret = options.apply(cur, args);\n\n                        // if this returns a value, we should register it as a module ...\n                        if ( ret ) {\n                            // register this module ....\n                            cur.value = ret;\n                        }\n                        return ret;\n                    },\n                    id: uri,\n                    type: \"fn\"\n                }\n                // this has nothing to do with 'loading' options\n                this.waits = true;\n                this.unique = false;\n            } else {\n                if(h.isString(options)) {\n                    options = {\n                        id: options\n                    }\n                }\n                // save the original options\n                this.options = steal.makeOptions(h.extend({}, options), this.curId);\n\n                this.waits = this.options.waits || false;\n                this.unique = (typeof this.options.unique === 'undefined') ? true : this.options.unique;\n            }\n            // if there are other options we haven't already set, reuse the old ones\n            for(opt in prevOptions){\n                if(!this.options[opt]){\n                    this.options[opt] = prevOptions[opt];\n                }\n            }\n            if(this.options.id){\n                this.options.abort = false;\n            }\n        },\n\n        // Calling complete indicates that all dependencies have\n        // been completed for this module\n        complete: function() {\n            this.completed.resolve();\n        },\n        // After the script has been loaded and run\n        // - checks what has been stolen (in pending)\n        // - wires up pendings steal's deferreds to eventually complete this\n        // - this is where all of steal's complexity is\n        executed: function( script ) {\n            var myqueue,\n                stel,\n                src = this.options.src,\n                rootSrc = this.options.rootSrc;\n            // Set this as the current file so any relative urls\n            // will load from it.\n            // rootSrc needs to be the translated path\n            // we need id vs rootSrc ...\n\n            if ( this.options.id ) {\n                URI.cur = URI(this.options.id);\n            }\n            if( this.exports ){\n                this.exports()\n            }\n            // set this as the current module\n            steal.cur = this;\n\n            // mark yourself as 'loaded'.\n            this.run.resolve();\n\n            // If we are IE, get the queue from interactives.\n            // It in interactives because you can't use onload to know\n            // which script is executing.\n            if ( h.support.interactive && src ) {\n                /*myqueue = interactives[src];*/\n                if(interactives[src]){\n                    myqueue = [];\n                    if(interactives.length){\n                        for(var i = 0; i < interactives.length; i++){\n                            if(interactives[i] !== this.orig){\n                                myqueue.push(interactives[i])\n                            }\n                        }\n                    } else {\n                        if(interactives[src] !== this.orig){\n                            myqueue = interactives[src];\n                            delete interactives[src];\n                        }\n                    }\n\n                }\n            }\n            // In other browsers, the queue of items to load is\n            // what is in pending\n            if (!myqueue ) {\n                myqueue = Module.pending.slice(0);\n                Module.pending = [];\n            }\n\n            // if we have nothing, mark us as complete\n            if (!myqueue.length ) {\n                this.complete();\n                return;\n            }\n            this.addDependencies(myqueue)\n            this.loadDependencies();\n\n        },\n        // add depenedencies to the module\n        addDependencies  : function(myqueue){\n            var self = this,\n                isProduction = steal.config().env == \"production\";\n            this.queue = [];\n            h.each(myqueue, function( i, item ) {\n                if( item === null){\n                    self.queue.push(null);\n                    return;\n                }\n\n                if ( (isProduction && item.ignore) || (!isProduction && !steal.isRhino && item.prodonly)) {\n                    return;\n                }\n\n                // make a steal object\n                var stel = Module.make(item);\n                if ( steal.packHash[stel.options.id] && stel.options.type !== 'fn' ) { // if we are production, and this is a package, mark as loading, but steal package?\n                    steal.has(\"\"+stel.options.id);\n                    stel = steal.make(steal.packHash[\"\"+stel.options.id]);\n                }\n                // has to happen before 'needs' for when reversed...\n                self.queue.push(stel);\n            });\n        },\n        // loads module's dependencies\n        loadDependencies : function(){\n\n            //print(\"-setting up \"+this.options.id)\n            // now we have to figure out how to wire up our pending steals\n            var self = this,\n            // the current\n\n\n            // iterate through the collection and add all the 'needs'\n            // before fetching...\n\n            //print(\"-instances \"+this.options.id)\n            // The set of modules before the previous \"wait\" module\n                priorSet = [],\n            // The current set of modules after and including the\n            // previous \"wait\" module\n                set = [],\n            // The first set of modules that we will execute\n            // right away. This should be the first set of dependencies\n            // that we can load in parallel. If something has\n            // a need, the need should be in this set\n                firstSet = [],\n            // Should we be adding modules to the\n            // firstSet\n                setFirstSet = true;\n\n            // Goes through each module and maintains\n            // a list of the set of modules\n            // that must be complete before the current\n            // module (`priorSet`).\n            h.each( this.queue, function( i, module ) {\n                // add it as a dependency, circular are not allowed\n                self.dependencies.push(module);\n\n                // if there's a wait and it's not the first thing\n                if ( (module === null || module.waits) && set.length ) {\n                    // add the current set to `priorSet`\n                    priorSet = priorSet.concat(set);\n                    // empty the current set\n                    set = [];\n                    // we have our firs set of items\n                    setFirstSet = false;\n                    if(module === null) {\n                        return;\n                    }\n\n                }\n                if ( module === null ) return;\n\n                // lets us know this module is currently wired to load\n                module.isSetupToExecute = true;\n                // when the priorSet is completed, execute this module\n                // and w.\n",
    "r0m4n": "Does anyone know if there's any workaround for removing these dev warnings when bundling with something other than steal? For example, browserify. @chasenlehara A similar bundle to that of the one in the jsfiddle so it must be the can-connect/can/model/ module. From what I read in the docs, the whole point of that module is to be backwards compatible so I included it in our bundle.\nWe were using the destroy as a custom function that performed a few api calls so we may just be better off moving away from the can-model \"destroy\" and just call it something else to avoid the serialize. We may have been using the model destroy in a non standard way.. ah you are right @chasenlehara, including can-model and not can-connect/all fixed the issue. Didn't realize they are being maintained separately (and work differently). I think the issue is that can-connect/can/model breaks backwards compatibility and the first sentence in the documentation says \"can-connect/can/model is for backwards compatibility with can.Model\"\nhttps://v3.canjs.com/doc/can-connect/can/model/model.html. Isn't it the same as this?\nhttps://v2.canjs.com/1.1/docs/can.Model.destroy.html\nImplement destroy with a function like:\nRecipe = can.Model.extend({\n  destroy : function(id){\n    return $.post(\"/recipe/destroy/\"+id,{});\n  }\n},{})\nOk that's ok. I think I will be able to get our project running with the module mentioned above without too much work. At some point it will have to be rewritten. Just thought I would mention it for anyone else that runs into a similar issue. Thanks for the help above. ",
    "Lighttree": "I think it makes sense to show how to work with Request Headers in CanJS (I assume this requires can-connect) and maybe other low level request manipulation.\nReal life case is \"Token based\" authentication. For example JWT authentication is very popular nowdays, and in order to implement it, you have to add Bearer token to request header, and build flow around it. Check its expiration, try to get new token if expired, re-try original request with new token attached.\nInternally we implemented this by behaviors, but since it looks like trivial scenario it makes sense to show how to do something like this. \n. I'll share more info on Monday since I don't have access to code right now.\nMain issues that we faced during implementation is that we weren't able to access 'request headers' and \"before send\" logic of original request. So additionaly to behavior that modify request we had to use custom ajax wrapper to met requirements.\nIt might be that today there is better way to do this. Anyway I'll return with more technical details on Monday :). Hi, sorry it took so long, to return with some details..\nBasically our solution includes 2 parts: custom behavior and \"customizable\" jQuery ajax.\nBehavior:\nIts role to append token to every request where this behavior used. If token is expired it should renew it by sending another request to endpoint that generates them. (tokens are short-living and saved in sessionStorage to use them for request during life-time)\nAfter this token generated it should append new token to request and re-try original request. If it succeed - ok. If generation of token fails - we redirect user to login.\n```javascript\nimport connect from 'can-connect';\nimport $ from 'jquery';\n// This is endpoint that generates new tokens...\nimport JWTAuthToken from './JWTAuthToken.model';\nconst methods = ['getListData', 'getData', 'createData', 'updateData', 'destroyData'];\nlet setHeaders = function (xhr) {\n    if (this) {\n        xhr.setRequestHeader('Authorization', Bearer ${this.token});\n    }\n};\nconst getToken = function (isRefreshNeeded) {\n    let isJwtTokenExpired;\n    let storedData = {};\nisJwtTokenExpired = ((new Date()).getTime() - /* token expiration date */) > 0;\n\nif (isRefreshNeeded || isJwtTokenExpired) {\n    sessionStorage.removeItem('token');\n}\n\nif (!sessionStorage.getItem('token')) {\n    return JWTAuthToken.get({}).then((data) => {\n        let time = (new Date()).getTime();\n        sessionStorage.setItem('token', data.token);\n        return data;\n    });\n}\n\nstoredData.token = sessionStorage.getItem('token');\n\nreturn $.Deferred().resolve(storedData);\n\n};\nconst JWTBehavior = connect.behavior('JWTBehavior', (baseConnection) => {\n    const behavior = {};\nfor (let i = 0; i < methods.length; i++) {\n    behavior[methods[i]] = function (params) {\n        let prom = $.Deferred();\n        getToken().then((data) => {\n            let self = this;\n            let ajaxConf = {\n                tryCount: 0,\n                retryLimit: 1\n            };\n            ajaxConf.beforeSend = setHeaders.bind(data);\n\n            ajaxConf.success = function (successData) {\n                prom.resolve(successData);\n            };\n\n            ajaxConf.error = function (xhr) {\n                this.tryCount++;\n                if (this.tryCount <= this.retryLimit && xhr.status === 401) {\n                    getToken(true).then((secondResponse) => {\n                        this.beforeSend = setHeaders.bind(secondResponse);\n                        self.ajax(this);\n                    }).catch(/* do something */);\n                } else {\n                    prom.reject(xhr);\n                }\n            };\n\n            // This is possible due to custom ajax provided.\n            this.ajax.setOptions(ajaxConf);\n\n            baseConnection[methods[i]].call(this, params);\n        }).catch(/* do something */);\n        return prom;\n    };\n}\n\nreturn behavior;\n\n});\nexport default JWTBehavior;\n```\nAfter you can use such behavior in models:\n```javascript\nimport DefineMap from 'can-define/map/map';\nimport DefineList from 'can-define/list/list';\nimport connect from 'can-connect';\nimport url from 'can-connect/data/url/url';\nimport constructor from 'can-connect/constructor/constructor';\nimport canMap from 'can-connect/can/map/map';\nimport ajaxConfigurable from 'canjs-auth/ajaxConfigurable';\nimport JWTAuthBehavior from 'canjs-auth/JWTAuth';\nconst Entity = DefineMap.extend({ seal: false }, {\n  // fields\n});\nEntity.List = DefineList.extend({\n    '#': Entity\n});\nEntity.connection = connect([\n    url,\n    JWTAuthBehavior,\n    constructor,\n    canMap\n], {\n    url: 'secured/endpoint/entity',\n    ajax: ajaxConfigurable(),\n    Map: Entity,\n    List: Entity.List\n});\nexport default Entity;\n```\nThis is done for Can@3 and maybe for Can@5 it can be done way more better.. @justinbmeyer \nSure, just run this project in development mode and open in IE11:\nhttps://github.com/Lighttree/ie11-canjs-demo\nThis is DoneJS example, it's just easiest way to reproduce to me.\nBut I reproduced on our custom project where we use CanJS only.\nAn example that you created recently doesn't work in IE11 as well:\nhttp://jsbin.com/misigo/edit?html,js,output\n(There is different issue, I assume because can.all bundled in a different way)\nI think the source of this issue is the same for DoneJS and just CanJS. Hi @frank-dspeed\nI don't think that this topic related to #4533 or #4527 (its good and I personally interested in this).\nI don't expect that this guide will use any particular technology or way to handle things, because there are too many technologies that you can use.\nI think main idea here is to show how you can with CanJS, using any tool, it might be Steal as well, key point is avoid features like Done-SSR or any other that don't work with CanJS out of the box.\n. Isn't \"Programmatically Instantiated Component\" helpful in this case ? I didn't use CanJS@5 but I was hoping that this feature will allow \"create\" component in NodeJS and test this. Its actually cool feature, because it will be great if we will be able to do what Enzyme provides for React: https://github.com/airbnb/enzyme/blob/master/docs/api/shallow.md\nBasically to allow simulate component interaction in Node and write all tests in Jest for example.. > issu: #4524 is related because this enables exactly what @Lighttree requested decouple DoneJS CanJS aka decouple Steal CanJS boundary\nWell I'm not sure that my topic is about Rollup or any other particular tool. I'll leave extended comment in the issue you mentioned.\nRegarding this topic.\nThere are some others: Parcel, WebPack, Brunch, FuseBox and more.\nAdditionally it's not clear what particular technologies developer would like to use (some of them requires additional configuration).\nIn this case isn't this overkill to publish packages for particular bundler ?\nI think its up to developer combine tools that he want / need to use. What makes sense for CanJS is... to be \"technology agnostic\" and allow people build it by any tool.\nFor example there was bug that affects CanJS if you use something different than Steal:\nhttps://github.com/canjs/canjs/issues/4011\nBefore this issue fixed CanJS had some logic that executes unless you build your CanJS app with Steal.\nFor example I use WebPack, because its easier for me to met requirements and setup everything. And for this issue we had to write custom loader that strips out these comments, but after the fix I mentioned above even this can be thrown away.. ",
    "eben-roux": "I had a really hard time trying to use can-connect that last time I had a look at it.  I ended up rolling a rather simple interaction mechanism.  This along with my shuttle-access for identity & access control gets me to where I need to be.\nAny mechanism I use should be flexible enough to allow one to add any behaviour (if required) for various \"events\" within the interaction pipeline.  If I need to add request headers then it should be a rather simple affair.  In most cases dropping down to the relevant level does actually help but it would be nice to keep it in the can-connect component for the 80% cases.\nFor security I simply add a header like so:\n```\n$.ajaxPrefilter(function (options, originalOptions) {\n    options.beforeSend = function (xhr) {\n        if (access.token) {\n            xhr.setRequestHeader('access-sessiontoken', access.token);\n        }\n    if (originalOptions.beforeSend) {\n        originalOptions.beforeSend(xhr);\n    }\n};\n\n});\n```\nI don't think session management should be baked in.  It should, however, be possible to add some implementation that works through a common interface.  These things can be tricky so if it isn't going to help much then it could also be excluded.\nFor me the main focus should be the data interaction.  How do I go about retrieving the data into the relevant DefineMap or DefineList structures?  I also do not want to set up a massive can-connect configuration for each endpoint.  There should be something that covers most cases and options that could override some behaviour; in some cases a totally different can-connect may be required but that should not happen all-too-often.\nI would still suggest that each of the interaction pipelines have a predefined set of steps (events) it passes through and that one could attach an observer to any of those events to enrich the state.  This roughly follows a pipes-and-filters mechanism.\nOnly base-bones functionality that is truly common should be baked-in and any other mechanisms or behaviours should be added explicitly.. I haven't quite read all the documentation so perhaps I'm stating some obvious bits here but let me do it anyway :)\nThe type of routing I use in my solutions is convention-based.  There is also a permission system built in but that type of thing can be done using a callback on some configuration.\nThe gist of it is that there is a list of resources that represent the various routes and the content/properties of that resource determine what the actual route will be created as.. Depending on how deep such a hierarchy goes the documentation may become quite long.  Perhaps having the display of the \"extended\" documentation  as an option would be useful.. ",
    "jeroencornelissen": "Looks very promising. \ud83d\udc4d\nWould be very useful if you could access the component.element directly inside the component.viewModel. Now we often have to set it in the connectedCallback.. @justinbmeyer https://github.com/canjs/canjs/issues/4081. It's just an idea, but it would be nice if it's available in the viewmodels automatically.\nThe idea came from issue https://github.com/canjs/canjs/issues/4030 , where it looks like component.element is being implemented.\nWe often set an element property on the viewModel. To set a configurable width/height or a class depending on the viewmodels state, ....\n. ",
    "ryangwilson": "Made changes to previously created SVGs\nPNGs\n\n\n\n\n\n\nSVGs\nArchive.zip. Two versions below are the same, but intended to show motion in the right hero section\n\n\n\nThe two versions below show motion in the CRUB image display\n\n\n\n\n. \n. \n\n\n. To Do List styling updated here: https://codepen.io/ryangwilson/pen/yZrogP\n\n. Added To Do list strikethrough, add, and remove animation examples here: https://codepen.io/ryangwilson/pen/qgGmVd\n\n. Step 2 - Option 1\n\nStep 2 - Option 2 (Stars, By Bitovi)\n\nStep 2 - Interior Page\n\n. Step 1 - Option 1\n\nStep 1 - Option 2 (Search layout different)\n\n. \n. ",
    "xu-oliver": "thanks~. ",
    "thomaswilburn": "Summary of work I've done so far on these issues:\nI've been working on the \"ie11-compatibility\" branch of canjs, as well as branching for individual modules when they need to be fixed. There's a separate test page (ie-test.html) that loads the polyfills for Promise, Object.assign, and WeakSet. It skips four test suites, for various reasons:\n\n\"can-component/test/component-viewmodel-observe-test\" - requires Proxy\n\"can-query-logic/src/types/make-maybe-test\" - uses the class keyword\n\"can-view-autorender/test/test\"\n\"can-route-pushstate/test/test\"\n\nThe last two suites run in iframes, and I haven't figured out the best strategy for polyfilling them yet.\nThe modules that have been branched but not merged are:\n\nhttps://github.com/canjs/can-define/tree/ie11-configurable\nhttps://github.com/canjs/can-observe/tree/ie11-compat\nhttps://github.com/canjs/can-query-logic/tree/ie11-compat\nhttps://github.com/canjs/can-reflect/tree/ie11-compat\nhttps://github.com/canjs/can-view-parser/tree/ie-compat\n\nMost of these are pretty minimal changes, but I wanted someone who knows the code better than me to take a look. I've run the tests in Firefox after making these changes, and everything passed, which is reassuring.\nOnce I had everything running, there were 241 failed assertions out of 5067 in IE11. I've managed to pare that down to 196, and it's worth talking about the changes that I made, so that we can avoid those when writing new code as long as IE support is relevant:\n\nAs noted above, do not chain .set() and .get() on Map or Set objects, and don't call their constructors with an iterable (they have to be populated in a separate step).\nIE doesn't support Array.from(), so use canReflect.toArray() instead.\nIE also doesn't implement the Node interface on Document objects, so you can't call contains() or other methods there. Use the element.ownerDocument.documentElement property if you need to test for element attachment.\nIE is way pickier about properties created with Object.defineProperty() than other browsers are. If you forget to set configurable: true in modern browsers, but you set the same value when you redefine the property, they'll just silently ignore the call. IE, however, throws an error regardless of the value identity. Basically, if you use Object.defineProperty(), make sure you always set it as configurable.\nThe method shorthand is not supported in object literals, and you can't use template strings. These seem like real quality of life issues that I thought Steal would transpile, but that doesn't seem to be the case.\nFunctions do not automatically get name properties in IE. When writing tests, don't assume the function name will be a constant--use a regex to check the warning or message you expect.\nDocumentFragments in IE don't have firstElementChild, only firstChild. Depending on how you've set the contents of the fragment, you may need to polyfill this, since there may be text nodes or other garbage in the first child slot.\n\nThere's also a hilariously terrible bug that I think I've discovered, where IE will not correctly respect enumerable: false for a property if, at any point in the prototype chain, that property is shadowed by an enumerable version. This seems like a bug waiting to happen, but it's subtle, and chasing down any cases where a property is set via higher inheritance is extremely time-consuming.\nA lot of the remaining issues look like they probably have shared causes based on the stack traces I'm seeing back in the tests, but I'm not experienced enough with some of the underlying Can modules to tell what is triggering them yet.. Will do!. One thing not mentioned above, in the restModel section we assign the TodoList constructor as the Todo.List property, then we only operate on the list through Todo.getList(). Elsewhere, I've seen us define the list separately as its own variable, and pass it into the restModel config object directly as List to be augmented and used. I think that may be clearer for many new users, instead of expecting them to understand that \"List\" is a special property on DefineMaps when used with the restModel mixin.. One specific and one general thought:\n\nFor the :from binding example, it uses a computed value, which is not something readers may have encountered at this stage in the docs (resolve() isn't mentioned in the tech overview, which precedes this). As such, the use of it in value property definition is a little confusing. It may make sense to change this example to have a setTimeout started from a button on the component, and mutate the state of count directly (i.e., this.count++) from there.\nThe page uses Components consistently throughout the code examples, and even explains it fairly early on. It's a little weird to get down to the bottom and see Component reintroduced, and largely re-explained. The info inside this section on initializing component properties, communicating between them, and composing them, is good. Maybe the introductory part of the section either needs to be moved, rewritten, or removed instead.. Re: symbol naming convention, if I look here, there's a number of mix-in props that use symbols as their name, and are referenced with an @ at the start. I'd never seen that convention before, so I didn't know if it was referring to an instance variable from the superclass like Ruby, or something else. It took some clicking through to figure out that it seems to be the way symbols are referenced.. I didn't notice the hover. I worry that hiding things behind the title attribute is an accessibility concern, and also makes it hard if anyone is looking these up on a mobile device (which does, admittedly, happen). I wasn't aware of the @@ convention either. On MDN, there's at least a reference to the Symbol type (or to Symbol.iterator) nearby in the plaintext.. As I'm understanding it from this bug, this doesn't really look like Vue's single file components, and I don't think it carries the same benefits. As used in Vue, they're convenient because they provide an easy way to package up a component with its styles and view template, and they also eliminate a bunch of the boilerplate. I personally like that they tend to work well with editors for syntax highlighting without adding special plugins the way that JSX or CSS-in-JS approaches normally do.\n\nThe equivalent, I think, for CanJS, might look something more like this:\nSingleFileComponent.canjs\n```html\n\n  Hello {{name}}\n\n\nexport default {\n  ViewModel: {\n    name: {\n      get() { return \"World\" }\n    }\n  }\n}\n\n\nsingle-file-component {\n  background: papayawhip;</p>\n<p>&amp;::before, &amp;::after {\n    content: \" *** \";\n  }\n}\n\n```\nWould compile down to something like:\n```js\nimport { Component, stache } from 'canjs';\n// load CSS somehow, compiling LESS in the process\nvar SingleFileComponent = Component.extend({\n  tag: 'single-file-component',\n  view: stache(Hello {{name}}),\n  ViewModel: {\n    name: { get() { return \"World\" } }\n  }\n}\nexport default SingleFileComponent;\n```\nEssentially, this isn't too different from the existing idea of modlets, it just means we're working in one file per Component instead of three. It also gives us an easy way to build presentation-only components, like a flexbox container:\n```html\n\n\n\n\n\n\n.flexbox {\n  display: flex;</p>\n<p>&amp; &gt; * {\n    flex: 1;\n  }</p>\n<p>&amp;[data-direction=\"column\"] {\n    flex-direction: column;\n  }\n}\n\n```\nAssuming that it generates unsealed (or Proxy-based ViewModels), I could now write a three-panel nested flex layout with:\nhtml\n<flex-box>\n  <flex-box direction=\"column\">\n    <div style=\"background: papayawhip\"></div>\n    <div style=\"background: salmon\"></div>\n  </flex-box>\n  <div style=\"wheat\"></div>\n</flex-box>\nIs this better than just writing well-constructed markup with reasonable CSS classes? I would argue... probably not? But it seems to be common in React and Vue to have logic-less components like this just for layout or presentation, which then wrap components with more complicated functionality.. I couldn't find a component file that looks like the example from your follow-up (which is probably why my initial reply was mostly just re-hashing stuff you already knew). Is that documented in the guides anywhere?\nI don't have a solid reason for this, but for some reason I'm less comfortable with transpilation that involves changing something written as a single JS file with template literals, as compared to the more explicit split that .vue files have. Part of it may be that I think it might be easier to abuse your all-JS component--say, by tagging the template literal or performing string interpolation on it--and end up with something that I didn't expect but which is \"technically\" still valid JS. Although .vue files are all in one, they enforce separation of concerns by making sure that your templates and styles are expressed as static inputs in separate languages.\nI'm sure you could guard components against this, or de-optimize and warn during compilation, but sometimes the simpler approach might easier for people to understand, and for build tools to process. I guess it depends on who you're targeting.. ",
    "zhanghengxin": "which version support the IE8 or lower. @tdreyno @leemhenson @arijo @schovi @obaid ,i'm so sorry , but i not find it . ",
    "janat08": "You might be interested in integrating atop https://github.com/codemeasandwich/hyper-element , that tries to hook reactive engines like mobx. It was pretty raw last I used it half a year ago with lacking context or something (preventing reusable templates, each>template), but it was fixed since, but it's still possible there're pieces missing.. there's some doc place where hyperhtml compares against lit-html and summarily lit-html is pretty trashy last I looked.. I like hyperhtml, but the sad part is that it doesn't readily accept third party libraries that manipulate DOM, unlike other view engines that are much more precise. . Would be cool if you could fall back to mustache for when there're other libraries doing DOM and then back, if mustache handles that. Otherwise, you're supposed to cordon off the area where 3rd library operates with hyperhtml and get imperative about things there.. ",
    "macku": "Hey @chasenlehara! I'm happy to help you. I've created the webpack loader some time ago for one of the projects I was involved in the past. If you feel you would like to contribute to the project or even take an ownership of it I could grant you all needed accesses.. @matthewp @chasenlehara I've granted you a permission to the NPM package. Let me check what I can do with github repo.. ",
    "Mamuuut": "I had the same issue while upgrading CanJS from v3.x to v5.x.\nWe definitely need to support IE 11 for quite a lot of our customers unfortunately.\nIs there any short term plan to make it happen?\nIs there any way to help?\n. Here are the problems I found:\n\n\nin can-dom-mutate/can-dom-mutate (line 31):\nvar data = dataStore.get(node) || dataStore.set(node, {}).get(node);\nin IE 11 WeakMap.prototype.set is not chainable and returns undefined.\n\n\nin can-reflect/types/map (line 24):\nshape.assignSymbols(Map.prototype, {\n    \"can.getOwnEnumerableKeys\": Map.prototype.keys,\n    \"can.setKeyValue\": Map.prototype.set,\n    \"can.getKeyValue\": Map.prototype.get,\n    \"can.deleteKeyValue\": Map.prototype[\"delete\"],\n    \"can.hasOwnKey\": Map.prototype.has\n  });\nthis works for \"can.getOwnEnumerableKeys\" and then for \"can.setKeyValue\" but once \"can.setKeyValue\" symbol is assigned to Map.prototype.set, the error occurs.\n\n\nIn can-reflect/reflections/get-set/get-set (line 47 - getSetReflections.setKeyValue):\nif(setKeyValue !== undefined) {\n    return setKeyValue.call(obj, key, value);\n} else {\n    obj[key] = value;\n}\nsetKeyValue is not undefined anymore and tries to call Map.prototype.set on Map.prototype which is not of type Map. This results in the Map polyfill to throw the error \"Method Map.prototype.set called on incompatible receiver\" (I tried 3 different ones, all throwing a similar error).\nNot sure what the would be the best way to fix this issue.\nHere is a glitch with an edited version of //unpkg.com/can@5/dist/global/core.js including my hack and a quick WeakMap.prototype.set polyfill to make it chainable.\nhttps://flax-odometer.glitch.me/\n. ",
    "CODE-REaD": "Just a note on https://github.com/canjs/canjs/blob/master/docs/can-guides/topics/debugging.md: I found by trial-and-error that <script src=\"https://unpkg.com/can/dist/global/core.js\"></script> does not include CanJS devtools while <script src=\"https://unpkg.com/can/dist/global/can.all.js\"></script> does.  That isn't covered in debugging.md.. ",
    "knrt10": "fixed this issue at #4365 . I would like to fix this.. ",
    "CleverOscar": "I fixed the link to this, so do I just make a PR to show the fixed code? . ",
    "mikedane": "Awesome! Yeah, just make a PR for the fix. Yeah good point! Im definitely not 100% sure, although I was using this yesterday and was able to successfully run npm install ../can-compute && npm run document which is technically installing a new package. Either way I think we should put some sort of note here which better explains the correct usage. @justinbmeyer . Yeah, it's mine. Yup! It's still needed, It'd be awesome if you could take a look!. Here's some of the demos that suffer from this problem:\n\n[ ] demos/technology-overview/route-counter.html\n[ ] demos/technology-overview/route-counter-registered.html\n[ ] demos/technology-overview/route-mini-app.html\n[ ] demos/technology-overview/route-mini-app-start.html\n[ ] demos/technology-overview/task-editor.html. \n",
    "NandoTheessen": "Is this still needed? \nIf yes, I'd be happy to contribute! . Awesome, just opened PR #4456 !. ",
    "michaelzcheng": "Fixed demos for codepen. Broken demos in codepen on can-component and it's viewModel sub-section should be fixed by the new canjs release. Will QA upon release.. ",
    "Mattchewone": "One of the things I raised in the training was about highlighting in .component files and .stache files which I have since found a way thanks to @mikemitchel's help. \nHaving seen a .component file I can see how similar it is to a .vue file although maybe it's just personal preference or just because I knew Vue before Canjs but I do still like the separation of the template / js / css in specific blocks within the file rather than all within the can-component tag. Although I'm sure I could get used to it. \nI have seen on projects that there are mixes between the split modlet components and sporadic .component files I think having so many ways to create the same thing maybe more the issue. The guides show using the following format:\n```js\nimport {Component, stache} from \"can\";\nComponent.extend({\n  view: <h1> some stache </h1>\n  css: h1: {color: \"red\"},\n  ViewModel: { ... }\n})\n```\nBut as far as I can tell .component files or everything like this are not recommended.. ",
    "manaswinidas": "I'm interested to solve this issue.. I'm interested to solve this issue. I'd like to help with the documentation. @justinbmeyer Thanks! That's awesome . ",
    "davidkpiano": "Re: creating a DSL, might be helpful to look at some prior art for this, especially the P language: https://github.com/p-org/P/wiki/Introduction-to-P-language \n```\n// PingPong.p\nevent PING assert 1: machine;\nevent PONG assert 1;\nevent SUCCESS;\nmain machine Client {\n    var server: machine;\nstart state Init {\n    entry {\n        server = new Server();\n        raise SUCCESS;         \n    }\n    on SUCCESS goto SendPing;\n}\n\nstate SendPing {\n    entry {\n          send server, PING, this;\n          raise SUCCESS;\n}\n    on SUCCESS goto WaitPong;\n}\n\nstate WaitPong {\n    on PONG goto SendPing;\n}\n\n}\nmachine Server {\n    start state WaitPing {\n        on PING goto SendPong;\n    }\nstate SendPong {\n      entry (payload: machine) {\n          send payload, PONG;\n          raise SUCCESS;              \n      }\n    on SUCCESS goto WaitPing;\n}\n\n}\n```. "
}